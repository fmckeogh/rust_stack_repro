#![no_std]
#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_doc_comments)]
#![allow(non_upper_case_globals)]
//! BOREALIS GENERATED FILE
extern crate alloc;
use PMEVCNTR_SysRegWrite32_dabf302752d231bf::*;
use DBGBXVR_SysRegWrite32_ec48b20803401d6a::*;
use DBGBCR_SysRegWrite32_df57cf6a3ef389f5::*;
use ICH_AP0R_SysRegWrite32_e8e0b6211baf6183::*;
use PMEVTYPER_SysRegWrite32_59d93d7cd130a144::*;
use ICH_HCR_SysRegWrite32_391df800f72b5649::*;
use ICH_AP1R_SysRegWrite32_9d0709acdf26e0db::*;
use TLBIALLHIS_SysRegWrite32_3f104fb53eee9e89::*;
use PMSELR_SysRegWrite32_3f6f0842c8047d3f::*;
use ERXMISC4_SysRegWrite32_429dc75aabc49f53::*;
use DBGBCR_SysRegWrite32_56e01e085292f5f1::*;
use AMEVTYPER1_SysRegWrite32_10f3aef13e8663a1::*;
use PMEVTYPER_SysRegWrite32_30cfe1e62bad0f9c::*;
use DBGBXVR_SysRegWrite32_9d5393fe9638bbc0::*;
use DBGBXVR_SysRegWrite32_0917f327cafd0459::*;
use ICIALLUIS_SysRegWrite32_33170c116ea45e36::*;
use PMEVTYPER_SysRegWrite32_3e4eb9eb36921364::*;
use DBGWCR_SysRegWrite32_ff5d8b7776f3598d::*;
use VPIDR_SysRegWrite32_deaaa2df067d2d32::*;
use CSSELR_SysRegWrite32_707b283268d02f0f::*;
use DBGWVR_SysRegWrite32_73839b539e79472c::*;
use PMEVTYPER_SysRegWrite32_6b959d889d3d66da::*;
use PMEVTYPER_SysRegWrite32_863b5087474e4a64::*;
use ITLBIALL_SysRegWrite32_58b4810189599a79::*;
use ICH_LRC_SysRegWrite32_dfd8b885b691ae03::*;
use AMCNTENSET1_SysRegWrite32_c9fde2d74a2eae8e::*;
use ICH_VMCR_SysRegWrite32_2eb356e2f10a122b::*;
use TLBIALLIS_SysRegWrite32_26b5c3b29f92f5ea::*;
use ICV_AP1R_SysRegWrite32_726e2b6e8a63f123::*;
use PMEVTYPER_SysRegWrite32_944684756672e51b::*;
use NSACR_SysRegWrite32_78181d9f16e34b35::*;
use PMEVCNTR_SysRegWrite32_9aa0227f42759948::*;
use TLBIIPAS2LIS_SysRegWrite32_4ae44938f6bf59ab::*;
use PMEVCNTR_SysRegWrite32_379354bb12604d68::*;
use PMCR_SysRegWrite32_ed58155cb22a3fd6::*;
use DSPSR_SysRegWrite32_eb89215986db3057::*;
use PMCCFILTR_SysRegWrite32_380c0e93b25f3214::*;
use DBGWCR_SysRegWrite32_370ee8f5d3ab6901::*;
use HTCR_SysRegWrite32_0a66990c7e5298a5::*;
use DBGBXVR_SysRegWrite32_ad72222be7819b11::*;
use DBGBXVR_SysRegWrite32_c8eb4615918df164::*;
use DBGBCR_SysRegWrite32_c77332e4c2ad23f2::*;
use PMEVTYPER_SysRegWrite32_3330ec8a9fad7b9b::*;
use PMEVCNTR_SysRegWrite32_65d523b551bc8ca5::*;
use ADFSR_SysRegWrite32_750ccc4b21c14510::*;
use PMEVTYPER_SysRegWrite32_3fdce9a0d75c4d7a::*;
use DBGWVR_SysRegWrite32_78026fd71312533d::*;
use DBGBCR_SysRegWrite32_951097733e549f18::*;
use ERXSTATUS_SysRegWrite32_5cd309fb6a56ceb4::*;
use SDER_SysRegWrite32_78d36c9dd1d8d07c::*;
use DBGWVR_SysRegWrite32_1db5da1de86cc148::*;
use ATS12NSOPR_SysRegWrite32_29b73e1bf71ad72e::*;
use DBGWCR_SysRegWrite32_4f1045e329d8e2cf::*;
use ICH_LR_SysRegWrite32_eaa9053ceb4916d6::*;
use ICH_AP0R_SysRegWrite32_0687237dd975d38e::*;
use HAMAIR1_SysRegWrite32_65d7b8ceff16c815::*;
use AMEVTYPER1_SysRegWrite32_c08be1aaf0c6ac78::*;
use DCCMVAC_SysRegWrite32_acc09968a78b7280::*;
use CNTHP_TVAL_SysRegWrite32_8e96a3fad1864250::*;
use DFAR_SysRegWrite32_27a6ae6fd1c0c709::*;
use ICH_AP0R_SysRegWrite32_776121746bc0b6a3::*;
use ERXADDR_SysRegWrite32_5df6ccfc72dd739d::*;
use CONTEXTIDR_SysRegWrite32_3295051c92606610::*;
use AMEVTYPER1_SysRegWrite32_3f6816ffcd57dccb::*;
use ICH_LRC_SysRegWrite32_fa0ed50b180dc30b::*;
use PMSWINC_SysRegWrite32_9b4c9b84c8e7597b::*;
use CNTFRQ_SysRegWrite32_bb1fcec10c61c758::*;
use DBGDTRTXext_SysRegWrite32_ed4d54f3969e2f78::*;
use ICIMVAU_SysRegWrite32_98e4788d39c19ba0::*;
use ATS1CPRP_SysRegWrite32_42119243d95c582f::*;
use DBGVCR_SysRegWrite32_fc44294faccd3e66::*;
use AArch32_UnallocatedSysRegAccess::*;
use DBGWVR_SysRegWrite32_02f0bae942bffd2c::*;
use ATS1CPWP_SysRegWrite32_9f529f7ec0bf0000::*;
use HACR_SysRegWrite32_5e68b66302bfb64c::*;
use DBGCLAIMSET_SysRegWrite32_edbb66d3027b713a::*;
use DBGWCR_SysRegWrite32_16fb8a88dc2a6a09::*;
use PMEVCNTR_SysRegWrite32_3f499998ad4dfc7e::*;
use DBGDSCRext_SysRegWrite32_4b0433917fc9c43d::*;
use ICC_BPR0_SysRegWrite32_953ba2861abee74a::*;
use PMEVTYPER_SysRegWrite32_a8d64216580bbaf2::*;
use DBGWCR_SysRegWrite32_c5827483af2959fc::*;
use HDCR_SysRegWrite32_b3fcbdce17e7337b::*;
use ICH_LR_SysRegWrite32_c3bfb21b3a349563::*;
use PMEVCNTR_SysRegWrite32_e55f104293c82cc7::*;
use DTLBIMVA_SysRegWrite32_4d3bdab2ea1d893d::*;
use HADFSR_SysRegWrite32_700a8776afbb1761::*;
use BPIALLIS_SysRegWrite32_17f454fbcdf975ae::*;
use ICH_LRC_SysRegWrite32_bc7eed7f83c8b68e::*;
use ICV_AP0R_SysRegWrite32_c1e479184edb7511::*;
use CNTKCTL_SysRegWrite32_e68a84be701ace4f::*;
use SDCR_SysRegWrite32_4a9ed44cdafd01dd::*;
use TTBCR2_SysRegWrite32_06c6fc8db37664f3::*;
use DBGWVR_SysRegWrite32_594886fdc2160e88::*;
use PAR_SysRegWrite32_b3494b8d6e542bfa::*;
use DBGWCR_SysRegWrite32_31697201fd39cd98::*;
use ATS1HW_SysRegWrite32_6bb51bbf34dda57b::*;
use ICV_AP1R_SysRegWrite32_4f1e8bd1c2644b3a::*;
use ICV_AP1R_SysRegWrite32_f4f5f3a432a35847::*;
use TLBIALLNSNHIS_SysRegWrite32_934a7e1a0cc96b4a::*;
use DBGBXVR_SysRegWrite32_b1bf8c267662673c::*;
use DBGDTRRXext_SysRegWrite32_b2264bfa940c912c::*;
use TTBCR_SysRegWrite32_4607ff14cabf6694::*;
use ICH_LRC_SysRegWrite32_9511e78c9b2df1ea::*;
use ERXADDR2_SysRegWrite32_9f92470c72b2a640::*;
use DBGBVR_SysRegWrite32_7386f767486da9e4::*;
use VBAR_SysRegWrite32_bc2b5cd33d4ee53c::*;
use AMEVTYPER1_SysRegWrite32_381d8337f3d30ba8::*;
use DBGWVR_SysRegWrite32_4a1275b1dbe9af28::*;
use ICV_AP0R_SysRegWrite32_7420f74019631696::*;
use DBGBVR_SysRegWrite32_08e35fe5ecd207ba::*;
use ERRSELR_SysRegWrite32_e1b5ff755f2cd46d::*;
use BPIMVA_SysRegWrite32_913ce21249c53f0d::*;
use DBGBCR_SysRegWrite32_77964c377a44e2ca::*;
use CNTHP_CTL_SysRegWrite32_ed680b861de2ac5b::*;
use AMCR_SysRegWrite32_0a36aa89c00db4ab::*;
use ICV_AP0R_SysRegWrite32_b2c1de53009da653::*;
use PMEVCNTR_SysRegWrite32_7b729c1912b85359::*;
use PMEVCNTR_SysRegWrite32_85d8fbb3220badc7::*;
use DBGBXVR_SysRegWrite32_3d0f51e1f9bc14d7::*;
use DSPSR2_SysRegWrite32_d1d98bc563bc83d5::*;
use DBGBCR_SysRegWrite32_9fe4284f184fd88f::*;
use HCPTR_SysRegWrite32_793a7f8578c5645f::*;
use HRMR_SysRegWrite32_da3e01dd793ebd87::*;
use ICH_LR_SysRegWrite32_64e5be949dba10fe::*;
use ICH_LR_SysRegWrite32_a7e50c74ffa894c4::*;
use JOSCR_SysRegWrite32_88e20b8662c98b9c::*;
use DBGDTRTXint_SysRegWrite32_bf0ab983b07d829c::*;
use SCR_SysRegWrite32_4891195fead51a46::*;
use ICH_LRC_SysRegWrite32_b623b068212a51e1::*;
use PMEVCNTR_SysRegWrite32_cdcaf594688625d5::*;
use DBGWCR_SysRegWrite32_ef9a1ddd79a2bf16::*;
use HCR_SysRegWrite32_968f9ec8dcacddcc::*;
use SCTLR_SysRegWrite32_88c9496795c226a4::*;
use DBGWCR_SysRegWrite32_7a1c0070fb5cde60::*;
use ITLBIASID_SysRegWrite32_4c595ca2314b7198::*;
use ICH_AP1R_SysRegWrite32_28a69956588386f7::*;
use HSTR_SysRegWrite32_f0139fe1b83ebb72::*;
use PMEVTYPER_SysRegWrite32_5e6a7eed513b84e1::*;
use PMEVCNTR_SysRegWrite32_aaa5edab79dc57c7::*;
use TLBIALLNSNH_SysRegWrite32_31faa2646b198591::*;
use HACTLR2_SysRegWrite32_a03973fca410ae10::*;
use ICH_LRC_SysRegWrite32_9859737df8ae4807::*;
use ICH_LR_SysRegWrite32_721fa51d485f4b0a::*;
use PRRR_SysRegWrite32_d60dcdae1cc2429d::*;
use ICC_BPR1_SysRegWrite32_fa0a3cea06e15e3e::*;
use DBGBCR_SysRegWrite32_4811ff3f924f49d2::*;
use PMEVTYPER_SysRegWrite32_1acb3b092d3b80ff::*;
use DBGBCR_SysRegWrite32_c3126c422a78b6f5::*;
use PMEVTYPER_SysRegWrite32_225a412cd5799c58::*;
use PMEVCNTR_SysRegWrite32_77f99f1f07c86e99::*;
use DACR_SysRegWrite32_bfabed8f69d486b5::*;
use TPIDRURO_SysRegWrite32_2b144f3027758b96::*;
use AMCNTENSET0_SysRegWrite32_e19916620d98350a::*;
use CP15DMB_SysRegWrite32_d17f32fecbb5fdad::*;
use AMUSERENR_SysRegWrite32_2ac4dae68b0ff25f::*;
use TLBIMVAH_SysRegWrite32_4fb355f41064966b::*;
use HSCTLR_SysRegWrite32_1fcc439d9224580e::*;
use PMCNTENCLR_SysRegWrite32_b4dfc0dbab472345::*;
use PMEVTYPER_SysRegWrite32_51fb35106f5676b7::*;
use ICH_LR_SysRegWrite32_f689ea0e1ff8a941::*;
use DTLBIALL_SysRegWrite32_e0269c0064c12331::*;
use AMEVTYPER1_SysRegWrite32_3549526a1f7ad5a9::*;
use ICH_LRC_SysRegWrite32_5dd9fb114b3c7d62::*;
use ATS1CUW_SysRegWrite32_eb4fd0807cfcfcfb::*;
use PMEVCNTR_SysRegWrite32_e848e1982619415c::*;
use PMEVCNTR_SysRegWrite32_a333b5034a3b86cb::*;
use ICV_AP0R_SysRegWrite32_f5921a0effda4992::*;
use DBGWVR_SysRegWrite32_b57dca3091b04393::*;
use ERXMISC3_SysRegWrite32_427198a3f5bc0b89::*;
use VDFSR_SysRegWrite32_a0962e93b6e4f29f::*;
use ICC_MCTLR_SysRegWrite32_c2e3c881e988dc90::*;
use ICC_MGRPEN1_SysRegWrite32_a295be12c6cd3191::*;
use PMEVCNTR_SysRegWrite32_b7abf79765976a11::*;
use ICV_AP1R_SysRegWrite32_fcd6d6e80a079de9::*;
use DBGBXVR_SysRegWrite32_4720fe7969390f72::*;
use DBGBVR_SysRegWrite32_2e65ad9d6a265c11::*;
use HTRFCR_SysRegWrite32_6d3975a6f673d36e::*;
use PMCCNTR_SysRegWrite32_2765928b3dd6404e::*;
use TLBIIPAS2IS_SysRegWrite32_e4867c386886a0ac::*;
use ERXCTLR_SysRegWrite32_9a6bdb0b20151705::*;
use PMEVTYPER_SysRegWrite32_73416eaea2ea531d::*;
use DBGBXVR_SysRegWrite32_3d25e640561e27b0::*;
use DBGBVR_SysRegWrite32_f6af3de5c6306a23::*;
use TLBIALL_SysRegWrite32_b21af7f2b4a8cf08::*;
use ICC_DIR_SysRegWrite32_5d925e0a6cd7195a::*;
use HTPIDR_SysRegWrite32_5bae00c8ab3297a3::*;
use PMEVTYPER_SysRegWrite32_d731b0e32007816c::*;
use ICH_LR_SysRegWrite32_2e1b19b394d8f1f7::*;
use DBGBCR_SysRegWrite32_e9d51eb4b51754d0::*;
use ICH_AP1R_SysRegWrite32_100dab3ceee19d37::*;
use DCCMVAU_SysRegWrite32_39870f723165ce38::*;
use ICH_LR_SysRegWrite32_66cfea86c7608fe1::*;
use PMEVCNTR_SysRegWrite32_8cf807c9cfa50ec9::*;
use HIFAR_SysRegWrite32_d0cdc9f9cdd54922::*;
use DTLBIASID_SysRegWrite32_58b10d925491a590::*;
use ICC_HSRE_SysRegWrite32_3352216733a79da7::*;
use DBGWCR_SysRegWrite32_e4aea7ea030c28ea::*;
use TLBIALLH_SysRegWrite32_ce3aa1e39dfad34d::*;
use AMEVTYPER1_SysRegWrite32_1c15a0e3b00864c2::*;
use CNTHCTL_SysRegWrite32_7d97fc0c6abe59e3::*;
use DCCISW_SysRegWrite32_419e334023bc59ed::*;
use DBGWVR_SysRegWrite32_605dd081b6345b68::*;
use ICIALLU_SysRegWrite32_cbf11f5ea46a9ef3::*;
use PMEVCNTR_SysRegWrite32_1b282b60cc4c6447::*;
use ATS1CUR_SysRegWrite32_592c369d819e223e::*;
use TLBIIPAS2L_SysRegWrite32_a0e257684d03ee99::*;
use MVBAR_SysRegWrite32_b51bf66bf3dc6e40::*;
use CP15DSB_SysRegWrite32_e8d50e04da138ecc::*;
use PMEVTYPER_SysRegWrite32_11835dd6069bfdf3::*;
use AMAIR0_SysRegWrite32_c80dd68970641167::*;
use TLBIMVAL_SysRegWrite32_db84fa64000a2011::*;
use AMEVTYPER1_SysRegWrite32_d612c920e0f1e095::*;
use ERXCTLR2_SysRegWrite32_0da36f801d9231d1::*;
use ACTLR_SysRegWrite32_5d9dcbc79ea74dc0::*;
use DBGBVR_SysRegWrite32_3fd7a5cc9728d4be::*;
use DBGBVR_SysRegWrite32_d3b70c896b17af64::*;
use PMOVSR_SysRegWrite32_afe1ff69a9fde1bd::*;
use ICV_IGRPEN1_SysRegWrite32_224f633a4805f3d5::*;
use TTBR1_SysRegWrite32_388bd96b6dea14cc::*;
use PMEVCNTR_SysRegWrite32_731843d10cb3a6ff::*;
use ERXMISC2_SysRegWrite32_3da1683956813628::*;
use HAIFSR_SysRegWrite32_a1d071280f147e46::*;
use TRFCR_SysRegWrite32_e7012a38712cc44a::*;
use ICH_LRC_SysRegWrite32_5036a59d7b5ab1d9::*;
use ICH_LR_SysRegWrite32_8da50c378e183c13::*;
use TLBIMVAIS_SysRegWrite32_bfc80b2d7757a07f::*;
use DBGPRCR_SysRegWrite32_99fa790871277002::*;
use PMEVCNTR_SysRegWrite32_7ee2623ac7e31637::*;
use ATS1CPW_SysRegWrite32_c343c707514145e0::*;
use DBGWVR_SysRegWrite32_47c683530a163238::*;
use ERXMISC1_SysRegWrite32_2fd201afaaba07ad::*;
use ICH_LR_SysRegWrite32_5f330d948f9246f1::*;
use PMEVTYPER_SysRegWrite32_5328bc51c618fc92::*;
use AMEVTYPER1_SysRegWrite32_fe1a95b5287339db::*;
use ICH_AP0R_SysRegWrite32_e8bf01c9f2e53161::*;
use ERXMISC7_SysRegWrite32_f7f96f4da3e8ae5b::*;
use PMEVCNTR_SysRegWrite32_91fa7b9aaafbca9c::*;
use HVBAR_SysRegWrite32_ebefed79e41064af::*;
use ICV_EOIR0_SysRegWrite32_a5e151ee536f5632::*;
use PMEVTYPER_SysRegWrite32_8790f8c36b20943f::*;
use DBGWVR_SysRegWrite32_75d9d09012e8a36d::*;
use DBGBCR_SysRegWrite32_ca879b07da5bfe93::*;
use DBGCLAIMCLR_SysRegWrite32_12efe8296d991861::*;
use AMEVTYPER1_SysRegWrite32_cb60b5ebc90e745e::*;
use DBGOSECCR_SysRegWrite32_87878830bf235bef::*;
use PMEVCNTR_SysRegWrite32_ae28080fa13bf9dd::*;
use DBGBXVR_SysRegWrite32_f06f2fb407b44033::*;
use DBGBXVR_SysRegWrite32_8266ce06319e0f6e::*;
use CNTHP_TVAL_SysRegWrite32_1a9db618df39c059::*;
use DBGBVR_SysRegWrite32_093d01ccd680c913::*;
use PMUSERENR_SysRegWrite32_5b91165bfc334c29::*;
use PMXEVCNTR_SysRegWrite32_4f0aa881614b1f11::*;
use ICH_LR_SysRegWrite32_9a10116a6dad894d::*;
use AIFSR_SysRegWrite32_0ca6e826bb64fe73::*;
use PMOVSSET_SysRegWrite32_d042c47fdd8f3705::*;
use PMEVTYPER_SysRegWrite32_1c8ef4dc87b91a11::*;
use ICC_SRE_SysRegWrite32_9b4f583336a77d42::*;
use VDISR_SysRegWrite32_d6e68a15b17084cf::*;
use JMCR_SysRegWrite32_5cdfe87c581e3185::*;
use PMEVCNTR_SysRegWrite32_77aaca2b0146bfed::*;
use DBGBCR_SysRegWrite32_2d689254949b32aa::*;
use DBGWVR_SysRegWrite32_4736e16210c07d51::*;
use NMRR_SysRegWrite32_d7c63fb9ed572aa1::*;
use DBGBVR_SysRegWrite32_09f07ef9f7a6387c::*;
use ICH_LR_SysRegWrite32_514fb9fa160b7dee::*;
use DBGWCR_SysRegWrite32_0d78661888bb9fac::*;
use ACTLR2_SysRegWrite32_282be907bf9b1055::*;
use DBGBVR_SysRegWrite32_1cb9715dee8f1c1b::*;
use IFAR_SysRegWrite32_7cf35b53506c7522::*;
use DLR_SysRegWrite32_aff2e156d6e1196e::*;
use DBGBCR_SysRegWrite32_122d009e13ded976::*;
use ATS1HR_SysRegWrite32_dc67c53b4eef830a::*;
use VTCR_SysRegWrite32_481811658d5f359e::*;
use HSR_SysRegWrite32_d1b5afc988459b67::*;
use CFPRCTX_SysRegWrite32_5c2c25bf2b1d12d6::*;
use DCIMVAC_SysRegWrite32_5e319c6b6a0107ac::*;
use PMEVCNTR_SysRegWrite32_3c9cffad5c0f5aa1::*;
use ICV_IGRPEN0_SysRegWrite32_e641a403de7ed22c::*;
use PMINTENCLR_SysRegWrite32_3861e4c2893d3032::*;
use DBGWCR_SysRegWrite32_b843cfc47f6433bd::*;
use DBGDCCINT_SysRegWrite32_6f112e4954747b48::*;
use HDFAR_SysRegWrite32_6e5ea51e474140cb::*;
use ICH_LRC_SysRegWrite32_386394d9b9080275::*;
use HMAIR1_SysRegWrite32_0de1027f448e168d::*;
use AMEVTYPER1_SysRegWrite32_405b1a2a28f91a31::*;
use CNTV_TVAL_SysRegWrite32_903e727583f63e89::*;
use ICH_LRC_SysRegWrite32_51763a756078a699::*;
use AMEVTYPER1_SysRegWrite32_4c73d953aff0e20b::*;
use PMEVTYPER_SysRegWrite32_4034283bec67f894::*;
use PMEVCNTR_SysRegWrite32_272a6440ad5e9b96::*;
use TLBIMVAA_SysRegWrite32_cb49c2a9a16e5968::*;
use DBGWCR_SysRegWrite32_74267755c7b7026a::*;
use DFSR_SysRegWrite32_d19afe00f293902c::*;
use ICH_LRC_SysRegWrite32_43a5c55815de94d9::*;
use DBGOSDLR_SysRegWrite32_d7c248a695fd43a4::*;
use DISR_SysRegWrite32_797163d94eb0b6e5::*;
use DBGWCR_SysRegWrite32_505cf952454e62f6::*;
use PMEVCNTR_SysRegWrite32_9dd8faac045ac370::*;
use ERXMISC0_SysRegWrite32_2c4882992476fc04::*;
use PMEVTYPER_SysRegWrite32_0dcdf6f29f657a14::*;
use ERXMISC5_SysRegWrite32_2205a9b0403bca94::*;
use PMEVCNTR_SysRegWrite32_ea82053afec3aa68::*;
use HAMAIR0_SysRegWrite32_8ce8a9ddd18b4f42::*;
use PMEVTYPER_SysRegWrite32_1340de29f3c858ee::*;
use HCR2_SysRegWrite32_e09ead3d01a1f060::*;
use PMEVCNTR_SysRegWrite32_93be8ea1078adab4::*;
use DBGBXVR_SysRegWrite32_afc6cb16977bd810::*;
use PMINTENSET_SysRegWrite32_068b645854413351::*;
use ICH_LRC_SysRegWrite32_26a1b63afe3dfd72::*;
use DBGBXVR_SysRegWrite32_116cb607b4f32fd9::*;
use HPFAR_SysRegWrite32_8aeb6030fddd52c2::*;
use IFSR_SysRegWrite32_86456fc11d1622be::*;
use TLBIIPAS2_SysRegWrite32_0f58707a5d9a37dd::*;
use ICV_CTLR_SysRegWrite32_6f9cee422585c5f5::*;
use PMEVTYPER_SysRegWrite32_6446dee6893e6f0c::*;
use CNTHVS_CTL_SysRegWrite32_018e2cf152f109f9::*;
use PMEVTYPER_SysRegWrite32_fc6d24db3b587aa8::*;
use DBGBXVR_SysRegWrite32_3dce4e0d5dbdee9b::*;
use DBGWVR_SysRegWrite32_9c49de3c8c0f3437::*;
use DBGBXVR_SysRegWrite32_24b2754b78ed2b6a::*;
use TLBIASIDIS_SysRegWrite32_03d2fed54ae109c3::*;
use PMEVCNTR_SysRegWrite32_80d48f0ea7518cab::*;
use TPIDRURW_SysRegWrite32_cb192fad8255358c::*;
use PMEVTYPER_SysRegWrite32_7a2ddec1dbe177e8::*;
use AMEVTYPER1_SysRegWrite32_a868a5149842a50f::*;
use DBGBCR_SysRegWrite32_08e08cceb84c7c71::*;
use DCISW_SysRegWrite32_e734ad2cce77231d::*;
use DBGWVR_SysRegWrite32_13a15cb94274721c::*;
use TLBIMVA_SysRegWrite32_f66a0ca0f4cc9ff0::*;
use AMEVTYPER1_SysRegWrite32_4f4eada85dcde70a::*;
use ATS1CPR_SysRegWrite32_810a4a7e2785c9d5::*;
use DVPRCTX_SysRegWrite32_60021502cabbda39::*;
use PMEVCNTR_SysRegWrite32_659a321a15f83618::*;
use PMEVCNTR_SysRegWrite32_f95277b9a9856b04::*;
use TLBIMVALHIS_SysRegWrite32_89a451ea9208e882::*;
use PMXEVTYPER_SysRegWrite32_853b58a36392d331::*;
use DBGWCR_SysRegWrite32_ab57e15a1119cc89::*;
use TLBIMVAHIS_SysRegWrite32_5da1d1a785b555e8::*;
use ITLBIMVA_SysRegWrite32_ff4131cdf091f782::*;
use PMCNTENSET_SysRegWrite32_8b1fd246c8987e40::*;
use DBGBVR_SysRegWrite32_43f4c896c92f0d6b::*;
use DCCSW_SysRegWrite32_0bd93e8a60e2ab27::*;
use CPACR_SysRegWrite32_512a962d4019b387::*;
use AMEVTYPER1_SysRegWrite32_d066b294b71fc9c6::*;
use DBGBVR_SysRegWrite32_582b75e31913750c::*;
use ICH_LRC_SysRegWrite32_f00162b6acc3532f::*;
use TLBIMVAAL_SysRegWrite32_b622dab84122dbc0::*;
use DBGBVR_SysRegWrite32_00f20f6c3bc04edd::*;
use AMEVTYPER1_SysRegWrite32_5a1635be7bbcd05b::*;
use DCCIMVAC_SysRegWrite32_9ec7bae67091217f::*;
use TLBIASID_SysRegWrite32_fb38392a6a11d341::*;
use ICH_LRC_SysRegWrite32_a1a007d19312bc57::*;
use PMEVTYPER_SysRegWrite32_82b4f80451193782::*;
use PMEVCNTR_SysRegWrite32_1402236c25c3ee30::*;
use ICC_MSRE_SysRegWrite32_3238a1354a48916c::*;
use TPIDRPRW_SysRegWrite32_5caaac18c68f924b::*;
use ICH_AP1R_SysRegWrite32_4eff4ec729dbfa39::*;
use HACTLR_SysRegWrite32_779af4815c28cfff::*;
use CP15ISB_SysRegWrite32_b2e3d8ab360938e2::*;
use AMCNTENCLR0_SysRegWrite32_38bf5168732af700::*;
use DBGBVR_SysRegWrite32_bf3ed59977f70f6c::*;
use ICH_LR_SysRegWrite32_29c49b66d9046e0a::*;
use DBGBVR_SysRegWrite32_6325f50ba95b0b24::*;
use AMCNTENCLR1_SysRegWrite32_54f7ea48fcecb714::*;
use FCSEIDR_SysRegWrite32_b64bdb1e5e7f2391::*;
use ICC_PMR_SysRegWrite32_b23a221ce6bd2853::*;
use ICH_LR_SysRegWrite32_d1e236ff7c3dc751::*;
use HMAIR0_SysRegWrite32_57f89dde47ed87b4::*;
use DBGWVR_SysRegWrite32_13f080217ac19392::*;
use AMEVTYPER1_SysRegWrite32_5157ae2713cc2d9d::*;
use DBGOSLAR_SysRegWrite32_38360f8339ba583f::*;
use DBGBVR_SysRegWrite32_bd28a7bc76c62bdd::*;
use TLBIMVALIS_SysRegWrite32_ff59541f99afcbcf::*;
use PMEVTYPER_SysRegWrite32_51b82d68052aa3e2::*;
use DBGBCR_SysRegWrite32_e67a829e0c397974::*;
use VMPIDR_SysRegWrite32_954adcfdf7aeec04::*;
use DBGWVR_SysRegWrite32_e152ce10f0dfcadb::*;
use CPPRCTX_SysRegWrite32_07d924e6f4753edc::*;
use CNTHPS_CTL_SysRegWrite32_420a204f985af014::*;
use DBGWVR_SysRegWrite32_e5618a29e5f06d6d::*;
use ATS12NSOPW_SysRegWrite32_ed16ee3eca6aefe5::*;
use ATS12NSOUW_SysRegWrite32_67f712d7e127f198::*;
use DBGWCR_SysRegWrite32_ab8bacc16ba179ac::*;
use DBGBCR_SysRegWrite32_28709afae2cd2b96::*;
use ERXMISC6_SysRegWrite32_58612120811a96a6::*;
use DBGBXVR_SysRegWrite32_b16f0d14e4620269::*;
use PMEVTYPER_SysRegWrite32_2577251aa43d9dc4::*;
use ICH_LRC_SysRegWrite32_e225401f886e4760::*;
use PMEVTYPER_SysRegWrite32_5d6bbab43fdc82f0::*;
use ICH_LR_SysRegWrite32_69f059200b508494::*;
use RMR_SysRegWrite32_9dfdd4710efdf52a::*;
use ICH_LR_SysRegWrite32_2360c70ac77c896c::*;
use TLBIMVAAIS_SysRegWrite32_96d1aeda66ab1386::*;
use DBGWFAR_SysRegWrite32_a92f4990bd564fb8::*;
use PMEVTYPER_SysRegWrite32_172e7a30c1ece78a::*;
use ICC_EOIR1_SysRegWrite32_b67c881f4f810bd8::*;
use DBGWCR_SysRegWrite32_3b90b969bb7720ca::*;
use PMEVCNTR_SysRegWrite32_9d177fd83b74425d::*;
use TLBIMVALH_SysRegWrite32_e910bf47238cb4c5::*;
use TLBIMVAALIS_SysRegWrite32_213090c663fe2ea7::*;
use DBGBVR_SysRegWrite32_eb8ac00541cce6a9::*;
use TTBR0_SysRegWrite32_455c3a8e0a51a871::*;
use PMEVTYPER_SysRegWrite32_5cfcde71ee84f007::*;
use BPIALL_SysRegWrite32_4a4889731f53da78::*;
use COSPRCTX_SysRegWrite32_4f4dd157b3f4905c::*;
use ICH_LRC_SysRegWrite32_ed5a361acf9b81f0::*;
use AMAIR1_SysRegWrite32_3836d7092d627787::*;
use ATS12NSOUR_SysRegWrite32_c89f9455fa8ec3dc::*;
use DBGBCR_SysRegWrite32_4d31a2bbe5418934::*;
use common::*;
pub fn AArch32_AutoGen_SysRegWrite32<T: Tracer>(
    state: &mut State,
    tracer: &T,
    el: u8,
    coproc: u8,
    opc1: u8,
    CRn: u8,
    opc2: u8,
    CRm: u8,
    t: i128,
) -> () {
    #[derive(Default)]
    struct FunctionState {
        gs_134697: bool,
        gs_134946: bool,
        gs_135845: bool,
        gs_134782: bool,
        gs_136022: bool,
        gs_135601: bool,
        gs_134899: bool,
        gs_134527: bool,
        gs_135293: bool,
        gs_135166: bool,
        gs_136087: bool,
        gs_134800: bool,
        gs_135648: bool,
        gs_135970: bool,
        gs_136071: bool,
        gs_134968: bool,
        gs_134819: bool,
        gs_135714: bool,
        gs_135533: bool,
        gs_135296: bool,
        gs_135464: bool,
        gs_134825: bool,
        gs_135514: bool,
        gs_135980: bool,
        gs_136066: bool,
        gs_134733: bool,
        gs_134597: bool,
        gs_135191: bool,
        gs_135479: bool,
        gs_134701: bool,
        gs_135410: bool,
        gs_135753: bool,
        gs_135896: bool,
        gs_135565: bool,
        gs_134682: bool,
        gs_134811: bool,
        gs_135140: bool,
        gs_135741: bool,
        gs_135101: bool,
        gs_134841: bool,
        gs_134569: bool,
        gs_135432: bool,
        gs_136102: bool,
        gs_134685: bool,
        gs_134763: bool,
        gs_134614: bool,
        gs_135082: bool,
        gs_135003: bool,
        gs_134977: bool,
        gs_134815: bool,
        gs_135494: bool,
        gs_135994: bool,
        gs_135157: bool,
        gs_134882: bool,
        gs_135387: bool,
        gs_134793: bool,
        gs_135756: bool,
        gs_135412: bool,
        gs_134574: bool,
        gs_134962: bool,
        gs_135128: bool,
        gs_135437: bool,
        gs_134896: bool,
        gs_134634: bool,
        gs_135848: bool,
        gs_134874: bool,
        gs_135026: bool,
        gs_135549: bool,
        gs_135005: bool,
        gs_135024: bool,
        gs_136028: bool,
        gs_135885: bool,
        gs_135802: bool,
        gs_136040: bool,
        gs_135470: bool,
        gs_134561: bool,
        gs_135946: bool,
        gs_135898: bool,
        gs_135378: bool,
        gs_135901: bool,
        gs_134486: bool,
        gs_134963: bool,
        gs_135860: bool,
        gs_135690: bool,
        gs_134567: bool,
        gs_134482: bool,
        gs_135674: bool,
        gs_134590: bool,
        gs_134941: bool,
        gs_135246: bool,
        gs_134613: bool,
        gs_134784: bool,
        gs_134639: bool,
        gs_136008: bool,
        gs_134688: bool,
        gs_135977: bool,
        gs_135614: bool,
        gs_135172: bool,
        gs_134824: bool,
        gs_135186: bool,
        gs_135384: bool,
        gs_134924: bool,
        gs_135339: bool,
        gs_134631: bool,
        gs_135236: bool,
        gs_135641: bool,
        gs_135158: bool,
        gs_135965: bool,
        gs_136079: bool,
        gs_134543: bool,
        gs_135551: bool,
        gs_135657: bool,
        gs_136082: bool,
        gs_135948: bool,
        gs_135959: bool,
        gs_134674: bool,
        gs_135953: bool,
        gs_135268: bool,
        gs_135847: bool,
        gs_134657: bool,
        gs_135260: bool,
        gs_134858: bool,
        gs_135799: bool,
        gs_134742: bool,
        gs_135877: bool,
        gs_134644: bool,
        gs_135611: bool,
        gs_135715: bool,
        gs_135043: bool,
        gs_134496: bool,
        gs_134949: bool,
        gs_135907: bool,
        gs_135321: bool,
        gs_136063: bool,
        gs_134518: bool,
        gs_136031: bool,
        gs_135322: bool,
        gs_135435: bool,
        gs_135666: bool,
        gs_134774: bool,
        gs_134843: bool,
        gs_135206: bool,
        gs_134630: bool,
        gs_134773: bool,
        gs_134686: bool,
        gs_135568: bool,
        gs_135950: bool,
        gs_135927: bool,
        gs_135328: bool,
        gs_136113: bool,
        gs_134680: bool,
        gs_134835: bool,
        gs_134937: bool,
        gs_135090: bool,
        gs_134912: bool,
        gs_135567: bool,
        gs_135520: bool,
        gs_135068: bool,
        gs_135933: bool,
        gs_135911: bool,
        gs_135400: bool,
        gs_134520: bool,
        gs_136042: bool,
        gs_134821: bool,
        gs_135060: bool,
        gs_135283: bool,
        gs_134565: bool,
        gs_135342: bool,
        gs_135452: bool,
        gs_134725: bool,
        gs_134573: bool,
        gs_135888: bool,
        gs_135218: bool,
        gs_135058: bool,
        gs_135759: bool,
        gs_135619: bool,
        gs_134716: bool,
        gs_135155: bool,
        gs_134847: bool,
        gs_135779: bool,
        gs_135300: bool,
        gs_135398: bool,
        gs_135539: bool,
        gs_135685: bool,
        gs_135796: bool,
        gs_135963: bool,
        gs_134778: bool,
        gs_135382: bool,
        gs_134704: bool,
        gs_135643: bool,
        gs_134743: bool,
        gs_135335: bool,
        gs_135389: bool,
        gs_135949: bool,
        gs_134556: bool,
        gs_136100: bool,
        gs_134517: bool,
        gs_135370: bool,
        gs_135780: bool,
        gs_135428: bool,
        gs_134649: bool,
        gs_134698: bool,
        gs_134741: bool,
        gs_136103: bool,
        gs_135751: bool,
        gs_135822: bool,
        gs_135252: bool,
        gs_134775: bool,
        gs_135617: bool,
        gs_135422: bool,
        gs_135017: bool,
        gs_135629: bool,
        gs_136043: bool,
        gs_135375: bool,
        gs_134752: bool,
        gs_134566: bool,
        gs_136069: bool,
        gs_135786: bool,
        gs_135406: bool,
        gs_135801: bool,
        gs_136088: bool,
        gs_134917: bool,
        gs_135886: bool,
        gs_135923: bool,
        gs_134785: bool,
        gs_135992: bool,
        gs_135324: bool,
        gs_136090: bool,
        gs_134999: bool,
        gs_135684: bool,
        gs_135458: bool,
        gs_135616: bool,
        gs_136039: bool,
        gs_134961: bool,
        gs_135676: bool,
        gs_135580: bool,
        gs_135305: bool,
        gs_134528: bool,
        gs_134651: bool,
        gs_135455: bool,
        gs_135833: bool,
        gs_135872: bool,
        gs_134938: bool,
        gs_136109: bool,
        gs_135098: bool,
        gs_135148: bool,
        gs_135095: bool,
        gs_135477: bool,
        gs_135230: bool,
        gs_134570: bool,
        gs_135383: bool,
        gs_135008: bool,
        gs_135270: bool,
        gs_135288: bool,
        gs_135850: bool,
        gs_136073: bool,
        gs_136060: bool,
        gs_136007: bool,
        gs_135930: bool,
        gs_135176: bool,
        gs_135445: bool,
        gs_134533: bool,
        gs_135438: bool,
        gs_136015: bool,
        gs_135034: bool,
        gs_134987: bool,
        gs_135987: bool,
        gs_135585: bool,
        gs_135512: bool,
        gs_135831: bool,
        gs_134640: bool,
        gs_134592: bool,
        gs_135352: bool,
        gs_135861: bool,
        gs_134889: bool,
        gs_135607: bool,
        gs_134582: bool,
        gs_135733: bool,
        gs_135490: bool,
        gs_135606: bool,
        gs_135958: bool,
        gs_135014: bool,
        gs_135265: bool,
        gs_135053: bool,
        gs_135841: bool,
        gs_134615: bool,
        gs_135105: bool,
        gs_135855: bool,
        gs_135713: bool,
        gs_135912: bool,
        gs_136092: bool,
        gs_134602: bool,
        gs_135876: bool,
        gs_135763: bool,
        gs_134572: bool,
        gs_135652: bool,
        gs_135301: bool,
        gs_135718: bool,
        gs_134836: bool,
        gs_134659: bool,
        gs_134706: bool,
        gs_134776: bool,
        gs_135880: bool,
        gs_135223: bool,
        gs_134635: bool,
        gs_136099: bool,
        gs_134495: bool,
        gs_135922: bool,
        gs_135961: bool,
        gs_135906: bool,
        gs_135152: bool,
        gs_134488: bool,
        gs_134772: bool,
        gs_135683: bool,
        gs_135698: bool,
        gs_135651: bool,
        gs_135522: bool,
        gs_135381: bool,
        gs_135858: bool,
        gs_135446: bool,
        gs_135231: bool,
        gs_135122: bool,
        gs_134593: bool,
        gs_135249: bool,
        gs_135289: bool,
        gs_135443: bool,
        gs_134844: bool,
        gs_135213: bool,
        gs_135162: bool,
        gs_134643: bool,
        gs_135106: bool,
        gs_134577: bool,
        gs_135118: bool,
        gs_134951: bool,
        gs_135002: bool,
        gs_135409: bool,
        gs_134650: bool,
        gs_135097: bool,
        gs_135015: bool,
        gs_135483: bool,
        gs_135072: bool,
        gs_135840: bool,
        gs_135336: bool,
        gs_135851: bool,
        gs_136062: bool,
        gs_134891: bool,
        gs_135705: bool,
        gs_135771: bool,
        gs_134877: bool,
        gs_134931: bool,
        gs_135272: bool,
        gs_134848: bool,
        gs_135423: bool,
        gs_134746: bool,
        gs_134867: bool,
        gs_135767: bool,
        gs_135472: bool,
        gs_135234: bool,
        gs_136045: bool,
        gs_135986: bool,
        gs_135194: bool,
        gs_134681: bool,
        gs_135150: bool,
        gs_136085: bool,
        gs_135159: bool,
        gs_135353: bool,
        gs_135910: bool,
        gs_134739: bool,
        gs_135125: bool,
        gs_135737: bool,
        gs_134497: bool,
        gs_136065: bool,
        gs_134954: bool,
        gs_135215: bool,
        gs_135303: bool,
        gs_134756: bool,
        gs_136112: bool,
        gs_135604: bool,
        gs_134648: bool,
        gs_134845: bool,
        gs_135814: bool,
        gs_135177: bool,
        gs_135009: bool,
        gs_135498: bool,
        gs_135785: bool,
        gs_135836: bool,
        gs_135920: bool,
        gs_134672: bool,
        gs_135075: bool,
        gs_135537: bool,
        gs_134897: bool,
        gs_134957: bool,
        gs_135156: bool,
        gs_134629: bool,
        gs_134846: bool,
        gs_135329: bool,
        gs_135084: bool,
        gs_135887: bool,
        gs_135117: bool,
        gs_134653: bool,
        gs_135844: bool,
        gs_135558: bool,
        gs_135154: bool,
        gs_135678: bool,
        gs_134693: bool,
        gs_135052: bool,
        gs_135624: bool,
        gs_134753: bool,
        gs_135426: bool,
        gs_135033: bool,
        gs_135174: bool,
        gs_134857: bool,
        gs_135671: bool,
        gs_135662: bool,
        gs_134986: bool,
        gs_135548: bool,
        gs_134965: bool,
        gs_135092: bool,
        gs_136024: bool,
        gs_135557: bool,
        gs_135661: bool,
        gs_135788: bool,
        gs_135495: bool,
        gs_134504: bool,
        gs_134523: bool,
        gs_134506: bool,
        gs_134610: bool,
        gs_134519: bool,
        gs_135875: bool,
        gs_135654: bool,
        gs_135029: bool,
        gs_136106: bool,
        gs_135820: bool,
        gs_134990: bool,
        gs_134692: bool,
        gs_136101: bool,
        gs_135835: bool,
        gs_134913: bool,
        gs_135587: bool,
        gs_134888: bool,
        gs_135344: bool,
        gs_134768: bool,
        gs_134759: bool,
        gs_136019: bool,
        gs_135054: bool,
        gs_134911: bool,
        gs_135145: bool,
        gs_134983: bool,
        gs_134799: bool,
        gs_135302: bool,
        gs_134790: bool,
        gs_134734: bool,
        gs_135292: bool,
        gs_135578: bool,
        gs_135431: bool,
        gs_134833: bool,
        gs_135493: bool,
        gs_135573: bool,
        gs_135338: bool,
        gs_134960: bool,
        gs_135331: bool,
        gs_135864: bool,
        gs_134806: bool,
        gs_135640: bool,
        gs_134676: bool,
        gs_135198: bool,
        gs_135816: bool,
        gs_134555: bool,
        gs_136076: bool,
        gs_135050: bool,
        gs_135668: bool,
        gs_135467: bool,
        gs_135813: bool,
        gs_135295: bool,
        gs_135721: bool,
        gs_135165: bool,
        gs_134618: bool,
        gs_135085: bool,
        gs_135179: bool,
        gs_135621: bool,
        gs_135752: bool,
        gs_136037: bool,
        gs_134664: bool,
        gs_134818: bool,
        gs_135006: bool,
        gs_134596: bool,
        gs_135116: bool,
        gs_135308: bool,
        gs_134781: bool,
        gs_135598: bool,
        gs_135849: bool,
        gs_134878: bool,
        gs_134623: bool,
        gs_135609: bool,
        gs_135554: bool,
        gs_134945: bool,
        gs_134887: bool,
        gs_135746: bool,
        gs_134900: bool,
        gs_134989: bool,
        gs_135503: bool,
        gs_135706: bool,
        gs_135712: bool,
        gs_134619: bool,
        gs_134935: bool,
        gs_135360: bool,
        gs_135615: bool,
        gs_135600: bool,
        gs_134589: bool,
        gs_134729: bool,
        gs_135149: bool,
        gs_135144: bool,
        gs_135784: bool,
        gs_134611: bool,
        gs_134998: bool,
        gs_134712: bool,
        gs_135552: bool,
        gs_135702: bool,
        gs_135350: bool,
        gs_134993: bool,
        gs_134872: bool,
        gs_135905: bool,
        gs_135120: bool,
        gs_135672: bool,
        gs_135538: bool,
        gs_135207: bool,
        gs_135664: bool,
        gs_134535: bool,
        gs_134915: bool,
        gs_135729: bool,
        gs_135112: bool,
        gs_135420: bool,
        gs_134585: bool,
        gs_135810: bool,
        gs_134606: bool,
        gs_135347: bool,
        gs_135693: bool,
        gs_135991: bool,
        gs_134822: bool,
        gs_135317: bool,
        gs_134510: bool,
        gs_135441: bool,
        gs_134660: bool,
        gs_135894: bool,
        gs_135964: bool,
        gs_135653: bool,
        gs_134880: bool,
        gs_135124: bool,
        gs_135393: bool,
        gs_135391: bool,
        gs_135707: bool,
        gs_135175: bool,
        gs_135521: bool,
        gs_135859: bool,
        gs_135221: bool,
        gs_134842: bool,
        gs_135734: bool,
        gs_135696: bool,
        gs_135071: bool,
        gs_135032: bool,
        gs_135195: bool,
        gs_135660: bool,
        gs_134608: bool,
        gs_136111: bool,
        gs_135938: bool,
        gs_136054: bool,
        gs_135160: bool,
        gs_134575: bool,
        gs_135936: bool,
        gs_134538: bool,
        gs_134622: bool,
        gs_135669: bool,
        gs_136053: bool,
        gs_135066: bool,
        gs_134626: bool,
        gs_135430: bool,
        gs_135182: bool,
        gs_135862: bool,
        gs_135645: bool,
        gs_134633: bool,
        gs_135762: bool,
        gs_135893: bool,
        gs_136115: bool,
        gs_135225: bool,
        gs_136096: bool,
        gs_135087: bool,
        gs_134881: bool,
        gs_135447: bool,
        gs_134869: bool,
        gs_134956: bool,
        gs_135769: bool,
        gs_134971: bool,
        gs_135742: bool,
        gs_134558: bool,
        gs_134584: bool,
        gs_135237: bool,
        gs_134505: bool,
        gs_135562: bool,
        gs_135478: bool,
        gs_135777: bool,
        gs_135357: bool,
        gs_135519: bool,
        gs_135941: bool,
        gs_134591: bool,
        gs_135273: bool,
        gs_134638: bool,
        gs_135010: bool,
        gs_136064: bool,
        gs_135511: bool,
        gs_136059: bool,
        gs_135740: bool,
        gs_134873: bool,
        gs_135989: bool,
        gs_134936: bool,
        gs_135307: bool,
        gs_134916: bool,
        gs_135532: bool,
        gs_134813: bool,
        gs_135151: bool,
        gs_135701: bool,
        gs_136006: bool,
        gs_134546: bool,
        gs_135094: bool,
        gs_135129: bool,
        gs_135899: bool,
        gs_134534: bool,
        gs_135790: bool,
        gs_135564: bool,
        gs_135417: bool,
        gs_135722: bool,
        gs_135404: bool,
        gs_135004: bool,
        gs_134901: bool,
        gs_135395: bool,
        gs_135967: bool,
        gs_135019: bool,
        gs_134728: bool,
        gs_134997: bool,
        gs_135220: bool,
        gs_135163: bool,
        gs_135379: bool,
        gs_135448: bool,
        gs_135626: bool,
        gs_136034: bool,
        gs_134791: bool,
        gs_135921: bool,
        gs_134838: bool,
        gs_135173: bool,
        gs_134522: bool,
        gs_134530: bool,
        gs_135100: bool,
        gs_135903: bool,
        gs_135605: bool,
        gs_135238: bool,
        gs_134738: bool,
        gs_135161: bool,
        gs_135947: bool,
        gs_135570: bool,
        gs_135080: bool,
        gs_135039: bool,
        gs_135699: bool,
        gs_135482: bool,
        gs_135462: bool,
        gs_135900: bool,
        gs_135362: bool,
        gs_134943: bool,
        gs_135227: bool,
        gs_135800: bool,
        gs_134982: bool,
        gs_135639: bool,
        gs_135311: bool,
        gs_135509: bool,
        gs_135257: bool,
        gs_135180: bool,
        gs_134687: bool,
        gs_135803: bool,
        gs_135114: bool,
        gs_136104: bool,
        gs_135171: bool,
        gs_135960: bool,
        gs_135716: bool,
        gs_136051: bool,
        gs_134927: bool,
        gs_134863: bool,
        gs_135655: bool,
        gs_135468: bool,
        gs_134859: bool,
        gs_134695: bool,
        gs_134745: bool,
        gs_135256: bool,
        gs_134979: bool,
        gs_135711: bool,
        gs_134974: bool,
        gs_135089: bool,
        gs_135232: bool,
        gs_134895: bool,
        gs_134539: bool,
        gs_134656: bool,
        gs_135825: bool,
        gs_135077: bool,
        gs_135881: bool,
        gs_134548: bool,
        gs_134562: bool,
        gs_135061: bool,
        gs_135250: bool,
        gs_135929: bool,
        gs_134816: bool,
        gs_134671: bool,
        gs_135791: bool,
        gs_134932: bool,
        gs_135348: bool,
        gs_135868: bool,
        gs_135728: bool,
        gs_134849: bool,
        gs_135405: bool,
        gs_135832: bool,
        gs_135319: bool,
        gs_136011: bool,
        gs_135275: bool,
        gs_135667: bool,
        gs_134783: bool,
        gs_134879: bool,
        gs_135628: bool,
        gs_134903: bool,
        gs_135656: bool,
        gs_135957: bool,
        gs_134972: bool,
        gs_134541: bool,
        gs_134980: bool,
        gs_135364: bool,
        gs_135047: bool,
        gs_135356: bool,
        gs_134708: bool,
        gs_134795: bool,
        gs_135966: bool,
        gs_135222: bool,
        gs_134908: bool,
        gs_134677: bool,
        gs_135267: bool,
        gs_135708: bool,
        gs_135807: bool,
        gs_136032: bool,
        gs_135203: bool,
        gs_134920: bool,
        gs_135597: bool,
        gs_134627: bool,
        gs_135130: bool,
        gs_135808: bool,
        gs_136072: bool,
        gs_135146: bool,
        gs_135418: bool,
        gs_134959: bool,
        gs_135170: bool,
        gs_136081: bool,
        gs_135566: bool,
        gs_135190: bool,
        gs_134579: bool,
        gs_135588: bool,
        gs_134814: bool,
        gs_136108: bool,
        gs_135530: bool,
        gs_135314: bool,
        gs_134637: bool,
        gs_136023: bool,
        gs_134976: bool,
        gs_135680: bool,
        gs_134789: bool,
        gs_136033: bool,
        gs_135108: bool,
        gs_135795: bool,
        gs_135824: bool,
        gs_136050: bool,
        gs_134823: bool,
        gs_135812: bool,
        gs_135516: bool,
        gs_135093: bool,
        gs_135869: bool,
        gs_134978: bool,
        gs_134829: bool,
        gs_134988: bool,
        gs_135282: bool,
        gs_134809: bool,
        gs_136107: bool,
        gs_135642: bool,
        gs_134856: bool,
        gs_135067: bool,
        gs_134807: bool,
        gs_134536: bool,
        gs_135529: bool,
        gs_135333: bool,
        gs_135064: bool,
        gs_134713: bool,
        gs_134747: bool,
        gs_135396: bool,
        gs_136091: bool,
        gs_135553: bool,
        gs_134832: bool,
        gs_134609: bool,
        gs_134947: bool,
        gs_135102: bool,
        gs_135501: bool,
        gs_135998: bool,
        gs_135515: bool,
        gs_135228: bool,
        gs_135687: bool,
        gs_135240: bool,
        gs_135306: bool,
        gs_134598: bool,
        gs_135817: bool,
        gs_135502: bool,
        gs_135563: bool,
        gs_135781: bool,
        gs_135940: bool,
        gs_135904: bool,
        gs_135928: bool,
        gs_136097: bool,
        gs_135187: bool,
        gs_135421: bool,
        gs_135200: bool,
        gs_135510: bool,
        gs_134919: bool,
        gs_135318: bool,
        gs_135070: bool,
        gs_135612: bool,
        gs_136049: bool,
        gs_135576: bool,
        gs_134500: bool,
        gs_134787: bool,
        gs_135838: bool,
        gs_134735: bool,
        gs_135613: bool,
        gs_135337: bool,
        gs_134625: bool,
        gs_135408: bool,
        gs_134850: bool,
        gs_134675: bool,
        gs_135692: bool,
        gs_135826: bool,
        gs_135235: bool,
        gs_135136: bool,
        gs_135540: bool,
        gs_135637: bool,
        gs_135046: bool,
        gs_134751: bool,
        gs_135937: bool,
        gs_134764: bool,
        gs_135091: bool,
        gs_135143: bool,
        gs_135474: bool,
        gs_135491: bool,
        gs_135636: bool,
        gs_134600: bool,
        gs_135507: bool,
        gs_135388: bool,
        gs_135345: bool,
        gs_135205: bool,
        gs_134904: bool,
        gs_135023: bool,
        gs_135892: bool,
        gs_135451: bool,
        gs_135694: bool,
        gs_135870: bool,
        gs_134967: bool,
        gs_135487: bool,
        gs_135681: bool,
        gs_134918: bool,
        gs_135968: bool,
        gs_135902: bool,
        gs_135063: bool,
        gs_136035: bool,
        gs_134588: bool,
        gs_135700: bool,
        gs_135944: bool,
        gs_135132: bool,
        gs_135251: bool,
        gs_135142: bool,
        gs_135036: bool,
        gs_134862: bool,
        gs_135839: bool,
        gs_134524: bool,
        gs_135385: bool,
        gs_135083: bool,
        gs_135583: bool,
        gs_134484: bool,
        gs_135599: bool,
        gs_135193: bool,
        gs_135745: bool,
        gs_135768: bool,
        gs_134652: bool,
        gs_136041: bool,
        gs_135778: bool,
        gs_135212: bool,
        gs_136014: bool,
        gs_135401: bool,
        gs_136086: bool,
        gs_135255: bool,
        gs_135376: bool,
        gs_134898: bool,
        gs_135984: bool,
        gs_135879: bool,
        gs_135546: bool,
        gs_135403: bool,
        gs_135732: bool,
        gs_134812: bool,
        gs_135439: bool,
        gs_134621: bool,
        gs_134929: bool,
        gs_134870: bool,
        gs_134723: bool,
        gs_135934: bool,
        gs_134853: bool,
        gs_134866: bool,
        gs_134808: bool,
        gs_134481: bool,
        gs_135038: bool,
        gs_135744: bool,
        gs_135055: bool,
        gs_135748: bool,
        gs_135815: bool,
        gs_134542: bool,
        gs_134715: bool,
        gs_135484: bool,
        gs_134830: bool,
        gs_134490: bool,
        gs_136036: bool,
        gs_135374: bool,
        gs_135647: bool,
        gs_135153: bool,
        gs_135865: bool,
        gs_134554: bool,
        gs_135031: bool,
        gs_134933: bool,
        gs_135663: bool,
        gs_135856: bool,
        gs_134803: bool,
        gs_135028: bool,
        gs_136074: bool,
        gs_135463: bool,
        gs_135419: bool,
        gs_135011: bool,
        gs_135016: bool,
        gs_136093: bool,
        gs_135280: bool,
        gs_135945: bool,
        gs_135750: bool,
        gs_135792: bool,
        gs_135457: bool,
        gs_134771: bool,
        gs_135985: bool,
        gs_135560: bool,
        gs_134854: bool,
        gs_135048: bool,
        gs_135453: bool,
        gs_134559: bool,
        gs_134521: bool,
        gs_134861: bool,
        gs_135811: bool,
        gs_135830: bool,
        gs_134910: bool,
        gs_134511: bool,
        gs_134801: bool,
        gs_134563: bool,
        gs_135416: bool,
        gs_135049: bool,
        gs_135939: bool,
        gs_134691: bool,
        gs_136001: bool,
        gs_134594: bool,
        gs_135358: bool,
        gs_134551: bool,
        gs_135216: bool,
        gs_135981: bool,
        gs_135244: bool,
        gs_135086: bool,
        gs_135045: bool,
        gs_134864: bool,
        gs_135924: bool,
        gs_135513: bool,
        gs_134732: bool,
        gs_135761: bool,
        gs_134654: bool,
        gs_135001: bool,
        gs_136070: bool,
        gs_135427: bool,
        gs_134491: bool,
        gs_134796: bool,
        gs_136052: bool,
        gs_135298: bool,
        gs_134940: bool,
        gs_135635: bool,
        gs_135201: bool,
        gs_135208: bool,
        gs_135730: bool,
        gs_134769: bool,
        gs_134568: bool,
        gs_135853: bool,
        gs_134586: bool,
        gs_135757: bool,
        gs_135586: bool,
        gs_134966: bool,
        gs_134852: bool,
        gs_135534: bool,
        gs_134721: bool,
        gs_135559: bool,
        gs_135476: bool,
        gs_135167: bool,
        gs_134549: bool,
        gs_135908: bool,
        gs_135012: bool,
        gs_134726: bool,
        gs_134700: bool,
        gs_134509: bool,
        gs_135269: bool,
        gs_135294: bool,
        gs_135542: bool,
        gs_134699: bool,
        gs_136094: bool,
        gs_135377: bool,
        gs_135506: bool,
        gs_136002: bool,
        gs_135372: bool,
        gs_135925: bool,
        gs_135271: bool,
        gs_134679: bool,
        gs_135772: bool,
        gs_135577: bool,
        gs_135724: bool,
        gs_135469: bool,
        gs_135007: bool,
        gs_134914: bool,
        gs_134839: bool,
        gs_135582: bool,
        gs_134655: bool,
        gs_134493: bool,
        gs_135442: bool,
        gs_135373: bool,
        gs_134758: bool,
        gs_135415: bool,
        gs_135829: bool,
        gs_134718: bool,
        gs_135665: bool,
        gs_134826: bool,
        gs_135916: bool,
        gs_136055: bool,
        gs_135942: bool,
        gs_136047: bool,
        gs_135556: bool,
        gs_135000: bool,
        gs_135340: bool,
        gs_135689: bool,
        gs_135675: bool,
        gs_134736: bool,
        gs_135297: bool,
        gs_134617: bool,
        gs_134665: bool,
        gs_134921: bool,
        gs_136026: bool,
        gs_134724: bool,
        gs_136025: bool,
        gs_134642: bool,
        gs_135527: bool,
        gs_135109: bool,
        gs_135486: bool,
        gs_135878: bool,
        gs_135259: bool,
        gs_135266: bool,
        gs_134564: bool,
        gs_135575: bool,
        gs_135884: bool,
        gs_135355: bool,
        gs_135738: bool,
        gs_135673: bool,
        gs_135183: bool,
        gs_134922: bool,
        gs_135997: bool,
        gs_135956: bool,
        gs_134975: bool,
        gs_135425: bool,
        gs_134851: bool,
        gs_135996: bool,
        gs_135776: bool,
        gs_134952: bool,
        gs_135536: bool,
        gs_135277: bool,
        gs_134525: bool,
        gs_134557: bool,
        gs_135988: bool,
        gs_134886: bool,
        gs_135854: bool,
        gs_135632: bool,
        gs_134970: bool,
        gs_135349: bool,
        gs_135480: bool,
        gs_135754: bool,
        gs_135955: bool,
        gs_135793: bool,
        gs_134599: bool,
        gs_135982: bool,
        gs_134507: bool,
        gs_135127: bool,
        gs_134512: bool,
        gs_135466: bool,
        gs_134707: bool,
        gs_135804: bool,
        gs_134909: bool,
        gs_134709: bool,
        gs_134494: bool,
        gs_135192: bool,
        gs_134777: bool,
        gs_134737: bool,
        gs_136077: bool,
        gs_135828: bool,
        gs_134865: bool,
        gs_134531: bool,
        gs_135782: bool,
        gs_135755: bool,
        gs_135030: bool,
        gs_135834: bool,
        gs_135625: bool,
        gs_135103: bool,
        gs_136021: bool,
        gs_135590: bool,
        gs_135842: bool,
        gs_135264: bool,
        gs_134923: bool,
        gs_135287: bool,
        gs_135809: bool,
        gs_134540: bool,
        gs_135402: bool,
        gs_134587: bool,
        gs_135219: bool,
        gs_135013: bool,
        gs_135214: bool,
        gs_136068: bool,
        gs_134689: bool,
        gs_135037: bool,
        gs_135119: bool,
        gs_135659: bool,
        gs_135508: bool,
        gs_135304: bool,
        gs_135882: bool,
        gs_135286: bool,
        gs_135747: bool,
        gs_134797: bool,
        gs_135866: bool,
        gs_135523: bool,
        gs_134526: bool,
        gs_135873: bool,
        gs_135242: bool,
        gs_134663: bool,
        gs_135138: bool,
        gs_134875: bool,
        gs_136078: bool,
        gs_135141: bool,
        gs_134578: bool,
        gs_135027: bool,
        gs_135726: bool,
        gs_136058: bool,
        gs_135399: bool,
        gs_134720: bool,
        gs_135258: bool,
        gs_135210: bool,
        gs_135760: bool,
        gs_134661: bool,
        gs_135035: bool,
        gs_135543: bool,
        gs_134604: bool,
        gs_134820: bool,
        gs_134668: bool,
        gs_135316: bool,
        gs_135890: bool,
        gs_136038: bool,
        gs_134667: bool,
        gs_135561: bool,
        gs_135323: bool,
        gs_135436: bool,
        gs_135040: bool,
        gs_136003: bool,
        gs_134779: bool,
        gs_135185: bool,
        gs_135247: bool,
        gs_135620: bool,
        gs_134981: bool,
        gs_134552: bool,
        gs_134748: bool,
        gs_136018: bool,
        gs_135473: bool,
        gs_136029: bool,
        gs_135450: bool,
        gs_135650: bool,
        gs_135454: bool,
        gs_135846: bool,
        gs_135593: bool,
        gs_135394: bool,
        gs_135954: bool,
        gs_135819: bool,
        gs_134662: bool,
        gs_134802: bool,
        gs_135062: bool,
        gs_135233: bool,
        gs_135505: bool,
        gs_135115: bool,
        gs_134487: bool,
        gs_135021: bool,
        gs_136114: bool,
        gs_135974: bool,
        gs_134727: bool,
        gs_136061: bool,
        gs_134702: bool,
        gs_135499: bool,
        gs_135623: bool,
        gs_134837: bool,
        gs_134666: bool,
        gs_134502: bool,
        gs_135475: bool,
        gs_135618: bool,
        gs_134678: bool,
        gs_135524: bool,
        gs_135581: bool,
        gs_135351: bool,
        gs_134485: bool,
        gs_135544: bool,
        gs_135827: bool,
        gs_134831: bool,
        gs_134804: bool,
        gs_135983: bool,
        gs_135979: bool,
        gs_135492: bool,
        gs_135088: bool,
        gs_135126: bool,
        gs_135806: bool,
        gs_135253: bool,
        gs_135025: bool,
        gs_135723: bool,
        gs_134612: bool,
        gs_135867: bool,
        gs_134948: bool,
        gs_135217: bool,
        gs_135022: bool,
        gs_134828: bool,
        gs_135608: bool,
        gs_135589: bool,
        gs_135579: bool,
        gs_135137: bool,
        gs_136009: bool,
        gs_135990: bool,
        gs_136080: bool,
        gs_135535: bool,
        gs_134711: bool,
        gs_135211: bool,
        gs_135361: bool,
        gs_135749: bool,
        gs_135488: bool,
        gs_134834: bool,
        gs_135346: bool,
        gs_135883: bool,
        gs_134560: bool,
        gs_134595: bool,
        gs_135889: bool,
        gs_135720: bool,
        gs_134840: bool,
        gs_135973: bool,
        gs_134636: bool,
        gs_135284: bool,
        gs_134641: bool,
        gs_135392: bool,
        gs_135371: bool,
        gs_134973: bool,
        gs_135178: bool,
        gs_136095: bool,
        gs_135460: bool,
        gs_135735: bool,
        gs_135932: bool,
        gs_134942: bool,
        gs_135274: bool,
        gs_135104: bool,
        gs_135184: bool,
        gs_135596: bool,
        gs_135226: bool,
        gs_136013: bool,
        gs_135059: bool,
        gs_134969: bool,
        gs_135995: bool,
        gs_135354: bool,
        gs_134515: bool,
        gs_134576: bool,
        gs_134766: bool,
        gs_134928: bool,
        gs_134499: bool,
        gs_134907: bool,
        gs_134603: bool,
        gs_134760: bool,
        gs_134645: bool,
        gs_135646: bool,
        gs_135074: bool,
        gs_135717: bool,
        gs_135670: bool,
        gs_134883: bool,
        gs_135330: bool,
        gs_135633: bool,
        gs_134905: bool,
        gs_135123: bool,
        gs_135919: bool,
        gs_134926: bool,
        gs_135326: bool,
        gs_135758: bool,
        gs_134513: bool,
        gs_135518: bool,
        gs_134537: bool,
        gs_135051: bool,
        gs_135365: bool,
        gs_134501: bool,
        gs_135107: bool,
        gs_134792: bool,
        gs_136010: bool,
        gs_135602: bool,
        gs_135147: bool,
        gs_135489: bool,
        gs_134529: bool,
        gs_135224: bool,
        gs_135504: bool,
        gs_135727: bool,
        gs_135411: bool,
        gs_135695: bool,
        gs_135262: bool,
        gs_135525: bool,
        gs_135481: bool,
        gs_135440: bool,
        gs_135703: bool,
        gs_135044: bool,
        gs_136017: bool,
        gs_134703: bool,
        gs_135380: bool,
        gs_135325: bool,
        gs_135677: bool,
        gs_134805: bool,
        gs_135591: bool,
        gs_135367: bool,
        gs_135818: bool,
        gs_135773: bool,
        gs_134855: bool,
        gs_134868: bool,
        gs_135299: bool,
        gs_136044: bool,
        gs_135797: bool,
        gs_136004: bool,
        gs_135913: bool,
        gs_136016: bool,
        gs_135485: bool,
        gs_135571: bool,
        gs_135572: bool,
        gs_135433: bool,
        gs_135041: bool,
        gs_135658: bool,
        gs_135291: bool,
        gs_135424: bool,
        gs_134719: bool,
        gs_135449: bool,
        gs_135976: bool,
        gs_134722: bool,
        gs_135245: bool,
        gs_135209: bool,
        gs_135918: bool,
        gs_135765: bool,
        gs_135312: bool,
        gs_134601: bool,
        gs_135517: bool,
        gs_135276: bool,
        gs_135188: bool,
        gs_135993: bool,
        gs_134516: bool,
        gs_135471: bool,
        gs_134616: bool,
        gs_134984: bool,
        gs_135018: bool,
        gs_135281: bool,
        gs_135631: bool,
        gs_135096: bool,
        gs_134885: bool,
        gs_135634: bool,
        gs_135310: bool,
        gs_136110: bool,
        gs_134571: bool,
        gs_135691: bool,
        gs_135169: bool,
        gs_136030: bool,
        gs_134944: bool,
        gs_134955: bool,
        gs_135197: bool,
        gs_135315: bool,
        gs_134876: bool,
        gs_135914: bool,
        gs_135627: bool,
        gs_135189: bool,
        gs_135243: bool,
        gs_134767: bool,
        gs_134532: bool,
        gs_135496: bool,
        gs_134696: bool,
        gs_135594: bool,
        gs_134544: bool,
        gs_134798: bool,
        gs_134580: bool,
        gs_135099: bool,
        gs_135111: bool,
        gs_135545: bool,
        gs_135248: bool,
        gs_134757: bool,
        gs_135065: bool,
        gs_135783: bool,
        gs_135743: bool,
        gs_134714: bool,
        gs_134925: bool,
        gs_135073: bool,
        gs_134690: bool,
        gs_135343: bool,
        gs_135931: bool,
        gs_135239: bool,
        gs_135407: bool,
        gs_135113: bool,
        gs_134731: bool,
        gs_134670: bool,
        gs_135135: bool,
        gs_135917: bool,
        gs_135386: bool,
        gs_135943: bool,
        gs_135133: bool,
        gs_135069: bool,
        gs_134744: bool,
        gs_134810: bool,
        gs_135770: bool,
        gs_135704: bool,
        gs_134628: bool,
        gs_135327: bool,
        gs_136057: bool,
        gs_135526: bool,
        gs_135622: bool,
        gs_135121: bool,
        gs_135531: bool,
        gs_134498: bool,
        gs_134794: bool,
        gs_135429: bool,
        gs_135056: bool,
        gs_134964: bool,
        gs_135290: bool,
        gs_134992: bool,
        gs_134683: bool,
        gs_134755: bool,
        gs_135871: bool,
        gs_135313: bool,
        gs_134762: bool,
        gs_134489: bool,
        gs_135390: bool,
        gs_134607: bool,
        gs_135725: bool,
        gs_134765: bool,
        gs_134483: bool,
        gs_134996: bool,
        gs_135057: bool,
        gs_134647: bool,
        gs_135285: bool,
        gs_135775: bool,
        gs_135679: bool,
        gs_136020: bool,
        gs_134871: bool,
        gs_135843: bool,
        gs_134620: bool,
        gs_135254: bool,
        gs_135341: bool,
        gs_135649: bool,
        gs_134550: bool,
        gs_134581: bool,
        gs_135110: bool,
        gs_136067: bool,
        gs_135076: bool,
        gs_134705: bool,
        gs_135020: bool,
        gs_135081: bool,
        gs_135731: bool,
        gs_135465: bool,
        gs_135909: bool,
        gs_135309: bool,
        gs_134583: bool,
        gs_134934: bool,
        gs_134906: bool,
        gs_135710: bool,
        gs_134894: bool,
        gs_134754: bool,
        gs_134605: bool,
        gs_135766: bool,
        gs_134658: bool,
        gs_135709: bool,
        gs_134553: bool,
        gs_136000: bool,
        gs_134991: bool,
        gs_136005: bool,
        gs_135139: bool,
        gs_135241: bool,
        gs_135603: bool,
        gs_135500: bool,
        gs_134786: bool,
        gs_135368: bool,
        gs_135739: bool,
        gs_136012: bool,
        gs_136089: bool,
        gs_135697: bool,
        gs_134750: bool,
        gs_136027: bool,
        gs_135541: bool,
        gs_134646: bool,
        gs_134503: bool,
        gs_135547: bool,
        gs_135686: bool,
        gs_135168: bool,
        gs_136083: bool,
        gs_135444: bool,
        gs_135278: bool,
        gs_134890: bool,
        gs_135682: bool,
        gs_135359: bool,
        gs_134884: bool,
        gs_135857: bool,
        gs_136056: bool,
        gs_134860: bool,
        gs_135569: bool,
        gs_135456: bool,
        gs_134545: bool,
        gs_135263: bool,
        gs_135164: bool,
        gs_135962: bool,
        gs_135895: bool,
        gs_135630: bool,
        gs_135555: bool,
        gs_135610: bool,
        gs_135202: bool,
        gs_135261: bool,
        gs_134710: bool,
        gs_135079: bool,
        gs_135935: bool,
        gs_135852: bool,
        gs_135863: bool,
        gs_134684: bool,
        gs_135042: bool,
        gs_135688: bool,
        gs_135975: bool,
        gs_134770: bool,
        gs_135926: bool,
        gs_135978: bool,
        gs_135199: bool,
        gs_135279: bool,
        gs_134508: bool,
        gs_135459: bool,
        gs_135332: bool,
        gs_135951: bool,
        gs_135999: bool,
        gs_135774: bool,
        gs_135798: bool,
        gs_134953: bool,
        gs_134817: bool,
        gs_135874: bool,
        gs_135595: bool,
        gs_135584: bool,
        gs_135369: bool,
        gs_134930: bool,
        gs_135131: bool,
        gs_135497: bool,
        gs_135837: bool,
        gs_136046: bool,
        gs_134492: bool,
        gs_135823: bool,
        gs_135574: bool,
        gs_135320: bool,
        gs_134827: bool,
        gs_135915: bool,
        gs_135528: bool,
        gs_135969: bool,
        gs_134780: bool,
        gs_136098: bool,
        gs_135821: bool,
        gs_135736: bool,
        gs_135134: bool,
        gs_135550: bool,
        gs_135805: bool,
        gs_135204: bool,
        gs_134788: bool,
        gs_135952: bool,
        gs_135638: bool,
        gs_135789: bool,
        gs_135078: bool,
        gs_135891: bool,
        gs_135413: bool,
        gs_134624: bool,
        gs_135366: bool,
        gs_134749: bool,
        gs_135972: bool,
        gs_134632: bool,
        gs_134669: bool,
        gs_135334: bool,
        gs_134985: bool,
        gs_135971: bool,
        gs_135363: bool,
        gs_134730: bool,
        gs_135181: bool,
        gs_136048: bool,
        gs_136075: bool,
        gs_135787: bool,
        gs_134958: bool,
        gs_134740: bool,
        gs_134892: bool,
        gs_135461: bool,
        gs_135196: bool,
        gs_134547: bool,
        gs_135414: bool,
        gs_134994: bool,
        gs_134761: bool,
        gs_134939: bool,
        gs_134995: bool,
        gs_135434: bool,
        gs_135897: bool,
        gs_135644: bool,
        gs_134893: bool,
        gs_135794: bool,
        gs_134694: bool,
        gs_134902: bool,
        gs_135229: bool,
        gs_136084: bool,
        gs_136105: bool,
        gs_134514: bool,
        gs_135764: bool,
        gs_135397: bool,
        gs_134717: bool,
        gs_134480: bool,
        gs_134673: bool,
        gs_135719: bool,
        gs_134950: bool,
        gs_135592: bool,
        el: u8,
        coproc: u8,
        opc1: u8,
        CRn: u8,
        opc2: u8,
        CRm: u8,
        t: i128,
    }
    let fn_state = FunctionState {
        el,
        coproc,
        opc1,
        CRn,
        opc2,
        CRm,
        t,
        ..Default::default()
    };
    return block_0(state, tracer, fn_state);
    fn block_0<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_0_0: read-var CRm:u8
        let s_0_0: u8 = fn_state.CRm;
        // D s_0_1: cast zx s_0_0 -> bv
        let s_0_1: Bits = Bits::new(s_0_0 as u128, 4u16);
        // C s_0_2: const #4u : u8
        let s_0_2: u8 = 4;
        // C s_0_3: cast zx s_0_2 -> bv
        let s_0_3: Bits = Bits::new(s_0_2 as u128, 4u16);
        // D s_0_4: cmp-eq s_0_1 s_0_3
        let s_0_4: bool = ((s_0_1) == (s_0_3));
        // N s_0_5: branch s_0_4 b5726 b1
        if s_0_4 {
            return block_5726(state, tracer, fn_state);
        } else {
            return block_1(state, tracer, fn_state);
        };
    }
    fn block_1<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1_0: const #0u : u8
        let s_1_0: bool = false;
        // D s_1_1: write-var gs#134480 <= s_1_0
        fn_state.gs_134480 = s_1_0;
        // N s_1_2: jump b2
        return block_2(state, tracer, fn_state);
    }
    fn block_2<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2_0: read-var gs#134480:u8
        let s_2_0: bool = fn_state.gs_134480;
        // N s_2_1: branch s_2_0 b5725 b3
        if s_2_0 {
            return block_5725(state, tracer, fn_state);
        } else {
            return block_3(state, tracer, fn_state);
        };
    }
    fn block_3<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3_0: const #0u : u8
        let s_3_0: bool = false;
        // D s_3_1: write-var gs#134481 <= s_3_0
        fn_state.gs_134481 = s_3_0;
        // N s_3_2: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_4<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4_0: read-var gs#134481:u8
        let s_4_0: bool = fn_state.gs_134481;
        // N s_4_1: branch s_4_0 b5724 b5
        if s_4_0 {
            return block_5724(state, tracer, fn_state);
        } else {
            return block_5(state, tracer, fn_state);
        };
    }
    fn block_5<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_5_0: const #0u : u8
        let s_5_0: bool = false;
        // D s_5_1: write-var gs#134482 <= s_5_0
        fn_state.gs_134482 = s_5_0;
        // N s_5_2: jump b6
        return block_6(state, tracer, fn_state);
    }
    fn block_6<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_6_0: read-var gs#134482:u8
        let s_6_0: bool = fn_state.gs_134482;
        // N s_6_1: branch s_6_0 b5723 b7
        if s_6_0 {
            return block_5723(state, tracer, fn_state);
        } else {
            return block_7(state, tracer, fn_state);
        };
    }
    fn block_7<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_7_0: const #0u : u8
        let s_7_0: bool = false;
        // D s_7_1: write-var gs#134483 <= s_7_0
        fn_state.gs_134483 = s_7_0;
        // N s_7_2: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_8<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_8_0: read-var gs#134483:u8
        let s_8_0: bool = fn_state.gs_134483;
        // N s_8_1: branch s_8_0 b5722 b9
        if s_8_0 {
            return block_5722(state, tracer, fn_state);
        } else {
            return block_9(state, tracer, fn_state);
        };
    }
    fn block_9<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_9_0: read-var CRm:u8
        let s_9_0: u8 = fn_state.CRm;
        // D s_9_1: cast zx s_9_0 -> bv
        let s_9_1: Bits = Bits::new(s_9_0 as u128, 4u16);
        // C s_9_2: const #13u : u8
        let s_9_2: u8 = 13;
        // C s_9_3: cast zx s_9_2 -> bv
        let s_9_3: Bits = Bits::new(s_9_2 as u128, 4u16);
        // D s_9_4: cmp-eq s_9_1 s_9_3
        let s_9_4: bool = ((s_9_1) == (s_9_3));
        // N s_9_5: branch s_9_4 b5721 b10
        if s_9_4 {
            return block_5721(state, tracer, fn_state);
        } else {
            return block_10(state, tracer, fn_state);
        };
    }
    fn block_10<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_10_0: const #0u : u8
        let s_10_0: bool = false;
        // D s_10_1: write-var gs#134484 <= s_10_0
        fn_state.gs_134484 = s_10_0;
        // N s_10_2: jump b11
        return block_11(state, tracer, fn_state);
    }
    fn block_11<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_11_0: read-var gs#134484:u8
        let s_11_0: bool = fn_state.gs_134484;
        // N s_11_1: branch s_11_0 b5720 b12
        if s_11_0 {
            return block_5720(state, tracer, fn_state);
        } else {
            return block_12(state, tracer, fn_state);
        };
    }
    fn block_12<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_12_0: const #0u : u8
        let s_12_0: bool = false;
        // D s_12_1: write-var gs#134485 <= s_12_0
        fn_state.gs_134485 = s_12_0;
        // N s_12_2: jump b13
        return block_13(state, tracer, fn_state);
    }
    fn block_13<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_13_0: read-var gs#134485:u8
        let s_13_0: bool = fn_state.gs_134485;
        // N s_13_1: branch s_13_0 b5719 b14
        if s_13_0 {
            return block_5719(state, tracer, fn_state);
        } else {
            return block_14(state, tracer, fn_state);
        };
    }
    fn block_14<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_14_0: const #0u : u8
        let s_14_0: bool = false;
        // D s_14_1: write-var gs#134486 <= s_14_0
        fn_state.gs_134486 = s_14_0;
        // N s_14_2: jump b15
        return block_15(state, tracer, fn_state);
    }
    fn block_15<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_15_0: read-var gs#134486:u8
        let s_15_0: bool = fn_state.gs_134486;
        // N s_15_1: branch s_15_0 b5718 b16
        if s_15_0 {
            return block_5718(state, tracer, fn_state);
        } else {
            return block_16(state, tracer, fn_state);
        };
    }
    fn block_16<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_16_0: const #0u : u8
        let s_16_0: bool = false;
        // D s_16_1: write-var gs#134487 <= s_16_0
        fn_state.gs_134487 = s_16_0;
        // N s_16_2: jump b17
        return block_17(state, tracer, fn_state);
    }
    fn block_17<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_17_0: read-var gs#134487:u8
        let s_17_0: bool = fn_state.gs_134487;
        // N s_17_1: branch s_17_0 b5717 b18
        if s_17_0 {
            return block_5717(state, tracer, fn_state);
        } else {
            return block_18(state, tracer, fn_state);
        };
    }
    fn block_18<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_18_0: read-var CRm:u8
        let s_18_0: u8 = fn_state.CRm;
        // D s_18_1: cast zx s_18_0 -> bv
        let s_18_1: Bits = Bits::new(s_18_0 as u128, 4u16);
        // C s_18_2: const #0u : u8
        let s_18_2: u8 = 0;
        // C s_18_3: cast zx s_18_2 -> bv
        let s_18_3: Bits = Bits::new(s_18_2 as u128, 4u16);
        // D s_18_4: cmp-eq s_18_1 s_18_3
        let s_18_4: bool = ((s_18_1) == (s_18_3));
        // N s_18_5: branch s_18_4 b5716 b19
        if s_18_4 {
            return block_5716(state, tracer, fn_state);
        } else {
            return block_19(state, tracer, fn_state);
        };
    }
    fn block_19<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_19_0: const #0u : u8
        let s_19_0: bool = false;
        // D s_19_1: write-var gs#134488 <= s_19_0
        fn_state.gs_134488 = s_19_0;
        // N s_19_2: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_20<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_20_0: read-var gs#134488:u8
        let s_20_0: bool = fn_state.gs_134488;
        // N s_20_1: branch s_20_0 b5715 b21
        if s_20_0 {
            return block_5715(state, tracer, fn_state);
        } else {
            return block_21(state, tracer, fn_state);
        };
    }
    fn block_21<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_21_0: const #0u : u8
        let s_21_0: bool = false;
        // D s_21_1: write-var gs#134489 <= s_21_0
        fn_state.gs_134489 = s_21_0;
        // N s_21_2: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_22<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_22_0: read-var gs#134489:u8
        let s_22_0: bool = fn_state.gs_134489;
        // N s_22_1: branch s_22_0 b5714 b23
        if s_22_0 {
            return block_5714(state, tracer, fn_state);
        } else {
            return block_23(state, tracer, fn_state);
        };
    }
    fn block_23<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_23_0: const #0u : u8
        let s_23_0: bool = false;
        // D s_23_1: write-var gs#134490 <= s_23_0
        fn_state.gs_134490 = s_23_0;
        // N s_23_2: jump b24
        return block_24(state, tracer, fn_state);
    }
    fn block_24<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_24_0: read-var gs#134490:u8
        let s_24_0: bool = fn_state.gs_134490;
        // N s_24_1: branch s_24_0 b5713 b25
        if s_24_0 {
            return block_5713(state, tracer, fn_state);
        } else {
            return block_25(state, tracer, fn_state);
        };
    }
    fn block_25<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_25_0: const #0u : u8
        let s_25_0: bool = false;
        // D s_25_1: write-var gs#134491 <= s_25_0
        fn_state.gs_134491 = s_25_0;
        // N s_25_2: jump b26
        return block_26(state, tracer, fn_state);
    }
    fn block_26<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_26_0: read-var gs#134491:u8
        let s_26_0: bool = fn_state.gs_134491;
        // N s_26_1: branch s_26_0 b5712 b27
        if s_26_0 {
            return block_5712(state, tracer, fn_state);
        } else {
            return block_27(state, tracer, fn_state);
        };
    }
    fn block_27<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_27_0: read-var CRm:u8
        let s_27_0: u8 = fn_state.CRm;
        // D s_27_1: cast zx s_27_0 -> bv
        let s_27_1: Bits = Bits::new(s_27_0 as u128, 4u16);
        // C s_27_2: const #0u : u8
        let s_27_2: u8 = 0;
        // C s_27_3: cast zx s_27_2 -> bv
        let s_27_3: Bits = Bits::new(s_27_2 as u128, 4u16);
        // D s_27_4: cmp-eq s_27_1 s_27_3
        let s_27_4: bool = ((s_27_1) == (s_27_3));
        // N s_27_5: branch s_27_4 b5711 b28
        if s_27_4 {
            return block_5711(state, tracer, fn_state);
        } else {
            return block_28(state, tracer, fn_state);
        };
    }
    fn block_28<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_28_0: const #0u : u8
        let s_28_0: bool = false;
        // D s_28_1: write-var gs#134492 <= s_28_0
        fn_state.gs_134492 = s_28_0;
        // N s_28_2: jump b29
        return block_29(state, tracer, fn_state);
    }
    fn block_29<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_29_0: read-var gs#134492:u8
        let s_29_0: bool = fn_state.gs_134492;
        // N s_29_1: branch s_29_0 b5710 b30
        if s_29_0 {
            return block_5710(state, tracer, fn_state);
        } else {
            return block_30(state, tracer, fn_state);
        };
    }
    fn block_30<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_30_0: const #0u : u8
        let s_30_0: bool = false;
        // D s_30_1: write-var gs#134493 <= s_30_0
        fn_state.gs_134493 = s_30_0;
        // N s_30_2: jump b31
        return block_31(state, tracer, fn_state);
    }
    fn block_31<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_31_0: read-var gs#134493:u8
        let s_31_0: bool = fn_state.gs_134493;
        // N s_31_1: branch s_31_0 b5709 b32
        if s_31_0 {
            return block_5709(state, tracer, fn_state);
        } else {
            return block_32(state, tracer, fn_state);
        };
    }
    fn block_32<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_32_0: const #0u : u8
        let s_32_0: bool = false;
        // D s_32_1: write-var gs#134494 <= s_32_0
        fn_state.gs_134494 = s_32_0;
        // N s_32_2: jump b33
        return block_33(state, tracer, fn_state);
    }
    fn block_33<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_33_0: read-var gs#134494:u8
        let s_33_0: bool = fn_state.gs_134494;
        // N s_33_1: branch s_33_0 b5708 b34
        if s_33_0 {
            return block_5708(state, tracer, fn_state);
        } else {
            return block_34(state, tracer, fn_state);
        };
    }
    fn block_34<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_34_0: const #0u : u8
        let s_34_0: bool = false;
        // D s_34_1: write-var gs#134495 <= s_34_0
        fn_state.gs_134495 = s_34_0;
        // N s_34_2: jump b35
        return block_35(state, tracer, fn_state);
    }
    fn block_35<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_35_0: read-var gs#134495:u8
        let s_35_0: bool = fn_state.gs_134495;
        // N s_35_1: branch s_35_0 b5707 b36
        if s_35_0 {
            return block_5707(state, tracer, fn_state);
        } else {
            return block_36(state, tracer, fn_state);
        };
    }
    fn block_36<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_36_0: read-var CRm:u8
        let s_36_0: u8 = fn_state.CRm;
        // D s_36_1: cast zx s_36_0 -> bv
        let s_36_1: Bits = Bits::new(s_36_0 as u128, 4u16);
        // C s_36_2: const #0u : u8
        let s_36_2: u8 = 0;
        // C s_36_3: cast zx s_36_2 -> bv
        let s_36_3: Bits = Bits::new(s_36_2 as u128, 4u16);
        // D s_36_4: cmp-eq s_36_1 s_36_3
        let s_36_4: bool = ((s_36_1) == (s_36_3));
        // N s_36_5: branch s_36_4 b5706 b37
        if s_36_4 {
            return block_5706(state, tracer, fn_state);
        } else {
            return block_37(state, tracer, fn_state);
        };
    }
    fn block_37<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_37_0: const #0u : u8
        let s_37_0: bool = false;
        // D s_37_1: write-var gs#134496 <= s_37_0
        fn_state.gs_134496 = s_37_0;
        // N s_37_2: jump b38
        return block_38(state, tracer, fn_state);
    }
    fn block_38<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_38_0: read-var gs#134496:u8
        let s_38_0: bool = fn_state.gs_134496;
        // N s_38_1: branch s_38_0 b5705 b39
        if s_38_0 {
            return block_5705(state, tracer, fn_state);
        } else {
            return block_39(state, tracer, fn_state);
        };
    }
    fn block_39<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_39_0: const #0u : u8
        let s_39_0: bool = false;
        // D s_39_1: write-var gs#134497 <= s_39_0
        fn_state.gs_134497 = s_39_0;
        // N s_39_2: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_40<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_40_0: read-var gs#134497:u8
        let s_40_0: bool = fn_state.gs_134497;
        // N s_40_1: branch s_40_0 b5704 b41
        if s_40_0 {
            return block_5704(state, tracer, fn_state);
        } else {
            return block_41(state, tracer, fn_state);
        };
    }
    fn block_41<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_41_0: const #0u : u8
        let s_41_0: bool = false;
        // D s_41_1: write-var gs#134498 <= s_41_0
        fn_state.gs_134498 = s_41_0;
        // N s_41_2: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_42<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_42_0: read-var gs#134498:u8
        let s_42_0: bool = fn_state.gs_134498;
        // N s_42_1: branch s_42_0 b5703 b43
        if s_42_0 {
            return block_5703(state, tracer, fn_state);
        } else {
            return block_43(state, tracer, fn_state);
        };
    }
    fn block_43<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_43_0: const #0u : u8
        let s_43_0: bool = false;
        // D s_43_1: write-var gs#134499 <= s_43_0
        fn_state.gs_134499 = s_43_0;
        // N s_43_2: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_44<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_44_0: read-var gs#134499:u8
        let s_44_0: bool = fn_state.gs_134499;
        // N s_44_1: branch s_44_0 b5702 b45
        if s_44_0 {
            return block_5702(state, tracer, fn_state);
        } else {
            return block_45(state, tracer, fn_state);
        };
    }
    fn block_45<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_45_0: read-var CRm:u8
        let s_45_0: u8 = fn_state.CRm;
        // D s_45_1: cast zx s_45_0 -> bv
        let s_45_1: Bits = Bits::new(s_45_0 as u128, 4u16);
        // C s_45_2: const #13u : u8
        let s_45_2: u8 = 13;
        // C s_45_3: cast zx s_45_2 -> bv
        let s_45_3: Bits = Bits::new(s_45_2 as u128, 4u16);
        // D s_45_4: cmp-eq s_45_1 s_45_3
        let s_45_4: bool = ((s_45_1) == (s_45_3));
        // N s_45_5: branch s_45_4 b5701 b46
        if s_45_4 {
            return block_5701(state, tracer, fn_state);
        } else {
            return block_46(state, tracer, fn_state);
        };
    }
    fn block_46<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_46_0: const #0u : u8
        let s_46_0: bool = false;
        // D s_46_1: write-var gs#134500 <= s_46_0
        fn_state.gs_134500 = s_46_0;
        // N s_46_2: jump b47
        return block_47(state, tracer, fn_state);
    }
    fn block_47<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_47_0: read-var gs#134500:u8
        let s_47_0: bool = fn_state.gs_134500;
        // N s_47_1: branch s_47_0 b5700 b48
        if s_47_0 {
            return block_5700(state, tracer, fn_state);
        } else {
            return block_48(state, tracer, fn_state);
        };
    }
    fn block_48<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_48_0: const #0u : u8
        let s_48_0: bool = false;
        // D s_48_1: write-var gs#134501 <= s_48_0
        fn_state.gs_134501 = s_48_0;
        // N s_48_2: jump b49
        return block_49(state, tracer, fn_state);
    }
    fn block_49<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_49_0: read-var gs#134501:u8
        let s_49_0: bool = fn_state.gs_134501;
        // N s_49_1: branch s_49_0 b5699 b50
        if s_49_0 {
            return block_5699(state, tracer, fn_state);
        } else {
            return block_50(state, tracer, fn_state);
        };
    }
    fn block_50<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_50_0: const #0u : u8
        let s_50_0: bool = false;
        // D s_50_1: write-var gs#134502 <= s_50_0
        fn_state.gs_134502 = s_50_0;
        // N s_50_2: jump b51
        return block_51(state, tracer, fn_state);
    }
    fn block_51<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_51_0: read-var gs#134502:u8
        let s_51_0: bool = fn_state.gs_134502;
        // N s_51_1: branch s_51_0 b5698 b52
        if s_51_0 {
            return block_5698(state, tracer, fn_state);
        } else {
            return block_52(state, tracer, fn_state);
        };
    }
    fn block_52<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_52_0: const #0u : u8
        let s_52_0: bool = false;
        // D s_52_1: write-var gs#134503 <= s_52_0
        fn_state.gs_134503 = s_52_0;
        // N s_52_2: jump b53
        return block_53(state, tracer, fn_state);
    }
    fn block_53<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_53_0: read-var gs#134503:u8
        let s_53_0: bool = fn_state.gs_134503;
        // N s_53_1: branch s_53_0 b5697 b54
        if s_53_0 {
            return block_5697(state, tracer, fn_state);
        } else {
            return block_54(state, tracer, fn_state);
        };
    }
    fn block_54<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_54_0: read-var CRm:u8
        let s_54_0: u8 = fn_state.CRm;
        // D s_54_1: cast zx s_54_0 -> bv
        let s_54_1: Bits = Bits::new(s_54_0 as u128, 4u16);
        // C s_54_2: const #1u : u8
        let s_54_2: u8 = 1;
        // C s_54_3: cast zx s_54_2 -> bv
        let s_54_3: Bits = Bits::new(s_54_2 as u128, 4u16);
        // D s_54_4: cmp-eq s_54_1 s_54_3
        let s_54_4: bool = ((s_54_1) == (s_54_3));
        // N s_54_5: branch s_54_4 b5696 b55
        if s_54_4 {
            return block_5696(state, tracer, fn_state);
        } else {
            return block_55(state, tracer, fn_state);
        };
    }
    fn block_55<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_55_0: const #0u : u8
        let s_55_0: bool = false;
        // D s_55_1: write-var gs#134504 <= s_55_0
        fn_state.gs_134504 = s_55_0;
        // N s_55_2: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_56<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_56_0: read-var gs#134504:u8
        let s_56_0: bool = fn_state.gs_134504;
        // N s_56_1: branch s_56_0 b5695 b57
        if s_56_0 {
            return block_5695(state, tracer, fn_state);
        } else {
            return block_57(state, tracer, fn_state);
        };
    }
    fn block_57<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_57_0: const #0u : u8
        let s_57_0: bool = false;
        // D s_57_1: write-var gs#134505 <= s_57_0
        fn_state.gs_134505 = s_57_0;
        // N s_57_2: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_58<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_58_0: read-var gs#134505:u8
        let s_58_0: bool = fn_state.gs_134505;
        // N s_58_1: branch s_58_0 b5694 b59
        if s_58_0 {
            return block_5694(state, tracer, fn_state);
        } else {
            return block_59(state, tracer, fn_state);
        };
    }
    fn block_59<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_59_0: const #0u : u8
        let s_59_0: bool = false;
        // D s_59_1: write-var gs#134506 <= s_59_0
        fn_state.gs_134506 = s_59_0;
        // N s_59_2: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_60<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_60_0: read-var gs#134506:u8
        let s_60_0: bool = fn_state.gs_134506;
        // N s_60_1: branch s_60_0 b5693 b61
        if s_60_0 {
            return block_5693(state, tracer, fn_state);
        } else {
            return block_61(state, tracer, fn_state);
        };
    }
    fn block_61<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_61_0: const #0u : u8
        let s_61_0: bool = false;
        // D s_61_1: write-var gs#134507 <= s_61_0
        fn_state.gs_134507 = s_61_0;
        // N s_61_2: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_62<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_62_0: read-var gs#134507:u8
        let s_62_0: bool = fn_state.gs_134507;
        // N s_62_1: branch s_62_0 b5692 b63
        if s_62_0 {
            return block_5692(state, tracer, fn_state);
        } else {
            return block_63(state, tracer, fn_state);
        };
    }
    fn block_63<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_63_0: read-var CRm:u8
        let s_63_0: u8 = fn_state.CRm;
        // D s_63_1: cast zx s_63_0 -> bv
        let s_63_1: Bits = Bits::new(s_63_0 as u128, 4u16);
        // C s_63_2: const #3u : u8
        let s_63_2: u8 = 3;
        // C s_63_3: cast zx s_63_2 -> bv
        let s_63_3: Bits = Bits::new(s_63_2 as u128, 4u16);
        // D s_63_4: cmp-eq s_63_1 s_63_3
        let s_63_4: bool = ((s_63_1) == (s_63_3));
        // N s_63_5: branch s_63_4 b5691 b64
        if s_63_4 {
            return block_5691(state, tracer, fn_state);
        } else {
            return block_64(state, tracer, fn_state);
        };
    }
    fn block_64<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_64_0: const #0u : u8
        let s_64_0: bool = false;
        // D s_64_1: write-var gs#134508 <= s_64_0
        fn_state.gs_134508 = s_64_0;
        // N s_64_2: jump b65
        return block_65(state, tracer, fn_state);
    }
    fn block_65<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_65_0: read-var gs#134508:u8
        let s_65_0: bool = fn_state.gs_134508;
        // N s_65_1: branch s_65_0 b5690 b66
        if s_65_0 {
            return block_5690(state, tracer, fn_state);
        } else {
            return block_66(state, tracer, fn_state);
        };
    }
    fn block_66<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_66_0: const #0u : u8
        let s_66_0: bool = false;
        // D s_66_1: write-var gs#134509 <= s_66_0
        fn_state.gs_134509 = s_66_0;
        // N s_66_2: jump b67
        return block_67(state, tracer, fn_state);
    }
    fn block_67<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_67_0: read-var gs#134509:u8
        let s_67_0: bool = fn_state.gs_134509;
        // N s_67_1: branch s_67_0 b5689 b68
        if s_67_0 {
            return block_5689(state, tracer, fn_state);
        } else {
            return block_68(state, tracer, fn_state);
        };
    }
    fn block_68<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_68_0: const #0u : u8
        let s_68_0: bool = false;
        // D s_68_1: write-var gs#134510 <= s_68_0
        fn_state.gs_134510 = s_68_0;
        // N s_68_2: jump b69
        return block_69(state, tracer, fn_state);
    }
    fn block_69<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_69_0: read-var gs#134510:u8
        let s_69_0: bool = fn_state.gs_134510;
        // N s_69_1: branch s_69_0 b5688 b70
        if s_69_0 {
            return block_5688(state, tracer, fn_state);
        } else {
            return block_70(state, tracer, fn_state);
        };
    }
    fn block_70<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_70_0: const #0u : u8
        let s_70_0: bool = false;
        // D s_70_1: write-var gs#134511 <= s_70_0
        fn_state.gs_134511 = s_70_0;
        // N s_70_2: jump b71
        return block_71(state, tracer, fn_state);
    }
    fn block_71<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_71_0: read-var gs#134511:u8
        let s_71_0: bool = fn_state.gs_134511;
        // N s_71_1: branch s_71_0 b5687 b72
        if s_71_0 {
            return block_5687(state, tracer, fn_state);
        } else {
            return block_72(state, tracer, fn_state);
        };
    }
    fn block_72<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_72_0: read-var CRm:u8
        let s_72_0: u8 = fn_state.CRm;
        // D s_72_1: cast zx s_72_0 -> bv
        let s_72_1: Bits = Bits::new(s_72_0 as u128, 4u16);
        // C s_72_2: const #3u : u8
        let s_72_2: u8 = 3;
        // C s_72_3: cast zx s_72_2 -> bv
        let s_72_3: Bits = Bits::new(s_72_2 as u128, 4u16);
        // D s_72_4: cmp-eq s_72_1 s_72_3
        let s_72_4: bool = ((s_72_1) == (s_72_3));
        // N s_72_5: branch s_72_4 b5686 b73
        if s_72_4 {
            return block_5686(state, tracer, fn_state);
        } else {
            return block_73(state, tracer, fn_state);
        };
    }
    fn block_73<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_73_0: const #0u : u8
        let s_73_0: bool = false;
        // D s_73_1: write-var gs#134512 <= s_73_0
        fn_state.gs_134512 = s_73_0;
        // N s_73_2: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_74<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_74_0: read-var gs#134512:u8
        let s_74_0: bool = fn_state.gs_134512;
        // N s_74_1: branch s_74_0 b5685 b75
        if s_74_0 {
            return block_5685(state, tracer, fn_state);
        } else {
            return block_75(state, tracer, fn_state);
        };
    }
    fn block_75<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_75_0: const #0u : u8
        let s_75_0: bool = false;
        // D s_75_1: write-var gs#134513 <= s_75_0
        fn_state.gs_134513 = s_75_0;
        // N s_75_2: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_76<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_76_0: read-var gs#134513:u8
        let s_76_0: bool = fn_state.gs_134513;
        // N s_76_1: branch s_76_0 b5684 b77
        if s_76_0 {
            return block_5684(state, tracer, fn_state);
        } else {
            return block_77(state, tracer, fn_state);
        };
    }
    fn block_77<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_77_0: const #0u : u8
        let s_77_0: bool = false;
        // D s_77_1: write-var gs#134514 <= s_77_0
        fn_state.gs_134514 = s_77_0;
        // N s_77_2: jump b78
        return block_78(state, tracer, fn_state);
    }
    fn block_78<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_78_0: read-var gs#134514:u8
        let s_78_0: bool = fn_state.gs_134514;
        // N s_78_1: branch s_78_0 b5683 b79
        if s_78_0 {
            return block_5683(state, tracer, fn_state);
        } else {
            return block_79(state, tracer, fn_state);
        };
    }
    fn block_79<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_79_0: const #0u : u8
        let s_79_0: bool = false;
        // D s_79_1: write-var gs#134515 <= s_79_0
        fn_state.gs_134515 = s_79_0;
        // N s_79_2: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_80<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_80_0: read-var gs#134515:u8
        let s_80_0: bool = fn_state.gs_134515;
        // N s_80_1: branch s_80_0 b5682 b81
        if s_80_0 {
            return block_5682(state, tracer, fn_state);
        } else {
            return block_81(state, tracer, fn_state);
        };
    }
    fn block_81<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_81_0: read-var CRm:u8
        let s_81_0: u8 = fn_state.CRm;
        // D s_81_1: cast zx s_81_0 -> bv
        let s_81_1: Bits = Bits::new(s_81_0 as u128, 4u16);
        // C s_81_2: const #8u : u8
        let s_81_2: u8 = 8;
        // C s_81_3: cast zx s_81_2 -> bv
        let s_81_3: Bits = Bits::new(s_81_2 as u128, 4u16);
        // D s_81_4: cmp-eq s_81_1 s_81_3
        let s_81_4: bool = ((s_81_1) == (s_81_3));
        // N s_81_5: branch s_81_4 b5681 b82
        if s_81_4 {
            return block_5681(state, tracer, fn_state);
        } else {
            return block_82(state, tracer, fn_state);
        };
    }
    fn block_82<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_82_0: const #0u : u8
        let s_82_0: bool = false;
        // D s_82_1: write-var gs#134516 <= s_82_0
        fn_state.gs_134516 = s_82_0;
        // N s_82_2: jump b83
        return block_83(state, tracer, fn_state);
    }
    fn block_83<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_83_0: read-var gs#134516:u8
        let s_83_0: bool = fn_state.gs_134516;
        // N s_83_1: branch s_83_0 b5680 b84
        if s_83_0 {
            return block_5680(state, tracer, fn_state);
        } else {
            return block_84(state, tracer, fn_state);
        };
    }
    fn block_84<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_84_0: const #0u : u8
        let s_84_0: bool = false;
        // D s_84_1: write-var gs#134517 <= s_84_0
        fn_state.gs_134517 = s_84_0;
        // N s_84_2: jump b85
        return block_85(state, tracer, fn_state);
    }
    fn block_85<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_85_0: read-var gs#134517:u8
        let s_85_0: bool = fn_state.gs_134517;
        // N s_85_1: branch s_85_0 b5679 b86
        if s_85_0 {
            return block_5679(state, tracer, fn_state);
        } else {
            return block_86(state, tracer, fn_state);
        };
    }
    fn block_86<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_86_0: const #0u : u8
        let s_86_0: bool = false;
        // D s_86_1: write-var gs#134518 <= s_86_0
        fn_state.gs_134518 = s_86_0;
        // N s_86_2: jump b87
        return block_87(state, tracer, fn_state);
    }
    fn block_87<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_87_0: read-var gs#134518:u8
        let s_87_0: bool = fn_state.gs_134518;
        // N s_87_1: branch s_87_0 b5678 b88
        if s_87_0 {
            return block_5678(state, tracer, fn_state);
        } else {
            return block_88(state, tracer, fn_state);
        };
    }
    fn block_88<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_88_0: const #0u : u8
        let s_88_0: bool = false;
        // D s_88_1: write-var gs#134519 <= s_88_0
        fn_state.gs_134519 = s_88_0;
        // N s_88_2: jump b89
        return block_89(state, tracer, fn_state);
    }
    fn block_89<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_89_0: read-var gs#134519:u8
        let s_89_0: bool = fn_state.gs_134519;
        // N s_89_1: branch s_89_0 b5677 b90
        if s_89_0 {
            return block_5677(state, tracer, fn_state);
        } else {
            return block_90(state, tracer, fn_state);
        };
    }
    fn block_90<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_90_0: read-var CRm:u8
        let s_90_0: u8 = fn_state.CRm;
        // D s_90_1: cast zx s_90_0 -> bv
        let s_90_1: Bits = Bits::new(s_90_0 as u128, 4u16);
        // C s_90_2: const #1u : u8
        let s_90_2: u8 = 1;
        // C s_90_3: cast zx s_90_2 -> bv
        let s_90_3: Bits = Bits::new(s_90_2 as u128, 4u16);
        // D s_90_4: cmp-eq s_90_1 s_90_3
        let s_90_4: bool = ((s_90_1) == (s_90_3));
        // N s_90_5: branch s_90_4 b5676 b91
        if s_90_4 {
            return block_5676(state, tracer, fn_state);
        } else {
            return block_91(state, tracer, fn_state);
        };
    }
    fn block_91<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_91_0: const #0u : u8
        let s_91_0: bool = false;
        // D s_91_1: write-var gs#134520 <= s_91_0
        fn_state.gs_134520 = s_91_0;
        // N s_91_2: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_92<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_92_0: read-var gs#134520:u8
        let s_92_0: bool = fn_state.gs_134520;
        // N s_92_1: branch s_92_0 b5675 b93
        if s_92_0 {
            return block_5675(state, tracer, fn_state);
        } else {
            return block_93(state, tracer, fn_state);
        };
    }
    fn block_93<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_93_0: const #0u : u8
        let s_93_0: bool = false;
        // D s_93_1: write-var gs#134521 <= s_93_0
        fn_state.gs_134521 = s_93_0;
        // N s_93_2: jump b94
        return block_94(state, tracer, fn_state);
    }
    fn block_94<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_94_0: read-var gs#134521:u8
        let s_94_0: bool = fn_state.gs_134521;
        // N s_94_1: branch s_94_0 b5674 b95
        if s_94_0 {
            return block_5674(state, tracer, fn_state);
        } else {
            return block_95(state, tracer, fn_state);
        };
    }
    fn block_95<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_95_0: const #0u : u8
        let s_95_0: bool = false;
        // D s_95_1: write-var gs#134522 <= s_95_0
        fn_state.gs_134522 = s_95_0;
        // N s_95_2: jump b96
        return block_96(state, tracer, fn_state);
    }
    fn block_96<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_96_0: read-var gs#134522:u8
        let s_96_0: bool = fn_state.gs_134522;
        // N s_96_1: branch s_96_0 b5673 b97
        if s_96_0 {
            return block_5673(state, tracer, fn_state);
        } else {
            return block_97(state, tracer, fn_state);
        };
    }
    fn block_97<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_97_0: const #0u : u8
        let s_97_0: bool = false;
        // D s_97_1: write-var gs#134523 <= s_97_0
        fn_state.gs_134523 = s_97_0;
        // N s_97_2: jump b98
        return block_98(state, tracer, fn_state);
    }
    fn block_98<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_98_0: read-var gs#134523:u8
        let s_98_0: bool = fn_state.gs_134523;
        // N s_98_1: branch s_98_0 b5672 b99
        if s_98_0 {
            return block_5672(state, tracer, fn_state);
        } else {
            return block_99(state, tracer, fn_state);
        };
    }
    fn block_99<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_99_0: read-var CRm:u8
        let s_99_0: u8 = fn_state.CRm;
        // D s_99_1: cast zx s_99_0 -> bv
        let s_99_1: Bits = Bits::new(s_99_0 as u128, 4u16);
        // C s_99_2: const #0u : u8
        let s_99_2: u8 = 0;
        // C s_99_3: cast zx s_99_2 -> bv
        let s_99_3: Bits = Bits::new(s_99_2 as u128, 4u16);
        // D s_99_4: cmp-eq s_99_1 s_99_3
        let s_99_4: bool = ((s_99_1) == (s_99_3));
        // N s_99_5: branch s_99_4 b5671 b100
        if s_99_4 {
            return block_5671(state, tracer, fn_state);
        } else {
            return block_100(state, tracer, fn_state);
        };
    }
    fn block_100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_100_0: const #0u : u8
        let s_100_0: bool = false;
        // D s_100_1: write-var gs#134524 <= s_100_0
        fn_state.gs_134524 = s_100_0;
        // N s_100_2: jump b101
        return block_101(state, tracer, fn_state);
    }
    fn block_101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_101_0: read-var gs#134524:u8
        let s_101_0: bool = fn_state.gs_134524;
        // N s_101_1: branch s_101_0 b5670 b102
        if s_101_0 {
            return block_5670(state, tracer, fn_state);
        } else {
            return block_102(state, tracer, fn_state);
        };
    }
    fn block_102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_102_0: const #0u : u8
        let s_102_0: bool = false;
        // D s_102_1: write-var gs#134525 <= s_102_0
        fn_state.gs_134525 = s_102_0;
        // N s_102_2: jump b103
        return block_103(state, tracer, fn_state);
    }
    fn block_103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_103_0: read-var gs#134525:u8
        let s_103_0: bool = fn_state.gs_134525;
        // N s_103_1: branch s_103_0 b5669 b104
        if s_103_0 {
            return block_5669(state, tracer, fn_state);
        } else {
            return block_104(state, tracer, fn_state);
        };
    }
    fn block_104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_104_0: const #0u : u8
        let s_104_0: bool = false;
        // D s_104_1: write-var gs#134526 <= s_104_0
        fn_state.gs_134526 = s_104_0;
        // N s_104_2: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_105_0: read-var gs#134526:u8
        let s_105_0: bool = fn_state.gs_134526;
        // N s_105_1: branch s_105_0 b5668 b106
        if s_105_0 {
            return block_5668(state, tracer, fn_state);
        } else {
            return block_106(state, tracer, fn_state);
        };
    }
    fn block_106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_106_0: const #0u : u8
        let s_106_0: bool = false;
        // D s_106_1: write-var gs#134527 <= s_106_0
        fn_state.gs_134527 = s_106_0;
        // N s_106_2: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_107_0: read-var gs#134527:u8
        let s_107_0: bool = fn_state.gs_134527;
        // N s_107_1: branch s_107_0 b5667 b108
        if s_107_0 {
            return block_5667(state, tracer, fn_state);
        } else {
            return block_108(state, tracer, fn_state);
        };
    }
    fn block_108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_108_0: read-var CRm:u8
        let s_108_0: u8 = fn_state.CRm;
        // D s_108_1: cast zx s_108_0 -> bv
        let s_108_1: Bits = Bits::new(s_108_0 as u128, 4u16);
        // C s_108_2: const #1u : u8
        let s_108_2: u8 = 1;
        // C s_108_3: cast zx s_108_2 -> bv
        let s_108_3: Bits = Bits::new(s_108_2 as u128, 4u16);
        // D s_108_4: cmp-eq s_108_1 s_108_3
        let s_108_4: bool = ((s_108_1) == (s_108_3));
        // N s_108_5: branch s_108_4 b5666 b109
        if s_108_4 {
            return block_5666(state, tracer, fn_state);
        } else {
            return block_109(state, tracer, fn_state);
        };
    }
    fn block_109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_109_0: const #0u : u8
        let s_109_0: bool = false;
        // D s_109_1: write-var gs#134528 <= s_109_0
        fn_state.gs_134528 = s_109_0;
        // N s_109_2: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_110_0: read-var gs#134528:u8
        let s_110_0: bool = fn_state.gs_134528;
        // N s_110_1: branch s_110_0 b5665 b111
        if s_110_0 {
            return block_5665(state, tracer, fn_state);
        } else {
            return block_111(state, tracer, fn_state);
        };
    }
    fn block_111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_111_0: const #0u : u8
        let s_111_0: bool = false;
        // D s_111_1: write-var gs#134529 <= s_111_0
        fn_state.gs_134529 = s_111_0;
        // N s_111_2: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_112_0: read-var gs#134529:u8
        let s_112_0: bool = fn_state.gs_134529;
        // N s_112_1: branch s_112_0 b5664 b113
        if s_112_0 {
            return block_5664(state, tracer, fn_state);
        } else {
            return block_113(state, tracer, fn_state);
        };
    }
    fn block_113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_113_0: const #0u : u8
        let s_113_0: bool = false;
        // D s_113_1: write-var gs#134530 <= s_113_0
        fn_state.gs_134530 = s_113_0;
        // N s_113_2: jump b114
        return block_114(state, tracer, fn_state);
    }
    fn block_114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_114_0: read-var gs#134530:u8
        let s_114_0: bool = fn_state.gs_134530;
        // N s_114_1: branch s_114_0 b5663 b115
        if s_114_0 {
            return block_5663(state, tracer, fn_state);
        } else {
            return block_115(state, tracer, fn_state);
        };
    }
    fn block_115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_115_0: const #0u : u8
        let s_115_0: bool = false;
        // D s_115_1: write-var gs#134531 <= s_115_0
        fn_state.gs_134531 = s_115_0;
        // N s_115_2: jump b116
        return block_116(state, tracer, fn_state);
    }
    fn block_116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_116_0: read-var gs#134531:u8
        let s_116_0: bool = fn_state.gs_134531;
        // N s_116_1: branch s_116_0 b5662 b117
        if s_116_0 {
            return block_5662(state, tracer, fn_state);
        } else {
            return block_117(state, tracer, fn_state);
        };
    }
    fn block_117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_117_0: read-var CRm:u8
        let s_117_0: u8 = fn_state.CRm;
        // D s_117_1: cast zx s_117_0 -> bv
        let s_117_1: Bits = Bits::new(s_117_0 as u128, 4u16);
        // C s_117_2: const #0u : u8
        let s_117_2: u8 = 0;
        // C s_117_3: cast zx s_117_2 -> bv
        let s_117_3: Bits = Bits::new(s_117_2 as u128, 4u16);
        // D s_117_4: cmp-eq s_117_1 s_117_3
        let s_117_4: bool = ((s_117_1) == (s_117_3));
        // N s_117_5: branch s_117_4 b5661 b118
        if s_117_4 {
            return block_5661(state, tracer, fn_state);
        } else {
            return block_118(state, tracer, fn_state);
        };
    }
    fn block_118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_118_0: const #0u : u8
        let s_118_0: bool = false;
        // D s_118_1: write-var gs#134532 <= s_118_0
        fn_state.gs_134532 = s_118_0;
        // N s_118_2: jump b119
        return block_119(state, tracer, fn_state);
    }
    fn block_119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_119_0: read-var gs#134532:u8
        let s_119_0: bool = fn_state.gs_134532;
        // N s_119_1: branch s_119_0 b5660 b120
        if s_119_0 {
            return block_5660(state, tracer, fn_state);
        } else {
            return block_120(state, tracer, fn_state);
        };
    }
    fn block_120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_120_0: const #0u : u8
        let s_120_0: bool = false;
        // D s_120_1: write-var gs#134533 <= s_120_0
        fn_state.gs_134533 = s_120_0;
        // N s_120_2: jump b121
        return block_121(state, tracer, fn_state);
    }
    fn block_121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_121_0: read-var gs#134533:u8
        let s_121_0: bool = fn_state.gs_134533;
        // N s_121_1: branch s_121_0 b5659 b122
        if s_121_0 {
            return block_5659(state, tracer, fn_state);
        } else {
            return block_122(state, tracer, fn_state);
        };
    }
    fn block_122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_122_0: const #0u : u8
        let s_122_0: bool = false;
        // D s_122_1: write-var gs#134534 <= s_122_0
        fn_state.gs_134534 = s_122_0;
        // N s_122_2: jump b123
        return block_123(state, tracer, fn_state);
    }
    fn block_123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_123_0: read-var gs#134534:u8
        let s_123_0: bool = fn_state.gs_134534;
        // N s_123_1: branch s_123_0 b5658 b124
        if s_123_0 {
            return block_5658(state, tracer, fn_state);
        } else {
            return block_124(state, tracer, fn_state);
        };
    }
    fn block_124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_124_0: const #0u : u8
        let s_124_0: bool = false;
        // D s_124_1: write-var gs#134535 <= s_124_0
        fn_state.gs_134535 = s_124_0;
        // N s_124_2: jump b125
        return block_125(state, tracer, fn_state);
    }
    fn block_125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_125_0: read-var gs#134535:u8
        let s_125_0: bool = fn_state.gs_134535;
        // N s_125_1: branch s_125_0 b5657 b126
        if s_125_0 {
            return block_5657(state, tracer, fn_state);
        } else {
            return block_126(state, tracer, fn_state);
        };
    }
    fn block_126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_126_0: read-var CRm:u8
        let s_126_0: u8 = fn_state.CRm;
        // D s_126_1: cast zx s_126_0 -> bv
        let s_126_1: Bits = Bits::new(s_126_0 as u128, 4u16);
        // C s_126_2: const #1u : u8
        let s_126_2: u8 = 1;
        // C s_126_3: cast zx s_126_2 -> bv
        let s_126_3: Bits = Bits::new(s_126_2 as u128, 4u16);
        // D s_126_4: cmp-eq s_126_1 s_126_3
        let s_126_4: bool = ((s_126_1) == (s_126_3));
        // N s_126_5: branch s_126_4 b5656 b127
        if s_126_4 {
            return block_5656(state, tracer, fn_state);
        } else {
            return block_127(state, tracer, fn_state);
        };
    }
    fn block_127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_127_0: const #0u : u8
        let s_127_0: bool = false;
        // D s_127_1: write-var gs#134536 <= s_127_0
        fn_state.gs_134536 = s_127_0;
        // N s_127_2: jump b128
        return block_128(state, tracer, fn_state);
    }
    fn block_128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_128_0: read-var gs#134536:u8
        let s_128_0: bool = fn_state.gs_134536;
        // N s_128_1: branch s_128_0 b5655 b129
        if s_128_0 {
            return block_5655(state, tracer, fn_state);
        } else {
            return block_129(state, tracer, fn_state);
        };
    }
    fn block_129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_129_0: const #0u : u8
        let s_129_0: bool = false;
        // D s_129_1: write-var gs#134537 <= s_129_0
        fn_state.gs_134537 = s_129_0;
        // N s_129_2: jump b130
        return block_130(state, tracer, fn_state);
    }
    fn block_130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_130_0: read-var gs#134537:u8
        let s_130_0: bool = fn_state.gs_134537;
        // N s_130_1: branch s_130_0 b5654 b131
        if s_130_0 {
            return block_5654(state, tracer, fn_state);
        } else {
            return block_131(state, tracer, fn_state);
        };
    }
    fn block_131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_131_0: const #0u : u8
        let s_131_0: bool = false;
        // D s_131_1: write-var gs#134538 <= s_131_0
        fn_state.gs_134538 = s_131_0;
        // N s_131_2: jump b132
        return block_132(state, tracer, fn_state);
    }
    fn block_132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_132_0: read-var gs#134538:u8
        let s_132_0: bool = fn_state.gs_134538;
        // N s_132_1: branch s_132_0 b5653 b133
        if s_132_0 {
            return block_5653(state, tracer, fn_state);
        } else {
            return block_133(state, tracer, fn_state);
        };
    }
    fn block_133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_133_0: const #0u : u8
        let s_133_0: bool = false;
        // D s_133_1: write-var gs#134539 <= s_133_0
        fn_state.gs_134539 = s_133_0;
        // N s_133_2: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_134_0: read-var gs#134539:u8
        let s_134_0: bool = fn_state.gs_134539;
        // N s_134_1: branch s_134_0 b5652 b135
        if s_134_0 {
            return block_5652(state, tracer, fn_state);
        } else {
            return block_135(state, tracer, fn_state);
        };
    }
    fn block_135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_135_0: read-var CRm:u8
        let s_135_0: u8 = fn_state.CRm;
        // D s_135_1: cast zx s_135_0 -> bv
        let s_135_1: Bits = Bits::new(s_135_0 as u128, 4u16);
        // C s_135_2: const #12u : u8
        let s_135_2: u8 = 12;
        // C s_135_3: cast zx s_135_2 -> bv
        let s_135_3: Bits = Bits::new(s_135_2 as u128, 4u16);
        // D s_135_4: cmp-eq s_135_1 s_135_3
        let s_135_4: bool = ((s_135_1) == (s_135_3));
        // N s_135_5: branch s_135_4 b5651 b136
        if s_135_4 {
            return block_5651(state, tracer, fn_state);
        } else {
            return block_136(state, tracer, fn_state);
        };
    }
    fn block_136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_136_0: const #0u : u8
        let s_136_0: bool = false;
        // D s_136_1: write-var gs#134540 <= s_136_0
        fn_state.gs_134540 = s_136_0;
        // N s_136_2: jump b137
        return block_137(state, tracer, fn_state);
    }
    fn block_137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_137_0: read-var gs#134540:u8
        let s_137_0: bool = fn_state.gs_134540;
        // N s_137_1: branch s_137_0 b5650 b138
        if s_137_0 {
            return block_5650(state, tracer, fn_state);
        } else {
            return block_138(state, tracer, fn_state);
        };
    }
    fn block_138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_138_0: const #0u : u8
        let s_138_0: bool = false;
        // D s_138_1: write-var gs#134541 <= s_138_0
        fn_state.gs_134541 = s_138_0;
        // N s_138_2: jump b139
        return block_139(state, tracer, fn_state);
    }
    fn block_139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_139_0: read-var gs#134541:u8
        let s_139_0: bool = fn_state.gs_134541;
        // N s_139_1: branch s_139_0 b5649 b140
        if s_139_0 {
            return block_5649(state, tracer, fn_state);
        } else {
            return block_140(state, tracer, fn_state);
        };
    }
    fn block_140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_140_0: const #0u : u8
        let s_140_0: bool = false;
        // D s_140_1: write-var gs#134542 <= s_140_0
        fn_state.gs_134542 = s_140_0;
        // N s_140_2: jump b141
        return block_141(state, tracer, fn_state);
    }
    fn block_141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_141_0: read-var gs#134542:u8
        let s_141_0: bool = fn_state.gs_134542;
        // N s_141_1: branch s_141_0 b5648 b142
        if s_141_0 {
            return block_5648(state, tracer, fn_state);
        } else {
            return block_142(state, tracer, fn_state);
        };
    }
    fn block_142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_142_0: const #0u : u8
        let s_142_0: bool = false;
        // D s_142_1: write-var gs#134543 <= s_142_0
        fn_state.gs_134543 = s_142_0;
        // N s_142_2: jump b143
        return block_143(state, tracer, fn_state);
    }
    fn block_143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_143_0: read-var gs#134543:u8
        let s_143_0: bool = fn_state.gs_134543;
        // N s_143_1: branch s_143_0 b5647 b144
        if s_143_0 {
            return block_5647(state, tracer, fn_state);
        } else {
            return block_144(state, tracer, fn_state);
        };
    }
    fn block_144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_144_0: read-var CRm:u8
        let s_144_0: u8 = fn_state.CRm;
        // D s_144_1: cast zx s_144_0 -> bv
        let s_144_1: Bits = Bits::new(s_144_0 as u128, 4u16);
        // C s_144_2: const #12u : u8
        let s_144_2: u8 = 12;
        // C s_144_3: cast zx s_144_2 -> bv
        let s_144_3: Bits = Bits::new(s_144_2 as u128, 4u16);
        // D s_144_4: cmp-eq s_144_1 s_144_3
        let s_144_4: bool = ((s_144_1) == (s_144_3));
        // N s_144_5: branch s_144_4 b5646 b145
        if s_144_4 {
            return block_5646(state, tracer, fn_state);
        } else {
            return block_145(state, tracer, fn_state);
        };
    }
    fn block_145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_145_0: const #0u : u8
        let s_145_0: bool = false;
        // D s_145_1: write-var gs#134544 <= s_145_0
        fn_state.gs_134544 = s_145_0;
        // N s_145_2: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_146_0: read-var gs#134544:u8
        let s_146_0: bool = fn_state.gs_134544;
        // N s_146_1: branch s_146_0 b5645 b147
        if s_146_0 {
            return block_5645(state, tracer, fn_state);
        } else {
            return block_147(state, tracer, fn_state);
        };
    }
    fn block_147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_147_0: const #0u : u8
        let s_147_0: bool = false;
        // D s_147_1: write-var gs#134545 <= s_147_0
        fn_state.gs_134545 = s_147_0;
        // N s_147_2: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_148_0: read-var gs#134545:u8
        let s_148_0: bool = fn_state.gs_134545;
        // N s_148_1: branch s_148_0 b5644 b149
        if s_148_0 {
            return block_5644(state, tracer, fn_state);
        } else {
            return block_149(state, tracer, fn_state);
        };
    }
    fn block_149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_149_0: const #0u : u8
        let s_149_0: bool = false;
        // D s_149_1: write-var gs#134546 <= s_149_0
        fn_state.gs_134546 = s_149_0;
        // N s_149_2: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_150_0: read-var gs#134546:u8
        let s_150_0: bool = fn_state.gs_134546;
        // N s_150_1: branch s_150_0 b5643 b151
        if s_150_0 {
            return block_5643(state, tracer, fn_state);
        } else {
            return block_151(state, tracer, fn_state);
        };
    }
    fn block_151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_151_0: const #0u : u8
        let s_151_0: bool = false;
        // D s_151_1: write-var gs#134547 <= s_151_0
        fn_state.gs_134547 = s_151_0;
        // N s_151_2: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_152_0: read-var gs#134547:u8
        let s_152_0: bool = fn_state.gs_134547;
        // N s_152_1: branch s_152_0 b5642 b153
        if s_152_0 {
            return block_5642(state, tracer, fn_state);
        } else {
            return block_153(state, tracer, fn_state);
        };
    }
    fn block_153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_153_0: read-var CRm:u8
        let s_153_0: u8 = fn_state.CRm;
        // D s_153_1: cast zx s_153_0 -> bv
        let s_153_1: Bits = Bits::new(s_153_0 as u128, 4u16);
        // C s_153_2: const #14u : u8
        let s_153_2: u8 = 14;
        // C s_153_3: cast zx s_153_2 -> bv
        let s_153_3: Bits = Bits::new(s_153_2 as u128, 4u16);
        // D s_153_4: cmp-eq s_153_1 s_153_3
        let s_153_4: bool = ((s_153_1) == (s_153_3));
        // N s_153_5: branch s_153_4 b5641 b154
        if s_153_4 {
            return block_5641(state, tracer, fn_state);
        } else {
            return block_154(state, tracer, fn_state);
        };
    }
    fn block_154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_154_0: const #0u : u8
        let s_154_0: bool = false;
        // D s_154_1: write-var gs#134548 <= s_154_0
        fn_state.gs_134548 = s_154_0;
        // N s_154_2: jump b155
        return block_155(state, tracer, fn_state);
    }
    fn block_155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_155_0: read-var gs#134548:u8
        let s_155_0: bool = fn_state.gs_134548;
        // N s_155_1: branch s_155_0 b5640 b156
        if s_155_0 {
            return block_5640(state, tracer, fn_state);
        } else {
            return block_156(state, tracer, fn_state);
        };
    }
    fn block_156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_156_0: const #0u : u8
        let s_156_0: bool = false;
        // D s_156_1: write-var gs#134549 <= s_156_0
        fn_state.gs_134549 = s_156_0;
        // N s_156_2: jump b157
        return block_157(state, tracer, fn_state);
    }
    fn block_157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_157_0: read-var gs#134549:u8
        let s_157_0: bool = fn_state.gs_134549;
        // N s_157_1: branch s_157_0 b5639 b158
        if s_157_0 {
            return block_5639(state, tracer, fn_state);
        } else {
            return block_158(state, tracer, fn_state);
        };
    }
    fn block_158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_158_0: const #0u : u8
        let s_158_0: bool = false;
        // D s_158_1: write-var gs#134550 <= s_158_0
        fn_state.gs_134550 = s_158_0;
        // N s_158_2: jump b159
        return block_159(state, tracer, fn_state);
    }
    fn block_159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_159_0: read-var gs#134550:u8
        let s_159_0: bool = fn_state.gs_134550;
        // N s_159_1: branch s_159_0 b5638 b160
        if s_159_0 {
            return block_5638(state, tracer, fn_state);
        } else {
            return block_160(state, tracer, fn_state);
        };
    }
    fn block_160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_160_0: const #0u : u8
        let s_160_0: bool = false;
        // D s_160_1: write-var gs#134551 <= s_160_0
        fn_state.gs_134551 = s_160_0;
        // N s_160_2: jump b161
        return block_161(state, tracer, fn_state);
    }
    fn block_161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_161_0: read-var gs#134551:u8
        let s_161_0: bool = fn_state.gs_134551;
        // N s_161_1: branch s_161_0 b5637 b162
        if s_161_0 {
            return block_5637(state, tracer, fn_state);
        } else {
            return block_162(state, tracer, fn_state);
        };
    }
    fn block_162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_162_0: read-var CRm:u8
        let s_162_0: u8 = fn_state.CRm;
        // D s_162_1: cast zx s_162_0 -> bv
        let s_162_1: Bits = Bits::new(s_162_0 as u128, 4u16);
        // C s_162_2: const #2u : u8
        let s_162_2: u8 = 2;
        // C s_162_3: cast zx s_162_2 -> bv
        let s_162_3: Bits = Bits::new(s_162_2 as u128, 4u16);
        // D s_162_4: cmp-eq s_162_1 s_162_3
        let s_162_4: bool = ((s_162_1) == (s_162_3));
        // N s_162_5: branch s_162_4 b5636 b163
        if s_162_4 {
            return block_5636(state, tracer, fn_state);
        } else {
            return block_163(state, tracer, fn_state);
        };
    }
    fn block_163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_163_0: const #0u : u8
        let s_163_0: bool = false;
        // D s_163_1: write-var gs#134552 <= s_163_0
        fn_state.gs_134552 = s_163_0;
        // N s_163_2: jump b164
        return block_164(state, tracer, fn_state);
    }
    fn block_164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_164_0: read-var gs#134552:u8
        let s_164_0: bool = fn_state.gs_134552;
        // N s_164_1: branch s_164_0 b5635 b165
        if s_164_0 {
            return block_5635(state, tracer, fn_state);
        } else {
            return block_165(state, tracer, fn_state);
        };
    }
    fn block_165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_165_0: const #0u : u8
        let s_165_0: bool = false;
        // D s_165_1: write-var gs#134553 <= s_165_0
        fn_state.gs_134553 = s_165_0;
        // N s_165_2: jump b166
        return block_166(state, tracer, fn_state);
    }
    fn block_166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_166_0: read-var gs#134553:u8
        let s_166_0: bool = fn_state.gs_134553;
        // N s_166_1: branch s_166_0 b5634 b167
        if s_166_0 {
            return block_5634(state, tracer, fn_state);
        } else {
            return block_167(state, tracer, fn_state);
        };
    }
    fn block_167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_167_0: const #0u : u8
        let s_167_0: bool = false;
        // D s_167_1: write-var gs#134554 <= s_167_0
        fn_state.gs_134554 = s_167_0;
        // N s_167_2: jump b168
        return block_168(state, tracer, fn_state);
    }
    fn block_168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_168_0: read-var gs#134554:u8
        let s_168_0: bool = fn_state.gs_134554;
        // N s_168_1: branch s_168_0 b5633 b169
        if s_168_0 {
            return block_5633(state, tracer, fn_state);
        } else {
            return block_169(state, tracer, fn_state);
        };
    }
    fn block_169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_169_0: const #0u : u8
        let s_169_0: bool = false;
        // D s_169_1: write-var gs#134555 <= s_169_0
        fn_state.gs_134555 = s_169_0;
        // N s_169_2: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_170_0: read-var gs#134555:u8
        let s_170_0: bool = fn_state.gs_134555;
        // N s_170_1: branch s_170_0 b5632 b171
        if s_170_0 {
            return block_5632(state, tracer, fn_state);
        } else {
            return block_171(state, tracer, fn_state);
        };
    }
    fn block_171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_171_0: read-var CRm:u8
        let s_171_0: u8 = fn_state.CRm;
        // D s_171_1: cast zx s_171_0 -> bv
        let s_171_1: Bits = Bits::new(s_171_0 as u128, 4u16);
        // C s_171_2: const #15u : u8
        let s_171_2: u8 = 15;
        // C s_171_3: cast zx s_171_2 -> bv
        let s_171_3: Bits = Bits::new(s_171_2 as u128, 4u16);
        // D s_171_4: cmp-eq s_171_1 s_171_3
        let s_171_4: bool = ((s_171_1) == (s_171_3));
        // N s_171_5: branch s_171_4 b5631 b172
        if s_171_4 {
            return block_5631(state, tracer, fn_state);
        } else {
            return block_172(state, tracer, fn_state);
        };
    }
    fn block_172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_172_0: const #0u : u8
        let s_172_0: bool = false;
        // D s_172_1: write-var gs#134556 <= s_172_0
        fn_state.gs_134556 = s_172_0;
        // N s_172_2: jump b173
        return block_173(state, tracer, fn_state);
    }
    fn block_173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_173_0: read-var gs#134556:u8
        let s_173_0: bool = fn_state.gs_134556;
        // N s_173_1: branch s_173_0 b5630 b174
        if s_173_0 {
            return block_5630(state, tracer, fn_state);
        } else {
            return block_174(state, tracer, fn_state);
        };
    }
    fn block_174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_174_0: const #0u : u8
        let s_174_0: bool = false;
        // D s_174_1: write-var gs#134557 <= s_174_0
        fn_state.gs_134557 = s_174_0;
        // N s_174_2: jump b175
        return block_175(state, tracer, fn_state);
    }
    fn block_175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_175_0: read-var gs#134557:u8
        let s_175_0: bool = fn_state.gs_134557;
        // N s_175_1: branch s_175_0 b5629 b176
        if s_175_0 {
            return block_5629(state, tracer, fn_state);
        } else {
            return block_176(state, tracer, fn_state);
        };
    }
    fn block_176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_176_0: const #0u : u8
        let s_176_0: bool = false;
        // D s_176_1: write-var gs#134558 <= s_176_0
        fn_state.gs_134558 = s_176_0;
        // N s_176_2: jump b177
        return block_177(state, tracer, fn_state);
    }
    fn block_177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_177_0: read-var gs#134558:u8
        let s_177_0: bool = fn_state.gs_134558;
        // N s_177_1: branch s_177_0 b5628 b178
        if s_177_0 {
            return block_5628(state, tracer, fn_state);
        } else {
            return block_178(state, tracer, fn_state);
        };
    }
    fn block_178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_178_0: const #0u : u8
        let s_178_0: bool = false;
        // D s_178_1: write-var gs#134559 <= s_178_0
        fn_state.gs_134559 = s_178_0;
        // N s_178_2: jump b179
        return block_179(state, tracer, fn_state);
    }
    fn block_179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_179_0: read-var gs#134559:u8
        let s_179_0: bool = fn_state.gs_134559;
        // N s_179_1: branch s_179_0 b5627 b180
        if s_179_0 {
            return block_5627(state, tracer, fn_state);
        } else {
            return block_180(state, tracer, fn_state);
        };
    }
    fn block_180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_180_0: read-var CRm:u8
        let s_180_0: u8 = fn_state.CRm;
        // D s_180_1: cast zx s_180_0 -> bv
        let s_180_1: Bits = Bits::new(s_180_0 as u128, 4u16);
        // C s_180_2: const #14u : u8
        let s_180_2: u8 = 14;
        // C s_180_3: cast zx s_180_2 -> bv
        let s_180_3: Bits = Bits::new(s_180_2 as u128, 4u16);
        // D s_180_4: cmp-eq s_180_1 s_180_3
        let s_180_4: bool = ((s_180_1) == (s_180_3));
        // N s_180_5: branch s_180_4 b5626 b181
        if s_180_4 {
            return block_5626(state, tracer, fn_state);
        } else {
            return block_181(state, tracer, fn_state);
        };
    }
    fn block_181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_181_0: const #0u : u8
        let s_181_0: bool = false;
        // D s_181_1: write-var gs#134560 <= s_181_0
        fn_state.gs_134560 = s_181_0;
        // N s_181_2: jump b182
        return block_182(state, tracer, fn_state);
    }
    fn block_182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_182_0: read-var gs#134560:u8
        let s_182_0: bool = fn_state.gs_134560;
        // N s_182_1: branch s_182_0 b5625 b183
        if s_182_0 {
            return block_5625(state, tracer, fn_state);
        } else {
            return block_183(state, tracer, fn_state);
        };
    }
    fn block_183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_183_0: const #0u : u8
        let s_183_0: bool = false;
        // D s_183_1: write-var gs#134561 <= s_183_0
        fn_state.gs_134561 = s_183_0;
        // N s_183_2: jump b184
        return block_184(state, tracer, fn_state);
    }
    fn block_184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_184_0: read-var gs#134561:u8
        let s_184_0: bool = fn_state.gs_134561;
        // N s_184_1: branch s_184_0 b5624 b185
        if s_184_0 {
            return block_5624(state, tracer, fn_state);
        } else {
            return block_185(state, tracer, fn_state);
        };
    }
    fn block_185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_185_0: const #0u : u8
        let s_185_0: bool = false;
        // D s_185_1: write-var gs#134562 <= s_185_0
        fn_state.gs_134562 = s_185_0;
        // N s_185_2: jump b186
        return block_186(state, tracer, fn_state);
    }
    fn block_186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_186_0: read-var gs#134562:u8
        let s_186_0: bool = fn_state.gs_134562;
        // N s_186_1: branch s_186_0 b5623 b187
        if s_186_0 {
            return block_5623(state, tracer, fn_state);
        } else {
            return block_187(state, tracer, fn_state);
        };
    }
    fn block_187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_187_0: const #0u : u8
        let s_187_0: bool = false;
        // D s_187_1: write-var gs#134563 <= s_187_0
        fn_state.gs_134563 = s_187_0;
        // N s_187_2: jump b188
        return block_188(state, tracer, fn_state);
    }
    fn block_188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_188_0: read-var gs#134563:u8
        let s_188_0: bool = fn_state.gs_134563;
        // N s_188_1: branch s_188_0 b5622 b189
        if s_188_0 {
            return block_5622(state, tracer, fn_state);
        } else {
            return block_189(state, tracer, fn_state);
        };
    }
    fn block_189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_189_0: read-var CRm:u8
        let s_189_0: u8 = fn_state.CRm;
        // D s_189_1: cast zx s_189_0 -> bv
        let s_189_1: Bits = Bits::new(s_189_0 as u128, 4u16);
        // C s_189_2: const #13u : u8
        let s_189_2: u8 = 13;
        // C s_189_3: cast zx s_189_2 -> bv
        let s_189_3: Bits = Bits::new(s_189_2 as u128, 4u16);
        // D s_189_4: cmp-eq s_189_1 s_189_3
        let s_189_4: bool = ((s_189_1) == (s_189_3));
        // N s_189_5: branch s_189_4 b5621 b190
        if s_189_4 {
            return block_5621(state, tracer, fn_state);
        } else {
            return block_190(state, tracer, fn_state);
        };
    }
    fn block_190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_190_0: const #0u : u8
        let s_190_0: bool = false;
        // D s_190_1: write-var gs#134564 <= s_190_0
        fn_state.gs_134564 = s_190_0;
        // N s_190_2: jump b191
        return block_191(state, tracer, fn_state);
    }
    fn block_191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_191_0: read-var gs#134564:u8
        let s_191_0: bool = fn_state.gs_134564;
        // N s_191_1: branch s_191_0 b5620 b192
        if s_191_0 {
            return block_5620(state, tracer, fn_state);
        } else {
            return block_192(state, tracer, fn_state);
        };
    }
    fn block_192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_192_0: const #0u : u8
        let s_192_0: bool = false;
        // D s_192_1: write-var gs#134565 <= s_192_0
        fn_state.gs_134565 = s_192_0;
        // N s_192_2: jump b193
        return block_193(state, tracer, fn_state);
    }
    fn block_193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_193_0: read-var gs#134565:u8
        let s_193_0: bool = fn_state.gs_134565;
        // N s_193_1: branch s_193_0 b5619 b194
        if s_193_0 {
            return block_5619(state, tracer, fn_state);
        } else {
            return block_194(state, tracer, fn_state);
        };
    }
    fn block_194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_194_0: const #0u : u8
        let s_194_0: bool = false;
        // D s_194_1: write-var gs#134566 <= s_194_0
        fn_state.gs_134566 = s_194_0;
        // N s_194_2: jump b195
        return block_195(state, tracer, fn_state);
    }
    fn block_195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_195_0: read-var gs#134566:u8
        let s_195_0: bool = fn_state.gs_134566;
        // N s_195_1: branch s_195_0 b5618 b196
        if s_195_0 {
            return block_5618(state, tracer, fn_state);
        } else {
            return block_196(state, tracer, fn_state);
        };
    }
    fn block_196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_196_0: const #0u : u8
        let s_196_0: bool = false;
        // D s_196_1: write-var gs#134567 <= s_196_0
        fn_state.gs_134567 = s_196_0;
        // N s_196_2: jump b197
        return block_197(state, tracer, fn_state);
    }
    fn block_197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_197_0: read-var gs#134567:u8
        let s_197_0: bool = fn_state.gs_134567;
        // N s_197_1: branch s_197_0 b5617 b198
        if s_197_0 {
            return block_5617(state, tracer, fn_state);
        } else {
            return block_198(state, tracer, fn_state);
        };
    }
    fn block_198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_198_0: read-var CRm:u8
        let s_198_0: u8 = fn_state.CRm;
        // D s_198_1: cast zx s_198_0 -> bv
        let s_198_1: Bits = Bits::new(s_198_0 as u128, 4u16);
        // C s_198_2: const #12u : u8
        let s_198_2: u8 = 12;
        // C s_198_3: cast zx s_198_2 -> bv
        let s_198_3: Bits = Bits::new(s_198_2 as u128, 4u16);
        // D s_198_4: cmp-eq s_198_1 s_198_3
        let s_198_4: bool = ((s_198_1) == (s_198_3));
        // N s_198_5: branch s_198_4 b5616 b199
        if s_198_4 {
            return block_5616(state, tracer, fn_state);
        } else {
            return block_199(state, tracer, fn_state);
        };
    }
    fn block_199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_199_0: const #0u : u8
        let s_199_0: bool = false;
        // D s_199_1: write-var gs#134568 <= s_199_0
        fn_state.gs_134568 = s_199_0;
        // N s_199_2: jump b200
        return block_200(state, tracer, fn_state);
    }
    fn block_200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_200_0: read-var gs#134568:u8
        let s_200_0: bool = fn_state.gs_134568;
        // N s_200_1: branch s_200_0 b5615 b201
        if s_200_0 {
            return block_5615(state, tracer, fn_state);
        } else {
            return block_201(state, tracer, fn_state);
        };
    }
    fn block_201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_201_0: const #0u : u8
        let s_201_0: bool = false;
        // D s_201_1: write-var gs#134569 <= s_201_0
        fn_state.gs_134569 = s_201_0;
        // N s_201_2: jump b202
        return block_202(state, tracer, fn_state);
    }
    fn block_202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_202_0: read-var gs#134569:u8
        let s_202_0: bool = fn_state.gs_134569;
        // N s_202_1: branch s_202_0 b5614 b203
        if s_202_0 {
            return block_5614(state, tracer, fn_state);
        } else {
            return block_203(state, tracer, fn_state);
        };
    }
    fn block_203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_203_0: const #0u : u8
        let s_203_0: bool = false;
        // D s_203_1: write-var gs#134570 <= s_203_0
        fn_state.gs_134570 = s_203_0;
        // N s_203_2: jump b204
        return block_204(state, tracer, fn_state);
    }
    fn block_204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_204_0: read-var gs#134570:u8
        let s_204_0: bool = fn_state.gs_134570;
        // N s_204_1: branch s_204_0 b5613 b205
        if s_204_0 {
            return block_5613(state, tracer, fn_state);
        } else {
            return block_205(state, tracer, fn_state);
        };
    }
    fn block_205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_205_0: const #0u : u8
        let s_205_0: bool = false;
        // D s_205_1: write-var gs#134571 <= s_205_0
        fn_state.gs_134571 = s_205_0;
        // N s_205_2: jump b206
        return block_206(state, tracer, fn_state);
    }
    fn block_206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_206_0: read-var gs#134571:u8
        let s_206_0: bool = fn_state.gs_134571;
        // N s_206_1: branch s_206_0 b5612 b207
        if s_206_0 {
            return block_5612(state, tracer, fn_state);
        } else {
            return block_207(state, tracer, fn_state);
        };
    }
    fn block_207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_207_0: read-var CRm:u8
        let s_207_0: u8 = fn_state.CRm;
        // D s_207_1: cast zx s_207_0 -> bv
        let s_207_1: Bits = Bits::new(s_207_0 as u128, 4u16);
        // C s_207_2: const #11u : u8
        let s_207_2: u8 = 11;
        // C s_207_3: cast zx s_207_2 -> bv
        let s_207_3: Bits = Bits::new(s_207_2 as u128, 4u16);
        // D s_207_4: cmp-eq s_207_1 s_207_3
        let s_207_4: bool = ((s_207_1) == (s_207_3));
        // N s_207_5: branch s_207_4 b5611 b208
        if s_207_4 {
            return block_5611(state, tracer, fn_state);
        } else {
            return block_208(state, tracer, fn_state);
        };
    }
    fn block_208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_208_0: const #0u : u8
        let s_208_0: bool = false;
        // D s_208_1: write-var gs#134572 <= s_208_0
        fn_state.gs_134572 = s_208_0;
        // N s_208_2: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_209_0: read-var gs#134572:u8
        let s_209_0: bool = fn_state.gs_134572;
        // N s_209_1: branch s_209_0 b5610 b210
        if s_209_0 {
            return block_5610(state, tracer, fn_state);
        } else {
            return block_210(state, tracer, fn_state);
        };
    }
    fn block_210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_210_0: const #0u : u8
        let s_210_0: bool = false;
        // D s_210_1: write-var gs#134573 <= s_210_0
        fn_state.gs_134573 = s_210_0;
        // N s_210_2: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_211_0: read-var gs#134573:u8
        let s_211_0: bool = fn_state.gs_134573;
        // N s_211_1: branch s_211_0 b5609 b212
        if s_211_0 {
            return block_5609(state, tracer, fn_state);
        } else {
            return block_212(state, tracer, fn_state);
        };
    }
    fn block_212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_212_0: const #0u : u8
        let s_212_0: bool = false;
        // D s_212_1: write-var gs#134574 <= s_212_0
        fn_state.gs_134574 = s_212_0;
        // N s_212_2: jump b213
        return block_213(state, tracer, fn_state);
    }
    fn block_213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_213_0: read-var gs#134574:u8
        let s_213_0: bool = fn_state.gs_134574;
        // N s_213_1: branch s_213_0 b5608 b214
        if s_213_0 {
            return block_5608(state, tracer, fn_state);
        } else {
            return block_214(state, tracer, fn_state);
        };
    }
    fn block_214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_214_0: const #0u : u8
        let s_214_0: bool = false;
        // D s_214_1: write-var gs#134575 <= s_214_0
        fn_state.gs_134575 = s_214_0;
        // N s_214_2: jump b215
        return block_215(state, tracer, fn_state);
    }
    fn block_215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_215_0: read-var gs#134575:u8
        let s_215_0: bool = fn_state.gs_134575;
        // N s_215_1: branch s_215_0 b5607 b216
        if s_215_0 {
            return block_5607(state, tracer, fn_state);
        } else {
            return block_216(state, tracer, fn_state);
        };
    }
    fn block_216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_216_0: read-var CRm:u8
        let s_216_0: u8 = fn_state.CRm;
        // D s_216_1: cast zx s_216_0 -> bv
        let s_216_1: Bits = Bits::new(s_216_0 as u128, 4u16);
        // C s_216_2: const #10u : u8
        let s_216_2: u8 = 10;
        // C s_216_3: cast zx s_216_2 -> bv
        let s_216_3: Bits = Bits::new(s_216_2 as u128, 4u16);
        // D s_216_4: cmp-eq s_216_1 s_216_3
        let s_216_4: bool = ((s_216_1) == (s_216_3));
        // N s_216_5: branch s_216_4 b5606 b217
        if s_216_4 {
            return block_5606(state, tracer, fn_state);
        } else {
            return block_217(state, tracer, fn_state);
        };
    }
    fn block_217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_217_0: const #0u : u8
        let s_217_0: bool = false;
        // D s_217_1: write-var gs#134576 <= s_217_0
        fn_state.gs_134576 = s_217_0;
        // N s_217_2: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_218_0: read-var gs#134576:u8
        let s_218_0: bool = fn_state.gs_134576;
        // N s_218_1: branch s_218_0 b5605 b219
        if s_218_0 {
            return block_5605(state, tracer, fn_state);
        } else {
            return block_219(state, tracer, fn_state);
        };
    }
    fn block_219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_219_0: const #0u : u8
        let s_219_0: bool = false;
        // D s_219_1: write-var gs#134577 <= s_219_0
        fn_state.gs_134577 = s_219_0;
        // N s_219_2: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_220_0: read-var gs#134577:u8
        let s_220_0: bool = fn_state.gs_134577;
        // N s_220_1: branch s_220_0 b5604 b221
        if s_220_0 {
            return block_5604(state, tracer, fn_state);
        } else {
            return block_221(state, tracer, fn_state);
        };
    }
    fn block_221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_221_0: const #0u : u8
        let s_221_0: bool = false;
        // D s_221_1: write-var gs#134578 <= s_221_0
        fn_state.gs_134578 = s_221_0;
        // N s_221_2: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_222_0: read-var gs#134578:u8
        let s_222_0: bool = fn_state.gs_134578;
        // N s_222_1: branch s_222_0 b5603 b223
        if s_222_0 {
            return block_5603(state, tracer, fn_state);
        } else {
            return block_223(state, tracer, fn_state);
        };
    }
    fn block_223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_223_0: const #0u : u8
        let s_223_0: bool = false;
        // D s_223_1: write-var gs#134579 <= s_223_0
        fn_state.gs_134579 = s_223_0;
        // N s_223_2: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_224_0: read-var gs#134579:u8
        let s_224_0: bool = fn_state.gs_134579;
        // N s_224_1: branch s_224_0 b5602 b225
        if s_224_0 {
            return block_5602(state, tracer, fn_state);
        } else {
            return block_225(state, tracer, fn_state);
        };
    }
    fn block_225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_225_0: read-var CRm:u8
        let s_225_0: u8 = fn_state.CRm;
        // D s_225_1: cast zx s_225_0 -> bv
        let s_225_1: Bits = Bits::new(s_225_0 as u128, 4u16);
        // C s_225_2: const #9u : u8
        let s_225_2: u8 = 9;
        // C s_225_3: cast zx s_225_2 -> bv
        let s_225_3: Bits = Bits::new(s_225_2 as u128, 4u16);
        // D s_225_4: cmp-eq s_225_1 s_225_3
        let s_225_4: bool = ((s_225_1) == (s_225_3));
        // N s_225_5: branch s_225_4 b5601 b226
        if s_225_4 {
            return block_5601(state, tracer, fn_state);
        } else {
            return block_226(state, tracer, fn_state);
        };
    }
    fn block_226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_226_0: const #0u : u8
        let s_226_0: bool = false;
        // D s_226_1: write-var gs#134580 <= s_226_0
        fn_state.gs_134580 = s_226_0;
        // N s_226_2: jump b227
        return block_227(state, tracer, fn_state);
    }
    fn block_227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_227_0: read-var gs#134580:u8
        let s_227_0: bool = fn_state.gs_134580;
        // N s_227_1: branch s_227_0 b5600 b228
        if s_227_0 {
            return block_5600(state, tracer, fn_state);
        } else {
            return block_228(state, tracer, fn_state);
        };
    }
    fn block_228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_228_0: const #0u : u8
        let s_228_0: bool = false;
        // D s_228_1: write-var gs#134581 <= s_228_0
        fn_state.gs_134581 = s_228_0;
        // N s_228_2: jump b229
        return block_229(state, tracer, fn_state);
    }
    fn block_229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_229_0: read-var gs#134581:u8
        let s_229_0: bool = fn_state.gs_134581;
        // N s_229_1: branch s_229_0 b5599 b230
        if s_229_0 {
            return block_5599(state, tracer, fn_state);
        } else {
            return block_230(state, tracer, fn_state);
        };
    }
    fn block_230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_230_0: const #0u : u8
        let s_230_0: bool = false;
        // D s_230_1: write-var gs#134582 <= s_230_0
        fn_state.gs_134582 = s_230_0;
        // N s_230_2: jump b231
        return block_231(state, tracer, fn_state);
    }
    fn block_231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_231_0: read-var gs#134582:u8
        let s_231_0: bool = fn_state.gs_134582;
        // N s_231_1: branch s_231_0 b5598 b232
        if s_231_0 {
            return block_5598(state, tracer, fn_state);
        } else {
            return block_232(state, tracer, fn_state);
        };
    }
    fn block_232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_232_0: const #0u : u8
        let s_232_0: bool = false;
        // D s_232_1: write-var gs#134583 <= s_232_0
        fn_state.gs_134583 = s_232_0;
        // N s_232_2: jump b233
        return block_233(state, tracer, fn_state);
    }
    fn block_233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_233_0: read-var gs#134583:u8
        let s_233_0: bool = fn_state.gs_134583;
        // N s_233_1: branch s_233_0 b5597 b234
        if s_233_0 {
            return block_5597(state, tracer, fn_state);
        } else {
            return block_234(state, tracer, fn_state);
        };
    }
    fn block_234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_234_0: read-var CRm:u8
        let s_234_0: u8 = fn_state.CRm;
        // D s_234_1: cast zx s_234_0 -> bv
        let s_234_1: Bits = Bits::new(s_234_0 as u128, 4u16);
        // C s_234_2: const #8u : u8
        let s_234_2: u8 = 8;
        // C s_234_3: cast zx s_234_2 -> bv
        let s_234_3: Bits = Bits::new(s_234_2 as u128, 4u16);
        // D s_234_4: cmp-eq s_234_1 s_234_3
        let s_234_4: bool = ((s_234_1) == (s_234_3));
        // N s_234_5: branch s_234_4 b5596 b235
        if s_234_4 {
            return block_5596(state, tracer, fn_state);
        } else {
            return block_235(state, tracer, fn_state);
        };
    }
    fn block_235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_235_0: const #0u : u8
        let s_235_0: bool = false;
        // D s_235_1: write-var gs#134584 <= s_235_0
        fn_state.gs_134584 = s_235_0;
        // N s_235_2: jump b236
        return block_236(state, tracer, fn_state);
    }
    fn block_236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_236_0: read-var gs#134584:u8
        let s_236_0: bool = fn_state.gs_134584;
        // N s_236_1: branch s_236_0 b5595 b237
        if s_236_0 {
            return block_5595(state, tracer, fn_state);
        } else {
            return block_237(state, tracer, fn_state);
        };
    }
    fn block_237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_237_0: const #0u : u8
        let s_237_0: bool = false;
        // D s_237_1: write-var gs#134585 <= s_237_0
        fn_state.gs_134585 = s_237_0;
        // N s_237_2: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_238_0: read-var gs#134585:u8
        let s_238_0: bool = fn_state.gs_134585;
        // N s_238_1: branch s_238_0 b5594 b239
        if s_238_0 {
            return block_5594(state, tracer, fn_state);
        } else {
            return block_239(state, tracer, fn_state);
        };
    }
    fn block_239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_239_0: const #0u : u8
        let s_239_0: bool = false;
        // D s_239_1: write-var gs#134586 <= s_239_0
        fn_state.gs_134586 = s_239_0;
        // N s_239_2: jump b240
        return block_240(state, tracer, fn_state);
    }
    fn block_240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_240_0: read-var gs#134586:u8
        let s_240_0: bool = fn_state.gs_134586;
        // N s_240_1: branch s_240_0 b5593 b241
        if s_240_0 {
            return block_5593(state, tracer, fn_state);
        } else {
            return block_241(state, tracer, fn_state);
        };
    }
    fn block_241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_241_0: const #0u : u8
        let s_241_0: bool = false;
        // D s_241_1: write-var gs#134587 <= s_241_0
        fn_state.gs_134587 = s_241_0;
        // N s_241_2: jump b242
        return block_242(state, tracer, fn_state);
    }
    fn block_242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_242_0: read-var gs#134587:u8
        let s_242_0: bool = fn_state.gs_134587;
        // N s_242_1: branch s_242_0 b5592 b243
        if s_242_0 {
            return block_5592(state, tracer, fn_state);
        } else {
            return block_243(state, tracer, fn_state);
        };
    }
    fn block_243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_243_0: read-var CRm:u8
        let s_243_0: u8 = fn_state.CRm;
        // D s_243_1: cast zx s_243_0 -> bv
        let s_243_1: Bits = Bits::new(s_243_0 as u128, 4u16);
        // C s_243_2: const #7u : u8
        let s_243_2: u8 = 7;
        // C s_243_3: cast zx s_243_2 -> bv
        let s_243_3: Bits = Bits::new(s_243_2 as u128, 4u16);
        // D s_243_4: cmp-eq s_243_1 s_243_3
        let s_243_4: bool = ((s_243_1) == (s_243_3));
        // N s_243_5: branch s_243_4 b5591 b244
        if s_243_4 {
            return block_5591(state, tracer, fn_state);
        } else {
            return block_244(state, tracer, fn_state);
        };
    }
    fn block_244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_244_0: const #0u : u8
        let s_244_0: bool = false;
        // D s_244_1: write-var gs#134588 <= s_244_0
        fn_state.gs_134588 = s_244_0;
        // N s_244_2: jump b245
        return block_245(state, tracer, fn_state);
    }
    fn block_245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_245_0: read-var gs#134588:u8
        let s_245_0: bool = fn_state.gs_134588;
        // N s_245_1: branch s_245_0 b5590 b246
        if s_245_0 {
            return block_5590(state, tracer, fn_state);
        } else {
            return block_246(state, tracer, fn_state);
        };
    }
    fn block_246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_246_0: const #0u : u8
        let s_246_0: bool = false;
        // D s_246_1: write-var gs#134589 <= s_246_0
        fn_state.gs_134589 = s_246_0;
        // N s_246_2: jump b247
        return block_247(state, tracer, fn_state);
    }
    fn block_247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_247_0: read-var gs#134589:u8
        let s_247_0: bool = fn_state.gs_134589;
        // N s_247_1: branch s_247_0 b5589 b248
        if s_247_0 {
            return block_5589(state, tracer, fn_state);
        } else {
            return block_248(state, tracer, fn_state);
        };
    }
    fn block_248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_248_0: const #0u : u8
        let s_248_0: bool = false;
        // D s_248_1: write-var gs#134590 <= s_248_0
        fn_state.gs_134590 = s_248_0;
        // N s_248_2: jump b249
        return block_249(state, tracer, fn_state);
    }
    fn block_249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_249_0: read-var gs#134590:u8
        let s_249_0: bool = fn_state.gs_134590;
        // N s_249_1: branch s_249_0 b5588 b250
        if s_249_0 {
            return block_5588(state, tracer, fn_state);
        } else {
            return block_250(state, tracer, fn_state);
        };
    }
    fn block_250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_250_0: const #0u : u8
        let s_250_0: bool = false;
        // D s_250_1: write-var gs#134591 <= s_250_0
        fn_state.gs_134591 = s_250_0;
        // N s_250_2: jump b251
        return block_251(state, tracer, fn_state);
    }
    fn block_251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_251_0: read-var gs#134591:u8
        let s_251_0: bool = fn_state.gs_134591;
        // N s_251_1: branch s_251_0 b5587 b252
        if s_251_0 {
            return block_5587(state, tracer, fn_state);
        } else {
            return block_252(state, tracer, fn_state);
        };
    }
    fn block_252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_252_0: read-var CRm:u8
        let s_252_0: u8 = fn_state.CRm;
        // D s_252_1: cast zx s_252_0 -> bv
        let s_252_1: Bits = Bits::new(s_252_0 as u128, 4u16);
        // C s_252_2: const #6u : u8
        let s_252_2: u8 = 6;
        // C s_252_3: cast zx s_252_2 -> bv
        let s_252_3: Bits = Bits::new(s_252_2 as u128, 4u16);
        // D s_252_4: cmp-eq s_252_1 s_252_3
        let s_252_4: bool = ((s_252_1) == (s_252_3));
        // N s_252_5: branch s_252_4 b5586 b253
        if s_252_4 {
            return block_5586(state, tracer, fn_state);
        } else {
            return block_253(state, tracer, fn_state);
        };
    }
    fn block_253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_253_0: const #0u : u8
        let s_253_0: bool = false;
        // D s_253_1: write-var gs#134592 <= s_253_0
        fn_state.gs_134592 = s_253_0;
        // N s_253_2: jump b254
        return block_254(state, tracer, fn_state);
    }
    fn block_254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_254_0: read-var gs#134592:u8
        let s_254_0: bool = fn_state.gs_134592;
        // N s_254_1: branch s_254_0 b5585 b255
        if s_254_0 {
            return block_5585(state, tracer, fn_state);
        } else {
            return block_255(state, tracer, fn_state);
        };
    }
    fn block_255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_255_0: const #0u : u8
        let s_255_0: bool = false;
        // D s_255_1: write-var gs#134593 <= s_255_0
        fn_state.gs_134593 = s_255_0;
        // N s_255_2: jump b256
        return block_256(state, tracer, fn_state);
    }
    fn block_256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_256_0: read-var gs#134593:u8
        let s_256_0: bool = fn_state.gs_134593;
        // N s_256_1: branch s_256_0 b5584 b257
        if s_256_0 {
            return block_5584(state, tracer, fn_state);
        } else {
            return block_257(state, tracer, fn_state);
        };
    }
    fn block_257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_257_0: const #0u : u8
        let s_257_0: bool = false;
        // D s_257_1: write-var gs#134594 <= s_257_0
        fn_state.gs_134594 = s_257_0;
        // N s_257_2: jump b258
        return block_258(state, tracer, fn_state);
    }
    fn block_258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_258_0: read-var gs#134594:u8
        let s_258_0: bool = fn_state.gs_134594;
        // N s_258_1: branch s_258_0 b5583 b259
        if s_258_0 {
            return block_5583(state, tracer, fn_state);
        } else {
            return block_259(state, tracer, fn_state);
        };
    }
    fn block_259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_259_0: const #0u : u8
        let s_259_0: bool = false;
        // D s_259_1: write-var gs#134595 <= s_259_0
        fn_state.gs_134595 = s_259_0;
        // N s_259_2: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_260_0: read-var gs#134595:u8
        let s_260_0: bool = fn_state.gs_134595;
        // N s_260_1: branch s_260_0 b5582 b261
        if s_260_0 {
            return block_5582(state, tracer, fn_state);
        } else {
            return block_261(state, tracer, fn_state);
        };
    }
    fn block_261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_261_0: read-var CRm:u8
        let s_261_0: u8 = fn_state.CRm;
        // D s_261_1: cast zx s_261_0 -> bv
        let s_261_1: Bits = Bits::new(s_261_0 as u128, 4u16);
        // C s_261_2: const #5u : u8
        let s_261_2: u8 = 5;
        // C s_261_3: cast zx s_261_2 -> bv
        let s_261_3: Bits = Bits::new(s_261_2 as u128, 4u16);
        // D s_261_4: cmp-eq s_261_1 s_261_3
        let s_261_4: bool = ((s_261_1) == (s_261_3));
        // N s_261_5: branch s_261_4 b5581 b262
        if s_261_4 {
            return block_5581(state, tracer, fn_state);
        } else {
            return block_262(state, tracer, fn_state);
        };
    }
    fn block_262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_262_0: const #0u : u8
        let s_262_0: bool = false;
        // D s_262_1: write-var gs#134596 <= s_262_0
        fn_state.gs_134596 = s_262_0;
        // N s_262_2: jump b263
        return block_263(state, tracer, fn_state);
    }
    fn block_263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_263_0: read-var gs#134596:u8
        let s_263_0: bool = fn_state.gs_134596;
        // N s_263_1: branch s_263_0 b5580 b264
        if s_263_0 {
            return block_5580(state, tracer, fn_state);
        } else {
            return block_264(state, tracer, fn_state);
        };
    }
    fn block_264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_264_0: const #0u : u8
        let s_264_0: bool = false;
        // D s_264_1: write-var gs#134597 <= s_264_0
        fn_state.gs_134597 = s_264_0;
        // N s_264_2: jump b265
        return block_265(state, tracer, fn_state);
    }
    fn block_265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_265_0: read-var gs#134597:u8
        let s_265_0: bool = fn_state.gs_134597;
        // N s_265_1: branch s_265_0 b5579 b266
        if s_265_0 {
            return block_5579(state, tracer, fn_state);
        } else {
            return block_266(state, tracer, fn_state);
        };
    }
    fn block_266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_266_0: const #0u : u8
        let s_266_0: bool = false;
        // D s_266_1: write-var gs#134598 <= s_266_0
        fn_state.gs_134598 = s_266_0;
        // N s_266_2: jump b267
        return block_267(state, tracer, fn_state);
    }
    fn block_267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_267_0: read-var gs#134598:u8
        let s_267_0: bool = fn_state.gs_134598;
        // N s_267_1: branch s_267_0 b5578 b268
        if s_267_0 {
            return block_5578(state, tracer, fn_state);
        } else {
            return block_268(state, tracer, fn_state);
        };
    }
    fn block_268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_268_0: const #0u : u8
        let s_268_0: bool = false;
        // D s_268_1: write-var gs#134599 <= s_268_0
        fn_state.gs_134599 = s_268_0;
        // N s_268_2: jump b269
        return block_269(state, tracer, fn_state);
    }
    fn block_269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_269_0: read-var gs#134599:u8
        let s_269_0: bool = fn_state.gs_134599;
        // N s_269_1: branch s_269_0 b5577 b270
        if s_269_0 {
            return block_5577(state, tracer, fn_state);
        } else {
            return block_270(state, tracer, fn_state);
        };
    }
    fn block_270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_270_0: read-var CRm:u8
        let s_270_0: u8 = fn_state.CRm;
        // D s_270_1: cast zx s_270_0 -> bv
        let s_270_1: Bits = Bits::new(s_270_0 as u128, 4u16);
        // C s_270_2: const #4u : u8
        let s_270_2: u8 = 4;
        // C s_270_3: cast zx s_270_2 -> bv
        let s_270_3: Bits = Bits::new(s_270_2 as u128, 4u16);
        // D s_270_4: cmp-eq s_270_1 s_270_3
        let s_270_4: bool = ((s_270_1) == (s_270_3));
        // N s_270_5: branch s_270_4 b5576 b271
        if s_270_4 {
            return block_5576(state, tracer, fn_state);
        } else {
            return block_271(state, tracer, fn_state);
        };
    }
    fn block_271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_271_0: const #0u : u8
        let s_271_0: bool = false;
        // D s_271_1: write-var gs#134600 <= s_271_0
        fn_state.gs_134600 = s_271_0;
        // N s_271_2: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_272_0: read-var gs#134600:u8
        let s_272_0: bool = fn_state.gs_134600;
        // N s_272_1: branch s_272_0 b5575 b273
        if s_272_0 {
            return block_5575(state, tracer, fn_state);
        } else {
            return block_273(state, tracer, fn_state);
        };
    }
    fn block_273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_273_0: const #0u : u8
        let s_273_0: bool = false;
        // D s_273_1: write-var gs#134601 <= s_273_0
        fn_state.gs_134601 = s_273_0;
        // N s_273_2: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_274_0: read-var gs#134601:u8
        let s_274_0: bool = fn_state.gs_134601;
        // N s_274_1: branch s_274_0 b5574 b275
        if s_274_0 {
            return block_5574(state, tracer, fn_state);
        } else {
            return block_275(state, tracer, fn_state);
        };
    }
    fn block_275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_275_0: const #0u : u8
        let s_275_0: bool = false;
        // D s_275_1: write-var gs#134602 <= s_275_0
        fn_state.gs_134602 = s_275_0;
        // N s_275_2: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_276_0: read-var gs#134602:u8
        let s_276_0: bool = fn_state.gs_134602;
        // N s_276_1: branch s_276_0 b5573 b277
        if s_276_0 {
            return block_5573(state, tracer, fn_state);
        } else {
            return block_277(state, tracer, fn_state);
        };
    }
    fn block_277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_277_0: const #0u : u8
        let s_277_0: bool = false;
        // D s_277_1: write-var gs#134603 <= s_277_0
        fn_state.gs_134603 = s_277_0;
        // N s_277_2: jump b278
        return block_278(state, tracer, fn_state);
    }
    fn block_278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_278_0: read-var gs#134603:u8
        let s_278_0: bool = fn_state.gs_134603;
        // N s_278_1: branch s_278_0 b5572 b279
        if s_278_0 {
            return block_5572(state, tracer, fn_state);
        } else {
            return block_279(state, tracer, fn_state);
        };
    }
    fn block_279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_279_0: read-var CRm:u8
        let s_279_0: u8 = fn_state.CRm;
        // D s_279_1: cast zx s_279_0 -> bv
        let s_279_1: Bits = Bits::new(s_279_0 as u128, 4u16);
        // C s_279_2: const #3u : u8
        let s_279_2: u8 = 3;
        // C s_279_3: cast zx s_279_2 -> bv
        let s_279_3: Bits = Bits::new(s_279_2 as u128, 4u16);
        // D s_279_4: cmp-eq s_279_1 s_279_3
        let s_279_4: bool = ((s_279_1) == (s_279_3));
        // N s_279_5: branch s_279_4 b5571 b280
        if s_279_4 {
            return block_5571(state, tracer, fn_state);
        } else {
            return block_280(state, tracer, fn_state);
        };
    }
    fn block_280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_280_0: const #0u : u8
        let s_280_0: bool = false;
        // D s_280_1: write-var gs#134604 <= s_280_0
        fn_state.gs_134604 = s_280_0;
        // N s_280_2: jump b281
        return block_281(state, tracer, fn_state);
    }
    fn block_281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_281_0: read-var gs#134604:u8
        let s_281_0: bool = fn_state.gs_134604;
        // N s_281_1: branch s_281_0 b5570 b282
        if s_281_0 {
            return block_5570(state, tracer, fn_state);
        } else {
            return block_282(state, tracer, fn_state);
        };
    }
    fn block_282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_282_0: const #0u : u8
        let s_282_0: bool = false;
        // D s_282_1: write-var gs#134605 <= s_282_0
        fn_state.gs_134605 = s_282_0;
        // N s_282_2: jump b283
        return block_283(state, tracer, fn_state);
    }
    fn block_283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_283_0: read-var gs#134605:u8
        let s_283_0: bool = fn_state.gs_134605;
        // N s_283_1: branch s_283_0 b5569 b284
        if s_283_0 {
            return block_5569(state, tracer, fn_state);
        } else {
            return block_284(state, tracer, fn_state);
        };
    }
    fn block_284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_284_0: const #0u : u8
        let s_284_0: bool = false;
        // D s_284_1: write-var gs#134606 <= s_284_0
        fn_state.gs_134606 = s_284_0;
        // N s_284_2: jump b285
        return block_285(state, tracer, fn_state);
    }
    fn block_285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_285_0: read-var gs#134606:u8
        let s_285_0: bool = fn_state.gs_134606;
        // N s_285_1: branch s_285_0 b5568 b286
        if s_285_0 {
            return block_5568(state, tracer, fn_state);
        } else {
            return block_286(state, tracer, fn_state);
        };
    }
    fn block_286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_286_0: const #0u : u8
        let s_286_0: bool = false;
        // D s_286_1: write-var gs#134607 <= s_286_0
        fn_state.gs_134607 = s_286_0;
        // N s_286_2: jump b287
        return block_287(state, tracer, fn_state);
    }
    fn block_287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_287_0: read-var gs#134607:u8
        let s_287_0: bool = fn_state.gs_134607;
        // N s_287_1: branch s_287_0 b5567 b288
        if s_287_0 {
            return block_5567(state, tracer, fn_state);
        } else {
            return block_288(state, tracer, fn_state);
        };
    }
    fn block_288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_288_0: read-var CRm:u8
        let s_288_0: u8 = fn_state.CRm;
        // D s_288_1: cast zx s_288_0 -> bv
        let s_288_1: Bits = Bits::new(s_288_0 as u128, 4u16);
        // C s_288_2: const #2u : u8
        let s_288_2: u8 = 2;
        // C s_288_3: cast zx s_288_2 -> bv
        let s_288_3: Bits = Bits::new(s_288_2 as u128, 4u16);
        // D s_288_4: cmp-eq s_288_1 s_288_3
        let s_288_4: bool = ((s_288_1) == (s_288_3));
        // N s_288_5: branch s_288_4 b5566 b289
        if s_288_4 {
            return block_5566(state, tracer, fn_state);
        } else {
            return block_289(state, tracer, fn_state);
        };
    }
    fn block_289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_289_0: const #0u : u8
        let s_289_0: bool = false;
        // D s_289_1: write-var gs#134608 <= s_289_0
        fn_state.gs_134608 = s_289_0;
        // N s_289_2: jump b290
        return block_290(state, tracer, fn_state);
    }
    fn block_290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_290_0: read-var gs#134608:u8
        let s_290_0: bool = fn_state.gs_134608;
        // N s_290_1: branch s_290_0 b5565 b291
        if s_290_0 {
            return block_5565(state, tracer, fn_state);
        } else {
            return block_291(state, tracer, fn_state);
        };
    }
    fn block_291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_291_0: const #0u : u8
        let s_291_0: bool = false;
        // D s_291_1: write-var gs#134609 <= s_291_0
        fn_state.gs_134609 = s_291_0;
        // N s_291_2: jump b292
        return block_292(state, tracer, fn_state);
    }
    fn block_292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_292_0: read-var gs#134609:u8
        let s_292_0: bool = fn_state.gs_134609;
        // N s_292_1: branch s_292_0 b5564 b293
        if s_292_0 {
            return block_5564(state, tracer, fn_state);
        } else {
            return block_293(state, tracer, fn_state);
        };
    }
    fn block_293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_293_0: const #0u : u8
        let s_293_0: bool = false;
        // D s_293_1: write-var gs#134610 <= s_293_0
        fn_state.gs_134610 = s_293_0;
        // N s_293_2: jump b294
        return block_294(state, tracer, fn_state);
    }
    fn block_294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_294_0: read-var gs#134610:u8
        let s_294_0: bool = fn_state.gs_134610;
        // N s_294_1: branch s_294_0 b5563 b295
        if s_294_0 {
            return block_5563(state, tracer, fn_state);
        } else {
            return block_295(state, tracer, fn_state);
        };
    }
    fn block_295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_295_0: const #0u : u8
        let s_295_0: bool = false;
        // D s_295_1: write-var gs#134611 <= s_295_0
        fn_state.gs_134611 = s_295_0;
        // N s_295_2: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_296_0: read-var gs#134611:u8
        let s_296_0: bool = fn_state.gs_134611;
        // N s_296_1: branch s_296_0 b5562 b297
        if s_296_0 {
            return block_5562(state, tracer, fn_state);
        } else {
            return block_297(state, tracer, fn_state);
        };
    }
    fn block_297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_297_0: read-var CRm:u8
        let s_297_0: u8 = fn_state.CRm;
        // D s_297_1: cast zx s_297_0 -> bv
        let s_297_1: Bits = Bits::new(s_297_0 as u128, 4u16);
        // C s_297_2: const #1u : u8
        let s_297_2: u8 = 1;
        // C s_297_3: cast zx s_297_2 -> bv
        let s_297_3: Bits = Bits::new(s_297_2 as u128, 4u16);
        // D s_297_4: cmp-eq s_297_1 s_297_3
        let s_297_4: bool = ((s_297_1) == (s_297_3));
        // N s_297_5: branch s_297_4 b5561 b298
        if s_297_4 {
            return block_5561(state, tracer, fn_state);
        } else {
            return block_298(state, tracer, fn_state);
        };
    }
    fn block_298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_298_0: const #0u : u8
        let s_298_0: bool = false;
        // D s_298_1: write-var gs#134612 <= s_298_0
        fn_state.gs_134612 = s_298_0;
        // N s_298_2: jump b299
        return block_299(state, tracer, fn_state);
    }
    fn block_299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_299_0: read-var gs#134612:u8
        let s_299_0: bool = fn_state.gs_134612;
        // N s_299_1: branch s_299_0 b5560 b300
        if s_299_0 {
            return block_5560(state, tracer, fn_state);
        } else {
            return block_300(state, tracer, fn_state);
        };
    }
    fn block_300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_300_0: const #0u : u8
        let s_300_0: bool = false;
        // D s_300_1: write-var gs#134613 <= s_300_0
        fn_state.gs_134613 = s_300_0;
        // N s_300_2: jump b301
        return block_301(state, tracer, fn_state);
    }
    fn block_301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_301_0: read-var gs#134613:u8
        let s_301_0: bool = fn_state.gs_134613;
        // N s_301_1: branch s_301_0 b5559 b302
        if s_301_0 {
            return block_5559(state, tracer, fn_state);
        } else {
            return block_302(state, tracer, fn_state);
        };
    }
    fn block_302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_302_0: const #0u : u8
        let s_302_0: bool = false;
        // D s_302_1: write-var gs#134614 <= s_302_0
        fn_state.gs_134614 = s_302_0;
        // N s_302_2: jump b303
        return block_303(state, tracer, fn_state);
    }
    fn block_303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_303_0: read-var gs#134614:u8
        let s_303_0: bool = fn_state.gs_134614;
        // N s_303_1: branch s_303_0 b5558 b304
        if s_303_0 {
            return block_5558(state, tracer, fn_state);
        } else {
            return block_304(state, tracer, fn_state);
        };
    }
    fn block_304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_304_0: const #0u : u8
        let s_304_0: bool = false;
        // D s_304_1: write-var gs#134615 <= s_304_0
        fn_state.gs_134615 = s_304_0;
        // N s_304_2: jump b305
        return block_305(state, tracer, fn_state);
    }
    fn block_305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_305_0: read-var gs#134615:u8
        let s_305_0: bool = fn_state.gs_134615;
        // N s_305_1: branch s_305_0 b5557 b306
        if s_305_0 {
            return block_5557(state, tracer, fn_state);
        } else {
            return block_306(state, tracer, fn_state);
        };
    }
    fn block_306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_306_0: read-var CRm:u8
        let s_306_0: u8 = fn_state.CRm;
        // D s_306_1: cast zx s_306_0 -> bv
        let s_306_1: Bits = Bits::new(s_306_0 as u128, 4u16);
        // C s_306_2: const #0u : u8
        let s_306_2: u8 = 0;
        // C s_306_3: cast zx s_306_2 -> bv
        let s_306_3: Bits = Bits::new(s_306_2 as u128, 4u16);
        // D s_306_4: cmp-eq s_306_1 s_306_3
        let s_306_4: bool = ((s_306_1) == (s_306_3));
        // N s_306_5: branch s_306_4 b5556 b307
        if s_306_4 {
            return block_5556(state, tracer, fn_state);
        } else {
            return block_307(state, tracer, fn_state);
        };
    }
    fn block_307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_307_0: const #0u : u8
        let s_307_0: bool = false;
        // D s_307_1: write-var gs#134616 <= s_307_0
        fn_state.gs_134616 = s_307_0;
        // N s_307_2: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_308_0: read-var gs#134616:u8
        let s_308_0: bool = fn_state.gs_134616;
        // N s_308_1: branch s_308_0 b5555 b309
        if s_308_0 {
            return block_5555(state, tracer, fn_state);
        } else {
            return block_309(state, tracer, fn_state);
        };
    }
    fn block_309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_309_0: const #0u : u8
        let s_309_0: bool = false;
        // D s_309_1: write-var gs#134617 <= s_309_0
        fn_state.gs_134617 = s_309_0;
        // N s_309_2: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_310_0: read-var gs#134617:u8
        let s_310_0: bool = fn_state.gs_134617;
        // N s_310_1: branch s_310_0 b5554 b311
        if s_310_0 {
            return block_5554(state, tracer, fn_state);
        } else {
            return block_311(state, tracer, fn_state);
        };
    }
    fn block_311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_311_0: const #0u : u8
        let s_311_0: bool = false;
        // D s_311_1: write-var gs#134618 <= s_311_0
        fn_state.gs_134618 = s_311_0;
        // N s_311_2: jump b312
        return block_312(state, tracer, fn_state);
    }
    fn block_312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_312_0: read-var gs#134618:u8
        let s_312_0: bool = fn_state.gs_134618;
        // N s_312_1: branch s_312_0 b5553 b313
        if s_312_0 {
            return block_5553(state, tracer, fn_state);
        } else {
            return block_313(state, tracer, fn_state);
        };
    }
    fn block_313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_313_0: const #0u : u8
        let s_313_0: bool = false;
        // D s_313_1: write-var gs#134619 <= s_313_0
        fn_state.gs_134619 = s_313_0;
        // N s_313_2: jump b314
        return block_314(state, tracer, fn_state);
    }
    fn block_314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_314_0: read-var gs#134619:u8
        let s_314_0: bool = fn_state.gs_134619;
        // N s_314_1: branch s_314_0 b5552 b315
        if s_314_0 {
            return block_5552(state, tracer, fn_state);
        } else {
            return block_315(state, tracer, fn_state);
        };
    }
    fn block_315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_315_0: read-var CRm:u8
        let s_315_0: u8 = fn_state.CRm;
        // D s_315_1: cast zx s_315_0 -> bv
        let s_315_1: Bits = Bits::new(s_315_0 as u128, 4u16);
        // C s_315_2: const #8u : u8
        let s_315_2: u8 = 8;
        // C s_315_3: cast zx s_315_2 -> bv
        let s_315_3: Bits = Bits::new(s_315_2 as u128, 4u16);
        // D s_315_4: cmp-eq s_315_1 s_315_3
        let s_315_4: bool = ((s_315_1) == (s_315_3));
        // N s_315_5: branch s_315_4 b5551 b316
        if s_315_4 {
            return block_5551(state, tracer, fn_state);
        } else {
            return block_316(state, tracer, fn_state);
        };
    }
    fn block_316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_316_0: const #0u : u8
        let s_316_0: bool = false;
        // D s_316_1: write-var gs#134620 <= s_316_0
        fn_state.gs_134620 = s_316_0;
        // N s_316_2: jump b317
        return block_317(state, tracer, fn_state);
    }
    fn block_317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_317_0: read-var gs#134620:u8
        let s_317_0: bool = fn_state.gs_134620;
        // N s_317_1: branch s_317_0 b5550 b318
        if s_317_0 {
            return block_5550(state, tracer, fn_state);
        } else {
            return block_318(state, tracer, fn_state);
        };
    }
    fn block_318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_318_0: const #0u : u8
        let s_318_0: bool = false;
        // D s_318_1: write-var gs#134621 <= s_318_0
        fn_state.gs_134621 = s_318_0;
        // N s_318_2: jump b319
        return block_319(state, tracer, fn_state);
    }
    fn block_319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_319_0: read-var gs#134621:u8
        let s_319_0: bool = fn_state.gs_134621;
        // N s_319_1: branch s_319_0 b5549 b320
        if s_319_0 {
            return block_5549(state, tracer, fn_state);
        } else {
            return block_320(state, tracer, fn_state);
        };
    }
    fn block_320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_320_0: const #0u : u8
        let s_320_0: bool = false;
        // D s_320_1: write-var gs#134622 <= s_320_0
        fn_state.gs_134622 = s_320_0;
        // N s_320_2: jump b321
        return block_321(state, tracer, fn_state);
    }
    fn block_321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_321_0: read-var gs#134622:u8
        let s_321_0: bool = fn_state.gs_134622;
        // N s_321_1: branch s_321_0 b5548 b322
        if s_321_0 {
            return block_5548(state, tracer, fn_state);
        } else {
            return block_322(state, tracer, fn_state);
        };
    }
    fn block_322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_322_0: const #0u : u8
        let s_322_0: bool = false;
        // D s_322_1: write-var gs#134623 <= s_322_0
        fn_state.gs_134623 = s_322_0;
        // N s_322_2: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_323_0: read-var gs#134623:u8
        let s_323_0: bool = fn_state.gs_134623;
        // N s_323_1: branch s_323_0 b5547 b324
        if s_323_0 {
            return block_5547(state, tracer, fn_state);
        } else {
            return block_324(state, tracer, fn_state);
        };
    }
    fn block_324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_324_0: read-var CRm:u8
        let s_324_0: u8 = fn_state.CRm;
        // D s_324_1: cast zx s_324_0 -> bv
        let s_324_1: Bits = Bits::new(s_324_0 as u128, 4u16);
        // C s_324_2: const #12u : u8
        let s_324_2: u8 = 12;
        // C s_324_3: cast zx s_324_2 -> bv
        let s_324_3: Bits = Bits::new(s_324_2 as u128, 4u16);
        // D s_324_4: cmp-eq s_324_1 s_324_3
        let s_324_4: bool = ((s_324_1) == (s_324_3));
        // N s_324_5: branch s_324_4 b5546 b325
        if s_324_4 {
            return block_5546(state, tracer, fn_state);
        } else {
            return block_325(state, tracer, fn_state);
        };
    }
    fn block_325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_325_0: const #0u : u8
        let s_325_0: bool = false;
        // D s_325_1: write-var gs#134624 <= s_325_0
        fn_state.gs_134624 = s_325_0;
        // N s_325_2: jump b326
        return block_326(state, tracer, fn_state);
    }
    fn block_326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_326_0: read-var gs#134624:u8
        let s_326_0: bool = fn_state.gs_134624;
        // N s_326_1: branch s_326_0 b5545 b327
        if s_326_0 {
            return block_5545(state, tracer, fn_state);
        } else {
            return block_327(state, tracer, fn_state);
        };
    }
    fn block_327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_327_0: const #0u : u8
        let s_327_0: bool = false;
        // D s_327_1: write-var gs#134625 <= s_327_0
        fn_state.gs_134625 = s_327_0;
        // N s_327_2: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_328_0: read-var gs#134625:u8
        let s_328_0: bool = fn_state.gs_134625;
        // N s_328_1: branch s_328_0 b5544 b329
        if s_328_0 {
            return block_5544(state, tracer, fn_state);
        } else {
            return block_329(state, tracer, fn_state);
        };
    }
    fn block_329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_329_0: const #0u : u8
        let s_329_0: bool = false;
        // D s_329_1: write-var gs#134626 <= s_329_0
        fn_state.gs_134626 = s_329_0;
        // N s_329_2: jump b330
        return block_330(state, tracer, fn_state);
    }
    fn block_330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_330_0: read-var gs#134626:u8
        let s_330_0: bool = fn_state.gs_134626;
        // N s_330_1: branch s_330_0 b5543 b331
        if s_330_0 {
            return block_5543(state, tracer, fn_state);
        } else {
            return block_331(state, tracer, fn_state);
        };
    }
    fn block_331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_331_0: const #0u : u8
        let s_331_0: bool = false;
        // D s_331_1: write-var gs#134627 <= s_331_0
        fn_state.gs_134627 = s_331_0;
        // N s_331_2: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_332_0: read-var gs#134627:u8
        let s_332_0: bool = fn_state.gs_134627;
        // N s_332_1: branch s_332_0 b5542 b333
        if s_332_0 {
            return block_5542(state, tracer, fn_state);
        } else {
            return block_333(state, tracer, fn_state);
        };
    }
    fn block_333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_333_0: read-var CRm:u8
        let s_333_0: u8 = fn_state.CRm;
        // D s_333_1: cast zx s_333_0 -> bv
        let s_333_1: Bits = Bits::new(s_333_0 as u128, 4u16);
        // C s_333_2: const #12u : u8
        let s_333_2: u8 = 12;
        // C s_333_3: cast zx s_333_2 -> bv
        let s_333_3: Bits = Bits::new(s_333_2 as u128, 4u16);
        // D s_333_4: cmp-eq s_333_1 s_333_3
        let s_333_4: bool = ((s_333_1) == (s_333_3));
        // N s_333_5: branch s_333_4 b5541 b334
        if s_333_4 {
            return block_5541(state, tracer, fn_state);
        } else {
            return block_334(state, tracer, fn_state);
        };
    }
    fn block_334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_334_0: const #0u : u8
        let s_334_0: bool = false;
        // D s_334_1: write-var gs#134628 <= s_334_0
        fn_state.gs_134628 = s_334_0;
        // N s_334_2: jump b335
        return block_335(state, tracer, fn_state);
    }
    fn block_335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_335_0: read-var gs#134628:u8
        let s_335_0: bool = fn_state.gs_134628;
        // N s_335_1: branch s_335_0 b5540 b336
        if s_335_0 {
            return block_5540(state, tracer, fn_state);
        } else {
            return block_336(state, tracer, fn_state);
        };
    }
    fn block_336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_336_0: const #0u : u8
        let s_336_0: bool = false;
        // D s_336_1: write-var gs#134629 <= s_336_0
        fn_state.gs_134629 = s_336_0;
        // N s_336_2: jump b337
        return block_337(state, tracer, fn_state);
    }
    fn block_337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_337_0: read-var gs#134629:u8
        let s_337_0: bool = fn_state.gs_134629;
        // N s_337_1: branch s_337_0 b5539 b338
        if s_337_0 {
            return block_5539(state, tracer, fn_state);
        } else {
            return block_338(state, tracer, fn_state);
        };
    }
    fn block_338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_338_0: const #0u : u8
        let s_338_0: bool = false;
        // D s_338_1: write-var gs#134630 <= s_338_0
        fn_state.gs_134630 = s_338_0;
        // N s_338_2: jump b339
        return block_339(state, tracer, fn_state);
    }
    fn block_339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_339_0: read-var gs#134630:u8
        let s_339_0: bool = fn_state.gs_134630;
        // N s_339_1: branch s_339_0 b5538 b340
        if s_339_0 {
            return block_5538(state, tracer, fn_state);
        } else {
            return block_340(state, tracer, fn_state);
        };
    }
    fn block_340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_340_0: const #0u : u8
        let s_340_0: bool = false;
        // D s_340_1: write-var gs#134631 <= s_340_0
        fn_state.gs_134631 = s_340_0;
        // N s_340_2: jump b341
        return block_341(state, tracer, fn_state);
    }
    fn block_341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_341_0: read-var gs#134631:u8
        let s_341_0: bool = fn_state.gs_134631;
        // N s_341_1: branch s_341_0 b5537 b342
        if s_341_0 {
            return block_5537(state, tracer, fn_state);
        } else {
            return block_342(state, tracer, fn_state);
        };
    }
    fn block_342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_342_0: read-var CRm:u8
        let s_342_0: u8 = fn_state.CRm;
        // D s_342_1: cast zx s_342_0 -> bv
        let s_342_1: Bits = Bits::new(s_342_0 as u128, 4u16);
        // C s_342_2: const #5u : u8
        let s_342_2: u8 = 5;
        // C s_342_3: cast zx s_342_2 -> bv
        let s_342_3: Bits = Bits::new(s_342_2 as u128, 4u16);
        // D s_342_4: cmp-eq s_342_1 s_342_3
        let s_342_4: bool = ((s_342_1) == (s_342_3));
        // N s_342_5: branch s_342_4 b5536 b343
        if s_342_4 {
            return block_5536(state, tracer, fn_state);
        } else {
            return block_343(state, tracer, fn_state);
        };
    }
    fn block_343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_343_0: const #0u : u8
        let s_343_0: bool = false;
        // D s_343_1: write-var gs#134632 <= s_343_0
        fn_state.gs_134632 = s_343_0;
        // N s_343_2: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_344_0: read-var gs#134632:u8
        let s_344_0: bool = fn_state.gs_134632;
        // N s_344_1: branch s_344_0 b5535 b345
        if s_344_0 {
            return block_5535(state, tracer, fn_state);
        } else {
            return block_345(state, tracer, fn_state);
        };
    }
    fn block_345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_345_0: const #0u : u8
        let s_345_0: bool = false;
        // D s_345_1: write-var gs#134633 <= s_345_0
        fn_state.gs_134633 = s_345_0;
        // N s_345_2: jump b346
        return block_346(state, tracer, fn_state);
    }
    fn block_346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_346_0: read-var gs#134633:u8
        let s_346_0: bool = fn_state.gs_134633;
        // N s_346_1: branch s_346_0 b5534 b347
        if s_346_0 {
            return block_5534(state, tracer, fn_state);
        } else {
            return block_347(state, tracer, fn_state);
        };
    }
    fn block_347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_347_0: const #0u : u8
        let s_347_0: bool = false;
        // D s_347_1: write-var gs#134634 <= s_347_0
        fn_state.gs_134634 = s_347_0;
        // N s_347_2: jump b348
        return block_348(state, tracer, fn_state);
    }
    fn block_348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_348_0: read-var gs#134634:u8
        let s_348_0: bool = fn_state.gs_134634;
        // N s_348_1: branch s_348_0 b5533 b349
        if s_348_0 {
            return block_5533(state, tracer, fn_state);
        } else {
            return block_349(state, tracer, fn_state);
        };
    }
    fn block_349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_349_0: const #0u : u8
        let s_349_0: bool = false;
        // D s_349_1: write-var gs#134635 <= s_349_0
        fn_state.gs_134635 = s_349_0;
        // N s_349_2: jump b350
        return block_350(state, tracer, fn_state);
    }
    fn block_350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_350_0: read-var gs#134635:u8
        let s_350_0: bool = fn_state.gs_134635;
        // N s_350_1: branch s_350_0 b5532 b351
        if s_350_0 {
            return block_5532(state, tracer, fn_state);
        } else {
            return block_351(state, tracer, fn_state);
        };
    }
    fn block_351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_351_0: read-var CRm:u8
        let s_351_0: u8 = fn_state.CRm;
        // D s_351_1: cast zx s_351_0 -> bv
        let s_351_1: Bits = Bits::new(s_351_0 as u128, 4u16);
        // C s_351_2: const #2u : u8
        let s_351_2: u8 = 2;
        // C s_351_3: cast zx s_351_2 -> bv
        let s_351_3: Bits = Bits::new(s_351_2 as u128, 4u16);
        // D s_351_4: cmp-eq s_351_1 s_351_3
        let s_351_4: bool = ((s_351_1) == (s_351_3));
        // N s_351_5: branch s_351_4 b5531 b352
        if s_351_4 {
            return block_5531(state, tracer, fn_state);
        } else {
            return block_352(state, tracer, fn_state);
        };
    }
    fn block_352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_352_0: const #0u : u8
        let s_352_0: bool = false;
        // D s_352_1: write-var gs#134636 <= s_352_0
        fn_state.gs_134636 = s_352_0;
        // N s_352_2: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_353_0: read-var gs#134636:u8
        let s_353_0: bool = fn_state.gs_134636;
        // N s_353_1: branch s_353_0 b5530 b354
        if s_353_0 {
            return block_5530(state, tracer, fn_state);
        } else {
            return block_354(state, tracer, fn_state);
        };
    }
    fn block_354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_354_0: const #0u : u8
        let s_354_0: bool = false;
        // D s_354_1: write-var gs#134637 <= s_354_0
        fn_state.gs_134637 = s_354_0;
        // N s_354_2: jump b355
        return block_355(state, tracer, fn_state);
    }
    fn block_355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_355_0: read-var gs#134637:u8
        let s_355_0: bool = fn_state.gs_134637;
        // N s_355_1: branch s_355_0 b5529 b356
        if s_355_0 {
            return block_5529(state, tracer, fn_state);
        } else {
            return block_356(state, tracer, fn_state);
        };
    }
    fn block_356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_356_0: const #0u : u8
        let s_356_0: bool = false;
        // D s_356_1: write-var gs#134638 <= s_356_0
        fn_state.gs_134638 = s_356_0;
        // N s_356_2: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_357_0: read-var gs#134638:u8
        let s_357_0: bool = fn_state.gs_134638;
        // N s_357_1: branch s_357_0 b5528 b358
        if s_357_0 {
            return block_5528(state, tracer, fn_state);
        } else {
            return block_358(state, tracer, fn_state);
        };
    }
    fn block_358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_358_0: const #0u : u8
        let s_358_0: bool = false;
        // D s_358_1: write-var gs#134639 <= s_358_0
        fn_state.gs_134639 = s_358_0;
        // N s_358_2: jump b359
        return block_359(state, tracer, fn_state);
    }
    fn block_359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_359_0: read-var gs#134639:u8
        let s_359_0: bool = fn_state.gs_134639;
        // N s_359_1: branch s_359_0 b5527 b360
        if s_359_0 {
            return block_5527(state, tracer, fn_state);
        } else {
            return block_360(state, tracer, fn_state);
        };
    }
    fn block_360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_360_0: read-var CRm:u8
        let s_360_0: u8 = fn_state.CRm;
        // D s_360_1: cast zx s_360_0 -> bv
        let s_360_1: Bits = Bits::new(s_360_0 as u128, 4u16);
        // C s_360_2: const #3u : u8
        let s_360_2: u8 = 3;
        // C s_360_3: cast zx s_360_2 -> bv
        let s_360_3: Bits = Bits::new(s_360_2 as u128, 4u16);
        // D s_360_4: cmp-eq s_360_1 s_360_3
        let s_360_4: bool = ((s_360_1) == (s_360_3));
        // N s_360_5: branch s_360_4 b5526 b361
        if s_360_4 {
            return block_5526(state, tracer, fn_state);
        } else {
            return block_361(state, tracer, fn_state);
        };
    }
    fn block_361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_361_0: const #0u : u8
        let s_361_0: bool = false;
        // D s_361_1: write-var gs#134640 <= s_361_0
        fn_state.gs_134640 = s_361_0;
        // N s_361_2: jump b362
        return block_362(state, tracer, fn_state);
    }
    fn block_362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_362_0: read-var gs#134640:u8
        let s_362_0: bool = fn_state.gs_134640;
        // N s_362_1: branch s_362_0 b5525 b363
        if s_362_0 {
            return block_5525(state, tracer, fn_state);
        } else {
            return block_363(state, tracer, fn_state);
        };
    }
    fn block_363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_363_0: const #0u : u8
        let s_363_0: bool = false;
        // D s_363_1: write-var gs#134641 <= s_363_0
        fn_state.gs_134641 = s_363_0;
        // N s_363_2: jump b364
        return block_364(state, tracer, fn_state);
    }
    fn block_364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_364_0: read-var gs#134641:u8
        let s_364_0: bool = fn_state.gs_134641;
        // N s_364_1: branch s_364_0 b5524 b365
        if s_364_0 {
            return block_5524(state, tracer, fn_state);
        } else {
            return block_365(state, tracer, fn_state);
        };
    }
    fn block_365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_365_0: const #0u : u8
        let s_365_0: bool = false;
        // D s_365_1: write-var gs#134642 <= s_365_0
        fn_state.gs_134642 = s_365_0;
        // N s_365_2: jump b366
        return block_366(state, tracer, fn_state);
    }
    fn block_366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_366_0: read-var gs#134642:u8
        let s_366_0: bool = fn_state.gs_134642;
        // N s_366_1: branch s_366_0 b5523 b367
        if s_366_0 {
            return block_5523(state, tracer, fn_state);
        } else {
            return block_367(state, tracer, fn_state);
        };
    }
    fn block_367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_367_0: const #0u : u8
        let s_367_0: bool = false;
        // D s_367_1: write-var gs#134643 <= s_367_0
        fn_state.gs_134643 = s_367_0;
        // N s_367_2: jump b368
        return block_368(state, tracer, fn_state);
    }
    fn block_368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_368_0: read-var gs#134643:u8
        let s_368_0: bool = fn_state.gs_134643;
        // N s_368_1: branch s_368_0 b5522 b369
        if s_368_0 {
            return block_5522(state, tracer, fn_state);
        } else {
            return block_369(state, tracer, fn_state);
        };
    }
    fn block_369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_369_0: read-var CRm:u8
        let s_369_0: u8 = fn_state.CRm;
        // D s_369_1: cast zx s_369_0 -> bv
        let s_369_1: Bits = Bits::new(s_369_0 as u128, 4u16);
        // C s_369_2: const #12u : u8
        let s_369_2: u8 = 12;
        // C s_369_3: cast zx s_369_2 -> bv
        let s_369_3: Bits = Bits::new(s_369_2 as u128, 4u16);
        // D s_369_4: cmp-eq s_369_1 s_369_3
        let s_369_4: bool = ((s_369_1) == (s_369_3));
        // N s_369_5: branch s_369_4 b5521 b370
        if s_369_4 {
            return block_5521(state, tracer, fn_state);
        } else {
            return block_370(state, tracer, fn_state);
        };
    }
    fn block_370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_370_0: const #0u : u8
        let s_370_0: bool = false;
        // D s_370_1: write-var gs#134644 <= s_370_0
        fn_state.gs_134644 = s_370_0;
        // N s_370_2: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_371_0: read-var gs#134644:u8
        let s_371_0: bool = fn_state.gs_134644;
        // N s_371_1: branch s_371_0 b5520 b372
        if s_371_0 {
            return block_5520(state, tracer, fn_state);
        } else {
            return block_372(state, tracer, fn_state);
        };
    }
    fn block_372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_372_0: const #0u : u8
        let s_372_0: bool = false;
        // D s_372_1: write-var gs#134645 <= s_372_0
        fn_state.gs_134645 = s_372_0;
        // N s_372_2: jump b373
        return block_373(state, tracer, fn_state);
    }
    fn block_373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_373_0: read-var gs#134645:u8
        let s_373_0: bool = fn_state.gs_134645;
        // N s_373_1: branch s_373_0 b5519 b374
        if s_373_0 {
            return block_5519(state, tracer, fn_state);
        } else {
            return block_374(state, tracer, fn_state);
        };
    }
    fn block_374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_374_0: const #0u : u8
        let s_374_0: bool = false;
        // D s_374_1: write-var gs#134646 <= s_374_0
        fn_state.gs_134646 = s_374_0;
        // N s_374_2: jump b375
        return block_375(state, tracer, fn_state);
    }
    fn block_375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_375_0: read-var gs#134646:u8
        let s_375_0: bool = fn_state.gs_134646;
        // N s_375_1: branch s_375_0 b5518 b376
        if s_375_0 {
            return block_5518(state, tracer, fn_state);
        } else {
            return block_376(state, tracer, fn_state);
        };
    }
    fn block_376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_376_0: const #0u : u8
        let s_376_0: bool = false;
        // D s_376_1: write-var gs#134647 <= s_376_0
        fn_state.gs_134647 = s_376_0;
        // N s_376_2: jump b377
        return block_377(state, tracer, fn_state);
    }
    fn block_377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_377_0: read-var gs#134647:u8
        let s_377_0: bool = fn_state.gs_134647;
        // N s_377_1: branch s_377_0 b5517 b378
        if s_377_0 {
            return block_5517(state, tracer, fn_state);
        } else {
            return block_378(state, tracer, fn_state);
        };
    }
    fn block_378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_378_0: read-var CRm:u8
        let s_378_0: u8 = fn_state.CRm;
        // D s_378_1: cast zx s_378_0 -> bv
        let s_378_1: Bits = Bits::new(s_378_0 as u128, 4u16);
        // C s_378_2: const #2u : u8
        let s_378_2: u8 = 2;
        // C s_378_3: cast zx s_378_2 -> bv
        let s_378_3: Bits = Bits::new(s_378_2 as u128, 4u16);
        // D s_378_4: cmp-eq s_378_1 s_378_3
        let s_378_4: bool = ((s_378_1) == (s_378_3));
        // N s_378_5: branch s_378_4 b5516 b379
        if s_378_4 {
            return block_5516(state, tracer, fn_state);
        } else {
            return block_379(state, tracer, fn_state);
        };
    }
    fn block_379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_379_0: const #0u : u8
        let s_379_0: bool = false;
        // D s_379_1: write-var gs#134648 <= s_379_0
        fn_state.gs_134648 = s_379_0;
        // N s_379_2: jump b380
        return block_380(state, tracer, fn_state);
    }
    fn block_380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_380_0: read-var gs#134648:u8
        let s_380_0: bool = fn_state.gs_134648;
        // N s_380_1: branch s_380_0 b5515 b381
        if s_380_0 {
            return block_5515(state, tracer, fn_state);
        } else {
            return block_381(state, tracer, fn_state);
        };
    }
    fn block_381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_381_0: const #0u : u8
        let s_381_0: bool = false;
        // D s_381_1: write-var gs#134649 <= s_381_0
        fn_state.gs_134649 = s_381_0;
        // N s_381_2: jump b382
        return block_382(state, tracer, fn_state);
    }
    fn block_382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_382_0: read-var gs#134649:u8
        let s_382_0: bool = fn_state.gs_134649;
        // N s_382_1: branch s_382_0 b5514 b383
        if s_382_0 {
            return block_5514(state, tracer, fn_state);
        } else {
            return block_383(state, tracer, fn_state);
        };
    }
    fn block_383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_383_0: const #0u : u8
        let s_383_0: bool = false;
        // D s_383_1: write-var gs#134650 <= s_383_0
        fn_state.gs_134650 = s_383_0;
        // N s_383_2: jump b384
        return block_384(state, tracer, fn_state);
    }
    fn block_384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_384_0: read-var gs#134650:u8
        let s_384_0: bool = fn_state.gs_134650;
        // N s_384_1: branch s_384_0 b5513 b385
        if s_384_0 {
            return block_5513(state, tracer, fn_state);
        } else {
            return block_385(state, tracer, fn_state);
        };
    }
    fn block_385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_385_0: const #0u : u8
        let s_385_0: bool = false;
        // D s_385_1: write-var gs#134651 <= s_385_0
        fn_state.gs_134651 = s_385_0;
        // N s_385_2: jump b386
        return block_386(state, tracer, fn_state);
    }
    fn block_386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_386_0: read-var gs#134651:u8
        let s_386_0: bool = fn_state.gs_134651;
        // N s_386_1: branch s_386_0 b5512 b387
        if s_386_0 {
            return block_5512(state, tracer, fn_state);
        } else {
            return block_387(state, tracer, fn_state);
        };
    }
    fn block_387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_387_0: read-var CRm:u8
        let s_387_0: u8 = fn_state.CRm;
        // D s_387_1: cast zx s_387_0 -> bv
        let s_387_1: Bits = Bits::new(s_387_0 as u128, 4u16);
        // C s_387_2: const #2u : u8
        let s_387_2: u8 = 2;
        // C s_387_3: cast zx s_387_2 -> bv
        let s_387_3: Bits = Bits::new(s_387_2 as u128, 4u16);
        // D s_387_4: cmp-eq s_387_1 s_387_3
        let s_387_4: bool = ((s_387_1) == (s_387_3));
        // N s_387_5: branch s_387_4 b5511 b388
        if s_387_4 {
            return block_5511(state, tracer, fn_state);
        } else {
            return block_388(state, tracer, fn_state);
        };
    }
    fn block_388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_388_0: const #0u : u8
        let s_388_0: bool = false;
        // D s_388_1: write-var gs#134652 <= s_388_0
        fn_state.gs_134652 = s_388_0;
        // N s_388_2: jump b389
        return block_389(state, tracer, fn_state);
    }
    fn block_389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_389_0: read-var gs#134652:u8
        let s_389_0: bool = fn_state.gs_134652;
        // N s_389_1: branch s_389_0 b5510 b390
        if s_389_0 {
            return block_5510(state, tracer, fn_state);
        } else {
            return block_390(state, tracer, fn_state);
        };
    }
    fn block_390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_390_0: const #0u : u8
        let s_390_0: bool = false;
        // D s_390_1: write-var gs#134653 <= s_390_0
        fn_state.gs_134653 = s_390_0;
        // N s_390_2: jump b391
        return block_391(state, tracer, fn_state);
    }
    fn block_391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_391_0: read-var gs#134653:u8
        let s_391_0: bool = fn_state.gs_134653;
        // N s_391_1: branch s_391_0 b5509 b392
        if s_391_0 {
            return block_5509(state, tracer, fn_state);
        } else {
            return block_392(state, tracer, fn_state);
        };
    }
    fn block_392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_392_0: const #0u : u8
        let s_392_0: bool = false;
        // D s_392_1: write-var gs#134654 <= s_392_0
        fn_state.gs_134654 = s_392_0;
        // N s_392_2: jump b393
        return block_393(state, tracer, fn_state);
    }
    fn block_393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_393_0: read-var gs#134654:u8
        let s_393_0: bool = fn_state.gs_134654;
        // N s_393_1: branch s_393_0 b5508 b394
        if s_393_0 {
            return block_5508(state, tracer, fn_state);
        } else {
            return block_394(state, tracer, fn_state);
        };
    }
    fn block_394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_394_0: const #0u : u8
        let s_394_0: bool = false;
        // D s_394_1: write-var gs#134655 <= s_394_0
        fn_state.gs_134655 = s_394_0;
        // N s_394_2: jump b395
        return block_395(state, tracer, fn_state);
    }
    fn block_395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_395_0: read-var gs#134655:u8
        let s_395_0: bool = fn_state.gs_134655;
        // N s_395_1: branch s_395_0 b5507 b396
        if s_395_0 {
            return block_5507(state, tracer, fn_state);
        } else {
            return block_396(state, tracer, fn_state);
        };
    }
    fn block_396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_396_0: read-var CRm:u8
        let s_396_0: u8 = fn_state.CRm;
        // D s_396_1: cast zx s_396_0 -> bv
        let s_396_1: Bits = Bits::new(s_396_0 as u128, 4u16);
        // C s_396_2: const #15u : u8
        let s_396_2: u8 = 15;
        // C s_396_3: cast zx s_396_2 -> bv
        let s_396_3: Bits = Bits::new(s_396_2 as u128, 4u16);
        // D s_396_4: cmp-eq s_396_1 s_396_3
        let s_396_4: bool = ((s_396_1) == (s_396_3));
        // N s_396_5: branch s_396_4 b5506 b397
        if s_396_4 {
            return block_5506(state, tracer, fn_state);
        } else {
            return block_397(state, tracer, fn_state);
        };
    }
    fn block_397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_397_0: const #0u : u8
        let s_397_0: bool = false;
        // D s_397_1: write-var gs#134656 <= s_397_0
        fn_state.gs_134656 = s_397_0;
        // N s_397_2: jump b398
        return block_398(state, tracer, fn_state);
    }
    fn block_398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_398_0: read-var gs#134656:u8
        let s_398_0: bool = fn_state.gs_134656;
        // N s_398_1: branch s_398_0 b5505 b399
        if s_398_0 {
            return block_5505(state, tracer, fn_state);
        } else {
            return block_399(state, tracer, fn_state);
        };
    }
    fn block_399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_399_0: const #0u : u8
        let s_399_0: bool = false;
        // D s_399_1: write-var gs#134657 <= s_399_0
        fn_state.gs_134657 = s_399_0;
        // N s_399_2: jump b400
        return block_400(state, tracer, fn_state);
    }
    fn block_400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_400_0: read-var gs#134657:u8
        let s_400_0: bool = fn_state.gs_134657;
        // N s_400_1: branch s_400_0 b5504 b401
        if s_400_0 {
            return block_5504(state, tracer, fn_state);
        } else {
            return block_401(state, tracer, fn_state);
        };
    }
    fn block_401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_401_0: const #0u : u8
        let s_401_0: bool = false;
        // D s_401_1: write-var gs#134658 <= s_401_0
        fn_state.gs_134658 = s_401_0;
        // N s_401_2: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_402_0: read-var gs#134658:u8
        let s_402_0: bool = fn_state.gs_134658;
        // N s_402_1: branch s_402_0 b5503 b403
        if s_402_0 {
            return block_5503(state, tracer, fn_state);
        } else {
            return block_403(state, tracer, fn_state);
        };
    }
    fn block_403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_403_0: const #0u : u8
        let s_403_0: bool = false;
        // D s_403_1: write-var gs#134659 <= s_403_0
        fn_state.gs_134659 = s_403_0;
        // N s_403_2: jump b404
        return block_404(state, tracer, fn_state);
    }
    fn block_404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_404_0: read-var gs#134659:u8
        let s_404_0: bool = fn_state.gs_134659;
        // N s_404_1: branch s_404_0 b5502 b405
        if s_404_0 {
            return block_5502(state, tracer, fn_state);
        } else {
            return block_405(state, tracer, fn_state);
        };
    }
    fn block_405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_405_0: read-var CRm:u8
        let s_405_0: u8 = fn_state.CRm;
        // D s_405_1: cast zx s_405_0 -> bv
        let s_405_1: Bits = Bits::new(s_405_0 as u128, 4u16);
        // C s_405_2: const #14u : u8
        let s_405_2: u8 = 14;
        // C s_405_3: cast zx s_405_2 -> bv
        let s_405_3: Bits = Bits::new(s_405_2 as u128, 4u16);
        // D s_405_4: cmp-eq s_405_1 s_405_3
        let s_405_4: bool = ((s_405_1) == (s_405_3));
        // N s_405_5: branch s_405_4 b5501 b406
        if s_405_4 {
            return block_5501(state, tracer, fn_state);
        } else {
            return block_406(state, tracer, fn_state);
        };
    }
    fn block_406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_406_0: const #0u : u8
        let s_406_0: bool = false;
        // D s_406_1: write-var gs#134660 <= s_406_0
        fn_state.gs_134660 = s_406_0;
        // N s_406_2: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_407_0: read-var gs#134660:u8
        let s_407_0: bool = fn_state.gs_134660;
        // N s_407_1: branch s_407_0 b5500 b408
        if s_407_0 {
            return block_5500(state, tracer, fn_state);
        } else {
            return block_408(state, tracer, fn_state);
        };
    }
    fn block_408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_408_0: const #0u : u8
        let s_408_0: bool = false;
        // D s_408_1: write-var gs#134661 <= s_408_0
        fn_state.gs_134661 = s_408_0;
        // N s_408_2: jump b409
        return block_409(state, tracer, fn_state);
    }
    fn block_409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_409_0: read-var gs#134661:u8
        let s_409_0: bool = fn_state.gs_134661;
        // N s_409_1: branch s_409_0 b5499 b410
        if s_409_0 {
            return block_5499(state, tracer, fn_state);
        } else {
            return block_410(state, tracer, fn_state);
        };
    }
    fn block_410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_410_0: const #0u : u8
        let s_410_0: bool = false;
        // D s_410_1: write-var gs#134662 <= s_410_0
        fn_state.gs_134662 = s_410_0;
        // N s_410_2: jump b411
        return block_411(state, tracer, fn_state);
    }
    fn block_411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_411_0: read-var gs#134662:u8
        let s_411_0: bool = fn_state.gs_134662;
        // N s_411_1: branch s_411_0 b5498 b412
        if s_411_0 {
            return block_5498(state, tracer, fn_state);
        } else {
            return block_412(state, tracer, fn_state);
        };
    }
    fn block_412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_412_0: const #0u : u8
        let s_412_0: bool = false;
        // D s_412_1: write-var gs#134663 <= s_412_0
        fn_state.gs_134663 = s_412_0;
        // N s_412_2: jump b413
        return block_413(state, tracer, fn_state);
    }
    fn block_413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_413_0: read-var gs#134663:u8
        let s_413_0: bool = fn_state.gs_134663;
        // N s_413_1: branch s_413_0 b5497 b414
        if s_413_0 {
            return block_5497(state, tracer, fn_state);
        } else {
            return block_414(state, tracer, fn_state);
        };
    }
    fn block_414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_414_0: read-var CRm:u8
        let s_414_0: u8 = fn_state.CRm;
        // D s_414_1: cast zx s_414_0 -> bv
        let s_414_1: Bits = Bits::new(s_414_0 as u128, 4u16);
        // C s_414_2: const #13u : u8
        let s_414_2: u8 = 13;
        // C s_414_3: cast zx s_414_2 -> bv
        let s_414_3: Bits = Bits::new(s_414_2 as u128, 4u16);
        // D s_414_4: cmp-eq s_414_1 s_414_3
        let s_414_4: bool = ((s_414_1) == (s_414_3));
        // N s_414_5: branch s_414_4 b5496 b415
        if s_414_4 {
            return block_5496(state, tracer, fn_state);
        } else {
            return block_415(state, tracer, fn_state);
        };
    }
    fn block_415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_415_0: const #0u : u8
        let s_415_0: bool = false;
        // D s_415_1: write-var gs#134664 <= s_415_0
        fn_state.gs_134664 = s_415_0;
        // N s_415_2: jump b416
        return block_416(state, tracer, fn_state);
    }
    fn block_416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_416_0: read-var gs#134664:u8
        let s_416_0: bool = fn_state.gs_134664;
        // N s_416_1: branch s_416_0 b5495 b417
        if s_416_0 {
            return block_5495(state, tracer, fn_state);
        } else {
            return block_417(state, tracer, fn_state);
        };
    }
    fn block_417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_417_0: const #0u : u8
        let s_417_0: bool = false;
        // D s_417_1: write-var gs#134665 <= s_417_0
        fn_state.gs_134665 = s_417_0;
        // N s_417_2: jump b418
        return block_418(state, tracer, fn_state);
    }
    fn block_418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_418_0: read-var gs#134665:u8
        let s_418_0: bool = fn_state.gs_134665;
        // N s_418_1: branch s_418_0 b5494 b419
        if s_418_0 {
            return block_5494(state, tracer, fn_state);
        } else {
            return block_419(state, tracer, fn_state);
        };
    }
    fn block_419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_419_0: const #0u : u8
        let s_419_0: bool = false;
        // D s_419_1: write-var gs#134666 <= s_419_0
        fn_state.gs_134666 = s_419_0;
        // N s_419_2: jump b420
        return block_420(state, tracer, fn_state);
    }
    fn block_420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_420_0: read-var gs#134666:u8
        let s_420_0: bool = fn_state.gs_134666;
        // N s_420_1: branch s_420_0 b5493 b421
        if s_420_0 {
            return block_5493(state, tracer, fn_state);
        } else {
            return block_421(state, tracer, fn_state);
        };
    }
    fn block_421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_421_0: const #0u : u8
        let s_421_0: bool = false;
        // D s_421_1: write-var gs#134667 <= s_421_0
        fn_state.gs_134667 = s_421_0;
        // N s_421_2: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_422_0: read-var gs#134667:u8
        let s_422_0: bool = fn_state.gs_134667;
        // N s_422_1: branch s_422_0 b5492 b423
        if s_422_0 {
            return block_5492(state, tracer, fn_state);
        } else {
            return block_423(state, tracer, fn_state);
        };
    }
    fn block_423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_423_0: read-var CRm:u8
        let s_423_0: u8 = fn_state.CRm;
        // D s_423_1: cast zx s_423_0 -> bv
        let s_423_1: Bits = Bits::new(s_423_0 as u128, 4u16);
        // C s_423_2: const #12u : u8
        let s_423_2: u8 = 12;
        // C s_423_3: cast zx s_423_2 -> bv
        let s_423_3: Bits = Bits::new(s_423_2 as u128, 4u16);
        // D s_423_4: cmp-eq s_423_1 s_423_3
        let s_423_4: bool = ((s_423_1) == (s_423_3));
        // N s_423_5: branch s_423_4 b5491 b424
        if s_423_4 {
            return block_5491(state, tracer, fn_state);
        } else {
            return block_424(state, tracer, fn_state);
        };
    }
    fn block_424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_424_0: const #0u : u8
        let s_424_0: bool = false;
        // D s_424_1: write-var gs#134668 <= s_424_0
        fn_state.gs_134668 = s_424_0;
        // N s_424_2: jump b425
        return block_425(state, tracer, fn_state);
    }
    fn block_425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_425_0: read-var gs#134668:u8
        let s_425_0: bool = fn_state.gs_134668;
        // N s_425_1: branch s_425_0 b5490 b426
        if s_425_0 {
            return block_5490(state, tracer, fn_state);
        } else {
            return block_426(state, tracer, fn_state);
        };
    }
    fn block_426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_426_0: const #0u : u8
        let s_426_0: bool = false;
        // D s_426_1: write-var gs#134669 <= s_426_0
        fn_state.gs_134669 = s_426_0;
        // N s_426_2: jump b427
        return block_427(state, tracer, fn_state);
    }
    fn block_427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_427_0: read-var gs#134669:u8
        let s_427_0: bool = fn_state.gs_134669;
        // N s_427_1: branch s_427_0 b5489 b428
        if s_427_0 {
            return block_5489(state, tracer, fn_state);
        } else {
            return block_428(state, tracer, fn_state);
        };
    }
    fn block_428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_428_0: const #0u : u8
        let s_428_0: bool = false;
        // D s_428_1: write-var gs#134670 <= s_428_0
        fn_state.gs_134670 = s_428_0;
        // N s_428_2: jump b429
        return block_429(state, tracer, fn_state);
    }
    fn block_429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_429_0: read-var gs#134670:u8
        let s_429_0: bool = fn_state.gs_134670;
        // N s_429_1: branch s_429_0 b5488 b430
        if s_429_0 {
            return block_5488(state, tracer, fn_state);
        } else {
            return block_430(state, tracer, fn_state);
        };
    }
    fn block_430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_430_0: const #0u : u8
        let s_430_0: bool = false;
        // D s_430_1: write-var gs#134671 <= s_430_0
        fn_state.gs_134671 = s_430_0;
        // N s_430_2: jump b431
        return block_431(state, tracer, fn_state);
    }
    fn block_431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_431_0: read-var gs#134671:u8
        let s_431_0: bool = fn_state.gs_134671;
        // N s_431_1: branch s_431_0 b5487 b432
        if s_431_0 {
            return block_5487(state, tracer, fn_state);
        } else {
            return block_432(state, tracer, fn_state);
        };
    }
    fn block_432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_432_0: read-var CRm:u8
        let s_432_0: u8 = fn_state.CRm;
        // D s_432_1: cast zx s_432_0 -> bv
        let s_432_1: Bits = Bits::new(s_432_0 as u128, 4u16);
        // C s_432_2: const #11u : u8
        let s_432_2: u8 = 11;
        // C s_432_3: cast zx s_432_2 -> bv
        let s_432_3: Bits = Bits::new(s_432_2 as u128, 4u16);
        // D s_432_4: cmp-eq s_432_1 s_432_3
        let s_432_4: bool = ((s_432_1) == (s_432_3));
        // N s_432_5: branch s_432_4 b5486 b433
        if s_432_4 {
            return block_5486(state, tracer, fn_state);
        } else {
            return block_433(state, tracer, fn_state);
        };
    }
    fn block_433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_433_0: const #0u : u8
        let s_433_0: bool = false;
        // D s_433_1: write-var gs#134672 <= s_433_0
        fn_state.gs_134672 = s_433_0;
        // N s_433_2: jump b434
        return block_434(state, tracer, fn_state);
    }
    fn block_434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_434_0: read-var gs#134672:u8
        let s_434_0: bool = fn_state.gs_134672;
        // N s_434_1: branch s_434_0 b5485 b435
        if s_434_0 {
            return block_5485(state, tracer, fn_state);
        } else {
            return block_435(state, tracer, fn_state);
        };
    }
    fn block_435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_435_0: const #0u : u8
        let s_435_0: bool = false;
        // D s_435_1: write-var gs#134673 <= s_435_0
        fn_state.gs_134673 = s_435_0;
        // N s_435_2: jump b436
        return block_436(state, tracer, fn_state);
    }
    fn block_436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_436_0: read-var gs#134673:u8
        let s_436_0: bool = fn_state.gs_134673;
        // N s_436_1: branch s_436_0 b5484 b437
        if s_436_0 {
            return block_5484(state, tracer, fn_state);
        } else {
            return block_437(state, tracer, fn_state);
        };
    }
    fn block_437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_437_0: const #0u : u8
        let s_437_0: bool = false;
        // D s_437_1: write-var gs#134674 <= s_437_0
        fn_state.gs_134674 = s_437_0;
        // N s_437_2: jump b438
        return block_438(state, tracer, fn_state);
    }
    fn block_438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_438_0: read-var gs#134674:u8
        let s_438_0: bool = fn_state.gs_134674;
        // N s_438_1: branch s_438_0 b5483 b439
        if s_438_0 {
            return block_5483(state, tracer, fn_state);
        } else {
            return block_439(state, tracer, fn_state);
        };
    }
    fn block_439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_439_0: const #0u : u8
        let s_439_0: bool = false;
        // D s_439_1: write-var gs#134675 <= s_439_0
        fn_state.gs_134675 = s_439_0;
        // N s_439_2: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_440_0: read-var gs#134675:u8
        let s_440_0: bool = fn_state.gs_134675;
        // N s_440_1: branch s_440_0 b5482 b441
        if s_440_0 {
            return block_5482(state, tracer, fn_state);
        } else {
            return block_441(state, tracer, fn_state);
        };
    }
    fn block_441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_441_0: read-var CRm:u8
        let s_441_0: u8 = fn_state.CRm;
        // D s_441_1: cast zx s_441_0 -> bv
        let s_441_1: Bits = Bits::new(s_441_0 as u128, 4u16);
        // C s_441_2: const #10u : u8
        let s_441_2: u8 = 10;
        // C s_441_3: cast zx s_441_2 -> bv
        let s_441_3: Bits = Bits::new(s_441_2 as u128, 4u16);
        // D s_441_4: cmp-eq s_441_1 s_441_3
        let s_441_4: bool = ((s_441_1) == (s_441_3));
        // N s_441_5: branch s_441_4 b5481 b442
        if s_441_4 {
            return block_5481(state, tracer, fn_state);
        } else {
            return block_442(state, tracer, fn_state);
        };
    }
    fn block_442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_442_0: const #0u : u8
        let s_442_0: bool = false;
        // D s_442_1: write-var gs#134676 <= s_442_0
        fn_state.gs_134676 = s_442_0;
        // N s_442_2: jump b443
        return block_443(state, tracer, fn_state);
    }
    fn block_443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_443_0: read-var gs#134676:u8
        let s_443_0: bool = fn_state.gs_134676;
        // N s_443_1: branch s_443_0 b5480 b444
        if s_443_0 {
            return block_5480(state, tracer, fn_state);
        } else {
            return block_444(state, tracer, fn_state);
        };
    }
    fn block_444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_444_0: const #0u : u8
        let s_444_0: bool = false;
        // D s_444_1: write-var gs#134677 <= s_444_0
        fn_state.gs_134677 = s_444_0;
        // N s_444_2: jump b445
        return block_445(state, tracer, fn_state);
    }
    fn block_445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_445_0: read-var gs#134677:u8
        let s_445_0: bool = fn_state.gs_134677;
        // N s_445_1: branch s_445_0 b5479 b446
        if s_445_0 {
            return block_5479(state, tracer, fn_state);
        } else {
            return block_446(state, tracer, fn_state);
        };
    }
    fn block_446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_446_0: const #0u : u8
        let s_446_0: bool = false;
        // D s_446_1: write-var gs#134678 <= s_446_0
        fn_state.gs_134678 = s_446_0;
        // N s_446_2: jump b447
        return block_447(state, tracer, fn_state);
    }
    fn block_447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_447_0: read-var gs#134678:u8
        let s_447_0: bool = fn_state.gs_134678;
        // N s_447_1: branch s_447_0 b5478 b448
        if s_447_0 {
            return block_5478(state, tracer, fn_state);
        } else {
            return block_448(state, tracer, fn_state);
        };
    }
    fn block_448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_448_0: const #0u : u8
        let s_448_0: bool = false;
        // D s_448_1: write-var gs#134679 <= s_448_0
        fn_state.gs_134679 = s_448_0;
        // N s_448_2: jump b449
        return block_449(state, tracer, fn_state);
    }
    fn block_449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_449_0: read-var gs#134679:u8
        let s_449_0: bool = fn_state.gs_134679;
        // N s_449_1: branch s_449_0 b5477 b450
        if s_449_0 {
            return block_5477(state, tracer, fn_state);
        } else {
            return block_450(state, tracer, fn_state);
        };
    }
    fn block_450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_450_0: read-var CRm:u8
        let s_450_0: u8 = fn_state.CRm;
        // D s_450_1: cast zx s_450_0 -> bv
        let s_450_1: Bits = Bits::new(s_450_0 as u128, 4u16);
        // C s_450_2: const #9u : u8
        let s_450_2: u8 = 9;
        // C s_450_3: cast zx s_450_2 -> bv
        let s_450_3: Bits = Bits::new(s_450_2 as u128, 4u16);
        // D s_450_4: cmp-eq s_450_1 s_450_3
        let s_450_4: bool = ((s_450_1) == (s_450_3));
        // N s_450_5: branch s_450_4 b5476 b451
        if s_450_4 {
            return block_5476(state, tracer, fn_state);
        } else {
            return block_451(state, tracer, fn_state);
        };
    }
    fn block_451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_451_0: const #0u : u8
        let s_451_0: bool = false;
        // D s_451_1: write-var gs#134680 <= s_451_0
        fn_state.gs_134680 = s_451_0;
        // N s_451_2: jump b452
        return block_452(state, tracer, fn_state);
    }
    fn block_452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_452_0: read-var gs#134680:u8
        let s_452_0: bool = fn_state.gs_134680;
        // N s_452_1: branch s_452_0 b5475 b453
        if s_452_0 {
            return block_5475(state, tracer, fn_state);
        } else {
            return block_453(state, tracer, fn_state);
        };
    }
    fn block_453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_453_0: const #0u : u8
        let s_453_0: bool = false;
        // D s_453_1: write-var gs#134681 <= s_453_0
        fn_state.gs_134681 = s_453_0;
        // N s_453_2: jump b454
        return block_454(state, tracer, fn_state);
    }
    fn block_454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_454_0: read-var gs#134681:u8
        let s_454_0: bool = fn_state.gs_134681;
        // N s_454_1: branch s_454_0 b5474 b455
        if s_454_0 {
            return block_5474(state, tracer, fn_state);
        } else {
            return block_455(state, tracer, fn_state);
        };
    }
    fn block_455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_455_0: const #0u : u8
        let s_455_0: bool = false;
        // D s_455_1: write-var gs#134682 <= s_455_0
        fn_state.gs_134682 = s_455_0;
        // N s_455_2: jump b456
        return block_456(state, tracer, fn_state);
    }
    fn block_456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_456_0: read-var gs#134682:u8
        let s_456_0: bool = fn_state.gs_134682;
        // N s_456_1: branch s_456_0 b5473 b457
        if s_456_0 {
            return block_5473(state, tracer, fn_state);
        } else {
            return block_457(state, tracer, fn_state);
        };
    }
    fn block_457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_457_0: const #0u : u8
        let s_457_0: bool = false;
        // D s_457_1: write-var gs#134683 <= s_457_0
        fn_state.gs_134683 = s_457_0;
        // N s_457_2: jump b458
        return block_458(state, tracer, fn_state);
    }
    fn block_458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_458_0: read-var gs#134683:u8
        let s_458_0: bool = fn_state.gs_134683;
        // N s_458_1: branch s_458_0 b5472 b459
        if s_458_0 {
            return block_5472(state, tracer, fn_state);
        } else {
            return block_459(state, tracer, fn_state);
        };
    }
    fn block_459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_459_0: read-var CRm:u8
        let s_459_0: u8 = fn_state.CRm;
        // D s_459_1: cast zx s_459_0 -> bv
        let s_459_1: Bits = Bits::new(s_459_0 as u128, 4u16);
        // C s_459_2: const #8u : u8
        let s_459_2: u8 = 8;
        // C s_459_3: cast zx s_459_2 -> bv
        let s_459_3: Bits = Bits::new(s_459_2 as u128, 4u16);
        // D s_459_4: cmp-eq s_459_1 s_459_3
        let s_459_4: bool = ((s_459_1) == (s_459_3));
        // N s_459_5: branch s_459_4 b5471 b460
        if s_459_4 {
            return block_5471(state, tracer, fn_state);
        } else {
            return block_460(state, tracer, fn_state);
        };
    }
    fn block_460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_460_0: const #0u : u8
        let s_460_0: bool = false;
        // D s_460_1: write-var gs#134684 <= s_460_0
        fn_state.gs_134684 = s_460_0;
        // N s_460_2: jump b461
        return block_461(state, tracer, fn_state);
    }
    fn block_461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_461_0: read-var gs#134684:u8
        let s_461_0: bool = fn_state.gs_134684;
        // N s_461_1: branch s_461_0 b5470 b462
        if s_461_0 {
            return block_5470(state, tracer, fn_state);
        } else {
            return block_462(state, tracer, fn_state);
        };
    }
    fn block_462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_462_0: const #0u : u8
        let s_462_0: bool = false;
        // D s_462_1: write-var gs#134685 <= s_462_0
        fn_state.gs_134685 = s_462_0;
        // N s_462_2: jump b463
        return block_463(state, tracer, fn_state);
    }
    fn block_463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_463_0: read-var gs#134685:u8
        let s_463_0: bool = fn_state.gs_134685;
        // N s_463_1: branch s_463_0 b5469 b464
        if s_463_0 {
            return block_5469(state, tracer, fn_state);
        } else {
            return block_464(state, tracer, fn_state);
        };
    }
    fn block_464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_464_0: const #0u : u8
        let s_464_0: bool = false;
        // D s_464_1: write-var gs#134686 <= s_464_0
        fn_state.gs_134686 = s_464_0;
        // N s_464_2: jump b465
        return block_465(state, tracer, fn_state);
    }
    fn block_465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_465_0: read-var gs#134686:u8
        let s_465_0: bool = fn_state.gs_134686;
        // N s_465_1: branch s_465_0 b5468 b466
        if s_465_0 {
            return block_5468(state, tracer, fn_state);
        } else {
            return block_466(state, tracer, fn_state);
        };
    }
    fn block_466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_466_0: const #0u : u8
        let s_466_0: bool = false;
        // D s_466_1: write-var gs#134687 <= s_466_0
        fn_state.gs_134687 = s_466_0;
        // N s_466_2: jump b467
        return block_467(state, tracer, fn_state);
    }
    fn block_467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_467_0: read-var gs#134687:u8
        let s_467_0: bool = fn_state.gs_134687;
        // N s_467_1: branch s_467_0 b5467 b468
        if s_467_0 {
            return block_5467(state, tracer, fn_state);
        } else {
            return block_468(state, tracer, fn_state);
        };
    }
    fn block_468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_468_0: read-var CRm:u8
        let s_468_0: u8 = fn_state.CRm;
        // D s_468_1: cast zx s_468_0 -> bv
        let s_468_1: Bits = Bits::new(s_468_0 as u128, 4u16);
        // C s_468_2: const #7u : u8
        let s_468_2: u8 = 7;
        // C s_468_3: cast zx s_468_2 -> bv
        let s_468_3: Bits = Bits::new(s_468_2 as u128, 4u16);
        // D s_468_4: cmp-eq s_468_1 s_468_3
        let s_468_4: bool = ((s_468_1) == (s_468_3));
        // N s_468_5: branch s_468_4 b5466 b469
        if s_468_4 {
            return block_5466(state, tracer, fn_state);
        } else {
            return block_469(state, tracer, fn_state);
        };
    }
    fn block_469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_469_0: const #0u : u8
        let s_469_0: bool = false;
        // D s_469_1: write-var gs#134688 <= s_469_0
        fn_state.gs_134688 = s_469_0;
        // N s_469_2: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_470_0: read-var gs#134688:u8
        let s_470_0: bool = fn_state.gs_134688;
        // N s_470_1: branch s_470_0 b5465 b471
        if s_470_0 {
            return block_5465(state, tracer, fn_state);
        } else {
            return block_471(state, tracer, fn_state);
        };
    }
    fn block_471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_471_0: const #0u : u8
        let s_471_0: bool = false;
        // D s_471_1: write-var gs#134689 <= s_471_0
        fn_state.gs_134689 = s_471_0;
        // N s_471_2: jump b472
        return block_472(state, tracer, fn_state);
    }
    fn block_472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_472_0: read-var gs#134689:u8
        let s_472_0: bool = fn_state.gs_134689;
        // N s_472_1: branch s_472_0 b5464 b473
        if s_472_0 {
            return block_5464(state, tracer, fn_state);
        } else {
            return block_473(state, tracer, fn_state);
        };
    }
    fn block_473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_473_0: const #0u : u8
        let s_473_0: bool = false;
        // D s_473_1: write-var gs#134690 <= s_473_0
        fn_state.gs_134690 = s_473_0;
        // N s_473_2: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_474_0: read-var gs#134690:u8
        let s_474_0: bool = fn_state.gs_134690;
        // N s_474_1: branch s_474_0 b5463 b475
        if s_474_0 {
            return block_5463(state, tracer, fn_state);
        } else {
            return block_475(state, tracer, fn_state);
        };
    }
    fn block_475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_475_0: const #0u : u8
        let s_475_0: bool = false;
        // D s_475_1: write-var gs#134691 <= s_475_0
        fn_state.gs_134691 = s_475_0;
        // N s_475_2: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_476_0: read-var gs#134691:u8
        let s_476_0: bool = fn_state.gs_134691;
        // N s_476_1: branch s_476_0 b5462 b477
        if s_476_0 {
            return block_5462(state, tracer, fn_state);
        } else {
            return block_477(state, tracer, fn_state);
        };
    }
    fn block_477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_477_0: read-var CRm:u8
        let s_477_0: u8 = fn_state.CRm;
        // D s_477_1: cast zx s_477_0 -> bv
        let s_477_1: Bits = Bits::new(s_477_0 as u128, 4u16);
        // C s_477_2: const #6u : u8
        let s_477_2: u8 = 6;
        // C s_477_3: cast zx s_477_2 -> bv
        let s_477_3: Bits = Bits::new(s_477_2 as u128, 4u16);
        // D s_477_4: cmp-eq s_477_1 s_477_3
        let s_477_4: bool = ((s_477_1) == (s_477_3));
        // N s_477_5: branch s_477_4 b5461 b478
        if s_477_4 {
            return block_5461(state, tracer, fn_state);
        } else {
            return block_478(state, tracer, fn_state);
        };
    }
    fn block_478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_478_0: const #0u : u8
        let s_478_0: bool = false;
        // D s_478_1: write-var gs#134692 <= s_478_0
        fn_state.gs_134692 = s_478_0;
        // N s_478_2: jump b479
        return block_479(state, tracer, fn_state);
    }
    fn block_479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_479_0: read-var gs#134692:u8
        let s_479_0: bool = fn_state.gs_134692;
        // N s_479_1: branch s_479_0 b5460 b480
        if s_479_0 {
            return block_5460(state, tracer, fn_state);
        } else {
            return block_480(state, tracer, fn_state);
        };
    }
    fn block_480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_480_0: const #0u : u8
        let s_480_0: bool = false;
        // D s_480_1: write-var gs#134693 <= s_480_0
        fn_state.gs_134693 = s_480_0;
        // N s_480_2: jump b481
        return block_481(state, tracer, fn_state);
    }
    fn block_481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_481_0: read-var gs#134693:u8
        let s_481_0: bool = fn_state.gs_134693;
        // N s_481_1: branch s_481_0 b5459 b482
        if s_481_0 {
            return block_5459(state, tracer, fn_state);
        } else {
            return block_482(state, tracer, fn_state);
        };
    }
    fn block_482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_482_0: const #0u : u8
        let s_482_0: bool = false;
        // D s_482_1: write-var gs#134694 <= s_482_0
        fn_state.gs_134694 = s_482_0;
        // N s_482_2: jump b483
        return block_483(state, tracer, fn_state);
    }
    fn block_483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_483_0: read-var gs#134694:u8
        let s_483_0: bool = fn_state.gs_134694;
        // N s_483_1: branch s_483_0 b5458 b484
        if s_483_0 {
            return block_5458(state, tracer, fn_state);
        } else {
            return block_484(state, tracer, fn_state);
        };
    }
    fn block_484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_484_0: const #0u : u8
        let s_484_0: bool = false;
        // D s_484_1: write-var gs#134695 <= s_484_0
        fn_state.gs_134695 = s_484_0;
        // N s_484_2: jump b485
        return block_485(state, tracer, fn_state);
    }
    fn block_485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_485_0: read-var gs#134695:u8
        let s_485_0: bool = fn_state.gs_134695;
        // N s_485_1: branch s_485_0 b5457 b486
        if s_485_0 {
            return block_5457(state, tracer, fn_state);
        } else {
            return block_486(state, tracer, fn_state);
        };
    }
    fn block_486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_486_0: read-var CRm:u8
        let s_486_0: u8 = fn_state.CRm;
        // D s_486_1: cast zx s_486_0 -> bv
        let s_486_1: Bits = Bits::new(s_486_0 as u128, 4u16);
        // C s_486_2: const #5u : u8
        let s_486_2: u8 = 5;
        // C s_486_3: cast zx s_486_2 -> bv
        let s_486_3: Bits = Bits::new(s_486_2 as u128, 4u16);
        // D s_486_4: cmp-eq s_486_1 s_486_3
        let s_486_4: bool = ((s_486_1) == (s_486_3));
        // N s_486_5: branch s_486_4 b5456 b487
        if s_486_4 {
            return block_5456(state, tracer, fn_state);
        } else {
            return block_487(state, tracer, fn_state);
        };
    }
    fn block_487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_487_0: const #0u : u8
        let s_487_0: bool = false;
        // D s_487_1: write-var gs#134696 <= s_487_0
        fn_state.gs_134696 = s_487_0;
        // N s_487_2: jump b488
        return block_488(state, tracer, fn_state);
    }
    fn block_488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_488_0: read-var gs#134696:u8
        let s_488_0: bool = fn_state.gs_134696;
        // N s_488_1: branch s_488_0 b5455 b489
        if s_488_0 {
            return block_5455(state, tracer, fn_state);
        } else {
            return block_489(state, tracer, fn_state);
        };
    }
    fn block_489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_489_0: const #0u : u8
        let s_489_0: bool = false;
        // D s_489_1: write-var gs#134697 <= s_489_0
        fn_state.gs_134697 = s_489_0;
        // N s_489_2: jump b490
        return block_490(state, tracer, fn_state);
    }
    fn block_490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_490_0: read-var gs#134697:u8
        let s_490_0: bool = fn_state.gs_134697;
        // N s_490_1: branch s_490_0 b5454 b491
        if s_490_0 {
            return block_5454(state, tracer, fn_state);
        } else {
            return block_491(state, tracer, fn_state);
        };
    }
    fn block_491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_491_0: const #0u : u8
        let s_491_0: bool = false;
        // D s_491_1: write-var gs#134698 <= s_491_0
        fn_state.gs_134698 = s_491_0;
        // N s_491_2: jump b492
        return block_492(state, tracer, fn_state);
    }
    fn block_492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_492_0: read-var gs#134698:u8
        let s_492_0: bool = fn_state.gs_134698;
        // N s_492_1: branch s_492_0 b5453 b493
        if s_492_0 {
            return block_5453(state, tracer, fn_state);
        } else {
            return block_493(state, tracer, fn_state);
        };
    }
    fn block_493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_493_0: const #0u : u8
        let s_493_0: bool = false;
        // D s_493_1: write-var gs#134699 <= s_493_0
        fn_state.gs_134699 = s_493_0;
        // N s_493_2: jump b494
        return block_494(state, tracer, fn_state);
    }
    fn block_494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_494_0: read-var gs#134699:u8
        let s_494_0: bool = fn_state.gs_134699;
        // N s_494_1: branch s_494_0 b5452 b495
        if s_494_0 {
            return block_5452(state, tracer, fn_state);
        } else {
            return block_495(state, tracer, fn_state);
        };
    }
    fn block_495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_495_0: read-var CRm:u8
        let s_495_0: u8 = fn_state.CRm;
        // D s_495_1: cast zx s_495_0 -> bv
        let s_495_1: Bits = Bits::new(s_495_0 as u128, 4u16);
        // C s_495_2: const #4u : u8
        let s_495_2: u8 = 4;
        // C s_495_3: cast zx s_495_2 -> bv
        let s_495_3: Bits = Bits::new(s_495_2 as u128, 4u16);
        // D s_495_4: cmp-eq s_495_1 s_495_3
        let s_495_4: bool = ((s_495_1) == (s_495_3));
        // N s_495_5: branch s_495_4 b5451 b496
        if s_495_4 {
            return block_5451(state, tracer, fn_state);
        } else {
            return block_496(state, tracer, fn_state);
        };
    }
    fn block_496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_496_0: const #0u : u8
        let s_496_0: bool = false;
        // D s_496_1: write-var gs#134700 <= s_496_0
        fn_state.gs_134700 = s_496_0;
        // N s_496_2: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_497_0: read-var gs#134700:u8
        let s_497_0: bool = fn_state.gs_134700;
        // N s_497_1: branch s_497_0 b5450 b498
        if s_497_0 {
            return block_5450(state, tracer, fn_state);
        } else {
            return block_498(state, tracer, fn_state);
        };
    }
    fn block_498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_498_0: const #0u : u8
        let s_498_0: bool = false;
        // D s_498_1: write-var gs#134701 <= s_498_0
        fn_state.gs_134701 = s_498_0;
        // N s_498_2: jump b499
        return block_499(state, tracer, fn_state);
    }
    fn block_499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_499_0: read-var gs#134701:u8
        let s_499_0: bool = fn_state.gs_134701;
        // N s_499_1: branch s_499_0 b5449 b500
        if s_499_0 {
            return block_5449(state, tracer, fn_state);
        } else {
            return block_500(state, tracer, fn_state);
        };
    }
    fn block_500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_500_0: const #0u : u8
        let s_500_0: bool = false;
        // D s_500_1: write-var gs#134702 <= s_500_0
        fn_state.gs_134702 = s_500_0;
        // N s_500_2: jump b501
        return block_501(state, tracer, fn_state);
    }
    fn block_501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_501_0: read-var gs#134702:u8
        let s_501_0: bool = fn_state.gs_134702;
        // N s_501_1: branch s_501_0 b5448 b502
        if s_501_0 {
            return block_5448(state, tracer, fn_state);
        } else {
            return block_502(state, tracer, fn_state);
        };
    }
    fn block_502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_502_0: const #0u : u8
        let s_502_0: bool = false;
        // D s_502_1: write-var gs#134703 <= s_502_0
        fn_state.gs_134703 = s_502_0;
        // N s_502_2: jump b503
        return block_503(state, tracer, fn_state);
    }
    fn block_503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_503_0: read-var gs#134703:u8
        let s_503_0: bool = fn_state.gs_134703;
        // N s_503_1: branch s_503_0 b5447 b504
        if s_503_0 {
            return block_5447(state, tracer, fn_state);
        } else {
            return block_504(state, tracer, fn_state);
        };
    }
    fn block_504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_504_0: read-var CRm:u8
        let s_504_0: u8 = fn_state.CRm;
        // D s_504_1: cast zx s_504_0 -> bv
        let s_504_1: Bits = Bits::new(s_504_0 as u128, 4u16);
        // C s_504_2: const #3u : u8
        let s_504_2: u8 = 3;
        // C s_504_3: cast zx s_504_2 -> bv
        let s_504_3: Bits = Bits::new(s_504_2 as u128, 4u16);
        // D s_504_4: cmp-eq s_504_1 s_504_3
        let s_504_4: bool = ((s_504_1) == (s_504_3));
        // N s_504_5: branch s_504_4 b5446 b505
        if s_504_4 {
            return block_5446(state, tracer, fn_state);
        } else {
            return block_505(state, tracer, fn_state);
        };
    }
    fn block_505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_505_0: const #0u : u8
        let s_505_0: bool = false;
        // D s_505_1: write-var gs#134704 <= s_505_0
        fn_state.gs_134704 = s_505_0;
        // N s_505_2: jump b506
        return block_506(state, tracer, fn_state);
    }
    fn block_506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_506_0: read-var gs#134704:u8
        let s_506_0: bool = fn_state.gs_134704;
        // N s_506_1: branch s_506_0 b5445 b507
        if s_506_0 {
            return block_5445(state, tracer, fn_state);
        } else {
            return block_507(state, tracer, fn_state);
        };
    }
    fn block_507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_507_0: const #0u : u8
        let s_507_0: bool = false;
        // D s_507_1: write-var gs#134705 <= s_507_0
        fn_state.gs_134705 = s_507_0;
        // N s_507_2: jump b508
        return block_508(state, tracer, fn_state);
    }
    fn block_508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_508_0: read-var gs#134705:u8
        let s_508_0: bool = fn_state.gs_134705;
        // N s_508_1: branch s_508_0 b5444 b509
        if s_508_0 {
            return block_5444(state, tracer, fn_state);
        } else {
            return block_509(state, tracer, fn_state);
        };
    }
    fn block_509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_509_0: const #0u : u8
        let s_509_0: bool = false;
        // D s_509_1: write-var gs#134706 <= s_509_0
        fn_state.gs_134706 = s_509_0;
        // N s_509_2: jump b510
        return block_510(state, tracer, fn_state);
    }
    fn block_510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_510_0: read-var gs#134706:u8
        let s_510_0: bool = fn_state.gs_134706;
        // N s_510_1: branch s_510_0 b5443 b511
        if s_510_0 {
            return block_5443(state, tracer, fn_state);
        } else {
            return block_511(state, tracer, fn_state);
        };
    }
    fn block_511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_511_0: const #0u : u8
        let s_511_0: bool = false;
        // D s_511_1: write-var gs#134707 <= s_511_0
        fn_state.gs_134707 = s_511_0;
        // N s_511_2: jump b512
        return block_512(state, tracer, fn_state);
    }
    fn block_512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_512_0: read-var gs#134707:u8
        let s_512_0: bool = fn_state.gs_134707;
        // N s_512_1: branch s_512_0 b5442 b513
        if s_512_0 {
            return block_5442(state, tracer, fn_state);
        } else {
            return block_513(state, tracer, fn_state);
        };
    }
    fn block_513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_513_0: read-var CRm:u8
        let s_513_0: u8 = fn_state.CRm;
        // D s_513_1: cast zx s_513_0 -> bv
        let s_513_1: Bits = Bits::new(s_513_0 as u128, 4u16);
        // C s_513_2: const #2u : u8
        let s_513_2: u8 = 2;
        // C s_513_3: cast zx s_513_2 -> bv
        let s_513_3: Bits = Bits::new(s_513_2 as u128, 4u16);
        // D s_513_4: cmp-eq s_513_1 s_513_3
        let s_513_4: bool = ((s_513_1) == (s_513_3));
        // N s_513_5: branch s_513_4 b5441 b514
        if s_513_4 {
            return block_5441(state, tracer, fn_state);
        } else {
            return block_514(state, tracer, fn_state);
        };
    }
    fn block_514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_514_0: const #0u : u8
        let s_514_0: bool = false;
        // D s_514_1: write-var gs#134708 <= s_514_0
        fn_state.gs_134708 = s_514_0;
        // N s_514_2: jump b515
        return block_515(state, tracer, fn_state);
    }
    fn block_515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_515_0: read-var gs#134708:u8
        let s_515_0: bool = fn_state.gs_134708;
        // N s_515_1: branch s_515_0 b5440 b516
        if s_515_0 {
            return block_5440(state, tracer, fn_state);
        } else {
            return block_516(state, tracer, fn_state);
        };
    }
    fn block_516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_516_0: const #0u : u8
        let s_516_0: bool = false;
        // D s_516_1: write-var gs#134709 <= s_516_0
        fn_state.gs_134709 = s_516_0;
        // N s_516_2: jump b517
        return block_517(state, tracer, fn_state);
    }
    fn block_517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_517_0: read-var gs#134709:u8
        let s_517_0: bool = fn_state.gs_134709;
        // N s_517_1: branch s_517_0 b5439 b518
        if s_517_0 {
            return block_5439(state, tracer, fn_state);
        } else {
            return block_518(state, tracer, fn_state);
        };
    }
    fn block_518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_518_0: const #0u : u8
        let s_518_0: bool = false;
        // D s_518_1: write-var gs#134710 <= s_518_0
        fn_state.gs_134710 = s_518_0;
        // N s_518_2: jump b519
        return block_519(state, tracer, fn_state);
    }
    fn block_519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_519_0: read-var gs#134710:u8
        let s_519_0: bool = fn_state.gs_134710;
        // N s_519_1: branch s_519_0 b5438 b520
        if s_519_0 {
            return block_5438(state, tracer, fn_state);
        } else {
            return block_520(state, tracer, fn_state);
        };
    }
    fn block_520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_520_0: const #0u : u8
        let s_520_0: bool = false;
        // D s_520_1: write-var gs#134711 <= s_520_0
        fn_state.gs_134711 = s_520_0;
        // N s_520_2: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_521_0: read-var gs#134711:u8
        let s_521_0: bool = fn_state.gs_134711;
        // N s_521_1: branch s_521_0 b5437 b522
        if s_521_0 {
            return block_5437(state, tracer, fn_state);
        } else {
            return block_522(state, tracer, fn_state);
        };
    }
    fn block_522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_522_0: read-var CRm:u8
        let s_522_0: u8 = fn_state.CRm;
        // D s_522_1: cast zx s_522_0 -> bv
        let s_522_1: Bits = Bits::new(s_522_0 as u128, 4u16);
        // C s_522_2: const #1u : u8
        let s_522_2: u8 = 1;
        // C s_522_3: cast zx s_522_2 -> bv
        let s_522_3: Bits = Bits::new(s_522_2 as u128, 4u16);
        // D s_522_4: cmp-eq s_522_1 s_522_3
        let s_522_4: bool = ((s_522_1) == (s_522_3));
        // N s_522_5: branch s_522_4 b5436 b523
        if s_522_4 {
            return block_5436(state, tracer, fn_state);
        } else {
            return block_523(state, tracer, fn_state);
        };
    }
    fn block_523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_523_0: const #0u : u8
        let s_523_0: bool = false;
        // D s_523_1: write-var gs#134712 <= s_523_0
        fn_state.gs_134712 = s_523_0;
        // N s_523_2: jump b524
        return block_524(state, tracer, fn_state);
    }
    fn block_524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_524_0: read-var gs#134712:u8
        let s_524_0: bool = fn_state.gs_134712;
        // N s_524_1: branch s_524_0 b5435 b525
        if s_524_0 {
            return block_5435(state, tracer, fn_state);
        } else {
            return block_525(state, tracer, fn_state);
        };
    }
    fn block_525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_525_0: const #0u : u8
        let s_525_0: bool = false;
        // D s_525_1: write-var gs#134713 <= s_525_0
        fn_state.gs_134713 = s_525_0;
        // N s_525_2: jump b526
        return block_526(state, tracer, fn_state);
    }
    fn block_526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_526_0: read-var gs#134713:u8
        let s_526_0: bool = fn_state.gs_134713;
        // N s_526_1: branch s_526_0 b5434 b527
        if s_526_0 {
            return block_5434(state, tracer, fn_state);
        } else {
            return block_527(state, tracer, fn_state);
        };
    }
    fn block_527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_527_0: const #0u : u8
        let s_527_0: bool = false;
        // D s_527_1: write-var gs#134714 <= s_527_0
        fn_state.gs_134714 = s_527_0;
        // N s_527_2: jump b528
        return block_528(state, tracer, fn_state);
    }
    fn block_528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_528_0: read-var gs#134714:u8
        let s_528_0: bool = fn_state.gs_134714;
        // N s_528_1: branch s_528_0 b5433 b529
        if s_528_0 {
            return block_5433(state, tracer, fn_state);
        } else {
            return block_529(state, tracer, fn_state);
        };
    }
    fn block_529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_529_0: const #0u : u8
        let s_529_0: bool = false;
        // D s_529_1: write-var gs#134715 <= s_529_0
        fn_state.gs_134715 = s_529_0;
        // N s_529_2: jump b530
        return block_530(state, tracer, fn_state);
    }
    fn block_530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_530_0: read-var gs#134715:u8
        let s_530_0: bool = fn_state.gs_134715;
        // N s_530_1: branch s_530_0 b5432 b531
        if s_530_0 {
            return block_5432(state, tracer, fn_state);
        } else {
            return block_531(state, tracer, fn_state);
        };
    }
    fn block_531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_531_0: read-var CRm:u8
        let s_531_0: u8 = fn_state.CRm;
        // D s_531_1: cast zx s_531_0 -> bv
        let s_531_1: Bits = Bits::new(s_531_0 as u128, 4u16);
        // C s_531_2: const #0u : u8
        let s_531_2: u8 = 0;
        // C s_531_3: cast zx s_531_2 -> bv
        let s_531_3: Bits = Bits::new(s_531_2 as u128, 4u16);
        // D s_531_4: cmp-eq s_531_1 s_531_3
        let s_531_4: bool = ((s_531_1) == (s_531_3));
        // N s_531_5: branch s_531_4 b5431 b532
        if s_531_4 {
            return block_5431(state, tracer, fn_state);
        } else {
            return block_532(state, tracer, fn_state);
        };
    }
    fn block_532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_532_0: const #0u : u8
        let s_532_0: bool = false;
        // D s_532_1: write-var gs#134716 <= s_532_0
        fn_state.gs_134716 = s_532_0;
        // N s_532_2: jump b533
        return block_533(state, tracer, fn_state);
    }
    fn block_533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_533_0: read-var gs#134716:u8
        let s_533_0: bool = fn_state.gs_134716;
        // N s_533_1: branch s_533_0 b5430 b534
        if s_533_0 {
            return block_5430(state, tracer, fn_state);
        } else {
            return block_534(state, tracer, fn_state);
        };
    }
    fn block_534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_534_0: const #0u : u8
        let s_534_0: bool = false;
        // D s_534_1: write-var gs#134717 <= s_534_0
        fn_state.gs_134717 = s_534_0;
        // N s_534_2: jump b535
        return block_535(state, tracer, fn_state);
    }
    fn block_535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_535_0: read-var gs#134717:u8
        let s_535_0: bool = fn_state.gs_134717;
        // N s_535_1: branch s_535_0 b5429 b536
        if s_535_0 {
            return block_5429(state, tracer, fn_state);
        } else {
            return block_536(state, tracer, fn_state);
        };
    }
    fn block_536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_536_0: const #0u : u8
        let s_536_0: bool = false;
        // D s_536_1: write-var gs#134718 <= s_536_0
        fn_state.gs_134718 = s_536_0;
        // N s_536_2: jump b537
        return block_537(state, tracer, fn_state);
    }
    fn block_537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_537_0: read-var gs#134718:u8
        let s_537_0: bool = fn_state.gs_134718;
        // N s_537_1: branch s_537_0 b5428 b538
        if s_537_0 {
            return block_5428(state, tracer, fn_state);
        } else {
            return block_538(state, tracer, fn_state);
        };
    }
    fn block_538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_538_0: const #0u : u8
        let s_538_0: bool = false;
        // D s_538_1: write-var gs#134719 <= s_538_0
        fn_state.gs_134719 = s_538_0;
        // N s_538_2: jump b539
        return block_539(state, tracer, fn_state);
    }
    fn block_539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_539_0: read-var gs#134719:u8
        let s_539_0: bool = fn_state.gs_134719;
        // N s_539_1: branch s_539_0 b5427 b540
        if s_539_0 {
            return block_5427(state, tracer, fn_state);
        } else {
            return block_540(state, tracer, fn_state);
        };
    }
    fn block_540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_540_0: read-var CRm:u8
        let s_540_0: u8 = fn_state.CRm;
        // D s_540_1: cast zx s_540_0 -> bv
        let s_540_1: Bits = Bits::new(s_540_0 as u128, 4u16);
        // C s_540_2: const #0u : u8
        let s_540_2: u8 = 0;
        // C s_540_3: cast zx s_540_2 -> bv
        let s_540_3: Bits = Bits::new(s_540_2 as u128, 4u16);
        // D s_540_4: cmp-eq s_540_1 s_540_3
        let s_540_4: bool = ((s_540_1) == (s_540_3));
        // N s_540_5: branch s_540_4 b5426 b541
        if s_540_4 {
            return block_5426(state, tracer, fn_state);
        } else {
            return block_541(state, tracer, fn_state);
        };
    }
    fn block_541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_541_0: const #0u : u8
        let s_541_0: bool = false;
        // D s_541_1: write-var gs#134720 <= s_541_0
        fn_state.gs_134720 = s_541_0;
        // N s_541_2: jump b542
        return block_542(state, tracer, fn_state);
    }
    fn block_542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_542_0: read-var gs#134720:u8
        let s_542_0: bool = fn_state.gs_134720;
        // N s_542_1: branch s_542_0 b5425 b543
        if s_542_0 {
            return block_5425(state, tracer, fn_state);
        } else {
            return block_543(state, tracer, fn_state);
        };
    }
    fn block_543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_543_0: const #0u : u8
        let s_543_0: bool = false;
        // D s_543_1: write-var gs#134721 <= s_543_0
        fn_state.gs_134721 = s_543_0;
        // N s_543_2: jump b544
        return block_544(state, tracer, fn_state);
    }
    fn block_544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_544_0: read-var gs#134721:u8
        let s_544_0: bool = fn_state.gs_134721;
        // N s_544_1: branch s_544_0 b5424 b545
        if s_544_0 {
            return block_5424(state, tracer, fn_state);
        } else {
            return block_545(state, tracer, fn_state);
        };
    }
    fn block_545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_545_0: const #0u : u8
        let s_545_0: bool = false;
        // D s_545_1: write-var gs#134722 <= s_545_0
        fn_state.gs_134722 = s_545_0;
        // N s_545_2: jump b546
        return block_546(state, tracer, fn_state);
    }
    fn block_546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_546_0: read-var gs#134722:u8
        let s_546_0: bool = fn_state.gs_134722;
        // N s_546_1: branch s_546_0 b5423 b547
        if s_546_0 {
            return block_5423(state, tracer, fn_state);
        } else {
            return block_547(state, tracer, fn_state);
        };
    }
    fn block_547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_547_0: const #0u : u8
        let s_547_0: bool = false;
        // D s_547_1: write-var gs#134723 <= s_547_0
        fn_state.gs_134723 = s_547_0;
        // N s_547_2: jump b548
        return block_548(state, tracer, fn_state);
    }
    fn block_548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_548_0: read-var gs#134723:u8
        let s_548_0: bool = fn_state.gs_134723;
        // N s_548_1: branch s_548_0 b5422 b549
        if s_548_0 {
            return block_5422(state, tracer, fn_state);
        } else {
            return block_549(state, tracer, fn_state);
        };
    }
    fn block_549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_549_0: read-var CRm:u8
        let s_549_0: u8 = fn_state.CRm;
        // D s_549_1: cast zx s_549_0 -> bv
        let s_549_1: Bits = Bits::new(s_549_0 as u128, 4u16);
        // C s_549_2: const #6u : u8
        let s_549_2: u8 = 6;
        // C s_549_3: cast zx s_549_2 -> bv
        let s_549_3: Bits = Bits::new(s_549_2 as u128, 4u16);
        // D s_549_4: cmp-eq s_549_1 s_549_3
        let s_549_4: bool = ((s_549_1) == (s_549_3));
        // N s_549_5: branch s_549_4 b5421 b550
        if s_549_4 {
            return block_5421(state, tracer, fn_state);
        } else {
            return block_550(state, tracer, fn_state);
        };
    }
    fn block_550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_550_0: const #0u : u8
        let s_550_0: bool = false;
        // D s_550_1: write-var gs#134724 <= s_550_0
        fn_state.gs_134724 = s_550_0;
        // N s_550_2: jump b551
        return block_551(state, tracer, fn_state);
    }
    fn block_551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_551_0: read-var gs#134724:u8
        let s_551_0: bool = fn_state.gs_134724;
        // N s_551_1: branch s_551_0 b5420 b552
        if s_551_0 {
            return block_5420(state, tracer, fn_state);
        } else {
            return block_552(state, tracer, fn_state);
        };
    }
    fn block_552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_552_0: const #0u : u8
        let s_552_0: bool = false;
        // D s_552_1: write-var gs#134725 <= s_552_0
        fn_state.gs_134725 = s_552_0;
        // N s_552_2: jump b553
        return block_553(state, tracer, fn_state);
    }
    fn block_553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_553_0: read-var gs#134725:u8
        let s_553_0: bool = fn_state.gs_134725;
        // N s_553_1: branch s_553_0 b5419 b554
        if s_553_0 {
            return block_5419(state, tracer, fn_state);
        } else {
            return block_554(state, tracer, fn_state);
        };
    }
    fn block_554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_554_0: const #0u : u8
        let s_554_0: bool = false;
        // D s_554_1: write-var gs#134726 <= s_554_0
        fn_state.gs_134726 = s_554_0;
        // N s_554_2: jump b555
        return block_555(state, tracer, fn_state);
    }
    fn block_555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_555_0: read-var gs#134726:u8
        let s_555_0: bool = fn_state.gs_134726;
        // N s_555_1: branch s_555_0 b5418 b556
        if s_555_0 {
            return block_5418(state, tracer, fn_state);
        } else {
            return block_556(state, tracer, fn_state);
        };
    }
    fn block_556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_556_0: const #0u : u8
        let s_556_0: bool = false;
        // D s_556_1: write-var gs#134727 <= s_556_0
        fn_state.gs_134727 = s_556_0;
        // N s_556_2: jump b557
        return block_557(state, tracer, fn_state);
    }
    fn block_557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_557_0: read-var gs#134727:u8
        let s_557_0: bool = fn_state.gs_134727;
        // N s_557_1: branch s_557_0 b5417 b558
        if s_557_0 {
            return block_5417(state, tracer, fn_state);
        } else {
            return block_558(state, tracer, fn_state);
        };
    }
    fn block_558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_558_0: read-var CRm:u8
        let s_558_0: u8 = fn_state.CRm;
        // D s_558_1: cast zx s_558_0 -> bv
        let s_558_1: Bits = Bits::new(s_558_0 as u128, 4u16);
        // C s_558_2: const #3u : u8
        let s_558_2: u8 = 3;
        // C s_558_3: cast zx s_558_2 -> bv
        let s_558_3: Bits = Bits::new(s_558_2 as u128, 4u16);
        // D s_558_4: cmp-eq s_558_1 s_558_3
        let s_558_4: bool = ((s_558_1) == (s_558_3));
        // N s_558_5: branch s_558_4 b5416 b559
        if s_558_4 {
            return block_5416(state, tracer, fn_state);
        } else {
            return block_559(state, tracer, fn_state);
        };
    }
    fn block_559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_559_0: const #0u : u8
        let s_559_0: bool = false;
        // D s_559_1: write-var gs#134728 <= s_559_0
        fn_state.gs_134728 = s_559_0;
        // N s_559_2: jump b560
        return block_560(state, tracer, fn_state);
    }
    fn block_560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_560_0: read-var gs#134728:u8
        let s_560_0: bool = fn_state.gs_134728;
        // N s_560_1: branch s_560_0 b5415 b561
        if s_560_0 {
            return block_5415(state, tracer, fn_state);
        } else {
            return block_561(state, tracer, fn_state);
        };
    }
    fn block_561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_561_0: const #0u : u8
        let s_561_0: bool = false;
        // D s_561_1: write-var gs#134729 <= s_561_0
        fn_state.gs_134729 = s_561_0;
        // N s_561_2: jump b562
        return block_562(state, tracer, fn_state);
    }
    fn block_562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_562_0: read-var gs#134729:u8
        let s_562_0: bool = fn_state.gs_134729;
        // N s_562_1: branch s_562_0 b5414 b563
        if s_562_0 {
            return block_5414(state, tracer, fn_state);
        } else {
            return block_563(state, tracer, fn_state);
        };
    }
    fn block_563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_563_0: const #0u : u8
        let s_563_0: bool = false;
        // D s_563_1: write-var gs#134730 <= s_563_0
        fn_state.gs_134730 = s_563_0;
        // N s_563_2: jump b564
        return block_564(state, tracer, fn_state);
    }
    fn block_564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_564_0: read-var gs#134730:u8
        let s_564_0: bool = fn_state.gs_134730;
        // N s_564_1: branch s_564_0 b5413 b565
        if s_564_0 {
            return block_5413(state, tracer, fn_state);
        } else {
            return block_565(state, tracer, fn_state);
        };
    }
    fn block_565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_565_0: const #0u : u8
        let s_565_0: bool = false;
        // D s_565_1: write-var gs#134731 <= s_565_0
        fn_state.gs_134731 = s_565_0;
        // N s_565_2: jump b566
        return block_566(state, tracer, fn_state);
    }
    fn block_566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_566_0: read-var gs#134731:u8
        let s_566_0: bool = fn_state.gs_134731;
        // N s_566_1: branch s_566_0 b5412 b567
        if s_566_0 {
            return block_5412(state, tracer, fn_state);
        } else {
            return block_567(state, tracer, fn_state);
        };
    }
    fn block_567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_567_0: read-var CRm:u8
        let s_567_0: u8 = fn_state.CRm;
        // D s_567_1: cast zx s_567_0 -> bv
        let s_567_1: Bits = Bits::new(s_567_0 as u128, 4u16);
        // C s_567_2: const #7u : u8
        let s_567_2: u8 = 7;
        // C s_567_3: cast zx s_567_2 -> bv
        let s_567_3: Bits = Bits::new(s_567_2 as u128, 4u16);
        // D s_567_4: cmp-eq s_567_1 s_567_3
        let s_567_4: bool = ((s_567_1) == (s_567_3));
        // N s_567_5: branch s_567_4 b5411 b568
        if s_567_4 {
            return block_5411(state, tracer, fn_state);
        } else {
            return block_568(state, tracer, fn_state);
        };
    }
    fn block_568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_568_0: const #0u : u8
        let s_568_0: bool = false;
        // D s_568_1: write-var gs#134732 <= s_568_0
        fn_state.gs_134732 = s_568_0;
        // N s_568_2: jump b569
        return block_569(state, tracer, fn_state);
    }
    fn block_569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_569_0: read-var gs#134732:u8
        let s_569_0: bool = fn_state.gs_134732;
        // N s_569_1: branch s_569_0 b5410 b570
        if s_569_0 {
            return block_5410(state, tracer, fn_state);
        } else {
            return block_570(state, tracer, fn_state);
        };
    }
    fn block_570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_570_0: const #0u : u8
        let s_570_0: bool = false;
        // D s_570_1: write-var gs#134733 <= s_570_0
        fn_state.gs_134733 = s_570_0;
        // N s_570_2: jump b571
        return block_571(state, tracer, fn_state);
    }
    fn block_571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_571_0: read-var gs#134733:u8
        let s_571_0: bool = fn_state.gs_134733;
        // N s_571_1: branch s_571_0 b5409 b572
        if s_571_0 {
            return block_5409(state, tracer, fn_state);
        } else {
            return block_572(state, tracer, fn_state);
        };
    }
    fn block_572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_572_0: const #0u : u8
        let s_572_0: bool = false;
        // D s_572_1: write-var gs#134734 <= s_572_0
        fn_state.gs_134734 = s_572_0;
        // N s_572_2: jump b573
        return block_573(state, tracer, fn_state);
    }
    fn block_573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_573_0: read-var gs#134734:u8
        let s_573_0: bool = fn_state.gs_134734;
        // N s_573_1: branch s_573_0 b5408 b574
        if s_573_0 {
            return block_5408(state, tracer, fn_state);
        } else {
            return block_574(state, tracer, fn_state);
        };
    }
    fn block_574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_574_0: const #0u : u8
        let s_574_0: bool = false;
        // D s_574_1: write-var gs#134735 <= s_574_0
        fn_state.gs_134735 = s_574_0;
        // N s_574_2: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_575_0: read-var gs#134735:u8
        let s_575_0: bool = fn_state.gs_134735;
        // N s_575_1: branch s_575_0 b5407 b576
        if s_575_0 {
            return block_5407(state, tracer, fn_state);
        } else {
            return block_576(state, tracer, fn_state);
        };
    }
    fn block_576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_576_0: read-var CRm:u8
        let s_576_0: u8 = fn_state.CRm;
        // D s_576_1: cast zx s_576_0 -> bv
        let s_576_1: Bits = Bits::new(s_576_0 as u128, 4u16);
        // C s_576_2: const #4u : u8
        let s_576_2: u8 = 4;
        // C s_576_3: cast zx s_576_2 -> bv
        let s_576_3: Bits = Bits::new(s_576_2 as u128, 4u16);
        // D s_576_4: cmp-eq s_576_1 s_576_3
        let s_576_4: bool = ((s_576_1) == (s_576_3));
        // N s_576_5: branch s_576_4 b5406 b577
        if s_576_4 {
            return block_5406(state, tracer, fn_state);
        } else {
            return block_577(state, tracer, fn_state);
        };
    }
    fn block_577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_577_0: const #0u : u8
        let s_577_0: bool = false;
        // D s_577_1: write-var gs#134736 <= s_577_0
        fn_state.gs_134736 = s_577_0;
        // N s_577_2: jump b578
        return block_578(state, tracer, fn_state);
    }
    fn block_578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_578_0: read-var gs#134736:u8
        let s_578_0: bool = fn_state.gs_134736;
        // N s_578_1: branch s_578_0 b5405 b579
        if s_578_0 {
            return block_5405(state, tracer, fn_state);
        } else {
            return block_579(state, tracer, fn_state);
        };
    }
    fn block_579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_579_0: const #0u : u8
        let s_579_0: bool = false;
        // D s_579_1: write-var gs#134737 <= s_579_0
        fn_state.gs_134737 = s_579_0;
        // N s_579_2: jump b580
        return block_580(state, tracer, fn_state);
    }
    fn block_580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_580_0: read-var gs#134737:u8
        let s_580_0: bool = fn_state.gs_134737;
        // N s_580_1: branch s_580_0 b5404 b581
        if s_580_0 {
            return block_5404(state, tracer, fn_state);
        } else {
            return block_581(state, tracer, fn_state);
        };
    }
    fn block_581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_581_0: const #0u : u8
        let s_581_0: bool = false;
        // D s_581_1: write-var gs#134738 <= s_581_0
        fn_state.gs_134738 = s_581_0;
        // N s_581_2: jump b582
        return block_582(state, tracer, fn_state);
    }
    fn block_582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_582_0: read-var gs#134738:u8
        let s_582_0: bool = fn_state.gs_134738;
        // N s_582_1: branch s_582_0 b5403 b583
        if s_582_0 {
            return block_5403(state, tracer, fn_state);
        } else {
            return block_583(state, tracer, fn_state);
        };
    }
    fn block_583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_583_0: const #0u : u8
        let s_583_0: bool = false;
        // D s_583_1: write-var gs#134739 <= s_583_0
        fn_state.gs_134739 = s_583_0;
        // N s_583_2: jump b584
        return block_584(state, tracer, fn_state);
    }
    fn block_584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_584_0: read-var gs#134739:u8
        let s_584_0: bool = fn_state.gs_134739;
        // N s_584_1: branch s_584_0 b5402 b585
        if s_584_0 {
            return block_5402(state, tracer, fn_state);
        } else {
            return block_585(state, tracer, fn_state);
        };
    }
    fn block_585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_585_0: read-var CRm:u8
        let s_585_0: u8 = fn_state.CRm;
        // D s_585_1: cast zx s_585_0 -> bv
        let s_585_1: Bits = Bits::new(s_585_0 as u128, 4u16);
        // C s_585_2: const #0u : u8
        let s_585_2: u8 = 0;
        // C s_585_3: cast zx s_585_2 -> bv
        let s_585_3: Bits = Bits::new(s_585_2 as u128, 4u16);
        // D s_585_4: cmp-eq s_585_1 s_585_3
        let s_585_4: bool = ((s_585_1) == (s_585_3));
        // N s_585_5: branch s_585_4 b5401 b586
        if s_585_4 {
            return block_5401(state, tracer, fn_state);
        } else {
            return block_586(state, tracer, fn_state);
        };
    }
    fn block_586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_586_0: const #0u : u8
        let s_586_0: bool = false;
        // D s_586_1: write-var gs#134740 <= s_586_0
        fn_state.gs_134740 = s_586_0;
        // N s_586_2: jump b587
        return block_587(state, tracer, fn_state);
    }
    fn block_587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_587_0: read-var gs#134740:u8
        let s_587_0: bool = fn_state.gs_134740;
        // N s_587_1: branch s_587_0 b5400 b588
        if s_587_0 {
            return block_5400(state, tracer, fn_state);
        } else {
            return block_588(state, tracer, fn_state);
        };
    }
    fn block_588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_588_0: const #0u : u8
        let s_588_0: bool = false;
        // D s_588_1: write-var gs#134741 <= s_588_0
        fn_state.gs_134741 = s_588_0;
        // N s_588_2: jump b589
        return block_589(state, tracer, fn_state);
    }
    fn block_589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_589_0: read-var gs#134741:u8
        let s_589_0: bool = fn_state.gs_134741;
        // N s_589_1: branch s_589_0 b5399 b590
        if s_589_0 {
            return block_5399(state, tracer, fn_state);
        } else {
            return block_590(state, tracer, fn_state);
        };
    }
    fn block_590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_590_0: const #0u : u8
        let s_590_0: bool = false;
        // D s_590_1: write-var gs#134742 <= s_590_0
        fn_state.gs_134742 = s_590_0;
        // N s_590_2: jump b591
        return block_591(state, tracer, fn_state);
    }
    fn block_591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_591_0: read-var gs#134742:u8
        let s_591_0: bool = fn_state.gs_134742;
        // N s_591_1: branch s_591_0 b5398 b592
        if s_591_0 {
            return block_5398(state, tracer, fn_state);
        } else {
            return block_592(state, tracer, fn_state);
        };
    }
    fn block_592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_592_0: const #0u : u8
        let s_592_0: bool = false;
        // D s_592_1: write-var gs#134743 <= s_592_0
        fn_state.gs_134743 = s_592_0;
        // N s_592_2: jump b593
        return block_593(state, tracer, fn_state);
    }
    fn block_593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_593_0: read-var gs#134743:u8
        let s_593_0: bool = fn_state.gs_134743;
        // N s_593_1: branch s_593_0 b5397 b594
        if s_593_0 {
            return block_5397(state, tracer, fn_state);
        } else {
            return block_594(state, tracer, fn_state);
        };
    }
    fn block_594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_594_0: read-var CRm:u8
        let s_594_0: u8 = fn_state.CRm;
        // D s_594_1: cast zx s_594_0 -> bv
        let s_594_1: Bits = Bits::new(s_594_0 as u128, 4u16);
        // C s_594_2: const #3u : u8
        let s_594_2: u8 = 3;
        // C s_594_3: cast zx s_594_2 -> bv
        let s_594_3: Bits = Bits::new(s_594_2 as u128, 4u16);
        // D s_594_4: cmp-eq s_594_1 s_594_3
        let s_594_4: bool = ((s_594_1) == (s_594_3));
        // N s_594_5: branch s_594_4 b5396 b595
        if s_594_4 {
            return block_5396(state, tracer, fn_state);
        } else {
            return block_595(state, tracer, fn_state);
        };
    }
    fn block_595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_595_0: const #0u : u8
        let s_595_0: bool = false;
        // D s_595_1: write-var gs#134744 <= s_595_0
        fn_state.gs_134744 = s_595_0;
        // N s_595_2: jump b596
        return block_596(state, tracer, fn_state);
    }
    fn block_596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_596_0: read-var gs#134744:u8
        let s_596_0: bool = fn_state.gs_134744;
        // N s_596_1: branch s_596_0 b5395 b597
        if s_596_0 {
            return block_5395(state, tracer, fn_state);
        } else {
            return block_597(state, tracer, fn_state);
        };
    }
    fn block_597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_597_0: const #0u : u8
        let s_597_0: bool = false;
        // D s_597_1: write-var gs#134745 <= s_597_0
        fn_state.gs_134745 = s_597_0;
        // N s_597_2: jump b598
        return block_598(state, tracer, fn_state);
    }
    fn block_598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_598_0: read-var gs#134745:u8
        let s_598_0: bool = fn_state.gs_134745;
        // N s_598_1: branch s_598_0 b5394 b599
        if s_598_0 {
            return block_5394(state, tracer, fn_state);
        } else {
            return block_599(state, tracer, fn_state);
        };
    }
    fn block_599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_599_0: const #0u : u8
        let s_599_0: bool = false;
        // D s_599_1: write-var gs#134746 <= s_599_0
        fn_state.gs_134746 = s_599_0;
        // N s_599_2: jump b600
        return block_600(state, tracer, fn_state);
    }
    fn block_600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_600_0: read-var gs#134746:u8
        let s_600_0: bool = fn_state.gs_134746;
        // N s_600_1: branch s_600_0 b5393 b601
        if s_600_0 {
            return block_5393(state, tracer, fn_state);
        } else {
            return block_601(state, tracer, fn_state);
        };
    }
    fn block_601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_601_0: const #0u : u8
        let s_601_0: bool = false;
        // D s_601_1: write-var gs#134747 <= s_601_0
        fn_state.gs_134747 = s_601_0;
        // N s_601_2: jump b602
        return block_602(state, tracer, fn_state);
    }
    fn block_602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_602_0: read-var gs#134747:u8
        let s_602_0: bool = fn_state.gs_134747;
        // N s_602_1: branch s_602_0 b5392 b603
        if s_602_0 {
            return block_5392(state, tracer, fn_state);
        } else {
            return block_603(state, tracer, fn_state);
        };
    }
    fn block_603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_603_0: read-var CRm:u8
        let s_603_0: u8 = fn_state.CRm;
        // D s_603_1: cast zx s_603_0 -> bv
        let s_603_1: Bits = Bits::new(s_603_0 as u128, 4u16);
        // C s_603_2: const #9u : u8
        let s_603_2: u8 = 9;
        // C s_603_3: cast zx s_603_2 -> bv
        let s_603_3: Bits = Bits::new(s_603_2 as u128, 4u16);
        // D s_603_4: cmp-eq s_603_1 s_603_3
        let s_603_4: bool = ((s_603_1) == (s_603_3));
        // N s_603_5: branch s_603_4 b5391 b604
        if s_603_4 {
            return block_5391(state, tracer, fn_state);
        } else {
            return block_604(state, tracer, fn_state);
        };
    }
    fn block_604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_604_0: const #0u : u8
        let s_604_0: bool = false;
        // D s_604_1: write-var gs#134748 <= s_604_0
        fn_state.gs_134748 = s_604_0;
        // N s_604_2: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_605_0: read-var gs#134748:u8
        let s_605_0: bool = fn_state.gs_134748;
        // N s_605_1: branch s_605_0 b5390 b606
        if s_605_0 {
            return block_5390(state, tracer, fn_state);
        } else {
            return block_606(state, tracer, fn_state);
        };
    }
    fn block_606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_606_0: const #0u : u8
        let s_606_0: bool = false;
        // D s_606_1: write-var gs#134749 <= s_606_0
        fn_state.gs_134749 = s_606_0;
        // N s_606_2: jump b607
        return block_607(state, tracer, fn_state);
    }
    fn block_607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_607_0: read-var gs#134749:u8
        let s_607_0: bool = fn_state.gs_134749;
        // N s_607_1: branch s_607_0 b5389 b608
        if s_607_0 {
            return block_5389(state, tracer, fn_state);
        } else {
            return block_608(state, tracer, fn_state);
        };
    }
    fn block_608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_608_0: const #0u : u8
        let s_608_0: bool = false;
        // D s_608_1: write-var gs#134750 <= s_608_0
        fn_state.gs_134750 = s_608_0;
        // N s_608_2: jump b609
        return block_609(state, tracer, fn_state);
    }
    fn block_609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_609_0: read-var gs#134750:u8
        let s_609_0: bool = fn_state.gs_134750;
        // N s_609_1: branch s_609_0 b5388 b610
        if s_609_0 {
            return block_5388(state, tracer, fn_state);
        } else {
            return block_610(state, tracer, fn_state);
        };
    }
    fn block_610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_610_0: const #0u : u8
        let s_610_0: bool = false;
        // D s_610_1: write-var gs#134751 <= s_610_0
        fn_state.gs_134751 = s_610_0;
        // N s_610_2: jump b611
        return block_611(state, tracer, fn_state);
    }
    fn block_611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_611_0: read-var gs#134751:u8
        let s_611_0: bool = fn_state.gs_134751;
        // N s_611_1: branch s_611_0 b5387 b612
        if s_611_0 {
            return block_5387(state, tracer, fn_state);
        } else {
            return block_612(state, tracer, fn_state);
        };
    }
    fn block_612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_612_0: read-var CRm:u8
        let s_612_0: u8 = fn_state.CRm;
        // D s_612_1: cast zx s_612_0 -> bv
        let s_612_1: Bits = Bits::new(s_612_0 as u128, 4u16);
        // C s_612_2: const #15u : u8
        let s_612_2: u8 = 15;
        // C s_612_3: cast zx s_612_2 -> bv
        let s_612_3: Bits = Bits::new(s_612_2 as u128, 4u16);
        // D s_612_4: cmp-eq s_612_1 s_612_3
        let s_612_4: bool = ((s_612_1) == (s_612_3));
        // N s_612_5: branch s_612_4 b5386 b613
        if s_612_4 {
            return block_5386(state, tracer, fn_state);
        } else {
            return block_613(state, tracer, fn_state);
        };
    }
    fn block_613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_613_0: const #0u : u8
        let s_613_0: bool = false;
        // D s_613_1: write-var gs#134752 <= s_613_0
        fn_state.gs_134752 = s_613_0;
        // N s_613_2: jump b614
        return block_614(state, tracer, fn_state);
    }
    fn block_614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_614_0: read-var gs#134752:u8
        let s_614_0: bool = fn_state.gs_134752;
        // N s_614_1: branch s_614_0 b5385 b615
        if s_614_0 {
            return block_5385(state, tracer, fn_state);
        } else {
            return block_615(state, tracer, fn_state);
        };
    }
    fn block_615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_615_0: const #0u : u8
        let s_615_0: bool = false;
        // D s_615_1: write-var gs#134753 <= s_615_0
        fn_state.gs_134753 = s_615_0;
        // N s_615_2: jump b616
        return block_616(state, tracer, fn_state);
    }
    fn block_616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_616_0: read-var gs#134753:u8
        let s_616_0: bool = fn_state.gs_134753;
        // N s_616_1: branch s_616_0 b5384 b617
        if s_616_0 {
            return block_5384(state, tracer, fn_state);
        } else {
            return block_617(state, tracer, fn_state);
        };
    }
    fn block_617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_617_0: const #0u : u8
        let s_617_0: bool = false;
        // D s_617_1: write-var gs#134754 <= s_617_0
        fn_state.gs_134754 = s_617_0;
        // N s_617_2: jump b618
        return block_618(state, tracer, fn_state);
    }
    fn block_618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_618_0: read-var gs#134754:u8
        let s_618_0: bool = fn_state.gs_134754;
        // N s_618_1: branch s_618_0 b5383 b619
        if s_618_0 {
            return block_5383(state, tracer, fn_state);
        } else {
            return block_619(state, tracer, fn_state);
        };
    }
    fn block_619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_619_0: const #0u : u8
        let s_619_0: bool = false;
        // D s_619_1: write-var gs#134755 <= s_619_0
        fn_state.gs_134755 = s_619_0;
        // N s_619_2: jump b620
        return block_620(state, tracer, fn_state);
    }
    fn block_620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_620_0: read-var gs#134755:u8
        let s_620_0: bool = fn_state.gs_134755;
        // N s_620_1: branch s_620_0 b5382 b621
        if s_620_0 {
            return block_5382(state, tracer, fn_state);
        } else {
            return block_621(state, tracer, fn_state);
        };
    }
    fn block_621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_621_0: read-var CRm:u8
        let s_621_0: u8 = fn_state.CRm;
        // D s_621_1: cast zx s_621_0 -> bv
        let s_621_1: Bits = Bits::new(s_621_0 as u128, 4u16);
        // C s_621_2: const #14u : u8
        let s_621_2: u8 = 14;
        // C s_621_3: cast zx s_621_2 -> bv
        let s_621_3: Bits = Bits::new(s_621_2 as u128, 4u16);
        // D s_621_4: cmp-eq s_621_1 s_621_3
        let s_621_4: bool = ((s_621_1) == (s_621_3));
        // N s_621_5: branch s_621_4 b5381 b622
        if s_621_4 {
            return block_5381(state, tracer, fn_state);
        } else {
            return block_622(state, tracer, fn_state);
        };
    }
    fn block_622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_622_0: const #0u : u8
        let s_622_0: bool = false;
        // D s_622_1: write-var gs#134756 <= s_622_0
        fn_state.gs_134756 = s_622_0;
        // N s_622_2: jump b623
        return block_623(state, tracer, fn_state);
    }
    fn block_623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_623_0: read-var gs#134756:u8
        let s_623_0: bool = fn_state.gs_134756;
        // N s_623_1: branch s_623_0 b5380 b624
        if s_623_0 {
            return block_5380(state, tracer, fn_state);
        } else {
            return block_624(state, tracer, fn_state);
        };
    }
    fn block_624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_624_0: const #0u : u8
        let s_624_0: bool = false;
        // D s_624_1: write-var gs#134757 <= s_624_0
        fn_state.gs_134757 = s_624_0;
        // N s_624_2: jump b625
        return block_625(state, tracer, fn_state);
    }
    fn block_625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_625_0: read-var gs#134757:u8
        let s_625_0: bool = fn_state.gs_134757;
        // N s_625_1: branch s_625_0 b5379 b626
        if s_625_0 {
            return block_5379(state, tracer, fn_state);
        } else {
            return block_626(state, tracer, fn_state);
        };
    }
    fn block_626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_626_0: const #0u : u8
        let s_626_0: bool = false;
        // D s_626_1: write-var gs#134758 <= s_626_0
        fn_state.gs_134758 = s_626_0;
        // N s_626_2: jump b627
        return block_627(state, tracer, fn_state);
    }
    fn block_627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_627_0: read-var gs#134758:u8
        let s_627_0: bool = fn_state.gs_134758;
        // N s_627_1: branch s_627_0 b5378 b628
        if s_627_0 {
            return block_5378(state, tracer, fn_state);
        } else {
            return block_628(state, tracer, fn_state);
        };
    }
    fn block_628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_628_0: const #0u : u8
        let s_628_0: bool = false;
        // D s_628_1: write-var gs#134759 <= s_628_0
        fn_state.gs_134759 = s_628_0;
        // N s_628_2: jump b629
        return block_629(state, tracer, fn_state);
    }
    fn block_629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_629_0: read-var gs#134759:u8
        let s_629_0: bool = fn_state.gs_134759;
        // N s_629_1: branch s_629_0 b5377 b630
        if s_629_0 {
            return block_5377(state, tracer, fn_state);
        } else {
            return block_630(state, tracer, fn_state);
        };
    }
    fn block_630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_630_0: read-var CRm:u8
        let s_630_0: u8 = fn_state.CRm;
        // D s_630_1: cast zx s_630_0 -> bv
        let s_630_1: Bits = Bits::new(s_630_0 as u128, 4u16);
        // C s_630_2: const #13u : u8
        let s_630_2: u8 = 13;
        // C s_630_3: cast zx s_630_2 -> bv
        let s_630_3: Bits = Bits::new(s_630_2 as u128, 4u16);
        // D s_630_4: cmp-eq s_630_1 s_630_3
        let s_630_4: bool = ((s_630_1) == (s_630_3));
        // N s_630_5: branch s_630_4 b5376 b631
        if s_630_4 {
            return block_5376(state, tracer, fn_state);
        } else {
            return block_631(state, tracer, fn_state);
        };
    }
    fn block_631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_631_0: const #0u : u8
        let s_631_0: bool = false;
        // D s_631_1: write-var gs#134760 <= s_631_0
        fn_state.gs_134760 = s_631_0;
        // N s_631_2: jump b632
        return block_632(state, tracer, fn_state);
    }
    fn block_632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_632_0: read-var gs#134760:u8
        let s_632_0: bool = fn_state.gs_134760;
        // N s_632_1: branch s_632_0 b5375 b633
        if s_632_0 {
            return block_5375(state, tracer, fn_state);
        } else {
            return block_633(state, tracer, fn_state);
        };
    }
    fn block_633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_633_0: const #0u : u8
        let s_633_0: bool = false;
        // D s_633_1: write-var gs#134761 <= s_633_0
        fn_state.gs_134761 = s_633_0;
        // N s_633_2: jump b634
        return block_634(state, tracer, fn_state);
    }
    fn block_634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_634_0: read-var gs#134761:u8
        let s_634_0: bool = fn_state.gs_134761;
        // N s_634_1: branch s_634_0 b5374 b635
        if s_634_0 {
            return block_5374(state, tracer, fn_state);
        } else {
            return block_635(state, tracer, fn_state);
        };
    }
    fn block_635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_635_0: const #0u : u8
        let s_635_0: bool = false;
        // D s_635_1: write-var gs#134762 <= s_635_0
        fn_state.gs_134762 = s_635_0;
        // N s_635_2: jump b636
        return block_636(state, tracer, fn_state);
    }
    fn block_636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_636_0: read-var gs#134762:u8
        let s_636_0: bool = fn_state.gs_134762;
        // N s_636_1: branch s_636_0 b5373 b637
        if s_636_0 {
            return block_5373(state, tracer, fn_state);
        } else {
            return block_637(state, tracer, fn_state);
        };
    }
    fn block_637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_637_0: const #0u : u8
        let s_637_0: bool = false;
        // D s_637_1: write-var gs#134763 <= s_637_0
        fn_state.gs_134763 = s_637_0;
        // N s_637_2: jump b638
        return block_638(state, tracer, fn_state);
    }
    fn block_638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_638_0: read-var gs#134763:u8
        let s_638_0: bool = fn_state.gs_134763;
        // N s_638_1: branch s_638_0 b5372 b639
        if s_638_0 {
            return block_5372(state, tracer, fn_state);
        } else {
            return block_639(state, tracer, fn_state);
        };
    }
    fn block_639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_639_0: read-var CRm:u8
        let s_639_0: u8 = fn_state.CRm;
        // D s_639_1: cast zx s_639_0 -> bv
        let s_639_1: Bits = Bits::new(s_639_0 as u128, 4u16);
        // C s_639_2: const #12u : u8
        let s_639_2: u8 = 12;
        // C s_639_3: cast zx s_639_2 -> bv
        let s_639_3: Bits = Bits::new(s_639_2 as u128, 4u16);
        // D s_639_4: cmp-eq s_639_1 s_639_3
        let s_639_4: bool = ((s_639_1) == (s_639_3));
        // N s_639_5: branch s_639_4 b5371 b640
        if s_639_4 {
            return block_5371(state, tracer, fn_state);
        } else {
            return block_640(state, tracer, fn_state);
        };
    }
    fn block_640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_640_0: const #0u : u8
        let s_640_0: bool = false;
        // D s_640_1: write-var gs#134764 <= s_640_0
        fn_state.gs_134764 = s_640_0;
        // N s_640_2: jump b641
        return block_641(state, tracer, fn_state);
    }
    fn block_641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_641_0: read-var gs#134764:u8
        let s_641_0: bool = fn_state.gs_134764;
        // N s_641_1: branch s_641_0 b5370 b642
        if s_641_0 {
            return block_5370(state, tracer, fn_state);
        } else {
            return block_642(state, tracer, fn_state);
        };
    }
    fn block_642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_642_0: const #0u : u8
        let s_642_0: bool = false;
        // D s_642_1: write-var gs#134765 <= s_642_0
        fn_state.gs_134765 = s_642_0;
        // N s_642_2: jump b643
        return block_643(state, tracer, fn_state);
    }
    fn block_643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_643_0: read-var gs#134765:u8
        let s_643_0: bool = fn_state.gs_134765;
        // N s_643_1: branch s_643_0 b5369 b644
        if s_643_0 {
            return block_5369(state, tracer, fn_state);
        } else {
            return block_644(state, tracer, fn_state);
        };
    }
    fn block_644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_644_0: const #0u : u8
        let s_644_0: bool = false;
        // D s_644_1: write-var gs#134766 <= s_644_0
        fn_state.gs_134766 = s_644_0;
        // N s_644_2: jump b645
        return block_645(state, tracer, fn_state);
    }
    fn block_645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_645_0: read-var gs#134766:u8
        let s_645_0: bool = fn_state.gs_134766;
        // N s_645_1: branch s_645_0 b5368 b646
        if s_645_0 {
            return block_5368(state, tracer, fn_state);
        } else {
            return block_646(state, tracer, fn_state);
        };
    }
    fn block_646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_646_0: const #0u : u8
        let s_646_0: bool = false;
        // D s_646_1: write-var gs#134767 <= s_646_0
        fn_state.gs_134767 = s_646_0;
        // N s_646_2: jump b647
        return block_647(state, tracer, fn_state);
    }
    fn block_647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_647_0: read-var gs#134767:u8
        let s_647_0: bool = fn_state.gs_134767;
        // N s_647_1: branch s_647_0 b5367 b648
        if s_647_0 {
            return block_5367(state, tracer, fn_state);
        } else {
            return block_648(state, tracer, fn_state);
        };
    }
    fn block_648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_648_0: read-var CRm:u8
        let s_648_0: u8 = fn_state.CRm;
        // D s_648_1: cast zx s_648_0 -> bv
        let s_648_1: Bits = Bits::new(s_648_0 as u128, 4u16);
        // C s_648_2: const #11u : u8
        let s_648_2: u8 = 11;
        // C s_648_3: cast zx s_648_2 -> bv
        let s_648_3: Bits = Bits::new(s_648_2 as u128, 4u16);
        // D s_648_4: cmp-eq s_648_1 s_648_3
        let s_648_4: bool = ((s_648_1) == (s_648_3));
        // N s_648_5: branch s_648_4 b5366 b649
        if s_648_4 {
            return block_5366(state, tracer, fn_state);
        } else {
            return block_649(state, tracer, fn_state);
        };
    }
    fn block_649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_649_0: const #0u : u8
        let s_649_0: bool = false;
        // D s_649_1: write-var gs#134768 <= s_649_0
        fn_state.gs_134768 = s_649_0;
        // N s_649_2: jump b650
        return block_650(state, tracer, fn_state);
    }
    fn block_650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_650_0: read-var gs#134768:u8
        let s_650_0: bool = fn_state.gs_134768;
        // N s_650_1: branch s_650_0 b5365 b651
        if s_650_0 {
            return block_5365(state, tracer, fn_state);
        } else {
            return block_651(state, tracer, fn_state);
        };
    }
    fn block_651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_651_0: const #0u : u8
        let s_651_0: bool = false;
        // D s_651_1: write-var gs#134769 <= s_651_0
        fn_state.gs_134769 = s_651_0;
        // N s_651_2: jump b652
        return block_652(state, tracer, fn_state);
    }
    fn block_652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_652_0: read-var gs#134769:u8
        let s_652_0: bool = fn_state.gs_134769;
        // N s_652_1: branch s_652_0 b5364 b653
        if s_652_0 {
            return block_5364(state, tracer, fn_state);
        } else {
            return block_653(state, tracer, fn_state);
        };
    }
    fn block_653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_653_0: const #0u : u8
        let s_653_0: bool = false;
        // D s_653_1: write-var gs#134770 <= s_653_0
        fn_state.gs_134770 = s_653_0;
        // N s_653_2: jump b654
        return block_654(state, tracer, fn_state);
    }
    fn block_654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_654_0: read-var gs#134770:u8
        let s_654_0: bool = fn_state.gs_134770;
        // N s_654_1: branch s_654_0 b5363 b655
        if s_654_0 {
            return block_5363(state, tracer, fn_state);
        } else {
            return block_655(state, tracer, fn_state);
        };
    }
    fn block_655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_655_0: const #0u : u8
        let s_655_0: bool = false;
        // D s_655_1: write-var gs#134771 <= s_655_0
        fn_state.gs_134771 = s_655_0;
        // N s_655_2: jump b656
        return block_656(state, tracer, fn_state);
    }
    fn block_656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_656_0: read-var gs#134771:u8
        let s_656_0: bool = fn_state.gs_134771;
        // N s_656_1: branch s_656_0 b5362 b657
        if s_656_0 {
            return block_5362(state, tracer, fn_state);
        } else {
            return block_657(state, tracer, fn_state);
        };
    }
    fn block_657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_657_0: read-var CRm:u8
        let s_657_0: u8 = fn_state.CRm;
        // D s_657_1: cast zx s_657_0 -> bv
        let s_657_1: Bits = Bits::new(s_657_0 as u128, 4u16);
        // C s_657_2: const #10u : u8
        let s_657_2: u8 = 10;
        // C s_657_3: cast zx s_657_2 -> bv
        let s_657_3: Bits = Bits::new(s_657_2 as u128, 4u16);
        // D s_657_4: cmp-eq s_657_1 s_657_3
        let s_657_4: bool = ((s_657_1) == (s_657_3));
        // N s_657_5: branch s_657_4 b5361 b658
        if s_657_4 {
            return block_5361(state, tracer, fn_state);
        } else {
            return block_658(state, tracer, fn_state);
        };
    }
    fn block_658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_658_0: const #0u : u8
        let s_658_0: bool = false;
        // D s_658_1: write-var gs#134772 <= s_658_0
        fn_state.gs_134772 = s_658_0;
        // N s_658_2: jump b659
        return block_659(state, tracer, fn_state);
    }
    fn block_659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_659_0: read-var gs#134772:u8
        let s_659_0: bool = fn_state.gs_134772;
        // N s_659_1: branch s_659_0 b5360 b660
        if s_659_0 {
            return block_5360(state, tracer, fn_state);
        } else {
            return block_660(state, tracer, fn_state);
        };
    }
    fn block_660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_660_0: const #0u : u8
        let s_660_0: bool = false;
        // D s_660_1: write-var gs#134773 <= s_660_0
        fn_state.gs_134773 = s_660_0;
        // N s_660_2: jump b661
        return block_661(state, tracer, fn_state);
    }
    fn block_661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_661_0: read-var gs#134773:u8
        let s_661_0: bool = fn_state.gs_134773;
        // N s_661_1: branch s_661_0 b5359 b662
        if s_661_0 {
            return block_5359(state, tracer, fn_state);
        } else {
            return block_662(state, tracer, fn_state);
        };
    }
    fn block_662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_662_0: const #0u : u8
        let s_662_0: bool = false;
        // D s_662_1: write-var gs#134774 <= s_662_0
        fn_state.gs_134774 = s_662_0;
        // N s_662_2: jump b663
        return block_663(state, tracer, fn_state);
    }
    fn block_663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_663_0: read-var gs#134774:u8
        let s_663_0: bool = fn_state.gs_134774;
        // N s_663_1: branch s_663_0 b5358 b664
        if s_663_0 {
            return block_5358(state, tracer, fn_state);
        } else {
            return block_664(state, tracer, fn_state);
        };
    }
    fn block_664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_664_0: const #0u : u8
        let s_664_0: bool = false;
        // D s_664_1: write-var gs#134775 <= s_664_0
        fn_state.gs_134775 = s_664_0;
        // N s_664_2: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_665_0: read-var gs#134775:u8
        let s_665_0: bool = fn_state.gs_134775;
        // N s_665_1: branch s_665_0 b5357 b666
        if s_665_0 {
            return block_5357(state, tracer, fn_state);
        } else {
            return block_666(state, tracer, fn_state);
        };
    }
    fn block_666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_666_0: read-var CRm:u8
        let s_666_0: u8 = fn_state.CRm;
        // D s_666_1: cast zx s_666_0 -> bv
        let s_666_1: Bits = Bits::new(s_666_0 as u128, 4u16);
        // C s_666_2: const #9u : u8
        let s_666_2: u8 = 9;
        // C s_666_3: cast zx s_666_2 -> bv
        let s_666_3: Bits = Bits::new(s_666_2 as u128, 4u16);
        // D s_666_4: cmp-eq s_666_1 s_666_3
        let s_666_4: bool = ((s_666_1) == (s_666_3));
        // N s_666_5: branch s_666_4 b5356 b667
        if s_666_4 {
            return block_5356(state, tracer, fn_state);
        } else {
            return block_667(state, tracer, fn_state);
        };
    }
    fn block_667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_667_0: const #0u : u8
        let s_667_0: bool = false;
        // D s_667_1: write-var gs#134776 <= s_667_0
        fn_state.gs_134776 = s_667_0;
        // N s_667_2: jump b668
        return block_668(state, tracer, fn_state);
    }
    fn block_668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_668_0: read-var gs#134776:u8
        let s_668_0: bool = fn_state.gs_134776;
        // N s_668_1: branch s_668_0 b5355 b669
        if s_668_0 {
            return block_5355(state, tracer, fn_state);
        } else {
            return block_669(state, tracer, fn_state);
        };
    }
    fn block_669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_669_0: const #0u : u8
        let s_669_0: bool = false;
        // D s_669_1: write-var gs#134777 <= s_669_0
        fn_state.gs_134777 = s_669_0;
        // N s_669_2: jump b670
        return block_670(state, tracer, fn_state);
    }
    fn block_670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_670_0: read-var gs#134777:u8
        let s_670_0: bool = fn_state.gs_134777;
        // N s_670_1: branch s_670_0 b5354 b671
        if s_670_0 {
            return block_5354(state, tracer, fn_state);
        } else {
            return block_671(state, tracer, fn_state);
        };
    }
    fn block_671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_671_0: const #0u : u8
        let s_671_0: bool = false;
        // D s_671_1: write-var gs#134778 <= s_671_0
        fn_state.gs_134778 = s_671_0;
        // N s_671_2: jump b672
        return block_672(state, tracer, fn_state);
    }
    fn block_672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_672_0: read-var gs#134778:u8
        let s_672_0: bool = fn_state.gs_134778;
        // N s_672_1: branch s_672_0 b5353 b673
        if s_672_0 {
            return block_5353(state, tracer, fn_state);
        } else {
            return block_673(state, tracer, fn_state);
        };
    }
    fn block_673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_673_0: const #0u : u8
        let s_673_0: bool = false;
        // D s_673_1: write-var gs#134779 <= s_673_0
        fn_state.gs_134779 = s_673_0;
        // N s_673_2: jump b674
        return block_674(state, tracer, fn_state);
    }
    fn block_674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_674_0: read-var gs#134779:u8
        let s_674_0: bool = fn_state.gs_134779;
        // N s_674_1: branch s_674_0 b5352 b675
        if s_674_0 {
            return block_5352(state, tracer, fn_state);
        } else {
            return block_675(state, tracer, fn_state);
        };
    }
    fn block_675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_675_0: read-var CRm:u8
        let s_675_0: u8 = fn_state.CRm;
        // D s_675_1: cast zx s_675_0 -> bv
        let s_675_1: Bits = Bits::new(s_675_0 as u128, 4u16);
        // C s_675_2: const #8u : u8
        let s_675_2: u8 = 8;
        // C s_675_3: cast zx s_675_2 -> bv
        let s_675_3: Bits = Bits::new(s_675_2 as u128, 4u16);
        // D s_675_4: cmp-eq s_675_1 s_675_3
        let s_675_4: bool = ((s_675_1) == (s_675_3));
        // N s_675_5: branch s_675_4 b5351 b676
        if s_675_4 {
            return block_5351(state, tracer, fn_state);
        } else {
            return block_676(state, tracer, fn_state);
        };
    }
    fn block_676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_676_0: const #0u : u8
        let s_676_0: bool = false;
        // D s_676_1: write-var gs#134780 <= s_676_0
        fn_state.gs_134780 = s_676_0;
        // N s_676_2: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_677_0: read-var gs#134780:u8
        let s_677_0: bool = fn_state.gs_134780;
        // N s_677_1: branch s_677_0 b5350 b678
        if s_677_0 {
            return block_5350(state, tracer, fn_state);
        } else {
            return block_678(state, tracer, fn_state);
        };
    }
    fn block_678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_678_0: const #0u : u8
        let s_678_0: bool = false;
        // D s_678_1: write-var gs#134781 <= s_678_0
        fn_state.gs_134781 = s_678_0;
        // N s_678_2: jump b679
        return block_679(state, tracer, fn_state);
    }
    fn block_679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_679_0: read-var gs#134781:u8
        let s_679_0: bool = fn_state.gs_134781;
        // N s_679_1: branch s_679_0 b5349 b680
        if s_679_0 {
            return block_5349(state, tracer, fn_state);
        } else {
            return block_680(state, tracer, fn_state);
        };
    }
    fn block_680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_680_0: const #0u : u8
        let s_680_0: bool = false;
        // D s_680_1: write-var gs#134782 <= s_680_0
        fn_state.gs_134782 = s_680_0;
        // N s_680_2: jump b681
        return block_681(state, tracer, fn_state);
    }
    fn block_681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_681_0: read-var gs#134782:u8
        let s_681_0: bool = fn_state.gs_134782;
        // N s_681_1: branch s_681_0 b5348 b682
        if s_681_0 {
            return block_5348(state, tracer, fn_state);
        } else {
            return block_682(state, tracer, fn_state);
        };
    }
    fn block_682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_682_0: const #0u : u8
        let s_682_0: bool = false;
        // D s_682_1: write-var gs#134783 <= s_682_0
        fn_state.gs_134783 = s_682_0;
        // N s_682_2: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_683_0: read-var gs#134783:u8
        let s_683_0: bool = fn_state.gs_134783;
        // N s_683_1: branch s_683_0 b5347 b684
        if s_683_0 {
            return block_5347(state, tracer, fn_state);
        } else {
            return block_684(state, tracer, fn_state);
        };
    }
    fn block_684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_684_0: read-var CRm:u8
        let s_684_0: u8 = fn_state.CRm;
        // D s_684_1: cast zx s_684_0 -> bv
        let s_684_1: Bits = Bits::new(s_684_0 as u128, 4u16);
        // C s_684_2: const #7u : u8
        let s_684_2: u8 = 7;
        // C s_684_3: cast zx s_684_2 -> bv
        let s_684_3: Bits = Bits::new(s_684_2 as u128, 4u16);
        // D s_684_4: cmp-eq s_684_1 s_684_3
        let s_684_4: bool = ((s_684_1) == (s_684_3));
        // N s_684_5: branch s_684_4 b5346 b685
        if s_684_4 {
            return block_5346(state, tracer, fn_state);
        } else {
            return block_685(state, tracer, fn_state);
        };
    }
    fn block_685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_685_0: const #0u : u8
        let s_685_0: bool = false;
        // D s_685_1: write-var gs#134784 <= s_685_0
        fn_state.gs_134784 = s_685_0;
        // N s_685_2: jump b686
        return block_686(state, tracer, fn_state);
    }
    fn block_686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_686_0: read-var gs#134784:u8
        let s_686_0: bool = fn_state.gs_134784;
        // N s_686_1: branch s_686_0 b5345 b687
        if s_686_0 {
            return block_5345(state, tracer, fn_state);
        } else {
            return block_687(state, tracer, fn_state);
        };
    }
    fn block_687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_687_0: const #0u : u8
        let s_687_0: bool = false;
        // D s_687_1: write-var gs#134785 <= s_687_0
        fn_state.gs_134785 = s_687_0;
        // N s_687_2: jump b688
        return block_688(state, tracer, fn_state);
    }
    fn block_688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_688_0: read-var gs#134785:u8
        let s_688_0: bool = fn_state.gs_134785;
        // N s_688_1: branch s_688_0 b5344 b689
        if s_688_0 {
            return block_5344(state, tracer, fn_state);
        } else {
            return block_689(state, tracer, fn_state);
        };
    }
    fn block_689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_689_0: const #0u : u8
        let s_689_0: bool = false;
        // D s_689_1: write-var gs#134786 <= s_689_0
        fn_state.gs_134786 = s_689_0;
        // N s_689_2: jump b690
        return block_690(state, tracer, fn_state);
    }
    fn block_690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_690_0: read-var gs#134786:u8
        let s_690_0: bool = fn_state.gs_134786;
        // N s_690_1: branch s_690_0 b5343 b691
        if s_690_0 {
            return block_5343(state, tracer, fn_state);
        } else {
            return block_691(state, tracer, fn_state);
        };
    }
    fn block_691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_691_0: const #0u : u8
        let s_691_0: bool = false;
        // D s_691_1: write-var gs#134787 <= s_691_0
        fn_state.gs_134787 = s_691_0;
        // N s_691_2: jump b692
        return block_692(state, tracer, fn_state);
    }
    fn block_692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_692_0: read-var gs#134787:u8
        let s_692_0: bool = fn_state.gs_134787;
        // N s_692_1: branch s_692_0 b5342 b693
        if s_692_0 {
            return block_5342(state, tracer, fn_state);
        } else {
            return block_693(state, tracer, fn_state);
        };
    }
    fn block_693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_693_0: read-var CRm:u8
        let s_693_0: u8 = fn_state.CRm;
        // D s_693_1: cast zx s_693_0 -> bv
        let s_693_1: Bits = Bits::new(s_693_0 as u128, 4u16);
        // C s_693_2: const #6u : u8
        let s_693_2: u8 = 6;
        // C s_693_3: cast zx s_693_2 -> bv
        let s_693_3: Bits = Bits::new(s_693_2 as u128, 4u16);
        // D s_693_4: cmp-eq s_693_1 s_693_3
        let s_693_4: bool = ((s_693_1) == (s_693_3));
        // N s_693_5: branch s_693_4 b5341 b694
        if s_693_4 {
            return block_5341(state, tracer, fn_state);
        } else {
            return block_694(state, tracer, fn_state);
        };
    }
    fn block_694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_694_0: const #0u : u8
        let s_694_0: bool = false;
        // D s_694_1: write-var gs#134788 <= s_694_0
        fn_state.gs_134788 = s_694_0;
        // N s_694_2: jump b695
        return block_695(state, tracer, fn_state);
    }
    fn block_695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_695_0: read-var gs#134788:u8
        let s_695_0: bool = fn_state.gs_134788;
        // N s_695_1: branch s_695_0 b5340 b696
        if s_695_0 {
            return block_5340(state, tracer, fn_state);
        } else {
            return block_696(state, tracer, fn_state);
        };
    }
    fn block_696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_696_0: const #0u : u8
        let s_696_0: bool = false;
        // D s_696_1: write-var gs#134789 <= s_696_0
        fn_state.gs_134789 = s_696_0;
        // N s_696_2: jump b697
        return block_697(state, tracer, fn_state);
    }
    fn block_697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_697_0: read-var gs#134789:u8
        let s_697_0: bool = fn_state.gs_134789;
        // N s_697_1: branch s_697_0 b5339 b698
        if s_697_0 {
            return block_5339(state, tracer, fn_state);
        } else {
            return block_698(state, tracer, fn_state);
        };
    }
    fn block_698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_698_0: const #0u : u8
        let s_698_0: bool = false;
        // D s_698_1: write-var gs#134790 <= s_698_0
        fn_state.gs_134790 = s_698_0;
        // N s_698_2: jump b699
        return block_699(state, tracer, fn_state);
    }
    fn block_699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_699_0: read-var gs#134790:u8
        let s_699_0: bool = fn_state.gs_134790;
        // N s_699_1: branch s_699_0 b5338 b700
        if s_699_0 {
            return block_5338(state, tracer, fn_state);
        } else {
            return block_700(state, tracer, fn_state);
        };
    }
    fn block_700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_700_0: const #0u : u8
        let s_700_0: bool = false;
        // D s_700_1: write-var gs#134791 <= s_700_0
        fn_state.gs_134791 = s_700_0;
        // N s_700_2: jump b701
        return block_701(state, tracer, fn_state);
    }
    fn block_701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_701_0: read-var gs#134791:u8
        let s_701_0: bool = fn_state.gs_134791;
        // N s_701_1: branch s_701_0 b5337 b702
        if s_701_0 {
            return block_5337(state, tracer, fn_state);
        } else {
            return block_702(state, tracer, fn_state);
        };
    }
    fn block_702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_702_0: read-var CRm:u8
        let s_702_0: u8 = fn_state.CRm;
        // D s_702_1: cast zx s_702_0 -> bv
        let s_702_1: Bits = Bits::new(s_702_0 as u128, 4u16);
        // C s_702_2: const #5u : u8
        let s_702_2: u8 = 5;
        // C s_702_3: cast zx s_702_2 -> bv
        let s_702_3: Bits = Bits::new(s_702_2 as u128, 4u16);
        // D s_702_4: cmp-eq s_702_1 s_702_3
        let s_702_4: bool = ((s_702_1) == (s_702_3));
        // N s_702_5: branch s_702_4 b5336 b703
        if s_702_4 {
            return block_5336(state, tracer, fn_state);
        } else {
            return block_703(state, tracer, fn_state);
        };
    }
    fn block_703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_703_0: const #0u : u8
        let s_703_0: bool = false;
        // D s_703_1: write-var gs#134792 <= s_703_0
        fn_state.gs_134792 = s_703_0;
        // N s_703_2: jump b704
        return block_704(state, tracer, fn_state);
    }
    fn block_704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_704_0: read-var gs#134792:u8
        let s_704_0: bool = fn_state.gs_134792;
        // N s_704_1: branch s_704_0 b5335 b705
        if s_704_0 {
            return block_5335(state, tracer, fn_state);
        } else {
            return block_705(state, tracer, fn_state);
        };
    }
    fn block_705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_705_0: const #0u : u8
        let s_705_0: bool = false;
        // D s_705_1: write-var gs#134793 <= s_705_0
        fn_state.gs_134793 = s_705_0;
        // N s_705_2: jump b706
        return block_706(state, tracer, fn_state);
    }
    fn block_706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_706_0: read-var gs#134793:u8
        let s_706_0: bool = fn_state.gs_134793;
        // N s_706_1: branch s_706_0 b5334 b707
        if s_706_0 {
            return block_5334(state, tracer, fn_state);
        } else {
            return block_707(state, tracer, fn_state);
        };
    }
    fn block_707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_707_0: const #0u : u8
        let s_707_0: bool = false;
        // D s_707_1: write-var gs#134794 <= s_707_0
        fn_state.gs_134794 = s_707_0;
        // N s_707_2: jump b708
        return block_708(state, tracer, fn_state);
    }
    fn block_708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_708_0: read-var gs#134794:u8
        let s_708_0: bool = fn_state.gs_134794;
        // N s_708_1: branch s_708_0 b5333 b709
        if s_708_0 {
            return block_5333(state, tracer, fn_state);
        } else {
            return block_709(state, tracer, fn_state);
        };
    }
    fn block_709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_709_0: const #0u : u8
        let s_709_0: bool = false;
        // D s_709_1: write-var gs#134795 <= s_709_0
        fn_state.gs_134795 = s_709_0;
        // N s_709_2: jump b710
        return block_710(state, tracer, fn_state);
    }
    fn block_710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_710_0: read-var gs#134795:u8
        let s_710_0: bool = fn_state.gs_134795;
        // N s_710_1: branch s_710_0 b5332 b711
        if s_710_0 {
            return block_5332(state, tracer, fn_state);
        } else {
            return block_711(state, tracer, fn_state);
        };
    }
    fn block_711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_711_0: read-var CRm:u8
        let s_711_0: u8 = fn_state.CRm;
        // D s_711_1: cast zx s_711_0 -> bv
        let s_711_1: Bits = Bits::new(s_711_0 as u128, 4u16);
        // C s_711_2: const #4u : u8
        let s_711_2: u8 = 4;
        // C s_711_3: cast zx s_711_2 -> bv
        let s_711_3: Bits = Bits::new(s_711_2 as u128, 4u16);
        // D s_711_4: cmp-eq s_711_1 s_711_3
        let s_711_4: bool = ((s_711_1) == (s_711_3));
        // N s_711_5: branch s_711_4 b5331 b712
        if s_711_4 {
            return block_5331(state, tracer, fn_state);
        } else {
            return block_712(state, tracer, fn_state);
        };
    }
    fn block_712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_712_0: const #0u : u8
        let s_712_0: bool = false;
        // D s_712_1: write-var gs#134796 <= s_712_0
        fn_state.gs_134796 = s_712_0;
        // N s_712_2: jump b713
        return block_713(state, tracer, fn_state);
    }
    fn block_713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_713_0: read-var gs#134796:u8
        let s_713_0: bool = fn_state.gs_134796;
        // N s_713_1: branch s_713_0 b5330 b714
        if s_713_0 {
            return block_5330(state, tracer, fn_state);
        } else {
            return block_714(state, tracer, fn_state);
        };
    }
    fn block_714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_714_0: const #0u : u8
        let s_714_0: bool = false;
        // D s_714_1: write-var gs#134797 <= s_714_0
        fn_state.gs_134797 = s_714_0;
        // N s_714_2: jump b715
        return block_715(state, tracer, fn_state);
    }
    fn block_715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_715_0: read-var gs#134797:u8
        let s_715_0: bool = fn_state.gs_134797;
        // N s_715_1: branch s_715_0 b5329 b716
        if s_715_0 {
            return block_5329(state, tracer, fn_state);
        } else {
            return block_716(state, tracer, fn_state);
        };
    }
    fn block_716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_716_0: const #0u : u8
        let s_716_0: bool = false;
        // D s_716_1: write-var gs#134798 <= s_716_0
        fn_state.gs_134798 = s_716_0;
        // N s_716_2: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_717_0: read-var gs#134798:u8
        let s_717_0: bool = fn_state.gs_134798;
        // N s_717_1: branch s_717_0 b5328 b718
        if s_717_0 {
            return block_5328(state, tracer, fn_state);
        } else {
            return block_718(state, tracer, fn_state);
        };
    }
    fn block_718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_718_0: const #0u : u8
        let s_718_0: bool = false;
        // D s_718_1: write-var gs#134799 <= s_718_0
        fn_state.gs_134799 = s_718_0;
        // N s_718_2: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_719_0: read-var gs#134799:u8
        let s_719_0: bool = fn_state.gs_134799;
        // N s_719_1: branch s_719_0 b5327 b720
        if s_719_0 {
            return block_5327(state, tracer, fn_state);
        } else {
            return block_720(state, tracer, fn_state);
        };
    }
    fn block_720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_720_0: read-var CRm:u8
        let s_720_0: u8 = fn_state.CRm;
        // D s_720_1: cast zx s_720_0 -> bv
        let s_720_1: Bits = Bits::new(s_720_0 as u128, 4u16);
        // C s_720_2: const #3u : u8
        let s_720_2: u8 = 3;
        // C s_720_3: cast zx s_720_2 -> bv
        let s_720_3: Bits = Bits::new(s_720_2 as u128, 4u16);
        // D s_720_4: cmp-eq s_720_1 s_720_3
        let s_720_4: bool = ((s_720_1) == (s_720_3));
        // N s_720_5: branch s_720_4 b5326 b721
        if s_720_4 {
            return block_5326(state, tracer, fn_state);
        } else {
            return block_721(state, tracer, fn_state);
        };
    }
    fn block_721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_721_0: const #0u : u8
        let s_721_0: bool = false;
        // D s_721_1: write-var gs#134800 <= s_721_0
        fn_state.gs_134800 = s_721_0;
        // N s_721_2: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_722_0: read-var gs#134800:u8
        let s_722_0: bool = fn_state.gs_134800;
        // N s_722_1: branch s_722_0 b5325 b723
        if s_722_0 {
            return block_5325(state, tracer, fn_state);
        } else {
            return block_723(state, tracer, fn_state);
        };
    }
    fn block_723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_723_0: const #0u : u8
        let s_723_0: bool = false;
        // D s_723_1: write-var gs#134801 <= s_723_0
        fn_state.gs_134801 = s_723_0;
        // N s_723_2: jump b724
        return block_724(state, tracer, fn_state);
    }
    fn block_724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_724_0: read-var gs#134801:u8
        let s_724_0: bool = fn_state.gs_134801;
        // N s_724_1: branch s_724_0 b5324 b725
        if s_724_0 {
            return block_5324(state, tracer, fn_state);
        } else {
            return block_725(state, tracer, fn_state);
        };
    }
    fn block_725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_725_0: const #0u : u8
        let s_725_0: bool = false;
        // D s_725_1: write-var gs#134802 <= s_725_0
        fn_state.gs_134802 = s_725_0;
        // N s_725_2: jump b726
        return block_726(state, tracer, fn_state);
    }
    fn block_726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_726_0: read-var gs#134802:u8
        let s_726_0: bool = fn_state.gs_134802;
        // N s_726_1: branch s_726_0 b5323 b727
        if s_726_0 {
            return block_5323(state, tracer, fn_state);
        } else {
            return block_727(state, tracer, fn_state);
        };
    }
    fn block_727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_727_0: const #0u : u8
        let s_727_0: bool = false;
        // D s_727_1: write-var gs#134803 <= s_727_0
        fn_state.gs_134803 = s_727_0;
        // N s_727_2: jump b728
        return block_728(state, tracer, fn_state);
    }
    fn block_728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_728_0: read-var gs#134803:u8
        let s_728_0: bool = fn_state.gs_134803;
        // N s_728_1: branch s_728_0 b5322 b729
        if s_728_0 {
            return block_5322(state, tracer, fn_state);
        } else {
            return block_729(state, tracer, fn_state);
        };
    }
    fn block_729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_729_0: read-var CRm:u8
        let s_729_0: u8 = fn_state.CRm;
        // D s_729_1: cast zx s_729_0 -> bv
        let s_729_1: Bits = Bits::new(s_729_0 as u128, 4u16);
        // C s_729_2: const #2u : u8
        let s_729_2: u8 = 2;
        // C s_729_3: cast zx s_729_2 -> bv
        let s_729_3: Bits = Bits::new(s_729_2 as u128, 4u16);
        // D s_729_4: cmp-eq s_729_1 s_729_3
        let s_729_4: bool = ((s_729_1) == (s_729_3));
        // N s_729_5: branch s_729_4 b5321 b730
        if s_729_4 {
            return block_5321(state, tracer, fn_state);
        } else {
            return block_730(state, tracer, fn_state);
        };
    }
    fn block_730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_730_0: const #0u : u8
        let s_730_0: bool = false;
        // D s_730_1: write-var gs#134804 <= s_730_0
        fn_state.gs_134804 = s_730_0;
        // N s_730_2: jump b731
        return block_731(state, tracer, fn_state);
    }
    fn block_731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_731_0: read-var gs#134804:u8
        let s_731_0: bool = fn_state.gs_134804;
        // N s_731_1: branch s_731_0 b5320 b732
        if s_731_0 {
            return block_5320(state, tracer, fn_state);
        } else {
            return block_732(state, tracer, fn_state);
        };
    }
    fn block_732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_732_0: const #0u : u8
        let s_732_0: bool = false;
        // D s_732_1: write-var gs#134805 <= s_732_0
        fn_state.gs_134805 = s_732_0;
        // N s_732_2: jump b733
        return block_733(state, tracer, fn_state);
    }
    fn block_733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_733_0: read-var gs#134805:u8
        let s_733_0: bool = fn_state.gs_134805;
        // N s_733_1: branch s_733_0 b5319 b734
        if s_733_0 {
            return block_5319(state, tracer, fn_state);
        } else {
            return block_734(state, tracer, fn_state);
        };
    }
    fn block_734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_734_0: const #0u : u8
        let s_734_0: bool = false;
        // D s_734_1: write-var gs#134806 <= s_734_0
        fn_state.gs_134806 = s_734_0;
        // N s_734_2: jump b735
        return block_735(state, tracer, fn_state);
    }
    fn block_735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_735_0: read-var gs#134806:u8
        let s_735_0: bool = fn_state.gs_134806;
        // N s_735_1: branch s_735_0 b5318 b736
        if s_735_0 {
            return block_5318(state, tracer, fn_state);
        } else {
            return block_736(state, tracer, fn_state);
        };
    }
    fn block_736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_736_0: const #0u : u8
        let s_736_0: bool = false;
        // D s_736_1: write-var gs#134807 <= s_736_0
        fn_state.gs_134807 = s_736_0;
        // N s_736_2: jump b737
        return block_737(state, tracer, fn_state);
    }
    fn block_737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_737_0: read-var gs#134807:u8
        let s_737_0: bool = fn_state.gs_134807;
        // N s_737_1: branch s_737_0 b5317 b738
        if s_737_0 {
            return block_5317(state, tracer, fn_state);
        } else {
            return block_738(state, tracer, fn_state);
        };
    }
    fn block_738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_738_0: read-var CRm:u8
        let s_738_0: u8 = fn_state.CRm;
        // D s_738_1: cast zx s_738_0 -> bv
        let s_738_1: Bits = Bits::new(s_738_0 as u128, 4u16);
        // C s_738_2: const #1u : u8
        let s_738_2: u8 = 1;
        // C s_738_3: cast zx s_738_2 -> bv
        let s_738_3: Bits = Bits::new(s_738_2 as u128, 4u16);
        // D s_738_4: cmp-eq s_738_1 s_738_3
        let s_738_4: bool = ((s_738_1) == (s_738_3));
        // N s_738_5: branch s_738_4 b5316 b739
        if s_738_4 {
            return block_5316(state, tracer, fn_state);
        } else {
            return block_739(state, tracer, fn_state);
        };
    }
    fn block_739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_739_0: const #0u : u8
        let s_739_0: bool = false;
        // D s_739_1: write-var gs#134808 <= s_739_0
        fn_state.gs_134808 = s_739_0;
        // N s_739_2: jump b740
        return block_740(state, tracer, fn_state);
    }
    fn block_740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_740_0: read-var gs#134808:u8
        let s_740_0: bool = fn_state.gs_134808;
        // N s_740_1: branch s_740_0 b5315 b741
        if s_740_0 {
            return block_5315(state, tracer, fn_state);
        } else {
            return block_741(state, tracer, fn_state);
        };
    }
    fn block_741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_741_0: const #0u : u8
        let s_741_0: bool = false;
        // D s_741_1: write-var gs#134809 <= s_741_0
        fn_state.gs_134809 = s_741_0;
        // N s_741_2: jump b742
        return block_742(state, tracer, fn_state);
    }
    fn block_742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_742_0: read-var gs#134809:u8
        let s_742_0: bool = fn_state.gs_134809;
        // N s_742_1: branch s_742_0 b5314 b743
        if s_742_0 {
            return block_5314(state, tracer, fn_state);
        } else {
            return block_743(state, tracer, fn_state);
        };
    }
    fn block_743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_743_0: const #0u : u8
        let s_743_0: bool = false;
        // D s_743_1: write-var gs#134810 <= s_743_0
        fn_state.gs_134810 = s_743_0;
        // N s_743_2: jump b744
        return block_744(state, tracer, fn_state);
    }
    fn block_744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_744_0: read-var gs#134810:u8
        let s_744_0: bool = fn_state.gs_134810;
        // N s_744_1: branch s_744_0 b5313 b745
        if s_744_0 {
            return block_5313(state, tracer, fn_state);
        } else {
            return block_745(state, tracer, fn_state);
        };
    }
    fn block_745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_745_0: const #0u : u8
        let s_745_0: bool = false;
        // D s_745_1: write-var gs#134811 <= s_745_0
        fn_state.gs_134811 = s_745_0;
        // N s_745_2: jump b746
        return block_746(state, tracer, fn_state);
    }
    fn block_746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_746_0: read-var gs#134811:u8
        let s_746_0: bool = fn_state.gs_134811;
        // N s_746_1: branch s_746_0 b5312 b747
        if s_746_0 {
            return block_5312(state, tracer, fn_state);
        } else {
            return block_747(state, tracer, fn_state);
        };
    }
    fn block_747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_747_0: read-var CRm:u8
        let s_747_0: u8 = fn_state.CRm;
        // D s_747_1: cast zx s_747_0 -> bv
        let s_747_1: Bits = Bits::new(s_747_0 as u128, 4u16);
        // C s_747_2: const #0u : u8
        let s_747_2: u8 = 0;
        // C s_747_3: cast zx s_747_2 -> bv
        let s_747_3: Bits = Bits::new(s_747_2 as u128, 4u16);
        // D s_747_4: cmp-eq s_747_1 s_747_3
        let s_747_4: bool = ((s_747_1) == (s_747_3));
        // N s_747_5: branch s_747_4 b5311 b748
        if s_747_4 {
            return block_5311(state, tracer, fn_state);
        } else {
            return block_748(state, tracer, fn_state);
        };
    }
    fn block_748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_748_0: const #0u : u8
        let s_748_0: bool = false;
        // D s_748_1: write-var gs#134812 <= s_748_0
        fn_state.gs_134812 = s_748_0;
        // N s_748_2: jump b749
        return block_749(state, tracer, fn_state);
    }
    fn block_749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_749_0: read-var gs#134812:u8
        let s_749_0: bool = fn_state.gs_134812;
        // N s_749_1: branch s_749_0 b5310 b750
        if s_749_0 {
            return block_5310(state, tracer, fn_state);
        } else {
            return block_750(state, tracer, fn_state);
        };
    }
    fn block_750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_750_0: const #0u : u8
        let s_750_0: bool = false;
        // D s_750_1: write-var gs#134813 <= s_750_0
        fn_state.gs_134813 = s_750_0;
        // N s_750_2: jump b751
        return block_751(state, tracer, fn_state);
    }
    fn block_751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_751_0: read-var gs#134813:u8
        let s_751_0: bool = fn_state.gs_134813;
        // N s_751_1: branch s_751_0 b5309 b752
        if s_751_0 {
            return block_5309(state, tracer, fn_state);
        } else {
            return block_752(state, tracer, fn_state);
        };
    }
    fn block_752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_752_0: const #0u : u8
        let s_752_0: bool = false;
        // D s_752_1: write-var gs#134814 <= s_752_0
        fn_state.gs_134814 = s_752_0;
        // N s_752_2: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_753_0: read-var gs#134814:u8
        let s_753_0: bool = fn_state.gs_134814;
        // N s_753_1: branch s_753_0 b5308 b754
        if s_753_0 {
            return block_5308(state, tracer, fn_state);
        } else {
            return block_754(state, tracer, fn_state);
        };
    }
    fn block_754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_754_0: const #0u : u8
        let s_754_0: bool = false;
        // D s_754_1: write-var gs#134815 <= s_754_0
        fn_state.gs_134815 = s_754_0;
        // N s_754_2: jump b755
        return block_755(state, tracer, fn_state);
    }
    fn block_755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_755_0: read-var gs#134815:u8
        let s_755_0: bool = fn_state.gs_134815;
        // N s_755_1: branch s_755_0 b5307 b756
        if s_755_0 {
            return block_5307(state, tracer, fn_state);
        } else {
            return block_756(state, tracer, fn_state);
        };
    }
    fn block_756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_756_0: read-var CRm:u8
        let s_756_0: u8 = fn_state.CRm;
        // D s_756_1: cast zx s_756_0 -> bv
        let s_756_1: Bits = Bits::new(s_756_0 as u128, 4u16);
        // C s_756_2: const #8u : u8
        let s_756_2: u8 = 8;
        // C s_756_3: cast zx s_756_2 -> bv
        let s_756_3: Bits = Bits::new(s_756_2 as u128, 4u16);
        // D s_756_4: cmp-eq s_756_1 s_756_3
        let s_756_4: bool = ((s_756_1) == (s_756_3));
        // N s_756_5: branch s_756_4 b5306 b757
        if s_756_4 {
            return block_5306(state, tracer, fn_state);
        } else {
            return block_757(state, tracer, fn_state);
        };
    }
    fn block_757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_757_0: const #0u : u8
        let s_757_0: bool = false;
        // D s_757_1: write-var gs#134816 <= s_757_0
        fn_state.gs_134816 = s_757_0;
        // N s_757_2: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_758_0: read-var gs#134816:u8
        let s_758_0: bool = fn_state.gs_134816;
        // N s_758_1: branch s_758_0 b5305 b759
        if s_758_0 {
            return block_5305(state, tracer, fn_state);
        } else {
            return block_759(state, tracer, fn_state);
        };
    }
    fn block_759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_759_0: const #0u : u8
        let s_759_0: bool = false;
        // D s_759_1: write-var gs#134817 <= s_759_0
        fn_state.gs_134817 = s_759_0;
        // N s_759_2: jump b760
        return block_760(state, tracer, fn_state);
    }
    fn block_760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_760_0: read-var gs#134817:u8
        let s_760_0: bool = fn_state.gs_134817;
        // N s_760_1: branch s_760_0 b5304 b761
        if s_760_0 {
            return block_5304(state, tracer, fn_state);
        } else {
            return block_761(state, tracer, fn_state);
        };
    }
    fn block_761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_761_0: const #0u : u8
        let s_761_0: bool = false;
        // D s_761_1: write-var gs#134818 <= s_761_0
        fn_state.gs_134818 = s_761_0;
        // N s_761_2: jump b762
        return block_762(state, tracer, fn_state);
    }
    fn block_762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_762_0: read-var gs#134818:u8
        let s_762_0: bool = fn_state.gs_134818;
        // N s_762_1: branch s_762_0 b5303 b763
        if s_762_0 {
            return block_5303(state, tracer, fn_state);
        } else {
            return block_763(state, tracer, fn_state);
        };
    }
    fn block_763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_763_0: const #0u : u8
        let s_763_0: bool = false;
        // D s_763_1: write-var gs#134819 <= s_763_0
        fn_state.gs_134819 = s_763_0;
        // N s_763_2: jump b764
        return block_764(state, tracer, fn_state);
    }
    fn block_764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_764_0: read-var gs#134819:u8
        let s_764_0: bool = fn_state.gs_134819;
        // N s_764_1: branch s_764_0 b5302 b765
        if s_764_0 {
            return block_5302(state, tracer, fn_state);
        } else {
            return block_765(state, tracer, fn_state);
        };
    }
    fn block_765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_765_0: read-var CRm:u8
        let s_765_0: u8 = fn_state.CRm;
        // D s_765_1: cast zx s_765_0 -> bv
        let s_765_1: Bits = Bits::new(s_765_0 as u128, 4u16);
        // C s_765_2: const #8u : u8
        let s_765_2: u8 = 8;
        // C s_765_3: cast zx s_765_2 -> bv
        let s_765_3: Bits = Bits::new(s_765_2 as u128, 4u16);
        // D s_765_4: cmp-eq s_765_1 s_765_3
        let s_765_4: bool = ((s_765_1) == (s_765_3));
        // N s_765_5: branch s_765_4 b5301 b766
        if s_765_4 {
            return block_5301(state, tracer, fn_state);
        } else {
            return block_766(state, tracer, fn_state);
        };
    }
    fn block_766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_766_0: const #0u : u8
        let s_766_0: bool = false;
        // D s_766_1: write-var gs#134820 <= s_766_0
        fn_state.gs_134820 = s_766_0;
        // N s_766_2: jump b767
        return block_767(state, tracer, fn_state);
    }
    fn block_767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_767_0: read-var gs#134820:u8
        let s_767_0: bool = fn_state.gs_134820;
        // N s_767_1: branch s_767_0 b5300 b768
        if s_767_0 {
            return block_5300(state, tracer, fn_state);
        } else {
            return block_768(state, tracer, fn_state);
        };
    }
    fn block_768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_768_0: const #0u : u8
        let s_768_0: bool = false;
        // D s_768_1: write-var gs#134821 <= s_768_0
        fn_state.gs_134821 = s_768_0;
        // N s_768_2: jump b769
        return block_769(state, tracer, fn_state);
    }
    fn block_769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_769_0: read-var gs#134821:u8
        let s_769_0: bool = fn_state.gs_134821;
        // N s_769_1: branch s_769_0 b5299 b770
        if s_769_0 {
            return block_5299(state, tracer, fn_state);
        } else {
            return block_770(state, tracer, fn_state);
        };
    }
    fn block_770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_770_0: const #0u : u8
        let s_770_0: bool = false;
        // D s_770_1: write-var gs#134822 <= s_770_0
        fn_state.gs_134822 = s_770_0;
        // N s_770_2: jump b771
        return block_771(state, tracer, fn_state);
    }
    fn block_771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_771_0: read-var gs#134822:u8
        let s_771_0: bool = fn_state.gs_134822;
        // N s_771_1: branch s_771_0 b5298 b772
        if s_771_0 {
            return block_5298(state, tracer, fn_state);
        } else {
            return block_772(state, tracer, fn_state);
        };
    }
    fn block_772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_772_0: const #0u : u8
        let s_772_0: bool = false;
        // D s_772_1: write-var gs#134823 <= s_772_0
        fn_state.gs_134823 = s_772_0;
        // N s_772_2: jump b773
        return block_773(state, tracer, fn_state);
    }
    fn block_773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_773_0: read-var gs#134823:u8
        let s_773_0: bool = fn_state.gs_134823;
        // N s_773_1: branch s_773_0 b5297 b774
        if s_773_0 {
            return block_5297(state, tracer, fn_state);
        } else {
            return block_774(state, tracer, fn_state);
        };
    }
    fn block_774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_774_0: read-var CRm:u8
        let s_774_0: u8 = fn_state.CRm;
        // D s_774_1: cast zx s_774_0 -> bv
        let s_774_1: Bits = Bits::new(s_774_0 as u128, 4u16);
        // C s_774_2: const #8u : u8
        let s_774_2: u8 = 8;
        // C s_774_3: cast zx s_774_2 -> bv
        let s_774_3: Bits = Bits::new(s_774_2 as u128, 4u16);
        // D s_774_4: cmp-eq s_774_1 s_774_3
        let s_774_4: bool = ((s_774_1) == (s_774_3));
        // N s_774_5: branch s_774_4 b5296 b775
        if s_774_4 {
            return block_5296(state, tracer, fn_state);
        } else {
            return block_775(state, tracer, fn_state);
        };
    }
    fn block_775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_775_0: const #0u : u8
        let s_775_0: bool = false;
        // D s_775_1: write-var gs#134824 <= s_775_0
        fn_state.gs_134824 = s_775_0;
        // N s_775_2: jump b776
        return block_776(state, tracer, fn_state);
    }
    fn block_776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_776_0: read-var gs#134824:u8
        let s_776_0: bool = fn_state.gs_134824;
        // N s_776_1: branch s_776_0 b5295 b777
        if s_776_0 {
            return block_5295(state, tracer, fn_state);
        } else {
            return block_777(state, tracer, fn_state);
        };
    }
    fn block_777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_777_0: const #0u : u8
        let s_777_0: bool = false;
        // D s_777_1: write-var gs#134825 <= s_777_0
        fn_state.gs_134825 = s_777_0;
        // N s_777_2: jump b778
        return block_778(state, tracer, fn_state);
    }
    fn block_778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_778_0: read-var gs#134825:u8
        let s_778_0: bool = fn_state.gs_134825;
        // N s_778_1: branch s_778_0 b5294 b779
        if s_778_0 {
            return block_5294(state, tracer, fn_state);
        } else {
            return block_779(state, tracer, fn_state);
        };
    }
    fn block_779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_779_0: const #0u : u8
        let s_779_0: bool = false;
        // D s_779_1: write-var gs#134826 <= s_779_0
        fn_state.gs_134826 = s_779_0;
        // N s_779_2: jump b780
        return block_780(state, tracer, fn_state);
    }
    fn block_780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_780_0: read-var gs#134826:u8
        let s_780_0: bool = fn_state.gs_134826;
        // N s_780_1: branch s_780_0 b5293 b781
        if s_780_0 {
            return block_5293(state, tracer, fn_state);
        } else {
            return block_781(state, tracer, fn_state);
        };
    }
    fn block_781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_781_0: const #0u : u8
        let s_781_0: bool = false;
        // D s_781_1: write-var gs#134827 <= s_781_0
        fn_state.gs_134827 = s_781_0;
        // N s_781_2: jump b782
        return block_782(state, tracer, fn_state);
    }
    fn block_782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_782_0: read-var gs#134827:u8
        let s_782_0: bool = fn_state.gs_134827;
        // N s_782_1: branch s_782_0 b5292 b783
        if s_782_0 {
            return block_5292(state, tracer, fn_state);
        } else {
            return block_783(state, tracer, fn_state);
        };
    }
    fn block_783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_783_0: read-var CRm:u8
        let s_783_0: u8 = fn_state.CRm;
        // D s_783_1: cast zx s_783_0 -> bv
        let s_783_1: Bits = Bits::new(s_783_0 as u128, 4u16);
        // C s_783_2: const #8u : u8
        let s_783_2: u8 = 8;
        // C s_783_3: cast zx s_783_2 -> bv
        let s_783_3: Bits = Bits::new(s_783_2 as u128, 4u16);
        // D s_783_4: cmp-eq s_783_1 s_783_3
        let s_783_4: bool = ((s_783_1) == (s_783_3));
        // N s_783_5: branch s_783_4 b5291 b784
        if s_783_4 {
            return block_5291(state, tracer, fn_state);
        } else {
            return block_784(state, tracer, fn_state);
        };
    }
    fn block_784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_784_0: const #0u : u8
        let s_784_0: bool = false;
        // D s_784_1: write-var gs#134828 <= s_784_0
        fn_state.gs_134828 = s_784_0;
        // N s_784_2: jump b785
        return block_785(state, tracer, fn_state);
    }
    fn block_785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_785_0: read-var gs#134828:u8
        let s_785_0: bool = fn_state.gs_134828;
        // N s_785_1: branch s_785_0 b5290 b786
        if s_785_0 {
            return block_5290(state, tracer, fn_state);
        } else {
            return block_786(state, tracer, fn_state);
        };
    }
    fn block_786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_786_0: const #0u : u8
        let s_786_0: bool = false;
        // D s_786_1: write-var gs#134829 <= s_786_0
        fn_state.gs_134829 = s_786_0;
        // N s_786_2: jump b787
        return block_787(state, tracer, fn_state);
    }
    fn block_787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_787_0: read-var gs#134829:u8
        let s_787_0: bool = fn_state.gs_134829;
        // N s_787_1: branch s_787_0 b5289 b788
        if s_787_0 {
            return block_5289(state, tracer, fn_state);
        } else {
            return block_788(state, tracer, fn_state);
        };
    }
    fn block_788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_788_0: const #0u : u8
        let s_788_0: bool = false;
        // D s_788_1: write-var gs#134830 <= s_788_0
        fn_state.gs_134830 = s_788_0;
        // N s_788_2: jump b789
        return block_789(state, tracer, fn_state);
    }
    fn block_789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_789_0: read-var gs#134830:u8
        let s_789_0: bool = fn_state.gs_134830;
        // N s_789_1: branch s_789_0 b5288 b790
        if s_789_0 {
            return block_5288(state, tracer, fn_state);
        } else {
            return block_790(state, tracer, fn_state);
        };
    }
    fn block_790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_790_0: const #0u : u8
        let s_790_0: bool = false;
        // D s_790_1: write-var gs#134831 <= s_790_0
        fn_state.gs_134831 = s_790_0;
        // N s_790_2: jump b791
        return block_791(state, tracer, fn_state);
    }
    fn block_791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_791_0: read-var gs#134831:u8
        let s_791_0: bool = fn_state.gs_134831;
        // N s_791_1: branch s_791_0 b5287 b792
        if s_791_0 {
            return block_5287(state, tracer, fn_state);
        } else {
            return block_792(state, tracer, fn_state);
        };
    }
    fn block_792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_792_0: read-var CRm:u8
        let s_792_0: u8 = fn_state.CRm;
        // D s_792_1: cast zx s_792_0 -> bv
        let s_792_1: Bits = Bits::new(s_792_0 as u128, 4u16);
        // C s_792_2: const #0u : u8
        let s_792_2: u8 = 0;
        // C s_792_3: cast zx s_792_2 -> bv
        let s_792_3: Bits = Bits::new(s_792_2 as u128, 4u16);
        // D s_792_4: cmp-eq s_792_1 s_792_3
        let s_792_4: bool = ((s_792_1) == (s_792_3));
        // N s_792_5: branch s_792_4 b5286 b793
        if s_792_4 {
            return block_5286(state, tracer, fn_state);
        } else {
            return block_793(state, tracer, fn_state);
        };
    }
    fn block_793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_793_0: const #0u : u8
        let s_793_0: bool = false;
        // D s_793_1: write-var gs#134832 <= s_793_0
        fn_state.gs_134832 = s_793_0;
        // N s_793_2: jump b794
        return block_794(state, tracer, fn_state);
    }
    fn block_794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_794_0: read-var gs#134832:u8
        let s_794_0: bool = fn_state.gs_134832;
        // N s_794_1: branch s_794_0 b5285 b795
        if s_794_0 {
            return block_5285(state, tracer, fn_state);
        } else {
            return block_795(state, tracer, fn_state);
        };
    }
    fn block_795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_795_0: const #0u : u8
        let s_795_0: bool = false;
        // D s_795_1: write-var gs#134833 <= s_795_0
        fn_state.gs_134833 = s_795_0;
        // N s_795_2: jump b796
        return block_796(state, tracer, fn_state);
    }
    fn block_796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_796_0: read-var gs#134833:u8
        let s_796_0: bool = fn_state.gs_134833;
        // N s_796_1: branch s_796_0 b5284 b797
        if s_796_0 {
            return block_5284(state, tracer, fn_state);
        } else {
            return block_797(state, tracer, fn_state);
        };
    }
    fn block_797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_797_0: const #0u : u8
        let s_797_0: bool = false;
        // D s_797_1: write-var gs#134834 <= s_797_0
        fn_state.gs_134834 = s_797_0;
        // N s_797_2: jump b798
        return block_798(state, tracer, fn_state);
    }
    fn block_798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_798_0: read-var gs#134834:u8
        let s_798_0: bool = fn_state.gs_134834;
        // N s_798_1: branch s_798_0 b5283 b799
        if s_798_0 {
            return block_5283(state, tracer, fn_state);
        } else {
            return block_799(state, tracer, fn_state);
        };
    }
    fn block_799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_799_0: const #0u : u8
        let s_799_0: bool = false;
        // D s_799_1: write-var gs#134835 <= s_799_0
        fn_state.gs_134835 = s_799_0;
        // N s_799_2: jump b800
        return block_800(state, tracer, fn_state);
    }
    fn block_800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_800_0: read-var gs#134835:u8
        let s_800_0: bool = fn_state.gs_134835;
        // N s_800_1: branch s_800_0 b5282 b801
        if s_800_0 {
            return block_5282(state, tracer, fn_state);
        } else {
            return block_801(state, tracer, fn_state);
        };
    }
    fn block_801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_801_0: read-var CRm:u8
        let s_801_0: u8 = fn_state.CRm;
        // D s_801_1: cast zx s_801_0 -> bv
        let s_801_1: Bits = Bits::new(s_801_0 as u128, 4u16);
        // C s_801_2: const #1u : u8
        let s_801_2: u8 = 1;
        // C s_801_3: cast zx s_801_2 -> bv
        let s_801_3: Bits = Bits::new(s_801_2 as u128, 4u16);
        // D s_801_4: cmp-eq s_801_1 s_801_3
        let s_801_4: bool = ((s_801_1) == (s_801_3));
        // N s_801_5: branch s_801_4 b5281 b802
        if s_801_4 {
            return block_5281(state, tracer, fn_state);
        } else {
            return block_802(state, tracer, fn_state);
        };
    }
    fn block_802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_802_0: const #0u : u8
        let s_802_0: bool = false;
        // D s_802_1: write-var gs#134836 <= s_802_0
        fn_state.gs_134836 = s_802_0;
        // N s_802_2: jump b803
        return block_803(state, tracer, fn_state);
    }
    fn block_803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_803_0: read-var gs#134836:u8
        let s_803_0: bool = fn_state.gs_134836;
        // N s_803_1: branch s_803_0 b5280 b804
        if s_803_0 {
            return block_5280(state, tracer, fn_state);
        } else {
            return block_804(state, tracer, fn_state);
        };
    }
    fn block_804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_804_0: const #0u : u8
        let s_804_0: bool = false;
        // D s_804_1: write-var gs#134837 <= s_804_0
        fn_state.gs_134837 = s_804_0;
        // N s_804_2: jump b805
        return block_805(state, tracer, fn_state);
    }
    fn block_805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_805_0: read-var gs#134837:u8
        let s_805_0: bool = fn_state.gs_134837;
        // N s_805_1: branch s_805_0 b5279 b806
        if s_805_0 {
            return block_5279(state, tracer, fn_state);
        } else {
            return block_806(state, tracer, fn_state);
        };
    }
    fn block_806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_806_0: const #0u : u8
        let s_806_0: bool = false;
        // D s_806_1: write-var gs#134838 <= s_806_0
        fn_state.gs_134838 = s_806_0;
        // N s_806_2: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_807_0: read-var gs#134838:u8
        let s_807_0: bool = fn_state.gs_134838;
        // N s_807_1: branch s_807_0 b5278 b808
        if s_807_0 {
            return block_5278(state, tracer, fn_state);
        } else {
            return block_808(state, tracer, fn_state);
        };
    }
    fn block_808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_808_0: const #0u : u8
        let s_808_0: bool = false;
        // D s_808_1: write-var gs#134839 <= s_808_0
        fn_state.gs_134839 = s_808_0;
        // N s_808_2: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_809_0: read-var gs#134839:u8
        let s_809_0: bool = fn_state.gs_134839;
        // N s_809_1: branch s_809_0 b5277 b810
        if s_809_0 {
            return block_5277(state, tracer, fn_state);
        } else {
            return block_810(state, tracer, fn_state);
        };
    }
    fn block_810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_810_0: read-var CRm:u8
        let s_810_0: u8 = fn_state.CRm;
        // D s_810_1: cast zx s_810_0 -> bv
        let s_810_1: Bits = Bits::new(s_810_0 as u128, 4u16);
        // C s_810_2: const #2u : u8
        let s_810_2: u8 = 2;
        // C s_810_3: cast zx s_810_2 -> bv
        let s_810_3: Bits = Bits::new(s_810_2 as u128, 4u16);
        // D s_810_4: cmp-eq s_810_1 s_810_3
        let s_810_4: bool = ((s_810_1) == (s_810_3));
        // N s_810_5: branch s_810_4 b5276 b811
        if s_810_4 {
            return block_5276(state, tracer, fn_state);
        } else {
            return block_811(state, tracer, fn_state);
        };
    }
    fn block_811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_811_0: const #0u : u8
        let s_811_0: bool = false;
        // D s_811_1: write-var gs#134840 <= s_811_0
        fn_state.gs_134840 = s_811_0;
        // N s_811_2: jump b812
        return block_812(state, tracer, fn_state);
    }
    fn block_812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_812_0: read-var gs#134840:u8
        let s_812_0: bool = fn_state.gs_134840;
        // N s_812_1: branch s_812_0 b5275 b813
        if s_812_0 {
            return block_5275(state, tracer, fn_state);
        } else {
            return block_813(state, tracer, fn_state);
        };
    }
    fn block_813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_813_0: const #0u : u8
        let s_813_0: bool = false;
        // D s_813_1: write-var gs#134841 <= s_813_0
        fn_state.gs_134841 = s_813_0;
        // N s_813_2: jump b814
        return block_814(state, tracer, fn_state);
    }
    fn block_814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_814_0: read-var gs#134841:u8
        let s_814_0: bool = fn_state.gs_134841;
        // N s_814_1: branch s_814_0 b5274 b815
        if s_814_0 {
            return block_5274(state, tracer, fn_state);
        } else {
            return block_815(state, tracer, fn_state);
        };
    }
    fn block_815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_815_0: const #0u : u8
        let s_815_0: bool = false;
        // D s_815_1: write-var gs#134842 <= s_815_0
        fn_state.gs_134842 = s_815_0;
        // N s_815_2: jump b816
        return block_816(state, tracer, fn_state);
    }
    fn block_816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_816_0: read-var gs#134842:u8
        let s_816_0: bool = fn_state.gs_134842;
        // N s_816_1: branch s_816_0 b5273 b817
        if s_816_0 {
            return block_5273(state, tracer, fn_state);
        } else {
            return block_817(state, tracer, fn_state);
        };
    }
    fn block_817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_817_0: const #0u : u8
        let s_817_0: bool = false;
        // D s_817_1: write-var gs#134843 <= s_817_0
        fn_state.gs_134843 = s_817_0;
        // N s_817_2: jump b818
        return block_818(state, tracer, fn_state);
    }
    fn block_818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_818_0: read-var gs#134843:u8
        let s_818_0: bool = fn_state.gs_134843;
        // N s_818_1: branch s_818_0 b5272 b819
        if s_818_0 {
            return block_5272(state, tracer, fn_state);
        } else {
            return block_819(state, tracer, fn_state);
        };
    }
    fn block_819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_819_0: read-var CRm:u8
        let s_819_0: u8 = fn_state.CRm;
        // D s_819_1: cast zx s_819_0 -> bv
        let s_819_1: Bits = Bits::new(s_819_0 as u128, 4u16);
        // C s_819_2: const #8u : u8
        let s_819_2: u8 = 8;
        // C s_819_3: cast zx s_819_2 -> bv
        let s_819_3: Bits = Bits::new(s_819_2 as u128, 4u16);
        // D s_819_4: cmp-eq s_819_1 s_819_3
        let s_819_4: bool = ((s_819_1) == (s_819_3));
        // N s_819_5: branch s_819_4 b5271 b820
        if s_819_4 {
            return block_5271(state, tracer, fn_state);
        } else {
            return block_820(state, tracer, fn_state);
        };
    }
    fn block_820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_820_0: const #0u : u8
        let s_820_0: bool = false;
        // D s_820_1: write-var gs#134844 <= s_820_0
        fn_state.gs_134844 = s_820_0;
        // N s_820_2: jump b821
        return block_821(state, tracer, fn_state);
    }
    fn block_821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_821_0: read-var gs#134844:u8
        let s_821_0: bool = fn_state.gs_134844;
        // N s_821_1: branch s_821_0 b5270 b822
        if s_821_0 {
            return block_5270(state, tracer, fn_state);
        } else {
            return block_822(state, tracer, fn_state);
        };
    }
    fn block_822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_822_0: const #0u : u8
        let s_822_0: bool = false;
        // D s_822_1: write-var gs#134845 <= s_822_0
        fn_state.gs_134845 = s_822_0;
        // N s_822_2: jump b823
        return block_823(state, tracer, fn_state);
    }
    fn block_823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_823_0: read-var gs#134845:u8
        let s_823_0: bool = fn_state.gs_134845;
        // N s_823_1: branch s_823_0 b5269 b824
        if s_823_0 {
            return block_5269(state, tracer, fn_state);
        } else {
            return block_824(state, tracer, fn_state);
        };
    }
    fn block_824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_824_0: const #0u : u8
        let s_824_0: bool = false;
        // D s_824_1: write-var gs#134846 <= s_824_0
        fn_state.gs_134846 = s_824_0;
        // N s_824_2: jump b825
        return block_825(state, tracer, fn_state);
    }
    fn block_825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_825_0: read-var gs#134846:u8
        let s_825_0: bool = fn_state.gs_134846;
        // N s_825_1: branch s_825_0 b5268 b826
        if s_825_0 {
            return block_5268(state, tracer, fn_state);
        } else {
            return block_826(state, tracer, fn_state);
        };
    }
    fn block_826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_826_0: const #0u : u8
        let s_826_0: bool = false;
        // D s_826_1: write-var gs#134847 <= s_826_0
        fn_state.gs_134847 = s_826_0;
        // N s_826_2: jump b827
        return block_827(state, tracer, fn_state);
    }
    fn block_827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_827_0: read-var gs#134847:u8
        let s_827_0: bool = fn_state.gs_134847;
        // N s_827_1: branch s_827_0 b5267 b828
        if s_827_0 {
            return block_5267(state, tracer, fn_state);
        } else {
            return block_828(state, tracer, fn_state);
        };
    }
    fn block_828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_828_0: read-var CRm:u8
        let s_828_0: u8 = fn_state.CRm;
        // D s_828_1: cast zx s_828_0 -> bv
        let s_828_1: Bits = Bits::new(s_828_0 as u128, 4u16);
        // C s_828_2: const #0u : u8
        let s_828_2: u8 = 0;
        // C s_828_3: cast zx s_828_2 -> bv
        let s_828_3: Bits = Bits::new(s_828_2 as u128, 4u16);
        // D s_828_4: cmp-eq s_828_1 s_828_3
        let s_828_4: bool = ((s_828_1) == (s_828_3));
        // N s_828_5: branch s_828_4 b5266 b829
        if s_828_4 {
            return block_5266(state, tracer, fn_state);
        } else {
            return block_829(state, tracer, fn_state);
        };
    }
    fn block_829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_829_0: const #0u : u8
        let s_829_0: bool = false;
        // D s_829_1: write-var gs#134848 <= s_829_0
        fn_state.gs_134848 = s_829_0;
        // N s_829_2: jump b830
        return block_830(state, tracer, fn_state);
    }
    fn block_830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_830_0: read-var gs#134848:u8
        let s_830_0: bool = fn_state.gs_134848;
        // N s_830_1: branch s_830_0 b5265 b831
        if s_830_0 {
            return block_5265(state, tracer, fn_state);
        } else {
            return block_831(state, tracer, fn_state);
        };
    }
    fn block_831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_831_0: const #0u : u8
        let s_831_0: bool = false;
        // D s_831_1: write-var gs#134849 <= s_831_0
        fn_state.gs_134849 = s_831_0;
        // N s_831_2: jump b832
        return block_832(state, tracer, fn_state);
    }
    fn block_832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_832_0: read-var gs#134849:u8
        let s_832_0: bool = fn_state.gs_134849;
        // N s_832_1: branch s_832_0 b5264 b833
        if s_832_0 {
            return block_5264(state, tracer, fn_state);
        } else {
            return block_833(state, tracer, fn_state);
        };
    }
    fn block_833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_833_0: const #0u : u8
        let s_833_0: bool = false;
        // D s_833_1: write-var gs#134850 <= s_833_0
        fn_state.gs_134850 = s_833_0;
        // N s_833_2: jump b834
        return block_834(state, tracer, fn_state);
    }
    fn block_834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_834_0: read-var gs#134850:u8
        let s_834_0: bool = fn_state.gs_134850;
        // N s_834_1: branch s_834_0 b5263 b835
        if s_834_0 {
            return block_5263(state, tracer, fn_state);
        } else {
            return block_835(state, tracer, fn_state);
        };
    }
    fn block_835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_835_0: const #0u : u8
        let s_835_0: bool = false;
        // D s_835_1: write-var gs#134851 <= s_835_0
        fn_state.gs_134851 = s_835_0;
        // N s_835_2: jump b836
        return block_836(state, tracer, fn_state);
    }
    fn block_836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_836_0: read-var gs#134851:u8
        let s_836_0: bool = fn_state.gs_134851;
        // N s_836_1: branch s_836_0 b5262 b837
        if s_836_0 {
            return block_5262(state, tracer, fn_state);
        } else {
            return block_837(state, tracer, fn_state);
        };
    }
    fn block_837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_837_0: read-var CRm:u8
        let s_837_0: u8 = fn_state.CRm;
        // D s_837_1: cast zx s_837_0 -> bv
        let s_837_1: Bits = Bits::new(s_837_0 as u128, 4u16);
        // C s_837_2: const #0u : u8
        let s_837_2: u8 = 0;
        // C s_837_3: cast zx s_837_2 -> bv
        let s_837_3: Bits = Bits::new(s_837_2 as u128, 4u16);
        // D s_837_4: cmp-eq s_837_1 s_837_3
        let s_837_4: bool = ((s_837_1) == (s_837_3));
        // N s_837_5: branch s_837_4 b5261 b838
        if s_837_4 {
            return block_5261(state, tracer, fn_state);
        } else {
            return block_838(state, tracer, fn_state);
        };
    }
    fn block_838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_838_0: const #0u : u8
        let s_838_0: bool = false;
        // D s_838_1: write-var gs#134852 <= s_838_0
        fn_state.gs_134852 = s_838_0;
        // N s_838_2: jump b839
        return block_839(state, tracer, fn_state);
    }
    fn block_839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_839_0: read-var gs#134852:u8
        let s_839_0: bool = fn_state.gs_134852;
        // N s_839_1: branch s_839_0 b5260 b840
        if s_839_0 {
            return block_5260(state, tracer, fn_state);
        } else {
            return block_840(state, tracer, fn_state);
        };
    }
    fn block_840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_840_0: const #0u : u8
        let s_840_0: bool = false;
        // D s_840_1: write-var gs#134853 <= s_840_0
        fn_state.gs_134853 = s_840_0;
        // N s_840_2: jump b841
        return block_841(state, tracer, fn_state);
    }
    fn block_841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_841_0: read-var gs#134853:u8
        let s_841_0: bool = fn_state.gs_134853;
        // N s_841_1: branch s_841_0 b5259 b842
        if s_841_0 {
            return block_5259(state, tracer, fn_state);
        } else {
            return block_842(state, tracer, fn_state);
        };
    }
    fn block_842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_842_0: const #0u : u8
        let s_842_0: bool = false;
        // D s_842_1: write-var gs#134854 <= s_842_0
        fn_state.gs_134854 = s_842_0;
        // N s_842_2: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_843_0: read-var gs#134854:u8
        let s_843_0: bool = fn_state.gs_134854;
        // N s_843_1: branch s_843_0 b5258 b844
        if s_843_0 {
            return block_5258(state, tracer, fn_state);
        } else {
            return block_844(state, tracer, fn_state);
        };
    }
    fn block_844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_844_0: const #0u : u8
        let s_844_0: bool = false;
        // D s_844_1: write-var gs#134855 <= s_844_0
        fn_state.gs_134855 = s_844_0;
        // N s_844_2: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_845_0: read-var gs#134855:u8
        let s_845_0: bool = fn_state.gs_134855;
        // N s_845_1: branch s_845_0 b5257 b846
        if s_845_0 {
            return block_5257(state, tracer, fn_state);
        } else {
            return block_846(state, tracer, fn_state);
        };
    }
    fn block_846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_846_0: read-var CRm:u8
        let s_846_0: u8 = fn_state.CRm;
        // D s_846_1: cast zx s_846_0 -> bv
        let s_846_1: Bits = Bits::new(s_846_0 as u128, 4u16);
        // C s_846_2: const #12u : u8
        let s_846_2: u8 = 12;
        // C s_846_3: cast zx s_846_2 -> bv
        let s_846_3: Bits = Bits::new(s_846_2 as u128, 4u16);
        // D s_846_4: cmp-eq s_846_1 s_846_3
        let s_846_4: bool = ((s_846_1) == (s_846_3));
        // N s_846_5: branch s_846_4 b5256 b847
        if s_846_4 {
            return block_5256(state, tracer, fn_state);
        } else {
            return block_847(state, tracer, fn_state);
        };
    }
    fn block_847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_847_0: const #0u : u8
        let s_847_0: bool = false;
        // D s_847_1: write-var gs#134856 <= s_847_0
        fn_state.gs_134856 = s_847_0;
        // N s_847_2: jump b848
        return block_848(state, tracer, fn_state);
    }
    fn block_848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_848_0: read-var gs#134856:u8
        let s_848_0: bool = fn_state.gs_134856;
        // N s_848_1: branch s_848_0 b5255 b849
        if s_848_0 {
            return block_5255(state, tracer, fn_state);
        } else {
            return block_849(state, tracer, fn_state);
        };
    }
    fn block_849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_849_0: const #0u : u8
        let s_849_0: bool = false;
        // D s_849_1: write-var gs#134857 <= s_849_0
        fn_state.gs_134857 = s_849_0;
        // N s_849_2: jump b850
        return block_850(state, tracer, fn_state);
    }
    fn block_850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_850_0: read-var gs#134857:u8
        let s_850_0: bool = fn_state.gs_134857;
        // N s_850_1: branch s_850_0 b5254 b851
        if s_850_0 {
            return block_5254(state, tracer, fn_state);
        } else {
            return block_851(state, tracer, fn_state);
        };
    }
    fn block_851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_851_0: const #0u : u8
        let s_851_0: bool = false;
        // D s_851_1: write-var gs#134858 <= s_851_0
        fn_state.gs_134858 = s_851_0;
        // N s_851_2: jump b852
        return block_852(state, tracer, fn_state);
    }
    fn block_852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_852_0: read-var gs#134858:u8
        let s_852_0: bool = fn_state.gs_134858;
        // N s_852_1: branch s_852_0 b5253 b853
        if s_852_0 {
            return block_5253(state, tracer, fn_state);
        } else {
            return block_853(state, tracer, fn_state);
        };
    }
    fn block_853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_853_0: const #0u : u8
        let s_853_0: bool = false;
        // D s_853_1: write-var gs#134859 <= s_853_0
        fn_state.gs_134859 = s_853_0;
        // N s_853_2: jump b854
        return block_854(state, tracer, fn_state);
    }
    fn block_854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_854_0: read-var gs#134859:u8
        let s_854_0: bool = fn_state.gs_134859;
        // N s_854_1: branch s_854_0 b5252 b855
        if s_854_0 {
            return block_5252(state, tracer, fn_state);
        } else {
            return block_855(state, tracer, fn_state);
        };
    }
    fn block_855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_855_0: read-var CRm:u8
        let s_855_0: u8 = fn_state.CRm;
        // D s_855_1: cast zx s_855_0 -> bv
        let s_855_1: Bits = Bits::new(s_855_0 as u128, 4u16);
        // C s_855_2: const #7u : u8
        let s_855_2: u8 = 7;
        // C s_855_3: cast zx s_855_2 -> bv
        let s_855_3: Bits = Bits::new(s_855_2 as u128, 4u16);
        // D s_855_4: cmp-eq s_855_1 s_855_3
        let s_855_4: bool = ((s_855_1) == (s_855_3));
        // N s_855_5: branch s_855_4 b5251 b856
        if s_855_4 {
            return block_5251(state, tracer, fn_state);
        } else {
            return block_856(state, tracer, fn_state);
        };
    }
    fn block_856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_856_0: const #0u : u8
        let s_856_0: bool = false;
        // D s_856_1: write-var gs#134860 <= s_856_0
        fn_state.gs_134860 = s_856_0;
        // N s_856_2: jump b857
        return block_857(state, tracer, fn_state);
    }
    fn block_857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_857_0: read-var gs#134860:u8
        let s_857_0: bool = fn_state.gs_134860;
        // N s_857_1: branch s_857_0 b5250 b858
        if s_857_0 {
            return block_5250(state, tracer, fn_state);
        } else {
            return block_858(state, tracer, fn_state);
        };
    }
    fn block_858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_858_0: const #0u : u8
        let s_858_0: bool = false;
        // D s_858_1: write-var gs#134861 <= s_858_0
        fn_state.gs_134861 = s_858_0;
        // N s_858_2: jump b859
        return block_859(state, tracer, fn_state);
    }
    fn block_859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_859_0: read-var gs#134861:u8
        let s_859_0: bool = fn_state.gs_134861;
        // N s_859_1: branch s_859_0 b5249 b860
        if s_859_0 {
            return block_5249(state, tracer, fn_state);
        } else {
            return block_860(state, tracer, fn_state);
        };
    }
    fn block_860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_860_0: const #0u : u8
        let s_860_0: bool = false;
        // D s_860_1: write-var gs#134862 <= s_860_0
        fn_state.gs_134862 = s_860_0;
        // N s_860_2: jump b861
        return block_861(state, tracer, fn_state);
    }
    fn block_861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_861_0: read-var gs#134862:u8
        let s_861_0: bool = fn_state.gs_134862;
        // N s_861_1: branch s_861_0 b5248 b862
        if s_861_0 {
            return block_5248(state, tracer, fn_state);
        } else {
            return block_862(state, tracer, fn_state);
        };
    }
    fn block_862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_862_0: const #0u : u8
        let s_862_0: bool = false;
        // D s_862_1: write-var gs#134863 <= s_862_0
        fn_state.gs_134863 = s_862_0;
        // N s_862_2: jump b863
        return block_863(state, tracer, fn_state);
    }
    fn block_863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_863_0: read-var gs#134863:u8
        let s_863_0: bool = fn_state.gs_134863;
        // N s_863_1: branch s_863_0 b5247 b864
        if s_863_0 {
            return block_5247(state, tracer, fn_state);
        } else {
            return block_864(state, tracer, fn_state);
        };
    }
    fn block_864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_864_0: read-var CRm:u8
        let s_864_0: u8 = fn_state.CRm;
        // D s_864_1: cast zx s_864_0 -> bv
        let s_864_1: Bits = Bits::new(s_864_0 as u128, 4u16);
        // C s_864_2: const #15u : u8
        let s_864_2: u8 = 15;
        // C s_864_3: cast zx s_864_2 -> bv
        let s_864_3: Bits = Bits::new(s_864_2 as u128, 4u16);
        // D s_864_4: cmp-eq s_864_1 s_864_3
        let s_864_4: bool = ((s_864_1) == (s_864_3));
        // N s_864_5: branch s_864_4 b5246 b865
        if s_864_4 {
            return block_5246(state, tracer, fn_state);
        } else {
            return block_865(state, tracer, fn_state);
        };
    }
    fn block_865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_865_0: const #0u : u8
        let s_865_0: bool = false;
        // D s_865_1: write-var gs#134864 <= s_865_0
        fn_state.gs_134864 = s_865_0;
        // N s_865_2: jump b866
        return block_866(state, tracer, fn_state);
    }
    fn block_866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_866_0: read-var gs#134864:u8
        let s_866_0: bool = fn_state.gs_134864;
        // N s_866_1: branch s_866_0 b5245 b867
        if s_866_0 {
            return block_5245(state, tracer, fn_state);
        } else {
            return block_867(state, tracer, fn_state);
        };
    }
    fn block_867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_867_0: const #0u : u8
        let s_867_0: bool = false;
        // D s_867_1: write-var gs#134865 <= s_867_0
        fn_state.gs_134865 = s_867_0;
        // N s_867_2: jump b868
        return block_868(state, tracer, fn_state);
    }
    fn block_868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_868_0: read-var gs#134865:u8
        let s_868_0: bool = fn_state.gs_134865;
        // N s_868_1: branch s_868_0 b5244 b869
        if s_868_0 {
            return block_5244(state, tracer, fn_state);
        } else {
            return block_869(state, tracer, fn_state);
        };
    }
    fn block_869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_869_0: const #0u : u8
        let s_869_0: bool = false;
        // D s_869_1: write-var gs#134866 <= s_869_0
        fn_state.gs_134866 = s_869_0;
        // N s_869_2: jump b870
        return block_870(state, tracer, fn_state);
    }
    fn block_870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_870_0: read-var gs#134866:u8
        let s_870_0: bool = fn_state.gs_134866;
        // N s_870_1: branch s_870_0 b5243 b871
        if s_870_0 {
            return block_5243(state, tracer, fn_state);
        } else {
            return block_871(state, tracer, fn_state);
        };
    }
    fn block_871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_871_0: const #0u : u8
        let s_871_0: bool = false;
        // D s_871_1: write-var gs#134867 <= s_871_0
        fn_state.gs_134867 = s_871_0;
        // N s_871_2: jump b872
        return block_872(state, tracer, fn_state);
    }
    fn block_872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_872_0: read-var gs#134867:u8
        let s_872_0: bool = fn_state.gs_134867;
        // N s_872_1: branch s_872_0 b5242 b873
        if s_872_0 {
            return block_5242(state, tracer, fn_state);
        } else {
            return block_873(state, tracer, fn_state);
        };
    }
    fn block_873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_873_0: read-var CRm:u8
        let s_873_0: u8 = fn_state.CRm;
        // D s_873_1: cast zx s_873_0 -> bv
        let s_873_1: Bits = Bits::new(s_873_0 as u128, 4u16);
        // C s_873_2: const #14u : u8
        let s_873_2: u8 = 14;
        // C s_873_3: cast zx s_873_2 -> bv
        let s_873_3: Bits = Bits::new(s_873_2 as u128, 4u16);
        // D s_873_4: cmp-eq s_873_1 s_873_3
        let s_873_4: bool = ((s_873_1) == (s_873_3));
        // N s_873_5: branch s_873_4 b5241 b874
        if s_873_4 {
            return block_5241(state, tracer, fn_state);
        } else {
            return block_874(state, tracer, fn_state);
        };
    }
    fn block_874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_874_0: const #0u : u8
        let s_874_0: bool = false;
        // D s_874_1: write-var gs#134868 <= s_874_0
        fn_state.gs_134868 = s_874_0;
        // N s_874_2: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_875_0: read-var gs#134868:u8
        let s_875_0: bool = fn_state.gs_134868;
        // N s_875_1: branch s_875_0 b5240 b876
        if s_875_0 {
            return block_5240(state, tracer, fn_state);
        } else {
            return block_876(state, tracer, fn_state);
        };
    }
    fn block_876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_876_0: const #0u : u8
        let s_876_0: bool = false;
        // D s_876_1: write-var gs#134869 <= s_876_0
        fn_state.gs_134869 = s_876_0;
        // N s_876_2: jump b877
        return block_877(state, tracer, fn_state);
    }
    fn block_877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_877_0: read-var gs#134869:u8
        let s_877_0: bool = fn_state.gs_134869;
        // N s_877_1: branch s_877_0 b5239 b878
        if s_877_0 {
            return block_5239(state, tracer, fn_state);
        } else {
            return block_878(state, tracer, fn_state);
        };
    }
    fn block_878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_878_0: const #0u : u8
        let s_878_0: bool = false;
        // D s_878_1: write-var gs#134870 <= s_878_0
        fn_state.gs_134870 = s_878_0;
        // N s_878_2: jump b879
        return block_879(state, tracer, fn_state);
    }
    fn block_879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_879_0: read-var gs#134870:u8
        let s_879_0: bool = fn_state.gs_134870;
        // N s_879_1: branch s_879_0 b5238 b880
        if s_879_0 {
            return block_5238(state, tracer, fn_state);
        } else {
            return block_880(state, tracer, fn_state);
        };
    }
    fn block_880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_880_0: const #0u : u8
        let s_880_0: bool = false;
        // D s_880_1: write-var gs#134871 <= s_880_0
        fn_state.gs_134871 = s_880_0;
        // N s_880_2: jump b881
        return block_881(state, tracer, fn_state);
    }
    fn block_881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_881_0: read-var gs#134871:u8
        let s_881_0: bool = fn_state.gs_134871;
        // N s_881_1: branch s_881_0 b5237 b882
        if s_881_0 {
            return block_5237(state, tracer, fn_state);
        } else {
            return block_882(state, tracer, fn_state);
        };
    }
    fn block_882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_882_0: read-var CRm:u8
        let s_882_0: u8 = fn_state.CRm;
        // D s_882_1: cast zx s_882_0 -> bv
        let s_882_1: Bits = Bits::new(s_882_0 as u128, 4u16);
        // C s_882_2: const #13u : u8
        let s_882_2: u8 = 13;
        // C s_882_3: cast zx s_882_2 -> bv
        let s_882_3: Bits = Bits::new(s_882_2 as u128, 4u16);
        // D s_882_4: cmp-eq s_882_1 s_882_3
        let s_882_4: bool = ((s_882_1) == (s_882_3));
        // N s_882_5: branch s_882_4 b5236 b883
        if s_882_4 {
            return block_5236(state, tracer, fn_state);
        } else {
            return block_883(state, tracer, fn_state);
        };
    }
    fn block_883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_883_0: const #0u : u8
        let s_883_0: bool = false;
        // D s_883_1: write-var gs#134872 <= s_883_0
        fn_state.gs_134872 = s_883_0;
        // N s_883_2: jump b884
        return block_884(state, tracer, fn_state);
    }
    fn block_884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_884_0: read-var gs#134872:u8
        let s_884_0: bool = fn_state.gs_134872;
        // N s_884_1: branch s_884_0 b5235 b885
        if s_884_0 {
            return block_5235(state, tracer, fn_state);
        } else {
            return block_885(state, tracer, fn_state);
        };
    }
    fn block_885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_885_0: const #0u : u8
        let s_885_0: bool = false;
        // D s_885_1: write-var gs#134873 <= s_885_0
        fn_state.gs_134873 = s_885_0;
        // N s_885_2: jump b886
        return block_886(state, tracer, fn_state);
    }
    fn block_886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_886_0: read-var gs#134873:u8
        let s_886_0: bool = fn_state.gs_134873;
        // N s_886_1: branch s_886_0 b5234 b887
        if s_886_0 {
            return block_5234(state, tracer, fn_state);
        } else {
            return block_887(state, tracer, fn_state);
        };
    }
    fn block_887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_887_0: const #0u : u8
        let s_887_0: bool = false;
        // D s_887_1: write-var gs#134874 <= s_887_0
        fn_state.gs_134874 = s_887_0;
        // N s_887_2: jump b888
        return block_888(state, tracer, fn_state);
    }
    fn block_888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_888_0: read-var gs#134874:u8
        let s_888_0: bool = fn_state.gs_134874;
        // N s_888_1: branch s_888_0 b5233 b889
        if s_888_0 {
            return block_5233(state, tracer, fn_state);
        } else {
            return block_889(state, tracer, fn_state);
        };
    }
    fn block_889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_889_0: const #0u : u8
        let s_889_0: bool = false;
        // D s_889_1: write-var gs#134875 <= s_889_0
        fn_state.gs_134875 = s_889_0;
        // N s_889_2: jump b890
        return block_890(state, tracer, fn_state);
    }
    fn block_890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_890_0: read-var gs#134875:u8
        let s_890_0: bool = fn_state.gs_134875;
        // N s_890_1: branch s_890_0 b5232 b891
        if s_890_0 {
            return block_5232(state, tracer, fn_state);
        } else {
            return block_891(state, tracer, fn_state);
        };
    }
    fn block_891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_891_0: read-var CRm:u8
        let s_891_0: u8 = fn_state.CRm;
        // D s_891_1: cast zx s_891_0 -> bv
        let s_891_1: Bits = Bits::new(s_891_0 as u128, 4u16);
        // C s_891_2: const #12u : u8
        let s_891_2: u8 = 12;
        // C s_891_3: cast zx s_891_2 -> bv
        let s_891_3: Bits = Bits::new(s_891_2 as u128, 4u16);
        // D s_891_4: cmp-eq s_891_1 s_891_3
        let s_891_4: bool = ((s_891_1) == (s_891_3));
        // N s_891_5: branch s_891_4 b5231 b892
        if s_891_4 {
            return block_5231(state, tracer, fn_state);
        } else {
            return block_892(state, tracer, fn_state);
        };
    }
    fn block_892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_892_0: const #0u : u8
        let s_892_0: bool = false;
        // D s_892_1: write-var gs#134876 <= s_892_0
        fn_state.gs_134876 = s_892_0;
        // N s_892_2: jump b893
        return block_893(state, tracer, fn_state);
    }
    fn block_893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_893_0: read-var gs#134876:u8
        let s_893_0: bool = fn_state.gs_134876;
        // N s_893_1: branch s_893_0 b5230 b894
        if s_893_0 {
            return block_5230(state, tracer, fn_state);
        } else {
            return block_894(state, tracer, fn_state);
        };
    }
    fn block_894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_894_0: const #0u : u8
        let s_894_0: bool = false;
        // D s_894_1: write-var gs#134877 <= s_894_0
        fn_state.gs_134877 = s_894_0;
        // N s_894_2: jump b895
        return block_895(state, tracer, fn_state);
    }
    fn block_895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_895_0: read-var gs#134877:u8
        let s_895_0: bool = fn_state.gs_134877;
        // N s_895_1: branch s_895_0 b5229 b896
        if s_895_0 {
            return block_5229(state, tracer, fn_state);
        } else {
            return block_896(state, tracer, fn_state);
        };
    }
    fn block_896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_896_0: const #0u : u8
        let s_896_0: bool = false;
        // D s_896_1: write-var gs#134878 <= s_896_0
        fn_state.gs_134878 = s_896_0;
        // N s_896_2: jump b897
        return block_897(state, tracer, fn_state);
    }
    fn block_897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_897_0: read-var gs#134878:u8
        let s_897_0: bool = fn_state.gs_134878;
        // N s_897_1: branch s_897_0 b5228 b898
        if s_897_0 {
            return block_5228(state, tracer, fn_state);
        } else {
            return block_898(state, tracer, fn_state);
        };
    }
    fn block_898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_898_0: const #0u : u8
        let s_898_0: bool = false;
        // D s_898_1: write-var gs#134879 <= s_898_0
        fn_state.gs_134879 = s_898_0;
        // N s_898_2: jump b899
        return block_899(state, tracer, fn_state);
    }
    fn block_899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_899_0: read-var gs#134879:u8
        let s_899_0: bool = fn_state.gs_134879;
        // N s_899_1: branch s_899_0 b5227 b900
        if s_899_0 {
            return block_5227(state, tracer, fn_state);
        } else {
            return block_900(state, tracer, fn_state);
        };
    }
    fn block_900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_900_0: read-var CRm:u8
        let s_900_0: u8 = fn_state.CRm;
        // D s_900_1: cast zx s_900_0 -> bv
        let s_900_1: Bits = Bits::new(s_900_0 as u128, 4u16);
        // C s_900_2: const #11u : u8
        let s_900_2: u8 = 11;
        // C s_900_3: cast zx s_900_2 -> bv
        let s_900_3: Bits = Bits::new(s_900_2 as u128, 4u16);
        // D s_900_4: cmp-eq s_900_1 s_900_3
        let s_900_4: bool = ((s_900_1) == (s_900_3));
        // N s_900_5: branch s_900_4 b5226 b901
        if s_900_4 {
            return block_5226(state, tracer, fn_state);
        } else {
            return block_901(state, tracer, fn_state);
        };
    }
    fn block_901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_901_0: const #0u : u8
        let s_901_0: bool = false;
        // D s_901_1: write-var gs#134880 <= s_901_0
        fn_state.gs_134880 = s_901_0;
        // N s_901_2: jump b902
        return block_902(state, tracer, fn_state);
    }
    fn block_902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_902_0: read-var gs#134880:u8
        let s_902_0: bool = fn_state.gs_134880;
        // N s_902_1: branch s_902_0 b5225 b903
        if s_902_0 {
            return block_5225(state, tracer, fn_state);
        } else {
            return block_903(state, tracer, fn_state);
        };
    }
    fn block_903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_903_0: const #0u : u8
        let s_903_0: bool = false;
        // D s_903_1: write-var gs#134881 <= s_903_0
        fn_state.gs_134881 = s_903_0;
        // N s_903_2: jump b904
        return block_904(state, tracer, fn_state);
    }
    fn block_904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_904_0: read-var gs#134881:u8
        let s_904_0: bool = fn_state.gs_134881;
        // N s_904_1: branch s_904_0 b5224 b905
        if s_904_0 {
            return block_5224(state, tracer, fn_state);
        } else {
            return block_905(state, tracer, fn_state);
        };
    }
    fn block_905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_905_0: const #0u : u8
        let s_905_0: bool = false;
        // D s_905_1: write-var gs#134882 <= s_905_0
        fn_state.gs_134882 = s_905_0;
        // N s_905_2: jump b906
        return block_906(state, tracer, fn_state);
    }
    fn block_906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_906_0: read-var gs#134882:u8
        let s_906_0: bool = fn_state.gs_134882;
        // N s_906_1: branch s_906_0 b5223 b907
        if s_906_0 {
            return block_5223(state, tracer, fn_state);
        } else {
            return block_907(state, tracer, fn_state);
        };
    }
    fn block_907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_907_0: const #0u : u8
        let s_907_0: bool = false;
        // D s_907_1: write-var gs#134883 <= s_907_0
        fn_state.gs_134883 = s_907_0;
        // N s_907_2: jump b908
        return block_908(state, tracer, fn_state);
    }
    fn block_908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_908_0: read-var gs#134883:u8
        let s_908_0: bool = fn_state.gs_134883;
        // N s_908_1: branch s_908_0 b5222 b909
        if s_908_0 {
            return block_5222(state, tracer, fn_state);
        } else {
            return block_909(state, tracer, fn_state);
        };
    }
    fn block_909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_909_0: read-var CRm:u8
        let s_909_0: u8 = fn_state.CRm;
        // D s_909_1: cast zx s_909_0 -> bv
        let s_909_1: Bits = Bits::new(s_909_0 as u128, 4u16);
        // C s_909_2: const #10u : u8
        let s_909_2: u8 = 10;
        // C s_909_3: cast zx s_909_2 -> bv
        let s_909_3: Bits = Bits::new(s_909_2 as u128, 4u16);
        // D s_909_4: cmp-eq s_909_1 s_909_3
        let s_909_4: bool = ((s_909_1) == (s_909_3));
        // N s_909_5: branch s_909_4 b5221 b910
        if s_909_4 {
            return block_5221(state, tracer, fn_state);
        } else {
            return block_910(state, tracer, fn_state);
        };
    }
    fn block_910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_910_0: const #0u : u8
        let s_910_0: bool = false;
        // D s_910_1: write-var gs#134884 <= s_910_0
        fn_state.gs_134884 = s_910_0;
        // N s_910_2: jump b911
        return block_911(state, tracer, fn_state);
    }
    fn block_911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_911_0: read-var gs#134884:u8
        let s_911_0: bool = fn_state.gs_134884;
        // N s_911_1: branch s_911_0 b5220 b912
        if s_911_0 {
            return block_5220(state, tracer, fn_state);
        } else {
            return block_912(state, tracer, fn_state);
        };
    }
    fn block_912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_912_0: const #0u : u8
        let s_912_0: bool = false;
        // D s_912_1: write-var gs#134885 <= s_912_0
        fn_state.gs_134885 = s_912_0;
        // N s_912_2: jump b913
        return block_913(state, tracer, fn_state);
    }
    fn block_913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_913_0: read-var gs#134885:u8
        let s_913_0: bool = fn_state.gs_134885;
        // N s_913_1: branch s_913_0 b5219 b914
        if s_913_0 {
            return block_5219(state, tracer, fn_state);
        } else {
            return block_914(state, tracer, fn_state);
        };
    }
    fn block_914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_914_0: const #0u : u8
        let s_914_0: bool = false;
        // D s_914_1: write-var gs#134886 <= s_914_0
        fn_state.gs_134886 = s_914_0;
        // N s_914_2: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_915_0: read-var gs#134886:u8
        let s_915_0: bool = fn_state.gs_134886;
        // N s_915_1: branch s_915_0 b5218 b916
        if s_915_0 {
            return block_5218(state, tracer, fn_state);
        } else {
            return block_916(state, tracer, fn_state);
        };
    }
    fn block_916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_916_0: const #0u : u8
        let s_916_0: bool = false;
        // D s_916_1: write-var gs#134887 <= s_916_0
        fn_state.gs_134887 = s_916_0;
        // N s_916_2: jump b917
        return block_917(state, tracer, fn_state);
    }
    fn block_917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_917_0: read-var gs#134887:u8
        let s_917_0: bool = fn_state.gs_134887;
        // N s_917_1: branch s_917_0 b5217 b918
        if s_917_0 {
            return block_5217(state, tracer, fn_state);
        } else {
            return block_918(state, tracer, fn_state);
        };
    }
    fn block_918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_918_0: read-var CRm:u8
        let s_918_0: u8 = fn_state.CRm;
        // D s_918_1: cast zx s_918_0 -> bv
        let s_918_1: Bits = Bits::new(s_918_0 as u128, 4u16);
        // C s_918_2: const #9u : u8
        let s_918_2: u8 = 9;
        // C s_918_3: cast zx s_918_2 -> bv
        let s_918_3: Bits = Bits::new(s_918_2 as u128, 4u16);
        // D s_918_4: cmp-eq s_918_1 s_918_3
        let s_918_4: bool = ((s_918_1) == (s_918_3));
        // N s_918_5: branch s_918_4 b5216 b919
        if s_918_4 {
            return block_5216(state, tracer, fn_state);
        } else {
            return block_919(state, tracer, fn_state);
        };
    }
    fn block_919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_919_0: const #0u : u8
        let s_919_0: bool = false;
        // D s_919_1: write-var gs#134888 <= s_919_0
        fn_state.gs_134888 = s_919_0;
        // N s_919_2: jump b920
        return block_920(state, tracer, fn_state);
    }
    fn block_920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_920_0: read-var gs#134888:u8
        let s_920_0: bool = fn_state.gs_134888;
        // N s_920_1: branch s_920_0 b5215 b921
        if s_920_0 {
            return block_5215(state, tracer, fn_state);
        } else {
            return block_921(state, tracer, fn_state);
        };
    }
    fn block_921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_921_0: const #0u : u8
        let s_921_0: bool = false;
        // D s_921_1: write-var gs#134889 <= s_921_0
        fn_state.gs_134889 = s_921_0;
        // N s_921_2: jump b922
        return block_922(state, tracer, fn_state);
    }
    fn block_922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_922_0: read-var gs#134889:u8
        let s_922_0: bool = fn_state.gs_134889;
        // N s_922_1: branch s_922_0 b5214 b923
        if s_922_0 {
            return block_5214(state, tracer, fn_state);
        } else {
            return block_923(state, tracer, fn_state);
        };
    }
    fn block_923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_923_0: const #0u : u8
        let s_923_0: bool = false;
        // D s_923_1: write-var gs#134890 <= s_923_0
        fn_state.gs_134890 = s_923_0;
        // N s_923_2: jump b924
        return block_924(state, tracer, fn_state);
    }
    fn block_924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_924_0: read-var gs#134890:u8
        let s_924_0: bool = fn_state.gs_134890;
        // N s_924_1: branch s_924_0 b5213 b925
        if s_924_0 {
            return block_5213(state, tracer, fn_state);
        } else {
            return block_925(state, tracer, fn_state);
        };
    }
    fn block_925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_925_0: const #0u : u8
        let s_925_0: bool = false;
        // D s_925_1: write-var gs#134891 <= s_925_0
        fn_state.gs_134891 = s_925_0;
        // N s_925_2: jump b926
        return block_926(state, tracer, fn_state);
    }
    fn block_926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_926_0: read-var gs#134891:u8
        let s_926_0: bool = fn_state.gs_134891;
        // N s_926_1: branch s_926_0 b5212 b927
        if s_926_0 {
            return block_5212(state, tracer, fn_state);
        } else {
            return block_927(state, tracer, fn_state);
        };
    }
    fn block_927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_927_0: read-var CRm:u8
        let s_927_0: u8 = fn_state.CRm;
        // D s_927_1: cast zx s_927_0 -> bv
        let s_927_1: Bits = Bits::new(s_927_0 as u128, 4u16);
        // C s_927_2: const #8u : u8
        let s_927_2: u8 = 8;
        // C s_927_3: cast zx s_927_2 -> bv
        let s_927_3: Bits = Bits::new(s_927_2 as u128, 4u16);
        // D s_927_4: cmp-eq s_927_1 s_927_3
        let s_927_4: bool = ((s_927_1) == (s_927_3));
        // N s_927_5: branch s_927_4 b5211 b928
        if s_927_4 {
            return block_5211(state, tracer, fn_state);
        } else {
            return block_928(state, tracer, fn_state);
        };
    }
    fn block_928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_928_0: const #0u : u8
        let s_928_0: bool = false;
        // D s_928_1: write-var gs#134892 <= s_928_0
        fn_state.gs_134892 = s_928_0;
        // N s_928_2: jump b929
        return block_929(state, tracer, fn_state);
    }
    fn block_929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_929_0: read-var gs#134892:u8
        let s_929_0: bool = fn_state.gs_134892;
        // N s_929_1: branch s_929_0 b5210 b930
        if s_929_0 {
            return block_5210(state, tracer, fn_state);
        } else {
            return block_930(state, tracer, fn_state);
        };
    }
    fn block_930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_930_0: const #0u : u8
        let s_930_0: bool = false;
        // D s_930_1: write-var gs#134893 <= s_930_0
        fn_state.gs_134893 = s_930_0;
        // N s_930_2: jump b931
        return block_931(state, tracer, fn_state);
    }
    fn block_931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_931_0: read-var gs#134893:u8
        let s_931_0: bool = fn_state.gs_134893;
        // N s_931_1: branch s_931_0 b5209 b932
        if s_931_0 {
            return block_5209(state, tracer, fn_state);
        } else {
            return block_932(state, tracer, fn_state);
        };
    }
    fn block_932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_932_0: const #0u : u8
        let s_932_0: bool = false;
        // D s_932_1: write-var gs#134894 <= s_932_0
        fn_state.gs_134894 = s_932_0;
        // N s_932_2: jump b933
        return block_933(state, tracer, fn_state);
    }
    fn block_933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_933_0: read-var gs#134894:u8
        let s_933_0: bool = fn_state.gs_134894;
        // N s_933_1: branch s_933_0 b5208 b934
        if s_933_0 {
            return block_5208(state, tracer, fn_state);
        } else {
            return block_934(state, tracer, fn_state);
        };
    }
    fn block_934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_934_0: const #0u : u8
        let s_934_0: bool = false;
        // D s_934_1: write-var gs#134895 <= s_934_0
        fn_state.gs_134895 = s_934_0;
        // N s_934_2: jump b935
        return block_935(state, tracer, fn_state);
    }
    fn block_935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_935_0: read-var gs#134895:u8
        let s_935_0: bool = fn_state.gs_134895;
        // N s_935_1: branch s_935_0 b5207 b936
        if s_935_0 {
            return block_5207(state, tracer, fn_state);
        } else {
            return block_936(state, tracer, fn_state);
        };
    }
    fn block_936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_936_0: read-var CRm:u8
        let s_936_0: u8 = fn_state.CRm;
        // D s_936_1: cast zx s_936_0 -> bv
        let s_936_1: Bits = Bits::new(s_936_0 as u128, 4u16);
        // C s_936_2: const #7u : u8
        let s_936_2: u8 = 7;
        // C s_936_3: cast zx s_936_2 -> bv
        let s_936_3: Bits = Bits::new(s_936_2 as u128, 4u16);
        // D s_936_4: cmp-eq s_936_1 s_936_3
        let s_936_4: bool = ((s_936_1) == (s_936_3));
        // N s_936_5: branch s_936_4 b5206 b937
        if s_936_4 {
            return block_5206(state, tracer, fn_state);
        } else {
            return block_937(state, tracer, fn_state);
        };
    }
    fn block_937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_937_0: const #0u : u8
        let s_937_0: bool = false;
        // D s_937_1: write-var gs#134896 <= s_937_0
        fn_state.gs_134896 = s_937_0;
        // N s_937_2: jump b938
        return block_938(state, tracer, fn_state);
    }
    fn block_938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_938_0: read-var gs#134896:u8
        let s_938_0: bool = fn_state.gs_134896;
        // N s_938_1: branch s_938_0 b5205 b939
        if s_938_0 {
            return block_5205(state, tracer, fn_state);
        } else {
            return block_939(state, tracer, fn_state);
        };
    }
    fn block_939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_939_0: const #0u : u8
        let s_939_0: bool = false;
        // D s_939_1: write-var gs#134897 <= s_939_0
        fn_state.gs_134897 = s_939_0;
        // N s_939_2: jump b940
        return block_940(state, tracer, fn_state);
    }
    fn block_940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_940_0: read-var gs#134897:u8
        let s_940_0: bool = fn_state.gs_134897;
        // N s_940_1: branch s_940_0 b5204 b941
        if s_940_0 {
            return block_5204(state, tracer, fn_state);
        } else {
            return block_941(state, tracer, fn_state);
        };
    }
    fn block_941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_941_0: const #0u : u8
        let s_941_0: bool = false;
        // D s_941_1: write-var gs#134898 <= s_941_0
        fn_state.gs_134898 = s_941_0;
        // N s_941_2: jump b942
        return block_942(state, tracer, fn_state);
    }
    fn block_942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_942_0: read-var gs#134898:u8
        let s_942_0: bool = fn_state.gs_134898;
        // N s_942_1: branch s_942_0 b5203 b943
        if s_942_0 {
            return block_5203(state, tracer, fn_state);
        } else {
            return block_943(state, tracer, fn_state);
        };
    }
    fn block_943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_943_0: const #0u : u8
        let s_943_0: bool = false;
        // D s_943_1: write-var gs#134899 <= s_943_0
        fn_state.gs_134899 = s_943_0;
        // N s_943_2: jump b944
        return block_944(state, tracer, fn_state);
    }
    fn block_944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_944_0: read-var gs#134899:u8
        let s_944_0: bool = fn_state.gs_134899;
        // N s_944_1: branch s_944_0 b5202 b945
        if s_944_0 {
            return block_5202(state, tracer, fn_state);
        } else {
            return block_945(state, tracer, fn_state);
        };
    }
    fn block_945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_945_0: read-var CRm:u8
        let s_945_0: u8 = fn_state.CRm;
        // D s_945_1: cast zx s_945_0 -> bv
        let s_945_1: Bits = Bits::new(s_945_0 as u128, 4u16);
        // C s_945_2: const #6u : u8
        let s_945_2: u8 = 6;
        // C s_945_3: cast zx s_945_2 -> bv
        let s_945_3: Bits = Bits::new(s_945_2 as u128, 4u16);
        // D s_945_4: cmp-eq s_945_1 s_945_3
        let s_945_4: bool = ((s_945_1) == (s_945_3));
        // N s_945_5: branch s_945_4 b5201 b946
        if s_945_4 {
            return block_5201(state, tracer, fn_state);
        } else {
            return block_946(state, tracer, fn_state);
        };
    }
    fn block_946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_946_0: const #0u : u8
        let s_946_0: bool = false;
        // D s_946_1: write-var gs#134900 <= s_946_0
        fn_state.gs_134900 = s_946_0;
        // N s_946_2: jump b947
        return block_947(state, tracer, fn_state);
    }
    fn block_947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_947_0: read-var gs#134900:u8
        let s_947_0: bool = fn_state.gs_134900;
        // N s_947_1: branch s_947_0 b5200 b948
        if s_947_0 {
            return block_5200(state, tracer, fn_state);
        } else {
            return block_948(state, tracer, fn_state);
        };
    }
    fn block_948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_948_0: const #0u : u8
        let s_948_0: bool = false;
        // D s_948_1: write-var gs#134901 <= s_948_0
        fn_state.gs_134901 = s_948_0;
        // N s_948_2: jump b949
        return block_949(state, tracer, fn_state);
    }
    fn block_949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_949_0: read-var gs#134901:u8
        let s_949_0: bool = fn_state.gs_134901;
        // N s_949_1: branch s_949_0 b5199 b950
        if s_949_0 {
            return block_5199(state, tracer, fn_state);
        } else {
            return block_950(state, tracer, fn_state);
        };
    }
    fn block_950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_950_0: const #0u : u8
        let s_950_0: bool = false;
        // D s_950_1: write-var gs#134902 <= s_950_0
        fn_state.gs_134902 = s_950_0;
        // N s_950_2: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_951_0: read-var gs#134902:u8
        let s_951_0: bool = fn_state.gs_134902;
        // N s_951_1: branch s_951_0 b5198 b952
        if s_951_0 {
            return block_5198(state, tracer, fn_state);
        } else {
            return block_952(state, tracer, fn_state);
        };
    }
    fn block_952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_952_0: const #0u : u8
        let s_952_0: bool = false;
        // D s_952_1: write-var gs#134903 <= s_952_0
        fn_state.gs_134903 = s_952_0;
        // N s_952_2: jump b953
        return block_953(state, tracer, fn_state);
    }
    fn block_953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_953_0: read-var gs#134903:u8
        let s_953_0: bool = fn_state.gs_134903;
        // N s_953_1: branch s_953_0 b5197 b954
        if s_953_0 {
            return block_5197(state, tracer, fn_state);
        } else {
            return block_954(state, tracer, fn_state);
        };
    }
    fn block_954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_954_0: read-var CRm:u8
        let s_954_0: u8 = fn_state.CRm;
        // D s_954_1: cast zx s_954_0 -> bv
        let s_954_1: Bits = Bits::new(s_954_0 as u128, 4u16);
        // C s_954_2: const #5u : u8
        let s_954_2: u8 = 5;
        // C s_954_3: cast zx s_954_2 -> bv
        let s_954_3: Bits = Bits::new(s_954_2 as u128, 4u16);
        // D s_954_4: cmp-eq s_954_1 s_954_3
        let s_954_4: bool = ((s_954_1) == (s_954_3));
        // N s_954_5: branch s_954_4 b5196 b955
        if s_954_4 {
            return block_5196(state, tracer, fn_state);
        } else {
            return block_955(state, tracer, fn_state);
        };
    }
    fn block_955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_955_0: const #0u : u8
        let s_955_0: bool = false;
        // D s_955_1: write-var gs#134904 <= s_955_0
        fn_state.gs_134904 = s_955_0;
        // N s_955_2: jump b956
        return block_956(state, tracer, fn_state);
    }
    fn block_956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_956_0: read-var gs#134904:u8
        let s_956_0: bool = fn_state.gs_134904;
        // N s_956_1: branch s_956_0 b5195 b957
        if s_956_0 {
            return block_5195(state, tracer, fn_state);
        } else {
            return block_957(state, tracer, fn_state);
        };
    }
    fn block_957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_957_0: const #0u : u8
        let s_957_0: bool = false;
        // D s_957_1: write-var gs#134905 <= s_957_0
        fn_state.gs_134905 = s_957_0;
        // N s_957_2: jump b958
        return block_958(state, tracer, fn_state);
    }
    fn block_958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_958_0: read-var gs#134905:u8
        let s_958_0: bool = fn_state.gs_134905;
        // N s_958_1: branch s_958_0 b5194 b959
        if s_958_0 {
            return block_5194(state, tracer, fn_state);
        } else {
            return block_959(state, tracer, fn_state);
        };
    }
    fn block_959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_959_0: const #0u : u8
        let s_959_0: bool = false;
        // D s_959_1: write-var gs#134906 <= s_959_0
        fn_state.gs_134906 = s_959_0;
        // N s_959_2: jump b960
        return block_960(state, tracer, fn_state);
    }
    fn block_960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_960_0: read-var gs#134906:u8
        let s_960_0: bool = fn_state.gs_134906;
        // N s_960_1: branch s_960_0 b5193 b961
        if s_960_0 {
            return block_5193(state, tracer, fn_state);
        } else {
            return block_961(state, tracer, fn_state);
        };
    }
    fn block_961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_961_0: const #0u : u8
        let s_961_0: bool = false;
        // D s_961_1: write-var gs#134907 <= s_961_0
        fn_state.gs_134907 = s_961_0;
        // N s_961_2: jump b962
        return block_962(state, tracer, fn_state);
    }
    fn block_962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_962_0: read-var gs#134907:u8
        let s_962_0: bool = fn_state.gs_134907;
        // N s_962_1: branch s_962_0 b5192 b963
        if s_962_0 {
            return block_5192(state, tracer, fn_state);
        } else {
            return block_963(state, tracer, fn_state);
        };
    }
    fn block_963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_963_0: read-var CRm:u8
        let s_963_0: u8 = fn_state.CRm;
        // D s_963_1: cast zx s_963_0 -> bv
        let s_963_1: Bits = Bits::new(s_963_0 as u128, 4u16);
        // C s_963_2: const #4u : u8
        let s_963_2: u8 = 4;
        // C s_963_3: cast zx s_963_2 -> bv
        let s_963_3: Bits = Bits::new(s_963_2 as u128, 4u16);
        // D s_963_4: cmp-eq s_963_1 s_963_3
        let s_963_4: bool = ((s_963_1) == (s_963_3));
        // N s_963_5: branch s_963_4 b5191 b964
        if s_963_4 {
            return block_5191(state, tracer, fn_state);
        } else {
            return block_964(state, tracer, fn_state);
        };
    }
    fn block_964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_964_0: const #0u : u8
        let s_964_0: bool = false;
        // D s_964_1: write-var gs#134908 <= s_964_0
        fn_state.gs_134908 = s_964_0;
        // N s_964_2: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_965_0: read-var gs#134908:u8
        let s_965_0: bool = fn_state.gs_134908;
        // N s_965_1: branch s_965_0 b5190 b966
        if s_965_0 {
            return block_5190(state, tracer, fn_state);
        } else {
            return block_966(state, tracer, fn_state);
        };
    }
    fn block_966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_966_0: const #0u : u8
        let s_966_0: bool = false;
        // D s_966_1: write-var gs#134909 <= s_966_0
        fn_state.gs_134909 = s_966_0;
        // N s_966_2: jump b967
        return block_967(state, tracer, fn_state);
    }
    fn block_967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_967_0: read-var gs#134909:u8
        let s_967_0: bool = fn_state.gs_134909;
        // N s_967_1: branch s_967_0 b5189 b968
        if s_967_0 {
            return block_5189(state, tracer, fn_state);
        } else {
            return block_968(state, tracer, fn_state);
        };
    }
    fn block_968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_968_0: const #0u : u8
        let s_968_0: bool = false;
        // D s_968_1: write-var gs#134910 <= s_968_0
        fn_state.gs_134910 = s_968_0;
        // N s_968_2: jump b969
        return block_969(state, tracer, fn_state);
    }
    fn block_969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_969_0: read-var gs#134910:u8
        let s_969_0: bool = fn_state.gs_134910;
        // N s_969_1: branch s_969_0 b5188 b970
        if s_969_0 {
            return block_5188(state, tracer, fn_state);
        } else {
            return block_970(state, tracer, fn_state);
        };
    }
    fn block_970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_970_0: const #0u : u8
        let s_970_0: bool = false;
        // D s_970_1: write-var gs#134911 <= s_970_0
        fn_state.gs_134911 = s_970_0;
        // N s_970_2: jump b971
        return block_971(state, tracer, fn_state);
    }
    fn block_971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_971_0: read-var gs#134911:u8
        let s_971_0: bool = fn_state.gs_134911;
        // N s_971_1: branch s_971_0 b5187 b972
        if s_971_0 {
            return block_5187(state, tracer, fn_state);
        } else {
            return block_972(state, tracer, fn_state);
        };
    }
    fn block_972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_972_0: read-var CRm:u8
        let s_972_0: u8 = fn_state.CRm;
        // D s_972_1: cast zx s_972_0 -> bv
        let s_972_1: Bits = Bits::new(s_972_0 as u128, 4u16);
        // C s_972_2: const #3u : u8
        let s_972_2: u8 = 3;
        // C s_972_3: cast zx s_972_2 -> bv
        let s_972_3: Bits = Bits::new(s_972_2 as u128, 4u16);
        // D s_972_4: cmp-eq s_972_1 s_972_3
        let s_972_4: bool = ((s_972_1) == (s_972_3));
        // N s_972_5: branch s_972_4 b5186 b973
        if s_972_4 {
            return block_5186(state, tracer, fn_state);
        } else {
            return block_973(state, tracer, fn_state);
        };
    }
    fn block_973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_973_0: const #0u : u8
        let s_973_0: bool = false;
        // D s_973_1: write-var gs#134912 <= s_973_0
        fn_state.gs_134912 = s_973_0;
        // N s_973_2: jump b974
        return block_974(state, tracer, fn_state);
    }
    fn block_974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_974_0: read-var gs#134912:u8
        let s_974_0: bool = fn_state.gs_134912;
        // N s_974_1: branch s_974_0 b5185 b975
        if s_974_0 {
            return block_5185(state, tracer, fn_state);
        } else {
            return block_975(state, tracer, fn_state);
        };
    }
    fn block_975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_975_0: const #0u : u8
        let s_975_0: bool = false;
        // D s_975_1: write-var gs#134913 <= s_975_0
        fn_state.gs_134913 = s_975_0;
        // N s_975_2: jump b976
        return block_976(state, tracer, fn_state);
    }
    fn block_976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_976_0: read-var gs#134913:u8
        let s_976_0: bool = fn_state.gs_134913;
        // N s_976_1: branch s_976_0 b5184 b977
        if s_976_0 {
            return block_5184(state, tracer, fn_state);
        } else {
            return block_977(state, tracer, fn_state);
        };
    }
    fn block_977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_977_0: const #0u : u8
        let s_977_0: bool = false;
        // D s_977_1: write-var gs#134914 <= s_977_0
        fn_state.gs_134914 = s_977_0;
        // N s_977_2: jump b978
        return block_978(state, tracer, fn_state);
    }
    fn block_978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_978_0: read-var gs#134914:u8
        let s_978_0: bool = fn_state.gs_134914;
        // N s_978_1: branch s_978_0 b5183 b979
        if s_978_0 {
            return block_5183(state, tracer, fn_state);
        } else {
            return block_979(state, tracer, fn_state);
        };
    }
    fn block_979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_979_0: const #0u : u8
        let s_979_0: bool = false;
        // D s_979_1: write-var gs#134915 <= s_979_0
        fn_state.gs_134915 = s_979_0;
        // N s_979_2: jump b980
        return block_980(state, tracer, fn_state);
    }
    fn block_980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_980_0: read-var gs#134915:u8
        let s_980_0: bool = fn_state.gs_134915;
        // N s_980_1: branch s_980_0 b5182 b981
        if s_980_0 {
            return block_5182(state, tracer, fn_state);
        } else {
            return block_981(state, tracer, fn_state);
        };
    }
    fn block_981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_981_0: read-var CRm:u8
        let s_981_0: u8 = fn_state.CRm;
        // D s_981_1: cast zx s_981_0 -> bv
        let s_981_1: Bits = Bits::new(s_981_0 as u128, 4u16);
        // C s_981_2: const #2u : u8
        let s_981_2: u8 = 2;
        // C s_981_3: cast zx s_981_2 -> bv
        let s_981_3: Bits = Bits::new(s_981_2 as u128, 4u16);
        // D s_981_4: cmp-eq s_981_1 s_981_3
        let s_981_4: bool = ((s_981_1) == (s_981_3));
        // N s_981_5: branch s_981_4 b5181 b982
        if s_981_4 {
            return block_5181(state, tracer, fn_state);
        } else {
            return block_982(state, tracer, fn_state);
        };
    }
    fn block_982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_982_0: const #0u : u8
        let s_982_0: bool = false;
        // D s_982_1: write-var gs#134916 <= s_982_0
        fn_state.gs_134916 = s_982_0;
        // N s_982_2: jump b983
        return block_983(state, tracer, fn_state);
    }
    fn block_983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_983_0: read-var gs#134916:u8
        let s_983_0: bool = fn_state.gs_134916;
        // N s_983_1: branch s_983_0 b5180 b984
        if s_983_0 {
            return block_5180(state, tracer, fn_state);
        } else {
            return block_984(state, tracer, fn_state);
        };
    }
    fn block_984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_984_0: const #0u : u8
        let s_984_0: bool = false;
        // D s_984_1: write-var gs#134917 <= s_984_0
        fn_state.gs_134917 = s_984_0;
        // N s_984_2: jump b985
        return block_985(state, tracer, fn_state);
    }
    fn block_985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_985_0: read-var gs#134917:u8
        let s_985_0: bool = fn_state.gs_134917;
        // N s_985_1: branch s_985_0 b5179 b986
        if s_985_0 {
            return block_5179(state, tracer, fn_state);
        } else {
            return block_986(state, tracer, fn_state);
        };
    }
    fn block_986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_986_0: const #0u : u8
        let s_986_0: bool = false;
        // D s_986_1: write-var gs#134918 <= s_986_0
        fn_state.gs_134918 = s_986_0;
        // N s_986_2: jump b987
        return block_987(state, tracer, fn_state);
    }
    fn block_987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_987_0: read-var gs#134918:u8
        let s_987_0: bool = fn_state.gs_134918;
        // N s_987_1: branch s_987_0 b5178 b988
        if s_987_0 {
            return block_5178(state, tracer, fn_state);
        } else {
            return block_988(state, tracer, fn_state);
        };
    }
    fn block_988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_988_0: const #0u : u8
        let s_988_0: bool = false;
        // D s_988_1: write-var gs#134919 <= s_988_0
        fn_state.gs_134919 = s_988_0;
        // N s_988_2: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_989_0: read-var gs#134919:u8
        let s_989_0: bool = fn_state.gs_134919;
        // N s_989_1: branch s_989_0 b5177 b990
        if s_989_0 {
            return block_5177(state, tracer, fn_state);
        } else {
            return block_990(state, tracer, fn_state);
        };
    }
    fn block_990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_990_0: read-var CRm:u8
        let s_990_0: u8 = fn_state.CRm;
        // D s_990_1: cast zx s_990_0 -> bv
        let s_990_1: Bits = Bits::new(s_990_0 as u128, 4u16);
        // C s_990_2: const #1u : u8
        let s_990_2: u8 = 1;
        // C s_990_3: cast zx s_990_2 -> bv
        let s_990_3: Bits = Bits::new(s_990_2 as u128, 4u16);
        // D s_990_4: cmp-eq s_990_1 s_990_3
        let s_990_4: bool = ((s_990_1) == (s_990_3));
        // N s_990_5: branch s_990_4 b5176 b991
        if s_990_4 {
            return block_5176(state, tracer, fn_state);
        } else {
            return block_991(state, tracer, fn_state);
        };
    }
    fn block_991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_991_0: const #0u : u8
        let s_991_0: bool = false;
        // D s_991_1: write-var gs#134920 <= s_991_0
        fn_state.gs_134920 = s_991_0;
        // N s_991_2: jump b992
        return block_992(state, tracer, fn_state);
    }
    fn block_992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_992_0: read-var gs#134920:u8
        let s_992_0: bool = fn_state.gs_134920;
        // N s_992_1: branch s_992_0 b5175 b993
        if s_992_0 {
            return block_5175(state, tracer, fn_state);
        } else {
            return block_993(state, tracer, fn_state);
        };
    }
    fn block_993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_993_0: const #0u : u8
        let s_993_0: bool = false;
        // D s_993_1: write-var gs#134921 <= s_993_0
        fn_state.gs_134921 = s_993_0;
        // N s_993_2: jump b994
        return block_994(state, tracer, fn_state);
    }
    fn block_994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_994_0: read-var gs#134921:u8
        let s_994_0: bool = fn_state.gs_134921;
        // N s_994_1: branch s_994_0 b5174 b995
        if s_994_0 {
            return block_5174(state, tracer, fn_state);
        } else {
            return block_995(state, tracer, fn_state);
        };
    }
    fn block_995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_995_0: const #0u : u8
        let s_995_0: bool = false;
        // D s_995_1: write-var gs#134922 <= s_995_0
        fn_state.gs_134922 = s_995_0;
        // N s_995_2: jump b996
        return block_996(state, tracer, fn_state);
    }
    fn block_996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_996_0: read-var gs#134922:u8
        let s_996_0: bool = fn_state.gs_134922;
        // N s_996_1: branch s_996_0 b5173 b997
        if s_996_0 {
            return block_5173(state, tracer, fn_state);
        } else {
            return block_997(state, tracer, fn_state);
        };
    }
    fn block_997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_997_0: const #0u : u8
        let s_997_0: bool = false;
        // D s_997_1: write-var gs#134923 <= s_997_0
        fn_state.gs_134923 = s_997_0;
        // N s_997_2: jump b998
        return block_998(state, tracer, fn_state);
    }
    fn block_998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_998_0: read-var gs#134923:u8
        let s_998_0: bool = fn_state.gs_134923;
        // N s_998_1: branch s_998_0 b5172 b999
        if s_998_0 {
            return block_5172(state, tracer, fn_state);
        } else {
            return block_999(state, tracer, fn_state);
        };
    }
    fn block_999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_999_0: read-var CRm:u8
        let s_999_0: u8 = fn_state.CRm;
        // D s_999_1: cast zx s_999_0 -> bv
        let s_999_1: Bits = Bits::new(s_999_0 as u128, 4u16);
        // C s_999_2: const #0u : u8
        let s_999_2: u8 = 0;
        // C s_999_3: cast zx s_999_2 -> bv
        let s_999_3: Bits = Bits::new(s_999_2 as u128, 4u16);
        // D s_999_4: cmp-eq s_999_1 s_999_3
        let s_999_4: bool = ((s_999_1) == (s_999_3));
        // N s_999_5: branch s_999_4 b5171 b1000
        if s_999_4 {
            return block_5171(state, tracer, fn_state);
        } else {
            return block_1000(state, tracer, fn_state);
        };
    }
    fn block_1000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1000_0: const #0u : u8
        let s_1000_0: bool = false;
        // D s_1000_1: write-var gs#134924 <= s_1000_0
        fn_state.gs_134924 = s_1000_0;
        // N s_1000_2: jump b1001
        return block_1001(state, tracer, fn_state);
    }
    fn block_1001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1001_0: read-var gs#134924:u8
        let s_1001_0: bool = fn_state.gs_134924;
        // N s_1001_1: branch s_1001_0 b5170 b1002
        if s_1001_0 {
            return block_5170(state, tracer, fn_state);
        } else {
            return block_1002(state, tracer, fn_state);
        };
    }
    fn block_1002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1002_0: const #0u : u8
        let s_1002_0: bool = false;
        // D s_1002_1: write-var gs#134925 <= s_1002_0
        fn_state.gs_134925 = s_1002_0;
        // N s_1002_2: jump b1003
        return block_1003(state, tracer, fn_state);
    }
    fn block_1003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1003_0: read-var gs#134925:u8
        let s_1003_0: bool = fn_state.gs_134925;
        // N s_1003_1: branch s_1003_0 b5169 b1004
        if s_1003_0 {
            return block_5169(state, tracer, fn_state);
        } else {
            return block_1004(state, tracer, fn_state);
        };
    }
    fn block_1004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1004_0: const #0u : u8
        let s_1004_0: bool = false;
        // D s_1004_1: write-var gs#134926 <= s_1004_0
        fn_state.gs_134926 = s_1004_0;
        // N s_1004_2: jump b1005
        return block_1005(state, tracer, fn_state);
    }
    fn block_1005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1005_0: read-var gs#134926:u8
        let s_1005_0: bool = fn_state.gs_134926;
        // N s_1005_1: branch s_1005_0 b5168 b1006
        if s_1005_0 {
            return block_5168(state, tracer, fn_state);
        } else {
            return block_1006(state, tracer, fn_state);
        };
    }
    fn block_1006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1006_0: const #0u : u8
        let s_1006_0: bool = false;
        // D s_1006_1: write-var gs#134927 <= s_1006_0
        fn_state.gs_134927 = s_1006_0;
        // N s_1006_2: jump b1007
        return block_1007(state, tracer, fn_state);
    }
    fn block_1007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1007_0: read-var gs#134927:u8
        let s_1007_0: bool = fn_state.gs_134927;
        // N s_1007_1: branch s_1007_0 b5167 b1008
        if s_1007_0 {
            return block_5167(state, tracer, fn_state);
        } else {
            return block_1008(state, tracer, fn_state);
        };
    }
    fn block_1008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1008_0: read-var CRm:u8
        let s_1008_0: u8 = fn_state.CRm;
        // D s_1008_1: cast zx s_1008_0 -> bv
        let s_1008_1: Bits = Bits::new(s_1008_0 as u128, 4u16);
        // C s_1008_2: const #11u : u8
        let s_1008_2: u8 = 11;
        // C s_1008_3: cast zx s_1008_2 -> bv
        let s_1008_3: Bits = Bits::new(s_1008_2 as u128, 4u16);
        // D s_1008_4: cmp-eq s_1008_1 s_1008_3
        let s_1008_4: bool = ((s_1008_1) == (s_1008_3));
        // N s_1008_5: branch s_1008_4 b5166 b1009
        if s_1008_4 {
            return block_5166(state, tracer, fn_state);
        } else {
            return block_1009(state, tracer, fn_state);
        };
    }
    fn block_1009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1009_0: const #0u : u8
        let s_1009_0: bool = false;
        // D s_1009_1: write-var gs#134928 <= s_1009_0
        fn_state.gs_134928 = s_1009_0;
        // N s_1009_2: jump b1010
        return block_1010(state, tracer, fn_state);
    }
    fn block_1010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1010_0: read-var gs#134928:u8
        let s_1010_0: bool = fn_state.gs_134928;
        // N s_1010_1: branch s_1010_0 b5165 b1011
        if s_1010_0 {
            return block_5165(state, tracer, fn_state);
        } else {
            return block_1011(state, tracer, fn_state);
        };
    }
    fn block_1011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1011_0: const #0u : u8
        let s_1011_0: bool = false;
        // D s_1011_1: write-var gs#134929 <= s_1011_0
        fn_state.gs_134929 = s_1011_0;
        // N s_1011_2: jump b1012
        return block_1012(state, tracer, fn_state);
    }
    fn block_1012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1012_0: read-var gs#134929:u8
        let s_1012_0: bool = fn_state.gs_134929;
        // N s_1012_1: branch s_1012_0 b5164 b1013
        if s_1012_0 {
            return block_5164(state, tracer, fn_state);
        } else {
            return block_1013(state, tracer, fn_state);
        };
    }
    fn block_1013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1013_0: const #0u : u8
        let s_1013_0: bool = false;
        // D s_1013_1: write-var gs#134930 <= s_1013_0
        fn_state.gs_134930 = s_1013_0;
        // N s_1013_2: jump b1014
        return block_1014(state, tracer, fn_state);
    }
    fn block_1014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1014_0: read-var gs#134930:u8
        let s_1014_0: bool = fn_state.gs_134930;
        // N s_1014_1: branch s_1014_0 b5163 b1015
        if s_1014_0 {
            return block_5163(state, tracer, fn_state);
        } else {
            return block_1015(state, tracer, fn_state);
        };
    }
    fn block_1015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1015_0: const #0u : u8
        let s_1015_0: bool = false;
        // D s_1015_1: write-var gs#134931 <= s_1015_0
        fn_state.gs_134931 = s_1015_0;
        // N s_1015_2: jump b1016
        return block_1016(state, tracer, fn_state);
    }
    fn block_1016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1016_0: read-var gs#134931:u8
        let s_1016_0: bool = fn_state.gs_134931;
        // N s_1016_1: branch s_1016_0 b5162 b1017
        if s_1016_0 {
            return block_5162(state, tracer, fn_state);
        } else {
            return block_1017(state, tracer, fn_state);
        };
    }
    fn block_1017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1017_0: read-var CRm:u8
        let s_1017_0: u8 = fn_state.CRm;
        // D s_1017_1: cast zx s_1017_0 -> bv
        let s_1017_1: Bits = Bits::new(s_1017_0 as u128, 4u16);
        // C s_1017_2: const #4u : u8
        let s_1017_2: u8 = 4;
        // C s_1017_3: cast zx s_1017_2 -> bv
        let s_1017_3: Bits = Bits::new(s_1017_2 as u128, 4u16);
        // D s_1017_4: cmp-eq s_1017_1 s_1017_3
        let s_1017_4: bool = ((s_1017_1) == (s_1017_3));
        // N s_1017_5: branch s_1017_4 b5161 b1018
        if s_1017_4 {
            return block_5161(state, tracer, fn_state);
        } else {
            return block_1018(state, tracer, fn_state);
        };
    }
    fn block_1018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1018_0: const #0u : u8
        let s_1018_0: bool = false;
        // D s_1018_1: write-var gs#134932 <= s_1018_0
        fn_state.gs_134932 = s_1018_0;
        // N s_1018_2: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_1019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1019_0: read-var gs#134932:u8
        let s_1019_0: bool = fn_state.gs_134932;
        // N s_1019_1: branch s_1019_0 b5160 b1020
        if s_1019_0 {
            return block_5160(state, tracer, fn_state);
        } else {
            return block_1020(state, tracer, fn_state);
        };
    }
    fn block_1020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1020_0: const #0u : u8
        let s_1020_0: bool = false;
        // D s_1020_1: write-var gs#134933 <= s_1020_0
        fn_state.gs_134933 = s_1020_0;
        // N s_1020_2: jump b1021
        return block_1021(state, tracer, fn_state);
    }
    fn block_1021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1021_0: read-var gs#134933:u8
        let s_1021_0: bool = fn_state.gs_134933;
        // N s_1021_1: branch s_1021_0 b5159 b1022
        if s_1021_0 {
            return block_5159(state, tracer, fn_state);
        } else {
            return block_1022(state, tracer, fn_state);
        };
    }
    fn block_1022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1022_0: const #0u : u8
        let s_1022_0: bool = false;
        // D s_1022_1: write-var gs#134934 <= s_1022_0
        fn_state.gs_134934 = s_1022_0;
        // N s_1022_2: jump b1023
        return block_1023(state, tracer, fn_state);
    }
    fn block_1023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1023_0: read-var gs#134934:u8
        let s_1023_0: bool = fn_state.gs_134934;
        // N s_1023_1: branch s_1023_0 b5158 b1024
        if s_1023_0 {
            return block_5158(state, tracer, fn_state);
        } else {
            return block_1024(state, tracer, fn_state);
        };
    }
    fn block_1024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1024_0: const #0u : u8
        let s_1024_0: bool = false;
        // D s_1024_1: write-var gs#134935 <= s_1024_0
        fn_state.gs_134935 = s_1024_0;
        // N s_1024_2: jump b1025
        return block_1025(state, tracer, fn_state);
    }
    fn block_1025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1025_0: read-var gs#134935:u8
        let s_1025_0: bool = fn_state.gs_134935;
        // N s_1025_1: branch s_1025_0 b5157 b1026
        if s_1025_0 {
            return block_5157(state, tracer, fn_state);
        } else {
            return block_1026(state, tracer, fn_state);
        };
    }
    fn block_1026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1026_0: read-var CRm:u8
        let s_1026_0: u8 = fn_state.CRm;
        // D s_1026_1: cast zx s_1026_0 -> bv
        let s_1026_1: Bits = Bits::new(s_1026_0 as u128, 4u16);
        // C s_1026_2: const #12u : u8
        let s_1026_2: u8 = 12;
        // C s_1026_3: cast zx s_1026_2 -> bv
        let s_1026_3: Bits = Bits::new(s_1026_2 as u128, 4u16);
        // D s_1026_4: cmp-eq s_1026_1 s_1026_3
        let s_1026_4: bool = ((s_1026_1) == (s_1026_3));
        // N s_1026_5: branch s_1026_4 b5156 b1027
        if s_1026_4 {
            return block_5156(state, tracer, fn_state);
        } else {
            return block_1027(state, tracer, fn_state);
        };
    }
    fn block_1027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1027_0: const #0u : u8
        let s_1027_0: bool = false;
        // D s_1027_1: write-var gs#134936 <= s_1027_0
        fn_state.gs_134936 = s_1027_0;
        // N s_1027_2: jump b1028
        return block_1028(state, tracer, fn_state);
    }
    fn block_1028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1028_0: read-var gs#134936:u8
        let s_1028_0: bool = fn_state.gs_134936;
        // N s_1028_1: branch s_1028_0 b5155 b1029
        if s_1028_0 {
            return block_5155(state, tracer, fn_state);
        } else {
            return block_1029(state, tracer, fn_state);
        };
    }
    fn block_1029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1029_0: const #0u : u8
        let s_1029_0: bool = false;
        // D s_1029_1: write-var gs#134937 <= s_1029_0
        fn_state.gs_134937 = s_1029_0;
        // N s_1029_2: jump b1030
        return block_1030(state, tracer, fn_state);
    }
    fn block_1030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1030_0: read-var gs#134937:u8
        let s_1030_0: bool = fn_state.gs_134937;
        // N s_1030_1: branch s_1030_0 b5154 b1031
        if s_1030_0 {
            return block_5154(state, tracer, fn_state);
        } else {
            return block_1031(state, tracer, fn_state);
        };
    }
    fn block_1031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1031_0: const #0u : u8
        let s_1031_0: bool = false;
        // D s_1031_1: write-var gs#134938 <= s_1031_0
        fn_state.gs_134938 = s_1031_0;
        // N s_1031_2: jump b1032
        return block_1032(state, tracer, fn_state);
    }
    fn block_1032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1032_0: read-var gs#134938:u8
        let s_1032_0: bool = fn_state.gs_134938;
        // N s_1032_1: branch s_1032_0 b5153 b1033
        if s_1032_0 {
            return block_5153(state, tracer, fn_state);
        } else {
            return block_1033(state, tracer, fn_state);
        };
    }
    fn block_1033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1033_0: const #0u : u8
        let s_1033_0: bool = false;
        // D s_1033_1: write-var gs#134939 <= s_1033_0
        fn_state.gs_134939 = s_1033_0;
        // N s_1033_2: jump b1034
        return block_1034(state, tracer, fn_state);
    }
    fn block_1034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1034_0: read-var gs#134939:u8
        let s_1034_0: bool = fn_state.gs_134939;
        // N s_1034_1: branch s_1034_0 b5152 b1035
        if s_1034_0 {
            return block_5152(state, tracer, fn_state);
        } else {
            return block_1035(state, tracer, fn_state);
        };
    }
    fn block_1035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1035_0: read-var CRm:u8
        let s_1035_0: u8 = fn_state.CRm;
        // D s_1035_1: cast zx s_1035_0 -> bv
        let s_1035_1: Bits = Bits::new(s_1035_0 as u128, 4u16);
        // C s_1035_2: const #8u : u8
        let s_1035_2: u8 = 8;
        // C s_1035_3: cast zx s_1035_2 -> bv
        let s_1035_3: Bits = Bits::new(s_1035_2 as u128, 4u16);
        // D s_1035_4: cmp-eq s_1035_1 s_1035_3
        let s_1035_4: bool = ((s_1035_1) == (s_1035_3));
        // N s_1035_5: branch s_1035_4 b5151 b1036
        if s_1035_4 {
            return block_5151(state, tracer, fn_state);
        } else {
            return block_1036(state, tracer, fn_state);
        };
    }
    fn block_1036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1036_0: const #0u : u8
        let s_1036_0: bool = false;
        // D s_1036_1: write-var gs#134940 <= s_1036_0
        fn_state.gs_134940 = s_1036_0;
        // N s_1036_2: jump b1037
        return block_1037(state, tracer, fn_state);
    }
    fn block_1037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1037_0: read-var gs#134940:u8
        let s_1037_0: bool = fn_state.gs_134940;
        // N s_1037_1: branch s_1037_0 b5150 b1038
        if s_1037_0 {
            return block_5150(state, tracer, fn_state);
        } else {
            return block_1038(state, tracer, fn_state);
        };
    }
    fn block_1038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1038_0: const #0u : u8
        let s_1038_0: bool = false;
        // D s_1038_1: write-var gs#134941 <= s_1038_0
        fn_state.gs_134941 = s_1038_0;
        // N s_1038_2: jump b1039
        return block_1039(state, tracer, fn_state);
    }
    fn block_1039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1039_0: read-var gs#134941:u8
        let s_1039_0: bool = fn_state.gs_134941;
        // N s_1039_1: branch s_1039_0 b5149 b1040
        if s_1039_0 {
            return block_5149(state, tracer, fn_state);
        } else {
            return block_1040(state, tracer, fn_state);
        };
    }
    fn block_1040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1040_0: const #0u : u8
        let s_1040_0: bool = false;
        // D s_1040_1: write-var gs#134942 <= s_1040_0
        fn_state.gs_134942 = s_1040_0;
        // N s_1040_2: jump b1041
        return block_1041(state, tracer, fn_state);
    }
    fn block_1041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1041_0: read-var gs#134942:u8
        let s_1041_0: bool = fn_state.gs_134942;
        // N s_1041_1: branch s_1041_0 b5148 b1042
        if s_1041_0 {
            return block_5148(state, tracer, fn_state);
        } else {
            return block_1042(state, tracer, fn_state);
        };
    }
    fn block_1042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1042_0: const #0u : u8
        let s_1042_0: bool = false;
        // D s_1042_1: write-var gs#134943 <= s_1042_0
        fn_state.gs_134943 = s_1042_0;
        // N s_1042_2: jump b1043
        return block_1043(state, tracer, fn_state);
    }
    fn block_1043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1043_0: read-var gs#134943:u8
        let s_1043_0: bool = fn_state.gs_134943;
        // N s_1043_1: branch s_1043_0 b5147 b1044
        if s_1043_0 {
            return block_5147(state, tracer, fn_state);
        } else {
            return block_1044(state, tracer, fn_state);
        };
    }
    fn block_1044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1044_0: read-var CRm:u8
        let s_1044_0: u8 = fn_state.CRm;
        // D s_1044_1: cast zx s_1044_0 -> bv
        let s_1044_1: Bits = Bits::new(s_1044_0 as u128, 4u16);
        // C s_1044_2: const #13u : u8
        let s_1044_2: u8 = 13;
        // C s_1044_3: cast zx s_1044_2 -> bv
        let s_1044_3: Bits = Bits::new(s_1044_2 as u128, 4u16);
        // D s_1044_4: cmp-eq s_1044_1 s_1044_3
        let s_1044_4: bool = ((s_1044_1) == (s_1044_3));
        // N s_1044_5: branch s_1044_4 b5146 b1045
        if s_1044_4 {
            return block_5146(state, tracer, fn_state);
        } else {
            return block_1045(state, tracer, fn_state);
        };
    }
    fn block_1045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1045_0: const #0u : u8
        let s_1045_0: bool = false;
        // D s_1045_1: write-var gs#134944 <= s_1045_0
        fn_state.gs_134944 = s_1045_0;
        // N s_1045_2: jump b1046
        return block_1046(state, tracer, fn_state);
    }
    fn block_1046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1046_0: read-var gs#134944:u8
        let s_1046_0: bool = fn_state.gs_134944;
        // N s_1046_1: branch s_1046_0 b5145 b1047
        if s_1046_0 {
            return block_5145(state, tracer, fn_state);
        } else {
            return block_1047(state, tracer, fn_state);
        };
    }
    fn block_1047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1047_0: const #0u : u8
        let s_1047_0: bool = false;
        // D s_1047_1: write-var gs#134945 <= s_1047_0
        fn_state.gs_134945 = s_1047_0;
        // N s_1047_2: jump b1048
        return block_1048(state, tracer, fn_state);
    }
    fn block_1048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1048_0: read-var gs#134945:u8
        let s_1048_0: bool = fn_state.gs_134945;
        // N s_1048_1: branch s_1048_0 b5144 b1049
        if s_1048_0 {
            return block_5144(state, tracer, fn_state);
        } else {
            return block_1049(state, tracer, fn_state);
        };
    }
    fn block_1049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1049_0: const #0u : u8
        let s_1049_0: bool = false;
        // D s_1049_1: write-var gs#134946 <= s_1049_0
        fn_state.gs_134946 = s_1049_0;
        // N s_1049_2: jump b1050
        return block_1050(state, tracer, fn_state);
    }
    fn block_1050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1050_0: read-var gs#134946:u8
        let s_1050_0: bool = fn_state.gs_134946;
        // N s_1050_1: branch s_1050_0 b5143 b1051
        if s_1050_0 {
            return block_5143(state, tracer, fn_state);
        } else {
            return block_1051(state, tracer, fn_state);
        };
    }
    fn block_1051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1051_0: const #0u : u8
        let s_1051_0: bool = false;
        // D s_1051_1: write-var gs#134947 <= s_1051_0
        fn_state.gs_134947 = s_1051_0;
        // N s_1051_2: jump b1052
        return block_1052(state, tracer, fn_state);
    }
    fn block_1052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1052_0: read-var gs#134947:u8
        let s_1052_0: bool = fn_state.gs_134947;
        // N s_1052_1: branch s_1052_0 b5142 b1053
        if s_1052_0 {
            return block_5142(state, tracer, fn_state);
        } else {
            return block_1053(state, tracer, fn_state);
        };
    }
    fn block_1053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1053_0: read-var CRm:u8
        let s_1053_0: u8 = fn_state.CRm;
        // D s_1053_1: cast zx s_1053_0 -> bv
        let s_1053_1: Bits = Bits::new(s_1053_0 as u128, 4u16);
        // C s_1053_2: const #3u : u8
        let s_1053_2: u8 = 3;
        // C s_1053_3: cast zx s_1053_2 -> bv
        let s_1053_3: Bits = Bits::new(s_1053_2 as u128, 4u16);
        // D s_1053_4: cmp-eq s_1053_1 s_1053_3
        let s_1053_4: bool = ((s_1053_1) == (s_1053_3));
        // N s_1053_5: branch s_1053_4 b5141 b1054
        if s_1053_4 {
            return block_5141(state, tracer, fn_state);
        } else {
            return block_1054(state, tracer, fn_state);
        };
    }
    fn block_1054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1054_0: const #0u : u8
        let s_1054_0: bool = false;
        // D s_1054_1: write-var gs#134948 <= s_1054_0
        fn_state.gs_134948 = s_1054_0;
        // N s_1054_2: jump b1055
        return block_1055(state, tracer, fn_state);
    }
    fn block_1055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1055_0: read-var gs#134948:u8
        let s_1055_0: bool = fn_state.gs_134948;
        // N s_1055_1: branch s_1055_0 b5140 b1056
        if s_1055_0 {
            return block_5140(state, tracer, fn_state);
        } else {
            return block_1056(state, tracer, fn_state);
        };
    }
    fn block_1056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1056_0: const #0u : u8
        let s_1056_0: bool = false;
        // D s_1056_1: write-var gs#134949 <= s_1056_0
        fn_state.gs_134949 = s_1056_0;
        // N s_1056_2: jump b1057
        return block_1057(state, tracer, fn_state);
    }
    fn block_1057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1057_0: read-var gs#134949:u8
        let s_1057_0: bool = fn_state.gs_134949;
        // N s_1057_1: branch s_1057_0 b5139 b1058
        if s_1057_0 {
            return block_5139(state, tracer, fn_state);
        } else {
            return block_1058(state, tracer, fn_state);
        };
    }
    fn block_1058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1058_0: const #0u : u8
        let s_1058_0: bool = false;
        // D s_1058_1: write-var gs#134950 <= s_1058_0
        fn_state.gs_134950 = s_1058_0;
        // N s_1058_2: jump b1059
        return block_1059(state, tracer, fn_state);
    }
    fn block_1059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1059_0: read-var gs#134950:u8
        let s_1059_0: bool = fn_state.gs_134950;
        // N s_1059_1: branch s_1059_0 b5138 b1060
        if s_1059_0 {
            return block_5138(state, tracer, fn_state);
        } else {
            return block_1060(state, tracer, fn_state);
        };
    }
    fn block_1060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1060_0: const #0u : u8
        let s_1060_0: bool = false;
        // D s_1060_1: write-var gs#134951 <= s_1060_0
        fn_state.gs_134951 = s_1060_0;
        // N s_1060_2: jump b1061
        return block_1061(state, tracer, fn_state);
    }
    fn block_1061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1061_0: read-var gs#134951:u8
        let s_1061_0: bool = fn_state.gs_134951;
        // N s_1061_1: branch s_1061_0 b5137 b1062
        if s_1061_0 {
            return block_5137(state, tracer, fn_state);
        } else {
            return block_1062(state, tracer, fn_state);
        };
    }
    fn block_1062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1062_0: read-var CRm:u8
        let s_1062_0: u8 = fn_state.CRm;
        // D s_1062_1: cast zx s_1062_0 -> bv
        let s_1062_1: Bits = Bits::new(s_1062_0 as u128, 4u16);
        // C s_1062_2: const #0u : u8
        let s_1062_2: u8 = 0;
        // C s_1062_3: cast zx s_1062_2 -> bv
        let s_1062_3: Bits = Bits::new(s_1062_2 as u128, 4u16);
        // D s_1062_4: cmp-eq s_1062_1 s_1062_3
        let s_1062_4: bool = ((s_1062_1) == (s_1062_3));
        // N s_1062_5: branch s_1062_4 b5136 b1063
        if s_1062_4 {
            return block_5136(state, tracer, fn_state);
        } else {
            return block_1063(state, tracer, fn_state);
        };
    }
    fn block_1063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1063_0: const #0u : u8
        let s_1063_0: bool = false;
        // D s_1063_1: write-var gs#134952 <= s_1063_0
        fn_state.gs_134952 = s_1063_0;
        // N s_1063_2: jump b1064
        return block_1064(state, tracer, fn_state);
    }
    fn block_1064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1064_0: read-var gs#134952:u8
        let s_1064_0: bool = fn_state.gs_134952;
        // N s_1064_1: branch s_1064_0 b5135 b1065
        if s_1064_0 {
            return block_5135(state, tracer, fn_state);
        } else {
            return block_1065(state, tracer, fn_state);
        };
    }
    fn block_1065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1065_0: const #0u : u8
        let s_1065_0: bool = false;
        // D s_1065_1: write-var gs#134953 <= s_1065_0
        fn_state.gs_134953 = s_1065_0;
        // N s_1065_2: jump b1066
        return block_1066(state, tracer, fn_state);
    }
    fn block_1066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1066_0: read-var gs#134953:u8
        let s_1066_0: bool = fn_state.gs_134953;
        // N s_1066_1: branch s_1066_0 b5134 b1067
        if s_1066_0 {
            return block_5134(state, tracer, fn_state);
        } else {
            return block_1067(state, tracer, fn_state);
        };
    }
    fn block_1067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1067_0: const #0u : u8
        let s_1067_0: bool = false;
        // D s_1067_1: write-var gs#134954 <= s_1067_0
        fn_state.gs_134954 = s_1067_0;
        // N s_1067_2: jump b1068
        return block_1068(state, tracer, fn_state);
    }
    fn block_1068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1068_0: read-var gs#134954:u8
        let s_1068_0: bool = fn_state.gs_134954;
        // N s_1068_1: branch s_1068_0 b5133 b1069
        if s_1068_0 {
            return block_5133(state, tracer, fn_state);
        } else {
            return block_1069(state, tracer, fn_state);
        };
    }
    fn block_1069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1069_0: const #0u : u8
        let s_1069_0: bool = false;
        // D s_1069_1: write-var gs#134955 <= s_1069_0
        fn_state.gs_134955 = s_1069_0;
        // N s_1069_2: jump b1070
        return block_1070(state, tracer, fn_state);
    }
    fn block_1070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1070_0: read-var gs#134955:u8
        let s_1070_0: bool = fn_state.gs_134955;
        // N s_1070_1: branch s_1070_0 b5132 b1071
        if s_1070_0 {
            return block_5132(state, tracer, fn_state);
        } else {
            return block_1071(state, tracer, fn_state);
        };
    }
    fn block_1071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1071_0: read-var CRm:u8
        let s_1071_0: u8 = fn_state.CRm;
        // D s_1071_1: cast zx s_1071_0 -> bv
        let s_1071_1: Bits = Bits::new(s_1071_0 as u128, 4u16);
        // C s_1071_2: const #14u : u8
        let s_1071_2: u8 = 14;
        // C s_1071_3: cast zx s_1071_2 -> bv
        let s_1071_3: Bits = Bits::new(s_1071_2 as u128, 4u16);
        // D s_1071_4: cmp-eq s_1071_1 s_1071_3
        let s_1071_4: bool = ((s_1071_1) == (s_1071_3));
        // N s_1071_5: branch s_1071_4 b5131 b1072
        if s_1071_4 {
            return block_5131(state, tracer, fn_state);
        } else {
            return block_1072(state, tracer, fn_state);
        };
    }
    fn block_1072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1072_0: const #0u : u8
        let s_1072_0: bool = false;
        // D s_1072_1: write-var gs#134956 <= s_1072_0
        fn_state.gs_134956 = s_1072_0;
        // N s_1072_2: jump b1073
        return block_1073(state, tracer, fn_state);
    }
    fn block_1073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1073_0: read-var gs#134956:u8
        let s_1073_0: bool = fn_state.gs_134956;
        // N s_1073_1: branch s_1073_0 b5130 b1074
        if s_1073_0 {
            return block_5130(state, tracer, fn_state);
        } else {
            return block_1074(state, tracer, fn_state);
        };
    }
    fn block_1074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1074_0: const #0u : u8
        let s_1074_0: bool = false;
        // D s_1074_1: write-var gs#134957 <= s_1074_0
        fn_state.gs_134957 = s_1074_0;
        // N s_1074_2: jump b1075
        return block_1075(state, tracer, fn_state);
    }
    fn block_1075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1075_0: read-var gs#134957:u8
        let s_1075_0: bool = fn_state.gs_134957;
        // N s_1075_1: branch s_1075_0 b5129 b1076
        if s_1075_0 {
            return block_5129(state, tracer, fn_state);
        } else {
            return block_1076(state, tracer, fn_state);
        };
    }
    fn block_1076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1076_0: const #0u : u8
        let s_1076_0: bool = false;
        // D s_1076_1: write-var gs#134958 <= s_1076_0
        fn_state.gs_134958 = s_1076_0;
        // N s_1076_2: jump b1077
        return block_1077(state, tracer, fn_state);
    }
    fn block_1077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1077_0: read-var gs#134958:u8
        let s_1077_0: bool = fn_state.gs_134958;
        // N s_1077_1: branch s_1077_0 b5128 b1078
        if s_1077_0 {
            return block_5128(state, tracer, fn_state);
        } else {
            return block_1078(state, tracer, fn_state);
        };
    }
    fn block_1078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1078_0: const #0u : u8
        let s_1078_0: bool = false;
        // D s_1078_1: write-var gs#134959 <= s_1078_0
        fn_state.gs_134959 = s_1078_0;
        // N s_1078_2: jump b1079
        return block_1079(state, tracer, fn_state);
    }
    fn block_1079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1079_0: read-var gs#134959:u8
        let s_1079_0: bool = fn_state.gs_134959;
        // N s_1079_1: branch s_1079_0 b5127 b1080
        if s_1079_0 {
            return block_5127(state, tracer, fn_state);
        } else {
            return block_1080(state, tracer, fn_state);
        };
    }
    fn block_1080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1080_0: read-var CRm:u8
        let s_1080_0: u8 = fn_state.CRm;
        // D s_1080_1: cast zx s_1080_0 -> bv
        let s_1080_1: Bits = Bits::new(s_1080_0 as u128, 4u16);
        // C s_1080_2: const #7u : u8
        let s_1080_2: u8 = 7;
        // C s_1080_3: cast zx s_1080_2 -> bv
        let s_1080_3: Bits = Bits::new(s_1080_2 as u128, 4u16);
        // D s_1080_4: cmp-eq s_1080_1 s_1080_3
        let s_1080_4: bool = ((s_1080_1) == (s_1080_3));
        // N s_1080_5: branch s_1080_4 b5126 b1081
        if s_1080_4 {
            return block_5126(state, tracer, fn_state);
        } else {
            return block_1081(state, tracer, fn_state);
        };
    }
    fn block_1081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1081_0: const #0u : u8
        let s_1081_0: bool = false;
        // D s_1081_1: write-var gs#134960 <= s_1081_0
        fn_state.gs_134960 = s_1081_0;
        // N s_1081_2: jump b1082
        return block_1082(state, tracer, fn_state);
    }
    fn block_1082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1082_0: read-var gs#134960:u8
        let s_1082_0: bool = fn_state.gs_134960;
        // N s_1082_1: branch s_1082_0 b5125 b1083
        if s_1082_0 {
            return block_5125(state, tracer, fn_state);
        } else {
            return block_1083(state, tracer, fn_state);
        };
    }
    fn block_1083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1083_0: const #0u : u8
        let s_1083_0: bool = false;
        // D s_1083_1: write-var gs#134961 <= s_1083_0
        fn_state.gs_134961 = s_1083_0;
        // N s_1083_2: jump b1084
        return block_1084(state, tracer, fn_state);
    }
    fn block_1084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1084_0: read-var gs#134961:u8
        let s_1084_0: bool = fn_state.gs_134961;
        // N s_1084_1: branch s_1084_0 b5124 b1085
        if s_1084_0 {
            return block_5124(state, tracer, fn_state);
        } else {
            return block_1085(state, tracer, fn_state);
        };
    }
    fn block_1085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1085_0: const #0u : u8
        let s_1085_0: bool = false;
        // D s_1085_1: write-var gs#134962 <= s_1085_0
        fn_state.gs_134962 = s_1085_0;
        // N s_1085_2: jump b1086
        return block_1086(state, tracer, fn_state);
    }
    fn block_1086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1086_0: read-var gs#134962:u8
        let s_1086_0: bool = fn_state.gs_134962;
        // N s_1086_1: branch s_1086_0 b5123 b1087
        if s_1086_0 {
            return block_5123(state, tracer, fn_state);
        } else {
            return block_1087(state, tracer, fn_state);
        };
    }
    fn block_1087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1087_0: const #0u : u8
        let s_1087_0: bool = false;
        // D s_1087_1: write-var gs#134963 <= s_1087_0
        fn_state.gs_134963 = s_1087_0;
        // N s_1087_2: jump b1088
        return block_1088(state, tracer, fn_state);
    }
    fn block_1088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1088_0: read-var gs#134963:u8
        let s_1088_0: bool = fn_state.gs_134963;
        // N s_1088_1: branch s_1088_0 b5122 b1089
        if s_1088_0 {
            return block_5122(state, tracer, fn_state);
        } else {
            return block_1089(state, tracer, fn_state);
        };
    }
    fn block_1089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1089_0: read-var CRm:u8
        let s_1089_0: u8 = fn_state.CRm;
        // D s_1089_1: cast zx s_1089_0 -> bv
        let s_1089_1: Bits = Bits::new(s_1089_0 as u128, 4u16);
        // C s_1089_2: const #4u : u8
        let s_1089_2: u8 = 4;
        // C s_1089_3: cast zx s_1089_2 -> bv
        let s_1089_3: Bits = Bits::new(s_1089_2 as u128, 4u16);
        // D s_1089_4: cmp-eq s_1089_1 s_1089_3
        let s_1089_4: bool = ((s_1089_1) == (s_1089_3));
        // N s_1089_5: branch s_1089_4 b5121 b1090
        if s_1089_4 {
            return block_5121(state, tracer, fn_state);
        } else {
            return block_1090(state, tracer, fn_state);
        };
    }
    fn block_1090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1090_0: const #0u : u8
        let s_1090_0: bool = false;
        // D s_1090_1: write-var gs#134964 <= s_1090_0
        fn_state.gs_134964 = s_1090_0;
        // N s_1090_2: jump b1091
        return block_1091(state, tracer, fn_state);
    }
    fn block_1091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1091_0: read-var gs#134964:u8
        let s_1091_0: bool = fn_state.gs_134964;
        // N s_1091_1: branch s_1091_0 b5120 b1092
        if s_1091_0 {
            return block_5120(state, tracer, fn_state);
        } else {
            return block_1092(state, tracer, fn_state);
        };
    }
    fn block_1092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1092_0: const #0u : u8
        let s_1092_0: bool = false;
        // D s_1092_1: write-var gs#134965 <= s_1092_0
        fn_state.gs_134965 = s_1092_0;
        // N s_1092_2: jump b1093
        return block_1093(state, tracer, fn_state);
    }
    fn block_1093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1093_0: read-var gs#134965:u8
        let s_1093_0: bool = fn_state.gs_134965;
        // N s_1093_1: branch s_1093_0 b5119 b1094
        if s_1093_0 {
            return block_5119(state, tracer, fn_state);
        } else {
            return block_1094(state, tracer, fn_state);
        };
    }
    fn block_1094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1094_0: const #0u : u8
        let s_1094_0: bool = false;
        // D s_1094_1: write-var gs#134966 <= s_1094_0
        fn_state.gs_134966 = s_1094_0;
        // N s_1094_2: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_1095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1095_0: read-var gs#134966:u8
        let s_1095_0: bool = fn_state.gs_134966;
        // N s_1095_1: branch s_1095_0 b5118 b1096
        if s_1095_0 {
            return block_5118(state, tracer, fn_state);
        } else {
            return block_1096(state, tracer, fn_state);
        };
    }
    fn block_1096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1096_0: const #0u : u8
        let s_1096_0: bool = false;
        // D s_1096_1: write-var gs#134967 <= s_1096_0
        fn_state.gs_134967 = s_1096_0;
        // N s_1096_2: jump b1097
        return block_1097(state, tracer, fn_state);
    }
    fn block_1097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1097_0: read-var gs#134967:u8
        let s_1097_0: bool = fn_state.gs_134967;
        // N s_1097_1: branch s_1097_0 b5117 b1098
        if s_1097_0 {
            return block_5117(state, tracer, fn_state);
        } else {
            return block_1098(state, tracer, fn_state);
        };
    }
    fn block_1098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1098_0: read-var CRm:u8
        let s_1098_0: u8 = fn_state.CRm;
        // D s_1098_1: cast zx s_1098_0 -> bv
        let s_1098_1: Bits = Bits::new(s_1098_0 as u128, 4u16);
        // C s_1098_2: const #1u : u8
        let s_1098_2: u8 = 1;
        // C s_1098_3: cast zx s_1098_2 -> bv
        let s_1098_3: Bits = Bits::new(s_1098_2 as u128, 4u16);
        // D s_1098_4: cmp-eq s_1098_1 s_1098_3
        let s_1098_4: bool = ((s_1098_1) == (s_1098_3));
        // N s_1098_5: branch s_1098_4 b5116 b1099
        if s_1098_4 {
            return block_5116(state, tracer, fn_state);
        } else {
            return block_1099(state, tracer, fn_state);
        };
    }
    fn block_1099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1099_0: const #0u : u8
        let s_1099_0: bool = false;
        // D s_1099_1: write-var gs#134968 <= s_1099_0
        fn_state.gs_134968 = s_1099_0;
        // N s_1099_2: jump b1100
        return block_1100(state, tracer, fn_state);
    }
    fn block_1100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1100_0: read-var gs#134968:u8
        let s_1100_0: bool = fn_state.gs_134968;
        // N s_1100_1: branch s_1100_0 b5115 b1101
        if s_1100_0 {
            return block_5115(state, tracer, fn_state);
        } else {
            return block_1101(state, tracer, fn_state);
        };
    }
    fn block_1101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1101_0: const #0u : u8
        let s_1101_0: bool = false;
        // D s_1101_1: write-var gs#134969 <= s_1101_0
        fn_state.gs_134969 = s_1101_0;
        // N s_1101_2: jump b1102
        return block_1102(state, tracer, fn_state);
    }
    fn block_1102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1102_0: read-var gs#134969:u8
        let s_1102_0: bool = fn_state.gs_134969;
        // N s_1102_1: branch s_1102_0 b5114 b1103
        if s_1102_0 {
            return block_5114(state, tracer, fn_state);
        } else {
            return block_1103(state, tracer, fn_state);
        };
    }
    fn block_1103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1103_0: const #0u : u8
        let s_1103_0: bool = false;
        // D s_1103_1: write-var gs#134970 <= s_1103_0
        fn_state.gs_134970 = s_1103_0;
        // N s_1103_2: jump b1104
        return block_1104(state, tracer, fn_state);
    }
    fn block_1104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1104_0: read-var gs#134970:u8
        let s_1104_0: bool = fn_state.gs_134970;
        // N s_1104_1: branch s_1104_0 b5113 b1105
        if s_1104_0 {
            return block_5113(state, tracer, fn_state);
        } else {
            return block_1105(state, tracer, fn_state);
        };
    }
    fn block_1105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1105_0: const #0u : u8
        let s_1105_0: bool = false;
        // D s_1105_1: write-var gs#134971 <= s_1105_0
        fn_state.gs_134971 = s_1105_0;
        // N s_1105_2: jump b1106
        return block_1106(state, tracer, fn_state);
    }
    fn block_1106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1106_0: read-var gs#134971:u8
        let s_1106_0: bool = fn_state.gs_134971;
        // N s_1106_1: branch s_1106_0 b5112 b1107
        if s_1106_0 {
            return block_5112(state, tracer, fn_state);
        } else {
            return block_1107(state, tracer, fn_state);
        };
    }
    fn block_1107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1107_0: read-var CRm:u8
        let s_1107_0: u8 = fn_state.CRm;
        // D s_1107_1: cast zx s_1107_0 -> bv
        let s_1107_1: Bits = Bits::new(s_1107_0 as u128, 4u16);
        // C s_1107_2: const #12u : u8
        let s_1107_2: u8 = 12;
        // C s_1107_3: cast zx s_1107_2 -> bv
        let s_1107_3: Bits = Bits::new(s_1107_2 as u128, 4u16);
        // D s_1107_4: cmp-eq s_1107_1 s_1107_3
        let s_1107_4: bool = ((s_1107_1) == (s_1107_3));
        // N s_1107_5: branch s_1107_4 b5111 b1108
        if s_1107_4 {
            return block_5111(state, tracer, fn_state);
        } else {
            return block_1108(state, tracer, fn_state);
        };
    }
    fn block_1108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1108_0: const #0u : u8
        let s_1108_0: bool = false;
        // D s_1108_1: write-var gs#134972 <= s_1108_0
        fn_state.gs_134972 = s_1108_0;
        // N s_1108_2: jump b1109
        return block_1109(state, tracer, fn_state);
    }
    fn block_1109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1109_0: read-var gs#134972:u8
        let s_1109_0: bool = fn_state.gs_134972;
        // N s_1109_1: branch s_1109_0 b5110 b1110
        if s_1109_0 {
            return block_5110(state, tracer, fn_state);
        } else {
            return block_1110(state, tracer, fn_state);
        };
    }
    fn block_1110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1110_0: const #0u : u8
        let s_1110_0: bool = false;
        // D s_1110_1: write-var gs#134973 <= s_1110_0
        fn_state.gs_134973 = s_1110_0;
        // N s_1110_2: jump b1111
        return block_1111(state, tracer, fn_state);
    }
    fn block_1111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1111_0: read-var gs#134973:u8
        let s_1111_0: bool = fn_state.gs_134973;
        // N s_1111_1: branch s_1111_0 b5109 b1112
        if s_1111_0 {
            return block_5109(state, tracer, fn_state);
        } else {
            return block_1112(state, tracer, fn_state);
        };
    }
    fn block_1112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1112_0: const #0u : u8
        let s_1112_0: bool = false;
        // D s_1112_1: write-var gs#134974 <= s_1112_0
        fn_state.gs_134974 = s_1112_0;
        // N s_1112_2: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_1113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1113_0: read-var gs#134974:u8
        let s_1113_0: bool = fn_state.gs_134974;
        // N s_1113_1: branch s_1113_0 b5108 b1114
        if s_1113_0 {
            return block_5108(state, tracer, fn_state);
        } else {
            return block_1114(state, tracer, fn_state);
        };
    }
    fn block_1114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1114_0: const #0u : u8
        let s_1114_0: bool = false;
        // D s_1114_1: write-var gs#134975 <= s_1114_0
        fn_state.gs_134975 = s_1114_0;
        // N s_1114_2: jump b1115
        return block_1115(state, tracer, fn_state);
    }
    fn block_1115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1115_0: read-var gs#134975:u8
        let s_1115_0: bool = fn_state.gs_134975;
        // N s_1115_1: branch s_1115_0 b5107 b1116
        if s_1115_0 {
            return block_5107(state, tracer, fn_state);
        } else {
            return block_1116(state, tracer, fn_state);
        };
    }
    fn block_1116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1116_0: read-var CRm:u8
        let s_1116_0: u8 = fn_state.CRm;
        // D s_1116_1: cast zx s_1116_0 -> bv
        let s_1116_1: Bits = Bits::new(s_1116_0 as u128, 4u16);
        // C s_1116_2: const #0u : u8
        let s_1116_2: u8 = 0;
        // C s_1116_3: cast zx s_1116_2 -> bv
        let s_1116_3: Bits = Bits::new(s_1116_2 as u128, 4u16);
        // D s_1116_4: cmp-eq s_1116_1 s_1116_3
        let s_1116_4: bool = ((s_1116_1) == (s_1116_3));
        // N s_1116_5: branch s_1116_4 b5106 b1117
        if s_1116_4 {
            return block_5106(state, tracer, fn_state);
        } else {
            return block_1117(state, tracer, fn_state);
        };
    }
    fn block_1117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1117_0: const #0u : u8
        let s_1117_0: bool = false;
        // D s_1117_1: write-var gs#134976 <= s_1117_0
        fn_state.gs_134976 = s_1117_0;
        // N s_1117_2: jump b1118
        return block_1118(state, tracer, fn_state);
    }
    fn block_1118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1118_0: read-var gs#134976:u8
        let s_1118_0: bool = fn_state.gs_134976;
        // N s_1118_1: branch s_1118_0 b5105 b1119
        if s_1118_0 {
            return block_5105(state, tracer, fn_state);
        } else {
            return block_1119(state, tracer, fn_state);
        };
    }
    fn block_1119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1119_0: const #0u : u8
        let s_1119_0: bool = false;
        // D s_1119_1: write-var gs#134977 <= s_1119_0
        fn_state.gs_134977 = s_1119_0;
        // N s_1119_2: jump b1120
        return block_1120(state, tracer, fn_state);
    }
    fn block_1120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1120_0: read-var gs#134977:u8
        let s_1120_0: bool = fn_state.gs_134977;
        // N s_1120_1: branch s_1120_0 b5104 b1121
        if s_1120_0 {
            return block_5104(state, tracer, fn_state);
        } else {
            return block_1121(state, tracer, fn_state);
        };
    }
    fn block_1121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1121_0: const #0u : u8
        let s_1121_0: bool = false;
        // D s_1121_1: write-var gs#134978 <= s_1121_0
        fn_state.gs_134978 = s_1121_0;
        // N s_1121_2: jump b1122
        return block_1122(state, tracer, fn_state);
    }
    fn block_1122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1122_0: read-var gs#134978:u8
        let s_1122_0: bool = fn_state.gs_134978;
        // N s_1122_1: branch s_1122_0 b5103 b1123
        if s_1122_0 {
            return block_5103(state, tracer, fn_state);
        } else {
            return block_1123(state, tracer, fn_state);
        };
    }
    fn block_1123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1123_0: const #0u : u8
        let s_1123_0: bool = false;
        // D s_1123_1: write-var gs#134979 <= s_1123_0
        fn_state.gs_134979 = s_1123_0;
        // N s_1123_2: jump b1124
        return block_1124(state, tracer, fn_state);
    }
    fn block_1124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1124_0: read-var gs#134979:u8
        let s_1124_0: bool = fn_state.gs_134979;
        // N s_1124_1: branch s_1124_0 b5102 b1125
        if s_1124_0 {
            return block_5102(state, tracer, fn_state);
        } else {
            return block_1125(state, tracer, fn_state);
        };
    }
    fn block_1125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1125_0: read-var CRm:u8
        let s_1125_0: u8 = fn_state.CRm;
        // D s_1125_1: cast zx s_1125_0 -> bv
        let s_1125_1: Bits = Bits::new(s_1125_0 as u128, 4u16);
        // C s_1125_2: const #8u : u8
        let s_1125_2: u8 = 8;
        // C s_1125_3: cast zx s_1125_2 -> bv
        let s_1125_3: Bits = Bits::new(s_1125_2 as u128, 4u16);
        // D s_1125_4: cmp-eq s_1125_1 s_1125_3
        let s_1125_4: bool = ((s_1125_1) == (s_1125_3));
        // N s_1125_5: branch s_1125_4 b5101 b1126
        if s_1125_4 {
            return block_5101(state, tracer, fn_state);
        } else {
            return block_1126(state, tracer, fn_state);
        };
    }
    fn block_1126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1126_0: const #0u : u8
        let s_1126_0: bool = false;
        // D s_1126_1: write-var gs#134980 <= s_1126_0
        fn_state.gs_134980 = s_1126_0;
        // N s_1126_2: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_1127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1127_0: read-var gs#134980:u8
        let s_1127_0: bool = fn_state.gs_134980;
        // N s_1127_1: branch s_1127_0 b5100 b1128
        if s_1127_0 {
            return block_5100(state, tracer, fn_state);
        } else {
            return block_1128(state, tracer, fn_state);
        };
    }
    fn block_1128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1128_0: const #0u : u8
        let s_1128_0: bool = false;
        // D s_1128_1: write-var gs#134981 <= s_1128_0
        fn_state.gs_134981 = s_1128_0;
        // N s_1128_2: jump b1129
        return block_1129(state, tracer, fn_state);
    }
    fn block_1129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1129_0: read-var gs#134981:u8
        let s_1129_0: bool = fn_state.gs_134981;
        // N s_1129_1: branch s_1129_0 b5099 b1130
        if s_1129_0 {
            return block_5099(state, tracer, fn_state);
        } else {
            return block_1130(state, tracer, fn_state);
        };
    }
    fn block_1130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1130_0: const #0u : u8
        let s_1130_0: bool = false;
        // D s_1130_1: write-var gs#134982 <= s_1130_0
        fn_state.gs_134982 = s_1130_0;
        // N s_1130_2: jump b1131
        return block_1131(state, tracer, fn_state);
    }
    fn block_1131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1131_0: read-var gs#134982:u8
        let s_1131_0: bool = fn_state.gs_134982;
        // N s_1131_1: branch s_1131_0 b5098 b1132
        if s_1131_0 {
            return block_5098(state, tracer, fn_state);
        } else {
            return block_1132(state, tracer, fn_state);
        };
    }
    fn block_1132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1132_0: const #0u : u8
        let s_1132_0: bool = false;
        // D s_1132_1: write-var gs#134983 <= s_1132_0
        fn_state.gs_134983 = s_1132_0;
        // N s_1132_2: jump b1133
        return block_1133(state, tracer, fn_state);
    }
    fn block_1133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1133_0: read-var gs#134983:u8
        let s_1133_0: bool = fn_state.gs_134983;
        // N s_1133_1: branch s_1133_0 b5097 b1134
        if s_1133_0 {
            return block_5097(state, tracer, fn_state);
        } else {
            return block_1134(state, tracer, fn_state);
        };
    }
    fn block_1134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1134_0: read-var CRm:u8
        let s_1134_0: u8 = fn_state.CRm;
        // D s_1134_1: cast zx s_1134_0 -> bv
        let s_1134_1: Bits = Bits::new(s_1134_0 as u128, 4u16);
        // C s_1134_2: const #9u : u8
        let s_1134_2: u8 = 9;
        // C s_1134_3: cast zx s_1134_2 -> bv
        let s_1134_3: Bits = Bits::new(s_1134_2 as u128, 4u16);
        // D s_1134_4: cmp-eq s_1134_1 s_1134_3
        let s_1134_4: bool = ((s_1134_1) == (s_1134_3));
        // N s_1134_5: branch s_1134_4 b5096 b1135
        if s_1134_4 {
            return block_5096(state, tracer, fn_state);
        } else {
            return block_1135(state, tracer, fn_state);
        };
    }
    fn block_1135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1135_0: const #0u : u8
        let s_1135_0: bool = false;
        // D s_1135_1: write-var gs#134984 <= s_1135_0
        fn_state.gs_134984 = s_1135_0;
        // N s_1135_2: jump b1136
        return block_1136(state, tracer, fn_state);
    }
    fn block_1136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1136_0: read-var gs#134984:u8
        let s_1136_0: bool = fn_state.gs_134984;
        // N s_1136_1: branch s_1136_0 b5095 b1137
        if s_1136_0 {
            return block_5095(state, tracer, fn_state);
        } else {
            return block_1137(state, tracer, fn_state);
        };
    }
    fn block_1137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1137_0: const #0u : u8
        let s_1137_0: bool = false;
        // D s_1137_1: write-var gs#134985 <= s_1137_0
        fn_state.gs_134985 = s_1137_0;
        // N s_1137_2: jump b1138
        return block_1138(state, tracer, fn_state);
    }
    fn block_1138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1138_0: read-var gs#134985:u8
        let s_1138_0: bool = fn_state.gs_134985;
        // N s_1138_1: branch s_1138_0 b5094 b1139
        if s_1138_0 {
            return block_5094(state, tracer, fn_state);
        } else {
            return block_1139(state, tracer, fn_state);
        };
    }
    fn block_1139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1139_0: const #0u : u8
        let s_1139_0: bool = false;
        // D s_1139_1: write-var gs#134986 <= s_1139_0
        fn_state.gs_134986 = s_1139_0;
        // N s_1139_2: jump b1140
        return block_1140(state, tracer, fn_state);
    }
    fn block_1140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1140_0: read-var gs#134986:u8
        let s_1140_0: bool = fn_state.gs_134986;
        // N s_1140_1: branch s_1140_0 b5093 b1141
        if s_1140_0 {
            return block_5093(state, tracer, fn_state);
        } else {
            return block_1141(state, tracer, fn_state);
        };
    }
    fn block_1141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1141_0: const #0u : u8
        let s_1141_0: bool = false;
        // D s_1141_1: write-var gs#134987 <= s_1141_0
        fn_state.gs_134987 = s_1141_0;
        // N s_1141_2: jump b1142
        return block_1142(state, tracer, fn_state);
    }
    fn block_1142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1142_0: read-var gs#134987:u8
        let s_1142_0: bool = fn_state.gs_134987;
        // N s_1142_1: branch s_1142_0 b5092 b1143
        if s_1142_0 {
            return block_5092(state, tracer, fn_state);
        } else {
            return block_1143(state, tracer, fn_state);
        };
    }
    fn block_1143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1143_0: read-var CRm:u8
        let s_1143_0: u8 = fn_state.CRm;
        // D s_1143_1: cast zx s_1143_0 -> bv
        let s_1143_1: Bits = Bits::new(s_1143_0 as u128, 4u16);
        // C s_1143_2: const #9u : u8
        let s_1143_2: u8 = 9;
        // C s_1143_3: cast zx s_1143_2 -> bv
        let s_1143_3: Bits = Bits::new(s_1143_2 as u128, 4u16);
        // D s_1143_4: cmp-eq s_1143_1 s_1143_3
        let s_1143_4: bool = ((s_1143_1) == (s_1143_3));
        // N s_1143_5: branch s_1143_4 b5091 b1144
        if s_1143_4 {
            return block_5091(state, tracer, fn_state);
        } else {
            return block_1144(state, tracer, fn_state);
        };
    }
    fn block_1144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1144_0: const #0u : u8
        let s_1144_0: bool = false;
        // D s_1144_1: write-var gs#134988 <= s_1144_0
        fn_state.gs_134988 = s_1144_0;
        // N s_1144_2: jump b1145
        return block_1145(state, tracer, fn_state);
    }
    fn block_1145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1145_0: read-var gs#134988:u8
        let s_1145_0: bool = fn_state.gs_134988;
        // N s_1145_1: branch s_1145_0 b5090 b1146
        if s_1145_0 {
            return block_5090(state, tracer, fn_state);
        } else {
            return block_1146(state, tracer, fn_state);
        };
    }
    fn block_1146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1146_0: const #0u : u8
        let s_1146_0: bool = false;
        // D s_1146_1: write-var gs#134989 <= s_1146_0
        fn_state.gs_134989 = s_1146_0;
        // N s_1146_2: jump b1147
        return block_1147(state, tracer, fn_state);
    }
    fn block_1147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1147_0: read-var gs#134989:u8
        let s_1147_0: bool = fn_state.gs_134989;
        // N s_1147_1: branch s_1147_0 b5089 b1148
        if s_1147_0 {
            return block_5089(state, tracer, fn_state);
        } else {
            return block_1148(state, tracer, fn_state);
        };
    }
    fn block_1148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1148_0: const #0u : u8
        let s_1148_0: bool = false;
        // D s_1148_1: write-var gs#134990 <= s_1148_0
        fn_state.gs_134990 = s_1148_0;
        // N s_1148_2: jump b1149
        return block_1149(state, tracer, fn_state);
    }
    fn block_1149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1149_0: read-var gs#134990:u8
        let s_1149_0: bool = fn_state.gs_134990;
        // N s_1149_1: branch s_1149_0 b5088 b1150
        if s_1149_0 {
            return block_5088(state, tracer, fn_state);
        } else {
            return block_1150(state, tracer, fn_state);
        };
    }
    fn block_1150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1150_0: const #0u : u8
        let s_1150_0: bool = false;
        // D s_1150_1: write-var gs#134991 <= s_1150_0
        fn_state.gs_134991 = s_1150_0;
        // N s_1150_2: jump b1151
        return block_1151(state, tracer, fn_state);
    }
    fn block_1151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1151_0: read-var gs#134991:u8
        let s_1151_0: bool = fn_state.gs_134991;
        // N s_1151_1: branch s_1151_0 b5087 b1152
        if s_1151_0 {
            return block_5087(state, tracer, fn_state);
        } else {
            return block_1152(state, tracer, fn_state);
        };
    }
    fn block_1152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1152_0: read-var CRm:u8
        let s_1152_0: u8 = fn_state.CRm;
        // D s_1152_1: cast zx s_1152_0 -> bv
        let s_1152_1: Bits = Bits::new(s_1152_0 as u128, 4u16);
        // C s_1152_2: const #9u : u8
        let s_1152_2: u8 = 9;
        // C s_1152_3: cast zx s_1152_2 -> bv
        let s_1152_3: Bits = Bits::new(s_1152_2 as u128, 4u16);
        // D s_1152_4: cmp-eq s_1152_1 s_1152_3
        let s_1152_4: bool = ((s_1152_1) == (s_1152_3));
        // N s_1152_5: branch s_1152_4 b5086 b1153
        if s_1152_4 {
            return block_5086(state, tracer, fn_state);
        } else {
            return block_1153(state, tracer, fn_state);
        };
    }
    fn block_1153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1153_0: const #0u : u8
        let s_1153_0: bool = false;
        // D s_1153_1: write-var gs#134992 <= s_1153_0
        fn_state.gs_134992 = s_1153_0;
        // N s_1153_2: jump b1154
        return block_1154(state, tracer, fn_state);
    }
    fn block_1154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1154_0: read-var gs#134992:u8
        let s_1154_0: bool = fn_state.gs_134992;
        // N s_1154_1: branch s_1154_0 b5085 b1155
        if s_1154_0 {
            return block_5085(state, tracer, fn_state);
        } else {
            return block_1155(state, tracer, fn_state);
        };
    }
    fn block_1155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1155_0: const #0u : u8
        let s_1155_0: bool = false;
        // D s_1155_1: write-var gs#134993 <= s_1155_0
        fn_state.gs_134993 = s_1155_0;
        // N s_1155_2: jump b1156
        return block_1156(state, tracer, fn_state);
    }
    fn block_1156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1156_0: read-var gs#134993:u8
        let s_1156_0: bool = fn_state.gs_134993;
        // N s_1156_1: branch s_1156_0 b5084 b1157
        if s_1156_0 {
            return block_5084(state, tracer, fn_state);
        } else {
            return block_1157(state, tracer, fn_state);
        };
    }
    fn block_1157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1157_0: const #0u : u8
        let s_1157_0: bool = false;
        // D s_1157_1: write-var gs#134994 <= s_1157_0
        fn_state.gs_134994 = s_1157_0;
        // N s_1157_2: jump b1158
        return block_1158(state, tracer, fn_state);
    }
    fn block_1158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1158_0: read-var gs#134994:u8
        let s_1158_0: bool = fn_state.gs_134994;
        // N s_1158_1: branch s_1158_0 b5083 b1159
        if s_1158_0 {
            return block_5083(state, tracer, fn_state);
        } else {
            return block_1159(state, tracer, fn_state);
        };
    }
    fn block_1159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1159_0: const #0u : u8
        let s_1159_0: bool = false;
        // D s_1159_1: write-var gs#134995 <= s_1159_0
        fn_state.gs_134995 = s_1159_0;
        // N s_1159_2: jump b1160
        return block_1160(state, tracer, fn_state);
    }
    fn block_1160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1160_0: read-var gs#134995:u8
        let s_1160_0: bool = fn_state.gs_134995;
        // N s_1160_1: branch s_1160_0 b5082 b1161
        if s_1160_0 {
            return block_5082(state, tracer, fn_state);
        } else {
            return block_1161(state, tracer, fn_state);
        };
    }
    fn block_1161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1161_0: read-var CRm:u8
        let s_1161_0: u8 = fn_state.CRm;
        // D s_1161_1: cast zx s_1161_0 -> bv
        let s_1161_1: Bits = Bits::new(s_1161_0 as u128, 4u16);
        // C s_1161_2: const #9u : u8
        let s_1161_2: u8 = 9;
        // C s_1161_3: cast zx s_1161_2 -> bv
        let s_1161_3: Bits = Bits::new(s_1161_2 as u128, 4u16);
        // D s_1161_4: cmp-eq s_1161_1 s_1161_3
        let s_1161_4: bool = ((s_1161_1) == (s_1161_3));
        // N s_1161_5: branch s_1161_4 b5081 b1162
        if s_1161_4 {
            return block_5081(state, tracer, fn_state);
        } else {
            return block_1162(state, tracer, fn_state);
        };
    }
    fn block_1162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1162_0: const #0u : u8
        let s_1162_0: bool = false;
        // D s_1162_1: write-var gs#134996 <= s_1162_0
        fn_state.gs_134996 = s_1162_0;
        // N s_1162_2: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_1163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1163_0: read-var gs#134996:u8
        let s_1163_0: bool = fn_state.gs_134996;
        // N s_1163_1: branch s_1163_0 b5080 b1164
        if s_1163_0 {
            return block_5080(state, tracer, fn_state);
        } else {
            return block_1164(state, tracer, fn_state);
        };
    }
    fn block_1164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1164_0: const #0u : u8
        let s_1164_0: bool = false;
        // D s_1164_1: write-var gs#134997 <= s_1164_0
        fn_state.gs_134997 = s_1164_0;
        // N s_1164_2: jump b1165
        return block_1165(state, tracer, fn_state);
    }
    fn block_1165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1165_0: read-var gs#134997:u8
        let s_1165_0: bool = fn_state.gs_134997;
        // N s_1165_1: branch s_1165_0 b5079 b1166
        if s_1165_0 {
            return block_5079(state, tracer, fn_state);
        } else {
            return block_1166(state, tracer, fn_state);
        };
    }
    fn block_1166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1166_0: const #0u : u8
        let s_1166_0: bool = false;
        // D s_1166_1: write-var gs#134998 <= s_1166_0
        fn_state.gs_134998 = s_1166_0;
        // N s_1166_2: jump b1167
        return block_1167(state, tracer, fn_state);
    }
    fn block_1167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1167_0: read-var gs#134998:u8
        let s_1167_0: bool = fn_state.gs_134998;
        // N s_1167_1: branch s_1167_0 b5078 b1168
        if s_1167_0 {
            return block_5078(state, tracer, fn_state);
        } else {
            return block_1168(state, tracer, fn_state);
        };
    }
    fn block_1168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1168_0: const #0u : u8
        let s_1168_0: bool = false;
        // D s_1168_1: write-var gs#134999 <= s_1168_0
        fn_state.gs_134999 = s_1168_0;
        // N s_1168_2: jump b1169
        return block_1169(state, tracer, fn_state);
    }
    fn block_1169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1169_0: read-var gs#134999:u8
        let s_1169_0: bool = fn_state.gs_134999;
        // N s_1169_1: branch s_1169_0 b5077 b1170
        if s_1169_0 {
            return block_5077(state, tracer, fn_state);
        } else {
            return block_1170(state, tracer, fn_state);
        };
    }
    fn block_1170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1170_0: read-var CRm:u8
        let s_1170_0: u8 = fn_state.CRm;
        // D s_1170_1: cast zx s_1170_0 -> bv
        let s_1170_1: Bits = Bits::new(s_1170_0 as u128, 4u16);
        // C s_1170_2: const #1u : u8
        let s_1170_2: u8 = 1;
        // C s_1170_3: cast zx s_1170_2 -> bv
        let s_1170_3: Bits = Bits::new(s_1170_2 as u128, 4u16);
        // D s_1170_4: cmp-eq s_1170_1 s_1170_3
        let s_1170_4: bool = ((s_1170_1) == (s_1170_3));
        // N s_1170_5: branch s_1170_4 b5076 b1171
        if s_1170_4 {
            return block_5076(state, tracer, fn_state);
        } else {
            return block_1171(state, tracer, fn_state);
        };
    }
    fn block_1171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1171_0: const #0u : u8
        let s_1171_0: bool = false;
        // D s_1171_1: write-var gs#135000 <= s_1171_0
        fn_state.gs_135000 = s_1171_0;
        // N s_1171_2: jump b1172
        return block_1172(state, tracer, fn_state);
    }
    fn block_1172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1172_0: read-var gs#135000:u8
        let s_1172_0: bool = fn_state.gs_135000;
        // N s_1172_1: branch s_1172_0 b5075 b1173
        if s_1172_0 {
            return block_5075(state, tracer, fn_state);
        } else {
            return block_1173(state, tracer, fn_state);
        };
    }
    fn block_1173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1173_0: const #0u : u8
        let s_1173_0: bool = false;
        // D s_1173_1: write-var gs#135001 <= s_1173_0
        fn_state.gs_135001 = s_1173_0;
        // N s_1173_2: jump b1174
        return block_1174(state, tracer, fn_state);
    }
    fn block_1174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1174_0: read-var gs#135001:u8
        let s_1174_0: bool = fn_state.gs_135001;
        // N s_1174_1: branch s_1174_0 b5074 b1175
        if s_1174_0 {
            return block_5074(state, tracer, fn_state);
        } else {
            return block_1175(state, tracer, fn_state);
        };
    }
    fn block_1175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1175_0: const #0u : u8
        let s_1175_0: bool = false;
        // D s_1175_1: write-var gs#135002 <= s_1175_0
        fn_state.gs_135002 = s_1175_0;
        // N s_1175_2: jump b1176
        return block_1176(state, tracer, fn_state);
    }
    fn block_1176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1176_0: read-var gs#135002:u8
        let s_1176_0: bool = fn_state.gs_135002;
        // N s_1176_1: branch s_1176_0 b5073 b1177
        if s_1176_0 {
            return block_5073(state, tracer, fn_state);
        } else {
            return block_1177(state, tracer, fn_state);
        };
    }
    fn block_1177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1177_0: const #0u : u8
        let s_1177_0: bool = false;
        // D s_1177_1: write-var gs#135003 <= s_1177_0
        fn_state.gs_135003 = s_1177_0;
        // N s_1177_2: jump b1178
        return block_1178(state, tracer, fn_state);
    }
    fn block_1178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1178_0: read-var gs#135003:u8
        let s_1178_0: bool = fn_state.gs_135003;
        // N s_1178_1: branch s_1178_0 b5072 b1179
        if s_1178_0 {
            return block_5072(state, tracer, fn_state);
        } else {
            return block_1179(state, tracer, fn_state);
        };
    }
    fn block_1179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1179_0: read-var CRm:u8
        let s_1179_0: u8 = fn_state.CRm;
        // D s_1179_1: cast zx s_1179_0 -> bv
        let s_1179_1: Bits = Bits::new(s_1179_0 as u128, 4u16);
        // C s_1179_2: const #8u : u8
        let s_1179_2: u8 = 8;
        // C s_1179_3: cast zx s_1179_2 -> bv
        let s_1179_3: Bits = Bits::new(s_1179_2 as u128, 4u16);
        // D s_1179_4: cmp-eq s_1179_1 s_1179_3
        let s_1179_4: bool = ((s_1179_1) == (s_1179_3));
        // N s_1179_5: branch s_1179_4 b5071 b1180
        if s_1179_4 {
            return block_5071(state, tracer, fn_state);
        } else {
            return block_1180(state, tracer, fn_state);
        };
    }
    fn block_1180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1180_0: const #0u : u8
        let s_1180_0: bool = false;
        // D s_1180_1: write-var gs#135004 <= s_1180_0
        fn_state.gs_135004 = s_1180_0;
        // N s_1180_2: jump b1181
        return block_1181(state, tracer, fn_state);
    }
    fn block_1181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1181_0: read-var gs#135004:u8
        let s_1181_0: bool = fn_state.gs_135004;
        // N s_1181_1: branch s_1181_0 b5070 b1182
        if s_1181_0 {
            return block_5070(state, tracer, fn_state);
        } else {
            return block_1182(state, tracer, fn_state);
        };
    }
    fn block_1182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1182_0: const #0u : u8
        let s_1182_0: bool = false;
        // D s_1182_1: write-var gs#135005 <= s_1182_0
        fn_state.gs_135005 = s_1182_0;
        // N s_1182_2: jump b1183
        return block_1183(state, tracer, fn_state);
    }
    fn block_1183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1183_0: read-var gs#135005:u8
        let s_1183_0: bool = fn_state.gs_135005;
        // N s_1183_1: branch s_1183_0 b5069 b1184
        if s_1183_0 {
            return block_5069(state, tracer, fn_state);
        } else {
            return block_1184(state, tracer, fn_state);
        };
    }
    fn block_1184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1184_0: const #0u : u8
        let s_1184_0: bool = false;
        // D s_1184_1: write-var gs#135006 <= s_1184_0
        fn_state.gs_135006 = s_1184_0;
        // N s_1184_2: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_1185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1185_0: read-var gs#135006:u8
        let s_1185_0: bool = fn_state.gs_135006;
        // N s_1185_1: branch s_1185_0 b5068 b1186
        if s_1185_0 {
            return block_5068(state, tracer, fn_state);
        } else {
            return block_1186(state, tracer, fn_state);
        };
    }
    fn block_1186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1186_0: const #0u : u8
        let s_1186_0: bool = false;
        // D s_1186_1: write-var gs#135007 <= s_1186_0
        fn_state.gs_135007 = s_1186_0;
        // N s_1186_2: jump b1187
        return block_1187(state, tracer, fn_state);
    }
    fn block_1187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1187_0: read-var gs#135007:u8
        let s_1187_0: bool = fn_state.gs_135007;
        // N s_1187_1: branch s_1187_0 b5067 b1188
        if s_1187_0 {
            return block_5067(state, tracer, fn_state);
        } else {
            return block_1188(state, tracer, fn_state);
        };
    }
    fn block_1188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1188_0: read-var CRm:u8
        let s_1188_0: u8 = fn_state.CRm;
        // D s_1188_1: cast zx s_1188_0 -> bv
        let s_1188_1: Bits = Bits::new(s_1188_0 as u128, 4u16);
        // C s_1188_2: const #1u : u8
        let s_1188_2: u8 = 1;
        // C s_1188_3: cast zx s_1188_2 -> bv
        let s_1188_3: Bits = Bits::new(s_1188_2 as u128, 4u16);
        // D s_1188_4: cmp-eq s_1188_1 s_1188_3
        let s_1188_4: bool = ((s_1188_1) == (s_1188_3));
        // N s_1188_5: branch s_1188_4 b5066 b1189
        if s_1188_4 {
            return block_5066(state, tracer, fn_state);
        } else {
            return block_1189(state, tracer, fn_state);
        };
    }
    fn block_1189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1189_0: const #0u : u8
        let s_1189_0: bool = false;
        // D s_1189_1: write-var gs#135008 <= s_1189_0
        fn_state.gs_135008 = s_1189_0;
        // N s_1189_2: jump b1190
        return block_1190(state, tracer, fn_state);
    }
    fn block_1190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1190_0: read-var gs#135008:u8
        let s_1190_0: bool = fn_state.gs_135008;
        // N s_1190_1: branch s_1190_0 b5065 b1191
        if s_1190_0 {
            return block_5065(state, tracer, fn_state);
        } else {
            return block_1191(state, tracer, fn_state);
        };
    }
    fn block_1191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1191_0: const #0u : u8
        let s_1191_0: bool = false;
        // D s_1191_1: write-var gs#135009 <= s_1191_0
        fn_state.gs_135009 = s_1191_0;
        // N s_1191_2: jump b1192
        return block_1192(state, tracer, fn_state);
    }
    fn block_1192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1192_0: read-var gs#135009:u8
        let s_1192_0: bool = fn_state.gs_135009;
        // N s_1192_1: branch s_1192_0 b5064 b1193
        if s_1192_0 {
            return block_5064(state, tracer, fn_state);
        } else {
            return block_1193(state, tracer, fn_state);
        };
    }
    fn block_1193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1193_0: const #0u : u8
        let s_1193_0: bool = false;
        // D s_1193_1: write-var gs#135010 <= s_1193_0
        fn_state.gs_135010 = s_1193_0;
        // N s_1193_2: jump b1194
        return block_1194(state, tracer, fn_state);
    }
    fn block_1194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1194_0: read-var gs#135010:u8
        let s_1194_0: bool = fn_state.gs_135010;
        // N s_1194_1: branch s_1194_0 b5063 b1195
        if s_1194_0 {
            return block_5063(state, tracer, fn_state);
        } else {
            return block_1195(state, tracer, fn_state);
        };
    }
    fn block_1195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1195_0: const #0u : u8
        let s_1195_0: bool = false;
        // D s_1195_1: write-var gs#135011 <= s_1195_0
        fn_state.gs_135011 = s_1195_0;
        // N s_1195_2: jump b1196
        return block_1196(state, tracer, fn_state);
    }
    fn block_1196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1196_0: read-var gs#135011:u8
        let s_1196_0: bool = fn_state.gs_135011;
        // N s_1196_1: branch s_1196_0 b5062 b1197
        if s_1196_0 {
            return block_5062(state, tracer, fn_state);
        } else {
            return block_1197(state, tracer, fn_state);
        };
    }
    fn block_1197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1197_0: read-var CRm:u8
        let s_1197_0: u8 = fn_state.CRm;
        // D s_1197_1: cast zx s_1197_0 -> bv
        let s_1197_1: Bits = Bits::new(s_1197_0 as u128, 4u16);
        // C s_1197_2: const #7u : u8
        let s_1197_2: u8 = 7;
        // C s_1197_3: cast zx s_1197_2 -> bv
        let s_1197_3: Bits = Bits::new(s_1197_2 as u128, 4u16);
        // D s_1197_4: cmp-eq s_1197_1 s_1197_3
        let s_1197_4: bool = ((s_1197_1) == (s_1197_3));
        // N s_1197_5: branch s_1197_4 b5061 b1198
        if s_1197_4 {
            return block_5061(state, tracer, fn_state);
        } else {
            return block_1198(state, tracer, fn_state);
        };
    }
    fn block_1198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1198_0: const #0u : u8
        let s_1198_0: bool = false;
        // D s_1198_1: write-var gs#135012 <= s_1198_0
        fn_state.gs_135012 = s_1198_0;
        // N s_1198_2: jump b1199
        return block_1199(state, tracer, fn_state);
    }
    fn block_1199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1199_0: read-var gs#135012:u8
        let s_1199_0: bool = fn_state.gs_135012;
        // N s_1199_1: branch s_1199_0 b5060 b1200
        if s_1199_0 {
            return block_5060(state, tracer, fn_state);
        } else {
            return block_1200(state, tracer, fn_state);
        };
    }
    fn block_1200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1200_0: const #0u : u8
        let s_1200_0: bool = false;
        // D s_1200_1: write-var gs#135013 <= s_1200_0
        fn_state.gs_135013 = s_1200_0;
        // N s_1200_2: jump b1201
        return block_1201(state, tracer, fn_state);
    }
    fn block_1201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1201_0: read-var gs#135013:u8
        let s_1201_0: bool = fn_state.gs_135013;
        // N s_1201_1: branch s_1201_0 b5059 b1202
        if s_1201_0 {
            return block_5059(state, tracer, fn_state);
        } else {
            return block_1202(state, tracer, fn_state);
        };
    }
    fn block_1202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1202_0: const #0u : u8
        let s_1202_0: bool = false;
        // D s_1202_1: write-var gs#135014 <= s_1202_0
        fn_state.gs_135014 = s_1202_0;
        // N s_1202_2: jump b1203
        return block_1203(state, tracer, fn_state);
    }
    fn block_1203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1203_0: read-var gs#135014:u8
        let s_1203_0: bool = fn_state.gs_135014;
        // N s_1203_1: branch s_1203_0 b5058 b1204
        if s_1203_0 {
            return block_5058(state, tracer, fn_state);
        } else {
            return block_1204(state, tracer, fn_state);
        };
    }
    fn block_1204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1204_0: const #0u : u8
        let s_1204_0: bool = false;
        // D s_1204_1: write-var gs#135015 <= s_1204_0
        fn_state.gs_135015 = s_1204_0;
        // N s_1204_2: jump b1205
        return block_1205(state, tracer, fn_state);
    }
    fn block_1205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1205_0: read-var gs#135015:u8
        let s_1205_0: bool = fn_state.gs_135015;
        // N s_1205_1: branch s_1205_0 b5057 b1206
        if s_1205_0 {
            return block_5057(state, tracer, fn_state);
        } else {
            return block_1206(state, tracer, fn_state);
        };
    }
    fn block_1206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1206_0: read-var CRm:u8
        let s_1206_0: u8 = fn_state.CRm;
        // D s_1206_1: cast zx s_1206_0 -> bv
        let s_1206_1: Bits = Bits::new(s_1206_0 as u128, 4u16);
        // C s_1206_2: const #3u : u8
        let s_1206_2: u8 = 3;
        // C s_1206_3: cast zx s_1206_2 -> bv
        let s_1206_3: Bits = Bits::new(s_1206_2 as u128, 4u16);
        // D s_1206_4: cmp-eq s_1206_1 s_1206_3
        let s_1206_4: bool = ((s_1206_1) == (s_1206_3));
        // N s_1206_5: branch s_1206_4 b5056 b1207
        if s_1206_4 {
            return block_5056(state, tracer, fn_state);
        } else {
            return block_1207(state, tracer, fn_state);
        };
    }
    fn block_1207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1207_0: const #0u : u8
        let s_1207_0: bool = false;
        // D s_1207_1: write-var gs#135016 <= s_1207_0
        fn_state.gs_135016 = s_1207_0;
        // N s_1207_2: jump b1208
        return block_1208(state, tracer, fn_state);
    }
    fn block_1208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1208_0: read-var gs#135016:u8
        let s_1208_0: bool = fn_state.gs_135016;
        // N s_1208_1: branch s_1208_0 b5055 b1209
        if s_1208_0 {
            return block_5055(state, tracer, fn_state);
        } else {
            return block_1209(state, tracer, fn_state);
        };
    }
    fn block_1209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1209_0: const #0u : u8
        let s_1209_0: bool = false;
        // D s_1209_1: write-var gs#135017 <= s_1209_0
        fn_state.gs_135017 = s_1209_0;
        // N s_1209_2: jump b1210
        return block_1210(state, tracer, fn_state);
    }
    fn block_1210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1210_0: read-var gs#135017:u8
        let s_1210_0: bool = fn_state.gs_135017;
        // N s_1210_1: branch s_1210_0 b5054 b1211
        if s_1210_0 {
            return block_5054(state, tracer, fn_state);
        } else {
            return block_1211(state, tracer, fn_state);
        };
    }
    fn block_1211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1211_0: const #0u : u8
        let s_1211_0: bool = false;
        // D s_1211_1: write-var gs#135018 <= s_1211_0
        fn_state.gs_135018 = s_1211_0;
        // N s_1211_2: jump b1212
        return block_1212(state, tracer, fn_state);
    }
    fn block_1212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1212_0: read-var gs#135018:u8
        let s_1212_0: bool = fn_state.gs_135018;
        // N s_1212_1: branch s_1212_0 b5053 b1213
        if s_1212_0 {
            return block_5053(state, tracer, fn_state);
        } else {
            return block_1213(state, tracer, fn_state);
        };
    }
    fn block_1213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1213_0: const #0u : u8
        let s_1213_0: bool = false;
        // D s_1213_1: write-var gs#135019 <= s_1213_0
        fn_state.gs_135019 = s_1213_0;
        // N s_1213_2: jump b1214
        return block_1214(state, tracer, fn_state);
    }
    fn block_1214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1214_0: read-var gs#135019:u8
        let s_1214_0: bool = fn_state.gs_135019;
        // N s_1214_1: branch s_1214_0 b5052 b1215
        if s_1214_0 {
            return block_5052(state, tracer, fn_state);
        } else {
            return block_1215(state, tracer, fn_state);
        };
    }
    fn block_1215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1215_0: read-var CRm:u8
        let s_1215_0: u8 = fn_state.CRm;
        // D s_1215_1: cast zx s_1215_0 -> bv
        let s_1215_1: Bits = Bits::new(s_1215_0 as u128, 4u16);
        // C s_1215_2: const #8u : u8
        let s_1215_2: u8 = 8;
        // C s_1215_3: cast zx s_1215_2 -> bv
        let s_1215_3: Bits = Bits::new(s_1215_2 as u128, 4u16);
        // D s_1215_4: cmp-eq s_1215_1 s_1215_3
        let s_1215_4: bool = ((s_1215_1) == (s_1215_3));
        // N s_1215_5: branch s_1215_4 b5051 b1216
        if s_1215_4 {
            return block_5051(state, tracer, fn_state);
        } else {
            return block_1216(state, tracer, fn_state);
        };
    }
    fn block_1216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1216_0: const #0u : u8
        let s_1216_0: bool = false;
        // D s_1216_1: write-var gs#135020 <= s_1216_0
        fn_state.gs_135020 = s_1216_0;
        // N s_1216_2: jump b1217
        return block_1217(state, tracer, fn_state);
    }
    fn block_1217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1217_0: read-var gs#135020:u8
        let s_1217_0: bool = fn_state.gs_135020;
        // N s_1217_1: branch s_1217_0 b5050 b1218
        if s_1217_0 {
            return block_5050(state, tracer, fn_state);
        } else {
            return block_1218(state, tracer, fn_state);
        };
    }
    fn block_1218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1218_0: const #0u : u8
        let s_1218_0: bool = false;
        // D s_1218_1: write-var gs#135021 <= s_1218_0
        fn_state.gs_135021 = s_1218_0;
        // N s_1218_2: jump b1219
        return block_1219(state, tracer, fn_state);
    }
    fn block_1219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1219_0: read-var gs#135021:u8
        let s_1219_0: bool = fn_state.gs_135021;
        // N s_1219_1: branch s_1219_0 b5049 b1220
        if s_1219_0 {
            return block_5049(state, tracer, fn_state);
        } else {
            return block_1220(state, tracer, fn_state);
        };
    }
    fn block_1220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1220_0: const #0u : u8
        let s_1220_0: bool = false;
        // D s_1220_1: write-var gs#135022 <= s_1220_0
        fn_state.gs_135022 = s_1220_0;
        // N s_1220_2: jump b1221
        return block_1221(state, tracer, fn_state);
    }
    fn block_1221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1221_0: read-var gs#135022:u8
        let s_1221_0: bool = fn_state.gs_135022;
        // N s_1221_1: branch s_1221_0 b5048 b1222
        if s_1221_0 {
            return block_5048(state, tracer, fn_state);
        } else {
            return block_1222(state, tracer, fn_state);
        };
    }
    fn block_1222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1222_0: const #0u : u8
        let s_1222_0: bool = false;
        // D s_1222_1: write-var gs#135023 <= s_1222_0
        fn_state.gs_135023 = s_1222_0;
        // N s_1222_2: jump b1223
        return block_1223(state, tracer, fn_state);
    }
    fn block_1223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1223_0: read-var gs#135023:u8
        let s_1223_0: bool = fn_state.gs_135023;
        // N s_1223_1: branch s_1223_0 b5047 b1224
        if s_1223_0 {
            return block_5047(state, tracer, fn_state);
        } else {
            return block_1224(state, tracer, fn_state);
        };
    }
    fn block_1224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1224_0: read-var CRm:u8
        let s_1224_0: u8 = fn_state.CRm;
        // D s_1224_1: cast zx s_1224_0 -> bv
        let s_1224_1: Bits = Bits::new(s_1224_0 as u128, 4u16);
        // C s_1224_2: const #3u : u8
        let s_1224_2: u8 = 3;
        // C s_1224_3: cast zx s_1224_2 -> bv
        let s_1224_3: Bits = Bits::new(s_1224_2 as u128, 4u16);
        // D s_1224_4: cmp-eq s_1224_1 s_1224_3
        let s_1224_4: bool = ((s_1224_1) == (s_1224_3));
        // N s_1224_5: branch s_1224_4 b5046 b1225
        if s_1224_4 {
            return block_5046(state, tracer, fn_state);
        } else {
            return block_1225(state, tracer, fn_state);
        };
    }
    fn block_1225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1225_0: const #0u : u8
        let s_1225_0: bool = false;
        // D s_1225_1: write-var gs#135024 <= s_1225_0
        fn_state.gs_135024 = s_1225_0;
        // N s_1225_2: jump b1226
        return block_1226(state, tracer, fn_state);
    }
    fn block_1226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1226_0: read-var gs#135024:u8
        let s_1226_0: bool = fn_state.gs_135024;
        // N s_1226_1: branch s_1226_0 b5045 b1227
        if s_1226_0 {
            return block_5045(state, tracer, fn_state);
        } else {
            return block_1227(state, tracer, fn_state);
        };
    }
    fn block_1227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1227_0: const #0u : u8
        let s_1227_0: bool = false;
        // D s_1227_1: write-var gs#135025 <= s_1227_0
        fn_state.gs_135025 = s_1227_0;
        // N s_1227_2: jump b1228
        return block_1228(state, tracer, fn_state);
    }
    fn block_1228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1228_0: read-var gs#135025:u8
        let s_1228_0: bool = fn_state.gs_135025;
        // N s_1228_1: branch s_1228_0 b5044 b1229
        if s_1228_0 {
            return block_5044(state, tracer, fn_state);
        } else {
            return block_1229(state, tracer, fn_state);
        };
    }
    fn block_1229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1229_0: const #0u : u8
        let s_1229_0: bool = false;
        // D s_1229_1: write-var gs#135026 <= s_1229_0
        fn_state.gs_135026 = s_1229_0;
        // N s_1229_2: jump b1230
        return block_1230(state, tracer, fn_state);
    }
    fn block_1230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1230_0: read-var gs#135026:u8
        let s_1230_0: bool = fn_state.gs_135026;
        // N s_1230_1: branch s_1230_0 b5043 b1231
        if s_1230_0 {
            return block_5043(state, tracer, fn_state);
        } else {
            return block_1231(state, tracer, fn_state);
        };
    }
    fn block_1231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1231_0: const #0u : u8
        let s_1231_0: bool = false;
        // D s_1231_1: write-var gs#135027 <= s_1231_0
        fn_state.gs_135027 = s_1231_0;
        // N s_1231_2: jump b1232
        return block_1232(state, tracer, fn_state);
    }
    fn block_1232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1232_0: read-var gs#135027:u8
        let s_1232_0: bool = fn_state.gs_135027;
        // N s_1232_1: branch s_1232_0 b5042 b1233
        if s_1232_0 {
            return block_5042(state, tracer, fn_state);
        } else {
            return block_1233(state, tracer, fn_state);
        };
    }
    fn block_1233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1233_0: read-var CRm:u8
        let s_1233_0: u8 = fn_state.CRm;
        // D s_1233_1: cast zx s_1233_0 -> bv
        let s_1233_1: Bits = Bits::new(s_1233_0 as u128, 4u16);
        // C s_1233_2: const #0u : u8
        let s_1233_2: u8 = 0;
        // C s_1233_3: cast zx s_1233_2 -> bv
        let s_1233_3: Bits = Bits::new(s_1233_2 as u128, 4u16);
        // D s_1233_4: cmp-eq s_1233_1 s_1233_3
        let s_1233_4: bool = ((s_1233_1) == (s_1233_3));
        // N s_1233_5: branch s_1233_4 b5041 b1234
        if s_1233_4 {
            return block_5041(state, tracer, fn_state);
        } else {
            return block_1234(state, tracer, fn_state);
        };
    }
    fn block_1234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1234_0: const #0u : u8
        let s_1234_0: bool = false;
        // D s_1234_1: write-var gs#135028 <= s_1234_0
        fn_state.gs_135028 = s_1234_0;
        // N s_1234_2: jump b1235
        return block_1235(state, tracer, fn_state);
    }
    fn block_1235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1235_0: read-var gs#135028:u8
        let s_1235_0: bool = fn_state.gs_135028;
        // N s_1235_1: branch s_1235_0 b5040 b1236
        if s_1235_0 {
            return block_5040(state, tracer, fn_state);
        } else {
            return block_1236(state, tracer, fn_state);
        };
    }
    fn block_1236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1236_0: const #0u : u8
        let s_1236_0: bool = false;
        // D s_1236_1: write-var gs#135029 <= s_1236_0
        fn_state.gs_135029 = s_1236_0;
        // N s_1236_2: jump b1237
        return block_1237(state, tracer, fn_state);
    }
    fn block_1237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1237_0: read-var gs#135029:u8
        let s_1237_0: bool = fn_state.gs_135029;
        // N s_1237_1: branch s_1237_0 b5039 b1238
        if s_1237_0 {
            return block_5039(state, tracer, fn_state);
        } else {
            return block_1238(state, tracer, fn_state);
        };
    }
    fn block_1238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1238_0: const #0u : u8
        let s_1238_0: bool = false;
        // D s_1238_1: write-var gs#135030 <= s_1238_0
        fn_state.gs_135030 = s_1238_0;
        // N s_1238_2: jump b1239
        return block_1239(state, tracer, fn_state);
    }
    fn block_1239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1239_0: read-var gs#135030:u8
        let s_1239_0: bool = fn_state.gs_135030;
        // N s_1239_1: branch s_1239_0 b5038 b1240
        if s_1239_0 {
            return block_5038(state, tracer, fn_state);
        } else {
            return block_1240(state, tracer, fn_state);
        };
    }
    fn block_1240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1240_0: const #0u : u8
        let s_1240_0: bool = false;
        // D s_1240_1: write-var gs#135031 <= s_1240_0
        fn_state.gs_135031 = s_1240_0;
        // N s_1240_2: jump b1241
        return block_1241(state, tracer, fn_state);
    }
    fn block_1241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1241_0: read-var gs#135031:u8
        let s_1241_0: bool = fn_state.gs_135031;
        // N s_1241_1: branch s_1241_0 b5037 b1242
        if s_1241_0 {
            return block_5037(state, tracer, fn_state);
        } else {
            return block_1242(state, tracer, fn_state);
        };
    }
    fn block_1242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1242_0: read-var CRm:u8
        let s_1242_0: u8 = fn_state.CRm;
        // D s_1242_1: cast zx s_1242_0 -> bv
        let s_1242_1: Bits = Bits::new(s_1242_0 as u128, 4u16);
        // C s_1242_2: const #12u : u8
        let s_1242_2: u8 = 12;
        // C s_1242_3: cast zx s_1242_2 -> bv
        let s_1242_3: Bits = Bits::new(s_1242_2 as u128, 4u16);
        // D s_1242_4: cmp-eq s_1242_1 s_1242_3
        let s_1242_4: bool = ((s_1242_1) == (s_1242_3));
        // N s_1242_5: branch s_1242_4 b5036 b1243
        if s_1242_4 {
            return block_5036(state, tracer, fn_state);
        } else {
            return block_1243(state, tracer, fn_state);
        };
    }
    fn block_1243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1243_0: const #0u : u8
        let s_1243_0: bool = false;
        // D s_1243_1: write-var gs#135032 <= s_1243_0
        fn_state.gs_135032 = s_1243_0;
        // N s_1243_2: jump b1244
        return block_1244(state, tracer, fn_state);
    }
    fn block_1244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1244_0: read-var gs#135032:u8
        let s_1244_0: bool = fn_state.gs_135032;
        // N s_1244_1: branch s_1244_0 b5035 b1245
        if s_1244_0 {
            return block_5035(state, tracer, fn_state);
        } else {
            return block_1245(state, tracer, fn_state);
        };
    }
    fn block_1245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1245_0: const #0u : u8
        let s_1245_0: bool = false;
        // D s_1245_1: write-var gs#135033 <= s_1245_0
        fn_state.gs_135033 = s_1245_0;
        // N s_1245_2: jump b1246
        return block_1246(state, tracer, fn_state);
    }
    fn block_1246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1246_0: read-var gs#135033:u8
        let s_1246_0: bool = fn_state.gs_135033;
        // N s_1246_1: branch s_1246_0 b5034 b1247
        if s_1246_0 {
            return block_5034(state, tracer, fn_state);
        } else {
            return block_1247(state, tracer, fn_state);
        };
    }
    fn block_1247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1247_0: const #0u : u8
        let s_1247_0: bool = false;
        // D s_1247_1: write-var gs#135034 <= s_1247_0
        fn_state.gs_135034 = s_1247_0;
        // N s_1247_2: jump b1248
        return block_1248(state, tracer, fn_state);
    }
    fn block_1248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1248_0: read-var gs#135034:u8
        let s_1248_0: bool = fn_state.gs_135034;
        // N s_1248_1: branch s_1248_0 b5033 b1249
        if s_1248_0 {
            return block_5033(state, tracer, fn_state);
        } else {
            return block_1249(state, tracer, fn_state);
        };
    }
    fn block_1249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1249_0: const #0u : u8
        let s_1249_0: bool = false;
        // D s_1249_1: write-var gs#135035 <= s_1249_0
        fn_state.gs_135035 = s_1249_0;
        // N s_1249_2: jump b1250
        return block_1250(state, tracer, fn_state);
    }
    fn block_1250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1250_0: read-var gs#135035:u8
        let s_1250_0: bool = fn_state.gs_135035;
        // N s_1250_1: branch s_1250_0 b5032 b1251
        if s_1250_0 {
            return block_5032(state, tracer, fn_state);
        } else {
            return block_1251(state, tracer, fn_state);
        };
    }
    fn block_1251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1251_0: read-var CRm:u8
        let s_1251_0: u8 = fn_state.CRm;
        // D s_1251_1: cast zx s_1251_0 -> bv
        let s_1251_1: Bits = Bits::new(s_1251_0 as u128, 4u16);
        // C s_1251_2: const #14u : u8
        let s_1251_2: u8 = 14;
        // C s_1251_3: cast zx s_1251_2 -> bv
        let s_1251_3: Bits = Bits::new(s_1251_2 as u128, 4u16);
        // D s_1251_4: cmp-eq s_1251_1 s_1251_3
        let s_1251_4: bool = ((s_1251_1) == (s_1251_3));
        // N s_1251_5: branch s_1251_4 b5031 b1252
        if s_1251_4 {
            return block_5031(state, tracer, fn_state);
        } else {
            return block_1252(state, tracer, fn_state);
        };
    }
    fn block_1252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1252_0: const #0u : u8
        let s_1252_0: bool = false;
        // D s_1252_1: write-var gs#135036 <= s_1252_0
        fn_state.gs_135036 = s_1252_0;
        // N s_1252_2: jump b1253
        return block_1253(state, tracer, fn_state);
    }
    fn block_1253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1253_0: read-var gs#135036:u8
        let s_1253_0: bool = fn_state.gs_135036;
        // N s_1253_1: branch s_1253_0 b5030 b1254
        if s_1253_0 {
            return block_5030(state, tracer, fn_state);
        } else {
            return block_1254(state, tracer, fn_state);
        };
    }
    fn block_1254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1254_0: const #0u : u8
        let s_1254_0: bool = false;
        // D s_1254_1: write-var gs#135037 <= s_1254_0
        fn_state.gs_135037 = s_1254_0;
        // N s_1254_2: jump b1255
        return block_1255(state, tracer, fn_state);
    }
    fn block_1255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1255_0: read-var gs#135037:u8
        let s_1255_0: bool = fn_state.gs_135037;
        // N s_1255_1: branch s_1255_0 b5029 b1256
        if s_1255_0 {
            return block_5029(state, tracer, fn_state);
        } else {
            return block_1256(state, tracer, fn_state);
        };
    }
    fn block_1256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1256_0: const #0u : u8
        let s_1256_0: bool = false;
        // D s_1256_1: write-var gs#135038 <= s_1256_0
        fn_state.gs_135038 = s_1256_0;
        // N s_1256_2: jump b1257
        return block_1257(state, tracer, fn_state);
    }
    fn block_1257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1257_0: read-var gs#135038:u8
        let s_1257_0: bool = fn_state.gs_135038;
        // N s_1257_1: branch s_1257_0 b5028 b1258
        if s_1257_0 {
            return block_5028(state, tracer, fn_state);
        } else {
            return block_1258(state, tracer, fn_state);
        };
    }
    fn block_1258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1258_0: const #0u : u8
        let s_1258_0: bool = false;
        // D s_1258_1: write-var gs#135039 <= s_1258_0
        fn_state.gs_135039 = s_1258_0;
        // N s_1258_2: jump b1259
        return block_1259(state, tracer, fn_state);
    }
    fn block_1259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1259_0: read-var gs#135039:u8
        let s_1259_0: bool = fn_state.gs_135039;
        // N s_1259_1: branch s_1259_0 b5027 b1260
        if s_1259_0 {
            return block_5027(state, tracer, fn_state);
        } else {
            return block_1260(state, tracer, fn_state);
        };
    }
    fn block_1260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1260_0: read-var CRm:u8
        let s_1260_0: u8 = fn_state.CRm;
        // D s_1260_1: cast zx s_1260_0 -> bv
        let s_1260_1: Bits = Bits::new(s_1260_0 as u128, 4u16);
        // C s_1260_2: const #0u : u8
        let s_1260_2: u8 = 0;
        // C s_1260_3: cast zx s_1260_2 -> bv
        let s_1260_3: Bits = Bits::new(s_1260_2 as u128, 4u16);
        // D s_1260_4: cmp-eq s_1260_1 s_1260_3
        let s_1260_4: bool = ((s_1260_1) == (s_1260_3));
        // N s_1260_5: branch s_1260_4 b5026 b1261
        if s_1260_4 {
            return block_5026(state, tracer, fn_state);
        } else {
            return block_1261(state, tracer, fn_state);
        };
    }
    fn block_1261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1261_0: const #0u : u8
        let s_1261_0: bool = false;
        // D s_1261_1: write-var gs#135040 <= s_1261_0
        fn_state.gs_135040 = s_1261_0;
        // N s_1261_2: jump b1262
        return block_1262(state, tracer, fn_state);
    }
    fn block_1262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1262_0: read-var gs#135040:u8
        let s_1262_0: bool = fn_state.gs_135040;
        // N s_1262_1: branch s_1262_0 b5025 b1263
        if s_1262_0 {
            return block_5025(state, tracer, fn_state);
        } else {
            return block_1263(state, tracer, fn_state);
        };
    }
    fn block_1263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1263_0: const #0u : u8
        let s_1263_0: bool = false;
        // D s_1263_1: write-var gs#135041 <= s_1263_0
        fn_state.gs_135041 = s_1263_0;
        // N s_1263_2: jump b1264
        return block_1264(state, tracer, fn_state);
    }
    fn block_1264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1264_0: read-var gs#135041:u8
        let s_1264_0: bool = fn_state.gs_135041;
        // N s_1264_1: branch s_1264_0 b5024 b1265
        if s_1264_0 {
            return block_5024(state, tracer, fn_state);
        } else {
            return block_1265(state, tracer, fn_state);
        };
    }
    fn block_1265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1265_0: const #0u : u8
        let s_1265_0: bool = false;
        // D s_1265_1: write-var gs#135042 <= s_1265_0
        fn_state.gs_135042 = s_1265_0;
        // N s_1265_2: jump b1266
        return block_1266(state, tracer, fn_state);
    }
    fn block_1266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1266_0: read-var gs#135042:u8
        let s_1266_0: bool = fn_state.gs_135042;
        // N s_1266_1: branch s_1266_0 b5023 b1267
        if s_1266_0 {
            return block_5023(state, tracer, fn_state);
        } else {
            return block_1267(state, tracer, fn_state);
        };
    }
    fn block_1267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1267_0: const #0u : u8
        let s_1267_0: bool = false;
        // D s_1267_1: write-var gs#135043 <= s_1267_0
        fn_state.gs_135043 = s_1267_0;
        // N s_1267_2: jump b1268
        return block_1268(state, tracer, fn_state);
    }
    fn block_1268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1268_0: read-var gs#135043:u8
        let s_1268_0: bool = fn_state.gs_135043;
        // N s_1268_1: branch s_1268_0 b5022 b1269
        if s_1268_0 {
            return block_5022(state, tracer, fn_state);
        } else {
            return block_1269(state, tracer, fn_state);
        };
    }
    fn block_1269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1269_0: read-var CRm:u8
        let s_1269_0: u8 = fn_state.CRm;
        // D s_1269_1: cast zx s_1269_0 -> bv
        let s_1269_1: Bits = Bits::new(s_1269_0 as u128, 4u16);
        // C s_1269_2: const #0u : u8
        let s_1269_2: u8 = 0;
        // C s_1269_3: cast zx s_1269_2 -> bv
        let s_1269_3: Bits = Bits::new(s_1269_2 as u128, 4u16);
        // D s_1269_4: cmp-eq s_1269_1 s_1269_3
        let s_1269_4: bool = ((s_1269_1) == (s_1269_3));
        // N s_1269_5: branch s_1269_4 b5021 b1270
        if s_1269_4 {
            return block_5021(state, tracer, fn_state);
        } else {
            return block_1270(state, tracer, fn_state);
        };
    }
    fn block_1270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1270_0: const #0u : u8
        let s_1270_0: bool = false;
        // D s_1270_1: write-var gs#135044 <= s_1270_0
        fn_state.gs_135044 = s_1270_0;
        // N s_1270_2: jump b1271
        return block_1271(state, tracer, fn_state);
    }
    fn block_1271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1271_0: read-var gs#135044:u8
        let s_1271_0: bool = fn_state.gs_135044;
        // N s_1271_1: branch s_1271_0 b5020 b1272
        if s_1271_0 {
            return block_5020(state, tracer, fn_state);
        } else {
            return block_1272(state, tracer, fn_state);
        };
    }
    fn block_1272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1272_0: const #0u : u8
        let s_1272_0: bool = false;
        // D s_1272_1: write-var gs#135045 <= s_1272_0
        fn_state.gs_135045 = s_1272_0;
        // N s_1272_2: jump b1273
        return block_1273(state, tracer, fn_state);
    }
    fn block_1273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1273_0: read-var gs#135045:u8
        let s_1273_0: bool = fn_state.gs_135045;
        // N s_1273_1: branch s_1273_0 b5019 b1274
        if s_1273_0 {
            return block_5019(state, tracer, fn_state);
        } else {
            return block_1274(state, tracer, fn_state);
        };
    }
    fn block_1274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1274_0: const #0u : u8
        let s_1274_0: bool = false;
        // D s_1274_1: write-var gs#135046 <= s_1274_0
        fn_state.gs_135046 = s_1274_0;
        // N s_1274_2: jump b1275
        return block_1275(state, tracer, fn_state);
    }
    fn block_1275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1275_0: read-var gs#135046:u8
        let s_1275_0: bool = fn_state.gs_135046;
        // N s_1275_1: branch s_1275_0 b5018 b1276
        if s_1275_0 {
            return block_5018(state, tracer, fn_state);
        } else {
            return block_1276(state, tracer, fn_state);
        };
    }
    fn block_1276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1276_0: const #0u : u8
        let s_1276_0: bool = false;
        // D s_1276_1: write-var gs#135047 <= s_1276_0
        fn_state.gs_135047 = s_1276_0;
        // N s_1276_2: jump b1277
        return block_1277(state, tracer, fn_state);
    }
    fn block_1277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1277_0: read-var gs#135047:u8
        let s_1277_0: bool = fn_state.gs_135047;
        // N s_1277_1: branch s_1277_0 b5017 b1278
        if s_1277_0 {
            return block_5017(state, tracer, fn_state);
        } else {
            return block_1278(state, tracer, fn_state);
        };
    }
    fn block_1278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1278_0: read-var CRm:u8
        let s_1278_0: u8 = fn_state.CRm;
        // D s_1278_1: cast zx s_1278_0 -> bv
        let s_1278_1: Bits = Bits::new(s_1278_0 as u128, 4u16);
        // C s_1278_2: const #5u : u8
        let s_1278_2: u8 = 5;
        // C s_1278_3: cast zx s_1278_2 -> bv
        let s_1278_3: Bits = Bits::new(s_1278_2 as u128, 4u16);
        // D s_1278_4: cmp-eq s_1278_1 s_1278_3
        let s_1278_4: bool = ((s_1278_1) == (s_1278_3));
        // N s_1278_5: branch s_1278_4 b5016 b1279
        if s_1278_4 {
            return block_5016(state, tracer, fn_state);
        } else {
            return block_1279(state, tracer, fn_state);
        };
    }
    fn block_1279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1279_0: const #0u : u8
        let s_1279_0: bool = false;
        // D s_1279_1: write-var gs#135048 <= s_1279_0
        fn_state.gs_135048 = s_1279_0;
        // N s_1279_2: jump b1280
        return block_1280(state, tracer, fn_state);
    }
    fn block_1280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1280_0: read-var gs#135048:u8
        let s_1280_0: bool = fn_state.gs_135048;
        // N s_1280_1: branch s_1280_0 b5015 b1281
        if s_1280_0 {
            return block_5015(state, tracer, fn_state);
        } else {
            return block_1281(state, tracer, fn_state);
        };
    }
    fn block_1281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1281_0: const #0u : u8
        let s_1281_0: bool = false;
        // D s_1281_1: write-var gs#135049 <= s_1281_0
        fn_state.gs_135049 = s_1281_0;
        // N s_1281_2: jump b1282
        return block_1282(state, tracer, fn_state);
    }
    fn block_1282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1282_0: read-var gs#135049:u8
        let s_1282_0: bool = fn_state.gs_135049;
        // N s_1282_1: branch s_1282_0 b5014 b1283
        if s_1282_0 {
            return block_5014(state, tracer, fn_state);
        } else {
            return block_1283(state, tracer, fn_state);
        };
    }
    fn block_1283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1283_0: const #0u : u8
        let s_1283_0: bool = false;
        // D s_1283_1: write-var gs#135050 <= s_1283_0
        fn_state.gs_135050 = s_1283_0;
        // N s_1283_2: jump b1284
        return block_1284(state, tracer, fn_state);
    }
    fn block_1284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1284_0: read-var gs#135050:u8
        let s_1284_0: bool = fn_state.gs_135050;
        // N s_1284_1: branch s_1284_0 b5013 b1285
        if s_1284_0 {
            return block_5013(state, tracer, fn_state);
        } else {
            return block_1285(state, tracer, fn_state);
        };
    }
    fn block_1285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1285_0: const #0u : u8
        let s_1285_0: bool = false;
        // D s_1285_1: write-var gs#135051 <= s_1285_0
        fn_state.gs_135051 = s_1285_0;
        // N s_1285_2: jump b1286
        return block_1286(state, tracer, fn_state);
    }
    fn block_1286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1286_0: read-var gs#135051:u8
        let s_1286_0: bool = fn_state.gs_135051;
        // N s_1286_1: branch s_1286_0 b5012 b1287
        if s_1286_0 {
            return block_5012(state, tracer, fn_state);
        } else {
            return block_1287(state, tracer, fn_state);
        };
    }
    fn block_1287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1287_0: read-var CRm:u8
        let s_1287_0: u8 = fn_state.CRm;
        // D s_1287_1: cast zx s_1287_0 -> bv
        let s_1287_1: Bits = Bits::new(s_1287_0 as u128, 4u16);
        // C s_1287_2: const #1u : u8
        let s_1287_2: u8 = 1;
        // C s_1287_3: cast zx s_1287_2 -> bv
        let s_1287_3: Bits = Bits::new(s_1287_2 as u128, 4u16);
        // D s_1287_4: cmp-eq s_1287_1 s_1287_3
        let s_1287_4: bool = ((s_1287_1) == (s_1287_3));
        // N s_1287_5: branch s_1287_4 b5011 b1288
        if s_1287_4 {
            return block_5011(state, tracer, fn_state);
        } else {
            return block_1288(state, tracer, fn_state);
        };
    }
    fn block_1288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1288_0: const #0u : u8
        let s_1288_0: bool = false;
        // D s_1288_1: write-var gs#135052 <= s_1288_0
        fn_state.gs_135052 = s_1288_0;
        // N s_1288_2: jump b1289
        return block_1289(state, tracer, fn_state);
    }
    fn block_1289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1289_0: read-var gs#135052:u8
        let s_1289_0: bool = fn_state.gs_135052;
        // N s_1289_1: branch s_1289_0 b5010 b1290
        if s_1289_0 {
            return block_5010(state, tracer, fn_state);
        } else {
            return block_1290(state, tracer, fn_state);
        };
    }
    fn block_1290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1290_0: const #0u : u8
        let s_1290_0: bool = false;
        // D s_1290_1: write-var gs#135053 <= s_1290_0
        fn_state.gs_135053 = s_1290_0;
        // N s_1290_2: jump b1291
        return block_1291(state, tracer, fn_state);
    }
    fn block_1291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1291_0: read-var gs#135053:u8
        let s_1291_0: bool = fn_state.gs_135053;
        // N s_1291_1: branch s_1291_0 b5009 b1292
        if s_1291_0 {
            return block_5009(state, tracer, fn_state);
        } else {
            return block_1292(state, tracer, fn_state);
        };
    }
    fn block_1292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1292_0: const #0u : u8
        let s_1292_0: bool = false;
        // D s_1292_1: write-var gs#135054 <= s_1292_0
        fn_state.gs_135054 = s_1292_0;
        // N s_1292_2: jump b1293
        return block_1293(state, tracer, fn_state);
    }
    fn block_1293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1293_0: read-var gs#135054:u8
        let s_1293_0: bool = fn_state.gs_135054;
        // N s_1293_1: branch s_1293_0 b5008 b1294
        if s_1293_0 {
            return block_5008(state, tracer, fn_state);
        } else {
            return block_1294(state, tracer, fn_state);
        };
    }
    fn block_1294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1294_0: const #0u : u8
        let s_1294_0: bool = false;
        // D s_1294_1: write-var gs#135055 <= s_1294_0
        fn_state.gs_135055 = s_1294_0;
        // N s_1294_2: jump b1295
        return block_1295(state, tracer, fn_state);
    }
    fn block_1295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1295_0: read-var gs#135055:u8
        let s_1295_0: bool = fn_state.gs_135055;
        // N s_1295_1: branch s_1295_0 b5007 b1296
        if s_1295_0 {
            return block_5007(state, tracer, fn_state);
        } else {
            return block_1296(state, tracer, fn_state);
        };
    }
    fn block_1296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1296_0: read-var CRm:u8
        let s_1296_0: u8 = fn_state.CRm;
        // D s_1296_1: cast zx s_1296_0 -> bv
        let s_1296_1: Bits = Bits::new(s_1296_0 as u128, 4u16);
        // C s_1296_2: const #12u : u8
        let s_1296_2: u8 = 12;
        // C s_1296_3: cast zx s_1296_2 -> bv
        let s_1296_3: Bits = Bits::new(s_1296_2 as u128, 4u16);
        // D s_1296_4: cmp-eq s_1296_1 s_1296_3
        let s_1296_4: bool = ((s_1296_1) == (s_1296_3));
        // N s_1296_5: branch s_1296_4 b5006 b1297
        if s_1296_4 {
            return block_5006(state, tracer, fn_state);
        } else {
            return block_1297(state, tracer, fn_state);
        };
    }
    fn block_1297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1297_0: const #0u : u8
        let s_1297_0: bool = false;
        // D s_1297_1: write-var gs#135056 <= s_1297_0
        fn_state.gs_135056 = s_1297_0;
        // N s_1297_2: jump b1298
        return block_1298(state, tracer, fn_state);
    }
    fn block_1298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1298_0: read-var gs#135056:u8
        let s_1298_0: bool = fn_state.gs_135056;
        // N s_1298_1: branch s_1298_0 b5005 b1299
        if s_1298_0 {
            return block_5005(state, tracer, fn_state);
        } else {
            return block_1299(state, tracer, fn_state);
        };
    }
    fn block_1299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1299_0: const #0u : u8
        let s_1299_0: bool = false;
        // D s_1299_1: write-var gs#135057 <= s_1299_0
        fn_state.gs_135057 = s_1299_0;
        // N s_1299_2: jump b1300
        return block_1300(state, tracer, fn_state);
    }
    fn block_1300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1300_0: read-var gs#135057:u8
        let s_1300_0: bool = fn_state.gs_135057;
        // N s_1300_1: branch s_1300_0 b5004 b1301
        if s_1300_0 {
            return block_5004(state, tracer, fn_state);
        } else {
            return block_1301(state, tracer, fn_state);
        };
    }
    fn block_1301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1301_0: const #0u : u8
        let s_1301_0: bool = false;
        // D s_1301_1: write-var gs#135058 <= s_1301_0
        fn_state.gs_135058 = s_1301_0;
        // N s_1301_2: jump b1302
        return block_1302(state, tracer, fn_state);
    }
    fn block_1302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1302_0: read-var gs#135058:u8
        let s_1302_0: bool = fn_state.gs_135058;
        // N s_1302_1: branch s_1302_0 b5003 b1303
        if s_1302_0 {
            return block_5003(state, tracer, fn_state);
        } else {
            return block_1303(state, tracer, fn_state);
        };
    }
    fn block_1303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1303_0: const #0u : u8
        let s_1303_0: bool = false;
        // D s_1303_1: write-var gs#135059 <= s_1303_0
        fn_state.gs_135059 = s_1303_0;
        // N s_1303_2: jump b1304
        return block_1304(state, tracer, fn_state);
    }
    fn block_1304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1304_0: read-var gs#135059:u8
        let s_1304_0: bool = fn_state.gs_135059;
        // N s_1304_1: branch s_1304_0 b5002 b1305
        if s_1304_0 {
            return block_5002(state, tracer, fn_state);
        } else {
            return block_1305(state, tracer, fn_state);
        };
    }
    fn block_1305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1305_0: read-var CRm:u8
        let s_1305_0: u8 = fn_state.CRm;
        // D s_1305_1: cast zx s_1305_0 -> bv
        let s_1305_1: Bits = Bits::new(s_1305_0 as u128, 4u16);
        // C s_1305_2: const #11u : u8
        let s_1305_2: u8 = 11;
        // C s_1305_3: cast zx s_1305_2 -> bv
        let s_1305_3: Bits = Bits::new(s_1305_2 as u128, 4u16);
        // D s_1305_4: cmp-eq s_1305_1 s_1305_3
        let s_1305_4: bool = ((s_1305_1) == (s_1305_3));
        // N s_1305_5: branch s_1305_4 b5001 b1306
        if s_1305_4 {
            return block_5001(state, tracer, fn_state);
        } else {
            return block_1306(state, tracer, fn_state);
        };
    }
    fn block_1306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1306_0: const #0u : u8
        let s_1306_0: bool = false;
        // D s_1306_1: write-var gs#135060 <= s_1306_0
        fn_state.gs_135060 = s_1306_0;
        // N s_1306_2: jump b1307
        return block_1307(state, tracer, fn_state);
    }
    fn block_1307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1307_0: read-var gs#135060:u8
        let s_1307_0: bool = fn_state.gs_135060;
        // N s_1307_1: branch s_1307_0 b5000 b1308
        if s_1307_0 {
            return block_5000(state, tracer, fn_state);
        } else {
            return block_1308(state, tracer, fn_state);
        };
    }
    fn block_1308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1308_0: const #0u : u8
        let s_1308_0: bool = false;
        // D s_1308_1: write-var gs#135061 <= s_1308_0
        fn_state.gs_135061 = s_1308_0;
        // N s_1308_2: jump b1309
        return block_1309(state, tracer, fn_state);
    }
    fn block_1309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1309_0: read-var gs#135061:u8
        let s_1309_0: bool = fn_state.gs_135061;
        // N s_1309_1: branch s_1309_0 b4999 b1310
        if s_1309_0 {
            return block_4999(state, tracer, fn_state);
        } else {
            return block_1310(state, tracer, fn_state);
        };
    }
    fn block_1310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1310_0: const #0u : u8
        let s_1310_0: bool = false;
        // D s_1310_1: write-var gs#135062 <= s_1310_0
        fn_state.gs_135062 = s_1310_0;
        // N s_1310_2: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_1311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1311_0: read-var gs#135062:u8
        let s_1311_0: bool = fn_state.gs_135062;
        // N s_1311_1: branch s_1311_0 b4998 b1312
        if s_1311_0 {
            return block_4998(state, tracer, fn_state);
        } else {
            return block_1312(state, tracer, fn_state);
        };
    }
    fn block_1312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1312_0: const #0u : u8
        let s_1312_0: bool = false;
        // D s_1312_1: write-var gs#135063 <= s_1312_0
        fn_state.gs_135063 = s_1312_0;
        // N s_1312_2: jump b1313
        return block_1313(state, tracer, fn_state);
    }
    fn block_1313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1313_0: read-var gs#135063:u8
        let s_1313_0: bool = fn_state.gs_135063;
        // N s_1313_1: branch s_1313_0 b4997 b1314
        if s_1313_0 {
            return block_4997(state, tracer, fn_state);
        } else {
            return block_1314(state, tracer, fn_state);
        };
    }
    fn block_1314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1314_0: read-var CRm:u8
        let s_1314_0: u8 = fn_state.CRm;
        // D s_1314_1: cast zx s_1314_0 -> bv
        let s_1314_1: Bits = Bits::new(s_1314_0 as u128, 4u16);
        // C s_1314_2: const #12u : u8
        let s_1314_2: u8 = 12;
        // C s_1314_3: cast zx s_1314_2 -> bv
        let s_1314_3: Bits = Bits::new(s_1314_2 as u128, 4u16);
        // D s_1314_4: cmp-eq s_1314_1 s_1314_3
        let s_1314_4: bool = ((s_1314_1) == (s_1314_3));
        // N s_1314_5: branch s_1314_4 b4996 b1315
        if s_1314_4 {
            return block_4996(state, tracer, fn_state);
        } else {
            return block_1315(state, tracer, fn_state);
        };
    }
    fn block_1315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1315_0: const #0u : u8
        let s_1315_0: bool = false;
        // D s_1315_1: write-var gs#135064 <= s_1315_0
        fn_state.gs_135064 = s_1315_0;
        // N s_1315_2: jump b1316
        return block_1316(state, tracer, fn_state);
    }
    fn block_1316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1316_0: read-var gs#135064:u8
        let s_1316_0: bool = fn_state.gs_135064;
        // N s_1316_1: branch s_1316_0 b4995 b1317
        if s_1316_0 {
            return block_4995(state, tracer, fn_state);
        } else {
            return block_1317(state, tracer, fn_state);
        };
    }
    fn block_1317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1317_0: const #0u : u8
        let s_1317_0: bool = false;
        // D s_1317_1: write-var gs#135065 <= s_1317_0
        fn_state.gs_135065 = s_1317_0;
        // N s_1317_2: jump b1318
        return block_1318(state, tracer, fn_state);
    }
    fn block_1318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1318_0: read-var gs#135065:u8
        let s_1318_0: bool = fn_state.gs_135065;
        // N s_1318_1: branch s_1318_0 b4994 b1319
        if s_1318_0 {
            return block_4994(state, tracer, fn_state);
        } else {
            return block_1319(state, tracer, fn_state);
        };
    }
    fn block_1319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1319_0: const #0u : u8
        let s_1319_0: bool = false;
        // D s_1319_1: write-var gs#135066 <= s_1319_0
        fn_state.gs_135066 = s_1319_0;
        // N s_1319_2: jump b1320
        return block_1320(state, tracer, fn_state);
    }
    fn block_1320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1320_0: read-var gs#135066:u8
        let s_1320_0: bool = fn_state.gs_135066;
        // N s_1320_1: branch s_1320_0 b4993 b1321
        if s_1320_0 {
            return block_4993(state, tracer, fn_state);
        } else {
            return block_1321(state, tracer, fn_state);
        };
    }
    fn block_1321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1321_0: const #0u : u8
        let s_1321_0: bool = false;
        // D s_1321_1: write-var gs#135067 <= s_1321_0
        fn_state.gs_135067 = s_1321_0;
        // N s_1321_2: jump b1322
        return block_1322(state, tracer, fn_state);
    }
    fn block_1322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1322_0: read-var gs#135067:u8
        let s_1322_0: bool = fn_state.gs_135067;
        // N s_1322_1: branch s_1322_0 b4992 b1323
        if s_1322_0 {
            return block_4992(state, tracer, fn_state);
        } else {
            return block_1323(state, tracer, fn_state);
        };
    }
    fn block_1323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1323_0: read-var CRm:u8
        let s_1323_0: u8 = fn_state.CRm;
        // D s_1323_1: cast zx s_1323_0 -> bv
        let s_1323_1: Bits = Bits::new(s_1323_0 as u128, 4u16);
        // C s_1323_2: const #5u : u8
        let s_1323_2: u8 = 5;
        // C s_1323_3: cast zx s_1323_2 -> bv
        let s_1323_3: Bits = Bits::new(s_1323_2 as u128, 4u16);
        // D s_1323_4: cmp-eq s_1323_1 s_1323_3
        let s_1323_4: bool = ((s_1323_1) == (s_1323_3));
        // N s_1323_5: branch s_1323_4 b4991 b1324
        if s_1323_4 {
            return block_4991(state, tracer, fn_state);
        } else {
            return block_1324(state, tracer, fn_state);
        };
    }
    fn block_1324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1324_0: const #0u : u8
        let s_1324_0: bool = false;
        // D s_1324_1: write-var gs#135068 <= s_1324_0
        fn_state.gs_135068 = s_1324_0;
        // N s_1324_2: jump b1325
        return block_1325(state, tracer, fn_state);
    }
    fn block_1325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1325_0: read-var gs#135068:u8
        let s_1325_0: bool = fn_state.gs_135068;
        // N s_1325_1: branch s_1325_0 b4990 b1326
        if s_1325_0 {
            return block_4990(state, tracer, fn_state);
        } else {
            return block_1326(state, tracer, fn_state);
        };
    }
    fn block_1326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1326_0: const #0u : u8
        let s_1326_0: bool = false;
        // D s_1326_1: write-var gs#135069 <= s_1326_0
        fn_state.gs_135069 = s_1326_0;
        // N s_1326_2: jump b1327
        return block_1327(state, tracer, fn_state);
    }
    fn block_1327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1327_0: read-var gs#135069:u8
        let s_1327_0: bool = fn_state.gs_135069;
        // N s_1327_1: branch s_1327_0 b4989 b1328
        if s_1327_0 {
            return block_4989(state, tracer, fn_state);
        } else {
            return block_1328(state, tracer, fn_state);
        };
    }
    fn block_1328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1328_0: const #0u : u8
        let s_1328_0: bool = false;
        // D s_1328_1: write-var gs#135070 <= s_1328_0
        fn_state.gs_135070 = s_1328_0;
        // N s_1328_2: jump b1329
        return block_1329(state, tracer, fn_state);
    }
    fn block_1329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1329_0: read-var gs#135070:u8
        let s_1329_0: bool = fn_state.gs_135070;
        // N s_1329_1: branch s_1329_0 b4988 b1330
        if s_1329_0 {
            return block_4988(state, tracer, fn_state);
        } else {
            return block_1330(state, tracer, fn_state);
        };
    }
    fn block_1330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1330_0: const #0u : u8
        let s_1330_0: bool = false;
        // D s_1330_1: write-var gs#135071 <= s_1330_0
        fn_state.gs_135071 = s_1330_0;
        // N s_1330_2: jump b1331
        return block_1331(state, tracer, fn_state);
    }
    fn block_1331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1331_0: read-var gs#135071:u8
        let s_1331_0: bool = fn_state.gs_135071;
        // N s_1331_1: branch s_1331_0 b4987 b1332
        if s_1331_0 {
            return block_4987(state, tracer, fn_state);
        } else {
            return block_1332(state, tracer, fn_state);
        };
    }
    fn block_1332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1332_0: read-var CRm:u8
        let s_1332_0: u8 = fn_state.CRm;
        // D s_1332_1: cast zx s_1332_0 -> bv
        let s_1332_1: Bits = Bits::new(s_1332_0 as u128, 4u16);
        // C s_1332_2: const #8u : u8
        let s_1332_2: u8 = 8;
        // C s_1332_3: cast zx s_1332_2 -> bv
        let s_1332_3: Bits = Bits::new(s_1332_2 as u128, 4u16);
        // D s_1332_4: cmp-eq s_1332_1 s_1332_3
        let s_1332_4: bool = ((s_1332_1) == (s_1332_3));
        // N s_1332_5: branch s_1332_4 b4986 b1333
        if s_1332_4 {
            return block_4986(state, tracer, fn_state);
        } else {
            return block_1333(state, tracer, fn_state);
        };
    }
    fn block_1333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1333_0: const #0u : u8
        let s_1333_0: bool = false;
        // D s_1333_1: write-var gs#135072 <= s_1333_0
        fn_state.gs_135072 = s_1333_0;
        // N s_1333_2: jump b1334
        return block_1334(state, tracer, fn_state);
    }
    fn block_1334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1334_0: read-var gs#135072:u8
        let s_1334_0: bool = fn_state.gs_135072;
        // N s_1334_1: branch s_1334_0 b4985 b1335
        if s_1334_0 {
            return block_4985(state, tracer, fn_state);
        } else {
            return block_1335(state, tracer, fn_state);
        };
    }
    fn block_1335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1335_0: const #0u : u8
        let s_1335_0: bool = false;
        // D s_1335_1: write-var gs#135073 <= s_1335_0
        fn_state.gs_135073 = s_1335_0;
        // N s_1335_2: jump b1336
        return block_1336(state, tracer, fn_state);
    }
    fn block_1336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1336_0: read-var gs#135073:u8
        let s_1336_0: bool = fn_state.gs_135073;
        // N s_1336_1: branch s_1336_0 b4984 b1337
        if s_1336_0 {
            return block_4984(state, tracer, fn_state);
        } else {
            return block_1337(state, tracer, fn_state);
        };
    }
    fn block_1337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1337_0: const #0u : u8
        let s_1337_0: bool = false;
        // D s_1337_1: write-var gs#135074 <= s_1337_0
        fn_state.gs_135074 = s_1337_0;
        // N s_1337_2: jump b1338
        return block_1338(state, tracer, fn_state);
    }
    fn block_1338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1338_0: read-var gs#135074:u8
        let s_1338_0: bool = fn_state.gs_135074;
        // N s_1338_1: branch s_1338_0 b4983 b1339
        if s_1338_0 {
            return block_4983(state, tracer, fn_state);
        } else {
            return block_1339(state, tracer, fn_state);
        };
    }
    fn block_1339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1339_0: const #0u : u8
        let s_1339_0: bool = false;
        // D s_1339_1: write-var gs#135075 <= s_1339_0
        fn_state.gs_135075 = s_1339_0;
        // N s_1339_2: jump b1340
        return block_1340(state, tracer, fn_state);
    }
    fn block_1340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1340_0: read-var gs#135075:u8
        let s_1340_0: bool = fn_state.gs_135075;
        // N s_1340_1: branch s_1340_0 b4982 b1341
        if s_1340_0 {
            return block_4982(state, tracer, fn_state);
        } else {
            return block_1341(state, tracer, fn_state);
        };
    }
    fn block_1341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1341_0: read-var CRm:u8
        let s_1341_0: u8 = fn_state.CRm;
        // D s_1341_1: cast zx s_1341_0 -> bv
        let s_1341_1: Bits = Bits::new(s_1341_0 as u128, 4u16);
        // C s_1341_2: const #2u : u8
        let s_1341_2: u8 = 2;
        // C s_1341_3: cast zx s_1341_2 -> bv
        let s_1341_3: Bits = Bits::new(s_1341_2 as u128, 4u16);
        // D s_1341_4: cmp-eq s_1341_1 s_1341_3
        let s_1341_4: bool = ((s_1341_1) == (s_1341_3));
        // N s_1341_5: branch s_1341_4 b4981 b1342
        if s_1341_4 {
            return block_4981(state, tracer, fn_state);
        } else {
            return block_1342(state, tracer, fn_state);
        };
    }
    fn block_1342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1342_0: const #0u : u8
        let s_1342_0: bool = false;
        // D s_1342_1: write-var gs#135076 <= s_1342_0
        fn_state.gs_135076 = s_1342_0;
        // N s_1342_2: jump b1343
        return block_1343(state, tracer, fn_state);
    }
    fn block_1343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1343_0: read-var gs#135076:u8
        let s_1343_0: bool = fn_state.gs_135076;
        // N s_1343_1: branch s_1343_0 b4980 b1344
        if s_1343_0 {
            return block_4980(state, tracer, fn_state);
        } else {
            return block_1344(state, tracer, fn_state);
        };
    }
    fn block_1344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1344_0: const #0u : u8
        let s_1344_0: bool = false;
        // D s_1344_1: write-var gs#135077 <= s_1344_0
        fn_state.gs_135077 = s_1344_0;
        // N s_1344_2: jump b1345
        return block_1345(state, tracer, fn_state);
    }
    fn block_1345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1345_0: read-var gs#135077:u8
        let s_1345_0: bool = fn_state.gs_135077;
        // N s_1345_1: branch s_1345_0 b4979 b1346
        if s_1345_0 {
            return block_4979(state, tracer, fn_state);
        } else {
            return block_1346(state, tracer, fn_state);
        };
    }
    fn block_1346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1346_0: const #0u : u8
        let s_1346_0: bool = false;
        // D s_1346_1: write-var gs#135078 <= s_1346_0
        fn_state.gs_135078 = s_1346_0;
        // N s_1346_2: jump b1347
        return block_1347(state, tracer, fn_state);
    }
    fn block_1347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1347_0: read-var gs#135078:u8
        let s_1347_0: bool = fn_state.gs_135078;
        // N s_1347_1: branch s_1347_0 b4978 b1348
        if s_1347_0 {
            return block_4978(state, tracer, fn_state);
        } else {
            return block_1348(state, tracer, fn_state);
        };
    }
    fn block_1348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1348_0: const #0u : u8
        let s_1348_0: bool = false;
        // D s_1348_1: write-var gs#135079 <= s_1348_0
        fn_state.gs_135079 = s_1348_0;
        // N s_1348_2: jump b1349
        return block_1349(state, tracer, fn_state);
    }
    fn block_1349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1349_0: read-var gs#135079:u8
        let s_1349_0: bool = fn_state.gs_135079;
        // N s_1349_1: branch s_1349_0 b4977 b1350
        if s_1349_0 {
            return block_4977(state, tracer, fn_state);
        } else {
            return block_1350(state, tracer, fn_state);
        };
    }
    fn block_1350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1350_0: read-var CRm:u8
        let s_1350_0: u8 = fn_state.CRm;
        // D s_1350_1: cast zx s_1350_0 -> bv
        let s_1350_1: Bits = Bits::new(s_1350_0 as u128, 4u16);
        // C s_1350_2: const #0u : u8
        let s_1350_2: u8 = 0;
        // C s_1350_3: cast zx s_1350_2 -> bv
        let s_1350_3: Bits = Bits::new(s_1350_2 as u128, 4u16);
        // D s_1350_4: cmp-eq s_1350_1 s_1350_3
        let s_1350_4: bool = ((s_1350_1) == (s_1350_3));
        // N s_1350_5: branch s_1350_4 b4976 b1351
        if s_1350_4 {
            return block_4976(state, tracer, fn_state);
        } else {
            return block_1351(state, tracer, fn_state);
        };
    }
    fn block_1351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1351_0: const #0u : u8
        let s_1351_0: bool = false;
        // D s_1351_1: write-var gs#135080 <= s_1351_0
        fn_state.gs_135080 = s_1351_0;
        // N s_1351_2: jump b1352
        return block_1352(state, tracer, fn_state);
    }
    fn block_1352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1352_0: read-var gs#135080:u8
        let s_1352_0: bool = fn_state.gs_135080;
        // N s_1352_1: branch s_1352_0 b4975 b1353
        if s_1352_0 {
            return block_4975(state, tracer, fn_state);
        } else {
            return block_1353(state, tracer, fn_state);
        };
    }
    fn block_1353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1353_0: const #0u : u8
        let s_1353_0: bool = false;
        // D s_1353_1: write-var gs#135081 <= s_1353_0
        fn_state.gs_135081 = s_1353_0;
        // N s_1353_2: jump b1354
        return block_1354(state, tracer, fn_state);
    }
    fn block_1354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1354_0: read-var gs#135081:u8
        let s_1354_0: bool = fn_state.gs_135081;
        // N s_1354_1: branch s_1354_0 b4974 b1355
        if s_1354_0 {
            return block_4974(state, tracer, fn_state);
        } else {
            return block_1355(state, tracer, fn_state);
        };
    }
    fn block_1355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1355_0: const #0u : u8
        let s_1355_0: bool = false;
        // D s_1355_1: write-var gs#135082 <= s_1355_0
        fn_state.gs_135082 = s_1355_0;
        // N s_1355_2: jump b1356
        return block_1356(state, tracer, fn_state);
    }
    fn block_1356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1356_0: read-var gs#135082:u8
        let s_1356_0: bool = fn_state.gs_135082;
        // N s_1356_1: branch s_1356_0 b4973 b1357
        if s_1356_0 {
            return block_4973(state, tracer, fn_state);
        } else {
            return block_1357(state, tracer, fn_state);
        };
    }
    fn block_1357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1357_0: const #0u : u8
        let s_1357_0: bool = false;
        // D s_1357_1: write-var gs#135083 <= s_1357_0
        fn_state.gs_135083 = s_1357_0;
        // N s_1357_2: jump b1358
        return block_1358(state, tracer, fn_state);
    }
    fn block_1358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1358_0: read-var gs#135083:u8
        let s_1358_0: bool = fn_state.gs_135083;
        // N s_1358_1: branch s_1358_0 b4972 b1359
        if s_1358_0 {
            return block_4972(state, tracer, fn_state);
        } else {
            return block_1359(state, tracer, fn_state);
        };
    }
    fn block_1359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1359_0: read-var CRm:u8
        let s_1359_0: u8 = fn_state.CRm;
        // D s_1359_1: cast zx s_1359_0 -> bv
        let s_1359_1: Bits = Bits::new(s_1359_0 as u128, 4u16);
        // C s_1359_2: const #6u : u8
        let s_1359_2: u8 = 6;
        // C s_1359_3: cast zx s_1359_2 -> bv
        let s_1359_3: Bits = Bits::new(s_1359_2 as u128, 4u16);
        // D s_1359_4: cmp-eq s_1359_1 s_1359_3
        let s_1359_4: bool = ((s_1359_1) == (s_1359_3));
        // N s_1359_5: branch s_1359_4 b4971 b1360
        if s_1359_4 {
            return block_4971(state, tracer, fn_state);
        } else {
            return block_1360(state, tracer, fn_state);
        };
    }
    fn block_1360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1360_0: const #0u : u8
        let s_1360_0: bool = false;
        // D s_1360_1: write-var gs#135084 <= s_1360_0
        fn_state.gs_135084 = s_1360_0;
        // N s_1360_2: jump b1361
        return block_1361(state, tracer, fn_state);
    }
    fn block_1361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1361_0: read-var gs#135084:u8
        let s_1361_0: bool = fn_state.gs_135084;
        // N s_1361_1: branch s_1361_0 b4970 b1362
        if s_1361_0 {
            return block_4970(state, tracer, fn_state);
        } else {
            return block_1362(state, tracer, fn_state);
        };
    }
    fn block_1362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1362_0: const #0u : u8
        let s_1362_0: bool = false;
        // D s_1362_1: write-var gs#135085 <= s_1362_0
        fn_state.gs_135085 = s_1362_0;
        // N s_1362_2: jump b1363
        return block_1363(state, tracer, fn_state);
    }
    fn block_1363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1363_0: read-var gs#135085:u8
        let s_1363_0: bool = fn_state.gs_135085;
        // N s_1363_1: branch s_1363_0 b4969 b1364
        if s_1363_0 {
            return block_4969(state, tracer, fn_state);
        } else {
            return block_1364(state, tracer, fn_state);
        };
    }
    fn block_1364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1364_0: const #0u : u8
        let s_1364_0: bool = false;
        // D s_1364_1: write-var gs#135086 <= s_1364_0
        fn_state.gs_135086 = s_1364_0;
        // N s_1364_2: jump b1365
        return block_1365(state, tracer, fn_state);
    }
    fn block_1365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1365_0: read-var gs#135086:u8
        let s_1365_0: bool = fn_state.gs_135086;
        // N s_1365_1: branch s_1365_0 b4968 b1366
        if s_1365_0 {
            return block_4968(state, tracer, fn_state);
        } else {
            return block_1366(state, tracer, fn_state);
        };
    }
    fn block_1366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1366_0: const #0u : u8
        let s_1366_0: bool = false;
        // D s_1366_1: write-var gs#135087 <= s_1366_0
        fn_state.gs_135087 = s_1366_0;
        // N s_1366_2: jump b1367
        return block_1367(state, tracer, fn_state);
    }
    fn block_1367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1367_0: read-var gs#135087:u8
        let s_1367_0: bool = fn_state.gs_135087;
        // N s_1367_1: branch s_1367_0 b4967 b1368
        if s_1367_0 {
            return block_4967(state, tracer, fn_state);
        } else {
            return block_1368(state, tracer, fn_state);
        };
    }
    fn block_1368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1368_0: read-var CRm:u8
        let s_1368_0: u8 = fn_state.CRm;
        // D s_1368_1: cast zx s_1368_0 -> bv
        let s_1368_1: Bits = Bits::new(s_1368_0 as u128, 4u16);
        // C s_1368_2: const #11u : u8
        let s_1368_2: u8 = 11;
        // C s_1368_3: cast zx s_1368_2 -> bv
        let s_1368_3: Bits = Bits::new(s_1368_2 as u128, 4u16);
        // D s_1368_4: cmp-eq s_1368_1 s_1368_3
        let s_1368_4: bool = ((s_1368_1) == (s_1368_3));
        // N s_1368_5: branch s_1368_4 b4966 b1369
        if s_1368_4 {
            return block_4966(state, tracer, fn_state);
        } else {
            return block_1369(state, tracer, fn_state);
        };
    }
    fn block_1369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1369_0: const #0u : u8
        let s_1369_0: bool = false;
        // D s_1369_1: write-var gs#135088 <= s_1369_0
        fn_state.gs_135088 = s_1369_0;
        // N s_1369_2: jump b1370
        return block_1370(state, tracer, fn_state);
    }
    fn block_1370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1370_0: read-var gs#135088:u8
        let s_1370_0: bool = fn_state.gs_135088;
        // N s_1370_1: branch s_1370_0 b4965 b1371
        if s_1370_0 {
            return block_4965(state, tracer, fn_state);
        } else {
            return block_1371(state, tracer, fn_state);
        };
    }
    fn block_1371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1371_0: const #0u : u8
        let s_1371_0: bool = false;
        // D s_1371_1: write-var gs#135089 <= s_1371_0
        fn_state.gs_135089 = s_1371_0;
        // N s_1371_2: jump b1372
        return block_1372(state, tracer, fn_state);
    }
    fn block_1372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1372_0: read-var gs#135089:u8
        let s_1372_0: bool = fn_state.gs_135089;
        // N s_1372_1: branch s_1372_0 b4964 b1373
        if s_1372_0 {
            return block_4964(state, tracer, fn_state);
        } else {
            return block_1373(state, tracer, fn_state);
        };
    }
    fn block_1373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1373_0: const #0u : u8
        let s_1373_0: bool = false;
        // D s_1373_1: write-var gs#135090 <= s_1373_0
        fn_state.gs_135090 = s_1373_0;
        // N s_1373_2: jump b1374
        return block_1374(state, tracer, fn_state);
    }
    fn block_1374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1374_0: read-var gs#135090:u8
        let s_1374_0: bool = fn_state.gs_135090;
        // N s_1374_1: branch s_1374_0 b4963 b1375
        if s_1374_0 {
            return block_4963(state, tracer, fn_state);
        } else {
            return block_1375(state, tracer, fn_state);
        };
    }
    fn block_1375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1375_0: const #0u : u8
        let s_1375_0: bool = false;
        // D s_1375_1: write-var gs#135091 <= s_1375_0
        fn_state.gs_135091 = s_1375_0;
        // N s_1375_2: jump b1376
        return block_1376(state, tracer, fn_state);
    }
    fn block_1376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1376_0: read-var gs#135091:u8
        let s_1376_0: bool = fn_state.gs_135091;
        // N s_1376_1: branch s_1376_0 b4962 b1377
        if s_1376_0 {
            return block_4962(state, tracer, fn_state);
        } else {
            return block_1377(state, tracer, fn_state);
        };
    }
    fn block_1377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1377_0: read-var CRm:u8
        let s_1377_0: u8 = fn_state.CRm;
        // D s_1377_1: cast zx s_1377_0 -> bv
        let s_1377_1: Bits = Bits::new(s_1377_0 as u128, 4u16);
        // C s_1377_2: const #11u : u8
        let s_1377_2: u8 = 11;
        // C s_1377_3: cast zx s_1377_2 -> bv
        let s_1377_3: Bits = Bits::new(s_1377_2 as u128, 4u16);
        // D s_1377_4: cmp-eq s_1377_1 s_1377_3
        let s_1377_4: bool = ((s_1377_1) == (s_1377_3));
        // N s_1377_5: branch s_1377_4 b4961 b1378
        if s_1377_4 {
            return block_4961(state, tracer, fn_state);
        } else {
            return block_1378(state, tracer, fn_state);
        };
    }
    fn block_1378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1378_0: const #0u : u8
        let s_1378_0: bool = false;
        // D s_1378_1: write-var gs#135092 <= s_1378_0
        fn_state.gs_135092 = s_1378_0;
        // N s_1378_2: jump b1379
        return block_1379(state, tracer, fn_state);
    }
    fn block_1379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1379_0: read-var gs#135092:u8
        let s_1379_0: bool = fn_state.gs_135092;
        // N s_1379_1: branch s_1379_0 b4960 b1380
        if s_1379_0 {
            return block_4960(state, tracer, fn_state);
        } else {
            return block_1380(state, tracer, fn_state);
        };
    }
    fn block_1380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1380_0: const #0u : u8
        let s_1380_0: bool = false;
        // D s_1380_1: write-var gs#135093 <= s_1380_0
        fn_state.gs_135093 = s_1380_0;
        // N s_1380_2: jump b1381
        return block_1381(state, tracer, fn_state);
    }
    fn block_1381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1381_0: read-var gs#135093:u8
        let s_1381_0: bool = fn_state.gs_135093;
        // N s_1381_1: branch s_1381_0 b4959 b1382
        if s_1381_0 {
            return block_4959(state, tracer, fn_state);
        } else {
            return block_1382(state, tracer, fn_state);
        };
    }
    fn block_1382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1382_0: const #0u : u8
        let s_1382_0: bool = false;
        // D s_1382_1: write-var gs#135094 <= s_1382_0
        fn_state.gs_135094 = s_1382_0;
        // N s_1382_2: jump b1383
        return block_1383(state, tracer, fn_state);
    }
    fn block_1383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1383_0: read-var gs#135094:u8
        let s_1383_0: bool = fn_state.gs_135094;
        // N s_1383_1: branch s_1383_0 b4958 b1384
        if s_1383_0 {
            return block_4958(state, tracer, fn_state);
        } else {
            return block_1384(state, tracer, fn_state);
        };
    }
    fn block_1384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1384_0: const #0u : u8
        let s_1384_0: bool = false;
        // D s_1384_1: write-var gs#135095 <= s_1384_0
        fn_state.gs_135095 = s_1384_0;
        // N s_1384_2: jump b1385
        return block_1385(state, tracer, fn_state);
    }
    fn block_1385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1385_0: read-var gs#135095:u8
        let s_1385_0: bool = fn_state.gs_135095;
        // N s_1385_1: branch s_1385_0 b4957 b1386
        if s_1385_0 {
            return block_4957(state, tracer, fn_state);
        } else {
            return block_1386(state, tracer, fn_state);
        };
    }
    fn block_1386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1386_0: read-var CRm:u8
        let s_1386_0: u8 = fn_state.CRm;
        // D s_1386_1: cast zx s_1386_0 -> bv
        let s_1386_1: Bits = Bits::new(s_1386_0 as u128, 4u16);
        // C s_1386_2: const #11u : u8
        let s_1386_2: u8 = 11;
        // C s_1386_3: cast zx s_1386_2 -> bv
        let s_1386_3: Bits = Bits::new(s_1386_2 as u128, 4u16);
        // D s_1386_4: cmp-eq s_1386_1 s_1386_3
        let s_1386_4: bool = ((s_1386_1) == (s_1386_3));
        // N s_1386_5: branch s_1386_4 b4956 b1387
        if s_1386_4 {
            return block_4956(state, tracer, fn_state);
        } else {
            return block_1387(state, tracer, fn_state);
        };
    }
    fn block_1387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1387_0: const #0u : u8
        let s_1387_0: bool = false;
        // D s_1387_1: write-var gs#135096 <= s_1387_0
        fn_state.gs_135096 = s_1387_0;
        // N s_1387_2: jump b1388
        return block_1388(state, tracer, fn_state);
    }
    fn block_1388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1388_0: read-var gs#135096:u8
        let s_1388_0: bool = fn_state.gs_135096;
        // N s_1388_1: branch s_1388_0 b4955 b1389
        if s_1388_0 {
            return block_4955(state, tracer, fn_state);
        } else {
            return block_1389(state, tracer, fn_state);
        };
    }
    fn block_1389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1389_0: const #0u : u8
        let s_1389_0: bool = false;
        // D s_1389_1: write-var gs#135097 <= s_1389_0
        fn_state.gs_135097 = s_1389_0;
        // N s_1389_2: jump b1390
        return block_1390(state, tracer, fn_state);
    }
    fn block_1390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1390_0: read-var gs#135097:u8
        let s_1390_0: bool = fn_state.gs_135097;
        // N s_1390_1: branch s_1390_0 b4954 b1391
        if s_1390_0 {
            return block_4954(state, tracer, fn_state);
        } else {
            return block_1391(state, tracer, fn_state);
        };
    }
    fn block_1391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1391_0: const #0u : u8
        let s_1391_0: bool = false;
        // D s_1391_1: write-var gs#135098 <= s_1391_0
        fn_state.gs_135098 = s_1391_0;
        // N s_1391_2: jump b1392
        return block_1392(state, tracer, fn_state);
    }
    fn block_1392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1392_0: read-var gs#135098:u8
        let s_1392_0: bool = fn_state.gs_135098;
        // N s_1392_1: branch s_1392_0 b4953 b1393
        if s_1392_0 {
            return block_4953(state, tracer, fn_state);
        } else {
            return block_1393(state, tracer, fn_state);
        };
    }
    fn block_1393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1393_0: const #0u : u8
        let s_1393_0: bool = false;
        // D s_1393_1: write-var gs#135099 <= s_1393_0
        fn_state.gs_135099 = s_1393_0;
        // N s_1393_2: jump b1394
        return block_1394(state, tracer, fn_state);
    }
    fn block_1394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1394_0: read-var gs#135099:u8
        let s_1394_0: bool = fn_state.gs_135099;
        // N s_1394_1: branch s_1394_0 b4952 b1395
        if s_1394_0 {
            return block_4952(state, tracer, fn_state);
        } else {
            return block_1395(state, tracer, fn_state);
        };
    }
    fn block_1395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1395_0: read-var CRm:u8
        let s_1395_0: u8 = fn_state.CRm;
        // D s_1395_1: cast zx s_1395_0 -> bv
        let s_1395_1: Bits = Bits::new(s_1395_0 as u128, 4u16);
        // C s_1395_2: const #11u : u8
        let s_1395_2: u8 = 11;
        // C s_1395_3: cast zx s_1395_2 -> bv
        let s_1395_3: Bits = Bits::new(s_1395_2 as u128, 4u16);
        // D s_1395_4: cmp-eq s_1395_1 s_1395_3
        let s_1395_4: bool = ((s_1395_1) == (s_1395_3));
        // N s_1395_5: branch s_1395_4 b4951 b1396
        if s_1395_4 {
            return block_4951(state, tracer, fn_state);
        } else {
            return block_1396(state, tracer, fn_state);
        };
    }
    fn block_1396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1396_0: const #0u : u8
        let s_1396_0: bool = false;
        // D s_1396_1: write-var gs#135100 <= s_1396_0
        fn_state.gs_135100 = s_1396_0;
        // N s_1396_2: jump b1397
        return block_1397(state, tracer, fn_state);
    }
    fn block_1397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1397_0: read-var gs#135100:u8
        let s_1397_0: bool = fn_state.gs_135100;
        // N s_1397_1: branch s_1397_0 b4950 b1398
        if s_1397_0 {
            return block_4950(state, tracer, fn_state);
        } else {
            return block_1398(state, tracer, fn_state);
        };
    }
    fn block_1398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1398_0: const #0u : u8
        let s_1398_0: bool = false;
        // D s_1398_1: write-var gs#135101 <= s_1398_0
        fn_state.gs_135101 = s_1398_0;
        // N s_1398_2: jump b1399
        return block_1399(state, tracer, fn_state);
    }
    fn block_1399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1399_0: read-var gs#135101:u8
        let s_1399_0: bool = fn_state.gs_135101;
        // N s_1399_1: branch s_1399_0 b4949 b1400
        if s_1399_0 {
            return block_4949(state, tracer, fn_state);
        } else {
            return block_1400(state, tracer, fn_state);
        };
    }
    fn block_1400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1400_0: const #0u : u8
        let s_1400_0: bool = false;
        // D s_1400_1: write-var gs#135102 <= s_1400_0
        fn_state.gs_135102 = s_1400_0;
        // N s_1400_2: jump b1401
        return block_1401(state, tracer, fn_state);
    }
    fn block_1401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1401_0: read-var gs#135102:u8
        let s_1401_0: bool = fn_state.gs_135102;
        // N s_1401_1: branch s_1401_0 b4948 b1402
        if s_1401_0 {
            return block_4948(state, tracer, fn_state);
        } else {
            return block_1402(state, tracer, fn_state);
        };
    }
    fn block_1402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1402_0: const #0u : u8
        let s_1402_0: bool = false;
        // D s_1402_1: write-var gs#135103 <= s_1402_0
        fn_state.gs_135103 = s_1402_0;
        // N s_1402_2: jump b1403
        return block_1403(state, tracer, fn_state);
    }
    fn block_1403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1403_0: read-var gs#135103:u8
        let s_1403_0: bool = fn_state.gs_135103;
        // N s_1403_1: branch s_1403_0 b4947 b1404
        if s_1403_0 {
            return block_4947(state, tracer, fn_state);
        } else {
            return block_1404(state, tracer, fn_state);
        };
    }
    fn block_1404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1404_0: read-var CRm:u8
        let s_1404_0: u8 = fn_state.CRm;
        // D s_1404_1: cast zx s_1404_0 -> bv
        let s_1404_1: Bits = Bits::new(s_1404_0 as u128, 4u16);
        // C s_1404_2: const #11u : u8
        let s_1404_2: u8 = 11;
        // C s_1404_3: cast zx s_1404_2 -> bv
        let s_1404_3: Bits = Bits::new(s_1404_2 as u128, 4u16);
        // D s_1404_4: cmp-eq s_1404_1 s_1404_3
        let s_1404_4: bool = ((s_1404_1) == (s_1404_3));
        // N s_1404_5: branch s_1404_4 b4946 b1405
        if s_1404_4 {
            return block_4946(state, tracer, fn_state);
        } else {
            return block_1405(state, tracer, fn_state);
        };
    }
    fn block_1405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1405_0: const #0u : u8
        let s_1405_0: bool = false;
        // D s_1405_1: write-var gs#135104 <= s_1405_0
        fn_state.gs_135104 = s_1405_0;
        // N s_1405_2: jump b1406
        return block_1406(state, tracer, fn_state);
    }
    fn block_1406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1406_0: read-var gs#135104:u8
        let s_1406_0: bool = fn_state.gs_135104;
        // N s_1406_1: branch s_1406_0 b4945 b1407
        if s_1406_0 {
            return block_4945(state, tracer, fn_state);
        } else {
            return block_1407(state, tracer, fn_state);
        };
    }
    fn block_1407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1407_0: const #0u : u8
        let s_1407_0: bool = false;
        // D s_1407_1: write-var gs#135105 <= s_1407_0
        fn_state.gs_135105 = s_1407_0;
        // N s_1407_2: jump b1408
        return block_1408(state, tracer, fn_state);
    }
    fn block_1408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1408_0: read-var gs#135105:u8
        let s_1408_0: bool = fn_state.gs_135105;
        // N s_1408_1: branch s_1408_0 b4944 b1409
        if s_1408_0 {
            return block_4944(state, tracer, fn_state);
        } else {
            return block_1409(state, tracer, fn_state);
        };
    }
    fn block_1409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1409_0: const #0u : u8
        let s_1409_0: bool = false;
        // D s_1409_1: write-var gs#135106 <= s_1409_0
        fn_state.gs_135106 = s_1409_0;
        // N s_1409_2: jump b1410
        return block_1410(state, tracer, fn_state);
    }
    fn block_1410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1410_0: read-var gs#135106:u8
        let s_1410_0: bool = fn_state.gs_135106;
        // N s_1410_1: branch s_1410_0 b4943 b1411
        if s_1410_0 {
            return block_4943(state, tracer, fn_state);
        } else {
            return block_1411(state, tracer, fn_state);
        };
    }
    fn block_1411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1411_0: const #0u : u8
        let s_1411_0: bool = false;
        // D s_1411_1: write-var gs#135107 <= s_1411_0
        fn_state.gs_135107 = s_1411_0;
        // N s_1411_2: jump b1412
        return block_1412(state, tracer, fn_state);
    }
    fn block_1412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1412_0: read-var gs#135107:u8
        let s_1412_0: bool = fn_state.gs_135107;
        // N s_1412_1: branch s_1412_0 b4942 b1413
        if s_1412_0 {
            return block_4942(state, tracer, fn_state);
        } else {
            return block_1413(state, tracer, fn_state);
        };
    }
    fn block_1413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1413_0: read-var CRm:u8
        let s_1413_0: u8 = fn_state.CRm;
        // D s_1413_1: cast zx s_1413_0 -> bv
        let s_1413_1: Bits = Bits::new(s_1413_0 as u128, 4u16);
        // C s_1413_2: const #11u : u8
        let s_1413_2: u8 = 11;
        // C s_1413_3: cast zx s_1413_2 -> bv
        let s_1413_3: Bits = Bits::new(s_1413_2 as u128, 4u16);
        // D s_1413_4: cmp-eq s_1413_1 s_1413_3
        let s_1413_4: bool = ((s_1413_1) == (s_1413_3));
        // N s_1413_5: branch s_1413_4 b4941 b1414
        if s_1413_4 {
            return block_4941(state, tracer, fn_state);
        } else {
            return block_1414(state, tracer, fn_state);
        };
    }
    fn block_1414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1414_0: const #0u : u8
        let s_1414_0: bool = false;
        // D s_1414_1: write-var gs#135108 <= s_1414_0
        fn_state.gs_135108 = s_1414_0;
        // N s_1414_2: jump b1415
        return block_1415(state, tracer, fn_state);
    }
    fn block_1415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1415_0: read-var gs#135108:u8
        let s_1415_0: bool = fn_state.gs_135108;
        // N s_1415_1: branch s_1415_0 b4940 b1416
        if s_1415_0 {
            return block_4940(state, tracer, fn_state);
        } else {
            return block_1416(state, tracer, fn_state);
        };
    }
    fn block_1416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1416_0: const #0u : u8
        let s_1416_0: bool = false;
        // D s_1416_1: write-var gs#135109 <= s_1416_0
        fn_state.gs_135109 = s_1416_0;
        // N s_1416_2: jump b1417
        return block_1417(state, tracer, fn_state);
    }
    fn block_1417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1417_0: read-var gs#135109:u8
        let s_1417_0: bool = fn_state.gs_135109;
        // N s_1417_1: branch s_1417_0 b4939 b1418
        if s_1417_0 {
            return block_4939(state, tracer, fn_state);
        } else {
            return block_1418(state, tracer, fn_state);
        };
    }
    fn block_1418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1418_0: const #0u : u8
        let s_1418_0: bool = false;
        // D s_1418_1: write-var gs#135110 <= s_1418_0
        fn_state.gs_135110 = s_1418_0;
        // N s_1418_2: jump b1419
        return block_1419(state, tracer, fn_state);
    }
    fn block_1419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1419_0: read-var gs#135110:u8
        let s_1419_0: bool = fn_state.gs_135110;
        // N s_1419_1: branch s_1419_0 b4938 b1420
        if s_1419_0 {
            return block_4938(state, tracer, fn_state);
        } else {
            return block_1420(state, tracer, fn_state);
        };
    }
    fn block_1420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1420_0: const #0u : u8
        let s_1420_0: bool = false;
        // D s_1420_1: write-var gs#135111 <= s_1420_0
        fn_state.gs_135111 = s_1420_0;
        // N s_1420_2: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_1421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1421_0: read-var gs#135111:u8
        let s_1421_0: bool = fn_state.gs_135111;
        // N s_1421_1: branch s_1421_0 b4937 b1422
        if s_1421_0 {
            return block_4937(state, tracer, fn_state);
        } else {
            return block_1422(state, tracer, fn_state);
        };
    }
    fn block_1422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1422_0: read-var CRm:u8
        let s_1422_0: u8 = fn_state.CRm;
        // D s_1422_1: cast zx s_1422_0 -> bv
        let s_1422_1: Bits = Bits::new(s_1422_0 as u128, 4u16);
        // C s_1422_2: const #11u : u8
        let s_1422_2: u8 = 11;
        // C s_1422_3: cast zx s_1422_2 -> bv
        let s_1422_3: Bits = Bits::new(s_1422_2 as u128, 4u16);
        // D s_1422_4: cmp-eq s_1422_1 s_1422_3
        let s_1422_4: bool = ((s_1422_1) == (s_1422_3));
        // N s_1422_5: branch s_1422_4 b4936 b1423
        if s_1422_4 {
            return block_4936(state, tracer, fn_state);
        } else {
            return block_1423(state, tracer, fn_state);
        };
    }
    fn block_1423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1423_0: const #0u : u8
        let s_1423_0: bool = false;
        // D s_1423_1: write-var gs#135112 <= s_1423_0
        fn_state.gs_135112 = s_1423_0;
        // N s_1423_2: jump b1424
        return block_1424(state, tracer, fn_state);
    }
    fn block_1424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1424_0: read-var gs#135112:u8
        let s_1424_0: bool = fn_state.gs_135112;
        // N s_1424_1: branch s_1424_0 b4935 b1425
        if s_1424_0 {
            return block_4935(state, tracer, fn_state);
        } else {
            return block_1425(state, tracer, fn_state);
        };
    }
    fn block_1425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1425_0: const #0u : u8
        let s_1425_0: bool = false;
        // D s_1425_1: write-var gs#135113 <= s_1425_0
        fn_state.gs_135113 = s_1425_0;
        // N s_1425_2: jump b1426
        return block_1426(state, tracer, fn_state);
    }
    fn block_1426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1426_0: read-var gs#135113:u8
        let s_1426_0: bool = fn_state.gs_135113;
        // N s_1426_1: branch s_1426_0 b4934 b1427
        if s_1426_0 {
            return block_4934(state, tracer, fn_state);
        } else {
            return block_1427(state, tracer, fn_state);
        };
    }
    fn block_1427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1427_0: const #0u : u8
        let s_1427_0: bool = false;
        // D s_1427_1: write-var gs#135114 <= s_1427_0
        fn_state.gs_135114 = s_1427_0;
        // N s_1427_2: jump b1428
        return block_1428(state, tracer, fn_state);
    }
    fn block_1428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1428_0: read-var gs#135114:u8
        let s_1428_0: bool = fn_state.gs_135114;
        // N s_1428_1: branch s_1428_0 b4933 b1429
        if s_1428_0 {
            return block_4933(state, tracer, fn_state);
        } else {
            return block_1429(state, tracer, fn_state);
        };
    }
    fn block_1429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1429_0: const #0u : u8
        let s_1429_0: bool = false;
        // D s_1429_1: write-var gs#135115 <= s_1429_0
        fn_state.gs_135115 = s_1429_0;
        // N s_1429_2: jump b1430
        return block_1430(state, tracer, fn_state);
    }
    fn block_1430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1430_0: read-var gs#135115:u8
        let s_1430_0: bool = fn_state.gs_135115;
        // N s_1430_1: branch s_1430_0 b4932 b1431
        if s_1430_0 {
            return block_4932(state, tracer, fn_state);
        } else {
            return block_1431(state, tracer, fn_state);
        };
    }
    fn block_1431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1431_0: read-var CRm:u8
        let s_1431_0: u8 = fn_state.CRm;
        // D s_1431_1: cast zx s_1431_0 -> bv
        let s_1431_1: Bits = Bits::new(s_1431_0 as u128, 4u16);
        // C s_1431_2: const #10u : u8
        let s_1431_2: u8 = 10;
        // C s_1431_3: cast zx s_1431_2 -> bv
        let s_1431_3: Bits = Bits::new(s_1431_2 as u128, 4u16);
        // D s_1431_4: cmp-eq s_1431_1 s_1431_3
        let s_1431_4: bool = ((s_1431_1) == (s_1431_3));
        // N s_1431_5: branch s_1431_4 b4931 b1432
        if s_1431_4 {
            return block_4931(state, tracer, fn_state);
        } else {
            return block_1432(state, tracer, fn_state);
        };
    }
    fn block_1432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1432_0: const #0u : u8
        let s_1432_0: bool = false;
        // D s_1432_1: write-var gs#135116 <= s_1432_0
        fn_state.gs_135116 = s_1432_0;
        // N s_1432_2: jump b1433
        return block_1433(state, tracer, fn_state);
    }
    fn block_1433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1433_0: read-var gs#135116:u8
        let s_1433_0: bool = fn_state.gs_135116;
        // N s_1433_1: branch s_1433_0 b4930 b1434
        if s_1433_0 {
            return block_4930(state, tracer, fn_state);
        } else {
            return block_1434(state, tracer, fn_state);
        };
    }
    fn block_1434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1434_0: const #0u : u8
        let s_1434_0: bool = false;
        // D s_1434_1: write-var gs#135117 <= s_1434_0
        fn_state.gs_135117 = s_1434_0;
        // N s_1434_2: jump b1435
        return block_1435(state, tracer, fn_state);
    }
    fn block_1435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1435_0: read-var gs#135117:u8
        let s_1435_0: bool = fn_state.gs_135117;
        // N s_1435_1: branch s_1435_0 b4929 b1436
        if s_1435_0 {
            return block_4929(state, tracer, fn_state);
        } else {
            return block_1436(state, tracer, fn_state);
        };
    }
    fn block_1436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1436_0: const #0u : u8
        let s_1436_0: bool = false;
        // D s_1436_1: write-var gs#135118 <= s_1436_0
        fn_state.gs_135118 = s_1436_0;
        // N s_1436_2: jump b1437
        return block_1437(state, tracer, fn_state);
    }
    fn block_1437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1437_0: read-var gs#135118:u8
        let s_1437_0: bool = fn_state.gs_135118;
        // N s_1437_1: branch s_1437_0 b4928 b1438
        if s_1437_0 {
            return block_4928(state, tracer, fn_state);
        } else {
            return block_1438(state, tracer, fn_state);
        };
    }
    fn block_1438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1438_0: const #0u : u8
        let s_1438_0: bool = false;
        // D s_1438_1: write-var gs#135119 <= s_1438_0
        fn_state.gs_135119 = s_1438_0;
        // N s_1438_2: jump b1439
        return block_1439(state, tracer, fn_state);
    }
    fn block_1439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1439_0: read-var gs#135119:u8
        let s_1439_0: bool = fn_state.gs_135119;
        // N s_1439_1: branch s_1439_0 b4927 b1440
        if s_1439_0 {
            return block_4927(state, tracer, fn_state);
        } else {
            return block_1440(state, tracer, fn_state);
        };
    }
    fn block_1440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1440_0: read-var CRm:u8
        let s_1440_0: u8 = fn_state.CRm;
        // D s_1440_1: cast zx s_1440_0 -> bv
        let s_1440_1: Bits = Bits::new(s_1440_0 as u128, 4u16);
        // C s_1440_2: const #10u : u8
        let s_1440_2: u8 = 10;
        // C s_1440_3: cast zx s_1440_2 -> bv
        let s_1440_3: Bits = Bits::new(s_1440_2 as u128, 4u16);
        // D s_1440_4: cmp-eq s_1440_1 s_1440_3
        let s_1440_4: bool = ((s_1440_1) == (s_1440_3));
        // N s_1440_5: branch s_1440_4 b4926 b1441
        if s_1440_4 {
            return block_4926(state, tracer, fn_state);
        } else {
            return block_1441(state, tracer, fn_state);
        };
    }
    fn block_1441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1441_0: const #0u : u8
        let s_1441_0: bool = false;
        // D s_1441_1: write-var gs#135120 <= s_1441_0
        fn_state.gs_135120 = s_1441_0;
        // N s_1441_2: jump b1442
        return block_1442(state, tracer, fn_state);
    }
    fn block_1442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1442_0: read-var gs#135120:u8
        let s_1442_0: bool = fn_state.gs_135120;
        // N s_1442_1: branch s_1442_0 b4925 b1443
        if s_1442_0 {
            return block_4925(state, tracer, fn_state);
        } else {
            return block_1443(state, tracer, fn_state);
        };
    }
    fn block_1443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1443_0: const #0u : u8
        let s_1443_0: bool = false;
        // D s_1443_1: write-var gs#135121 <= s_1443_0
        fn_state.gs_135121 = s_1443_0;
        // N s_1443_2: jump b1444
        return block_1444(state, tracer, fn_state);
    }
    fn block_1444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1444_0: read-var gs#135121:u8
        let s_1444_0: bool = fn_state.gs_135121;
        // N s_1444_1: branch s_1444_0 b4924 b1445
        if s_1444_0 {
            return block_4924(state, tracer, fn_state);
        } else {
            return block_1445(state, tracer, fn_state);
        };
    }
    fn block_1445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1445_0: const #0u : u8
        let s_1445_0: bool = false;
        // D s_1445_1: write-var gs#135122 <= s_1445_0
        fn_state.gs_135122 = s_1445_0;
        // N s_1445_2: jump b1446
        return block_1446(state, tracer, fn_state);
    }
    fn block_1446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1446_0: read-var gs#135122:u8
        let s_1446_0: bool = fn_state.gs_135122;
        // N s_1446_1: branch s_1446_0 b4923 b1447
        if s_1446_0 {
            return block_4923(state, tracer, fn_state);
        } else {
            return block_1447(state, tracer, fn_state);
        };
    }
    fn block_1447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1447_0: const #0u : u8
        let s_1447_0: bool = false;
        // D s_1447_1: write-var gs#135123 <= s_1447_0
        fn_state.gs_135123 = s_1447_0;
        // N s_1447_2: jump b1448
        return block_1448(state, tracer, fn_state);
    }
    fn block_1448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1448_0: read-var gs#135123:u8
        let s_1448_0: bool = fn_state.gs_135123;
        // N s_1448_1: branch s_1448_0 b4922 b1449
        if s_1448_0 {
            return block_4922(state, tracer, fn_state);
        } else {
            return block_1449(state, tracer, fn_state);
        };
    }
    fn block_1449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1449_0: read-var CRm:u8
        let s_1449_0: u8 = fn_state.CRm;
        // D s_1449_1: cast zx s_1449_0 -> bv
        let s_1449_1: Bits = Bits::new(s_1449_0 as u128, 4u16);
        // C s_1449_2: const #10u : u8
        let s_1449_2: u8 = 10;
        // C s_1449_3: cast zx s_1449_2 -> bv
        let s_1449_3: Bits = Bits::new(s_1449_2 as u128, 4u16);
        // D s_1449_4: cmp-eq s_1449_1 s_1449_3
        let s_1449_4: bool = ((s_1449_1) == (s_1449_3));
        // N s_1449_5: branch s_1449_4 b4921 b1450
        if s_1449_4 {
            return block_4921(state, tracer, fn_state);
        } else {
            return block_1450(state, tracer, fn_state);
        };
    }
    fn block_1450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1450_0: const #0u : u8
        let s_1450_0: bool = false;
        // D s_1450_1: write-var gs#135124 <= s_1450_0
        fn_state.gs_135124 = s_1450_0;
        // N s_1450_2: jump b1451
        return block_1451(state, tracer, fn_state);
    }
    fn block_1451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1451_0: read-var gs#135124:u8
        let s_1451_0: bool = fn_state.gs_135124;
        // N s_1451_1: branch s_1451_0 b4920 b1452
        if s_1451_0 {
            return block_4920(state, tracer, fn_state);
        } else {
            return block_1452(state, tracer, fn_state);
        };
    }
    fn block_1452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1452_0: const #0u : u8
        let s_1452_0: bool = false;
        // D s_1452_1: write-var gs#135125 <= s_1452_0
        fn_state.gs_135125 = s_1452_0;
        // N s_1452_2: jump b1453
        return block_1453(state, tracer, fn_state);
    }
    fn block_1453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1453_0: read-var gs#135125:u8
        let s_1453_0: bool = fn_state.gs_135125;
        // N s_1453_1: branch s_1453_0 b4919 b1454
        if s_1453_0 {
            return block_4919(state, tracer, fn_state);
        } else {
            return block_1454(state, tracer, fn_state);
        };
    }
    fn block_1454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1454_0: const #0u : u8
        let s_1454_0: bool = false;
        // D s_1454_1: write-var gs#135126 <= s_1454_0
        fn_state.gs_135126 = s_1454_0;
        // N s_1454_2: jump b1455
        return block_1455(state, tracer, fn_state);
    }
    fn block_1455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1455_0: read-var gs#135126:u8
        let s_1455_0: bool = fn_state.gs_135126;
        // N s_1455_1: branch s_1455_0 b4918 b1456
        if s_1455_0 {
            return block_4918(state, tracer, fn_state);
        } else {
            return block_1456(state, tracer, fn_state);
        };
    }
    fn block_1456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1456_0: const #0u : u8
        let s_1456_0: bool = false;
        // D s_1456_1: write-var gs#135127 <= s_1456_0
        fn_state.gs_135127 = s_1456_0;
        // N s_1456_2: jump b1457
        return block_1457(state, tracer, fn_state);
    }
    fn block_1457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1457_0: read-var gs#135127:u8
        let s_1457_0: bool = fn_state.gs_135127;
        // N s_1457_1: branch s_1457_0 b4917 b1458
        if s_1457_0 {
            return block_4917(state, tracer, fn_state);
        } else {
            return block_1458(state, tracer, fn_state);
        };
    }
    fn block_1458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1458_0: read-var CRm:u8
        let s_1458_0: u8 = fn_state.CRm;
        // D s_1458_1: cast zx s_1458_0 -> bv
        let s_1458_1: Bits = Bits::new(s_1458_0 as u128, 4u16);
        // C s_1458_2: const #10u : u8
        let s_1458_2: u8 = 10;
        // C s_1458_3: cast zx s_1458_2 -> bv
        let s_1458_3: Bits = Bits::new(s_1458_2 as u128, 4u16);
        // D s_1458_4: cmp-eq s_1458_1 s_1458_3
        let s_1458_4: bool = ((s_1458_1) == (s_1458_3));
        // N s_1458_5: branch s_1458_4 b4916 b1459
        if s_1458_4 {
            return block_4916(state, tracer, fn_state);
        } else {
            return block_1459(state, tracer, fn_state);
        };
    }
    fn block_1459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1459_0: const #0u : u8
        let s_1459_0: bool = false;
        // D s_1459_1: write-var gs#135128 <= s_1459_0
        fn_state.gs_135128 = s_1459_0;
        // N s_1459_2: jump b1460
        return block_1460(state, tracer, fn_state);
    }
    fn block_1460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1460_0: read-var gs#135128:u8
        let s_1460_0: bool = fn_state.gs_135128;
        // N s_1460_1: branch s_1460_0 b4915 b1461
        if s_1460_0 {
            return block_4915(state, tracer, fn_state);
        } else {
            return block_1461(state, tracer, fn_state);
        };
    }
    fn block_1461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1461_0: const #0u : u8
        let s_1461_0: bool = false;
        // D s_1461_1: write-var gs#135129 <= s_1461_0
        fn_state.gs_135129 = s_1461_0;
        // N s_1461_2: jump b1462
        return block_1462(state, tracer, fn_state);
    }
    fn block_1462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1462_0: read-var gs#135129:u8
        let s_1462_0: bool = fn_state.gs_135129;
        // N s_1462_1: branch s_1462_0 b4914 b1463
        if s_1462_0 {
            return block_4914(state, tracer, fn_state);
        } else {
            return block_1463(state, tracer, fn_state);
        };
    }
    fn block_1463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1463_0: const #0u : u8
        let s_1463_0: bool = false;
        // D s_1463_1: write-var gs#135130 <= s_1463_0
        fn_state.gs_135130 = s_1463_0;
        // N s_1463_2: jump b1464
        return block_1464(state, tracer, fn_state);
    }
    fn block_1464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1464_0: read-var gs#135130:u8
        let s_1464_0: bool = fn_state.gs_135130;
        // N s_1464_1: branch s_1464_0 b4913 b1465
        if s_1464_0 {
            return block_4913(state, tracer, fn_state);
        } else {
            return block_1465(state, tracer, fn_state);
        };
    }
    fn block_1465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1465_0: const #0u : u8
        let s_1465_0: bool = false;
        // D s_1465_1: write-var gs#135131 <= s_1465_0
        fn_state.gs_135131 = s_1465_0;
        // N s_1465_2: jump b1466
        return block_1466(state, tracer, fn_state);
    }
    fn block_1466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1466_0: read-var gs#135131:u8
        let s_1466_0: bool = fn_state.gs_135131;
        // N s_1466_1: branch s_1466_0 b4912 b1467
        if s_1466_0 {
            return block_4912(state, tracer, fn_state);
        } else {
            return block_1467(state, tracer, fn_state);
        };
    }
    fn block_1467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1467_0: read-var CRm:u8
        let s_1467_0: u8 = fn_state.CRm;
        // D s_1467_1: cast zx s_1467_0 -> bv
        let s_1467_1: Bits = Bits::new(s_1467_0 as u128, 4u16);
        // C s_1467_2: const #10u : u8
        let s_1467_2: u8 = 10;
        // C s_1467_3: cast zx s_1467_2 -> bv
        let s_1467_3: Bits = Bits::new(s_1467_2 as u128, 4u16);
        // D s_1467_4: cmp-eq s_1467_1 s_1467_3
        let s_1467_4: bool = ((s_1467_1) == (s_1467_3));
        // N s_1467_5: branch s_1467_4 b4911 b1468
        if s_1467_4 {
            return block_4911(state, tracer, fn_state);
        } else {
            return block_1468(state, tracer, fn_state);
        };
    }
    fn block_1468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1468_0: const #0u : u8
        let s_1468_0: bool = false;
        // D s_1468_1: write-var gs#135132 <= s_1468_0
        fn_state.gs_135132 = s_1468_0;
        // N s_1468_2: jump b1469
        return block_1469(state, tracer, fn_state);
    }
    fn block_1469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1469_0: read-var gs#135132:u8
        let s_1469_0: bool = fn_state.gs_135132;
        // N s_1469_1: branch s_1469_0 b4910 b1470
        if s_1469_0 {
            return block_4910(state, tracer, fn_state);
        } else {
            return block_1470(state, tracer, fn_state);
        };
    }
    fn block_1470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1470_0: const #0u : u8
        let s_1470_0: bool = false;
        // D s_1470_1: write-var gs#135133 <= s_1470_0
        fn_state.gs_135133 = s_1470_0;
        // N s_1470_2: jump b1471
        return block_1471(state, tracer, fn_state);
    }
    fn block_1471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1471_0: read-var gs#135133:u8
        let s_1471_0: bool = fn_state.gs_135133;
        // N s_1471_1: branch s_1471_0 b4909 b1472
        if s_1471_0 {
            return block_4909(state, tracer, fn_state);
        } else {
            return block_1472(state, tracer, fn_state);
        };
    }
    fn block_1472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1472_0: const #0u : u8
        let s_1472_0: bool = false;
        // D s_1472_1: write-var gs#135134 <= s_1472_0
        fn_state.gs_135134 = s_1472_0;
        // N s_1472_2: jump b1473
        return block_1473(state, tracer, fn_state);
    }
    fn block_1473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1473_0: read-var gs#135134:u8
        let s_1473_0: bool = fn_state.gs_135134;
        // N s_1473_1: branch s_1473_0 b4908 b1474
        if s_1473_0 {
            return block_4908(state, tracer, fn_state);
        } else {
            return block_1474(state, tracer, fn_state);
        };
    }
    fn block_1474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1474_0: const #0u : u8
        let s_1474_0: bool = false;
        // D s_1474_1: write-var gs#135135 <= s_1474_0
        fn_state.gs_135135 = s_1474_0;
        // N s_1474_2: jump b1475
        return block_1475(state, tracer, fn_state);
    }
    fn block_1475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1475_0: read-var gs#135135:u8
        let s_1475_0: bool = fn_state.gs_135135;
        // N s_1475_1: branch s_1475_0 b4907 b1476
        if s_1475_0 {
            return block_4907(state, tracer, fn_state);
        } else {
            return block_1476(state, tracer, fn_state);
        };
    }
    fn block_1476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1476_0: read-var CRm:u8
        let s_1476_0: u8 = fn_state.CRm;
        // D s_1476_1: cast zx s_1476_0 -> bv
        let s_1476_1: Bits = Bits::new(s_1476_0 as u128, 4u16);
        // C s_1476_2: const #10u : u8
        let s_1476_2: u8 = 10;
        // C s_1476_3: cast zx s_1476_2 -> bv
        let s_1476_3: Bits = Bits::new(s_1476_2 as u128, 4u16);
        // D s_1476_4: cmp-eq s_1476_1 s_1476_3
        let s_1476_4: bool = ((s_1476_1) == (s_1476_3));
        // N s_1476_5: branch s_1476_4 b4906 b1477
        if s_1476_4 {
            return block_4906(state, tracer, fn_state);
        } else {
            return block_1477(state, tracer, fn_state);
        };
    }
    fn block_1477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1477_0: const #0u : u8
        let s_1477_0: bool = false;
        // D s_1477_1: write-var gs#135136 <= s_1477_0
        fn_state.gs_135136 = s_1477_0;
        // N s_1477_2: jump b1478
        return block_1478(state, tracer, fn_state);
    }
    fn block_1478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1478_0: read-var gs#135136:u8
        let s_1478_0: bool = fn_state.gs_135136;
        // N s_1478_1: branch s_1478_0 b4905 b1479
        if s_1478_0 {
            return block_4905(state, tracer, fn_state);
        } else {
            return block_1479(state, tracer, fn_state);
        };
    }
    fn block_1479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1479_0: const #0u : u8
        let s_1479_0: bool = false;
        // D s_1479_1: write-var gs#135137 <= s_1479_0
        fn_state.gs_135137 = s_1479_0;
        // N s_1479_2: jump b1480
        return block_1480(state, tracer, fn_state);
    }
    fn block_1480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1480_0: read-var gs#135137:u8
        let s_1480_0: bool = fn_state.gs_135137;
        // N s_1480_1: branch s_1480_0 b4904 b1481
        if s_1480_0 {
            return block_4904(state, tracer, fn_state);
        } else {
            return block_1481(state, tracer, fn_state);
        };
    }
    fn block_1481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1481_0: const #0u : u8
        let s_1481_0: bool = false;
        // D s_1481_1: write-var gs#135138 <= s_1481_0
        fn_state.gs_135138 = s_1481_0;
        // N s_1481_2: jump b1482
        return block_1482(state, tracer, fn_state);
    }
    fn block_1482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1482_0: read-var gs#135138:u8
        let s_1482_0: bool = fn_state.gs_135138;
        // N s_1482_1: branch s_1482_0 b4903 b1483
        if s_1482_0 {
            return block_4903(state, tracer, fn_state);
        } else {
            return block_1483(state, tracer, fn_state);
        };
    }
    fn block_1483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1483_0: const #0u : u8
        let s_1483_0: bool = false;
        // D s_1483_1: write-var gs#135139 <= s_1483_0
        fn_state.gs_135139 = s_1483_0;
        // N s_1483_2: jump b1484
        return block_1484(state, tracer, fn_state);
    }
    fn block_1484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1484_0: read-var gs#135139:u8
        let s_1484_0: bool = fn_state.gs_135139;
        // N s_1484_1: branch s_1484_0 b4902 b1485
        if s_1484_0 {
            return block_4902(state, tracer, fn_state);
        } else {
            return block_1485(state, tracer, fn_state);
        };
    }
    fn block_1485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1485_0: read-var CRm:u8
        let s_1485_0: u8 = fn_state.CRm;
        // D s_1485_1: cast zx s_1485_0 -> bv
        let s_1485_1: Bits = Bits::new(s_1485_0 as u128, 4u16);
        // C s_1485_2: const #10u : u8
        let s_1485_2: u8 = 10;
        // C s_1485_3: cast zx s_1485_2 -> bv
        let s_1485_3: Bits = Bits::new(s_1485_2 as u128, 4u16);
        // D s_1485_4: cmp-eq s_1485_1 s_1485_3
        let s_1485_4: bool = ((s_1485_1) == (s_1485_3));
        // N s_1485_5: branch s_1485_4 b4901 b1486
        if s_1485_4 {
            return block_4901(state, tracer, fn_state);
        } else {
            return block_1486(state, tracer, fn_state);
        };
    }
    fn block_1486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1486_0: const #0u : u8
        let s_1486_0: bool = false;
        // D s_1486_1: write-var gs#135140 <= s_1486_0
        fn_state.gs_135140 = s_1486_0;
        // N s_1486_2: jump b1487
        return block_1487(state, tracer, fn_state);
    }
    fn block_1487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1487_0: read-var gs#135140:u8
        let s_1487_0: bool = fn_state.gs_135140;
        // N s_1487_1: branch s_1487_0 b4900 b1488
        if s_1487_0 {
            return block_4900(state, tracer, fn_state);
        } else {
            return block_1488(state, tracer, fn_state);
        };
    }
    fn block_1488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1488_0: const #0u : u8
        let s_1488_0: bool = false;
        // D s_1488_1: write-var gs#135141 <= s_1488_0
        fn_state.gs_135141 = s_1488_0;
        // N s_1488_2: jump b1489
        return block_1489(state, tracer, fn_state);
    }
    fn block_1489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1489_0: read-var gs#135141:u8
        let s_1489_0: bool = fn_state.gs_135141;
        // N s_1489_1: branch s_1489_0 b4899 b1490
        if s_1489_0 {
            return block_4899(state, tracer, fn_state);
        } else {
            return block_1490(state, tracer, fn_state);
        };
    }
    fn block_1490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1490_0: const #0u : u8
        let s_1490_0: bool = false;
        // D s_1490_1: write-var gs#135142 <= s_1490_0
        fn_state.gs_135142 = s_1490_0;
        // N s_1490_2: jump b1491
        return block_1491(state, tracer, fn_state);
    }
    fn block_1491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1491_0: read-var gs#135142:u8
        let s_1491_0: bool = fn_state.gs_135142;
        // N s_1491_1: branch s_1491_0 b4898 b1492
        if s_1491_0 {
            return block_4898(state, tracer, fn_state);
        } else {
            return block_1492(state, tracer, fn_state);
        };
    }
    fn block_1492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1492_0: const #0u : u8
        let s_1492_0: bool = false;
        // D s_1492_1: write-var gs#135143 <= s_1492_0
        fn_state.gs_135143 = s_1492_0;
        // N s_1492_2: jump b1493
        return block_1493(state, tracer, fn_state);
    }
    fn block_1493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1493_0: read-var gs#135143:u8
        let s_1493_0: bool = fn_state.gs_135143;
        // N s_1493_1: branch s_1493_0 b4897 b1494
        if s_1493_0 {
            return block_4897(state, tracer, fn_state);
        } else {
            return block_1494(state, tracer, fn_state);
        };
    }
    fn block_1494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1494_0: read-var CRm:u8
        let s_1494_0: u8 = fn_state.CRm;
        // D s_1494_1: cast zx s_1494_0 -> bv
        let s_1494_1: Bits = Bits::new(s_1494_0 as u128, 4u16);
        // C s_1494_2: const #10u : u8
        let s_1494_2: u8 = 10;
        // C s_1494_3: cast zx s_1494_2 -> bv
        let s_1494_3: Bits = Bits::new(s_1494_2 as u128, 4u16);
        // D s_1494_4: cmp-eq s_1494_1 s_1494_3
        let s_1494_4: bool = ((s_1494_1) == (s_1494_3));
        // N s_1494_5: branch s_1494_4 b4896 b1495
        if s_1494_4 {
            return block_4896(state, tracer, fn_state);
        } else {
            return block_1495(state, tracer, fn_state);
        };
    }
    fn block_1495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1495_0: const #0u : u8
        let s_1495_0: bool = false;
        // D s_1495_1: write-var gs#135144 <= s_1495_0
        fn_state.gs_135144 = s_1495_0;
        // N s_1495_2: jump b1496
        return block_1496(state, tracer, fn_state);
    }
    fn block_1496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1496_0: read-var gs#135144:u8
        let s_1496_0: bool = fn_state.gs_135144;
        // N s_1496_1: branch s_1496_0 b4895 b1497
        if s_1496_0 {
            return block_4895(state, tracer, fn_state);
        } else {
            return block_1497(state, tracer, fn_state);
        };
    }
    fn block_1497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1497_0: const #0u : u8
        let s_1497_0: bool = false;
        // D s_1497_1: write-var gs#135145 <= s_1497_0
        fn_state.gs_135145 = s_1497_0;
        // N s_1497_2: jump b1498
        return block_1498(state, tracer, fn_state);
    }
    fn block_1498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1498_0: read-var gs#135145:u8
        let s_1498_0: bool = fn_state.gs_135145;
        // N s_1498_1: branch s_1498_0 b4894 b1499
        if s_1498_0 {
            return block_4894(state, tracer, fn_state);
        } else {
            return block_1499(state, tracer, fn_state);
        };
    }
    fn block_1499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1499_0: const #0u : u8
        let s_1499_0: bool = false;
        // D s_1499_1: write-var gs#135146 <= s_1499_0
        fn_state.gs_135146 = s_1499_0;
        // N s_1499_2: jump b1500
        return block_1500(state, tracer, fn_state);
    }
    fn block_1500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1500_0: read-var gs#135146:u8
        let s_1500_0: bool = fn_state.gs_135146;
        // N s_1500_1: branch s_1500_0 b4893 b1501
        if s_1500_0 {
            return block_4893(state, tracer, fn_state);
        } else {
            return block_1501(state, tracer, fn_state);
        };
    }
    fn block_1501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1501_0: const #0u : u8
        let s_1501_0: bool = false;
        // D s_1501_1: write-var gs#135147 <= s_1501_0
        fn_state.gs_135147 = s_1501_0;
        // N s_1501_2: jump b1502
        return block_1502(state, tracer, fn_state);
    }
    fn block_1502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1502_0: read-var gs#135147:u8
        let s_1502_0: bool = fn_state.gs_135147;
        // N s_1502_1: branch s_1502_0 b4892 b1503
        if s_1502_0 {
            return block_4892(state, tracer, fn_state);
        } else {
            return block_1503(state, tracer, fn_state);
        };
    }
    fn block_1503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1503_0: read-var CRm:u8
        let s_1503_0: u8 = fn_state.CRm;
        // D s_1503_1: cast zx s_1503_0 -> bv
        let s_1503_1: Bits = Bits::new(s_1503_0 as u128, 4u16);
        // C s_1503_2: const #9u : u8
        let s_1503_2: u8 = 9;
        // C s_1503_3: cast zx s_1503_2 -> bv
        let s_1503_3: Bits = Bits::new(s_1503_2 as u128, 4u16);
        // D s_1503_4: cmp-eq s_1503_1 s_1503_3
        let s_1503_4: bool = ((s_1503_1) == (s_1503_3));
        // N s_1503_5: branch s_1503_4 b4891 b1504
        if s_1503_4 {
            return block_4891(state, tracer, fn_state);
        } else {
            return block_1504(state, tracer, fn_state);
        };
    }
    fn block_1504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1504_0: const #0u : u8
        let s_1504_0: bool = false;
        // D s_1504_1: write-var gs#135148 <= s_1504_0
        fn_state.gs_135148 = s_1504_0;
        // N s_1504_2: jump b1505
        return block_1505(state, tracer, fn_state);
    }
    fn block_1505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1505_0: read-var gs#135148:u8
        let s_1505_0: bool = fn_state.gs_135148;
        // N s_1505_1: branch s_1505_0 b4890 b1506
        if s_1505_0 {
            return block_4890(state, tracer, fn_state);
        } else {
            return block_1506(state, tracer, fn_state);
        };
    }
    fn block_1506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1506_0: const #0u : u8
        let s_1506_0: bool = false;
        // D s_1506_1: write-var gs#135149 <= s_1506_0
        fn_state.gs_135149 = s_1506_0;
        // N s_1506_2: jump b1507
        return block_1507(state, tracer, fn_state);
    }
    fn block_1507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1507_0: read-var gs#135149:u8
        let s_1507_0: bool = fn_state.gs_135149;
        // N s_1507_1: branch s_1507_0 b4889 b1508
        if s_1507_0 {
            return block_4889(state, tracer, fn_state);
        } else {
            return block_1508(state, tracer, fn_state);
        };
    }
    fn block_1508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1508_0: const #0u : u8
        let s_1508_0: bool = false;
        // D s_1508_1: write-var gs#135150 <= s_1508_0
        fn_state.gs_135150 = s_1508_0;
        // N s_1508_2: jump b1509
        return block_1509(state, tracer, fn_state);
    }
    fn block_1509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1509_0: read-var gs#135150:u8
        let s_1509_0: bool = fn_state.gs_135150;
        // N s_1509_1: branch s_1509_0 b4888 b1510
        if s_1509_0 {
            return block_4888(state, tracer, fn_state);
        } else {
            return block_1510(state, tracer, fn_state);
        };
    }
    fn block_1510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1510_0: const #0u : u8
        let s_1510_0: bool = false;
        // D s_1510_1: write-var gs#135151 <= s_1510_0
        fn_state.gs_135151 = s_1510_0;
        // N s_1510_2: jump b1511
        return block_1511(state, tracer, fn_state);
    }
    fn block_1511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1511_0: read-var gs#135151:u8
        let s_1511_0: bool = fn_state.gs_135151;
        // N s_1511_1: branch s_1511_0 b4887 b1512
        if s_1511_0 {
            return block_4887(state, tracer, fn_state);
        } else {
            return block_1512(state, tracer, fn_state);
        };
    }
    fn block_1512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1512_0: read-var CRm:u8
        let s_1512_0: u8 = fn_state.CRm;
        // D s_1512_1: cast zx s_1512_0 -> bv
        let s_1512_1: Bits = Bits::new(s_1512_0 as u128, 4u16);
        // C s_1512_2: const #9u : u8
        let s_1512_2: u8 = 9;
        // C s_1512_3: cast zx s_1512_2 -> bv
        let s_1512_3: Bits = Bits::new(s_1512_2 as u128, 4u16);
        // D s_1512_4: cmp-eq s_1512_1 s_1512_3
        let s_1512_4: bool = ((s_1512_1) == (s_1512_3));
        // N s_1512_5: branch s_1512_4 b4886 b1513
        if s_1512_4 {
            return block_4886(state, tracer, fn_state);
        } else {
            return block_1513(state, tracer, fn_state);
        };
    }
    fn block_1513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1513_0: const #0u : u8
        let s_1513_0: bool = false;
        // D s_1513_1: write-var gs#135152 <= s_1513_0
        fn_state.gs_135152 = s_1513_0;
        // N s_1513_2: jump b1514
        return block_1514(state, tracer, fn_state);
    }
    fn block_1514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1514_0: read-var gs#135152:u8
        let s_1514_0: bool = fn_state.gs_135152;
        // N s_1514_1: branch s_1514_0 b4885 b1515
        if s_1514_0 {
            return block_4885(state, tracer, fn_state);
        } else {
            return block_1515(state, tracer, fn_state);
        };
    }
    fn block_1515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1515_0: const #0u : u8
        let s_1515_0: bool = false;
        // D s_1515_1: write-var gs#135153 <= s_1515_0
        fn_state.gs_135153 = s_1515_0;
        // N s_1515_2: jump b1516
        return block_1516(state, tracer, fn_state);
    }
    fn block_1516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1516_0: read-var gs#135153:u8
        let s_1516_0: bool = fn_state.gs_135153;
        // N s_1516_1: branch s_1516_0 b4884 b1517
        if s_1516_0 {
            return block_4884(state, tracer, fn_state);
        } else {
            return block_1517(state, tracer, fn_state);
        };
    }
    fn block_1517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1517_0: const #0u : u8
        let s_1517_0: bool = false;
        // D s_1517_1: write-var gs#135154 <= s_1517_0
        fn_state.gs_135154 = s_1517_0;
        // N s_1517_2: jump b1518
        return block_1518(state, tracer, fn_state);
    }
    fn block_1518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1518_0: read-var gs#135154:u8
        let s_1518_0: bool = fn_state.gs_135154;
        // N s_1518_1: branch s_1518_0 b4883 b1519
        if s_1518_0 {
            return block_4883(state, tracer, fn_state);
        } else {
            return block_1519(state, tracer, fn_state);
        };
    }
    fn block_1519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1519_0: const #0u : u8
        let s_1519_0: bool = false;
        // D s_1519_1: write-var gs#135155 <= s_1519_0
        fn_state.gs_135155 = s_1519_0;
        // N s_1519_2: jump b1520
        return block_1520(state, tracer, fn_state);
    }
    fn block_1520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1520_0: read-var gs#135155:u8
        let s_1520_0: bool = fn_state.gs_135155;
        // N s_1520_1: branch s_1520_0 b4882 b1521
        if s_1520_0 {
            return block_4882(state, tracer, fn_state);
        } else {
            return block_1521(state, tracer, fn_state);
        };
    }
    fn block_1521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1521_0: read-var CRm:u8
        let s_1521_0: u8 = fn_state.CRm;
        // D s_1521_1: cast zx s_1521_0 -> bv
        let s_1521_1: Bits = Bits::new(s_1521_0 as u128, 4u16);
        // C s_1521_2: const #9u : u8
        let s_1521_2: u8 = 9;
        // C s_1521_3: cast zx s_1521_2 -> bv
        let s_1521_3: Bits = Bits::new(s_1521_2 as u128, 4u16);
        // D s_1521_4: cmp-eq s_1521_1 s_1521_3
        let s_1521_4: bool = ((s_1521_1) == (s_1521_3));
        // N s_1521_5: branch s_1521_4 b4881 b1522
        if s_1521_4 {
            return block_4881(state, tracer, fn_state);
        } else {
            return block_1522(state, tracer, fn_state);
        };
    }
    fn block_1522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1522_0: const #0u : u8
        let s_1522_0: bool = false;
        // D s_1522_1: write-var gs#135156 <= s_1522_0
        fn_state.gs_135156 = s_1522_0;
        // N s_1522_2: jump b1523
        return block_1523(state, tracer, fn_state);
    }
    fn block_1523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1523_0: read-var gs#135156:u8
        let s_1523_0: bool = fn_state.gs_135156;
        // N s_1523_1: branch s_1523_0 b4880 b1524
        if s_1523_0 {
            return block_4880(state, tracer, fn_state);
        } else {
            return block_1524(state, tracer, fn_state);
        };
    }
    fn block_1524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1524_0: const #0u : u8
        let s_1524_0: bool = false;
        // D s_1524_1: write-var gs#135157 <= s_1524_0
        fn_state.gs_135157 = s_1524_0;
        // N s_1524_2: jump b1525
        return block_1525(state, tracer, fn_state);
    }
    fn block_1525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1525_0: read-var gs#135157:u8
        let s_1525_0: bool = fn_state.gs_135157;
        // N s_1525_1: branch s_1525_0 b4879 b1526
        if s_1525_0 {
            return block_4879(state, tracer, fn_state);
        } else {
            return block_1526(state, tracer, fn_state);
        };
    }
    fn block_1526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1526_0: const #0u : u8
        let s_1526_0: bool = false;
        // D s_1526_1: write-var gs#135158 <= s_1526_0
        fn_state.gs_135158 = s_1526_0;
        // N s_1526_2: jump b1527
        return block_1527(state, tracer, fn_state);
    }
    fn block_1527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1527_0: read-var gs#135158:u8
        let s_1527_0: bool = fn_state.gs_135158;
        // N s_1527_1: branch s_1527_0 b4878 b1528
        if s_1527_0 {
            return block_4878(state, tracer, fn_state);
        } else {
            return block_1528(state, tracer, fn_state);
        };
    }
    fn block_1528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1528_0: const #0u : u8
        let s_1528_0: bool = false;
        // D s_1528_1: write-var gs#135159 <= s_1528_0
        fn_state.gs_135159 = s_1528_0;
        // N s_1528_2: jump b1529
        return block_1529(state, tracer, fn_state);
    }
    fn block_1529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1529_0: read-var gs#135159:u8
        let s_1529_0: bool = fn_state.gs_135159;
        // N s_1529_1: branch s_1529_0 b4877 b1530
        if s_1529_0 {
            return block_4877(state, tracer, fn_state);
        } else {
            return block_1530(state, tracer, fn_state);
        };
    }
    fn block_1530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1530_0: read-var CRm:u8
        let s_1530_0: u8 = fn_state.CRm;
        // D s_1530_1: cast zx s_1530_0 -> bv
        let s_1530_1: Bits = Bits::new(s_1530_0 as u128, 4u16);
        // C s_1530_2: const #9u : u8
        let s_1530_2: u8 = 9;
        // C s_1530_3: cast zx s_1530_2 -> bv
        let s_1530_3: Bits = Bits::new(s_1530_2 as u128, 4u16);
        // D s_1530_4: cmp-eq s_1530_1 s_1530_3
        let s_1530_4: bool = ((s_1530_1) == (s_1530_3));
        // N s_1530_5: branch s_1530_4 b4876 b1531
        if s_1530_4 {
            return block_4876(state, tracer, fn_state);
        } else {
            return block_1531(state, tracer, fn_state);
        };
    }
    fn block_1531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1531_0: const #0u : u8
        let s_1531_0: bool = false;
        // D s_1531_1: write-var gs#135160 <= s_1531_0
        fn_state.gs_135160 = s_1531_0;
        // N s_1531_2: jump b1532
        return block_1532(state, tracer, fn_state);
    }
    fn block_1532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1532_0: read-var gs#135160:u8
        let s_1532_0: bool = fn_state.gs_135160;
        // N s_1532_1: branch s_1532_0 b4875 b1533
        if s_1532_0 {
            return block_4875(state, tracer, fn_state);
        } else {
            return block_1533(state, tracer, fn_state);
        };
    }
    fn block_1533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1533_0: const #0u : u8
        let s_1533_0: bool = false;
        // D s_1533_1: write-var gs#135161 <= s_1533_0
        fn_state.gs_135161 = s_1533_0;
        // N s_1533_2: jump b1534
        return block_1534(state, tracer, fn_state);
    }
    fn block_1534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1534_0: read-var gs#135161:u8
        let s_1534_0: bool = fn_state.gs_135161;
        // N s_1534_1: branch s_1534_0 b4874 b1535
        if s_1534_0 {
            return block_4874(state, tracer, fn_state);
        } else {
            return block_1535(state, tracer, fn_state);
        };
    }
    fn block_1535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1535_0: const #0u : u8
        let s_1535_0: bool = false;
        // D s_1535_1: write-var gs#135162 <= s_1535_0
        fn_state.gs_135162 = s_1535_0;
        // N s_1535_2: jump b1536
        return block_1536(state, tracer, fn_state);
    }
    fn block_1536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1536_0: read-var gs#135162:u8
        let s_1536_0: bool = fn_state.gs_135162;
        // N s_1536_1: branch s_1536_0 b4873 b1537
        if s_1536_0 {
            return block_4873(state, tracer, fn_state);
        } else {
            return block_1537(state, tracer, fn_state);
        };
    }
    fn block_1537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1537_0: const #0u : u8
        let s_1537_0: bool = false;
        // D s_1537_1: write-var gs#135163 <= s_1537_0
        fn_state.gs_135163 = s_1537_0;
        // N s_1537_2: jump b1538
        return block_1538(state, tracer, fn_state);
    }
    fn block_1538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1538_0: read-var gs#135163:u8
        let s_1538_0: bool = fn_state.gs_135163;
        // N s_1538_1: branch s_1538_0 b4872 b1539
        if s_1538_0 {
            return block_4872(state, tracer, fn_state);
        } else {
            return block_1539(state, tracer, fn_state);
        };
    }
    fn block_1539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1539_0: read-var CRm:u8
        let s_1539_0: u8 = fn_state.CRm;
        // D s_1539_1: cast zx s_1539_0 -> bv
        let s_1539_1: Bits = Bits::new(s_1539_0 as u128, 4u16);
        // C s_1539_2: const #9u : u8
        let s_1539_2: u8 = 9;
        // C s_1539_3: cast zx s_1539_2 -> bv
        let s_1539_3: Bits = Bits::new(s_1539_2 as u128, 4u16);
        // D s_1539_4: cmp-eq s_1539_1 s_1539_3
        let s_1539_4: bool = ((s_1539_1) == (s_1539_3));
        // N s_1539_5: branch s_1539_4 b4871 b1540
        if s_1539_4 {
            return block_4871(state, tracer, fn_state);
        } else {
            return block_1540(state, tracer, fn_state);
        };
    }
    fn block_1540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1540_0: const #0u : u8
        let s_1540_0: bool = false;
        // D s_1540_1: write-var gs#135164 <= s_1540_0
        fn_state.gs_135164 = s_1540_0;
        // N s_1540_2: jump b1541
        return block_1541(state, tracer, fn_state);
    }
    fn block_1541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1541_0: read-var gs#135164:u8
        let s_1541_0: bool = fn_state.gs_135164;
        // N s_1541_1: branch s_1541_0 b4870 b1542
        if s_1541_0 {
            return block_4870(state, tracer, fn_state);
        } else {
            return block_1542(state, tracer, fn_state);
        };
    }
    fn block_1542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1542_0: const #0u : u8
        let s_1542_0: bool = false;
        // D s_1542_1: write-var gs#135165 <= s_1542_0
        fn_state.gs_135165 = s_1542_0;
        // N s_1542_2: jump b1543
        return block_1543(state, tracer, fn_state);
    }
    fn block_1543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1543_0: read-var gs#135165:u8
        let s_1543_0: bool = fn_state.gs_135165;
        // N s_1543_1: branch s_1543_0 b4869 b1544
        if s_1543_0 {
            return block_4869(state, tracer, fn_state);
        } else {
            return block_1544(state, tracer, fn_state);
        };
    }
    fn block_1544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1544_0: const #0u : u8
        let s_1544_0: bool = false;
        // D s_1544_1: write-var gs#135166 <= s_1544_0
        fn_state.gs_135166 = s_1544_0;
        // N s_1544_2: jump b1545
        return block_1545(state, tracer, fn_state);
    }
    fn block_1545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1545_0: read-var gs#135166:u8
        let s_1545_0: bool = fn_state.gs_135166;
        // N s_1545_1: branch s_1545_0 b4868 b1546
        if s_1545_0 {
            return block_4868(state, tracer, fn_state);
        } else {
            return block_1546(state, tracer, fn_state);
        };
    }
    fn block_1546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1546_0: const #0u : u8
        let s_1546_0: bool = false;
        // D s_1546_1: write-var gs#135167 <= s_1546_0
        fn_state.gs_135167 = s_1546_0;
        // N s_1546_2: jump b1547
        return block_1547(state, tracer, fn_state);
    }
    fn block_1547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1547_0: read-var gs#135167:u8
        let s_1547_0: bool = fn_state.gs_135167;
        // N s_1547_1: branch s_1547_0 b4867 b1548
        if s_1547_0 {
            return block_4867(state, tracer, fn_state);
        } else {
            return block_1548(state, tracer, fn_state);
        };
    }
    fn block_1548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1548_0: read-var CRm:u8
        let s_1548_0: u8 = fn_state.CRm;
        // D s_1548_1: cast zx s_1548_0 -> bv
        let s_1548_1: Bits = Bits::new(s_1548_0 as u128, 4u16);
        // C s_1548_2: const #9u : u8
        let s_1548_2: u8 = 9;
        // C s_1548_3: cast zx s_1548_2 -> bv
        let s_1548_3: Bits = Bits::new(s_1548_2 as u128, 4u16);
        // D s_1548_4: cmp-eq s_1548_1 s_1548_3
        let s_1548_4: bool = ((s_1548_1) == (s_1548_3));
        // N s_1548_5: branch s_1548_4 b4866 b1549
        if s_1548_4 {
            return block_4866(state, tracer, fn_state);
        } else {
            return block_1549(state, tracer, fn_state);
        };
    }
    fn block_1549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1549_0: const #0u : u8
        let s_1549_0: bool = false;
        // D s_1549_1: write-var gs#135168 <= s_1549_0
        fn_state.gs_135168 = s_1549_0;
        // N s_1549_2: jump b1550
        return block_1550(state, tracer, fn_state);
    }
    fn block_1550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1550_0: read-var gs#135168:u8
        let s_1550_0: bool = fn_state.gs_135168;
        // N s_1550_1: branch s_1550_0 b4865 b1551
        if s_1550_0 {
            return block_4865(state, tracer, fn_state);
        } else {
            return block_1551(state, tracer, fn_state);
        };
    }
    fn block_1551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1551_0: const #0u : u8
        let s_1551_0: bool = false;
        // D s_1551_1: write-var gs#135169 <= s_1551_0
        fn_state.gs_135169 = s_1551_0;
        // N s_1551_2: jump b1552
        return block_1552(state, tracer, fn_state);
    }
    fn block_1552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1552_0: read-var gs#135169:u8
        let s_1552_0: bool = fn_state.gs_135169;
        // N s_1552_1: branch s_1552_0 b4864 b1553
        if s_1552_0 {
            return block_4864(state, tracer, fn_state);
        } else {
            return block_1553(state, tracer, fn_state);
        };
    }
    fn block_1553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1553_0: const #0u : u8
        let s_1553_0: bool = false;
        // D s_1553_1: write-var gs#135170 <= s_1553_0
        fn_state.gs_135170 = s_1553_0;
        // N s_1553_2: jump b1554
        return block_1554(state, tracer, fn_state);
    }
    fn block_1554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1554_0: read-var gs#135170:u8
        let s_1554_0: bool = fn_state.gs_135170;
        // N s_1554_1: branch s_1554_0 b4863 b1555
        if s_1554_0 {
            return block_4863(state, tracer, fn_state);
        } else {
            return block_1555(state, tracer, fn_state);
        };
    }
    fn block_1555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1555_0: const #0u : u8
        let s_1555_0: bool = false;
        // D s_1555_1: write-var gs#135171 <= s_1555_0
        fn_state.gs_135171 = s_1555_0;
        // N s_1555_2: jump b1556
        return block_1556(state, tracer, fn_state);
    }
    fn block_1556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1556_0: read-var gs#135171:u8
        let s_1556_0: bool = fn_state.gs_135171;
        // N s_1556_1: branch s_1556_0 b4862 b1557
        if s_1556_0 {
            return block_4862(state, tracer, fn_state);
        } else {
            return block_1557(state, tracer, fn_state);
        };
    }
    fn block_1557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1557_0: read-var CRm:u8
        let s_1557_0: u8 = fn_state.CRm;
        // D s_1557_1: cast zx s_1557_0 -> bv
        let s_1557_1: Bits = Bits::new(s_1557_0 as u128, 4u16);
        // C s_1557_2: const #9u : u8
        let s_1557_2: u8 = 9;
        // C s_1557_3: cast zx s_1557_2 -> bv
        let s_1557_3: Bits = Bits::new(s_1557_2 as u128, 4u16);
        // D s_1557_4: cmp-eq s_1557_1 s_1557_3
        let s_1557_4: bool = ((s_1557_1) == (s_1557_3));
        // N s_1557_5: branch s_1557_4 b4861 b1558
        if s_1557_4 {
            return block_4861(state, tracer, fn_state);
        } else {
            return block_1558(state, tracer, fn_state);
        };
    }
    fn block_1558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1558_0: const #0u : u8
        let s_1558_0: bool = false;
        // D s_1558_1: write-var gs#135172 <= s_1558_0
        fn_state.gs_135172 = s_1558_0;
        // N s_1558_2: jump b1559
        return block_1559(state, tracer, fn_state);
    }
    fn block_1559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1559_0: read-var gs#135172:u8
        let s_1559_0: bool = fn_state.gs_135172;
        // N s_1559_1: branch s_1559_0 b4860 b1560
        if s_1559_0 {
            return block_4860(state, tracer, fn_state);
        } else {
            return block_1560(state, tracer, fn_state);
        };
    }
    fn block_1560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1560_0: const #0u : u8
        let s_1560_0: bool = false;
        // D s_1560_1: write-var gs#135173 <= s_1560_0
        fn_state.gs_135173 = s_1560_0;
        // N s_1560_2: jump b1561
        return block_1561(state, tracer, fn_state);
    }
    fn block_1561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1561_0: read-var gs#135173:u8
        let s_1561_0: bool = fn_state.gs_135173;
        // N s_1561_1: branch s_1561_0 b4859 b1562
        if s_1561_0 {
            return block_4859(state, tracer, fn_state);
        } else {
            return block_1562(state, tracer, fn_state);
        };
    }
    fn block_1562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1562_0: const #0u : u8
        let s_1562_0: bool = false;
        // D s_1562_1: write-var gs#135174 <= s_1562_0
        fn_state.gs_135174 = s_1562_0;
        // N s_1562_2: jump b1563
        return block_1563(state, tracer, fn_state);
    }
    fn block_1563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1563_0: read-var gs#135174:u8
        let s_1563_0: bool = fn_state.gs_135174;
        // N s_1563_1: branch s_1563_0 b4858 b1564
        if s_1563_0 {
            return block_4858(state, tracer, fn_state);
        } else {
            return block_1564(state, tracer, fn_state);
        };
    }
    fn block_1564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1564_0: const #0u : u8
        let s_1564_0: bool = false;
        // D s_1564_1: write-var gs#135175 <= s_1564_0
        fn_state.gs_135175 = s_1564_0;
        // N s_1564_2: jump b1565
        return block_1565(state, tracer, fn_state);
    }
    fn block_1565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1565_0: read-var gs#135175:u8
        let s_1565_0: bool = fn_state.gs_135175;
        // N s_1565_1: branch s_1565_0 b4857 b1566
        if s_1565_0 {
            return block_4857(state, tracer, fn_state);
        } else {
            return block_1566(state, tracer, fn_state);
        };
    }
    fn block_1566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1566_0: read-var CRm:u8
        let s_1566_0: u8 = fn_state.CRm;
        // D s_1566_1: cast zx s_1566_0 -> bv
        let s_1566_1: Bits = Bits::new(s_1566_0 as u128, 4u16);
        // C s_1566_2: const #9u : u8
        let s_1566_2: u8 = 9;
        // C s_1566_3: cast zx s_1566_2 -> bv
        let s_1566_3: Bits = Bits::new(s_1566_2 as u128, 4u16);
        // D s_1566_4: cmp-eq s_1566_1 s_1566_3
        let s_1566_4: bool = ((s_1566_1) == (s_1566_3));
        // N s_1566_5: branch s_1566_4 b4856 b1567
        if s_1566_4 {
            return block_4856(state, tracer, fn_state);
        } else {
            return block_1567(state, tracer, fn_state);
        };
    }
    fn block_1567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1567_0: const #0u : u8
        let s_1567_0: bool = false;
        // D s_1567_1: write-var gs#135176 <= s_1567_0
        fn_state.gs_135176 = s_1567_0;
        // N s_1567_2: jump b1568
        return block_1568(state, tracer, fn_state);
    }
    fn block_1568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1568_0: read-var gs#135176:u8
        let s_1568_0: bool = fn_state.gs_135176;
        // N s_1568_1: branch s_1568_0 b4855 b1569
        if s_1568_0 {
            return block_4855(state, tracer, fn_state);
        } else {
            return block_1569(state, tracer, fn_state);
        };
    }
    fn block_1569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1569_0: const #0u : u8
        let s_1569_0: bool = false;
        // D s_1569_1: write-var gs#135177 <= s_1569_0
        fn_state.gs_135177 = s_1569_0;
        // N s_1569_2: jump b1570
        return block_1570(state, tracer, fn_state);
    }
    fn block_1570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1570_0: read-var gs#135177:u8
        let s_1570_0: bool = fn_state.gs_135177;
        // N s_1570_1: branch s_1570_0 b4854 b1571
        if s_1570_0 {
            return block_4854(state, tracer, fn_state);
        } else {
            return block_1571(state, tracer, fn_state);
        };
    }
    fn block_1571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1571_0: const #0u : u8
        let s_1571_0: bool = false;
        // D s_1571_1: write-var gs#135178 <= s_1571_0
        fn_state.gs_135178 = s_1571_0;
        // N s_1571_2: jump b1572
        return block_1572(state, tracer, fn_state);
    }
    fn block_1572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1572_0: read-var gs#135178:u8
        let s_1572_0: bool = fn_state.gs_135178;
        // N s_1572_1: branch s_1572_0 b4853 b1573
        if s_1572_0 {
            return block_4853(state, tracer, fn_state);
        } else {
            return block_1573(state, tracer, fn_state);
        };
    }
    fn block_1573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1573_0: const #0u : u8
        let s_1573_0: bool = false;
        // D s_1573_1: write-var gs#135179 <= s_1573_0
        fn_state.gs_135179 = s_1573_0;
        // N s_1573_2: jump b1574
        return block_1574(state, tracer, fn_state);
    }
    fn block_1574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1574_0: read-var gs#135179:u8
        let s_1574_0: bool = fn_state.gs_135179;
        // N s_1574_1: branch s_1574_0 b4852 b1575
        if s_1574_0 {
            return block_4852(state, tracer, fn_state);
        } else {
            return block_1575(state, tracer, fn_state);
        };
    }
    fn block_1575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1575_0: read-var CRm:u8
        let s_1575_0: u8 = fn_state.CRm;
        // D s_1575_1: cast zx s_1575_0 -> bv
        let s_1575_1: Bits = Bits::new(s_1575_0 as u128, 4u16);
        // C s_1575_2: const #8u : u8
        let s_1575_2: u8 = 8;
        // C s_1575_3: cast zx s_1575_2 -> bv
        let s_1575_3: Bits = Bits::new(s_1575_2 as u128, 4u16);
        // D s_1575_4: cmp-eq s_1575_1 s_1575_3
        let s_1575_4: bool = ((s_1575_1) == (s_1575_3));
        // N s_1575_5: branch s_1575_4 b4851 b1576
        if s_1575_4 {
            return block_4851(state, tracer, fn_state);
        } else {
            return block_1576(state, tracer, fn_state);
        };
    }
    fn block_1576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1576_0: const #0u : u8
        let s_1576_0: bool = false;
        // D s_1576_1: write-var gs#135180 <= s_1576_0
        fn_state.gs_135180 = s_1576_0;
        // N s_1576_2: jump b1577
        return block_1577(state, tracer, fn_state);
    }
    fn block_1577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1577_0: read-var gs#135180:u8
        let s_1577_0: bool = fn_state.gs_135180;
        // N s_1577_1: branch s_1577_0 b4850 b1578
        if s_1577_0 {
            return block_4850(state, tracer, fn_state);
        } else {
            return block_1578(state, tracer, fn_state);
        };
    }
    fn block_1578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1578_0: const #0u : u8
        let s_1578_0: bool = false;
        // D s_1578_1: write-var gs#135181 <= s_1578_0
        fn_state.gs_135181 = s_1578_0;
        // N s_1578_2: jump b1579
        return block_1579(state, tracer, fn_state);
    }
    fn block_1579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1579_0: read-var gs#135181:u8
        let s_1579_0: bool = fn_state.gs_135181;
        // N s_1579_1: branch s_1579_0 b4849 b1580
        if s_1579_0 {
            return block_4849(state, tracer, fn_state);
        } else {
            return block_1580(state, tracer, fn_state);
        };
    }
    fn block_1580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1580_0: const #0u : u8
        let s_1580_0: bool = false;
        // D s_1580_1: write-var gs#135182 <= s_1580_0
        fn_state.gs_135182 = s_1580_0;
        // N s_1580_2: jump b1581
        return block_1581(state, tracer, fn_state);
    }
    fn block_1581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1581_0: read-var gs#135182:u8
        let s_1581_0: bool = fn_state.gs_135182;
        // N s_1581_1: branch s_1581_0 b4848 b1582
        if s_1581_0 {
            return block_4848(state, tracer, fn_state);
        } else {
            return block_1582(state, tracer, fn_state);
        };
    }
    fn block_1582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1582_0: const #0u : u8
        let s_1582_0: bool = false;
        // D s_1582_1: write-var gs#135183 <= s_1582_0
        fn_state.gs_135183 = s_1582_0;
        // N s_1582_2: jump b1583
        return block_1583(state, tracer, fn_state);
    }
    fn block_1583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1583_0: read-var gs#135183:u8
        let s_1583_0: bool = fn_state.gs_135183;
        // N s_1583_1: branch s_1583_0 b4847 b1584
        if s_1583_0 {
            return block_4847(state, tracer, fn_state);
        } else {
            return block_1584(state, tracer, fn_state);
        };
    }
    fn block_1584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1584_0: read-var CRm:u8
        let s_1584_0: u8 = fn_state.CRm;
        // D s_1584_1: cast zx s_1584_0 -> bv
        let s_1584_1: Bits = Bits::new(s_1584_0 as u128, 4u16);
        // C s_1584_2: const #8u : u8
        let s_1584_2: u8 = 8;
        // C s_1584_3: cast zx s_1584_2 -> bv
        let s_1584_3: Bits = Bits::new(s_1584_2 as u128, 4u16);
        // D s_1584_4: cmp-eq s_1584_1 s_1584_3
        let s_1584_4: bool = ((s_1584_1) == (s_1584_3));
        // N s_1584_5: branch s_1584_4 b4846 b1585
        if s_1584_4 {
            return block_4846(state, tracer, fn_state);
        } else {
            return block_1585(state, tracer, fn_state);
        };
    }
    fn block_1585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1585_0: const #0u : u8
        let s_1585_0: bool = false;
        // D s_1585_1: write-var gs#135184 <= s_1585_0
        fn_state.gs_135184 = s_1585_0;
        // N s_1585_2: jump b1586
        return block_1586(state, tracer, fn_state);
    }
    fn block_1586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1586_0: read-var gs#135184:u8
        let s_1586_0: bool = fn_state.gs_135184;
        // N s_1586_1: branch s_1586_0 b4845 b1587
        if s_1586_0 {
            return block_4845(state, tracer, fn_state);
        } else {
            return block_1587(state, tracer, fn_state);
        };
    }
    fn block_1587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1587_0: const #0u : u8
        let s_1587_0: bool = false;
        // D s_1587_1: write-var gs#135185 <= s_1587_0
        fn_state.gs_135185 = s_1587_0;
        // N s_1587_2: jump b1588
        return block_1588(state, tracer, fn_state);
    }
    fn block_1588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1588_0: read-var gs#135185:u8
        let s_1588_0: bool = fn_state.gs_135185;
        // N s_1588_1: branch s_1588_0 b4844 b1589
        if s_1588_0 {
            return block_4844(state, tracer, fn_state);
        } else {
            return block_1589(state, tracer, fn_state);
        };
    }
    fn block_1589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1589_0: const #0u : u8
        let s_1589_0: bool = false;
        // D s_1589_1: write-var gs#135186 <= s_1589_0
        fn_state.gs_135186 = s_1589_0;
        // N s_1589_2: jump b1590
        return block_1590(state, tracer, fn_state);
    }
    fn block_1590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1590_0: read-var gs#135186:u8
        let s_1590_0: bool = fn_state.gs_135186;
        // N s_1590_1: branch s_1590_0 b4843 b1591
        if s_1590_0 {
            return block_4843(state, tracer, fn_state);
        } else {
            return block_1591(state, tracer, fn_state);
        };
    }
    fn block_1591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1591_0: const #0u : u8
        let s_1591_0: bool = false;
        // D s_1591_1: write-var gs#135187 <= s_1591_0
        fn_state.gs_135187 = s_1591_0;
        // N s_1591_2: jump b1592
        return block_1592(state, tracer, fn_state);
    }
    fn block_1592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1592_0: read-var gs#135187:u8
        let s_1592_0: bool = fn_state.gs_135187;
        // N s_1592_1: branch s_1592_0 b4842 b1593
        if s_1592_0 {
            return block_4842(state, tracer, fn_state);
        } else {
            return block_1593(state, tracer, fn_state);
        };
    }
    fn block_1593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1593_0: read-var CRm:u8
        let s_1593_0: u8 = fn_state.CRm;
        // D s_1593_1: cast zx s_1593_0 -> bv
        let s_1593_1: Bits = Bits::new(s_1593_0 as u128, 4u16);
        // C s_1593_2: const #8u : u8
        let s_1593_2: u8 = 8;
        // C s_1593_3: cast zx s_1593_2 -> bv
        let s_1593_3: Bits = Bits::new(s_1593_2 as u128, 4u16);
        // D s_1593_4: cmp-eq s_1593_1 s_1593_3
        let s_1593_4: bool = ((s_1593_1) == (s_1593_3));
        // N s_1593_5: branch s_1593_4 b4841 b1594
        if s_1593_4 {
            return block_4841(state, tracer, fn_state);
        } else {
            return block_1594(state, tracer, fn_state);
        };
    }
    fn block_1594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1594_0: const #0u : u8
        let s_1594_0: bool = false;
        // D s_1594_1: write-var gs#135188 <= s_1594_0
        fn_state.gs_135188 = s_1594_0;
        // N s_1594_2: jump b1595
        return block_1595(state, tracer, fn_state);
    }
    fn block_1595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1595_0: read-var gs#135188:u8
        let s_1595_0: bool = fn_state.gs_135188;
        // N s_1595_1: branch s_1595_0 b4840 b1596
        if s_1595_0 {
            return block_4840(state, tracer, fn_state);
        } else {
            return block_1596(state, tracer, fn_state);
        };
    }
    fn block_1596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1596_0: const #0u : u8
        let s_1596_0: bool = false;
        // D s_1596_1: write-var gs#135189 <= s_1596_0
        fn_state.gs_135189 = s_1596_0;
        // N s_1596_2: jump b1597
        return block_1597(state, tracer, fn_state);
    }
    fn block_1597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1597_0: read-var gs#135189:u8
        let s_1597_0: bool = fn_state.gs_135189;
        // N s_1597_1: branch s_1597_0 b4839 b1598
        if s_1597_0 {
            return block_4839(state, tracer, fn_state);
        } else {
            return block_1598(state, tracer, fn_state);
        };
    }
    fn block_1598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1598_0: const #0u : u8
        let s_1598_0: bool = false;
        // D s_1598_1: write-var gs#135190 <= s_1598_0
        fn_state.gs_135190 = s_1598_0;
        // N s_1598_2: jump b1599
        return block_1599(state, tracer, fn_state);
    }
    fn block_1599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1599_0: read-var gs#135190:u8
        let s_1599_0: bool = fn_state.gs_135190;
        // N s_1599_1: branch s_1599_0 b4838 b1600
        if s_1599_0 {
            return block_4838(state, tracer, fn_state);
        } else {
            return block_1600(state, tracer, fn_state);
        };
    }
    fn block_1600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1600_0: const #0u : u8
        let s_1600_0: bool = false;
        // D s_1600_1: write-var gs#135191 <= s_1600_0
        fn_state.gs_135191 = s_1600_0;
        // N s_1600_2: jump b1601
        return block_1601(state, tracer, fn_state);
    }
    fn block_1601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1601_0: read-var gs#135191:u8
        let s_1601_0: bool = fn_state.gs_135191;
        // N s_1601_1: branch s_1601_0 b4837 b1602
        if s_1601_0 {
            return block_4837(state, tracer, fn_state);
        } else {
            return block_1602(state, tracer, fn_state);
        };
    }
    fn block_1602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1602_0: read-var CRm:u8
        let s_1602_0: u8 = fn_state.CRm;
        // D s_1602_1: cast zx s_1602_0 -> bv
        let s_1602_1: Bits = Bits::new(s_1602_0 as u128, 4u16);
        // C s_1602_2: const #8u : u8
        let s_1602_2: u8 = 8;
        // C s_1602_3: cast zx s_1602_2 -> bv
        let s_1602_3: Bits = Bits::new(s_1602_2 as u128, 4u16);
        // D s_1602_4: cmp-eq s_1602_1 s_1602_3
        let s_1602_4: bool = ((s_1602_1) == (s_1602_3));
        // N s_1602_5: branch s_1602_4 b4836 b1603
        if s_1602_4 {
            return block_4836(state, tracer, fn_state);
        } else {
            return block_1603(state, tracer, fn_state);
        };
    }
    fn block_1603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1603_0: const #0u : u8
        let s_1603_0: bool = false;
        // D s_1603_1: write-var gs#135192 <= s_1603_0
        fn_state.gs_135192 = s_1603_0;
        // N s_1603_2: jump b1604
        return block_1604(state, tracer, fn_state);
    }
    fn block_1604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1604_0: read-var gs#135192:u8
        let s_1604_0: bool = fn_state.gs_135192;
        // N s_1604_1: branch s_1604_0 b4835 b1605
        if s_1604_0 {
            return block_4835(state, tracer, fn_state);
        } else {
            return block_1605(state, tracer, fn_state);
        };
    }
    fn block_1605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1605_0: const #0u : u8
        let s_1605_0: bool = false;
        // D s_1605_1: write-var gs#135193 <= s_1605_0
        fn_state.gs_135193 = s_1605_0;
        // N s_1605_2: jump b1606
        return block_1606(state, tracer, fn_state);
    }
    fn block_1606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1606_0: read-var gs#135193:u8
        let s_1606_0: bool = fn_state.gs_135193;
        // N s_1606_1: branch s_1606_0 b4834 b1607
        if s_1606_0 {
            return block_4834(state, tracer, fn_state);
        } else {
            return block_1607(state, tracer, fn_state);
        };
    }
    fn block_1607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1607_0: const #0u : u8
        let s_1607_0: bool = false;
        // D s_1607_1: write-var gs#135194 <= s_1607_0
        fn_state.gs_135194 = s_1607_0;
        // N s_1607_2: jump b1608
        return block_1608(state, tracer, fn_state);
    }
    fn block_1608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1608_0: read-var gs#135194:u8
        let s_1608_0: bool = fn_state.gs_135194;
        // N s_1608_1: branch s_1608_0 b4833 b1609
        if s_1608_0 {
            return block_4833(state, tracer, fn_state);
        } else {
            return block_1609(state, tracer, fn_state);
        };
    }
    fn block_1609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1609_0: const #0u : u8
        let s_1609_0: bool = false;
        // D s_1609_1: write-var gs#135195 <= s_1609_0
        fn_state.gs_135195 = s_1609_0;
        // N s_1609_2: jump b1610
        return block_1610(state, tracer, fn_state);
    }
    fn block_1610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1610_0: read-var gs#135195:u8
        let s_1610_0: bool = fn_state.gs_135195;
        // N s_1610_1: branch s_1610_0 b4832 b1611
        if s_1610_0 {
            return block_4832(state, tracer, fn_state);
        } else {
            return block_1611(state, tracer, fn_state);
        };
    }
    fn block_1611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1611_0: read-var CRm:u8
        let s_1611_0: u8 = fn_state.CRm;
        // D s_1611_1: cast zx s_1611_0 -> bv
        let s_1611_1: Bits = Bits::new(s_1611_0 as u128, 4u16);
        // C s_1611_2: const #8u : u8
        let s_1611_2: u8 = 8;
        // C s_1611_3: cast zx s_1611_2 -> bv
        let s_1611_3: Bits = Bits::new(s_1611_2 as u128, 4u16);
        // D s_1611_4: cmp-eq s_1611_1 s_1611_3
        let s_1611_4: bool = ((s_1611_1) == (s_1611_3));
        // N s_1611_5: branch s_1611_4 b4831 b1612
        if s_1611_4 {
            return block_4831(state, tracer, fn_state);
        } else {
            return block_1612(state, tracer, fn_state);
        };
    }
    fn block_1612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1612_0: const #0u : u8
        let s_1612_0: bool = false;
        // D s_1612_1: write-var gs#135196 <= s_1612_0
        fn_state.gs_135196 = s_1612_0;
        // N s_1612_2: jump b1613
        return block_1613(state, tracer, fn_state);
    }
    fn block_1613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1613_0: read-var gs#135196:u8
        let s_1613_0: bool = fn_state.gs_135196;
        // N s_1613_1: branch s_1613_0 b4830 b1614
        if s_1613_0 {
            return block_4830(state, tracer, fn_state);
        } else {
            return block_1614(state, tracer, fn_state);
        };
    }
    fn block_1614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1614_0: const #0u : u8
        let s_1614_0: bool = false;
        // D s_1614_1: write-var gs#135197 <= s_1614_0
        fn_state.gs_135197 = s_1614_0;
        // N s_1614_2: jump b1615
        return block_1615(state, tracer, fn_state);
    }
    fn block_1615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1615_0: read-var gs#135197:u8
        let s_1615_0: bool = fn_state.gs_135197;
        // N s_1615_1: branch s_1615_0 b4829 b1616
        if s_1615_0 {
            return block_4829(state, tracer, fn_state);
        } else {
            return block_1616(state, tracer, fn_state);
        };
    }
    fn block_1616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1616_0: const #0u : u8
        let s_1616_0: bool = false;
        // D s_1616_1: write-var gs#135198 <= s_1616_0
        fn_state.gs_135198 = s_1616_0;
        // N s_1616_2: jump b1617
        return block_1617(state, tracer, fn_state);
    }
    fn block_1617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1617_0: read-var gs#135198:u8
        let s_1617_0: bool = fn_state.gs_135198;
        // N s_1617_1: branch s_1617_0 b4828 b1618
        if s_1617_0 {
            return block_4828(state, tracer, fn_state);
        } else {
            return block_1618(state, tracer, fn_state);
        };
    }
    fn block_1618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1618_0: const #0u : u8
        let s_1618_0: bool = false;
        // D s_1618_1: write-var gs#135199 <= s_1618_0
        fn_state.gs_135199 = s_1618_0;
        // N s_1618_2: jump b1619
        return block_1619(state, tracer, fn_state);
    }
    fn block_1619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1619_0: read-var gs#135199:u8
        let s_1619_0: bool = fn_state.gs_135199;
        // N s_1619_1: branch s_1619_0 b4827 b1620
        if s_1619_0 {
            return block_4827(state, tracer, fn_state);
        } else {
            return block_1620(state, tracer, fn_state);
        };
    }
    fn block_1620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1620_0: read-var CRm:u8
        let s_1620_0: u8 = fn_state.CRm;
        // D s_1620_1: cast zx s_1620_0 -> bv
        let s_1620_1: Bits = Bits::new(s_1620_0 as u128, 4u16);
        // C s_1620_2: const #8u : u8
        let s_1620_2: u8 = 8;
        // C s_1620_3: cast zx s_1620_2 -> bv
        let s_1620_3: Bits = Bits::new(s_1620_2 as u128, 4u16);
        // D s_1620_4: cmp-eq s_1620_1 s_1620_3
        let s_1620_4: bool = ((s_1620_1) == (s_1620_3));
        // N s_1620_5: branch s_1620_4 b4826 b1621
        if s_1620_4 {
            return block_4826(state, tracer, fn_state);
        } else {
            return block_1621(state, tracer, fn_state);
        };
    }
    fn block_1621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1621_0: const #0u : u8
        let s_1621_0: bool = false;
        // D s_1621_1: write-var gs#135200 <= s_1621_0
        fn_state.gs_135200 = s_1621_0;
        // N s_1621_2: jump b1622
        return block_1622(state, tracer, fn_state);
    }
    fn block_1622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1622_0: read-var gs#135200:u8
        let s_1622_0: bool = fn_state.gs_135200;
        // N s_1622_1: branch s_1622_0 b4825 b1623
        if s_1622_0 {
            return block_4825(state, tracer, fn_state);
        } else {
            return block_1623(state, tracer, fn_state);
        };
    }
    fn block_1623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1623_0: const #0u : u8
        let s_1623_0: bool = false;
        // D s_1623_1: write-var gs#135201 <= s_1623_0
        fn_state.gs_135201 = s_1623_0;
        // N s_1623_2: jump b1624
        return block_1624(state, tracer, fn_state);
    }
    fn block_1624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1624_0: read-var gs#135201:u8
        let s_1624_0: bool = fn_state.gs_135201;
        // N s_1624_1: branch s_1624_0 b4824 b1625
        if s_1624_0 {
            return block_4824(state, tracer, fn_state);
        } else {
            return block_1625(state, tracer, fn_state);
        };
    }
    fn block_1625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1625_0: const #0u : u8
        let s_1625_0: bool = false;
        // D s_1625_1: write-var gs#135202 <= s_1625_0
        fn_state.gs_135202 = s_1625_0;
        // N s_1625_2: jump b1626
        return block_1626(state, tracer, fn_state);
    }
    fn block_1626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1626_0: read-var gs#135202:u8
        let s_1626_0: bool = fn_state.gs_135202;
        // N s_1626_1: branch s_1626_0 b4823 b1627
        if s_1626_0 {
            return block_4823(state, tracer, fn_state);
        } else {
            return block_1627(state, tracer, fn_state);
        };
    }
    fn block_1627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1627_0: const #0u : u8
        let s_1627_0: bool = false;
        // D s_1627_1: write-var gs#135203 <= s_1627_0
        fn_state.gs_135203 = s_1627_0;
        // N s_1627_2: jump b1628
        return block_1628(state, tracer, fn_state);
    }
    fn block_1628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1628_0: read-var gs#135203:u8
        let s_1628_0: bool = fn_state.gs_135203;
        // N s_1628_1: branch s_1628_0 b4822 b1629
        if s_1628_0 {
            return block_4822(state, tracer, fn_state);
        } else {
            return block_1629(state, tracer, fn_state);
        };
    }
    fn block_1629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1629_0: read-var CRm:u8
        let s_1629_0: u8 = fn_state.CRm;
        // D s_1629_1: cast zx s_1629_0 -> bv
        let s_1629_1: Bits = Bits::new(s_1629_0 as u128, 4u16);
        // C s_1629_2: const #8u : u8
        let s_1629_2: u8 = 8;
        // C s_1629_3: cast zx s_1629_2 -> bv
        let s_1629_3: Bits = Bits::new(s_1629_2 as u128, 4u16);
        // D s_1629_4: cmp-eq s_1629_1 s_1629_3
        let s_1629_4: bool = ((s_1629_1) == (s_1629_3));
        // N s_1629_5: branch s_1629_4 b4821 b1630
        if s_1629_4 {
            return block_4821(state, tracer, fn_state);
        } else {
            return block_1630(state, tracer, fn_state);
        };
    }
    fn block_1630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1630_0: const #0u : u8
        let s_1630_0: bool = false;
        // D s_1630_1: write-var gs#135204 <= s_1630_0
        fn_state.gs_135204 = s_1630_0;
        // N s_1630_2: jump b1631
        return block_1631(state, tracer, fn_state);
    }
    fn block_1631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1631_0: read-var gs#135204:u8
        let s_1631_0: bool = fn_state.gs_135204;
        // N s_1631_1: branch s_1631_0 b4820 b1632
        if s_1631_0 {
            return block_4820(state, tracer, fn_state);
        } else {
            return block_1632(state, tracer, fn_state);
        };
    }
    fn block_1632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1632_0: const #0u : u8
        let s_1632_0: bool = false;
        // D s_1632_1: write-var gs#135205 <= s_1632_0
        fn_state.gs_135205 = s_1632_0;
        // N s_1632_2: jump b1633
        return block_1633(state, tracer, fn_state);
    }
    fn block_1633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1633_0: read-var gs#135205:u8
        let s_1633_0: bool = fn_state.gs_135205;
        // N s_1633_1: branch s_1633_0 b4819 b1634
        if s_1633_0 {
            return block_4819(state, tracer, fn_state);
        } else {
            return block_1634(state, tracer, fn_state);
        };
    }
    fn block_1634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1634_0: const #0u : u8
        let s_1634_0: bool = false;
        // D s_1634_1: write-var gs#135206 <= s_1634_0
        fn_state.gs_135206 = s_1634_0;
        // N s_1634_2: jump b1635
        return block_1635(state, tracer, fn_state);
    }
    fn block_1635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1635_0: read-var gs#135206:u8
        let s_1635_0: bool = fn_state.gs_135206;
        // N s_1635_1: branch s_1635_0 b4818 b1636
        if s_1635_0 {
            return block_4818(state, tracer, fn_state);
        } else {
            return block_1636(state, tracer, fn_state);
        };
    }
    fn block_1636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1636_0: const #0u : u8
        let s_1636_0: bool = false;
        // D s_1636_1: write-var gs#135207 <= s_1636_0
        fn_state.gs_135207 = s_1636_0;
        // N s_1636_2: jump b1637
        return block_1637(state, tracer, fn_state);
    }
    fn block_1637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1637_0: read-var gs#135207:u8
        let s_1637_0: bool = fn_state.gs_135207;
        // N s_1637_1: branch s_1637_0 b4817 b1638
        if s_1637_0 {
            return block_4817(state, tracer, fn_state);
        } else {
            return block_1638(state, tracer, fn_state);
        };
    }
    fn block_1638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1638_0: read-var CRm:u8
        let s_1638_0: u8 = fn_state.CRm;
        // D s_1638_1: cast zx s_1638_0 -> bv
        let s_1638_1: Bits = Bits::new(s_1638_0 as u128, 4u16);
        // C s_1638_2: const #8u : u8
        let s_1638_2: u8 = 8;
        // C s_1638_3: cast zx s_1638_2 -> bv
        let s_1638_3: Bits = Bits::new(s_1638_2 as u128, 4u16);
        // D s_1638_4: cmp-eq s_1638_1 s_1638_3
        let s_1638_4: bool = ((s_1638_1) == (s_1638_3));
        // N s_1638_5: branch s_1638_4 b4816 b1639
        if s_1638_4 {
            return block_4816(state, tracer, fn_state);
        } else {
            return block_1639(state, tracer, fn_state);
        };
    }
    fn block_1639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1639_0: const #0u : u8
        let s_1639_0: bool = false;
        // D s_1639_1: write-var gs#135208 <= s_1639_0
        fn_state.gs_135208 = s_1639_0;
        // N s_1639_2: jump b1640
        return block_1640(state, tracer, fn_state);
    }
    fn block_1640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1640_0: read-var gs#135208:u8
        let s_1640_0: bool = fn_state.gs_135208;
        // N s_1640_1: branch s_1640_0 b4815 b1641
        if s_1640_0 {
            return block_4815(state, tracer, fn_state);
        } else {
            return block_1641(state, tracer, fn_state);
        };
    }
    fn block_1641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1641_0: const #0u : u8
        let s_1641_0: bool = false;
        // D s_1641_1: write-var gs#135209 <= s_1641_0
        fn_state.gs_135209 = s_1641_0;
        // N s_1641_2: jump b1642
        return block_1642(state, tracer, fn_state);
    }
    fn block_1642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1642_0: read-var gs#135209:u8
        let s_1642_0: bool = fn_state.gs_135209;
        // N s_1642_1: branch s_1642_0 b4814 b1643
        if s_1642_0 {
            return block_4814(state, tracer, fn_state);
        } else {
            return block_1643(state, tracer, fn_state);
        };
    }
    fn block_1643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1643_0: const #0u : u8
        let s_1643_0: bool = false;
        // D s_1643_1: write-var gs#135210 <= s_1643_0
        fn_state.gs_135210 = s_1643_0;
        // N s_1643_2: jump b1644
        return block_1644(state, tracer, fn_state);
    }
    fn block_1644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1644_0: read-var gs#135210:u8
        let s_1644_0: bool = fn_state.gs_135210;
        // N s_1644_1: branch s_1644_0 b4813 b1645
        if s_1644_0 {
            return block_4813(state, tracer, fn_state);
        } else {
            return block_1645(state, tracer, fn_state);
        };
    }
    fn block_1645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1645_0: const #0u : u8
        let s_1645_0: bool = false;
        // D s_1645_1: write-var gs#135211 <= s_1645_0
        fn_state.gs_135211 = s_1645_0;
        // N s_1645_2: jump b1646
        return block_1646(state, tracer, fn_state);
    }
    fn block_1646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1646_0: read-var gs#135211:u8
        let s_1646_0: bool = fn_state.gs_135211;
        // N s_1646_1: branch s_1646_0 b4812 b1647
        if s_1646_0 {
            return block_4812(state, tracer, fn_state);
        } else {
            return block_1647(state, tracer, fn_state);
        };
    }
    fn block_1647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1647_0: read-var CRm:u8
        let s_1647_0: u8 = fn_state.CRm;
        // D s_1647_1: cast zx s_1647_0 -> bv
        let s_1647_1: Bits = Bits::new(s_1647_0 as u128, 4u16);
        // C s_1647_2: const #3u : u8
        let s_1647_2: u8 = 3;
        // C s_1647_3: cast zx s_1647_2 -> bv
        let s_1647_3: Bits = Bits::new(s_1647_2 as u128, 4u16);
        // D s_1647_4: cmp-eq s_1647_1 s_1647_3
        let s_1647_4: bool = ((s_1647_1) == (s_1647_3));
        // N s_1647_5: branch s_1647_4 b4811 b1648
        if s_1647_4 {
            return block_4811(state, tracer, fn_state);
        } else {
            return block_1648(state, tracer, fn_state);
        };
    }
    fn block_1648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1648_0: const #0u : u8
        let s_1648_0: bool = false;
        // D s_1648_1: write-var gs#135212 <= s_1648_0
        fn_state.gs_135212 = s_1648_0;
        // N s_1648_2: jump b1649
        return block_1649(state, tracer, fn_state);
    }
    fn block_1649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1649_0: read-var gs#135212:u8
        let s_1649_0: bool = fn_state.gs_135212;
        // N s_1649_1: branch s_1649_0 b4810 b1650
        if s_1649_0 {
            return block_4810(state, tracer, fn_state);
        } else {
            return block_1650(state, tracer, fn_state);
        };
    }
    fn block_1650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1650_0: const #0u : u8
        let s_1650_0: bool = false;
        // D s_1650_1: write-var gs#135213 <= s_1650_0
        fn_state.gs_135213 = s_1650_0;
        // N s_1650_2: jump b1651
        return block_1651(state, tracer, fn_state);
    }
    fn block_1651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1651_0: read-var gs#135213:u8
        let s_1651_0: bool = fn_state.gs_135213;
        // N s_1651_1: branch s_1651_0 b4809 b1652
        if s_1651_0 {
            return block_4809(state, tracer, fn_state);
        } else {
            return block_1652(state, tracer, fn_state);
        };
    }
    fn block_1652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1652_0: const #0u : u8
        let s_1652_0: bool = false;
        // D s_1652_1: write-var gs#135214 <= s_1652_0
        fn_state.gs_135214 = s_1652_0;
        // N s_1652_2: jump b1653
        return block_1653(state, tracer, fn_state);
    }
    fn block_1653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1653_0: read-var gs#135214:u8
        let s_1653_0: bool = fn_state.gs_135214;
        // N s_1653_1: branch s_1653_0 b4808 b1654
        if s_1653_0 {
            return block_4808(state, tracer, fn_state);
        } else {
            return block_1654(state, tracer, fn_state);
        };
    }
    fn block_1654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1654_0: const #0u : u8
        let s_1654_0: bool = false;
        // D s_1654_1: write-var gs#135215 <= s_1654_0
        fn_state.gs_135215 = s_1654_0;
        // N s_1654_2: jump b1655
        return block_1655(state, tracer, fn_state);
    }
    fn block_1655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1655_0: read-var gs#135215:u8
        let s_1655_0: bool = fn_state.gs_135215;
        // N s_1655_1: branch s_1655_0 b4807 b1656
        if s_1655_0 {
            return block_4807(state, tracer, fn_state);
        } else {
            return block_1656(state, tracer, fn_state);
        };
    }
    fn block_1656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1656_0: read-var CRm:u8
        let s_1656_0: u8 = fn_state.CRm;
        // D s_1656_1: cast zx s_1656_0 -> bv
        let s_1656_1: Bits = Bits::new(s_1656_0 as u128, 4u16);
        // C s_1656_2: const #0u : u8
        let s_1656_2: u8 = 0;
        // C s_1656_3: cast zx s_1656_2 -> bv
        let s_1656_3: Bits = Bits::new(s_1656_2 as u128, 4u16);
        // D s_1656_4: cmp-eq s_1656_1 s_1656_3
        let s_1656_4: bool = ((s_1656_1) == (s_1656_3));
        // N s_1656_5: branch s_1656_4 b4806 b1657
        if s_1656_4 {
            return block_4806(state, tracer, fn_state);
        } else {
            return block_1657(state, tracer, fn_state);
        };
    }
    fn block_1657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1657_0: const #0u : u8
        let s_1657_0: bool = false;
        // D s_1657_1: write-var gs#135216 <= s_1657_0
        fn_state.gs_135216 = s_1657_0;
        // N s_1657_2: jump b1658
        return block_1658(state, tracer, fn_state);
    }
    fn block_1658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1658_0: read-var gs#135216:u8
        let s_1658_0: bool = fn_state.gs_135216;
        // N s_1658_1: branch s_1658_0 b4805 b1659
        if s_1658_0 {
            return block_4805(state, tracer, fn_state);
        } else {
            return block_1659(state, tracer, fn_state);
        };
    }
    fn block_1659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1659_0: const #0u : u8
        let s_1659_0: bool = false;
        // D s_1659_1: write-var gs#135217 <= s_1659_0
        fn_state.gs_135217 = s_1659_0;
        // N s_1659_2: jump b1660
        return block_1660(state, tracer, fn_state);
    }
    fn block_1660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1660_0: read-var gs#135217:u8
        let s_1660_0: bool = fn_state.gs_135217;
        // N s_1660_1: branch s_1660_0 b4804 b1661
        if s_1660_0 {
            return block_4804(state, tracer, fn_state);
        } else {
            return block_1661(state, tracer, fn_state);
        };
    }
    fn block_1661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1661_0: const #0u : u8
        let s_1661_0: bool = false;
        // D s_1661_1: write-var gs#135218 <= s_1661_0
        fn_state.gs_135218 = s_1661_0;
        // N s_1661_2: jump b1662
        return block_1662(state, tracer, fn_state);
    }
    fn block_1662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1662_0: read-var gs#135218:u8
        let s_1662_0: bool = fn_state.gs_135218;
        // N s_1662_1: branch s_1662_0 b4803 b1663
        if s_1662_0 {
            return block_4803(state, tracer, fn_state);
        } else {
            return block_1663(state, tracer, fn_state);
        };
    }
    fn block_1663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1663_0: const #0u : u8
        let s_1663_0: bool = false;
        // D s_1663_1: write-var gs#135219 <= s_1663_0
        fn_state.gs_135219 = s_1663_0;
        // N s_1663_2: jump b1664
        return block_1664(state, tracer, fn_state);
    }
    fn block_1664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1664_0: read-var gs#135219:u8
        let s_1664_0: bool = fn_state.gs_135219;
        // N s_1664_1: branch s_1664_0 b4802 b1665
        if s_1664_0 {
            return block_4802(state, tracer, fn_state);
        } else {
            return block_1665(state, tracer, fn_state);
        };
    }
    fn block_1665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1665_0: read-var CRm:u8
        let s_1665_0: u8 = fn_state.CRm;
        // D s_1665_1: cast zx s_1665_0 -> bv
        let s_1665_1: Bits = Bits::new(s_1665_0 as u128, 4u16);
        // C s_1665_2: const #7u : u8
        let s_1665_2: u8 = 7;
        // C s_1665_3: cast zx s_1665_2 -> bv
        let s_1665_3: Bits = Bits::new(s_1665_2 as u128, 4u16);
        // D s_1665_4: cmp-eq s_1665_1 s_1665_3
        let s_1665_4: bool = ((s_1665_1) == (s_1665_3));
        // N s_1665_5: branch s_1665_4 b4801 b1666
        if s_1665_4 {
            return block_4801(state, tracer, fn_state);
        } else {
            return block_1666(state, tracer, fn_state);
        };
    }
    fn block_1666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1666_0: const #0u : u8
        let s_1666_0: bool = false;
        // D s_1666_1: write-var gs#135220 <= s_1666_0
        fn_state.gs_135220 = s_1666_0;
        // N s_1666_2: jump b1667
        return block_1667(state, tracer, fn_state);
    }
    fn block_1667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1667_0: read-var gs#135220:u8
        let s_1667_0: bool = fn_state.gs_135220;
        // N s_1667_1: branch s_1667_0 b4800 b1668
        if s_1667_0 {
            return block_4800(state, tracer, fn_state);
        } else {
            return block_1668(state, tracer, fn_state);
        };
    }
    fn block_1668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1668_0: const #0u : u8
        let s_1668_0: bool = false;
        // D s_1668_1: write-var gs#135221 <= s_1668_0
        fn_state.gs_135221 = s_1668_0;
        // N s_1668_2: jump b1669
        return block_1669(state, tracer, fn_state);
    }
    fn block_1669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1669_0: read-var gs#135221:u8
        let s_1669_0: bool = fn_state.gs_135221;
        // N s_1669_1: branch s_1669_0 b4799 b1670
        if s_1669_0 {
            return block_4799(state, tracer, fn_state);
        } else {
            return block_1670(state, tracer, fn_state);
        };
    }
    fn block_1670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1670_0: const #0u : u8
        let s_1670_0: bool = false;
        // D s_1670_1: write-var gs#135222 <= s_1670_0
        fn_state.gs_135222 = s_1670_0;
        // N s_1670_2: jump b1671
        return block_1671(state, tracer, fn_state);
    }
    fn block_1671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1671_0: read-var gs#135222:u8
        let s_1671_0: bool = fn_state.gs_135222;
        // N s_1671_1: branch s_1671_0 b4798 b1672
        if s_1671_0 {
            return block_4798(state, tracer, fn_state);
        } else {
            return block_1672(state, tracer, fn_state);
        };
    }
    fn block_1672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1672_0: const #0u : u8
        let s_1672_0: bool = false;
        // D s_1672_1: write-var gs#135223 <= s_1672_0
        fn_state.gs_135223 = s_1672_0;
        // N s_1672_2: jump b1673
        return block_1673(state, tracer, fn_state);
    }
    fn block_1673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1673_0: read-var gs#135223:u8
        let s_1673_0: bool = fn_state.gs_135223;
        // N s_1673_1: branch s_1673_0 b4797 b1674
        if s_1673_0 {
            return block_4797(state, tracer, fn_state);
        } else {
            return block_1674(state, tracer, fn_state);
        };
    }
    fn block_1674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1674_0: read-var CRm:u8
        let s_1674_0: u8 = fn_state.CRm;
        // D s_1674_1: cast zx s_1674_0 -> bv
        let s_1674_1: Bits = Bits::new(s_1674_0 as u128, 4u16);
        // C s_1674_2: const #0u : u8
        let s_1674_2: u8 = 0;
        // C s_1674_3: cast zx s_1674_2 -> bv
        let s_1674_3: Bits = Bits::new(s_1674_2 as u128, 4u16);
        // D s_1674_4: cmp-eq s_1674_1 s_1674_3
        let s_1674_4: bool = ((s_1674_1) == (s_1674_3));
        // N s_1674_5: branch s_1674_4 b4796 b1675
        if s_1674_4 {
            return block_4796(state, tracer, fn_state);
        } else {
            return block_1675(state, tracer, fn_state);
        };
    }
    fn block_1675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1675_0: const #0u : u8
        let s_1675_0: bool = false;
        // D s_1675_1: write-var gs#135224 <= s_1675_0
        fn_state.gs_135224 = s_1675_0;
        // N s_1675_2: jump b1676
        return block_1676(state, tracer, fn_state);
    }
    fn block_1676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1676_0: read-var gs#135224:u8
        let s_1676_0: bool = fn_state.gs_135224;
        // N s_1676_1: branch s_1676_0 b4795 b1677
        if s_1676_0 {
            return block_4795(state, tracer, fn_state);
        } else {
            return block_1677(state, tracer, fn_state);
        };
    }
    fn block_1677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1677_0: const #0u : u8
        let s_1677_0: bool = false;
        // D s_1677_1: write-var gs#135225 <= s_1677_0
        fn_state.gs_135225 = s_1677_0;
        // N s_1677_2: jump b1678
        return block_1678(state, tracer, fn_state);
    }
    fn block_1678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1678_0: read-var gs#135225:u8
        let s_1678_0: bool = fn_state.gs_135225;
        // N s_1678_1: branch s_1678_0 b4794 b1679
        if s_1678_0 {
            return block_4794(state, tracer, fn_state);
        } else {
            return block_1679(state, tracer, fn_state);
        };
    }
    fn block_1679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1679_0: const #0u : u8
        let s_1679_0: bool = false;
        // D s_1679_1: write-var gs#135226 <= s_1679_0
        fn_state.gs_135226 = s_1679_0;
        // N s_1679_2: jump b1680
        return block_1680(state, tracer, fn_state);
    }
    fn block_1680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1680_0: read-var gs#135226:u8
        let s_1680_0: bool = fn_state.gs_135226;
        // N s_1680_1: branch s_1680_0 b4793 b1681
        if s_1680_0 {
            return block_4793(state, tracer, fn_state);
        } else {
            return block_1681(state, tracer, fn_state);
        };
    }
    fn block_1681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1681_0: const #0u : u8
        let s_1681_0: bool = false;
        // D s_1681_1: write-var gs#135227 <= s_1681_0
        fn_state.gs_135227 = s_1681_0;
        // N s_1681_2: jump b1682
        return block_1682(state, tracer, fn_state);
    }
    fn block_1682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1682_0: read-var gs#135227:u8
        let s_1682_0: bool = fn_state.gs_135227;
        // N s_1682_1: branch s_1682_0 b4792 b1683
        if s_1682_0 {
            return block_4792(state, tracer, fn_state);
        } else {
            return block_1683(state, tracer, fn_state);
        };
    }
    fn block_1683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1683_0: read-var CRm:u8
        let s_1683_0: u8 = fn_state.CRm;
        // D s_1683_1: cast zx s_1683_0 -> bv
        let s_1683_1: Bits = Bits::new(s_1683_0 as u128, 4u16);
        // C s_1683_2: const #0u : u8
        let s_1683_2: u8 = 0;
        // C s_1683_3: cast zx s_1683_2 -> bv
        let s_1683_3: Bits = Bits::new(s_1683_2 as u128, 4u16);
        // D s_1683_4: cmp-eq s_1683_1 s_1683_3
        let s_1683_4: bool = ((s_1683_1) == (s_1683_3));
        // N s_1683_5: branch s_1683_4 b4791 b1684
        if s_1683_4 {
            return block_4791(state, tracer, fn_state);
        } else {
            return block_1684(state, tracer, fn_state);
        };
    }
    fn block_1684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1684_0: const #0u : u8
        let s_1684_0: bool = false;
        // D s_1684_1: write-var gs#135228 <= s_1684_0
        fn_state.gs_135228 = s_1684_0;
        // N s_1684_2: jump b1685
        return block_1685(state, tracer, fn_state);
    }
    fn block_1685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1685_0: read-var gs#135228:u8
        let s_1685_0: bool = fn_state.gs_135228;
        // N s_1685_1: branch s_1685_0 b4790 b1686
        if s_1685_0 {
            return block_4790(state, tracer, fn_state);
        } else {
            return block_1686(state, tracer, fn_state);
        };
    }
    fn block_1686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1686_0: const #0u : u8
        let s_1686_0: bool = false;
        // D s_1686_1: write-var gs#135229 <= s_1686_0
        fn_state.gs_135229 = s_1686_0;
        // N s_1686_2: jump b1687
        return block_1687(state, tracer, fn_state);
    }
    fn block_1687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1687_0: read-var gs#135229:u8
        let s_1687_0: bool = fn_state.gs_135229;
        // N s_1687_1: branch s_1687_0 b4789 b1688
        if s_1687_0 {
            return block_4789(state, tracer, fn_state);
        } else {
            return block_1688(state, tracer, fn_state);
        };
    }
    fn block_1688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1688_0: const #0u : u8
        let s_1688_0: bool = false;
        // D s_1688_1: write-var gs#135230 <= s_1688_0
        fn_state.gs_135230 = s_1688_0;
        // N s_1688_2: jump b1689
        return block_1689(state, tracer, fn_state);
    }
    fn block_1689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1689_0: read-var gs#135230:u8
        let s_1689_0: bool = fn_state.gs_135230;
        // N s_1689_1: branch s_1689_0 b4788 b1690
        if s_1689_0 {
            return block_4788(state, tracer, fn_state);
        } else {
            return block_1690(state, tracer, fn_state);
        };
    }
    fn block_1690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1690_0: const #0u : u8
        let s_1690_0: bool = false;
        // D s_1690_1: write-var gs#135231 <= s_1690_0
        fn_state.gs_135231 = s_1690_0;
        // N s_1690_2: jump b1691
        return block_1691(state, tracer, fn_state);
    }
    fn block_1691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1691_0: read-var gs#135231:u8
        let s_1691_0: bool = fn_state.gs_135231;
        // N s_1691_1: branch s_1691_0 b4787 b1692
        if s_1691_0 {
            return block_4787(state, tracer, fn_state);
        } else {
            return block_1692(state, tracer, fn_state);
        };
    }
    fn block_1692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1692_0: read-var CRm:u8
        let s_1692_0: u8 = fn_state.CRm;
        // D s_1692_1: cast zx s_1692_0 -> bv
        let s_1692_1: Bits = Bits::new(s_1692_0 as u128, 4u16);
        // C s_1692_2: const #6u : u8
        let s_1692_2: u8 = 6;
        // C s_1692_3: cast zx s_1692_2 -> bv
        let s_1692_3: Bits = Bits::new(s_1692_2 as u128, 4u16);
        // D s_1692_4: cmp-eq s_1692_1 s_1692_3
        let s_1692_4: bool = ((s_1692_1) == (s_1692_3));
        // N s_1692_5: branch s_1692_4 b4786 b1693
        if s_1692_4 {
            return block_4786(state, tracer, fn_state);
        } else {
            return block_1693(state, tracer, fn_state);
        };
    }
    fn block_1693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1693_0: const #0u : u8
        let s_1693_0: bool = false;
        // D s_1693_1: write-var gs#135232 <= s_1693_0
        fn_state.gs_135232 = s_1693_0;
        // N s_1693_2: jump b1694
        return block_1694(state, tracer, fn_state);
    }
    fn block_1694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1694_0: read-var gs#135232:u8
        let s_1694_0: bool = fn_state.gs_135232;
        // N s_1694_1: branch s_1694_0 b4785 b1695
        if s_1694_0 {
            return block_4785(state, tracer, fn_state);
        } else {
            return block_1695(state, tracer, fn_state);
        };
    }
    fn block_1695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1695_0: const #0u : u8
        let s_1695_0: bool = false;
        // D s_1695_1: write-var gs#135233 <= s_1695_0
        fn_state.gs_135233 = s_1695_0;
        // N s_1695_2: jump b1696
        return block_1696(state, tracer, fn_state);
    }
    fn block_1696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1696_0: read-var gs#135233:u8
        let s_1696_0: bool = fn_state.gs_135233;
        // N s_1696_1: branch s_1696_0 b4784 b1697
        if s_1696_0 {
            return block_4784(state, tracer, fn_state);
        } else {
            return block_1697(state, tracer, fn_state);
        };
    }
    fn block_1697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1697_0: const #0u : u8
        let s_1697_0: bool = false;
        // D s_1697_1: write-var gs#135234 <= s_1697_0
        fn_state.gs_135234 = s_1697_0;
        // N s_1697_2: jump b1698
        return block_1698(state, tracer, fn_state);
    }
    fn block_1698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1698_0: read-var gs#135234:u8
        let s_1698_0: bool = fn_state.gs_135234;
        // N s_1698_1: branch s_1698_0 b4783 b1699
        if s_1698_0 {
            return block_4783(state, tracer, fn_state);
        } else {
            return block_1699(state, tracer, fn_state);
        };
    }
    fn block_1699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1699_0: const #0u : u8
        let s_1699_0: bool = false;
        // D s_1699_1: write-var gs#135235 <= s_1699_0
        fn_state.gs_135235 = s_1699_0;
        // N s_1699_2: jump b1700
        return block_1700(state, tracer, fn_state);
    }
    fn block_1700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1700_0: read-var gs#135235:u8
        let s_1700_0: bool = fn_state.gs_135235;
        // N s_1700_1: branch s_1700_0 b4782 b1701
        if s_1700_0 {
            return block_4782(state, tracer, fn_state);
        } else {
            return block_1701(state, tracer, fn_state);
        };
    }
    fn block_1701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1701_0: read-var CRm:u8
        let s_1701_0: u8 = fn_state.CRm;
        // D s_1701_1: cast zx s_1701_0 -> bv
        let s_1701_1: Bits = Bits::new(s_1701_0 as u128, 4u16);
        // C s_1701_2: const #3u : u8
        let s_1701_2: u8 = 3;
        // C s_1701_3: cast zx s_1701_2 -> bv
        let s_1701_3: Bits = Bits::new(s_1701_2 as u128, 4u16);
        // D s_1701_4: cmp-eq s_1701_1 s_1701_3
        let s_1701_4: bool = ((s_1701_1) == (s_1701_3));
        // N s_1701_5: branch s_1701_4 b4781 b1702
        if s_1701_4 {
            return block_4781(state, tracer, fn_state);
        } else {
            return block_1702(state, tracer, fn_state);
        };
    }
    fn block_1702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1702_0: const #0u : u8
        let s_1702_0: bool = false;
        // D s_1702_1: write-var gs#135236 <= s_1702_0
        fn_state.gs_135236 = s_1702_0;
        // N s_1702_2: jump b1703
        return block_1703(state, tracer, fn_state);
    }
    fn block_1703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1703_0: read-var gs#135236:u8
        let s_1703_0: bool = fn_state.gs_135236;
        // N s_1703_1: branch s_1703_0 b4780 b1704
        if s_1703_0 {
            return block_4780(state, tracer, fn_state);
        } else {
            return block_1704(state, tracer, fn_state);
        };
    }
    fn block_1704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1704_0: const #0u : u8
        let s_1704_0: bool = false;
        // D s_1704_1: write-var gs#135237 <= s_1704_0
        fn_state.gs_135237 = s_1704_0;
        // N s_1704_2: jump b1705
        return block_1705(state, tracer, fn_state);
    }
    fn block_1705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1705_0: read-var gs#135237:u8
        let s_1705_0: bool = fn_state.gs_135237;
        // N s_1705_1: branch s_1705_0 b4779 b1706
        if s_1705_0 {
            return block_4779(state, tracer, fn_state);
        } else {
            return block_1706(state, tracer, fn_state);
        };
    }
    fn block_1706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1706_0: const #0u : u8
        let s_1706_0: bool = false;
        // D s_1706_1: write-var gs#135238 <= s_1706_0
        fn_state.gs_135238 = s_1706_0;
        // N s_1706_2: jump b1707
        return block_1707(state, tracer, fn_state);
    }
    fn block_1707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1707_0: read-var gs#135238:u8
        let s_1707_0: bool = fn_state.gs_135238;
        // N s_1707_1: branch s_1707_0 b4778 b1708
        if s_1707_0 {
            return block_4778(state, tracer, fn_state);
        } else {
            return block_1708(state, tracer, fn_state);
        };
    }
    fn block_1708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1708_0: const #0u : u8
        let s_1708_0: bool = false;
        // D s_1708_1: write-var gs#135239 <= s_1708_0
        fn_state.gs_135239 = s_1708_0;
        // N s_1708_2: jump b1709
        return block_1709(state, tracer, fn_state);
    }
    fn block_1709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1709_0: read-var gs#135239:u8
        let s_1709_0: bool = fn_state.gs_135239;
        // N s_1709_1: branch s_1709_0 b4777 b1710
        if s_1709_0 {
            return block_4777(state, tracer, fn_state);
        } else {
            return block_1710(state, tracer, fn_state);
        };
    }
    fn block_1710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1710_0: read-var CRm:u8
        let s_1710_0: u8 = fn_state.CRm;
        // D s_1710_1: cast zx s_1710_0 -> bv
        let s_1710_1: Bits = Bits::new(s_1710_0 as u128, 4u16);
        // C s_1710_2: const #1u : u8
        let s_1710_2: u8 = 1;
        // C s_1710_3: cast zx s_1710_2 -> bv
        let s_1710_3: Bits = Bits::new(s_1710_2 as u128, 4u16);
        // D s_1710_4: cmp-eq s_1710_1 s_1710_3
        let s_1710_4: bool = ((s_1710_1) == (s_1710_3));
        // N s_1710_5: branch s_1710_4 b4776 b1711
        if s_1710_4 {
            return block_4776(state, tracer, fn_state);
        } else {
            return block_1711(state, tracer, fn_state);
        };
    }
    fn block_1711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1711_0: const #0u : u8
        let s_1711_0: bool = false;
        // D s_1711_1: write-var gs#135240 <= s_1711_0
        fn_state.gs_135240 = s_1711_0;
        // N s_1711_2: jump b1712
        return block_1712(state, tracer, fn_state);
    }
    fn block_1712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1712_0: read-var gs#135240:u8
        let s_1712_0: bool = fn_state.gs_135240;
        // N s_1712_1: branch s_1712_0 b4775 b1713
        if s_1712_0 {
            return block_4775(state, tracer, fn_state);
        } else {
            return block_1713(state, tracer, fn_state);
        };
    }
    fn block_1713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1713_0: const #0u : u8
        let s_1713_0: bool = false;
        // D s_1713_1: write-var gs#135241 <= s_1713_0
        fn_state.gs_135241 = s_1713_0;
        // N s_1713_2: jump b1714
        return block_1714(state, tracer, fn_state);
    }
    fn block_1714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1714_0: read-var gs#135241:u8
        let s_1714_0: bool = fn_state.gs_135241;
        // N s_1714_1: branch s_1714_0 b4774 b1715
        if s_1714_0 {
            return block_4774(state, tracer, fn_state);
        } else {
            return block_1715(state, tracer, fn_state);
        };
    }
    fn block_1715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1715_0: const #0u : u8
        let s_1715_0: bool = false;
        // D s_1715_1: write-var gs#135242 <= s_1715_0
        fn_state.gs_135242 = s_1715_0;
        // N s_1715_2: jump b1716
        return block_1716(state, tracer, fn_state);
    }
    fn block_1716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1716_0: read-var gs#135242:u8
        let s_1716_0: bool = fn_state.gs_135242;
        // N s_1716_1: branch s_1716_0 b4773 b1717
        if s_1716_0 {
            return block_4773(state, tracer, fn_state);
        } else {
            return block_1717(state, tracer, fn_state);
        };
    }
    fn block_1717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1717_0: const #0u : u8
        let s_1717_0: bool = false;
        // D s_1717_1: write-var gs#135243 <= s_1717_0
        fn_state.gs_135243 = s_1717_0;
        // N s_1717_2: jump b1718
        return block_1718(state, tracer, fn_state);
    }
    fn block_1718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1718_0: read-var gs#135243:u8
        let s_1718_0: bool = fn_state.gs_135243;
        // N s_1718_1: branch s_1718_0 b4772 b1719
        if s_1718_0 {
            return block_4772(state, tracer, fn_state);
        } else {
            return block_1719(state, tracer, fn_state);
        };
    }
    fn block_1719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1719_0: read-var CRm:u8
        let s_1719_0: u8 = fn_state.CRm;
        // D s_1719_1: cast zx s_1719_0 -> bv
        let s_1719_1: Bits = Bits::new(s_1719_0 as u128, 4u16);
        // C s_1719_2: const #1u : u8
        let s_1719_2: u8 = 1;
        // C s_1719_3: cast zx s_1719_2 -> bv
        let s_1719_3: Bits = Bits::new(s_1719_2 as u128, 4u16);
        // D s_1719_4: cmp-eq s_1719_1 s_1719_3
        let s_1719_4: bool = ((s_1719_1) == (s_1719_3));
        // N s_1719_5: branch s_1719_4 b4771 b1720
        if s_1719_4 {
            return block_4771(state, tracer, fn_state);
        } else {
            return block_1720(state, tracer, fn_state);
        };
    }
    fn block_1720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1720_0: const #0u : u8
        let s_1720_0: bool = false;
        // D s_1720_1: write-var gs#135244 <= s_1720_0
        fn_state.gs_135244 = s_1720_0;
        // N s_1720_2: jump b1721
        return block_1721(state, tracer, fn_state);
    }
    fn block_1721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1721_0: read-var gs#135244:u8
        let s_1721_0: bool = fn_state.gs_135244;
        // N s_1721_1: branch s_1721_0 b4770 b1722
        if s_1721_0 {
            return block_4770(state, tracer, fn_state);
        } else {
            return block_1722(state, tracer, fn_state);
        };
    }
    fn block_1722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1722_0: const #0u : u8
        let s_1722_0: bool = false;
        // D s_1722_1: write-var gs#135245 <= s_1722_0
        fn_state.gs_135245 = s_1722_0;
        // N s_1722_2: jump b1723
        return block_1723(state, tracer, fn_state);
    }
    fn block_1723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1723_0: read-var gs#135245:u8
        let s_1723_0: bool = fn_state.gs_135245;
        // N s_1723_1: branch s_1723_0 b4769 b1724
        if s_1723_0 {
            return block_4769(state, tracer, fn_state);
        } else {
            return block_1724(state, tracer, fn_state);
        };
    }
    fn block_1724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1724_0: const #0u : u8
        let s_1724_0: bool = false;
        // D s_1724_1: write-var gs#135246 <= s_1724_0
        fn_state.gs_135246 = s_1724_0;
        // N s_1724_2: jump b1725
        return block_1725(state, tracer, fn_state);
    }
    fn block_1725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1725_0: read-var gs#135246:u8
        let s_1725_0: bool = fn_state.gs_135246;
        // N s_1725_1: branch s_1725_0 b4768 b1726
        if s_1725_0 {
            return block_4768(state, tracer, fn_state);
        } else {
            return block_1726(state, tracer, fn_state);
        };
    }
    fn block_1726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1726_0: const #0u : u8
        let s_1726_0: bool = false;
        // D s_1726_1: write-var gs#135247 <= s_1726_0
        fn_state.gs_135247 = s_1726_0;
        // N s_1726_2: jump b1727
        return block_1727(state, tracer, fn_state);
    }
    fn block_1727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1727_0: read-var gs#135247:u8
        let s_1727_0: bool = fn_state.gs_135247;
        // N s_1727_1: branch s_1727_0 b4767 b1728
        if s_1727_0 {
            return block_4767(state, tracer, fn_state);
        } else {
            return block_1728(state, tracer, fn_state);
        };
    }
    fn block_1728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1728_0: read-var CRm:u8
        let s_1728_0: u8 = fn_state.CRm;
        // D s_1728_1: cast zx s_1728_0 -> bv
        let s_1728_1: Bits = Bits::new(s_1728_0 as u128, 4u16);
        // C s_1728_2: const #9u : u8
        let s_1728_2: u8 = 9;
        // C s_1728_3: cast zx s_1728_2 -> bv
        let s_1728_3: Bits = Bits::new(s_1728_2 as u128, 4u16);
        // D s_1728_4: cmp-eq s_1728_1 s_1728_3
        let s_1728_4: bool = ((s_1728_1) == (s_1728_3));
        // N s_1728_5: branch s_1728_4 b4766 b1729
        if s_1728_4 {
            return block_4766(state, tracer, fn_state);
        } else {
            return block_1729(state, tracer, fn_state);
        };
    }
    fn block_1729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1729_0: const #0u : u8
        let s_1729_0: bool = false;
        // D s_1729_1: write-var gs#135248 <= s_1729_0
        fn_state.gs_135248 = s_1729_0;
        // N s_1729_2: jump b1730
        return block_1730(state, tracer, fn_state);
    }
    fn block_1730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1730_0: read-var gs#135248:u8
        let s_1730_0: bool = fn_state.gs_135248;
        // N s_1730_1: branch s_1730_0 b4765 b1731
        if s_1730_0 {
            return block_4765(state, tracer, fn_state);
        } else {
            return block_1731(state, tracer, fn_state);
        };
    }
    fn block_1731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1731_0: const #0u : u8
        let s_1731_0: bool = false;
        // D s_1731_1: write-var gs#135249 <= s_1731_0
        fn_state.gs_135249 = s_1731_0;
        // N s_1731_2: jump b1732
        return block_1732(state, tracer, fn_state);
    }
    fn block_1732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1732_0: read-var gs#135249:u8
        let s_1732_0: bool = fn_state.gs_135249;
        // N s_1732_1: branch s_1732_0 b4764 b1733
        if s_1732_0 {
            return block_4764(state, tracer, fn_state);
        } else {
            return block_1733(state, tracer, fn_state);
        };
    }
    fn block_1733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1733_0: const #0u : u8
        let s_1733_0: bool = false;
        // D s_1733_1: write-var gs#135250 <= s_1733_0
        fn_state.gs_135250 = s_1733_0;
        // N s_1733_2: jump b1734
        return block_1734(state, tracer, fn_state);
    }
    fn block_1734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1734_0: read-var gs#135250:u8
        let s_1734_0: bool = fn_state.gs_135250;
        // N s_1734_1: branch s_1734_0 b4763 b1735
        if s_1734_0 {
            return block_4763(state, tracer, fn_state);
        } else {
            return block_1735(state, tracer, fn_state);
        };
    }
    fn block_1735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1735_0: const #0u : u8
        let s_1735_0: bool = false;
        // D s_1735_1: write-var gs#135251 <= s_1735_0
        fn_state.gs_135251 = s_1735_0;
        // N s_1735_2: jump b1736
        return block_1736(state, tracer, fn_state);
    }
    fn block_1736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1736_0: read-var gs#135251:u8
        let s_1736_0: bool = fn_state.gs_135251;
        // N s_1736_1: branch s_1736_0 b4762 b1737
        if s_1736_0 {
            return block_4762(state, tracer, fn_state);
        } else {
            return block_1737(state, tracer, fn_state);
        };
    }
    fn block_1737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1737_0: read-var CRm:u8
        let s_1737_0: u8 = fn_state.CRm;
        // D s_1737_1: cast zx s_1737_0 -> bv
        let s_1737_1: Bits = Bits::new(s_1737_0 as u128, 4u16);
        // C s_1737_2: const #9u : u8
        let s_1737_2: u8 = 9;
        // C s_1737_3: cast zx s_1737_2 -> bv
        let s_1737_3: Bits = Bits::new(s_1737_2 as u128, 4u16);
        // D s_1737_4: cmp-eq s_1737_1 s_1737_3
        let s_1737_4: bool = ((s_1737_1) == (s_1737_3));
        // N s_1737_5: branch s_1737_4 b4761 b1738
        if s_1737_4 {
            return block_4761(state, tracer, fn_state);
        } else {
            return block_1738(state, tracer, fn_state);
        };
    }
    fn block_1738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1738_0: const #0u : u8
        let s_1738_0: bool = false;
        // D s_1738_1: write-var gs#135252 <= s_1738_0
        fn_state.gs_135252 = s_1738_0;
        // N s_1738_2: jump b1739
        return block_1739(state, tracer, fn_state);
    }
    fn block_1739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1739_0: read-var gs#135252:u8
        let s_1739_0: bool = fn_state.gs_135252;
        // N s_1739_1: branch s_1739_0 b4760 b1740
        if s_1739_0 {
            return block_4760(state, tracer, fn_state);
        } else {
            return block_1740(state, tracer, fn_state);
        };
    }
    fn block_1740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1740_0: const #0u : u8
        let s_1740_0: bool = false;
        // D s_1740_1: write-var gs#135253 <= s_1740_0
        fn_state.gs_135253 = s_1740_0;
        // N s_1740_2: jump b1741
        return block_1741(state, tracer, fn_state);
    }
    fn block_1741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1741_0: read-var gs#135253:u8
        let s_1741_0: bool = fn_state.gs_135253;
        // N s_1741_1: branch s_1741_0 b4759 b1742
        if s_1741_0 {
            return block_4759(state, tracer, fn_state);
        } else {
            return block_1742(state, tracer, fn_state);
        };
    }
    fn block_1742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1742_0: const #0u : u8
        let s_1742_0: bool = false;
        // D s_1742_1: write-var gs#135254 <= s_1742_0
        fn_state.gs_135254 = s_1742_0;
        // N s_1742_2: jump b1743
        return block_1743(state, tracer, fn_state);
    }
    fn block_1743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1743_0: read-var gs#135254:u8
        let s_1743_0: bool = fn_state.gs_135254;
        // N s_1743_1: branch s_1743_0 b4758 b1744
        if s_1743_0 {
            return block_4758(state, tracer, fn_state);
        } else {
            return block_1744(state, tracer, fn_state);
        };
    }
    fn block_1744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1744_0: const #0u : u8
        let s_1744_0: bool = false;
        // D s_1744_1: write-var gs#135255 <= s_1744_0
        fn_state.gs_135255 = s_1744_0;
        // N s_1744_2: jump b1745
        return block_1745(state, tracer, fn_state);
    }
    fn block_1745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1745_0: read-var gs#135255:u8
        let s_1745_0: bool = fn_state.gs_135255;
        // N s_1745_1: branch s_1745_0 b4757 b1746
        if s_1745_0 {
            return block_4757(state, tracer, fn_state);
        } else {
            return block_1746(state, tracer, fn_state);
        };
    }
    fn block_1746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1746_0: read-var CRm:u8
        let s_1746_0: u8 = fn_state.CRm;
        // D s_1746_1: cast zx s_1746_0 -> bv
        let s_1746_1: Bits = Bits::new(s_1746_0 as u128, 4u16);
        // C s_1746_2: const #9u : u8
        let s_1746_2: u8 = 9;
        // C s_1746_3: cast zx s_1746_2 -> bv
        let s_1746_3: Bits = Bits::new(s_1746_2 as u128, 4u16);
        // D s_1746_4: cmp-eq s_1746_1 s_1746_3
        let s_1746_4: bool = ((s_1746_1) == (s_1746_3));
        // N s_1746_5: branch s_1746_4 b4756 b1747
        if s_1746_4 {
            return block_4756(state, tracer, fn_state);
        } else {
            return block_1747(state, tracer, fn_state);
        };
    }
    fn block_1747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1747_0: const #0u : u8
        let s_1747_0: bool = false;
        // D s_1747_1: write-var gs#135256 <= s_1747_0
        fn_state.gs_135256 = s_1747_0;
        // N s_1747_2: jump b1748
        return block_1748(state, tracer, fn_state);
    }
    fn block_1748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1748_0: read-var gs#135256:u8
        let s_1748_0: bool = fn_state.gs_135256;
        // N s_1748_1: branch s_1748_0 b4755 b1749
        if s_1748_0 {
            return block_4755(state, tracer, fn_state);
        } else {
            return block_1749(state, tracer, fn_state);
        };
    }
    fn block_1749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1749_0: const #0u : u8
        let s_1749_0: bool = false;
        // D s_1749_1: write-var gs#135257 <= s_1749_0
        fn_state.gs_135257 = s_1749_0;
        // N s_1749_2: jump b1750
        return block_1750(state, tracer, fn_state);
    }
    fn block_1750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1750_0: read-var gs#135257:u8
        let s_1750_0: bool = fn_state.gs_135257;
        // N s_1750_1: branch s_1750_0 b4754 b1751
        if s_1750_0 {
            return block_4754(state, tracer, fn_state);
        } else {
            return block_1751(state, tracer, fn_state);
        };
    }
    fn block_1751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1751_0: const #0u : u8
        let s_1751_0: bool = false;
        // D s_1751_1: write-var gs#135258 <= s_1751_0
        fn_state.gs_135258 = s_1751_0;
        // N s_1751_2: jump b1752
        return block_1752(state, tracer, fn_state);
    }
    fn block_1752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1752_0: read-var gs#135258:u8
        let s_1752_0: bool = fn_state.gs_135258;
        // N s_1752_1: branch s_1752_0 b4753 b1753
        if s_1752_0 {
            return block_4753(state, tracer, fn_state);
        } else {
            return block_1753(state, tracer, fn_state);
        };
    }
    fn block_1753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1753_0: const #0u : u8
        let s_1753_0: bool = false;
        // D s_1753_1: write-var gs#135259 <= s_1753_0
        fn_state.gs_135259 = s_1753_0;
        // N s_1753_2: jump b1754
        return block_1754(state, tracer, fn_state);
    }
    fn block_1754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1754_0: read-var gs#135259:u8
        let s_1754_0: bool = fn_state.gs_135259;
        // N s_1754_1: branch s_1754_0 b4752 b1755
        if s_1754_0 {
            return block_4752(state, tracer, fn_state);
        } else {
            return block_1755(state, tracer, fn_state);
        };
    }
    fn block_1755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1755_0: read-var CRm:u8
        let s_1755_0: u8 = fn_state.CRm;
        // D s_1755_1: cast zx s_1755_0 -> bv
        let s_1755_1: Bits = Bits::new(s_1755_0 as u128, 4u16);
        // C s_1755_2: const #9u : u8
        let s_1755_2: u8 = 9;
        // C s_1755_3: cast zx s_1755_2 -> bv
        let s_1755_3: Bits = Bits::new(s_1755_2 as u128, 4u16);
        // D s_1755_4: cmp-eq s_1755_1 s_1755_3
        let s_1755_4: bool = ((s_1755_1) == (s_1755_3));
        // N s_1755_5: branch s_1755_4 b4751 b1756
        if s_1755_4 {
            return block_4751(state, tracer, fn_state);
        } else {
            return block_1756(state, tracer, fn_state);
        };
    }
    fn block_1756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1756_0: const #0u : u8
        let s_1756_0: bool = false;
        // D s_1756_1: write-var gs#135260 <= s_1756_0
        fn_state.gs_135260 = s_1756_0;
        // N s_1756_2: jump b1757
        return block_1757(state, tracer, fn_state);
    }
    fn block_1757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1757_0: read-var gs#135260:u8
        let s_1757_0: bool = fn_state.gs_135260;
        // N s_1757_1: branch s_1757_0 b4750 b1758
        if s_1757_0 {
            return block_4750(state, tracer, fn_state);
        } else {
            return block_1758(state, tracer, fn_state);
        };
    }
    fn block_1758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1758_0: const #0u : u8
        let s_1758_0: bool = false;
        // D s_1758_1: write-var gs#135261 <= s_1758_0
        fn_state.gs_135261 = s_1758_0;
        // N s_1758_2: jump b1759
        return block_1759(state, tracer, fn_state);
    }
    fn block_1759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1759_0: read-var gs#135261:u8
        let s_1759_0: bool = fn_state.gs_135261;
        // N s_1759_1: branch s_1759_0 b4749 b1760
        if s_1759_0 {
            return block_4749(state, tracer, fn_state);
        } else {
            return block_1760(state, tracer, fn_state);
        };
    }
    fn block_1760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1760_0: const #0u : u8
        let s_1760_0: bool = false;
        // D s_1760_1: write-var gs#135262 <= s_1760_0
        fn_state.gs_135262 = s_1760_0;
        // N s_1760_2: jump b1761
        return block_1761(state, tracer, fn_state);
    }
    fn block_1761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1761_0: read-var gs#135262:u8
        let s_1761_0: bool = fn_state.gs_135262;
        // N s_1761_1: branch s_1761_0 b4748 b1762
        if s_1761_0 {
            return block_4748(state, tracer, fn_state);
        } else {
            return block_1762(state, tracer, fn_state);
        };
    }
    fn block_1762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1762_0: const #0u : u8
        let s_1762_0: bool = false;
        // D s_1762_1: write-var gs#135263 <= s_1762_0
        fn_state.gs_135263 = s_1762_0;
        // N s_1762_2: jump b1763
        return block_1763(state, tracer, fn_state);
    }
    fn block_1763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1763_0: read-var gs#135263:u8
        let s_1763_0: bool = fn_state.gs_135263;
        // N s_1763_1: branch s_1763_0 b4747 b1764
        if s_1763_0 {
            return block_4747(state, tracer, fn_state);
        } else {
            return block_1764(state, tracer, fn_state);
        };
    }
    fn block_1764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1764_0: read-var CRm:u8
        let s_1764_0: u8 = fn_state.CRm;
        // D s_1764_1: cast zx s_1764_0 -> bv
        let s_1764_1: Bits = Bits::new(s_1764_0 as u128, 4u16);
        // C s_1764_2: const #3u : u8
        let s_1764_2: u8 = 3;
        // C s_1764_3: cast zx s_1764_2 -> bv
        let s_1764_3: Bits = Bits::new(s_1764_2 as u128, 4u16);
        // D s_1764_4: cmp-eq s_1764_1 s_1764_3
        let s_1764_4: bool = ((s_1764_1) == (s_1764_3));
        // N s_1764_5: branch s_1764_4 b4746 b1765
        if s_1764_4 {
            return block_4746(state, tracer, fn_state);
        } else {
            return block_1765(state, tracer, fn_state);
        };
    }
    fn block_1765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1765_0: const #0u : u8
        let s_1765_0: bool = false;
        // D s_1765_1: write-var gs#135264 <= s_1765_0
        fn_state.gs_135264 = s_1765_0;
        // N s_1765_2: jump b1766
        return block_1766(state, tracer, fn_state);
    }
    fn block_1766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1766_0: read-var gs#135264:u8
        let s_1766_0: bool = fn_state.gs_135264;
        // N s_1766_1: branch s_1766_0 b4745 b1767
        if s_1766_0 {
            return block_4745(state, tracer, fn_state);
        } else {
            return block_1767(state, tracer, fn_state);
        };
    }
    fn block_1767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1767_0: const #0u : u8
        let s_1767_0: bool = false;
        // D s_1767_1: write-var gs#135265 <= s_1767_0
        fn_state.gs_135265 = s_1767_0;
        // N s_1767_2: jump b1768
        return block_1768(state, tracer, fn_state);
    }
    fn block_1768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1768_0: read-var gs#135265:u8
        let s_1768_0: bool = fn_state.gs_135265;
        // N s_1768_1: branch s_1768_0 b4744 b1769
        if s_1768_0 {
            return block_4744(state, tracer, fn_state);
        } else {
            return block_1769(state, tracer, fn_state);
        };
    }
    fn block_1769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1769_0: const #0u : u8
        let s_1769_0: bool = false;
        // D s_1769_1: write-var gs#135266 <= s_1769_0
        fn_state.gs_135266 = s_1769_0;
        // N s_1769_2: jump b1770
        return block_1770(state, tracer, fn_state);
    }
    fn block_1770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1770_0: read-var gs#135266:u8
        let s_1770_0: bool = fn_state.gs_135266;
        // N s_1770_1: branch s_1770_0 b4743 b1771
        if s_1770_0 {
            return block_4743(state, tracer, fn_state);
        } else {
            return block_1771(state, tracer, fn_state);
        };
    }
    fn block_1771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1771_0: const #0u : u8
        let s_1771_0: bool = false;
        // D s_1771_1: write-var gs#135267 <= s_1771_0
        fn_state.gs_135267 = s_1771_0;
        // N s_1771_2: jump b1772
        return block_1772(state, tracer, fn_state);
    }
    fn block_1772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1772_0: read-var gs#135267:u8
        let s_1772_0: bool = fn_state.gs_135267;
        // N s_1772_1: branch s_1772_0 b4742 b1773
        if s_1772_0 {
            return block_4742(state, tracer, fn_state);
        } else {
            return block_1773(state, tracer, fn_state);
        };
    }
    fn block_1773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1773_0: read-var CRm:u8
        let s_1773_0: u8 = fn_state.CRm;
        // D s_1773_1: cast zx s_1773_0 -> bv
        let s_1773_1: Bits = Bits::new(s_1773_0 as u128, 4u16);
        // C s_1773_2: const #1u : u8
        let s_1773_2: u8 = 1;
        // C s_1773_3: cast zx s_1773_2 -> bv
        let s_1773_3: Bits = Bits::new(s_1773_2 as u128, 4u16);
        // D s_1773_4: cmp-eq s_1773_1 s_1773_3
        let s_1773_4: bool = ((s_1773_1) == (s_1773_3));
        // N s_1773_5: branch s_1773_4 b4741 b1774
        if s_1773_4 {
            return block_4741(state, tracer, fn_state);
        } else {
            return block_1774(state, tracer, fn_state);
        };
    }
    fn block_1774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1774_0: const #0u : u8
        let s_1774_0: bool = false;
        // D s_1774_1: write-var gs#135268 <= s_1774_0
        fn_state.gs_135268 = s_1774_0;
        // N s_1774_2: jump b1775
        return block_1775(state, tracer, fn_state);
    }
    fn block_1775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1775_0: read-var gs#135268:u8
        let s_1775_0: bool = fn_state.gs_135268;
        // N s_1775_1: branch s_1775_0 b4740 b1776
        if s_1775_0 {
            return block_4740(state, tracer, fn_state);
        } else {
            return block_1776(state, tracer, fn_state);
        };
    }
    fn block_1776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1776_0: const #0u : u8
        let s_1776_0: bool = false;
        // D s_1776_1: write-var gs#135269 <= s_1776_0
        fn_state.gs_135269 = s_1776_0;
        // N s_1776_2: jump b1777
        return block_1777(state, tracer, fn_state);
    }
    fn block_1777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1777_0: read-var gs#135269:u8
        let s_1777_0: bool = fn_state.gs_135269;
        // N s_1777_1: branch s_1777_0 b4739 b1778
        if s_1777_0 {
            return block_4739(state, tracer, fn_state);
        } else {
            return block_1778(state, tracer, fn_state);
        };
    }
    fn block_1778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1778_0: const #0u : u8
        let s_1778_0: bool = false;
        // D s_1778_1: write-var gs#135270 <= s_1778_0
        fn_state.gs_135270 = s_1778_0;
        // N s_1778_2: jump b1779
        return block_1779(state, tracer, fn_state);
    }
    fn block_1779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1779_0: read-var gs#135270:u8
        let s_1779_0: bool = fn_state.gs_135270;
        // N s_1779_1: branch s_1779_0 b4738 b1780
        if s_1779_0 {
            return block_4738(state, tracer, fn_state);
        } else {
            return block_1780(state, tracer, fn_state);
        };
    }
    fn block_1780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1780_0: const #0u : u8
        let s_1780_0: bool = false;
        // D s_1780_1: write-var gs#135271 <= s_1780_0
        fn_state.gs_135271 = s_1780_0;
        // N s_1780_2: jump b1781
        return block_1781(state, tracer, fn_state);
    }
    fn block_1781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1781_0: read-var gs#135271:u8
        let s_1781_0: bool = fn_state.gs_135271;
        // N s_1781_1: branch s_1781_0 b4737 b1782
        if s_1781_0 {
            return block_4737(state, tracer, fn_state);
        } else {
            return block_1782(state, tracer, fn_state);
        };
    }
    fn block_1782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1782_0: read-var CRm:u8
        let s_1782_0: u8 = fn_state.CRm;
        // D s_1782_1: cast zx s_1782_0 -> bv
        let s_1782_1: Bits = Bits::new(s_1782_0 as u128, 4u16);
        // C s_1782_2: const #3u : u8
        let s_1782_2: u8 = 3;
        // C s_1782_3: cast zx s_1782_2 -> bv
        let s_1782_3: Bits = Bits::new(s_1782_2 as u128, 4u16);
        // D s_1782_4: cmp-eq s_1782_1 s_1782_3
        let s_1782_4: bool = ((s_1782_1) == (s_1782_3));
        // N s_1782_5: branch s_1782_4 b4736 b1783
        if s_1782_4 {
            return block_4736(state, tracer, fn_state);
        } else {
            return block_1783(state, tracer, fn_state);
        };
    }
    fn block_1783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1783_0: const #0u : u8
        let s_1783_0: bool = false;
        // D s_1783_1: write-var gs#135272 <= s_1783_0
        fn_state.gs_135272 = s_1783_0;
        // N s_1783_2: jump b1784
        return block_1784(state, tracer, fn_state);
    }
    fn block_1784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1784_0: read-var gs#135272:u8
        let s_1784_0: bool = fn_state.gs_135272;
        // N s_1784_1: branch s_1784_0 b4735 b1785
        if s_1784_0 {
            return block_4735(state, tracer, fn_state);
        } else {
            return block_1785(state, tracer, fn_state);
        };
    }
    fn block_1785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1785_0: const #0u : u8
        let s_1785_0: bool = false;
        // D s_1785_1: write-var gs#135273 <= s_1785_0
        fn_state.gs_135273 = s_1785_0;
        // N s_1785_2: jump b1786
        return block_1786(state, tracer, fn_state);
    }
    fn block_1786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1786_0: read-var gs#135273:u8
        let s_1786_0: bool = fn_state.gs_135273;
        // N s_1786_1: branch s_1786_0 b4734 b1787
        if s_1786_0 {
            return block_4734(state, tracer, fn_state);
        } else {
            return block_1787(state, tracer, fn_state);
        };
    }
    fn block_1787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1787_0: const #0u : u8
        let s_1787_0: bool = false;
        // D s_1787_1: write-var gs#135274 <= s_1787_0
        fn_state.gs_135274 = s_1787_0;
        // N s_1787_2: jump b1788
        return block_1788(state, tracer, fn_state);
    }
    fn block_1788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1788_0: read-var gs#135274:u8
        let s_1788_0: bool = fn_state.gs_135274;
        // N s_1788_1: branch s_1788_0 b4733 b1789
        if s_1788_0 {
            return block_4733(state, tracer, fn_state);
        } else {
            return block_1789(state, tracer, fn_state);
        };
    }
    fn block_1789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1789_0: const #0u : u8
        let s_1789_0: bool = false;
        // D s_1789_1: write-var gs#135275 <= s_1789_0
        fn_state.gs_135275 = s_1789_0;
        // N s_1789_2: jump b1790
        return block_1790(state, tracer, fn_state);
    }
    fn block_1790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1790_0: read-var gs#135275:u8
        let s_1790_0: bool = fn_state.gs_135275;
        // N s_1790_1: branch s_1790_0 b4732 b1791
        if s_1790_0 {
            return block_4732(state, tracer, fn_state);
        } else {
            return block_1791(state, tracer, fn_state);
        };
    }
    fn block_1791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1791_0: read-var CRm:u8
        let s_1791_0: u8 = fn_state.CRm;
        // D s_1791_1: cast zx s_1791_0 -> bv
        let s_1791_1: Bits = Bits::new(s_1791_0 as u128, 4u16);
        // C s_1791_2: const #3u : u8
        let s_1791_2: u8 = 3;
        // C s_1791_3: cast zx s_1791_2 -> bv
        let s_1791_3: Bits = Bits::new(s_1791_2 as u128, 4u16);
        // D s_1791_4: cmp-eq s_1791_1 s_1791_3
        let s_1791_4: bool = ((s_1791_1) == (s_1791_3));
        // N s_1791_5: branch s_1791_4 b4731 b1792
        if s_1791_4 {
            return block_4731(state, tracer, fn_state);
        } else {
            return block_1792(state, tracer, fn_state);
        };
    }
    fn block_1792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1792_0: const #0u : u8
        let s_1792_0: bool = false;
        // D s_1792_1: write-var gs#135276 <= s_1792_0
        fn_state.gs_135276 = s_1792_0;
        // N s_1792_2: jump b1793
        return block_1793(state, tracer, fn_state);
    }
    fn block_1793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1793_0: read-var gs#135276:u8
        let s_1793_0: bool = fn_state.gs_135276;
        // N s_1793_1: branch s_1793_0 b4730 b1794
        if s_1793_0 {
            return block_4730(state, tracer, fn_state);
        } else {
            return block_1794(state, tracer, fn_state);
        };
    }
    fn block_1794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1794_0: const #0u : u8
        let s_1794_0: bool = false;
        // D s_1794_1: write-var gs#135277 <= s_1794_0
        fn_state.gs_135277 = s_1794_0;
        // N s_1794_2: jump b1795
        return block_1795(state, tracer, fn_state);
    }
    fn block_1795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1795_0: read-var gs#135277:u8
        let s_1795_0: bool = fn_state.gs_135277;
        // N s_1795_1: branch s_1795_0 b4729 b1796
        if s_1795_0 {
            return block_4729(state, tracer, fn_state);
        } else {
            return block_1796(state, tracer, fn_state);
        };
    }
    fn block_1796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1796_0: const #0u : u8
        let s_1796_0: bool = false;
        // D s_1796_1: write-var gs#135278 <= s_1796_0
        fn_state.gs_135278 = s_1796_0;
        // N s_1796_2: jump b1797
        return block_1797(state, tracer, fn_state);
    }
    fn block_1797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1797_0: read-var gs#135278:u8
        let s_1797_0: bool = fn_state.gs_135278;
        // N s_1797_1: branch s_1797_0 b4728 b1798
        if s_1797_0 {
            return block_4728(state, tracer, fn_state);
        } else {
            return block_1798(state, tracer, fn_state);
        };
    }
    fn block_1798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1798_0: const #0u : u8
        let s_1798_0: bool = false;
        // D s_1798_1: write-var gs#135279 <= s_1798_0
        fn_state.gs_135279 = s_1798_0;
        // N s_1798_2: jump b1799
        return block_1799(state, tracer, fn_state);
    }
    fn block_1799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1799_0: read-var gs#135279:u8
        let s_1799_0: bool = fn_state.gs_135279;
        // N s_1799_1: branch s_1799_0 b4727 b1800
        if s_1799_0 {
            return block_4727(state, tracer, fn_state);
        } else {
            return block_1800(state, tracer, fn_state);
        };
    }
    fn block_1800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1800_0: read-var CRm:u8
        let s_1800_0: u8 = fn_state.CRm;
        // D s_1800_1: cast zx s_1800_0 -> bv
        let s_1800_1: Bits = Bits::new(s_1800_0 as u128, 4u16);
        // C s_1800_2: const #9u : u8
        let s_1800_2: u8 = 9;
        // C s_1800_3: cast zx s_1800_2 -> bv
        let s_1800_3: Bits = Bits::new(s_1800_2 as u128, 4u16);
        // D s_1800_4: cmp-eq s_1800_1 s_1800_3
        let s_1800_4: bool = ((s_1800_1) == (s_1800_3));
        // N s_1800_5: branch s_1800_4 b4726 b1801
        if s_1800_4 {
            return block_4726(state, tracer, fn_state);
        } else {
            return block_1801(state, tracer, fn_state);
        };
    }
    fn block_1801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1801_0: const #0u : u8
        let s_1801_0: bool = false;
        // D s_1801_1: write-var gs#135280 <= s_1801_0
        fn_state.gs_135280 = s_1801_0;
        // N s_1801_2: jump b1802
        return block_1802(state, tracer, fn_state);
    }
    fn block_1802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1802_0: read-var gs#135280:u8
        let s_1802_0: bool = fn_state.gs_135280;
        // N s_1802_1: branch s_1802_0 b4725 b1803
        if s_1802_0 {
            return block_4725(state, tracer, fn_state);
        } else {
            return block_1803(state, tracer, fn_state);
        };
    }
    fn block_1803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1803_0: const #0u : u8
        let s_1803_0: bool = false;
        // D s_1803_1: write-var gs#135281 <= s_1803_0
        fn_state.gs_135281 = s_1803_0;
        // N s_1803_2: jump b1804
        return block_1804(state, tracer, fn_state);
    }
    fn block_1804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1804_0: read-var gs#135281:u8
        let s_1804_0: bool = fn_state.gs_135281;
        // N s_1804_1: branch s_1804_0 b4724 b1805
        if s_1804_0 {
            return block_4724(state, tracer, fn_state);
        } else {
            return block_1805(state, tracer, fn_state);
        };
    }
    fn block_1805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1805_0: const #0u : u8
        let s_1805_0: bool = false;
        // D s_1805_1: write-var gs#135282 <= s_1805_0
        fn_state.gs_135282 = s_1805_0;
        // N s_1805_2: jump b1806
        return block_1806(state, tracer, fn_state);
    }
    fn block_1806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1806_0: read-var gs#135282:u8
        let s_1806_0: bool = fn_state.gs_135282;
        // N s_1806_1: branch s_1806_0 b4723 b1807
        if s_1806_0 {
            return block_4723(state, tracer, fn_state);
        } else {
            return block_1807(state, tracer, fn_state);
        };
    }
    fn block_1807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1807_0: const #0u : u8
        let s_1807_0: bool = false;
        // D s_1807_1: write-var gs#135283 <= s_1807_0
        fn_state.gs_135283 = s_1807_0;
        // N s_1807_2: jump b1808
        return block_1808(state, tracer, fn_state);
    }
    fn block_1808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1808_0: read-var gs#135283:u8
        let s_1808_0: bool = fn_state.gs_135283;
        // N s_1808_1: branch s_1808_0 b4722 b1809
        if s_1808_0 {
            return block_4722(state, tracer, fn_state);
        } else {
            return block_1809(state, tracer, fn_state);
        };
    }
    fn block_1809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1809_0: read-var CRm:u8
        let s_1809_0: u8 = fn_state.CRm;
        // D s_1809_1: cast zx s_1809_0 -> bv
        let s_1809_1: Bits = Bits::new(s_1809_0 as u128, 4u16);
        // C s_1809_2: const #15u : u8
        let s_1809_2: u8 = 15;
        // C s_1809_3: cast zx s_1809_2 -> bv
        let s_1809_3: Bits = Bits::new(s_1809_2 as u128, 4u16);
        // D s_1809_4: cmp-eq s_1809_1 s_1809_3
        let s_1809_4: bool = ((s_1809_1) == (s_1809_3));
        // N s_1809_5: branch s_1809_4 b4721 b1810
        if s_1809_4 {
            return block_4721(state, tracer, fn_state);
        } else {
            return block_1810(state, tracer, fn_state);
        };
    }
    fn block_1810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1810_0: const #0u : u8
        let s_1810_0: bool = false;
        // D s_1810_1: write-var gs#135284 <= s_1810_0
        fn_state.gs_135284 = s_1810_0;
        // N s_1810_2: jump b1811
        return block_1811(state, tracer, fn_state);
    }
    fn block_1811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1811_0: read-var gs#135284:u8
        let s_1811_0: bool = fn_state.gs_135284;
        // N s_1811_1: branch s_1811_0 b4720 b1812
        if s_1811_0 {
            return block_4720(state, tracer, fn_state);
        } else {
            return block_1812(state, tracer, fn_state);
        };
    }
    fn block_1812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1812_0: const #0u : u8
        let s_1812_0: bool = false;
        // D s_1812_1: write-var gs#135285 <= s_1812_0
        fn_state.gs_135285 = s_1812_0;
        // N s_1812_2: jump b1813
        return block_1813(state, tracer, fn_state);
    }
    fn block_1813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1813_0: read-var gs#135285:u8
        let s_1813_0: bool = fn_state.gs_135285;
        // N s_1813_1: branch s_1813_0 b4719 b1814
        if s_1813_0 {
            return block_4719(state, tracer, fn_state);
        } else {
            return block_1814(state, tracer, fn_state);
        };
    }
    fn block_1814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1814_0: const #0u : u8
        let s_1814_0: bool = false;
        // D s_1814_1: write-var gs#135286 <= s_1814_0
        fn_state.gs_135286 = s_1814_0;
        // N s_1814_2: jump b1815
        return block_1815(state, tracer, fn_state);
    }
    fn block_1815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1815_0: read-var gs#135286:u8
        let s_1815_0: bool = fn_state.gs_135286;
        // N s_1815_1: branch s_1815_0 b4718 b1816
        if s_1815_0 {
            return block_4718(state, tracer, fn_state);
        } else {
            return block_1816(state, tracer, fn_state);
        };
    }
    fn block_1816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1816_0: const #0u : u8
        let s_1816_0: bool = false;
        // D s_1816_1: write-var gs#135287 <= s_1816_0
        fn_state.gs_135287 = s_1816_0;
        // N s_1816_2: jump b1817
        return block_1817(state, tracer, fn_state);
    }
    fn block_1817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1817_0: read-var gs#135287:u8
        let s_1817_0: bool = fn_state.gs_135287;
        // N s_1817_1: branch s_1817_0 b4717 b1818
        if s_1817_0 {
            return block_4717(state, tracer, fn_state);
        } else {
            return block_1818(state, tracer, fn_state);
        };
    }
    fn block_1818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1818_0: read-var CRm:u8
        let s_1818_0: u8 = fn_state.CRm;
        // D s_1818_1: cast zx s_1818_0 -> bv
        let s_1818_1: Bits = Bits::new(s_1818_0 as u128, 4u16);
        // C s_1818_2: const #3u : u8
        let s_1818_2: u8 = 3;
        // C s_1818_3: cast zx s_1818_2 -> bv
        let s_1818_3: Bits = Bits::new(s_1818_2 as u128, 4u16);
        // D s_1818_4: cmp-eq s_1818_1 s_1818_3
        let s_1818_4: bool = ((s_1818_1) == (s_1818_3));
        // N s_1818_5: branch s_1818_4 b4716 b1819
        if s_1818_4 {
            return block_4716(state, tracer, fn_state);
        } else {
            return block_1819(state, tracer, fn_state);
        };
    }
    fn block_1819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1819_0: const #0u : u8
        let s_1819_0: bool = false;
        // D s_1819_1: write-var gs#135288 <= s_1819_0
        fn_state.gs_135288 = s_1819_0;
        // N s_1819_2: jump b1820
        return block_1820(state, tracer, fn_state);
    }
    fn block_1820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1820_0: read-var gs#135288:u8
        let s_1820_0: bool = fn_state.gs_135288;
        // N s_1820_1: branch s_1820_0 b4715 b1821
        if s_1820_0 {
            return block_4715(state, tracer, fn_state);
        } else {
            return block_1821(state, tracer, fn_state);
        };
    }
    fn block_1821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1821_0: const #0u : u8
        let s_1821_0: bool = false;
        // D s_1821_1: write-var gs#135289 <= s_1821_0
        fn_state.gs_135289 = s_1821_0;
        // N s_1821_2: jump b1822
        return block_1822(state, tracer, fn_state);
    }
    fn block_1822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1822_0: read-var gs#135289:u8
        let s_1822_0: bool = fn_state.gs_135289;
        // N s_1822_1: branch s_1822_0 b4714 b1823
        if s_1822_0 {
            return block_4714(state, tracer, fn_state);
        } else {
            return block_1823(state, tracer, fn_state);
        };
    }
    fn block_1823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1823_0: const #0u : u8
        let s_1823_0: bool = false;
        // D s_1823_1: write-var gs#135290 <= s_1823_0
        fn_state.gs_135290 = s_1823_0;
        // N s_1823_2: jump b1824
        return block_1824(state, tracer, fn_state);
    }
    fn block_1824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1824_0: read-var gs#135290:u8
        let s_1824_0: bool = fn_state.gs_135290;
        // N s_1824_1: branch s_1824_0 b4713 b1825
        if s_1824_0 {
            return block_4713(state, tracer, fn_state);
        } else {
            return block_1825(state, tracer, fn_state);
        };
    }
    fn block_1825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1825_0: const #0u : u8
        let s_1825_0: bool = false;
        // D s_1825_1: write-var gs#135291 <= s_1825_0
        fn_state.gs_135291 = s_1825_0;
        // N s_1825_2: jump b1826
        return block_1826(state, tracer, fn_state);
    }
    fn block_1826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1826_0: read-var gs#135291:u8
        let s_1826_0: bool = fn_state.gs_135291;
        // N s_1826_1: branch s_1826_0 b4712 b1827
        if s_1826_0 {
            return block_4712(state, tracer, fn_state);
        } else {
            return block_1827(state, tracer, fn_state);
        };
    }
    fn block_1827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1827_0: read-var CRm:u8
        let s_1827_0: u8 = fn_state.CRm;
        // D s_1827_1: cast zx s_1827_0 -> bv
        let s_1827_1: Bits = Bits::new(s_1827_0 as u128, 4u16);
        // C s_1827_2: const #8u : u8
        let s_1827_2: u8 = 8;
        // C s_1827_3: cast zx s_1827_2 -> bv
        let s_1827_3: Bits = Bits::new(s_1827_2 as u128, 4u16);
        // D s_1827_4: cmp-eq s_1827_1 s_1827_3
        let s_1827_4: bool = ((s_1827_1) == (s_1827_3));
        // N s_1827_5: branch s_1827_4 b4711 b1828
        if s_1827_4 {
            return block_4711(state, tracer, fn_state);
        } else {
            return block_1828(state, tracer, fn_state);
        };
    }
    fn block_1828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1828_0: const #0u : u8
        let s_1828_0: bool = false;
        // D s_1828_1: write-var gs#135292 <= s_1828_0
        fn_state.gs_135292 = s_1828_0;
        // N s_1828_2: jump b1829
        return block_1829(state, tracer, fn_state);
    }
    fn block_1829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1829_0: read-var gs#135292:u8
        let s_1829_0: bool = fn_state.gs_135292;
        // N s_1829_1: branch s_1829_0 b4710 b1830
        if s_1829_0 {
            return block_4710(state, tracer, fn_state);
        } else {
            return block_1830(state, tracer, fn_state);
        };
    }
    fn block_1830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1830_0: const #0u : u8
        let s_1830_0: bool = false;
        // D s_1830_1: write-var gs#135293 <= s_1830_0
        fn_state.gs_135293 = s_1830_0;
        // N s_1830_2: jump b1831
        return block_1831(state, tracer, fn_state);
    }
    fn block_1831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1831_0: read-var gs#135293:u8
        let s_1831_0: bool = fn_state.gs_135293;
        // N s_1831_1: branch s_1831_0 b4709 b1832
        if s_1831_0 {
            return block_4709(state, tracer, fn_state);
        } else {
            return block_1832(state, tracer, fn_state);
        };
    }
    fn block_1832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1832_0: const #0u : u8
        let s_1832_0: bool = false;
        // D s_1832_1: write-var gs#135294 <= s_1832_0
        fn_state.gs_135294 = s_1832_0;
        // N s_1832_2: jump b1833
        return block_1833(state, tracer, fn_state);
    }
    fn block_1833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1833_0: read-var gs#135294:u8
        let s_1833_0: bool = fn_state.gs_135294;
        // N s_1833_1: branch s_1833_0 b4708 b1834
        if s_1833_0 {
            return block_4708(state, tracer, fn_state);
        } else {
            return block_1834(state, tracer, fn_state);
        };
    }
    fn block_1834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1834_0: const #0u : u8
        let s_1834_0: bool = false;
        // D s_1834_1: write-var gs#135295 <= s_1834_0
        fn_state.gs_135295 = s_1834_0;
        // N s_1834_2: jump b1835
        return block_1835(state, tracer, fn_state);
    }
    fn block_1835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1835_0: read-var gs#135295:u8
        let s_1835_0: bool = fn_state.gs_135295;
        // N s_1835_1: branch s_1835_0 b4707 b1836
        if s_1835_0 {
            return block_4707(state, tracer, fn_state);
        } else {
            return block_1836(state, tracer, fn_state);
        };
    }
    fn block_1836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1836_0: read-var CRm:u8
        let s_1836_0: u8 = fn_state.CRm;
        // D s_1836_1: cast zx s_1836_0 -> bv
        let s_1836_1: Bits = Bits::new(s_1836_0 as u128, 4u16);
        // C s_1836_2: const #8u : u8
        let s_1836_2: u8 = 8;
        // C s_1836_3: cast zx s_1836_2 -> bv
        let s_1836_3: Bits = Bits::new(s_1836_2 as u128, 4u16);
        // D s_1836_4: cmp-eq s_1836_1 s_1836_3
        let s_1836_4: bool = ((s_1836_1) == (s_1836_3));
        // N s_1836_5: branch s_1836_4 b4706 b1837
        if s_1836_4 {
            return block_4706(state, tracer, fn_state);
        } else {
            return block_1837(state, tracer, fn_state);
        };
    }
    fn block_1837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1837_0: const #0u : u8
        let s_1837_0: bool = false;
        // D s_1837_1: write-var gs#135296 <= s_1837_0
        fn_state.gs_135296 = s_1837_0;
        // N s_1837_2: jump b1838
        return block_1838(state, tracer, fn_state);
    }
    fn block_1838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1838_0: read-var gs#135296:u8
        let s_1838_0: bool = fn_state.gs_135296;
        // N s_1838_1: branch s_1838_0 b4705 b1839
        if s_1838_0 {
            return block_4705(state, tracer, fn_state);
        } else {
            return block_1839(state, tracer, fn_state);
        };
    }
    fn block_1839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1839_0: const #0u : u8
        let s_1839_0: bool = false;
        // D s_1839_1: write-var gs#135297 <= s_1839_0
        fn_state.gs_135297 = s_1839_0;
        // N s_1839_2: jump b1840
        return block_1840(state, tracer, fn_state);
    }
    fn block_1840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1840_0: read-var gs#135297:u8
        let s_1840_0: bool = fn_state.gs_135297;
        // N s_1840_1: branch s_1840_0 b4704 b1841
        if s_1840_0 {
            return block_4704(state, tracer, fn_state);
        } else {
            return block_1841(state, tracer, fn_state);
        };
    }
    fn block_1841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1841_0: const #0u : u8
        let s_1841_0: bool = false;
        // D s_1841_1: write-var gs#135298 <= s_1841_0
        fn_state.gs_135298 = s_1841_0;
        // N s_1841_2: jump b1842
        return block_1842(state, tracer, fn_state);
    }
    fn block_1842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1842_0: read-var gs#135298:u8
        let s_1842_0: bool = fn_state.gs_135298;
        // N s_1842_1: branch s_1842_0 b4703 b1843
        if s_1842_0 {
            return block_4703(state, tracer, fn_state);
        } else {
            return block_1843(state, tracer, fn_state);
        };
    }
    fn block_1843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1843_0: const #0u : u8
        let s_1843_0: bool = false;
        // D s_1843_1: write-var gs#135299 <= s_1843_0
        fn_state.gs_135299 = s_1843_0;
        // N s_1843_2: jump b1844
        return block_1844(state, tracer, fn_state);
    }
    fn block_1844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1844_0: read-var gs#135299:u8
        let s_1844_0: bool = fn_state.gs_135299;
        // N s_1844_1: branch s_1844_0 b4702 b1845
        if s_1844_0 {
            return block_4702(state, tracer, fn_state);
        } else {
            return block_1845(state, tracer, fn_state);
        };
    }
    fn block_1845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1845_0: read-var CRm:u8
        let s_1845_0: u8 = fn_state.CRm;
        // D s_1845_1: cast zx s_1845_0 -> bv
        let s_1845_1: Bits = Bits::new(s_1845_0 as u128, 4u16);
        // C s_1845_2: const #8u : u8
        let s_1845_2: u8 = 8;
        // C s_1845_3: cast zx s_1845_2 -> bv
        let s_1845_3: Bits = Bits::new(s_1845_2 as u128, 4u16);
        // D s_1845_4: cmp-eq s_1845_1 s_1845_3
        let s_1845_4: bool = ((s_1845_1) == (s_1845_3));
        // N s_1845_5: branch s_1845_4 b4701 b1846
        if s_1845_4 {
            return block_4701(state, tracer, fn_state);
        } else {
            return block_1846(state, tracer, fn_state);
        };
    }
    fn block_1846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1846_0: const #0u : u8
        let s_1846_0: bool = false;
        // D s_1846_1: write-var gs#135300 <= s_1846_0
        fn_state.gs_135300 = s_1846_0;
        // N s_1846_2: jump b1847
        return block_1847(state, tracer, fn_state);
    }
    fn block_1847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1847_0: read-var gs#135300:u8
        let s_1847_0: bool = fn_state.gs_135300;
        // N s_1847_1: branch s_1847_0 b4700 b1848
        if s_1847_0 {
            return block_4700(state, tracer, fn_state);
        } else {
            return block_1848(state, tracer, fn_state);
        };
    }
    fn block_1848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1848_0: const #0u : u8
        let s_1848_0: bool = false;
        // D s_1848_1: write-var gs#135301 <= s_1848_0
        fn_state.gs_135301 = s_1848_0;
        // N s_1848_2: jump b1849
        return block_1849(state, tracer, fn_state);
    }
    fn block_1849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1849_0: read-var gs#135301:u8
        let s_1849_0: bool = fn_state.gs_135301;
        // N s_1849_1: branch s_1849_0 b4699 b1850
        if s_1849_0 {
            return block_4699(state, tracer, fn_state);
        } else {
            return block_1850(state, tracer, fn_state);
        };
    }
    fn block_1850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1850_0: const #0u : u8
        let s_1850_0: bool = false;
        // D s_1850_1: write-var gs#135302 <= s_1850_0
        fn_state.gs_135302 = s_1850_0;
        // N s_1850_2: jump b1851
        return block_1851(state, tracer, fn_state);
    }
    fn block_1851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1851_0: read-var gs#135302:u8
        let s_1851_0: bool = fn_state.gs_135302;
        // N s_1851_1: branch s_1851_0 b4698 b1852
        if s_1851_0 {
            return block_4698(state, tracer, fn_state);
        } else {
            return block_1852(state, tracer, fn_state);
        };
    }
    fn block_1852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1852_0: const #0u : u8
        let s_1852_0: bool = false;
        // D s_1852_1: write-var gs#135303 <= s_1852_0
        fn_state.gs_135303 = s_1852_0;
        // N s_1852_2: jump b1853
        return block_1853(state, tracer, fn_state);
    }
    fn block_1853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1853_0: read-var gs#135303:u8
        let s_1853_0: bool = fn_state.gs_135303;
        // N s_1853_1: branch s_1853_0 b4697 b1854
        if s_1853_0 {
            return block_4697(state, tracer, fn_state);
        } else {
            return block_1854(state, tracer, fn_state);
        };
    }
    fn block_1854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1854_0: read-var CRm:u8
        let s_1854_0: u8 = fn_state.CRm;
        // D s_1854_1: cast zx s_1854_0 -> bv
        let s_1854_1: Bits = Bits::new(s_1854_0 as u128, 4u16);
        // C s_1854_2: const #8u : u8
        let s_1854_2: u8 = 8;
        // C s_1854_3: cast zx s_1854_2 -> bv
        let s_1854_3: Bits = Bits::new(s_1854_2 as u128, 4u16);
        // D s_1854_4: cmp-eq s_1854_1 s_1854_3
        let s_1854_4: bool = ((s_1854_1) == (s_1854_3));
        // N s_1854_5: branch s_1854_4 b4696 b1855
        if s_1854_4 {
            return block_4696(state, tracer, fn_state);
        } else {
            return block_1855(state, tracer, fn_state);
        };
    }
    fn block_1855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1855_0: const #0u : u8
        let s_1855_0: bool = false;
        // D s_1855_1: write-var gs#135304 <= s_1855_0
        fn_state.gs_135304 = s_1855_0;
        // N s_1855_2: jump b1856
        return block_1856(state, tracer, fn_state);
    }
    fn block_1856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1856_0: read-var gs#135304:u8
        let s_1856_0: bool = fn_state.gs_135304;
        // N s_1856_1: branch s_1856_0 b4695 b1857
        if s_1856_0 {
            return block_4695(state, tracer, fn_state);
        } else {
            return block_1857(state, tracer, fn_state);
        };
    }
    fn block_1857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1857_0: const #0u : u8
        let s_1857_0: bool = false;
        // D s_1857_1: write-var gs#135305 <= s_1857_0
        fn_state.gs_135305 = s_1857_0;
        // N s_1857_2: jump b1858
        return block_1858(state, tracer, fn_state);
    }
    fn block_1858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1858_0: read-var gs#135305:u8
        let s_1858_0: bool = fn_state.gs_135305;
        // N s_1858_1: branch s_1858_0 b4694 b1859
        if s_1858_0 {
            return block_4694(state, tracer, fn_state);
        } else {
            return block_1859(state, tracer, fn_state);
        };
    }
    fn block_1859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1859_0: const #0u : u8
        let s_1859_0: bool = false;
        // D s_1859_1: write-var gs#135306 <= s_1859_0
        fn_state.gs_135306 = s_1859_0;
        // N s_1859_2: jump b1860
        return block_1860(state, tracer, fn_state);
    }
    fn block_1860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1860_0: read-var gs#135306:u8
        let s_1860_0: bool = fn_state.gs_135306;
        // N s_1860_1: branch s_1860_0 b4693 b1861
        if s_1860_0 {
            return block_4693(state, tracer, fn_state);
        } else {
            return block_1861(state, tracer, fn_state);
        };
    }
    fn block_1861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1861_0: const #0u : u8
        let s_1861_0: bool = false;
        // D s_1861_1: write-var gs#135307 <= s_1861_0
        fn_state.gs_135307 = s_1861_0;
        // N s_1861_2: jump b1862
        return block_1862(state, tracer, fn_state);
    }
    fn block_1862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1862_0: read-var gs#135307:u8
        let s_1862_0: bool = fn_state.gs_135307;
        // N s_1862_1: branch s_1862_0 b4692 b1863
        if s_1862_0 {
            return block_4692(state, tracer, fn_state);
        } else {
            return block_1863(state, tracer, fn_state);
        };
    }
    fn block_1863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1863_0: read-var CRm:u8
        let s_1863_0: u8 = fn_state.CRm;
        // D s_1863_1: cast zx s_1863_0 -> bv
        let s_1863_1: Bits = Bits::new(s_1863_0 as u128, 4u16);
        // C s_1863_2: const #0u : u8
        let s_1863_2: u8 = 0;
        // C s_1863_3: cast zx s_1863_2 -> bv
        let s_1863_3: Bits = Bits::new(s_1863_2 as u128, 4u16);
        // D s_1863_4: cmp-eq s_1863_1 s_1863_3
        let s_1863_4: bool = ((s_1863_1) == (s_1863_3));
        // N s_1863_5: branch s_1863_4 b4691 b1864
        if s_1863_4 {
            return block_4691(state, tracer, fn_state);
        } else {
            return block_1864(state, tracer, fn_state);
        };
    }
    fn block_1864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1864_0: const #0u : u8
        let s_1864_0: bool = false;
        // D s_1864_1: write-var gs#135308 <= s_1864_0
        fn_state.gs_135308 = s_1864_0;
        // N s_1864_2: jump b1865
        return block_1865(state, tracer, fn_state);
    }
    fn block_1865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1865_0: read-var gs#135308:u8
        let s_1865_0: bool = fn_state.gs_135308;
        // N s_1865_1: branch s_1865_0 b4690 b1866
        if s_1865_0 {
            return block_4690(state, tracer, fn_state);
        } else {
            return block_1866(state, tracer, fn_state);
        };
    }
    fn block_1866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1866_0: const #0u : u8
        let s_1866_0: bool = false;
        // D s_1866_1: write-var gs#135309 <= s_1866_0
        fn_state.gs_135309 = s_1866_0;
        // N s_1866_2: jump b1867
        return block_1867(state, tracer, fn_state);
    }
    fn block_1867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1867_0: read-var gs#135309:u8
        let s_1867_0: bool = fn_state.gs_135309;
        // N s_1867_1: branch s_1867_0 b4689 b1868
        if s_1867_0 {
            return block_4689(state, tracer, fn_state);
        } else {
            return block_1868(state, tracer, fn_state);
        };
    }
    fn block_1868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1868_0: const #0u : u8
        let s_1868_0: bool = false;
        // D s_1868_1: write-var gs#135310 <= s_1868_0
        fn_state.gs_135310 = s_1868_0;
        // N s_1868_2: jump b1869
        return block_1869(state, tracer, fn_state);
    }
    fn block_1869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1869_0: read-var gs#135310:u8
        let s_1869_0: bool = fn_state.gs_135310;
        // N s_1869_1: branch s_1869_0 b4688 b1870
        if s_1869_0 {
            return block_4688(state, tracer, fn_state);
        } else {
            return block_1870(state, tracer, fn_state);
        };
    }
    fn block_1870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1870_0: const #0u : u8
        let s_1870_0: bool = false;
        // D s_1870_1: write-var gs#135311 <= s_1870_0
        fn_state.gs_135311 = s_1870_0;
        // N s_1870_2: jump b1871
        return block_1871(state, tracer, fn_state);
    }
    fn block_1871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1871_0: read-var gs#135311:u8
        let s_1871_0: bool = fn_state.gs_135311;
        // N s_1871_1: branch s_1871_0 b4687 b1872
        if s_1871_0 {
            return block_4687(state, tracer, fn_state);
        } else {
            return block_1872(state, tracer, fn_state);
        };
    }
    fn block_1872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1872_0: read-var CRm:u8
        let s_1872_0: u8 = fn_state.CRm;
        // D s_1872_1: cast zx s_1872_0 -> bv
        let s_1872_1: Bits = Bits::new(s_1872_0 as u128, 4u16);
        // C s_1872_2: const #6u : u8
        let s_1872_2: u8 = 6;
        // C s_1872_3: cast zx s_1872_2 -> bv
        let s_1872_3: Bits = Bits::new(s_1872_2 as u128, 4u16);
        // D s_1872_4: cmp-eq s_1872_1 s_1872_3
        let s_1872_4: bool = ((s_1872_1) == (s_1872_3));
        // N s_1872_5: branch s_1872_4 b4686 b1873
        if s_1872_4 {
            return block_4686(state, tracer, fn_state);
        } else {
            return block_1873(state, tracer, fn_state);
        };
    }
    fn block_1873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1873_0: const #0u : u8
        let s_1873_0: bool = false;
        // D s_1873_1: write-var gs#135312 <= s_1873_0
        fn_state.gs_135312 = s_1873_0;
        // N s_1873_2: jump b1874
        return block_1874(state, tracer, fn_state);
    }
    fn block_1874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1874_0: read-var gs#135312:u8
        let s_1874_0: bool = fn_state.gs_135312;
        // N s_1874_1: branch s_1874_0 b4685 b1875
        if s_1874_0 {
            return block_4685(state, tracer, fn_state);
        } else {
            return block_1875(state, tracer, fn_state);
        };
    }
    fn block_1875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1875_0: const #0u : u8
        let s_1875_0: bool = false;
        // D s_1875_1: write-var gs#135313 <= s_1875_0
        fn_state.gs_135313 = s_1875_0;
        // N s_1875_2: jump b1876
        return block_1876(state, tracer, fn_state);
    }
    fn block_1876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1876_0: read-var gs#135313:u8
        let s_1876_0: bool = fn_state.gs_135313;
        // N s_1876_1: branch s_1876_0 b4684 b1877
        if s_1876_0 {
            return block_4684(state, tracer, fn_state);
        } else {
            return block_1877(state, tracer, fn_state);
        };
    }
    fn block_1877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1877_0: const #0u : u8
        let s_1877_0: bool = false;
        // D s_1877_1: write-var gs#135314 <= s_1877_0
        fn_state.gs_135314 = s_1877_0;
        // N s_1877_2: jump b1878
        return block_1878(state, tracer, fn_state);
    }
    fn block_1878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1878_0: read-var gs#135314:u8
        let s_1878_0: bool = fn_state.gs_135314;
        // N s_1878_1: branch s_1878_0 b4683 b1879
        if s_1878_0 {
            return block_4683(state, tracer, fn_state);
        } else {
            return block_1879(state, tracer, fn_state);
        };
    }
    fn block_1879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1879_0: const #0u : u8
        let s_1879_0: bool = false;
        // D s_1879_1: write-var gs#135315 <= s_1879_0
        fn_state.gs_135315 = s_1879_0;
        // N s_1879_2: jump b1880
        return block_1880(state, tracer, fn_state);
    }
    fn block_1880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1880_0: read-var gs#135315:u8
        let s_1880_0: bool = fn_state.gs_135315;
        // N s_1880_1: branch s_1880_0 b4682 b1881
        if s_1880_0 {
            return block_4682(state, tracer, fn_state);
        } else {
            return block_1881(state, tracer, fn_state);
        };
    }
    fn block_1881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1881_0: read-var CRm:u8
        let s_1881_0: u8 = fn_state.CRm;
        // D s_1881_1: cast zx s_1881_0 -> bv
        let s_1881_1: Bits = Bits::new(s_1881_0 as u128, 4u16);
        // C s_1881_2: const #11u : u8
        let s_1881_2: u8 = 11;
        // C s_1881_3: cast zx s_1881_2 -> bv
        let s_1881_3: Bits = Bits::new(s_1881_2 as u128, 4u16);
        // D s_1881_4: cmp-eq s_1881_1 s_1881_3
        let s_1881_4: bool = ((s_1881_1) == (s_1881_3));
        // N s_1881_5: branch s_1881_4 b4681 b1882
        if s_1881_4 {
            return block_4681(state, tracer, fn_state);
        } else {
            return block_1882(state, tracer, fn_state);
        };
    }
    fn block_1882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1882_0: const #0u : u8
        let s_1882_0: bool = false;
        // D s_1882_1: write-var gs#135316 <= s_1882_0
        fn_state.gs_135316 = s_1882_0;
        // N s_1882_2: jump b1883
        return block_1883(state, tracer, fn_state);
    }
    fn block_1883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1883_0: read-var gs#135316:u8
        let s_1883_0: bool = fn_state.gs_135316;
        // N s_1883_1: branch s_1883_0 b4680 b1884
        if s_1883_0 {
            return block_4680(state, tracer, fn_state);
        } else {
            return block_1884(state, tracer, fn_state);
        };
    }
    fn block_1884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1884_0: const #0u : u8
        let s_1884_0: bool = false;
        // D s_1884_1: write-var gs#135317 <= s_1884_0
        fn_state.gs_135317 = s_1884_0;
        // N s_1884_2: jump b1885
        return block_1885(state, tracer, fn_state);
    }
    fn block_1885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1885_0: read-var gs#135317:u8
        let s_1885_0: bool = fn_state.gs_135317;
        // N s_1885_1: branch s_1885_0 b4679 b1886
        if s_1885_0 {
            return block_4679(state, tracer, fn_state);
        } else {
            return block_1886(state, tracer, fn_state);
        };
    }
    fn block_1886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1886_0: const #0u : u8
        let s_1886_0: bool = false;
        // D s_1886_1: write-var gs#135318 <= s_1886_0
        fn_state.gs_135318 = s_1886_0;
        // N s_1886_2: jump b1887
        return block_1887(state, tracer, fn_state);
    }
    fn block_1887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1887_0: read-var gs#135318:u8
        let s_1887_0: bool = fn_state.gs_135318;
        // N s_1887_1: branch s_1887_0 b4678 b1888
        if s_1887_0 {
            return block_4678(state, tracer, fn_state);
        } else {
            return block_1888(state, tracer, fn_state);
        };
    }
    fn block_1888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1888_0: const #0u : u8
        let s_1888_0: bool = false;
        // D s_1888_1: write-var gs#135319 <= s_1888_0
        fn_state.gs_135319 = s_1888_0;
        // N s_1888_2: jump b1889
        return block_1889(state, tracer, fn_state);
    }
    fn block_1889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1889_0: read-var gs#135319:u8
        let s_1889_0: bool = fn_state.gs_135319;
        // N s_1889_1: branch s_1889_0 b4677 b1890
        if s_1889_0 {
            return block_4677(state, tracer, fn_state);
        } else {
            return block_1890(state, tracer, fn_state);
        };
    }
    fn block_1890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1890_0: read-var CRm:u8
        let s_1890_0: u8 = fn_state.CRm;
        // D s_1890_1: cast zx s_1890_0 -> bv
        let s_1890_1: Bits = Bits::new(s_1890_0 as u128, 4u16);
        // C s_1890_2: const #0u : u8
        let s_1890_2: u8 = 0;
        // C s_1890_3: cast zx s_1890_2 -> bv
        let s_1890_3: Bits = Bits::new(s_1890_2 as u128, 4u16);
        // D s_1890_4: cmp-eq s_1890_1 s_1890_3
        let s_1890_4: bool = ((s_1890_1) == (s_1890_3));
        // N s_1890_5: branch s_1890_4 b4676 b1891
        if s_1890_4 {
            return block_4676(state, tracer, fn_state);
        } else {
            return block_1891(state, tracer, fn_state);
        };
    }
    fn block_1891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1891_0: const #0u : u8
        let s_1891_0: bool = false;
        // D s_1891_1: write-var gs#135320 <= s_1891_0
        fn_state.gs_135320 = s_1891_0;
        // N s_1891_2: jump b1892
        return block_1892(state, tracer, fn_state);
    }
    fn block_1892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1892_0: read-var gs#135320:u8
        let s_1892_0: bool = fn_state.gs_135320;
        // N s_1892_1: branch s_1892_0 b4675 b1893
        if s_1892_0 {
            return block_4675(state, tracer, fn_state);
        } else {
            return block_1893(state, tracer, fn_state);
        };
    }
    fn block_1893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1893_0: const #0u : u8
        let s_1893_0: bool = false;
        // D s_1893_1: write-var gs#135321 <= s_1893_0
        fn_state.gs_135321 = s_1893_0;
        // N s_1893_2: jump b1894
        return block_1894(state, tracer, fn_state);
    }
    fn block_1894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1894_0: read-var gs#135321:u8
        let s_1894_0: bool = fn_state.gs_135321;
        // N s_1894_1: branch s_1894_0 b4674 b1895
        if s_1894_0 {
            return block_4674(state, tracer, fn_state);
        } else {
            return block_1895(state, tracer, fn_state);
        };
    }
    fn block_1895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1895_0: const #0u : u8
        let s_1895_0: bool = false;
        // D s_1895_1: write-var gs#135322 <= s_1895_0
        fn_state.gs_135322 = s_1895_0;
        // N s_1895_2: jump b1896
        return block_1896(state, tracer, fn_state);
    }
    fn block_1896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1896_0: read-var gs#135322:u8
        let s_1896_0: bool = fn_state.gs_135322;
        // N s_1896_1: branch s_1896_0 b4673 b1897
        if s_1896_0 {
            return block_4673(state, tracer, fn_state);
        } else {
            return block_1897(state, tracer, fn_state);
        };
    }
    fn block_1897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1897_0: const #0u : u8
        let s_1897_0: bool = false;
        // D s_1897_1: write-var gs#135323 <= s_1897_0
        fn_state.gs_135323 = s_1897_0;
        // N s_1897_2: jump b1898
        return block_1898(state, tracer, fn_state);
    }
    fn block_1898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1898_0: read-var gs#135323:u8
        let s_1898_0: bool = fn_state.gs_135323;
        // N s_1898_1: branch s_1898_0 b4672 b1899
        if s_1898_0 {
            return block_4672(state, tracer, fn_state);
        } else {
            return block_1899(state, tracer, fn_state);
        };
    }
    fn block_1899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1899_0: read-var CRm:u8
        let s_1899_0: u8 = fn_state.CRm;
        // D s_1899_1: cast zx s_1899_0 -> bv
        let s_1899_1: Bits = Bits::new(s_1899_0 as u128, 4u16);
        // C s_1899_2: const #2u : u8
        let s_1899_2: u8 = 2;
        // C s_1899_3: cast zx s_1899_2 -> bv
        let s_1899_3: Bits = Bits::new(s_1899_2 as u128, 4u16);
        // D s_1899_4: cmp-eq s_1899_1 s_1899_3
        let s_1899_4: bool = ((s_1899_1) == (s_1899_3));
        // N s_1899_5: branch s_1899_4 b4671 b1900
        if s_1899_4 {
            return block_4671(state, tracer, fn_state);
        } else {
            return block_1900(state, tracer, fn_state);
        };
    }
    fn block_1900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1900_0: const #0u : u8
        let s_1900_0: bool = false;
        // D s_1900_1: write-var gs#135324 <= s_1900_0
        fn_state.gs_135324 = s_1900_0;
        // N s_1900_2: jump b1901
        return block_1901(state, tracer, fn_state);
    }
    fn block_1901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1901_0: read-var gs#135324:u8
        let s_1901_0: bool = fn_state.gs_135324;
        // N s_1901_1: branch s_1901_0 b4670 b1902
        if s_1901_0 {
            return block_4670(state, tracer, fn_state);
        } else {
            return block_1902(state, tracer, fn_state);
        };
    }
    fn block_1902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1902_0: const #0u : u8
        let s_1902_0: bool = false;
        // D s_1902_1: write-var gs#135325 <= s_1902_0
        fn_state.gs_135325 = s_1902_0;
        // N s_1902_2: jump b1903
        return block_1903(state, tracer, fn_state);
    }
    fn block_1903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1903_0: read-var gs#135325:u8
        let s_1903_0: bool = fn_state.gs_135325;
        // N s_1903_1: branch s_1903_0 b4669 b1904
        if s_1903_0 {
            return block_4669(state, tracer, fn_state);
        } else {
            return block_1904(state, tracer, fn_state);
        };
    }
    fn block_1904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1904_0: const #0u : u8
        let s_1904_0: bool = false;
        // D s_1904_1: write-var gs#135326 <= s_1904_0
        fn_state.gs_135326 = s_1904_0;
        // N s_1904_2: jump b1905
        return block_1905(state, tracer, fn_state);
    }
    fn block_1905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1905_0: read-var gs#135326:u8
        let s_1905_0: bool = fn_state.gs_135326;
        // N s_1905_1: branch s_1905_0 b4668 b1906
        if s_1905_0 {
            return block_4668(state, tracer, fn_state);
        } else {
            return block_1906(state, tracer, fn_state);
        };
    }
    fn block_1906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1906_0: const #0u : u8
        let s_1906_0: bool = false;
        // D s_1906_1: write-var gs#135327 <= s_1906_0
        fn_state.gs_135327 = s_1906_0;
        // N s_1906_2: jump b1907
        return block_1907(state, tracer, fn_state);
    }
    fn block_1907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1907_0: read-var gs#135327:u8
        let s_1907_0: bool = fn_state.gs_135327;
        // N s_1907_1: branch s_1907_0 b4667 b1908
        if s_1907_0 {
            return block_4667(state, tracer, fn_state);
        } else {
            return block_1908(state, tracer, fn_state);
        };
    }
    fn block_1908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1908_0: read-var CRm:u8
        let s_1908_0: u8 = fn_state.CRm;
        // D s_1908_1: cast zx s_1908_0 -> bv
        let s_1908_1: Bits = Bits::new(s_1908_0 as u128, 4u16);
        // C s_1908_2: const #0u : u8
        let s_1908_2: u8 = 0;
        // C s_1908_3: cast zx s_1908_2 -> bv
        let s_1908_3: Bits = Bits::new(s_1908_2 as u128, 4u16);
        // D s_1908_4: cmp-eq s_1908_1 s_1908_3
        let s_1908_4: bool = ((s_1908_1) == (s_1908_3));
        // N s_1908_5: branch s_1908_4 b4666 b1909
        if s_1908_4 {
            return block_4666(state, tracer, fn_state);
        } else {
            return block_1909(state, tracer, fn_state);
        };
    }
    fn block_1909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1909_0: const #0u : u8
        let s_1909_0: bool = false;
        // D s_1909_1: write-var gs#135328 <= s_1909_0
        fn_state.gs_135328 = s_1909_0;
        // N s_1909_2: jump b1910
        return block_1910(state, tracer, fn_state);
    }
    fn block_1910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1910_0: read-var gs#135328:u8
        let s_1910_0: bool = fn_state.gs_135328;
        // N s_1910_1: branch s_1910_0 b4665 b1911
        if s_1910_0 {
            return block_4665(state, tracer, fn_state);
        } else {
            return block_1911(state, tracer, fn_state);
        };
    }
    fn block_1911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1911_0: const #0u : u8
        let s_1911_0: bool = false;
        // D s_1911_1: write-var gs#135329 <= s_1911_0
        fn_state.gs_135329 = s_1911_0;
        // N s_1911_2: jump b1912
        return block_1912(state, tracer, fn_state);
    }
    fn block_1912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1912_0: read-var gs#135329:u8
        let s_1912_0: bool = fn_state.gs_135329;
        // N s_1912_1: branch s_1912_0 b4664 b1913
        if s_1912_0 {
            return block_4664(state, tracer, fn_state);
        } else {
            return block_1913(state, tracer, fn_state);
        };
    }
    fn block_1913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1913_0: const #0u : u8
        let s_1913_0: bool = false;
        // D s_1913_1: write-var gs#135330 <= s_1913_0
        fn_state.gs_135330 = s_1913_0;
        // N s_1913_2: jump b1914
        return block_1914(state, tracer, fn_state);
    }
    fn block_1914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1914_0: read-var gs#135330:u8
        let s_1914_0: bool = fn_state.gs_135330;
        // N s_1914_1: branch s_1914_0 b4663 b1915
        if s_1914_0 {
            return block_4663(state, tracer, fn_state);
        } else {
            return block_1915(state, tracer, fn_state);
        };
    }
    fn block_1915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1915_0: const #0u : u8
        let s_1915_0: bool = false;
        // D s_1915_1: write-var gs#135331 <= s_1915_0
        fn_state.gs_135331 = s_1915_0;
        // N s_1915_2: jump b1916
        return block_1916(state, tracer, fn_state);
    }
    fn block_1916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1916_0: read-var gs#135331:u8
        let s_1916_0: bool = fn_state.gs_135331;
        // N s_1916_1: branch s_1916_0 b4662 b1917
        if s_1916_0 {
            return block_4662(state, tracer, fn_state);
        } else {
            return block_1917(state, tracer, fn_state);
        };
    }
    fn block_1917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1917_0: read-var CRm:u8
        let s_1917_0: u8 = fn_state.CRm;
        // D s_1917_1: cast zx s_1917_0 -> bv
        let s_1917_1: Bits = Bits::new(s_1917_0 as u128, 4u16);
        // C s_1917_2: const #3u : u8
        let s_1917_2: u8 = 3;
        // C s_1917_3: cast zx s_1917_2 -> bv
        let s_1917_3: Bits = Bits::new(s_1917_2 as u128, 4u16);
        // D s_1917_4: cmp-eq s_1917_1 s_1917_3
        let s_1917_4: bool = ((s_1917_1) == (s_1917_3));
        // N s_1917_5: branch s_1917_4 b4661 b1918
        if s_1917_4 {
            return block_4661(state, tracer, fn_state);
        } else {
            return block_1918(state, tracer, fn_state);
        };
    }
    fn block_1918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1918_0: const #0u : u8
        let s_1918_0: bool = false;
        // D s_1918_1: write-var gs#135332 <= s_1918_0
        fn_state.gs_135332 = s_1918_0;
        // N s_1918_2: jump b1919
        return block_1919(state, tracer, fn_state);
    }
    fn block_1919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1919_0: read-var gs#135332:u8
        let s_1919_0: bool = fn_state.gs_135332;
        // N s_1919_1: branch s_1919_0 b4660 b1920
        if s_1919_0 {
            return block_4660(state, tracer, fn_state);
        } else {
            return block_1920(state, tracer, fn_state);
        };
    }
    fn block_1920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1920_0: const #0u : u8
        let s_1920_0: bool = false;
        // D s_1920_1: write-var gs#135333 <= s_1920_0
        fn_state.gs_135333 = s_1920_0;
        // N s_1920_2: jump b1921
        return block_1921(state, tracer, fn_state);
    }
    fn block_1921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1921_0: read-var gs#135333:u8
        let s_1921_0: bool = fn_state.gs_135333;
        // N s_1921_1: branch s_1921_0 b4659 b1922
        if s_1921_0 {
            return block_4659(state, tracer, fn_state);
        } else {
            return block_1922(state, tracer, fn_state);
        };
    }
    fn block_1922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1922_0: const #0u : u8
        let s_1922_0: bool = false;
        // D s_1922_1: write-var gs#135334 <= s_1922_0
        fn_state.gs_135334 = s_1922_0;
        // N s_1922_2: jump b1923
        return block_1923(state, tracer, fn_state);
    }
    fn block_1923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1923_0: read-var gs#135334:u8
        let s_1923_0: bool = fn_state.gs_135334;
        // N s_1923_1: branch s_1923_0 b4658 b1924
        if s_1923_0 {
            return block_4658(state, tracer, fn_state);
        } else {
            return block_1924(state, tracer, fn_state);
        };
    }
    fn block_1924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1924_0: const #0u : u8
        let s_1924_0: bool = false;
        // D s_1924_1: write-var gs#135335 <= s_1924_0
        fn_state.gs_135335 = s_1924_0;
        // N s_1924_2: jump b1925
        return block_1925(state, tracer, fn_state);
    }
    fn block_1925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1925_0: read-var gs#135335:u8
        let s_1925_0: bool = fn_state.gs_135335;
        // N s_1925_1: branch s_1925_0 b4657 b1926
        if s_1925_0 {
            return block_4657(state, tracer, fn_state);
        } else {
            return block_1926(state, tracer, fn_state);
        };
    }
    fn block_1926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1926_0: read-var CRm:u8
        let s_1926_0: u8 = fn_state.CRm;
        // D s_1926_1: cast zx s_1926_0 -> bv
        let s_1926_1: Bits = Bits::new(s_1926_0 as u128, 4u16);
        // C s_1926_2: const #2u : u8
        let s_1926_2: u8 = 2;
        // C s_1926_3: cast zx s_1926_2 -> bv
        let s_1926_3: Bits = Bits::new(s_1926_2 as u128, 4u16);
        // D s_1926_4: cmp-eq s_1926_1 s_1926_3
        let s_1926_4: bool = ((s_1926_1) == (s_1926_3));
        // N s_1926_5: branch s_1926_4 b4656 b1927
        if s_1926_4 {
            return block_4656(state, tracer, fn_state);
        } else {
            return block_1927(state, tracer, fn_state);
        };
    }
    fn block_1927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1927_0: const #0u : u8
        let s_1927_0: bool = false;
        // D s_1927_1: write-var gs#135336 <= s_1927_0
        fn_state.gs_135336 = s_1927_0;
        // N s_1927_2: jump b1928
        return block_1928(state, tracer, fn_state);
    }
    fn block_1928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1928_0: read-var gs#135336:u8
        let s_1928_0: bool = fn_state.gs_135336;
        // N s_1928_1: branch s_1928_0 b4655 b1929
        if s_1928_0 {
            return block_4655(state, tracer, fn_state);
        } else {
            return block_1929(state, tracer, fn_state);
        };
    }
    fn block_1929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1929_0: const #0u : u8
        let s_1929_0: bool = false;
        // D s_1929_1: write-var gs#135337 <= s_1929_0
        fn_state.gs_135337 = s_1929_0;
        // N s_1929_2: jump b1930
        return block_1930(state, tracer, fn_state);
    }
    fn block_1930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1930_0: read-var gs#135337:u8
        let s_1930_0: bool = fn_state.gs_135337;
        // N s_1930_1: branch s_1930_0 b4654 b1931
        if s_1930_0 {
            return block_4654(state, tracer, fn_state);
        } else {
            return block_1931(state, tracer, fn_state);
        };
    }
    fn block_1931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1931_0: const #0u : u8
        let s_1931_0: bool = false;
        // D s_1931_1: write-var gs#135338 <= s_1931_0
        fn_state.gs_135338 = s_1931_0;
        // N s_1931_2: jump b1932
        return block_1932(state, tracer, fn_state);
    }
    fn block_1932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1932_0: read-var gs#135338:u8
        let s_1932_0: bool = fn_state.gs_135338;
        // N s_1932_1: branch s_1932_0 b4653 b1933
        if s_1932_0 {
            return block_4653(state, tracer, fn_state);
        } else {
            return block_1933(state, tracer, fn_state);
        };
    }
    fn block_1933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1933_0: const #0u : u8
        let s_1933_0: bool = false;
        // D s_1933_1: write-var gs#135339 <= s_1933_0
        fn_state.gs_135339 = s_1933_0;
        // N s_1933_2: jump b1934
        return block_1934(state, tracer, fn_state);
    }
    fn block_1934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1934_0: read-var gs#135339:u8
        let s_1934_0: bool = fn_state.gs_135339;
        // N s_1934_1: branch s_1934_0 b4652 b1935
        if s_1934_0 {
            return block_4652(state, tracer, fn_state);
        } else {
            return block_1935(state, tracer, fn_state);
        };
    }
    fn block_1935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1935_0: read-var CRm:u8
        let s_1935_0: u8 = fn_state.CRm;
        // D s_1935_1: cast zx s_1935_0 -> bv
        let s_1935_1: Bits = Bits::new(s_1935_0 as u128, 4u16);
        // C s_1935_2: const #0u : u8
        let s_1935_2: u8 = 0;
        // C s_1935_3: cast zx s_1935_2 -> bv
        let s_1935_3: Bits = Bits::new(s_1935_2 as u128, 4u16);
        // D s_1935_4: cmp-eq s_1935_1 s_1935_3
        let s_1935_4: bool = ((s_1935_1) == (s_1935_3));
        // N s_1935_5: branch s_1935_4 b4651 b1936
        if s_1935_4 {
            return block_4651(state, tracer, fn_state);
        } else {
            return block_1936(state, tracer, fn_state);
        };
    }
    fn block_1936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1936_0: const #0u : u8
        let s_1936_0: bool = false;
        // D s_1936_1: write-var gs#135340 <= s_1936_0
        fn_state.gs_135340 = s_1936_0;
        // N s_1936_2: jump b1937
        return block_1937(state, tracer, fn_state);
    }
    fn block_1937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1937_0: read-var gs#135340:u8
        let s_1937_0: bool = fn_state.gs_135340;
        // N s_1937_1: branch s_1937_0 b4650 b1938
        if s_1937_0 {
            return block_4650(state, tracer, fn_state);
        } else {
            return block_1938(state, tracer, fn_state);
        };
    }
    fn block_1938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1938_0: const #0u : u8
        let s_1938_0: bool = false;
        // D s_1938_1: write-var gs#135341 <= s_1938_0
        fn_state.gs_135341 = s_1938_0;
        // N s_1938_2: jump b1939
        return block_1939(state, tracer, fn_state);
    }
    fn block_1939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1939_0: read-var gs#135341:u8
        let s_1939_0: bool = fn_state.gs_135341;
        // N s_1939_1: branch s_1939_0 b4649 b1940
        if s_1939_0 {
            return block_4649(state, tracer, fn_state);
        } else {
            return block_1940(state, tracer, fn_state);
        };
    }
    fn block_1940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1940_0: const #0u : u8
        let s_1940_0: bool = false;
        // D s_1940_1: write-var gs#135342 <= s_1940_0
        fn_state.gs_135342 = s_1940_0;
        // N s_1940_2: jump b1941
        return block_1941(state, tracer, fn_state);
    }
    fn block_1941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1941_0: read-var gs#135342:u8
        let s_1941_0: bool = fn_state.gs_135342;
        // N s_1941_1: branch s_1941_0 b4648 b1942
        if s_1941_0 {
            return block_4648(state, tracer, fn_state);
        } else {
            return block_1942(state, tracer, fn_state);
        };
    }
    fn block_1942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1942_0: const #0u : u8
        let s_1942_0: bool = false;
        // D s_1942_1: write-var gs#135343 <= s_1942_0
        fn_state.gs_135343 = s_1942_0;
        // N s_1942_2: jump b1943
        return block_1943(state, tracer, fn_state);
    }
    fn block_1943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1943_0: read-var gs#135343:u8
        let s_1943_0: bool = fn_state.gs_135343;
        // N s_1943_1: branch s_1943_0 b4647 b1944
        if s_1943_0 {
            return block_4647(state, tracer, fn_state);
        } else {
            return block_1944(state, tracer, fn_state);
        };
    }
    fn block_1944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1944_0: read-var CRm:u8
        let s_1944_0: u8 = fn_state.CRm;
        // D s_1944_1: cast zx s_1944_0 -> bv
        let s_1944_1: Bits = Bits::new(s_1944_0 as u128, 4u16);
        // C s_1944_2: const #13u : u8
        let s_1944_2: u8 = 13;
        // C s_1944_3: cast zx s_1944_2 -> bv
        let s_1944_3: Bits = Bits::new(s_1944_2 as u128, 4u16);
        // D s_1944_4: cmp-eq s_1944_1 s_1944_3
        let s_1944_4: bool = ((s_1944_1) == (s_1944_3));
        // N s_1944_5: branch s_1944_4 b4646 b1945
        if s_1944_4 {
            return block_4646(state, tracer, fn_state);
        } else {
            return block_1945(state, tracer, fn_state);
        };
    }
    fn block_1945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1945_0: const #0u : u8
        let s_1945_0: bool = false;
        // D s_1945_1: write-var gs#135344 <= s_1945_0
        fn_state.gs_135344 = s_1945_0;
        // N s_1945_2: jump b1946
        return block_1946(state, tracer, fn_state);
    }
    fn block_1946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1946_0: read-var gs#135344:u8
        let s_1946_0: bool = fn_state.gs_135344;
        // N s_1946_1: branch s_1946_0 b4645 b1947
        if s_1946_0 {
            return block_4645(state, tracer, fn_state);
        } else {
            return block_1947(state, tracer, fn_state);
        };
    }
    fn block_1947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1947_0: const #0u : u8
        let s_1947_0: bool = false;
        // D s_1947_1: write-var gs#135345 <= s_1947_0
        fn_state.gs_135345 = s_1947_0;
        // N s_1947_2: jump b1948
        return block_1948(state, tracer, fn_state);
    }
    fn block_1948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1948_0: read-var gs#135345:u8
        let s_1948_0: bool = fn_state.gs_135345;
        // N s_1948_1: branch s_1948_0 b4644 b1949
        if s_1948_0 {
            return block_4644(state, tracer, fn_state);
        } else {
            return block_1949(state, tracer, fn_state);
        };
    }
    fn block_1949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1949_0: const #0u : u8
        let s_1949_0: bool = false;
        // D s_1949_1: write-var gs#135346 <= s_1949_0
        fn_state.gs_135346 = s_1949_0;
        // N s_1949_2: jump b1950
        return block_1950(state, tracer, fn_state);
    }
    fn block_1950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1950_0: read-var gs#135346:u8
        let s_1950_0: bool = fn_state.gs_135346;
        // N s_1950_1: branch s_1950_0 b4643 b1951
        if s_1950_0 {
            return block_4643(state, tracer, fn_state);
        } else {
            return block_1951(state, tracer, fn_state);
        };
    }
    fn block_1951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1951_0: const #0u : u8
        let s_1951_0: bool = false;
        // D s_1951_1: write-var gs#135347 <= s_1951_0
        fn_state.gs_135347 = s_1951_0;
        // N s_1951_2: jump b1952
        return block_1952(state, tracer, fn_state);
    }
    fn block_1952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1952_0: read-var gs#135347:u8
        let s_1952_0: bool = fn_state.gs_135347;
        // N s_1952_1: branch s_1952_0 b4642 b1953
        if s_1952_0 {
            return block_4642(state, tracer, fn_state);
        } else {
            return block_1953(state, tracer, fn_state);
        };
    }
    fn block_1953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1953_0: read-var CRm:u8
        let s_1953_0: u8 = fn_state.CRm;
        // D s_1953_1: cast zx s_1953_0 -> bv
        let s_1953_1: Bits = Bits::new(s_1953_0 as u128, 4u16);
        // C s_1953_2: const #13u : u8
        let s_1953_2: u8 = 13;
        // C s_1953_3: cast zx s_1953_2 -> bv
        let s_1953_3: Bits = Bits::new(s_1953_2 as u128, 4u16);
        // D s_1953_4: cmp-eq s_1953_1 s_1953_3
        let s_1953_4: bool = ((s_1953_1) == (s_1953_3));
        // N s_1953_5: branch s_1953_4 b4641 b1954
        if s_1953_4 {
            return block_4641(state, tracer, fn_state);
        } else {
            return block_1954(state, tracer, fn_state);
        };
    }
    fn block_1954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1954_0: const #0u : u8
        let s_1954_0: bool = false;
        // D s_1954_1: write-var gs#135348 <= s_1954_0
        fn_state.gs_135348 = s_1954_0;
        // N s_1954_2: jump b1955
        return block_1955(state, tracer, fn_state);
    }
    fn block_1955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1955_0: read-var gs#135348:u8
        let s_1955_0: bool = fn_state.gs_135348;
        // N s_1955_1: branch s_1955_0 b4640 b1956
        if s_1955_0 {
            return block_4640(state, tracer, fn_state);
        } else {
            return block_1956(state, tracer, fn_state);
        };
    }
    fn block_1956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1956_0: const #0u : u8
        let s_1956_0: bool = false;
        // D s_1956_1: write-var gs#135349 <= s_1956_0
        fn_state.gs_135349 = s_1956_0;
        // N s_1956_2: jump b1957
        return block_1957(state, tracer, fn_state);
    }
    fn block_1957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1957_0: read-var gs#135349:u8
        let s_1957_0: bool = fn_state.gs_135349;
        // N s_1957_1: branch s_1957_0 b4639 b1958
        if s_1957_0 {
            return block_4639(state, tracer, fn_state);
        } else {
            return block_1958(state, tracer, fn_state);
        };
    }
    fn block_1958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1958_0: const #0u : u8
        let s_1958_0: bool = false;
        // D s_1958_1: write-var gs#135350 <= s_1958_0
        fn_state.gs_135350 = s_1958_0;
        // N s_1958_2: jump b1959
        return block_1959(state, tracer, fn_state);
    }
    fn block_1959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1959_0: read-var gs#135350:u8
        let s_1959_0: bool = fn_state.gs_135350;
        // N s_1959_1: branch s_1959_0 b4638 b1960
        if s_1959_0 {
            return block_4638(state, tracer, fn_state);
        } else {
            return block_1960(state, tracer, fn_state);
        };
    }
    fn block_1960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1960_0: const #0u : u8
        let s_1960_0: bool = false;
        // D s_1960_1: write-var gs#135351 <= s_1960_0
        fn_state.gs_135351 = s_1960_0;
        // N s_1960_2: jump b1961
        return block_1961(state, tracer, fn_state);
    }
    fn block_1961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1961_0: read-var gs#135351:u8
        let s_1961_0: bool = fn_state.gs_135351;
        // N s_1961_1: branch s_1961_0 b4637 b1962
        if s_1961_0 {
            return block_4637(state, tracer, fn_state);
        } else {
            return block_1962(state, tracer, fn_state);
        };
    }
    fn block_1962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1962_0: read-var CRm:u8
        let s_1962_0: u8 = fn_state.CRm;
        // D s_1962_1: cast zx s_1962_0 -> bv
        let s_1962_1: Bits = Bits::new(s_1962_0 as u128, 4u16);
        // C s_1962_2: const #13u : u8
        let s_1962_2: u8 = 13;
        // C s_1962_3: cast zx s_1962_2 -> bv
        let s_1962_3: Bits = Bits::new(s_1962_2 as u128, 4u16);
        // D s_1962_4: cmp-eq s_1962_1 s_1962_3
        let s_1962_4: bool = ((s_1962_1) == (s_1962_3));
        // N s_1962_5: branch s_1962_4 b4636 b1963
        if s_1962_4 {
            return block_4636(state, tracer, fn_state);
        } else {
            return block_1963(state, tracer, fn_state);
        };
    }
    fn block_1963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1963_0: const #0u : u8
        let s_1963_0: bool = false;
        // D s_1963_1: write-var gs#135352 <= s_1963_0
        fn_state.gs_135352 = s_1963_0;
        // N s_1963_2: jump b1964
        return block_1964(state, tracer, fn_state);
    }
    fn block_1964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1964_0: read-var gs#135352:u8
        let s_1964_0: bool = fn_state.gs_135352;
        // N s_1964_1: branch s_1964_0 b4635 b1965
        if s_1964_0 {
            return block_4635(state, tracer, fn_state);
        } else {
            return block_1965(state, tracer, fn_state);
        };
    }
    fn block_1965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1965_0: const #0u : u8
        let s_1965_0: bool = false;
        // D s_1965_1: write-var gs#135353 <= s_1965_0
        fn_state.gs_135353 = s_1965_0;
        // N s_1965_2: jump b1966
        return block_1966(state, tracer, fn_state);
    }
    fn block_1966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1966_0: read-var gs#135353:u8
        let s_1966_0: bool = fn_state.gs_135353;
        // N s_1966_1: branch s_1966_0 b4634 b1967
        if s_1966_0 {
            return block_4634(state, tracer, fn_state);
        } else {
            return block_1967(state, tracer, fn_state);
        };
    }
    fn block_1967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1967_0: const #0u : u8
        let s_1967_0: bool = false;
        // D s_1967_1: write-var gs#135354 <= s_1967_0
        fn_state.gs_135354 = s_1967_0;
        // N s_1967_2: jump b1968
        return block_1968(state, tracer, fn_state);
    }
    fn block_1968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1968_0: read-var gs#135354:u8
        let s_1968_0: bool = fn_state.gs_135354;
        // N s_1968_1: branch s_1968_0 b4633 b1969
        if s_1968_0 {
            return block_4633(state, tracer, fn_state);
        } else {
            return block_1969(state, tracer, fn_state);
        };
    }
    fn block_1969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1969_0: const #0u : u8
        let s_1969_0: bool = false;
        // D s_1969_1: write-var gs#135355 <= s_1969_0
        fn_state.gs_135355 = s_1969_0;
        // N s_1969_2: jump b1970
        return block_1970(state, tracer, fn_state);
    }
    fn block_1970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1970_0: read-var gs#135355:u8
        let s_1970_0: bool = fn_state.gs_135355;
        // N s_1970_1: branch s_1970_0 b4632 b1971
        if s_1970_0 {
            return block_4632(state, tracer, fn_state);
        } else {
            return block_1971(state, tracer, fn_state);
        };
    }
    fn block_1971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1971_0: read-var CRm:u8
        let s_1971_0: u8 = fn_state.CRm;
        // D s_1971_1: cast zx s_1971_0 -> bv
        let s_1971_1: Bits = Bits::new(s_1971_0 as u128, 4u16);
        // C s_1971_2: const #13u : u8
        let s_1971_2: u8 = 13;
        // C s_1971_3: cast zx s_1971_2 -> bv
        let s_1971_3: Bits = Bits::new(s_1971_2 as u128, 4u16);
        // D s_1971_4: cmp-eq s_1971_1 s_1971_3
        let s_1971_4: bool = ((s_1971_1) == (s_1971_3));
        // N s_1971_5: branch s_1971_4 b4631 b1972
        if s_1971_4 {
            return block_4631(state, tracer, fn_state);
        } else {
            return block_1972(state, tracer, fn_state);
        };
    }
    fn block_1972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1972_0: const #0u : u8
        let s_1972_0: bool = false;
        // D s_1972_1: write-var gs#135356 <= s_1972_0
        fn_state.gs_135356 = s_1972_0;
        // N s_1972_2: jump b1973
        return block_1973(state, tracer, fn_state);
    }
    fn block_1973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1973_0: read-var gs#135356:u8
        let s_1973_0: bool = fn_state.gs_135356;
        // N s_1973_1: branch s_1973_0 b4630 b1974
        if s_1973_0 {
            return block_4630(state, tracer, fn_state);
        } else {
            return block_1974(state, tracer, fn_state);
        };
    }
    fn block_1974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1974_0: const #0u : u8
        let s_1974_0: bool = false;
        // D s_1974_1: write-var gs#135357 <= s_1974_0
        fn_state.gs_135357 = s_1974_0;
        // N s_1974_2: jump b1975
        return block_1975(state, tracer, fn_state);
    }
    fn block_1975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1975_0: read-var gs#135357:u8
        let s_1975_0: bool = fn_state.gs_135357;
        // N s_1975_1: branch s_1975_0 b4629 b1976
        if s_1975_0 {
            return block_4629(state, tracer, fn_state);
        } else {
            return block_1976(state, tracer, fn_state);
        };
    }
    fn block_1976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1976_0: const #0u : u8
        let s_1976_0: bool = false;
        // D s_1976_1: write-var gs#135358 <= s_1976_0
        fn_state.gs_135358 = s_1976_0;
        // N s_1976_2: jump b1977
        return block_1977(state, tracer, fn_state);
    }
    fn block_1977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1977_0: read-var gs#135358:u8
        let s_1977_0: bool = fn_state.gs_135358;
        // N s_1977_1: branch s_1977_0 b4628 b1978
        if s_1977_0 {
            return block_4628(state, tracer, fn_state);
        } else {
            return block_1978(state, tracer, fn_state);
        };
    }
    fn block_1978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1978_0: const #0u : u8
        let s_1978_0: bool = false;
        // D s_1978_1: write-var gs#135359 <= s_1978_0
        fn_state.gs_135359 = s_1978_0;
        // N s_1978_2: jump b1979
        return block_1979(state, tracer, fn_state);
    }
    fn block_1979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1979_0: read-var gs#135359:u8
        let s_1979_0: bool = fn_state.gs_135359;
        // N s_1979_1: branch s_1979_0 b4627 b1980
        if s_1979_0 {
            return block_4627(state, tracer, fn_state);
        } else {
            return block_1980(state, tracer, fn_state);
        };
    }
    fn block_1980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1980_0: read-var CRm:u8
        let s_1980_0: u8 = fn_state.CRm;
        // D s_1980_1: cast zx s_1980_0 -> bv
        let s_1980_1: Bits = Bits::new(s_1980_0 as u128, 4u16);
        // C s_1980_2: const #13u : u8
        let s_1980_2: u8 = 13;
        // C s_1980_3: cast zx s_1980_2 -> bv
        let s_1980_3: Bits = Bits::new(s_1980_2 as u128, 4u16);
        // D s_1980_4: cmp-eq s_1980_1 s_1980_3
        let s_1980_4: bool = ((s_1980_1) == (s_1980_3));
        // N s_1980_5: branch s_1980_4 b4626 b1981
        if s_1980_4 {
            return block_4626(state, tracer, fn_state);
        } else {
            return block_1981(state, tracer, fn_state);
        };
    }
    fn block_1981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1981_0: const #0u : u8
        let s_1981_0: bool = false;
        // D s_1981_1: write-var gs#135360 <= s_1981_0
        fn_state.gs_135360 = s_1981_0;
        // N s_1981_2: jump b1982
        return block_1982(state, tracer, fn_state);
    }
    fn block_1982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1982_0: read-var gs#135360:u8
        let s_1982_0: bool = fn_state.gs_135360;
        // N s_1982_1: branch s_1982_0 b4625 b1983
        if s_1982_0 {
            return block_4625(state, tracer, fn_state);
        } else {
            return block_1983(state, tracer, fn_state);
        };
    }
    fn block_1983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1983_0: const #0u : u8
        let s_1983_0: bool = false;
        // D s_1983_1: write-var gs#135361 <= s_1983_0
        fn_state.gs_135361 = s_1983_0;
        // N s_1983_2: jump b1984
        return block_1984(state, tracer, fn_state);
    }
    fn block_1984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1984_0: read-var gs#135361:u8
        let s_1984_0: bool = fn_state.gs_135361;
        // N s_1984_1: branch s_1984_0 b4624 b1985
        if s_1984_0 {
            return block_4624(state, tracer, fn_state);
        } else {
            return block_1985(state, tracer, fn_state);
        };
    }
    fn block_1985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1985_0: const #0u : u8
        let s_1985_0: bool = false;
        // D s_1985_1: write-var gs#135362 <= s_1985_0
        fn_state.gs_135362 = s_1985_0;
        // N s_1985_2: jump b1986
        return block_1986(state, tracer, fn_state);
    }
    fn block_1986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1986_0: read-var gs#135362:u8
        let s_1986_0: bool = fn_state.gs_135362;
        // N s_1986_1: branch s_1986_0 b4623 b1987
        if s_1986_0 {
            return block_4623(state, tracer, fn_state);
        } else {
            return block_1987(state, tracer, fn_state);
        };
    }
    fn block_1987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1987_0: const #0u : u8
        let s_1987_0: bool = false;
        // D s_1987_1: write-var gs#135363 <= s_1987_0
        fn_state.gs_135363 = s_1987_0;
        // N s_1987_2: jump b1988
        return block_1988(state, tracer, fn_state);
    }
    fn block_1988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1988_0: read-var gs#135363:u8
        let s_1988_0: bool = fn_state.gs_135363;
        // N s_1988_1: branch s_1988_0 b4622 b1989
        if s_1988_0 {
            return block_4622(state, tracer, fn_state);
        } else {
            return block_1989(state, tracer, fn_state);
        };
    }
    fn block_1989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1989_0: read-var CRm:u8
        let s_1989_0: u8 = fn_state.CRm;
        // D s_1989_1: cast zx s_1989_0 -> bv
        let s_1989_1: Bits = Bits::new(s_1989_0 as u128, 4u16);
        // C s_1989_2: const #13u : u8
        let s_1989_2: u8 = 13;
        // C s_1989_3: cast zx s_1989_2 -> bv
        let s_1989_3: Bits = Bits::new(s_1989_2 as u128, 4u16);
        // D s_1989_4: cmp-eq s_1989_1 s_1989_3
        let s_1989_4: bool = ((s_1989_1) == (s_1989_3));
        // N s_1989_5: branch s_1989_4 b4621 b1990
        if s_1989_4 {
            return block_4621(state, tracer, fn_state);
        } else {
            return block_1990(state, tracer, fn_state);
        };
    }
    fn block_1990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1990_0: const #0u : u8
        let s_1990_0: bool = false;
        // D s_1990_1: write-var gs#135364 <= s_1990_0
        fn_state.gs_135364 = s_1990_0;
        // N s_1990_2: jump b1991
        return block_1991(state, tracer, fn_state);
    }
    fn block_1991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1991_0: read-var gs#135364:u8
        let s_1991_0: bool = fn_state.gs_135364;
        // N s_1991_1: branch s_1991_0 b4620 b1992
        if s_1991_0 {
            return block_4620(state, tracer, fn_state);
        } else {
            return block_1992(state, tracer, fn_state);
        };
    }
    fn block_1992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1992_0: const #0u : u8
        let s_1992_0: bool = false;
        // D s_1992_1: write-var gs#135365 <= s_1992_0
        fn_state.gs_135365 = s_1992_0;
        // N s_1992_2: jump b1993
        return block_1993(state, tracer, fn_state);
    }
    fn block_1993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1993_0: read-var gs#135365:u8
        let s_1993_0: bool = fn_state.gs_135365;
        // N s_1993_1: branch s_1993_0 b4619 b1994
        if s_1993_0 {
            return block_4619(state, tracer, fn_state);
        } else {
            return block_1994(state, tracer, fn_state);
        };
    }
    fn block_1994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1994_0: const #0u : u8
        let s_1994_0: bool = false;
        // D s_1994_1: write-var gs#135366 <= s_1994_0
        fn_state.gs_135366 = s_1994_0;
        // N s_1994_2: jump b1995
        return block_1995(state, tracer, fn_state);
    }
    fn block_1995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1995_0: read-var gs#135366:u8
        let s_1995_0: bool = fn_state.gs_135366;
        // N s_1995_1: branch s_1995_0 b4618 b1996
        if s_1995_0 {
            return block_4618(state, tracer, fn_state);
        } else {
            return block_1996(state, tracer, fn_state);
        };
    }
    fn block_1996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1996_0: const #0u : u8
        let s_1996_0: bool = false;
        // D s_1996_1: write-var gs#135367 <= s_1996_0
        fn_state.gs_135367 = s_1996_0;
        // N s_1996_2: jump b1997
        return block_1997(state, tracer, fn_state);
    }
    fn block_1997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1997_0: read-var gs#135367:u8
        let s_1997_0: bool = fn_state.gs_135367;
        // N s_1997_1: branch s_1997_0 b4617 b1998
        if s_1997_0 {
            return block_4617(state, tracer, fn_state);
        } else {
            return block_1998(state, tracer, fn_state);
        };
    }
    fn block_1998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1998_0: read-var CRm:u8
        let s_1998_0: u8 = fn_state.CRm;
        // D s_1998_1: cast zx s_1998_0 -> bv
        let s_1998_1: Bits = Bits::new(s_1998_0 as u128, 4u16);
        // C s_1998_2: const #13u : u8
        let s_1998_2: u8 = 13;
        // C s_1998_3: cast zx s_1998_2 -> bv
        let s_1998_3: Bits = Bits::new(s_1998_2 as u128, 4u16);
        // D s_1998_4: cmp-eq s_1998_1 s_1998_3
        let s_1998_4: bool = ((s_1998_1) == (s_1998_3));
        // N s_1998_5: branch s_1998_4 b4616 b1999
        if s_1998_4 {
            return block_4616(state, tracer, fn_state);
        } else {
            return block_1999(state, tracer, fn_state);
        };
    }
    fn block_1999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1999_0: const #0u : u8
        let s_1999_0: bool = false;
        // D s_1999_1: write-var gs#135368 <= s_1999_0
        fn_state.gs_135368 = s_1999_0;
        // N s_1999_2: jump b2000
        return block_2000(state, tracer, fn_state);
    }
    fn block_2000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2000_0: read-var gs#135368:u8
        let s_2000_0: bool = fn_state.gs_135368;
        // N s_2000_1: branch s_2000_0 b4615 b2001
        if s_2000_0 {
            return block_4615(state, tracer, fn_state);
        } else {
            return block_2001(state, tracer, fn_state);
        };
    }
    fn block_2001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2001_0: const #0u : u8
        let s_2001_0: bool = false;
        // D s_2001_1: write-var gs#135369 <= s_2001_0
        fn_state.gs_135369 = s_2001_0;
        // N s_2001_2: jump b2002
        return block_2002(state, tracer, fn_state);
    }
    fn block_2002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2002_0: read-var gs#135369:u8
        let s_2002_0: bool = fn_state.gs_135369;
        // N s_2002_1: branch s_2002_0 b4614 b2003
        if s_2002_0 {
            return block_4614(state, tracer, fn_state);
        } else {
            return block_2003(state, tracer, fn_state);
        };
    }
    fn block_2003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2003_0: const #0u : u8
        let s_2003_0: bool = false;
        // D s_2003_1: write-var gs#135370 <= s_2003_0
        fn_state.gs_135370 = s_2003_0;
        // N s_2003_2: jump b2004
        return block_2004(state, tracer, fn_state);
    }
    fn block_2004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2004_0: read-var gs#135370:u8
        let s_2004_0: bool = fn_state.gs_135370;
        // N s_2004_1: branch s_2004_0 b4613 b2005
        if s_2004_0 {
            return block_4613(state, tracer, fn_state);
        } else {
            return block_2005(state, tracer, fn_state);
        };
    }
    fn block_2005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2005_0: const #0u : u8
        let s_2005_0: bool = false;
        // D s_2005_1: write-var gs#135371 <= s_2005_0
        fn_state.gs_135371 = s_2005_0;
        // N s_2005_2: jump b2006
        return block_2006(state, tracer, fn_state);
    }
    fn block_2006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2006_0: read-var gs#135371:u8
        let s_2006_0: bool = fn_state.gs_135371;
        // N s_2006_1: branch s_2006_0 b4612 b2007
        if s_2006_0 {
            return block_4612(state, tracer, fn_state);
        } else {
            return block_2007(state, tracer, fn_state);
        };
    }
    fn block_2007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2007_0: read-var CRm:u8
        let s_2007_0: u8 = fn_state.CRm;
        // D s_2007_1: cast zx s_2007_0 -> bv
        let s_2007_1: Bits = Bits::new(s_2007_0 as u128, 4u16);
        // C s_2007_2: const #13u : u8
        let s_2007_2: u8 = 13;
        // C s_2007_3: cast zx s_2007_2 -> bv
        let s_2007_3: Bits = Bits::new(s_2007_2 as u128, 4u16);
        // D s_2007_4: cmp-eq s_2007_1 s_2007_3
        let s_2007_4: bool = ((s_2007_1) == (s_2007_3));
        // N s_2007_5: branch s_2007_4 b4611 b2008
        if s_2007_4 {
            return block_4611(state, tracer, fn_state);
        } else {
            return block_2008(state, tracer, fn_state);
        };
    }
    fn block_2008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2008_0: const #0u : u8
        let s_2008_0: bool = false;
        // D s_2008_1: write-var gs#135372 <= s_2008_0
        fn_state.gs_135372 = s_2008_0;
        // N s_2008_2: jump b2009
        return block_2009(state, tracer, fn_state);
    }
    fn block_2009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2009_0: read-var gs#135372:u8
        let s_2009_0: bool = fn_state.gs_135372;
        // N s_2009_1: branch s_2009_0 b4610 b2010
        if s_2009_0 {
            return block_4610(state, tracer, fn_state);
        } else {
            return block_2010(state, tracer, fn_state);
        };
    }
    fn block_2010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2010_0: const #0u : u8
        let s_2010_0: bool = false;
        // D s_2010_1: write-var gs#135373 <= s_2010_0
        fn_state.gs_135373 = s_2010_0;
        // N s_2010_2: jump b2011
        return block_2011(state, tracer, fn_state);
    }
    fn block_2011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2011_0: read-var gs#135373:u8
        let s_2011_0: bool = fn_state.gs_135373;
        // N s_2011_1: branch s_2011_0 b4609 b2012
        if s_2011_0 {
            return block_4609(state, tracer, fn_state);
        } else {
            return block_2012(state, tracer, fn_state);
        };
    }
    fn block_2012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2012_0: const #0u : u8
        let s_2012_0: bool = false;
        // D s_2012_1: write-var gs#135374 <= s_2012_0
        fn_state.gs_135374 = s_2012_0;
        // N s_2012_2: jump b2013
        return block_2013(state, tracer, fn_state);
    }
    fn block_2013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2013_0: read-var gs#135374:u8
        let s_2013_0: bool = fn_state.gs_135374;
        // N s_2013_1: branch s_2013_0 b4608 b2014
        if s_2013_0 {
            return block_4608(state, tracer, fn_state);
        } else {
            return block_2014(state, tracer, fn_state);
        };
    }
    fn block_2014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2014_0: const #0u : u8
        let s_2014_0: bool = false;
        // D s_2014_1: write-var gs#135375 <= s_2014_0
        fn_state.gs_135375 = s_2014_0;
        // N s_2014_2: jump b2015
        return block_2015(state, tracer, fn_state);
    }
    fn block_2015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2015_0: read-var gs#135375:u8
        let s_2015_0: bool = fn_state.gs_135375;
        // N s_2015_1: branch s_2015_0 b4607 b2016
        if s_2015_0 {
            return block_4607(state, tracer, fn_state);
        } else {
            return block_2016(state, tracer, fn_state);
        };
    }
    fn block_2016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2016_0: read-var CRm:u8
        let s_2016_0: u8 = fn_state.CRm;
        // D s_2016_1: cast zx s_2016_0 -> bv
        let s_2016_1: Bits = Bits::new(s_2016_0 as u128, 4u16);
        // C s_2016_2: const #12u : u8
        let s_2016_2: u8 = 12;
        // C s_2016_3: cast zx s_2016_2 -> bv
        let s_2016_3: Bits = Bits::new(s_2016_2 as u128, 4u16);
        // D s_2016_4: cmp-eq s_2016_1 s_2016_3
        let s_2016_4: bool = ((s_2016_1) == (s_2016_3));
        // N s_2016_5: branch s_2016_4 b4606 b2017
        if s_2016_4 {
            return block_4606(state, tracer, fn_state);
        } else {
            return block_2017(state, tracer, fn_state);
        };
    }
    fn block_2017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2017_0: const #0u : u8
        let s_2017_0: bool = false;
        // D s_2017_1: write-var gs#135376 <= s_2017_0
        fn_state.gs_135376 = s_2017_0;
        // N s_2017_2: jump b2018
        return block_2018(state, tracer, fn_state);
    }
    fn block_2018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2018_0: read-var gs#135376:u8
        let s_2018_0: bool = fn_state.gs_135376;
        // N s_2018_1: branch s_2018_0 b4605 b2019
        if s_2018_0 {
            return block_4605(state, tracer, fn_state);
        } else {
            return block_2019(state, tracer, fn_state);
        };
    }
    fn block_2019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2019_0: const #0u : u8
        let s_2019_0: bool = false;
        // D s_2019_1: write-var gs#135377 <= s_2019_0
        fn_state.gs_135377 = s_2019_0;
        // N s_2019_2: jump b2020
        return block_2020(state, tracer, fn_state);
    }
    fn block_2020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2020_0: read-var gs#135377:u8
        let s_2020_0: bool = fn_state.gs_135377;
        // N s_2020_1: branch s_2020_0 b4604 b2021
        if s_2020_0 {
            return block_4604(state, tracer, fn_state);
        } else {
            return block_2021(state, tracer, fn_state);
        };
    }
    fn block_2021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2021_0: const #0u : u8
        let s_2021_0: bool = false;
        // D s_2021_1: write-var gs#135378 <= s_2021_0
        fn_state.gs_135378 = s_2021_0;
        // N s_2021_2: jump b2022
        return block_2022(state, tracer, fn_state);
    }
    fn block_2022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2022_0: read-var gs#135378:u8
        let s_2022_0: bool = fn_state.gs_135378;
        // N s_2022_1: branch s_2022_0 b4603 b2023
        if s_2022_0 {
            return block_4603(state, tracer, fn_state);
        } else {
            return block_2023(state, tracer, fn_state);
        };
    }
    fn block_2023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2023_0: const #0u : u8
        let s_2023_0: bool = false;
        // D s_2023_1: write-var gs#135379 <= s_2023_0
        fn_state.gs_135379 = s_2023_0;
        // N s_2023_2: jump b2024
        return block_2024(state, tracer, fn_state);
    }
    fn block_2024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2024_0: read-var gs#135379:u8
        let s_2024_0: bool = fn_state.gs_135379;
        // N s_2024_1: branch s_2024_0 b4602 b2025
        if s_2024_0 {
            return block_4602(state, tracer, fn_state);
        } else {
            return block_2025(state, tracer, fn_state);
        };
    }
    fn block_2025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2025_0: read-var CRm:u8
        let s_2025_0: u8 = fn_state.CRm;
        // D s_2025_1: cast zx s_2025_0 -> bv
        let s_2025_1: Bits = Bits::new(s_2025_0 as u128, 4u16);
        // C s_2025_2: const #12u : u8
        let s_2025_2: u8 = 12;
        // C s_2025_3: cast zx s_2025_2 -> bv
        let s_2025_3: Bits = Bits::new(s_2025_2 as u128, 4u16);
        // D s_2025_4: cmp-eq s_2025_1 s_2025_3
        let s_2025_4: bool = ((s_2025_1) == (s_2025_3));
        // N s_2025_5: branch s_2025_4 b4601 b2026
        if s_2025_4 {
            return block_4601(state, tracer, fn_state);
        } else {
            return block_2026(state, tracer, fn_state);
        };
    }
    fn block_2026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2026_0: const #0u : u8
        let s_2026_0: bool = false;
        // D s_2026_1: write-var gs#135380 <= s_2026_0
        fn_state.gs_135380 = s_2026_0;
        // N s_2026_2: jump b2027
        return block_2027(state, tracer, fn_state);
    }
    fn block_2027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2027_0: read-var gs#135380:u8
        let s_2027_0: bool = fn_state.gs_135380;
        // N s_2027_1: branch s_2027_0 b4600 b2028
        if s_2027_0 {
            return block_4600(state, tracer, fn_state);
        } else {
            return block_2028(state, tracer, fn_state);
        };
    }
    fn block_2028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2028_0: const #0u : u8
        let s_2028_0: bool = false;
        // D s_2028_1: write-var gs#135381 <= s_2028_0
        fn_state.gs_135381 = s_2028_0;
        // N s_2028_2: jump b2029
        return block_2029(state, tracer, fn_state);
    }
    fn block_2029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2029_0: read-var gs#135381:u8
        let s_2029_0: bool = fn_state.gs_135381;
        // N s_2029_1: branch s_2029_0 b4599 b2030
        if s_2029_0 {
            return block_4599(state, tracer, fn_state);
        } else {
            return block_2030(state, tracer, fn_state);
        };
    }
    fn block_2030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2030_0: const #0u : u8
        let s_2030_0: bool = false;
        // D s_2030_1: write-var gs#135382 <= s_2030_0
        fn_state.gs_135382 = s_2030_0;
        // N s_2030_2: jump b2031
        return block_2031(state, tracer, fn_state);
    }
    fn block_2031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2031_0: read-var gs#135382:u8
        let s_2031_0: bool = fn_state.gs_135382;
        // N s_2031_1: branch s_2031_0 b4598 b2032
        if s_2031_0 {
            return block_4598(state, tracer, fn_state);
        } else {
            return block_2032(state, tracer, fn_state);
        };
    }
    fn block_2032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2032_0: const #0u : u8
        let s_2032_0: bool = false;
        // D s_2032_1: write-var gs#135383 <= s_2032_0
        fn_state.gs_135383 = s_2032_0;
        // N s_2032_2: jump b2033
        return block_2033(state, tracer, fn_state);
    }
    fn block_2033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2033_0: read-var gs#135383:u8
        let s_2033_0: bool = fn_state.gs_135383;
        // N s_2033_1: branch s_2033_0 b4597 b2034
        if s_2033_0 {
            return block_4597(state, tracer, fn_state);
        } else {
            return block_2034(state, tracer, fn_state);
        };
    }
    fn block_2034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2034_0: read-var CRm:u8
        let s_2034_0: u8 = fn_state.CRm;
        // D s_2034_1: cast zx s_2034_0 -> bv
        let s_2034_1: Bits = Bits::new(s_2034_0 as u128, 4u16);
        // C s_2034_2: const #12u : u8
        let s_2034_2: u8 = 12;
        // C s_2034_3: cast zx s_2034_2 -> bv
        let s_2034_3: Bits = Bits::new(s_2034_2 as u128, 4u16);
        // D s_2034_4: cmp-eq s_2034_1 s_2034_3
        let s_2034_4: bool = ((s_2034_1) == (s_2034_3));
        // N s_2034_5: branch s_2034_4 b4596 b2035
        if s_2034_4 {
            return block_4596(state, tracer, fn_state);
        } else {
            return block_2035(state, tracer, fn_state);
        };
    }
    fn block_2035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2035_0: const #0u : u8
        let s_2035_0: bool = false;
        // D s_2035_1: write-var gs#135384 <= s_2035_0
        fn_state.gs_135384 = s_2035_0;
        // N s_2035_2: jump b2036
        return block_2036(state, tracer, fn_state);
    }
    fn block_2036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2036_0: read-var gs#135384:u8
        let s_2036_0: bool = fn_state.gs_135384;
        // N s_2036_1: branch s_2036_0 b4595 b2037
        if s_2036_0 {
            return block_4595(state, tracer, fn_state);
        } else {
            return block_2037(state, tracer, fn_state);
        };
    }
    fn block_2037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2037_0: const #0u : u8
        let s_2037_0: bool = false;
        // D s_2037_1: write-var gs#135385 <= s_2037_0
        fn_state.gs_135385 = s_2037_0;
        // N s_2037_2: jump b2038
        return block_2038(state, tracer, fn_state);
    }
    fn block_2038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2038_0: read-var gs#135385:u8
        let s_2038_0: bool = fn_state.gs_135385;
        // N s_2038_1: branch s_2038_0 b4594 b2039
        if s_2038_0 {
            return block_4594(state, tracer, fn_state);
        } else {
            return block_2039(state, tracer, fn_state);
        };
    }
    fn block_2039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2039_0: const #0u : u8
        let s_2039_0: bool = false;
        // D s_2039_1: write-var gs#135386 <= s_2039_0
        fn_state.gs_135386 = s_2039_0;
        // N s_2039_2: jump b2040
        return block_2040(state, tracer, fn_state);
    }
    fn block_2040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2040_0: read-var gs#135386:u8
        let s_2040_0: bool = fn_state.gs_135386;
        // N s_2040_1: branch s_2040_0 b4593 b2041
        if s_2040_0 {
            return block_4593(state, tracer, fn_state);
        } else {
            return block_2041(state, tracer, fn_state);
        };
    }
    fn block_2041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2041_0: const #0u : u8
        let s_2041_0: bool = false;
        // D s_2041_1: write-var gs#135387 <= s_2041_0
        fn_state.gs_135387 = s_2041_0;
        // N s_2041_2: jump b2042
        return block_2042(state, tracer, fn_state);
    }
    fn block_2042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2042_0: read-var gs#135387:u8
        let s_2042_0: bool = fn_state.gs_135387;
        // N s_2042_1: branch s_2042_0 b4592 b2043
        if s_2042_0 {
            return block_4592(state, tracer, fn_state);
        } else {
            return block_2043(state, tracer, fn_state);
        };
    }
    fn block_2043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2043_0: read-var CRm:u8
        let s_2043_0: u8 = fn_state.CRm;
        // D s_2043_1: cast zx s_2043_0 -> bv
        let s_2043_1: Bits = Bits::new(s_2043_0 as u128, 4u16);
        // C s_2043_2: const #12u : u8
        let s_2043_2: u8 = 12;
        // C s_2043_3: cast zx s_2043_2 -> bv
        let s_2043_3: Bits = Bits::new(s_2043_2 as u128, 4u16);
        // D s_2043_4: cmp-eq s_2043_1 s_2043_3
        let s_2043_4: bool = ((s_2043_1) == (s_2043_3));
        // N s_2043_5: branch s_2043_4 b4591 b2044
        if s_2043_4 {
            return block_4591(state, tracer, fn_state);
        } else {
            return block_2044(state, tracer, fn_state);
        };
    }
    fn block_2044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2044_0: const #0u : u8
        let s_2044_0: bool = false;
        // D s_2044_1: write-var gs#135388 <= s_2044_0
        fn_state.gs_135388 = s_2044_0;
        // N s_2044_2: jump b2045
        return block_2045(state, tracer, fn_state);
    }
    fn block_2045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2045_0: read-var gs#135388:u8
        let s_2045_0: bool = fn_state.gs_135388;
        // N s_2045_1: branch s_2045_0 b4590 b2046
        if s_2045_0 {
            return block_4590(state, tracer, fn_state);
        } else {
            return block_2046(state, tracer, fn_state);
        };
    }
    fn block_2046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2046_0: const #0u : u8
        let s_2046_0: bool = false;
        // D s_2046_1: write-var gs#135389 <= s_2046_0
        fn_state.gs_135389 = s_2046_0;
        // N s_2046_2: jump b2047
        return block_2047(state, tracer, fn_state);
    }
    fn block_2047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2047_0: read-var gs#135389:u8
        let s_2047_0: bool = fn_state.gs_135389;
        // N s_2047_1: branch s_2047_0 b4589 b2048
        if s_2047_0 {
            return block_4589(state, tracer, fn_state);
        } else {
            return block_2048(state, tracer, fn_state);
        };
    }
    fn block_2048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2048_0: const #0u : u8
        let s_2048_0: bool = false;
        // D s_2048_1: write-var gs#135390 <= s_2048_0
        fn_state.gs_135390 = s_2048_0;
        // N s_2048_2: jump b2049
        return block_2049(state, tracer, fn_state);
    }
    fn block_2049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2049_0: read-var gs#135390:u8
        let s_2049_0: bool = fn_state.gs_135390;
        // N s_2049_1: branch s_2049_0 b4588 b2050
        if s_2049_0 {
            return block_4588(state, tracer, fn_state);
        } else {
            return block_2050(state, tracer, fn_state);
        };
    }
    fn block_2050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2050_0: const #0u : u8
        let s_2050_0: bool = false;
        // D s_2050_1: write-var gs#135391 <= s_2050_0
        fn_state.gs_135391 = s_2050_0;
        // N s_2050_2: jump b2051
        return block_2051(state, tracer, fn_state);
    }
    fn block_2051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2051_0: read-var gs#135391:u8
        let s_2051_0: bool = fn_state.gs_135391;
        // N s_2051_1: branch s_2051_0 b4587 b2052
        if s_2051_0 {
            return block_4587(state, tracer, fn_state);
        } else {
            return block_2052(state, tracer, fn_state);
        };
    }
    fn block_2052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2052_0: read-var CRm:u8
        let s_2052_0: u8 = fn_state.CRm;
        // D s_2052_1: cast zx s_2052_0 -> bv
        let s_2052_1: Bits = Bits::new(s_2052_0 as u128, 4u16);
        // C s_2052_2: const #12u : u8
        let s_2052_2: u8 = 12;
        // C s_2052_3: cast zx s_2052_2 -> bv
        let s_2052_3: Bits = Bits::new(s_2052_2 as u128, 4u16);
        // D s_2052_4: cmp-eq s_2052_1 s_2052_3
        let s_2052_4: bool = ((s_2052_1) == (s_2052_3));
        // N s_2052_5: branch s_2052_4 b4586 b2053
        if s_2052_4 {
            return block_4586(state, tracer, fn_state);
        } else {
            return block_2053(state, tracer, fn_state);
        };
    }
    fn block_2053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2053_0: const #0u : u8
        let s_2053_0: bool = false;
        // D s_2053_1: write-var gs#135392 <= s_2053_0
        fn_state.gs_135392 = s_2053_0;
        // N s_2053_2: jump b2054
        return block_2054(state, tracer, fn_state);
    }
    fn block_2054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2054_0: read-var gs#135392:u8
        let s_2054_0: bool = fn_state.gs_135392;
        // N s_2054_1: branch s_2054_0 b4585 b2055
        if s_2054_0 {
            return block_4585(state, tracer, fn_state);
        } else {
            return block_2055(state, tracer, fn_state);
        };
    }
    fn block_2055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2055_0: const #0u : u8
        let s_2055_0: bool = false;
        // D s_2055_1: write-var gs#135393 <= s_2055_0
        fn_state.gs_135393 = s_2055_0;
        // N s_2055_2: jump b2056
        return block_2056(state, tracer, fn_state);
    }
    fn block_2056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2056_0: read-var gs#135393:u8
        let s_2056_0: bool = fn_state.gs_135393;
        // N s_2056_1: branch s_2056_0 b4584 b2057
        if s_2056_0 {
            return block_4584(state, tracer, fn_state);
        } else {
            return block_2057(state, tracer, fn_state);
        };
    }
    fn block_2057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2057_0: const #0u : u8
        let s_2057_0: bool = false;
        // D s_2057_1: write-var gs#135394 <= s_2057_0
        fn_state.gs_135394 = s_2057_0;
        // N s_2057_2: jump b2058
        return block_2058(state, tracer, fn_state);
    }
    fn block_2058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2058_0: read-var gs#135394:u8
        let s_2058_0: bool = fn_state.gs_135394;
        // N s_2058_1: branch s_2058_0 b4583 b2059
        if s_2058_0 {
            return block_4583(state, tracer, fn_state);
        } else {
            return block_2059(state, tracer, fn_state);
        };
    }
    fn block_2059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2059_0: const #0u : u8
        let s_2059_0: bool = false;
        // D s_2059_1: write-var gs#135395 <= s_2059_0
        fn_state.gs_135395 = s_2059_0;
        // N s_2059_2: jump b2060
        return block_2060(state, tracer, fn_state);
    }
    fn block_2060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2060_0: read-var gs#135395:u8
        let s_2060_0: bool = fn_state.gs_135395;
        // N s_2060_1: branch s_2060_0 b4582 b2061
        if s_2060_0 {
            return block_4582(state, tracer, fn_state);
        } else {
            return block_2061(state, tracer, fn_state);
        };
    }
    fn block_2061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2061_0: read-var CRm:u8
        let s_2061_0: u8 = fn_state.CRm;
        // D s_2061_1: cast zx s_2061_0 -> bv
        let s_2061_1: Bits = Bits::new(s_2061_0 as u128, 4u16);
        // C s_2061_2: const #12u : u8
        let s_2061_2: u8 = 12;
        // C s_2061_3: cast zx s_2061_2 -> bv
        let s_2061_3: Bits = Bits::new(s_2061_2 as u128, 4u16);
        // D s_2061_4: cmp-eq s_2061_1 s_2061_3
        let s_2061_4: bool = ((s_2061_1) == (s_2061_3));
        // N s_2061_5: branch s_2061_4 b4581 b2062
        if s_2061_4 {
            return block_4581(state, tracer, fn_state);
        } else {
            return block_2062(state, tracer, fn_state);
        };
    }
    fn block_2062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2062_0: const #0u : u8
        let s_2062_0: bool = false;
        // D s_2062_1: write-var gs#135396 <= s_2062_0
        fn_state.gs_135396 = s_2062_0;
        // N s_2062_2: jump b2063
        return block_2063(state, tracer, fn_state);
    }
    fn block_2063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2063_0: read-var gs#135396:u8
        let s_2063_0: bool = fn_state.gs_135396;
        // N s_2063_1: branch s_2063_0 b4580 b2064
        if s_2063_0 {
            return block_4580(state, tracer, fn_state);
        } else {
            return block_2064(state, tracer, fn_state);
        };
    }
    fn block_2064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2064_0: const #0u : u8
        let s_2064_0: bool = false;
        // D s_2064_1: write-var gs#135397 <= s_2064_0
        fn_state.gs_135397 = s_2064_0;
        // N s_2064_2: jump b2065
        return block_2065(state, tracer, fn_state);
    }
    fn block_2065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2065_0: read-var gs#135397:u8
        let s_2065_0: bool = fn_state.gs_135397;
        // N s_2065_1: branch s_2065_0 b4579 b2066
        if s_2065_0 {
            return block_4579(state, tracer, fn_state);
        } else {
            return block_2066(state, tracer, fn_state);
        };
    }
    fn block_2066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2066_0: const #0u : u8
        let s_2066_0: bool = false;
        // D s_2066_1: write-var gs#135398 <= s_2066_0
        fn_state.gs_135398 = s_2066_0;
        // N s_2066_2: jump b2067
        return block_2067(state, tracer, fn_state);
    }
    fn block_2067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2067_0: read-var gs#135398:u8
        let s_2067_0: bool = fn_state.gs_135398;
        // N s_2067_1: branch s_2067_0 b4578 b2068
        if s_2067_0 {
            return block_4578(state, tracer, fn_state);
        } else {
            return block_2068(state, tracer, fn_state);
        };
    }
    fn block_2068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2068_0: const #0u : u8
        let s_2068_0: bool = false;
        // D s_2068_1: write-var gs#135399 <= s_2068_0
        fn_state.gs_135399 = s_2068_0;
        // N s_2068_2: jump b2069
        return block_2069(state, tracer, fn_state);
    }
    fn block_2069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2069_0: read-var gs#135399:u8
        let s_2069_0: bool = fn_state.gs_135399;
        // N s_2069_1: branch s_2069_0 b4577 b2070
        if s_2069_0 {
            return block_4577(state, tracer, fn_state);
        } else {
            return block_2070(state, tracer, fn_state);
        };
    }
    fn block_2070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2070_0: read-var CRm:u8
        let s_2070_0: u8 = fn_state.CRm;
        // D s_2070_1: cast zx s_2070_0 -> bv
        let s_2070_1: Bits = Bits::new(s_2070_0 as u128, 4u16);
        // C s_2070_2: const #12u : u8
        let s_2070_2: u8 = 12;
        // C s_2070_3: cast zx s_2070_2 -> bv
        let s_2070_3: Bits = Bits::new(s_2070_2 as u128, 4u16);
        // D s_2070_4: cmp-eq s_2070_1 s_2070_3
        let s_2070_4: bool = ((s_2070_1) == (s_2070_3));
        // N s_2070_5: branch s_2070_4 b4576 b2071
        if s_2070_4 {
            return block_4576(state, tracer, fn_state);
        } else {
            return block_2071(state, tracer, fn_state);
        };
    }
    fn block_2071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2071_0: const #0u : u8
        let s_2071_0: bool = false;
        // D s_2071_1: write-var gs#135400 <= s_2071_0
        fn_state.gs_135400 = s_2071_0;
        // N s_2071_2: jump b2072
        return block_2072(state, tracer, fn_state);
    }
    fn block_2072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2072_0: read-var gs#135400:u8
        let s_2072_0: bool = fn_state.gs_135400;
        // N s_2072_1: branch s_2072_0 b4575 b2073
        if s_2072_0 {
            return block_4575(state, tracer, fn_state);
        } else {
            return block_2073(state, tracer, fn_state);
        };
    }
    fn block_2073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2073_0: const #0u : u8
        let s_2073_0: bool = false;
        // D s_2073_1: write-var gs#135401 <= s_2073_0
        fn_state.gs_135401 = s_2073_0;
        // N s_2073_2: jump b2074
        return block_2074(state, tracer, fn_state);
    }
    fn block_2074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2074_0: read-var gs#135401:u8
        let s_2074_0: bool = fn_state.gs_135401;
        // N s_2074_1: branch s_2074_0 b4574 b2075
        if s_2074_0 {
            return block_4574(state, tracer, fn_state);
        } else {
            return block_2075(state, tracer, fn_state);
        };
    }
    fn block_2075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2075_0: const #0u : u8
        let s_2075_0: bool = false;
        // D s_2075_1: write-var gs#135402 <= s_2075_0
        fn_state.gs_135402 = s_2075_0;
        // N s_2075_2: jump b2076
        return block_2076(state, tracer, fn_state);
    }
    fn block_2076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2076_0: read-var gs#135402:u8
        let s_2076_0: bool = fn_state.gs_135402;
        // N s_2076_1: branch s_2076_0 b4573 b2077
        if s_2076_0 {
            return block_4573(state, tracer, fn_state);
        } else {
            return block_2077(state, tracer, fn_state);
        };
    }
    fn block_2077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2077_0: const #0u : u8
        let s_2077_0: bool = false;
        // D s_2077_1: write-var gs#135403 <= s_2077_0
        fn_state.gs_135403 = s_2077_0;
        // N s_2077_2: jump b2078
        return block_2078(state, tracer, fn_state);
    }
    fn block_2078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2078_0: read-var gs#135403:u8
        let s_2078_0: bool = fn_state.gs_135403;
        // N s_2078_1: branch s_2078_0 b4572 b2079
        if s_2078_0 {
            return block_4572(state, tracer, fn_state);
        } else {
            return block_2079(state, tracer, fn_state);
        };
    }
    fn block_2079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2079_0: read-var CRm:u8
        let s_2079_0: u8 = fn_state.CRm;
        // D s_2079_1: cast zx s_2079_0 -> bv
        let s_2079_1: Bits = Bits::new(s_2079_0 as u128, 4u16);
        // C s_2079_2: const #12u : u8
        let s_2079_2: u8 = 12;
        // C s_2079_3: cast zx s_2079_2 -> bv
        let s_2079_3: Bits = Bits::new(s_2079_2 as u128, 4u16);
        // D s_2079_4: cmp-eq s_2079_1 s_2079_3
        let s_2079_4: bool = ((s_2079_1) == (s_2079_3));
        // N s_2079_5: branch s_2079_4 b4571 b2080
        if s_2079_4 {
            return block_4571(state, tracer, fn_state);
        } else {
            return block_2080(state, tracer, fn_state);
        };
    }
    fn block_2080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2080_0: const #0u : u8
        let s_2080_0: bool = false;
        // D s_2080_1: write-var gs#135404 <= s_2080_0
        fn_state.gs_135404 = s_2080_0;
        // N s_2080_2: jump b2081
        return block_2081(state, tracer, fn_state);
    }
    fn block_2081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2081_0: read-var gs#135404:u8
        let s_2081_0: bool = fn_state.gs_135404;
        // N s_2081_1: branch s_2081_0 b4570 b2082
        if s_2081_0 {
            return block_4570(state, tracer, fn_state);
        } else {
            return block_2082(state, tracer, fn_state);
        };
    }
    fn block_2082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2082_0: const #0u : u8
        let s_2082_0: bool = false;
        // D s_2082_1: write-var gs#135405 <= s_2082_0
        fn_state.gs_135405 = s_2082_0;
        // N s_2082_2: jump b2083
        return block_2083(state, tracer, fn_state);
    }
    fn block_2083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2083_0: read-var gs#135405:u8
        let s_2083_0: bool = fn_state.gs_135405;
        // N s_2083_1: branch s_2083_0 b4569 b2084
        if s_2083_0 {
            return block_4569(state, tracer, fn_state);
        } else {
            return block_2084(state, tracer, fn_state);
        };
    }
    fn block_2084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2084_0: const #0u : u8
        let s_2084_0: bool = false;
        // D s_2084_1: write-var gs#135406 <= s_2084_0
        fn_state.gs_135406 = s_2084_0;
        // N s_2084_2: jump b2085
        return block_2085(state, tracer, fn_state);
    }
    fn block_2085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2085_0: read-var gs#135406:u8
        let s_2085_0: bool = fn_state.gs_135406;
        // N s_2085_1: branch s_2085_0 b4568 b2086
        if s_2085_0 {
            return block_4568(state, tracer, fn_state);
        } else {
            return block_2086(state, tracer, fn_state);
        };
    }
    fn block_2086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2086_0: const #0u : u8
        let s_2086_0: bool = false;
        // D s_2086_1: write-var gs#135407 <= s_2086_0
        fn_state.gs_135407 = s_2086_0;
        // N s_2086_2: jump b2087
        return block_2087(state, tracer, fn_state);
    }
    fn block_2087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2087_0: read-var gs#135407:u8
        let s_2087_0: bool = fn_state.gs_135407;
        // N s_2087_1: branch s_2087_0 b4567 b2088
        if s_2087_0 {
            return block_4567(state, tracer, fn_state);
        } else {
            return block_2088(state, tracer, fn_state);
        };
    }
    fn block_2088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2088_0: read-var CRm:u8
        let s_2088_0: u8 = fn_state.CRm;
        // D s_2088_1: cast zx s_2088_0 -> bv
        let s_2088_1: Bits = Bits::new(s_2088_0 as u128, 4u16);
        // C s_2088_2: const #3u : u8
        let s_2088_2: u8 = 3;
        // C s_2088_3: cast zx s_2088_2 -> bv
        let s_2088_3: Bits = Bits::new(s_2088_2 as u128, 4u16);
        // D s_2088_4: cmp-eq s_2088_1 s_2088_3
        let s_2088_4: bool = ((s_2088_1) == (s_2088_3));
        // N s_2088_5: branch s_2088_4 b4566 b2089
        if s_2088_4 {
            return block_4566(state, tracer, fn_state);
        } else {
            return block_2089(state, tracer, fn_state);
        };
    }
    fn block_2089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2089_0: const #0u : u8
        let s_2089_0: bool = false;
        // D s_2089_1: write-var gs#135408 <= s_2089_0
        fn_state.gs_135408 = s_2089_0;
        // N s_2089_2: jump b2090
        return block_2090(state, tracer, fn_state);
    }
    fn block_2090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2090_0: read-var gs#135408:u8
        let s_2090_0: bool = fn_state.gs_135408;
        // N s_2090_1: branch s_2090_0 b4565 b2091
        if s_2090_0 {
            return block_4565(state, tracer, fn_state);
        } else {
            return block_2091(state, tracer, fn_state);
        };
    }
    fn block_2091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2091_0: const #0u : u8
        let s_2091_0: bool = false;
        // D s_2091_1: write-var gs#135409 <= s_2091_0
        fn_state.gs_135409 = s_2091_0;
        // N s_2091_2: jump b2092
        return block_2092(state, tracer, fn_state);
    }
    fn block_2092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2092_0: read-var gs#135409:u8
        let s_2092_0: bool = fn_state.gs_135409;
        // N s_2092_1: branch s_2092_0 b4564 b2093
        if s_2092_0 {
            return block_4564(state, tracer, fn_state);
        } else {
            return block_2093(state, tracer, fn_state);
        };
    }
    fn block_2093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2093_0: const #0u : u8
        let s_2093_0: bool = false;
        // D s_2093_1: write-var gs#135410 <= s_2093_0
        fn_state.gs_135410 = s_2093_0;
        // N s_2093_2: jump b2094
        return block_2094(state, tracer, fn_state);
    }
    fn block_2094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2094_0: read-var gs#135410:u8
        let s_2094_0: bool = fn_state.gs_135410;
        // N s_2094_1: branch s_2094_0 b4563 b2095
        if s_2094_0 {
            return block_4563(state, tracer, fn_state);
        } else {
            return block_2095(state, tracer, fn_state);
        };
    }
    fn block_2095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2095_0: const #0u : u8
        let s_2095_0: bool = false;
        // D s_2095_1: write-var gs#135411 <= s_2095_0
        fn_state.gs_135411 = s_2095_0;
        // N s_2095_2: jump b2096
        return block_2096(state, tracer, fn_state);
    }
    fn block_2096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2096_0: read-var gs#135411:u8
        let s_2096_0: bool = fn_state.gs_135411;
        // N s_2096_1: branch s_2096_0 b4562 b2097
        if s_2096_0 {
            return block_4562(state, tracer, fn_state);
        } else {
            return block_2097(state, tracer, fn_state);
        };
    }
    fn block_2097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2097_0: read-var CRm:u8
        let s_2097_0: u8 = fn_state.CRm;
        // D s_2097_1: cast zx s_2097_0 -> bv
        let s_2097_1: Bits = Bits::new(s_2097_0 as u128, 4u16);
        // C s_2097_2: const #1u : u8
        let s_2097_2: u8 = 1;
        // C s_2097_3: cast zx s_2097_2 -> bv
        let s_2097_3: Bits = Bits::new(s_2097_2 as u128, 4u16);
        // D s_2097_4: cmp-eq s_2097_1 s_2097_3
        let s_2097_4: bool = ((s_2097_1) == (s_2097_3));
        // N s_2097_5: branch s_2097_4 b4561 b2098
        if s_2097_4 {
            return block_4561(state, tracer, fn_state);
        } else {
            return block_2098(state, tracer, fn_state);
        };
    }
    fn block_2098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2098_0: const #0u : u8
        let s_2098_0: bool = false;
        // D s_2098_1: write-var gs#135412 <= s_2098_0
        fn_state.gs_135412 = s_2098_0;
        // N s_2098_2: jump b2099
        return block_2099(state, tracer, fn_state);
    }
    fn block_2099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2099_0: read-var gs#135412:u8
        let s_2099_0: bool = fn_state.gs_135412;
        // N s_2099_1: branch s_2099_0 b4560 b2100
        if s_2099_0 {
            return block_4560(state, tracer, fn_state);
        } else {
            return block_2100(state, tracer, fn_state);
        };
    }
    fn block_2100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2100_0: const #0u : u8
        let s_2100_0: bool = false;
        // D s_2100_1: write-var gs#135413 <= s_2100_0
        fn_state.gs_135413 = s_2100_0;
        // N s_2100_2: jump b2101
        return block_2101(state, tracer, fn_state);
    }
    fn block_2101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2101_0: read-var gs#135413:u8
        let s_2101_0: bool = fn_state.gs_135413;
        // N s_2101_1: branch s_2101_0 b4559 b2102
        if s_2101_0 {
            return block_4559(state, tracer, fn_state);
        } else {
            return block_2102(state, tracer, fn_state);
        };
    }
    fn block_2102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2102_0: const #0u : u8
        let s_2102_0: bool = false;
        // D s_2102_1: write-var gs#135414 <= s_2102_0
        fn_state.gs_135414 = s_2102_0;
        // N s_2102_2: jump b2103
        return block_2103(state, tracer, fn_state);
    }
    fn block_2103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2103_0: read-var gs#135414:u8
        let s_2103_0: bool = fn_state.gs_135414;
        // N s_2103_1: branch s_2103_0 b4558 b2104
        if s_2103_0 {
            return block_4558(state, tracer, fn_state);
        } else {
            return block_2104(state, tracer, fn_state);
        };
    }
    fn block_2104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2104_0: const #0u : u8
        let s_2104_0: bool = false;
        // D s_2104_1: write-var gs#135415 <= s_2104_0
        fn_state.gs_135415 = s_2104_0;
        // N s_2104_2: jump b2105
        return block_2105(state, tracer, fn_state);
    }
    fn block_2105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2105_0: read-var gs#135415:u8
        let s_2105_0: bool = fn_state.gs_135415;
        // N s_2105_1: branch s_2105_0 b4557 b2106
        if s_2105_0 {
            return block_4557(state, tracer, fn_state);
        } else {
            return block_2106(state, tracer, fn_state);
        };
    }
    fn block_2106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2106_0: read-var CRm:u8
        let s_2106_0: u8 = fn_state.CRm;
        // D s_2106_1: cast zx s_2106_0 -> bv
        let s_2106_1: Bits = Bits::new(s_2106_0 as u128, 4u16);
        // C s_2106_2: const #0u : u8
        let s_2106_2: u8 = 0;
        // C s_2106_3: cast zx s_2106_2 -> bv
        let s_2106_3: Bits = Bits::new(s_2106_2 as u128, 4u16);
        // D s_2106_4: cmp-eq s_2106_1 s_2106_3
        let s_2106_4: bool = ((s_2106_1) == (s_2106_3));
        // N s_2106_5: branch s_2106_4 b4556 b2107
        if s_2106_4 {
            return block_4556(state, tracer, fn_state);
        } else {
            return block_2107(state, tracer, fn_state);
        };
    }
    fn block_2107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2107_0: const #0u : u8
        let s_2107_0: bool = false;
        // D s_2107_1: write-var gs#135416 <= s_2107_0
        fn_state.gs_135416 = s_2107_0;
        // N s_2107_2: jump b2108
        return block_2108(state, tracer, fn_state);
    }
    fn block_2108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2108_0: read-var gs#135416:u8
        let s_2108_0: bool = fn_state.gs_135416;
        // N s_2108_1: branch s_2108_0 b4555 b2109
        if s_2108_0 {
            return block_4555(state, tracer, fn_state);
        } else {
            return block_2109(state, tracer, fn_state);
        };
    }
    fn block_2109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2109_0: const #0u : u8
        let s_2109_0: bool = false;
        // D s_2109_1: write-var gs#135417 <= s_2109_0
        fn_state.gs_135417 = s_2109_0;
        // N s_2109_2: jump b2110
        return block_2110(state, tracer, fn_state);
    }
    fn block_2110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2110_0: read-var gs#135417:u8
        let s_2110_0: bool = fn_state.gs_135417;
        // N s_2110_1: branch s_2110_0 b4554 b2111
        if s_2110_0 {
            return block_4554(state, tracer, fn_state);
        } else {
            return block_2111(state, tracer, fn_state);
        };
    }
    fn block_2111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2111_0: const #0u : u8
        let s_2111_0: bool = false;
        // D s_2111_1: write-var gs#135418 <= s_2111_0
        fn_state.gs_135418 = s_2111_0;
        // N s_2111_2: jump b2112
        return block_2112(state, tracer, fn_state);
    }
    fn block_2112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2112_0: read-var gs#135418:u8
        let s_2112_0: bool = fn_state.gs_135418;
        // N s_2112_1: branch s_2112_0 b4553 b2113
        if s_2112_0 {
            return block_4553(state, tracer, fn_state);
        } else {
            return block_2113(state, tracer, fn_state);
        };
    }
    fn block_2113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2113_0: const #0u : u8
        let s_2113_0: bool = false;
        // D s_2113_1: write-var gs#135419 <= s_2113_0
        fn_state.gs_135419 = s_2113_0;
        // N s_2113_2: jump b2114
        return block_2114(state, tracer, fn_state);
    }
    fn block_2114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2114_0: read-var gs#135419:u8
        let s_2114_0: bool = fn_state.gs_135419;
        // N s_2114_1: branch s_2114_0 b4552 b2115
        if s_2114_0 {
            return block_4552(state, tracer, fn_state);
        } else {
            return block_2115(state, tracer, fn_state);
        };
    }
    fn block_2115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2115_0: read-var CRm:u8
        let s_2115_0: u8 = fn_state.CRm;
        // D s_2115_1: cast zx s_2115_0 -> bv
        let s_2115_1: Bits = Bits::new(s_2115_0 as u128, 4u16);
        // C s_2115_2: const #1u : u8
        let s_2115_2: u8 = 1;
        // C s_2115_3: cast zx s_2115_2 -> bv
        let s_2115_3: Bits = Bits::new(s_2115_2 as u128, 4u16);
        // D s_2115_4: cmp-eq s_2115_1 s_2115_3
        let s_2115_4: bool = ((s_2115_1) == (s_2115_3));
        // N s_2115_5: branch s_2115_4 b4551 b2116
        if s_2115_4 {
            return block_4551(state, tracer, fn_state);
        } else {
            return block_2116(state, tracer, fn_state);
        };
    }
    fn block_2116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2116_0: const #0u : u8
        let s_2116_0: bool = false;
        // D s_2116_1: write-var gs#135420 <= s_2116_0
        fn_state.gs_135420 = s_2116_0;
        // N s_2116_2: jump b2117
        return block_2117(state, tracer, fn_state);
    }
    fn block_2117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2117_0: read-var gs#135420:u8
        let s_2117_0: bool = fn_state.gs_135420;
        // N s_2117_1: branch s_2117_0 b4550 b2118
        if s_2117_0 {
            return block_4550(state, tracer, fn_state);
        } else {
            return block_2118(state, tracer, fn_state);
        };
    }
    fn block_2118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2118_0: const #0u : u8
        let s_2118_0: bool = false;
        // D s_2118_1: write-var gs#135421 <= s_2118_0
        fn_state.gs_135421 = s_2118_0;
        // N s_2118_2: jump b2119
        return block_2119(state, tracer, fn_state);
    }
    fn block_2119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2119_0: read-var gs#135421:u8
        let s_2119_0: bool = fn_state.gs_135421;
        // N s_2119_1: branch s_2119_0 b4549 b2120
        if s_2119_0 {
            return block_4549(state, tracer, fn_state);
        } else {
            return block_2120(state, tracer, fn_state);
        };
    }
    fn block_2120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2120_0: const #0u : u8
        let s_2120_0: bool = false;
        // D s_2120_1: write-var gs#135422 <= s_2120_0
        fn_state.gs_135422 = s_2120_0;
        // N s_2120_2: jump b2121
        return block_2121(state, tracer, fn_state);
    }
    fn block_2121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2121_0: read-var gs#135422:u8
        let s_2121_0: bool = fn_state.gs_135422;
        // N s_2121_1: branch s_2121_0 b4548 b2122
        if s_2121_0 {
            return block_4548(state, tracer, fn_state);
        } else {
            return block_2122(state, tracer, fn_state);
        };
    }
    fn block_2122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2122_0: const #0u : u8
        let s_2122_0: bool = false;
        // D s_2122_1: write-var gs#135423 <= s_2122_0
        fn_state.gs_135423 = s_2122_0;
        // N s_2122_2: jump b2123
        return block_2123(state, tracer, fn_state);
    }
    fn block_2123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2123_0: read-var gs#135423:u8
        let s_2123_0: bool = fn_state.gs_135423;
        // N s_2123_1: branch s_2123_0 b4547 b2124
        if s_2123_0 {
            return block_4547(state, tracer, fn_state);
        } else {
            return block_2124(state, tracer, fn_state);
        };
    }
    fn block_2124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2124_0: read-var CRm:u8
        let s_2124_0: u8 = fn_state.CRm;
        // D s_2124_1: cast zx s_2124_0 -> bv
        let s_2124_1: Bits = Bits::new(s_2124_0 as u128, 4u16);
        // C s_2124_2: const #8u : u8
        let s_2124_2: u8 = 8;
        // C s_2124_3: cast zx s_2124_2 -> bv
        let s_2124_3: Bits = Bits::new(s_2124_2 as u128, 4u16);
        // D s_2124_4: cmp-eq s_2124_1 s_2124_3
        let s_2124_4: bool = ((s_2124_1) == (s_2124_3));
        // N s_2124_5: branch s_2124_4 b4546 b2125
        if s_2124_4 {
            return block_4546(state, tracer, fn_state);
        } else {
            return block_2125(state, tracer, fn_state);
        };
    }
    fn block_2125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2125_0: const #0u : u8
        let s_2125_0: bool = false;
        // D s_2125_1: write-var gs#135424 <= s_2125_0
        fn_state.gs_135424 = s_2125_0;
        // N s_2125_2: jump b2126
        return block_2126(state, tracer, fn_state);
    }
    fn block_2126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2126_0: read-var gs#135424:u8
        let s_2126_0: bool = fn_state.gs_135424;
        // N s_2126_1: branch s_2126_0 b4545 b2127
        if s_2126_0 {
            return block_4545(state, tracer, fn_state);
        } else {
            return block_2127(state, tracer, fn_state);
        };
    }
    fn block_2127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2127_0: const #0u : u8
        let s_2127_0: bool = false;
        // D s_2127_1: write-var gs#135425 <= s_2127_0
        fn_state.gs_135425 = s_2127_0;
        // N s_2127_2: jump b2128
        return block_2128(state, tracer, fn_state);
    }
    fn block_2128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2128_0: read-var gs#135425:u8
        let s_2128_0: bool = fn_state.gs_135425;
        // N s_2128_1: branch s_2128_0 b4544 b2129
        if s_2128_0 {
            return block_4544(state, tracer, fn_state);
        } else {
            return block_2129(state, tracer, fn_state);
        };
    }
    fn block_2129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2129_0: const #0u : u8
        let s_2129_0: bool = false;
        // D s_2129_1: write-var gs#135426 <= s_2129_0
        fn_state.gs_135426 = s_2129_0;
        // N s_2129_2: jump b2130
        return block_2130(state, tracer, fn_state);
    }
    fn block_2130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2130_0: read-var gs#135426:u8
        let s_2130_0: bool = fn_state.gs_135426;
        // N s_2130_1: branch s_2130_0 b4543 b2131
        if s_2130_0 {
            return block_4543(state, tracer, fn_state);
        } else {
            return block_2131(state, tracer, fn_state);
        };
    }
    fn block_2131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2131_0: const #0u : u8
        let s_2131_0: bool = false;
        // D s_2131_1: write-var gs#135427 <= s_2131_0
        fn_state.gs_135427 = s_2131_0;
        // N s_2131_2: jump b2132
        return block_2132(state, tracer, fn_state);
    }
    fn block_2132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2132_0: read-var gs#135427:u8
        let s_2132_0: bool = fn_state.gs_135427;
        // N s_2132_1: branch s_2132_0 b4542 b2133
        if s_2132_0 {
            return block_4542(state, tracer, fn_state);
        } else {
            return block_2133(state, tracer, fn_state);
        };
    }
    fn block_2133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2133_0: read-var CRm:u8
        let s_2133_0: u8 = fn_state.CRm;
        // D s_2133_1: cast zx s_2133_0 -> bv
        let s_2133_1: Bits = Bits::new(s_2133_0 as u128, 4u16);
        // C s_2133_2: const #14u : u8
        let s_2133_2: u8 = 14;
        // C s_2133_3: cast zx s_2133_2 -> bv
        let s_2133_3: Bits = Bits::new(s_2133_2 as u128, 4u16);
        // D s_2133_4: cmp-eq s_2133_1 s_2133_3
        let s_2133_4: bool = ((s_2133_1) == (s_2133_3));
        // N s_2133_5: branch s_2133_4 b4541 b2134
        if s_2133_4 {
            return block_4541(state, tracer, fn_state);
        } else {
            return block_2134(state, tracer, fn_state);
        };
    }
    fn block_2134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2134_0: const #0u : u8
        let s_2134_0: bool = false;
        // D s_2134_1: write-var gs#135428 <= s_2134_0
        fn_state.gs_135428 = s_2134_0;
        // N s_2134_2: jump b2135
        return block_2135(state, tracer, fn_state);
    }
    fn block_2135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2135_0: read-var gs#135428:u8
        let s_2135_0: bool = fn_state.gs_135428;
        // N s_2135_1: branch s_2135_0 b4540 b2136
        if s_2135_0 {
            return block_4540(state, tracer, fn_state);
        } else {
            return block_2136(state, tracer, fn_state);
        };
    }
    fn block_2136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2136_0: const #0u : u8
        let s_2136_0: bool = false;
        // D s_2136_1: write-var gs#135429 <= s_2136_0
        fn_state.gs_135429 = s_2136_0;
        // N s_2136_2: jump b2137
        return block_2137(state, tracer, fn_state);
    }
    fn block_2137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2137_0: read-var gs#135429:u8
        let s_2137_0: bool = fn_state.gs_135429;
        // N s_2137_1: branch s_2137_0 b4539 b2138
        if s_2137_0 {
            return block_4539(state, tracer, fn_state);
        } else {
            return block_2138(state, tracer, fn_state);
        };
    }
    fn block_2138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2138_0: const #0u : u8
        let s_2138_0: bool = false;
        // D s_2138_1: write-var gs#135430 <= s_2138_0
        fn_state.gs_135430 = s_2138_0;
        // N s_2138_2: jump b2139
        return block_2139(state, tracer, fn_state);
    }
    fn block_2139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2139_0: read-var gs#135430:u8
        let s_2139_0: bool = fn_state.gs_135430;
        // N s_2139_1: branch s_2139_0 b4538 b2140
        if s_2139_0 {
            return block_4538(state, tracer, fn_state);
        } else {
            return block_2140(state, tracer, fn_state);
        };
    }
    fn block_2140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2140_0: const #0u : u8
        let s_2140_0: bool = false;
        // D s_2140_1: write-var gs#135431 <= s_2140_0
        fn_state.gs_135431 = s_2140_0;
        // N s_2140_2: jump b2141
        return block_2141(state, tracer, fn_state);
    }
    fn block_2141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2141_0: read-var gs#135431:u8
        let s_2141_0: bool = fn_state.gs_135431;
        // N s_2141_1: branch s_2141_0 b4537 b2142
        if s_2141_0 {
            return block_4537(state, tracer, fn_state);
        } else {
            return block_2142(state, tracer, fn_state);
        };
    }
    fn block_2142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2142_0: read-var CRm:u8
        let s_2142_0: u8 = fn_state.CRm;
        // D s_2142_1: cast zx s_2142_0 -> bv
        let s_2142_1: Bits = Bits::new(s_2142_0 as u128, 4u16);
        // C s_2142_2: const #15u : u8
        let s_2142_2: u8 = 15;
        // C s_2142_3: cast zx s_2142_2 -> bv
        let s_2142_3: Bits = Bits::new(s_2142_2 as u128, 4u16);
        // D s_2142_4: cmp-eq s_2142_1 s_2142_3
        let s_2142_4: bool = ((s_2142_1) == (s_2142_3));
        // N s_2142_5: branch s_2142_4 b4536 b2143
        if s_2142_4 {
            return block_4536(state, tracer, fn_state);
        } else {
            return block_2143(state, tracer, fn_state);
        };
    }
    fn block_2143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2143_0: const #0u : u8
        let s_2143_0: bool = false;
        // D s_2143_1: write-var gs#135432 <= s_2143_0
        fn_state.gs_135432 = s_2143_0;
        // N s_2143_2: jump b2144
        return block_2144(state, tracer, fn_state);
    }
    fn block_2144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2144_0: read-var gs#135432:u8
        let s_2144_0: bool = fn_state.gs_135432;
        // N s_2144_1: branch s_2144_0 b4535 b2145
        if s_2144_0 {
            return block_4535(state, tracer, fn_state);
        } else {
            return block_2145(state, tracer, fn_state);
        };
    }
    fn block_2145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2145_0: const #0u : u8
        let s_2145_0: bool = false;
        // D s_2145_1: write-var gs#135433 <= s_2145_0
        fn_state.gs_135433 = s_2145_0;
        // N s_2145_2: jump b2146
        return block_2146(state, tracer, fn_state);
    }
    fn block_2146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2146_0: read-var gs#135433:u8
        let s_2146_0: bool = fn_state.gs_135433;
        // N s_2146_1: branch s_2146_0 b4534 b2147
        if s_2146_0 {
            return block_4534(state, tracer, fn_state);
        } else {
            return block_2147(state, tracer, fn_state);
        };
    }
    fn block_2147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2147_0: const #0u : u8
        let s_2147_0: bool = false;
        // D s_2147_1: write-var gs#135434 <= s_2147_0
        fn_state.gs_135434 = s_2147_0;
        // N s_2147_2: jump b2148
        return block_2148(state, tracer, fn_state);
    }
    fn block_2148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2148_0: read-var gs#135434:u8
        let s_2148_0: bool = fn_state.gs_135434;
        // N s_2148_1: branch s_2148_0 b4533 b2149
        if s_2148_0 {
            return block_4533(state, tracer, fn_state);
        } else {
            return block_2149(state, tracer, fn_state);
        };
    }
    fn block_2149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2149_0: const #0u : u8
        let s_2149_0: bool = false;
        // D s_2149_1: write-var gs#135435 <= s_2149_0
        fn_state.gs_135435 = s_2149_0;
        // N s_2149_2: jump b2150
        return block_2150(state, tracer, fn_state);
    }
    fn block_2150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2150_0: read-var gs#135435:u8
        let s_2150_0: bool = fn_state.gs_135435;
        // N s_2150_1: branch s_2150_0 b4532 b2151
        if s_2150_0 {
            return block_4532(state, tracer, fn_state);
        } else {
            return block_2151(state, tracer, fn_state);
        };
    }
    fn block_2151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2151_0: read-var CRm:u8
        let s_2151_0: u8 = fn_state.CRm;
        // D s_2151_1: cast zx s_2151_0 -> bv
        let s_2151_1: Bits = Bits::new(s_2151_0 as u128, 4u16);
        // C s_2151_2: const #14u : u8
        let s_2151_2: u8 = 14;
        // C s_2151_3: cast zx s_2151_2 -> bv
        let s_2151_3: Bits = Bits::new(s_2151_2 as u128, 4u16);
        // D s_2151_4: cmp-eq s_2151_1 s_2151_3
        let s_2151_4: bool = ((s_2151_1) == (s_2151_3));
        // N s_2151_5: branch s_2151_4 b4531 b2152
        if s_2151_4 {
            return block_4531(state, tracer, fn_state);
        } else {
            return block_2152(state, tracer, fn_state);
        };
    }
    fn block_2152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2152_0: const #0u : u8
        let s_2152_0: bool = false;
        // D s_2152_1: write-var gs#135436 <= s_2152_0
        fn_state.gs_135436 = s_2152_0;
        // N s_2152_2: jump b2153
        return block_2153(state, tracer, fn_state);
    }
    fn block_2153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2153_0: read-var gs#135436:u8
        let s_2153_0: bool = fn_state.gs_135436;
        // N s_2153_1: branch s_2153_0 b4530 b2154
        if s_2153_0 {
            return block_4530(state, tracer, fn_state);
        } else {
            return block_2154(state, tracer, fn_state);
        };
    }
    fn block_2154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2154_0: const #0u : u8
        let s_2154_0: bool = false;
        // D s_2154_1: write-var gs#135437 <= s_2154_0
        fn_state.gs_135437 = s_2154_0;
        // N s_2154_2: jump b2155
        return block_2155(state, tracer, fn_state);
    }
    fn block_2155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2155_0: read-var gs#135437:u8
        let s_2155_0: bool = fn_state.gs_135437;
        // N s_2155_1: branch s_2155_0 b4529 b2156
        if s_2155_0 {
            return block_4529(state, tracer, fn_state);
        } else {
            return block_2156(state, tracer, fn_state);
        };
    }
    fn block_2156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2156_0: const #0u : u8
        let s_2156_0: bool = false;
        // D s_2156_1: write-var gs#135438 <= s_2156_0
        fn_state.gs_135438 = s_2156_0;
        // N s_2156_2: jump b2157
        return block_2157(state, tracer, fn_state);
    }
    fn block_2157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2157_0: read-var gs#135438:u8
        let s_2157_0: bool = fn_state.gs_135438;
        // N s_2157_1: branch s_2157_0 b4528 b2158
        if s_2157_0 {
            return block_4528(state, tracer, fn_state);
        } else {
            return block_2158(state, tracer, fn_state);
        };
    }
    fn block_2158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2158_0: const #0u : u8
        let s_2158_0: bool = false;
        // D s_2158_1: write-var gs#135439 <= s_2158_0
        fn_state.gs_135439 = s_2158_0;
        // N s_2158_2: jump b2159
        return block_2159(state, tracer, fn_state);
    }
    fn block_2159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2159_0: read-var gs#135439:u8
        let s_2159_0: bool = fn_state.gs_135439;
        // N s_2159_1: branch s_2159_0 b4527 b2160
        if s_2159_0 {
            return block_4527(state, tracer, fn_state);
        } else {
            return block_2160(state, tracer, fn_state);
        };
    }
    fn block_2160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2160_0: read-var CRm:u8
        let s_2160_0: u8 = fn_state.CRm;
        // D s_2160_1: cast zx s_2160_0 -> bv
        let s_2160_1: Bits = Bits::new(s_2160_0 as u128, 4u16);
        // C s_2160_2: const #13u : u8
        let s_2160_2: u8 = 13;
        // C s_2160_3: cast zx s_2160_2 -> bv
        let s_2160_3: Bits = Bits::new(s_2160_2 as u128, 4u16);
        // D s_2160_4: cmp-eq s_2160_1 s_2160_3
        let s_2160_4: bool = ((s_2160_1) == (s_2160_3));
        // N s_2160_5: branch s_2160_4 b4526 b2161
        if s_2160_4 {
            return block_4526(state, tracer, fn_state);
        } else {
            return block_2161(state, tracer, fn_state);
        };
    }
    fn block_2161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2161_0: const #0u : u8
        let s_2161_0: bool = false;
        // D s_2161_1: write-var gs#135440 <= s_2161_0
        fn_state.gs_135440 = s_2161_0;
        // N s_2161_2: jump b2162
        return block_2162(state, tracer, fn_state);
    }
    fn block_2162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2162_0: read-var gs#135440:u8
        let s_2162_0: bool = fn_state.gs_135440;
        // N s_2162_1: branch s_2162_0 b4525 b2163
        if s_2162_0 {
            return block_4525(state, tracer, fn_state);
        } else {
            return block_2163(state, tracer, fn_state);
        };
    }
    fn block_2163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2163_0: const #0u : u8
        let s_2163_0: bool = false;
        // D s_2163_1: write-var gs#135441 <= s_2163_0
        fn_state.gs_135441 = s_2163_0;
        // N s_2163_2: jump b2164
        return block_2164(state, tracer, fn_state);
    }
    fn block_2164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2164_0: read-var gs#135441:u8
        let s_2164_0: bool = fn_state.gs_135441;
        // N s_2164_1: branch s_2164_0 b4524 b2165
        if s_2164_0 {
            return block_4524(state, tracer, fn_state);
        } else {
            return block_2165(state, tracer, fn_state);
        };
    }
    fn block_2165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2165_0: const #0u : u8
        let s_2165_0: bool = false;
        // D s_2165_1: write-var gs#135442 <= s_2165_0
        fn_state.gs_135442 = s_2165_0;
        // N s_2165_2: jump b2166
        return block_2166(state, tracer, fn_state);
    }
    fn block_2166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2166_0: read-var gs#135442:u8
        let s_2166_0: bool = fn_state.gs_135442;
        // N s_2166_1: branch s_2166_0 b4523 b2167
        if s_2166_0 {
            return block_4523(state, tracer, fn_state);
        } else {
            return block_2167(state, tracer, fn_state);
        };
    }
    fn block_2167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2167_0: const #0u : u8
        let s_2167_0: bool = false;
        // D s_2167_1: write-var gs#135443 <= s_2167_0
        fn_state.gs_135443 = s_2167_0;
        // N s_2167_2: jump b2168
        return block_2168(state, tracer, fn_state);
    }
    fn block_2168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2168_0: read-var gs#135443:u8
        let s_2168_0: bool = fn_state.gs_135443;
        // N s_2168_1: branch s_2168_0 b4522 b2169
        if s_2168_0 {
            return block_4522(state, tracer, fn_state);
        } else {
            return block_2169(state, tracer, fn_state);
        };
    }
    fn block_2169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2169_0: read-var CRm:u8
        let s_2169_0: u8 = fn_state.CRm;
        // D s_2169_1: cast zx s_2169_0 -> bv
        let s_2169_1: Bits = Bits::new(s_2169_0 as u128, 4u16);
        // C s_2169_2: const #12u : u8
        let s_2169_2: u8 = 12;
        // C s_2169_3: cast zx s_2169_2 -> bv
        let s_2169_3: Bits = Bits::new(s_2169_2 as u128, 4u16);
        // D s_2169_4: cmp-eq s_2169_1 s_2169_3
        let s_2169_4: bool = ((s_2169_1) == (s_2169_3));
        // N s_2169_5: branch s_2169_4 b4521 b2170
        if s_2169_4 {
            return block_4521(state, tracer, fn_state);
        } else {
            return block_2170(state, tracer, fn_state);
        };
    }
    fn block_2170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2170_0: const #0u : u8
        let s_2170_0: bool = false;
        // D s_2170_1: write-var gs#135444 <= s_2170_0
        fn_state.gs_135444 = s_2170_0;
        // N s_2170_2: jump b2171
        return block_2171(state, tracer, fn_state);
    }
    fn block_2171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2171_0: read-var gs#135444:u8
        let s_2171_0: bool = fn_state.gs_135444;
        // N s_2171_1: branch s_2171_0 b4520 b2172
        if s_2171_0 {
            return block_4520(state, tracer, fn_state);
        } else {
            return block_2172(state, tracer, fn_state);
        };
    }
    fn block_2172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2172_0: const #0u : u8
        let s_2172_0: bool = false;
        // D s_2172_1: write-var gs#135445 <= s_2172_0
        fn_state.gs_135445 = s_2172_0;
        // N s_2172_2: jump b2173
        return block_2173(state, tracer, fn_state);
    }
    fn block_2173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2173_0: read-var gs#135445:u8
        let s_2173_0: bool = fn_state.gs_135445;
        // N s_2173_1: branch s_2173_0 b4519 b2174
        if s_2173_0 {
            return block_4519(state, tracer, fn_state);
        } else {
            return block_2174(state, tracer, fn_state);
        };
    }
    fn block_2174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2174_0: const #0u : u8
        let s_2174_0: bool = false;
        // D s_2174_1: write-var gs#135446 <= s_2174_0
        fn_state.gs_135446 = s_2174_0;
        // N s_2174_2: jump b2175
        return block_2175(state, tracer, fn_state);
    }
    fn block_2175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2175_0: read-var gs#135446:u8
        let s_2175_0: bool = fn_state.gs_135446;
        // N s_2175_1: branch s_2175_0 b4518 b2176
        if s_2175_0 {
            return block_4518(state, tracer, fn_state);
        } else {
            return block_2176(state, tracer, fn_state);
        };
    }
    fn block_2176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2176_0: const #0u : u8
        let s_2176_0: bool = false;
        // D s_2176_1: write-var gs#135447 <= s_2176_0
        fn_state.gs_135447 = s_2176_0;
        // N s_2176_2: jump b2177
        return block_2177(state, tracer, fn_state);
    }
    fn block_2177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2177_0: read-var gs#135447:u8
        let s_2177_0: bool = fn_state.gs_135447;
        // N s_2177_1: branch s_2177_0 b4517 b2178
        if s_2177_0 {
            return block_4517(state, tracer, fn_state);
        } else {
            return block_2178(state, tracer, fn_state);
        };
    }
    fn block_2178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2178_0: read-var CRm:u8
        let s_2178_0: u8 = fn_state.CRm;
        // D s_2178_1: cast zx s_2178_0 -> bv
        let s_2178_1: Bits = Bits::new(s_2178_0 as u128, 4u16);
        // C s_2178_2: const #11u : u8
        let s_2178_2: u8 = 11;
        // C s_2178_3: cast zx s_2178_2 -> bv
        let s_2178_3: Bits = Bits::new(s_2178_2 as u128, 4u16);
        // D s_2178_4: cmp-eq s_2178_1 s_2178_3
        let s_2178_4: bool = ((s_2178_1) == (s_2178_3));
        // N s_2178_5: branch s_2178_4 b4516 b2179
        if s_2178_4 {
            return block_4516(state, tracer, fn_state);
        } else {
            return block_2179(state, tracer, fn_state);
        };
    }
    fn block_2179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2179_0: const #0u : u8
        let s_2179_0: bool = false;
        // D s_2179_1: write-var gs#135448 <= s_2179_0
        fn_state.gs_135448 = s_2179_0;
        // N s_2179_2: jump b2180
        return block_2180(state, tracer, fn_state);
    }
    fn block_2180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2180_0: read-var gs#135448:u8
        let s_2180_0: bool = fn_state.gs_135448;
        // N s_2180_1: branch s_2180_0 b4515 b2181
        if s_2180_0 {
            return block_4515(state, tracer, fn_state);
        } else {
            return block_2181(state, tracer, fn_state);
        };
    }
    fn block_2181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2181_0: const #0u : u8
        let s_2181_0: bool = false;
        // D s_2181_1: write-var gs#135449 <= s_2181_0
        fn_state.gs_135449 = s_2181_0;
        // N s_2181_2: jump b2182
        return block_2182(state, tracer, fn_state);
    }
    fn block_2182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2182_0: read-var gs#135449:u8
        let s_2182_0: bool = fn_state.gs_135449;
        // N s_2182_1: branch s_2182_0 b4514 b2183
        if s_2182_0 {
            return block_4514(state, tracer, fn_state);
        } else {
            return block_2183(state, tracer, fn_state);
        };
    }
    fn block_2183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2183_0: const #0u : u8
        let s_2183_0: bool = false;
        // D s_2183_1: write-var gs#135450 <= s_2183_0
        fn_state.gs_135450 = s_2183_0;
        // N s_2183_2: jump b2184
        return block_2184(state, tracer, fn_state);
    }
    fn block_2184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2184_0: read-var gs#135450:u8
        let s_2184_0: bool = fn_state.gs_135450;
        // N s_2184_1: branch s_2184_0 b4513 b2185
        if s_2184_0 {
            return block_4513(state, tracer, fn_state);
        } else {
            return block_2185(state, tracer, fn_state);
        };
    }
    fn block_2185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2185_0: const #0u : u8
        let s_2185_0: bool = false;
        // D s_2185_1: write-var gs#135451 <= s_2185_0
        fn_state.gs_135451 = s_2185_0;
        // N s_2185_2: jump b2186
        return block_2186(state, tracer, fn_state);
    }
    fn block_2186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2186_0: read-var gs#135451:u8
        let s_2186_0: bool = fn_state.gs_135451;
        // N s_2186_1: branch s_2186_0 b4512 b2187
        if s_2186_0 {
            return block_4512(state, tracer, fn_state);
        } else {
            return block_2187(state, tracer, fn_state);
        };
    }
    fn block_2187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2187_0: read-var CRm:u8
        let s_2187_0: u8 = fn_state.CRm;
        // D s_2187_1: cast zx s_2187_0 -> bv
        let s_2187_1: Bits = Bits::new(s_2187_0 as u128, 4u16);
        // C s_2187_2: const #10u : u8
        let s_2187_2: u8 = 10;
        // C s_2187_3: cast zx s_2187_2 -> bv
        let s_2187_3: Bits = Bits::new(s_2187_2 as u128, 4u16);
        // D s_2187_4: cmp-eq s_2187_1 s_2187_3
        let s_2187_4: bool = ((s_2187_1) == (s_2187_3));
        // N s_2187_5: branch s_2187_4 b4511 b2188
        if s_2187_4 {
            return block_4511(state, tracer, fn_state);
        } else {
            return block_2188(state, tracer, fn_state);
        };
    }
    fn block_2188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2188_0: const #0u : u8
        let s_2188_0: bool = false;
        // D s_2188_1: write-var gs#135452 <= s_2188_0
        fn_state.gs_135452 = s_2188_0;
        // N s_2188_2: jump b2189
        return block_2189(state, tracer, fn_state);
    }
    fn block_2189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2189_0: read-var gs#135452:u8
        let s_2189_0: bool = fn_state.gs_135452;
        // N s_2189_1: branch s_2189_0 b4510 b2190
        if s_2189_0 {
            return block_4510(state, tracer, fn_state);
        } else {
            return block_2190(state, tracer, fn_state);
        };
    }
    fn block_2190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2190_0: const #0u : u8
        let s_2190_0: bool = false;
        // D s_2190_1: write-var gs#135453 <= s_2190_0
        fn_state.gs_135453 = s_2190_0;
        // N s_2190_2: jump b2191
        return block_2191(state, tracer, fn_state);
    }
    fn block_2191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2191_0: read-var gs#135453:u8
        let s_2191_0: bool = fn_state.gs_135453;
        // N s_2191_1: branch s_2191_0 b4509 b2192
        if s_2191_0 {
            return block_4509(state, tracer, fn_state);
        } else {
            return block_2192(state, tracer, fn_state);
        };
    }
    fn block_2192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2192_0: const #0u : u8
        let s_2192_0: bool = false;
        // D s_2192_1: write-var gs#135454 <= s_2192_0
        fn_state.gs_135454 = s_2192_0;
        // N s_2192_2: jump b2193
        return block_2193(state, tracer, fn_state);
    }
    fn block_2193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2193_0: read-var gs#135454:u8
        let s_2193_0: bool = fn_state.gs_135454;
        // N s_2193_1: branch s_2193_0 b4508 b2194
        if s_2193_0 {
            return block_4508(state, tracer, fn_state);
        } else {
            return block_2194(state, tracer, fn_state);
        };
    }
    fn block_2194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2194_0: const #0u : u8
        let s_2194_0: bool = false;
        // D s_2194_1: write-var gs#135455 <= s_2194_0
        fn_state.gs_135455 = s_2194_0;
        // N s_2194_2: jump b2195
        return block_2195(state, tracer, fn_state);
    }
    fn block_2195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2195_0: read-var gs#135455:u8
        let s_2195_0: bool = fn_state.gs_135455;
        // N s_2195_1: branch s_2195_0 b4507 b2196
        if s_2195_0 {
            return block_4507(state, tracer, fn_state);
        } else {
            return block_2196(state, tracer, fn_state);
        };
    }
    fn block_2196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2196_0: read-var CRm:u8
        let s_2196_0: u8 = fn_state.CRm;
        // D s_2196_1: cast zx s_2196_0 -> bv
        let s_2196_1: Bits = Bits::new(s_2196_0 as u128, 4u16);
        // C s_2196_2: const #9u : u8
        let s_2196_2: u8 = 9;
        // C s_2196_3: cast zx s_2196_2 -> bv
        let s_2196_3: Bits = Bits::new(s_2196_2 as u128, 4u16);
        // D s_2196_4: cmp-eq s_2196_1 s_2196_3
        let s_2196_4: bool = ((s_2196_1) == (s_2196_3));
        // N s_2196_5: branch s_2196_4 b4506 b2197
        if s_2196_4 {
            return block_4506(state, tracer, fn_state);
        } else {
            return block_2197(state, tracer, fn_state);
        };
    }
    fn block_2197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2197_0: const #0u : u8
        let s_2197_0: bool = false;
        // D s_2197_1: write-var gs#135456 <= s_2197_0
        fn_state.gs_135456 = s_2197_0;
        // N s_2197_2: jump b2198
        return block_2198(state, tracer, fn_state);
    }
    fn block_2198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2198_0: read-var gs#135456:u8
        let s_2198_0: bool = fn_state.gs_135456;
        // N s_2198_1: branch s_2198_0 b4505 b2199
        if s_2198_0 {
            return block_4505(state, tracer, fn_state);
        } else {
            return block_2199(state, tracer, fn_state);
        };
    }
    fn block_2199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2199_0: const #0u : u8
        let s_2199_0: bool = false;
        // D s_2199_1: write-var gs#135457 <= s_2199_0
        fn_state.gs_135457 = s_2199_0;
        // N s_2199_2: jump b2200
        return block_2200(state, tracer, fn_state);
    }
    fn block_2200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2200_0: read-var gs#135457:u8
        let s_2200_0: bool = fn_state.gs_135457;
        // N s_2200_1: branch s_2200_0 b4504 b2201
        if s_2200_0 {
            return block_4504(state, tracer, fn_state);
        } else {
            return block_2201(state, tracer, fn_state);
        };
    }
    fn block_2201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2201_0: const #0u : u8
        let s_2201_0: bool = false;
        // D s_2201_1: write-var gs#135458 <= s_2201_0
        fn_state.gs_135458 = s_2201_0;
        // N s_2201_2: jump b2202
        return block_2202(state, tracer, fn_state);
    }
    fn block_2202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2202_0: read-var gs#135458:u8
        let s_2202_0: bool = fn_state.gs_135458;
        // N s_2202_1: branch s_2202_0 b4503 b2203
        if s_2202_0 {
            return block_4503(state, tracer, fn_state);
        } else {
            return block_2203(state, tracer, fn_state);
        };
    }
    fn block_2203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2203_0: const #0u : u8
        let s_2203_0: bool = false;
        // D s_2203_1: write-var gs#135459 <= s_2203_0
        fn_state.gs_135459 = s_2203_0;
        // N s_2203_2: jump b2204
        return block_2204(state, tracer, fn_state);
    }
    fn block_2204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2204_0: read-var gs#135459:u8
        let s_2204_0: bool = fn_state.gs_135459;
        // N s_2204_1: branch s_2204_0 b4502 b2205
        if s_2204_0 {
            return block_4502(state, tracer, fn_state);
        } else {
            return block_2205(state, tracer, fn_state);
        };
    }
    fn block_2205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2205_0: read-var CRm:u8
        let s_2205_0: u8 = fn_state.CRm;
        // D s_2205_1: cast zx s_2205_0 -> bv
        let s_2205_1: Bits = Bits::new(s_2205_0 as u128, 4u16);
        // C s_2205_2: const #8u : u8
        let s_2205_2: u8 = 8;
        // C s_2205_3: cast zx s_2205_2 -> bv
        let s_2205_3: Bits = Bits::new(s_2205_2 as u128, 4u16);
        // D s_2205_4: cmp-eq s_2205_1 s_2205_3
        let s_2205_4: bool = ((s_2205_1) == (s_2205_3));
        // N s_2205_5: branch s_2205_4 b4501 b2206
        if s_2205_4 {
            return block_4501(state, tracer, fn_state);
        } else {
            return block_2206(state, tracer, fn_state);
        };
    }
    fn block_2206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2206_0: const #0u : u8
        let s_2206_0: bool = false;
        // D s_2206_1: write-var gs#135460 <= s_2206_0
        fn_state.gs_135460 = s_2206_0;
        // N s_2206_2: jump b2207
        return block_2207(state, tracer, fn_state);
    }
    fn block_2207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2207_0: read-var gs#135460:u8
        let s_2207_0: bool = fn_state.gs_135460;
        // N s_2207_1: branch s_2207_0 b4500 b2208
        if s_2207_0 {
            return block_4500(state, tracer, fn_state);
        } else {
            return block_2208(state, tracer, fn_state);
        };
    }
    fn block_2208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2208_0: const #0u : u8
        let s_2208_0: bool = false;
        // D s_2208_1: write-var gs#135461 <= s_2208_0
        fn_state.gs_135461 = s_2208_0;
        // N s_2208_2: jump b2209
        return block_2209(state, tracer, fn_state);
    }
    fn block_2209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2209_0: read-var gs#135461:u8
        let s_2209_0: bool = fn_state.gs_135461;
        // N s_2209_1: branch s_2209_0 b4499 b2210
        if s_2209_0 {
            return block_4499(state, tracer, fn_state);
        } else {
            return block_2210(state, tracer, fn_state);
        };
    }
    fn block_2210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2210_0: const #0u : u8
        let s_2210_0: bool = false;
        // D s_2210_1: write-var gs#135462 <= s_2210_0
        fn_state.gs_135462 = s_2210_0;
        // N s_2210_2: jump b2211
        return block_2211(state, tracer, fn_state);
    }
    fn block_2211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2211_0: read-var gs#135462:u8
        let s_2211_0: bool = fn_state.gs_135462;
        // N s_2211_1: branch s_2211_0 b4498 b2212
        if s_2211_0 {
            return block_4498(state, tracer, fn_state);
        } else {
            return block_2212(state, tracer, fn_state);
        };
    }
    fn block_2212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2212_0: const #0u : u8
        let s_2212_0: bool = false;
        // D s_2212_1: write-var gs#135463 <= s_2212_0
        fn_state.gs_135463 = s_2212_0;
        // N s_2212_2: jump b2213
        return block_2213(state, tracer, fn_state);
    }
    fn block_2213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2213_0: read-var gs#135463:u8
        let s_2213_0: bool = fn_state.gs_135463;
        // N s_2213_1: branch s_2213_0 b4497 b2214
        if s_2213_0 {
            return block_4497(state, tracer, fn_state);
        } else {
            return block_2214(state, tracer, fn_state);
        };
    }
    fn block_2214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2214_0: read-var CRm:u8
        let s_2214_0: u8 = fn_state.CRm;
        // D s_2214_1: cast zx s_2214_0 -> bv
        let s_2214_1: Bits = Bits::new(s_2214_0 as u128, 4u16);
        // C s_2214_2: const #7u : u8
        let s_2214_2: u8 = 7;
        // C s_2214_3: cast zx s_2214_2 -> bv
        let s_2214_3: Bits = Bits::new(s_2214_2 as u128, 4u16);
        // D s_2214_4: cmp-eq s_2214_1 s_2214_3
        let s_2214_4: bool = ((s_2214_1) == (s_2214_3));
        // N s_2214_5: branch s_2214_4 b4496 b2215
        if s_2214_4 {
            return block_4496(state, tracer, fn_state);
        } else {
            return block_2215(state, tracer, fn_state);
        };
    }
    fn block_2215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2215_0: const #0u : u8
        let s_2215_0: bool = false;
        // D s_2215_1: write-var gs#135464 <= s_2215_0
        fn_state.gs_135464 = s_2215_0;
        // N s_2215_2: jump b2216
        return block_2216(state, tracer, fn_state);
    }
    fn block_2216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2216_0: read-var gs#135464:u8
        let s_2216_0: bool = fn_state.gs_135464;
        // N s_2216_1: branch s_2216_0 b4495 b2217
        if s_2216_0 {
            return block_4495(state, tracer, fn_state);
        } else {
            return block_2217(state, tracer, fn_state);
        };
    }
    fn block_2217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2217_0: const #0u : u8
        let s_2217_0: bool = false;
        // D s_2217_1: write-var gs#135465 <= s_2217_0
        fn_state.gs_135465 = s_2217_0;
        // N s_2217_2: jump b2218
        return block_2218(state, tracer, fn_state);
    }
    fn block_2218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2218_0: read-var gs#135465:u8
        let s_2218_0: bool = fn_state.gs_135465;
        // N s_2218_1: branch s_2218_0 b4494 b2219
        if s_2218_0 {
            return block_4494(state, tracer, fn_state);
        } else {
            return block_2219(state, tracer, fn_state);
        };
    }
    fn block_2219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2219_0: const #0u : u8
        let s_2219_0: bool = false;
        // D s_2219_1: write-var gs#135466 <= s_2219_0
        fn_state.gs_135466 = s_2219_0;
        // N s_2219_2: jump b2220
        return block_2220(state, tracer, fn_state);
    }
    fn block_2220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2220_0: read-var gs#135466:u8
        let s_2220_0: bool = fn_state.gs_135466;
        // N s_2220_1: branch s_2220_0 b4493 b2221
        if s_2220_0 {
            return block_4493(state, tracer, fn_state);
        } else {
            return block_2221(state, tracer, fn_state);
        };
    }
    fn block_2221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2221_0: const #0u : u8
        let s_2221_0: bool = false;
        // D s_2221_1: write-var gs#135467 <= s_2221_0
        fn_state.gs_135467 = s_2221_0;
        // N s_2221_2: jump b2222
        return block_2222(state, tracer, fn_state);
    }
    fn block_2222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2222_0: read-var gs#135467:u8
        let s_2222_0: bool = fn_state.gs_135467;
        // N s_2222_1: branch s_2222_0 b4492 b2223
        if s_2222_0 {
            return block_4492(state, tracer, fn_state);
        } else {
            return block_2223(state, tracer, fn_state);
        };
    }
    fn block_2223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2223_0: read-var CRm:u8
        let s_2223_0: u8 = fn_state.CRm;
        // D s_2223_1: cast zx s_2223_0 -> bv
        let s_2223_1: Bits = Bits::new(s_2223_0 as u128, 4u16);
        // C s_2223_2: const #6u : u8
        let s_2223_2: u8 = 6;
        // C s_2223_3: cast zx s_2223_2 -> bv
        let s_2223_3: Bits = Bits::new(s_2223_2 as u128, 4u16);
        // D s_2223_4: cmp-eq s_2223_1 s_2223_3
        let s_2223_4: bool = ((s_2223_1) == (s_2223_3));
        // N s_2223_5: branch s_2223_4 b4491 b2224
        if s_2223_4 {
            return block_4491(state, tracer, fn_state);
        } else {
            return block_2224(state, tracer, fn_state);
        };
    }
    fn block_2224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2224_0: const #0u : u8
        let s_2224_0: bool = false;
        // D s_2224_1: write-var gs#135468 <= s_2224_0
        fn_state.gs_135468 = s_2224_0;
        // N s_2224_2: jump b2225
        return block_2225(state, tracer, fn_state);
    }
    fn block_2225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2225_0: read-var gs#135468:u8
        let s_2225_0: bool = fn_state.gs_135468;
        // N s_2225_1: branch s_2225_0 b4490 b2226
        if s_2225_0 {
            return block_4490(state, tracer, fn_state);
        } else {
            return block_2226(state, tracer, fn_state);
        };
    }
    fn block_2226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2226_0: const #0u : u8
        let s_2226_0: bool = false;
        // D s_2226_1: write-var gs#135469 <= s_2226_0
        fn_state.gs_135469 = s_2226_0;
        // N s_2226_2: jump b2227
        return block_2227(state, tracer, fn_state);
    }
    fn block_2227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2227_0: read-var gs#135469:u8
        let s_2227_0: bool = fn_state.gs_135469;
        // N s_2227_1: branch s_2227_0 b4489 b2228
        if s_2227_0 {
            return block_4489(state, tracer, fn_state);
        } else {
            return block_2228(state, tracer, fn_state);
        };
    }
    fn block_2228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2228_0: const #0u : u8
        let s_2228_0: bool = false;
        // D s_2228_1: write-var gs#135470 <= s_2228_0
        fn_state.gs_135470 = s_2228_0;
        // N s_2228_2: jump b2229
        return block_2229(state, tracer, fn_state);
    }
    fn block_2229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2229_0: read-var gs#135470:u8
        let s_2229_0: bool = fn_state.gs_135470;
        // N s_2229_1: branch s_2229_0 b4488 b2230
        if s_2229_0 {
            return block_4488(state, tracer, fn_state);
        } else {
            return block_2230(state, tracer, fn_state);
        };
    }
    fn block_2230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2230_0: const #0u : u8
        let s_2230_0: bool = false;
        // D s_2230_1: write-var gs#135471 <= s_2230_0
        fn_state.gs_135471 = s_2230_0;
        // N s_2230_2: jump b2231
        return block_2231(state, tracer, fn_state);
    }
    fn block_2231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2231_0: read-var gs#135471:u8
        let s_2231_0: bool = fn_state.gs_135471;
        // N s_2231_1: branch s_2231_0 b4487 b2232
        if s_2231_0 {
            return block_4487(state, tracer, fn_state);
        } else {
            return block_2232(state, tracer, fn_state);
        };
    }
    fn block_2232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2232_0: read-var CRm:u8
        let s_2232_0: u8 = fn_state.CRm;
        // D s_2232_1: cast zx s_2232_0 -> bv
        let s_2232_1: Bits = Bits::new(s_2232_0 as u128, 4u16);
        // C s_2232_2: const #5u : u8
        let s_2232_2: u8 = 5;
        // C s_2232_3: cast zx s_2232_2 -> bv
        let s_2232_3: Bits = Bits::new(s_2232_2 as u128, 4u16);
        // D s_2232_4: cmp-eq s_2232_1 s_2232_3
        let s_2232_4: bool = ((s_2232_1) == (s_2232_3));
        // N s_2232_5: branch s_2232_4 b4486 b2233
        if s_2232_4 {
            return block_4486(state, tracer, fn_state);
        } else {
            return block_2233(state, tracer, fn_state);
        };
    }
    fn block_2233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2233_0: const #0u : u8
        let s_2233_0: bool = false;
        // D s_2233_1: write-var gs#135472 <= s_2233_0
        fn_state.gs_135472 = s_2233_0;
        // N s_2233_2: jump b2234
        return block_2234(state, tracer, fn_state);
    }
    fn block_2234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2234_0: read-var gs#135472:u8
        let s_2234_0: bool = fn_state.gs_135472;
        // N s_2234_1: branch s_2234_0 b4485 b2235
        if s_2234_0 {
            return block_4485(state, tracer, fn_state);
        } else {
            return block_2235(state, tracer, fn_state);
        };
    }
    fn block_2235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2235_0: const #0u : u8
        let s_2235_0: bool = false;
        // D s_2235_1: write-var gs#135473 <= s_2235_0
        fn_state.gs_135473 = s_2235_0;
        // N s_2235_2: jump b2236
        return block_2236(state, tracer, fn_state);
    }
    fn block_2236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2236_0: read-var gs#135473:u8
        let s_2236_0: bool = fn_state.gs_135473;
        // N s_2236_1: branch s_2236_0 b4484 b2237
        if s_2236_0 {
            return block_4484(state, tracer, fn_state);
        } else {
            return block_2237(state, tracer, fn_state);
        };
    }
    fn block_2237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2237_0: const #0u : u8
        let s_2237_0: bool = false;
        // D s_2237_1: write-var gs#135474 <= s_2237_0
        fn_state.gs_135474 = s_2237_0;
        // N s_2237_2: jump b2238
        return block_2238(state, tracer, fn_state);
    }
    fn block_2238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2238_0: read-var gs#135474:u8
        let s_2238_0: bool = fn_state.gs_135474;
        // N s_2238_1: branch s_2238_0 b4483 b2239
        if s_2238_0 {
            return block_4483(state, tracer, fn_state);
        } else {
            return block_2239(state, tracer, fn_state);
        };
    }
    fn block_2239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2239_0: const #0u : u8
        let s_2239_0: bool = false;
        // D s_2239_1: write-var gs#135475 <= s_2239_0
        fn_state.gs_135475 = s_2239_0;
        // N s_2239_2: jump b2240
        return block_2240(state, tracer, fn_state);
    }
    fn block_2240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2240_0: read-var gs#135475:u8
        let s_2240_0: bool = fn_state.gs_135475;
        // N s_2240_1: branch s_2240_0 b4482 b2241
        if s_2240_0 {
            return block_4482(state, tracer, fn_state);
        } else {
            return block_2241(state, tracer, fn_state);
        };
    }
    fn block_2241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2241_0: read-var CRm:u8
        let s_2241_0: u8 = fn_state.CRm;
        // D s_2241_1: cast zx s_2241_0 -> bv
        let s_2241_1: Bits = Bits::new(s_2241_0 as u128, 4u16);
        // C s_2241_2: const #4u : u8
        let s_2241_2: u8 = 4;
        // C s_2241_3: cast zx s_2241_2 -> bv
        let s_2241_3: Bits = Bits::new(s_2241_2 as u128, 4u16);
        // D s_2241_4: cmp-eq s_2241_1 s_2241_3
        let s_2241_4: bool = ((s_2241_1) == (s_2241_3));
        // N s_2241_5: branch s_2241_4 b4481 b2242
        if s_2241_4 {
            return block_4481(state, tracer, fn_state);
        } else {
            return block_2242(state, tracer, fn_state);
        };
    }
    fn block_2242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2242_0: const #0u : u8
        let s_2242_0: bool = false;
        // D s_2242_1: write-var gs#135476 <= s_2242_0
        fn_state.gs_135476 = s_2242_0;
        // N s_2242_2: jump b2243
        return block_2243(state, tracer, fn_state);
    }
    fn block_2243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2243_0: read-var gs#135476:u8
        let s_2243_0: bool = fn_state.gs_135476;
        // N s_2243_1: branch s_2243_0 b4480 b2244
        if s_2243_0 {
            return block_4480(state, tracer, fn_state);
        } else {
            return block_2244(state, tracer, fn_state);
        };
    }
    fn block_2244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2244_0: const #0u : u8
        let s_2244_0: bool = false;
        // D s_2244_1: write-var gs#135477 <= s_2244_0
        fn_state.gs_135477 = s_2244_0;
        // N s_2244_2: jump b2245
        return block_2245(state, tracer, fn_state);
    }
    fn block_2245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2245_0: read-var gs#135477:u8
        let s_2245_0: bool = fn_state.gs_135477;
        // N s_2245_1: branch s_2245_0 b4479 b2246
        if s_2245_0 {
            return block_4479(state, tracer, fn_state);
        } else {
            return block_2246(state, tracer, fn_state);
        };
    }
    fn block_2246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2246_0: const #0u : u8
        let s_2246_0: bool = false;
        // D s_2246_1: write-var gs#135478 <= s_2246_0
        fn_state.gs_135478 = s_2246_0;
        // N s_2246_2: jump b2247
        return block_2247(state, tracer, fn_state);
    }
    fn block_2247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2247_0: read-var gs#135478:u8
        let s_2247_0: bool = fn_state.gs_135478;
        // N s_2247_1: branch s_2247_0 b4478 b2248
        if s_2247_0 {
            return block_4478(state, tracer, fn_state);
        } else {
            return block_2248(state, tracer, fn_state);
        };
    }
    fn block_2248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2248_0: const #0u : u8
        let s_2248_0: bool = false;
        // D s_2248_1: write-var gs#135479 <= s_2248_0
        fn_state.gs_135479 = s_2248_0;
        // N s_2248_2: jump b2249
        return block_2249(state, tracer, fn_state);
    }
    fn block_2249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2249_0: read-var gs#135479:u8
        let s_2249_0: bool = fn_state.gs_135479;
        // N s_2249_1: branch s_2249_0 b4477 b2250
        if s_2249_0 {
            return block_4477(state, tracer, fn_state);
        } else {
            return block_2250(state, tracer, fn_state);
        };
    }
    fn block_2250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2250_0: read-var CRm:u8
        let s_2250_0: u8 = fn_state.CRm;
        // D s_2250_1: cast zx s_2250_0 -> bv
        let s_2250_1: Bits = Bits::new(s_2250_0 as u128, 4u16);
        // C s_2250_2: const #3u : u8
        let s_2250_2: u8 = 3;
        // C s_2250_3: cast zx s_2250_2 -> bv
        let s_2250_3: Bits = Bits::new(s_2250_2 as u128, 4u16);
        // D s_2250_4: cmp-eq s_2250_1 s_2250_3
        let s_2250_4: bool = ((s_2250_1) == (s_2250_3));
        // N s_2250_5: branch s_2250_4 b4476 b2251
        if s_2250_4 {
            return block_4476(state, tracer, fn_state);
        } else {
            return block_2251(state, tracer, fn_state);
        };
    }
    fn block_2251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2251_0: const #0u : u8
        let s_2251_0: bool = false;
        // D s_2251_1: write-var gs#135480 <= s_2251_0
        fn_state.gs_135480 = s_2251_0;
        // N s_2251_2: jump b2252
        return block_2252(state, tracer, fn_state);
    }
    fn block_2252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2252_0: read-var gs#135480:u8
        let s_2252_0: bool = fn_state.gs_135480;
        // N s_2252_1: branch s_2252_0 b4475 b2253
        if s_2252_0 {
            return block_4475(state, tracer, fn_state);
        } else {
            return block_2253(state, tracer, fn_state);
        };
    }
    fn block_2253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2253_0: const #0u : u8
        let s_2253_0: bool = false;
        // D s_2253_1: write-var gs#135481 <= s_2253_0
        fn_state.gs_135481 = s_2253_0;
        // N s_2253_2: jump b2254
        return block_2254(state, tracer, fn_state);
    }
    fn block_2254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2254_0: read-var gs#135481:u8
        let s_2254_0: bool = fn_state.gs_135481;
        // N s_2254_1: branch s_2254_0 b4474 b2255
        if s_2254_0 {
            return block_4474(state, tracer, fn_state);
        } else {
            return block_2255(state, tracer, fn_state);
        };
    }
    fn block_2255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2255_0: const #0u : u8
        let s_2255_0: bool = false;
        // D s_2255_1: write-var gs#135482 <= s_2255_0
        fn_state.gs_135482 = s_2255_0;
        // N s_2255_2: jump b2256
        return block_2256(state, tracer, fn_state);
    }
    fn block_2256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2256_0: read-var gs#135482:u8
        let s_2256_0: bool = fn_state.gs_135482;
        // N s_2256_1: branch s_2256_0 b4473 b2257
        if s_2256_0 {
            return block_4473(state, tracer, fn_state);
        } else {
            return block_2257(state, tracer, fn_state);
        };
    }
    fn block_2257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2257_0: const #0u : u8
        let s_2257_0: bool = false;
        // D s_2257_1: write-var gs#135483 <= s_2257_0
        fn_state.gs_135483 = s_2257_0;
        // N s_2257_2: jump b2258
        return block_2258(state, tracer, fn_state);
    }
    fn block_2258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2258_0: read-var gs#135483:u8
        let s_2258_0: bool = fn_state.gs_135483;
        // N s_2258_1: branch s_2258_0 b4472 b2259
        if s_2258_0 {
            return block_4472(state, tracer, fn_state);
        } else {
            return block_2259(state, tracer, fn_state);
        };
    }
    fn block_2259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2259_0: read-var CRm:u8
        let s_2259_0: u8 = fn_state.CRm;
        // D s_2259_1: cast zx s_2259_0 -> bv
        let s_2259_1: Bits = Bits::new(s_2259_0 as u128, 4u16);
        // C s_2259_2: const #2u : u8
        let s_2259_2: u8 = 2;
        // C s_2259_3: cast zx s_2259_2 -> bv
        let s_2259_3: Bits = Bits::new(s_2259_2 as u128, 4u16);
        // D s_2259_4: cmp-eq s_2259_1 s_2259_3
        let s_2259_4: bool = ((s_2259_1) == (s_2259_3));
        // N s_2259_5: branch s_2259_4 b4471 b2260
        if s_2259_4 {
            return block_4471(state, tracer, fn_state);
        } else {
            return block_2260(state, tracer, fn_state);
        };
    }
    fn block_2260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2260_0: const #0u : u8
        let s_2260_0: bool = false;
        // D s_2260_1: write-var gs#135484 <= s_2260_0
        fn_state.gs_135484 = s_2260_0;
        // N s_2260_2: jump b2261
        return block_2261(state, tracer, fn_state);
    }
    fn block_2261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2261_0: read-var gs#135484:u8
        let s_2261_0: bool = fn_state.gs_135484;
        // N s_2261_1: branch s_2261_0 b4470 b2262
        if s_2261_0 {
            return block_4470(state, tracer, fn_state);
        } else {
            return block_2262(state, tracer, fn_state);
        };
    }
    fn block_2262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2262_0: const #0u : u8
        let s_2262_0: bool = false;
        // D s_2262_1: write-var gs#135485 <= s_2262_0
        fn_state.gs_135485 = s_2262_0;
        // N s_2262_2: jump b2263
        return block_2263(state, tracer, fn_state);
    }
    fn block_2263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2263_0: read-var gs#135485:u8
        let s_2263_0: bool = fn_state.gs_135485;
        // N s_2263_1: branch s_2263_0 b4469 b2264
        if s_2263_0 {
            return block_4469(state, tracer, fn_state);
        } else {
            return block_2264(state, tracer, fn_state);
        };
    }
    fn block_2264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2264_0: const #0u : u8
        let s_2264_0: bool = false;
        // D s_2264_1: write-var gs#135486 <= s_2264_0
        fn_state.gs_135486 = s_2264_0;
        // N s_2264_2: jump b2265
        return block_2265(state, tracer, fn_state);
    }
    fn block_2265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2265_0: read-var gs#135486:u8
        let s_2265_0: bool = fn_state.gs_135486;
        // N s_2265_1: branch s_2265_0 b4468 b2266
        if s_2265_0 {
            return block_4468(state, tracer, fn_state);
        } else {
            return block_2266(state, tracer, fn_state);
        };
    }
    fn block_2266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2266_0: const #0u : u8
        let s_2266_0: bool = false;
        // D s_2266_1: write-var gs#135487 <= s_2266_0
        fn_state.gs_135487 = s_2266_0;
        // N s_2266_2: jump b2267
        return block_2267(state, tracer, fn_state);
    }
    fn block_2267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2267_0: read-var gs#135487:u8
        let s_2267_0: bool = fn_state.gs_135487;
        // N s_2267_1: branch s_2267_0 b4467 b2268
        if s_2267_0 {
            return block_4467(state, tracer, fn_state);
        } else {
            return block_2268(state, tracer, fn_state);
        };
    }
    fn block_2268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2268_0: read-var CRm:u8
        let s_2268_0: u8 = fn_state.CRm;
        // D s_2268_1: cast zx s_2268_0 -> bv
        let s_2268_1: Bits = Bits::new(s_2268_0 as u128, 4u16);
        // C s_2268_2: const #1u : u8
        let s_2268_2: u8 = 1;
        // C s_2268_3: cast zx s_2268_2 -> bv
        let s_2268_3: Bits = Bits::new(s_2268_2 as u128, 4u16);
        // D s_2268_4: cmp-eq s_2268_1 s_2268_3
        let s_2268_4: bool = ((s_2268_1) == (s_2268_3));
        // N s_2268_5: branch s_2268_4 b4466 b2269
        if s_2268_4 {
            return block_4466(state, tracer, fn_state);
        } else {
            return block_2269(state, tracer, fn_state);
        };
    }
    fn block_2269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2269_0: const #0u : u8
        let s_2269_0: bool = false;
        // D s_2269_1: write-var gs#135488 <= s_2269_0
        fn_state.gs_135488 = s_2269_0;
        // N s_2269_2: jump b2270
        return block_2270(state, tracer, fn_state);
    }
    fn block_2270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2270_0: read-var gs#135488:u8
        let s_2270_0: bool = fn_state.gs_135488;
        // N s_2270_1: branch s_2270_0 b4465 b2271
        if s_2270_0 {
            return block_4465(state, tracer, fn_state);
        } else {
            return block_2271(state, tracer, fn_state);
        };
    }
    fn block_2271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2271_0: const #0u : u8
        let s_2271_0: bool = false;
        // D s_2271_1: write-var gs#135489 <= s_2271_0
        fn_state.gs_135489 = s_2271_0;
        // N s_2271_2: jump b2272
        return block_2272(state, tracer, fn_state);
    }
    fn block_2272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2272_0: read-var gs#135489:u8
        let s_2272_0: bool = fn_state.gs_135489;
        // N s_2272_1: branch s_2272_0 b4464 b2273
        if s_2272_0 {
            return block_4464(state, tracer, fn_state);
        } else {
            return block_2273(state, tracer, fn_state);
        };
    }
    fn block_2273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2273_0: const #0u : u8
        let s_2273_0: bool = false;
        // D s_2273_1: write-var gs#135490 <= s_2273_0
        fn_state.gs_135490 = s_2273_0;
        // N s_2273_2: jump b2274
        return block_2274(state, tracer, fn_state);
    }
    fn block_2274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2274_0: read-var gs#135490:u8
        let s_2274_0: bool = fn_state.gs_135490;
        // N s_2274_1: branch s_2274_0 b4463 b2275
        if s_2274_0 {
            return block_4463(state, tracer, fn_state);
        } else {
            return block_2275(state, tracer, fn_state);
        };
    }
    fn block_2275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2275_0: const #0u : u8
        let s_2275_0: bool = false;
        // D s_2275_1: write-var gs#135491 <= s_2275_0
        fn_state.gs_135491 = s_2275_0;
        // N s_2275_2: jump b2276
        return block_2276(state, tracer, fn_state);
    }
    fn block_2276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2276_0: read-var gs#135491:u8
        let s_2276_0: bool = fn_state.gs_135491;
        // N s_2276_1: branch s_2276_0 b4462 b2277
        if s_2276_0 {
            return block_4462(state, tracer, fn_state);
        } else {
            return block_2277(state, tracer, fn_state);
        };
    }
    fn block_2277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2277_0: read-var CRm:u8
        let s_2277_0: u8 = fn_state.CRm;
        // D s_2277_1: cast zx s_2277_0 -> bv
        let s_2277_1: Bits = Bits::new(s_2277_0 as u128, 4u16);
        // C s_2277_2: const #0u : u8
        let s_2277_2: u8 = 0;
        // C s_2277_3: cast zx s_2277_2 -> bv
        let s_2277_3: Bits = Bits::new(s_2277_2 as u128, 4u16);
        // D s_2277_4: cmp-eq s_2277_1 s_2277_3
        let s_2277_4: bool = ((s_2277_1) == (s_2277_3));
        // N s_2277_5: branch s_2277_4 b4461 b2278
        if s_2277_4 {
            return block_4461(state, tracer, fn_state);
        } else {
            return block_2278(state, tracer, fn_state);
        };
    }
    fn block_2278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2278_0: const #0u : u8
        let s_2278_0: bool = false;
        // D s_2278_1: write-var gs#135492 <= s_2278_0
        fn_state.gs_135492 = s_2278_0;
        // N s_2278_2: jump b2279
        return block_2279(state, tracer, fn_state);
    }
    fn block_2279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2279_0: read-var gs#135492:u8
        let s_2279_0: bool = fn_state.gs_135492;
        // N s_2279_1: branch s_2279_0 b4460 b2280
        if s_2279_0 {
            return block_4460(state, tracer, fn_state);
        } else {
            return block_2280(state, tracer, fn_state);
        };
    }
    fn block_2280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2280_0: const #0u : u8
        let s_2280_0: bool = false;
        // D s_2280_1: write-var gs#135493 <= s_2280_0
        fn_state.gs_135493 = s_2280_0;
        // N s_2280_2: jump b2281
        return block_2281(state, tracer, fn_state);
    }
    fn block_2281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2281_0: read-var gs#135493:u8
        let s_2281_0: bool = fn_state.gs_135493;
        // N s_2281_1: branch s_2281_0 b4459 b2282
        if s_2281_0 {
            return block_4459(state, tracer, fn_state);
        } else {
            return block_2282(state, tracer, fn_state);
        };
    }
    fn block_2282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2282_0: const #0u : u8
        let s_2282_0: bool = false;
        // D s_2282_1: write-var gs#135494 <= s_2282_0
        fn_state.gs_135494 = s_2282_0;
        // N s_2282_2: jump b2283
        return block_2283(state, tracer, fn_state);
    }
    fn block_2283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2283_0: read-var gs#135494:u8
        let s_2283_0: bool = fn_state.gs_135494;
        // N s_2283_1: branch s_2283_0 b4458 b2284
        if s_2283_0 {
            return block_4458(state, tracer, fn_state);
        } else {
            return block_2284(state, tracer, fn_state);
        };
    }
    fn block_2284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2284_0: const #0u : u8
        let s_2284_0: bool = false;
        // D s_2284_1: write-var gs#135495 <= s_2284_0
        fn_state.gs_135495 = s_2284_0;
        // N s_2284_2: jump b2285
        return block_2285(state, tracer, fn_state);
    }
    fn block_2285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2285_0: read-var gs#135495:u8
        let s_2285_0: bool = fn_state.gs_135495;
        // N s_2285_1: branch s_2285_0 b4457 b2286
        if s_2285_0 {
            return block_4457(state, tracer, fn_state);
        } else {
            return block_2286(state, tracer, fn_state);
        };
    }
    fn block_2286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2286_0: read-var CRm:u8
        let s_2286_0: u8 = fn_state.CRm;
        // D s_2286_1: cast zx s_2286_0 -> bv
        let s_2286_1: Bits = Bits::new(s_2286_0 as u128, 4u16);
        // C s_2286_2: const #6u : u8
        let s_2286_2: u8 = 6;
        // C s_2286_3: cast zx s_2286_2 -> bv
        let s_2286_3: Bits = Bits::new(s_2286_2 as u128, 4u16);
        // D s_2286_4: cmp-eq s_2286_1 s_2286_3
        let s_2286_4: bool = ((s_2286_1) == (s_2286_3));
        // N s_2286_5: branch s_2286_4 b4456 b2287
        if s_2286_4 {
            return block_4456(state, tracer, fn_state);
        } else {
            return block_2287(state, tracer, fn_state);
        };
    }
    fn block_2287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2287_0: const #0u : u8
        let s_2287_0: bool = false;
        // D s_2287_1: write-var gs#135496 <= s_2287_0
        fn_state.gs_135496 = s_2287_0;
        // N s_2287_2: jump b2288
        return block_2288(state, tracer, fn_state);
    }
    fn block_2288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2288_0: read-var gs#135496:u8
        let s_2288_0: bool = fn_state.gs_135496;
        // N s_2288_1: branch s_2288_0 b4455 b2289
        if s_2288_0 {
            return block_4455(state, tracer, fn_state);
        } else {
            return block_2289(state, tracer, fn_state);
        };
    }
    fn block_2289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2289_0: const #0u : u8
        let s_2289_0: bool = false;
        // D s_2289_1: write-var gs#135497 <= s_2289_0
        fn_state.gs_135497 = s_2289_0;
        // N s_2289_2: jump b2290
        return block_2290(state, tracer, fn_state);
    }
    fn block_2290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2290_0: read-var gs#135497:u8
        let s_2290_0: bool = fn_state.gs_135497;
        // N s_2290_1: branch s_2290_0 b4454 b2291
        if s_2290_0 {
            return block_4454(state, tracer, fn_state);
        } else {
            return block_2291(state, tracer, fn_state);
        };
    }
    fn block_2291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2291_0: const #0u : u8
        let s_2291_0: bool = false;
        // D s_2291_1: write-var gs#135498 <= s_2291_0
        fn_state.gs_135498 = s_2291_0;
        // N s_2291_2: jump b2292
        return block_2292(state, tracer, fn_state);
    }
    fn block_2292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2292_0: read-var gs#135498:u8
        let s_2292_0: bool = fn_state.gs_135498;
        // N s_2292_1: branch s_2292_0 b4453 b2293
        if s_2292_0 {
            return block_4453(state, tracer, fn_state);
        } else {
            return block_2293(state, tracer, fn_state);
        };
    }
    fn block_2293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2293_0: const #0u : u8
        let s_2293_0: bool = false;
        // D s_2293_1: write-var gs#135499 <= s_2293_0
        fn_state.gs_135499 = s_2293_0;
        // N s_2293_2: jump b2294
        return block_2294(state, tracer, fn_state);
    }
    fn block_2294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2294_0: read-var gs#135499:u8
        let s_2294_0: bool = fn_state.gs_135499;
        // N s_2294_1: branch s_2294_0 b4452 b2295
        if s_2294_0 {
            return block_4452(state, tracer, fn_state);
        } else {
            return block_2295(state, tracer, fn_state);
        };
    }
    fn block_2295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2295_0: read-var CRm:u8
        let s_2295_0: u8 = fn_state.CRm;
        // D s_2295_1: cast zx s_2295_0 -> bv
        let s_2295_1: Bits = Bits::new(s_2295_0 as u128, 4u16);
        // C s_2295_2: const #0u : u8
        let s_2295_2: u8 = 0;
        // C s_2295_3: cast zx s_2295_2 -> bv
        let s_2295_3: Bits = Bits::new(s_2295_2 as u128, 4u16);
        // D s_2295_4: cmp-eq s_2295_1 s_2295_3
        let s_2295_4: bool = ((s_2295_1) == (s_2295_3));
        // N s_2295_5: branch s_2295_4 b4451 b2296
        if s_2295_4 {
            return block_4451(state, tracer, fn_state);
        } else {
            return block_2296(state, tracer, fn_state);
        };
    }
    fn block_2296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2296_0: const #0u : u8
        let s_2296_0: bool = false;
        // D s_2296_1: write-var gs#135500 <= s_2296_0
        fn_state.gs_135500 = s_2296_0;
        // N s_2296_2: jump b2297
        return block_2297(state, tracer, fn_state);
    }
    fn block_2297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2297_0: read-var gs#135500:u8
        let s_2297_0: bool = fn_state.gs_135500;
        // N s_2297_1: branch s_2297_0 b4450 b2298
        if s_2297_0 {
            return block_4450(state, tracer, fn_state);
        } else {
            return block_2298(state, tracer, fn_state);
        };
    }
    fn block_2298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2298_0: const #0u : u8
        let s_2298_0: bool = false;
        // D s_2298_1: write-var gs#135501 <= s_2298_0
        fn_state.gs_135501 = s_2298_0;
        // N s_2298_2: jump b2299
        return block_2299(state, tracer, fn_state);
    }
    fn block_2299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2299_0: read-var gs#135501:u8
        let s_2299_0: bool = fn_state.gs_135501;
        // N s_2299_1: branch s_2299_0 b4449 b2300
        if s_2299_0 {
            return block_4449(state, tracer, fn_state);
        } else {
            return block_2300(state, tracer, fn_state);
        };
    }
    fn block_2300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2300_0: const #0u : u8
        let s_2300_0: bool = false;
        // D s_2300_1: write-var gs#135502 <= s_2300_0
        fn_state.gs_135502 = s_2300_0;
        // N s_2300_2: jump b2301
        return block_2301(state, tracer, fn_state);
    }
    fn block_2301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2301_0: read-var gs#135502:u8
        let s_2301_0: bool = fn_state.gs_135502;
        // N s_2301_1: branch s_2301_0 b4448 b2302
        if s_2301_0 {
            return block_4448(state, tracer, fn_state);
        } else {
            return block_2302(state, tracer, fn_state);
        };
    }
    fn block_2302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2302_0: const #0u : u8
        let s_2302_0: bool = false;
        // D s_2302_1: write-var gs#135503 <= s_2302_0
        fn_state.gs_135503 = s_2302_0;
        // N s_2302_2: jump b2303
        return block_2303(state, tracer, fn_state);
    }
    fn block_2303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2303_0: read-var gs#135503:u8
        let s_2303_0: bool = fn_state.gs_135503;
        // N s_2303_1: branch s_2303_0 b4447 b2304
        if s_2303_0 {
            return block_4447(state, tracer, fn_state);
        } else {
            return block_2304(state, tracer, fn_state);
        };
    }
    fn block_2304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2304_0: read-var CRm:u8
        let s_2304_0: u8 = fn_state.CRm;
        // D s_2304_1: cast zx s_2304_0 -> bv
        let s_2304_1: Bits = Bits::new(s_2304_0 as u128, 4u16);
        // C s_2304_2: const #1u : u8
        let s_2304_2: u8 = 1;
        // C s_2304_3: cast zx s_2304_2 -> bv
        let s_2304_3: Bits = Bits::new(s_2304_2 as u128, 4u16);
        // D s_2304_4: cmp-eq s_2304_1 s_2304_3
        let s_2304_4: bool = ((s_2304_1) == (s_2304_3));
        // N s_2304_5: branch s_2304_4 b4446 b2305
        if s_2304_4 {
            return block_4446(state, tracer, fn_state);
        } else {
            return block_2305(state, tracer, fn_state);
        };
    }
    fn block_2305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2305_0: const #0u : u8
        let s_2305_0: bool = false;
        // D s_2305_1: write-var gs#135504 <= s_2305_0
        fn_state.gs_135504 = s_2305_0;
        // N s_2305_2: jump b2306
        return block_2306(state, tracer, fn_state);
    }
    fn block_2306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2306_0: read-var gs#135504:u8
        let s_2306_0: bool = fn_state.gs_135504;
        // N s_2306_1: branch s_2306_0 b4445 b2307
        if s_2306_0 {
            return block_4445(state, tracer, fn_state);
        } else {
            return block_2307(state, tracer, fn_state);
        };
    }
    fn block_2307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2307_0: const #0u : u8
        let s_2307_0: bool = false;
        // D s_2307_1: write-var gs#135505 <= s_2307_0
        fn_state.gs_135505 = s_2307_0;
        // N s_2307_2: jump b2308
        return block_2308(state, tracer, fn_state);
    }
    fn block_2308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2308_0: read-var gs#135505:u8
        let s_2308_0: bool = fn_state.gs_135505;
        // N s_2308_1: branch s_2308_0 b4444 b2309
        if s_2308_0 {
            return block_4444(state, tracer, fn_state);
        } else {
            return block_2309(state, tracer, fn_state);
        };
    }
    fn block_2309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2309_0: const #0u : u8
        let s_2309_0: bool = false;
        // D s_2309_1: write-var gs#135506 <= s_2309_0
        fn_state.gs_135506 = s_2309_0;
        // N s_2309_2: jump b2310
        return block_2310(state, tracer, fn_state);
    }
    fn block_2310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2310_0: read-var gs#135506:u8
        let s_2310_0: bool = fn_state.gs_135506;
        // N s_2310_1: branch s_2310_0 b4443 b2311
        if s_2310_0 {
            return block_4443(state, tracer, fn_state);
        } else {
            return block_2311(state, tracer, fn_state);
        };
    }
    fn block_2311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2311_0: const #0u : u8
        let s_2311_0: bool = false;
        // D s_2311_1: write-var gs#135507 <= s_2311_0
        fn_state.gs_135507 = s_2311_0;
        // N s_2311_2: jump b2312
        return block_2312(state, tracer, fn_state);
    }
    fn block_2312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2312_0: read-var gs#135507:u8
        let s_2312_0: bool = fn_state.gs_135507;
        // N s_2312_1: branch s_2312_0 b4442 b2313
        if s_2312_0 {
            return block_4442(state, tracer, fn_state);
        } else {
            return block_2313(state, tracer, fn_state);
        };
    }
    fn block_2313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2313_0: read-var CRm:u8
        let s_2313_0: u8 = fn_state.CRm;
        // D s_2313_1: cast zx s_2313_0 -> bv
        let s_2313_1: Bits = Bits::new(s_2313_0 as u128, 4u16);
        // C s_2313_2: const #12u : u8
        let s_2313_2: u8 = 12;
        // C s_2313_3: cast zx s_2313_2 -> bv
        let s_2313_3: Bits = Bits::new(s_2313_2 as u128, 4u16);
        // D s_2313_4: cmp-eq s_2313_1 s_2313_3
        let s_2313_4: bool = ((s_2313_1) == (s_2313_3));
        // N s_2313_5: branch s_2313_4 b4441 b2314
        if s_2313_4 {
            return block_4441(state, tracer, fn_state);
        } else {
            return block_2314(state, tracer, fn_state);
        };
    }
    fn block_2314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2314_0: const #0u : u8
        let s_2314_0: bool = false;
        // D s_2314_1: write-var gs#135508 <= s_2314_0
        fn_state.gs_135508 = s_2314_0;
        // N s_2314_2: jump b2315
        return block_2315(state, tracer, fn_state);
    }
    fn block_2315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2315_0: read-var gs#135508:u8
        let s_2315_0: bool = fn_state.gs_135508;
        // N s_2315_1: branch s_2315_0 b4440 b2316
        if s_2315_0 {
            return block_4440(state, tracer, fn_state);
        } else {
            return block_2316(state, tracer, fn_state);
        };
    }
    fn block_2316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2316_0: const #0u : u8
        let s_2316_0: bool = false;
        // D s_2316_1: write-var gs#135509 <= s_2316_0
        fn_state.gs_135509 = s_2316_0;
        // N s_2316_2: jump b2317
        return block_2317(state, tracer, fn_state);
    }
    fn block_2317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2317_0: read-var gs#135509:u8
        let s_2317_0: bool = fn_state.gs_135509;
        // N s_2317_1: branch s_2317_0 b4439 b2318
        if s_2317_0 {
            return block_4439(state, tracer, fn_state);
        } else {
            return block_2318(state, tracer, fn_state);
        };
    }
    fn block_2318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2318_0: const #0u : u8
        let s_2318_0: bool = false;
        // D s_2318_1: write-var gs#135510 <= s_2318_0
        fn_state.gs_135510 = s_2318_0;
        // N s_2318_2: jump b2319
        return block_2319(state, tracer, fn_state);
    }
    fn block_2319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2319_0: read-var gs#135510:u8
        let s_2319_0: bool = fn_state.gs_135510;
        // N s_2319_1: branch s_2319_0 b4438 b2320
        if s_2319_0 {
            return block_4438(state, tracer, fn_state);
        } else {
            return block_2320(state, tracer, fn_state);
        };
    }
    fn block_2320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2320_0: const #0u : u8
        let s_2320_0: bool = false;
        // D s_2320_1: write-var gs#135511 <= s_2320_0
        fn_state.gs_135511 = s_2320_0;
        // N s_2320_2: jump b2321
        return block_2321(state, tracer, fn_state);
    }
    fn block_2321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2321_0: read-var gs#135511:u8
        let s_2321_0: bool = fn_state.gs_135511;
        // N s_2321_1: branch s_2321_0 b4437 b2322
        if s_2321_0 {
            return block_4437(state, tracer, fn_state);
        } else {
            return block_2322(state, tracer, fn_state);
        };
    }
    fn block_2322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2322_0: read-var CRm:u8
        let s_2322_0: u8 = fn_state.CRm;
        // D s_2322_1: cast zx s_2322_0 -> bv
        let s_2322_1: Bits = Bits::new(s_2322_0 as u128, 4u16);
        // C s_2322_2: const #0u : u8
        let s_2322_2: u8 = 0;
        // C s_2322_3: cast zx s_2322_2 -> bv
        let s_2322_3: Bits = Bits::new(s_2322_2 as u128, 4u16);
        // D s_2322_4: cmp-eq s_2322_1 s_2322_3
        let s_2322_4: bool = ((s_2322_1) == (s_2322_3));
        // N s_2322_5: branch s_2322_4 b4436 b2323
        if s_2322_4 {
            return block_4436(state, tracer, fn_state);
        } else {
            return block_2323(state, tracer, fn_state);
        };
    }
    fn block_2323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2323_0: const #0u : u8
        let s_2323_0: bool = false;
        // D s_2323_1: write-var gs#135512 <= s_2323_0
        fn_state.gs_135512 = s_2323_0;
        // N s_2323_2: jump b2324
        return block_2324(state, tracer, fn_state);
    }
    fn block_2324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2324_0: read-var gs#135512:u8
        let s_2324_0: bool = fn_state.gs_135512;
        // N s_2324_1: branch s_2324_0 b4435 b2325
        if s_2324_0 {
            return block_4435(state, tracer, fn_state);
        } else {
            return block_2325(state, tracer, fn_state);
        };
    }
    fn block_2325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2325_0: const #0u : u8
        let s_2325_0: bool = false;
        // D s_2325_1: write-var gs#135513 <= s_2325_0
        fn_state.gs_135513 = s_2325_0;
        // N s_2325_2: jump b2326
        return block_2326(state, tracer, fn_state);
    }
    fn block_2326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2326_0: read-var gs#135513:u8
        let s_2326_0: bool = fn_state.gs_135513;
        // N s_2326_1: branch s_2326_0 b4434 b2327
        if s_2326_0 {
            return block_4434(state, tracer, fn_state);
        } else {
            return block_2327(state, tracer, fn_state);
        };
    }
    fn block_2327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2327_0: const #0u : u8
        let s_2327_0: bool = false;
        // D s_2327_1: write-var gs#135514 <= s_2327_0
        fn_state.gs_135514 = s_2327_0;
        // N s_2327_2: jump b2328
        return block_2328(state, tracer, fn_state);
    }
    fn block_2328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2328_0: read-var gs#135514:u8
        let s_2328_0: bool = fn_state.gs_135514;
        // N s_2328_1: branch s_2328_0 b4433 b2329
        if s_2328_0 {
            return block_4433(state, tracer, fn_state);
        } else {
            return block_2329(state, tracer, fn_state);
        };
    }
    fn block_2329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2329_0: const #0u : u8
        let s_2329_0: bool = false;
        // D s_2329_1: write-var gs#135515 <= s_2329_0
        fn_state.gs_135515 = s_2329_0;
        // N s_2329_2: jump b2330
        return block_2330(state, tracer, fn_state);
    }
    fn block_2330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2330_0: read-var gs#135515:u8
        let s_2330_0: bool = fn_state.gs_135515;
        // N s_2330_1: branch s_2330_0 b4432 b2331
        if s_2330_0 {
            return block_4432(state, tracer, fn_state);
        } else {
            return block_2331(state, tracer, fn_state);
        };
    }
    fn block_2331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2331_0: read-var CRm:u8
        let s_2331_0: u8 = fn_state.CRm;
        // D s_2331_1: cast zx s_2331_0 -> bv
        let s_2331_1: Bits = Bits::new(s_2331_0 as u128, 4u16);
        // C s_2331_2: const #14u : u8
        let s_2331_2: u8 = 14;
        // C s_2331_3: cast zx s_2331_2 -> bv
        let s_2331_3: Bits = Bits::new(s_2331_2 as u128, 4u16);
        // D s_2331_4: cmp-eq s_2331_1 s_2331_3
        let s_2331_4: bool = ((s_2331_1) == (s_2331_3));
        // N s_2331_5: branch s_2331_4 b4431 b2332
        if s_2331_4 {
            return block_4431(state, tracer, fn_state);
        } else {
            return block_2332(state, tracer, fn_state);
        };
    }
    fn block_2332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2332_0: const #0u : u8
        let s_2332_0: bool = false;
        // D s_2332_1: write-var gs#135516 <= s_2332_0
        fn_state.gs_135516 = s_2332_0;
        // N s_2332_2: jump b2333
        return block_2333(state, tracer, fn_state);
    }
    fn block_2333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2333_0: read-var gs#135516:u8
        let s_2333_0: bool = fn_state.gs_135516;
        // N s_2333_1: branch s_2333_0 b4430 b2334
        if s_2333_0 {
            return block_4430(state, tracer, fn_state);
        } else {
            return block_2334(state, tracer, fn_state);
        };
    }
    fn block_2334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2334_0: const #0u : u8
        let s_2334_0: bool = false;
        // D s_2334_1: write-var gs#135517 <= s_2334_0
        fn_state.gs_135517 = s_2334_0;
        // N s_2334_2: jump b2335
        return block_2335(state, tracer, fn_state);
    }
    fn block_2335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2335_0: read-var gs#135517:u8
        let s_2335_0: bool = fn_state.gs_135517;
        // N s_2335_1: branch s_2335_0 b4429 b2336
        if s_2335_0 {
            return block_4429(state, tracer, fn_state);
        } else {
            return block_2336(state, tracer, fn_state);
        };
    }
    fn block_2336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2336_0: const #0u : u8
        let s_2336_0: bool = false;
        // D s_2336_1: write-var gs#135518 <= s_2336_0
        fn_state.gs_135518 = s_2336_0;
        // N s_2336_2: jump b2337
        return block_2337(state, tracer, fn_state);
    }
    fn block_2337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2337_0: read-var gs#135518:u8
        let s_2337_0: bool = fn_state.gs_135518;
        // N s_2337_1: branch s_2337_0 b4428 b2338
        if s_2337_0 {
            return block_4428(state, tracer, fn_state);
        } else {
            return block_2338(state, tracer, fn_state);
        };
    }
    fn block_2338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2338_0: const #0u : u8
        let s_2338_0: bool = false;
        // D s_2338_1: write-var gs#135519 <= s_2338_0
        fn_state.gs_135519 = s_2338_0;
        // N s_2338_2: jump b2339
        return block_2339(state, tracer, fn_state);
    }
    fn block_2339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2339_0: read-var gs#135519:u8
        let s_2339_0: bool = fn_state.gs_135519;
        // N s_2339_1: branch s_2339_0 b4427 b2340
        if s_2339_0 {
            return block_4427(state, tracer, fn_state);
        } else {
            return block_2340(state, tracer, fn_state);
        };
    }
    fn block_2340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2340_0: read-var CRm:u8
        let s_2340_0: u8 = fn_state.CRm;
        // D s_2340_1: cast zx s_2340_0 -> bv
        let s_2340_1: Bits = Bits::new(s_2340_0 as u128, 4u16);
        // C s_2340_2: const #0u : u8
        let s_2340_2: u8 = 0;
        // C s_2340_3: cast zx s_2340_2 -> bv
        let s_2340_3: Bits = Bits::new(s_2340_2 as u128, 4u16);
        // D s_2340_4: cmp-eq s_2340_1 s_2340_3
        let s_2340_4: bool = ((s_2340_1) == (s_2340_3));
        // N s_2340_5: branch s_2340_4 b4426 b2341
        if s_2340_4 {
            return block_4426(state, tracer, fn_state);
        } else {
            return block_2341(state, tracer, fn_state);
        };
    }
    fn block_2341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2341_0: const #0u : u8
        let s_2341_0: bool = false;
        // D s_2341_1: write-var gs#135520 <= s_2341_0
        fn_state.gs_135520 = s_2341_0;
        // N s_2341_2: jump b2342
        return block_2342(state, tracer, fn_state);
    }
    fn block_2342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2342_0: read-var gs#135520:u8
        let s_2342_0: bool = fn_state.gs_135520;
        // N s_2342_1: branch s_2342_0 b4425 b2343
        if s_2342_0 {
            return block_4425(state, tracer, fn_state);
        } else {
            return block_2343(state, tracer, fn_state);
        };
    }
    fn block_2343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2343_0: const #0u : u8
        let s_2343_0: bool = false;
        // D s_2343_1: write-var gs#135521 <= s_2343_0
        fn_state.gs_135521 = s_2343_0;
        // N s_2343_2: jump b2344
        return block_2344(state, tracer, fn_state);
    }
    fn block_2344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2344_0: read-var gs#135521:u8
        let s_2344_0: bool = fn_state.gs_135521;
        // N s_2344_1: branch s_2344_0 b4424 b2345
        if s_2344_0 {
            return block_4424(state, tracer, fn_state);
        } else {
            return block_2345(state, tracer, fn_state);
        };
    }
    fn block_2345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2345_0: const #0u : u8
        let s_2345_0: bool = false;
        // D s_2345_1: write-var gs#135522 <= s_2345_0
        fn_state.gs_135522 = s_2345_0;
        // N s_2345_2: jump b2346
        return block_2346(state, tracer, fn_state);
    }
    fn block_2346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2346_0: read-var gs#135522:u8
        let s_2346_0: bool = fn_state.gs_135522;
        // N s_2346_1: branch s_2346_0 b4423 b2347
        if s_2346_0 {
            return block_4423(state, tracer, fn_state);
        } else {
            return block_2347(state, tracer, fn_state);
        };
    }
    fn block_2347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2347_0: const #0u : u8
        let s_2347_0: bool = false;
        // D s_2347_1: write-var gs#135523 <= s_2347_0
        fn_state.gs_135523 = s_2347_0;
        // N s_2347_2: jump b2348
        return block_2348(state, tracer, fn_state);
    }
    fn block_2348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2348_0: read-var gs#135523:u8
        let s_2348_0: bool = fn_state.gs_135523;
        // N s_2348_1: branch s_2348_0 b4422 b2349
        if s_2348_0 {
            return block_4422(state, tracer, fn_state);
        } else {
            return block_2349(state, tracer, fn_state);
        };
    }
    fn block_2349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2349_0: read-var CRm:u8
        let s_2349_0: u8 = fn_state.CRm;
        // D s_2349_1: cast zx s_2349_0 -> bv
        let s_2349_1: Bits = Bits::new(s_2349_0 as u128, 4u16);
        // C s_2349_2: const #8u : u8
        let s_2349_2: u8 = 8;
        // C s_2349_3: cast zx s_2349_2 -> bv
        let s_2349_3: Bits = Bits::new(s_2349_2 as u128, 4u16);
        // D s_2349_4: cmp-eq s_2349_1 s_2349_3
        let s_2349_4: bool = ((s_2349_1) == (s_2349_3));
        // N s_2349_5: branch s_2349_4 b4421 b2350
        if s_2349_4 {
            return block_4421(state, tracer, fn_state);
        } else {
            return block_2350(state, tracer, fn_state);
        };
    }
    fn block_2350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2350_0: const #0u : u8
        let s_2350_0: bool = false;
        // D s_2350_1: write-var gs#135524 <= s_2350_0
        fn_state.gs_135524 = s_2350_0;
        // N s_2350_2: jump b2351
        return block_2351(state, tracer, fn_state);
    }
    fn block_2351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2351_0: read-var gs#135524:u8
        let s_2351_0: bool = fn_state.gs_135524;
        // N s_2351_1: branch s_2351_0 b4420 b2352
        if s_2351_0 {
            return block_4420(state, tracer, fn_state);
        } else {
            return block_2352(state, tracer, fn_state);
        };
    }
    fn block_2352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2352_0: const #0u : u8
        let s_2352_0: bool = false;
        // D s_2352_1: write-var gs#135525 <= s_2352_0
        fn_state.gs_135525 = s_2352_0;
        // N s_2352_2: jump b2353
        return block_2353(state, tracer, fn_state);
    }
    fn block_2353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2353_0: read-var gs#135525:u8
        let s_2353_0: bool = fn_state.gs_135525;
        // N s_2353_1: branch s_2353_0 b4419 b2354
        if s_2353_0 {
            return block_4419(state, tracer, fn_state);
        } else {
            return block_2354(state, tracer, fn_state);
        };
    }
    fn block_2354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2354_0: const #0u : u8
        let s_2354_0: bool = false;
        // D s_2354_1: write-var gs#135526 <= s_2354_0
        fn_state.gs_135526 = s_2354_0;
        // N s_2354_2: jump b2355
        return block_2355(state, tracer, fn_state);
    }
    fn block_2355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2355_0: read-var gs#135526:u8
        let s_2355_0: bool = fn_state.gs_135526;
        // N s_2355_1: branch s_2355_0 b4418 b2356
        if s_2355_0 {
            return block_4418(state, tracer, fn_state);
        } else {
            return block_2356(state, tracer, fn_state);
        };
    }
    fn block_2356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2356_0: const #0u : u8
        let s_2356_0: bool = false;
        // D s_2356_1: write-var gs#135527 <= s_2356_0
        fn_state.gs_135527 = s_2356_0;
        // N s_2356_2: jump b2357
        return block_2357(state, tracer, fn_state);
    }
    fn block_2357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2357_0: read-var gs#135527:u8
        let s_2357_0: bool = fn_state.gs_135527;
        // N s_2357_1: branch s_2357_0 b4417 b2358
        if s_2357_0 {
            return block_4417(state, tracer, fn_state);
        } else {
            return block_2358(state, tracer, fn_state);
        };
    }
    fn block_2358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2358_0: read-var CRm:u8
        let s_2358_0: u8 = fn_state.CRm;
        // D s_2358_1: cast zx s_2358_0 -> bv
        let s_2358_1: Bits = Bits::new(s_2358_0 as u128, 4u16);
        // C s_2358_2: const #6u : u8
        let s_2358_2: u8 = 6;
        // C s_2358_3: cast zx s_2358_2 -> bv
        let s_2358_3: Bits = Bits::new(s_2358_2 as u128, 4u16);
        // D s_2358_4: cmp-eq s_2358_1 s_2358_3
        let s_2358_4: bool = ((s_2358_1) == (s_2358_3));
        // N s_2358_5: branch s_2358_4 b4416 b2359
        if s_2358_4 {
            return block_4416(state, tracer, fn_state);
        } else {
            return block_2359(state, tracer, fn_state);
        };
    }
    fn block_2359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2359_0: const #0u : u8
        let s_2359_0: bool = false;
        // D s_2359_1: write-var gs#135528 <= s_2359_0
        fn_state.gs_135528 = s_2359_0;
        // N s_2359_2: jump b2360
        return block_2360(state, tracer, fn_state);
    }
    fn block_2360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2360_0: read-var gs#135528:u8
        let s_2360_0: bool = fn_state.gs_135528;
        // N s_2360_1: branch s_2360_0 b4415 b2361
        if s_2360_0 {
            return block_4415(state, tracer, fn_state);
        } else {
            return block_2361(state, tracer, fn_state);
        };
    }
    fn block_2361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2361_0: const #0u : u8
        let s_2361_0: bool = false;
        // D s_2361_1: write-var gs#135529 <= s_2361_0
        fn_state.gs_135529 = s_2361_0;
        // N s_2361_2: jump b2362
        return block_2362(state, tracer, fn_state);
    }
    fn block_2362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2362_0: read-var gs#135529:u8
        let s_2362_0: bool = fn_state.gs_135529;
        // N s_2362_1: branch s_2362_0 b4414 b2363
        if s_2362_0 {
            return block_4414(state, tracer, fn_state);
        } else {
            return block_2363(state, tracer, fn_state);
        };
    }
    fn block_2363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2363_0: const #0u : u8
        let s_2363_0: bool = false;
        // D s_2363_1: write-var gs#135530 <= s_2363_0
        fn_state.gs_135530 = s_2363_0;
        // N s_2363_2: jump b2364
        return block_2364(state, tracer, fn_state);
    }
    fn block_2364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2364_0: read-var gs#135530:u8
        let s_2364_0: bool = fn_state.gs_135530;
        // N s_2364_1: branch s_2364_0 b4413 b2365
        if s_2364_0 {
            return block_4413(state, tracer, fn_state);
        } else {
            return block_2365(state, tracer, fn_state);
        };
    }
    fn block_2365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2365_0: const #0u : u8
        let s_2365_0: bool = false;
        // D s_2365_1: write-var gs#135531 <= s_2365_0
        fn_state.gs_135531 = s_2365_0;
        // N s_2365_2: jump b2366
        return block_2366(state, tracer, fn_state);
    }
    fn block_2366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2366_0: read-var gs#135531:u8
        let s_2366_0: bool = fn_state.gs_135531;
        // N s_2366_1: branch s_2366_0 b4412 b2367
        if s_2366_0 {
            return block_4412(state, tracer, fn_state);
        } else {
            return block_2367(state, tracer, fn_state);
        };
    }
    fn block_2367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2367_0: read-var CRm:u8
        let s_2367_0: u8 = fn_state.CRm;
        // D s_2367_1: cast zx s_2367_0 -> bv
        let s_2367_1: Bits = Bits::new(s_2367_0 as u128, 4u16);
        // C s_2367_2: const #0u : u8
        let s_2367_2: u8 = 0;
        // C s_2367_3: cast zx s_2367_2 -> bv
        let s_2367_3: Bits = Bits::new(s_2367_2 as u128, 4u16);
        // D s_2367_4: cmp-eq s_2367_1 s_2367_3
        let s_2367_4: bool = ((s_2367_1) == (s_2367_3));
        // N s_2367_5: branch s_2367_4 b4411 b2368
        if s_2367_4 {
            return block_4411(state, tracer, fn_state);
        } else {
            return block_2368(state, tracer, fn_state);
        };
    }
    fn block_2368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2368_0: const #0u : u8
        let s_2368_0: bool = false;
        // D s_2368_1: write-var gs#135532 <= s_2368_0
        fn_state.gs_135532 = s_2368_0;
        // N s_2368_2: jump b2369
        return block_2369(state, tracer, fn_state);
    }
    fn block_2369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2369_0: read-var gs#135532:u8
        let s_2369_0: bool = fn_state.gs_135532;
        // N s_2369_1: branch s_2369_0 b4410 b2370
        if s_2369_0 {
            return block_4410(state, tracer, fn_state);
        } else {
            return block_2370(state, tracer, fn_state);
        };
    }
    fn block_2370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2370_0: const #0u : u8
        let s_2370_0: bool = false;
        // D s_2370_1: write-var gs#135533 <= s_2370_0
        fn_state.gs_135533 = s_2370_0;
        // N s_2370_2: jump b2371
        return block_2371(state, tracer, fn_state);
    }
    fn block_2371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2371_0: read-var gs#135533:u8
        let s_2371_0: bool = fn_state.gs_135533;
        // N s_2371_1: branch s_2371_0 b4409 b2372
        if s_2371_0 {
            return block_4409(state, tracer, fn_state);
        } else {
            return block_2372(state, tracer, fn_state);
        };
    }
    fn block_2372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2372_0: const #0u : u8
        let s_2372_0: bool = false;
        // D s_2372_1: write-var gs#135534 <= s_2372_0
        fn_state.gs_135534 = s_2372_0;
        // N s_2372_2: jump b2373
        return block_2373(state, tracer, fn_state);
    }
    fn block_2373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2373_0: read-var gs#135534:u8
        let s_2373_0: bool = fn_state.gs_135534;
        // N s_2373_1: branch s_2373_0 b4408 b2374
        if s_2373_0 {
            return block_4408(state, tracer, fn_state);
        } else {
            return block_2374(state, tracer, fn_state);
        };
    }
    fn block_2374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2374_0: const #0u : u8
        let s_2374_0: bool = false;
        // D s_2374_1: write-var gs#135535 <= s_2374_0
        fn_state.gs_135535 = s_2374_0;
        // N s_2374_2: jump b2375
        return block_2375(state, tracer, fn_state);
    }
    fn block_2375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2375_0: read-var gs#135535:u8
        let s_2375_0: bool = fn_state.gs_135535;
        // N s_2375_1: branch s_2375_0 b4407 b2376
        if s_2375_0 {
            return block_4407(state, tracer, fn_state);
        } else {
            return block_2376(state, tracer, fn_state);
        };
    }
    fn block_2376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2376_0: read-var CRm:u8
        let s_2376_0: u8 = fn_state.CRm;
        // D s_2376_1: cast zx s_2376_0 -> bv
        let s_2376_1: Bits = Bits::new(s_2376_0 as u128, 4u16);
        // C s_2376_2: const #0u : u8
        let s_2376_2: u8 = 0;
        // C s_2376_3: cast zx s_2376_2 -> bv
        let s_2376_3: Bits = Bits::new(s_2376_2 as u128, 4u16);
        // D s_2376_4: cmp-eq s_2376_1 s_2376_3
        let s_2376_4: bool = ((s_2376_1) == (s_2376_3));
        // N s_2376_5: branch s_2376_4 b4406 b2377
        if s_2376_4 {
            return block_4406(state, tracer, fn_state);
        } else {
            return block_2377(state, tracer, fn_state);
        };
    }
    fn block_2377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2377_0: const #0u : u8
        let s_2377_0: bool = false;
        // D s_2377_1: write-var gs#135536 <= s_2377_0
        fn_state.gs_135536 = s_2377_0;
        // N s_2377_2: jump b2378
        return block_2378(state, tracer, fn_state);
    }
    fn block_2378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2378_0: read-var gs#135536:u8
        let s_2378_0: bool = fn_state.gs_135536;
        // N s_2378_1: branch s_2378_0 b4405 b2379
        if s_2378_0 {
            return block_4405(state, tracer, fn_state);
        } else {
            return block_2379(state, tracer, fn_state);
        };
    }
    fn block_2379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2379_0: const #0u : u8
        let s_2379_0: bool = false;
        // D s_2379_1: write-var gs#135537 <= s_2379_0
        fn_state.gs_135537 = s_2379_0;
        // N s_2379_2: jump b2380
        return block_2380(state, tracer, fn_state);
    }
    fn block_2380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2380_0: read-var gs#135537:u8
        let s_2380_0: bool = fn_state.gs_135537;
        // N s_2380_1: branch s_2380_0 b4404 b2381
        if s_2380_0 {
            return block_4404(state, tracer, fn_state);
        } else {
            return block_2381(state, tracer, fn_state);
        };
    }
    fn block_2381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2381_0: const #0u : u8
        let s_2381_0: bool = false;
        // D s_2381_1: write-var gs#135538 <= s_2381_0
        fn_state.gs_135538 = s_2381_0;
        // N s_2381_2: jump b2382
        return block_2382(state, tracer, fn_state);
    }
    fn block_2382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2382_0: read-var gs#135538:u8
        let s_2382_0: bool = fn_state.gs_135538;
        // N s_2382_1: branch s_2382_0 b4403 b2383
        if s_2382_0 {
            return block_4403(state, tracer, fn_state);
        } else {
            return block_2383(state, tracer, fn_state);
        };
    }
    fn block_2383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2383_0: const #0u : u8
        let s_2383_0: bool = false;
        // D s_2383_1: write-var gs#135539 <= s_2383_0
        fn_state.gs_135539 = s_2383_0;
        // N s_2383_2: jump b2384
        return block_2384(state, tracer, fn_state);
    }
    fn block_2384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2384_0: read-var gs#135539:u8
        let s_2384_0: bool = fn_state.gs_135539;
        // N s_2384_1: branch s_2384_0 b4402 b2385
        if s_2384_0 {
            return block_4402(state, tracer, fn_state);
        } else {
            return block_2385(state, tracer, fn_state);
        };
    }
    fn block_2385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2385_0: read-var CRm:u8
        let s_2385_0: u8 = fn_state.CRm;
        // D s_2385_1: cast zx s_2385_0 -> bv
        let s_2385_1: Bits = Bits::new(s_2385_0 as u128, 4u16);
        // C s_2385_2: const #0u : u8
        let s_2385_2: u8 = 0;
        // C s_2385_3: cast zx s_2385_2 -> bv
        let s_2385_3: Bits = Bits::new(s_2385_2 as u128, 4u16);
        // D s_2385_4: cmp-eq s_2385_1 s_2385_3
        let s_2385_4: bool = ((s_2385_1) == (s_2385_3));
        // N s_2385_5: branch s_2385_4 b4401 b2386
        if s_2385_4 {
            return block_4401(state, tracer, fn_state);
        } else {
            return block_2386(state, tracer, fn_state);
        };
    }
    fn block_2386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2386_0: const #0u : u8
        let s_2386_0: bool = false;
        // D s_2386_1: write-var gs#135540 <= s_2386_0
        fn_state.gs_135540 = s_2386_0;
        // N s_2386_2: jump b2387
        return block_2387(state, tracer, fn_state);
    }
    fn block_2387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2387_0: read-var gs#135540:u8
        let s_2387_0: bool = fn_state.gs_135540;
        // N s_2387_1: branch s_2387_0 b4400 b2388
        if s_2387_0 {
            return block_4400(state, tracer, fn_state);
        } else {
            return block_2388(state, tracer, fn_state);
        };
    }
    fn block_2388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2388_0: const #0u : u8
        let s_2388_0: bool = false;
        // D s_2388_1: write-var gs#135541 <= s_2388_0
        fn_state.gs_135541 = s_2388_0;
        // N s_2388_2: jump b2389
        return block_2389(state, tracer, fn_state);
    }
    fn block_2389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2389_0: read-var gs#135541:u8
        let s_2389_0: bool = fn_state.gs_135541;
        // N s_2389_1: branch s_2389_0 b4399 b2390
        if s_2389_0 {
            return block_4399(state, tracer, fn_state);
        } else {
            return block_2390(state, tracer, fn_state);
        };
    }
    fn block_2390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2390_0: const #0u : u8
        let s_2390_0: bool = false;
        // D s_2390_1: write-var gs#135542 <= s_2390_0
        fn_state.gs_135542 = s_2390_0;
        // N s_2390_2: jump b2391
        return block_2391(state, tracer, fn_state);
    }
    fn block_2391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2391_0: read-var gs#135542:u8
        let s_2391_0: bool = fn_state.gs_135542;
        // N s_2391_1: branch s_2391_0 b4398 b2392
        if s_2391_0 {
            return block_4398(state, tracer, fn_state);
        } else {
            return block_2392(state, tracer, fn_state);
        };
    }
    fn block_2392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2392_0: const #0u : u8
        let s_2392_0: bool = false;
        // D s_2392_1: write-var gs#135543 <= s_2392_0
        fn_state.gs_135543 = s_2392_0;
        // N s_2392_2: jump b2393
        return block_2393(state, tracer, fn_state);
    }
    fn block_2393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2393_0: read-var gs#135543:u8
        let s_2393_0: bool = fn_state.gs_135543;
        // N s_2393_1: branch s_2393_0 b4397 b2394
        if s_2393_0 {
            return block_4397(state, tracer, fn_state);
        } else {
            return block_2394(state, tracer, fn_state);
        };
    }
    fn block_2394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2394_0: read-var CRm:u8
        let s_2394_0: u8 = fn_state.CRm;
        // D s_2394_1: cast zx s_2394_0 -> bv
        let s_2394_1: Bits = Bits::new(s_2394_0 as u128, 4u16);
        // C s_2394_2: const #6u : u8
        let s_2394_2: u8 = 6;
        // C s_2394_3: cast zx s_2394_2 -> bv
        let s_2394_3: Bits = Bits::new(s_2394_2 as u128, 4u16);
        // D s_2394_4: cmp-eq s_2394_1 s_2394_3
        let s_2394_4: bool = ((s_2394_1) == (s_2394_3));
        // N s_2394_5: branch s_2394_4 b4396 b2395
        if s_2394_4 {
            return block_4396(state, tracer, fn_state);
        } else {
            return block_2395(state, tracer, fn_state);
        };
    }
    fn block_2395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2395_0: const #0u : u8
        let s_2395_0: bool = false;
        // D s_2395_1: write-var gs#135544 <= s_2395_0
        fn_state.gs_135544 = s_2395_0;
        // N s_2395_2: jump b2396
        return block_2396(state, tracer, fn_state);
    }
    fn block_2396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2396_0: read-var gs#135544:u8
        let s_2396_0: bool = fn_state.gs_135544;
        // N s_2396_1: branch s_2396_0 b4395 b2397
        if s_2396_0 {
            return block_4395(state, tracer, fn_state);
        } else {
            return block_2397(state, tracer, fn_state);
        };
    }
    fn block_2397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2397_0: const #0u : u8
        let s_2397_0: bool = false;
        // D s_2397_1: write-var gs#135545 <= s_2397_0
        fn_state.gs_135545 = s_2397_0;
        // N s_2397_2: jump b2398
        return block_2398(state, tracer, fn_state);
    }
    fn block_2398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2398_0: read-var gs#135545:u8
        let s_2398_0: bool = fn_state.gs_135545;
        // N s_2398_1: branch s_2398_0 b4394 b2399
        if s_2398_0 {
            return block_4394(state, tracer, fn_state);
        } else {
            return block_2399(state, tracer, fn_state);
        };
    }
    fn block_2399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2399_0: const #0u : u8
        let s_2399_0: bool = false;
        // D s_2399_1: write-var gs#135546 <= s_2399_0
        fn_state.gs_135546 = s_2399_0;
        // N s_2399_2: jump b2400
        return block_2400(state, tracer, fn_state);
    }
    fn block_2400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2400_0: read-var gs#135546:u8
        let s_2400_0: bool = fn_state.gs_135546;
        // N s_2400_1: branch s_2400_0 b4393 b2401
        if s_2400_0 {
            return block_4393(state, tracer, fn_state);
        } else {
            return block_2401(state, tracer, fn_state);
        };
    }
    fn block_2401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2401_0: const #0u : u8
        let s_2401_0: bool = false;
        // D s_2401_1: write-var gs#135547 <= s_2401_0
        fn_state.gs_135547 = s_2401_0;
        // N s_2401_2: jump b2402
        return block_2402(state, tracer, fn_state);
    }
    fn block_2402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2402_0: read-var gs#135547:u8
        let s_2402_0: bool = fn_state.gs_135547;
        // N s_2402_1: branch s_2402_0 b4392 b2403
        if s_2402_0 {
            return block_4392(state, tracer, fn_state);
        } else {
            return block_2403(state, tracer, fn_state);
        };
    }
    fn block_2403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2403_0: read-var CRm:u8
        let s_2403_0: u8 = fn_state.CRm;
        // D s_2403_1: cast zx s_2403_0 -> bv
        let s_2403_1: Bits = Bits::new(s_2403_0 as u128, 4u16);
        // C s_2403_2: const #3u : u8
        let s_2403_2: u8 = 3;
        // C s_2403_3: cast zx s_2403_2 -> bv
        let s_2403_3: Bits = Bits::new(s_2403_2 as u128, 4u16);
        // D s_2403_4: cmp-eq s_2403_1 s_2403_3
        let s_2403_4: bool = ((s_2403_1) == (s_2403_3));
        // N s_2403_5: branch s_2403_4 b4391 b2404
        if s_2403_4 {
            return block_4391(state, tracer, fn_state);
        } else {
            return block_2404(state, tracer, fn_state);
        };
    }
    fn block_2404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2404_0: const #0u : u8
        let s_2404_0: bool = false;
        // D s_2404_1: write-var gs#135548 <= s_2404_0
        fn_state.gs_135548 = s_2404_0;
        // N s_2404_2: jump b2405
        return block_2405(state, tracer, fn_state);
    }
    fn block_2405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2405_0: read-var gs#135548:u8
        let s_2405_0: bool = fn_state.gs_135548;
        // N s_2405_1: branch s_2405_0 b4390 b2406
        if s_2405_0 {
            return block_4390(state, tracer, fn_state);
        } else {
            return block_2406(state, tracer, fn_state);
        };
    }
    fn block_2406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2406_0: const #0u : u8
        let s_2406_0: bool = false;
        // D s_2406_1: write-var gs#135549 <= s_2406_0
        fn_state.gs_135549 = s_2406_0;
        // N s_2406_2: jump b2407
        return block_2407(state, tracer, fn_state);
    }
    fn block_2407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2407_0: read-var gs#135549:u8
        let s_2407_0: bool = fn_state.gs_135549;
        // N s_2407_1: branch s_2407_0 b4389 b2408
        if s_2407_0 {
            return block_4389(state, tracer, fn_state);
        } else {
            return block_2408(state, tracer, fn_state);
        };
    }
    fn block_2408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2408_0: const #0u : u8
        let s_2408_0: bool = false;
        // D s_2408_1: write-var gs#135550 <= s_2408_0
        fn_state.gs_135550 = s_2408_0;
        // N s_2408_2: jump b2409
        return block_2409(state, tracer, fn_state);
    }
    fn block_2409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2409_0: read-var gs#135550:u8
        let s_2409_0: bool = fn_state.gs_135550;
        // N s_2409_1: branch s_2409_0 b4388 b2410
        if s_2409_0 {
            return block_4388(state, tracer, fn_state);
        } else {
            return block_2410(state, tracer, fn_state);
        };
    }
    fn block_2410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2410_0: const #0u : u8
        let s_2410_0: bool = false;
        // D s_2410_1: write-var gs#135551 <= s_2410_0
        fn_state.gs_135551 = s_2410_0;
        // N s_2410_2: jump b2411
        return block_2411(state, tracer, fn_state);
    }
    fn block_2411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2411_0: read-var gs#135551:u8
        let s_2411_0: bool = fn_state.gs_135551;
        // N s_2411_1: branch s_2411_0 b4387 b2412
        if s_2411_0 {
            return block_4387(state, tracer, fn_state);
        } else {
            return block_2412(state, tracer, fn_state);
        };
    }
    fn block_2412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2412_0: read-var CRm:u8
        let s_2412_0: u8 = fn_state.CRm;
        // D s_2412_1: cast zx s_2412_0 -> bv
        let s_2412_1: Bits = Bits::new(s_2412_0 as u128, 4u16);
        // C s_2412_2: const #10u : u8
        let s_2412_2: u8 = 10;
        // C s_2412_3: cast zx s_2412_2 -> bv
        let s_2412_3: Bits = Bits::new(s_2412_2 as u128, 4u16);
        // D s_2412_4: cmp-eq s_2412_1 s_2412_3
        let s_2412_4: bool = ((s_2412_1) == (s_2412_3));
        // N s_2412_5: branch s_2412_4 b4386 b2413
        if s_2412_4 {
            return block_4386(state, tracer, fn_state);
        } else {
            return block_2413(state, tracer, fn_state);
        };
    }
    fn block_2413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2413_0: const #0u : u8
        let s_2413_0: bool = false;
        // D s_2413_1: write-var gs#135552 <= s_2413_0
        fn_state.gs_135552 = s_2413_0;
        // N s_2413_2: jump b2414
        return block_2414(state, tracer, fn_state);
    }
    fn block_2414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2414_0: read-var gs#135552:u8
        let s_2414_0: bool = fn_state.gs_135552;
        // N s_2414_1: branch s_2414_0 b4385 b2415
        if s_2414_0 {
            return block_4385(state, tracer, fn_state);
        } else {
            return block_2415(state, tracer, fn_state);
        };
    }
    fn block_2415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2415_0: const #0u : u8
        let s_2415_0: bool = false;
        // D s_2415_1: write-var gs#135553 <= s_2415_0
        fn_state.gs_135553 = s_2415_0;
        // N s_2415_2: jump b2416
        return block_2416(state, tracer, fn_state);
    }
    fn block_2416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2416_0: read-var gs#135553:u8
        let s_2416_0: bool = fn_state.gs_135553;
        // N s_2416_1: branch s_2416_0 b4384 b2417
        if s_2416_0 {
            return block_4384(state, tracer, fn_state);
        } else {
            return block_2417(state, tracer, fn_state);
        };
    }
    fn block_2417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2417_0: const #0u : u8
        let s_2417_0: bool = false;
        // D s_2417_1: write-var gs#135554 <= s_2417_0
        fn_state.gs_135554 = s_2417_0;
        // N s_2417_2: jump b2418
        return block_2418(state, tracer, fn_state);
    }
    fn block_2418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2418_0: read-var gs#135554:u8
        let s_2418_0: bool = fn_state.gs_135554;
        // N s_2418_1: branch s_2418_0 b4383 b2419
        if s_2418_0 {
            return block_4383(state, tracer, fn_state);
        } else {
            return block_2419(state, tracer, fn_state);
        };
    }
    fn block_2419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2419_0: const #0u : u8
        let s_2419_0: bool = false;
        // D s_2419_1: write-var gs#135555 <= s_2419_0
        fn_state.gs_135555 = s_2419_0;
        // N s_2419_2: jump b2420
        return block_2420(state, tracer, fn_state);
    }
    fn block_2420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2420_0: read-var gs#135555:u8
        let s_2420_0: bool = fn_state.gs_135555;
        // N s_2420_1: branch s_2420_0 b4382 b2421
        if s_2420_0 {
            return block_4382(state, tracer, fn_state);
        } else {
            return block_2421(state, tracer, fn_state);
        };
    }
    fn block_2421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2421_0: read-var CRm:u8
        let s_2421_0: u8 = fn_state.CRm;
        // D s_2421_1: cast zx s_2421_0 -> bv
        let s_2421_1: Bits = Bits::new(s_2421_0 as u128, 4u16);
        // C s_2421_2: const #9u : u8
        let s_2421_2: u8 = 9;
        // C s_2421_3: cast zx s_2421_2 -> bv
        let s_2421_3: Bits = Bits::new(s_2421_2 as u128, 4u16);
        // D s_2421_4: cmp-eq s_2421_1 s_2421_3
        let s_2421_4: bool = ((s_2421_1) == (s_2421_3));
        // N s_2421_5: branch s_2421_4 b4381 b2422
        if s_2421_4 {
            return block_4381(state, tracer, fn_state);
        } else {
            return block_2422(state, tracer, fn_state);
        };
    }
    fn block_2422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2422_0: const #0u : u8
        let s_2422_0: bool = false;
        // D s_2422_1: write-var gs#135556 <= s_2422_0
        fn_state.gs_135556 = s_2422_0;
        // N s_2422_2: jump b2423
        return block_2423(state, tracer, fn_state);
    }
    fn block_2423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2423_0: read-var gs#135556:u8
        let s_2423_0: bool = fn_state.gs_135556;
        // N s_2423_1: branch s_2423_0 b4380 b2424
        if s_2423_0 {
            return block_4380(state, tracer, fn_state);
        } else {
            return block_2424(state, tracer, fn_state);
        };
    }
    fn block_2424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2424_0: const #0u : u8
        let s_2424_0: bool = false;
        // D s_2424_1: write-var gs#135557 <= s_2424_0
        fn_state.gs_135557 = s_2424_0;
        // N s_2424_2: jump b2425
        return block_2425(state, tracer, fn_state);
    }
    fn block_2425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2425_0: read-var gs#135557:u8
        let s_2425_0: bool = fn_state.gs_135557;
        // N s_2425_1: branch s_2425_0 b4379 b2426
        if s_2425_0 {
            return block_4379(state, tracer, fn_state);
        } else {
            return block_2426(state, tracer, fn_state);
        };
    }
    fn block_2426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2426_0: const #0u : u8
        let s_2426_0: bool = false;
        // D s_2426_1: write-var gs#135558 <= s_2426_0
        fn_state.gs_135558 = s_2426_0;
        // N s_2426_2: jump b2427
        return block_2427(state, tracer, fn_state);
    }
    fn block_2427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2427_0: read-var gs#135558:u8
        let s_2427_0: bool = fn_state.gs_135558;
        // N s_2427_1: branch s_2427_0 b4378 b2428
        if s_2427_0 {
            return block_4378(state, tracer, fn_state);
        } else {
            return block_2428(state, tracer, fn_state);
        };
    }
    fn block_2428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2428_0: const #0u : u8
        let s_2428_0: bool = false;
        // D s_2428_1: write-var gs#135559 <= s_2428_0
        fn_state.gs_135559 = s_2428_0;
        // N s_2428_2: jump b2429
        return block_2429(state, tracer, fn_state);
    }
    fn block_2429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2429_0: read-var gs#135559:u8
        let s_2429_0: bool = fn_state.gs_135559;
        // N s_2429_1: branch s_2429_0 b4377 b2430
        if s_2429_0 {
            return block_4377(state, tracer, fn_state);
        } else {
            return block_2430(state, tracer, fn_state);
        };
    }
    fn block_2430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2430_0: read-var CRm:u8
        let s_2430_0: u8 = fn_state.CRm;
        // D s_2430_1: cast zx s_2430_0 -> bv
        let s_2430_1: Bits = Bits::new(s_2430_0 as u128, 4u16);
        // C s_2430_2: const #1u : u8
        let s_2430_2: u8 = 1;
        // C s_2430_3: cast zx s_2430_2 -> bv
        let s_2430_3: Bits = Bits::new(s_2430_2 as u128, 4u16);
        // D s_2430_4: cmp-eq s_2430_1 s_2430_3
        let s_2430_4: bool = ((s_2430_1) == (s_2430_3));
        // N s_2430_5: branch s_2430_4 b4376 b2431
        if s_2430_4 {
            return block_4376(state, tracer, fn_state);
        } else {
            return block_2431(state, tracer, fn_state);
        };
    }
    fn block_2431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2431_0: const #0u : u8
        let s_2431_0: bool = false;
        // D s_2431_1: write-var gs#135560 <= s_2431_0
        fn_state.gs_135560 = s_2431_0;
        // N s_2431_2: jump b2432
        return block_2432(state, tracer, fn_state);
    }
    fn block_2432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2432_0: read-var gs#135560:u8
        let s_2432_0: bool = fn_state.gs_135560;
        // N s_2432_1: branch s_2432_0 b4375 b2433
        if s_2432_0 {
            return block_4375(state, tracer, fn_state);
        } else {
            return block_2433(state, tracer, fn_state);
        };
    }
    fn block_2433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2433_0: const #0u : u8
        let s_2433_0: bool = false;
        // D s_2433_1: write-var gs#135561 <= s_2433_0
        fn_state.gs_135561 = s_2433_0;
        // N s_2433_2: jump b2434
        return block_2434(state, tracer, fn_state);
    }
    fn block_2434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2434_0: read-var gs#135561:u8
        let s_2434_0: bool = fn_state.gs_135561;
        // N s_2434_1: branch s_2434_0 b4374 b2435
        if s_2434_0 {
            return block_4374(state, tracer, fn_state);
        } else {
            return block_2435(state, tracer, fn_state);
        };
    }
    fn block_2435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2435_0: const #0u : u8
        let s_2435_0: bool = false;
        // D s_2435_1: write-var gs#135562 <= s_2435_0
        fn_state.gs_135562 = s_2435_0;
        // N s_2435_2: jump b2436
        return block_2436(state, tracer, fn_state);
    }
    fn block_2436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2436_0: read-var gs#135562:u8
        let s_2436_0: bool = fn_state.gs_135562;
        // N s_2436_1: branch s_2436_0 b4373 b2437
        if s_2436_0 {
            return block_4373(state, tracer, fn_state);
        } else {
            return block_2437(state, tracer, fn_state);
        };
    }
    fn block_2437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2437_0: const #0u : u8
        let s_2437_0: bool = false;
        // D s_2437_1: write-var gs#135563 <= s_2437_0
        fn_state.gs_135563 = s_2437_0;
        // N s_2437_2: jump b2438
        return block_2438(state, tracer, fn_state);
    }
    fn block_2438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2438_0: read-var gs#135563:u8
        let s_2438_0: bool = fn_state.gs_135563;
        // N s_2438_1: branch s_2438_0 b4372 b2439
        if s_2438_0 {
            return block_4372(state, tracer, fn_state);
        } else {
            return block_2439(state, tracer, fn_state);
        };
    }
    fn block_2439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2439_0: read-var CRm:u8
        let s_2439_0: u8 = fn_state.CRm;
        // D s_2439_1: cast zx s_2439_0 -> bv
        let s_2439_1: Bits = Bits::new(s_2439_0 as u128, 4u16);
        // C s_2439_2: const #0u : u8
        let s_2439_2: u8 = 0;
        // C s_2439_3: cast zx s_2439_2 -> bv
        let s_2439_3: Bits = Bits::new(s_2439_2 as u128, 4u16);
        // D s_2439_4: cmp-eq s_2439_1 s_2439_3
        let s_2439_4: bool = ((s_2439_1) == (s_2439_3));
        // N s_2439_5: branch s_2439_4 b4371 b2440
        if s_2439_4 {
            return block_4371(state, tracer, fn_state);
        } else {
            return block_2440(state, tracer, fn_state);
        };
    }
    fn block_2440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2440_0: const #0u : u8
        let s_2440_0: bool = false;
        // D s_2440_1: write-var gs#135564 <= s_2440_0
        fn_state.gs_135564 = s_2440_0;
        // N s_2440_2: jump b2441
        return block_2441(state, tracer, fn_state);
    }
    fn block_2441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2441_0: read-var gs#135564:u8
        let s_2441_0: bool = fn_state.gs_135564;
        // N s_2441_1: branch s_2441_0 b4370 b2442
        if s_2441_0 {
            return block_4370(state, tracer, fn_state);
        } else {
            return block_2442(state, tracer, fn_state);
        };
    }
    fn block_2442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2442_0: const #0u : u8
        let s_2442_0: bool = false;
        // D s_2442_1: write-var gs#135565 <= s_2442_0
        fn_state.gs_135565 = s_2442_0;
        // N s_2442_2: jump b2443
        return block_2443(state, tracer, fn_state);
    }
    fn block_2443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2443_0: read-var gs#135565:u8
        let s_2443_0: bool = fn_state.gs_135565;
        // N s_2443_1: branch s_2443_0 b4369 b2444
        if s_2443_0 {
            return block_4369(state, tracer, fn_state);
        } else {
            return block_2444(state, tracer, fn_state);
        };
    }
    fn block_2444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2444_0: const #0u : u8
        let s_2444_0: bool = false;
        // D s_2444_1: write-var gs#135566 <= s_2444_0
        fn_state.gs_135566 = s_2444_0;
        // N s_2444_2: jump b2445
        return block_2445(state, tracer, fn_state);
    }
    fn block_2445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2445_0: read-var gs#135566:u8
        let s_2445_0: bool = fn_state.gs_135566;
        // N s_2445_1: branch s_2445_0 b4368 b2446
        if s_2445_0 {
            return block_4368(state, tracer, fn_state);
        } else {
            return block_2446(state, tracer, fn_state);
        };
    }
    fn block_2446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2446_0: const #0u : u8
        let s_2446_0: bool = false;
        // D s_2446_1: write-var gs#135567 <= s_2446_0
        fn_state.gs_135567 = s_2446_0;
        // N s_2446_2: jump b2447
        return block_2447(state, tracer, fn_state);
    }
    fn block_2447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2447_0: read-var gs#135567:u8
        let s_2447_0: bool = fn_state.gs_135567;
        // N s_2447_1: branch s_2447_0 b4367 b2448
        if s_2447_0 {
            return block_4367(state, tracer, fn_state);
        } else {
            return block_2448(state, tracer, fn_state);
        };
    }
    fn block_2448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2448_0: read-var CRm:u8
        let s_2448_0: u8 = fn_state.CRm;
        // D s_2448_1: cast zx s_2448_0 -> bv
        let s_2448_1: Bits = Bits::new(s_2448_0 as u128, 4u16);
        // C s_2448_2: const #2u : u8
        let s_2448_2: u8 = 2;
        // C s_2448_3: cast zx s_2448_2 -> bv
        let s_2448_3: Bits = Bits::new(s_2448_2 as u128, 4u16);
        // D s_2448_4: cmp-eq s_2448_1 s_2448_3
        let s_2448_4: bool = ((s_2448_1) == (s_2448_3));
        // N s_2448_5: branch s_2448_4 b4366 b2449
        if s_2448_4 {
            return block_4366(state, tracer, fn_state);
        } else {
            return block_2449(state, tracer, fn_state);
        };
    }
    fn block_2449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2449_0: const #0u : u8
        let s_2449_0: bool = false;
        // D s_2449_1: write-var gs#135568 <= s_2449_0
        fn_state.gs_135568 = s_2449_0;
        // N s_2449_2: jump b2450
        return block_2450(state, tracer, fn_state);
    }
    fn block_2450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2450_0: read-var gs#135568:u8
        let s_2450_0: bool = fn_state.gs_135568;
        // N s_2450_1: branch s_2450_0 b4365 b2451
        if s_2450_0 {
            return block_4365(state, tracer, fn_state);
        } else {
            return block_2451(state, tracer, fn_state);
        };
    }
    fn block_2451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2451_0: const #0u : u8
        let s_2451_0: bool = false;
        // D s_2451_1: write-var gs#135569 <= s_2451_0
        fn_state.gs_135569 = s_2451_0;
        // N s_2451_2: jump b2452
        return block_2452(state, tracer, fn_state);
    }
    fn block_2452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2452_0: read-var gs#135569:u8
        let s_2452_0: bool = fn_state.gs_135569;
        // N s_2452_1: branch s_2452_0 b4364 b2453
        if s_2452_0 {
            return block_4364(state, tracer, fn_state);
        } else {
            return block_2453(state, tracer, fn_state);
        };
    }
    fn block_2453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2453_0: const #0u : u8
        let s_2453_0: bool = false;
        // D s_2453_1: write-var gs#135570 <= s_2453_0
        fn_state.gs_135570 = s_2453_0;
        // N s_2453_2: jump b2454
        return block_2454(state, tracer, fn_state);
    }
    fn block_2454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2454_0: read-var gs#135570:u8
        let s_2454_0: bool = fn_state.gs_135570;
        // N s_2454_1: branch s_2454_0 b4363 b2455
        if s_2454_0 {
            return block_4363(state, tracer, fn_state);
        } else {
            return block_2455(state, tracer, fn_state);
        };
    }
    fn block_2455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2455_0: const #0u : u8
        let s_2455_0: bool = false;
        // D s_2455_1: write-var gs#135571 <= s_2455_0
        fn_state.gs_135571 = s_2455_0;
        // N s_2455_2: jump b2456
        return block_2456(state, tracer, fn_state);
    }
    fn block_2456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2456_0: read-var gs#135571:u8
        let s_2456_0: bool = fn_state.gs_135571;
        // N s_2456_1: branch s_2456_0 b4362 b2457
        if s_2456_0 {
            return block_4362(state, tracer, fn_state);
        } else {
            return block_2457(state, tracer, fn_state);
        };
    }
    fn block_2457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2457_0: read-var CRm:u8
        let s_2457_0: u8 = fn_state.CRm;
        // D s_2457_1: cast zx s_2457_0 -> bv
        let s_2457_1: Bits = Bits::new(s_2457_0 as u128, 4u16);
        // C s_2457_2: const #2u : u8
        let s_2457_2: u8 = 2;
        // C s_2457_3: cast zx s_2457_2 -> bv
        let s_2457_3: Bits = Bits::new(s_2457_2 as u128, 4u16);
        // D s_2457_4: cmp-eq s_2457_1 s_2457_3
        let s_2457_4: bool = ((s_2457_1) == (s_2457_3));
        // N s_2457_5: branch s_2457_4 b4361 b2458
        if s_2457_4 {
            return block_4361(state, tracer, fn_state);
        } else {
            return block_2458(state, tracer, fn_state);
        };
    }
    fn block_2458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2458_0: const #0u : u8
        let s_2458_0: bool = false;
        // D s_2458_1: write-var gs#135572 <= s_2458_0
        fn_state.gs_135572 = s_2458_0;
        // N s_2458_2: jump b2459
        return block_2459(state, tracer, fn_state);
    }
    fn block_2459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2459_0: read-var gs#135572:u8
        let s_2459_0: bool = fn_state.gs_135572;
        // N s_2459_1: branch s_2459_0 b4360 b2460
        if s_2459_0 {
            return block_4360(state, tracer, fn_state);
        } else {
            return block_2460(state, tracer, fn_state);
        };
    }
    fn block_2460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2460_0: const #0u : u8
        let s_2460_0: bool = false;
        // D s_2460_1: write-var gs#135573 <= s_2460_0
        fn_state.gs_135573 = s_2460_0;
        // N s_2460_2: jump b2461
        return block_2461(state, tracer, fn_state);
    }
    fn block_2461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2461_0: read-var gs#135573:u8
        let s_2461_0: bool = fn_state.gs_135573;
        // N s_2461_1: branch s_2461_0 b4359 b2462
        if s_2461_0 {
            return block_4359(state, tracer, fn_state);
        } else {
            return block_2462(state, tracer, fn_state);
        };
    }
    fn block_2462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2462_0: const #0u : u8
        let s_2462_0: bool = false;
        // D s_2462_1: write-var gs#135574 <= s_2462_0
        fn_state.gs_135574 = s_2462_0;
        // N s_2462_2: jump b2463
        return block_2463(state, tracer, fn_state);
    }
    fn block_2463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2463_0: read-var gs#135574:u8
        let s_2463_0: bool = fn_state.gs_135574;
        // N s_2463_1: branch s_2463_0 b4358 b2464
        if s_2463_0 {
            return block_4358(state, tracer, fn_state);
        } else {
            return block_2464(state, tracer, fn_state);
        };
    }
    fn block_2464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2464_0: const #0u : u8
        let s_2464_0: bool = false;
        // D s_2464_1: write-var gs#135575 <= s_2464_0
        fn_state.gs_135575 = s_2464_0;
        // N s_2464_2: jump b2465
        return block_2465(state, tracer, fn_state);
    }
    fn block_2465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2465_0: read-var gs#135575:u8
        let s_2465_0: bool = fn_state.gs_135575;
        // N s_2465_1: branch s_2465_0 b4357 b2466
        if s_2465_0 {
            return block_4357(state, tracer, fn_state);
        } else {
            return block_2466(state, tracer, fn_state);
        };
    }
    fn block_2466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2466_0: read-var CRm:u8
        let s_2466_0: u8 = fn_state.CRm;
        // D s_2466_1: cast zx s_2466_0 -> bv
        let s_2466_1: Bits = Bits::new(s_2466_0 as u128, 4u16);
        // C s_2466_2: const #0u : u8
        let s_2466_2: u8 = 0;
        // C s_2466_3: cast zx s_2466_2 -> bv
        let s_2466_3: Bits = Bits::new(s_2466_2 as u128, 4u16);
        // D s_2466_4: cmp-eq s_2466_1 s_2466_3
        let s_2466_4: bool = ((s_2466_1) == (s_2466_3));
        // N s_2466_5: branch s_2466_4 b4356 b2467
        if s_2466_4 {
            return block_4356(state, tracer, fn_state);
        } else {
            return block_2467(state, tracer, fn_state);
        };
    }
    fn block_2467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2467_0: const #0u : u8
        let s_2467_0: bool = false;
        // D s_2467_1: write-var gs#135576 <= s_2467_0
        fn_state.gs_135576 = s_2467_0;
        // N s_2467_2: jump b2468
        return block_2468(state, tracer, fn_state);
    }
    fn block_2468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2468_0: read-var gs#135576:u8
        let s_2468_0: bool = fn_state.gs_135576;
        // N s_2468_1: branch s_2468_0 b4355 b2469
        if s_2468_0 {
            return block_4355(state, tracer, fn_state);
        } else {
            return block_2469(state, tracer, fn_state);
        };
    }
    fn block_2469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2469_0: const #0u : u8
        let s_2469_0: bool = false;
        // D s_2469_1: write-var gs#135577 <= s_2469_0
        fn_state.gs_135577 = s_2469_0;
        // N s_2469_2: jump b2470
        return block_2470(state, tracer, fn_state);
    }
    fn block_2470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2470_0: read-var gs#135577:u8
        let s_2470_0: bool = fn_state.gs_135577;
        // N s_2470_1: branch s_2470_0 b4354 b2471
        if s_2470_0 {
            return block_4354(state, tracer, fn_state);
        } else {
            return block_2471(state, tracer, fn_state);
        };
    }
    fn block_2471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2471_0: const #0u : u8
        let s_2471_0: bool = false;
        // D s_2471_1: write-var gs#135578 <= s_2471_0
        fn_state.gs_135578 = s_2471_0;
        // N s_2471_2: jump b2472
        return block_2472(state, tracer, fn_state);
    }
    fn block_2472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2472_0: read-var gs#135578:u8
        let s_2472_0: bool = fn_state.gs_135578;
        // N s_2472_1: branch s_2472_0 b4353 b2473
        if s_2472_0 {
            return block_4353(state, tracer, fn_state);
        } else {
            return block_2473(state, tracer, fn_state);
        };
    }
    fn block_2473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2473_0: const #0u : u8
        let s_2473_0: bool = false;
        // D s_2473_1: write-var gs#135579 <= s_2473_0
        fn_state.gs_135579 = s_2473_0;
        // N s_2473_2: jump b2474
        return block_2474(state, tracer, fn_state);
    }
    fn block_2474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2474_0: read-var gs#135579:u8
        let s_2474_0: bool = fn_state.gs_135579;
        // N s_2474_1: branch s_2474_0 b4352 b2475
        if s_2474_0 {
            return block_4352(state, tracer, fn_state);
        } else {
            return block_2475(state, tracer, fn_state);
        };
    }
    fn block_2475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2475_0: read-var CRm:u8
        let s_2475_0: u8 = fn_state.CRm;
        // D s_2475_1: cast zx s_2475_0 -> bv
        let s_2475_1: Bits = Bits::new(s_2475_0 as u128, 4u16);
        // C s_2475_2: const #0u : u8
        let s_2475_2: u8 = 0;
        // C s_2475_3: cast zx s_2475_2 -> bv
        let s_2475_3: Bits = Bits::new(s_2475_2 as u128, 4u16);
        // D s_2475_4: cmp-eq s_2475_1 s_2475_3
        let s_2475_4: bool = ((s_2475_1) == (s_2475_3));
        // N s_2475_5: branch s_2475_4 b4351 b2476
        if s_2475_4 {
            return block_4351(state, tracer, fn_state);
        } else {
            return block_2476(state, tracer, fn_state);
        };
    }
    fn block_2476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2476_0: const #0u : u8
        let s_2476_0: bool = false;
        // D s_2476_1: write-var gs#135580 <= s_2476_0
        fn_state.gs_135580 = s_2476_0;
        // N s_2476_2: jump b2477
        return block_2477(state, tracer, fn_state);
    }
    fn block_2477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2477_0: read-var gs#135580:u8
        let s_2477_0: bool = fn_state.gs_135580;
        // N s_2477_1: branch s_2477_0 b4350 b2478
        if s_2477_0 {
            return block_4350(state, tracer, fn_state);
        } else {
            return block_2478(state, tracer, fn_state);
        };
    }
    fn block_2478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2478_0: const #0u : u8
        let s_2478_0: bool = false;
        // D s_2478_1: write-var gs#135581 <= s_2478_0
        fn_state.gs_135581 = s_2478_0;
        // N s_2478_2: jump b2479
        return block_2479(state, tracer, fn_state);
    }
    fn block_2479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2479_0: read-var gs#135581:u8
        let s_2479_0: bool = fn_state.gs_135581;
        // N s_2479_1: branch s_2479_0 b4349 b2480
        if s_2479_0 {
            return block_4349(state, tracer, fn_state);
        } else {
            return block_2480(state, tracer, fn_state);
        };
    }
    fn block_2480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2480_0: const #0u : u8
        let s_2480_0: bool = false;
        // D s_2480_1: write-var gs#135582 <= s_2480_0
        fn_state.gs_135582 = s_2480_0;
        // N s_2480_2: jump b2481
        return block_2481(state, tracer, fn_state);
    }
    fn block_2481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2481_0: read-var gs#135582:u8
        let s_2481_0: bool = fn_state.gs_135582;
        // N s_2481_1: branch s_2481_0 b4348 b2482
        if s_2481_0 {
            return block_4348(state, tracer, fn_state);
        } else {
            return block_2482(state, tracer, fn_state);
        };
    }
    fn block_2482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2482_0: const #0u : u8
        let s_2482_0: bool = false;
        // D s_2482_1: write-var gs#135583 <= s_2482_0
        fn_state.gs_135583 = s_2482_0;
        // N s_2482_2: jump b2483
        return block_2483(state, tracer, fn_state);
    }
    fn block_2483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2483_0: read-var gs#135583:u8
        let s_2483_0: bool = fn_state.gs_135583;
        // N s_2483_1: branch s_2483_0 b4347 b2484
        if s_2483_0 {
            return block_4347(state, tracer, fn_state);
        } else {
            return block_2484(state, tracer, fn_state);
        };
    }
    fn block_2484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2484_0: read-var CRm:u8
        let s_2484_0: u8 = fn_state.CRm;
        // D s_2484_1: cast zx s_2484_0 -> bv
        let s_2484_1: Bits = Bits::new(s_2484_0 as u128, 4u16);
        // C s_2484_2: const #5u : u8
        let s_2484_2: u8 = 5;
        // C s_2484_3: cast zx s_2484_2 -> bv
        let s_2484_3: Bits = Bits::new(s_2484_2 as u128, 4u16);
        // D s_2484_4: cmp-eq s_2484_1 s_2484_3
        let s_2484_4: bool = ((s_2484_1) == (s_2484_3));
        // N s_2484_5: branch s_2484_4 b4346 b2485
        if s_2484_4 {
            return block_4346(state, tracer, fn_state);
        } else {
            return block_2485(state, tracer, fn_state);
        };
    }
    fn block_2485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2485_0: const #0u : u8
        let s_2485_0: bool = false;
        // D s_2485_1: write-var gs#135584 <= s_2485_0
        fn_state.gs_135584 = s_2485_0;
        // N s_2485_2: jump b2486
        return block_2486(state, tracer, fn_state);
    }
    fn block_2486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2486_0: read-var gs#135584:u8
        let s_2486_0: bool = fn_state.gs_135584;
        // N s_2486_1: branch s_2486_0 b4345 b2487
        if s_2486_0 {
            return block_4345(state, tracer, fn_state);
        } else {
            return block_2487(state, tracer, fn_state);
        };
    }
    fn block_2487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2487_0: const #0u : u8
        let s_2487_0: bool = false;
        // D s_2487_1: write-var gs#135585 <= s_2487_0
        fn_state.gs_135585 = s_2487_0;
        // N s_2487_2: jump b2488
        return block_2488(state, tracer, fn_state);
    }
    fn block_2488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2488_0: read-var gs#135585:u8
        let s_2488_0: bool = fn_state.gs_135585;
        // N s_2488_1: branch s_2488_0 b4344 b2489
        if s_2488_0 {
            return block_4344(state, tracer, fn_state);
        } else {
            return block_2489(state, tracer, fn_state);
        };
    }
    fn block_2489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2489_0: const #0u : u8
        let s_2489_0: bool = false;
        // D s_2489_1: write-var gs#135586 <= s_2489_0
        fn_state.gs_135586 = s_2489_0;
        // N s_2489_2: jump b2490
        return block_2490(state, tracer, fn_state);
    }
    fn block_2490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2490_0: read-var gs#135586:u8
        let s_2490_0: bool = fn_state.gs_135586;
        // N s_2490_1: branch s_2490_0 b4343 b2491
        if s_2490_0 {
            return block_4343(state, tracer, fn_state);
        } else {
            return block_2491(state, tracer, fn_state);
        };
    }
    fn block_2491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2491_0: const #0u : u8
        let s_2491_0: bool = false;
        // D s_2491_1: write-var gs#135587 <= s_2491_0
        fn_state.gs_135587 = s_2491_0;
        // N s_2491_2: jump b2492
        return block_2492(state, tracer, fn_state);
    }
    fn block_2492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2492_0: read-var gs#135587:u8
        let s_2492_0: bool = fn_state.gs_135587;
        // N s_2492_1: branch s_2492_0 b4342 b2493
        if s_2492_0 {
            return block_4342(state, tracer, fn_state);
        } else {
            return block_2493(state, tracer, fn_state);
        };
    }
    fn block_2493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2493_0: read-var CRm:u8
        let s_2493_0: u8 = fn_state.CRm;
        // D s_2493_1: cast zx s_2493_0 -> bv
        let s_2493_1: Bits = Bits::new(s_2493_0 as u128, 4u16);
        // C s_2493_2: const #8u : u8
        let s_2493_2: u8 = 8;
        // C s_2493_3: cast zx s_2493_2 -> bv
        let s_2493_3: Bits = Bits::new(s_2493_2 as u128, 4u16);
        // D s_2493_4: cmp-eq s_2493_1 s_2493_3
        let s_2493_4: bool = ((s_2493_1) == (s_2493_3));
        // N s_2493_5: branch s_2493_4 b4341 b2494
        if s_2493_4 {
            return block_4341(state, tracer, fn_state);
        } else {
            return block_2494(state, tracer, fn_state);
        };
    }
    fn block_2494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2494_0: const #0u : u8
        let s_2494_0: bool = false;
        // D s_2494_1: write-var gs#135588 <= s_2494_0
        fn_state.gs_135588 = s_2494_0;
        // N s_2494_2: jump b2495
        return block_2495(state, tracer, fn_state);
    }
    fn block_2495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2495_0: read-var gs#135588:u8
        let s_2495_0: bool = fn_state.gs_135588;
        // N s_2495_1: branch s_2495_0 b4340 b2496
        if s_2495_0 {
            return block_4340(state, tracer, fn_state);
        } else {
            return block_2496(state, tracer, fn_state);
        };
    }
    fn block_2496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2496_0: const #0u : u8
        let s_2496_0: bool = false;
        // D s_2496_1: write-var gs#135589 <= s_2496_0
        fn_state.gs_135589 = s_2496_0;
        // N s_2496_2: jump b2497
        return block_2497(state, tracer, fn_state);
    }
    fn block_2497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2497_0: read-var gs#135589:u8
        let s_2497_0: bool = fn_state.gs_135589;
        // N s_2497_1: branch s_2497_0 b4339 b2498
        if s_2497_0 {
            return block_4339(state, tracer, fn_state);
        } else {
            return block_2498(state, tracer, fn_state);
        };
    }
    fn block_2498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2498_0: const #0u : u8
        let s_2498_0: bool = false;
        // D s_2498_1: write-var gs#135590 <= s_2498_0
        fn_state.gs_135590 = s_2498_0;
        // N s_2498_2: jump b2499
        return block_2499(state, tracer, fn_state);
    }
    fn block_2499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2499_0: read-var gs#135590:u8
        let s_2499_0: bool = fn_state.gs_135590;
        // N s_2499_1: branch s_2499_0 b4338 b2500
        if s_2499_0 {
            return block_4338(state, tracer, fn_state);
        } else {
            return block_2500(state, tracer, fn_state);
        };
    }
    fn block_2500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2500_0: const #0u : u8
        let s_2500_0: bool = false;
        // D s_2500_1: write-var gs#135591 <= s_2500_0
        fn_state.gs_135591 = s_2500_0;
        // N s_2500_2: jump b2501
        return block_2501(state, tracer, fn_state);
    }
    fn block_2501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2501_0: read-var gs#135591:u8
        let s_2501_0: bool = fn_state.gs_135591;
        // N s_2501_1: branch s_2501_0 b4337 b2502
        if s_2501_0 {
            return block_4337(state, tracer, fn_state);
        } else {
            return block_2502(state, tracer, fn_state);
        };
    }
    fn block_2502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2502_0: read-var CRm:u8
        let s_2502_0: u8 = fn_state.CRm;
        // D s_2502_1: cast zx s_2502_0 -> bv
        let s_2502_1: Bits = Bits::new(s_2502_0 as u128, 4u16);
        // C s_2502_2: const #0u : u8
        let s_2502_2: u8 = 0;
        // C s_2502_3: cast zx s_2502_2 -> bv
        let s_2502_3: Bits = Bits::new(s_2502_2 as u128, 4u16);
        // D s_2502_4: cmp-eq s_2502_1 s_2502_3
        let s_2502_4: bool = ((s_2502_1) == (s_2502_3));
        // N s_2502_5: branch s_2502_4 b4336 b2503
        if s_2502_4 {
            return block_4336(state, tracer, fn_state);
        } else {
            return block_2503(state, tracer, fn_state);
        };
    }
    fn block_2503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2503_0: const #0u : u8
        let s_2503_0: bool = false;
        // D s_2503_1: write-var gs#135592 <= s_2503_0
        fn_state.gs_135592 = s_2503_0;
        // N s_2503_2: jump b2504
        return block_2504(state, tracer, fn_state);
    }
    fn block_2504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2504_0: read-var gs#135592:u8
        let s_2504_0: bool = fn_state.gs_135592;
        // N s_2504_1: branch s_2504_0 b4335 b2505
        if s_2504_0 {
            return block_4335(state, tracer, fn_state);
        } else {
            return block_2505(state, tracer, fn_state);
        };
    }
    fn block_2505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2505_0: const #0u : u8
        let s_2505_0: bool = false;
        // D s_2505_1: write-var gs#135593 <= s_2505_0
        fn_state.gs_135593 = s_2505_0;
        // N s_2505_2: jump b2506
        return block_2506(state, tracer, fn_state);
    }
    fn block_2506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2506_0: read-var gs#135593:u8
        let s_2506_0: bool = fn_state.gs_135593;
        // N s_2506_1: branch s_2506_0 b4334 b2507
        if s_2506_0 {
            return block_4334(state, tracer, fn_state);
        } else {
            return block_2507(state, tracer, fn_state);
        };
    }
    fn block_2507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2507_0: const #0u : u8
        let s_2507_0: bool = false;
        // D s_2507_1: write-var gs#135594 <= s_2507_0
        fn_state.gs_135594 = s_2507_0;
        // N s_2507_2: jump b2508
        return block_2508(state, tracer, fn_state);
    }
    fn block_2508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2508_0: read-var gs#135594:u8
        let s_2508_0: bool = fn_state.gs_135594;
        // N s_2508_1: branch s_2508_0 b4333 b2509
        if s_2508_0 {
            return block_4333(state, tracer, fn_state);
        } else {
            return block_2509(state, tracer, fn_state);
        };
    }
    fn block_2509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2509_0: const #0u : u8
        let s_2509_0: bool = false;
        // D s_2509_1: write-var gs#135595 <= s_2509_0
        fn_state.gs_135595 = s_2509_0;
        // N s_2509_2: jump b2510
        return block_2510(state, tracer, fn_state);
    }
    fn block_2510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2510_0: read-var gs#135595:u8
        let s_2510_0: bool = fn_state.gs_135595;
        // N s_2510_1: branch s_2510_0 b4332 b2511
        if s_2510_0 {
            return block_4332(state, tracer, fn_state);
        } else {
            return block_2511(state, tracer, fn_state);
        };
    }
    fn block_2511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2511_0: read-var CRm:u8
        let s_2511_0: u8 = fn_state.CRm;
        // D s_2511_1: cast zx s_2511_0 -> bv
        let s_2511_1: Bits = Bits::new(s_2511_0 as u128, 4u16);
        // C s_2511_2: const #0u : u8
        let s_2511_2: u8 = 0;
        // C s_2511_3: cast zx s_2511_2 -> bv
        let s_2511_3: Bits = Bits::new(s_2511_2 as u128, 4u16);
        // D s_2511_4: cmp-eq s_2511_1 s_2511_3
        let s_2511_4: bool = ((s_2511_1) == (s_2511_3));
        // N s_2511_5: branch s_2511_4 b4331 b2512
        if s_2511_4 {
            return block_4331(state, tracer, fn_state);
        } else {
            return block_2512(state, tracer, fn_state);
        };
    }
    fn block_2512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2512_0: const #0u : u8
        let s_2512_0: bool = false;
        // D s_2512_1: write-var gs#135596 <= s_2512_0
        fn_state.gs_135596 = s_2512_0;
        // N s_2512_2: jump b2513
        return block_2513(state, tracer, fn_state);
    }
    fn block_2513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2513_0: read-var gs#135596:u8
        let s_2513_0: bool = fn_state.gs_135596;
        // N s_2513_1: branch s_2513_0 b4330 b2514
        if s_2513_0 {
            return block_4330(state, tracer, fn_state);
        } else {
            return block_2514(state, tracer, fn_state);
        };
    }
    fn block_2514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2514_0: const #0u : u8
        let s_2514_0: bool = false;
        // D s_2514_1: write-var gs#135597 <= s_2514_0
        fn_state.gs_135597 = s_2514_0;
        // N s_2514_2: jump b2515
        return block_2515(state, tracer, fn_state);
    }
    fn block_2515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2515_0: read-var gs#135597:u8
        let s_2515_0: bool = fn_state.gs_135597;
        // N s_2515_1: branch s_2515_0 b4329 b2516
        if s_2515_0 {
            return block_4329(state, tracer, fn_state);
        } else {
            return block_2516(state, tracer, fn_state);
        };
    }
    fn block_2516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2516_0: const #0u : u8
        let s_2516_0: bool = false;
        // D s_2516_1: write-var gs#135598 <= s_2516_0
        fn_state.gs_135598 = s_2516_0;
        // N s_2516_2: jump b2517
        return block_2517(state, tracer, fn_state);
    }
    fn block_2517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2517_0: read-var gs#135598:u8
        let s_2517_0: bool = fn_state.gs_135598;
        // N s_2517_1: branch s_2517_0 b4328 b2518
        if s_2517_0 {
            return block_4328(state, tracer, fn_state);
        } else {
            return block_2518(state, tracer, fn_state);
        };
    }
    fn block_2518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2518_0: const #0u : u8
        let s_2518_0: bool = false;
        // D s_2518_1: write-var gs#135599 <= s_2518_0
        fn_state.gs_135599 = s_2518_0;
        // N s_2518_2: jump b2519
        return block_2519(state, tracer, fn_state);
    }
    fn block_2519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2519_0: read-var gs#135599:u8
        let s_2519_0: bool = fn_state.gs_135599;
        // N s_2519_1: branch s_2519_0 b4327 b2520
        if s_2519_0 {
            return block_4327(state, tracer, fn_state);
        } else {
            return block_2520(state, tracer, fn_state);
        };
    }
    fn block_2520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2520_0: read-var CRm:u8
        let s_2520_0: u8 = fn_state.CRm;
        // D s_2520_1: cast zx s_2520_0 -> bv
        let s_2520_1: Bits = Bits::new(s_2520_0 as u128, 4u16);
        // C s_2520_2: const #2u : u8
        let s_2520_2: u8 = 2;
        // C s_2520_3: cast zx s_2520_2 -> bv
        let s_2520_3: Bits = Bits::new(s_2520_2 as u128, 4u16);
        // D s_2520_4: cmp-eq s_2520_1 s_2520_3
        let s_2520_4: bool = ((s_2520_1) == (s_2520_3));
        // N s_2520_5: branch s_2520_4 b4326 b2521
        if s_2520_4 {
            return block_4326(state, tracer, fn_state);
        } else {
            return block_2521(state, tracer, fn_state);
        };
    }
    fn block_2521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2521_0: const #0u : u8
        let s_2521_0: bool = false;
        // D s_2521_1: write-var gs#135600 <= s_2521_0
        fn_state.gs_135600 = s_2521_0;
        // N s_2521_2: jump b2522
        return block_2522(state, tracer, fn_state);
    }
    fn block_2522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2522_0: read-var gs#135600:u8
        let s_2522_0: bool = fn_state.gs_135600;
        // N s_2522_1: branch s_2522_0 b4325 b2523
        if s_2522_0 {
            return block_4325(state, tracer, fn_state);
        } else {
            return block_2523(state, tracer, fn_state);
        };
    }
    fn block_2523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2523_0: const #0u : u8
        let s_2523_0: bool = false;
        // D s_2523_1: write-var gs#135601 <= s_2523_0
        fn_state.gs_135601 = s_2523_0;
        // N s_2523_2: jump b2524
        return block_2524(state, tracer, fn_state);
    }
    fn block_2524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2524_0: read-var gs#135601:u8
        let s_2524_0: bool = fn_state.gs_135601;
        // N s_2524_1: branch s_2524_0 b4324 b2525
        if s_2524_0 {
            return block_4324(state, tracer, fn_state);
        } else {
            return block_2525(state, tracer, fn_state);
        };
    }
    fn block_2525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2525_0: const #0u : u8
        let s_2525_0: bool = false;
        // D s_2525_1: write-var gs#135602 <= s_2525_0
        fn_state.gs_135602 = s_2525_0;
        // N s_2525_2: jump b2526
        return block_2526(state, tracer, fn_state);
    }
    fn block_2526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2526_0: read-var gs#135602:u8
        let s_2526_0: bool = fn_state.gs_135602;
        // N s_2526_1: branch s_2526_0 b4323 b2527
        if s_2526_0 {
            return block_4323(state, tracer, fn_state);
        } else {
            return block_2527(state, tracer, fn_state);
        };
    }
    fn block_2527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2527_0: const #0u : u8
        let s_2527_0: bool = false;
        // D s_2527_1: write-var gs#135603 <= s_2527_0
        fn_state.gs_135603 = s_2527_0;
        // N s_2527_2: jump b2528
        return block_2528(state, tracer, fn_state);
    }
    fn block_2528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2528_0: read-var gs#135603:u8
        let s_2528_0: bool = fn_state.gs_135603;
        // N s_2528_1: branch s_2528_0 b4322 b2529
        if s_2528_0 {
            return block_4322(state, tracer, fn_state);
        } else {
            return block_2529(state, tracer, fn_state);
        };
    }
    fn block_2529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2529_0: read-var CRm:u8
        let s_2529_0: u8 = fn_state.CRm;
        // D s_2529_1: cast zx s_2529_0 -> bv
        let s_2529_1: Bits = Bits::new(s_2529_0 as u128, 4u16);
        // C s_2529_2: const #0u : u8
        let s_2529_2: u8 = 0;
        // C s_2529_3: cast zx s_2529_2 -> bv
        let s_2529_3: Bits = Bits::new(s_2529_2 as u128, 4u16);
        // D s_2529_4: cmp-eq s_2529_1 s_2529_3
        let s_2529_4: bool = ((s_2529_1) == (s_2529_3));
        // N s_2529_5: branch s_2529_4 b4321 b2530
        if s_2529_4 {
            return block_4321(state, tracer, fn_state);
        } else {
            return block_2530(state, tracer, fn_state);
        };
    }
    fn block_2530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2530_0: const #0u : u8
        let s_2530_0: bool = false;
        // D s_2530_1: write-var gs#135604 <= s_2530_0
        fn_state.gs_135604 = s_2530_0;
        // N s_2530_2: jump b2531
        return block_2531(state, tracer, fn_state);
    }
    fn block_2531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2531_0: read-var gs#135604:u8
        let s_2531_0: bool = fn_state.gs_135604;
        // N s_2531_1: branch s_2531_0 b4320 b2532
        if s_2531_0 {
            return block_4320(state, tracer, fn_state);
        } else {
            return block_2532(state, tracer, fn_state);
        };
    }
    fn block_2532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2532_0: const #0u : u8
        let s_2532_0: bool = false;
        // D s_2532_1: write-var gs#135605 <= s_2532_0
        fn_state.gs_135605 = s_2532_0;
        // N s_2532_2: jump b2533
        return block_2533(state, tracer, fn_state);
    }
    fn block_2533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2533_0: read-var gs#135605:u8
        let s_2533_0: bool = fn_state.gs_135605;
        // N s_2533_1: branch s_2533_0 b4319 b2534
        if s_2533_0 {
            return block_4319(state, tracer, fn_state);
        } else {
            return block_2534(state, tracer, fn_state);
        };
    }
    fn block_2534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2534_0: const #0u : u8
        let s_2534_0: bool = false;
        // D s_2534_1: write-var gs#135606 <= s_2534_0
        fn_state.gs_135606 = s_2534_0;
        // N s_2534_2: jump b2535
        return block_2535(state, tracer, fn_state);
    }
    fn block_2535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2535_0: read-var gs#135606:u8
        let s_2535_0: bool = fn_state.gs_135606;
        // N s_2535_1: branch s_2535_0 b4318 b2536
        if s_2535_0 {
            return block_4318(state, tracer, fn_state);
        } else {
            return block_2536(state, tracer, fn_state);
        };
    }
    fn block_2536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2536_0: const #0u : u8
        let s_2536_0: bool = false;
        // D s_2536_1: write-var gs#135607 <= s_2536_0
        fn_state.gs_135607 = s_2536_0;
        // N s_2536_2: jump b2537
        return block_2537(state, tracer, fn_state);
    }
    fn block_2537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2537_0: read-var gs#135607:u8
        let s_2537_0: bool = fn_state.gs_135607;
        // N s_2537_1: branch s_2537_0 b4317 b2538
        if s_2537_0 {
            return block_4317(state, tracer, fn_state);
        } else {
            return block_2538(state, tracer, fn_state);
        };
    }
    fn block_2538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2538_0: read-var CRm:u8
        let s_2538_0: u8 = fn_state.CRm;
        // D s_2538_1: cast zx s_2538_0 -> bv
        let s_2538_1: Bits = Bits::new(s_2538_0 as u128, 4u16);
        // C s_2538_2: const #12u : u8
        let s_2538_2: u8 = 12;
        // C s_2538_3: cast zx s_2538_2 -> bv
        let s_2538_3: Bits = Bits::new(s_2538_2 as u128, 4u16);
        // D s_2538_4: cmp-eq s_2538_1 s_2538_3
        let s_2538_4: bool = ((s_2538_1) == (s_2538_3));
        // N s_2538_5: branch s_2538_4 b4316 b2539
        if s_2538_4 {
            return block_4316(state, tracer, fn_state);
        } else {
            return block_2539(state, tracer, fn_state);
        };
    }
    fn block_2539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2539_0: const #0u : u8
        let s_2539_0: bool = false;
        // D s_2539_1: write-var gs#135608 <= s_2539_0
        fn_state.gs_135608 = s_2539_0;
        // N s_2539_2: jump b2540
        return block_2540(state, tracer, fn_state);
    }
    fn block_2540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2540_0: read-var gs#135608:u8
        let s_2540_0: bool = fn_state.gs_135608;
        // N s_2540_1: branch s_2540_0 b4315 b2541
        if s_2540_0 {
            return block_4315(state, tracer, fn_state);
        } else {
            return block_2541(state, tracer, fn_state);
        };
    }
    fn block_2541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2541_0: const #0u : u8
        let s_2541_0: bool = false;
        // D s_2541_1: write-var gs#135609 <= s_2541_0
        fn_state.gs_135609 = s_2541_0;
        // N s_2541_2: jump b2542
        return block_2542(state, tracer, fn_state);
    }
    fn block_2542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2542_0: read-var gs#135609:u8
        let s_2542_0: bool = fn_state.gs_135609;
        // N s_2542_1: branch s_2542_0 b4314 b2543
        if s_2542_0 {
            return block_4314(state, tracer, fn_state);
        } else {
            return block_2543(state, tracer, fn_state);
        };
    }
    fn block_2543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2543_0: const #0u : u8
        let s_2543_0: bool = false;
        // D s_2543_1: write-var gs#135610 <= s_2543_0
        fn_state.gs_135610 = s_2543_0;
        // N s_2543_2: jump b2544
        return block_2544(state, tracer, fn_state);
    }
    fn block_2544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2544_0: read-var gs#135610:u8
        let s_2544_0: bool = fn_state.gs_135610;
        // N s_2544_1: branch s_2544_0 b4313 b2545
        if s_2544_0 {
            return block_4313(state, tracer, fn_state);
        } else {
            return block_2545(state, tracer, fn_state);
        };
    }
    fn block_2545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2545_0: const #0u : u8
        let s_2545_0: bool = false;
        // D s_2545_1: write-var gs#135611 <= s_2545_0
        fn_state.gs_135611 = s_2545_0;
        // N s_2545_2: jump b2546
        return block_2546(state, tracer, fn_state);
    }
    fn block_2546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2546_0: read-var gs#135611:u8
        let s_2546_0: bool = fn_state.gs_135611;
        // N s_2546_1: branch s_2546_0 b4312 b2547
        if s_2546_0 {
            return block_4312(state, tracer, fn_state);
        } else {
            return block_2547(state, tracer, fn_state);
        };
    }
    fn block_2547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2547_0: read-var CRm:u8
        let s_2547_0: u8 = fn_state.CRm;
        // D s_2547_1: cast zx s_2547_0 -> bv
        let s_2547_1: Bits = Bits::new(s_2547_0 as u128, 4u16);
        // C s_2547_2: const #15u : u8
        let s_2547_2: u8 = 15;
        // C s_2547_3: cast zx s_2547_2 -> bv
        let s_2547_3: Bits = Bits::new(s_2547_2 as u128, 4u16);
        // D s_2547_4: cmp-eq s_2547_1 s_2547_3
        let s_2547_4: bool = ((s_2547_1) == (s_2547_3));
        // N s_2547_5: branch s_2547_4 b4311 b2548
        if s_2547_4 {
            return block_4311(state, tracer, fn_state);
        } else {
            return block_2548(state, tracer, fn_state);
        };
    }
    fn block_2548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2548_0: const #0u : u8
        let s_2548_0: bool = false;
        // D s_2548_1: write-var gs#135612 <= s_2548_0
        fn_state.gs_135612 = s_2548_0;
        // N s_2548_2: jump b2549
        return block_2549(state, tracer, fn_state);
    }
    fn block_2549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2549_0: read-var gs#135612:u8
        let s_2549_0: bool = fn_state.gs_135612;
        // N s_2549_1: branch s_2549_0 b4310 b2550
        if s_2549_0 {
            return block_4310(state, tracer, fn_state);
        } else {
            return block_2550(state, tracer, fn_state);
        };
    }
    fn block_2550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2550_0: const #0u : u8
        let s_2550_0: bool = false;
        // D s_2550_1: write-var gs#135613 <= s_2550_0
        fn_state.gs_135613 = s_2550_0;
        // N s_2550_2: jump b2551
        return block_2551(state, tracer, fn_state);
    }
    fn block_2551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2551_0: read-var gs#135613:u8
        let s_2551_0: bool = fn_state.gs_135613;
        // N s_2551_1: branch s_2551_0 b4309 b2552
        if s_2551_0 {
            return block_4309(state, tracer, fn_state);
        } else {
            return block_2552(state, tracer, fn_state);
        };
    }
    fn block_2552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2552_0: const #0u : u8
        let s_2552_0: bool = false;
        // D s_2552_1: write-var gs#135614 <= s_2552_0
        fn_state.gs_135614 = s_2552_0;
        // N s_2552_2: jump b2553
        return block_2553(state, tracer, fn_state);
    }
    fn block_2553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2553_0: read-var gs#135614:u8
        let s_2553_0: bool = fn_state.gs_135614;
        // N s_2553_1: branch s_2553_0 b4308 b2554
        if s_2553_0 {
            return block_4308(state, tracer, fn_state);
        } else {
            return block_2554(state, tracer, fn_state);
        };
    }
    fn block_2554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2554_0: const #0u : u8
        let s_2554_0: bool = false;
        // D s_2554_1: write-var gs#135615 <= s_2554_0
        fn_state.gs_135615 = s_2554_0;
        // N s_2554_2: jump b2555
        return block_2555(state, tracer, fn_state);
    }
    fn block_2555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2555_0: read-var gs#135615:u8
        let s_2555_0: bool = fn_state.gs_135615;
        // N s_2555_1: branch s_2555_0 b4307 b2556
        if s_2555_0 {
            return block_4307(state, tracer, fn_state);
        } else {
            return block_2556(state, tracer, fn_state);
        };
    }
    fn block_2556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2556_0: read-var CRm:u8
        let s_2556_0: u8 = fn_state.CRm;
        // D s_2556_1: cast zx s_2556_0 -> bv
        let s_2556_1: Bits = Bits::new(s_2556_0 as u128, 4u16);
        // C s_2556_2: const #15u : u8
        let s_2556_2: u8 = 15;
        // C s_2556_3: cast zx s_2556_2 -> bv
        let s_2556_3: Bits = Bits::new(s_2556_2 as u128, 4u16);
        // D s_2556_4: cmp-eq s_2556_1 s_2556_3
        let s_2556_4: bool = ((s_2556_1) == (s_2556_3));
        // N s_2556_5: branch s_2556_4 b4306 b2557
        if s_2556_4 {
            return block_4306(state, tracer, fn_state);
        } else {
            return block_2557(state, tracer, fn_state);
        };
    }
    fn block_2557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2557_0: const #0u : u8
        let s_2557_0: bool = false;
        // D s_2557_1: write-var gs#135616 <= s_2557_0
        fn_state.gs_135616 = s_2557_0;
        // N s_2557_2: jump b2558
        return block_2558(state, tracer, fn_state);
    }
    fn block_2558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2558_0: read-var gs#135616:u8
        let s_2558_0: bool = fn_state.gs_135616;
        // N s_2558_1: branch s_2558_0 b4305 b2559
        if s_2558_0 {
            return block_4305(state, tracer, fn_state);
        } else {
            return block_2559(state, tracer, fn_state);
        };
    }
    fn block_2559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2559_0: const #0u : u8
        let s_2559_0: bool = false;
        // D s_2559_1: write-var gs#135617 <= s_2559_0
        fn_state.gs_135617 = s_2559_0;
        // N s_2559_2: jump b2560
        return block_2560(state, tracer, fn_state);
    }
    fn block_2560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2560_0: read-var gs#135617:u8
        let s_2560_0: bool = fn_state.gs_135617;
        // N s_2560_1: branch s_2560_0 b4304 b2561
        if s_2560_0 {
            return block_4304(state, tracer, fn_state);
        } else {
            return block_2561(state, tracer, fn_state);
        };
    }
    fn block_2561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2561_0: const #0u : u8
        let s_2561_0: bool = false;
        // D s_2561_1: write-var gs#135618 <= s_2561_0
        fn_state.gs_135618 = s_2561_0;
        // N s_2561_2: jump b2562
        return block_2562(state, tracer, fn_state);
    }
    fn block_2562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2562_0: read-var gs#135618:u8
        let s_2562_0: bool = fn_state.gs_135618;
        // N s_2562_1: branch s_2562_0 b4303 b2563
        if s_2562_0 {
            return block_4303(state, tracer, fn_state);
        } else {
            return block_2563(state, tracer, fn_state);
        };
    }
    fn block_2563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2563_0: const #0u : u8
        let s_2563_0: bool = false;
        // D s_2563_1: write-var gs#135619 <= s_2563_0
        fn_state.gs_135619 = s_2563_0;
        // N s_2563_2: jump b2564
        return block_2564(state, tracer, fn_state);
    }
    fn block_2564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2564_0: read-var gs#135619:u8
        let s_2564_0: bool = fn_state.gs_135619;
        // N s_2564_1: branch s_2564_0 b4302 b2565
        if s_2564_0 {
            return block_4302(state, tracer, fn_state);
        } else {
            return block_2565(state, tracer, fn_state);
        };
    }
    fn block_2565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2565_0: read-var CRm:u8
        let s_2565_0: u8 = fn_state.CRm;
        // D s_2565_1: cast zx s_2565_0 -> bv
        let s_2565_1: Bits = Bits::new(s_2565_0 as u128, 4u16);
        // C s_2565_2: const #15u : u8
        let s_2565_2: u8 = 15;
        // C s_2565_3: cast zx s_2565_2 -> bv
        let s_2565_3: Bits = Bits::new(s_2565_2 as u128, 4u16);
        // D s_2565_4: cmp-eq s_2565_1 s_2565_3
        let s_2565_4: bool = ((s_2565_1) == (s_2565_3));
        // N s_2565_5: branch s_2565_4 b4301 b2566
        if s_2565_4 {
            return block_4301(state, tracer, fn_state);
        } else {
            return block_2566(state, tracer, fn_state);
        };
    }
    fn block_2566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2566_0: const #0u : u8
        let s_2566_0: bool = false;
        // D s_2566_1: write-var gs#135620 <= s_2566_0
        fn_state.gs_135620 = s_2566_0;
        // N s_2566_2: jump b2567
        return block_2567(state, tracer, fn_state);
    }
    fn block_2567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2567_0: read-var gs#135620:u8
        let s_2567_0: bool = fn_state.gs_135620;
        // N s_2567_1: branch s_2567_0 b4300 b2568
        if s_2567_0 {
            return block_4300(state, tracer, fn_state);
        } else {
            return block_2568(state, tracer, fn_state);
        };
    }
    fn block_2568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2568_0: const #0u : u8
        let s_2568_0: bool = false;
        // D s_2568_1: write-var gs#135621 <= s_2568_0
        fn_state.gs_135621 = s_2568_0;
        // N s_2568_2: jump b2569
        return block_2569(state, tracer, fn_state);
    }
    fn block_2569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2569_0: read-var gs#135621:u8
        let s_2569_0: bool = fn_state.gs_135621;
        // N s_2569_1: branch s_2569_0 b4299 b2570
        if s_2569_0 {
            return block_4299(state, tracer, fn_state);
        } else {
            return block_2570(state, tracer, fn_state);
        };
    }
    fn block_2570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2570_0: const #0u : u8
        let s_2570_0: bool = false;
        // D s_2570_1: write-var gs#135622 <= s_2570_0
        fn_state.gs_135622 = s_2570_0;
        // N s_2570_2: jump b2571
        return block_2571(state, tracer, fn_state);
    }
    fn block_2571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2571_0: read-var gs#135622:u8
        let s_2571_0: bool = fn_state.gs_135622;
        // N s_2571_1: branch s_2571_0 b4298 b2572
        if s_2571_0 {
            return block_4298(state, tracer, fn_state);
        } else {
            return block_2572(state, tracer, fn_state);
        };
    }
    fn block_2572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2572_0: const #0u : u8
        let s_2572_0: bool = false;
        // D s_2572_1: write-var gs#135623 <= s_2572_0
        fn_state.gs_135623 = s_2572_0;
        // N s_2572_2: jump b2573
        return block_2573(state, tracer, fn_state);
    }
    fn block_2573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2573_0: read-var gs#135623:u8
        let s_2573_0: bool = fn_state.gs_135623;
        // N s_2573_1: branch s_2573_0 b4297 b2574
        if s_2573_0 {
            return block_4297(state, tracer, fn_state);
        } else {
            return block_2574(state, tracer, fn_state);
        };
    }
    fn block_2574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2574_0: read-var CRm:u8
        let s_2574_0: u8 = fn_state.CRm;
        // D s_2574_1: cast zx s_2574_0 -> bv
        let s_2574_1: Bits = Bits::new(s_2574_0 as u128, 4u16);
        // C s_2574_2: const #15u : u8
        let s_2574_2: u8 = 15;
        // C s_2574_3: cast zx s_2574_2 -> bv
        let s_2574_3: Bits = Bits::new(s_2574_2 as u128, 4u16);
        // D s_2574_4: cmp-eq s_2574_1 s_2574_3
        let s_2574_4: bool = ((s_2574_1) == (s_2574_3));
        // N s_2574_5: branch s_2574_4 b4296 b2575
        if s_2574_4 {
            return block_4296(state, tracer, fn_state);
        } else {
            return block_2575(state, tracer, fn_state);
        };
    }
    fn block_2575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2575_0: const #0u : u8
        let s_2575_0: bool = false;
        // D s_2575_1: write-var gs#135624 <= s_2575_0
        fn_state.gs_135624 = s_2575_0;
        // N s_2575_2: jump b2576
        return block_2576(state, tracer, fn_state);
    }
    fn block_2576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2576_0: read-var gs#135624:u8
        let s_2576_0: bool = fn_state.gs_135624;
        // N s_2576_1: branch s_2576_0 b4295 b2577
        if s_2576_0 {
            return block_4295(state, tracer, fn_state);
        } else {
            return block_2577(state, tracer, fn_state);
        };
    }
    fn block_2577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2577_0: const #0u : u8
        let s_2577_0: bool = false;
        // D s_2577_1: write-var gs#135625 <= s_2577_0
        fn_state.gs_135625 = s_2577_0;
        // N s_2577_2: jump b2578
        return block_2578(state, tracer, fn_state);
    }
    fn block_2578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2578_0: read-var gs#135625:u8
        let s_2578_0: bool = fn_state.gs_135625;
        // N s_2578_1: branch s_2578_0 b4294 b2579
        if s_2578_0 {
            return block_4294(state, tracer, fn_state);
        } else {
            return block_2579(state, tracer, fn_state);
        };
    }
    fn block_2579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2579_0: const #0u : u8
        let s_2579_0: bool = false;
        // D s_2579_1: write-var gs#135626 <= s_2579_0
        fn_state.gs_135626 = s_2579_0;
        // N s_2579_2: jump b2580
        return block_2580(state, tracer, fn_state);
    }
    fn block_2580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2580_0: read-var gs#135626:u8
        let s_2580_0: bool = fn_state.gs_135626;
        // N s_2580_1: branch s_2580_0 b4293 b2581
        if s_2580_0 {
            return block_4293(state, tracer, fn_state);
        } else {
            return block_2581(state, tracer, fn_state);
        };
    }
    fn block_2581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2581_0: const #0u : u8
        let s_2581_0: bool = false;
        // D s_2581_1: write-var gs#135627 <= s_2581_0
        fn_state.gs_135627 = s_2581_0;
        // N s_2581_2: jump b2582
        return block_2582(state, tracer, fn_state);
    }
    fn block_2582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2582_0: read-var gs#135627:u8
        let s_2582_0: bool = fn_state.gs_135627;
        // N s_2582_1: branch s_2582_0 b4292 b2583
        if s_2582_0 {
            return block_4292(state, tracer, fn_state);
        } else {
            return block_2583(state, tracer, fn_state);
        };
    }
    fn block_2583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2583_0: read-var CRm:u8
        let s_2583_0: u8 = fn_state.CRm;
        // D s_2583_1: cast zx s_2583_0 -> bv
        let s_2583_1: Bits = Bits::new(s_2583_0 as u128, 4u16);
        // C s_2583_2: const #15u : u8
        let s_2583_2: u8 = 15;
        // C s_2583_3: cast zx s_2583_2 -> bv
        let s_2583_3: Bits = Bits::new(s_2583_2 as u128, 4u16);
        // D s_2583_4: cmp-eq s_2583_1 s_2583_3
        let s_2583_4: bool = ((s_2583_1) == (s_2583_3));
        // N s_2583_5: branch s_2583_4 b4291 b2584
        if s_2583_4 {
            return block_4291(state, tracer, fn_state);
        } else {
            return block_2584(state, tracer, fn_state);
        };
    }
    fn block_2584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2584_0: const #0u : u8
        let s_2584_0: bool = false;
        // D s_2584_1: write-var gs#135628 <= s_2584_0
        fn_state.gs_135628 = s_2584_0;
        // N s_2584_2: jump b2585
        return block_2585(state, tracer, fn_state);
    }
    fn block_2585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2585_0: read-var gs#135628:u8
        let s_2585_0: bool = fn_state.gs_135628;
        // N s_2585_1: branch s_2585_0 b4290 b2586
        if s_2585_0 {
            return block_4290(state, tracer, fn_state);
        } else {
            return block_2586(state, tracer, fn_state);
        };
    }
    fn block_2586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2586_0: const #0u : u8
        let s_2586_0: bool = false;
        // D s_2586_1: write-var gs#135629 <= s_2586_0
        fn_state.gs_135629 = s_2586_0;
        // N s_2586_2: jump b2587
        return block_2587(state, tracer, fn_state);
    }
    fn block_2587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2587_0: read-var gs#135629:u8
        let s_2587_0: bool = fn_state.gs_135629;
        // N s_2587_1: branch s_2587_0 b4289 b2588
        if s_2587_0 {
            return block_4289(state, tracer, fn_state);
        } else {
            return block_2588(state, tracer, fn_state);
        };
    }
    fn block_2588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2588_0: const #0u : u8
        let s_2588_0: bool = false;
        // D s_2588_1: write-var gs#135630 <= s_2588_0
        fn_state.gs_135630 = s_2588_0;
        // N s_2588_2: jump b2589
        return block_2589(state, tracer, fn_state);
    }
    fn block_2589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2589_0: read-var gs#135630:u8
        let s_2589_0: bool = fn_state.gs_135630;
        // N s_2589_1: branch s_2589_0 b4288 b2590
        if s_2589_0 {
            return block_4288(state, tracer, fn_state);
        } else {
            return block_2590(state, tracer, fn_state);
        };
    }
    fn block_2590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2590_0: const #0u : u8
        let s_2590_0: bool = false;
        // D s_2590_1: write-var gs#135631 <= s_2590_0
        fn_state.gs_135631 = s_2590_0;
        // N s_2590_2: jump b2591
        return block_2591(state, tracer, fn_state);
    }
    fn block_2591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2591_0: read-var gs#135631:u8
        let s_2591_0: bool = fn_state.gs_135631;
        // N s_2591_1: branch s_2591_0 b4287 b2592
        if s_2591_0 {
            return block_4287(state, tracer, fn_state);
        } else {
            return block_2592(state, tracer, fn_state);
        };
    }
    fn block_2592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2592_0: read-var CRm:u8
        let s_2592_0: u8 = fn_state.CRm;
        // D s_2592_1: cast zx s_2592_0 -> bv
        let s_2592_1: Bits = Bits::new(s_2592_0 as u128, 4u16);
        // C s_2592_2: const #15u : u8
        let s_2592_2: u8 = 15;
        // C s_2592_3: cast zx s_2592_2 -> bv
        let s_2592_3: Bits = Bits::new(s_2592_2 as u128, 4u16);
        // D s_2592_4: cmp-eq s_2592_1 s_2592_3
        let s_2592_4: bool = ((s_2592_1) == (s_2592_3));
        // N s_2592_5: branch s_2592_4 b4286 b2593
        if s_2592_4 {
            return block_4286(state, tracer, fn_state);
        } else {
            return block_2593(state, tracer, fn_state);
        };
    }
    fn block_2593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2593_0: const #0u : u8
        let s_2593_0: bool = false;
        // D s_2593_1: write-var gs#135632 <= s_2593_0
        fn_state.gs_135632 = s_2593_0;
        // N s_2593_2: jump b2594
        return block_2594(state, tracer, fn_state);
    }
    fn block_2594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2594_0: read-var gs#135632:u8
        let s_2594_0: bool = fn_state.gs_135632;
        // N s_2594_1: branch s_2594_0 b4285 b2595
        if s_2594_0 {
            return block_4285(state, tracer, fn_state);
        } else {
            return block_2595(state, tracer, fn_state);
        };
    }
    fn block_2595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2595_0: const #0u : u8
        let s_2595_0: bool = false;
        // D s_2595_1: write-var gs#135633 <= s_2595_0
        fn_state.gs_135633 = s_2595_0;
        // N s_2595_2: jump b2596
        return block_2596(state, tracer, fn_state);
    }
    fn block_2596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2596_0: read-var gs#135633:u8
        let s_2596_0: bool = fn_state.gs_135633;
        // N s_2596_1: branch s_2596_0 b4284 b2597
        if s_2596_0 {
            return block_4284(state, tracer, fn_state);
        } else {
            return block_2597(state, tracer, fn_state);
        };
    }
    fn block_2597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2597_0: const #0u : u8
        let s_2597_0: bool = false;
        // D s_2597_1: write-var gs#135634 <= s_2597_0
        fn_state.gs_135634 = s_2597_0;
        // N s_2597_2: jump b2598
        return block_2598(state, tracer, fn_state);
    }
    fn block_2598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2598_0: read-var gs#135634:u8
        let s_2598_0: bool = fn_state.gs_135634;
        // N s_2598_1: branch s_2598_0 b4283 b2599
        if s_2598_0 {
            return block_4283(state, tracer, fn_state);
        } else {
            return block_2599(state, tracer, fn_state);
        };
    }
    fn block_2599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2599_0: const #0u : u8
        let s_2599_0: bool = false;
        // D s_2599_1: write-var gs#135635 <= s_2599_0
        fn_state.gs_135635 = s_2599_0;
        // N s_2599_2: jump b2600
        return block_2600(state, tracer, fn_state);
    }
    fn block_2600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2600_0: read-var gs#135635:u8
        let s_2600_0: bool = fn_state.gs_135635;
        // N s_2600_1: branch s_2600_0 b4282 b2601
        if s_2600_0 {
            return block_4282(state, tracer, fn_state);
        } else {
            return block_2601(state, tracer, fn_state);
        };
    }
    fn block_2601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2601_0: read-var CRm:u8
        let s_2601_0: u8 = fn_state.CRm;
        // D s_2601_1: cast zx s_2601_0 -> bv
        let s_2601_1: Bits = Bits::new(s_2601_0 as u128, 4u16);
        // C s_2601_2: const #15u : u8
        let s_2601_2: u8 = 15;
        // C s_2601_3: cast zx s_2601_2 -> bv
        let s_2601_3: Bits = Bits::new(s_2601_2 as u128, 4u16);
        // D s_2601_4: cmp-eq s_2601_1 s_2601_3
        let s_2601_4: bool = ((s_2601_1) == (s_2601_3));
        // N s_2601_5: branch s_2601_4 b4281 b2602
        if s_2601_4 {
            return block_4281(state, tracer, fn_state);
        } else {
            return block_2602(state, tracer, fn_state);
        };
    }
    fn block_2602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2602_0: const #0u : u8
        let s_2602_0: bool = false;
        // D s_2602_1: write-var gs#135636 <= s_2602_0
        fn_state.gs_135636 = s_2602_0;
        // N s_2602_2: jump b2603
        return block_2603(state, tracer, fn_state);
    }
    fn block_2603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2603_0: read-var gs#135636:u8
        let s_2603_0: bool = fn_state.gs_135636;
        // N s_2603_1: branch s_2603_0 b4280 b2604
        if s_2603_0 {
            return block_4280(state, tracer, fn_state);
        } else {
            return block_2604(state, tracer, fn_state);
        };
    }
    fn block_2604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2604_0: const #0u : u8
        let s_2604_0: bool = false;
        // D s_2604_1: write-var gs#135637 <= s_2604_0
        fn_state.gs_135637 = s_2604_0;
        // N s_2604_2: jump b2605
        return block_2605(state, tracer, fn_state);
    }
    fn block_2605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2605_0: read-var gs#135637:u8
        let s_2605_0: bool = fn_state.gs_135637;
        // N s_2605_1: branch s_2605_0 b4279 b2606
        if s_2605_0 {
            return block_4279(state, tracer, fn_state);
        } else {
            return block_2606(state, tracer, fn_state);
        };
    }
    fn block_2606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2606_0: const #0u : u8
        let s_2606_0: bool = false;
        // D s_2606_1: write-var gs#135638 <= s_2606_0
        fn_state.gs_135638 = s_2606_0;
        // N s_2606_2: jump b2607
        return block_2607(state, tracer, fn_state);
    }
    fn block_2607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2607_0: read-var gs#135638:u8
        let s_2607_0: bool = fn_state.gs_135638;
        // N s_2607_1: branch s_2607_0 b4278 b2608
        if s_2607_0 {
            return block_4278(state, tracer, fn_state);
        } else {
            return block_2608(state, tracer, fn_state);
        };
    }
    fn block_2608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2608_0: const #0u : u8
        let s_2608_0: bool = false;
        // D s_2608_1: write-var gs#135639 <= s_2608_0
        fn_state.gs_135639 = s_2608_0;
        // N s_2608_2: jump b2609
        return block_2609(state, tracer, fn_state);
    }
    fn block_2609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2609_0: read-var gs#135639:u8
        let s_2609_0: bool = fn_state.gs_135639;
        // N s_2609_1: branch s_2609_0 b4277 b2610
        if s_2609_0 {
            return block_4277(state, tracer, fn_state);
        } else {
            return block_2610(state, tracer, fn_state);
        };
    }
    fn block_2610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2610_0: read-var CRm:u8
        let s_2610_0: u8 = fn_state.CRm;
        // D s_2610_1: cast zx s_2610_0 -> bv
        let s_2610_1: Bits = Bits::new(s_2610_0 as u128, 4u16);
        // C s_2610_2: const #14u : u8
        let s_2610_2: u8 = 14;
        // C s_2610_3: cast zx s_2610_2 -> bv
        let s_2610_3: Bits = Bits::new(s_2610_2 as u128, 4u16);
        // D s_2610_4: cmp-eq s_2610_1 s_2610_3
        let s_2610_4: bool = ((s_2610_1) == (s_2610_3));
        // N s_2610_5: branch s_2610_4 b4276 b2611
        if s_2610_4 {
            return block_4276(state, tracer, fn_state);
        } else {
            return block_2611(state, tracer, fn_state);
        };
    }
    fn block_2611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2611_0: const #0u : u8
        let s_2611_0: bool = false;
        // D s_2611_1: write-var gs#135640 <= s_2611_0
        fn_state.gs_135640 = s_2611_0;
        // N s_2611_2: jump b2612
        return block_2612(state, tracer, fn_state);
    }
    fn block_2612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2612_0: read-var gs#135640:u8
        let s_2612_0: bool = fn_state.gs_135640;
        // N s_2612_1: branch s_2612_0 b4275 b2613
        if s_2612_0 {
            return block_4275(state, tracer, fn_state);
        } else {
            return block_2613(state, tracer, fn_state);
        };
    }
    fn block_2613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2613_0: const #0u : u8
        let s_2613_0: bool = false;
        // D s_2613_1: write-var gs#135641 <= s_2613_0
        fn_state.gs_135641 = s_2613_0;
        // N s_2613_2: jump b2614
        return block_2614(state, tracer, fn_state);
    }
    fn block_2614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2614_0: read-var gs#135641:u8
        let s_2614_0: bool = fn_state.gs_135641;
        // N s_2614_1: branch s_2614_0 b4274 b2615
        if s_2614_0 {
            return block_4274(state, tracer, fn_state);
        } else {
            return block_2615(state, tracer, fn_state);
        };
    }
    fn block_2615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2615_0: const #0u : u8
        let s_2615_0: bool = false;
        // D s_2615_1: write-var gs#135642 <= s_2615_0
        fn_state.gs_135642 = s_2615_0;
        // N s_2615_2: jump b2616
        return block_2616(state, tracer, fn_state);
    }
    fn block_2616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2616_0: read-var gs#135642:u8
        let s_2616_0: bool = fn_state.gs_135642;
        // N s_2616_1: branch s_2616_0 b4273 b2617
        if s_2616_0 {
            return block_4273(state, tracer, fn_state);
        } else {
            return block_2617(state, tracer, fn_state);
        };
    }
    fn block_2617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2617_0: const #0u : u8
        let s_2617_0: bool = false;
        // D s_2617_1: write-var gs#135643 <= s_2617_0
        fn_state.gs_135643 = s_2617_0;
        // N s_2617_2: jump b2618
        return block_2618(state, tracer, fn_state);
    }
    fn block_2618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2618_0: read-var gs#135643:u8
        let s_2618_0: bool = fn_state.gs_135643;
        // N s_2618_1: branch s_2618_0 b4272 b2619
        if s_2618_0 {
            return block_4272(state, tracer, fn_state);
        } else {
            return block_2619(state, tracer, fn_state);
        };
    }
    fn block_2619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2619_0: read-var CRm:u8
        let s_2619_0: u8 = fn_state.CRm;
        // D s_2619_1: cast zx s_2619_0 -> bv
        let s_2619_1: Bits = Bits::new(s_2619_0 as u128, 4u16);
        // C s_2619_2: const #14u : u8
        let s_2619_2: u8 = 14;
        // C s_2619_3: cast zx s_2619_2 -> bv
        let s_2619_3: Bits = Bits::new(s_2619_2 as u128, 4u16);
        // D s_2619_4: cmp-eq s_2619_1 s_2619_3
        let s_2619_4: bool = ((s_2619_1) == (s_2619_3));
        // N s_2619_5: branch s_2619_4 b4271 b2620
        if s_2619_4 {
            return block_4271(state, tracer, fn_state);
        } else {
            return block_2620(state, tracer, fn_state);
        };
    }
    fn block_2620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2620_0: const #0u : u8
        let s_2620_0: bool = false;
        // D s_2620_1: write-var gs#135644 <= s_2620_0
        fn_state.gs_135644 = s_2620_0;
        // N s_2620_2: jump b2621
        return block_2621(state, tracer, fn_state);
    }
    fn block_2621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2621_0: read-var gs#135644:u8
        let s_2621_0: bool = fn_state.gs_135644;
        // N s_2621_1: branch s_2621_0 b4270 b2622
        if s_2621_0 {
            return block_4270(state, tracer, fn_state);
        } else {
            return block_2622(state, tracer, fn_state);
        };
    }
    fn block_2622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2622_0: const #0u : u8
        let s_2622_0: bool = false;
        // D s_2622_1: write-var gs#135645 <= s_2622_0
        fn_state.gs_135645 = s_2622_0;
        // N s_2622_2: jump b2623
        return block_2623(state, tracer, fn_state);
    }
    fn block_2623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2623_0: read-var gs#135645:u8
        let s_2623_0: bool = fn_state.gs_135645;
        // N s_2623_1: branch s_2623_0 b4269 b2624
        if s_2623_0 {
            return block_4269(state, tracer, fn_state);
        } else {
            return block_2624(state, tracer, fn_state);
        };
    }
    fn block_2624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2624_0: const #0u : u8
        let s_2624_0: bool = false;
        // D s_2624_1: write-var gs#135646 <= s_2624_0
        fn_state.gs_135646 = s_2624_0;
        // N s_2624_2: jump b2625
        return block_2625(state, tracer, fn_state);
    }
    fn block_2625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2625_0: read-var gs#135646:u8
        let s_2625_0: bool = fn_state.gs_135646;
        // N s_2625_1: branch s_2625_0 b4268 b2626
        if s_2625_0 {
            return block_4268(state, tracer, fn_state);
        } else {
            return block_2626(state, tracer, fn_state);
        };
    }
    fn block_2626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2626_0: const #0u : u8
        let s_2626_0: bool = false;
        // D s_2626_1: write-var gs#135647 <= s_2626_0
        fn_state.gs_135647 = s_2626_0;
        // N s_2626_2: jump b2627
        return block_2627(state, tracer, fn_state);
    }
    fn block_2627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2627_0: read-var gs#135647:u8
        let s_2627_0: bool = fn_state.gs_135647;
        // N s_2627_1: branch s_2627_0 b4267 b2628
        if s_2627_0 {
            return block_4267(state, tracer, fn_state);
        } else {
            return block_2628(state, tracer, fn_state);
        };
    }
    fn block_2628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2628_0: read-var CRm:u8
        let s_2628_0: u8 = fn_state.CRm;
        // D s_2628_1: cast zx s_2628_0 -> bv
        let s_2628_1: Bits = Bits::new(s_2628_0 as u128, 4u16);
        // C s_2628_2: const #14u : u8
        let s_2628_2: u8 = 14;
        // C s_2628_3: cast zx s_2628_2 -> bv
        let s_2628_3: Bits = Bits::new(s_2628_2 as u128, 4u16);
        // D s_2628_4: cmp-eq s_2628_1 s_2628_3
        let s_2628_4: bool = ((s_2628_1) == (s_2628_3));
        // N s_2628_5: branch s_2628_4 b4266 b2629
        if s_2628_4 {
            return block_4266(state, tracer, fn_state);
        } else {
            return block_2629(state, tracer, fn_state);
        };
    }
    fn block_2629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2629_0: const #0u : u8
        let s_2629_0: bool = false;
        // D s_2629_1: write-var gs#135648 <= s_2629_0
        fn_state.gs_135648 = s_2629_0;
        // N s_2629_2: jump b2630
        return block_2630(state, tracer, fn_state);
    }
    fn block_2630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2630_0: read-var gs#135648:u8
        let s_2630_0: bool = fn_state.gs_135648;
        // N s_2630_1: branch s_2630_0 b4265 b2631
        if s_2630_0 {
            return block_4265(state, tracer, fn_state);
        } else {
            return block_2631(state, tracer, fn_state);
        };
    }
    fn block_2631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2631_0: const #0u : u8
        let s_2631_0: bool = false;
        // D s_2631_1: write-var gs#135649 <= s_2631_0
        fn_state.gs_135649 = s_2631_0;
        // N s_2631_2: jump b2632
        return block_2632(state, tracer, fn_state);
    }
    fn block_2632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2632_0: read-var gs#135649:u8
        let s_2632_0: bool = fn_state.gs_135649;
        // N s_2632_1: branch s_2632_0 b4264 b2633
        if s_2632_0 {
            return block_4264(state, tracer, fn_state);
        } else {
            return block_2633(state, tracer, fn_state);
        };
    }
    fn block_2633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2633_0: const #0u : u8
        let s_2633_0: bool = false;
        // D s_2633_1: write-var gs#135650 <= s_2633_0
        fn_state.gs_135650 = s_2633_0;
        // N s_2633_2: jump b2634
        return block_2634(state, tracer, fn_state);
    }
    fn block_2634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2634_0: read-var gs#135650:u8
        let s_2634_0: bool = fn_state.gs_135650;
        // N s_2634_1: branch s_2634_0 b4263 b2635
        if s_2634_0 {
            return block_4263(state, tracer, fn_state);
        } else {
            return block_2635(state, tracer, fn_state);
        };
    }
    fn block_2635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2635_0: const #0u : u8
        let s_2635_0: bool = false;
        // D s_2635_1: write-var gs#135651 <= s_2635_0
        fn_state.gs_135651 = s_2635_0;
        // N s_2635_2: jump b2636
        return block_2636(state, tracer, fn_state);
    }
    fn block_2636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2636_0: read-var gs#135651:u8
        let s_2636_0: bool = fn_state.gs_135651;
        // N s_2636_1: branch s_2636_0 b4262 b2637
        if s_2636_0 {
            return block_4262(state, tracer, fn_state);
        } else {
            return block_2637(state, tracer, fn_state);
        };
    }
    fn block_2637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2637_0: read-var CRm:u8
        let s_2637_0: u8 = fn_state.CRm;
        // D s_2637_1: cast zx s_2637_0 -> bv
        let s_2637_1: Bits = Bits::new(s_2637_0 as u128, 4u16);
        // C s_2637_2: const #14u : u8
        let s_2637_2: u8 = 14;
        // C s_2637_3: cast zx s_2637_2 -> bv
        let s_2637_3: Bits = Bits::new(s_2637_2 as u128, 4u16);
        // D s_2637_4: cmp-eq s_2637_1 s_2637_3
        let s_2637_4: bool = ((s_2637_1) == (s_2637_3));
        // N s_2637_5: branch s_2637_4 b4261 b2638
        if s_2637_4 {
            return block_4261(state, tracer, fn_state);
        } else {
            return block_2638(state, tracer, fn_state);
        };
    }
    fn block_2638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2638_0: const #0u : u8
        let s_2638_0: bool = false;
        // D s_2638_1: write-var gs#135652 <= s_2638_0
        fn_state.gs_135652 = s_2638_0;
        // N s_2638_2: jump b2639
        return block_2639(state, tracer, fn_state);
    }
    fn block_2639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2639_0: read-var gs#135652:u8
        let s_2639_0: bool = fn_state.gs_135652;
        // N s_2639_1: branch s_2639_0 b4260 b2640
        if s_2639_0 {
            return block_4260(state, tracer, fn_state);
        } else {
            return block_2640(state, tracer, fn_state);
        };
    }
    fn block_2640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2640_0: const #0u : u8
        let s_2640_0: bool = false;
        // D s_2640_1: write-var gs#135653 <= s_2640_0
        fn_state.gs_135653 = s_2640_0;
        // N s_2640_2: jump b2641
        return block_2641(state, tracer, fn_state);
    }
    fn block_2641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2641_0: read-var gs#135653:u8
        let s_2641_0: bool = fn_state.gs_135653;
        // N s_2641_1: branch s_2641_0 b4259 b2642
        if s_2641_0 {
            return block_4259(state, tracer, fn_state);
        } else {
            return block_2642(state, tracer, fn_state);
        };
    }
    fn block_2642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2642_0: const #0u : u8
        let s_2642_0: bool = false;
        // D s_2642_1: write-var gs#135654 <= s_2642_0
        fn_state.gs_135654 = s_2642_0;
        // N s_2642_2: jump b2643
        return block_2643(state, tracer, fn_state);
    }
    fn block_2643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2643_0: read-var gs#135654:u8
        let s_2643_0: bool = fn_state.gs_135654;
        // N s_2643_1: branch s_2643_0 b4258 b2644
        if s_2643_0 {
            return block_4258(state, tracer, fn_state);
        } else {
            return block_2644(state, tracer, fn_state);
        };
    }
    fn block_2644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2644_0: const #0u : u8
        let s_2644_0: bool = false;
        // D s_2644_1: write-var gs#135655 <= s_2644_0
        fn_state.gs_135655 = s_2644_0;
        // N s_2644_2: jump b2645
        return block_2645(state, tracer, fn_state);
    }
    fn block_2645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2645_0: read-var gs#135655:u8
        let s_2645_0: bool = fn_state.gs_135655;
        // N s_2645_1: branch s_2645_0 b4257 b2646
        if s_2645_0 {
            return block_4257(state, tracer, fn_state);
        } else {
            return block_2646(state, tracer, fn_state);
        };
    }
    fn block_2646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2646_0: read-var CRm:u8
        let s_2646_0: u8 = fn_state.CRm;
        // D s_2646_1: cast zx s_2646_0 -> bv
        let s_2646_1: Bits = Bits::new(s_2646_0 as u128, 4u16);
        // C s_2646_2: const #14u : u8
        let s_2646_2: u8 = 14;
        // C s_2646_3: cast zx s_2646_2 -> bv
        let s_2646_3: Bits = Bits::new(s_2646_2 as u128, 4u16);
        // D s_2646_4: cmp-eq s_2646_1 s_2646_3
        let s_2646_4: bool = ((s_2646_1) == (s_2646_3));
        // N s_2646_5: branch s_2646_4 b4256 b2647
        if s_2646_4 {
            return block_4256(state, tracer, fn_state);
        } else {
            return block_2647(state, tracer, fn_state);
        };
    }
    fn block_2647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2647_0: const #0u : u8
        let s_2647_0: bool = false;
        // D s_2647_1: write-var gs#135656 <= s_2647_0
        fn_state.gs_135656 = s_2647_0;
        // N s_2647_2: jump b2648
        return block_2648(state, tracer, fn_state);
    }
    fn block_2648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2648_0: read-var gs#135656:u8
        let s_2648_0: bool = fn_state.gs_135656;
        // N s_2648_1: branch s_2648_0 b4255 b2649
        if s_2648_0 {
            return block_4255(state, tracer, fn_state);
        } else {
            return block_2649(state, tracer, fn_state);
        };
    }
    fn block_2649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2649_0: const #0u : u8
        let s_2649_0: bool = false;
        // D s_2649_1: write-var gs#135657 <= s_2649_0
        fn_state.gs_135657 = s_2649_0;
        // N s_2649_2: jump b2650
        return block_2650(state, tracer, fn_state);
    }
    fn block_2650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2650_0: read-var gs#135657:u8
        let s_2650_0: bool = fn_state.gs_135657;
        // N s_2650_1: branch s_2650_0 b4254 b2651
        if s_2650_0 {
            return block_4254(state, tracer, fn_state);
        } else {
            return block_2651(state, tracer, fn_state);
        };
    }
    fn block_2651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2651_0: const #0u : u8
        let s_2651_0: bool = false;
        // D s_2651_1: write-var gs#135658 <= s_2651_0
        fn_state.gs_135658 = s_2651_0;
        // N s_2651_2: jump b2652
        return block_2652(state, tracer, fn_state);
    }
    fn block_2652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2652_0: read-var gs#135658:u8
        let s_2652_0: bool = fn_state.gs_135658;
        // N s_2652_1: branch s_2652_0 b4253 b2653
        if s_2652_0 {
            return block_4253(state, tracer, fn_state);
        } else {
            return block_2653(state, tracer, fn_state);
        };
    }
    fn block_2653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2653_0: const #0u : u8
        let s_2653_0: bool = false;
        // D s_2653_1: write-var gs#135659 <= s_2653_0
        fn_state.gs_135659 = s_2653_0;
        // N s_2653_2: jump b2654
        return block_2654(state, tracer, fn_state);
    }
    fn block_2654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2654_0: read-var gs#135659:u8
        let s_2654_0: bool = fn_state.gs_135659;
        // N s_2654_1: branch s_2654_0 b4252 b2655
        if s_2654_0 {
            return block_4252(state, tracer, fn_state);
        } else {
            return block_2655(state, tracer, fn_state);
        };
    }
    fn block_2655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2655_0: read-var CRm:u8
        let s_2655_0: u8 = fn_state.CRm;
        // D s_2655_1: cast zx s_2655_0 -> bv
        let s_2655_1: Bits = Bits::new(s_2655_0 as u128, 4u16);
        // C s_2655_2: const #14u : u8
        let s_2655_2: u8 = 14;
        // C s_2655_3: cast zx s_2655_2 -> bv
        let s_2655_3: Bits = Bits::new(s_2655_2 as u128, 4u16);
        // D s_2655_4: cmp-eq s_2655_1 s_2655_3
        let s_2655_4: bool = ((s_2655_1) == (s_2655_3));
        // N s_2655_5: branch s_2655_4 b4251 b2656
        if s_2655_4 {
            return block_4251(state, tracer, fn_state);
        } else {
            return block_2656(state, tracer, fn_state);
        };
    }
    fn block_2656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2656_0: const #0u : u8
        let s_2656_0: bool = false;
        // D s_2656_1: write-var gs#135660 <= s_2656_0
        fn_state.gs_135660 = s_2656_0;
        // N s_2656_2: jump b2657
        return block_2657(state, tracer, fn_state);
    }
    fn block_2657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2657_0: read-var gs#135660:u8
        let s_2657_0: bool = fn_state.gs_135660;
        // N s_2657_1: branch s_2657_0 b4250 b2658
        if s_2657_0 {
            return block_4250(state, tracer, fn_state);
        } else {
            return block_2658(state, tracer, fn_state);
        };
    }
    fn block_2658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2658_0: const #0u : u8
        let s_2658_0: bool = false;
        // D s_2658_1: write-var gs#135661 <= s_2658_0
        fn_state.gs_135661 = s_2658_0;
        // N s_2658_2: jump b2659
        return block_2659(state, tracer, fn_state);
    }
    fn block_2659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2659_0: read-var gs#135661:u8
        let s_2659_0: bool = fn_state.gs_135661;
        // N s_2659_1: branch s_2659_0 b4249 b2660
        if s_2659_0 {
            return block_4249(state, tracer, fn_state);
        } else {
            return block_2660(state, tracer, fn_state);
        };
    }
    fn block_2660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2660_0: const #0u : u8
        let s_2660_0: bool = false;
        // D s_2660_1: write-var gs#135662 <= s_2660_0
        fn_state.gs_135662 = s_2660_0;
        // N s_2660_2: jump b2661
        return block_2661(state, tracer, fn_state);
    }
    fn block_2661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2661_0: read-var gs#135662:u8
        let s_2661_0: bool = fn_state.gs_135662;
        // N s_2661_1: branch s_2661_0 b4248 b2662
        if s_2661_0 {
            return block_4248(state, tracer, fn_state);
        } else {
            return block_2662(state, tracer, fn_state);
        };
    }
    fn block_2662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2662_0: const #0u : u8
        let s_2662_0: bool = false;
        // D s_2662_1: write-var gs#135663 <= s_2662_0
        fn_state.gs_135663 = s_2662_0;
        // N s_2662_2: jump b2663
        return block_2663(state, tracer, fn_state);
    }
    fn block_2663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2663_0: read-var gs#135663:u8
        let s_2663_0: bool = fn_state.gs_135663;
        // N s_2663_1: branch s_2663_0 b4247 b2664
        if s_2663_0 {
            return block_4247(state, tracer, fn_state);
        } else {
            return block_2664(state, tracer, fn_state);
        };
    }
    fn block_2664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2664_0: read-var CRm:u8
        let s_2664_0: u8 = fn_state.CRm;
        // D s_2664_1: cast zx s_2664_0 -> bv
        let s_2664_1: Bits = Bits::new(s_2664_0 as u128, 4u16);
        // C s_2664_2: const #14u : u8
        let s_2664_2: u8 = 14;
        // C s_2664_3: cast zx s_2664_2 -> bv
        let s_2664_3: Bits = Bits::new(s_2664_2 as u128, 4u16);
        // D s_2664_4: cmp-eq s_2664_1 s_2664_3
        let s_2664_4: bool = ((s_2664_1) == (s_2664_3));
        // N s_2664_5: branch s_2664_4 b4246 b2665
        if s_2664_4 {
            return block_4246(state, tracer, fn_state);
        } else {
            return block_2665(state, tracer, fn_state);
        };
    }
    fn block_2665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2665_0: const #0u : u8
        let s_2665_0: bool = false;
        // D s_2665_1: write-var gs#135664 <= s_2665_0
        fn_state.gs_135664 = s_2665_0;
        // N s_2665_2: jump b2666
        return block_2666(state, tracer, fn_state);
    }
    fn block_2666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2666_0: read-var gs#135664:u8
        let s_2666_0: bool = fn_state.gs_135664;
        // N s_2666_1: branch s_2666_0 b4245 b2667
        if s_2666_0 {
            return block_4245(state, tracer, fn_state);
        } else {
            return block_2667(state, tracer, fn_state);
        };
    }
    fn block_2667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2667_0: const #0u : u8
        let s_2667_0: bool = false;
        // D s_2667_1: write-var gs#135665 <= s_2667_0
        fn_state.gs_135665 = s_2667_0;
        // N s_2667_2: jump b2668
        return block_2668(state, tracer, fn_state);
    }
    fn block_2668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2668_0: read-var gs#135665:u8
        let s_2668_0: bool = fn_state.gs_135665;
        // N s_2668_1: branch s_2668_0 b4244 b2669
        if s_2668_0 {
            return block_4244(state, tracer, fn_state);
        } else {
            return block_2669(state, tracer, fn_state);
        };
    }
    fn block_2669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2669_0: const #0u : u8
        let s_2669_0: bool = false;
        // D s_2669_1: write-var gs#135666 <= s_2669_0
        fn_state.gs_135666 = s_2669_0;
        // N s_2669_2: jump b2670
        return block_2670(state, tracer, fn_state);
    }
    fn block_2670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2670_0: read-var gs#135666:u8
        let s_2670_0: bool = fn_state.gs_135666;
        // N s_2670_1: branch s_2670_0 b4243 b2671
        if s_2670_0 {
            return block_4243(state, tracer, fn_state);
        } else {
            return block_2671(state, tracer, fn_state);
        };
    }
    fn block_2671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2671_0: const #0u : u8
        let s_2671_0: bool = false;
        // D s_2671_1: write-var gs#135667 <= s_2671_0
        fn_state.gs_135667 = s_2671_0;
        // N s_2671_2: jump b2672
        return block_2672(state, tracer, fn_state);
    }
    fn block_2672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2672_0: read-var gs#135667:u8
        let s_2672_0: bool = fn_state.gs_135667;
        // N s_2672_1: branch s_2672_0 b4242 b2673
        if s_2672_0 {
            return block_4242(state, tracer, fn_state);
        } else {
            return block_2673(state, tracer, fn_state);
        };
    }
    fn block_2673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2673_0: read-var CRm:u8
        let s_2673_0: u8 = fn_state.CRm;
        // D s_2673_1: cast zx s_2673_0 -> bv
        let s_2673_1: Bits = Bits::new(s_2673_0 as u128, 4u16);
        // C s_2673_2: const #14u : u8
        let s_2673_2: u8 = 14;
        // C s_2673_3: cast zx s_2673_2 -> bv
        let s_2673_3: Bits = Bits::new(s_2673_2 as u128, 4u16);
        // D s_2673_4: cmp-eq s_2673_1 s_2673_3
        let s_2673_4: bool = ((s_2673_1) == (s_2673_3));
        // N s_2673_5: branch s_2673_4 b4241 b2674
        if s_2673_4 {
            return block_4241(state, tracer, fn_state);
        } else {
            return block_2674(state, tracer, fn_state);
        };
    }
    fn block_2674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2674_0: const #0u : u8
        let s_2674_0: bool = false;
        // D s_2674_1: write-var gs#135668 <= s_2674_0
        fn_state.gs_135668 = s_2674_0;
        // N s_2674_2: jump b2675
        return block_2675(state, tracer, fn_state);
    }
    fn block_2675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2675_0: read-var gs#135668:u8
        let s_2675_0: bool = fn_state.gs_135668;
        // N s_2675_1: branch s_2675_0 b4240 b2676
        if s_2675_0 {
            return block_4240(state, tracer, fn_state);
        } else {
            return block_2676(state, tracer, fn_state);
        };
    }
    fn block_2676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2676_0: const #0u : u8
        let s_2676_0: bool = false;
        // D s_2676_1: write-var gs#135669 <= s_2676_0
        fn_state.gs_135669 = s_2676_0;
        // N s_2676_2: jump b2677
        return block_2677(state, tracer, fn_state);
    }
    fn block_2677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2677_0: read-var gs#135669:u8
        let s_2677_0: bool = fn_state.gs_135669;
        // N s_2677_1: branch s_2677_0 b4239 b2678
        if s_2677_0 {
            return block_4239(state, tracer, fn_state);
        } else {
            return block_2678(state, tracer, fn_state);
        };
    }
    fn block_2678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2678_0: const #0u : u8
        let s_2678_0: bool = false;
        // D s_2678_1: write-var gs#135670 <= s_2678_0
        fn_state.gs_135670 = s_2678_0;
        // N s_2678_2: jump b2679
        return block_2679(state, tracer, fn_state);
    }
    fn block_2679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2679_0: read-var gs#135670:u8
        let s_2679_0: bool = fn_state.gs_135670;
        // N s_2679_1: branch s_2679_0 b4238 b2680
        if s_2679_0 {
            return block_4238(state, tracer, fn_state);
        } else {
            return block_2680(state, tracer, fn_state);
        };
    }
    fn block_2680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2680_0: const #0u : u8
        let s_2680_0: bool = false;
        // D s_2680_1: write-var gs#135671 <= s_2680_0
        fn_state.gs_135671 = s_2680_0;
        // N s_2680_2: jump b2681
        return block_2681(state, tracer, fn_state);
    }
    fn block_2681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2681_0: read-var gs#135671:u8
        let s_2681_0: bool = fn_state.gs_135671;
        // N s_2681_1: branch s_2681_0 b4237 b2682
        if s_2681_0 {
            return block_4237(state, tracer, fn_state);
        } else {
            return block_2682(state, tracer, fn_state);
        };
    }
    fn block_2682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2682_0: read-var CRm:u8
        let s_2682_0: u8 = fn_state.CRm;
        // D s_2682_1: cast zx s_2682_0 -> bv
        let s_2682_1: Bits = Bits::new(s_2682_0 as u128, 4u16);
        // C s_2682_2: const #13u : u8
        let s_2682_2: u8 = 13;
        // C s_2682_3: cast zx s_2682_2 -> bv
        let s_2682_3: Bits = Bits::new(s_2682_2 as u128, 4u16);
        // D s_2682_4: cmp-eq s_2682_1 s_2682_3
        let s_2682_4: bool = ((s_2682_1) == (s_2682_3));
        // N s_2682_5: branch s_2682_4 b4236 b2683
        if s_2682_4 {
            return block_4236(state, tracer, fn_state);
        } else {
            return block_2683(state, tracer, fn_state);
        };
    }
    fn block_2683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2683_0: const #0u : u8
        let s_2683_0: bool = false;
        // D s_2683_1: write-var gs#135672 <= s_2683_0
        fn_state.gs_135672 = s_2683_0;
        // N s_2683_2: jump b2684
        return block_2684(state, tracer, fn_state);
    }
    fn block_2684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2684_0: read-var gs#135672:u8
        let s_2684_0: bool = fn_state.gs_135672;
        // N s_2684_1: branch s_2684_0 b4235 b2685
        if s_2684_0 {
            return block_4235(state, tracer, fn_state);
        } else {
            return block_2685(state, tracer, fn_state);
        };
    }
    fn block_2685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2685_0: const #0u : u8
        let s_2685_0: bool = false;
        // D s_2685_1: write-var gs#135673 <= s_2685_0
        fn_state.gs_135673 = s_2685_0;
        // N s_2685_2: jump b2686
        return block_2686(state, tracer, fn_state);
    }
    fn block_2686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2686_0: read-var gs#135673:u8
        let s_2686_0: bool = fn_state.gs_135673;
        // N s_2686_1: branch s_2686_0 b4234 b2687
        if s_2686_0 {
            return block_4234(state, tracer, fn_state);
        } else {
            return block_2687(state, tracer, fn_state);
        };
    }
    fn block_2687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2687_0: const #0u : u8
        let s_2687_0: bool = false;
        // D s_2687_1: write-var gs#135674 <= s_2687_0
        fn_state.gs_135674 = s_2687_0;
        // N s_2687_2: jump b2688
        return block_2688(state, tracer, fn_state);
    }
    fn block_2688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2688_0: read-var gs#135674:u8
        let s_2688_0: bool = fn_state.gs_135674;
        // N s_2688_1: branch s_2688_0 b4233 b2689
        if s_2688_0 {
            return block_4233(state, tracer, fn_state);
        } else {
            return block_2689(state, tracer, fn_state);
        };
    }
    fn block_2689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2689_0: const #0u : u8
        let s_2689_0: bool = false;
        // D s_2689_1: write-var gs#135675 <= s_2689_0
        fn_state.gs_135675 = s_2689_0;
        // N s_2689_2: jump b2690
        return block_2690(state, tracer, fn_state);
    }
    fn block_2690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2690_0: read-var gs#135675:u8
        let s_2690_0: bool = fn_state.gs_135675;
        // N s_2690_1: branch s_2690_0 b4232 b2691
        if s_2690_0 {
            return block_4232(state, tracer, fn_state);
        } else {
            return block_2691(state, tracer, fn_state);
        };
    }
    fn block_2691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2691_0: read-var CRm:u8
        let s_2691_0: u8 = fn_state.CRm;
        // D s_2691_1: cast zx s_2691_0 -> bv
        let s_2691_1: Bits = Bits::new(s_2691_0 as u128, 4u16);
        // C s_2691_2: const #13u : u8
        let s_2691_2: u8 = 13;
        // C s_2691_3: cast zx s_2691_2 -> bv
        let s_2691_3: Bits = Bits::new(s_2691_2 as u128, 4u16);
        // D s_2691_4: cmp-eq s_2691_1 s_2691_3
        let s_2691_4: bool = ((s_2691_1) == (s_2691_3));
        // N s_2691_5: branch s_2691_4 b4231 b2692
        if s_2691_4 {
            return block_4231(state, tracer, fn_state);
        } else {
            return block_2692(state, tracer, fn_state);
        };
    }
    fn block_2692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2692_0: const #0u : u8
        let s_2692_0: bool = false;
        // D s_2692_1: write-var gs#135676 <= s_2692_0
        fn_state.gs_135676 = s_2692_0;
        // N s_2692_2: jump b2693
        return block_2693(state, tracer, fn_state);
    }
    fn block_2693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2693_0: read-var gs#135676:u8
        let s_2693_0: bool = fn_state.gs_135676;
        // N s_2693_1: branch s_2693_0 b4230 b2694
        if s_2693_0 {
            return block_4230(state, tracer, fn_state);
        } else {
            return block_2694(state, tracer, fn_state);
        };
    }
    fn block_2694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2694_0: const #0u : u8
        let s_2694_0: bool = false;
        // D s_2694_1: write-var gs#135677 <= s_2694_0
        fn_state.gs_135677 = s_2694_0;
        // N s_2694_2: jump b2695
        return block_2695(state, tracer, fn_state);
    }
    fn block_2695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2695_0: read-var gs#135677:u8
        let s_2695_0: bool = fn_state.gs_135677;
        // N s_2695_1: branch s_2695_0 b4229 b2696
        if s_2695_0 {
            return block_4229(state, tracer, fn_state);
        } else {
            return block_2696(state, tracer, fn_state);
        };
    }
    fn block_2696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2696_0: const #0u : u8
        let s_2696_0: bool = false;
        // D s_2696_1: write-var gs#135678 <= s_2696_0
        fn_state.gs_135678 = s_2696_0;
        // N s_2696_2: jump b2697
        return block_2697(state, tracer, fn_state);
    }
    fn block_2697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2697_0: read-var gs#135678:u8
        let s_2697_0: bool = fn_state.gs_135678;
        // N s_2697_1: branch s_2697_0 b4228 b2698
        if s_2697_0 {
            return block_4228(state, tracer, fn_state);
        } else {
            return block_2698(state, tracer, fn_state);
        };
    }
    fn block_2698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2698_0: const #0u : u8
        let s_2698_0: bool = false;
        // D s_2698_1: write-var gs#135679 <= s_2698_0
        fn_state.gs_135679 = s_2698_0;
        // N s_2698_2: jump b2699
        return block_2699(state, tracer, fn_state);
    }
    fn block_2699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2699_0: read-var gs#135679:u8
        let s_2699_0: bool = fn_state.gs_135679;
        // N s_2699_1: branch s_2699_0 b4227 b2700
        if s_2699_0 {
            return block_4227(state, tracer, fn_state);
        } else {
            return block_2700(state, tracer, fn_state);
        };
    }
    fn block_2700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2700_0: read-var CRm:u8
        let s_2700_0: u8 = fn_state.CRm;
        // D s_2700_1: cast zx s_2700_0 -> bv
        let s_2700_1: Bits = Bits::new(s_2700_0 as u128, 4u16);
        // C s_2700_2: const #13u : u8
        let s_2700_2: u8 = 13;
        // C s_2700_3: cast zx s_2700_2 -> bv
        let s_2700_3: Bits = Bits::new(s_2700_2 as u128, 4u16);
        // D s_2700_4: cmp-eq s_2700_1 s_2700_3
        let s_2700_4: bool = ((s_2700_1) == (s_2700_3));
        // N s_2700_5: branch s_2700_4 b4226 b2701
        if s_2700_4 {
            return block_4226(state, tracer, fn_state);
        } else {
            return block_2701(state, tracer, fn_state);
        };
    }
    fn block_2701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2701_0: const #0u : u8
        let s_2701_0: bool = false;
        // D s_2701_1: write-var gs#135680 <= s_2701_0
        fn_state.gs_135680 = s_2701_0;
        // N s_2701_2: jump b2702
        return block_2702(state, tracer, fn_state);
    }
    fn block_2702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2702_0: read-var gs#135680:u8
        let s_2702_0: bool = fn_state.gs_135680;
        // N s_2702_1: branch s_2702_0 b4225 b2703
        if s_2702_0 {
            return block_4225(state, tracer, fn_state);
        } else {
            return block_2703(state, tracer, fn_state);
        };
    }
    fn block_2703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2703_0: const #0u : u8
        let s_2703_0: bool = false;
        // D s_2703_1: write-var gs#135681 <= s_2703_0
        fn_state.gs_135681 = s_2703_0;
        // N s_2703_2: jump b2704
        return block_2704(state, tracer, fn_state);
    }
    fn block_2704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2704_0: read-var gs#135681:u8
        let s_2704_0: bool = fn_state.gs_135681;
        // N s_2704_1: branch s_2704_0 b4224 b2705
        if s_2704_0 {
            return block_4224(state, tracer, fn_state);
        } else {
            return block_2705(state, tracer, fn_state);
        };
    }
    fn block_2705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2705_0: const #0u : u8
        let s_2705_0: bool = false;
        // D s_2705_1: write-var gs#135682 <= s_2705_0
        fn_state.gs_135682 = s_2705_0;
        // N s_2705_2: jump b2706
        return block_2706(state, tracer, fn_state);
    }
    fn block_2706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2706_0: read-var gs#135682:u8
        let s_2706_0: bool = fn_state.gs_135682;
        // N s_2706_1: branch s_2706_0 b4223 b2707
        if s_2706_0 {
            return block_4223(state, tracer, fn_state);
        } else {
            return block_2707(state, tracer, fn_state);
        };
    }
    fn block_2707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2707_0: const #0u : u8
        let s_2707_0: bool = false;
        // D s_2707_1: write-var gs#135683 <= s_2707_0
        fn_state.gs_135683 = s_2707_0;
        // N s_2707_2: jump b2708
        return block_2708(state, tracer, fn_state);
    }
    fn block_2708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2708_0: read-var gs#135683:u8
        let s_2708_0: bool = fn_state.gs_135683;
        // N s_2708_1: branch s_2708_0 b4222 b2709
        if s_2708_0 {
            return block_4222(state, tracer, fn_state);
        } else {
            return block_2709(state, tracer, fn_state);
        };
    }
    fn block_2709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2709_0: read-var CRm:u8
        let s_2709_0: u8 = fn_state.CRm;
        // D s_2709_1: cast zx s_2709_0 -> bv
        let s_2709_1: Bits = Bits::new(s_2709_0 as u128, 4u16);
        // C s_2709_2: const #13u : u8
        let s_2709_2: u8 = 13;
        // C s_2709_3: cast zx s_2709_2 -> bv
        let s_2709_3: Bits = Bits::new(s_2709_2 as u128, 4u16);
        // D s_2709_4: cmp-eq s_2709_1 s_2709_3
        let s_2709_4: bool = ((s_2709_1) == (s_2709_3));
        // N s_2709_5: branch s_2709_4 b4221 b2710
        if s_2709_4 {
            return block_4221(state, tracer, fn_state);
        } else {
            return block_2710(state, tracer, fn_state);
        };
    }
    fn block_2710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2710_0: const #0u : u8
        let s_2710_0: bool = false;
        // D s_2710_1: write-var gs#135684 <= s_2710_0
        fn_state.gs_135684 = s_2710_0;
        // N s_2710_2: jump b2711
        return block_2711(state, tracer, fn_state);
    }
    fn block_2711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2711_0: read-var gs#135684:u8
        let s_2711_0: bool = fn_state.gs_135684;
        // N s_2711_1: branch s_2711_0 b4220 b2712
        if s_2711_0 {
            return block_4220(state, tracer, fn_state);
        } else {
            return block_2712(state, tracer, fn_state);
        };
    }
    fn block_2712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2712_0: const #0u : u8
        let s_2712_0: bool = false;
        // D s_2712_1: write-var gs#135685 <= s_2712_0
        fn_state.gs_135685 = s_2712_0;
        // N s_2712_2: jump b2713
        return block_2713(state, tracer, fn_state);
    }
    fn block_2713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2713_0: read-var gs#135685:u8
        let s_2713_0: bool = fn_state.gs_135685;
        // N s_2713_1: branch s_2713_0 b4219 b2714
        if s_2713_0 {
            return block_4219(state, tracer, fn_state);
        } else {
            return block_2714(state, tracer, fn_state);
        };
    }
    fn block_2714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2714_0: const #0u : u8
        let s_2714_0: bool = false;
        // D s_2714_1: write-var gs#135686 <= s_2714_0
        fn_state.gs_135686 = s_2714_0;
        // N s_2714_2: jump b2715
        return block_2715(state, tracer, fn_state);
    }
    fn block_2715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2715_0: read-var gs#135686:u8
        let s_2715_0: bool = fn_state.gs_135686;
        // N s_2715_1: branch s_2715_0 b4218 b2716
        if s_2715_0 {
            return block_4218(state, tracer, fn_state);
        } else {
            return block_2716(state, tracer, fn_state);
        };
    }
    fn block_2716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2716_0: const #0u : u8
        let s_2716_0: bool = false;
        // D s_2716_1: write-var gs#135687 <= s_2716_0
        fn_state.gs_135687 = s_2716_0;
        // N s_2716_2: jump b2717
        return block_2717(state, tracer, fn_state);
    }
    fn block_2717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2717_0: read-var gs#135687:u8
        let s_2717_0: bool = fn_state.gs_135687;
        // N s_2717_1: branch s_2717_0 b4217 b2718
        if s_2717_0 {
            return block_4217(state, tracer, fn_state);
        } else {
            return block_2718(state, tracer, fn_state);
        };
    }
    fn block_2718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2718_0: read-var CRm:u8
        let s_2718_0: u8 = fn_state.CRm;
        // D s_2718_1: cast zx s_2718_0 -> bv
        let s_2718_1: Bits = Bits::new(s_2718_0 as u128, 4u16);
        // C s_2718_2: const #13u : u8
        let s_2718_2: u8 = 13;
        // C s_2718_3: cast zx s_2718_2 -> bv
        let s_2718_3: Bits = Bits::new(s_2718_2 as u128, 4u16);
        // D s_2718_4: cmp-eq s_2718_1 s_2718_3
        let s_2718_4: bool = ((s_2718_1) == (s_2718_3));
        // N s_2718_5: branch s_2718_4 b4216 b2719
        if s_2718_4 {
            return block_4216(state, tracer, fn_state);
        } else {
            return block_2719(state, tracer, fn_state);
        };
    }
    fn block_2719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2719_0: const #0u : u8
        let s_2719_0: bool = false;
        // D s_2719_1: write-var gs#135688 <= s_2719_0
        fn_state.gs_135688 = s_2719_0;
        // N s_2719_2: jump b2720
        return block_2720(state, tracer, fn_state);
    }
    fn block_2720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2720_0: read-var gs#135688:u8
        let s_2720_0: bool = fn_state.gs_135688;
        // N s_2720_1: branch s_2720_0 b4215 b2721
        if s_2720_0 {
            return block_4215(state, tracer, fn_state);
        } else {
            return block_2721(state, tracer, fn_state);
        };
    }
    fn block_2721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2721_0: const #0u : u8
        let s_2721_0: bool = false;
        // D s_2721_1: write-var gs#135689 <= s_2721_0
        fn_state.gs_135689 = s_2721_0;
        // N s_2721_2: jump b2722
        return block_2722(state, tracer, fn_state);
    }
    fn block_2722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2722_0: read-var gs#135689:u8
        let s_2722_0: bool = fn_state.gs_135689;
        // N s_2722_1: branch s_2722_0 b4214 b2723
        if s_2722_0 {
            return block_4214(state, tracer, fn_state);
        } else {
            return block_2723(state, tracer, fn_state);
        };
    }
    fn block_2723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2723_0: const #0u : u8
        let s_2723_0: bool = false;
        // D s_2723_1: write-var gs#135690 <= s_2723_0
        fn_state.gs_135690 = s_2723_0;
        // N s_2723_2: jump b2724
        return block_2724(state, tracer, fn_state);
    }
    fn block_2724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2724_0: read-var gs#135690:u8
        let s_2724_0: bool = fn_state.gs_135690;
        // N s_2724_1: branch s_2724_0 b4213 b2725
        if s_2724_0 {
            return block_4213(state, tracer, fn_state);
        } else {
            return block_2725(state, tracer, fn_state);
        };
    }
    fn block_2725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2725_0: const #0u : u8
        let s_2725_0: bool = false;
        // D s_2725_1: write-var gs#135691 <= s_2725_0
        fn_state.gs_135691 = s_2725_0;
        // N s_2725_2: jump b2726
        return block_2726(state, tracer, fn_state);
    }
    fn block_2726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2726_0: read-var gs#135691:u8
        let s_2726_0: bool = fn_state.gs_135691;
        // N s_2726_1: branch s_2726_0 b4212 b2727
        if s_2726_0 {
            return block_4212(state, tracer, fn_state);
        } else {
            return block_2727(state, tracer, fn_state);
        };
    }
    fn block_2727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2727_0: read-var CRm:u8
        let s_2727_0: u8 = fn_state.CRm;
        // D s_2727_1: cast zx s_2727_0 -> bv
        let s_2727_1: Bits = Bits::new(s_2727_0 as u128, 4u16);
        // C s_2727_2: const #13u : u8
        let s_2727_2: u8 = 13;
        // C s_2727_3: cast zx s_2727_2 -> bv
        let s_2727_3: Bits = Bits::new(s_2727_2 as u128, 4u16);
        // D s_2727_4: cmp-eq s_2727_1 s_2727_3
        let s_2727_4: bool = ((s_2727_1) == (s_2727_3));
        // N s_2727_5: branch s_2727_4 b4211 b2728
        if s_2727_4 {
            return block_4211(state, tracer, fn_state);
        } else {
            return block_2728(state, tracer, fn_state);
        };
    }
    fn block_2728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2728_0: const #0u : u8
        let s_2728_0: bool = false;
        // D s_2728_1: write-var gs#135692 <= s_2728_0
        fn_state.gs_135692 = s_2728_0;
        // N s_2728_2: jump b2729
        return block_2729(state, tracer, fn_state);
    }
    fn block_2729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2729_0: read-var gs#135692:u8
        let s_2729_0: bool = fn_state.gs_135692;
        // N s_2729_1: branch s_2729_0 b4210 b2730
        if s_2729_0 {
            return block_4210(state, tracer, fn_state);
        } else {
            return block_2730(state, tracer, fn_state);
        };
    }
    fn block_2730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2730_0: const #0u : u8
        let s_2730_0: bool = false;
        // D s_2730_1: write-var gs#135693 <= s_2730_0
        fn_state.gs_135693 = s_2730_0;
        // N s_2730_2: jump b2731
        return block_2731(state, tracer, fn_state);
    }
    fn block_2731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2731_0: read-var gs#135693:u8
        let s_2731_0: bool = fn_state.gs_135693;
        // N s_2731_1: branch s_2731_0 b4209 b2732
        if s_2731_0 {
            return block_4209(state, tracer, fn_state);
        } else {
            return block_2732(state, tracer, fn_state);
        };
    }
    fn block_2732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2732_0: const #0u : u8
        let s_2732_0: bool = false;
        // D s_2732_1: write-var gs#135694 <= s_2732_0
        fn_state.gs_135694 = s_2732_0;
        // N s_2732_2: jump b2733
        return block_2733(state, tracer, fn_state);
    }
    fn block_2733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2733_0: read-var gs#135694:u8
        let s_2733_0: bool = fn_state.gs_135694;
        // N s_2733_1: branch s_2733_0 b4208 b2734
        if s_2733_0 {
            return block_4208(state, tracer, fn_state);
        } else {
            return block_2734(state, tracer, fn_state);
        };
    }
    fn block_2734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2734_0: const #0u : u8
        let s_2734_0: bool = false;
        // D s_2734_1: write-var gs#135695 <= s_2734_0
        fn_state.gs_135695 = s_2734_0;
        // N s_2734_2: jump b2735
        return block_2735(state, tracer, fn_state);
    }
    fn block_2735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2735_0: read-var gs#135695:u8
        let s_2735_0: bool = fn_state.gs_135695;
        // N s_2735_1: branch s_2735_0 b4207 b2736
        if s_2735_0 {
            return block_4207(state, tracer, fn_state);
        } else {
            return block_2736(state, tracer, fn_state);
        };
    }
    fn block_2736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2736_0: read-var CRm:u8
        let s_2736_0: u8 = fn_state.CRm;
        // D s_2736_1: cast zx s_2736_0 -> bv
        let s_2736_1: Bits = Bits::new(s_2736_0 as u128, 4u16);
        // C s_2736_2: const #13u : u8
        let s_2736_2: u8 = 13;
        // C s_2736_3: cast zx s_2736_2 -> bv
        let s_2736_3: Bits = Bits::new(s_2736_2 as u128, 4u16);
        // D s_2736_4: cmp-eq s_2736_1 s_2736_3
        let s_2736_4: bool = ((s_2736_1) == (s_2736_3));
        // N s_2736_5: branch s_2736_4 b4206 b2737
        if s_2736_4 {
            return block_4206(state, tracer, fn_state);
        } else {
            return block_2737(state, tracer, fn_state);
        };
    }
    fn block_2737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2737_0: const #0u : u8
        let s_2737_0: bool = false;
        // D s_2737_1: write-var gs#135696 <= s_2737_0
        fn_state.gs_135696 = s_2737_0;
        // N s_2737_2: jump b2738
        return block_2738(state, tracer, fn_state);
    }
    fn block_2738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2738_0: read-var gs#135696:u8
        let s_2738_0: bool = fn_state.gs_135696;
        // N s_2738_1: branch s_2738_0 b4205 b2739
        if s_2738_0 {
            return block_4205(state, tracer, fn_state);
        } else {
            return block_2739(state, tracer, fn_state);
        };
    }
    fn block_2739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2739_0: const #0u : u8
        let s_2739_0: bool = false;
        // D s_2739_1: write-var gs#135697 <= s_2739_0
        fn_state.gs_135697 = s_2739_0;
        // N s_2739_2: jump b2740
        return block_2740(state, tracer, fn_state);
    }
    fn block_2740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2740_0: read-var gs#135697:u8
        let s_2740_0: bool = fn_state.gs_135697;
        // N s_2740_1: branch s_2740_0 b4204 b2741
        if s_2740_0 {
            return block_4204(state, tracer, fn_state);
        } else {
            return block_2741(state, tracer, fn_state);
        };
    }
    fn block_2741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2741_0: const #0u : u8
        let s_2741_0: bool = false;
        // D s_2741_1: write-var gs#135698 <= s_2741_0
        fn_state.gs_135698 = s_2741_0;
        // N s_2741_2: jump b2742
        return block_2742(state, tracer, fn_state);
    }
    fn block_2742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2742_0: read-var gs#135698:u8
        let s_2742_0: bool = fn_state.gs_135698;
        // N s_2742_1: branch s_2742_0 b4203 b2743
        if s_2742_0 {
            return block_4203(state, tracer, fn_state);
        } else {
            return block_2743(state, tracer, fn_state);
        };
    }
    fn block_2743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2743_0: const #0u : u8
        let s_2743_0: bool = false;
        // D s_2743_1: write-var gs#135699 <= s_2743_0
        fn_state.gs_135699 = s_2743_0;
        // N s_2743_2: jump b2744
        return block_2744(state, tracer, fn_state);
    }
    fn block_2744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2744_0: read-var gs#135699:u8
        let s_2744_0: bool = fn_state.gs_135699;
        // N s_2744_1: branch s_2744_0 b4202 b2745
        if s_2744_0 {
            return block_4202(state, tracer, fn_state);
        } else {
            return block_2745(state, tracer, fn_state);
        };
    }
    fn block_2745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2745_0: read-var CRm:u8
        let s_2745_0: u8 = fn_state.CRm;
        // D s_2745_1: cast zx s_2745_0 -> bv
        let s_2745_1: Bits = Bits::new(s_2745_0 as u128, 4u16);
        // C s_2745_2: const #13u : u8
        let s_2745_2: u8 = 13;
        // C s_2745_3: cast zx s_2745_2 -> bv
        let s_2745_3: Bits = Bits::new(s_2745_2 as u128, 4u16);
        // D s_2745_4: cmp-eq s_2745_1 s_2745_3
        let s_2745_4: bool = ((s_2745_1) == (s_2745_3));
        // N s_2745_5: branch s_2745_4 b4201 b2746
        if s_2745_4 {
            return block_4201(state, tracer, fn_state);
        } else {
            return block_2746(state, tracer, fn_state);
        };
    }
    fn block_2746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2746_0: const #0u : u8
        let s_2746_0: bool = false;
        // D s_2746_1: write-var gs#135700 <= s_2746_0
        fn_state.gs_135700 = s_2746_0;
        // N s_2746_2: jump b2747
        return block_2747(state, tracer, fn_state);
    }
    fn block_2747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2747_0: read-var gs#135700:u8
        let s_2747_0: bool = fn_state.gs_135700;
        // N s_2747_1: branch s_2747_0 b4200 b2748
        if s_2747_0 {
            return block_4200(state, tracer, fn_state);
        } else {
            return block_2748(state, tracer, fn_state);
        };
    }
    fn block_2748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2748_0: const #0u : u8
        let s_2748_0: bool = false;
        // D s_2748_1: write-var gs#135701 <= s_2748_0
        fn_state.gs_135701 = s_2748_0;
        // N s_2748_2: jump b2749
        return block_2749(state, tracer, fn_state);
    }
    fn block_2749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2749_0: read-var gs#135701:u8
        let s_2749_0: bool = fn_state.gs_135701;
        // N s_2749_1: branch s_2749_0 b4199 b2750
        if s_2749_0 {
            return block_4199(state, tracer, fn_state);
        } else {
            return block_2750(state, tracer, fn_state);
        };
    }
    fn block_2750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2750_0: const #0u : u8
        let s_2750_0: bool = false;
        // D s_2750_1: write-var gs#135702 <= s_2750_0
        fn_state.gs_135702 = s_2750_0;
        // N s_2750_2: jump b2751
        return block_2751(state, tracer, fn_state);
    }
    fn block_2751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2751_0: read-var gs#135702:u8
        let s_2751_0: bool = fn_state.gs_135702;
        // N s_2751_1: branch s_2751_0 b4198 b2752
        if s_2751_0 {
            return block_4198(state, tracer, fn_state);
        } else {
            return block_2752(state, tracer, fn_state);
        };
    }
    fn block_2752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2752_0: const #0u : u8
        let s_2752_0: bool = false;
        // D s_2752_1: write-var gs#135703 <= s_2752_0
        fn_state.gs_135703 = s_2752_0;
        // N s_2752_2: jump b2753
        return block_2753(state, tracer, fn_state);
    }
    fn block_2753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2753_0: read-var gs#135703:u8
        let s_2753_0: bool = fn_state.gs_135703;
        // N s_2753_1: branch s_2753_0 b4197 b2754
        if s_2753_0 {
            return block_4197(state, tracer, fn_state);
        } else {
            return block_2754(state, tracer, fn_state);
        };
    }
    fn block_2754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2754_0: read-var CRm:u8
        let s_2754_0: u8 = fn_state.CRm;
        // D s_2754_1: cast zx s_2754_0 -> bv
        let s_2754_1: Bits = Bits::new(s_2754_0 as u128, 4u16);
        // C s_2754_2: const #12u : u8
        let s_2754_2: u8 = 12;
        // C s_2754_3: cast zx s_2754_2 -> bv
        let s_2754_3: Bits = Bits::new(s_2754_2 as u128, 4u16);
        // D s_2754_4: cmp-eq s_2754_1 s_2754_3
        let s_2754_4: bool = ((s_2754_1) == (s_2754_3));
        // N s_2754_5: branch s_2754_4 b4196 b2755
        if s_2754_4 {
            return block_4196(state, tracer, fn_state);
        } else {
            return block_2755(state, tracer, fn_state);
        };
    }
    fn block_2755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2755_0: const #0u : u8
        let s_2755_0: bool = false;
        // D s_2755_1: write-var gs#135704 <= s_2755_0
        fn_state.gs_135704 = s_2755_0;
        // N s_2755_2: jump b2756
        return block_2756(state, tracer, fn_state);
    }
    fn block_2756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2756_0: read-var gs#135704:u8
        let s_2756_0: bool = fn_state.gs_135704;
        // N s_2756_1: branch s_2756_0 b4195 b2757
        if s_2756_0 {
            return block_4195(state, tracer, fn_state);
        } else {
            return block_2757(state, tracer, fn_state);
        };
    }
    fn block_2757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2757_0: const #0u : u8
        let s_2757_0: bool = false;
        // D s_2757_1: write-var gs#135705 <= s_2757_0
        fn_state.gs_135705 = s_2757_0;
        // N s_2757_2: jump b2758
        return block_2758(state, tracer, fn_state);
    }
    fn block_2758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2758_0: read-var gs#135705:u8
        let s_2758_0: bool = fn_state.gs_135705;
        // N s_2758_1: branch s_2758_0 b4194 b2759
        if s_2758_0 {
            return block_4194(state, tracer, fn_state);
        } else {
            return block_2759(state, tracer, fn_state);
        };
    }
    fn block_2759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2759_0: const #0u : u8
        let s_2759_0: bool = false;
        // D s_2759_1: write-var gs#135706 <= s_2759_0
        fn_state.gs_135706 = s_2759_0;
        // N s_2759_2: jump b2760
        return block_2760(state, tracer, fn_state);
    }
    fn block_2760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2760_0: read-var gs#135706:u8
        let s_2760_0: bool = fn_state.gs_135706;
        // N s_2760_1: branch s_2760_0 b4193 b2761
        if s_2760_0 {
            return block_4193(state, tracer, fn_state);
        } else {
            return block_2761(state, tracer, fn_state);
        };
    }
    fn block_2761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2761_0: const #0u : u8
        let s_2761_0: bool = false;
        // D s_2761_1: write-var gs#135707 <= s_2761_0
        fn_state.gs_135707 = s_2761_0;
        // N s_2761_2: jump b2762
        return block_2762(state, tracer, fn_state);
    }
    fn block_2762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2762_0: read-var gs#135707:u8
        let s_2762_0: bool = fn_state.gs_135707;
        // N s_2762_1: branch s_2762_0 b4192 b2763
        if s_2762_0 {
            return block_4192(state, tracer, fn_state);
        } else {
            return block_2763(state, tracer, fn_state);
        };
    }
    fn block_2763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2763_0: read-var CRm:u8
        let s_2763_0: u8 = fn_state.CRm;
        // D s_2763_1: cast zx s_2763_0 -> bv
        let s_2763_1: Bits = Bits::new(s_2763_0 as u128, 4u16);
        // C s_2763_2: const #12u : u8
        let s_2763_2: u8 = 12;
        // C s_2763_3: cast zx s_2763_2 -> bv
        let s_2763_3: Bits = Bits::new(s_2763_2 as u128, 4u16);
        // D s_2763_4: cmp-eq s_2763_1 s_2763_3
        let s_2763_4: bool = ((s_2763_1) == (s_2763_3));
        // N s_2763_5: branch s_2763_4 b4191 b2764
        if s_2763_4 {
            return block_4191(state, tracer, fn_state);
        } else {
            return block_2764(state, tracer, fn_state);
        };
    }
    fn block_2764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2764_0: const #0u : u8
        let s_2764_0: bool = false;
        // D s_2764_1: write-var gs#135708 <= s_2764_0
        fn_state.gs_135708 = s_2764_0;
        // N s_2764_2: jump b2765
        return block_2765(state, tracer, fn_state);
    }
    fn block_2765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2765_0: read-var gs#135708:u8
        let s_2765_0: bool = fn_state.gs_135708;
        // N s_2765_1: branch s_2765_0 b4190 b2766
        if s_2765_0 {
            return block_4190(state, tracer, fn_state);
        } else {
            return block_2766(state, tracer, fn_state);
        };
    }
    fn block_2766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2766_0: const #0u : u8
        let s_2766_0: bool = false;
        // D s_2766_1: write-var gs#135709 <= s_2766_0
        fn_state.gs_135709 = s_2766_0;
        // N s_2766_2: jump b2767
        return block_2767(state, tracer, fn_state);
    }
    fn block_2767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2767_0: read-var gs#135709:u8
        let s_2767_0: bool = fn_state.gs_135709;
        // N s_2767_1: branch s_2767_0 b4189 b2768
        if s_2767_0 {
            return block_4189(state, tracer, fn_state);
        } else {
            return block_2768(state, tracer, fn_state);
        };
    }
    fn block_2768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2768_0: const #0u : u8
        let s_2768_0: bool = false;
        // D s_2768_1: write-var gs#135710 <= s_2768_0
        fn_state.gs_135710 = s_2768_0;
        // N s_2768_2: jump b2769
        return block_2769(state, tracer, fn_state);
    }
    fn block_2769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2769_0: read-var gs#135710:u8
        let s_2769_0: bool = fn_state.gs_135710;
        // N s_2769_1: branch s_2769_0 b4188 b2770
        if s_2769_0 {
            return block_4188(state, tracer, fn_state);
        } else {
            return block_2770(state, tracer, fn_state);
        };
    }
    fn block_2770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2770_0: const #0u : u8
        let s_2770_0: bool = false;
        // D s_2770_1: write-var gs#135711 <= s_2770_0
        fn_state.gs_135711 = s_2770_0;
        // N s_2770_2: jump b2771
        return block_2771(state, tracer, fn_state);
    }
    fn block_2771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2771_0: read-var gs#135711:u8
        let s_2771_0: bool = fn_state.gs_135711;
        // N s_2771_1: branch s_2771_0 b4187 b2772
        if s_2771_0 {
            return block_4187(state, tracer, fn_state);
        } else {
            return block_2772(state, tracer, fn_state);
        };
    }
    fn block_2772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2772_0: read-var CRm:u8
        let s_2772_0: u8 = fn_state.CRm;
        // D s_2772_1: cast zx s_2772_0 -> bv
        let s_2772_1: Bits = Bits::new(s_2772_0 as u128, 4u16);
        // C s_2772_2: const #12u : u8
        let s_2772_2: u8 = 12;
        // C s_2772_3: cast zx s_2772_2 -> bv
        let s_2772_3: Bits = Bits::new(s_2772_2 as u128, 4u16);
        // D s_2772_4: cmp-eq s_2772_1 s_2772_3
        let s_2772_4: bool = ((s_2772_1) == (s_2772_3));
        // N s_2772_5: branch s_2772_4 b4186 b2773
        if s_2772_4 {
            return block_4186(state, tracer, fn_state);
        } else {
            return block_2773(state, tracer, fn_state);
        };
    }
    fn block_2773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2773_0: const #0u : u8
        let s_2773_0: bool = false;
        // D s_2773_1: write-var gs#135712 <= s_2773_0
        fn_state.gs_135712 = s_2773_0;
        // N s_2773_2: jump b2774
        return block_2774(state, tracer, fn_state);
    }
    fn block_2774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2774_0: read-var gs#135712:u8
        let s_2774_0: bool = fn_state.gs_135712;
        // N s_2774_1: branch s_2774_0 b4185 b2775
        if s_2774_0 {
            return block_4185(state, tracer, fn_state);
        } else {
            return block_2775(state, tracer, fn_state);
        };
    }
    fn block_2775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2775_0: const #0u : u8
        let s_2775_0: bool = false;
        // D s_2775_1: write-var gs#135713 <= s_2775_0
        fn_state.gs_135713 = s_2775_0;
        // N s_2775_2: jump b2776
        return block_2776(state, tracer, fn_state);
    }
    fn block_2776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2776_0: read-var gs#135713:u8
        let s_2776_0: bool = fn_state.gs_135713;
        // N s_2776_1: branch s_2776_0 b4184 b2777
        if s_2776_0 {
            return block_4184(state, tracer, fn_state);
        } else {
            return block_2777(state, tracer, fn_state);
        };
    }
    fn block_2777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2777_0: const #0u : u8
        let s_2777_0: bool = false;
        // D s_2777_1: write-var gs#135714 <= s_2777_0
        fn_state.gs_135714 = s_2777_0;
        // N s_2777_2: jump b2778
        return block_2778(state, tracer, fn_state);
    }
    fn block_2778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2778_0: read-var gs#135714:u8
        let s_2778_0: bool = fn_state.gs_135714;
        // N s_2778_1: branch s_2778_0 b4183 b2779
        if s_2778_0 {
            return block_4183(state, tracer, fn_state);
        } else {
            return block_2779(state, tracer, fn_state);
        };
    }
    fn block_2779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2779_0: const #0u : u8
        let s_2779_0: bool = false;
        // D s_2779_1: write-var gs#135715 <= s_2779_0
        fn_state.gs_135715 = s_2779_0;
        // N s_2779_2: jump b2780
        return block_2780(state, tracer, fn_state);
    }
    fn block_2780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2780_0: read-var gs#135715:u8
        let s_2780_0: bool = fn_state.gs_135715;
        // N s_2780_1: branch s_2780_0 b4182 b2781
        if s_2780_0 {
            return block_4182(state, tracer, fn_state);
        } else {
            return block_2781(state, tracer, fn_state);
        };
    }
    fn block_2781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2781_0: read-var CRm:u8
        let s_2781_0: u8 = fn_state.CRm;
        // D s_2781_1: cast zx s_2781_0 -> bv
        let s_2781_1: Bits = Bits::new(s_2781_0 as u128, 4u16);
        // C s_2781_2: const #12u : u8
        let s_2781_2: u8 = 12;
        // C s_2781_3: cast zx s_2781_2 -> bv
        let s_2781_3: Bits = Bits::new(s_2781_2 as u128, 4u16);
        // D s_2781_4: cmp-eq s_2781_1 s_2781_3
        let s_2781_4: bool = ((s_2781_1) == (s_2781_3));
        // N s_2781_5: branch s_2781_4 b4181 b2782
        if s_2781_4 {
            return block_4181(state, tracer, fn_state);
        } else {
            return block_2782(state, tracer, fn_state);
        };
    }
    fn block_2782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2782_0: const #0u : u8
        let s_2782_0: bool = false;
        // D s_2782_1: write-var gs#135716 <= s_2782_0
        fn_state.gs_135716 = s_2782_0;
        // N s_2782_2: jump b2783
        return block_2783(state, tracer, fn_state);
    }
    fn block_2783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2783_0: read-var gs#135716:u8
        let s_2783_0: bool = fn_state.gs_135716;
        // N s_2783_1: branch s_2783_0 b4180 b2784
        if s_2783_0 {
            return block_4180(state, tracer, fn_state);
        } else {
            return block_2784(state, tracer, fn_state);
        };
    }
    fn block_2784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2784_0: const #0u : u8
        let s_2784_0: bool = false;
        // D s_2784_1: write-var gs#135717 <= s_2784_0
        fn_state.gs_135717 = s_2784_0;
        // N s_2784_2: jump b2785
        return block_2785(state, tracer, fn_state);
    }
    fn block_2785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2785_0: read-var gs#135717:u8
        let s_2785_0: bool = fn_state.gs_135717;
        // N s_2785_1: branch s_2785_0 b4179 b2786
        if s_2785_0 {
            return block_4179(state, tracer, fn_state);
        } else {
            return block_2786(state, tracer, fn_state);
        };
    }
    fn block_2786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2786_0: const #0u : u8
        let s_2786_0: bool = false;
        // D s_2786_1: write-var gs#135718 <= s_2786_0
        fn_state.gs_135718 = s_2786_0;
        // N s_2786_2: jump b2787
        return block_2787(state, tracer, fn_state);
    }
    fn block_2787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2787_0: read-var gs#135718:u8
        let s_2787_0: bool = fn_state.gs_135718;
        // N s_2787_1: branch s_2787_0 b4178 b2788
        if s_2787_0 {
            return block_4178(state, tracer, fn_state);
        } else {
            return block_2788(state, tracer, fn_state);
        };
    }
    fn block_2788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2788_0: const #0u : u8
        let s_2788_0: bool = false;
        // D s_2788_1: write-var gs#135719 <= s_2788_0
        fn_state.gs_135719 = s_2788_0;
        // N s_2788_2: jump b2789
        return block_2789(state, tracer, fn_state);
    }
    fn block_2789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2789_0: read-var gs#135719:u8
        let s_2789_0: bool = fn_state.gs_135719;
        // N s_2789_1: branch s_2789_0 b4177 b2790
        if s_2789_0 {
            return block_4177(state, tracer, fn_state);
        } else {
            return block_2790(state, tracer, fn_state);
        };
    }
    fn block_2790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2790_0: read-var CRm:u8
        let s_2790_0: u8 = fn_state.CRm;
        // D s_2790_1: cast zx s_2790_0 -> bv
        let s_2790_1: Bits = Bits::new(s_2790_0 as u128, 4u16);
        // C s_2790_2: const #12u : u8
        let s_2790_2: u8 = 12;
        // C s_2790_3: cast zx s_2790_2 -> bv
        let s_2790_3: Bits = Bits::new(s_2790_2 as u128, 4u16);
        // D s_2790_4: cmp-eq s_2790_1 s_2790_3
        let s_2790_4: bool = ((s_2790_1) == (s_2790_3));
        // N s_2790_5: branch s_2790_4 b4176 b2791
        if s_2790_4 {
            return block_4176(state, tracer, fn_state);
        } else {
            return block_2791(state, tracer, fn_state);
        };
    }
    fn block_2791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2791_0: const #0u : u8
        let s_2791_0: bool = false;
        // D s_2791_1: write-var gs#135720 <= s_2791_0
        fn_state.gs_135720 = s_2791_0;
        // N s_2791_2: jump b2792
        return block_2792(state, tracer, fn_state);
    }
    fn block_2792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2792_0: read-var gs#135720:u8
        let s_2792_0: bool = fn_state.gs_135720;
        // N s_2792_1: branch s_2792_0 b4175 b2793
        if s_2792_0 {
            return block_4175(state, tracer, fn_state);
        } else {
            return block_2793(state, tracer, fn_state);
        };
    }
    fn block_2793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2793_0: const #0u : u8
        let s_2793_0: bool = false;
        // D s_2793_1: write-var gs#135721 <= s_2793_0
        fn_state.gs_135721 = s_2793_0;
        // N s_2793_2: jump b2794
        return block_2794(state, tracer, fn_state);
    }
    fn block_2794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2794_0: read-var gs#135721:u8
        let s_2794_0: bool = fn_state.gs_135721;
        // N s_2794_1: branch s_2794_0 b4174 b2795
        if s_2794_0 {
            return block_4174(state, tracer, fn_state);
        } else {
            return block_2795(state, tracer, fn_state);
        };
    }
    fn block_2795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2795_0: const #0u : u8
        let s_2795_0: bool = false;
        // D s_2795_1: write-var gs#135722 <= s_2795_0
        fn_state.gs_135722 = s_2795_0;
        // N s_2795_2: jump b2796
        return block_2796(state, tracer, fn_state);
    }
    fn block_2796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2796_0: read-var gs#135722:u8
        let s_2796_0: bool = fn_state.gs_135722;
        // N s_2796_1: branch s_2796_0 b4173 b2797
        if s_2796_0 {
            return block_4173(state, tracer, fn_state);
        } else {
            return block_2797(state, tracer, fn_state);
        };
    }
    fn block_2797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2797_0: const #0u : u8
        let s_2797_0: bool = false;
        // D s_2797_1: write-var gs#135723 <= s_2797_0
        fn_state.gs_135723 = s_2797_0;
        // N s_2797_2: jump b2798
        return block_2798(state, tracer, fn_state);
    }
    fn block_2798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2798_0: read-var gs#135723:u8
        let s_2798_0: bool = fn_state.gs_135723;
        // N s_2798_1: branch s_2798_0 b4172 b2799
        if s_2798_0 {
            return block_4172(state, tracer, fn_state);
        } else {
            return block_2799(state, tracer, fn_state);
        };
    }
    fn block_2799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2799_0: read-var CRm:u8
        let s_2799_0: u8 = fn_state.CRm;
        // D s_2799_1: cast zx s_2799_0 -> bv
        let s_2799_1: Bits = Bits::new(s_2799_0 as u128, 4u16);
        // C s_2799_2: const #12u : u8
        let s_2799_2: u8 = 12;
        // C s_2799_3: cast zx s_2799_2 -> bv
        let s_2799_3: Bits = Bits::new(s_2799_2 as u128, 4u16);
        // D s_2799_4: cmp-eq s_2799_1 s_2799_3
        let s_2799_4: bool = ((s_2799_1) == (s_2799_3));
        // N s_2799_5: branch s_2799_4 b4171 b2800
        if s_2799_4 {
            return block_4171(state, tracer, fn_state);
        } else {
            return block_2800(state, tracer, fn_state);
        };
    }
    fn block_2800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2800_0: const #0u : u8
        let s_2800_0: bool = false;
        // D s_2800_1: write-var gs#135724 <= s_2800_0
        fn_state.gs_135724 = s_2800_0;
        // N s_2800_2: jump b2801
        return block_2801(state, tracer, fn_state);
    }
    fn block_2801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2801_0: read-var gs#135724:u8
        let s_2801_0: bool = fn_state.gs_135724;
        // N s_2801_1: branch s_2801_0 b4170 b2802
        if s_2801_0 {
            return block_4170(state, tracer, fn_state);
        } else {
            return block_2802(state, tracer, fn_state);
        };
    }
    fn block_2802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2802_0: const #0u : u8
        let s_2802_0: bool = false;
        // D s_2802_1: write-var gs#135725 <= s_2802_0
        fn_state.gs_135725 = s_2802_0;
        // N s_2802_2: jump b2803
        return block_2803(state, tracer, fn_state);
    }
    fn block_2803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2803_0: read-var gs#135725:u8
        let s_2803_0: bool = fn_state.gs_135725;
        // N s_2803_1: branch s_2803_0 b4169 b2804
        if s_2803_0 {
            return block_4169(state, tracer, fn_state);
        } else {
            return block_2804(state, tracer, fn_state);
        };
    }
    fn block_2804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2804_0: const #0u : u8
        let s_2804_0: bool = false;
        // D s_2804_1: write-var gs#135726 <= s_2804_0
        fn_state.gs_135726 = s_2804_0;
        // N s_2804_2: jump b2805
        return block_2805(state, tracer, fn_state);
    }
    fn block_2805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2805_0: read-var gs#135726:u8
        let s_2805_0: bool = fn_state.gs_135726;
        // N s_2805_1: branch s_2805_0 b4168 b2806
        if s_2805_0 {
            return block_4168(state, tracer, fn_state);
        } else {
            return block_2806(state, tracer, fn_state);
        };
    }
    fn block_2806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2806_0: const #0u : u8
        let s_2806_0: bool = false;
        // D s_2806_1: write-var gs#135727 <= s_2806_0
        fn_state.gs_135727 = s_2806_0;
        // N s_2806_2: jump b2807
        return block_2807(state, tracer, fn_state);
    }
    fn block_2807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2807_0: read-var gs#135727:u8
        let s_2807_0: bool = fn_state.gs_135727;
        // N s_2807_1: branch s_2807_0 b4167 b2808
        if s_2807_0 {
            return block_4167(state, tracer, fn_state);
        } else {
            return block_2808(state, tracer, fn_state);
        };
    }
    fn block_2808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2808_0: read-var CRm:u8
        let s_2808_0: u8 = fn_state.CRm;
        // D s_2808_1: cast zx s_2808_0 -> bv
        let s_2808_1: Bits = Bits::new(s_2808_0 as u128, 4u16);
        // C s_2808_2: const #12u : u8
        let s_2808_2: u8 = 12;
        // C s_2808_3: cast zx s_2808_2 -> bv
        let s_2808_3: Bits = Bits::new(s_2808_2 as u128, 4u16);
        // D s_2808_4: cmp-eq s_2808_1 s_2808_3
        let s_2808_4: bool = ((s_2808_1) == (s_2808_3));
        // N s_2808_5: branch s_2808_4 b4166 b2809
        if s_2808_4 {
            return block_4166(state, tracer, fn_state);
        } else {
            return block_2809(state, tracer, fn_state);
        };
    }
    fn block_2809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2809_0: const #0u : u8
        let s_2809_0: bool = false;
        // D s_2809_1: write-var gs#135728 <= s_2809_0
        fn_state.gs_135728 = s_2809_0;
        // N s_2809_2: jump b2810
        return block_2810(state, tracer, fn_state);
    }
    fn block_2810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2810_0: read-var gs#135728:u8
        let s_2810_0: bool = fn_state.gs_135728;
        // N s_2810_1: branch s_2810_0 b4165 b2811
        if s_2810_0 {
            return block_4165(state, tracer, fn_state);
        } else {
            return block_2811(state, tracer, fn_state);
        };
    }
    fn block_2811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2811_0: const #0u : u8
        let s_2811_0: bool = false;
        // D s_2811_1: write-var gs#135729 <= s_2811_0
        fn_state.gs_135729 = s_2811_0;
        // N s_2811_2: jump b2812
        return block_2812(state, tracer, fn_state);
    }
    fn block_2812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2812_0: read-var gs#135729:u8
        let s_2812_0: bool = fn_state.gs_135729;
        // N s_2812_1: branch s_2812_0 b4164 b2813
        if s_2812_0 {
            return block_4164(state, tracer, fn_state);
        } else {
            return block_2813(state, tracer, fn_state);
        };
    }
    fn block_2813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2813_0: const #0u : u8
        let s_2813_0: bool = false;
        // D s_2813_1: write-var gs#135730 <= s_2813_0
        fn_state.gs_135730 = s_2813_0;
        // N s_2813_2: jump b2814
        return block_2814(state, tracer, fn_state);
    }
    fn block_2814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2814_0: read-var gs#135730:u8
        let s_2814_0: bool = fn_state.gs_135730;
        // N s_2814_1: branch s_2814_0 b4163 b2815
        if s_2814_0 {
            return block_4163(state, tracer, fn_state);
        } else {
            return block_2815(state, tracer, fn_state);
        };
    }
    fn block_2815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2815_0: const #0u : u8
        let s_2815_0: bool = false;
        // D s_2815_1: write-var gs#135731 <= s_2815_0
        fn_state.gs_135731 = s_2815_0;
        // N s_2815_2: jump b2816
        return block_2816(state, tracer, fn_state);
    }
    fn block_2816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2816_0: read-var gs#135731:u8
        let s_2816_0: bool = fn_state.gs_135731;
        // N s_2816_1: branch s_2816_0 b4162 b2817
        if s_2816_0 {
            return block_4162(state, tracer, fn_state);
        } else {
            return block_2817(state, tracer, fn_state);
        };
    }
    fn block_2817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2817_0: read-var CRm:u8
        let s_2817_0: u8 = fn_state.CRm;
        // D s_2817_1: cast zx s_2817_0 -> bv
        let s_2817_1: Bits = Bits::new(s_2817_0 as u128, 4u16);
        // C s_2817_2: const #12u : u8
        let s_2817_2: u8 = 12;
        // C s_2817_3: cast zx s_2817_2 -> bv
        let s_2817_3: Bits = Bits::new(s_2817_2 as u128, 4u16);
        // D s_2817_4: cmp-eq s_2817_1 s_2817_3
        let s_2817_4: bool = ((s_2817_1) == (s_2817_3));
        // N s_2817_5: branch s_2817_4 b4161 b2818
        if s_2817_4 {
            return block_4161(state, tracer, fn_state);
        } else {
            return block_2818(state, tracer, fn_state);
        };
    }
    fn block_2818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2818_0: const #0u : u8
        let s_2818_0: bool = false;
        // D s_2818_1: write-var gs#135732 <= s_2818_0
        fn_state.gs_135732 = s_2818_0;
        // N s_2818_2: jump b2819
        return block_2819(state, tracer, fn_state);
    }
    fn block_2819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2819_0: read-var gs#135732:u8
        let s_2819_0: bool = fn_state.gs_135732;
        // N s_2819_1: branch s_2819_0 b4160 b2820
        if s_2819_0 {
            return block_4160(state, tracer, fn_state);
        } else {
            return block_2820(state, tracer, fn_state);
        };
    }
    fn block_2820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2820_0: const #0u : u8
        let s_2820_0: bool = false;
        // D s_2820_1: write-var gs#135733 <= s_2820_0
        fn_state.gs_135733 = s_2820_0;
        // N s_2820_2: jump b2821
        return block_2821(state, tracer, fn_state);
    }
    fn block_2821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2821_0: read-var gs#135733:u8
        let s_2821_0: bool = fn_state.gs_135733;
        // N s_2821_1: branch s_2821_0 b4159 b2822
        if s_2821_0 {
            return block_4159(state, tracer, fn_state);
        } else {
            return block_2822(state, tracer, fn_state);
        };
    }
    fn block_2822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2822_0: const #0u : u8
        let s_2822_0: bool = false;
        // D s_2822_1: write-var gs#135734 <= s_2822_0
        fn_state.gs_135734 = s_2822_0;
        // N s_2822_2: jump b2823
        return block_2823(state, tracer, fn_state);
    }
    fn block_2823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2823_0: read-var gs#135734:u8
        let s_2823_0: bool = fn_state.gs_135734;
        // N s_2823_1: branch s_2823_0 b4158 b2824
        if s_2823_0 {
            return block_4158(state, tracer, fn_state);
        } else {
            return block_2824(state, tracer, fn_state);
        };
    }
    fn block_2824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2824_0: const #0u : u8
        let s_2824_0: bool = false;
        // D s_2824_1: write-var gs#135735 <= s_2824_0
        fn_state.gs_135735 = s_2824_0;
        // N s_2824_2: jump b2825
        return block_2825(state, tracer, fn_state);
    }
    fn block_2825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2825_0: read-var gs#135735:u8
        let s_2825_0: bool = fn_state.gs_135735;
        // N s_2825_1: branch s_2825_0 b4157 b2826
        if s_2825_0 {
            return block_4157(state, tracer, fn_state);
        } else {
            return block_2826(state, tracer, fn_state);
        };
    }
    fn block_2826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2826_0: read-var CRm:u8
        let s_2826_0: u8 = fn_state.CRm;
        // D s_2826_1: cast zx s_2826_0 -> bv
        let s_2826_1: Bits = Bits::new(s_2826_0 as u128, 4u16);
        // C s_2826_2: const #0u : u8
        let s_2826_2: u8 = 0;
        // C s_2826_3: cast zx s_2826_2 -> bv
        let s_2826_3: Bits = Bits::new(s_2826_2 as u128, 4u16);
        // D s_2826_4: cmp-eq s_2826_1 s_2826_3
        let s_2826_4: bool = ((s_2826_1) == (s_2826_3));
        // N s_2826_5: branch s_2826_4 b4156 b2827
        if s_2826_4 {
            return block_4156(state, tracer, fn_state);
        } else {
            return block_2827(state, tracer, fn_state);
        };
    }
    fn block_2827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2827_0: const #0u : u8
        let s_2827_0: bool = false;
        // D s_2827_1: write-var gs#135736 <= s_2827_0
        fn_state.gs_135736 = s_2827_0;
        // N s_2827_2: jump b2828
        return block_2828(state, tracer, fn_state);
    }
    fn block_2828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2828_0: read-var gs#135736:u8
        let s_2828_0: bool = fn_state.gs_135736;
        // N s_2828_1: branch s_2828_0 b4155 b2829
        if s_2828_0 {
            return block_4155(state, tracer, fn_state);
        } else {
            return block_2829(state, tracer, fn_state);
        };
    }
    fn block_2829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2829_0: const #0u : u8
        let s_2829_0: bool = false;
        // D s_2829_1: write-var gs#135737 <= s_2829_0
        fn_state.gs_135737 = s_2829_0;
        // N s_2829_2: jump b2830
        return block_2830(state, tracer, fn_state);
    }
    fn block_2830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2830_0: read-var gs#135737:u8
        let s_2830_0: bool = fn_state.gs_135737;
        // N s_2830_1: branch s_2830_0 b4154 b2831
        if s_2830_0 {
            return block_4154(state, tracer, fn_state);
        } else {
            return block_2831(state, tracer, fn_state);
        };
    }
    fn block_2831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2831_0: const #0u : u8
        let s_2831_0: bool = false;
        // D s_2831_1: write-var gs#135738 <= s_2831_0
        fn_state.gs_135738 = s_2831_0;
        // N s_2831_2: jump b2832
        return block_2832(state, tracer, fn_state);
    }
    fn block_2832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2832_0: read-var gs#135738:u8
        let s_2832_0: bool = fn_state.gs_135738;
        // N s_2832_1: branch s_2832_0 b4153 b2833
        if s_2832_0 {
            return block_4153(state, tracer, fn_state);
        } else {
            return block_2833(state, tracer, fn_state);
        };
    }
    fn block_2833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2833_0: const #0u : u8
        let s_2833_0: bool = false;
        // D s_2833_1: write-var gs#135739 <= s_2833_0
        fn_state.gs_135739 = s_2833_0;
        // N s_2833_2: jump b2834
        return block_2834(state, tracer, fn_state);
    }
    fn block_2834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2834_0: read-var gs#135739:u8
        let s_2834_0: bool = fn_state.gs_135739;
        // N s_2834_1: branch s_2834_0 b4152 b2835
        if s_2834_0 {
            return block_4152(state, tracer, fn_state);
        } else {
            return block_2835(state, tracer, fn_state);
        };
    }
    fn block_2835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2835_0: read-var CRm:u8
        let s_2835_0: u8 = fn_state.CRm;
        // D s_2835_1: cast zx s_2835_0 -> bv
        let s_2835_1: Bits = Bits::new(s_2835_0 as u128, 4u16);
        // C s_2835_2: const #0u : u8
        let s_2835_2: u8 = 0;
        // C s_2835_3: cast zx s_2835_2 -> bv
        let s_2835_3: Bits = Bits::new(s_2835_2 as u128, 4u16);
        // D s_2835_4: cmp-eq s_2835_1 s_2835_3
        let s_2835_4: bool = ((s_2835_1) == (s_2835_3));
        // N s_2835_5: branch s_2835_4 b4151 b2836
        if s_2835_4 {
            return block_4151(state, tracer, fn_state);
        } else {
            return block_2836(state, tracer, fn_state);
        };
    }
    fn block_2836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2836_0: const #0u : u8
        let s_2836_0: bool = false;
        // D s_2836_1: write-var gs#135740 <= s_2836_0
        fn_state.gs_135740 = s_2836_0;
        // N s_2836_2: jump b2837
        return block_2837(state, tracer, fn_state);
    }
    fn block_2837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2837_0: read-var gs#135740:u8
        let s_2837_0: bool = fn_state.gs_135740;
        // N s_2837_1: branch s_2837_0 b4150 b2838
        if s_2837_0 {
            return block_4150(state, tracer, fn_state);
        } else {
            return block_2838(state, tracer, fn_state);
        };
    }
    fn block_2838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2838_0: const #0u : u8
        let s_2838_0: bool = false;
        // D s_2838_1: write-var gs#135741 <= s_2838_0
        fn_state.gs_135741 = s_2838_0;
        // N s_2838_2: jump b2839
        return block_2839(state, tracer, fn_state);
    }
    fn block_2839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2839_0: read-var gs#135741:u8
        let s_2839_0: bool = fn_state.gs_135741;
        // N s_2839_1: branch s_2839_0 b4149 b2840
        if s_2839_0 {
            return block_4149(state, tracer, fn_state);
        } else {
            return block_2840(state, tracer, fn_state);
        };
    }
    fn block_2840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2840_0: const #0u : u8
        let s_2840_0: bool = false;
        // D s_2840_1: write-var gs#135742 <= s_2840_0
        fn_state.gs_135742 = s_2840_0;
        // N s_2840_2: jump b2841
        return block_2841(state, tracer, fn_state);
    }
    fn block_2841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2841_0: read-var gs#135742:u8
        let s_2841_0: bool = fn_state.gs_135742;
        // N s_2841_1: branch s_2841_0 b4148 b2842
        if s_2841_0 {
            return block_4148(state, tracer, fn_state);
        } else {
            return block_2842(state, tracer, fn_state);
        };
    }
    fn block_2842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2842_0: const #0u : u8
        let s_2842_0: bool = false;
        // D s_2842_1: write-var gs#135743 <= s_2842_0
        fn_state.gs_135743 = s_2842_0;
        // N s_2842_2: jump b2843
        return block_2843(state, tracer, fn_state);
    }
    fn block_2843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2843_0: read-var gs#135743:u8
        let s_2843_0: bool = fn_state.gs_135743;
        // N s_2843_1: branch s_2843_0 b4147 b2844
        if s_2843_0 {
            return block_4147(state, tracer, fn_state);
        } else {
            return block_2844(state, tracer, fn_state);
        };
    }
    fn block_2844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2844_0: read-var CRm:u8
        let s_2844_0: u8 = fn_state.CRm;
        // D s_2844_1: cast zx s_2844_0 -> bv
        let s_2844_1: Bits = Bits::new(s_2844_0 as u128, 4u16);
        // C s_2844_2: const #14u : u8
        let s_2844_2: u8 = 14;
        // C s_2844_3: cast zx s_2844_2 -> bv
        let s_2844_3: Bits = Bits::new(s_2844_2 as u128, 4u16);
        // D s_2844_4: cmp-eq s_2844_1 s_2844_3
        let s_2844_4: bool = ((s_2844_1) == (s_2844_3));
        // N s_2844_5: branch s_2844_4 b4146 b2845
        if s_2844_4 {
            return block_4146(state, tracer, fn_state);
        } else {
            return block_2845(state, tracer, fn_state);
        };
    }
    fn block_2845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2845_0: const #0u : u8
        let s_2845_0: bool = false;
        // D s_2845_1: write-var gs#135744 <= s_2845_0
        fn_state.gs_135744 = s_2845_0;
        // N s_2845_2: jump b2846
        return block_2846(state, tracer, fn_state);
    }
    fn block_2846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2846_0: read-var gs#135744:u8
        let s_2846_0: bool = fn_state.gs_135744;
        // N s_2846_1: branch s_2846_0 b4145 b2847
        if s_2846_0 {
            return block_4145(state, tracer, fn_state);
        } else {
            return block_2847(state, tracer, fn_state);
        };
    }
    fn block_2847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2847_0: const #0u : u8
        let s_2847_0: bool = false;
        // D s_2847_1: write-var gs#135745 <= s_2847_0
        fn_state.gs_135745 = s_2847_0;
        // N s_2847_2: jump b2848
        return block_2848(state, tracer, fn_state);
    }
    fn block_2848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2848_0: read-var gs#135745:u8
        let s_2848_0: bool = fn_state.gs_135745;
        // N s_2848_1: branch s_2848_0 b4144 b2849
        if s_2848_0 {
            return block_4144(state, tracer, fn_state);
        } else {
            return block_2849(state, tracer, fn_state);
        };
    }
    fn block_2849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2849_0: const #0u : u8
        let s_2849_0: bool = false;
        // D s_2849_1: write-var gs#135746 <= s_2849_0
        fn_state.gs_135746 = s_2849_0;
        // N s_2849_2: jump b2850
        return block_2850(state, tracer, fn_state);
    }
    fn block_2850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2850_0: read-var gs#135746:u8
        let s_2850_0: bool = fn_state.gs_135746;
        // N s_2850_1: branch s_2850_0 b4143 b2851
        if s_2850_0 {
            return block_4143(state, tracer, fn_state);
        } else {
            return block_2851(state, tracer, fn_state);
        };
    }
    fn block_2851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2851_0: const #0u : u8
        let s_2851_0: bool = false;
        // D s_2851_1: write-var gs#135747 <= s_2851_0
        fn_state.gs_135747 = s_2851_0;
        // N s_2851_2: jump b2852
        return block_2852(state, tracer, fn_state);
    }
    fn block_2852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2852_0: read-var gs#135747:u8
        let s_2852_0: bool = fn_state.gs_135747;
        // N s_2852_1: branch s_2852_0 b4142 b2853
        if s_2852_0 {
            return block_4142(state, tracer, fn_state);
        } else {
            return block_2853(state, tracer, fn_state);
        };
    }
    fn block_2853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2853_0: read-var CRm:u8
        let s_2853_0: u8 = fn_state.CRm;
        // D s_2853_1: cast zx s_2853_0 -> bv
        let s_2853_1: Bits = Bits::new(s_2853_0 as u128, 4u16);
        // C s_2853_2: const #3u : u8
        let s_2853_2: u8 = 3;
        // C s_2853_3: cast zx s_2853_2 -> bv
        let s_2853_3: Bits = Bits::new(s_2853_2 as u128, 4u16);
        // D s_2853_4: cmp-eq s_2853_1 s_2853_3
        let s_2853_4: bool = ((s_2853_1) == (s_2853_3));
        // N s_2853_5: branch s_2853_4 b4141 b2854
        if s_2853_4 {
            return block_4141(state, tracer, fn_state);
        } else {
            return block_2854(state, tracer, fn_state);
        };
    }
    fn block_2854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2854_0: const #0u : u8
        let s_2854_0: bool = false;
        // D s_2854_1: write-var gs#135748 <= s_2854_0
        fn_state.gs_135748 = s_2854_0;
        // N s_2854_2: jump b2855
        return block_2855(state, tracer, fn_state);
    }
    fn block_2855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2855_0: read-var gs#135748:u8
        let s_2855_0: bool = fn_state.gs_135748;
        // N s_2855_1: branch s_2855_0 b4140 b2856
        if s_2855_0 {
            return block_4140(state, tracer, fn_state);
        } else {
            return block_2856(state, tracer, fn_state);
        };
    }
    fn block_2856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2856_0: const #0u : u8
        let s_2856_0: bool = false;
        // D s_2856_1: write-var gs#135749 <= s_2856_0
        fn_state.gs_135749 = s_2856_0;
        // N s_2856_2: jump b2857
        return block_2857(state, tracer, fn_state);
    }
    fn block_2857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2857_0: read-var gs#135749:u8
        let s_2857_0: bool = fn_state.gs_135749;
        // N s_2857_1: branch s_2857_0 b4139 b2858
        if s_2857_0 {
            return block_4139(state, tracer, fn_state);
        } else {
            return block_2858(state, tracer, fn_state);
        };
    }
    fn block_2858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2858_0: const #0u : u8
        let s_2858_0: bool = false;
        // D s_2858_1: write-var gs#135750 <= s_2858_0
        fn_state.gs_135750 = s_2858_0;
        // N s_2858_2: jump b2859
        return block_2859(state, tracer, fn_state);
    }
    fn block_2859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2859_0: read-var gs#135750:u8
        let s_2859_0: bool = fn_state.gs_135750;
        // N s_2859_1: branch s_2859_0 b4138 b2860
        if s_2859_0 {
            return block_4138(state, tracer, fn_state);
        } else {
            return block_2860(state, tracer, fn_state);
        };
    }
    fn block_2860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2860_0: const #0u : u8
        let s_2860_0: bool = false;
        // D s_2860_1: write-var gs#135751 <= s_2860_0
        fn_state.gs_135751 = s_2860_0;
        // N s_2860_2: jump b2861
        return block_2861(state, tracer, fn_state);
    }
    fn block_2861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2861_0: read-var gs#135751:u8
        let s_2861_0: bool = fn_state.gs_135751;
        // N s_2861_1: branch s_2861_0 b4137 b2862
        if s_2861_0 {
            return block_4137(state, tracer, fn_state);
        } else {
            return block_2862(state, tracer, fn_state);
        };
    }
    fn block_2862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2862_0: read-var CRm:u8
        let s_2862_0: u8 = fn_state.CRm;
        // D s_2862_1: cast zx s_2862_0 -> bv
        let s_2862_1: Bits = Bits::new(s_2862_0 as u128, 4u16);
        // C s_2862_2: const #0u : u8
        let s_2862_2: u8 = 0;
        // C s_2862_3: cast zx s_2862_2 -> bv
        let s_2862_3: Bits = Bits::new(s_2862_2 as u128, 4u16);
        // D s_2862_4: cmp-eq s_2862_1 s_2862_3
        let s_2862_4: bool = ((s_2862_1) == (s_2862_3));
        // N s_2862_5: branch s_2862_4 b4136 b2863
        if s_2862_4 {
            return block_4136(state, tracer, fn_state);
        } else {
            return block_2863(state, tracer, fn_state);
        };
    }
    fn block_2863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2863_0: const #0u : u8
        let s_2863_0: bool = false;
        // D s_2863_1: write-var gs#135752 <= s_2863_0
        fn_state.gs_135752 = s_2863_0;
        // N s_2863_2: jump b2864
        return block_2864(state, tracer, fn_state);
    }
    fn block_2864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2864_0: read-var gs#135752:u8
        let s_2864_0: bool = fn_state.gs_135752;
        // N s_2864_1: branch s_2864_0 b4135 b2865
        if s_2864_0 {
            return block_4135(state, tracer, fn_state);
        } else {
            return block_2865(state, tracer, fn_state);
        };
    }
    fn block_2865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2865_0: const #0u : u8
        let s_2865_0: bool = false;
        // D s_2865_1: write-var gs#135753 <= s_2865_0
        fn_state.gs_135753 = s_2865_0;
        // N s_2865_2: jump b2866
        return block_2866(state, tracer, fn_state);
    }
    fn block_2866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2866_0: read-var gs#135753:u8
        let s_2866_0: bool = fn_state.gs_135753;
        // N s_2866_1: branch s_2866_0 b4134 b2867
        if s_2866_0 {
            return block_4134(state, tracer, fn_state);
        } else {
            return block_2867(state, tracer, fn_state);
        };
    }
    fn block_2867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2867_0: const #0u : u8
        let s_2867_0: bool = false;
        // D s_2867_1: write-var gs#135754 <= s_2867_0
        fn_state.gs_135754 = s_2867_0;
        // N s_2867_2: jump b2868
        return block_2868(state, tracer, fn_state);
    }
    fn block_2868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2868_0: read-var gs#135754:u8
        let s_2868_0: bool = fn_state.gs_135754;
        // N s_2868_1: branch s_2868_0 b4133 b2869
        if s_2868_0 {
            return block_4133(state, tracer, fn_state);
        } else {
            return block_2869(state, tracer, fn_state);
        };
    }
    fn block_2869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2869_0: const #0u : u8
        let s_2869_0: bool = false;
        // D s_2869_1: write-var gs#135755 <= s_2869_0
        fn_state.gs_135755 = s_2869_0;
        // N s_2869_2: jump b2870
        return block_2870(state, tracer, fn_state);
    }
    fn block_2870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2870_0: read-var gs#135755:u8
        let s_2870_0: bool = fn_state.gs_135755;
        // N s_2870_1: branch s_2870_0 b4132 b2871
        if s_2870_0 {
            return block_4132(state, tracer, fn_state);
        } else {
            return block_2871(state, tracer, fn_state);
        };
    }
    fn block_2871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2871_0: read-var CRm:u8
        let s_2871_0: u8 = fn_state.CRm;
        // D s_2871_1: cast zx s_2871_0 -> bv
        let s_2871_1: Bits = Bits::new(s_2871_0 as u128, 4u16);
        // C s_2871_2: const #12u : u8
        let s_2871_2: u8 = 12;
        // C s_2871_3: cast zx s_2871_2 -> bv
        let s_2871_3: Bits = Bits::new(s_2871_2 as u128, 4u16);
        // D s_2871_4: cmp-eq s_2871_1 s_2871_3
        let s_2871_4: bool = ((s_2871_1) == (s_2871_3));
        // N s_2871_5: branch s_2871_4 b4131 b2872
        if s_2871_4 {
            return block_4131(state, tracer, fn_state);
        } else {
            return block_2872(state, tracer, fn_state);
        };
    }
    fn block_2872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2872_0: const #0u : u8
        let s_2872_0: bool = false;
        // D s_2872_1: write-var gs#135756 <= s_2872_0
        fn_state.gs_135756 = s_2872_0;
        // N s_2872_2: jump b2873
        return block_2873(state, tracer, fn_state);
    }
    fn block_2873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2873_0: read-var gs#135756:u8
        let s_2873_0: bool = fn_state.gs_135756;
        // N s_2873_1: branch s_2873_0 b4130 b2874
        if s_2873_0 {
            return block_4130(state, tracer, fn_state);
        } else {
            return block_2874(state, tracer, fn_state);
        };
    }
    fn block_2874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2874_0: const #0u : u8
        let s_2874_0: bool = false;
        // D s_2874_1: write-var gs#135757 <= s_2874_0
        fn_state.gs_135757 = s_2874_0;
        // N s_2874_2: jump b2875
        return block_2875(state, tracer, fn_state);
    }
    fn block_2875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2875_0: read-var gs#135757:u8
        let s_2875_0: bool = fn_state.gs_135757;
        // N s_2875_1: branch s_2875_0 b4129 b2876
        if s_2875_0 {
            return block_4129(state, tracer, fn_state);
        } else {
            return block_2876(state, tracer, fn_state);
        };
    }
    fn block_2876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2876_0: const #0u : u8
        let s_2876_0: bool = false;
        // D s_2876_1: write-var gs#135758 <= s_2876_0
        fn_state.gs_135758 = s_2876_0;
        // N s_2876_2: jump b2877
        return block_2877(state, tracer, fn_state);
    }
    fn block_2877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2877_0: read-var gs#135758:u8
        let s_2877_0: bool = fn_state.gs_135758;
        // N s_2877_1: branch s_2877_0 b4128 b2878
        if s_2877_0 {
            return block_4128(state, tracer, fn_state);
        } else {
            return block_2878(state, tracer, fn_state);
        };
    }
    fn block_2878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2878_0: const #0u : u8
        let s_2878_0: bool = false;
        // D s_2878_1: write-var gs#135759 <= s_2878_0
        fn_state.gs_135759 = s_2878_0;
        // N s_2878_2: jump b2879
        return block_2879(state, tracer, fn_state);
    }
    fn block_2879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2879_0: read-var gs#135759:u8
        let s_2879_0: bool = fn_state.gs_135759;
        // N s_2879_1: branch s_2879_0 b4127 b2880
        if s_2879_0 {
            return block_4127(state, tracer, fn_state);
        } else {
            return block_2880(state, tracer, fn_state);
        };
    }
    fn block_2880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2880_0: read-var CRm:u8
        let s_2880_0: u8 = fn_state.CRm;
        // D s_2880_1: cast zx s_2880_0 -> bv
        let s_2880_1: Bits = Bits::new(s_2880_0 as u128, 4u16);
        // C s_2880_2: const #8u : u8
        let s_2880_2: u8 = 8;
        // C s_2880_3: cast zx s_2880_2 -> bv
        let s_2880_3: Bits = Bits::new(s_2880_2 as u128, 4u16);
        // D s_2880_4: cmp-eq s_2880_1 s_2880_3
        let s_2880_4: bool = ((s_2880_1) == (s_2880_3));
        // N s_2880_5: branch s_2880_4 b4126 b2881
        if s_2880_4 {
            return block_4126(state, tracer, fn_state);
        } else {
            return block_2881(state, tracer, fn_state);
        };
    }
    fn block_2881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2881_0: const #0u : u8
        let s_2881_0: bool = false;
        // D s_2881_1: write-var gs#135760 <= s_2881_0
        fn_state.gs_135760 = s_2881_0;
        // N s_2881_2: jump b2882
        return block_2882(state, tracer, fn_state);
    }
    fn block_2882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2882_0: read-var gs#135760:u8
        let s_2882_0: bool = fn_state.gs_135760;
        // N s_2882_1: branch s_2882_0 b4125 b2883
        if s_2882_0 {
            return block_4125(state, tracer, fn_state);
        } else {
            return block_2883(state, tracer, fn_state);
        };
    }
    fn block_2883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2883_0: const #0u : u8
        let s_2883_0: bool = false;
        // D s_2883_1: write-var gs#135761 <= s_2883_0
        fn_state.gs_135761 = s_2883_0;
        // N s_2883_2: jump b2884
        return block_2884(state, tracer, fn_state);
    }
    fn block_2884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2884_0: read-var gs#135761:u8
        let s_2884_0: bool = fn_state.gs_135761;
        // N s_2884_1: branch s_2884_0 b4124 b2885
        if s_2884_0 {
            return block_4124(state, tracer, fn_state);
        } else {
            return block_2885(state, tracer, fn_state);
        };
    }
    fn block_2885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2885_0: const #0u : u8
        let s_2885_0: bool = false;
        // D s_2885_1: write-var gs#135762 <= s_2885_0
        fn_state.gs_135762 = s_2885_0;
        // N s_2885_2: jump b2886
        return block_2886(state, tracer, fn_state);
    }
    fn block_2886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2886_0: read-var gs#135762:u8
        let s_2886_0: bool = fn_state.gs_135762;
        // N s_2886_1: branch s_2886_0 b4123 b2887
        if s_2886_0 {
            return block_4123(state, tracer, fn_state);
        } else {
            return block_2887(state, tracer, fn_state);
        };
    }
    fn block_2887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2887_0: const #0u : u8
        let s_2887_0: bool = false;
        // D s_2887_1: write-var gs#135763 <= s_2887_0
        fn_state.gs_135763 = s_2887_0;
        // N s_2887_2: jump b2888
        return block_2888(state, tracer, fn_state);
    }
    fn block_2888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2888_0: read-var gs#135763:u8
        let s_2888_0: bool = fn_state.gs_135763;
        // N s_2888_1: branch s_2888_0 b4122 b2889
        if s_2888_0 {
            return block_4122(state, tracer, fn_state);
        } else {
            return block_2889(state, tracer, fn_state);
        };
    }
    fn block_2889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2889_0: read-var CRm:u8
        let s_2889_0: u8 = fn_state.CRm;
        // D s_2889_1: cast zx s_2889_0 -> bv
        let s_2889_1: Bits = Bits::new(s_2889_0 as u128, 4u16);
        // C s_2889_2: const #5u : u8
        let s_2889_2: u8 = 5;
        // C s_2889_3: cast zx s_2889_2 -> bv
        let s_2889_3: Bits = Bits::new(s_2889_2 as u128, 4u16);
        // D s_2889_4: cmp-eq s_2889_1 s_2889_3
        let s_2889_4: bool = ((s_2889_1) == (s_2889_3));
        // N s_2889_5: branch s_2889_4 b4121 b2890
        if s_2889_4 {
            return block_4121(state, tracer, fn_state);
        } else {
            return block_2890(state, tracer, fn_state);
        };
    }
    fn block_2890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2890_0: const #0u : u8
        let s_2890_0: bool = false;
        // D s_2890_1: write-var gs#135764 <= s_2890_0
        fn_state.gs_135764 = s_2890_0;
        // N s_2890_2: jump b2891
        return block_2891(state, tracer, fn_state);
    }
    fn block_2891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2891_0: read-var gs#135764:u8
        let s_2891_0: bool = fn_state.gs_135764;
        // N s_2891_1: branch s_2891_0 b4120 b2892
        if s_2891_0 {
            return block_4120(state, tracer, fn_state);
        } else {
            return block_2892(state, tracer, fn_state);
        };
    }
    fn block_2892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2892_0: const #0u : u8
        let s_2892_0: bool = false;
        // D s_2892_1: write-var gs#135765 <= s_2892_0
        fn_state.gs_135765 = s_2892_0;
        // N s_2892_2: jump b2893
        return block_2893(state, tracer, fn_state);
    }
    fn block_2893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2893_0: read-var gs#135765:u8
        let s_2893_0: bool = fn_state.gs_135765;
        // N s_2893_1: branch s_2893_0 b4119 b2894
        if s_2893_0 {
            return block_4119(state, tracer, fn_state);
        } else {
            return block_2894(state, tracer, fn_state);
        };
    }
    fn block_2894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2894_0: const #0u : u8
        let s_2894_0: bool = false;
        // D s_2894_1: write-var gs#135766 <= s_2894_0
        fn_state.gs_135766 = s_2894_0;
        // N s_2894_2: jump b2895
        return block_2895(state, tracer, fn_state);
    }
    fn block_2895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2895_0: read-var gs#135766:u8
        let s_2895_0: bool = fn_state.gs_135766;
        // N s_2895_1: branch s_2895_0 b4118 b2896
        if s_2895_0 {
            return block_4118(state, tracer, fn_state);
        } else {
            return block_2896(state, tracer, fn_state);
        };
    }
    fn block_2896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2896_0: const #0u : u8
        let s_2896_0: bool = false;
        // D s_2896_1: write-var gs#135767 <= s_2896_0
        fn_state.gs_135767 = s_2896_0;
        // N s_2896_2: jump b2897
        return block_2897(state, tracer, fn_state);
    }
    fn block_2897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2897_0: read-var gs#135767:u8
        let s_2897_0: bool = fn_state.gs_135767;
        // N s_2897_1: branch s_2897_0 b4117 b2898
        if s_2897_0 {
            return block_4117(state, tracer, fn_state);
        } else {
            return block_2898(state, tracer, fn_state);
        };
    }
    fn block_2898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2898_0: read-var CRm:u8
        let s_2898_0: u8 = fn_state.CRm;
        // D s_2898_1: cast zx s_2898_0 -> bv
        let s_2898_1: Bits = Bits::new(s_2898_0 as u128, 4u16);
        // C s_2898_2: const #2u : u8
        let s_2898_2: u8 = 2;
        // C s_2898_3: cast zx s_2898_2 -> bv
        let s_2898_3: Bits = Bits::new(s_2898_2 as u128, 4u16);
        // D s_2898_4: cmp-eq s_2898_1 s_2898_3
        let s_2898_4: bool = ((s_2898_1) == (s_2898_3));
        // N s_2898_5: branch s_2898_4 b4116 b2899
        if s_2898_4 {
            return block_4116(state, tracer, fn_state);
        } else {
            return block_2899(state, tracer, fn_state);
        };
    }
    fn block_2899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2899_0: const #0u : u8
        let s_2899_0: bool = false;
        // D s_2899_1: write-var gs#135768 <= s_2899_0
        fn_state.gs_135768 = s_2899_0;
        // N s_2899_2: jump b2900
        return block_2900(state, tracer, fn_state);
    }
    fn block_2900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2900_0: read-var gs#135768:u8
        let s_2900_0: bool = fn_state.gs_135768;
        // N s_2900_1: branch s_2900_0 b4115 b2901
        if s_2900_0 {
            return block_4115(state, tracer, fn_state);
        } else {
            return block_2901(state, tracer, fn_state);
        };
    }
    fn block_2901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2901_0: const #0u : u8
        let s_2901_0: bool = false;
        // D s_2901_1: write-var gs#135769 <= s_2901_0
        fn_state.gs_135769 = s_2901_0;
        // N s_2901_2: jump b2902
        return block_2902(state, tracer, fn_state);
    }
    fn block_2902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2902_0: read-var gs#135769:u8
        let s_2902_0: bool = fn_state.gs_135769;
        // N s_2902_1: branch s_2902_0 b4114 b2903
        if s_2902_0 {
            return block_4114(state, tracer, fn_state);
        } else {
            return block_2903(state, tracer, fn_state);
        };
    }
    fn block_2903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2903_0: const #0u : u8
        let s_2903_0: bool = false;
        // D s_2903_1: write-var gs#135770 <= s_2903_0
        fn_state.gs_135770 = s_2903_0;
        // N s_2903_2: jump b2904
        return block_2904(state, tracer, fn_state);
    }
    fn block_2904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2904_0: read-var gs#135770:u8
        let s_2904_0: bool = fn_state.gs_135770;
        // N s_2904_1: branch s_2904_0 b4113 b2905
        if s_2904_0 {
            return block_4113(state, tracer, fn_state);
        } else {
            return block_2905(state, tracer, fn_state);
        };
    }
    fn block_2905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2905_0: const #0u : u8
        let s_2905_0: bool = false;
        // D s_2905_1: write-var gs#135771 <= s_2905_0
        fn_state.gs_135771 = s_2905_0;
        // N s_2905_2: jump b2906
        return block_2906(state, tracer, fn_state);
    }
    fn block_2906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2906_0: read-var gs#135771:u8
        let s_2906_0: bool = fn_state.gs_135771;
        // N s_2906_1: branch s_2906_0 b4112 b2907
        if s_2906_0 {
            return block_4112(state, tracer, fn_state);
        } else {
            return block_2907(state, tracer, fn_state);
        };
    }
    fn block_2907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2907_0: read-var CRm:u8
        let s_2907_0: u8 = fn_state.CRm;
        // D s_2907_1: cast zx s_2907_0 -> bv
        let s_2907_1: Bits = Bits::new(s_2907_0 as u128, 4u16);
        // C s_2907_2: const #2u : u8
        let s_2907_2: u8 = 2;
        // C s_2907_3: cast zx s_2907_2 -> bv
        let s_2907_3: Bits = Bits::new(s_2907_2 as u128, 4u16);
        // D s_2907_4: cmp-eq s_2907_1 s_2907_3
        let s_2907_4: bool = ((s_2907_1) == (s_2907_3));
        // N s_2907_5: branch s_2907_4 b4111 b2908
        if s_2907_4 {
            return block_4111(state, tracer, fn_state);
        } else {
            return block_2908(state, tracer, fn_state);
        };
    }
    fn block_2908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2908_0: const #0u : u8
        let s_2908_0: bool = false;
        // D s_2908_1: write-var gs#135772 <= s_2908_0
        fn_state.gs_135772 = s_2908_0;
        // N s_2908_2: jump b2909
        return block_2909(state, tracer, fn_state);
    }
    fn block_2909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2909_0: read-var gs#135772:u8
        let s_2909_0: bool = fn_state.gs_135772;
        // N s_2909_1: branch s_2909_0 b4110 b2910
        if s_2909_0 {
            return block_4110(state, tracer, fn_state);
        } else {
            return block_2910(state, tracer, fn_state);
        };
    }
    fn block_2910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2910_0: const #0u : u8
        let s_2910_0: bool = false;
        // D s_2910_1: write-var gs#135773 <= s_2910_0
        fn_state.gs_135773 = s_2910_0;
        // N s_2910_2: jump b2911
        return block_2911(state, tracer, fn_state);
    }
    fn block_2911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2911_0: read-var gs#135773:u8
        let s_2911_0: bool = fn_state.gs_135773;
        // N s_2911_1: branch s_2911_0 b4109 b2912
        if s_2911_0 {
            return block_4109(state, tracer, fn_state);
        } else {
            return block_2912(state, tracer, fn_state);
        };
    }
    fn block_2912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2912_0: const #0u : u8
        let s_2912_0: bool = false;
        // D s_2912_1: write-var gs#135774 <= s_2912_0
        fn_state.gs_135774 = s_2912_0;
        // N s_2912_2: jump b2913
        return block_2913(state, tracer, fn_state);
    }
    fn block_2913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2913_0: read-var gs#135774:u8
        let s_2913_0: bool = fn_state.gs_135774;
        // N s_2913_1: branch s_2913_0 b4108 b2914
        if s_2913_0 {
            return block_4108(state, tracer, fn_state);
        } else {
            return block_2914(state, tracer, fn_state);
        };
    }
    fn block_2914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2914_0: const #0u : u8
        let s_2914_0: bool = false;
        // D s_2914_1: write-var gs#135775 <= s_2914_0
        fn_state.gs_135775 = s_2914_0;
        // N s_2914_2: jump b2915
        return block_2915(state, tracer, fn_state);
    }
    fn block_2915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2915_0: read-var gs#135775:u8
        let s_2915_0: bool = fn_state.gs_135775;
        // N s_2915_1: branch s_2915_0 b4107 b2916
        if s_2915_0 {
            return block_4107(state, tracer, fn_state);
        } else {
            return block_2916(state, tracer, fn_state);
        };
    }
    fn block_2916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2916_0: read-var CRm:u8
        let s_2916_0: u8 = fn_state.CRm;
        // D s_2916_1: cast zx s_2916_0 -> bv
        let s_2916_1: Bits = Bits::new(s_2916_0 as u128, 4u16);
        // C s_2916_2: const #11u : u8
        let s_2916_2: u8 = 11;
        // C s_2916_3: cast zx s_2916_2 -> bv
        let s_2916_3: Bits = Bits::new(s_2916_2 as u128, 4u16);
        // D s_2916_4: cmp-eq s_2916_1 s_2916_3
        let s_2916_4: bool = ((s_2916_1) == (s_2916_3));
        // N s_2916_5: branch s_2916_4 b4106 b2917
        if s_2916_4 {
            return block_4106(state, tracer, fn_state);
        } else {
            return block_2917(state, tracer, fn_state);
        };
    }
    fn block_2917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2917_0: const #0u : u8
        let s_2917_0: bool = false;
        // D s_2917_1: write-var gs#135776 <= s_2917_0
        fn_state.gs_135776 = s_2917_0;
        // N s_2917_2: jump b2918
        return block_2918(state, tracer, fn_state);
    }
    fn block_2918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2918_0: read-var gs#135776:u8
        let s_2918_0: bool = fn_state.gs_135776;
        // N s_2918_1: branch s_2918_0 b4105 b2919
        if s_2918_0 {
            return block_4105(state, tracer, fn_state);
        } else {
            return block_2919(state, tracer, fn_state);
        };
    }
    fn block_2919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2919_0: const #0u : u8
        let s_2919_0: bool = false;
        // D s_2919_1: write-var gs#135777 <= s_2919_0
        fn_state.gs_135777 = s_2919_0;
        // N s_2919_2: jump b2920
        return block_2920(state, tracer, fn_state);
    }
    fn block_2920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2920_0: read-var gs#135777:u8
        let s_2920_0: bool = fn_state.gs_135777;
        // N s_2920_1: branch s_2920_0 b4104 b2921
        if s_2920_0 {
            return block_4104(state, tracer, fn_state);
        } else {
            return block_2921(state, tracer, fn_state);
        };
    }
    fn block_2921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2921_0: const #0u : u8
        let s_2921_0: bool = false;
        // D s_2921_1: write-var gs#135778 <= s_2921_0
        fn_state.gs_135778 = s_2921_0;
        // N s_2921_2: jump b2922
        return block_2922(state, tracer, fn_state);
    }
    fn block_2922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2922_0: read-var gs#135778:u8
        let s_2922_0: bool = fn_state.gs_135778;
        // N s_2922_1: branch s_2922_0 b4103 b2923
        if s_2922_0 {
            return block_4103(state, tracer, fn_state);
        } else {
            return block_2923(state, tracer, fn_state);
        };
    }
    fn block_2923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2923_0: const #0u : u8
        let s_2923_0: bool = false;
        // D s_2923_1: write-var gs#135779 <= s_2923_0
        fn_state.gs_135779 = s_2923_0;
        // N s_2923_2: jump b2924
        return block_2924(state, tracer, fn_state);
    }
    fn block_2924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2924_0: read-var gs#135779:u8
        let s_2924_0: bool = fn_state.gs_135779;
        // N s_2924_1: branch s_2924_0 b4102 b2925
        if s_2924_0 {
            return block_4102(state, tracer, fn_state);
        } else {
            return block_2925(state, tracer, fn_state);
        };
    }
    fn block_2925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2925_0: read-var CRm:u8
        let s_2925_0: u8 = fn_state.CRm;
        // D s_2925_1: cast zx s_2925_0 -> bv
        let s_2925_1: Bits = Bits::new(s_2925_0 as u128, 4u16);
        // C s_2925_2: const #3u : u8
        let s_2925_2: u8 = 3;
        // C s_2925_3: cast zx s_2925_2 -> bv
        let s_2925_3: Bits = Bits::new(s_2925_2 as u128, 4u16);
        // D s_2925_4: cmp-eq s_2925_1 s_2925_3
        let s_2925_4: bool = ((s_2925_1) == (s_2925_3));
        // N s_2925_5: branch s_2925_4 b4101 b2926
        if s_2925_4 {
            return block_4101(state, tracer, fn_state);
        } else {
            return block_2926(state, tracer, fn_state);
        };
    }
    fn block_2926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2926_0: const #0u : u8
        let s_2926_0: bool = false;
        // D s_2926_1: write-var gs#135780 <= s_2926_0
        fn_state.gs_135780 = s_2926_0;
        // N s_2926_2: jump b2927
        return block_2927(state, tracer, fn_state);
    }
    fn block_2927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2927_0: read-var gs#135780:u8
        let s_2927_0: bool = fn_state.gs_135780;
        // N s_2927_1: branch s_2927_0 b4100 b2928
        if s_2927_0 {
            return block_4100(state, tracer, fn_state);
        } else {
            return block_2928(state, tracer, fn_state);
        };
    }
    fn block_2928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2928_0: const #0u : u8
        let s_2928_0: bool = false;
        // D s_2928_1: write-var gs#135781 <= s_2928_0
        fn_state.gs_135781 = s_2928_0;
        // N s_2928_2: jump b2929
        return block_2929(state, tracer, fn_state);
    }
    fn block_2929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2929_0: read-var gs#135781:u8
        let s_2929_0: bool = fn_state.gs_135781;
        // N s_2929_1: branch s_2929_0 b4099 b2930
        if s_2929_0 {
            return block_4099(state, tracer, fn_state);
        } else {
            return block_2930(state, tracer, fn_state);
        };
    }
    fn block_2930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2930_0: const #0u : u8
        let s_2930_0: bool = false;
        // D s_2930_1: write-var gs#135782 <= s_2930_0
        fn_state.gs_135782 = s_2930_0;
        // N s_2930_2: jump b2931
        return block_2931(state, tracer, fn_state);
    }
    fn block_2931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2931_0: read-var gs#135782:u8
        let s_2931_0: bool = fn_state.gs_135782;
        // N s_2931_1: branch s_2931_0 b4098 b2932
        if s_2931_0 {
            return block_4098(state, tracer, fn_state);
        } else {
            return block_2932(state, tracer, fn_state);
        };
    }
    fn block_2932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2932_0: const #0u : u8
        let s_2932_0: bool = false;
        // D s_2932_1: write-var gs#135783 <= s_2932_0
        fn_state.gs_135783 = s_2932_0;
        // N s_2932_2: jump b2933
        return block_2933(state, tracer, fn_state);
    }
    fn block_2933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2933_0: read-var gs#135783:u8
        let s_2933_0: bool = fn_state.gs_135783;
        // N s_2933_1: branch s_2933_0 b4097 b2934
        if s_2933_0 {
            return block_4097(state, tracer, fn_state);
        } else {
            return block_2934(state, tracer, fn_state);
        };
    }
    fn block_2934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2934_0: read-var CRm:u8
        let s_2934_0: u8 = fn_state.CRm;
        // D s_2934_1: cast zx s_2934_0 -> bv
        let s_2934_1: Bits = Bits::new(s_2934_0 as u128, 4u16);
        // C s_2934_2: const #7u : u8
        let s_2934_2: u8 = 7;
        // C s_2934_3: cast zx s_2934_2 -> bv
        let s_2934_3: Bits = Bits::new(s_2934_2 as u128, 4u16);
        // D s_2934_4: cmp-eq s_2934_1 s_2934_3
        let s_2934_4: bool = ((s_2934_1) == (s_2934_3));
        // N s_2934_5: branch s_2934_4 b4096 b2935
        if s_2934_4 {
            return block_4096(state, tracer, fn_state);
        } else {
            return block_2935(state, tracer, fn_state);
        };
    }
    fn block_2935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2935_0: const #0u : u8
        let s_2935_0: bool = false;
        // D s_2935_1: write-var gs#135784 <= s_2935_0
        fn_state.gs_135784 = s_2935_0;
        // N s_2935_2: jump b2936
        return block_2936(state, tracer, fn_state);
    }
    fn block_2936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2936_0: read-var gs#135784:u8
        let s_2936_0: bool = fn_state.gs_135784;
        // N s_2936_1: branch s_2936_0 b4095 b2937
        if s_2936_0 {
            return block_4095(state, tracer, fn_state);
        } else {
            return block_2937(state, tracer, fn_state);
        };
    }
    fn block_2937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2937_0: const #0u : u8
        let s_2937_0: bool = false;
        // D s_2937_1: write-var gs#135785 <= s_2937_0
        fn_state.gs_135785 = s_2937_0;
        // N s_2937_2: jump b2938
        return block_2938(state, tracer, fn_state);
    }
    fn block_2938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2938_0: read-var gs#135785:u8
        let s_2938_0: bool = fn_state.gs_135785;
        // N s_2938_1: branch s_2938_0 b4094 b2939
        if s_2938_0 {
            return block_4094(state, tracer, fn_state);
        } else {
            return block_2939(state, tracer, fn_state);
        };
    }
    fn block_2939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2939_0: const #0u : u8
        let s_2939_0: bool = false;
        // D s_2939_1: write-var gs#135786 <= s_2939_0
        fn_state.gs_135786 = s_2939_0;
        // N s_2939_2: jump b2940
        return block_2940(state, tracer, fn_state);
    }
    fn block_2940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2940_0: read-var gs#135786:u8
        let s_2940_0: bool = fn_state.gs_135786;
        // N s_2940_1: branch s_2940_0 b4093 b2941
        if s_2940_0 {
            return block_4093(state, tracer, fn_state);
        } else {
            return block_2941(state, tracer, fn_state);
        };
    }
    fn block_2941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2941_0: const #0u : u8
        let s_2941_0: bool = false;
        // D s_2941_1: write-var gs#135787 <= s_2941_0
        fn_state.gs_135787 = s_2941_0;
        // N s_2941_2: jump b2942
        return block_2942(state, tracer, fn_state);
    }
    fn block_2942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2942_0: read-var gs#135787:u8
        let s_2942_0: bool = fn_state.gs_135787;
        // N s_2942_1: branch s_2942_0 b4092 b2943
        if s_2942_0 {
            return block_4092(state, tracer, fn_state);
        } else {
            return block_2943(state, tracer, fn_state);
        };
    }
    fn block_2943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2943_0: read-var CRm:u8
        let s_2943_0: u8 = fn_state.CRm;
        // D s_2943_1: cast zx s_2943_0 -> bv
        let s_2943_1: Bits = Bits::new(s_2943_0 as u128, 4u16);
        // C s_2943_2: const #7u : u8
        let s_2943_2: u8 = 7;
        // C s_2943_3: cast zx s_2943_2 -> bv
        let s_2943_3: Bits = Bits::new(s_2943_2 as u128, 4u16);
        // D s_2943_4: cmp-eq s_2943_1 s_2943_3
        let s_2943_4: bool = ((s_2943_1) == (s_2943_3));
        // N s_2943_5: branch s_2943_4 b4091 b2944
        if s_2943_4 {
            return block_4091(state, tracer, fn_state);
        } else {
            return block_2944(state, tracer, fn_state);
        };
    }
    fn block_2944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2944_0: const #0u : u8
        let s_2944_0: bool = false;
        // D s_2944_1: write-var gs#135788 <= s_2944_0
        fn_state.gs_135788 = s_2944_0;
        // N s_2944_2: jump b2945
        return block_2945(state, tracer, fn_state);
    }
    fn block_2945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2945_0: read-var gs#135788:u8
        let s_2945_0: bool = fn_state.gs_135788;
        // N s_2945_1: branch s_2945_0 b4090 b2946
        if s_2945_0 {
            return block_4090(state, tracer, fn_state);
        } else {
            return block_2946(state, tracer, fn_state);
        };
    }
    fn block_2946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2946_0: const #0u : u8
        let s_2946_0: bool = false;
        // D s_2946_1: write-var gs#135789 <= s_2946_0
        fn_state.gs_135789 = s_2946_0;
        // N s_2946_2: jump b2947
        return block_2947(state, tracer, fn_state);
    }
    fn block_2947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2947_0: read-var gs#135789:u8
        let s_2947_0: bool = fn_state.gs_135789;
        // N s_2947_1: branch s_2947_0 b4089 b2948
        if s_2947_0 {
            return block_4089(state, tracer, fn_state);
        } else {
            return block_2948(state, tracer, fn_state);
        };
    }
    fn block_2948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2948_0: const #0u : u8
        let s_2948_0: bool = false;
        // D s_2948_1: write-var gs#135790 <= s_2948_0
        fn_state.gs_135790 = s_2948_0;
        // N s_2948_2: jump b2949
        return block_2949(state, tracer, fn_state);
    }
    fn block_2949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2949_0: read-var gs#135790:u8
        let s_2949_0: bool = fn_state.gs_135790;
        // N s_2949_1: branch s_2949_0 b4088 b2950
        if s_2949_0 {
            return block_4088(state, tracer, fn_state);
        } else {
            return block_2950(state, tracer, fn_state);
        };
    }
    fn block_2950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2950_0: const #0u : u8
        let s_2950_0: bool = false;
        // D s_2950_1: write-var gs#135791 <= s_2950_0
        fn_state.gs_135791 = s_2950_0;
        // N s_2950_2: jump b2951
        return block_2951(state, tracer, fn_state);
    }
    fn block_2951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2951_0: read-var gs#135791:u8
        let s_2951_0: bool = fn_state.gs_135791;
        // N s_2951_1: branch s_2951_0 b4087 b2952
        if s_2951_0 {
            return block_4087(state, tracer, fn_state);
        } else {
            return block_2952(state, tracer, fn_state);
        };
    }
    fn block_2952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2952_0: read-var CRm:u8
        let s_2952_0: u8 = fn_state.CRm;
        // D s_2952_1: cast zx s_2952_0 -> bv
        let s_2952_1: Bits = Bits::new(s_2952_0 as u128, 4u16);
        // C s_2952_2: const #10u : u8
        let s_2952_2: u8 = 10;
        // C s_2952_3: cast zx s_2952_2 -> bv
        let s_2952_3: Bits = Bits::new(s_2952_2 as u128, 4u16);
        // D s_2952_4: cmp-eq s_2952_1 s_2952_3
        let s_2952_4: bool = ((s_2952_1) == (s_2952_3));
        // N s_2952_5: branch s_2952_4 b4086 b2953
        if s_2952_4 {
            return block_4086(state, tracer, fn_state);
        } else {
            return block_2953(state, tracer, fn_state);
        };
    }
    fn block_2953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2953_0: const #0u : u8
        let s_2953_0: bool = false;
        // D s_2953_1: write-var gs#135792 <= s_2953_0
        fn_state.gs_135792 = s_2953_0;
        // N s_2953_2: jump b2954
        return block_2954(state, tracer, fn_state);
    }
    fn block_2954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2954_0: read-var gs#135792:u8
        let s_2954_0: bool = fn_state.gs_135792;
        // N s_2954_1: branch s_2954_0 b4085 b2955
        if s_2954_0 {
            return block_4085(state, tracer, fn_state);
        } else {
            return block_2955(state, tracer, fn_state);
        };
    }
    fn block_2955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2955_0: const #0u : u8
        let s_2955_0: bool = false;
        // D s_2955_1: write-var gs#135793 <= s_2955_0
        fn_state.gs_135793 = s_2955_0;
        // N s_2955_2: jump b2956
        return block_2956(state, tracer, fn_state);
    }
    fn block_2956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2956_0: read-var gs#135793:u8
        let s_2956_0: bool = fn_state.gs_135793;
        // N s_2956_1: branch s_2956_0 b4084 b2957
        if s_2956_0 {
            return block_4084(state, tracer, fn_state);
        } else {
            return block_2957(state, tracer, fn_state);
        };
    }
    fn block_2957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2957_0: const #0u : u8
        let s_2957_0: bool = false;
        // D s_2957_1: write-var gs#135794 <= s_2957_0
        fn_state.gs_135794 = s_2957_0;
        // N s_2957_2: jump b2958
        return block_2958(state, tracer, fn_state);
    }
    fn block_2958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2958_0: read-var gs#135794:u8
        let s_2958_0: bool = fn_state.gs_135794;
        // N s_2958_1: branch s_2958_0 b4083 b2959
        if s_2958_0 {
            return block_4083(state, tracer, fn_state);
        } else {
            return block_2959(state, tracer, fn_state);
        };
    }
    fn block_2959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2959_0: const #0u : u8
        let s_2959_0: bool = false;
        // D s_2959_1: write-var gs#135795 <= s_2959_0
        fn_state.gs_135795 = s_2959_0;
        // N s_2959_2: jump b2960
        return block_2960(state, tracer, fn_state);
    }
    fn block_2960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2960_0: read-var gs#135795:u8
        let s_2960_0: bool = fn_state.gs_135795;
        // N s_2960_1: branch s_2960_0 b4082 b2961
        if s_2960_0 {
            return block_4082(state, tracer, fn_state);
        } else {
            return block_2961(state, tracer, fn_state);
        };
    }
    fn block_2961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2961_0: read-var CRm:u8
        let s_2961_0: u8 = fn_state.CRm;
        // D s_2961_1: cast zx s_2961_0 -> bv
        let s_2961_1: Bits = Bits::new(s_2961_0 as u128, 4u16);
        // C s_2961_2: const #8u : u8
        let s_2961_2: u8 = 8;
        // C s_2961_3: cast zx s_2961_2 -> bv
        let s_2961_3: Bits = Bits::new(s_2961_2 as u128, 4u16);
        // D s_2961_4: cmp-eq s_2961_1 s_2961_3
        let s_2961_4: bool = ((s_2961_1) == (s_2961_3));
        // N s_2961_5: branch s_2961_4 b4081 b2962
        if s_2961_4 {
            return block_4081(state, tracer, fn_state);
        } else {
            return block_2962(state, tracer, fn_state);
        };
    }
    fn block_2962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2962_0: const #0u : u8
        let s_2962_0: bool = false;
        // D s_2962_1: write-var gs#135796 <= s_2962_0
        fn_state.gs_135796 = s_2962_0;
        // N s_2962_2: jump b2963
        return block_2963(state, tracer, fn_state);
    }
    fn block_2963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2963_0: read-var gs#135796:u8
        let s_2963_0: bool = fn_state.gs_135796;
        // N s_2963_1: branch s_2963_0 b4080 b2964
        if s_2963_0 {
            return block_4080(state, tracer, fn_state);
        } else {
            return block_2964(state, tracer, fn_state);
        };
    }
    fn block_2964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2964_0: const #0u : u8
        let s_2964_0: bool = false;
        // D s_2964_1: write-var gs#135797 <= s_2964_0
        fn_state.gs_135797 = s_2964_0;
        // N s_2964_2: jump b2965
        return block_2965(state, tracer, fn_state);
    }
    fn block_2965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2965_0: read-var gs#135797:u8
        let s_2965_0: bool = fn_state.gs_135797;
        // N s_2965_1: branch s_2965_0 b4079 b2966
        if s_2965_0 {
            return block_4079(state, tracer, fn_state);
        } else {
            return block_2966(state, tracer, fn_state);
        };
    }
    fn block_2966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2966_0: const #0u : u8
        let s_2966_0: bool = false;
        // D s_2966_1: write-var gs#135798 <= s_2966_0
        fn_state.gs_135798 = s_2966_0;
        // N s_2966_2: jump b2967
        return block_2967(state, tracer, fn_state);
    }
    fn block_2967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2967_0: read-var gs#135798:u8
        let s_2967_0: bool = fn_state.gs_135798;
        // N s_2967_1: branch s_2967_0 b4078 b2968
        if s_2967_0 {
            return block_4078(state, tracer, fn_state);
        } else {
            return block_2968(state, tracer, fn_state);
        };
    }
    fn block_2968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2968_0: const #0u : u8
        let s_2968_0: bool = false;
        // D s_2968_1: write-var gs#135799 <= s_2968_0
        fn_state.gs_135799 = s_2968_0;
        // N s_2968_2: jump b2969
        return block_2969(state, tracer, fn_state);
    }
    fn block_2969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2969_0: read-var gs#135799:u8
        let s_2969_0: bool = fn_state.gs_135799;
        // N s_2969_1: branch s_2969_0 b4077 b2970
        if s_2969_0 {
            return block_4077(state, tracer, fn_state);
        } else {
            return block_2970(state, tracer, fn_state);
        };
    }
    fn block_2970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2970_0: read-var CRm:u8
        let s_2970_0: u8 = fn_state.CRm;
        // D s_2970_1: cast zx s_2970_0 -> bv
        let s_2970_1: Bits = Bits::new(s_2970_0 as u128, 4u16);
        // C s_2970_2: const #15u : u8
        let s_2970_2: u8 = 15;
        // C s_2970_3: cast zx s_2970_2 -> bv
        let s_2970_3: Bits = Bits::new(s_2970_2 as u128, 4u16);
        // D s_2970_4: cmp-eq s_2970_1 s_2970_3
        let s_2970_4: bool = ((s_2970_1) == (s_2970_3));
        // N s_2970_5: branch s_2970_4 b4076 b2971
        if s_2970_4 {
            return block_4076(state, tracer, fn_state);
        } else {
            return block_2971(state, tracer, fn_state);
        };
    }
    fn block_2971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2971_0: const #0u : u8
        let s_2971_0: bool = false;
        // D s_2971_1: write-var gs#135800 <= s_2971_0
        fn_state.gs_135800 = s_2971_0;
        // N s_2971_2: jump b2972
        return block_2972(state, tracer, fn_state);
    }
    fn block_2972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2972_0: read-var gs#135800:u8
        let s_2972_0: bool = fn_state.gs_135800;
        // N s_2972_1: branch s_2972_0 b4075 b2973
        if s_2972_0 {
            return block_4075(state, tracer, fn_state);
        } else {
            return block_2973(state, tracer, fn_state);
        };
    }
    fn block_2973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2973_0: const #0u : u8
        let s_2973_0: bool = false;
        // D s_2973_1: write-var gs#135801 <= s_2973_0
        fn_state.gs_135801 = s_2973_0;
        // N s_2973_2: jump b2974
        return block_2974(state, tracer, fn_state);
    }
    fn block_2974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2974_0: read-var gs#135801:u8
        let s_2974_0: bool = fn_state.gs_135801;
        // N s_2974_1: branch s_2974_0 b4074 b2975
        if s_2974_0 {
            return block_4074(state, tracer, fn_state);
        } else {
            return block_2975(state, tracer, fn_state);
        };
    }
    fn block_2975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2975_0: const #0u : u8
        let s_2975_0: bool = false;
        // D s_2975_1: write-var gs#135802 <= s_2975_0
        fn_state.gs_135802 = s_2975_0;
        // N s_2975_2: jump b2976
        return block_2976(state, tracer, fn_state);
    }
    fn block_2976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2976_0: read-var gs#135802:u8
        let s_2976_0: bool = fn_state.gs_135802;
        // N s_2976_1: branch s_2976_0 b4073 b2977
        if s_2976_0 {
            return block_4073(state, tracer, fn_state);
        } else {
            return block_2977(state, tracer, fn_state);
        };
    }
    fn block_2977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2977_0: const #0u : u8
        let s_2977_0: bool = false;
        // D s_2977_1: write-var gs#135803 <= s_2977_0
        fn_state.gs_135803 = s_2977_0;
        // N s_2977_2: jump b2978
        return block_2978(state, tracer, fn_state);
    }
    fn block_2978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2978_0: read-var gs#135803:u8
        let s_2978_0: bool = fn_state.gs_135803;
        // N s_2978_1: branch s_2978_0 b4072 b2979
        if s_2978_0 {
            return block_4072(state, tracer, fn_state);
        } else {
            return block_2979(state, tracer, fn_state);
        };
    }
    fn block_2979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2979_0: read-var CRm:u8
        let s_2979_0: u8 = fn_state.CRm;
        // D s_2979_1: cast zx s_2979_0 -> bv
        let s_2979_1: Bits = Bits::new(s_2979_0 as u128, 4u16);
        // C s_2979_2: const #15u : u8
        let s_2979_2: u8 = 15;
        // C s_2979_3: cast zx s_2979_2 -> bv
        let s_2979_3: Bits = Bits::new(s_2979_2 as u128, 4u16);
        // D s_2979_4: cmp-eq s_2979_1 s_2979_3
        let s_2979_4: bool = ((s_2979_1) == (s_2979_3));
        // N s_2979_5: branch s_2979_4 b4071 b2980
        if s_2979_4 {
            return block_4071(state, tracer, fn_state);
        } else {
            return block_2980(state, tracer, fn_state);
        };
    }
    fn block_2980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2980_0: const #0u : u8
        let s_2980_0: bool = false;
        // D s_2980_1: write-var gs#135804 <= s_2980_0
        fn_state.gs_135804 = s_2980_0;
        // N s_2980_2: jump b2981
        return block_2981(state, tracer, fn_state);
    }
    fn block_2981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2981_0: read-var gs#135804:u8
        let s_2981_0: bool = fn_state.gs_135804;
        // N s_2981_1: branch s_2981_0 b4070 b2982
        if s_2981_0 {
            return block_4070(state, tracer, fn_state);
        } else {
            return block_2982(state, tracer, fn_state);
        };
    }
    fn block_2982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2982_0: const #0u : u8
        let s_2982_0: bool = false;
        // D s_2982_1: write-var gs#135805 <= s_2982_0
        fn_state.gs_135805 = s_2982_0;
        // N s_2982_2: jump b2983
        return block_2983(state, tracer, fn_state);
    }
    fn block_2983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2983_0: read-var gs#135805:u8
        let s_2983_0: bool = fn_state.gs_135805;
        // N s_2983_1: branch s_2983_0 b4069 b2984
        if s_2983_0 {
            return block_4069(state, tracer, fn_state);
        } else {
            return block_2984(state, tracer, fn_state);
        };
    }
    fn block_2984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2984_0: const #0u : u8
        let s_2984_0: bool = false;
        // D s_2984_1: write-var gs#135806 <= s_2984_0
        fn_state.gs_135806 = s_2984_0;
        // N s_2984_2: jump b2985
        return block_2985(state, tracer, fn_state);
    }
    fn block_2985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2985_0: read-var gs#135806:u8
        let s_2985_0: bool = fn_state.gs_135806;
        // N s_2985_1: branch s_2985_0 b4068 b2986
        if s_2985_0 {
            return block_4068(state, tracer, fn_state);
        } else {
            return block_2986(state, tracer, fn_state);
        };
    }
    fn block_2986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2986_0: const #0u : u8
        let s_2986_0: bool = false;
        // D s_2986_1: write-var gs#135807 <= s_2986_0
        fn_state.gs_135807 = s_2986_0;
        // N s_2986_2: jump b2987
        return block_2987(state, tracer, fn_state);
    }
    fn block_2987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2987_0: read-var gs#135807:u8
        let s_2987_0: bool = fn_state.gs_135807;
        // N s_2987_1: branch s_2987_0 b4067 b2988
        if s_2987_0 {
            return block_4067(state, tracer, fn_state);
        } else {
            return block_2988(state, tracer, fn_state);
        };
    }
    fn block_2988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2988_0: read-var CRm:u8
        let s_2988_0: u8 = fn_state.CRm;
        // D s_2988_1: cast zx s_2988_0 -> bv
        let s_2988_1: Bits = Bits::new(s_2988_0 as u128, 4u16);
        // C s_2988_2: const #15u : u8
        let s_2988_2: u8 = 15;
        // C s_2988_3: cast zx s_2988_2 -> bv
        let s_2988_3: Bits = Bits::new(s_2988_2 as u128, 4u16);
        // D s_2988_4: cmp-eq s_2988_1 s_2988_3
        let s_2988_4: bool = ((s_2988_1) == (s_2988_3));
        // N s_2988_5: branch s_2988_4 b4066 b2989
        if s_2988_4 {
            return block_4066(state, tracer, fn_state);
        } else {
            return block_2989(state, tracer, fn_state);
        };
    }
    fn block_2989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2989_0: const #0u : u8
        let s_2989_0: bool = false;
        // D s_2989_1: write-var gs#135808 <= s_2989_0
        fn_state.gs_135808 = s_2989_0;
        // N s_2989_2: jump b2990
        return block_2990(state, tracer, fn_state);
    }
    fn block_2990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2990_0: read-var gs#135808:u8
        let s_2990_0: bool = fn_state.gs_135808;
        // N s_2990_1: branch s_2990_0 b4065 b2991
        if s_2990_0 {
            return block_4065(state, tracer, fn_state);
        } else {
            return block_2991(state, tracer, fn_state);
        };
    }
    fn block_2991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2991_0: const #0u : u8
        let s_2991_0: bool = false;
        // D s_2991_1: write-var gs#135809 <= s_2991_0
        fn_state.gs_135809 = s_2991_0;
        // N s_2991_2: jump b2992
        return block_2992(state, tracer, fn_state);
    }
    fn block_2992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2992_0: read-var gs#135809:u8
        let s_2992_0: bool = fn_state.gs_135809;
        // N s_2992_1: branch s_2992_0 b4064 b2993
        if s_2992_0 {
            return block_4064(state, tracer, fn_state);
        } else {
            return block_2993(state, tracer, fn_state);
        };
    }
    fn block_2993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2993_0: const #0u : u8
        let s_2993_0: bool = false;
        // D s_2993_1: write-var gs#135810 <= s_2993_0
        fn_state.gs_135810 = s_2993_0;
        // N s_2993_2: jump b2994
        return block_2994(state, tracer, fn_state);
    }
    fn block_2994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2994_0: read-var gs#135810:u8
        let s_2994_0: bool = fn_state.gs_135810;
        // N s_2994_1: branch s_2994_0 b4063 b2995
        if s_2994_0 {
            return block_4063(state, tracer, fn_state);
        } else {
            return block_2995(state, tracer, fn_state);
        };
    }
    fn block_2995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2995_0: const #0u : u8
        let s_2995_0: bool = false;
        // D s_2995_1: write-var gs#135811 <= s_2995_0
        fn_state.gs_135811 = s_2995_0;
        // N s_2995_2: jump b2996
        return block_2996(state, tracer, fn_state);
    }
    fn block_2996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2996_0: read-var gs#135811:u8
        let s_2996_0: bool = fn_state.gs_135811;
        // N s_2996_1: branch s_2996_0 b4062 b2997
        if s_2996_0 {
            return block_4062(state, tracer, fn_state);
        } else {
            return block_2997(state, tracer, fn_state);
        };
    }
    fn block_2997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2997_0: read-var CRm:u8
        let s_2997_0: u8 = fn_state.CRm;
        // D s_2997_1: cast zx s_2997_0 -> bv
        let s_2997_1: Bits = Bits::new(s_2997_0 as u128, 4u16);
        // C s_2997_2: const #15u : u8
        let s_2997_2: u8 = 15;
        // C s_2997_3: cast zx s_2997_2 -> bv
        let s_2997_3: Bits = Bits::new(s_2997_2 as u128, 4u16);
        // D s_2997_4: cmp-eq s_2997_1 s_2997_3
        let s_2997_4: bool = ((s_2997_1) == (s_2997_3));
        // N s_2997_5: branch s_2997_4 b4061 b2998
        if s_2997_4 {
            return block_4061(state, tracer, fn_state);
        } else {
            return block_2998(state, tracer, fn_state);
        };
    }
    fn block_2998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2998_0: const #0u : u8
        let s_2998_0: bool = false;
        // D s_2998_1: write-var gs#135812 <= s_2998_0
        fn_state.gs_135812 = s_2998_0;
        // N s_2998_2: jump b2999
        return block_2999(state, tracer, fn_state);
    }
    fn block_2999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2999_0: read-var gs#135812:u8
        let s_2999_0: bool = fn_state.gs_135812;
        // N s_2999_1: branch s_2999_0 b4060 b3000
        if s_2999_0 {
            return block_4060(state, tracer, fn_state);
        } else {
            return block_3000(state, tracer, fn_state);
        };
    }
    fn block_3000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3000_0: const #0u : u8
        let s_3000_0: bool = false;
        // D s_3000_1: write-var gs#135813 <= s_3000_0
        fn_state.gs_135813 = s_3000_0;
        // N s_3000_2: jump b3001
        return block_3001(state, tracer, fn_state);
    }
    fn block_3001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3001_0: read-var gs#135813:u8
        let s_3001_0: bool = fn_state.gs_135813;
        // N s_3001_1: branch s_3001_0 b4059 b3002
        if s_3001_0 {
            return block_4059(state, tracer, fn_state);
        } else {
            return block_3002(state, tracer, fn_state);
        };
    }
    fn block_3002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3002_0: const #0u : u8
        let s_3002_0: bool = false;
        // D s_3002_1: write-var gs#135814 <= s_3002_0
        fn_state.gs_135814 = s_3002_0;
        // N s_3002_2: jump b3003
        return block_3003(state, tracer, fn_state);
    }
    fn block_3003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3003_0: read-var gs#135814:u8
        let s_3003_0: bool = fn_state.gs_135814;
        // N s_3003_1: branch s_3003_0 b4058 b3004
        if s_3003_0 {
            return block_4058(state, tracer, fn_state);
        } else {
            return block_3004(state, tracer, fn_state);
        };
    }
    fn block_3004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3004_0: const #0u : u8
        let s_3004_0: bool = false;
        // D s_3004_1: write-var gs#135815 <= s_3004_0
        fn_state.gs_135815 = s_3004_0;
        // N s_3004_2: jump b3005
        return block_3005(state, tracer, fn_state);
    }
    fn block_3005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3005_0: read-var gs#135815:u8
        let s_3005_0: bool = fn_state.gs_135815;
        // N s_3005_1: branch s_3005_0 b4057 b3006
        if s_3005_0 {
            return block_4057(state, tracer, fn_state);
        } else {
            return block_3006(state, tracer, fn_state);
        };
    }
    fn block_3006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3006_0: read-var CRm:u8
        let s_3006_0: u8 = fn_state.CRm;
        // D s_3006_1: cast zx s_3006_0 -> bv
        let s_3006_1: Bits = Bits::new(s_3006_0 as u128, 4u16);
        // C s_3006_2: const #15u : u8
        let s_3006_2: u8 = 15;
        // C s_3006_3: cast zx s_3006_2 -> bv
        let s_3006_3: Bits = Bits::new(s_3006_2 as u128, 4u16);
        // D s_3006_4: cmp-eq s_3006_1 s_3006_3
        let s_3006_4: bool = ((s_3006_1) == (s_3006_3));
        // N s_3006_5: branch s_3006_4 b4056 b3007
        if s_3006_4 {
            return block_4056(state, tracer, fn_state);
        } else {
            return block_3007(state, tracer, fn_state);
        };
    }
    fn block_3007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3007_0: const #0u : u8
        let s_3007_0: bool = false;
        // D s_3007_1: write-var gs#135816 <= s_3007_0
        fn_state.gs_135816 = s_3007_0;
        // N s_3007_2: jump b3008
        return block_3008(state, tracer, fn_state);
    }
    fn block_3008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3008_0: read-var gs#135816:u8
        let s_3008_0: bool = fn_state.gs_135816;
        // N s_3008_1: branch s_3008_0 b4055 b3009
        if s_3008_0 {
            return block_4055(state, tracer, fn_state);
        } else {
            return block_3009(state, tracer, fn_state);
        };
    }
    fn block_3009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3009_0: const #0u : u8
        let s_3009_0: bool = false;
        // D s_3009_1: write-var gs#135817 <= s_3009_0
        fn_state.gs_135817 = s_3009_0;
        // N s_3009_2: jump b3010
        return block_3010(state, tracer, fn_state);
    }
    fn block_3010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3010_0: read-var gs#135817:u8
        let s_3010_0: bool = fn_state.gs_135817;
        // N s_3010_1: branch s_3010_0 b4054 b3011
        if s_3010_0 {
            return block_4054(state, tracer, fn_state);
        } else {
            return block_3011(state, tracer, fn_state);
        };
    }
    fn block_3011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3011_0: const #0u : u8
        let s_3011_0: bool = false;
        // D s_3011_1: write-var gs#135818 <= s_3011_0
        fn_state.gs_135818 = s_3011_0;
        // N s_3011_2: jump b3012
        return block_3012(state, tracer, fn_state);
    }
    fn block_3012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3012_0: read-var gs#135818:u8
        let s_3012_0: bool = fn_state.gs_135818;
        // N s_3012_1: branch s_3012_0 b4053 b3013
        if s_3012_0 {
            return block_4053(state, tracer, fn_state);
        } else {
            return block_3013(state, tracer, fn_state);
        };
    }
    fn block_3013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3013_0: const #0u : u8
        let s_3013_0: bool = false;
        // D s_3013_1: write-var gs#135819 <= s_3013_0
        fn_state.gs_135819 = s_3013_0;
        // N s_3013_2: jump b3014
        return block_3014(state, tracer, fn_state);
    }
    fn block_3014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3014_0: read-var gs#135819:u8
        let s_3014_0: bool = fn_state.gs_135819;
        // N s_3014_1: branch s_3014_0 b4052 b3015
        if s_3014_0 {
            return block_4052(state, tracer, fn_state);
        } else {
            return block_3015(state, tracer, fn_state);
        };
    }
    fn block_3015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3015_0: read-var CRm:u8
        let s_3015_0: u8 = fn_state.CRm;
        // D s_3015_1: cast zx s_3015_0 -> bv
        let s_3015_1: Bits = Bits::new(s_3015_0 as u128, 4u16);
        // C s_3015_2: const #15u : u8
        let s_3015_2: u8 = 15;
        // C s_3015_3: cast zx s_3015_2 -> bv
        let s_3015_3: Bits = Bits::new(s_3015_2 as u128, 4u16);
        // D s_3015_4: cmp-eq s_3015_1 s_3015_3
        let s_3015_4: bool = ((s_3015_1) == (s_3015_3));
        // N s_3015_5: branch s_3015_4 b4051 b3016
        if s_3015_4 {
            return block_4051(state, tracer, fn_state);
        } else {
            return block_3016(state, tracer, fn_state);
        };
    }
    fn block_3016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3016_0: const #0u : u8
        let s_3016_0: bool = false;
        // D s_3016_1: write-var gs#135820 <= s_3016_0
        fn_state.gs_135820 = s_3016_0;
        // N s_3016_2: jump b3017
        return block_3017(state, tracer, fn_state);
    }
    fn block_3017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3017_0: read-var gs#135820:u8
        let s_3017_0: bool = fn_state.gs_135820;
        // N s_3017_1: branch s_3017_0 b4050 b3018
        if s_3017_0 {
            return block_4050(state, tracer, fn_state);
        } else {
            return block_3018(state, tracer, fn_state);
        };
    }
    fn block_3018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3018_0: const #0u : u8
        let s_3018_0: bool = false;
        // D s_3018_1: write-var gs#135821 <= s_3018_0
        fn_state.gs_135821 = s_3018_0;
        // N s_3018_2: jump b3019
        return block_3019(state, tracer, fn_state);
    }
    fn block_3019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3019_0: read-var gs#135821:u8
        let s_3019_0: bool = fn_state.gs_135821;
        // N s_3019_1: branch s_3019_0 b4049 b3020
        if s_3019_0 {
            return block_4049(state, tracer, fn_state);
        } else {
            return block_3020(state, tracer, fn_state);
        };
    }
    fn block_3020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3020_0: const #0u : u8
        let s_3020_0: bool = false;
        // D s_3020_1: write-var gs#135822 <= s_3020_0
        fn_state.gs_135822 = s_3020_0;
        // N s_3020_2: jump b3021
        return block_3021(state, tracer, fn_state);
    }
    fn block_3021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3021_0: read-var gs#135822:u8
        let s_3021_0: bool = fn_state.gs_135822;
        // N s_3021_1: branch s_3021_0 b4048 b3022
        if s_3021_0 {
            return block_4048(state, tracer, fn_state);
        } else {
            return block_3022(state, tracer, fn_state);
        };
    }
    fn block_3022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3022_0: const #0u : u8
        let s_3022_0: bool = false;
        // D s_3022_1: write-var gs#135823 <= s_3022_0
        fn_state.gs_135823 = s_3022_0;
        // N s_3022_2: jump b3023
        return block_3023(state, tracer, fn_state);
    }
    fn block_3023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3023_0: read-var gs#135823:u8
        let s_3023_0: bool = fn_state.gs_135823;
        // N s_3023_1: branch s_3023_0 b4047 b3024
        if s_3023_0 {
            return block_4047(state, tracer, fn_state);
        } else {
            return block_3024(state, tracer, fn_state);
        };
    }
    fn block_3024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3024_0: read-var CRm:u8
        let s_3024_0: u8 = fn_state.CRm;
        // D s_3024_1: cast zx s_3024_0 -> bv
        let s_3024_1: Bits = Bits::new(s_3024_0 as u128, 4u16);
        // C s_3024_2: const #15u : u8
        let s_3024_2: u8 = 15;
        // C s_3024_3: cast zx s_3024_2 -> bv
        let s_3024_3: Bits = Bits::new(s_3024_2 as u128, 4u16);
        // D s_3024_4: cmp-eq s_3024_1 s_3024_3
        let s_3024_4: bool = ((s_3024_1) == (s_3024_3));
        // N s_3024_5: branch s_3024_4 b4046 b3025
        if s_3024_4 {
            return block_4046(state, tracer, fn_state);
        } else {
            return block_3025(state, tracer, fn_state);
        };
    }
    fn block_3025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3025_0: const #0u : u8
        let s_3025_0: bool = false;
        // D s_3025_1: write-var gs#135824 <= s_3025_0
        fn_state.gs_135824 = s_3025_0;
        // N s_3025_2: jump b3026
        return block_3026(state, tracer, fn_state);
    }
    fn block_3026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3026_0: read-var gs#135824:u8
        let s_3026_0: bool = fn_state.gs_135824;
        // N s_3026_1: branch s_3026_0 b4045 b3027
        if s_3026_0 {
            return block_4045(state, tracer, fn_state);
        } else {
            return block_3027(state, tracer, fn_state);
        };
    }
    fn block_3027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3027_0: const #0u : u8
        let s_3027_0: bool = false;
        // D s_3027_1: write-var gs#135825 <= s_3027_0
        fn_state.gs_135825 = s_3027_0;
        // N s_3027_2: jump b3028
        return block_3028(state, tracer, fn_state);
    }
    fn block_3028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3028_0: read-var gs#135825:u8
        let s_3028_0: bool = fn_state.gs_135825;
        // N s_3028_1: branch s_3028_0 b4044 b3029
        if s_3028_0 {
            return block_4044(state, tracer, fn_state);
        } else {
            return block_3029(state, tracer, fn_state);
        };
    }
    fn block_3029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3029_0: const #0u : u8
        let s_3029_0: bool = false;
        // D s_3029_1: write-var gs#135826 <= s_3029_0
        fn_state.gs_135826 = s_3029_0;
        // N s_3029_2: jump b3030
        return block_3030(state, tracer, fn_state);
    }
    fn block_3030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3030_0: read-var gs#135826:u8
        let s_3030_0: bool = fn_state.gs_135826;
        // N s_3030_1: branch s_3030_0 b4043 b3031
        if s_3030_0 {
            return block_4043(state, tracer, fn_state);
        } else {
            return block_3031(state, tracer, fn_state);
        };
    }
    fn block_3031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3031_0: const #0u : u8
        let s_3031_0: bool = false;
        // D s_3031_1: write-var gs#135827 <= s_3031_0
        fn_state.gs_135827 = s_3031_0;
        // N s_3031_2: jump b3032
        return block_3032(state, tracer, fn_state);
    }
    fn block_3032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3032_0: read-var gs#135827:u8
        let s_3032_0: bool = fn_state.gs_135827;
        // N s_3032_1: branch s_3032_0 b4042 b3033
        if s_3032_0 {
            return block_4042(state, tracer, fn_state);
        } else {
            return block_3033(state, tracer, fn_state);
        };
    }
    fn block_3033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3033_0: read-var CRm:u8
        let s_3033_0: u8 = fn_state.CRm;
        // D s_3033_1: cast zx s_3033_0 -> bv
        let s_3033_1: Bits = Bits::new(s_3033_0 as u128, 4u16);
        // C s_3033_2: const #15u : u8
        let s_3033_2: u8 = 15;
        // C s_3033_3: cast zx s_3033_2 -> bv
        let s_3033_3: Bits = Bits::new(s_3033_2 as u128, 4u16);
        // D s_3033_4: cmp-eq s_3033_1 s_3033_3
        let s_3033_4: bool = ((s_3033_1) == (s_3033_3));
        // N s_3033_5: branch s_3033_4 b4041 b3034
        if s_3033_4 {
            return block_4041(state, tracer, fn_state);
        } else {
            return block_3034(state, tracer, fn_state);
        };
    }
    fn block_3034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3034_0: const #0u : u8
        let s_3034_0: bool = false;
        // D s_3034_1: write-var gs#135828 <= s_3034_0
        fn_state.gs_135828 = s_3034_0;
        // N s_3034_2: jump b3035
        return block_3035(state, tracer, fn_state);
    }
    fn block_3035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3035_0: read-var gs#135828:u8
        let s_3035_0: bool = fn_state.gs_135828;
        // N s_3035_1: branch s_3035_0 b4040 b3036
        if s_3035_0 {
            return block_4040(state, tracer, fn_state);
        } else {
            return block_3036(state, tracer, fn_state);
        };
    }
    fn block_3036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3036_0: const #0u : u8
        let s_3036_0: bool = false;
        // D s_3036_1: write-var gs#135829 <= s_3036_0
        fn_state.gs_135829 = s_3036_0;
        // N s_3036_2: jump b3037
        return block_3037(state, tracer, fn_state);
    }
    fn block_3037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3037_0: read-var gs#135829:u8
        let s_3037_0: bool = fn_state.gs_135829;
        // N s_3037_1: branch s_3037_0 b4039 b3038
        if s_3037_0 {
            return block_4039(state, tracer, fn_state);
        } else {
            return block_3038(state, tracer, fn_state);
        };
    }
    fn block_3038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3038_0: const #0u : u8
        let s_3038_0: bool = false;
        // D s_3038_1: write-var gs#135830 <= s_3038_0
        fn_state.gs_135830 = s_3038_0;
        // N s_3038_2: jump b3039
        return block_3039(state, tracer, fn_state);
    }
    fn block_3039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3039_0: read-var gs#135830:u8
        let s_3039_0: bool = fn_state.gs_135830;
        // N s_3039_1: branch s_3039_0 b4038 b3040
        if s_3039_0 {
            return block_4038(state, tracer, fn_state);
        } else {
            return block_3040(state, tracer, fn_state);
        };
    }
    fn block_3040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3040_0: const #0u : u8
        let s_3040_0: bool = false;
        // D s_3040_1: write-var gs#135831 <= s_3040_0
        fn_state.gs_135831 = s_3040_0;
        // N s_3040_2: jump b3041
        return block_3041(state, tracer, fn_state);
    }
    fn block_3041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3041_0: read-var gs#135831:u8
        let s_3041_0: bool = fn_state.gs_135831;
        // N s_3041_1: branch s_3041_0 b4037 b3042
        if s_3041_0 {
            return block_4037(state, tracer, fn_state);
        } else {
            return block_3042(state, tracer, fn_state);
        };
    }
    fn block_3042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3042_0: read-var CRm:u8
        let s_3042_0: u8 = fn_state.CRm;
        // D s_3042_1: cast zx s_3042_0 -> bv
        let s_3042_1: Bits = Bits::new(s_3042_0 as u128, 4u16);
        // C s_3042_2: const #14u : u8
        let s_3042_2: u8 = 14;
        // C s_3042_3: cast zx s_3042_2 -> bv
        let s_3042_3: Bits = Bits::new(s_3042_2 as u128, 4u16);
        // D s_3042_4: cmp-eq s_3042_1 s_3042_3
        let s_3042_4: bool = ((s_3042_1) == (s_3042_3));
        // N s_3042_5: branch s_3042_4 b4036 b3043
        if s_3042_4 {
            return block_4036(state, tracer, fn_state);
        } else {
            return block_3043(state, tracer, fn_state);
        };
    }
    fn block_3043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3043_0: const #0u : u8
        let s_3043_0: bool = false;
        // D s_3043_1: write-var gs#135832 <= s_3043_0
        fn_state.gs_135832 = s_3043_0;
        // N s_3043_2: jump b3044
        return block_3044(state, tracer, fn_state);
    }
    fn block_3044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3044_0: read-var gs#135832:u8
        let s_3044_0: bool = fn_state.gs_135832;
        // N s_3044_1: branch s_3044_0 b4035 b3045
        if s_3044_0 {
            return block_4035(state, tracer, fn_state);
        } else {
            return block_3045(state, tracer, fn_state);
        };
    }
    fn block_3045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3045_0: const #0u : u8
        let s_3045_0: bool = false;
        // D s_3045_1: write-var gs#135833 <= s_3045_0
        fn_state.gs_135833 = s_3045_0;
        // N s_3045_2: jump b3046
        return block_3046(state, tracer, fn_state);
    }
    fn block_3046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3046_0: read-var gs#135833:u8
        let s_3046_0: bool = fn_state.gs_135833;
        // N s_3046_1: branch s_3046_0 b4034 b3047
        if s_3046_0 {
            return block_4034(state, tracer, fn_state);
        } else {
            return block_3047(state, tracer, fn_state);
        };
    }
    fn block_3047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3047_0: const #0u : u8
        let s_3047_0: bool = false;
        // D s_3047_1: write-var gs#135834 <= s_3047_0
        fn_state.gs_135834 = s_3047_0;
        // N s_3047_2: jump b3048
        return block_3048(state, tracer, fn_state);
    }
    fn block_3048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3048_0: read-var gs#135834:u8
        let s_3048_0: bool = fn_state.gs_135834;
        // N s_3048_1: branch s_3048_0 b4033 b3049
        if s_3048_0 {
            return block_4033(state, tracer, fn_state);
        } else {
            return block_3049(state, tracer, fn_state);
        };
    }
    fn block_3049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3049_0: const #0u : u8
        let s_3049_0: bool = false;
        // D s_3049_1: write-var gs#135835 <= s_3049_0
        fn_state.gs_135835 = s_3049_0;
        // N s_3049_2: jump b3050
        return block_3050(state, tracer, fn_state);
    }
    fn block_3050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3050_0: read-var gs#135835:u8
        let s_3050_0: bool = fn_state.gs_135835;
        // N s_3050_1: branch s_3050_0 b4032 b3051
        if s_3050_0 {
            return block_4032(state, tracer, fn_state);
        } else {
            return block_3051(state, tracer, fn_state);
        };
    }
    fn block_3051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3051_0: read-var CRm:u8
        let s_3051_0: u8 = fn_state.CRm;
        // D s_3051_1: cast zx s_3051_0 -> bv
        let s_3051_1: Bits = Bits::new(s_3051_0 as u128, 4u16);
        // C s_3051_2: const #14u : u8
        let s_3051_2: u8 = 14;
        // C s_3051_3: cast zx s_3051_2 -> bv
        let s_3051_3: Bits = Bits::new(s_3051_2 as u128, 4u16);
        // D s_3051_4: cmp-eq s_3051_1 s_3051_3
        let s_3051_4: bool = ((s_3051_1) == (s_3051_3));
        // N s_3051_5: branch s_3051_4 b4031 b3052
        if s_3051_4 {
            return block_4031(state, tracer, fn_state);
        } else {
            return block_3052(state, tracer, fn_state);
        };
    }
    fn block_3052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3052_0: const #0u : u8
        let s_3052_0: bool = false;
        // D s_3052_1: write-var gs#135836 <= s_3052_0
        fn_state.gs_135836 = s_3052_0;
        // N s_3052_2: jump b3053
        return block_3053(state, tracer, fn_state);
    }
    fn block_3053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3053_0: read-var gs#135836:u8
        let s_3053_0: bool = fn_state.gs_135836;
        // N s_3053_1: branch s_3053_0 b4030 b3054
        if s_3053_0 {
            return block_4030(state, tracer, fn_state);
        } else {
            return block_3054(state, tracer, fn_state);
        };
    }
    fn block_3054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3054_0: const #0u : u8
        let s_3054_0: bool = false;
        // D s_3054_1: write-var gs#135837 <= s_3054_0
        fn_state.gs_135837 = s_3054_0;
        // N s_3054_2: jump b3055
        return block_3055(state, tracer, fn_state);
    }
    fn block_3055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3055_0: read-var gs#135837:u8
        let s_3055_0: bool = fn_state.gs_135837;
        // N s_3055_1: branch s_3055_0 b4029 b3056
        if s_3055_0 {
            return block_4029(state, tracer, fn_state);
        } else {
            return block_3056(state, tracer, fn_state);
        };
    }
    fn block_3056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3056_0: const #0u : u8
        let s_3056_0: bool = false;
        // D s_3056_1: write-var gs#135838 <= s_3056_0
        fn_state.gs_135838 = s_3056_0;
        // N s_3056_2: jump b3057
        return block_3057(state, tracer, fn_state);
    }
    fn block_3057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3057_0: read-var gs#135838:u8
        let s_3057_0: bool = fn_state.gs_135838;
        // N s_3057_1: branch s_3057_0 b4028 b3058
        if s_3057_0 {
            return block_4028(state, tracer, fn_state);
        } else {
            return block_3058(state, tracer, fn_state);
        };
    }
    fn block_3058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3058_0: const #0u : u8
        let s_3058_0: bool = false;
        // D s_3058_1: write-var gs#135839 <= s_3058_0
        fn_state.gs_135839 = s_3058_0;
        // N s_3058_2: jump b3059
        return block_3059(state, tracer, fn_state);
    }
    fn block_3059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3059_0: read-var gs#135839:u8
        let s_3059_0: bool = fn_state.gs_135839;
        // N s_3059_1: branch s_3059_0 b4027 b3060
        if s_3059_0 {
            return block_4027(state, tracer, fn_state);
        } else {
            return block_3060(state, tracer, fn_state);
        };
    }
    fn block_3060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3060_0: read-var CRm:u8
        let s_3060_0: u8 = fn_state.CRm;
        // D s_3060_1: cast zx s_3060_0 -> bv
        let s_3060_1: Bits = Bits::new(s_3060_0 as u128, 4u16);
        // C s_3060_2: const #14u : u8
        let s_3060_2: u8 = 14;
        // C s_3060_3: cast zx s_3060_2 -> bv
        let s_3060_3: Bits = Bits::new(s_3060_2 as u128, 4u16);
        // D s_3060_4: cmp-eq s_3060_1 s_3060_3
        let s_3060_4: bool = ((s_3060_1) == (s_3060_3));
        // N s_3060_5: branch s_3060_4 b4026 b3061
        if s_3060_4 {
            return block_4026(state, tracer, fn_state);
        } else {
            return block_3061(state, tracer, fn_state);
        };
    }
    fn block_3061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3061_0: const #0u : u8
        let s_3061_0: bool = false;
        // D s_3061_1: write-var gs#135840 <= s_3061_0
        fn_state.gs_135840 = s_3061_0;
        // N s_3061_2: jump b3062
        return block_3062(state, tracer, fn_state);
    }
    fn block_3062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3062_0: read-var gs#135840:u8
        let s_3062_0: bool = fn_state.gs_135840;
        // N s_3062_1: branch s_3062_0 b4025 b3063
        if s_3062_0 {
            return block_4025(state, tracer, fn_state);
        } else {
            return block_3063(state, tracer, fn_state);
        };
    }
    fn block_3063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3063_0: const #0u : u8
        let s_3063_0: bool = false;
        // D s_3063_1: write-var gs#135841 <= s_3063_0
        fn_state.gs_135841 = s_3063_0;
        // N s_3063_2: jump b3064
        return block_3064(state, tracer, fn_state);
    }
    fn block_3064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3064_0: read-var gs#135841:u8
        let s_3064_0: bool = fn_state.gs_135841;
        // N s_3064_1: branch s_3064_0 b4024 b3065
        if s_3064_0 {
            return block_4024(state, tracer, fn_state);
        } else {
            return block_3065(state, tracer, fn_state);
        };
    }
    fn block_3065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3065_0: const #0u : u8
        let s_3065_0: bool = false;
        // D s_3065_1: write-var gs#135842 <= s_3065_0
        fn_state.gs_135842 = s_3065_0;
        // N s_3065_2: jump b3066
        return block_3066(state, tracer, fn_state);
    }
    fn block_3066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3066_0: read-var gs#135842:u8
        let s_3066_0: bool = fn_state.gs_135842;
        // N s_3066_1: branch s_3066_0 b4023 b3067
        if s_3066_0 {
            return block_4023(state, tracer, fn_state);
        } else {
            return block_3067(state, tracer, fn_state);
        };
    }
    fn block_3067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3067_0: const #0u : u8
        let s_3067_0: bool = false;
        // D s_3067_1: write-var gs#135843 <= s_3067_0
        fn_state.gs_135843 = s_3067_0;
        // N s_3067_2: jump b3068
        return block_3068(state, tracer, fn_state);
    }
    fn block_3068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3068_0: read-var gs#135843:u8
        let s_3068_0: bool = fn_state.gs_135843;
        // N s_3068_1: branch s_3068_0 b4022 b3069
        if s_3068_0 {
            return block_4022(state, tracer, fn_state);
        } else {
            return block_3069(state, tracer, fn_state);
        };
    }
    fn block_3069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3069_0: read-var CRm:u8
        let s_3069_0: u8 = fn_state.CRm;
        // D s_3069_1: cast zx s_3069_0 -> bv
        let s_3069_1: Bits = Bits::new(s_3069_0 as u128, 4u16);
        // C s_3069_2: const #14u : u8
        let s_3069_2: u8 = 14;
        // C s_3069_3: cast zx s_3069_2 -> bv
        let s_3069_3: Bits = Bits::new(s_3069_2 as u128, 4u16);
        // D s_3069_4: cmp-eq s_3069_1 s_3069_3
        let s_3069_4: bool = ((s_3069_1) == (s_3069_3));
        // N s_3069_5: branch s_3069_4 b4021 b3070
        if s_3069_4 {
            return block_4021(state, tracer, fn_state);
        } else {
            return block_3070(state, tracer, fn_state);
        };
    }
    fn block_3070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3070_0: const #0u : u8
        let s_3070_0: bool = false;
        // D s_3070_1: write-var gs#135844 <= s_3070_0
        fn_state.gs_135844 = s_3070_0;
        // N s_3070_2: jump b3071
        return block_3071(state, tracer, fn_state);
    }
    fn block_3071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3071_0: read-var gs#135844:u8
        let s_3071_0: bool = fn_state.gs_135844;
        // N s_3071_1: branch s_3071_0 b4020 b3072
        if s_3071_0 {
            return block_4020(state, tracer, fn_state);
        } else {
            return block_3072(state, tracer, fn_state);
        };
    }
    fn block_3072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3072_0: const #0u : u8
        let s_3072_0: bool = false;
        // D s_3072_1: write-var gs#135845 <= s_3072_0
        fn_state.gs_135845 = s_3072_0;
        // N s_3072_2: jump b3073
        return block_3073(state, tracer, fn_state);
    }
    fn block_3073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3073_0: read-var gs#135845:u8
        let s_3073_0: bool = fn_state.gs_135845;
        // N s_3073_1: branch s_3073_0 b4019 b3074
        if s_3073_0 {
            return block_4019(state, tracer, fn_state);
        } else {
            return block_3074(state, tracer, fn_state);
        };
    }
    fn block_3074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3074_0: const #0u : u8
        let s_3074_0: bool = false;
        // D s_3074_1: write-var gs#135846 <= s_3074_0
        fn_state.gs_135846 = s_3074_0;
        // N s_3074_2: jump b3075
        return block_3075(state, tracer, fn_state);
    }
    fn block_3075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3075_0: read-var gs#135846:u8
        let s_3075_0: bool = fn_state.gs_135846;
        // N s_3075_1: branch s_3075_0 b4018 b3076
        if s_3075_0 {
            return block_4018(state, tracer, fn_state);
        } else {
            return block_3076(state, tracer, fn_state);
        };
    }
    fn block_3076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3076_0: const #0u : u8
        let s_3076_0: bool = false;
        // D s_3076_1: write-var gs#135847 <= s_3076_0
        fn_state.gs_135847 = s_3076_0;
        // N s_3076_2: jump b3077
        return block_3077(state, tracer, fn_state);
    }
    fn block_3077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3077_0: read-var gs#135847:u8
        let s_3077_0: bool = fn_state.gs_135847;
        // N s_3077_1: branch s_3077_0 b4017 b3078
        if s_3077_0 {
            return block_4017(state, tracer, fn_state);
        } else {
            return block_3078(state, tracer, fn_state);
        };
    }
    fn block_3078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3078_0: read-var CRm:u8
        let s_3078_0: u8 = fn_state.CRm;
        // D s_3078_1: cast zx s_3078_0 -> bv
        let s_3078_1: Bits = Bits::new(s_3078_0 as u128, 4u16);
        // C s_3078_2: const #14u : u8
        let s_3078_2: u8 = 14;
        // C s_3078_3: cast zx s_3078_2 -> bv
        let s_3078_3: Bits = Bits::new(s_3078_2 as u128, 4u16);
        // D s_3078_4: cmp-eq s_3078_1 s_3078_3
        let s_3078_4: bool = ((s_3078_1) == (s_3078_3));
        // N s_3078_5: branch s_3078_4 b4016 b3079
        if s_3078_4 {
            return block_4016(state, tracer, fn_state);
        } else {
            return block_3079(state, tracer, fn_state);
        };
    }
    fn block_3079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3079_0: const #0u : u8
        let s_3079_0: bool = false;
        // D s_3079_1: write-var gs#135848 <= s_3079_0
        fn_state.gs_135848 = s_3079_0;
        // N s_3079_2: jump b3080
        return block_3080(state, tracer, fn_state);
    }
    fn block_3080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3080_0: read-var gs#135848:u8
        let s_3080_0: bool = fn_state.gs_135848;
        // N s_3080_1: branch s_3080_0 b4015 b3081
        if s_3080_0 {
            return block_4015(state, tracer, fn_state);
        } else {
            return block_3081(state, tracer, fn_state);
        };
    }
    fn block_3081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3081_0: const #0u : u8
        let s_3081_0: bool = false;
        // D s_3081_1: write-var gs#135849 <= s_3081_0
        fn_state.gs_135849 = s_3081_0;
        // N s_3081_2: jump b3082
        return block_3082(state, tracer, fn_state);
    }
    fn block_3082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3082_0: read-var gs#135849:u8
        let s_3082_0: bool = fn_state.gs_135849;
        // N s_3082_1: branch s_3082_0 b4014 b3083
        if s_3082_0 {
            return block_4014(state, tracer, fn_state);
        } else {
            return block_3083(state, tracer, fn_state);
        };
    }
    fn block_3083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3083_0: const #0u : u8
        let s_3083_0: bool = false;
        // D s_3083_1: write-var gs#135850 <= s_3083_0
        fn_state.gs_135850 = s_3083_0;
        // N s_3083_2: jump b3084
        return block_3084(state, tracer, fn_state);
    }
    fn block_3084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3084_0: read-var gs#135850:u8
        let s_3084_0: bool = fn_state.gs_135850;
        // N s_3084_1: branch s_3084_0 b4013 b3085
        if s_3084_0 {
            return block_4013(state, tracer, fn_state);
        } else {
            return block_3085(state, tracer, fn_state);
        };
    }
    fn block_3085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3085_0: const #0u : u8
        let s_3085_0: bool = false;
        // D s_3085_1: write-var gs#135851 <= s_3085_0
        fn_state.gs_135851 = s_3085_0;
        // N s_3085_2: jump b3086
        return block_3086(state, tracer, fn_state);
    }
    fn block_3086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3086_0: read-var gs#135851:u8
        let s_3086_0: bool = fn_state.gs_135851;
        // N s_3086_1: branch s_3086_0 b4012 b3087
        if s_3086_0 {
            return block_4012(state, tracer, fn_state);
        } else {
            return block_3087(state, tracer, fn_state);
        };
    }
    fn block_3087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3087_0: read-var CRm:u8
        let s_3087_0: u8 = fn_state.CRm;
        // D s_3087_1: cast zx s_3087_0 -> bv
        let s_3087_1: Bits = Bits::new(s_3087_0 as u128, 4u16);
        // C s_3087_2: const #14u : u8
        let s_3087_2: u8 = 14;
        // C s_3087_3: cast zx s_3087_2 -> bv
        let s_3087_3: Bits = Bits::new(s_3087_2 as u128, 4u16);
        // D s_3087_4: cmp-eq s_3087_1 s_3087_3
        let s_3087_4: bool = ((s_3087_1) == (s_3087_3));
        // N s_3087_5: branch s_3087_4 b4011 b3088
        if s_3087_4 {
            return block_4011(state, tracer, fn_state);
        } else {
            return block_3088(state, tracer, fn_state);
        };
    }
    fn block_3088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3088_0: const #0u : u8
        let s_3088_0: bool = false;
        // D s_3088_1: write-var gs#135852 <= s_3088_0
        fn_state.gs_135852 = s_3088_0;
        // N s_3088_2: jump b3089
        return block_3089(state, tracer, fn_state);
    }
    fn block_3089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3089_0: read-var gs#135852:u8
        let s_3089_0: bool = fn_state.gs_135852;
        // N s_3089_1: branch s_3089_0 b4010 b3090
        if s_3089_0 {
            return block_4010(state, tracer, fn_state);
        } else {
            return block_3090(state, tracer, fn_state);
        };
    }
    fn block_3090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3090_0: const #0u : u8
        let s_3090_0: bool = false;
        // D s_3090_1: write-var gs#135853 <= s_3090_0
        fn_state.gs_135853 = s_3090_0;
        // N s_3090_2: jump b3091
        return block_3091(state, tracer, fn_state);
    }
    fn block_3091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3091_0: read-var gs#135853:u8
        let s_3091_0: bool = fn_state.gs_135853;
        // N s_3091_1: branch s_3091_0 b4009 b3092
        if s_3091_0 {
            return block_4009(state, tracer, fn_state);
        } else {
            return block_3092(state, tracer, fn_state);
        };
    }
    fn block_3092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3092_0: const #0u : u8
        let s_3092_0: bool = false;
        // D s_3092_1: write-var gs#135854 <= s_3092_0
        fn_state.gs_135854 = s_3092_0;
        // N s_3092_2: jump b3093
        return block_3093(state, tracer, fn_state);
    }
    fn block_3093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3093_0: read-var gs#135854:u8
        let s_3093_0: bool = fn_state.gs_135854;
        // N s_3093_1: branch s_3093_0 b4008 b3094
        if s_3093_0 {
            return block_4008(state, tracer, fn_state);
        } else {
            return block_3094(state, tracer, fn_state);
        };
    }
    fn block_3094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3094_0: const #0u : u8
        let s_3094_0: bool = false;
        // D s_3094_1: write-var gs#135855 <= s_3094_0
        fn_state.gs_135855 = s_3094_0;
        // N s_3094_2: jump b3095
        return block_3095(state, tracer, fn_state);
    }
    fn block_3095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3095_0: read-var gs#135855:u8
        let s_3095_0: bool = fn_state.gs_135855;
        // N s_3095_1: branch s_3095_0 b4007 b3096
        if s_3095_0 {
            return block_4007(state, tracer, fn_state);
        } else {
            return block_3096(state, tracer, fn_state);
        };
    }
    fn block_3096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3096_0: read-var CRm:u8
        let s_3096_0: u8 = fn_state.CRm;
        // D s_3096_1: cast zx s_3096_0 -> bv
        let s_3096_1: Bits = Bits::new(s_3096_0 as u128, 4u16);
        // C s_3096_2: const #14u : u8
        let s_3096_2: u8 = 14;
        // C s_3096_3: cast zx s_3096_2 -> bv
        let s_3096_3: Bits = Bits::new(s_3096_2 as u128, 4u16);
        // D s_3096_4: cmp-eq s_3096_1 s_3096_3
        let s_3096_4: bool = ((s_3096_1) == (s_3096_3));
        // N s_3096_5: branch s_3096_4 b4006 b3097
        if s_3096_4 {
            return block_4006(state, tracer, fn_state);
        } else {
            return block_3097(state, tracer, fn_state);
        };
    }
    fn block_3097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3097_0: const #0u : u8
        let s_3097_0: bool = false;
        // D s_3097_1: write-var gs#135856 <= s_3097_0
        fn_state.gs_135856 = s_3097_0;
        // N s_3097_2: jump b3098
        return block_3098(state, tracer, fn_state);
    }
    fn block_3098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3098_0: read-var gs#135856:u8
        let s_3098_0: bool = fn_state.gs_135856;
        // N s_3098_1: branch s_3098_0 b4005 b3099
        if s_3098_0 {
            return block_4005(state, tracer, fn_state);
        } else {
            return block_3099(state, tracer, fn_state);
        };
    }
    fn block_3099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3099_0: const #0u : u8
        let s_3099_0: bool = false;
        // D s_3099_1: write-var gs#135857 <= s_3099_0
        fn_state.gs_135857 = s_3099_0;
        // N s_3099_2: jump b3100
        return block_3100(state, tracer, fn_state);
    }
    fn block_3100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3100_0: read-var gs#135857:u8
        let s_3100_0: bool = fn_state.gs_135857;
        // N s_3100_1: branch s_3100_0 b4004 b3101
        if s_3100_0 {
            return block_4004(state, tracer, fn_state);
        } else {
            return block_3101(state, tracer, fn_state);
        };
    }
    fn block_3101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3101_0: const #0u : u8
        let s_3101_0: bool = false;
        // D s_3101_1: write-var gs#135858 <= s_3101_0
        fn_state.gs_135858 = s_3101_0;
        // N s_3101_2: jump b3102
        return block_3102(state, tracer, fn_state);
    }
    fn block_3102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3102_0: read-var gs#135858:u8
        let s_3102_0: bool = fn_state.gs_135858;
        // N s_3102_1: branch s_3102_0 b4003 b3103
        if s_3102_0 {
            return block_4003(state, tracer, fn_state);
        } else {
            return block_3103(state, tracer, fn_state);
        };
    }
    fn block_3103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3103_0: const #0u : u8
        let s_3103_0: bool = false;
        // D s_3103_1: write-var gs#135859 <= s_3103_0
        fn_state.gs_135859 = s_3103_0;
        // N s_3103_2: jump b3104
        return block_3104(state, tracer, fn_state);
    }
    fn block_3104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3104_0: read-var gs#135859:u8
        let s_3104_0: bool = fn_state.gs_135859;
        // N s_3104_1: branch s_3104_0 b4002 b3105
        if s_3104_0 {
            return block_4002(state, tracer, fn_state);
        } else {
            return block_3105(state, tracer, fn_state);
        };
    }
    fn block_3105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3105_0: read-var CRm:u8
        let s_3105_0: u8 = fn_state.CRm;
        // D s_3105_1: cast zx s_3105_0 -> bv
        let s_3105_1: Bits = Bits::new(s_3105_0 as u128, 4u16);
        // C s_3105_2: const #14u : u8
        let s_3105_2: u8 = 14;
        // C s_3105_3: cast zx s_3105_2 -> bv
        let s_3105_3: Bits = Bits::new(s_3105_2 as u128, 4u16);
        // D s_3105_4: cmp-eq s_3105_1 s_3105_3
        let s_3105_4: bool = ((s_3105_1) == (s_3105_3));
        // N s_3105_5: branch s_3105_4 b4001 b3106
        if s_3105_4 {
            return block_4001(state, tracer, fn_state);
        } else {
            return block_3106(state, tracer, fn_state);
        };
    }
    fn block_3106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3106_0: const #0u : u8
        let s_3106_0: bool = false;
        // D s_3106_1: write-var gs#135860 <= s_3106_0
        fn_state.gs_135860 = s_3106_0;
        // N s_3106_2: jump b3107
        return block_3107(state, tracer, fn_state);
    }
    fn block_3107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3107_0: read-var gs#135860:u8
        let s_3107_0: bool = fn_state.gs_135860;
        // N s_3107_1: branch s_3107_0 b4000 b3108
        if s_3107_0 {
            return block_4000(state, tracer, fn_state);
        } else {
            return block_3108(state, tracer, fn_state);
        };
    }
    fn block_3108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3108_0: const #0u : u8
        let s_3108_0: bool = false;
        // D s_3108_1: write-var gs#135861 <= s_3108_0
        fn_state.gs_135861 = s_3108_0;
        // N s_3108_2: jump b3109
        return block_3109(state, tracer, fn_state);
    }
    fn block_3109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3109_0: read-var gs#135861:u8
        let s_3109_0: bool = fn_state.gs_135861;
        // N s_3109_1: branch s_3109_0 b3999 b3110
        if s_3109_0 {
            return block_3999(state, tracer, fn_state);
        } else {
            return block_3110(state, tracer, fn_state);
        };
    }
    fn block_3110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3110_0: const #0u : u8
        let s_3110_0: bool = false;
        // D s_3110_1: write-var gs#135862 <= s_3110_0
        fn_state.gs_135862 = s_3110_0;
        // N s_3110_2: jump b3111
        return block_3111(state, tracer, fn_state);
    }
    fn block_3111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3111_0: read-var gs#135862:u8
        let s_3111_0: bool = fn_state.gs_135862;
        // N s_3111_1: branch s_3111_0 b3998 b3112
        if s_3111_0 {
            return block_3998(state, tracer, fn_state);
        } else {
            return block_3112(state, tracer, fn_state);
        };
    }
    fn block_3112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3112_0: const #0u : u8
        let s_3112_0: bool = false;
        // D s_3112_1: write-var gs#135863 <= s_3112_0
        fn_state.gs_135863 = s_3112_0;
        // N s_3112_2: jump b3113
        return block_3113(state, tracer, fn_state);
    }
    fn block_3113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3113_0: read-var gs#135863:u8
        let s_3113_0: bool = fn_state.gs_135863;
        // N s_3113_1: branch s_3113_0 b3997 b3114
        if s_3113_0 {
            return block_3997(state, tracer, fn_state);
        } else {
            return block_3114(state, tracer, fn_state);
        };
    }
    fn block_3114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3114_0: read-var CRm:u8
        let s_3114_0: u8 = fn_state.CRm;
        // D s_3114_1: cast zx s_3114_0 -> bv
        let s_3114_1: Bits = Bits::new(s_3114_0 as u128, 4u16);
        // C s_3114_2: const #5u : u8
        let s_3114_2: u8 = 5;
        // C s_3114_3: cast zx s_3114_2 -> bv
        let s_3114_3: Bits = Bits::new(s_3114_2 as u128, 4u16);
        // D s_3114_4: cmp-eq s_3114_1 s_3114_3
        let s_3114_4: bool = ((s_3114_1) == (s_3114_3));
        // N s_3114_5: branch s_3114_4 b3996 b3115
        if s_3114_4 {
            return block_3996(state, tracer, fn_state);
        } else {
            return block_3115(state, tracer, fn_state);
        };
    }
    fn block_3115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3115_0: const #0u : u8
        let s_3115_0: bool = false;
        // D s_3115_1: write-var gs#135864 <= s_3115_0
        fn_state.gs_135864 = s_3115_0;
        // N s_3115_2: jump b3116
        return block_3116(state, tracer, fn_state);
    }
    fn block_3116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3116_0: read-var gs#135864:u8
        let s_3116_0: bool = fn_state.gs_135864;
        // N s_3116_1: branch s_3116_0 b3995 b3117
        if s_3116_0 {
            return block_3995(state, tracer, fn_state);
        } else {
            return block_3117(state, tracer, fn_state);
        };
    }
    fn block_3117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3117_0: const #0u : u8
        let s_3117_0: bool = false;
        // D s_3117_1: write-var gs#135865 <= s_3117_0
        fn_state.gs_135865 = s_3117_0;
        // N s_3117_2: jump b3118
        return block_3118(state, tracer, fn_state);
    }
    fn block_3118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3118_0: read-var gs#135865:u8
        let s_3118_0: bool = fn_state.gs_135865;
        // N s_3118_1: branch s_3118_0 b3994 b3119
        if s_3118_0 {
            return block_3994(state, tracer, fn_state);
        } else {
            return block_3119(state, tracer, fn_state);
        };
    }
    fn block_3119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3119_0: const #0u : u8
        let s_3119_0: bool = false;
        // D s_3119_1: write-var gs#135866 <= s_3119_0
        fn_state.gs_135866 = s_3119_0;
        // N s_3119_2: jump b3120
        return block_3120(state, tracer, fn_state);
    }
    fn block_3120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3120_0: read-var gs#135866:u8
        let s_3120_0: bool = fn_state.gs_135866;
        // N s_3120_1: branch s_3120_0 b3993 b3121
        if s_3120_0 {
            return block_3993(state, tracer, fn_state);
        } else {
            return block_3121(state, tracer, fn_state);
        };
    }
    fn block_3121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3121_0: const #0u : u8
        let s_3121_0: bool = false;
        // D s_3121_1: write-var gs#135867 <= s_3121_0
        fn_state.gs_135867 = s_3121_0;
        // N s_3121_2: jump b3122
        return block_3122(state, tracer, fn_state);
    }
    fn block_3122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3122_0: read-var gs#135867:u8
        let s_3122_0: bool = fn_state.gs_135867;
        // N s_3122_1: branch s_3122_0 b3992 b3123
        if s_3122_0 {
            return block_3992(state, tracer, fn_state);
        } else {
            return block_3123(state, tracer, fn_state);
        };
    }
    fn block_3123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3123_0: read-var CRm:u8
        let s_3123_0: u8 = fn_state.CRm;
        // D s_3123_1: cast zx s_3123_0 -> bv
        let s_3123_1: Bits = Bits::new(s_3123_0 as u128, 4u16);
        // C s_3123_2: const #7u : u8
        let s_3123_2: u8 = 7;
        // C s_3123_3: cast zx s_3123_2 -> bv
        let s_3123_3: Bits = Bits::new(s_3123_2 as u128, 4u16);
        // D s_3123_4: cmp-eq s_3123_1 s_3123_3
        let s_3123_4: bool = ((s_3123_1) == (s_3123_3));
        // N s_3123_5: branch s_3123_4 b3991 b3124
        if s_3123_4 {
            return block_3991(state, tracer, fn_state);
        } else {
            return block_3124(state, tracer, fn_state);
        };
    }
    fn block_3124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3124_0: const #0u : u8
        let s_3124_0: bool = false;
        // D s_3124_1: write-var gs#135868 <= s_3124_0
        fn_state.gs_135868 = s_3124_0;
        // N s_3124_2: jump b3125
        return block_3125(state, tracer, fn_state);
    }
    fn block_3125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3125_0: read-var gs#135868:u8
        let s_3125_0: bool = fn_state.gs_135868;
        // N s_3125_1: branch s_3125_0 b3990 b3126
        if s_3125_0 {
            return block_3990(state, tracer, fn_state);
        } else {
            return block_3126(state, tracer, fn_state);
        };
    }
    fn block_3126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3126_0: const #0u : u8
        let s_3126_0: bool = false;
        // D s_3126_1: write-var gs#135869 <= s_3126_0
        fn_state.gs_135869 = s_3126_0;
        // N s_3126_2: jump b3127
        return block_3127(state, tracer, fn_state);
    }
    fn block_3127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3127_0: read-var gs#135869:u8
        let s_3127_0: bool = fn_state.gs_135869;
        // N s_3127_1: branch s_3127_0 b3989 b3128
        if s_3127_0 {
            return block_3989(state, tracer, fn_state);
        } else {
            return block_3128(state, tracer, fn_state);
        };
    }
    fn block_3128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3128_0: const #0u : u8
        let s_3128_0: bool = false;
        // D s_3128_1: write-var gs#135870 <= s_3128_0
        fn_state.gs_135870 = s_3128_0;
        // N s_3128_2: jump b3129
        return block_3129(state, tracer, fn_state);
    }
    fn block_3129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3129_0: read-var gs#135870:u8
        let s_3129_0: bool = fn_state.gs_135870;
        // N s_3129_1: branch s_3129_0 b3988 b3130
        if s_3129_0 {
            return block_3988(state, tracer, fn_state);
        } else {
            return block_3130(state, tracer, fn_state);
        };
    }
    fn block_3130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3130_0: const #0u : u8
        let s_3130_0: bool = false;
        // D s_3130_1: write-var gs#135871 <= s_3130_0
        fn_state.gs_135871 = s_3130_0;
        // N s_3130_2: jump b3131
        return block_3131(state, tracer, fn_state);
    }
    fn block_3131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3131_0: read-var gs#135871:u8
        let s_3131_0: bool = fn_state.gs_135871;
        // N s_3131_1: branch s_3131_0 b3987 b3132
        if s_3131_0 {
            return block_3987(state, tracer, fn_state);
        } else {
            return block_3132(state, tracer, fn_state);
        };
    }
    fn block_3132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3132_0: read-var CRm:u8
        let s_3132_0: u8 = fn_state.CRm;
        // D s_3132_1: cast zx s_3132_0 -> bv
        let s_3132_1: Bits = Bits::new(s_3132_0 as u128, 4u16);
        // C s_3132_2: const #9u : u8
        let s_3132_2: u8 = 9;
        // C s_3132_3: cast zx s_3132_2 -> bv
        let s_3132_3: Bits = Bits::new(s_3132_2 as u128, 4u16);
        // D s_3132_4: cmp-eq s_3132_1 s_3132_3
        let s_3132_4: bool = ((s_3132_1) == (s_3132_3));
        // N s_3132_5: branch s_3132_4 b3986 b3133
        if s_3132_4 {
            return block_3986(state, tracer, fn_state);
        } else {
            return block_3133(state, tracer, fn_state);
        };
    }
    fn block_3133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3133_0: const #0u : u8
        let s_3133_0: bool = false;
        // D s_3133_1: write-var gs#135872 <= s_3133_0
        fn_state.gs_135872 = s_3133_0;
        // N s_3133_2: jump b3134
        return block_3134(state, tracer, fn_state);
    }
    fn block_3134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3134_0: read-var gs#135872:u8
        let s_3134_0: bool = fn_state.gs_135872;
        // N s_3134_1: branch s_3134_0 b3985 b3135
        if s_3134_0 {
            return block_3985(state, tracer, fn_state);
        } else {
            return block_3135(state, tracer, fn_state);
        };
    }
    fn block_3135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3135_0: const #0u : u8
        let s_3135_0: bool = false;
        // D s_3135_1: write-var gs#135873 <= s_3135_0
        fn_state.gs_135873 = s_3135_0;
        // N s_3135_2: jump b3136
        return block_3136(state, tracer, fn_state);
    }
    fn block_3136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3136_0: read-var gs#135873:u8
        let s_3136_0: bool = fn_state.gs_135873;
        // N s_3136_1: branch s_3136_0 b3984 b3137
        if s_3136_0 {
            return block_3984(state, tracer, fn_state);
        } else {
            return block_3137(state, tracer, fn_state);
        };
    }
    fn block_3137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3137_0: const #0u : u8
        let s_3137_0: bool = false;
        // D s_3137_1: write-var gs#135874 <= s_3137_0
        fn_state.gs_135874 = s_3137_0;
        // N s_3137_2: jump b3138
        return block_3138(state, tracer, fn_state);
    }
    fn block_3138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3138_0: read-var gs#135874:u8
        let s_3138_0: bool = fn_state.gs_135874;
        // N s_3138_1: branch s_3138_0 b3983 b3139
        if s_3138_0 {
            return block_3983(state, tracer, fn_state);
        } else {
            return block_3139(state, tracer, fn_state);
        };
    }
    fn block_3139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3139_0: const #0u : u8
        let s_3139_0: bool = false;
        // D s_3139_1: write-var gs#135875 <= s_3139_0
        fn_state.gs_135875 = s_3139_0;
        // N s_3139_2: jump b3140
        return block_3140(state, tracer, fn_state);
    }
    fn block_3140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3140_0: read-var gs#135875:u8
        let s_3140_0: bool = fn_state.gs_135875;
        // N s_3140_1: branch s_3140_0 b3982 b3141
        if s_3140_0 {
            return block_3982(state, tracer, fn_state);
        } else {
            return block_3141(state, tracer, fn_state);
        };
    }
    fn block_3141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3141_0: read-var CRm:u8
        let s_3141_0: u8 = fn_state.CRm;
        // D s_3141_1: cast zx s_3141_0 -> bv
        let s_3141_1: Bits = Bits::new(s_3141_0 as u128, 4u16);
        // C s_3141_2: const #12u : u8
        let s_3141_2: u8 = 12;
        // C s_3141_3: cast zx s_3141_2 -> bv
        let s_3141_3: Bits = Bits::new(s_3141_2 as u128, 4u16);
        // D s_3141_4: cmp-eq s_3141_1 s_3141_3
        let s_3141_4: bool = ((s_3141_1) == (s_3141_3));
        // N s_3141_5: branch s_3141_4 b3981 b3142
        if s_3141_4 {
            return block_3981(state, tracer, fn_state);
        } else {
            return block_3142(state, tracer, fn_state);
        };
    }
    fn block_3142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3142_0: const #0u : u8
        let s_3142_0: bool = false;
        // D s_3142_1: write-var gs#135876 <= s_3142_0
        fn_state.gs_135876 = s_3142_0;
        // N s_3142_2: jump b3143
        return block_3143(state, tracer, fn_state);
    }
    fn block_3143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3143_0: read-var gs#135876:u8
        let s_3143_0: bool = fn_state.gs_135876;
        // N s_3143_1: branch s_3143_0 b3980 b3144
        if s_3143_0 {
            return block_3980(state, tracer, fn_state);
        } else {
            return block_3144(state, tracer, fn_state);
        };
    }
    fn block_3144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3144_0: const #0u : u8
        let s_3144_0: bool = false;
        // D s_3144_1: write-var gs#135877 <= s_3144_0
        fn_state.gs_135877 = s_3144_0;
        // N s_3144_2: jump b3145
        return block_3145(state, tracer, fn_state);
    }
    fn block_3145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3145_0: read-var gs#135877:u8
        let s_3145_0: bool = fn_state.gs_135877;
        // N s_3145_1: branch s_3145_0 b3979 b3146
        if s_3145_0 {
            return block_3979(state, tracer, fn_state);
        } else {
            return block_3146(state, tracer, fn_state);
        };
    }
    fn block_3146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3146_0: const #0u : u8
        let s_3146_0: bool = false;
        // D s_3146_1: write-var gs#135878 <= s_3146_0
        fn_state.gs_135878 = s_3146_0;
        // N s_3146_2: jump b3147
        return block_3147(state, tracer, fn_state);
    }
    fn block_3147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3147_0: read-var gs#135878:u8
        let s_3147_0: bool = fn_state.gs_135878;
        // N s_3147_1: branch s_3147_0 b3978 b3148
        if s_3147_0 {
            return block_3978(state, tracer, fn_state);
        } else {
            return block_3148(state, tracer, fn_state);
        };
    }
    fn block_3148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3148_0: const #0u : u8
        let s_3148_0: bool = false;
        // D s_3148_1: write-var gs#135879 <= s_3148_0
        fn_state.gs_135879 = s_3148_0;
        // N s_3148_2: jump b3149
        return block_3149(state, tracer, fn_state);
    }
    fn block_3149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3149_0: read-var gs#135879:u8
        let s_3149_0: bool = fn_state.gs_135879;
        // N s_3149_1: branch s_3149_0 b3977 b3150
        if s_3149_0 {
            return block_3977(state, tracer, fn_state);
        } else {
            return block_3150(state, tracer, fn_state);
        };
    }
    fn block_3150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3150_0: read-var CRm:u8
        let s_3150_0: u8 = fn_state.CRm;
        // D s_3150_1: cast zx s_3150_0 -> bv
        let s_3150_1: Bits = Bits::new(s_3150_0 as u128, 4u16);
        // C s_3150_2: const #3u : u8
        let s_3150_2: u8 = 3;
        // C s_3150_3: cast zx s_3150_2 -> bv
        let s_3150_3: Bits = Bits::new(s_3150_2 as u128, 4u16);
        // D s_3150_4: cmp-eq s_3150_1 s_3150_3
        let s_3150_4: bool = ((s_3150_1) == (s_3150_3));
        // N s_3150_5: branch s_3150_4 b3976 b3151
        if s_3150_4 {
            return block_3976(state, tracer, fn_state);
        } else {
            return block_3151(state, tracer, fn_state);
        };
    }
    fn block_3151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3151_0: const #0u : u8
        let s_3151_0: bool = false;
        // D s_3151_1: write-var gs#135880 <= s_3151_0
        fn_state.gs_135880 = s_3151_0;
        // N s_3151_2: jump b3152
        return block_3152(state, tracer, fn_state);
    }
    fn block_3152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3152_0: read-var gs#135880:u8
        let s_3152_0: bool = fn_state.gs_135880;
        // N s_3152_1: branch s_3152_0 b3975 b3153
        if s_3152_0 {
            return block_3975(state, tracer, fn_state);
        } else {
            return block_3153(state, tracer, fn_state);
        };
    }
    fn block_3153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3153_0: const #0u : u8
        let s_3153_0: bool = false;
        // D s_3153_1: write-var gs#135881 <= s_3153_0
        fn_state.gs_135881 = s_3153_0;
        // N s_3153_2: jump b3154
        return block_3154(state, tracer, fn_state);
    }
    fn block_3154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3154_0: read-var gs#135881:u8
        let s_3154_0: bool = fn_state.gs_135881;
        // N s_3154_1: branch s_3154_0 b3974 b3155
        if s_3154_0 {
            return block_3974(state, tracer, fn_state);
        } else {
            return block_3155(state, tracer, fn_state);
        };
    }
    fn block_3155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3155_0: const #0u : u8
        let s_3155_0: bool = false;
        // D s_3155_1: write-var gs#135882 <= s_3155_0
        fn_state.gs_135882 = s_3155_0;
        // N s_3155_2: jump b3156
        return block_3156(state, tracer, fn_state);
    }
    fn block_3156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3156_0: read-var gs#135882:u8
        let s_3156_0: bool = fn_state.gs_135882;
        // N s_3156_1: branch s_3156_0 b3973 b3157
        if s_3156_0 {
            return block_3973(state, tracer, fn_state);
        } else {
            return block_3157(state, tracer, fn_state);
        };
    }
    fn block_3157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3157_0: const #0u : u8
        let s_3157_0: bool = false;
        // D s_3157_1: write-var gs#135883 <= s_3157_0
        fn_state.gs_135883 = s_3157_0;
        // N s_3157_2: jump b3158
        return block_3158(state, tracer, fn_state);
    }
    fn block_3158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3158_0: read-var gs#135883:u8
        let s_3158_0: bool = fn_state.gs_135883;
        // N s_3158_1: branch s_3158_0 b3972 b3159
        if s_3158_0 {
            return block_3972(state, tracer, fn_state);
        } else {
            return block_3159(state, tracer, fn_state);
        };
    }
    fn block_3159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3159_0: read-var CRm:u8
        let s_3159_0: u8 = fn_state.CRm;
        // D s_3159_1: cast zx s_3159_0 -> bv
        let s_3159_1: Bits = Bits::new(s_3159_0 as u128, 4u16);
        // C s_3159_2: const #5u : u8
        let s_3159_2: u8 = 5;
        // C s_3159_3: cast zx s_3159_2 -> bv
        let s_3159_3: Bits = Bits::new(s_3159_2 as u128, 4u16);
        // D s_3159_4: cmp-eq s_3159_1 s_3159_3
        let s_3159_4: bool = ((s_3159_1) == (s_3159_3));
        // N s_3159_5: branch s_3159_4 b3971 b3160
        if s_3159_4 {
            return block_3971(state, tracer, fn_state);
        } else {
            return block_3160(state, tracer, fn_state);
        };
    }
    fn block_3160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3160_0: const #0u : u8
        let s_3160_0: bool = false;
        // D s_3160_1: write-var gs#135884 <= s_3160_0
        fn_state.gs_135884 = s_3160_0;
        // N s_3160_2: jump b3161
        return block_3161(state, tracer, fn_state);
    }
    fn block_3161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3161_0: read-var gs#135884:u8
        let s_3161_0: bool = fn_state.gs_135884;
        // N s_3161_1: branch s_3161_0 b3970 b3162
        if s_3161_0 {
            return block_3970(state, tracer, fn_state);
        } else {
            return block_3162(state, tracer, fn_state);
        };
    }
    fn block_3162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3162_0: const #0u : u8
        let s_3162_0: bool = false;
        // D s_3162_1: write-var gs#135885 <= s_3162_0
        fn_state.gs_135885 = s_3162_0;
        // N s_3162_2: jump b3163
        return block_3163(state, tracer, fn_state);
    }
    fn block_3163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3163_0: read-var gs#135885:u8
        let s_3163_0: bool = fn_state.gs_135885;
        // N s_3163_1: branch s_3163_0 b3969 b3164
        if s_3163_0 {
            return block_3969(state, tracer, fn_state);
        } else {
            return block_3164(state, tracer, fn_state);
        };
    }
    fn block_3164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3164_0: const #0u : u8
        let s_3164_0: bool = false;
        // D s_3164_1: write-var gs#135886 <= s_3164_0
        fn_state.gs_135886 = s_3164_0;
        // N s_3164_2: jump b3165
        return block_3165(state, tracer, fn_state);
    }
    fn block_3165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3165_0: read-var gs#135886:u8
        let s_3165_0: bool = fn_state.gs_135886;
        // N s_3165_1: branch s_3165_0 b3968 b3166
        if s_3165_0 {
            return block_3968(state, tracer, fn_state);
        } else {
            return block_3166(state, tracer, fn_state);
        };
    }
    fn block_3166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3166_0: const #0u : u8
        let s_3166_0: bool = false;
        // D s_3166_1: write-var gs#135887 <= s_3166_0
        fn_state.gs_135887 = s_3166_0;
        // N s_3166_2: jump b3167
        return block_3167(state, tracer, fn_state);
    }
    fn block_3167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3167_0: read-var gs#135887:u8
        let s_3167_0: bool = fn_state.gs_135887;
        // N s_3167_1: branch s_3167_0 b3967 b3168
        if s_3167_0 {
            return block_3967(state, tracer, fn_state);
        } else {
            return block_3168(state, tracer, fn_state);
        };
    }
    fn block_3168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3168_0: read-var CRm:u8
        let s_3168_0: u8 = fn_state.CRm;
        // D s_3168_1: cast zx s_3168_0 -> bv
        let s_3168_1: Bits = Bits::new(s_3168_0 as u128, 4u16);
        // C s_3168_2: const #0u : u8
        let s_3168_2: u8 = 0;
        // C s_3168_3: cast zx s_3168_2 -> bv
        let s_3168_3: Bits = Bits::new(s_3168_2 as u128, 4u16);
        // D s_3168_4: cmp-eq s_3168_1 s_3168_3
        let s_3168_4: bool = ((s_3168_1) == (s_3168_3));
        // N s_3168_5: branch s_3168_4 b3966 b3169
        if s_3168_4 {
            return block_3966(state, tracer, fn_state);
        } else {
            return block_3169(state, tracer, fn_state);
        };
    }
    fn block_3169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3169_0: const #0u : u8
        let s_3169_0: bool = false;
        // D s_3169_1: write-var gs#135888 <= s_3169_0
        fn_state.gs_135888 = s_3169_0;
        // N s_3169_2: jump b3170
        return block_3170(state, tracer, fn_state);
    }
    fn block_3170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3170_0: read-var gs#135888:u8
        let s_3170_0: bool = fn_state.gs_135888;
        // N s_3170_1: branch s_3170_0 b3965 b3171
        if s_3170_0 {
            return block_3965(state, tracer, fn_state);
        } else {
            return block_3171(state, tracer, fn_state);
        };
    }
    fn block_3171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3171_0: const #0u : u8
        let s_3171_0: bool = false;
        // D s_3171_1: write-var gs#135889 <= s_3171_0
        fn_state.gs_135889 = s_3171_0;
        // N s_3171_2: jump b3172
        return block_3172(state, tracer, fn_state);
    }
    fn block_3172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3172_0: read-var gs#135889:u8
        let s_3172_0: bool = fn_state.gs_135889;
        // N s_3172_1: branch s_3172_0 b3964 b3173
        if s_3172_0 {
            return block_3964(state, tracer, fn_state);
        } else {
            return block_3173(state, tracer, fn_state);
        };
    }
    fn block_3173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3173_0: const #0u : u8
        let s_3173_0: bool = false;
        // D s_3173_1: write-var gs#135890 <= s_3173_0
        fn_state.gs_135890 = s_3173_0;
        // N s_3173_2: jump b3174
        return block_3174(state, tracer, fn_state);
    }
    fn block_3174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3174_0: read-var gs#135890:u8
        let s_3174_0: bool = fn_state.gs_135890;
        // N s_3174_1: branch s_3174_0 b3963 b3175
        if s_3174_0 {
            return block_3963(state, tracer, fn_state);
        } else {
            return block_3175(state, tracer, fn_state);
        };
    }
    fn block_3175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3175_0: const #0u : u8
        let s_3175_0: bool = false;
        // D s_3175_1: write-var gs#135891 <= s_3175_0
        fn_state.gs_135891 = s_3175_0;
        // N s_3175_2: jump b3176
        return block_3176(state, tracer, fn_state);
    }
    fn block_3176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3176_0: read-var gs#135891:u8
        let s_3176_0: bool = fn_state.gs_135891;
        // N s_3176_1: branch s_3176_0 b3962 b3177
        if s_3176_0 {
            return block_3962(state, tracer, fn_state);
        } else {
            return block_3177(state, tracer, fn_state);
        };
    }
    fn block_3177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3177_0: read-var CRm:u8
        let s_3177_0: u8 = fn_state.CRm;
        // D s_3177_1: cast zx s_3177_0 -> bv
        let s_3177_1: Bits = Bits::new(s_3177_0 as u128, 4u16);
        // C s_3177_2: const #5u : u8
        let s_3177_2: u8 = 5;
        // C s_3177_3: cast zx s_3177_2 -> bv
        let s_3177_3: Bits = Bits::new(s_3177_2 as u128, 4u16);
        // D s_3177_4: cmp-eq s_3177_1 s_3177_3
        let s_3177_4: bool = ((s_3177_1) == (s_3177_3));
        // N s_3177_5: branch s_3177_4 b3961 b3178
        if s_3177_4 {
            return block_3961(state, tracer, fn_state);
        } else {
            return block_3178(state, tracer, fn_state);
        };
    }
    fn block_3178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3178_0: const #0u : u8
        let s_3178_0: bool = false;
        // D s_3178_1: write-var gs#135892 <= s_3178_0
        fn_state.gs_135892 = s_3178_0;
        // N s_3178_2: jump b3179
        return block_3179(state, tracer, fn_state);
    }
    fn block_3179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3179_0: read-var gs#135892:u8
        let s_3179_0: bool = fn_state.gs_135892;
        // N s_3179_1: branch s_3179_0 b3960 b3180
        if s_3179_0 {
            return block_3960(state, tracer, fn_state);
        } else {
            return block_3180(state, tracer, fn_state);
        };
    }
    fn block_3180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3180_0: const #0u : u8
        let s_3180_0: bool = false;
        // D s_3180_1: write-var gs#135893 <= s_3180_0
        fn_state.gs_135893 = s_3180_0;
        // N s_3180_2: jump b3181
        return block_3181(state, tracer, fn_state);
    }
    fn block_3181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3181_0: read-var gs#135893:u8
        let s_3181_0: bool = fn_state.gs_135893;
        // N s_3181_1: branch s_3181_0 b3959 b3182
        if s_3181_0 {
            return block_3959(state, tracer, fn_state);
        } else {
            return block_3182(state, tracer, fn_state);
        };
    }
    fn block_3182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3182_0: const #0u : u8
        let s_3182_0: bool = false;
        // D s_3182_1: write-var gs#135894 <= s_3182_0
        fn_state.gs_135894 = s_3182_0;
        // N s_3182_2: jump b3183
        return block_3183(state, tracer, fn_state);
    }
    fn block_3183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3183_0: read-var gs#135894:u8
        let s_3183_0: bool = fn_state.gs_135894;
        // N s_3183_1: branch s_3183_0 b3958 b3184
        if s_3183_0 {
            return block_3958(state, tracer, fn_state);
        } else {
            return block_3184(state, tracer, fn_state);
        };
    }
    fn block_3184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3184_0: const #0u : u8
        let s_3184_0: bool = false;
        // D s_3184_1: write-var gs#135895 <= s_3184_0
        fn_state.gs_135895 = s_3184_0;
        // N s_3184_2: jump b3185
        return block_3185(state, tracer, fn_state);
    }
    fn block_3185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3185_0: read-var gs#135895:u8
        let s_3185_0: bool = fn_state.gs_135895;
        // N s_3185_1: branch s_3185_0 b3957 b3186
        if s_3185_0 {
            return block_3957(state, tracer, fn_state);
        } else {
            return block_3186(state, tracer, fn_state);
        };
    }
    fn block_3186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3186_0: read-var CRm:u8
        let s_3186_0: u8 = fn_state.CRm;
        // D s_3186_1: cast zx s_3186_0 -> bv
        let s_3186_1: Bits = Bits::new(s_3186_0 as u128, 4u16);
        // C s_3186_2: const #2u : u8
        let s_3186_2: u8 = 2;
        // C s_3186_3: cast zx s_3186_2 -> bv
        let s_3186_3: Bits = Bits::new(s_3186_2 as u128, 4u16);
        // D s_3186_4: cmp-eq s_3186_1 s_3186_3
        let s_3186_4: bool = ((s_3186_1) == (s_3186_3));
        // N s_3186_5: branch s_3186_4 b3956 b3187
        if s_3186_4 {
            return block_3956(state, tracer, fn_state);
        } else {
            return block_3187(state, tracer, fn_state);
        };
    }
    fn block_3187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3187_0: const #0u : u8
        let s_3187_0: bool = false;
        // D s_3187_1: write-var gs#135896 <= s_3187_0
        fn_state.gs_135896 = s_3187_0;
        // N s_3187_2: jump b3188
        return block_3188(state, tracer, fn_state);
    }
    fn block_3188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3188_0: read-var gs#135896:u8
        let s_3188_0: bool = fn_state.gs_135896;
        // N s_3188_1: branch s_3188_0 b3955 b3189
        if s_3188_0 {
            return block_3955(state, tracer, fn_state);
        } else {
            return block_3189(state, tracer, fn_state);
        };
    }
    fn block_3189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3189_0: const #0u : u8
        let s_3189_0: bool = false;
        // D s_3189_1: write-var gs#135897 <= s_3189_0
        fn_state.gs_135897 = s_3189_0;
        // N s_3189_2: jump b3190
        return block_3190(state, tracer, fn_state);
    }
    fn block_3190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3190_0: read-var gs#135897:u8
        let s_3190_0: bool = fn_state.gs_135897;
        // N s_3190_1: branch s_3190_0 b3954 b3191
        if s_3190_0 {
            return block_3954(state, tracer, fn_state);
        } else {
            return block_3191(state, tracer, fn_state);
        };
    }
    fn block_3191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3191_0: const #0u : u8
        let s_3191_0: bool = false;
        // D s_3191_1: write-var gs#135898 <= s_3191_0
        fn_state.gs_135898 = s_3191_0;
        // N s_3191_2: jump b3192
        return block_3192(state, tracer, fn_state);
    }
    fn block_3192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3192_0: read-var gs#135898:u8
        let s_3192_0: bool = fn_state.gs_135898;
        // N s_3192_1: branch s_3192_0 b3953 b3193
        if s_3192_0 {
            return block_3953(state, tracer, fn_state);
        } else {
            return block_3193(state, tracer, fn_state);
        };
    }
    fn block_3193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3193_0: const #0u : u8
        let s_3193_0: bool = false;
        // D s_3193_1: write-var gs#135899 <= s_3193_0
        fn_state.gs_135899 = s_3193_0;
        // N s_3193_2: jump b3194
        return block_3194(state, tracer, fn_state);
    }
    fn block_3194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3194_0: read-var gs#135899:u8
        let s_3194_0: bool = fn_state.gs_135899;
        // N s_3194_1: branch s_3194_0 b3952 b3195
        if s_3194_0 {
            return block_3952(state, tracer, fn_state);
        } else {
            return block_3195(state, tracer, fn_state);
        };
    }
    fn block_3195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3195_0: read-var CRm:u8
        let s_3195_0: u8 = fn_state.CRm;
        // D s_3195_1: cast zx s_3195_0 -> bv
        let s_3195_1: Bits = Bits::new(s_3195_0 as u128, 4u16);
        // C s_3195_2: const #15u : u8
        let s_3195_2: u8 = 15;
        // C s_3195_3: cast zx s_3195_2 -> bv
        let s_3195_3: Bits = Bits::new(s_3195_2 as u128, 4u16);
        // D s_3195_4: cmp-eq s_3195_1 s_3195_3
        let s_3195_4: bool = ((s_3195_1) == (s_3195_3));
        // N s_3195_5: branch s_3195_4 b3951 b3196
        if s_3195_4 {
            return block_3951(state, tracer, fn_state);
        } else {
            return block_3196(state, tracer, fn_state);
        };
    }
    fn block_3196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3196_0: const #0u : u8
        let s_3196_0: bool = false;
        // D s_3196_1: write-var gs#135900 <= s_3196_0
        fn_state.gs_135900 = s_3196_0;
        // N s_3196_2: jump b3197
        return block_3197(state, tracer, fn_state);
    }
    fn block_3197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3197_0: read-var gs#135900:u8
        let s_3197_0: bool = fn_state.gs_135900;
        // N s_3197_1: branch s_3197_0 b3950 b3198
        if s_3197_0 {
            return block_3950(state, tracer, fn_state);
        } else {
            return block_3198(state, tracer, fn_state);
        };
    }
    fn block_3198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3198_0: const #0u : u8
        let s_3198_0: bool = false;
        // D s_3198_1: write-var gs#135901 <= s_3198_0
        fn_state.gs_135901 = s_3198_0;
        // N s_3198_2: jump b3199
        return block_3199(state, tracer, fn_state);
    }
    fn block_3199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3199_0: read-var gs#135901:u8
        let s_3199_0: bool = fn_state.gs_135901;
        // N s_3199_1: branch s_3199_0 b3949 b3200
        if s_3199_0 {
            return block_3949(state, tracer, fn_state);
        } else {
            return block_3200(state, tracer, fn_state);
        };
    }
    fn block_3200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3200_0: const #0u : u8
        let s_3200_0: bool = false;
        // D s_3200_1: write-var gs#135902 <= s_3200_0
        fn_state.gs_135902 = s_3200_0;
        // N s_3200_2: jump b3201
        return block_3201(state, tracer, fn_state);
    }
    fn block_3201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3201_0: read-var gs#135902:u8
        let s_3201_0: bool = fn_state.gs_135902;
        // N s_3201_1: branch s_3201_0 b3948 b3202
        if s_3201_0 {
            return block_3948(state, tracer, fn_state);
        } else {
            return block_3202(state, tracer, fn_state);
        };
    }
    fn block_3202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3202_0: const #0u : u8
        let s_3202_0: bool = false;
        // D s_3202_1: write-var gs#135903 <= s_3202_0
        fn_state.gs_135903 = s_3202_0;
        // N s_3202_2: jump b3203
        return block_3203(state, tracer, fn_state);
    }
    fn block_3203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3203_0: read-var gs#135903:u8
        let s_3203_0: bool = fn_state.gs_135903;
        // N s_3203_1: branch s_3203_0 b3947 b3204
        if s_3203_0 {
            return block_3947(state, tracer, fn_state);
        } else {
            return block_3204(state, tracer, fn_state);
        };
    }
    fn block_3204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3204_0: read-var CRm:u8
        let s_3204_0: u8 = fn_state.CRm;
        // D s_3204_1: cast zx s_3204_0 -> bv
        let s_3204_1: Bits = Bits::new(s_3204_0 as u128, 4u16);
        // C s_3204_2: const #15u : u8
        let s_3204_2: u8 = 15;
        // C s_3204_3: cast zx s_3204_2 -> bv
        let s_3204_3: Bits = Bits::new(s_3204_2 as u128, 4u16);
        // D s_3204_4: cmp-eq s_3204_1 s_3204_3
        let s_3204_4: bool = ((s_3204_1) == (s_3204_3));
        // N s_3204_5: branch s_3204_4 b3946 b3205
        if s_3204_4 {
            return block_3946(state, tracer, fn_state);
        } else {
            return block_3205(state, tracer, fn_state);
        };
    }
    fn block_3205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3205_0: const #0u : u8
        let s_3205_0: bool = false;
        // D s_3205_1: write-var gs#135904 <= s_3205_0
        fn_state.gs_135904 = s_3205_0;
        // N s_3205_2: jump b3206
        return block_3206(state, tracer, fn_state);
    }
    fn block_3206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3206_0: read-var gs#135904:u8
        let s_3206_0: bool = fn_state.gs_135904;
        // N s_3206_1: branch s_3206_0 b3945 b3207
        if s_3206_0 {
            return block_3945(state, tracer, fn_state);
        } else {
            return block_3207(state, tracer, fn_state);
        };
    }
    fn block_3207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3207_0: const #0u : u8
        let s_3207_0: bool = false;
        // D s_3207_1: write-var gs#135905 <= s_3207_0
        fn_state.gs_135905 = s_3207_0;
        // N s_3207_2: jump b3208
        return block_3208(state, tracer, fn_state);
    }
    fn block_3208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3208_0: read-var gs#135905:u8
        let s_3208_0: bool = fn_state.gs_135905;
        // N s_3208_1: branch s_3208_0 b3944 b3209
        if s_3208_0 {
            return block_3944(state, tracer, fn_state);
        } else {
            return block_3209(state, tracer, fn_state);
        };
    }
    fn block_3209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3209_0: const #0u : u8
        let s_3209_0: bool = false;
        // D s_3209_1: write-var gs#135906 <= s_3209_0
        fn_state.gs_135906 = s_3209_0;
        // N s_3209_2: jump b3210
        return block_3210(state, tracer, fn_state);
    }
    fn block_3210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3210_0: read-var gs#135906:u8
        let s_3210_0: bool = fn_state.gs_135906;
        // N s_3210_1: branch s_3210_0 b3943 b3211
        if s_3210_0 {
            return block_3943(state, tracer, fn_state);
        } else {
            return block_3211(state, tracer, fn_state);
        };
    }
    fn block_3211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3211_0: const #0u : u8
        let s_3211_0: bool = false;
        // D s_3211_1: write-var gs#135907 <= s_3211_0
        fn_state.gs_135907 = s_3211_0;
        // N s_3211_2: jump b3212
        return block_3212(state, tracer, fn_state);
    }
    fn block_3212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3212_0: read-var gs#135907:u8
        let s_3212_0: bool = fn_state.gs_135907;
        // N s_3212_1: branch s_3212_0 b3942 b3213
        if s_3212_0 {
            return block_3942(state, tracer, fn_state);
        } else {
            return block_3213(state, tracer, fn_state);
        };
    }
    fn block_3213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3213_0: read-var CRm:u8
        let s_3213_0: u8 = fn_state.CRm;
        // D s_3213_1: cast zx s_3213_0 -> bv
        let s_3213_1: Bits = Bits::new(s_3213_0 as u128, 4u16);
        // C s_3213_2: const #15u : u8
        let s_3213_2: u8 = 15;
        // C s_3213_3: cast zx s_3213_2 -> bv
        let s_3213_3: Bits = Bits::new(s_3213_2 as u128, 4u16);
        // D s_3213_4: cmp-eq s_3213_1 s_3213_3
        let s_3213_4: bool = ((s_3213_1) == (s_3213_3));
        // N s_3213_5: branch s_3213_4 b3941 b3214
        if s_3213_4 {
            return block_3941(state, tracer, fn_state);
        } else {
            return block_3214(state, tracer, fn_state);
        };
    }
    fn block_3214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3214_0: const #0u : u8
        let s_3214_0: bool = false;
        // D s_3214_1: write-var gs#135908 <= s_3214_0
        fn_state.gs_135908 = s_3214_0;
        // N s_3214_2: jump b3215
        return block_3215(state, tracer, fn_state);
    }
    fn block_3215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3215_0: read-var gs#135908:u8
        let s_3215_0: bool = fn_state.gs_135908;
        // N s_3215_1: branch s_3215_0 b3940 b3216
        if s_3215_0 {
            return block_3940(state, tracer, fn_state);
        } else {
            return block_3216(state, tracer, fn_state);
        };
    }
    fn block_3216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3216_0: const #0u : u8
        let s_3216_0: bool = false;
        // D s_3216_1: write-var gs#135909 <= s_3216_0
        fn_state.gs_135909 = s_3216_0;
        // N s_3216_2: jump b3217
        return block_3217(state, tracer, fn_state);
    }
    fn block_3217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3217_0: read-var gs#135909:u8
        let s_3217_0: bool = fn_state.gs_135909;
        // N s_3217_1: branch s_3217_0 b3939 b3218
        if s_3217_0 {
            return block_3939(state, tracer, fn_state);
        } else {
            return block_3218(state, tracer, fn_state);
        };
    }
    fn block_3218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3218_0: const #0u : u8
        let s_3218_0: bool = false;
        // D s_3218_1: write-var gs#135910 <= s_3218_0
        fn_state.gs_135910 = s_3218_0;
        // N s_3218_2: jump b3219
        return block_3219(state, tracer, fn_state);
    }
    fn block_3219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3219_0: read-var gs#135910:u8
        let s_3219_0: bool = fn_state.gs_135910;
        // N s_3219_1: branch s_3219_0 b3938 b3220
        if s_3219_0 {
            return block_3938(state, tracer, fn_state);
        } else {
            return block_3220(state, tracer, fn_state);
        };
    }
    fn block_3220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3220_0: const #0u : u8
        let s_3220_0: bool = false;
        // D s_3220_1: write-var gs#135911 <= s_3220_0
        fn_state.gs_135911 = s_3220_0;
        // N s_3220_2: jump b3221
        return block_3221(state, tracer, fn_state);
    }
    fn block_3221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3221_0: read-var gs#135911:u8
        let s_3221_0: bool = fn_state.gs_135911;
        // N s_3221_1: branch s_3221_0 b3937 b3222
        if s_3221_0 {
            return block_3937(state, tracer, fn_state);
        } else {
            return block_3222(state, tracer, fn_state);
        };
    }
    fn block_3222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3222_0: read-var CRm:u8
        let s_3222_0: u8 = fn_state.CRm;
        // D s_3222_1: cast zx s_3222_0 -> bv
        let s_3222_1: Bits = Bits::new(s_3222_0 as u128, 4u16);
        // C s_3222_2: const #15u : u8
        let s_3222_2: u8 = 15;
        // C s_3222_3: cast zx s_3222_2 -> bv
        let s_3222_3: Bits = Bits::new(s_3222_2 as u128, 4u16);
        // D s_3222_4: cmp-eq s_3222_1 s_3222_3
        let s_3222_4: bool = ((s_3222_1) == (s_3222_3));
        // N s_3222_5: branch s_3222_4 b3936 b3223
        if s_3222_4 {
            return block_3936(state, tracer, fn_state);
        } else {
            return block_3223(state, tracer, fn_state);
        };
    }
    fn block_3223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3223_0: const #0u : u8
        let s_3223_0: bool = false;
        // D s_3223_1: write-var gs#135912 <= s_3223_0
        fn_state.gs_135912 = s_3223_0;
        // N s_3223_2: jump b3224
        return block_3224(state, tracer, fn_state);
    }
    fn block_3224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3224_0: read-var gs#135912:u8
        let s_3224_0: bool = fn_state.gs_135912;
        // N s_3224_1: branch s_3224_0 b3935 b3225
        if s_3224_0 {
            return block_3935(state, tracer, fn_state);
        } else {
            return block_3225(state, tracer, fn_state);
        };
    }
    fn block_3225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3225_0: const #0u : u8
        let s_3225_0: bool = false;
        // D s_3225_1: write-var gs#135913 <= s_3225_0
        fn_state.gs_135913 = s_3225_0;
        // N s_3225_2: jump b3226
        return block_3226(state, tracer, fn_state);
    }
    fn block_3226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3226_0: read-var gs#135913:u8
        let s_3226_0: bool = fn_state.gs_135913;
        // N s_3226_1: branch s_3226_0 b3934 b3227
        if s_3226_0 {
            return block_3934(state, tracer, fn_state);
        } else {
            return block_3227(state, tracer, fn_state);
        };
    }
    fn block_3227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3227_0: const #0u : u8
        let s_3227_0: bool = false;
        // D s_3227_1: write-var gs#135914 <= s_3227_0
        fn_state.gs_135914 = s_3227_0;
        // N s_3227_2: jump b3228
        return block_3228(state, tracer, fn_state);
    }
    fn block_3228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3228_0: read-var gs#135914:u8
        let s_3228_0: bool = fn_state.gs_135914;
        // N s_3228_1: branch s_3228_0 b3933 b3229
        if s_3228_0 {
            return block_3933(state, tracer, fn_state);
        } else {
            return block_3229(state, tracer, fn_state);
        };
    }
    fn block_3229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3229_0: const #0u : u8
        let s_3229_0: bool = false;
        // D s_3229_1: write-var gs#135915 <= s_3229_0
        fn_state.gs_135915 = s_3229_0;
        // N s_3229_2: jump b3230
        return block_3230(state, tracer, fn_state);
    }
    fn block_3230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3230_0: read-var gs#135915:u8
        let s_3230_0: bool = fn_state.gs_135915;
        // N s_3230_1: branch s_3230_0 b3932 b3231
        if s_3230_0 {
            return block_3932(state, tracer, fn_state);
        } else {
            return block_3231(state, tracer, fn_state);
        };
    }
    fn block_3231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3231_0: read-var CRm:u8
        let s_3231_0: u8 = fn_state.CRm;
        // D s_3231_1: cast zx s_3231_0 -> bv
        let s_3231_1: Bits = Bits::new(s_3231_0 as u128, 4u16);
        // C s_3231_2: const #15u : u8
        let s_3231_2: u8 = 15;
        // C s_3231_3: cast zx s_3231_2 -> bv
        let s_3231_3: Bits = Bits::new(s_3231_2 as u128, 4u16);
        // D s_3231_4: cmp-eq s_3231_1 s_3231_3
        let s_3231_4: bool = ((s_3231_1) == (s_3231_3));
        // N s_3231_5: branch s_3231_4 b3931 b3232
        if s_3231_4 {
            return block_3931(state, tracer, fn_state);
        } else {
            return block_3232(state, tracer, fn_state);
        };
    }
    fn block_3232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3232_0: const #0u : u8
        let s_3232_0: bool = false;
        // D s_3232_1: write-var gs#135916 <= s_3232_0
        fn_state.gs_135916 = s_3232_0;
        // N s_3232_2: jump b3233
        return block_3233(state, tracer, fn_state);
    }
    fn block_3233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3233_0: read-var gs#135916:u8
        let s_3233_0: bool = fn_state.gs_135916;
        // N s_3233_1: branch s_3233_0 b3930 b3234
        if s_3233_0 {
            return block_3930(state, tracer, fn_state);
        } else {
            return block_3234(state, tracer, fn_state);
        };
    }
    fn block_3234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3234_0: const #0u : u8
        let s_3234_0: bool = false;
        // D s_3234_1: write-var gs#135917 <= s_3234_0
        fn_state.gs_135917 = s_3234_0;
        // N s_3234_2: jump b3235
        return block_3235(state, tracer, fn_state);
    }
    fn block_3235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3235_0: read-var gs#135917:u8
        let s_3235_0: bool = fn_state.gs_135917;
        // N s_3235_1: branch s_3235_0 b3929 b3236
        if s_3235_0 {
            return block_3929(state, tracer, fn_state);
        } else {
            return block_3236(state, tracer, fn_state);
        };
    }
    fn block_3236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3236_0: const #0u : u8
        let s_3236_0: bool = false;
        // D s_3236_1: write-var gs#135918 <= s_3236_0
        fn_state.gs_135918 = s_3236_0;
        // N s_3236_2: jump b3237
        return block_3237(state, tracer, fn_state);
    }
    fn block_3237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3237_0: read-var gs#135918:u8
        let s_3237_0: bool = fn_state.gs_135918;
        // N s_3237_1: branch s_3237_0 b3928 b3238
        if s_3237_0 {
            return block_3928(state, tracer, fn_state);
        } else {
            return block_3238(state, tracer, fn_state);
        };
    }
    fn block_3238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3238_0: const #0u : u8
        let s_3238_0: bool = false;
        // D s_3238_1: write-var gs#135919 <= s_3238_0
        fn_state.gs_135919 = s_3238_0;
        // N s_3238_2: jump b3239
        return block_3239(state, tracer, fn_state);
    }
    fn block_3239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3239_0: read-var gs#135919:u8
        let s_3239_0: bool = fn_state.gs_135919;
        // N s_3239_1: branch s_3239_0 b3927 b3240
        if s_3239_0 {
            return block_3927(state, tracer, fn_state);
        } else {
            return block_3240(state, tracer, fn_state);
        };
    }
    fn block_3240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3240_0: read-var CRm:u8
        let s_3240_0: u8 = fn_state.CRm;
        // D s_3240_1: cast zx s_3240_0 -> bv
        let s_3240_1: Bits = Bits::new(s_3240_0 as u128, 4u16);
        // C s_3240_2: const #15u : u8
        let s_3240_2: u8 = 15;
        // C s_3240_3: cast zx s_3240_2 -> bv
        let s_3240_3: Bits = Bits::new(s_3240_2 as u128, 4u16);
        // D s_3240_4: cmp-eq s_3240_1 s_3240_3
        let s_3240_4: bool = ((s_3240_1) == (s_3240_3));
        // N s_3240_5: branch s_3240_4 b3926 b3241
        if s_3240_4 {
            return block_3926(state, tracer, fn_state);
        } else {
            return block_3241(state, tracer, fn_state);
        };
    }
    fn block_3241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3241_0: const #0u : u8
        let s_3241_0: bool = false;
        // D s_3241_1: write-var gs#135920 <= s_3241_0
        fn_state.gs_135920 = s_3241_0;
        // N s_3241_2: jump b3242
        return block_3242(state, tracer, fn_state);
    }
    fn block_3242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3242_0: read-var gs#135920:u8
        let s_3242_0: bool = fn_state.gs_135920;
        // N s_3242_1: branch s_3242_0 b3925 b3243
        if s_3242_0 {
            return block_3925(state, tracer, fn_state);
        } else {
            return block_3243(state, tracer, fn_state);
        };
    }
    fn block_3243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3243_0: const #0u : u8
        let s_3243_0: bool = false;
        // D s_3243_1: write-var gs#135921 <= s_3243_0
        fn_state.gs_135921 = s_3243_0;
        // N s_3243_2: jump b3244
        return block_3244(state, tracer, fn_state);
    }
    fn block_3244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3244_0: read-var gs#135921:u8
        let s_3244_0: bool = fn_state.gs_135921;
        // N s_3244_1: branch s_3244_0 b3924 b3245
        if s_3244_0 {
            return block_3924(state, tracer, fn_state);
        } else {
            return block_3245(state, tracer, fn_state);
        };
    }
    fn block_3245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3245_0: const #0u : u8
        let s_3245_0: bool = false;
        // D s_3245_1: write-var gs#135922 <= s_3245_0
        fn_state.gs_135922 = s_3245_0;
        // N s_3245_2: jump b3246
        return block_3246(state, tracer, fn_state);
    }
    fn block_3246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3246_0: read-var gs#135922:u8
        let s_3246_0: bool = fn_state.gs_135922;
        // N s_3246_1: branch s_3246_0 b3923 b3247
        if s_3246_0 {
            return block_3923(state, tracer, fn_state);
        } else {
            return block_3247(state, tracer, fn_state);
        };
    }
    fn block_3247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3247_0: const #0u : u8
        let s_3247_0: bool = false;
        // D s_3247_1: write-var gs#135923 <= s_3247_0
        fn_state.gs_135923 = s_3247_0;
        // N s_3247_2: jump b3248
        return block_3248(state, tracer, fn_state);
    }
    fn block_3248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3248_0: read-var gs#135923:u8
        let s_3248_0: bool = fn_state.gs_135923;
        // N s_3248_1: branch s_3248_0 b3922 b3249
        if s_3248_0 {
            return block_3922(state, tracer, fn_state);
        } else {
            return block_3249(state, tracer, fn_state);
        };
    }
    fn block_3249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3249_0: read-var CRm:u8
        let s_3249_0: u8 = fn_state.CRm;
        // D s_3249_1: cast zx s_3249_0 -> bv
        let s_3249_1: Bits = Bits::new(s_3249_0 as u128, 4u16);
        // C s_3249_2: const #15u : u8
        let s_3249_2: u8 = 15;
        // C s_3249_3: cast zx s_3249_2 -> bv
        let s_3249_3: Bits = Bits::new(s_3249_2 as u128, 4u16);
        // D s_3249_4: cmp-eq s_3249_1 s_3249_3
        let s_3249_4: bool = ((s_3249_1) == (s_3249_3));
        // N s_3249_5: branch s_3249_4 b3921 b3250
        if s_3249_4 {
            return block_3921(state, tracer, fn_state);
        } else {
            return block_3250(state, tracer, fn_state);
        };
    }
    fn block_3250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3250_0: const #0u : u8
        let s_3250_0: bool = false;
        // D s_3250_1: write-var gs#135924 <= s_3250_0
        fn_state.gs_135924 = s_3250_0;
        // N s_3250_2: jump b3251
        return block_3251(state, tracer, fn_state);
    }
    fn block_3251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3251_0: read-var gs#135924:u8
        let s_3251_0: bool = fn_state.gs_135924;
        // N s_3251_1: branch s_3251_0 b3920 b3252
        if s_3251_0 {
            return block_3920(state, tracer, fn_state);
        } else {
            return block_3252(state, tracer, fn_state);
        };
    }
    fn block_3252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3252_0: const #0u : u8
        let s_3252_0: bool = false;
        // D s_3252_1: write-var gs#135925 <= s_3252_0
        fn_state.gs_135925 = s_3252_0;
        // N s_3252_2: jump b3253
        return block_3253(state, tracer, fn_state);
    }
    fn block_3253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3253_0: read-var gs#135925:u8
        let s_3253_0: bool = fn_state.gs_135925;
        // N s_3253_1: branch s_3253_0 b3919 b3254
        if s_3253_0 {
            return block_3919(state, tracer, fn_state);
        } else {
            return block_3254(state, tracer, fn_state);
        };
    }
    fn block_3254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3254_0: const #0u : u8
        let s_3254_0: bool = false;
        // D s_3254_1: write-var gs#135926 <= s_3254_0
        fn_state.gs_135926 = s_3254_0;
        // N s_3254_2: jump b3255
        return block_3255(state, tracer, fn_state);
    }
    fn block_3255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3255_0: read-var gs#135926:u8
        let s_3255_0: bool = fn_state.gs_135926;
        // N s_3255_1: branch s_3255_0 b3918 b3256
        if s_3255_0 {
            return block_3918(state, tracer, fn_state);
        } else {
            return block_3256(state, tracer, fn_state);
        };
    }
    fn block_3256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3256_0: const #0u : u8
        let s_3256_0: bool = false;
        // D s_3256_1: write-var gs#135927 <= s_3256_0
        fn_state.gs_135927 = s_3256_0;
        // N s_3256_2: jump b3257
        return block_3257(state, tracer, fn_state);
    }
    fn block_3257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3257_0: read-var gs#135927:u8
        let s_3257_0: bool = fn_state.gs_135927;
        // N s_3257_1: branch s_3257_0 b3917 b3258
        if s_3257_0 {
            return block_3917(state, tracer, fn_state);
        } else {
            return block_3258(state, tracer, fn_state);
        };
    }
    fn block_3258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3258_0: read-var CRm:u8
        let s_3258_0: u8 = fn_state.CRm;
        // D s_3258_1: cast zx s_3258_0 -> bv
        let s_3258_1: Bits = Bits::new(s_3258_0 as u128, 4u16);
        // C s_3258_2: const #15u : u8
        let s_3258_2: u8 = 15;
        // C s_3258_3: cast zx s_3258_2 -> bv
        let s_3258_3: Bits = Bits::new(s_3258_2 as u128, 4u16);
        // D s_3258_4: cmp-eq s_3258_1 s_3258_3
        let s_3258_4: bool = ((s_3258_1) == (s_3258_3));
        // N s_3258_5: branch s_3258_4 b3916 b3259
        if s_3258_4 {
            return block_3916(state, tracer, fn_state);
        } else {
            return block_3259(state, tracer, fn_state);
        };
    }
    fn block_3259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3259_0: const #0u : u8
        let s_3259_0: bool = false;
        // D s_3259_1: write-var gs#135928 <= s_3259_0
        fn_state.gs_135928 = s_3259_0;
        // N s_3259_2: jump b3260
        return block_3260(state, tracer, fn_state);
    }
    fn block_3260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3260_0: read-var gs#135928:u8
        let s_3260_0: bool = fn_state.gs_135928;
        // N s_3260_1: branch s_3260_0 b3915 b3261
        if s_3260_0 {
            return block_3915(state, tracer, fn_state);
        } else {
            return block_3261(state, tracer, fn_state);
        };
    }
    fn block_3261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3261_0: const #0u : u8
        let s_3261_0: bool = false;
        // D s_3261_1: write-var gs#135929 <= s_3261_0
        fn_state.gs_135929 = s_3261_0;
        // N s_3261_2: jump b3262
        return block_3262(state, tracer, fn_state);
    }
    fn block_3262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3262_0: read-var gs#135929:u8
        let s_3262_0: bool = fn_state.gs_135929;
        // N s_3262_1: branch s_3262_0 b3914 b3263
        if s_3262_0 {
            return block_3914(state, tracer, fn_state);
        } else {
            return block_3263(state, tracer, fn_state);
        };
    }
    fn block_3263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3263_0: const #0u : u8
        let s_3263_0: bool = false;
        // D s_3263_1: write-var gs#135930 <= s_3263_0
        fn_state.gs_135930 = s_3263_0;
        // N s_3263_2: jump b3264
        return block_3264(state, tracer, fn_state);
    }
    fn block_3264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3264_0: read-var gs#135930:u8
        let s_3264_0: bool = fn_state.gs_135930;
        // N s_3264_1: branch s_3264_0 b3913 b3265
        if s_3264_0 {
            return block_3913(state, tracer, fn_state);
        } else {
            return block_3265(state, tracer, fn_state);
        };
    }
    fn block_3265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3265_0: const #0u : u8
        let s_3265_0: bool = false;
        // D s_3265_1: write-var gs#135931 <= s_3265_0
        fn_state.gs_135931 = s_3265_0;
        // N s_3265_2: jump b3266
        return block_3266(state, tracer, fn_state);
    }
    fn block_3266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3266_0: read-var gs#135931:u8
        let s_3266_0: bool = fn_state.gs_135931;
        // N s_3266_1: branch s_3266_0 b3912 b3267
        if s_3266_0 {
            return block_3912(state, tracer, fn_state);
        } else {
            return block_3267(state, tracer, fn_state);
        };
    }
    fn block_3267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3267_0: read-var CRm:u8
        let s_3267_0: u8 = fn_state.CRm;
        // D s_3267_1: cast zx s_3267_0 -> bv
        let s_3267_1: Bits = Bits::new(s_3267_0 as u128, 4u16);
        // C s_3267_2: const #14u : u8
        let s_3267_2: u8 = 14;
        // C s_3267_3: cast zx s_3267_2 -> bv
        let s_3267_3: Bits = Bits::new(s_3267_2 as u128, 4u16);
        // D s_3267_4: cmp-eq s_3267_1 s_3267_3
        let s_3267_4: bool = ((s_3267_1) == (s_3267_3));
        // N s_3267_5: branch s_3267_4 b3911 b3268
        if s_3267_4 {
            return block_3911(state, tracer, fn_state);
        } else {
            return block_3268(state, tracer, fn_state);
        };
    }
    fn block_3268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3268_0: const #0u : u8
        let s_3268_0: bool = false;
        // D s_3268_1: write-var gs#135932 <= s_3268_0
        fn_state.gs_135932 = s_3268_0;
        // N s_3268_2: jump b3269
        return block_3269(state, tracer, fn_state);
    }
    fn block_3269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3269_0: read-var gs#135932:u8
        let s_3269_0: bool = fn_state.gs_135932;
        // N s_3269_1: branch s_3269_0 b3910 b3270
        if s_3269_0 {
            return block_3910(state, tracer, fn_state);
        } else {
            return block_3270(state, tracer, fn_state);
        };
    }
    fn block_3270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3270_0: const #0u : u8
        let s_3270_0: bool = false;
        // D s_3270_1: write-var gs#135933 <= s_3270_0
        fn_state.gs_135933 = s_3270_0;
        // N s_3270_2: jump b3271
        return block_3271(state, tracer, fn_state);
    }
    fn block_3271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3271_0: read-var gs#135933:u8
        let s_3271_0: bool = fn_state.gs_135933;
        // N s_3271_1: branch s_3271_0 b3909 b3272
        if s_3271_0 {
            return block_3909(state, tracer, fn_state);
        } else {
            return block_3272(state, tracer, fn_state);
        };
    }
    fn block_3272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3272_0: const #0u : u8
        let s_3272_0: bool = false;
        // D s_3272_1: write-var gs#135934 <= s_3272_0
        fn_state.gs_135934 = s_3272_0;
        // N s_3272_2: jump b3273
        return block_3273(state, tracer, fn_state);
    }
    fn block_3273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3273_0: read-var gs#135934:u8
        let s_3273_0: bool = fn_state.gs_135934;
        // N s_3273_1: branch s_3273_0 b3908 b3274
        if s_3273_0 {
            return block_3908(state, tracer, fn_state);
        } else {
            return block_3274(state, tracer, fn_state);
        };
    }
    fn block_3274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3274_0: const #0u : u8
        let s_3274_0: bool = false;
        // D s_3274_1: write-var gs#135935 <= s_3274_0
        fn_state.gs_135935 = s_3274_0;
        // N s_3274_2: jump b3275
        return block_3275(state, tracer, fn_state);
    }
    fn block_3275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3275_0: read-var gs#135935:u8
        let s_3275_0: bool = fn_state.gs_135935;
        // N s_3275_1: branch s_3275_0 b3907 b3276
        if s_3275_0 {
            return block_3907(state, tracer, fn_state);
        } else {
            return block_3276(state, tracer, fn_state);
        };
    }
    fn block_3276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3276_0: read-var CRm:u8
        let s_3276_0: u8 = fn_state.CRm;
        // D s_3276_1: cast zx s_3276_0 -> bv
        let s_3276_1: Bits = Bits::new(s_3276_0 as u128, 4u16);
        // C s_3276_2: const #14u : u8
        let s_3276_2: u8 = 14;
        // C s_3276_3: cast zx s_3276_2 -> bv
        let s_3276_3: Bits = Bits::new(s_3276_2 as u128, 4u16);
        // D s_3276_4: cmp-eq s_3276_1 s_3276_3
        let s_3276_4: bool = ((s_3276_1) == (s_3276_3));
        // N s_3276_5: branch s_3276_4 b3906 b3277
        if s_3276_4 {
            return block_3906(state, tracer, fn_state);
        } else {
            return block_3277(state, tracer, fn_state);
        };
    }
    fn block_3277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3277_0: const #0u : u8
        let s_3277_0: bool = false;
        // D s_3277_1: write-var gs#135936 <= s_3277_0
        fn_state.gs_135936 = s_3277_0;
        // N s_3277_2: jump b3278
        return block_3278(state, tracer, fn_state);
    }
    fn block_3278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3278_0: read-var gs#135936:u8
        let s_3278_0: bool = fn_state.gs_135936;
        // N s_3278_1: branch s_3278_0 b3905 b3279
        if s_3278_0 {
            return block_3905(state, tracer, fn_state);
        } else {
            return block_3279(state, tracer, fn_state);
        };
    }
    fn block_3279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3279_0: const #0u : u8
        let s_3279_0: bool = false;
        // D s_3279_1: write-var gs#135937 <= s_3279_0
        fn_state.gs_135937 = s_3279_0;
        // N s_3279_2: jump b3280
        return block_3280(state, tracer, fn_state);
    }
    fn block_3280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3280_0: read-var gs#135937:u8
        let s_3280_0: bool = fn_state.gs_135937;
        // N s_3280_1: branch s_3280_0 b3904 b3281
        if s_3280_0 {
            return block_3904(state, tracer, fn_state);
        } else {
            return block_3281(state, tracer, fn_state);
        };
    }
    fn block_3281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3281_0: const #0u : u8
        let s_3281_0: bool = false;
        // D s_3281_1: write-var gs#135938 <= s_3281_0
        fn_state.gs_135938 = s_3281_0;
        // N s_3281_2: jump b3282
        return block_3282(state, tracer, fn_state);
    }
    fn block_3282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3282_0: read-var gs#135938:u8
        let s_3282_0: bool = fn_state.gs_135938;
        // N s_3282_1: branch s_3282_0 b3903 b3283
        if s_3282_0 {
            return block_3903(state, tracer, fn_state);
        } else {
            return block_3283(state, tracer, fn_state);
        };
    }
    fn block_3283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3283_0: const #0u : u8
        let s_3283_0: bool = false;
        // D s_3283_1: write-var gs#135939 <= s_3283_0
        fn_state.gs_135939 = s_3283_0;
        // N s_3283_2: jump b3284
        return block_3284(state, tracer, fn_state);
    }
    fn block_3284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3284_0: read-var gs#135939:u8
        let s_3284_0: bool = fn_state.gs_135939;
        // N s_3284_1: branch s_3284_0 b3902 b3285
        if s_3284_0 {
            return block_3902(state, tracer, fn_state);
        } else {
            return block_3285(state, tracer, fn_state);
        };
    }
    fn block_3285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3285_0: read-var CRm:u8
        let s_3285_0: u8 = fn_state.CRm;
        // D s_3285_1: cast zx s_3285_0 -> bv
        let s_3285_1: Bits = Bits::new(s_3285_0 as u128, 4u16);
        // C s_3285_2: const #14u : u8
        let s_3285_2: u8 = 14;
        // C s_3285_3: cast zx s_3285_2 -> bv
        let s_3285_3: Bits = Bits::new(s_3285_2 as u128, 4u16);
        // D s_3285_4: cmp-eq s_3285_1 s_3285_3
        let s_3285_4: bool = ((s_3285_1) == (s_3285_3));
        // N s_3285_5: branch s_3285_4 b3901 b3286
        if s_3285_4 {
            return block_3901(state, tracer, fn_state);
        } else {
            return block_3286(state, tracer, fn_state);
        };
    }
    fn block_3286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3286_0: const #0u : u8
        let s_3286_0: bool = false;
        // D s_3286_1: write-var gs#135940 <= s_3286_0
        fn_state.gs_135940 = s_3286_0;
        // N s_3286_2: jump b3287
        return block_3287(state, tracer, fn_state);
    }
    fn block_3287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3287_0: read-var gs#135940:u8
        let s_3287_0: bool = fn_state.gs_135940;
        // N s_3287_1: branch s_3287_0 b3900 b3288
        if s_3287_0 {
            return block_3900(state, tracer, fn_state);
        } else {
            return block_3288(state, tracer, fn_state);
        };
    }
    fn block_3288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3288_0: const #0u : u8
        let s_3288_0: bool = false;
        // D s_3288_1: write-var gs#135941 <= s_3288_0
        fn_state.gs_135941 = s_3288_0;
        // N s_3288_2: jump b3289
        return block_3289(state, tracer, fn_state);
    }
    fn block_3289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3289_0: read-var gs#135941:u8
        let s_3289_0: bool = fn_state.gs_135941;
        // N s_3289_1: branch s_3289_0 b3899 b3290
        if s_3289_0 {
            return block_3899(state, tracer, fn_state);
        } else {
            return block_3290(state, tracer, fn_state);
        };
    }
    fn block_3290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3290_0: const #0u : u8
        let s_3290_0: bool = false;
        // D s_3290_1: write-var gs#135942 <= s_3290_0
        fn_state.gs_135942 = s_3290_0;
        // N s_3290_2: jump b3291
        return block_3291(state, tracer, fn_state);
    }
    fn block_3291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3291_0: read-var gs#135942:u8
        let s_3291_0: bool = fn_state.gs_135942;
        // N s_3291_1: branch s_3291_0 b3898 b3292
        if s_3291_0 {
            return block_3898(state, tracer, fn_state);
        } else {
            return block_3292(state, tracer, fn_state);
        };
    }
    fn block_3292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3292_0: const #0u : u8
        let s_3292_0: bool = false;
        // D s_3292_1: write-var gs#135943 <= s_3292_0
        fn_state.gs_135943 = s_3292_0;
        // N s_3292_2: jump b3293
        return block_3293(state, tracer, fn_state);
    }
    fn block_3293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3293_0: read-var gs#135943:u8
        let s_3293_0: bool = fn_state.gs_135943;
        // N s_3293_1: branch s_3293_0 b3897 b3294
        if s_3293_0 {
            return block_3897(state, tracer, fn_state);
        } else {
            return block_3294(state, tracer, fn_state);
        };
    }
    fn block_3294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3294_0: read-var CRm:u8
        let s_3294_0: u8 = fn_state.CRm;
        // D s_3294_1: cast zx s_3294_0 -> bv
        let s_3294_1: Bits = Bits::new(s_3294_0 as u128, 4u16);
        // C s_3294_2: const #14u : u8
        let s_3294_2: u8 = 14;
        // C s_3294_3: cast zx s_3294_2 -> bv
        let s_3294_3: Bits = Bits::new(s_3294_2 as u128, 4u16);
        // D s_3294_4: cmp-eq s_3294_1 s_3294_3
        let s_3294_4: bool = ((s_3294_1) == (s_3294_3));
        // N s_3294_5: branch s_3294_4 b3896 b3295
        if s_3294_4 {
            return block_3896(state, tracer, fn_state);
        } else {
            return block_3295(state, tracer, fn_state);
        };
    }
    fn block_3295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3295_0: const #0u : u8
        let s_3295_0: bool = false;
        // D s_3295_1: write-var gs#135944 <= s_3295_0
        fn_state.gs_135944 = s_3295_0;
        // N s_3295_2: jump b3296
        return block_3296(state, tracer, fn_state);
    }
    fn block_3296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3296_0: read-var gs#135944:u8
        let s_3296_0: bool = fn_state.gs_135944;
        // N s_3296_1: branch s_3296_0 b3895 b3297
        if s_3296_0 {
            return block_3895(state, tracer, fn_state);
        } else {
            return block_3297(state, tracer, fn_state);
        };
    }
    fn block_3297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3297_0: const #0u : u8
        let s_3297_0: bool = false;
        // D s_3297_1: write-var gs#135945 <= s_3297_0
        fn_state.gs_135945 = s_3297_0;
        // N s_3297_2: jump b3298
        return block_3298(state, tracer, fn_state);
    }
    fn block_3298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3298_0: read-var gs#135945:u8
        let s_3298_0: bool = fn_state.gs_135945;
        // N s_3298_1: branch s_3298_0 b3894 b3299
        if s_3298_0 {
            return block_3894(state, tracer, fn_state);
        } else {
            return block_3299(state, tracer, fn_state);
        };
    }
    fn block_3299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3299_0: const #0u : u8
        let s_3299_0: bool = false;
        // D s_3299_1: write-var gs#135946 <= s_3299_0
        fn_state.gs_135946 = s_3299_0;
        // N s_3299_2: jump b3300
        return block_3300(state, tracer, fn_state);
    }
    fn block_3300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3300_0: read-var gs#135946:u8
        let s_3300_0: bool = fn_state.gs_135946;
        // N s_3300_1: branch s_3300_0 b3893 b3301
        if s_3300_0 {
            return block_3893(state, tracer, fn_state);
        } else {
            return block_3301(state, tracer, fn_state);
        };
    }
    fn block_3301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3301_0: const #0u : u8
        let s_3301_0: bool = false;
        // D s_3301_1: write-var gs#135947 <= s_3301_0
        fn_state.gs_135947 = s_3301_0;
        // N s_3301_2: jump b3302
        return block_3302(state, tracer, fn_state);
    }
    fn block_3302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3302_0: read-var gs#135947:u8
        let s_3302_0: bool = fn_state.gs_135947;
        // N s_3302_1: branch s_3302_0 b3892 b3303
        if s_3302_0 {
            return block_3892(state, tracer, fn_state);
        } else {
            return block_3303(state, tracer, fn_state);
        };
    }
    fn block_3303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3303_0: read-var CRm:u8
        let s_3303_0: u8 = fn_state.CRm;
        // D s_3303_1: cast zx s_3303_0 -> bv
        let s_3303_1: Bits = Bits::new(s_3303_0 as u128, 4u16);
        // C s_3303_2: const #14u : u8
        let s_3303_2: u8 = 14;
        // C s_3303_3: cast zx s_3303_2 -> bv
        let s_3303_3: Bits = Bits::new(s_3303_2 as u128, 4u16);
        // D s_3303_4: cmp-eq s_3303_1 s_3303_3
        let s_3303_4: bool = ((s_3303_1) == (s_3303_3));
        // N s_3303_5: branch s_3303_4 b3891 b3304
        if s_3303_4 {
            return block_3891(state, tracer, fn_state);
        } else {
            return block_3304(state, tracer, fn_state);
        };
    }
    fn block_3304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3304_0: const #0u : u8
        let s_3304_0: bool = false;
        // D s_3304_1: write-var gs#135948 <= s_3304_0
        fn_state.gs_135948 = s_3304_0;
        // N s_3304_2: jump b3305
        return block_3305(state, tracer, fn_state);
    }
    fn block_3305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3305_0: read-var gs#135948:u8
        let s_3305_0: bool = fn_state.gs_135948;
        // N s_3305_1: branch s_3305_0 b3890 b3306
        if s_3305_0 {
            return block_3890(state, tracer, fn_state);
        } else {
            return block_3306(state, tracer, fn_state);
        };
    }
    fn block_3306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3306_0: const #0u : u8
        let s_3306_0: bool = false;
        // D s_3306_1: write-var gs#135949 <= s_3306_0
        fn_state.gs_135949 = s_3306_0;
        // N s_3306_2: jump b3307
        return block_3307(state, tracer, fn_state);
    }
    fn block_3307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3307_0: read-var gs#135949:u8
        let s_3307_0: bool = fn_state.gs_135949;
        // N s_3307_1: branch s_3307_0 b3889 b3308
        if s_3307_0 {
            return block_3889(state, tracer, fn_state);
        } else {
            return block_3308(state, tracer, fn_state);
        };
    }
    fn block_3308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3308_0: const #0u : u8
        let s_3308_0: bool = false;
        // D s_3308_1: write-var gs#135950 <= s_3308_0
        fn_state.gs_135950 = s_3308_0;
        // N s_3308_2: jump b3309
        return block_3309(state, tracer, fn_state);
    }
    fn block_3309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3309_0: read-var gs#135950:u8
        let s_3309_0: bool = fn_state.gs_135950;
        // N s_3309_1: branch s_3309_0 b3888 b3310
        if s_3309_0 {
            return block_3888(state, tracer, fn_state);
        } else {
            return block_3310(state, tracer, fn_state);
        };
    }
    fn block_3310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3310_0: const #0u : u8
        let s_3310_0: bool = false;
        // D s_3310_1: write-var gs#135951 <= s_3310_0
        fn_state.gs_135951 = s_3310_0;
        // N s_3310_2: jump b3311
        return block_3311(state, tracer, fn_state);
    }
    fn block_3311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3311_0: read-var gs#135951:u8
        let s_3311_0: bool = fn_state.gs_135951;
        // N s_3311_1: branch s_3311_0 b3887 b3312
        if s_3311_0 {
            return block_3887(state, tracer, fn_state);
        } else {
            return block_3312(state, tracer, fn_state);
        };
    }
    fn block_3312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3312_0: read-var CRm:u8
        let s_3312_0: u8 = fn_state.CRm;
        // D s_3312_1: cast zx s_3312_0 -> bv
        let s_3312_1: Bits = Bits::new(s_3312_0 as u128, 4u16);
        // C s_3312_2: const #14u : u8
        let s_3312_2: u8 = 14;
        // C s_3312_3: cast zx s_3312_2 -> bv
        let s_3312_3: Bits = Bits::new(s_3312_2 as u128, 4u16);
        // D s_3312_4: cmp-eq s_3312_1 s_3312_3
        let s_3312_4: bool = ((s_3312_1) == (s_3312_3));
        // N s_3312_5: branch s_3312_4 b3886 b3313
        if s_3312_4 {
            return block_3886(state, tracer, fn_state);
        } else {
            return block_3313(state, tracer, fn_state);
        };
    }
    fn block_3313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3313_0: const #0u : u8
        let s_3313_0: bool = false;
        // D s_3313_1: write-var gs#135952 <= s_3313_0
        fn_state.gs_135952 = s_3313_0;
        // N s_3313_2: jump b3314
        return block_3314(state, tracer, fn_state);
    }
    fn block_3314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3314_0: read-var gs#135952:u8
        let s_3314_0: bool = fn_state.gs_135952;
        // N s_3314_1: branch s_3314_0 b3885 b3315
        if s_3314_0 {
            return block_3885(state, tracer, fn_state);
        } else {
            return block_3315(state, tracer, fn_state);
        };
    }
    fn block_3315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3315_0: const #0u : u8
        let s_3315_0: bool = false;
        // D s_3315_1: write-var gs#135953 <= s_3315_0
        fn_state.gs_135953 = s_3315_0;
        // N s_3315_2: jump b3316
        return block_3316(state, tracer, fn_state);
    }
    fn block_3316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3316_0: read-var gs#135953:u8
        let s_3316_0: bool = fn_state.gs_135953;
        // N s_3316_1: branch s_3316_0 b3884 b3317
        if s_3316_0 {
            return block_3884(state, tracer, fn_state);
        } else {
            return block_3317(state, tracer, fn_state);
        };
    }
    fn block_3317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3317_0: const #0u : u8
        let s_3317_0: bool = false;
        // D s_3317_1: write-var gs#135954 <= s_3317_0
        fn_state.gs_135954 = s_3317_0;
        // N s_3317_2: jump b3318
        return block_3318(state, tracer, fn_state);
    }
    fn block_3318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3318_0: read-var gs#135954:u8
        let s_3318_0: bool = fn_state.gs_135954;
        // N s_3318_1: branch s_3318_0 b3883 b3319
        if s_3318_0 {
            return block_3883(state, tracer, fn_state);
        } else {
            return block_3319(state, tracer, fn_state);
        };
    }
    fn block_3319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3319_0: const #0u : u8
        let s_3319_0: bool = false;
        // D s_3319_1: write-var gs#135955 <= s_3319_0
        fn_state.gs_135955 = s_3319_0;
        // N s_3319_2: jump b3320
        return block_3320(state, tracer, fn_state);
    }
    fn block_3320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3320_0: read-var gs#135955:u8
        let s_3320_0: bool = fn_state.gs_135955;
        // N s_3320_1: branch s_3320_0 b3882 b3321
        if s_3320_0 {
            return block_3882(state, tracer, fn_state);
        } else {
            return block_3321(state, tracer, fn_state);
        };
    }
    fn block_3321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3321_0: read-var CRm:u8
        let s_3321_0: u8 = fn_state.CRm;
        // D s_3321_1: cast zx s_3321_0 -> bv
        let s_3321_1: Bits = Bits::new(s_3321_0 as u128, 4u16);
        // C s_3321_2: const #14u : u8
        let s_3321_2: u8 = 14;
        // C s_3321_3: cast zx s_3321_2 -> bv
        let s_3321_3: Bits = Bits::new(s_3321_2 as u128, 4u16);
        // D s_3321_4: cmp-eq s_3321_1 s_3321_3
        let s_3321_4: bool = ((s_3321_1) == (s_3321_3));
        // N s_3321_5: branch s_3321_4 b3881 b3322
        if s_3321_4 {
            return block_3881(state, tracer, fn_state);
        } else {
            return block_3322(state, tracer, fn_state);
        };
    }
    fn block_3322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3322_0: const #0u : u8
        let s_3322_0: bool = false;
        // D s_3322_1: write-var gs#135956 <= s_3322_0
        fn_state.gs_135956 = s_3322_0;
        // N s_3322_2: jump b3323
        return block_3323(state, tracer, fn_state);
    }
    fn block_3323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3323_0: read-var gs#135956:u8
        let s_3323_0: bool = fn_state.gs_135956;
        // N s_3323_1: branch s_3323_0 b3880 b3324
        if s_3323_0 {
            return block_3880(state, tracer, fn_state);
        } else {
            return block_3324(state, tracer, fn_state);
        };
    }
    fn block_3324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3324_0: const #0u : u8
        let s_3324_0: bool = false;
        // D s_3324_1: write-var gs#135957 <= s_3324_0
        fn_state.gs_135957 = s_3324_0;
        // N s_3324_2: jump b3325
        return block_3325(state, tracer, fn_state);
    }
    fn block_3325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3325_0: read-var gs#135957:u8
        let s_3325_0: bool = fn_state.gs_135957;
        // N s_3325_1: branch s_3325_0 b3879 b3326
        if s_3325_0 {
            return block_3879(state, tracer, fn_state);
        } else {
            return block_3326(state, tracer, fn_state);
        };
    }
    fn block_3326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3326_0: const #0u : u8
        let s_3326_0: bool = false;
        // D s_3326_1: write-var gs#135958 <= s_3326_0
        fn_state.gs_135958 = s_3326_0;
        // N s_3326_2: jump b3327
        return block_3327(state, tracer, fn_state);
    }
    fn block_3327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3327_0: read-var gs#135958:u8
        let s_3327_0: bool = fn_state.gs_135958;
        // N s_3327_1: branch s_3327_0 b3878 b3328
        if s_3327_0 {
            return block_3878(state, tracer, fn_state);
        } else {
            return block_3328(state, tracer, fn_state);
        };
    }
    fn block_3328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3328_0: const #0u : u8
        let s_3328_0: bool = false;
        // D s_3328_1: write-var gs#135959 <= s_3328_0
        fn_state.gs_135959 = s_3328_0;
        // N s_3328_2: jump b3329
        return block_3329(state, tracer, fn_state);
    }
    fn block_3329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3329_0: read-var gs#135959:u8
        let s_3329_0: bool = fn_state.gs_135959;
        // N s_3329_1: branch s_3329_0 b3877 b3330
        if s_3329_0 {
            return block_3877(state, tracer, fn_state);
        } else {
            return block_3330(state, tracer, fn_state);
        };
    }
    fn block_3330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3330_0: read-var CRm:u8
        let s_3330_0: u8 = fn_state.CRm;
        // D s_3330_1: cast zx s_3330_0 -> bv
        let s_3330_1: Bits = Bits::new(s_3330_0 as u128, 4u16);
        // C s_3330_2: const #14u : u8
        let s_3330_2: u8 = 14;
        // C s_3330_3: cast zx s_3330_2 -> bv
        let s_3330_3: Bits = Bits::new(s_3330_2 as u128, 4u16);
        // D s_3330_4: cmp-eq s_3330_1 s_3330_3
        let s_3330_4: bool = ((s_3330_1) == (s_3330_3));
        // N s_3330_5: branch s_3330_4 b3876 b3331
        if s_3330_4 {
            return block_3876(state, tracer, fn_state);
        } else {
            return block_3331(state, tracer, fn_state);
        };
    }
    fn block_3331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3331_0: const #0u : u8
        let s_3331_0: bool = false;
        // D s_3331_1: write-var gs#135960 <= s_3331_0
        fn_state.gs_135960 = s_3331_0;
        // N s_3331_2: jump b3332
        return block_3332(state, tracer, fn_state);
    }
    fn block_3332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3332_0: read-var gs#135960:u8
        let s_3332_0: bool = fn_state.gs_135960;
        // N s_3332_1: branch s_3332_0 b3875 b3333
        if s_3332_0 {
            return block_3875(state, tracer, fn_state);
        } else {
            return block_3333(state, tracer, fn_state);
        };
    }
    fn block_3333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3333_0: const #0u : u8
        let s_3333_0: bool = false;
        // D s_3333_1: write-var gs#135961 <= s_3333_0
        fn_state.gs_135961 = s_3333_0;
        // N s_3333_2: jump b3334
        return block_3334(state, tracer, fn_state);
    }
    fn block_3334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3334_0: read-var gs#135961:u8
        let s_3334_0: bool = fn_state.gs_135961;
        // N s_3334_1: branch s_3334_0 b3874 b3335
        if s_3334_0 {
            return block_3874(state, tracer, fn_state);
        } else {
            return block_3335(state, tracer, fn_state);
        };
    }
    fn block_3335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3335_0: const #0u : u8
        let s_3335_0: bool = false;
        // D s_3335_1: write-var gs#135962 <= s_3335_0
        fn_state.gs_135962 = s_3335_0;
        // N s_3335_2: jump b3336
        return block_3336(state, tracer, fn_state);
    }
    fn block_3336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3336_0: read-var gs#135962:u8
        let s_3336_0: bool = fn_state.gs_135962;
        // N s_3336_1: branch s_3336_0 b3873 b3337
        if s_3336_0 {
            return block_3873(state, tracer, fn_state);
        } else {
            return block_3337(state, tracer, fn_state);
        };
    }
    fn block_3337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3337_0: const #0u : u8
        let s_3337_0: bool = false;
        // D s_3337_1: write-var gs#135963 <= s_3337_0
        fn_state.gs_135963 = s_3337_0;
        // N s_3337_2: jump b3338
        return block_3338(state, tracer, fn_state);
    }
    fn block_3338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3338_0: read-var gs#135963:u8
        let s_3338_0: bool = fn_state.gs_135963;
        // N s_3338_1: branch s_3338_0 b3872 b3339
        if s_3338_0 {
            return block_3872(state, tracer, fn_state);
        } else {
            return block_3339(state, tracer, fn_state);
        };
    }
    fn block_3339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3339_0: read-var CRm:u8
        let s_3339_0: u8 = fn_state.CRm;
        // D s_3339_1: cast zx s_3339_0 -> bv
        let s_3339_1: Bits = Bits::new(s_3339_0 as u128, 4u16);
        // C s_3339_2: const #3u : u8
        let s_3339_2: u8 = 3;
        // C s_3339_3: cast zx s_3339_2 -> bv
        let s_3339_3: Bits = Bits::new(s_3339_2 as u128, 4u16);
        // D s_3339_4: cmp-eq s_3339_1 s_3339_3
        let s_3339_4: bool = ((s_3339_1) == (s_3339_3));
        // N s_3339_5: branch s_3339_4 b3871 b3340
        if s_3339_4 {
            return block_3871(state, tracer, fn_state);
        } else {
            return block_3340(state, tracer, fn_state);
        };
    }
    fn block_3340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3340_0: const #0u : u8
        let s_3340_0: bool = false;
        // D s_3340_1: write-var gs#135964 <= s_3340_0
        fn_state.gs_135964 = s_3340_0;
        // N s_3340_2: jump b3341
        return block_3341(state, tracer, fn_state);
    }
    fn block_3341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3341_0: read-var gs#135964:u8
        let s_3341_0: bool = fn_state.gs_135964;
        // N s_3341_1: branch s_3341_0 b3870 b3342
        if s_3341_0 {
            return block_3870(state, tracer, fn_state);
        } else {
            return block_3342(state, tracer, fn_state);
        };
    }
    fn block_3342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3342_0: const #0u : u8
        let s_3342_0: bool = false;
        // D s_3342_1: write-var gs#135965 <= s_3342_0
        fn_state.gs_135965 = s_3342_0;
        // N s_3342_2: jump b3343
        return block_3343(state, tracer, fn_state);
    }
    fn block_3343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3343_0: read-var gs#135965:u8
        let s_3343_0: bool = fn_state.gs_135965;
        // N s_3343_1: branch s_3343_0 b3869 b3344
        if s_3343_0 {
            return block_3869(state, tracer, fn_state);
        } else {
            return block_3344(state, tracer, fn_state);
        };
    }
    fn block_3344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3344_0: const #0u : u8
        let s_3344_0: bool = false;
        // D s_3344_1: write-var gs#135966 <= s_3344_0
        fn_state.gs_135966 = s_3344_0;
        // N s_3344_2: jump b3345
        return block_3345(state, tracer, fn_state);
    }
    fn block_3345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3345_0: read-var gs#135966:u8
        let s_3345_0: bool = fn_state.gs_135966;
        // N s_3345_1: branch s_3345_0 b3868 b3346
        if s_3345_0 {
            return block_3868(state, tracer, fn_state);
        } else {
            return block_3346(state, tracer, fn_state);
        };
    }
    fn block_3346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3346_0: const #0u : u8
        let s_3346_0: bool = false;
        // D s_3346_1: write-var gs#135967 <= s_3346_0
        fn_state.gs_135967 = s_3346_0;
        // N s_3346_2: jump b3347
        return block_3347(state, tracer, fn_state);
    }
    fn block_3347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3347_0: read-var gs#135967:u8
        let s_3347_0: bool = fn_state.gs_135967;
        // N s_3347_1: branch s_3347_0 b3867 b3348
        if s_3347_0 {
            return block_3867(state, tracer, fn_state);
        } else {
            return block_3348(state, tracer, fn_state);
        };
    }
    fn block_3348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3348_0: read-var CRm:u8
        let s_3348_0: u8 = fn_state.CRm;
        // D s_3348_1: cast zx s_3348_0 -> bv
        let s_3348_1: Bits = Bits::new(s_3348_0 as u128, 4u16);
        // C s_3348_2: const #2u : u8
        let s_3348_2: u8 = 2;
        // C s_3348_3: cast zx s_3348_2 -> bv
        let s_3348_3: Bits = Bits::new(s_3348_2 as u128, 4u16);
        // D s_3348_4: cmp-eq s_3348_1 s_3348_3
        let s_3348_4: bool = ((s_3348_1) == (s_3348_3));
        // N s_3348_5: branch s_3348_4 b3866 b3349
        if s_3348_4 {
            return block_3866(state, tracer, fn_state);
        } else {
            return block_3349(state, tracer, fn_state);
        };
    }
    fn block_3349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3349_0: const #0u : u8
        let s_3349_0: bool = false;
        // D s_3349_1: write-var gs#135968 <= s_3349_0
        fn_state.gs_135968 = s_3349_0;
        // N s_3349_2: jump b3350
        return block_3350(state, tracer, fn_state);
    }
    fn block_3350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3350_0: read-var gs#135968:u8
        let s_3350_0: bool = fn_state.gs_135968;
        // N s_3350_1: branch s_3350_0 b3865 b3351
        if s_3350_0 {
            return block_3865(state, tracer, fn_state);
        } else {
            return block_3351(state, tracer, fn_state);
        };
    }
    fn block_3351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3351_0: const #0u : u8
        let s_3351_0: bool = false;
        // D s_3351_1: write-var gs#135969 <= s_3351_0
        fn_state.gs_135969 = s_3351_0;
        // N s_3351_2: jump b3352
        return block_3352(state, tracer, fn_state);
    }
    fn block_3352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3352_0: read-var gs#135969:u8
        let s_3352_0: bool = fn_state.gs_135969;
        // N s_3352_1: branch s_3352_0 b3864 b3353
        if s_3352_0 {
            return block_3864(state, tracer, fn_state);
        } else {
            return block_3353(state, tracer, fn_state);
        };
    }
    fn block_3353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3353_0: const #0u : u8
        let s_3353_0: bool = false;
        // D s_3353_1: write-var gs#135970 <= s_3353_0
        fn_state.gs_135970 = s_3353_0;
        // N s_3353_2: jump b3354
        return block_3354(state, tracer, fn_state);
    }
    fn block_3354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3354_0: read-var gs#135970:u8
        let s_3354_0: bool = fn_state.gs_135970;
        // N s_3354_1: branch s_3354_0 b3863 b3355
        if s_3354_0 {
            return block_3863(state, tracer, fn_state);
        } else {
            return block_3355(state, tracer, fn_state);
        };
    }
    fn block_3355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3355_0: const #0u : u8
        let s_3355_0: bool = false;
        // D s_3355_1: write-var gs#135971 <= s_3355_0
        fn_state.gs_135971 = s_3355_0;
        // N s_3355_2: jump b3356
        return block_3356(state, tracer, fn_state);
    }
    fn block_3356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3356_0: read-var gs#135971:u8
        let s_3356_0: bool = fn_state.gs_135971;
        // N s_3356_1: branch s_3356_0 b3862 b3357
        if s_3356_0 {
            return block_3862(state, tracer, fn_state);
        } else {
            return block_3357(state, tracer, fn_state);
        };
    }
    fn block_3357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3357_0: read-var CRm:u8
        let s_3357_0: u8 = fn_state.CRm;
        // D s_3357_1: cast zx s_3357_0 -> bv
        let s_3357_1: Bits = Bits::new(s_3357_0 as u128, 4u16);
        // C s_3357_2: const #2u : u8
        let s_3357_2: u8 = 2;
        // C s_3357_3: cast zx s_3357_2 -> bv
        let s_3357_3: Bits = Bits::new(s_3357_2 as u128, 4u16);
        // D s_3357_4: cmp-eq s_3357_1 s_3357_3
        let s_3357_4: bool = ((s_3357_1) == (s_3357_3));
        // N s_3357_5: branch s_3357_4 b3861 b3358
        if s_3357_4 {
            return block_3861(state, tracer, fn_state);
        } else {
            return block_3358(state, tracer, fn_state);
        };
    }
    fn block_3358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3358_0: const #0u : u8
        let s_3358_0: bool = false;
        // D s_3358_1: write-var gs#135972 <= s_3358_0
        fn_state.gs_135972 = s_3358_0;
        // N s_3358_2: jump b3359
        return block_3359(state, tracer, fn_state);
    }
    fn block_3359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3359_0: read-var gs#135972:u8
        let s_3359_0: bool = fn_state.gs_135972;
        // N s_3359_1: branch s_3359_0 b3860 b3360
        if s_3359_0 {
            return block_3860(state, tracer, fn_state);
        } else {
            return block_3360(state, tracer, fn_state);
        };
    }
    fn block_3360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3360_0: const #0u : u8
        let s_3360_0: bool = false;
        // D s_3360_1: write-var gs#135973 <= s_3360_0
        fn_state.gs_135973 = s_3360_0;
        // N s_3360_2: jump b3361
        return block_3361(state, tracer, fn_state);
    }
    fn block_3361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3361_0: read-var gs#135973:u8
        let s_3361_0: bool = fn_state.gs_135973;
        // N s_3361_1: branch s_3361_0 b3859 b3362
        if s_3361_0 {
            return block_3859(state, tracer, fn_state);
        } else {
            return block_3362(state, tracer, fn_state);
        };
    }
    fn block_3362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3362_0: const #0u : u8
        let s_3362_0: bool = false;
        // D s_3362_1: write-var gs#135974 <= s_3362_0
        fn_state.gs_135974 = s_3362_0;
        // N s_3362_2: jump b3363
        return block_3363(state, tracer, fn_state);
    }
    fn block_3363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3363_0: read-var gs#135974:u8
        let s_3363_0: bool = fn_state.gs_135974;
        // N s_3363_1: branch s_3363_0 b3858 b3364
        if s_3363_0 {
            return block_3858(state, tracer, fn_state);
        } else {
            return block_3364(state, tracer, fn_state);
        };
    }
    fn block_3364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3364_0: const #0u : u8
        let s_3364_0: bool = false;
        // D s_3364_1: write-var gs#135975 <= s_3364_0
        fn_state.gs_135975 = s_3364_0;
        // N s_3364_2: jump b3365
        return block_3365(state, tracer, fn_state);
    }
    fn block_3365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3365_0: read-var gs#135975:u8
        let s_3365_0: bool = fn_state.gs_135975;
        // N s_3365_1: branch s_3365_0 b3857 b3366
        if s_3365_0 {
            return block_3857(state, tracer, fn_state);
        } else {
            return block_3366(state, tracer, fn_state);
        };
    }
    fn block_3366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3366_0: read-var CRm:u8
        let s_3366_0: u8 = fn_state.CRm;
        // D s_3366_1: cast zx s_3366_0 -> bv
        let s_3366_1: Bits = Bits::new(s_3366_0 as u128, 4u16);
        // C s_3366_2: const #3u : u8
        let s_3366_2: u8 = 3;
        // C s_3366_3: cast zx s_3366_2 -> bv
        let s_3366_3: Bits = Bits::new(s_3366_2 as u128, 4u16);
        // D s_3366_4: cmp-eq s_3366_1 s_3366_3
        let s_3366_4: bool = ((s_3366_1) == (s_3366_3));
        // N s_3366_5: branch s_3366_4 b3856 b3367
        if s_3366_4 {
            return block_3856(state, tracer, fn_state);
        } else {
            return block_3367(state, tracer, fn_state);
        };
    }
    fn block_3367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3367_0: const #0u : u8
        let s_3367_0: bool = false;
        // D s_3367_1: write-var gs#135976 <= s_3367_0
        fn_state.gs_135976 = s_3367_0;
        // N s_3367_2: jump b3368
        return block_3368(state, tracer, fn_state);
    }
    fn block_3368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3368_0: read-var gs#135976:u8
        let s_3368_0: bool = fn_state.gs_135976;
        // N s_3368_1: branch s_3368_0 b3855 b3369
        if s_3368_0 {
            return block_3855(state, tracer, fn_state);
        } else {
            return block_3369(state, tracer, fn_state);
        };
    }
    fn block_3369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3369_0: const #0u : u8
        let s_3369_0: bool = false;
        // D s_3369_1: write-var gs#135977 <= s_3369_0
        fn_state.gs_135977 = s_3369_0;
        // N s_3369_2: jump b3370
        return block_3370(state, tracer, fn_state);
    }
    fn block_3370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3370_0: read-var gs#135977:u8
        let s_3370_0: bool = fn_state.gs_135977;
        // N s_3370_1: branch s_3370_0 b3854 b3371
        if s_3370_0 {
            return block_3854(state, tracer, fn_state);
        } else {
            return block_3371(state, tracer, fn_state);
        };
    }
    fn block_3371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3371_0: const #0u : u8
        let s_3371_0: bool = false;
        // D s_3371_1: write-var gs#135978 <= s_3371_0
        fn_state.gs_135978 = s_3371_0;
        // N s_3371_2: jump b3372
        return block_3372(state, tracer, fn_state);
    }
    fn block_3372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3372_0: read-var gs#135978:u8
        let s_3372_0: bool = fn_state.gs_135978;
        // N s_3372_1: branch s_3372_0 b3853 b3373
        if s_3372_0 {
            return block_3853(state, tracer, fn_state);
        } else {
            return block_3373(state, tracer, fn_state);
        };
    }
    fn block_3373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3373_0: const #0u : u8
        let s_3373_0: bool = false;
        // D s_3373_1: write-var gs#135979 <= s_3373_0
        fn_state.gs_135979 = s_3373_0;
        // N s_3373_2: jump b3374
        return block_3374(state, tracer, fn_state);
    }
    fn block_3374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3374_0: read-var gs#135979:u8
        let s_3374_0: bool = fn_state.gs_135979;
        // N s_3374_1: branch s_3374_0 b3852 b3375
        if s_3374_0 {
            return block_3852(state, tracer, fn_state);
        } else {
            return block_3375(state, tracer, fn_state);
        };
    }
    fn block_3375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3375_0: read-var CRm:u8
        let s_3375_0: u8 = fn_state.CRm;
        // D s_3375_1: cast zx s_3375_0 -> bv
        let s_3375_1: Bits = Bits::new(s_3375_0 as u128, 4u16);
        // C s_3375_2: const #2u : u8
        let s_3375_2: u8 = 2;
        // C s_3375_3: cast zx s_3375_2 -> bv
        let s_3375_3: Bits = Bits::new(s_3375_2 as u128, 4u16);
        // D s_3375_4: cmp-eq s_3375_1 s_3375_3
        let s_3375_4: bool = ((s_3375_1) == (s_3375_3));
        // N s_3375_5: branch s_3375_4 b3851 b3376
        if s_3375_4 {
            return block_3851(state, tracer, fn_state);
        } else {
            return block_3376(state, tracer, fn_state);
        };
    }
    fn block_3376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3376_0: const #0u : u8
        let s_3376_0: bool = false;
        // D s_3376_1: write-var gs#135980 <= s_3376_0
        fn_state.gs_135980 = s_3376_0;
        // N s_3376_2: jump b3377
        return block_3377(state, tracer, fn_state);
    }
    fn block_3377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3377_0: read-var gs#135980:u8
        let s_3377_0: bool = fn_state.gs_135980;
        // N s_3377_1: branch s_3377_0 b3850 b3378
        if s_3377_0 {
            return block_3850(state, tracer, fn_state);
        } else {
            return block_3378(state, tracer, fn_state);
        };
    }
    fn block_3378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3378_0: const #0u : u8
        let s_3378_0: bool = false;
        // D s_3378_1: write-var gs#135981 <= s_3378_0
        fn_state.gs_135981 = s_3378_0;
        // N s_3378_2: jump b3379
        return block_3379(state, tracer, fn_state);
    }
    fn block_3379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3379_0: read-var gs#135981:u8
        let s_3379_0: bool = fn_state.gs_135981;
        // N s_3379_1: branch s_3379_0 b3849 b3380
        if s_3379_0 {
            return block_3849(state, tracer, fn_state);
        } else {
            return block_3380(state, tracer, fn_state);
        };
    }
    fn block_3380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3380_0: const #0u : u8
        let s_3380_0: bool = false;
        // D s_3380_1: write-var gs#135982 <= s_3380_0
        fn_state.gs_135982 = s_3380_0;
        // N s_3380_2: jump b3381
        return block_3381(state, tracer, fn_state);
    }
    fn block_3381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3381_0: read-var gs#135982:u8
        let s_3381_0: bool = fn_state.gs_135982;
        // N s_3381_1: branch s_3381_0 b3848 b3382
        if s_3381_0 {
            return block_3848(state, tracer, fn_state);
        } else {
            return block_3382(state, tracer, fn_state);
        };
    }
    fn block_3382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3382_0: const #0u : u8
        let s_3382_0: bool = false;
        // D s_3382_1: write-var gs#135983 <= s_3382_0
        fn_state.gs_135983 = s_3382_0;
        // N s_3382_2: jump b3383
        return block_3383(state, tracer, fn_state);
    }
    fn block_3383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3383_0: read-var gs#135983:u8
        let s_3383_0: bool = fn_state.gs_135983;
        // N s_3383_1: branch s_3383_0 b3847 b3384
        if s_3383_0 {
            return block_3847(state, tracer, fn_state);
        } else {
            return block_3384(state, tracer, fn_state);
        };
    }
    fn block_3384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3384_0: read-var CRm:u8
        let s_3384_0: u8 = fn_state.CRm;
        // D s_3384_1: cast zx s_3384_0 -> bv
        let s_3384_1: Bits = Bits::new(s_3384_0 as u128, 4u16);
        // C s_3384_2: const #5u : u8
        let s_3384_2: u8 = 5;
        // C s_3384_3: cast zx s_3384_2 -> bv
        let s_3384_3: Bits = Bits::new(s_3384_2 as u128, 4u16);
        // D s_3384_4: cmp-eq s_3384_1 s_3384_3
        let s_3384_4: bool = ((s_3384_1) == (s_3384_3));
        // N s_3384_5: branch s_3384_4 b3846 b3385
        if s_3384_4 {
            return block_3846(state, tracer, fn_state);
        } else {
            return block_3385(state, tracer, fn_state);
        };
    }
    fn block_3385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3385_0: const #0u : u8
        let s_3385_0: bool = false;
        // D s_3385_1: write-var gs#135984 <= s_3385_0
        fn_state.gs_135984 = s_3385_0;
        // N s_3385_2: jump b3386
        return block_3386(state, tracer, fn_state);
    }
    fn block_3386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3386_0: read-var gs#135984:u8
        let s_3386_0: bool = fn_state.gs_135984;
        // N s_3386_1: branch s_3386_0 b3845 b3387
        if s_3386_0 {
            return block_3845(state, tracer, fn_state);
        } else {
            return block_3387(state, tracer, fn_state);
        };
    }
    fn block_3387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3387_0: const #0u : u8
        let s_3387_0: bool = false;
        // D s_3387_1: write-var gs#135985 <= s_3387_0
        fn_state.gs_135985 = s_3387_0;
        // N s_3387_2: jump b3388
        return block_3388(state, tracer, fn_state);
    }
    fn block_3388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3388_0: read-var gs#135985:u8
        let s_3388_0: bool = fn_state.gs_135985;
        // N s_3388_1: branch s_3388_0 b3844 b3389
        if s_3388_0 {
            return block_3844(state, tracer, fn_state);
        } else {
            return block_3389(state, tracer, fn_state);
        };
    }
    fn block_3389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3389_0: const #0u : u8
        let s_3389_0: bool = false;
        // D s_3389_1: write-var gs#135986 <= s_3389_0
        fn_state.gs_135986 = s_3389_0;
        // N s_3389_2: jump b3390
        return block_3390(state, tracer, fn_state);
    }
    fn block_3390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3390_0: read-var gs#135986:u8
        let s_3390_0: bool = fn_state.gs_135986;
        // N s_3390_1: branch s_3390_0 b3843 b3391
        if s_3390_0 {
            return block_3843(state, tracer, fn_state);
        } else {
            return block_3391(state, tracer, fn_state);
        };
    }
    fn block_3391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3391_0: const #0u : u8
        let s_3391_0: bool = false;
        // D s_3391_1: write-var gs#135987 <= s_3391_0
        fn_state.gs_135987 = s_3391_0;
        // N s_3391_2: jump b3392
        return block_3392(state, tracer, fn_state);
    }
    fn block_3392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3392_0: read-var gs#135987:u8
        let s_3392_0: bool = fn_state.gs_135987;
        // N s_3392_1: branch s_3392_0 b3842 b3393
        if s_3392_0 {
            return block_3842(state, tracer, fn_state);
        } else {
            return block_3393(state, tracer, fn_state);
        };
    }
    fn block_3393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3393_0: read-var CRm:u8
        let s_3393_0: u8 = fn_state.CRm;
        // D s_3393_1: cast zx s_3393_0 -> bv
        let s_3393_1: Bits = Bits::new(s_3393_0 as u128, 4u16);
        // C s_3393_2: const #4u : u8
        let s_3393_2: u8 = 4;
        // C s_3393_3: cast zx s_3393_2 -> bv
        let s_3393_3: Bits = Bits::new(s_3393_2 as u128, 4u16);
        // D s_3393_4: cmp-eq s_3393_1 s_3393_3
        let s_3393_4: bool = ((s_3393_1) == (s_3393_3));
        // N s_3393_5: branch s_3393_4 b3841 b3394
        if s_3393_4 {
            return block_3841(state, tracer, fn_state);
        } else {
            return block_3394(state, tracer, fn_state);
        };
    }
    fn block_3394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3394_0: const #0u : u8
        let s_3394_0: bool = false;
        // D s_3394_1: write-var gs#135988 <= s_3394_0
        fn_state.gs_135988 = s_3394_0;
        // N s_3394_2: jump b3395
        return block_3395(state, tracer, fn_state);
    }
    fn block_3395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3395_0: read-var gs#135988:u8
        let s_3395_0: bool = fn_state.gs_135988;
        // N s_3395_1: branch s_3395_0 b3840 b3396
        if s_3395_0 {
            return block_3840(state, tracer, fn_state);
        } else {
            return block_3396(state, tracer, fn_state);
        };
    }
    fn block_3396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3396_0: const #0u : u8
        let s_3396_0: bool = false;
        // D s_3396_1: write-var gs#135989 <= s_3396_0
        fn_state.gs_135989 = s_3396_0;
        // N s_3396_2: jump b3397
        return block_3397(state, tracer, fn_state);
    }
    fn block_3397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3397_0: read-var gs#135989:u8
        let s_3397_0: bool = fn_state.gs_135989;
        // N s_3397_1: branch s_3397_0 b3839 b3398
        if s_3397_0 {
            return block_3839(state, tracer, fn_state);
        } else {
            return block_3398(state, tracer, fn_state);
        };
    }
    fn block_3398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3398_0: const #0u : u8
        let s_3398_0: bool = false;
        // D s_3398_1: write-var gs#135990 <= s_3398_0
        fn_state.gs_135990 = s_3398_0;
        // N s_3398_2: jump b3399
        return block_3399(state, tracer, fn_state);
    }
    fn block_3399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3399_0: read-var gs#135990:u8
        let s_3399_0: bool = fn_state.gs_135990;
        // N s_3399_1: branch s_3399_0 b3838 b3400
        if s_3399_0 {
            return block_3838(state, tracer, fn_state);
        } else {
            return block_3400(state, tracer, fn_state);
        };
    }
    fn block_3400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3400_0: const #0u : u8
        let s_3400_0: bool = false;
        // D s_3400_1: write-var gs#135991 <= s_3400_0
        fn_state.gs_135991 = s_3400_0;
        // N s_3400_2: jump b3401
        return block_3401(state, tracer, fn_state);
    }
    fn block_3401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3401_0: read-var gs#135991:u8
        let s_3401_0: bool = fn_state.gs_135991;
        // N s_3401_1: branch s_3401_0 b3837 b3402
        if s_3401_0 {
            return block_3837(state, tracer, fn_state);
        } else {
            return block_3402(state, tracer, fn_state);
        };
    }
    fn block_3402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3402_0: read-var CRm:u8
        let s_3402_0: u8 = fn_state.CRm;
        // D s_3402_1: cast zx s_3402_0 -> bv
        let s_3402_1: Bits = Bits::new(s_3402_0 as u128, 4u16);
        // C s_3402_2: const #5u : u8
        let s_3402_2: u8 = 5;
        // C s_3402_3: cast zx s_3402_2 -> bv
        let s_3402_3: Bits = Bits::new(s_3402_2 as u128, 4u16);
        // D s_3402_4: cmp-eq s_3402_1 s_3402_3
        let s_3402_4: bool = ((s_3402_1) == (s_3402_3));
        // N s_3402_5: branch s_3402_4 b3836 b3403
        if s_3402_4 {
            return block_3836(state, tracer, fn_state);
        } else {
            return block_3403(state, tracer, fn_state);
        };
    }
    fn block_3403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3403_0: const #0u : u8
        let s_3403_0: bool = false;
        // D s_3403_1: write-var gs#135992 <= s_3403_0
        fn_state.gs_135992 = s_3403_0;
        // N s_3403_2: jump b3404
        return block_3404(state, tracer, fn_state);
    }
    fn block_3404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3404_0: read-var gs#135992:u8
        let s_3404_0: bool = fn_state.gs_135992;
        // N s_3404_1: branch s_3404_0 b3835 b3405
        if s_3404_0 {
            return block_3835(state, tracer, fn_state);
        } else {
            return block_3405(state, tracer, fn_state);
        };
    }
    fn block_3405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3405_0: const #0u : u8
        let s_3405_0: bool = false;
        // D s_3405_1: write-var gs#135993 <= s_3405_0
        fn_state.gs_135993 = s_3405_0;
        // N s_3405_2: jump b3406
        return block_3406(state, tracer, fn_state);
    }
    fn block_3406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3406_0: read-var gs#135993:u8
        let s_3406_0: bool = fn_state.gs_135993;
        // N s_3406_1: branch s_3406_0 b3834 b3407
        if s_3406_0 {
            return block_3834(state, tracer, fn_state);
        } else {
            return block_3407(state, tracer, fn_state);
        };
    }
    fn block_3407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3407_0: const #0u : u8
        let s_3407_0: bool = false;
        // D s_3407_1: write-var gs#135994 <= s_3407_0
        fn_state.gs_135994 = s_3407_0;
        // N s_3407_2: jump b3408
        return block_3408(state, tracer, fn_state);
    }
    fn block_3408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3408_0: read-var gs#135994:u8
        let s_3408_0: bool = fn_state.gs_135994;
        // N s_3408_1: branch s_3408_0 b3833 b3409
        if s_3408_0 {
            return block_3833(state, tracer, fn_state);
        } else {
            return block_3409(state, tracer, fn_state);
        };
    }
    fn block_3409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3409_0: const #0u : u8
        let s_3409_0: bool = false;
        // D s_3409_1: write-var gs#135995 <= s_3409_0
        fn_state.gs_135995 = s_3409_0;
        // N s_3409_2: jump b3410
        return block_3410(state, tracer, fn_state);
    }
    fn block_3410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3410_0: read-var gs#135995:u8
        let s_3410_0: bool = fn_state.gs_135995;
        // N s_3410_1: branch s_3410_0 b3832 b3411
        if s_3410_0 {
            return block_3832(state, tracer, fn_state);
        } else {
            return block_3411(state, tracer, fn_state);
        };
    }
    fn block_3411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3411_0: read-var CRm:u8
        let s_3411_0: u8 = fn_state.CRm;
        // D s_3411_1: cast zx s_3411_0 -> bv
        let s_3411_1: Bits = Bits::new(s_3411_0 as u128, 4u16);
        // C s_3411_2: const #5u : u8
        let s_3411_2: u8 = 5;
        // C s_3411_3: cast zx s_3411_2 -> bv
        let s_3411_3: Bits = Bits::new(s_3411_2 as u128, 4u16);
        // D s_3411_4: cmp-eq s_3411_1 s_3411_3
        let s_3411_4: bool = ((s_3411_1) == (s_3411_3));
        // N s_3411_5: branch s_3411_4 b3831 b3412
        if s_3411_4 {
            return block_3831(state, tracer, fn_state);
        } else {
            return block_3412(state, tracer, fn_state);
        };
    }
    fn block_3412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3412_0: const #0u : u8
        let s_3412_0: bool = false;
        // D s_3412_1: write-var gs#135996 <= s_3412_0
        fn_state.gs_135996 = s_3412_0;
        // N s_3412_2: jump b3413
        return block_3413(state, tracer, fn_state);
    }
    fn block_3413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3413_0: read-var gs#135996:u8
        let s_3413_0: bool = fn_state.gs_135996;
        // N s_3413_1: branch s_3413_0 b3830 b3414
        if s_3413_0 {
            return block_3830(state, tracer, fn_state);
        } else {
            return block_3414(state, tracer, fn_state);
        };
    }
    fn block_3414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3414_0: const #0u : u8
        let s_3414_0: bool = false;
        // D s_3414_1: write-var gs#135997 <= s_3414_0
        fn_state.gs_135997 = s_3414_0;
        // N s_3414_2: jump b3415
        return block_3415(state, tracer, fn_state);
    }
    fn block_3415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3415_0: read-var gs#135997:u8
        let s_3415_0: bool = fn_state.gs_135997;
        // N s_3415_1: branch s_3415_0 b3829 b3416
        if s_3415_0 {
            return block_3829(state, tracer, fn_state);
        } else {
            return block_3416(state, tracer, fn_state);
        };
    }
    fn block_3416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3416_0: const #0u : u8
        let s_3416_0: bool = false;
        // D s_3416_1: write-var gs#135998 <= s_3416_0
        fn_state.gs_135998 = s_3416_0;
        // N s_3416_2: jump b3417
        return block_3417(state, tracer, fn_state);
    }
    fn block_3417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3417_0: read-var gs#135998:u8
        let s_3417_0: bool = fn_state.gs_135998;
        // N s_3417_1: branch s_3417_0 b3828 b3418
        if s_3417_0 {
            return block_3828(state, tracer, fn_state);
        } else {
            return block_3418(state, tracer, fn_state);
        };
    }
    fn block_3418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3418_0: const #0u : u8
        let s_3418_0: bool = false;
        // D s_3418_1: write-var gs#135999 <= s_3418_0
        fn_state.gs_135999 = s_3418_0;
        // N s_3418_2: jump b3419
        return block_3419(state, tracer, fn_state);
    }
    fn block_3419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3419_0: read-var gs#135999:u8
        let s_3419_0: bool = fn_state.gs_135999;
        // N s_3419_1: branch s_3419_0 b3827 b3420
        if s_3419_0 {
            return block_3827(state, tracer, fn_state);
        } else {
            return block_3420(state, tracer, fn_state);
        };
    }
    fn block_3420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3420_0: read-var CRm:u8
        let s_3420_0: u8 = fn_state.CRm;
        // D s_3420_1: cast zx s_3420_0 -> bv
        let s_3420_1: Bits = Bits::new(s_3420_0 as u128, 4u16);
        // C s_3420_2: const #3u : u8
        let s_3420_2: u8 = 3;
        // C s_3420_3: cast zx s_3420_2 -> bv
        let s_3420_3: Bits = Bits::new(s_3420_2 as u128, 4u16);
        // D s_3420_4: cmp-eq s_3420_1 s_3420_3
        let s_3420_4: bool = ((s_3420_1) == (s_3420_3));
        // N s_3420_5: branch s_3420_4 b3826 b3421
        if s_3420_4 {
            return block_3826(state, tracer, fn_state);
        } else {
            return block_3421(state, tracer, fn_state);
        };
    }
    fn block_3421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3421_0: const #0u : u8
        let s_3421_0: bool = false;
        // D s_3421_1: write-var gs#136000 <= s_3421_0
        fn_state.gs_136000 = s_3421_0;
        // N s_3421_2: jump b3422
        return block_3422(state, tracer, fn_state);
    }
    fn block_3422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3422_0: read-var gs#136000:u8
        let s_3422_0: bool = fn_state.gs_136000;
        // N s_3422_1: branch s_3422_0 b3825 b3423
        if s_3422_0 {
            return block_3825(state, tracer, fn_state);
        } else {
            return block_3423(state, tracer, fn_state);
        };
    }
    fn block_3423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3423_0: const #0u : u8
        let s_3423_0: bool = false;
        // D s_3423_1: write-var gs#136001 <= s_3423_0
        fn_state.gs_136001 = s_3423_0;
        // N s_3423_2: jump b3424
        return block_3424(state, tracer, fn_state);
    }
    fn block_3424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3424_0: read-var gs#136001:u8
        let s_3424_0: bool = fn_state.gs_136001;
        // N s_3424_1: branch s_3424_0 b3824 b3425
        if s_3424_0 {
            return block_3824(state, tracer, fn_state);
        } else {
            return block_3425(state, tracer, fn_state);
        };
    }
    fn block_3425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3425_0: const #0u : u8
        let s_3425_0: bool = false;
        // D s_3425_1: write-var gs#136002 <= s_3425_0
        fn_state.gs_136002 = s_3425_0;
        // N s_3425_2: jump b3426
        return block_3426(state, tracer, fn_state);
    }
    fn block_3426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3426_0: read-var gs#136002:u8
        let s_3426_0: bool = fn_state.gs_136002;
        // N s_3426_1: branch s_3426_0 b3823 b3427
        if s_3426_0 {
            return block_3823(state, tracer, fn_state);
        } else {
            return block_3427(state, tracer, fn_state);
        };
    }
    fn block_3427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3427_0: const #0u : u8
        let s_3427_0: bool = false;
        // D s_3427_1: write-var gs#136003 <= s_3427_0
        fn_state.gs_136003 = s_3427_0;
        // N s_3427_2: jump b3428
        return block_3428(state, tracer, fn_state);
    }
    fn block_3428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3428_0: read-var gs#136003:u8
        let s_3428_0: bool = fn_state.gs_136003;
        // N s_3428_1: branch s_3428_0 b3822 b3429
        if s_3428_0 {
            return block_3822(state, tracer, fn_state);
        } else {
            return block_3429(state, tracer, fn_state);
        };
    }
    fn block_3429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3429_0: read-var CRm:u8
        let s_3429_0: u8 = fn_state.CRm;
        // D s_3429_1: cast zx s_3429_0 -> bv
        let s_3429_1: Bits = Bits::new(s_3429_0 as u128, 4u16);
        // C s_3429_2: const #4u : u8
        let s_3429_2: u8 = 4;
        // C s_3429_3: cast zx s_3429_2 -> bv
        let s_3429_3: Bits = Bits::new(s_3429_2 as u128, 4u16);
        // D s_3429_4: cmp-eq s_3429_1 s_3429_3
        let s_3429_4: bool = ((s_3429_1) == (s_3429_3));
        // N s_3429_5: branch s_3429_4 b3821 b3430
        if s_3429_4 {
            return block_3821(state, tracer, fn_state);
        } else {
            return block_3430(state, tracer, fn_state);
        };
    }
    fn block_3430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3430_0: const #0u : u8
        let s_3430_0: bool = false;
        // D s_3430_1: write-var gs#136004 <= s_3430_0
        fn_state.gs_136004 = s_3430_0;
        // N s_3430_2: jump b3431
        return block_3431(state, tracer, fn_state);
    }
    fn block_3431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3431_0: read-var gs#136004:u8
        let s_3431_0: bool = fn_state.gs_136004;
        // N s_3431_1: branch s_3431_0 b3820 b3432
        if s_3431_0 {
            return block_3820(state, tracer, fn_state);
        } else {
            return block_3432(state, tracer, fn_state);
        };
    }
    fn block_3432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3432_0: const #0u : u8
        let s_3432_0: bool = false;
        // D s_3432_1: write-var gs#136005 <= s_3432_0
        fn_state.gs_136005 = s_3432_0;
        // N s_3432_2: jump b3433
        return block_3433(state, tracer, fn_state);
    }
    fn block_3433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3433_0: read-var gs#136005:u8
        let s_3433_0: bool = fn_state.gs_136005;
        // N s_3433_1: branch s_3433_0 b3819 b3434
        if s_3433_0 {
            return block_3819(state, tracer, fn_state);
        } else {
            return block_3434(state, tracer, fn_state);
        };
    }
    fn block_3434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3434_0: const #0u : u8
        let s_3434_0: bool = false;
        // D s_3434_1: write-var gs#136006 <= s_3434_0
        fn_state.gs_136006 = s_3434_0;
        // N s_3434_2: jump b3435
        return block_3435(state, tracer, fn_state);
    }
    fn block_3435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3435_0: read-var gs#136006:u8
        let s_3435_0: bool = fn_state.gs_136006;
        // N s_3435_1: branch s_3435_0 b3818 b3436
        if s_3435_0 {
            return block_3818(state, tracer, fn_state);
        } else {
            return block_3436(state, tracer, fn_state);
        };
    }
    fn block_3436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3436_0: const #0u : u8
        let s_3436_0: bool = false;
        // D s_3436_1: write-var gs#136007 <= s_3436_0
        fn_state.gs_136007 = s_3436_0;
        // N s_3436_2: jump b3437
        return block_3437(state, tracer, fn_state);
    }
    fn block_3437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3437_0: read-var gs#136007:u8
        let s_3437_0: bool = fn_state.gs_136007;
        // N s_3437_1: branch s_3437_0 b3817 b3438
        if s_3437_0 {
            return block_3817(state, tracer, fn_state);
        } else {
            return block_3438(state, tracer, fn_state);
        };
    }
    fn block_3438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3438_0: read-var CRm:u8
        let s_3438_0: u8 = fn_state.CRm;
        // D s_3438_1: cast zx s_3438_0 -> bv
        let s_3438_1: Bits = Bits::new(s_3438_0 as u128, 4u16);
        // C s_3438_2: const #1u : u8
        let s_3438_2: u8 = 1;
        // C s_3438_3: cast zx s_3438_2 -> bv
        let s_3438_3: Bits = Bits::new(s_3438_2 as u128, 4u16);
        // D s_3438_4: cmp-eq s_3438_1 s_3438_3
        let s_3438_4: bool = ((s_3438_1) == (s_3438_3));
        // N s_3438_5: branch s_3438_4 b3816 b3439
        if s_3438_4 {
            return block_3816(state, tracer, fn_state);
        } else {
            return block_3439(state, tracer, fn_state);
        };
    }
    fn block_3439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3439_0: const #0u : u8
        let s_3439_0: bool = false;
        // D s_3439_1: write-var gs#136008 <= s_3439_0
        fn_state.gs_136008 = s_3439_0;
        // N s_3439_2: jump b3440
        return block_3440(state, tracer, fn_state);
    }
    fn block_3440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3440_0: read-var gs#136008:u8
        let s_3440_0: bool = fn_state.gs_136008;
        // N s_3440_1: branch s_3440_0 b3815 b3441
        if s_3440_0 {
            return block_3815(state, tracer, fn_state);
        } else {
            return block_3441(state, tracer, fn_state);
        };
    }
    fn block_3441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3441_0: const #0u : u8
        let s_3441_0: bool = false;
        // D s_3441_1: write-var gs#136009 <= s_3441_0
        fn_state.gs_136009 = s_3441_0;
        // N s_3441_2: jump b3442
        return block_3442(state, tracer, fn_state);
    }
    fn block_3442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3442_0: read-var gs#136009:u8
        let s_3442_0: bool = fn_state.gs_136009;
        // N s_3442_1: branch s_3442_0 b3814 b3443
        if s_3442_0 {
            return block_3814(state, tracer, fn_state);
        } else {
            return block_3443(state, tracer, fn_state);
        };
    }
    fn block_3443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3443_0: const #0u : u8
        let s_3443_0: bool = false;
        // D s_3443_1: write-var gs#136010 <= s_3443_0
        fn_state.gs_136010 = s_3443_0;
        // N s_3443_2: jump b3444
        return block_3444(state, tracer, fn_state);
    }
    fn block_3444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3444_0: read-var gs#136010:u8
        let s_3444_0: bool = fn_state.gs_136010;
        // N s_3444_1: branch s_3444_0 b3813 b3445
        if s_3444_0 {
            return block_3813(state, tracer, fn_state);
        } else {
            return block_3445(state, tracer, fn_state);
        };
    }
    fn block_3445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3445_0: const #0u : u8
        let s_3445_0: bool = false;
        // D s_3445_1: write-var gs#136011 <= s_3445_0
        fn_state.gs_136011 = s_3445_0;
        // N s_3445_2: jump b3446
        return block_3446(state, tracer, fn_state);
    }
    fn block_3446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3446_0: read-var gs#136011:u8
        let s_3446_0: bool = fn_state.gs_136011;
        // N s_3446_1: branch s_3446_0 b3812 b3447
        if s_3446_0 {
            return block_3812(state, tracer, fn_state);
        } else {
            return block_3447(state, tracer, fn_state);
        };
    }
    fn block_3447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3447_0: read-var CRm:u8
        let s_3447_0: u8 = fn_state.CRm;
        // D s_3447_1: cast zx s_3447_0 -> bv
        let s_3447_1: Bits = Bits::new(s_3447_0 as u128, 4u16);
        // C s_3447_2: const #2u : u8
        let s_3447_2: u8 = 2;
        // C s_3447_3: cast zx s_3447_2 -> bv
        let s_3447_3: Bits = Bits::new(s_3447_2 as u128, 4u16);
        // D s_3447_4: cmp-eq s_3447_1 s_3447_3
        let s_3447_4: bool = ((s_3447_1) == (s_3447_3));
        // N s_3447_5: branch s_3447_4 b3811 b3448
        if s_3447_4 {
            return block_3811(state, tracer, fn_state);
        } else {
            return block_3448(state, tracer, fn_state);
        };
    }
    fn block_3448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3448_0: const #0u : u8
        let s_3448_0: bool = false;
        // D s_3448_1: write-var gs#136012 <= s_3448_0
        fn_state.gs_136012 = s_3448_0;
        // N s_3448_2: jump b3449
        return block_3449(state, tracer, fn_state);
    }
    fn block_3449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3449_0: read-var gs#136012:u8
        let s_3449_0: bool = fn_state.gs_136012;
        // N s_3449_1: branch s_3449_0 b3810 b3450
        if s_3449_0 {
            return block_3810(state, tracer, fn_state);
        } else {
            return block_3450(state, tracer, fn_state);
        };
    }
    fn block_3450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3450_0: const #0u : u8
        let s_3450_0: bool = false;
        // D s_3450_1: write-var gs#136013 <= s_3450_0
        fn_state.gs_136013 = s_3450_0;
        // N s_3450_2: jump b3451
        return block_3451(state, tracer, fn_state);
    }
    fn block_3451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3451_0: read-var gs#136013:u8
        let s_3451_0: bool = fn_state.gs_136013;
        // N s_3451_1: branch s_3451_0 b3809 b3452
        if s_3451_0 {
            return block_3809(state, tracer, fn_state);
        } else {
            return block_3452(state, tracer, fn_state);
        };
    }
    fn block_3452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3452_0: const #0u : u8
        let s_3452_0: bool = false;
        // D s_3452_1: write-var gs#136014 <= s_3452_0
        fn_state.gs_136014 = s_3452_0;
        // N s_3452_2: jump b3453
        return block_3453(state, tracer, fn_state);
    }
    fn block_3453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3453_0: read-var gs#136014:u8
        let s_3453_0: bool = fn_state.gs_136014;
        // N s_3453_1: branch s_3453_0 b3808 b3454
        if s_3453_0 {
            return block_3808(state, tracer, fn_state);
        } else {
            return block_3454(state, tracer, fn_state);
        };
    }
    fn block_3454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3454_0: const #0u : u8
        let s_3454_0: bool = false;
        // D s_3454_1: write-var gs#136015 <= s_3454_0
        fn_state.gs_136015 = s_3454_0;
        // N s_3454_2: jump b3455
        return block_3455(state, tracer, fn_state);
    }
    fn block_3455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3455_0: read-var gs#136015:u8
        let s_3455_0: bool = fn_state.gs_136015;
        // N s_3455_1: branch s_3455_0 b3807 b3456
        if s_3455_0 {
            return block_3807(state, tracer, fn_state);
        } else {
            return block_3456(state, tracer, fn_state);
        };
    }
    fn block_3456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3456_0: read-var CRm:u8
        let s_3456_0: u8 = fn_state.CRm;
        // D s_3456_1: cast zx s_3456_0 -> bv
        let s_3456_1: Bits = Bits::new(s_3456_0 as u128, 4u16);
        // C s_3456_2: const #5u : u8
        let s_3456_2: u8 = 5;
        // C s_3456_3: cast zx s_3456_2 -> bv
        let s_3456_3: Bits = Bits::new(s_3456_2 as u128, 4u16);
        // D s_3456_4: cmp-eq s_3456_1 s_3456_3
        let s_3456_4: bool = ((s_3456_1) == (s_3456_3));
        // N s_3456_5: branch s_3456_4 b3806 b3457
        if s_3456_4 {
            return block_3806(state, tracer, fn_state);
        } else {
            return block_3457(state, tracer, fn_state);
        };
    }
    fn block_3457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3457_0: const #0u : u8
        let s_3457_0: bool = false;
        // D s_3457_1: write-var gs#136016 <= s_3457_0
        fn_state.gs_136016 = s_3457_0;
        // N s_3457_2: jump b3458
        return block_3458(state, tracer, fn_state);
    }
    fn block_3458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3458_0: read-var gs#136016:u8
        let s_3458_0: bool = fn_state.gs_136016;
        // N s_3458_1: branch s_3458_0 b3805 b3459
        if s_3458_0 {
            return block_3805(state, tracer, fn_state);
        } else {
            return block_3459(state, tracer, fn_state);
        };
    }
    fn block_3459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3459_0: const #0u : u8
        let s_3459_0: bool = false;
        // D s_3459_1: write-var gs#136017 <= s_3459_0
        fn_state.gs_136017 = s_3459_0;
        // N s_3459_2: jump b3460
        return block_3460(state, tracer, fn_state);
    }
    fn block_3460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3460_0: read-var gs#136017:u8
        let s_3460_0: bool = fn_state.gs_136017;
        // N s_3460_1: branch s_3460_0 b3804 b3461
        if s_3460_0 {
            return block_3804(state, tracer, fn_state);
        } else {
            return block_3461(state, tracer, fn_state);
        };
    }
    fn block_3461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3461_0: const #0u : u8
        let s_3461_0: bool = false;
        // D s_3461_1: write-var gs#136018 <= s_3461_0
        fn_state.gs_136018 = s_3461_0;
        // N s_3461_2: jump b3462
        return block_3462(state, tracer, fn_state);
    }
    fn block_3462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3462_0: read-var gs#136018:u8
        let s_3462_0: bool = fn_state.gs_136018;
        // N s_3462_1: branch s_3462_0 b3803 b3463
        if s_3462_0 {
            return block_3803(state, tracer, fn_state);
        } else {
            return block_3463(state, tracer, fn_state);
        };
    }
    fn block_3463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3463_0: const #0u : u8
        let s_3463_0: bool = false;
        // D s_3463_1: write-var gs#136019 <= s_3463_0
        fn_state.gs_136019 = s_3463_0;
        // N s_3463_2: jump b3464
        return block_3464(state, tracer, fn_state);
    }
    fn block_3464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3464_0: read-var gs#136019:u8
        let s_3464_0: bool = fn_state.gs_136019;
        // N s_3464_1: branch s_3464_0 b3802 b3465
        if s_3464_0 {
            return block_3802(state, tracer, fn_state);
        } else {
            return block_3465(state, tracer, fn_state);
        };
    }
    fn block_3465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3465_0: read-var CRm:u8
        let s_3465_0: u8 = fn_state.CRm;
        // D s_3465_1: cast zx s_3465_0 -> bv
        let s_3465_1: Bits = Bits::new(s_3465_0 as u128, 4u16);
        // C s_3465_2: const #4u : u8
        let s_3465_2: u8 = 4;
        // C s_3465_3: cast zx s_3465_2 -> bv
        let s_3465_3: Bits = Bits::new(s_3465_2 as u128, 4u16);
        // D s_3465_4: cmp-eq s_3465_1 s_3465_3
        let s_3465_4: bool = ((s_3465_1) == (s_3465_3));
        // N s_3465_5: branch s_3465_4 b3801 b3466
        if s_3465_4 {
            return block_3801(state, tracer, fn_state);
        } else {
            return block_3466(state, tracer, fn_state);
        };
    }
    fn block_3466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3466_0: const #0u : u8
        let s_3466_0: bool = false;
        // D s_3466_1: write-var gs#136020 <= s_3466_0
        fn_state.gs_136020 = s_3466_0;
        // N s_3466_2: jump b3467
        return block_3467(state, tracer, fn_state);
    }
    fn block_3467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3467_0: read-var gs#136020:u8
        let s_3467_0: bool = fn_state.gs_136020;
        // N s_3467_1: branch s_3467_0 b3800 b3468
        if s_3467_0 {
            return block_3800(state, tracer, fn_state);
        } else {
            return block_3468(state, tracer, fn_state);
        };
    }
    fn block_3468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3468_0: const #0u : u8
        let s_3468_0: bool = false;
        // D s_3468_1: write-var gs#136021 <= s_3468_0
        fn_state.gs_136021 = s_3468_0;
        // N s_3468_2: jump b3469
        return block_3469(state, tracer, fn_state);
    }
    fn block_3469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3469_0: read-var gs#136021:u8
        let s_3469_0: bool = fn_state.gs_136021;
        // N s_3469_1: branch s_3469_0 b3799 b3470
        if s_3469_0 {
            return block_3799(state, tracer, fn_state);
        } else {
            return block_3470(state, tracer, fn_state);
        };
    }
    fn block_3470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3470_0: const #0u : u8
        let s_3470_0: bool = false;
        // D s_3470_1: write-var gs#136022 <= s_3470_0
        fn_state.gs_136022 = s_3470_0;
        // N s_3470_2: jump b3471
        return block_3471(state, tracer, fn_state);
    }
    fn block_3471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3471_0: read-var gs#136022:u8
        let s_3471_0: bool = fn_state.gs_136022;
        // N s_3471_1: branch s_3471_0 b3798 b3472
        if s_3471_0 {
            return block_3798(state, tracer, fn_state);
        } else {
            return block_3472(state, tracer, fn_state);
        };
    }
    fn block_3472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3472_0: const #0u : u8
        let s_3472_0: bool = false;
        // D s_3472_1: write-var gs#136023 <= s_3472_0
        fn_state.gs_136023 = s_3472_0;
        // N s_3472_2: jump b3473
        return block_3473(state, tracer, fn_state);
    }
    fn block_3473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3473_0: read-var gs#136023:u8
        let s_3473_0: bool = fn_state.gs_136023;
        // N s_3473_1: branch s_3473_0 b3797 b3474
        if s_3473_0 {
            return block_3797(state, tracer, fn_state);
        } else {
            return block_3474(state, tracer, fn_state);
        };
    }
    fn block_3474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3474_0: read-var CRm:u8
        let s_3474_0: u8 = fn_state.CRm;
        // D s_3474_1: cast zx s_3474_0 -> bv
        let s_3474_1: Bits = Bits::new(s_3474_0 as u128, 4u16);
        // C s_3474_2: const #5u : u8
        let s_3474_2: u8 = 5;
        // C s_3474_3: cast zx s_3474_2 -> bv
        let s_3474_3: Bits = Bits::new(s_3474_2 as u128, 4u16);
        // D s_3474_4: cmp-eq s_3474_1 s_3474_3
        let s_3474_4: bool = ((s_3474_1) == (s_3474_3));
        // N s_3474_5: branch s_3474_4 b3796 b3475
        if s_3474_4 {
            return block_3796(state, tracer, fn_state);
        } else {
            return block_3475(state, tracer, fn_state);
        };
    }
    fn block_3475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3475_0: const #0u : u8
        let s_3475_0: bool = false;
        // D s_3475_1: write-var gs#136024 <= s_3475_0
        fn_state.gs_136024 = s_3475_0;
        // N s_3475_2: jump b3476
        return block_3476(state, tracer, fn_state);
    }
    fn block_3476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3476_0: read-var gs#136024:u8
        let s_3476_0: bool = fn_state.gs_136024;
        // N s_3476_1: branch s_3476_0 b3795 b3477
        if s_3476_0 {
            return block_3795(state, tracer, fn_state);
        } else {
            return block_3477(state, tracer, fn_state);
        };
    }
    fn block_3477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3477_0: const #0u : u8
        let s_3477_0: bool = false;
        // D s_3477_1: write-var gs#136025 <= s_3477_0
        fn_state.gs_136025 = s_3477_0;
        // N s_3477_2: jump b3478
        return block_3478(state, tracer, fn_state);
    }
    fn block_3478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3478_0: read-var gs#136025:u8
        let s_3478_0: bool = fn_state.gs_136025;
        // N s_3478_1: branch s_3478_0 b3794 b3479
        if s_3478_0 {
            return block_3794(state, tracer, fn_state);
        } else {
            return block_3479(state, tracer, fn_state);
        };
    }
    fn block_3479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3479_0: const #0u : u8
        let s_3479_0: bool = false;
        // D s_3479_1: write-var gs#136026 <= s_3479_0
        fn_state.gs_136026 = s_3479_0;
        // N s_3479_2: jump b3480
        return block_3480(state, tracer, fn_state);
    }
    fn block_3480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3480_0: read-var gs#136026:u8
        let s_3480_0: bool = fn_state.gs_136026;
        // N s_3480_1: branch s_3480_0 b3793 b3481
        if s_3480_0 {
            return block_3793(state, tracer, fn_state);
        } else {
            return block_3481(state, tracer, fn_state);
        };
    }
    fn block_3481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3481_0: const #0u : u8
        let s_3481_0: bool = false;
        // D s_3481_1: write-var gs#136027 <= s_3481_0
        fn_state.gs_136027 = s_3481_0;
        // N s_3481_2: jump b3482
        return block_3482(state, tracer, fn_state);
    }
    fn block_3482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3482_0: read-var gs#136027:u8
        let s_3482_0: bool = fn_state.gs_136027;
        // N s_3482_1: branch s_3482_0 b3792 b3483
        if s_3482_0 {
            return block_3792(state, tracer, fn_state);
        } else {
            return block_3483(state, tracer, fn_state);
        };
    }
    fn block_3483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3483_0: read-var CRm:u8
        let s_3483_0: u8 = fn_state.CRm;
        // D s_3483_1: cast zx s_3483_0 -> bv
        let s_3483_1: Bits = Bits::new(s_3483_0 as u128, 4u16);
        // C s_3483_2: const #5u : u8
        let s_3483_2: u8 = 5;
        // C s_3483_3: cast zx s_3483_2 -> bv
        let s_3483_3: Bits = Bits::new(s_3483_2 as u128, 4u16);
        // D s_3483_4: cmp-eq s_3483_1 s_3483_3
        let s_3483_4: bool = ((s_3483_1) == (s_3483_3));
        // N s_3483_5: branch s_3483_4 b3791 b3484
        if s_3483_4 {
            return block_3791(state, tracer, fn_state);
        } else {
            return block_3484(state, tracer, fn_state);
        };
    }
    fn block_3484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3484_0: const #0u : u8
        let s_3484_0: bool = false;
        // D s_3484_1: write-var gs#136028 <= s_3484_0
        fn_state.gs_136028 = s_3484_0;
        // N s_3484_2: jump b3485
        return block_3485(state, tracer, fn_state);
    }
    fn block_3485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3485_0: read-var gs#136028:u8
        let s_3485_0: bool = fn_state.gs_136028;
        // N s_3485_1: branch s_3485_0 b3790 b3486
        if s_3485_0 {
            return block_3790(state, tracer, fn_state);
        } else {
            return block_3486(state, tracer, fn_state);
        };
    }
    fn block_3486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3486_0: const #0u : u8
        let s_3486_0: bool = false;
        // D s_3486_1: write-var gs#136029 <= s_3486_0
        fn_state.gs_136029 = s_3486_0;
        // N s_3486_2: jump b3487
        return block_3487(state, tracer, fn_state);
    }
    fn block_3487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3487_0: read-var gs#136029:u8
        let s_3487_0: bool = fn_state.gs_136029;
        // N s_3487_1: branch s_3487_0 b3789 b3488
        if s_3487_0 {
            return block_3789(state, tracer, fn_state);
        } else {
            return block_3488(state, tracer, fn_state);
        };
    }
    fn block_3488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3488_0: const #0u : u8
        let s_3488_0: bool = false;
        // D s_3488_1: write-var gs#136030 <= s_3488_0
        fn_state.gs_136030 = s_3488_0;
        // N s_3488_2: jump b3489
        return block_3489(state, tracer, fn_state);
    }
    fn block_3489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3489_0: read-var gs#136030:u8
        let s_3489_0: bool = fn_state.gs_136030;
        // N s_3489_1: branch s_3489_0 b3788 b3490
        if s_3489_0 {
            return block_3788(state, tracer, fn_state);
        } else {
            return block_3490(state, tracer, fn_state);
        };
    }
    fn block_3490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3490_0: const #0u : u8
        let s_3490_0: bool = false;
        // D s_3490_1: write-var gs#136031 <= s_3490_0
        fn_state.gs_136031 = s_3490_0;
        // N s_3490_2: jump b3491
        return block_3491(state, tracer, fn_state);
    }
    fn block_3491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3491_0: read-var gs#136031:u8
        let s_3491_0: bool = fn_state.gs_136031;
        // N s_3491_1: branch s_3491_0 b3787 b3492
        if s_3491_0 {
            return block_3787(state, tracer, fn_state);
        } else {
            return block_3492(state, tracer, fn_state);
        };
    }
    fn block_3492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3492_0: read-var CRm:u8
        let s_3492_0: u8 = fn_state.CRm;
        // D s_3492_1: cast zx s_3492_0 -> bv
        let s_3492_1: Bits = Bits::new(s_3492_0 as u128, 4u16);
        // C s_3492_2: const #4u : u8
        let s_3492_2: u8 = 4;
        // C s_3492_3: cast zx s_3492_2 -> bv
        let s_3492_3: Bits = Bits::new(s_3492_2 as u128, 4u16);
        // D s_3492_4: cmp-eq s_3492_1 s_3492_3
        let s_3492_4: bool = ((s_3492_1) == (s_3492_3));
        // N s_3492_5: branch s_3492_4 b3786 b3493
        if s_3492_4 {
            return block_3786(state, tracer, fn_state);
        } else {
            return block_3493(state, tracer, fn_state);
        };
    }
    fn block_3493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3493_0: const #0u : u8
        let s_3493_0: bool = false;
        // D s_3493_1: write-var gs#136032 <= s_3493_0
        fn_state.gs_136032 = s_3493_0;
        // N s_3493_2: jump b3494
        return block_3494(state, tracer, fn_state);
    }
    fn block_3494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3494_0: read-var gs#136032:u8
        let s_3494_0: bool = fn_state.gs_136032;
        // N s_3494_1: branch s_3494_0 b3785 b3495
        if s_3494_0 {
            return block_3785(state, tracer, fn_state);
        } else {
            return block_3495(state, tracer, fn_state);
        };
    }
    fn block_3495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3495_0: const #0u : u8
        let s_3495_0: bool = false;
        // D s_3495_1: write-var gs#136033 <= s_3495_0
        fn_state.gs_136033 = s_3495_0;
        // N s_3495_2: jump b3496
        return block_3496(state, tracer, fn_state);
    }
    fn block_3496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3496_0: read-var gs#136033:u8
        let s_3496_0: bool = fn_state.gs_136033;
        // N s_3496_1: branch s_3496_0 b3784 b3497
        if s_3496_0 {
            return block_3784(state, tracer, fn_state);
        } else {
            return block_3497(state, tracer, fn_state);
        };
    }
    fn block_3497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3497_0: const #0u : u8
        let s_3497_0: bool = false;
        // D s_3497_1: write-var gs#136034 <= s_3497_0
        fn_state.gs_136034 = s_3497_0;
        // N s_3497_2: jump b3498
        return block_3498(state, tracer, fn_state);
    }
    fn block_3498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3498_0: read-var gs#136034:u8
        let s_3498_0: bool = fn_state.gs_136034;
        // N s_3498_1: branch s_3498_0 b3783 b3499
        if s_3498_0 {
            return block_3783(state, tracer, fn_state);
        } else {
            return block_3499(state, tracer, fn_state);
        };
    }
    fn block_3499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3499_0: const #0u : u8
        let s_3499_0: bool = false;
        // D s_3499_1: write-var gs#136035 <= s_3499_0
        fn_state.gs_136035 = s_3499_0;
        // N s_3499_2: jump b3500
        return block_3500(state, tracer, fn_state);
    }
    fn block_3500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3500_0: read-var gs#136035:u8
        let s_3500_0: bool = fn_state.gs_136035;
        // N s_3500_1: branch s_3500_0 b3782 b3501
        if s_3500_0 {
            return block_3782(state, tracer, fn_state);
        } else {
            return block_3501(state, tracer, fn_state);
        };
    }
    fn block_3501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3501_0: read-var CRm:u8
        let s_3501_0: u8 = fn_state.CRm;
        // D s_3501_1: cast zx s_3501_0 -> bv
        let s_3501_1: Bits = Bits::new(s_3501_0 as u128, 4u16);
        // C s_3501_2: const #5u : u8
        let s_3501_2: u8 = 5;
        // C s_3501_3: cast zx s_3501_2 -> bv
        let s_3501_3: Bits = Bits::new(s_3501_2 as u128, 4u16);
        // D s_3501_4: cmp-eq s_3501_1 s_3501_3
        let s_3501_4: bool = ((s_3501_1) == (s_3501_3));
        // N s_3501_5: branch s_3501_4 b3781 b3502
        if s_3501_4 {
            return block_3781(state, tracer, fn_state);
        } else {
            return block_3502(state, tracer, fn_state);
        };
    }
    fn block_3502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3502_0: const #0u : u8
        let s_3502_0: bool = false;
        // D s_3502_1: write-var gs#136036 <= s_3502_0
        fn_state.gs_136036 = s_3502_0;
        // N s_3502_2: jump b3503
        return block_3503(state, tracer, fn_state);
    }
    fn block_3503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3503_0: read-var gs#136036:u8
        let s_3503_0: bool = fn_state.gs_136036;
        // N s_3503_1: branch s_3503_0 b3780 b3504
        if s_3503_0 {
            return block_3780(state, tracer, fn_state);
        } else {
            return block_3504(state, tracer, fn_state);
        };
    }
    fn block_3504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3504_0: const #0u : u8
        let s_3504_0: bool = false;
        // D s_3504_1: write-var gs#136037 <= s_3504_0
        fn_state.gs_136037 = s_3504_0;
        // N s_3504_2: jump b3505
        return block_3505(state, tracer, fn_state);
    }
    fn block_3505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3505_0: read-var gs#136037:u8
        let s_3505_0: bool = fn_state.gs_136037;
        // N s_3505_1: branch s_3505_0 b3779 b3506
        if s_3505_0 {
            return block_3779(state, tracer, fn_state);
        } else {
            return block_3506(state, tracer, fn_state);
        };
    }
    fn block_3506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3506_0: const #0u : u8
        let s_3506_0: bool = false;
        // D s_3506_1: write-var gs#136038 <= s_3506_0
        fn_state.gs_136038 = s_3506_0;
        // N s_3506_2: jump b3507
        return block_3507(state, tracer, fn_state);
    }
    fn block_3507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3507_0: read-var gs#136038:u8
        let s_3507_0: bool = fn_state.gs_136038;
        // N s_3507_1: branch s_3507_0 b3778 b3508
        if s_3507_0 {
            return block_3778(state, tracer, fn_state);
        } else {
            return block_3508(state, tracer, fn_state);
        };
    }
    fn block_3508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3508_0: const #0u : u8
        let s_3508_0: bool = false;
        // D s_3508_1: write-var gs#136039 <= s_3508_0
        fn_state.gs_136039 = s_3508_0;
        // N s_3508_2: jump b3509
        return block_3509(state, tracer, fn_state);
    }
    fn block_3509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3509_0: read-var gs#136039:u8
        let s_3509_0: bool = fn_state.gs_136039;
        // N s_3509_1: branch s_3509_0 b3777 b3510
        if s_3509_0 {
            return block_3777(state, tracer, fn_state);
        } else {
            return block_3510(state, tracer, fn_state);
        };
    }
    fn block_3510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3510_0: read-var CRm:u8
        let s_3510_0: u8 = fn_state.CRm;
        // D s_3510_1: cast zx s_3510_0 -> bv
        let s_3510_1: Bits = Bits::new(s_3510_0 as u128, 4u16);
        // C s_3510_2: const #5u : u8
        let s_3510_2: u8 = 5;
        // C s_3510_3: cast zx s_3510_2 -> bv
        let s_3510_3: Bits = Bits::new(s_3510_2 as u128, 4u16);
        // D s_3510_4: cmp-eq s_3510_1 s_3510_3
        let s_3510_4: bool = ((s_3510_1) == (s_3510_3));
        // N s_3510_5: branch s_3510_4 b3776 b3511
        if s_3510_4 {
            return block_3776(state, tracer, fn_state);
        } else {
            return block_3511(state, tracer, fn_state);
        };
    }
    fn block_3511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3511_0: const #0u : u8
        let s_3511_0: bool = false;
        // D s_3511_1: write-var gs#136040 <= s_3511_0
        fn_state.gs_136040 = s_3511_0;
        // N s_3511_2: jump b3512
        return block_3512(state, tracer, fn_state);
    }
    fn block_3512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3512_0: read-var gs#136040:u8
        let s_3512_0: bool = fn_state.gs_136040;
        // N s_3512_1: branch s_3512_0 b3775 b3513
        if s_3512_0 {
            return block_3775(state, tracer, fn_state);
        } else {
            return block_3513(state, tracer, fn_state);
        };
    }
    fn block_3513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3513_0: const #0u : u8
        let s_3513_0: bool = false;
        // D s_3513_1: write-var gs#136041 <= s_3513_0
        fn_state.gs_136041 = s_3513_0;
        // N s_3513_2: jump b3514
        return block_3514(state, tracer, fn_state);
    }
    fn block_3514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3514_0: read-var gs#136041:u8
        let s_3514_0: bool = fn_state.gs_136041;
        // N s_3514_1: branch s_3514_0 b3774 b3515
        if s_3514_0 {
            return block_3774(state, tracer, fn_state);
        } else {
            return block_3515(state, tracer, fn_state);
        };
    }
    fn block_3515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3515_0: const #0u : u8
        let s_3515_0: bool = false;
        // D s_3515_1: write-var gs#136042 <= s_3515_0
        fn_state.gs_136042 = s_3515_0;
        // N s_3515_2: jump b3516
        return block_3516(state, tracer, fn_state);
    }
    fn block_3516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3516_0: read-var gs#136042:u8
        let s_3516_0: bool = fn_state.gs_136042;
        // N s_3516_1: branch s_3516_0 b3773 b3517
        if s_3516_0 {
            return block_3773(state, tracer, fn_state);
        } else {
            return block_3517(state, tracer, fn_state);
        };
    }
    fn block_3517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3517_0: const #0u : u8
        let s_3517_0: bool = false;
        // D s_3517_1: write-var gs#136043 <= s_3517_0
        fn_state.gs_136043 = s_3517_0;
        // N s_3517_2: jump b3518
        return block_3518(state, tracer, fn_state);
    }
    fn block_3518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3518_0: read-var gs#136043:u8
        let s_3518_0: bool = fn_state.gs_136043;
        // N s_3518_1: branch s_3518_0 b3772 b3519
        if s_3518_0 {
            return block_3772(state, tracer, fn_state);
        } else {
            return block_3519(state, tracer, fn_state);
        };
    }
    fn block_3519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3519_0: read-var CRm:u8
        let s_3519_0: u8 = fn_state.CRm;
        // D s_3519_1: cast zx s_3519_0 -> bv
        let s_3519_1: Bits = Bits::new(s_3519_0 as u128, 4u16);
        // C s_3519_2: const #1u : u8
        let s_3519_2: u8 = 1;
        // C s_3519_3: cast zx s_3519_2 -> bv
        let s_3519_3: Bits = Bits::new(s_3519_2 as u128, 4u16);
        // D s_3519_4: cmp-eq s_3519_1 s_3519_3
        let s_3519_4: bool = ((s_3519_1) == (s_3519_3));
        // N s_3519_5: branch s_3519_4 b3771 b3520
        if s_3519_4 {
            return block_3771(state, tracer, fn_state);
        } else {
            return block_3520(state, tracer, fn_state);
        };
    }
    fn block_3520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3520_0: const #0u : u8
        let s_3520_0: bool = false;
        // D s_3520_1: write-var gs#136044 <= s_3520_0
        fn_state.gs_136044 = s_3520_0;
        // N s_3520_2: jump b3521
        return block_3521(state, tracer, fn_state);
    }
    fn block_3521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3521_0: read-var gs#136044:u8
        let s_3521_0: bool = fn_state.gs_136044;
        // N s_3521_1: branch s_3521_0 b3770 b3522
        if s_3521_0 {
            return block_3770(state, tracer, fn_state);
        } else {
            return block_3522(state, tracer, fn_state);
        };
    }
    fn block_3522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3522_0: const #0u : u8
        let s_3522_0: bool = false;
        // D s_3522_1: write-var gs#136045 <= s_3522_0
        fn_state.gs_136045 = s_3522_0;
        // N s_3522_2: jump b3523
        return block_3523(state, tracer, fn_state);
    }
    fn block_3523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3523_0: read-var gs#136045:u8
        let s_3523_0: bool = fn_state.gs_136045;
        // N s_3523_1: branch s_3523_0 b3769 b3524
        if s_3523_0 {
            return block_3769(state, tracer, fn_state);
        } else {
            return block_3524(state, tracer, fn_state);
        };
    }
    fn block_3524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3524_0: const #0u : u8
        let s_3524_0: bool = false;
        // D s_3524_1: write-var gs#136046 <= s_3524_0
        fn_state.gs_136046 = s_3524_0;
        // N s_3524_2: jump b3525
        return block_3525(state, tracer, fn_state);
    }
    fn block_3525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3525_0: read-var gs#136046:u8
        let s_3525_0: bool = fn_state.gs_136046;
        // N s_3525_1: branch s_3525_0 b3768 b3526
        if s_3525_0 {
            return block_3768(state, tracer, fn_state);
        } else {
            return block_3526(state, tracer, fn_state);
        };
    }
    fn block_3526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3526_0: const #0u : u8
        let s_3526_0: bool = false;
        // D s_3526_1: write-var gs#136047 <= s_3526_0
        fn_state.gs_136047 = s_3526_0;
        // N s_3526_2: jump b3527
        return block_3527(state, tracer, fn_state);
    }
    fn block_3527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3527_0: read-var gs#136047:u8
        let s_3527_0: bool = fn_state.gs_136047;
        // N s_3527_1: branch s_3527_0 b3767 b3528
        if s_3527_0 {
            return block_3767(state, tracer, fn_state);
        } else {
            return block_3528(state, tracer, fn_state);
        };
    }
    fn block_3528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3528_0: read-var CRm:u8
        let s_3528_0: u8 = fn_state.CRm;
        // D s_3528_1: cast zx s_3528_0 -> bv
        let s_3528_1: Bits = Bits::new(s_3528_0 as u128, 4u16);
        // C s_3528_2: const #4u : u8
        let s_3528_2: u8 = 4;
        // C s_3528_3: cast zx s_3528_2 -> bv
        let s_3528_3: Bits = Bits::new(s_3528_2 as u128, 4u16);
        // D s_3528_4: cmp-eq s_3528_1 s_3528_3
        let s_3528_4: bool = ((s_3528_1) == (s_3528_3));
        // N s_3528_5: branch s_3528_4 b3766 b3529
        if s_3528_4 {
            return block_3766(state, tracer, fn_state);
        } else {
            return block_3529(state, tracer, fn_state);
        };
    }
    fn block_3529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3529_0: const #0u : u8
        let s_3529_0: bool = false;
        // D s_3529_1: write-var gs#136048 <= s_3529_0
        fn_state.gs_136048 = s_3529_0;
        // N s_3529_2: jump b3530
        return block_3530(state, tracer, fn_state);
    }
    fn block_3530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3530_0: read-var gs#136048:u8
        let s_3530_0: bool = fn_state.gs_136048;
        // N s_3530_1: branch s_3530_0 b3765 b3531
        if s_3530_0 {
            return block_3765(state, tracer, fn_state);
        } else {
            return block_3531(state, tracer, fn_state);
        };
    }
    fn block_3531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3531_0: const #0u : u8
        let s_3531_0: bool = false;
        // D s_3531_1: write-var gs#136049 <= s_3531_0
        fn_state.gs_136049 = s_3531_0;
        // N s_3531_2: jump b3532
        return block_3532(state, tracer, fn_state);
    }
    fn block_3532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3532_0: read-var gs#136049:u8
        let s_3532_0: bool = fn_state.gs_136049;
        // N s_3532_1: branch s_3532_0 b3764 b3533
        if s_3532_0 {
            return block_3764(state, tracer, fn_state);
        } else {
            return block_3533(state, tracer, fn_state);
        };
    }
    fn block_3533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3533_0: const #0u : u8
        let s_3533_0: bool = false;
        // D s_3533_1: write-var gs#136050 <= s_3533_0
        fn_state.gs_136050 = s_3533_0;
        // N s_3533_2: jump b3534
        return block_3534(state, tracer, fn_state);
    }
    fn block_3534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3534_0: read-var gs#136050:u8
        let s_3534_0: bool = fn_state.gs_136050;
        // N s_3534_1: branch s_3534_0 b3763 b3535
        if s_3534_0 {
            return block_3763(state, tracer, fn_state);
        } else {
            return block_3535(state, tracer, fn_state);
        };
    }
    fn block_3535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3535_0: const #0u : u8
        let s_3535_0: bool = false;
        // D s_3535_1: write-var gs#136051 <= s_3535_0
        fn_state.gs_136051 = s_3535_0;
        // N s_3535_2: jump b3536
        return block_3536(state, tracer, fn_state);
    }
    fn block_3536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3536_0: read-var gs#136051:u8
        let s_3536_0: bool = fn_state.gs_136051;
        // N s_3536_1: branch s_3536_0 b3762 b3537
        if s_3536_0 {
            return block_3762(state, tracer, fn_state);
        } else {
            return block_3537(state, tracer, fn_state);
        };
    }
    fn block_3537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3537_0: read-var CRm:u8
        let s_3537_0: u8 = fn_state.CRm;
        // D s_3537_1: cast zx s_3537_0 -> bv
        let s_3537_1: Bits = Bits::new(s_3537_0 as u128, 4u16);
        // C s_3537_2: const #0u : u8
        let s_3537_2: u8 = 0;
        // C s_3537_3: cast zx s_3537_2 -> bv
        let s_3537_3: Bits = Bits::new(s_3537_2 as u128, 4u16);
        // D s_3537_4: cmp-eq s_3537_1 s_3537_3
        let s_3537_4: bool = ((s_3537_1) == (s_3537_3));
        // N s_3537_5: branch s_3537_4 b3761 b3538
        if s_3537_4 {
            return block_3761(state, tracer, fn_state);
        } else {
            return block_3538(state, tracer, fn_state);
        };
    }
    fn block_3538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3538_0: const #0u : u8
        let s_3538_0: bool = false;
        // D s_3538_1: write-var gs#136052 <= s_3538_0
        fn_state.gs_136052 = s_3538_0;
        // N s_3538_2: jump b3539
        return block_3539(state, tracer, fn_state);
    }
    fn block_3539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3539_0: read-var gs#136052:u8
        let s_3539_0: bool = fn_state.gs_136052;
        // N s_3539_1: branch s_3539_0 b3760 b3540
        if s_3539_0 {
            return block_3760(state, tracer, fn_state);
        } else {
            return block_3540(state, tracer, fn_state);
        };
    }
    fn block_3540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3540_0: const #0u : u8
        let s_3540_0: bool = false;
        // D s_3540_1: write-var gs#136053 <= s_3540_0
        fn_state.gs_136053 = s_3540_0;
        // N s_3540_2: jump b3541
        return block_3541(state, tracer, fn_state);
    }
    fn block_3541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3541_0: read-var gs#136053:u8
        let s_3541_0: bool = fn_state.gs_136053;
        // N s_3541_1: branch s_3541_0 b3759 b3542
        if s_3541_0 {
            return block_3759(state, tracer, fn_state);
        } else {
            return block_3542(state, tracer, fn_state);
        };
    }
    fn block_3542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3542_0: const #0u : u8
        let s_3542_0: bool = false;
        // D s_3542_1: write-var gs#136054 <= s_3542_0
        fn_state.gs_136054 = s_3542_0;
        // N s_3542_2: jump b3543
        return block_3543(state, tracer, fn_state);
    }
    fn block_3543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3543_0: read-var gs#136054:u8
        let s_3543_0: bool = fn_state.gs_136054;
        // N s_3543_1: branch s_3543_0 b3758 b3544
        if s_3543_0 {
            return block_3758(state, tracer, fn_state);
        } else {
            return block_3544(state, tracer, fn_state);
        };
    }
    fn block_3544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3544_0: const #0u : u8
        let s_3544_0: bool = false;
        // D s_3544_1: write-var gs#136055 <= s_3544_0
        fn_state.gs_136055 = s_3544_0;
        // N s_3544_2: jump b3545
        return block_3545(state, tracer, fn_state);
    }
    fn block_3545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3545_0: read-var gs#136055:u8
        let s_3545_0: bool = fn_state.gs_136055;
        // N s_3545_1: branch s_3545_0 b3757 b3546
        if s_3545_0 {
            return block_3757(state, tracer, fn_state);
        } else {
            return block_3546(state, tracer, fn_state);
        };
    }
    fn block_3546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3546_0: read-var CRm:u8
        let s_3546_0: u8 = fn_state.CRm;
        // D s_3546_1: cast zx s_3546_0 -> bv
        let s_3546_1: Bits = Bits::new(s_3546_0 as u128, 4u16);
        // C s_3546_2: const #7u : u8
        let s_3546_2: u8 = 7;
        // C s_3546_3: cast zx s_3546_2 -> bv
        let s_3546_3: Bits = Bits::new(s_3546_2 as u128, 4u16);
        // D s_3546_4: cmp-eq s_3546_1 s_3546_3
        let s_3546_4: bool = ((s_3546_1) == (s_3546_3));
        // N s_3546_5: branch s_3546_4 b3756 b3547
        if s_3546_4 {
            return block_3756(state, tracer, fn_state);
        } else {
            return block_3547(state, tracer, fn_state);
        };
    }
    fn block_3547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3547_0: const #0u : u8
        let s_3547_0: bool = false;
        // D s_3547_1: write-var gs#136056 <= s_3547_0
        fn_state.gs_136056 = s_3547_0;
        // N s_3547_2: jump b3548
        return block_3548(state, tracer, fn_state);
    }
    fn block_3548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3548_0: read-var gs#136056:u8
        let s_3548_0: bool = fn_state.gs_136056;
        // N s_3548_1: branch s_3548_0 b3755 b3549
        if s_3548_0 {
            return block_3755(state, tracer, fn_state);
        } else {
            return block_3549(state, tracer, fn_state);
        };
    }
    fn block_3549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3549_0: const #0u : u8
        let s_3549_0: bool = false;
        // D s_3549_1: write-var gs#136057 <= s_3549_0
        fn_state.gs_136057 = s_3549_0;
        // N s_3549_2: jump b3550
        return block_3550(state, tracer, fn_state);
    }
    fn block_3550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3550_0: read-var gs#136057:u8
        let s_3550_0: bool = fn_state.gs_136057;
        // N s_3550_1: branch s_3550_0 b3754 b3551
        if s_3550_0 {
            return block_3754(state, tracer, fn_state);
        } else {
            return block_3551(state, tracer, fn_state);
        };
    }
    fn block_3551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3551_0: const #0u : u8
        let s_3551_0: bool = false;
        // D s_3551_1: write-var gs#136058 <= s_3551_0
        fn_state.gs_136058 = s_3551_0;
        // N s_3551_2: jump b3552
        return block_3552(state, tracer, fn_state);
    }
    fn block_3552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3552_0: read-var gs#136058:u8
        let s_3552_0: bool = fn_state.gs_136058;
        // N s_3552_1: branch s_3552_0 b3753 b3553
        if s_3552_0 {
            return block_3753(state, tracer, fn_state);
        } else {
            return block_3553(state, tracer, fn_state);
        };
    }
    fn block_3553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3553_0: const #0u : u8
        let s_3553_0: bool = false;
        // D s_3553_1: write-var gs#136059 <= s_3553_0
        fn_state.gs_136059 = s_3553_0;
        // N s_3553_2: jump b3554
        return block_3554(state, tracer, fn_state);
    }
    fn block_3554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3554_0: read-var gs#136059:u8
        let s_3554_0: bool = fn_state.gs_136059;
        // N s_3554_1: branch s_3554_0 b3752 b3555
        if s_3554_0 {
            return block_3752(state, tracer, fn_state);
        } else {
            return block_3555(state, tracer, fn_state);
        };
    }
    fn block_3555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3555_0: read-var CRm:u8
        let s_3555_0: u8 = fn_state.CRm;
        // D s_3555_1: cast zx s_3555_0 -> bv
        let s_3555_1: Bits = Bits::new(s_3555_0 as u128, 4u16);
        // C s_3555_2: const #10u : u8
        let s_3555_2: u8 = 10;
        // C s_3555_3: cast zx s_3555_2 -> bv
        let s_3555_3: Bits = Bits::new(s_3555_2 as u128, 4u16);
        // D s_3555_4: cmp-eq s_3555_1 s_3555_3
        let s_3555_4: bool = ((s_3555_1) == (s_3555_3));
        // N s_3555_5: branch s_3555_4 b3751 b3556
        if s_3555_4 {
            return block_3751(state, tracer, fn_state);
        } else {
            return block_3556(state, tracer, fn_state);
        };
    }
    fn block_3556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3556_0: const #0u : u8
        let s_3556_0: bool = false;
        // D s_3556_1: write-var gs#136060 <= s_3556_0
        fn_state.gs_136060 = s_3556_0;
        // N s_3556_2: jump b3557
        return block_3557(state, tracer, fn_state);
    }
    fn block_3557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3557_0: read-var gs#136060:u8
        let s_3557_0: bool = fn_state.gs_136060;
        // N s_3557_1: branch s_3557_0 b3750 b3558
        if s_3557_0 {
            return block_3750(state, tracer, fn_state);
        } else {
            return block_3558(state, tracer, fn_state);
        };
    }
    fn block_3558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3558_0: const #0u : u8
        let s_3558_0: bool = false;
        // D s_3558_1: write-var gs#136061 <= s_3558_0
        fn_state.gs_136061 = s_3558_0;
        // N s_3558_2: jump b3559
        return block_3559(state, tracer, fn_state);
    }
    fn block_3559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3559_0: read-var gs#136061:u8
        let s_3559_0: bool = fn_state.gs_136061;
        // N s_3559_1: branch s_3559_0 b3749 b3560
        if s_3559_0 {
            return block_3749(state, tracer, fn_state);
        } else {
            return block_3560(state, tracer, fn_state);
        };
    }
    fn block_3560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3560_0: const #0u : u8
        let s_3560_0: bool = false;
        // D s_3560_1: write-var gs#136062 <= s_3560_0
        fn_state.gs_136062 = s_3560_0;
        // N s_3560_2: jump b3561
        return block_3561(state, tracer, fn_state);
    }
    fn block_3561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3561_0: read-var gs#136062:u8
        let s_3561_0: bool = fn_state.gs_136062;
        // N s_3561_1: branch s_3561_0 b3748 b3562
        if s_3561_0 {
            return block_3748(state, tracer, fn_state);
        } else {
            return block_3562(state, tracer, fn_state);
        };
    }
    fn block_3562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3562_0: const #0u : u8
        let s_3562_0: bool = false;
        // D s_3562_1: write-var gs#136063 <= s_3562_0
        fn_state.gs_136063 = s_3562_0;
        // N s_3562_2: jump b3563
        return block_3563(state, tracer, fn_state);
    }
    fn block_3563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3563_0: read-var gs#136063:u8
        let s_3563_0: bool = fn_state.gs_136063;
        // N s_3563_1: branch s_3563_0 b3747 b3564
        if s_3563_0 {
            return block_3747(state, tracer, fn_state);
        } else {
            return block_3564(state, tracer, fn_state);
        };
    }
    fn block_3564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3564_0: read-var CRm:u8
        let s_3564_0: u8 = fn_state.CRm;
        // D s_3564_1: cast zx s_3564_0 -> bv
        let s_3564_1: Bits = Bits::new(s_3564_0 as u128, 4u16);
        // C s_3564_2: const #3u : u8
        let s_3564_2: u8 = 3;
        // C s_3564_3: cast zx s_3564_2 -> bv
        let s_3564_3: Bits = Bits::new(s_3564_2 as u128, 4u16);
        // D s_3564_4: cmp-eq s_3564_1 s_3564_3
        let s_3564_4: bool = ((s_3564_1) == (s_3564_3));
        // N s_3564_5: branch s_3564_4 b3746 b3565
        if s_3564_4 {
            return block_3746(state, tracer, fn_state);
        } else {
            return block_3565(state, tracer, fn_state);
        };
    }
    fn block_3565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3565_0: const #0u : u8
        let s_3565_0: bool = false;
        // D s_3565_1: write-var gs#136064 <= s_3565_0
        fn_state.gs_136064 = s_3565_0;
        // N s_3565_2: jump b3566
        return block_3566(state, tracer, fn_state);
    }
    fn block_3566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3566_0: read-var gs#136064:u8
        let s_3566_0: bool = fn_state.gs_136064;
        // N s_3566_1: branch s_3566_0 b3745 b3567
        if s_3566_0 {
            return block_3745(state, tracer, fn_state);
        } else {
            return block_3567(state, tracer, fn_state);
        };
    }
    fn block_3567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3567_0: const #0u : u8
        let s_3567_0: bool = false;
        // D s_3567_1: write-var gs#136065 <= s_3567_0
        fn_state.gs_136065 = s_3567_0;
        // N s_3567_2: jump b3568
        return block_3568(state, tracer, fn_state);
    }
    fn block_3568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3568_0: read-var gs#136065:u8
        let s_3568_0: bool = fn_state.gs_136065;
        // N s_3568_1: branch s_3568_0 b3744 b3569
        if s_3568_0 {
            return block_3744(state, tracer, fn_state);
        } else {
            return block_3569(state, tracer, fn_state);
        };
    }
    fn block_3569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3569_0: const #0u : u8
        let s_3569_0: bool = false;
        // D s_3569_1: write-var gs#136066 <= s_3569_0
        fn_state.gs_136066 = s_3569_0;
        // N s_3569_2: jump b3570
        return block_3570(state, tracer, fn_state);
    }
    fn block_3570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3570_0: read-var gs#136066:u8
        let s_3570_0: bool = fn_state.gs_136066;
        // N s_3570_1: branch s_3570_0 b3743 b3571
        if s_3570_0 {
            return block_3743(state, tracer, fn_state);
        } else {
            return block_3571(state, tracer, fn_state);
        };
    }
    fn block_3571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3571_0: const #0u : u8
        let s_3571_0: bool = false;
        // D s_3571_1: write-var gs#136067 <= s_3571_0
        fn_state.gs_136067 = s_3571_0;
        // N s_3571_2: jump b3572
        return block_3572(state, tracer, fn_state);
    }
    fn block_3572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3572_0: read-var gs#136067:u8
        let s_3572_0: bool = fn_state.gs_136067;
        // N s_3572_1: branch s_3572_0 b3742 b3573
        if s_3572_0 {
            return block_3742(state, tracer, fn_state);
        } else {
            return block_3573(state, tracer, fn_state);
        };
    }
    fn block_3573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3573_0: read-var CRm:u8
        let s_3573_0: u8 = fn_state.CRm;
        // D s_3573_1: cast zx s_3573_0 -> bv
        let s_3573_1: Bits = Bits::new(s_3573_0 as u128, 4u16);
        // C s_3573_2: const #3u : u8
        let s_3573_2: u8 = 3;
        // C s_3573_3: cast zx s_3573_2 -> bv
        let s_3573_3: Bits = Bits::new(s_3573_2 as u128, 4u16);
        // D s_3573_4: cmp-eq s_3573_1 s_3573_3
        let s_3573_4: bool = ((s_3573_1) == (s_3573_3));
        // N s_3573_5: branch s_3573_4 b3741 b3574
        if s_3573_4 {
            return block_3741(state, tracer, fn_state);
        } else {
            return block_3574(state, tracer, fn_state);
        };
    }
    fn block_3574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3574_0: const #0u : u8
        let s_3574_0: bool = false;
        // D s_3574_1: write-var gs#136068 <= s_3574_0
        fn_state.gs_136068 = s_3574_0;
        // N s_3574_2: jump b3575
        return block_3575(state, tracer, fn_state);
    }
    fn block_3575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3575_0: read-var gs#136068:u8
        let s_3575_0: bool = fn_state.gs_136068;
        // N s_3575_1: branch s_3575_0 b3740 b3576
        if s_3575_0 {
            return block_3740(state, tracer, fn_state);
        } else {
            return block_3576(state, tracer, fn_state);
        };
    }
    fn block_3576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3576_0: const #0u : u8
        let s_3576_0: bool = false;
        // D s_3576_1: write-var gs#136069 <= s_3576_0
        fn_state.gs_136069 = s_3576_0;
        // N s_3576_2: jump b3577
        return block_3577(state, tracer, fn_state);
    }
    fn block_3577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3577_0: read-var gs#136069:u8
        let s_3577_0: bool = fn_state.gs_136069;
        // N s_3577_1: branch s_3577_0 b3739 b3578
        if s_3577_0 {
            return block_3739(state, tracer, fn_state);
        } else {
            return block_3578(state, tracer, fn_state);
        };
    }
    fn block_3578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3578_0: const #0u : u8
        let s_3578_0: bool = false;
        // D s_3578_1: write-var gs#136070 <= s_3578_0
        fn_state.gs_136070 = s_3578_0;
        // N s_3578_2: jump b3579
        return block_3579(state, tracer, fn_state);
    }
    fn block_3579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3579_0: read-var gs#136070:u8
        let s_3579_0: bool = fn_state.gs_136070;
        // N s_3579_1: branch s_3579_0 b3738 b3580
        if s_3579_0 {
            return block_3738(state, tracer, fn_state);
        } else {
            return block_3580(state, tracer, fn_state);
        };
    }
    fn block_3580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3580_0: const #0u : u8
        let s_3580_0: bool = false;
        // D s_3580_1: write-var gs#136071 <= s_3580_0
        fn_state.gs_136071 = s_3580_0;
        // N s_3580_2: jump b3581
        return block_3581(state, tracer, fn_state);
    }
    fn block_3581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3581_0: read-var gs#136071:u8
        let s_3581_0: bool = fn_state.gs_136071;
        // N s_3581_1: branch s_3581_0 b3737 b3582
        if s_3581_0 {
            return block_3737(state, tracer, fn_state);
        } else {
            return block_3582(state, tracer, fn_state);
        };
    }
    fn block_3582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3582_0: read-var CRm:u8
        let s_3582_0: u8 = fn_state.CRm;
        // D s_3582_1: cast zx s_3582_0 -> bv
        let s_3582_1: Bits = Bits::new(s_3582_0 as u128, 4u16);
        // C s_3582_2: const #7u : u8
        let s_3582_2: u8 = 7;
        // C s_3582_3: cast zx s_3582_2 -> bv
        let s_3582_3: Bits = Bits::new(s_3582_2 as u128, 4u16);
        // D s_3582_4: cmp-eq s_3582_1 s_3582_3
        let s_3582_4: bool = ((s_3582_1) == (s_3582_3));
        // N s_3582_5: branch s_3582_4 b3736 b3583
        if s_3582_4 {
            return block_3736(state, tracer, fn_state);
        } else {
            return block_3583(state, tracer, fn_state);
        };
    }
    fn block_3583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3583_0: const #0u : u8
        let s_3583_0: bool = false;
        // D s_3583_1: write-var gs#136072 <= s_3583_0
        fn_state.gs_136072 = s_3583_0;
        // N s_3583_2: jump b3584
        return block_3584(state, tracer, fn_state);
    }
    fn block_3584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3584_0: read-var gs#136072:u8
        let s_3584_0: bool = fn_state.gs_136072;
        // N s_3584_1: branch s_3584_0 b3735 b3585
        if s_3584_0 {
            return block_3735(state, tracer, fn_state);
        } else {
            return block_3585(state, tracer, fn_state);
        };
    }
    fn block_3585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3585_0: const #0u : u8
        let s_3585_0: bool = false;
        // D s_3585_1: write-var gs#136073 <= s_3585_0
        fn_state.gs_136073 = s_3585_0;
        // N s_3585_2: jump b3586
        return block_3586(state, tracer, fn_state);
    }
    fn block_3586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3586_0: read-var gs#136073:u8
        let s_3586_0: bool = fn_state.gs_136073;
        // N s_3586_1: branch s_3586_0 b3734 b3587
        if s_3586_0 {
            return block_3734(state, tracer, fn_state);
        } else {
            return block_3587(state, tracer, fn_state);
        };
    }
    fn block_3587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3587_0: const #0u : u8
        let s_3587_0: bool = false;
        // D s_3587_1: write-var gs#136074 <= s_3587_0
        fn_state.gs_136074 = s_3587_0;
        // N s_3587_2: jump b3588
        return block_3588(state, tracer, fn_state);
    }
    fn block_3588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3588_0: read-var gs#136074:u8
        let s_3588_0: bool = fn_state.gs_136074;
        // N s_3588_1: branch s_3588_0 b3733 b3589
        if s_3588_0 {
            return block_3733(state, tracer, fn_state);
        } else {
            return block_3589(state, tracer, fn_state);
        };
    }
    fn block_3589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3589_0: const #0u : u8
        let s_3589_0: bool = false;
        // D s_3589_1: write-var gs#136075 <= s_3589_0
        fn_state.gs_136075 = s_3589_0;
        // N s_3589_2: jump b3590
        return block_3590(state, tracer, fn_state);
    }
    fn block_3590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3590_0: read-var gs#136075:u8
        let s_3590_0: bool = fn_state.gs_136075;
        // N s_3590_1: branch s_3590_0 b3732 b3591
        if s_3590_0 {
            return block_3732(state, tracer, fn_state);
        } else {
            return block_3591(state, tracer, fn_state);
        };
    }
    fn block_3591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3591_0: read-var CRm:u8
        let s_3591_0: u8 = fn_state.CRm;
        // D s_3591_1: cast zx s_3591_0 -> bv
        let s_3591_1: Bits = Bits::new(s_3591_0 as u128, 4u16);
        // C s_3591_2: const #7u : u8
        let s_3591_2: u8 = 7;
        // C s_3591_3: cast zx s_3591_2 -> bv
        let s_3591_3: Bits = Bits::new(s_3591_2 as u128, 4u16);
        // D s_3591_4: cmp-eq s_3591_1 s_3591_3
        let s_3591_4: bool = ((s_3591_1) == (s_3591_3));
        // N s_3591_5: branch s_3591_4 b3731 b3592
        if s_3591_4 {
            return block_3731(state, tracer, fn_state);
        } else {
            return block_3592(state, tracer, fn_state);
        };
    }
    fn block_3592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3592_0: const #0u : u8
        let s_3592_0: bool = false;
        // D s_3592_1: write-var gs#136076 <= s_3592_0
        fn_state.gs_136076 = s_3592_0;
        // N s_3592_2: jump b3593
        return block_3593(state, tracer, fn_state);
    }
    fn block_3593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3593_0: read-var gs#136076:u8
        let s_3593_0: bool = fn_state.gs_136076;
        // N s_3593_1: branch s_3593_0 b3730 b3594
        if s_3593_0 {
            return block_3730(state, tracer, fn_state);
        } else {
            return block_3594(state, tracer, fn_state);
        };
    }
    fn block_3594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3594_0: const #0u : u8
        let s_3594_0: bool = false;
        // D s_3594_1: write-var gs#136077 <= s_3594_0
        fn_state.gs_136077 = s_3594_0;
        // N s_3594_2: jump b3595
        return block_3595(state, tracer, fn_state);
    }
    fn block_3595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3595_0: read-var gs#136077:u8
        let s_3595_0: bool = fn_state.gs_136077;
        // N s_3595_1: branch s_3595_0 b3729 b3596
        if s_3595_0 {
            return block_3729(state, tracer, fn_state);
        } else {
            return block_3596(state, tracer, fn_state);
        };
    }
    fn block_3596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3596_0: const #0u : u8
        let s_3596_0: bool = false;
        // D s_3596_1: write-var gs#136078 <= s_3596_0
        fn_state.gs_136078 = s_3596_0;
        // N s_3596_2: jump b3597
        return block_3597(state, tracer, fn_state);
    }
    fn block_3597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3597_0: read-var gs#136078:u8
        let s_3597_0: bool = fn_state.gs_136078;
        // N s_3597_1: branch s_3597_0 b3728 b3598
        if s_3597_0 {
            return block_3728(state, tracer, fn_state);
        } else {
            return block_3598(state, tracer, fn_state);
        };
    }
    fn block_3598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3598_0: const #0u : u8
        let s_3598_0: bool = false;
        // D s_3598_1: write-var gs#136079 <= s_3598_0
        fn_state.gs_136079 = s_3598_0;
        // N s_3598_2: jump b3599
        return block_3599(state, tracer, fn_state);
    }
    fn block_3599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3599_0: read-var gs#136079:u8
        let s_3599_0: bool = fn_state.gs_136079;
        // N s_3599_1: branch s_3599_0 b3727 b3600
        if s_3599_0 {
            return block_3727(state, tracer, fn_state);
        } else {
            return block_3600(state, tracer, fn_state);
        };
    }
    fn block_3600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3600_0: read-var CRm:u8
        let s_3600_0: u8 = fn_state.CRm;
        // D s_3600_1: cast zx s_3600_0 -> bv
        let s_3600_1: Bits = Bits::new(s_3600_0 as u128, 4u16);
        // C s_3600_2: const #5u : u8
        let s_3600_2: u8 = 5;
        // C s_3600_3: cast zx s_3600_2 -> bv
        let s_3600_3: Bits = Bits::new(s_3600_2 as u128, 4u16);
        // D s_3600_4: cmp-eq s_3600_1 s_3600_3
        let s_3600_4: bool = ((s_3600_1) == (s_3600_3));
        // N s_3600_5: branch s_3600_4 b3726 b3601
        if s_3600_4 {
            return block_3726(state, tracer, fn_state);
        } else {
            return block_3601(state, tracer, fn_state);
        };
    }
    fn block_3601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3601_0: const #0u : u8
        let s_3601_0: bool = false;
        // D s_3601_1: write-var gs#136080 <= s_3601_0
        fn_state.gs_136080 = s_3601_0;
        // N s_3601_2: jump b3602
        return block_3602(state, tracer, fn_state);
    }
    fn block_3602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3602_0: read-var gs#136080:u8
        let s_3602_0: bool = fn_state.gs_136080;
        // N s_3602_1: branch s_3602_0 b3725 b3603
        if s_3602_0 {
            return block_3725(state, tracer, fn_state);
        } else {
            return block_3603(state, tracer, fn_state);
        };
    }
    fn block_3603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3603_0: const #0u : u8
        let s_3603_0: bool = false;
        // D s_3603_1: write-var gs#136081 <= s_3603_0
        fn_state.gs_136081 = s_3603_0;
        // N s_3603_2: jump b3604
        return block_3604(state, tracer, fn_state);
    }
    fn block_3604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3604_0: read-var gs#136081:u8
        let s_3604_0: bool = fn_state.gs_136081;
        // N s_3604_1: branch s_3604_0 b3724 b3605
        if s_3604_0 {
            return block_3724(state, tracer, fn_state);
        } else {
            return block_3605(state, tracer, fn_state);
        };
    }
    fn block_3605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3605_0: const #0u : u8
        let s_3605_0: bool = false;
        // D s_3605_1: write-var gs#136082 <= s_3605_0
        fn_state.gs_136082 = s_3605_0;
        // N s_3605_2: jump b3606
        return block_3606(state, tracer, fn_state);
    }
    fn block_3606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3606_0: read-var gs#136082:u8
        let s_3606_0: bool = fn_state.gs_136082;
        // N s_3606_1: branch s_3606_0 b3723 b3607
        if s_3606_0 {
            return block_3723(state, tracer, fn_state);
        } else {
            return block_3607(state, tracer, fn_state);
        };
    }
    fn block_3607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3607_0: const #0u : u8
        let s_3607_0: bool = false;
        // D s_3607_1: write-var gs#136083 <= s_3607_0
        fn_state.gs_136083 = s_3607_0;
        // N s_3607_2: jump b3608
        return block_3608(state, tracer, fn_state);
    }
    fn block_3608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3608_0: read-var gs#136083:u8
        let s_3608_0: bool = fn_state.gs_136083;
        // N s_3608_1: branch s_3608_0 b3722 b3609
        if s_3608_0 {
            return block_3722(state, tracer, fn_state);
        } else {
            return block_3609(state, tracer, fn_state);
        };
    }
    fn block_3609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3609_0: read-var CRm:u8
        let s_3609_0: u8 = fn_state.CRm;
        // D s_3609_1: cast zx s_3609_0 -> bv
        let s_3609_1: Bits = Bits::new(s_3609_0 as u128, 4u16);
        // C s_3609_2: const #5u : u8
        let s_3609_2: u8 = 5;
        // C s_3609_3: cast zx s_3609_2 -> bv
        let s_3609_3: Bits = Bits::new(s_3609_2 as u128, 4u16);
        // D s_3609_4: cmp-eq s_3609_1 s_3609_3
        let s_3609_4: bool = ((s_3609_1) == (s_3609_3));
        // N s_3609_5: branch s_3609_4 b3721 b3610
        if s_3609_4 {
            return block_3721(state, tracer, fn_state);
        } else {
            return block_3610(state, tracer, fn_state);
        };
    }
    fn block_3610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3610_0: const #0u : u8
        let s_3610_0: bool = false;
        // D s_3610_1: write-var gs#136084 <= s_3610_0
        fn_state.gs_136084 = s_3610_0;
        // N s_3610_2: jump b3611
        return block_3611(state, tracer, fn_state);
    }
    fn block_3611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3611_0: read-var gs#136084:u8
        let s_3611_0: bool = fn_state.gs_136084;
        // N s_3611_1: branch s_3611_0 b3720 b3612
        if s_3611_0 {
            return block_3720(state, tracer, fn_state);
        } else {
            return block_3612(state, tracer, fn_state);
        };
    }
    fn block_3612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3612_0: const #0u : u8
        let s_3612_0: bool = false;
        // D s_3612_1: write-var gs#136085 <= s_3612_0
        fn_state.gs_136085 = s_3612_0;
        // N s_3612_2: jump b3613
        return block_3613(state, tracer, fn_state);
    }
    fn block_3613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3613_0: read-var gs#136085:u8
        let s_3613_0: bool = fn_state.gs_136085;
        // N s_3613_1: branch s_3613_0 b3719 b3614
        if s_3613_0 {
            return block_3719(state, tracer, fn_state);
        } else {
            return block_3614(state, tracer, fn_state);
        };
    }
    fn block_3614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3614_0: const #0u : u8
        let s_3614_0: bool = false;
        // D s_3614_1: write-var gs#136086 <= s_3614_0
        fn_state.gs_136086 = s_3614_0;
        // N s_3614_2: jump b3615
        return block_3615(state, tracer, fn_state);
    }
    fn block_3615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3615_0: read-var gs#136086:u8
        let s_3615_0: bool = fn_state.gs_136086;
        // N s_3615_1: branch s_3615_0 b3718 b3616
        if s_3615_0 {
            return block_3718(state, tracer, fn_state);
        } else {
            return block_3616(state, tracer, fn_state);
        };
    }
    fn block_3616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3616_0: const #0u : u8
        let s_3616_0: bool = false;
        // D s_3616_1: write-var gs#136087 <= s_3616_0
        fn_state.gs_136087 = s_3616_0;
        // N s_3616_2: jump b3617
        return block_3617(state, tracer, fn_state);
    }
    fn block_3617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3617_0: read-var gs#136087:u8
        let s_3617_0: bool = fn_state.gs_136087;
        // N s_3617_1: branch s_3617_0 b3717 b3618
        if s_3617_0 {
            return block_3717(state, tracer, fn_state);
        } else {
            return block_3618(state, tracer, fn_state);
        };
    }
    fn block_3618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3618_0: read-var CRm:u8
        let s_3618_0: u8 = fn_state.CRm;
        // D s_3618_1: cast zx s_3618_0 -> bv
        let s_3618_1: Bits = Bits::new(s_3618_0 as u128, 4u16);
        // C s_3618_2: const #6u : u8
        let s_3618_2: u8 = 6;
        // C s_3618_3: cast zx s_3618_2 -> bv
        let s_3618_3: Bits = Bits::new(s_3618_2 as u128, 4u16);
        // D s_3618_4: cmp-eq s_3618_1 s_3618_3
        let s_3618_4: bool = ((s_3618_1) == (s_3618_3));
        // N s_3618_5: branch s_3618_4 b3716 b3619
        if s_3618_4 {
            return block_3716(state, tracer, fn_state);
        } else {
            return block_3619(state, tracer, fn_state);
        };
    }
    fn block_3619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3619_0: const #0u : u8
        let s_3619_0: bool = false;
        // D s_3619_1: write-var gs#136088 <= s_3619_0
        fn_state.gs_136088 = s_3619_0;
        // N s_3619_2: jump b3620
        return block_3620(state, tracer, fn_state);
    }
    fn block_3620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3620_0: read-var gs#136088:u8
        let s_3620_0: bool = fn_state.gs_136088;
        // N s_3620_1: branch s_3620_0 b3715 b3621
        if s_3620_0 {
            return block_3715(state, tracer, fn_state);
        } else {
            return block_3621(state, tracer, fn_state);
        };
    }
    fn block_3621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3621_0: const #0u : u8
        let s_3621_0: bool = false;
        // D s_3621_1: write-var gs#136089 <= s_3621_0
        fn_state.gs_136089 = s_3621_0;
        // N s_3621_2: jump b3622
        return block_3622(state, tracer, fn_state);
    }
    fn block_3622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3622_0: read-var gs#136089:u8
        let s_3622_0: bool = fn_state.gs_136089;
        // N s_3622_1: branch s_3622_0 b3714 b3623
        if s_3622_0 {
            return block_3714(state, tracer, fn_state);
        } else {
            return block_3623(state, tracer, fn_state);
        };
    }
    fn block_3623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3623_0: const #0u : u8
        let s_3623_0: bool = false;
        // D s_3623_1: write-var gs#136090 <= s_3623_0
        fn_state.gs_136090 = s_3623_0;
        // N s_3623_2: jump b3624
        return block_3624(state, tracer, fn_state);
    }
    fn block_3624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3624_0: read-var gs#136090:u8
        let s_3624_0: bool = fn_state.gs_136090;
        // N s_3624_1: branch s_3624_0 b3713 b3625
        if s_3624_0 {
            return block_3713(state, tracer, fn_state);
        } else {
            return block_3625(state, tracer, fn_state);
        };
    }
    fn block_3625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3625_0: const #0u : u8
        let s_3625_0: bool = false;
        // D s_3625_1: write-var gs#136091 <= s_3625_0
        fn_state.gs_136091 = s_3625_0;
        // N s_3625_2: jump b3626
        return block_3626(state, tracer, fn_state);
    }
    fn block_3626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3626_0: read-var gs#136091:u8
        let s_3626_0: bool = fn_state.gs_136091;
        // N s_3626_1: branch s_3626_0 b3712 b3627
        if s_3626_0 {
            return block_3712(state, tracer, fn_state);
        } else {
            return block_3627(state, tracer, fn_state);
        };
    }
    fn block_3627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3627_0: read-var CRm:u8
        let s_3627_0: u8 = fn_state.CRm;
        // D s_3627_1: cast zx s_3627_0 -> bv
        let s_3627_1: Bits = Bits::new(s_3627_0 as u128, 4u16);
        // C s_3627_2: const #5u : u8
        let s_3627_2: u8 = 5;
        // C s_3627_3: cast zx s_3627_2 -> bv
        let s_3627_3: Bits = Bits::new(s_3627_2 as u128, 4u16);
        // D s_3627_4: cmp-eq s_3627_1 s_3627_3
        let s_3627_4: bool = ((s_3627_1) == (s_3627_3));
        // N s_3627_5: branch s_3627_4 b3711 b3628
        if s_3627_4 {
            return block_3711(state, tracer, fn_state);
        } else {
            return block_3628(state, tracer, fn_state);
        };
    }
    fn block_3628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3628_0: const #0u : u8
        let s_3628_0: bool = false;
        // D s_3628_1: write-var gs#136092 <= s_3628_0
        fn_state.gs_136092 = s_3628_0;
        // N s_3628_2: jump b3629
        return block_3629(state, tracer, fn_state);
    }
    fn block_3629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3629_0: read-var gs#136092:u8
        let s_3629_0: bool = fn_state.gs_136092;
        // N s_3629_1: branch s_3629_0 b3710 b3630
        if s_3629_0 {
            return block_3710(state, tracer, fn_state);
        } else {
            return block_3630(state, tracer, fn_state);
        };
    }
    fn block_3630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3630_0: const #0u : u8
        let s_3630_0: bool = false;
        // D s_3630_1: write-var gs#136093 <= s_3630_0
        fn_state.gs_136093 = s_3630_0;
        // N s_3630_2: jump b3631
        return block_3631(state, tracer, fn_state);
    }
    fn block_3631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3631_0: read-var gs#136093:u8
        let s_3631_0: bool = fn_state.gs_136093;
        // N s_3631_1: branch s_3631_0 b3709 b3632
        if s_3631_0 {
            return block_3709(state, tracer, fn_state);
        } else {
            return block_3632(state, tracer, fn_state);
        };
    }
    fn block_3632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3632_0: const #0u : u8
        let s_3632_0: bool = false;
        // D s_3632_1: write-var gs#136094 <= s_3632_0
        fn_state.gs_136094 = s_3632_0;
        // N s_3632_2: jump b3633
        return block_3633(state, tracer, fn_state);
    }
    fn block_3633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3633_0: read-var gs#136094:u8
        let s_3633_0: bool = fn_state.gs_136094;
        // N s_3633_1: branch s_3633_0 b3708 b3634
        if s_3633_0 {
            return block_3708(state, tracer, fn_state);
        } else {
            return block_3634(state, tracer, fn_state);
        };
    }
    fn block_3634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3634_0: const #0u : u8
        let s_3634_0: bool = false;
        // D s_3634_1: write-var gs#136095 <= s_3634_0
        fn_state.gs_136095 = s_3634_0;
        // N s_3634_2: jump b3635
        return block_3635(state, tracer, fn_state);
    }
    fn block_3635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3635_0: read-var gs#136095:u8
        let s_3635_0: bool = fn_state.gs_136095;
        // N s_3635_1: branch s_3635_0 b3707 b3636
        if s_3635_0 {
            return block_3707(state, tracer, fn_state);
        } else {
            return block_3636(state, tracer, fn_state);
        };
    }
    fn block_3636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3636_0: read-var CRm:u8
        let s_3636_0: u8 = fn_state.CRm;
        // D s_3636_1: cast zx s_3636_0 -> bv
        let s_3636_1: Bits = Bits::new(s_3636_0 as u128, 4u16);
        // C s_3636_2: const #1u : u8
        let s_3636_2: u8 = 1;
        // C s_3636_3: cast zx s_3636_2 -> bv
        let s_3636_3: Bits = Bits::new(s_3636_2 as u128, 4u16);
        // D s_3636_4: cmp-eq s_3636_1 s_3636_3
        let s_3636_4: bool = ((s_3636_1) == (s_3636_3));
        // N s_3636_5: branch s_3636_4 b3706 b3637
        if s_3636_4 {
            return block_3706(state, tracer, fn_state);
        } else {
            return block_3637(state, tracer, fn_state);
        };
    }
    fn block_3637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3637_0: const #0u : u8
        let s_3637_0: bool = false;
        // D s_3637_1: write-var gs#136096 <= s_3637_0
        fn_state.gs_136096 = s_3637_0;
        // N s_3637_2: jump b3638
        return block_3638(state, tracer, fn_state);
    }
    fn block_3638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3638_0: read-var gs#136096:u8
        let s_3638_0: bool = fn_state.gs_136096;
        // N s_3638_1: branch s_3638_0 b3705 b3639
        if s_3638_0 {
            return block_3705(state, tracer, fn_state);
        } else {
            return block_3639(state, tracer, fn_state);
        };
    }
    fn block_3639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3639_0: const #0u : u8
        let s_3639_0: bool = false;
        // D s_3639_1: write-var gs#136097 <= s_3639_0
        fn_state.gs_136097 = s_3639_0;
        // N s_3639_2: jump b3640
        return block_3640(state, tracer, fn_state);
    }
    fn block_3640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3640_0: read-var gs#136097:u8
        let s_3640_0: bool = fn_state.gs_136097;
        // N s_3640_1: branch s_3640_0 b3704 b3641
        if s_3640_0 {
            return block_3704(state, tracer, fn_state);
        } else {
            return block_3641(state, tracer, fn_state);
        };
    }
    fn block_3641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3641_0: const #0u : u8
        let s_3641_0: bool = false;
        // D s_3641_1: write-var gs#136098 <= s_3641_0
        fn_state.gs_136098 = s_3641_0;
        // N s_3641_2: jump b3642
        return block_3642(state, tracer, fn_state);
    }
    fn block_3642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3642_0: read-var gs#136098:u8
        let s_3642_0: bool = fn_state.gs_136098;
        // N s_3642_1: branch s_3642_0 b3703 b3643
        if s_3642_0 {
            return block_3703(state, tracer, fn_state);
        } else {
            return block_3643(state, tracer, fn_state);
        };
    }
    fn block_3643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3643_0: const #0u : u8
        let s_3643_0: bool = false;
        // D s_3643_1: write-var gs#136099 <= s_3643_0
        fn_state.gs_136099 = s_3643_0;
        // N s_3643_2: jump b3644
        return block_3644(state, tracer, fn_state);
    }
    fn block_3644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3644_0: read-var gs#136099:u8
        let s_3644_0: bool = fn_state.gs_136099;
        // N s_3644_1: branch s_3644_0 b3702 b3645
        if s_3644_0 {
            return block_3702(state, tracer, fn_state);
        } else {
            return block_3645(state, tracer, fn_state);
        };
    }
    fn block_3645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3645_0: read-var CRm:u8
        let s_3645_0: u8 = fn_state.CRm;
        // D s_3645_1: cast zx s_3645_0 -> bv
        let s_3645_1: Bits = Bits::new(s_3645_0 as u128, 4u16);
        // C s_3645_2: const #3u : u8
        let s_3645_2: u8 = 3;
        // C s_3645_3: cast zx s_3645_2 -> bv
        let s_3645_3: Bits = Bits::new(s_3645_2 as u128, 4u16);
        // D s_3645_4: cmp-eq s_3645_1 s_3645_3
        let s_3645_4: bool = ((s_3645_1) == (s_3645_3));
        // N s_3645_5: branch s_3645_4 b3701 b3646
        if s_3645_4 {
            return block_3701(state, tracer, fn_state);
        } else {
            return block_3646(state, tracer, fn_state);
        };
    }
    fn block_3646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3646_0: const #0u : u8
        let s_3646_0: bool = false;
        // D s_3646_1: write-var gs#136100 <= s_3646_0
        fn_state.gs_136100 = s_3646_0;
        // N s_3646_2: jump b3647
        return block_3647(state, tracer, fn_state);
    }
    fn block_3647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3647_0: read-var gs#136100:u8
        let s_3647_0: bool = fn_state.gs_136100;
        // N s_3647_1: branch s_3647_0 b3700 b3648
        if s_3647_0 {
            return block_3700(state, tracer, fn_state);
        } else {
            return block_3648(state, tracer, fn_state);
        };
    }
    fn block_3648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3648_0: const #0u : u8
        let s_3648_0: bool = false;
        // D s_3648_1: write-var gs#136101 <= s_3648_0
        fn_state.gs_136101 = s_3648_0;
        // N s_3648_2: jump b3649
        return block_3649(state, tracer, fn_state);
    }
    fn block_3649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3649_0: read-var gs#136101:u8
        let s_3649_0: bool = fn_state.gs_136101;
        // N s_3649_1: branch s_3649_0 b3699 b3650
        if s_3649_0 {
            return block_3699(state, tracer, fn_state);
        } else {
            return block_3650(state, tracer, fn_state);
        };
    }
    fn block_3650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3650_0: const #0u : u8
        let s_3650_0: bool = false;
        // D s_3650_1: write-var gs#136102 <= s_3650_0
        fn_state.gs_136102 = s_3650_0;
        // N s_3650_2: jump b3651
        return block_3651(state, tracer, fn_state);
    }
    fn block_3651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3651_0: read-var gs#136102:u8
        let s_3651_0: bool = fn_state.gs_136102;
        // N s_3651_1: branch s_3651_0 b3698 b3652
        if s_3651_0 {
            return block_3698(state, tracer, fn_state);
        } else {
            return block_3652(state, tracer, fn_state);
        };
    }
    fn block_3652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3652_0: const #0u : u8
        let s_3652_0: bool = false;
        // D s_3652_1: write-var gs#136103 <= s_3652_0
        fn_state.gs_136103 = s_3652_0;
        // N s_3652_2: jump b3653
        return block_3653(state, tracer, fn_state);
    }
    fn block_3653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3653_0: read-var gs#136103:u8
        let s_3653_0: bool = fn_state.gs_136103;
        // N s_3653_1: branch s_3653_0 b3697 b3654
        if s_3653_0 {
            return block_3697(state, tracer, fn_state);
        } else {
            return block_3654(state, tracer, fn_state);
        };
    }
    fn block_3654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3654_0: read-var CRm:u8
        let s_3654_0: u8 = fn_state.CRm;
        // D s_3654_1: cast zx s_3654_0 -> bv
        let s_3654_1: Bits = Bits::new(s_3654_0 as u128, 4u16);
        // C s_3654_2: const #5u : u8
        let s_3654_2: u8 = 5;
        // C s_3654_3: cast zx s_3654_2 -> bv
        let s_3654_3: Bits = Bits::new(s_3654_2 as u128, 4u16);
        // D s_3654_4: cmp-eq s_3654_1 s_3654_3
        let s_3654_4: bool = ((s_3654_1) == (s_3654_3));
        // N s_3654_5: branch s_3654_4 b3696 b3655
        if s_3654_4 {
            return block_3696(state, tracer, fn_state);
        } else {
            return block_3655(state, tracer, fn_state);
        };
    }
    fn block_3655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3655_0: const #0u : u8
        let s_3655_0: bool = false;
        // D s_3655_1: write-var gs#136104 <= s_3655_0
        fn_state.gs_136104 = s_3655_0;
        // N s_3655_2: jump b3656
        return block_3656(state, tracer, fn_state);
    }
    fn block_3656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3656_0: read-var gs#136104:u8
        let s_3656_0: bool = fn_state.gs_136104;
        // N s_3656_1: branch s_3656_0 b3695 b3657
        if s_3656_0 {
            return block_3695(state, tracer, fn_state);
        } else {
            return block_3657(state, tracer, fn_state);
        };
    }
    fn block_3657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3657_0: const #0u : u8
        let s_3657_0: bool = false;
        // D s_3657_1: write-var gs#136105 <= s_3657_0
        fn_state.gs_136105 = s_3657_0;
        // N s_3657_2: jump b3658
        return block_3658(state, tracer, fn_state);
    }
    fn block_3658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3658_0: read-var gs#136105:u8
        let s_3658_0: bool = fn_state.gs_136105;
        // N s_3658_1: branch s_3658_0 b3694 b3659
        if s_3658_0 {
            return block_3694(state, tracer, fn_state);
        } else {
            return block_3659(state, tracer, fn_state);
        };
    }
    fn block_3659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3659_0: const #0u : u8
        let s_3659_0: bool = false;
        // D s_3659_1: write-var gs#136106 <= s_3659_0
        fn_state.gs_136106 = s_3659_0;
        // N s_3659_2: jump b3660
        return block_3660(state, tracer, fn_state);
    }
    fn block_3660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3660_0: read-var gs#136106:u8
        let s_3660_0: bool = fn_state.gs_136106;
        // N s_3660_1: branch s_3660_0 b3693 b3661
        if s_3660_0 {
            return block_3693(state, tracer, fn_state);
        } else {
            return block_3661(state, tracer, fn_state);
        };
    }
    fn block_3661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3661_0: const #0u : u8
        let s_3661_0: bool = false;
        // D s_3661_1: write-var gs#136107 <= s_3661_0
        fn_state.gs_136107 = s_3661_0;
        // N s_3661_2: jump b3662
        return block_3662(state, tracer, fn_state);
    }
    fn block_3662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3662_0: read-var gs#136107:u8
        let s_3662_0: bool = fn_state.gs_136107;
        // N s_3662_1: branch s_3662_0 b3692 b3663
        if s_3662_0 {
            return block_3692(state, tracer, fn_state);
        } else {
            return block_3663(state, tracer, fn_state);
        };
    }
    fn block_3663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3663_0: read-var CRm:u8
        let s_3663_0: u8 = fn_state.CRm;
        // D s_3663_1: cast zx s_3663_0 -> bv
        let s_3663_1: Bits = Bits::new(s_3663_0 as u128, 4u16);
        // C s_3663_2: const #10u : u8
        let s_3663_2: u8 = 10;
        // C s_3663_3: cast zx s_3663_2 -> bv
        let s_3663_3: Bits = Bits::new(s_3663_2 as u128, 4u16);
        // D s_3663_4: cmp-eq s_3663_1 s_3663_3
        let s_3663_4: bool = ((s_3663_1) == (s_3663_3));
        // N s_3663_5: branch s_3663_4 b3691 b3664
        if s_3663_4 {
            return block_3691(state, tracer, fn_state);
        } else {
            return block_3664(state, tracer, fn_state);
        };
    }
    fn block_3664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3664_0: const #0u : u8
        let s_3664_0: bool = false;
        // D s_3664_1: write-var gs#136108 <= s_3664_0
        fn_state.gs_136108 = s_3664_0;
        // N s_3664_2: jump b3665
        return block_3665(state, tracer, fn_state);
    }
    fn block_3665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3665_0: read-var gs#136108:u8
        let s_3665_0: bool = fn_state.gs_136108;
        // N s_3665_1: branch s_3665_0 b3690 b3666
        if s_3665_0 {
            return block_3690(state, tracer, fn_state);
        } else {
            return block_3666(state, tracer, fn_state);
        };
    }
    fn block_3666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3666_0: const #0u : u8
        let s_3666_0: bool = false;
        // D s_3666_1: write-var gs#136109 <= s_3666_0
        fn_state.gs_136109 = s_3666_0;
        // N s_3666_2: jump b3667
        return block_3667(state, tracer, fn_state);
    }
    fn block_3667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3667_0: read-var gs#136109:u8
        let s_3667_0: bool = fn_state.gs_136109;
        // N s_3667_1: branch s_3667_0 b3689 b3668
        if s_3667_0 {
            return block_3689(state, tracer, fn_state);
        } else {
            return block_3668(state, tracer, fn_state);
        };
    }
    fn block_3668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3668_0: const #0u : u8
        let s_3668_0: bool = false;
        // D s_3668_1: write-var gs#136110 <= s_3668_0
        fn_state.gs_136110 = s_3668_0;
        // N s_3668_2: jump b3669
        return block_3669(state, tracer, fn_state);
    }
    fn block_3669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3669_0: read-var gs#136110:u8
        let s_3669_0: bool = fn_state.gs_136110;
        // N s_3669_1: branch s_3669_0 b3688 b3670
        if s_3669_0 {
            return block_3688(state, tracer, fn_state);
        } else {
            return block_3670(state, tracer, fn_state);
        };
    }
    fn block_3670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3670_0: const #0u : u8
        let s_3670_0: bool = false;
        // D s_3670_1: write-var gs#136111 <= s_3670_0
        fn_state.gs_136111 = s_3670_0;
        // N s_3670_2: jump b3671
        return block_3671(state, tracer, fn_state);
    }
    fn block_3671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3671_0: read-var gs#136111:u8
        let s_3671_0: bool = fn_state.gs_136111;
        // N s_3671_1: branch s_3671_0 b3687 b3672
        if s_3671_0 {
            return block_3687(state, tracer, fn_state);
        } else {
            return block_3672(state, tracer, fn_state);
        };
    }
    fn block_3672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3672_0: read-var CRm:u8
        let s_3672_0: u8 = fn_state.CRm;
        // D s_3672_1: cast zx s_3672_0 -> bv
        let s_3672_1: Bits = Bits::new(s_3672_0 as u128, 4u16);
        // C s_3672_2: const #1u : u8
        let s_3672_2: u8 = 1;
        // C s_3672_3: cast zx s_3672_2 -> bv
        let s_3672_3: Bits = Bits::new(s_3672_2 as u128, 4u16);
        // D s_3672_4: cmp-eq s_3672_1 s_3672_3
        let s_3672_4: bool = ((s_3672_1) == (s_3672_3));
        // N s_3672_5: branch s_3672_4 b3686 b3673
        if s_3672_4 {
            return block_3686(state, tracer, fn_state);
        } else {
            return block_3673(state, tracer, fn_state);
        };
    }
    fn block_3673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3673_0: const #0u : u8
        let s_3673_0: bool = false;
        // D s_3673_1: write-var gs#136112 <= s_3673_0
        fn_state.gs_136112 = s_3673_0;
        // N s_3673_2: jump b3674
        return block_3674(state, tracer, fn_state);
    }
    fn block_3674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3674_0: read-var gs#136112:u8
        let s_3674_0: bool = fn_state.gs_136112;
        // N s_3674_1: branch s_3674_0 b3685 b3675
        if s_3674_0 {
            return block_3685(state, tracer, fn_state);
        } else {
            return block_3675(state, tracer, fn_state);
        };
    }
    fn block_3675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3675_0: const #0u : u8
        let s_3675_0: bool = false;
        // D s_3675_1: write-var gs#136113 <= s_3675_0
        fn_state.gs_136113 = s_3675_0;
        // N s_3675_2: jump b3676
        return block_3676(state, tracer, fn_state);
    }
    fn block_3676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3676_0: read-var gs#136113:u8
        let s_3676_0: bool = fn_state.gs_136113;
        // N s_3676_1: branch s_3676_0 b3684 b3677
        if s_3676_0 {
            return block_3684(state, tracer, fn_state);
        } else {
            return block_3677(state, tracer, fn_state);
        };
    }
    fn block_3677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3677_0: const #0u : u8
        let s_3677_0: bool = false;
        // D s_3677_1: write-var gs#136114 <= s_3677_0
        fn_state.gs_136114 = s_3677_0;
        // N s_3677_2: jump b3678
        return block_3678(state, tracer, fn_state);
    }
    fn block_3678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3678_0: read-var gs#136114:u8
        let s_3678_0: bool = fn_state.gs_136114;
        // N s_3678_1: branch s_3678_0 b3683 b3679
        if s_3678_0 {
            return block_3683(state, tracer, fn_state);
        } else {
            return block_3679(state, tracer, fn_state);
        };
    }
    fn block_3679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3679_0: const #0u : u8
        let s_3679_0: bool = false;
        // D s_3679_1: write-var gs#136115 <= s_3679_0
        fn_state.gs_136115 = s_3679_0;
        // N s_3679_2: jump b3680
        return block_3680(state, tracer, fn_state);
    }
    fn block_3680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3680_0: read-var gs#136115:u8
        let s_3680_0: bool = fn_state.gs_136115;
        // N s_3680_1: branch s_3680_0 b3682 b3681
        if s_3680_0 {
            return block_3682(state, tracer, fn_state);
        } else {
            return block_3681(state, tracer, fn_state);
        };
    }
    fn block_3681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3681_0: read-var coproc:u8
        let s_3681_0: u8 = fn_state.coproc;
        // D s_3681_1: read-var opc1:u8
        let s_3681_1: u8 = fn_state.opc1;
        // D s_3681_2: read-var CRn:u8
        let s_3681_2: u8 = fn_state.CRn;
        // D s_3681_3: read-var opc2:u8
        let s_3681_3: u8 = fn_state.opc2;
        // D s_3681_4: read-var CRm:u8
        let s_3681_4: u8 = fn_state.CRm;
        // C s_3681_5: const #0u : u8
        let s_3681_5: bool = false;
        // D s_3681_6: read-var t:i
        let s_3681_6: i128 = fn_state.t;
        // D s_3681_7: call AArch32_UnallocatedSysRegAccess(s_3681_0, s_3681_1, s_3681_2, s_3681_3, s_3681_4, s_3681_5, s_3681_6)
        let s_3681_7: () = AArch32_UnallocatedSysRegAccess(
            state,
            tracer,
            s_3681_0,
            s_3681_1,
            s_3681_2,
            s_3681_3,
            s_3681_4,
            s_3681_5,
            s_3681_6,
        );
        // N s_3681_8: return
        return;
    }
    fn block_3682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3682_0: read-var el:u8
        let s_3682_0: u8 = fn_state.el;
        // D s_3682_1: read-var coproc:u8
        let s_3682_1: u8 = fn_state.coproc;
        // D s_3682_2: read-var opc1:u8
        let s_3682_2: u8 = fn_state.opc1;
        // D s_3682_3: read-var CRn:u8
        let s_3682_3: u8 = fn_state.CRn;
        // D s_3682_4: read-var opc2:u8
        let s_3682_4: u8 = fn_state.opc2;
        // D s_3682_5: read-var CRm:u8
        let s_3682_5: u8 = fn_state.CRm;
        // D s_3682_6: read-var t:i
        let s_3682_6: i128 = fn_state.t;
        // D s_3682_7: call BPIALLIS_SysRegWrite32_17f454fbcdf975ae(s_3682_0, s_3682_1, s_3682_2, s_3682_3, s_3682_4, s_3682_5, s_3682_6)
        let s_3682_7: () = BPIALLIS_SysRegWrite32_17f454fbcdf975ae(
            state,
            tracer,
            s_3682_0,
            s_3682_1,
            s_3682_2,
            s_3682_3,
            s_3682_4,
            s_3682_5,
            s_3682_6,
        );
        // N s_3682_8: return
        return;
    }
    fn block_3683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3683_0: read-var opc2:u8
        let s_3683_0: u8 = fn_state.opc2;
        // D s_3683_1: cast zx s_3683_0 -> bv
        let s_3683_1: Bits = Bits::new(s_3683_0 as u128, 3u16);
        // C s_3683_2: const #6u : u8
        let s_3683_2: u8 = 6;
        // C s_3683_3: cast zx s_3683_2 -> bv
        let s_3683_3: Bits = Bits::new(s_3683_2 as u128, 3u16);
        // D s_3683_4: cmp-eq s_3683_1 s_3683_3
        let s_3683_4: bool = ((s_3683_1) == (s_3683_3));
        // D s_3683_5: write-var gs#136115 <= s_3683_4
        fn_state.gs_136115 = s_3683_4;
        // N s_3683_6: jump b3680
        return block_3680(state, tracer, fn_state);
    }
    fn block_3684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3684_0: read-var opc1:u8
        let s_3684_0: u8 = fn_state.opc1;
        // D s_3684_1: cast zx s_3684_0 -> bv
        let s_3684_1: Bits = Bits::new(s_3684_0 as u128, 3u16);
        // C s_3684_2: const #0u : u8
        let s_3684_2: u8 = 0;
        // C s_3684_3: cast zx s_3684_2 -> bv
        let s_3684_3: Bits = Bits::new(s_3684_2 as u128, 3u16);
        // D s_3684_4: cmp-eq s_3684_1 s_3684_3
        let s_3684_4: bool = ((s_3684_1) == (s_3684_3));
        // D s_3684_5: write-var gs#136114 <= s_3684_4
        fn_state.gs_136114 = s_3684_4;
        // N s_3684_6: jump b3678
        return block_3678(state, tracer, fn_state);
    }
    fn block_3685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3685_0: read-var coproc:u8
        let s_3685_0: u8 = fn_state.coproc;
        // D s_3685_1: cast zx s_3685_0 -> bv
        let s_3685_1: Bits = Bits::new(s_3685_0 as u128, 4u16);
        // C s_3685_2: const #15u : u8
        let s_3685_2: u8 = 15;
        // C s_3685_3: cast zx s_3685_2 -> bv
        let s_3685_3: Bits = Bits::new(s_3685_2 as u128, 4u16);
        // D s_3685_4: cmp-eq s_3685_1 s_3685_3
        let s_3685_4: bool = ((s_3685_1) == (s_3685_3));
        // D s_3685_5: write-var gs#136113 <= s_3685_4
        fn_state.gs_136113 = s_3685_4;
        // N s_3685_6: jump b3676
        return block_3676(state, tracer, fn_state);
    }
    fn block_3686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3686_0: read-var CRn:u8
        let s_3686_0: u8 = fn_state.CRn;
        // D s_3686_1: cast zx s_3686_0 -> bv
        let s_3686_1: Bits = Bits::new(s_3686_0 as u128, 4u16);
        // C s_3686_2: const #7u : u8
        let s_3686_2: u8 = 7;
        // C s_3686_3: cast zx s_3686_2 -> bv
        let s_3686_3: Bits = Bits::new(s_3686_2 as u128, 4u16);
        // D s_3686_4: cmp-eq s_3686_1 s_3686_3
        let s_3686_4: bool = ((s_3686_1) == (s_3686_3));
        // D s_3686_5: write-var gs#136112 <= s_3686_4
        fn_state.gs_136112 = s_3686_4;
        // N s_3686_6: jump b3674
        return block_3674(state, tracer, fn_state);
    }
    fn block_3687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3687_0: read-var el:u8
        let s_3687_0: u8 = fn_state.el;
        // D s_3687_1: read-var coproc:u8
        let s_3687_1: u8 = fn_state.coproc;
        // D s_3687_2: read-var opc1:u8
        let s_3687_2: u8 = fn_state.opc1;
        // D s_3687_3: read-var CRn:u8
        let s_3687_3: u8 = fn_state.CRn;
        // D s_3687_4: read-var opc2:u8
        let s_3687_4: u8 = fn_state.opc2;
        // D s_3687_5: read-var CRm:u8
        let s_3687_5: u8 = fn_state.CRm;
        // D s_3687_6: read-var t:i
        let s_3687_6: i128 = fn_state.t;
        // D s_3687_7: call CP15DMB_SysRegWrite32_d17f32fecbb5fdad(s_3687_0, s_3687_1, s_3687_2, s_3687_3, s_3687_4, s_3687_5, s_3687_6)
        let s_3687_7: () = CP15DMB_SysRegWrite32_d17f32fecbb5fdad(
            state,
            tracer,
            s_3687_0,
            s_3687_1,
            s_3687_2,
            s_3687_3,
            s_3687_4,
            s_3687_5,
            s_3687_6,
        );
        // N s_3687_8: return
        return;
    }
    fn block_3688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3688_0: read-var opc2:u8
        let s_3688_0: u8 = fn_state.opc2;
        // D s_3688_1: cast zx s_3688_0 -> bv
        let s_3688_1: Bits = Bits::new(s_3688_0 as u128, 3u16);
        // C s_3688_2: const #5u : u8
        let s_3688_2: u8 = 5;
        // C s_3688_3: cast zx s_3688_2 -> bv
        let s_3688_3: Bits = Bits::new(s_3688_2 as u128, 3u16);
        // D s_3688_4: cmp-eq s_3688_1 s_3688_3
        let s_3688_4: bool = ((s_3688_1) == (s_3688_3));
        // D s_3688_5: write-var gs#136111 <= s_3688_4
        fn_state.gs_136111 = s_3688_4;
        // N s_3688_6: jump b3671
        return block_3671(state, tracer, fn_state);
    }
    fn block_3689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3689_0: read-var opc1:u8
        let s_3689_0: u8 = fn_state.opc1;
        // D s_3689_1: cast zx s_3689_0 -> bv
        let s_3689_1: Bits = Bits::new(s_3689_0 as u128, 3u16);
        // C s_3689_2: const #0u : u8
        let s_3689_2: u8 = 0;
        // C s_3689_3: cast zx s_3689_2 -> bv
        let s_3689_3: Bits = Bits::new(s_3689_2 as u128, 3u16);
        // D s_3689_4: cmp-eq s_3689_1 s_3689_3
        let s_3689_4: bool = ((s_3689_1) == (s_3689_3));
        // D s_3689_5: write-var gs#136110 <= s_3689_4
        fn_state.gs_136110 = s_3689_4;
        // N s_3689_6: jump b3669
        return block_3669(state, tracer, fn_state);
    }
    fn block_3690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3690_0: read-var coproc:u8
        let s_3690_0: u8 = fn_state.coproc;
        // D s_3690_1: cast zx s_3690_0 -> bv
        let s_3690_1: Bits = Bits::new(s_3690_0 as u128, 4u16);
        // C s_3690_2: const #15u : u8
        let s_3690_2: u8 = 15;
        // C s_3690_3: cast zx s_3690_2 -> bv
        let s_3690_3: Bits = Bits::new(s_3690_2 as u128, 4u16);
        // D s_3690_4: cmp-eq s_3690_1 s_3690_3
        let s_3690_4: bool = ((s_3690_1) == (s_3690_3));
        // D s_3690_5: write-var gs#136109 <= s_3690_4
        fn_state.gs_136109 = s_3690_4;
        // N s_3690_6: jump b3667
        return block_3667(state, tracer, fn_state);
    }
    fn block_3691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3691_0: read-var CRn:u8
        let s_3691_0: u8 = fn_state.CRn;
        // D s_3691_1: cast zx s_3691_0 -> bv
        let s_3691_1: Bits = Bits::new(s_3691_0 as u128, 4u16);
        // C s_3691_2: const #7u : u8
        let s_3691_2: u8 = 7;
        // C s_3691_3: cast zx s_3691_2 -> bv
        let s_3691_3: Bits = Bits::new(s_3691_2 as u128, 4u16);
        // D s_3691_4: cmp-eq s_3691_1 s_3691_3
        let s_3691_4: bool = ((s_3691_1) == (s_3691_3));
        // D s_3691_5: write-var gs#136108 <= s_3691_4
        fn_state.gs_136108 = s_3691_4;
        // N s_3691_6: jump b3665
        return block_3665(state, tracer, fn_state);
    }
    fn block_3692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3692_0: read-var el:u8
        let s_3692_0: u8 = fn_state.el;
        // D s_3692_1: read-var coproc:u8
        let s_3692_1: u8 = fn_state.coproc;
        // D s_3692_2: read-var opc1:u8
        let s_3692_2: u8 = fn_state.opc1;
        // D s_3692_3: read-var CRn:u8
        let s_3692_3: u8 = fn_state.CRn;
        // D s_3692_4: read-var opc2:u8
        let s_3692_4: u8 = fn_state.opc2;
        // D s_3692_5: read-var CRm:u8
        let s_3692_5: u8 = fn_state.CRm;
        // D s_3692_6: read-var t:i
        let s_3692_6: i128 = fn_state.t;
        // D s_3692_7: call BPIALL_SysRegWrite32_4a4889731f53da78(s_3692_0, s_3692_1, s_3692_2, s_3692_3, s_3692_4, s_3692_5, s_3692_6)
        let s_3692_7: () = BPIALL_SysRegWrite32_4a4889731f53da78(
            state,
            tracer,
            s_3692_0,
            s_3692_1,
            s_3692_2,
            s_3692_3,
            s_3692_4,
            s_3692_5,
            s_3692_6,
        );
        // N s_3692_8: return
        return;
    }
    fn block_3693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3693_0: read-var opc2:u8
        let s_3693_0: u8 = fn_state.opc2;
        // D s_3693_1: cast zx s_3693_0 -> bv
        let s_3693_1: Bits = Bits::new(s_3693_0 as u128, 3u16);
        // C s_3693_2: const #6u : u8
        let s_3693_2: u8 = 6;
        // C s_3693_3: cast zx s_3693_2 -> bv
        let s_3693_3: Bits = Bits::new(s_3693_2 as u128, 3u16);
        // D s_3693_4: cmp-eq s_3693_1 s_3693_3
        let s_3693_4: bool = ((s_3693_1) == (s_3693_3));
        // D s_3693_5: write-var gs#136107 <= s_3693_4
        fn_state.gs_136107 = s_3693_4;
        // N s_3693_6: jump b3662
        return block_3662(state, tracer, fn_state);
    }
    fn block_3694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3694_0: read-var opc1:u8
        let s_3694_0: u8 = fn_state.opc1;
        // D s_3694_1: cast zx s_3694_0 -> bv
        let s_3694_1: Bits = Bits::new(s_3694_0 as u128, 3u16);
        // C s_3694_2: const #0u : u8
        let s_3694_2: u8 = 0;
        // C s_3694_3: cast zx s_3694_2 -> bv
        let s_3694_3: Bits = Bits::new(s_3694_2 as u128, 3u16);
        // D s_3694_4: cmp-eq s_3694_1 s_3694_3
        let s_3694_4: bool = ((s_3694_1) == (s_3694_3));
        // D s_3694_5: write-var gs#136106 <= s_3694_4
        fn_state.gs_136106 = s_3694_4;
        // N s_3694_6: jump b3660
        return block_3660(state, tracer, fn_state);
    }
    fn block_3695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3695_0: read-var coproc:u8
        let s_3695_0: u8 = fn_state.coproc;
        // D s_3695_1: cast zx s_3695_0 -> bv
        let s_3695_1: Bits = Bits::new(s_3695_0 as u128, 4u16);
        // C s_3695_2: const #15u : u8
        let s_3695_2: u8 = 15;
        // C s_3695_3: cast zx s_3695_2 -> bv
        let s_3695_3: Bits = Bits::new(s_3695_2 as u128, 4u16);
        // D s_3695_4: cmp-eq s_3695_1 s_3695_3
        let s_3695_4: bool = ((s_3695_1) == (s_3695_3));
        // D s_3695_5: write-var gs#136105 <= s_3695_4
        fn_state.gs_136105 = s_3695_4;
        // N s_3695_6: jump b3658
        return block_3658(state, tracer, fn_state);
    }
    fn block_3696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3696_0: read-var CRn:u8
        let s_3696_0: u8 = fn_state.CRn;
        // D s_3696_1: cast zx s_3696_0 -> bv
        let s_3696_1: Bits = Bits::new(s_3696_0 as u128, 4u16);
        // C s_3696_2: const #7u : u8
        let s_3696_2: u8 = 7;
        // C s_3696_3: cast zx s_3696_2 -> bv
        let s_3696_3: Bits = Bits::new(s_3696_2 as u128, 4u16);
        // D s_3696_4: cmp-eq s_3696_1 s_3696_3
        let s_3696_4: bool = ((s_3696_1) == (s_3696_3));
        // D s_3696_5: write-var gs#136104 <= s_3696_4
        fn_state.gs_136104 = s_3696_4;
        // N s_3696_6: jump b3656
        return block_3656(state, tracer, fn_state);
    }
    fn block_3697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3697_0: read-var el:u8
        let s_3697_0: u8 = fn_state.el;
        // D s_3697_1: read-var coproc:u8
        let s_3697_1: u8 = fn_state.coproc;
        // D s_3697_2: read-var opc1:u8
        let s_3697_2: u8 = fn_state.opc1;
        // D s_3697_3: read-var CRn:u8
        let s_3697_3: u8 = fn_state.CRn;
        // D s_3697_4: read-var opc2:u8
        let s_3697_4: u8 = fn_state.opc2;
        // D s_3697_5: read-var CRm:u8
        let s_3697_5: u8 = fn_state.CRm;
        // D s_3697_6: read-var t:i
        let s_3697_6: i128 = fn_state.t;
        // D s_3697_7: call TLBIALLNSNHIS_SysRegWrite32_934a7e1a0cc96b4a(s_3697_0, s_3697_1, s_3697_2, s_3697_3, s_3697_4, s_3697_5, s_3697_6)
        let s_3697_7: () = TLBIALLNSNHIS_SysRegWrite32_934a7e1a0cc96b4a(
            state,
            tracer,
            s_3697_0,
            s_3697_1,
            s_3697_2,
            s_3697_3,
            s_3697_4,
            s_3697_5,
            s_3697_6,
        );
        // N s_3697_8: return
        return;
    }
    fn block_3698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3698_0: read-var opc2:u8
        let s_3698_0: u8 = fn_state.opc2;
        // D s_3698_1: cast zx s_3698_0 -> bv
        let s_3698_1: Bits = Bits::new(s_3698_0 as u128, 3u16);
        // C s_3698_2: const #4u : u8
        let s_3698_2: u8 = 4;
        // C s_3698_3: cast zx s_3698_2 -> bv
        let s_3698_3: Bits = Bits::new(s_3698_2 as u128, 3u16);
        // D s_3698_4: cmp-eq s_3698_1 s_3698_3
        let s_3698_4: bool = ((s_3698_1) == (s_3698_3));
        // D s_3698_5: write-var gs#136103 <= s_3698_4
        fn_state.gs_136103 = s_3698_4;
        // N s_3698_6: jump b3653
        return block_3653(state, tracer, fn_state);
    }
    fn block_3699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3699_0: read-var opc1:u8
        let s_3699_0: u8 = fn_state.opc1;
        // D s_3699_1: cast zx s_3699_0 -> bv
        let s_3699_1: Bits = Bits::new(s_3699_0 as u128, 3u16);
        // C s_3699_2: const #4u : u8
        let s_3699_2: u8 = 4;
        // C s_3699_3: cast zx s_3699_2 -> bv
        let s_3699_3: Bits = Bits::new(s_3699_2 as u128, 3u16);
        // D s_3699_4: cmp-eq s_3699_1 s_3699_3
        let s_3699_4: bool = ((s_3699_1) == (s_3699_3));
        // D s_3699_5: write-var gs#136102 <= s_3699_4
        fn_state.gs_136102 = s_3699_4;
        // N s_3699_6: jump b3651
        return block_3651(state, tracer, fn_state);
    }
    fn block_3700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3700_0: read-var coproc:u8
        let s_3700_0: u8 = fn_state.coproc;
        // D s_3700_1: cast zx s_3700_0 -> bv
        let s_3700_1: Bits = Bits::new(s_3700_0 as u128, 4u16);
        // C s_3700_2: const #15u : u8
        let s_3700_2: u8 = 15;
        // C s_3700_3: cast zx s_3700_2 -> bv
        let s_3700_3: Bits = Bits::new(s_3700_2 as u128, 4u16);
        // D s_3700_4: cmp-eq s_3700_1 s_3700_3
        let s_3700_4: bool = ((s_3700_1) == (s_3700_3));
        // D s_3700_5: write-var gs#136101 <= s_3700_4
        fn_state.gs_136101 = s_3700_4;
        // N s_3700_6: jump b3649
        return block_3649(state, tracer, fn_state);
    }
    fn block_3701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3701_0: read-var CRn:u8
        let s_3701_0: u8 = fn_state.CRn;
        // D s_3701_1: cast zx s_3701_0 -> bv
        let s_3701_1: Bits = Bits::new(s_3701_0 as u128, 4u16);
        // C s_3701_2: const #8u : u8
        let s_3701_2: u8 = 8;
        // C s_3701_3: cast zx s_3701_2 -> bv
        let s_3701_3: Bits = Bits::new(s_3701_2 as u128, 4u16);
        // D s_3701_4: cmp-eq s_3701_1 s_3701_3
        let s_3701_4: bool = ((s_3701_1) == (s_3701_3));
        // D s_3701_5: write-var gs#136100 <= s_3701_4
        fn_state.gs_136100 = s_3701_4;
        // N s_3701_6: jump b3647
        return block_3647(state, tracer, fn_state);
    }
    fn block_3702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3702_0: read-var el:u8
        let s_3702_0: u8 = fn_state.el;
        // D s_3702_1: read-var coproc:u8
        let s_3702_1: u8 = fn_state.coproc;
        // D s_3702_2: read-var opc1:u8
        let s_3702_2: u8 = fn_state.opc1;
        // D s_3702_3: read-var CRn:u8
        let s_3702_3: u8 = fn_state.CRn;
        // D s_3702_4: read-var opc2:u8
        let s_3702_4: u8 = fn_state.opc2;
        // D s_3702_5: read-var CRm:u8
        let s_3702_5: u8 = fn_state.CRm;
        // D s_3702_6: read-var t:i
        let s_3702_6: i128 = fn_state.t;
        // D s_3702_7: call ICIALLUIS_SysRegWrite32_33170c116ea45e36(s_3702_0, s_3702_1, s_3702_2, s_3702_3, s_3702_4, s_3702_5, s_3702_6)
        let s_3702_7: () = ICIALLUIS_SysRegWrite32_33170c116ea45e36(
            state,
            tracer,
            s_3702_0,
            s_3702_1,
            s_3702_2,
            s_3702_3,
            s_3702_4,
            s_3702_5,
            s_3702_6,
        );
        // N s_3702_8: return
        return;
    }
    fn block_3703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3703_0: read-var opc2:u8
        let s_3703_0: u8 = fn_state.opc2;
        // D s_3703_1: cast zx s_3703_0 -> bv
        let s_3703_1: Bits = Bits::new(s_3703_0 as u128, 3u16);
        // C s_3703_2: const #0u : u8
        let s_3703_2: u8 = 0;
        // C s_3703_3: cast zx s_3703_2 -> bv
        let s_3703_3: Bits = Bits::new(s_3703_2 as u128, 3u16);
        // D s_3703_4: cmp-eq s_3703_1 s_3703_3
        let s_3703_4: bool = ((s_3703_1) == (s_3703_3));
        // D s_3703_5: write-var gs#136099 <= s_3703_4
        fn_state.gs_136099 = s_3703_4;
        // N s_3703_6: jump b3644
        return block_3644(state, tracer, fn_state);
    }
    fn block_3704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3704_0: read-var opc1:u8
        let s_3704_0: u8 = fn_state.opc1;
        // D s_3704_1: cast zx s_3704_0 -> bv
        let s_3704_1: Bits = Bits::new(s_3704_0 as u128, 3u16);
        // C s_3704_2: const #0u : u8
        let s_3704_2: u8 = 0;
        // C s_3704_3: cast zx s_3704_2 -> bv
        let s_3704_3: Bits = Bits::new(s_3704_2 as u128, 3u16);
        // D s_3704_4: cmp-eq s_3704_1 s_3704_3
        let s_3704_4: bool = ((s_3704_1) == (s_3704_3));
        // D s_3704_5: write-var gs#136098 <= s_3704_4
        fn_state.gs_136098 = s_3704_4;
        // N s_3704_6: jump b3642
        return block_3642(state, tracer, fn_state);
    }
    fn block_3705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3705_0: read-var coproc:u8
        let s_3705_0: u8 = fn_state.coproc;
        // D s_3705_1: cast zx s_3705_0 -> bv
        let s_3705_1: Bits = Bits::new(s_3705_0 as u128, 4u16);
        // C s_3705_2: const #15u : u8
        let s_3705_2: u8 = 15;
        // C s_3705_3: cast zx s_3705_2 -> bv
        let s_3705_3: Bits = Bits::new(s_3705_2 as u128, 4u16);
        // D s_3705_4: cmp-eq s_3705_1 s_3705_3
        let s_3705_4: bool = ((s_3705_1) == (s_3705_3));
        // D s_3705_5: write-var gs#136097 <= s_3705_4
        fn_state.gs_136097 = s_3705_4;
        // N s_3705_6: jump b3640
        return block_3640(state, tracer, fn_state);
    }
    fn block_3706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3706_0: read-var CRn:u8
        let s_3706_0: u8 = fn_state.CRn;
        // D s_3706_1: cast zx s_3706_0 -> bv
        let s_3706_1: Bits = Bits::new(s_3706_0 as u128, 4u16);
        // C s_3706_2: const #7u : u8
        let s_3706_2: u8 = 7;
        // C s_3706_3: cast zx s_3706_2 -> bv
        let s_3706_3: Bits = Bits::new(s_3706_2 as u128, 4u16);
        // D s_3706_4: cmp-eq s_3706_1 s_3706_3
        let s_3706_4: bool = ((s_3706_1) == (s_3706_3));
        // D s_3706_5: write-var gs#136096 <= s_3706_4
        fn_state.gs_136096 = s_3706_4;
        // N s_3706_6: jump b3638
        return block_3638(state, tracer, fn_state);
    }
    fn block_3707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3707_0: read-var el:u8
        let s_3707_0: u8 = fn_state.el;
        // D s_3707_1: read-var coproc:u8
        let s_3707_1: u8 = fn_state.coproc;
        // D s_3707_2: read-var opc1:u8
        let s_3707_2: u8 = fn_state.opc1;
        // D s_3707_3: read-var CRn:u8
        let s_3707_3: u8 = fn_state.CRn;
        // D s_3707_4: read-var opc2:u8
        let s_3707_4: u8 = fn_state.opc2;
        // D s_3707_5: read-var CRm:u8
        let s_3707_5: u8 = fn_state.CRm;
        // D s_3707_6: read-var t:i
        let s_3707_6: i128 = fn_state.t;
        // D s_3707_7: call ITLBIALL_SysRegWrite32_58b4810189599a79(s_3707_0, s_3707_1, s_3707_2, s_3707_3, s_3707_4, s_3707_5, s_3707_6)
        let s_3707_7: () = ITLBIALL_SysRegWrite32_58b4810189599a79(
            state,
            tracer,
            s_3707_0,
            s_3707_1,
            s_3707_2,
            s_3707_3,
            s_3707_4,
            s_3707_5,
            s_3707_6,
        );
        // N s_3707_8: return
        return;
    }
    fn block_3708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3708_0: read-var opc2:u8
        let s_3708_0: u8 = fn_state.opc2;
        // D s_3708_1: cast zx s_3708_0 -> bv
        let s_3708_1: Bits = Bits::new(s_3708_0 as u128, 3u16);
        // C s_3708_2: const #0u : u8
        let s_3708_2: u8 = 0;
        // C s_3708_3: cast zx s_3708_2 -> bv
        let s_3708_3: Bits = Bits::new(s_3708_2 as u128, 3u16);
        // D s_3708_4: cmp-eq s_3708_1 s_3708_3
        let s_3708_4: bool = ((s_3708_1) == (s_3708_3));
        // D s_3708_5: write-var gs#136095 <= s_3708_4
        fn_state.gs_136095 = s_3708_4;
        // N s_3708_6: jump b3635
        return block_3635(state, tracer, fn_state);
    }
    fn block_3709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3709_0: read-var opc1:u8
        let s_3709_0: u8 = fn_state.opc1;
        // D s_3709_1: cast zx s_3709_0 -> bv
        let s_3709_1: Bits = Bits::new(s_3709_0 as u128, 3u16);
        // C s_3709_2: const #0u : u8
        let s_3709_2: u8 = 0;
        // C s_3709_3: cast zx s_3709_2 -> bv
        let s_3709_3: Bits = Bits::new(s_3709_2 as u128, 3u16);
        // D s_3709_4: cmp-eq s_3709_1 s_3709_3
        let s_3709_4: bool = ((s_3709_1) == (s_3709_3));
        // D s_3709_5: write-var gs#136094 <= s_3709_4
        fn_state.gs_136094 = s_3709_4;
        // N s_3709_6: jump b3633
        return block_3633(state, tracer, fn_state);
    }
    fn block_3710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3710_0: read-var coproc:u8
        let s_3710_0: u8 = fn_state.coproc;
        // D s_3710_1: cast zx s_3710_0 -> bv
        let s_3710_1: Bits = Bits::new(s_3710_0 as u128, 4u16);
        // C s_3710_2: const #15u : u8
        let s_3710_2: u8 = 15;
        // C s_3710_3: cast zx s_3710_2 -> bv
        let s_3710_3: Bits = Bits::new(s_3710_2 as u128, 4u16);
        // D s_3710_4: cmp-eq s_3710_1 s_3710_3
        let s_3710_4: bool = ((s_3710_1) == (s_3710_3));
        // D s_3710_5: write-var gs#136093 <= s_3710_4
        fn_state.gs_136093 = s_3710_4;
        // N s_3710_6: jump b3631
        return block_3631(state, tracer, fn_state);
    }
    fn block_3711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3711_0: read-var CRn:u8
        let s_3711_0: u8 = fn_state.CRn;
        // D s_3711_1: cast zx s_3711_0 -> bv
        let s_3711_1: Bits = Bits::new(s_3711_0 as u128, 4u16);
        // C s_3711_2: const #8u : u8
        let s_3711_2: u8 = 8;
        // C s_3711_3: cast zx s_3711_2 -> bv
        let s_3711_3: Bits = Bits::new(s_3711_2 as u128, 4u16);
        // D s_3711_4: cmp-eq s_3711_1 s_3711_3
        let s_3711_4: bool = ((s_3711_1) == (s_3711_3));
        // D s_3711_5: write-var gs#136092 <= s_3711_4
        fn_state.gs_136092 = s_3711_4;
        // N s_3711_6: jump b3629
        return block_3629(state, tracer, fn_state);
    }
    fn block_3712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3712_0: read-var el:u8
        let s_3712_0: u8 = fn_state.el;
        // D s_3712_1: read-var coproc:u8
        let s_3712_1: u8 = fn_state.coproc;
        // D s_3712_2: read-var opc1:u8
        let s_3712_2: u8 = fn_state.opc1;
        // D s_3712_3: read-var CRn:u8
        let s_3712_3: u8 = fn_state.CRn;
        // D s_3712_4: read-var opc2:u8
        let s_3712_4: u8 = fn_state.opc2;
        // D s_3712_5: read-var CRm:u8
        let s_3712_5: u8 = fn_state.CRm;
        // D s_3712_6: read-var t:i
        let s_3712_6: i128 = fn_state.t;
        // D s_3712_7: call DTLBIALL_SysRegWrite32_e0269c0064c12331(s_3712_0, s_3712_1, s_3712_2, s_3712_3, s_3712_4, s_3712_5, s_3712_6)
        let s_3712_7: () = DTLBIALL_SysRegWrite32_e0269c0064c12331(
            state,
            tracer,
            s_3712_0,
            s_3712_1,
            s_3712_2,
            s_3712_3,
            s_3712_4,
            s_3712_5,
            s_3712_6,
        );
        // N s_3712_8: return
        return;
    }
    fn block_3713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3713_0: read-var opc2:u8
        let s_3713_0: u8 = fn_state.opc2;
        // D s_3713_1: cast zx s_3713_0 -> bv
        let s_3713_1: Bits = Bits::new(s_3713_0 as u128, 3u16);
        // C s_3713_2: const #0u : u8
        let s_3713_2: u8 = 0;
        // C s_3713_3: cast zx s_3713_2 -> bv
        let s_3713_3: Bits = Bits::new(s_3713_2 as u128, 3u16);
        // D s_3713_4: cmp-eq s_3713_1 s_3713_3
        let s_3713_4: bool = ((s_3713_1) == (s_3713_3));
        // D s_3713_5: write-var gs#136091 <= s_3713_4
        fn_state.gs_136091 = s_3713_4;
        // N s_3713_6: jump b3626
        return block_3626(state, tracer, fn_state);
    }
    fn block_3714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3714_0: read-var opc1:u8
        let s_3714_0: u8 = fn_state.opc1;
        // D s_3714_1: cast zx s_3714_0 -> bv
        let s_3714_1: Bits = Bits::new(s_3714_0 as u128, 3u16);
        // C s_3714_2: const #0u : u8
        let s_3714_2: u8 = 0;
        // C s_3714_3: cast zx s_3714_2 -> bv
        let s_3714_3: Bits = Bits::new(s_3714_2 as u128, 3u16);
        // D s_3714_4: cmp-eq s_3714_1 s_3714_3
        let s_3714_4: bool = ((s_3714_1) == (s_3714_3));
        // D s_3714_5: write-var gs#136090 <= s_3714_4
        fn_state.gs_136090 = s_3714_4;
        // N s_3714_6: jump b3624
        return block_3624(state, tracer, fn_state);
    }
    fn block_3715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3715_0: read-var coproc:u8
        let s_3715_0: u8 = fn_state.coproc;
        // D s_3715_1: cast zx s_3715_0 -> bv
        let s_3715_1: Bits = Bits::new(s_3715_0 as u128, 4u16);
        // C s_3715_2: const #15u : u8
        let s_3715_2: u8 = 15;
        // C s_3715_3: cast zx s_3715_2 -> bv
        let s_3715_3: Bits = Bits::new(s_3715_2 as u128, 4u16);
        // D s_3715_4: cmp-eq s_3715_1 s_3715_3
        let s_3715_4: bool = ((s_3715_1) == (s_3715_3));
        // D s_3715_5: write-var gs#136089 <= s_3715_4
        fn_state.gs_136089 = s_3715_4;
        // N s_3715_6: jump b3622
        return block_3622(state, tracer, fn_state);
    }
    fn block_3716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3716_0: read-var CRn:u8
        let s_3716_0: u8 = fn_state.CRn;
        // D s_3716_1: cast zx s_3716_0 -> bv
        let s_3716_1: Bits = Bits::new(s_3716_0 as u128, 4u16);
        // C s_3716_2: const #8u : u8
        let s_3716_2: u8 = 8;
        // C s_3716_3: cast zx s_3716_2 -> bv
        let s_3716_3: Bits = Bits::new(s_3716_2 as u128, 4u16);
        // D s_3716_4: cmp-eq s_3716_1 s_3716_3
        let s_3716_4: bool = ((s_3716_1) == (s_3716_3));
        // D s_3716_5: write-var gs#136088 <= s_3716_4
        fn_state.gs_136088 = s_3716_4;
        // N s_3716_6: jump b3620
        return block_3620(state, tracer, fn_state);
    }
    fn block_3717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3717_0: read-var el:u8
        let s_3717_0: u8 = fn_state.el;
        // D s_3717_1: read-var coproc:u8
        let s_3717_1: u8 = fn_state.coproc;
        // D s_3717_2: read-var opc1:u8
        let s_3717_2: u8 = fn_state.opc1;
        // D s_3717_3: read-var CRn:u8
        let s_3717_3: u8 = fn_state.CRn;
        // D s_3717_4: read-var opc2:u8
        let s_3717_4: u8 = fn_state.opc2;
        // D s_3717_5: read-var CRm:u8
        let s_3717_5: u8 = fn_state.CRm;
        // D s_3717_6: read-var t:i
        let s_3717_6: i128 = fn_state.t;
        // D s_3717_7: call CP15ISB_SysRegWrite32_b2e3d8ab360938e2(s_3717_0, s_3717_1, s_3717_2, s_3717_3, s_3717_4, s_3717_5, s_3717_6)
        let s_3717_7: () = CP15ISB_SysRegWrite32_b2e3d8ab360938e2(
            state,
            tracer,
            s_3717_0,
            s_3717_1,
            s_3717_2,
            s_3717_3,
            s_3717_4,
            s_3717_5,
            s_3717_6,
        );
        // N s_3717_8: return
        return;
    }
    fn block_3718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3718_0: read-var opc2:u8
        let s_3718_0: u8 = fn_state.opc2;
        // D s_3718_1: cast zx s_3718_0 -> bv
        let s_3718_1: Bits = Bits::new(s_3718_0 as u128, 3u16);
        // C s_3718_2: const #4u : u8
        let s_3718_2: u8 = 4;
        // C s_3718_3: cast zx s_3718_2 -> bv
        let s_3718_3: Bits = Bits::new(s_3718_2 as u128, 3u16);
        // D s_3718_4: cmp-eq s_3718_1 s_3718_3
        let s_3718_4: bool = ((s_3718_1) == (s_3718_3));
        // D s_3718_5: write-var gs#136087 <= s_3718_4
        fn_state.gs_136087 = s_3718_4;
        // N s_3718_6: jump b3617
        return block_3617(state, tracer, fn_state);
    }
    fn block_3719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3719_0: read-var opc1:u8
        let s_3719_0: u8 = fn_state.opc1;
        // D s_3719_1: cast zx s_3719_0 -> bv
        let s_3719_1: Bits = Bits::new(s_3719_0 as u128, 3u16);
        // C s_3719_2: const #0u : u8
        let s_3719_2: u8 = 0;
        // C s_3719_3: cast zx s_3719_2 -> bv
        let s_3719_3: Bits = Bits::new(s_3719_2 as u128, 3u16);
        // D s_3719_4: cmp-eq s_3719_1 s_3719_3
        let s_3719_4: bool = ((s_3719_1) == (s_3719_3));
        // D s_3719_5: write-var gs#136086 <= s_3719_4
        fn_state.gs_136086 = s_3719_4;
        // N s_3719_6: jump b3615
        return block_3615(state, tracer, fn_state);
    }
    fn block_3720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3720_0: read-var coproc:u8
        let s_3720_0: u8 = fn_state.coproc;
        // D s_3720_1: cast zx s_3720_0 -> bv
        let s_3720_1: Bits = Bits::new(s_3720_0 as u128, 4u16);
        // C s_3720_2: const #15u : u8
        let s_3720_2: u8 = 15;
        // C s_3720_3: cast zx s_3720_2 -> bv
        let s_3720_3: Bits = Bits::new(s_3720_2 as u128, 4u16);
        // D s_3720_4: cmp-eq s_3720_1 s_3720_3
        let s_3720_4: bool = ((s_3720_1) == (s_3720_3));
        // D s_3720_5: write-var gs#136085 <= s_3720_4
        fn_state.gs_136085 = s_3720_4;
        // N s_3720_6: jump b3613
        return block_3613(state, tracer, fn_state);
    }
    fn block_3721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3721_0: read-var CRn:u8
        let s_3721_0: u8 = fn_state.CRn;
        // D s_3721_1: cast zx s_3721_0 -> bv
        let s_3721_1: Bits = Bits::new(s_3721_0 as u128, 4u16);
        // C s_3721_2: const #7u : u8
        let s_3721_2: u8 = 7;
        // C s_3721_3: cast zx s_3721_2 -> bv
        let s_3721_3: Bits = Bits::new(s_3721_2 as u128, 4u16);
        // D s_3721_4: cmp-eq s_3721_1 s_3721_3
        let s_3721_4: bool = ((s_3721_1) == (s_3721_3));
        // D s_3721_5: write-var gs#136084 <= s_3721_4
        fn_state.gs_136084 = s_3721_4;
        // N s_3721_6: jump b3611
        return block_3611(state, tracer, fn_state);
    }
    fn block_3722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3722_0: read-var el:u8
        let s_3722_0: u8 = fn_state.el;
        // D s_3722_1: read-var coproc:u8
        let s_3722_1: u8 = fn_state.coproc;
        // D s_3722_2: read-var opc1:u8
        let s_3722_2: u8 = fn_state.opc1;
        // D s_3722_3: read-var CRn:u8
        let s_3722_3: u8 = fn_state.CRn;
        // D s_3722_4: read-var opc2:u8
        let s_3722_4: u8 = fn_state.opc2;
        // D s_3722_5: read-var CRm:u8
        let s_3722_5: u8 = fn_state.CRm;
        // D s_3722_6: read-var t:i
        let s_3722_6: i128 = fn_state.t;
        // D s_3722_7: call ICIALLU_SysRegWrite32_cbf11f5ea46a9ef3(s_3722_0, s_3722_1, s_3722_2, s_3722_3, s_3722_4, s_3722_5, s_3722_6)
        let s_3722_7: () = ICIALLU_SysRegWrite32_cbf11f5ea46a9ef3(
            state,
            tracer,
            s_3722_0,
            s_3722_1,
            s_3722_2,
            s_3722_3,
            s_3722_4,
            s_3722_5,
            s_3722_6,
        );
        // N s_3722_8: return
        return;
    }
    fn block_3723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3723_0: read-var opc2:u8
        let s_3723_0: u8 = fn_state.opc2;
        // D s_3723_1: cast zx s_3723_0 -> bv
        let s_3723_1: Bits = Bits::new(s_3723_0 as u128, 3u16);
        // C s_3723_2: const #0u : u8
        let s_3723_2: u8 = 0;
        // C s_3723_3: cast zx s_3723_2 -> bv
        let s_3723_3: Bits = Bits::new(s_3723_2 as u128, 3u16);
        // D s_3723_4: cmp-eq s_3723_1 s_3723_3
        let s_3723_4: bool = ((s_3723_1) == (s_3723_3));
        // D s_3723_5: write-var gs#136083 <= s_3723_4
        fn_state.gs_136083 = s_3723_4;
        // N s_3723_6: jump b3608
        return block_3608(state, tracer, fn_state);
    }
    fn block_3724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3724_0: read-var opc1:u8
        let s_3724_0: u8 = fn_state.opc1;
        // D s_3724_1: cast zx s_3724_0 -> bv
        let s_3724_1: Bits = Bits::new(s_3724_0 as u128, 3u16);
        // C s_3724_2: const #0u : u8
        let s_3724_2: u8 = 0;
        // C s_3724_3: cast zx s_3724_2 -> bv
        let s_3724_3: Bits = Bits::new(s_3724_2 as u128, 3u16);
        // D s_3724_4: cmp-eq s_3724_1 s_3724_3
        let s_3724_4: bool = ((s_3724_1) == (s_3724_3));
        // D s_3724_5: write-var gs#136082 <= s_3724_4
        fn_state.gs_136082 = s_3724_4;
        // N s_3724_6: jump b3606
        return block_3606(state, tracer, fn_state);
    }
    fn block_3725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3725_0: read-var coproc:u8
        let s_3725_0: u8 = fn_state.coproc;
        // D s_3725_1: cast zx s_3725_0 -> bv
        let s_3725_1: Bits = Bits::new(s_3725_0 as u128, 4u16);
        // C s_3725_2: const #15u : u8
        let s_3725_2: u8 = 15;
        // C s_3725_3: cast zx s_3725_2 -> bv
        let s_3725_3: Bits = Bits::new(s_3725_2 as u128, 4u16);
        // D s_3725_4: cmp-eq s_3725_1 s_3725_3
        let s_3725_4: bool = ((s_3725_1) == (s_3725_3));
        // D s_3725_5: write-var gs#136081 <= s_3725_4
        fn_state.gs_136081 = s_3725_4;
        // N s_3725_6: jump b3604
        return block_3604(state, tracer, fn_state);
    }
    fn block_3726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3726_0: read-var CRn:u8
        let s_3726_0: u8 = fn_state.CRn;
        // D s_3726_1: cast zx s_3726_0 -> bv
        let s_3726_1: Bits = Bits::new(s_3726_0 as u128, 4u16);
        // C s_3726_2: const #7u : u8
        let s_3726_2: u8 = 7;
        // C s_3726_3: cast zx s_3726_2 -> bv
        let s_3726_3: Bits = Bits::new(s_3726_2 as u128, 4u16);
        // D s_3726_4: cmp-eq s_3726_1 s_3726_3
        let s_3726_4: bool = ((s_3726_1) == (s_3726_3));
        // D s_3726_5: write-var gs#136080 <= s_3726_4
        fn_state.gs_136080 = s_3726_4;
        // N s_3726_6: jump b3602
        return block_3602(state, tracer, fn_state);
    }
    fn block_3727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3727_0: read-var el:u8
        let s_3727_0: u8 = fn_state.el;
        // D s_3727_1: read-var coproc:u8
        let s_3727_1: u8 = fn_state.coproc;
        // D s_3727_2: read-var opc1:u8
        let s_3727_2: u8 = fn_state.opc1;
        // D s_3727_3: read-var CRn:u8
        let s_3727_3: u8 = fn_state.CRn;
        // D s_3727_4: read-var opc2:u8
        let s_3727_4: u8 = fn_state.opc2;
        // D s_3727_5: read-var CRm:u8
        let s_3727_5: u8 = fn_state.CRm;
        // D s_3727_6: read-var t:i
        let s_3727_6: i128 = fn_state.t;
        // D s_3727_7: call TLBIALLNSNH_SysRegWrite32_31faa2646b198591(s_3727_0, s_3727_1, s_3727_2, s_3727_3, s_3727_4, s_3727_5, s_3727_6)
        let s_3727_7: () = TLBIALLNSNH_SysRegWrite32_31faa2646b198591(
            state,
            tracer,
            s_3727_0,
            s_3727_1,
            s_3727_2,
            s_3727_3,
            s_3727_4,
            s_3727_5,
            s_3727_6,
        );
        // N s_3727_8: return
        return;
    }
    fn block_3728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3728_0: read-var opc2:u8
        let s_3728_0: u8 = fn_state.opc2;
        // D s_3728_1: cast zx s_3728_0 -> bv
        let s_3728_1: Bits = Bits::new(s_3728_0 as u128, 3u16);
        // C s_3728_2: const #4u : u8
        let s_3728_2: u8 = 4;
        // C s_3728_3: cast zx s_3728_2 -> bv
        let s_3728_3: Bits = Bits::new(s_3728_2 as u128, 3u16);
        // D s_3728_4: cmp-eq s_3728_1 s_3728_3
        let s_3728_4: bool = ((s_3728_1) == (s_3728_3));
        // D s_3728_5: write-var gs#136079 <= s_3728_4
        fn_state.gs_136079 = s_3728_4;
        // N s_3728_6: jump b3599
        return block_3599(state, tracer, fn_state);
    }
    fn block_3729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3729_0: read-var opc1:u8
        let s_3729_0: u8 = fn_state.opc1;
        // D s_3729_1: cast zx s_3729_0 -> bv
        let s_3729_1: Bits = Bits::new(s_3729_0 as u128, 3u16);
        // C s_3729_2: const #4u : u8
        let s_3729_2: u8 = 4;
        // C s_3729_3: cast zx s_3729_2 -> bv
        let s_3729_3: Bits = Bits::new(s_3729_2 as u128, 3u16);
        // D s_3729_4: cmp-eq s_3729_1 s_3729_3
        let s_3729_4: bool = ((s_3729_1) == (s_3729_3));
        // D s_3729_5: write-var gs#136078 <= s_3729_4
        fn_state.gs_136078 = s_3729_4;
        // N s_3729_6: jump b3597
        return block_3597(state, tracer, fn_state);
    }
    fn block_3730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3730_0: read-var coproc:u8
        let s_3730_0: u8 = fn_state.coproc;
        // D s_3730_1: cast zx s_3730_0 -> bv
        let s_3730_1: Bits = Bits::new(s_3730_0 as u128, 4u16);
        // C s_3730_2: const #15u : u8
        let s_3730_2: u8 = 15;
        // C s_3730_3: cast zx s_3730_2 -> bv
        let s_3730_3: Bits = Bits::new(s_3730_2 as u128, 4u16);
        // D s_3730_4: cmp-eq s_3730_1 s_3730_3
        let s_3730_4: bool = ((s_3730_1) == (s_3730_3));
        // D s_3730_5: write-var gs#136077 <= s_3730_4
        fn_state.gs_136077 = s_3730_4;
        // N s_3730_6: jump b3595
        return block_3595(state, tracer, fn_state);
    }
    fn block_3731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3731_0: read-var CRn:u8
        let s_3731_0: u8 = fn_state.CRn;
        // D s_3731_1: cast zx s_3731_0 -> bv
        let s_3731_1: Bits = Bits::new(s_3731_0 as u128, 4u16);
        // C s_3731_2: const #8u : u8
        let s_3731_2: u8 = 8;
        // C s_3731_3: cast zx s_3731_2 -> bv
        let s_3731_3: Bits = Bits::new(s_3731_2 as u128, 4u16);
        // D s_3731_4: cmp-eq s_3731_1 s_3731_3
        let s_3731_4: bool = ((s_3731_1) == (s_3731_3));
        // D s_3731_5: write-var gs#136076 <= s_3731_4
        fn_state.gs_136076 = s_3731_4;
        // N s_3731_6: jump b3593
        return block_3593(state, tracer, fn_state);
    }
    fn block_3732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3732_0: read-var el:u8
        let s_3732_0: u8 = fn_state.el;
        // D s_3732_1: read-var coproc:u8
        let s_3732_1: u8 = fn_state.coproc;
        // D s_3732_2: read-var opc1:u8
        let s_3732_2: u8 = fn_state.opc1;
        // D s_3732_3: read-var CRn:u8
        let s_3732_3: u8 = fn_state.CRn;
        // D s_3732_4: read-var opc2:u8
        let s_3732_4: u8 = fn_state.opc2;
        // D s_3732_5: read-var CRm:u8
        let s_3732_5: u8 = fn_state.CRm;
        // D s_3732_6: read-var t:i
        let s_3732_6: i128 = fn_state.t;
        // D s_3732_7: call TLBIALLH_SysRegWrite32_ce3aa1e39dfad34d(s_3732_0, s_3732_1, s_3732_2, s_3732_3, s_3732_4, s_3732_5, s_3732_6)
        let s_3732_7: () = TLBIALLH_SysRegWrite32_ce3aa1e39dfad34d(
            state,
            tracer,
            s_3732_0,
            s_3732_1,
            s_3732_2,
            s_3732_3,
            s_3732_4,
            s_3732_5,
            s_3732_6,
        );
        // N s_3732_8: return
        return;
    }
    fn block_3733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3733_0: read-var opc2:u8
        let s_3733_0: u8 = fn_state.opc2;
        // D s_3733_1: cast zx s_3733_0 -> bv
        let s_3733_1: Bits = Bits::new(s_3733_0 as u128, 3u16);
        // C s_3733_2: const #0u : u8
        let s_3733_2: u8 = 0;
        // C s_3733_3: cast zx s_3733_2 -> bv
        let s_3733_3: Bits = Bits::new(s_3733_2 as u128, 3u16);
        // D s_3733_4: cmp-eq s_3733_1 s_3733_3
        let s_3733_4: bool = ((s_3733_1) == (s_3733_3));
        // D s_3733_5: write-var gs#136075 <= s_3733_4
        fn_state.gs_136075 = s_3733_4;
        // N s_3733_6: jump b3590
        return block_3590(state, tracer, fn_state);
    }
    fn block_3734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3734_0: read-var opc1:u8
        let s_3734_0: u8 = fn_state.opc1;
        // D s_3734_1: cast zx s_3734_0 -> bv
        let s_3734_1: Bits = Bits::new(s_3734_0 as u128, 3u16);
        // C s_3734_2: const #4u : u8
        let s_3734_2: u8 = 4;
        // C s_3734_3: cast zx s_3734_2 -> bv
        let s_3734_3: Bits = Bits::new(s_3734_2 as u128, 3u16);
        // D s_3734_4: cmp-eq s_3734_1 s_3734_3
        let s_3734_4: bool = ((s_3734_1) == (s_3734_3));
        // D s_3734_5: write-var gs#136074 <= s_3734_4
        fn_state.gs_136074 = s_3734_4;
        // N s_3734_6: jump b3588
        return block_3588(state, tracer, fn_state);
    }
    fn block_3735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3735_0: read-var coproc:u8
        let s_3735_0: u8 = fn_state.coproc;
        // D s_3735_1: cast zx s_3735_0 -> bv
        let s_3735_1: Bits = Bits::new(s_3735_0 as u128, 4u16);
        // C s_3735_2: const #15u : u8
        let s_3735_2: u8 = 15;
        // C s_3735_3: cast zx s_3735_2 -> bv
        let s_3735_3: Bits = Bits::new(s_3735_2 as u128, 4u16);
        // D s_3735_4: cmp-eq s_3735_1 s_3735_3
        let s_3735_4: bool = ((s_3735_1) == (s_3735_3));
        // D s_3735_5: write-var gs#136073 <= s_3735_4
        fn_state.gs_136073 = s_3735_4;
        // N s_3735_6: jump b3586
        return block_3586(state, tracer, fn_state);
    }
    fn block_3736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3736_0: read-var CRn:u8
        let s_3736_0: u8 = fn_state.CRn;
        // D s_3736_1: cast zx s_3736_0 -> bv
        let s_3736_1: Bits = Bits::new(s_3736_0 as u128, 4u16);
        // C s_3736_2: const #8u : u8
        let s_3736_2: u8 = 8;
        // C s_3736_3: cast zx s_3736_2 -> bv
        let s_3736_3: Bits = Bits::new(s_3736_2 as u128, 4u16);
        // D s_3736_4: cmp-eq s_3736_1 s_3736_3
        let s_3736_4: bool = ((s_3736_1) == (s_3736_3));
        // D s_3736_5: write-var gs#136072 <= s_3736_4
        fn_state.gs_136072 = s_3736_4;
        // N s_3736_6: jump b3584
        return block_3584(state, tracer, fn_state);
    }
    fn block_3737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3737_0: read-var el:u8
        let s_3737_0: u8 = fn_state.el;
        // D s_3737_1: read-var coproc:u8
        let s_3737_1: u8 = fn_state.coproc;
        // D s_3737_2: read-var opc1:u8
        let s_3737_2: u8 = fn_state.opc1;
        // D s_3737_3: read-var CRn:u8
        let s_3737_3: u8 = fn_state.CRn;
        // D s_3737_4: read-var opc2:u8
        let s_3737_4: u8 = fn_state.opc2;
        // D s_3737_5: read-var CRm:u8
        let s_3737_5: u8 = fn_state.CRm;
        // D s_3737_6: read-var t:i
        let s_3737_6: i128 = fn_state.t;
        // D s_3737_7: call TLBIALLIS_SysRegWrite32_26b5c3b29f92f5ea(s_3737_0, s_3737_1, s_3737_2, s_3737_3, s_3737_4, s_3737_5, s_3737_6)
        let s_3737_7: () = TLBIALLIS_SysRegWrite32_26b5c3b29f92f5ea(
            state,
            tracer,
            s_3737_0,
            s_3737_1,
            s_3737_2,
            s_3737_3,
            s_3737_4,
            s_3737_5,
            s_3737_6,
        );
        // N s_3737_8: return
        return;
    }
    fn block_3738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3738_0: read-var opc2:u8
        let s_3738_0: u8 = fn_state.opc2;
        // D s_3738_1: cast zx s_3738_0 -> bv
        let s_3738_1: Bits = Bits::new(s_3738_0 as u128, 3u16);
        // C s_3738_2: const #0u : u8
        let s_3738_2: u8 = 0;
        // C s_3738_3: cast zx s_3738_2 -> bv
        let s_3738_3: Bits = Bits::new(s_3738_2 as u128, 3u16);
        // D s_3738_4: cmp-eq s_3738_1 s_3738_3
        let s_3738_4: bool = ((s_3738_1) == (s_3738_3));
        // D s_3738_5: write-var gs#136071 <= s_3738_4
        fn_state.gs_136071 = s_3738_4;
        // N s_3738_6: jump b3581
        return block_3581(state, tracer, fn_state);
    }
    fn block_3739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3739_0: read-var opc1:u8
        let s_3739_0: u8 = fn_state.opc1;
        // D s_3739_1: cast zx s_3739_0 -> bv
        let s_3739_1: Bits = Bits::new(s_3739_0 as u128, 3u16);
        // C s_3739_2: const #0u : u8
        let s_3739_2: u8 = 0;
        // C s_3739_3: cast zx s_3739_2 -> bv
        let s_3739_3: Bits = Bits::new(s_3739_2 as u128, 3u16);
        // D s_3739_4: cmp-eq s_3739_1 s_3739_3
        let s_3739_4: bool = ((s_3739_1) == (s_3739_3));
        // D s_3739_5: write-var gs#136070 <= s_3739_4
        fn_state.gs_136070 = s_3739_4;
        // N s_3739_6: jump b3579
        return block_3579(state, tracer, fn_state);
    }
    fn block_3740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3740_0: read-var coproc:u8
        let s_3740_0: u8 = fn_state.coproc;
        // D s_3740_1: cast zx s_3740_0 -> bv
        let s_3740_1: Bits = Bits::new(s_3740_0 as u128, 4u16);
        // C s_3740_2: const #15u : u8
        let s_3740_2: u8 = 15;
        // C s_3740_3: cast zx s_3740_2 -> bv
        let s_3740_3: Bits = Bits::new(s_3740_2 as u128, 4u16);
        // D s_3740_4: cmp-eq s_3740_1 s_3740_3
        let s_3740_4: bool = ((s_3740_1) == (s_3740_3));
        // D s_3740_5: write-var gs#136069 <= s_3740_4
        fn_state.gs_136069 = s_3740_4;
        // N s_3740_6: jump b3577
        return block_3577(state, tracer, fn_state);
    }
    fn block_3741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3741_0: read-var CRn:u8
        let s_3741_0: u8 = fn_state.CRn;
        // D s_3741_1: cast zx s_3741_0 -> bv
        let s_3741_1: Bits = Bits::new(s_3741_0 as u128, 4u16);
        // C s_3741_2: const #8u : u8
        let s_3741_2: u8 = 8;
        // C s_3741_3: cast zx s_3741_2 -> bv
        let s_3741_3: Bits = Bits::new(s_3741_2 as u128, 4u16);
        // D s_3741_4: cmp-eq s_3741_1 s_3741_3
        let s_3741_4: bool = ((s_3741_1) == (s_3741_3));
        // D s_3741_5: write-var gs#136068 <= s_3741_4
        fn_state.gs_136068 = s_3741_4;
        // N s_3741_6: jump b3575
        return block_3575(state, tracer, fn_state);
    }
    fn block_3742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3742_0: read-var el:u8
        let s_3742_0: u8 = fn_state.el;
        // D s_3742_1: read-var coproc:u8
        let s_3742_1: u8 = fn_state.coproc;
        // D s_3742_2: read-var opc1:u8
        let s_3742_2: u8 = fn_state.opc1;
        // D s_3742_3: read-var CRn:u8
        let s_3742_3: u8 = fn_state.CRn;
        // D s_3742_4: read-var opc2:u8
        let s_3742_4: u8 = fn_state.opc2;
        // D s_3742_5: read-var CRm:u8
        let s_3742_5: u8 = fn_state.CRm;
        // D s_3742_6: read-var t:i
        let s_3742_6: i128 = fn_state.t;
        // D s_3742_7: call TLBIALLHIS_SysRegWrite32_3f104fb53eee9e89(s_3742_0, s_3742_1, s_3742_2, s_3742_3, s_3742_4, s_3742_5, s_3742_6)
        let s_3742_7: () = TLBIALLHIS_SysRegWrite32_3f104fb53eee9e89(
            state,
            tracer,
            s_3742_0,
            s_3742_1,
            s_3742_2,
            s_3742_3,
            s_3742_4,
            s_3742_5,
            s_3742_6,
        );
        // N s_3742_8: return
        return;
    }
    fn block_3743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3743_0: read-var opc2:u8
        let s_3743_0: u8 = fn_state.opc2;
        // D s_3743_1: cast zx s_3743_0 -> bv
        let s_3743_1: Bits = Bits::new(s_3743_0 as u128, 3u16);
        // C s_3743_2: const #0u : u8
        let s_3743_2: u8 = 0;
        // C s_3743_3: cast zx s_3743_2 -> bv
        let s_3743_3: Bits = Bits::new(s_3743_2 as u128, 3u16);
        // D s_3743_4: cmp-eq s_3743_1 s_3743_3
        let s_3743_4: bool = ((s_3743_1) == (s_3743_3));
        // D s_3743_5: write-var gs#136067 <= s_3743_4
        fn_state.gs_136067 = s_3743_4;
        // N s_3743_6: jump b3572
        return block_3572(state, tracer, fn_state);
    }
    fn block_3744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3744_0: read-var opc1:u8
        let s_3744_0: u8 = fn_state.opc1;
        // D s_3744_1: cast zx s_3744_0 -> bv
        let s_3744_1: Bits = Bits::new(s_3744_0 as u128, 3u16);
        // C s_3744_2: const #4u : u8
        let s_3744_2: u8 = 4;
        // C s_3744_3: cast zx s_3744_2 -> bv
        let s_3744_3: Bits = Bits::new(s_3744_2 as u128, 3u16);
        // D s_3744_4: cmp-eq s_3744_1 s_3744_3
        let s_3744_4: bool = ((s_3744_1) == (s_3744_3));
        // D s_3744_5: write-var gs#136066 <= s_3744_4
        fn_state.gs_136066 = s_3744_4;
        // N s_3744_6: jump b3570
        return block_3570(state, tracer, fn_state);
    }
    fn block_3745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3745_0: read-var coproc:u8
        let s_3745_0: u8 = fn_state.coproc;
        // D s_3745_1: cast zx s_3745_0 -> bv
        let s_3745_1: Bits = Bits::new(s_3745_0 as u128, 4u16);
        // C s_3745_2: const #15u : u8
        let s_3745_2: u8 = 15;
        // C s_3745_3: cast zx s_3745_2 -> bv
        let s_3745_3: Bits = Bits::new(s_3745_2 as u128, 4u16);
        // D s_3745_4: cmp-eq s_3745_1 s_3745_3
        let s_3745_4: bool = ((s_3745_1) == (s_3745_3));
        // D s_3745_5: write-var gs#136065 <= s_3745_4
        fn_state.gs_136065 = s_3745_4;
        // N s_3745_6: jump b3568
        return block_3568(state, tracer, fn_state);
    }
    fn block_3746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3746_0: read-var CRn:u8
        let s_3746_0: u8 = fn_state.CRn;
        // D s_3746_1: cast zx s_3746_0 -> bv
        let s_3746_1: Bits = Bits::new(s_3746_0 as u128, 4u16);
        // C s_3746_2: const #8u : u8
        let s_3746_2: u8 = 8;
        // C s_3746_3: cast zx s_3746_2 -> bv
        let s_3746_3: Bits = Bits::new(s_3746_2 as u128, 4u16);
        // D s_3746_4: cmp-eq s_3746_1 s_3746_3
        let s_3746_4: bool = ((s_3746_1) == (s_3746_3));
        // D s_3746_5: write-var gs#136064 <= s_3746_4
        fn_state.gs_136064 = s_3746_4;
        // N s_3746_6: jump b3566
        return block_3566(state, tracer, fn_state);
    }
    fn block_3747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3747_0: read-var el:u8
        let s_3747_0: u8 = fn_state.el;
        // D s_3747_1: read-var coproc:u8
        let s_3747_1: u8 = fn_state.coproc;
        // D s_3747_2: read-var opc1:u8
        let s_3747_2: u8 = fn_state.opc1;
        // D s_3747_3: read-var CRn:u8
        let s_3747_3: u8 = fn_state.CRn;
        // D s_3747_4: read-var opc2:u8
        let s_3747_4: u8 = fn_state.opc2;
        // D s_3747_5: read-var CRm:u8
        let s_3747_5: u8 = fn_state.CRm;
        // D s_3747_6: read-var t:i
        let s_3747_6: i128 = fn_state.t;
        // D s_3747_7: call CP15DSB_SysRegWrite32_e8d50e04da138ecc(s_3747_0, s_3747_1, s_3747_2, s_3747_3, s_3747_4, s_3747_5, s_3747_6)
        let s_3747_7: () = CP15DSB_SysRegWrite32_e8d50e04da138ecc(
            state,
            tracer,
            s_3747_0,
            s_3747_1,
            s_3747_2,
            s_3747_3,
            s_3747_4,
            s_3747_5,
            s_3747_6,
        );
        // N s_3747_8: return
        return;
    }
    fn block_3748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3748_0: read-var opc2:u8
        let s_3748_0: u8 = fn_state.opc2;
        // D s_3748_1: cast zx s_3748_0 -> bv
        let s_3748_1: Bits = Bits::new(s_3748_0 as u128, 3u16);
        // C s_3748_2: const #4u : u8
        let s_3748_2: u8 = 4;
        // C s_3748_3: cast zx s_3748_2 -> bv
        let s_3748_3: Bits = Bits::new(s_3748_2 as u128, 3u16);
        // D s_3748_4: cmp-eq s_3748_1 s_3748_3
        let s_3748_4: bool = ((s_3748_1) == (s_3748_3));
        // D s_3748_5: write-var gs#136063 <= s_3748_4
        fn_state.gs_136063 = s_3748_4;
        // N s_3748_6: jump b3563
        return block_3563(state, tracer, fn_state);
    }
    fn block_3749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3749_0: read-var opc1:u8
        let s_3749_0: u8 = fn_state.opc1;
        // D s_3749_1: cast zx s_3749_0 -> bv
        let s_3749_1: Bits = Bits::new(s_3749_0 as u128, 3u16);
        // C s_3749_2: const #0u : u8
        let s_3749_2: u8 = 0;
        // C s_3749_3: cast zx s_3749_2 -> bv
        let s_3749_3: Bits = Bits::new(s_3749_2 as u128, 3u16);
        // D s_3749_4: cmp-eq s_3749_1 s_3749_3
        let s_3749_4: bool = ((s_3749_1) == (s_3749_3));
        // D s_3749_5: write-var gs#136062 <= s_3749_4
        fn_state.gs_136062 = s_3749_4;
        // N s_3749_6: jump b3561
        return block_3561(state, tracer, fn_state);
    }
    fn block_3750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3750_0: read-var coproc:u8
        let s_3750_0: u8 = fn_state.coproc;
        // D s_3750_1: cast zx s_3750_0 -> bv
        let s_3750_1: Bits = Bits::new(s_3750_0 as u128, 4u16);
        // C s_3750_2: const #15u : u8
        let s_3750_2: u8 = 15;
        // C s_3750_3: cast zx s_3750_2 -> bv
        let s_3750_3: Bits = Bits::new(s_3750_2 as u128, 4u16);
        // D s_3750_4: cmp-eq s_3750_1 s_3750_3
        let s_3750_4: bool = ((s_3750_1) == (s_3750_3));
        // D s_3750_5: write-var gs#136061 <= s_3750_4
        fn_state.gs_136061 = s_3750_4;
        // N s_3750_6: jump b3559
        return block_3559(state, tracer, fn_state);
    }
    fn block_3751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3751_0: read-var CRn:u8
        let s_3751_0: u8 = fn_state.CRn;
        // D s_3751_1: cast zx s_3751_0 -> bv
        let s_3751_1: Bits = Bits::new(s_3751_0 as u128, 4u16);
        // C s_3751_2: const #7u : u8
        let s_3751_2: u8 = 7;
        // C s_3751_3: cast zx s_3751_2 -> bv
        let s_3751_3: Bits = Bits::new(s_3751_2 as u128, 4u16);
        // D s_3751_4: cmp-eq s_3751_1 s_3751_3
        let s_3751_4: bool = ((s_3751_1) == (s_3751_3));
        // D s_3751_5: write-var gs#136060 <= s_3751_4
        fn_state.gs_136060 = s_3751_4;
        // N s_3751_6: jump b3557
        return block_3557(state, tracer, fn_state);
    }
    fn block_3752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3752_0: read-var el:u8
        let s_3752_0: u8 = fn_state.el;
        // D s_3752_1: read-var coproc:u8
        let s_3752_1: u8 = fn_state.coproc;
        // D s_3752_2: read-var opc1:u8
        let s_3752_2: u8 = fn_state.opc1;
        // D s_3752_3: read-var CRn:u8
        let s_3752_3: u8 = fn_state.CRn;
        // D s_3752_4: read-var opc2:u8
        let s_3752_4: u8 = fn_state.opc2;
        // D s_3752_5: read-var CRm:u8
        let s_3752_5: u8 = fn_state.CRm;
        // D s_3752_6: read-var t:i
        let s_3752_6: i128 = fn_state.t;
        // D s_3752_7: call TLBIALL_SysRegWrite32_b21af7f2b4a8cf08(s_3752_0, s_3752_1, s_3752_2, s_3752_3, s_3752_4, s_3752_5, s_3752_6)
        let s_3752_7: () = TLBIALL_SysRegWrite32_b21af7f2b4a8cf08(
            state,
            tracer,
            s_3752_0,
            s_3752_1,
            s_3752_2,
            s_3752_3,
            s_3752_4,
            s_3752_5,
            s_3752_6,
        );
        // N s_3752_8: return
        return;
    }
    fn block_3753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3753_0: read-var opc2:u8
        let s_3753_0: u8 = fn_state.opc2;
        // D s_3753_1: cast zx s_3753_0 -> bv
        let s_3753_1: Bits = Bits::new(s_3753_0 as u128, 3u16);
        // C s_3753_2: const #0u : u8
        let s_3753_2: u8 = 0;
        // C s_3753_3: cast zx s_3753_2 -> bv
        let s_3753_3: Bits = Bits::new(s_3753_2 as u128, 3u16);
        // D s_3753_4: cmp-eq s_3753_1 s_3753_3
        let s_3753_4: bool = ((s_3753_1) == (s_3753_3));
        // D s_3753_5: write-var gs#136059 <= s_3753_4
        fn_state.gs_136059 = s_3753_4;
        // N s_3753_6: jump b3554
        return block_3554(state, tracer, fn_state);
    }
    fn block_3754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3754_0: read-var opc1:u8
        let s_3754_0: u8 = fn_state.opc1;
        // D s_3754_1: cast zx s_3754_0 -> bv
        let s_3754_1: Bits = Bits::new(s_3754_0 as u128, 3u16);
        // C s_3754_2: const #0u : u8
        let s_3754_2: u8 = 0;
        // C s_3754_3: cast zx s_3754_2 -> bv
        let s_3754_3: Bits = Bits::new(s_3754_2 as u128, 3u16);
        // D s_3754_4: cmp-eq s_3754_1 s_3754_3
        let s_3754_4: bool = ((s_3754_1) == (s_3754_3));
        // D s_3754_5: write-var gs#136058 <= s_3754_4
        fn_state.gs_136058 = s_3754_4;
        // N s_3754_6: jump b3552
        return block_3552(state, tracer, fn_state);
    }
    fn block_3755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3755_0: read-var coproc:u8
        let s_3755_0: u8 = fn_state.coproc;
        // D s_3755_1: cast zx s_3755_0 -> bv
        let s_3755_1: Bits = Bits::new(s_3755_0 as u128, 4u16);
        // C s_3755_2: const #15u : u8
        let s_3755_2: u8 = 15;
        // C s_3755_3: cast zx s_3755_2 -> bv
        let s_3755_3: Bits = Bits::new(s_3755_2 as u128, 4u16);
        // D s_3755_4: cmp-eq s_3755_1 s_3755_3
        let s_3755_4: bool = ((s_3755_1) == (s_3755_3));
        // D s_3755_5: write-var gs#136057 <= s_3755_4
        fn_state.gs_136057 = s_3755_4;
        // N s_3755_6: jump b3550
        return block_3550(state, tracer, fn_state);
    }
    fn block_3756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3756_0: read-var CRn:u8
        let s_3756_0: u8 = fn_state.CRn;
        // D s_3756_1: cast zx s_3756_0 -> bv
        let s_3756_1: Bits = Bits::new(s_3756_0 as u128, 4u16);
        // C s_3756_2: const #8u : u8
        let s_3756_2: u8 = 8;
        // C s_3756_3: cast zx s_3756_2 -> bv
        let s_3756_3: Bits = Bits::new(s_3756_2 as u128, 4u16);
        // D s_3756_4: cmp-eq s_3756_1 s_3756_3
        let s_3756_4: bool = ((s_3756_1) == (s_3756_3));
        // D s_3756_5: write-var gs#136056 <= s_3756_4
        fn_state.gs_136056 = s_3756_4;
        // N s_3756_6: jump b3548
        return block_3548(state, tracer, fn_state);
    }
    fn block_3757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3757_0: read-var el:u8
        let s_3757_0: u8 = fn_state.el;
        // D s_3757_1: read-var coproc:u8
        let s_3757_1: u8 = fn_state.coproc;
        // D s_3757_2: read-var opc1:u8
        let s_3757_2: u8 = fn_state.opc1;
        // D s_3757_3: read-var CRn:u8
        let s_3757_3: u8 = fn_state.CRn;
        // D s_3757_4: read-var opc2:u8
        let s_3757_4: u8 = fn_state.opc2;
        // D s_3757_5: read-var CRm:u8
        let s_3757_5: u8 = fn_state.CRm;
        // D s_3757_6: read-var t:i
        let s_3757_6: i128 = fn_state.t;
        // D s_3757_7: call HACTLR2_SysRegWrite32_a03973fca410ae10(s_3757_0, s_3757_1, s_3757_2, s_3757_3, s_3757_4, s_3757_5, s_3757_6)
        let s_3757_7: () = HACTLR2_SysRegWrite32_a03973fca410ae10(
            state,
            tracer,
            s_3757_0,
            s_3757_1,
            s_3757_2,
            s_3757_3,
            s_3757_4,
            s_3757_5,
            s_3757_6,
        );
        // N s_3757_8: return
        return;
    }
    fn block_3758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3758_0: read-var opc2:u8
        let s_3758_0: u8 = fn_state.opc2;
        // D s_3758_1: cast zx s_3758_0 -> bv
        let s_3758_1: Bits = Bits::new(s_3758_0 as u128, 3u16);
        // C s_3758_2: const #3u : u8
        let s_3758_2: u8 = 3;
        // C s_3758_3: cast zx s_3758_2 -> bv
        let s_3758_3: Bits = Bits::new(s_3758_2 as u128, 3u16);
        // D s_3758_4: cmp-eq s_3758_1 s_3758_3
        let s_3758_4: bool = ((s_3758_1) == (s_3758_3));
        // D s_3758_5: write-var gs#136055 <= s_3758_4
        fn_state.gs_136055 = s_3758_4;
        // N s_3758_6: jump b3545
        return block_3545(state, tracer, fn_state);
    }
    fn block_3759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3759_0: read-var opc1:u8
        let s_3759_0: u8 = fn_state.opc1;
        // D s_3759_1: cast zx s_3759_0 -> bv
        let s_3759_1: Bits = Bits::new(s_3759_0 as u128, 3u16);
        // C s_3759_2: const #4u : u8
        let s_3759_2: u8 = 4;
        // C s_3759_3: cast zx s_3759_2 -> bv
        let s_3759_3: Bits = Bits::new(s_3759_2 as u128, 3u16);
        // D s_3759_4: cmp-eq s_3759_1 s_3759_3
        let s_3759_4: bool = ((s_3759_1) == (s_3759_3));
        // D s_3759_5: write-var gs#136054 <= s_3759_4
        fn_state.gs_136054 = s_3759_4;
        // N s_3759_6: jump b3543
        return block_3543(state, tracer, fn_state);
    }
    fn block_3760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3760_0: read-var coproc:u8
        let s_3760_0: u8 = fn_state.coproc;
        // D s_3760_1: cast zx s_3760_0 -> bv
        let s_3760_1: Bits = Bits::new(s_3760_0 as u128, 4u16);
        // C s_3760_2: const #15u : u8
        let s_3760_2: u8 = 15;
        // C s_3760_3: cast zx s_3760_2 -> bv
        let s_3760_3: Bits = Bits::new(s_3760_2 as u128, 4u16);
        // D s_3760_4: cmp-eq s_3760_1 s_3760_3
        let s_3760_4: bool = ((s_3760_1) == (s_3760_3));
        // D s_3760_5: write-var gs#136053 <= s_3760_4
        fn_state.gs_136053 = s_3760_4;
        // N s_3760_6: jump b3541
        return block_3541(state, tracer, fn_state);
    }
    fn block_3761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3761_0: read-var CRn:u8
        let s_3761_0: u8 = fn_state.CRn;
        // D s_3761_1: cast zx s_3761_0 -> bv
        let s_3761_1: Bits = Bits::new(s_3761_0 as u128, 4u16);
        // C s_3761_2: const #1u : u8
        let s_3761_2: u8 = 1;
        // C s_3761_3: cast zx s_3761_2 -> bv
        let s_3761_3: Bits = Bits::new(s_3761_2 as u128, 4u16);
        // D s_3761_4: cmp-eq s_3761_1 s_3761_3
        let s_3761_4: bool = ((s_3761_1) == (s_3761_3));
        // D s_3761_5: write-var gs#136052 <= s_3761_4
        fn_state.gs_136052 = s_3761_4;
        // N s_3761_6: jump b3539
        return block_3539(state, tracer, fn_state);
    }
    fn block_3762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3762_0: read-var el:u8
        let s_3762_0: u8 = fn_state.el;
        // D s_3762_1: read-var coproc:u8
        let s_3762_1: u8 = fn_state.coproc;
        // D s_3762_2: read-var opc1:u8
        let s_3762_2: u8 = fn_state.opc1;
        // D s_3762_3: read-var CRn:u8
        let s_3762_3: u8 = fn_state.CRn;
        // D s_3762_4: read-var opc2:u8
        let s_3762_4: u8 = fn_state.opc2;
        // D s_3762_5: read-var CRm:u8
        let s_3762_5: u8 = fn_state.CRm;
        // D s_3762_6: read-var t:i
        let s_3762_6: i128 = fn_state.t;
        // D s_3762_7: call ERXSTATUS_SysRegWrite32_5cd309fb6a56ceb4(s_3762_0, s_3762_1, s_3762_2, s_3762_3, s_3762_4, s_3762_5, s_3762_6)
        let s_3762_7: () = ERXSTATUS_SysRegWrite32_5cd309fb6a56ceb4(
            state,
            tracer,
            s_3762_0,
            s_3762_1,
            s_3762_2,
            s_3762_3,
            s_3762_4,
            s_3762_5,
            s_3762_6,
        );
        // N s_3762_8: return
        return;
    }
    fn block_3763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3763_0: read-var opc2:u8
        let s_3763_0: u8 = fn_state.opc2;
        // D s_3763_1: cast zx s_3763_0 -> bv
        let s_3763_1: Bits = Bits::new(s_3763_0 as u128, 3u16);
        // C s_3763_2: const #2u : u8
        let s_3763_2: u8 = 2;
        // C s_3763_3: cast zx s_3763_2 -> bv
        let s_3763_3: Bits = Bits::new(s_3763_2 as u128, 3u16);
        // D s_3763_4: cmp-eq s_3763_1 s_3763_3
        let s_3763_4: bool = ((s_3763_1) == (s_3763_3));
        // D s_3763_5: write-var gs#136051 <= s_3763_4
        fn_state.gs_136051 = s_3763_4;
        // N s_3763_6: jump b3536
        return block_3536(state, tracer, fn_state);
    }
    fn block_3764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3764_0: read-var opc1:u8
        let s_3764_0: u8 = fn_state.opc1;
        // D s_3764_1: cast zx s_3764_0 -> bv
        let s_3764_1: Bits = Bits::new(s_3764_0 as u128, 3u16);
        // C s_3764_2: const #0u : u8
        let s_3764_2: u8 = 0;
        // C s_3764_3: cast zx s_3764_2 -> bv
        let s_3764_3: Bits = Bits::new(s_3764_2 as u128, 3u16);
        // D s_3764_4: cmp-eq s_3764_1 s_3764_3
        let s_3764_4: bool = ((s_3764_1) == (s_3764_3));
        // D s_3764_5: write-var gs#136050 <= s_3764_4
        fn_state.gs_136050 = s_3764_4;
        // N s_3764_6: jump b3534
        return block_3534(state, tracer, fn_state);
    }
    fn block_3765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3765_0: read-var coproc:u8
        let s_3765_0: u8 = fn_state.coproc;
        // D s_3765_1: cast zx s_3765_0 -> bv
        let s_3765_1: Bits = Bits::new(s_3765_0 as u128, 4u16);
        // C s_3765_2: const #15u : u8
        let s_3765_2: u8 = 15;
        // C s_3765_3: cast zx s_3765_2 -> bv
        let s_3765_3: Bits = Bits::new(s_3765_2 as u128, 4u16);
        // D s_3765_4: cmp-eq s_3765_1 s_3765_3
        let s_3765_4: bool = ((s_3765_1) == (s_3765_3));
        // D s_3765_5: write-var gs#136049 <= s_3765_4
        fn_state.gs_136049 = s_3765_4;
        // N s_3765_6: jump b3532
        return block_3532(state, tracer, fn_state);
    }
    fn block_3766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3766_0: read-var CRn:u8
        let s_3766_0: u8 = fn_state.CRn;
        // D s_3766_1: cast zx s_3766_0 -> bv
        let s_3766_1: Bits = Bits::new(s_3766_0 as u128, 4u16);
        // C s_3766_2: const #5u : u8
        let s_3766_2: u8 = 5;
        // C s_3766_3: cast zx s_3766_2 -> bv
        let s_3766_3: Bits = Bits::new(s_3766_2 as u128, 4u16);
        // D s_3766_4: cmp-eq s_3766_1 s_3766_3
        let s_3766_4: bool = ((s_3766_1) == (s_3766_3));
        // D s_3766_5: write-var gs#136048 <= s_3766_4
        fn_state.gs_136048 = s_3766_4;
        // N s_3766_6: jump b3530
        return block_3530(state, tracer, fn_state);
    }
    fn block_3767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3767_0: read-var el:u8
        let s_3767_0: u8 = fn_state.el;
        // D s_3767_1: read-var coproc:u8
        let s_3767_1: u8 = fn_state.coproc;
        // D s_3767_2: read-var opc1:u8
        let s_3767_2: u8 = fn_state.opc1;
        // D s_3767_3: read-var CRn:u8
        let s_3767_3: u8 = fn_state.CRn;
        // D s_3767_4: read-var opc2:u8
        let s_3767_4: u8 = fn_state.opc2;
        // D s_3767_5: read-var CRm:u8
        let s_3767_5: u8 = fn_state.CRm;
        // D s_3767_6: read-var t:i
        let s_3767_6: i128 = fn_state.t;
        // D s_3767_7: call VDISR_SysRegWrite32_d6e68a15b17084cf(s_3767_0, s_3767_1, s_3767_2, s_3767_3, s_3767_4, s_3767_5, s_3767_6)
        let s_3767_7: () = VDISR_SysRegWrite32_d6e68a15b17084cf(
            state,
            tracer,
            s_3767_0,
            s_3767_1,
            s_3767_2,
            s_3767_3,
            s_3767_4,
            s_3767_5,
            s_3767_6,
        );
        // N s_3767_8: return
        return;
    }
    fn block_3768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3768_0: read-var opc2:u8
        let s_3768_0: u8 = fn_state.opc2;
        // D s_3768_1: cast zx s_3768_0 -> bv
        let s_3768_1: Bits = Bits::new(s_3768_0 as u128, 3u16);
        // C s_3768_2: const #1u : u8
        let s_3768_2: u8 = 1;
        // C s_3768_3: cast zx s_3768_2 -> bv
        let s_3768_3: Bits = Bits::new(s_3768_2 as u128, 3u16);
        // D s_3768_4: cmp-eq s_3768_1 s_3768_3
        let s_3768_4: bool = ((s_3768_1) == (s_3768_3));
        // D s_3768_5: write-var gs#136047 <= s_3768_4
        fn_state.gs_136047 = s_3768_4;
        // N s_3768_6: jump b3527
        return block_3527(state, tracer, fn_state);
    }
    fn block_3769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3769_0: read-var opc1:u8
        let s_3769_0: u8 = fn_state.opc1;
        // D s_3769_1: cast zx s_3769_0 -> bv
        let s_3769_1: Bits = Bits::new(s_3769_0 as u128, 3u16);
        // C s_3769_2: const #4u : u8
        let s_3769_2: u8 = 4;
        // C s_3769_3: cast zx s_3769_2 -> bv
        let s_3769_3: Bits = Bits::new(s_3769_2 as u128, 3u16);
        // D s_3769_4: cmp-eq s_3769_1 s_3769_3
        let s_3769_4: bool = ((s_3769_1) == (s_3769_3));
        // D s_3769_5: write-var gs#136046 <= s_3769_4
        fn_state.gs_136046 = s_3769_4;
        // N s_3769_6: jump b3525
        return block_3525(state, tracer, fn_state);
    }
    fn block_3770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3770_0: read-var coproc:u8
        let s_3770_0: u8 = fn_state.coproc;
        // D s_3770_1: cast zx s_3770_0 -> bv
        let s_3770_1: Bits = Bits::new(s_3770_0 as u128, 4u16);
        // C s_3770_2: const #15u : u8
        let s_3770_2: u8 = 15;
        // C s_3770_3: cast zx s_3770_2 -> bv
        let s_3770_3: Bits = Bits::new(s_3770_2 as u128, 4u16);
        // D s_3770_4: cmp-eq s_3770_1 s_3770_3
        let s_3770_4: bool = ((s_3770_1) == (s_3770_3));
        // D s_3770_5: write-var gs#136045 <= s_3770_4
        fn_state.gs_136045 = s_3770_4;
        // N s_3770_6: jump b3523
        return block_3523(state, tracer, fn_state);
    }
    fn block_3771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3771_0: read-var CRn:u8
        let s_3771_0: u8 = fn_state.CRn;
        // D s_3771_1: cast zx s_3771_0 -> bv
        let s_3771_1: Bits = Bits::new(s_3771_0 as u128, 4u16);
        // C s_3771_2: const #12u : u8
        let s_3771_2: u8 = 12;
        // C s_3771_3: cast zx s_3771_2 -> bv
        let s_3771_3: Bits = Bits::new(s_3771_2 as u128, 4u16);
        // D s_3771_4: cmp-eq s_3771_1 s_3771_3
        let s_3771_4: bool = ((s_3771_1) == (s_3771_3));
        // D s_3771_5: write-var gs#136044 <= s_3771_4
        fn_state.gs_136044 = s_3771_4;
        // N s_3771_6: jump b3521
        return block_3521(state, tracer, fn_state);
    }
    fn block_3772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3772_0: read-var el:u8
        let s_3772_0: u8 = fn_state.el;
        // D s_3772_1: read-var coproc:u8
        let s_3772_1: u8 = fn_state.coproc;
        // D s_3772_2: read-var opc1:u8
        let s_3772_2: u8 = fn_state.opc1;
        // D s_3772_3: read-var CRn:u8
        let s_3772_3: u8 = fn_state.CRn;
        // D s_3772_4: read-var opc2:u8
        let s_3772_4: u8 = fn_state.opc2;
        // D s_3772_5: read-var CRm:u8
        let s_3772_5: u8 = fn_state.CRm;
        // D s_3772_6: read-var t:i
        let s_3772_6: i128 = fn_state.t;
        // D s_3772_7: call ERXMISC3_SysRegWrite32_427198a3f5bc0b89(s_3772_0, s_3772_1, s_3772_2, s_3772_3, s_3772_4, s_3772_5, s_3772_6)
        let s_3772_7: () = ERXMISC3_SysRegWrite32_427198a3f5bc0b89(
            state,
            tracer,
            s_3772_0,
            s_3772_1,
            s_3772_2,
            s_3772_3,
            s_3772_4,
            s_3772_5,
            s_3772_6,
        );
        // N s_3772_8: return
        return;
    }
    fn block_3773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3773_0: read-var opc2:u8
        let s_3773_0: u8 = fn_state.opc2;
        // D s_3773_1: cast zx s_3773_0 -> bv
        let s_3773_1: Bits = Bits::new(s_3773_0 as u128, 3u16);
        // C s_3773_2: const #5u : u8
        let s_3773_2: u8 = 5;
        // C s_3773_3: cast zx s_3773_2 -> bv
        let s_3773_3: Bits = Bits::new(s_3773_2 as u128, 3u16);
        // D s_3773_4: cmp-eq s_3773_1 s_3773_3
        let s_3773_4: bool = ((s_3773_1) == (s_3773_3));
        // D s_3773_5: write-var gs#136043 <= s_3773_4
        fn_state.gs_136043 = s_3773_4;
        // N s_3773_6: jump b3518
        return block_3518(state, tracer, fn_state);
    }
    fn block_3774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3774_0: read-var opc1:u8
        let s_3774_0: u8 = fn_state.opc1;
        // D s_3774_1: cast zx s_3774_0 -> bv
        let s_3774_1: Bits = Bits::new(s_3774_0 as u128, 3u16);
        // C s_3774_2: const #0u : u8
        let s_3774_2: u8 = 0;
        // C s_3774_3: cast zx s_3774_2 -> bv
        let s_3774_3: Bits = Bits::new(s_3774_2 as u128, 3u16);
        // D s_3774_4: cmp-eq s_3774_1 s_3774_3
        let s_3774_4: bool = ((s_3774_1) == (s_3774_3));
        // D s_3774_5: write-var gs#136042 <= s_3774_4
        fn_state.gs_136042 = s_3774_4;
        // N s_3774_6: jump b3516
        return block_3516(state, tracer, fn_state);
    }
    fn block_3775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3775_0: read-var coproc:u8
        let s_3775_0: u8 = fn_state.coproc;
        // D s_3775_1: cast zx s_3775_0 -> bv
        let s_3775_1: Bits = Bits::new(s_3775_0 as u128, 4u16);
        // C s_3775_2: const #15u : u8
        let s_3775_2: u8 = 15;
        // C s_3775_3: cast zx s_3775_2 -> bv
        let s_3775_3: Bits = Bits::new(s_3775_2 as u128, 4u16);
        // D s_3775_4: cmp-eq s_3775_1 s_3775_3
        let s_3775_4: bool = ((s_3775_1) == (s_3775_3));
        // D s_3775_5: write-var gs#136041 <= s_3775_4
        fn_state.gs_136041 = s_3775_4;
        // N s_3775_6: jump b3514
        return block_3514(state, tracer, fn_state);
    }
    fn block_3776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3776_0: read-var CRn:u8
        let s_3776_0: u8 = fn_state.CRn;
        // D s_3776_1: cast zx s_3776_0 -> bv
        let s_3776_1: Bits = Bits::new(s_3776_0 as u128, 4u16);
        // C s_3776_2: const #5u : u8
        let s_3776_2: u8 = 5;
        // C s_3776_3: cast zx s_3776_2 -> bv
        let s_3776_3: Bits = Bits::new(s_3776_2 as u128, 4u16);
        // D s_3776_4: cmp-eq s_3776_1 s_3776_3
        let s_3776_4: bool = ((s_3776_1) == (s_3776_3));
        // D s_3776_5: write-var gs#136040 <= s_3776_4
        fn_state.gs_136040 = s_3776_4;
        // N s_3776_6: jump b3512
        return block_3512(state, tracer, fn_state);
    }
    fn block_3777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3777_0: read-var el:u8
        let s_3777_0: u8 = fn_state.el;
        // D s_3777_1: read-var coproc:u8
        let s_3777_1: u8 = fn_state.coproc;
        // D s_3777_2: read-var opc1:u8
        let s_3777_2: u8 = fn_state.opc1;
        // D s_3777_3: read-var CRn:u8
        let s_3777_3: u8 = fn_state.CRn;
        // D s_3777_4: read-var opc2:u8
        let s_3777_4: u8 = fn_state.opc2;
        // D s_3777_5: read-var CRm:u8
        let s_3777_5: u8 = fn_state.CRm;
        // D s_3777_6: read-var t:i
        let s_3777_6: i128 = fn_state.t;
        // D s_3777_7: call ERXMISC7_SysRegWrite32_f7f96f4da3e8ae5b(s_3777_0, s_3777_1, s_3777_2, s_3777_3, s_3777_4, s_3777_5, s_3777_6)
        let s_3777_7: () = ERXMISC7_SysRegWrite32_f7f96f4da3e8ae5b(
            state,
            tracer,
            s_3777_0,
            s_3777_1,
            s_3777_2,
            s_3777_3,
            s_3777_4,
            s_3777_5,
            s_3777_6,
        );
        // N s_3777_8: return
        return;
    }
    fn block_3778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3778_0: read-var opc2:u8
        let s_3778_0: u8 = fn_state.opc2;
        // D s_3778_1: cast zx s_3778_0 -> bv
        let s_3778_1: Bits = Bits::new(s_3778_0 as u128, 3u16);
        // C s_3778_2: const #7u : u8
        let s_3778_2: u8 = 7;
        // C s_3778_3: cast zx s_3778_2 -> bv
        let s_3778_3: Bits = Bits::new(s_3778_2 as u128, 3u16);
        // D s_3778_4: cmp-eq s_3778_1 s_3778_3
        let s_3778_4: bool = ((s_3778_1) == (s_3778_3));
        // D s_3778_5: write-var gs#136039 <= s_3778_4
        fn_state.gs_136039 = s_3778_4;
        // N s_3778_6: jump b3509
        return block_3509(state, tracer, fn_state);
    }
    fn block_3779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3779_0: read-var opc1:u8
        let s_3779_0: u8 = fn_state.opc1;
        // D s_3779_1: cast zx s_3779_0 -> bv
        let s_3779_1: Bits = Bits::new(s_3779_0 as u128, 3u16);
        // C s_3779_2: const #0u : u8
        let s_3779_2: u8 = 0;
        // C s_3779_3: cast zx s_3779_2 -> bv
        let s_3779_3: Bits = Bits::new(s_3779_2 as u128, 3u16);
        // D s_3779_4: cmp-eq s_3779_1 s_3779_3
        let s_3779_4: bool = ((s_3779_1) == (s_3779_3));
        // D s_3779_5: write-var gs#136038 <= s_3779_4
        fn_state.gs_136038 = s_3779_4;
        // N s_3779_6: jump b3507
        return block_3507(state, tracer, fn_state);
    }
    fn block_3780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3780_0: read-var coproc:u8
        let s_3780_0: u8 = fn_state.coproc;
        // D s_3780_1: cast zx s_3780_0 -> bv
        let s_3780_1: Bits = Bits::new(s_3780_0 as u128, 4u16);
        // C s_3780_2: const #15u : u8
        let s_3780_2: u8 = 15;
        // C s_3780_3: cast zx s_3780_2 -> bv
        let s_3780_3: Bits = Bits::new(s_3780_2 as u128, 4u16);
        // D s_3780_4: cmp-eq s_3780_1 s_3780_3
        let s_3780_4: bool = ((s_3780_1) == (s_3780_3));
        // D s_3780_5: write-var gs#136037 <= s_3780_4
        fn_state.gs_136037 = s_3780_4;
        // N s_3780_6: jump b3505
        return block_3505(state, tracer, fn_state);
    }
    fn block_3781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3781_0: read-var CRn:u8
        let s_3781_0: u8 = fn_state.CRn;
        // D s_3781_1: cast zx s_3781_0 -> bv
        let s_3781_1: Bits = Bits::new(s_3781_0 as u128, 4u16);
        // C s_3781_2: const #5u : u8
        let s_3781_2: u8 = 5;
        // C s_3781_3: cast zx s_3781_2 -> bv
        let s_3781_3: Bits = Bits::new(s_3781_2 as u128, 4u16);
        // D s_3781_4: cmp-eq s_3781_1 s_3781_3
        let s_3781_4: bool = ((s_3781_1) == (s_3781_3));
        // D s_3781_5: write-var gs#136036 <= s_3781_4
        fn_state.gs_136036 = s_3781_4;
        // N s_3781_6: jump b3503
        return block_3503(state, tracer, fn_state);
    }
    fn block_3782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3782_0: read-var el:u8
        let s_3782_0: u8 = fn_state.el;
        // D s_3782_1: read-var coproc:u8
        let s_3782_1: u8 = fn_state.coproc;
        // D s_3782_2: read-var opc1:u8
        let s_3782_2: u8 = fn_state.opc1;
        // D s_3782_3: read-var CRn:u8
        let s_3782_3: u8 = fn_state.CRn;
        // D s_3782_4: read-var opc2:u8
        let s_3782_4: u8 = fn_state.opc2;
        // D s_3782_5: read-var CRm:u8
        let s_3782_5: u8 = fn_state.CRm;
        // D s_3782_6: read-var t:i
        let s_3782_6: i128 = fn_state.t;
        // D s_3782_7: call ERXADDR2_SysRegWrite32_9f92470c72b2a640(s_3782_0, s_3782_1, s_3782_2, s_3782_3, s_3782_4, s_3782_5, s_3782_6)
        let s_3782_7: () = ERXADDR2_SysRegWrite32_9f92470c72b2a640(
            state,
            tracer,
            s_3782_0,
            s_3782_1,
            s_3782_2,
            s_3782_3,
            s_3782_4,
            s_3782_5,
            s_3782_6,
        );
        // N s_3782_8: return
        return;
    }
    fn block_3783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3783_0: read-var opc2:u8
        let s_3783_0: u8 = fn_state.opc2;
        // D s_3783_1: cast zx s_3783_0 -> bv
        let s_3783_1: Bits = Bits::new(s_3783_0 as u128, 3u16);
        // C s_3783_2: const #7u : u8
        let s_3783_2: u8 = 7;
        // C s_3783_3: cast zx s_3783_2 -> bv
        let s_3783_3: Bits = Bits::new(s_3783_2 as u128, 3u16);
        // D s_3783_4: cmp-eq s_3783_1 s_3783_3
        let s_3783_4: bool = ((s_3783_1) == (s_3783_3));
        // D s_3783_5: write-var gs#136035 <= s_3783_4
        fn_state.gs_136035 = s_3783_4;
        // N s_3783_6: jump b3500
        return block_3500(state, tracer, fn_state);
    }
    fn block_3784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3784_0: read-var opc1:u8
        let s_3784_0: u8 = fn_state.opc1;
        // D s_3784_1: cast zx s_3784_0 -> bv
        let s_3784_1: Bits = Bits::new(s_3784_0 as u128, 3u16);
        // C s_3784_2: const #0u : u8
        let s_3784_2: u8 = 0;
        // C s_3784_3: cast zx s_3784_2 -> bv
        let s_3784_3: Bits = Bits::new(s_3784_2 as u128, 3u16);
        // D s_3784_4: cmp-eq s_3784_1 s_3784_3
        let s_3784_4: bool = ((s_3784_1) == (s_3784_3));
        // D s_3784_5: write-var gs#136034 <= s_3784_4
        fn_state.gs_136034 = s_3784_4;
        // N s_3784_6: jump b3498
        return block_3498(state, tracer, fn_state);
    }
    fn block_3785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3785_0: read-var coproc:u8
        let s_3785_0: u8 = fn_state.coproc;
        // D s_3785_1: cast zx s_3785_0 -> bv
        let s_3785_1: Bits = Bits::new(s_3785_0 as u128, 4u16);
        // C s_3785_2: const #15u : u8
        let s_3785_2: u8 = 15;
        // C s_3785_3: cast zx s_3785_2 -> bv
        let s_3785_3: Bits = Bits::new(s_3785_2 as u128, 4u16);
        // D s_3785_4: cmp-eq s_3785_1 s_3785_3
        let s_3785_4: bool = ((s_3785_1) == (s_3785_3));
        // D s_3785_5: write-var gs#136033 <= s_3785_4
        fn_state.gs_136033 = s_3785_4;
        // N s_3785_6: jump b3496
        return block_3496(state, tracer, fn_state);
    }
    fn block_3786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3786_0: read-var CRn:u8
        let s_3786_0: u8 = fn_state.CRn;
        // D s_3786_1: cast zx s_3786_0 -> bv
        let s_3786_1: Bits = Bits::new(s_3786_0 as u128, 4u16);
        // C s_3786_2: const #5u : u8
        let s_3786_2: u8 = 5;
        // C s_3786_3: cast zx s_3786_2 -> bv
        let s_3786_3: Bits = Bits::new(s_3786_2 as u128, 4u16);
        // D s_3786_4: cmp-eq s_3786_1 s_3786_3
        let s_3786_4: bool = ((s_3786_1) == (s_3786_3));
        // D s_3786_5: write-var gs#136032 <= s_3786_4
        fn_state.gs_136032 = s_3786_4;
        // N s_3786_6: jump b3494
        return block_3494(state, tracer, fn_state);
    }
    fn block_3787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3787_0: read-var el:u8
        let s_3787_0: u8 = fn_state.el;
        // D s_3787_1: read-var coproc:u8
        let s_3787_1: u8 = fn_state.coproc;
        // D s_3787_2: read-var opc1:u8
        let s_3787_2: u8 = fn_state.opc1;
        // D s_3787_3: read-var CRn:u8
        let s_3787_3: u8 = fn_state.CRn;
        // D s_3787_4: read-var opc2:u8
        let s_3787_4: u8 = fn_state.opc2;
        // D s_3787_5: read-var CRm:u8
        let s_3787_5: u8 = fn_state.CRm;
        // D s_3787_6: read-var t:i
        let s_3787_6: i128 = fn_state.t;
        // D s_3787_7: call ERXMISC4_SysRegWrite32_429dc75aabc49f53(s_3787_0, s_3787_1, s_3787_2, s_3787_3, s_3787_4, s_3787_5, s_3787_6)
        let s_3787_7: () = ERXMISC4_SysRegWrite32_429dc75aabc49f53(
            state,
            tracer,
            s_3787_0,
            s_3787_1,
            s_3787_2,
            s_3787_3,
            s_3787_4,
            s_3787_5,
            s_3787_6,
        );
        // N s_3787_8: return
        return;
    }
    fn block_3788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3788_0: read-var opc2:u8
        let s_3788_0: u8 = fn_state.opc2;
        // D s_3788_1: cast zx s_3788_0 -> bv
        let s_3788_1: Bits = Bits::new(s_3788_0 as u128, 3u16);
        // C s_3788_2: const #2u : u8
        let s_3788_2: u8 = 2;
        // C s_3788_3: cast zx s_3788_2 -> bv
        let s_3788_3: Bits = Bits::new(s_3788_2 as u128, 3u16);
        // D s_3788_4: cmp-eq s_3788_1 s_3788_3
        let s_3788_4: bool = ((s_3788_1) == (s_3788_3));
        // D s_3788_5: write-var gs#136031 <= s_3788_4
        fn_state.gs_136031 = s_3788_4;
        // N s_3788_6: jump b3491
        return block_3491(state, tracer, fn_state);
    }
    fn block_3789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3789_0: read-var opc1:u8
        let s_3789_0: u8 = fn_state.opc1;
        // D s_3789_1: cast zx s_3789_0 -> bv
        let s_3789_1: Bits = Bits::new(s_3789_0 as u128, 3u16);
        // C s_3789_2: const #0u : u8
        let s_3789_2: u8 = 0;
        // C s_3789_3: cast zx s_3789_2 -> bv
        let s_3789_3: Bits = Bits::new(s_3789_2 as u128, 3u16);
        // D s_3789_4: cmp-eq s_3789_1 s_3789_3
        let s_3789_4: bool = ((s_3789_1) == (s_3789_3));
        // D s_3789_5: write-var gs#136030 <= s_3789_4
        fn_state.gs_136030 = s_3789_4;
        // N s_3789_6: jump b3489
        return block_3489(state, tracer, fn_state);
    }
    fn block_3790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3790_0: read-var coproc:u8
        let s_3790_0: u8 = fn_state.coproc;
        // D s_3790_1: cast zx s_3790_0 -> bv
        let s_3790_1: Bits = Bits::new(s_3790_0 as u128, 4u16);
        // C s_3790_2: const #15u : u8
        let s_3790_2: u8 = 15;
        // C s_3790_3: cast zx s_3790_2 -> bv
        let s_3790_3: Bits = Bits::new(s_3790_2 as u128, 4u16);
        // D s_3790_4: cmp-eq s_3790_1 s_3790_3
        let s_3790_4: bool = ((s_3790_1) == (s_3790_3));
        // D s_3790_5: write-var gs#136029 <= s_3790_4
        fn_state.gs_136029 = s_3790_4;
        // N s_3790_6: jump b3487
        return block_3487(state, tracer, fn_state);
    }
    fn block_3791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3791_0: read-var CRn:u8
        let s_3791_0: u8 = fn_state.CRn;
        // D s_3791_1: cast zx s_3791_0 -> bv
        let s_3791_1: Bits = Bits::new(s_3791_0 as u128, 4u16);
        // C s_3791_2: const #5u : u8
        let s_3791_2: u8 = 5;
        // C s_3791_3: cast zx s_3791_2 -> bv
        let s_3791_3: Bits = Bits::new(s_3791_2 as u128, 4u16);
        // D s_3791_4: cmp-eq s_3791_1 s_3791_3
        let s_3791_4: bool = ((s_3791_1) == (s_3791_3));
        // D s_3791_5: write-var gs#136028 <= s_3791_4
        fn_state.gs_136028 = s_3791_4;
        // N s_3791_6: jump b3485
        return block_3485(state, tracer, fn_state);
    }
    fn block_3792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3792_0: read-var el:u8
        let s_3792_0: u8 = fn_state.el;
        // D s_3792_1: read-var coproc:u8
        let s_3792_1: u8 = fn_state.coproc;
        // D s_3792_2: read-var opc1:u8
        let s_3792_2: u8 = fn_state.opc1;
        // D s_3792_3: read-var CRn:u8
        let s_3792_3: u8 = fn_state.CRn;
        // D s_3792_4: read-var opc2:u8
        let s_3792_4: u8 = fn_state.opc2;
        // D s_3792_5: read-var CRm:u8
        let s_3792_5: u8 = fn_state.CRm;
        // D s_3792_6: read-var t:i
        let s_3792_6: i128 = fn_state.t;
        // D s_3792_7: call ERXMISC6_SysRegWrite32_58612120811a96a6(s_3792_0, s_3792_1, s_3792_2, s_3792_3, s_3792_4, s_3792_5, s_3792_6)
        let s_3792_7: () = ERXMISC6_SysRegWrite32_58612120811a96a6(
            state,
            tracer,
            s_3792_0,
            s_3792_1,
            s_3792_2,
            s_3792_3,
            s_3792_4,
            s_3792_5,
            s_3792_6,
        );
        // N s_3792_8: return
        return;
    }
    fn block_3793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3793_0: read-var opc2:u8
        let s_3793_0: u8 = fn_state.opc2;
        // D s_3793_1: cast zx s_3793_0 -> bv
        let s_3793_1: Bits = Bits::new(s_3793_0 as u128, 3u16);
        // C s_3793_2: const #6u : u8
        let s_3793_2: u8 = 6;
        // C s_3793_3: cast zx s_3793_2 -> bv
        let s_3793_3: Bits = Bits::new(s_3793_2 as u128, 3u16);
        // D s_3793_4: cmp-eq s_3793_1 s_3793_3
        let s_3793_4: bool = ((s_3793_1) == (s_3793_3));
        // D s_3793_5: write-var gs#136027 <= s_3793_4
        fn_state.gs_136027 = s_3793_4;
        // N s_3793_6: jump b3482
        return block_3482(state, tracer, fn_state);
    }
    fn block_3794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3794_0: read-var opc1:u8
        let s_3794_0: u8 = fn_state.opc1;
        // D s_3794_1: cast zx s_3794_0 -> bv
        let s_3794_1: Bits = Bits::new(s_3794_0 as u128, 3u16);
        // C s_3794_2: const #0u : u8
        let s_3794_2: u8 = 0;
        // C s_3794_3: cast zx s_3794_2 -> bv
        let s_3794_3: Bits = Bits::new(s_3794_2 as u128, 3u16);
        // D s_3794_4: cmp-eq s_3794_1 s_3794_3
        let s_3794_4: bool = ((s_3794_1) == (s_3794_3));
        // D s_3794_5: write-var gs#136026 <= s_3794_4
        fn_state.gs_136026 = s_3794_4;
        // N s_3794_6: jump b3480
        return block_3480(state, tracer, fn_state);
    }
    fn block_3795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3795_0: read-var coproc:u8
        let s_3795_0: u8 = fn_state.coproc;
        // D s_3795_1: cast zx s_3795_0 -> bv
        let s_3795_1: Bits = Bits::new(s_3795_0 as u128, 4u16);
        // C s_3795_2: const #15u : u8
        let s_3795_2: u8 = 15;
        // C s_3795_3: cast zx s_3795_2 -> bv
        let s_3795_3: Bits = Bits::new(s_3795_2 as u128, 4u16);
        // D s_3795_4: cmp-eq s_3795_1 s_3795_3
        let s_3795_4: bool = ((s_3795_1) == (s_3795_3));
        // D s_3795_5: write-var gs#136025 <= s_3795_4
        fn_state.gs_136025 = s_3795_4;
        // N s_3795_6: jump b3478
        return block_3478(state, tracer, fn_state);
    }
    fn block_3796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3796_0: read-var CRn:u8
        let s_3796_0: u8 = fn_state.CRn;
        // D s_3796_1: cast zx s_3796_0 -> bv
        let s_3796_1: Bits = Bits::new(s_3796_0 as u128, 4u16);
        // C s_3796_2: const #5u : u8
        let s_3796_2: u8 = 5;
        // C s_3796_3: cast zx s_3796_2 -> bv
        let s_3796_3: Bits = Bits::new(s_3796_2 as u128, 4u16);
        // D s_3796_4: cmp-eq s_3796_1 s_3796_3
        let s_3796_4: bool = ((s_3796_1) == (s_3796_3));
        // D s_3796_5: write-var gs#136024 <= s_3796_4
        fn_state.gs_136024 = s_3796_4;
        // N s_3796_6: jump b3476
        return block_3476(state, tracer, fn_state);
    }
    fn block_3797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3797_0: read-var el:u8
        let s_3797_0: u8 = fn_state.el;
        // D s_3797_1: read-var coproc:u8
        let s_3797_1: u8 = fn_state.coproc;
        // D s_3797_2: read-var opc1:u8
        let s_3797_2: u8 = fn_state.opc1;
        // D s_3797_3: read-var CRn:u8
        let s_3797_3: u8 = fn_state.CRn;
        // D s_3797_4: read-var opc2:u8
        let s_3797_4: u8 = fn_state.opc2;
        // D s_3797_5: read-var CRm:u8
        let s_3797_5: u8 = fn_state.CRm;
        // D s_3797_6: read-var t:i
        let s_3797_6: i128 = fn_state.t;
        // D s_3797_7: call ERXCTLR_SysRegWrite32_9a6bdb0b20151705(s_3797_0, s_3797_1, s_3797_2, s_3797_3, s_3797_4, s_3797_5, s_3797_6)
        let s_3797_7: () = ERXCTLR_SysRegWrite32_9a6bdb0b20151705(
            state,
            tracer,
            s_3797_0,
            s_3797_1,
            s_3797_2,
            s_3797_3,
            s_3797_4,
            s_3797_5,
            s_3797_6,
        );
        // N s_3797_8: return
        return;
    }
    fn block_3798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3798_0: read-var opc2:u8
        let s_3798_0: u8 = fn_state.opc2;
        // D s_3798_1: cast zx s_3798_0 -> bv
        let s_3798_1: Bits = Bits::new(s_3798_0 as u128, 3u16);
        // C s_3798_2: const #1u : u8
        let s_3798_2: u8 = 1;
        // C s_3798_3: cast zx s_3798_2 -> bv
        let s_3798_3: Bits = Bits::new(s_3798_2 as u128, 3u16);
        // D s_3798_4: cmp-eq s_3798_1 s_3798_3
        let s_3798_4: bool = ((s_3798_1) == (s_3798_3));
        // D s_3798_5: write-var gs#136023 <= s_3798_4
        fn_state.gs_136023 = s_3798_4;
        // N s_3798_6: jump b3473
        return block_3473(state, tracer, fn_state);
    }
    fn block_3799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3799_0: read-var opc1:u8
        let s_3799_0: u8 = fn_state.opc1;
        // D s_3799_1: cast zx s_3799_0 -> bv
        let s_3799_1: Bits = Bits::new(s_3799_0 as u128, 3u16);
        // C s_3799_2: const #0u : u8
        let s_3799_2: u8 = 0;
        // C s_3799_3: cast zx s_3799_2 -> bv
        let s_3799_3: Bits = Bits::new(s_3799_2 as u128, 3u16);
        // D s_3799_4: cmp-eq s_3799_1 s_3799_3
        let s_3799_4: bool = ((s_3799_1) == (s_3799_3));
        // D s_3799_5: write-var gs#136022 <= s_3799_4
        fn_state.gs_136022 = s_3799_4;
        // N s_3799_6: jump b3471
        return block_3471(state, tracer, fn_state);
    }
    fn block_3800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3800_0: read-var coproc:u8
        let s_3800_0: u8 = fn_state.coproc;
        // D s_3800_1: cast zx s_3800_0 -> bv
        let s_3800_1: Bits = Bits::new(s_3800_0 as u128, 4u16);
        // C s_3800_2: const #15u : u8
        let s_3800_2: u8 = 15;
        // C s_3800_3: cast zx s_3800_2 -> bv
        let s_3800_3: Bits = Bits::new(s_3800_2 as u128, 4u16);
        // D s_3800_4: cmp-eq s_3800_1 s_3800_3
        let s_3800_4: bool = ((s_3800_1) == (s_3800_3));
        // D s_3800_5: write-var gs#136021 <= s_3800_4
        fn_state.gs_136021 = s_3800_4;
        // N s_3800_6: jump b3469
        return block_3469(state, tracer, fn_state);
    }
    fn block_3801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3801_0: read-var CRn:u8
        let s_3801_0: u8 = fn_state.CRn;
        // D s_3801_1: cast zx s_3801_0 -> bv
        let s_3801_1: Bits = Bits::new(s_3801_0 as u128, 4u16);
        // C s_3801_2: const #5u : u8
        let s_3801_2: u8 = 5;
        // C s_3801_3: cast zx s_3801_2 -> bv
        let s_3801_3: Bits = Bits::new(s_3801_2 as u128, 4u16);
        // D s_3801_4: cmp-eq s_3801_1 s_3801_3
        let s_3801_4: bool = ((s_3801_1) == (s_3801_3));
        // D s_3801_5: write-var gs#136020 <= s_3801_4
        fn_state.gs_136020 = s_3801_4;
        // N s_3801_6: jump b3467
        return block_3467(state, tracer, fn_state);
    }
    fn block_3802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3802_0: read-var el:u8
        let s_3802_0: u8 = fn_state.el;
        // D s_3802_1: read-var coproc:u8
        let s_3802_1: u8 = fn_state.coproc;
        // D s_3802_2: read-var opc1:u8
        let s_3802_2: u8 = fn_state.opc1;
        // D s_3802_3: read-var CRn:u8
        let s_3802_3: u8 = fn_state.CRn;
        // D s_3802_4: read-var opc2:u8
        let s_3802_4: u8 = fn_state.opc2;
        // D s_3802_5: read-var CRm:u8
        let s_3802_5: u8 = fn_state.CRm;
        // D s_3802_6: read-var t:i
        let s_3802_6: i128 = fn_state.t;
        // D s_3802_7: call ERXMISC1_SysRegWrite32_2fd201afaaba07ad(s_3802_0, s_3802_1, s_3802_2, s_3802_3, s_3802_4, s_3802_5, s_3802_6)
        let s_3802_7: () = ERXMISC1_SysRegWrite32_2fd201afaaba07ad(
            state,
            tracer,
            s_3802_0,
            s_3802_1,
            s_3802_2,
            s_3802_3,
            s_3802_4,
            s_3802_5,
            s_3802_6,
        );
        // N s_3802_8: return
        return;
    }
    fn block_3803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3803_0: read-var opc2:u8
        let s_3803_0: u8 = fn_state.opc2;
        // D s_3803_1: cast zx s_3803_0 -> bv
        let s_3803_1: Bits = Bits::new(s_3803_0 as u128, 3u16);
        // C s_3803_2: const #1u : u8
        let s_3803_2: u8 = 1;
        // C s_3803_3: cast zx s_3803_2 -> bv
        let s_3803_3: Bits = Bits::new(s_3803_2 as u128, 3u16);
        // D s_3803_4: cmp-eq s_3803_1 s_3803_3
        let s_3803_4: bool = ((s_3803_1) == (s_3803_3));
        // D s_3803_5: write-var gs#136019 <= s_3803_4
        fn_state.gs_136019 = s_3803_4;
        // N s_3803_6: jump b3464
        return block_3464(state, tracer, fn_state);
    }
    fn block_3804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3804_0: read-var opc1:u8
        let s_3804_0: u8 = fn_state.opc1;
        // D s_3804_1: cast zx s_3804_0 -> bv
        let s_3804_1: Bits = Bits::new(s_3804_0 as u128, 3u16);
        // C s_3804_2: const #0u : u8
        let s_3804_2: u8 = 0;
        // C s_3804_3: cast zx s_3804_2 -> bv
        let s_3804_3: Bits = Bits::new(s_3804_2 as u128, 3u16);
        // D s_3804_4: cmp-eq s_3804_1 s_3804_3
        let s_3804_4: bool = ((s_3804_1) == (s_3804_3));
        // D s_3804_5: write-var gs#136018 <= s_3804_4
        fn_state.gs_136018 = s_3804_4;
        // N s_3804_6: jump b3462
        return block_3462(state, tracer, fn_state);
    }
    fn block_3805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3805_0: read-var coproc:u8
        let s_3805_0: u8 = fn_state.coproc;
        // D s_3805_1: cast zx s_3805_0 -> bv
        let s_3805_1: Bits = Bits::new(s_3805_0 as u128, 4u16);
        // C s_3805_2: const #15u : u8
        let s_3805_2: u8 = 15;
        // C s_3805_3: cast zx s_3805_2 -> bv
        let s_3805_3: Bits = Bits::new(s_3805_2 as u128, 4u16);
        // D s_3805_4: cmp-eq s_3805_1 s_3805_3
        let s_3805_4: bool = ((s_3805_1) == (s_3805_3));
        // D s_3805_5: write-var gs#136017 <= s_3805_4
        fn_state.gs_136017 = s_3805_4;
        // N s_3805_6: jump b3460
        return block_3460(state, tracer, fn_state);
    }
    fn block_3806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3806_0: read-var CRn:u8
        let s_3806_0: u8 = fn_state.CRn;
        // D s_3806_1: cast zx s_3806_0 -> bv
        let s_3806_1: Bits = Bits::new(s_3806_0 as u128, 4u16);
        // C s_3806_2: const #5u : u8
        let s_3806_2: u8 = 5;
        // C s_3806_3: cast zx s_3806_2 -> bv
        let s_3806_3: Bits = Bits::new(s_3806_2 as u128, 4u16);
        // D s_3806_4: cmp-eq s_3806_1 s_3806_3
        let s_3806_4: bool = ((s_3806_1) == (s_3806_3));
        // D s_3806_5: write-var gs#136016 <= s_3806_4
        fn_state.gs_136016 = s_3806_4;
        // N s_3806_6: jump b3458
        return block_3458(state, tracer, fn_state);
    }
    fn block_3807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3807_0: read-var el:u8
        let s_3807_0: u8 = fn_state.el;
        // D s_3807_1: read-var coproc:u8
        let s_3807_1: u8 = fn_state.coproc;
        // D s_3807_2: read-var opc1:u8
        let s_3807_2: u8 = fn_state.opc1;
        // D s_3807_3: read-var CRn:u8
        let s_3807_3: u8 = fn_state.CRn;
        // D s_3807_4: read-var opc2:u8
        let s_3807_4: u8 = fn_state.opc2;
        // D s_3807_5: read-var CRm:u8
        let s_3807_5: u8 = fn_state.CRm;
        // D s_3807_6: read-var t:i
        let s_3807_6: i128 = fn_state.t;
        // D s_3807_7: call VDFSR_SysRegWrite32_a0962e93b6e4f29f(s_3807_0, s_3807_1, s_3807_2, s_3807_3, s_3807_4, s_3807_5, s_3807_6)
        let s_3807_7: () = VDFSR_SysRegWrite32_a0962e93b6e4f29f(
            state,
            tracer,
            s_3807_0,
            s_3807_1,
            s_3807_2,
            s_3807_3,
            s_3807_4,
            s_3807_5,
            s_3807_6,
        );
        // N s_3807_8: return
        return;
    }
    fn block_3808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3808_0: read-var opc2:u8
        let s_3808_0: u8 = fn_state.opc2;
        // D s_3808_1: cast zx s_3808_0 -> bv
        let s_3808_1: Bits = Bits::new(s_3808_0 as u128, 3u16);
        // C s_3808_2: const #3u : u8
        let s_3808_2: u8 = 3;
        // C s_3808_3: cast zx s_3808_2 -> bv
        let s_3808_3: Bits = Bits::new(s_3808_2 as u128, 3u16);
        // D s_3808_4: cmp-eq s_3808_1 s_3808_3
        let s_3808_4: bool = ((s_3808_1) == (s_3808_3));
        // D s_3808_5: write-var gs#136015 <= s_3808_4
        fn_state.gs_136015 = s_3808_4;
        // N s_3808_6: jump b3455
        return block_3455(state, tracer, fn_state);
    }
    fn block_3809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3809_0: read-var opc1:u8
        let s_3809_0: u8 = fn_state.opc1;
        // D s_3809_1: cast zx s_3809_0 -> bv
        let s_3809_1: Bits = Bits::new(s_3809_0 as u128, 3u16);
        // C s_3809_2: const #4u : u8
        let s_3809_2: u8 = 4;
        // C s_3809_3: cast zx s_3809_2 -> bv
        let s_3809_3: Bits = Bits::new(s_3809_2 as u128, 3u16);
        // D s_3809_4: cmp-eq s_3809_1 s_3809_3
        let s_3809_4: bool = ((s_3809_1) == (s_3809_3));
        // D s_3809_5: write-var gs#136014 <= s_3809_4
        fn_state.gs_136014 = s_3809_4;
        // N s_3809_6: jump b3453
        return block_3453(state, tracer, fn_state);
    }
    fn block_3810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3810_0: read-var coproc:u8
        let s_3810_0: u8 = fn_state.coproc;
        // D s_3810_1: cast zx s_3810_0 -> bv
        let s_3810_1: Bits = Bits::new(s_3810_0 as u128, 4u16);
        // C s_3810_2: const #15u : u8
        let s_3810_2: u8 = 15;
        // C s_3810_3: cast zx s_3810_2 -> bv
        let s_3810_3: Bits = Bits::new(s_3810_2 as u128, 4u16);
        // D s_3810_4: cmp-eq s_3810_1 s_3810_3
        let s_3810_4: bool = ((s_3810_1) == (s_3810_3));
        // D s_3810_5: write-var gs#136013 <= s_3810_4
        fn_state.gs_136013 = s_3810_4;
        // N s_3810_6: jump b3451
        return block_3451(state, tracer, fn_state);
    }
    fn block_3811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3811_0: read-var CRn:u8
        let s_3811_0: u8 = fn_state.CRn;
        // D s_3811_1: cast zx s_3811_0 -> bv
        let s_3811_1: Bits = Bits::new(s_3811_0 as u128, 4u16);
        // C s_3811_2: const #5u : u8
        let s_3811_2: u8 = 5;
        // C s_3811_3: cast zx s_3811_2 -> bv
        let s_3811_3: Bits = Bits::new(s_3811_2 as u128, 4u16);
        // D s_3811_4: cmp-eq s_3811_1 s_3811_3
        let s_3811_4: bool = ((s_3811_1) == (s_3811_3));
        // D s_3811_5: write-var gs#136012 <= s_3811_4
        fn_state.gs_136012 = s_3811_4;
        // N s_3811_6: jump b3449
        return block_3449(state, tracer, fn_state);
    }
    fn block_3812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3812_0: read-var el:u8
        let s_3812_0: u8 = fn_state.el;
        // D s_3812_1: read-var coproc:u8
        let s_3812_1: u8 = fn_state.coproc;
        // D s_3812_2: read-var opc1:u8
        let s_3812_2: u8 = fn_state.opc1;
        // D s_3812_3: read-var CRn:u8
        let s_3812_3: u8 = fn_state.CRn;
        // D s_3812_4: read-var opc2:u8
        let s_3812_4: u8 = fn_state.opc2;
        // D s_3812_5: read-var CRm:u8
        let s_3812_5: u8 = fn_state.CRm;
        // D s_3812_6: read-var t:i
        let s_3812_6: i128 = fn_state.t;
        // D s_3812_7: call DISR_SysRegWrite32_797163d94eb0b6e5(s_3812_0, s_3812_1, s_3812_2, s_3812_3, s_3812_4, s_3812_5, s_3812_6)
        let s_3812_7: () = DISR_SysRegWrite32_797163d94eb0b6e5(
            state,
            tracer,
            s_3812_0,
            s_3812_1,
            s_3812_2,
            s_3812_3,
            s_3812_4,
            s_3812_5,
            s_3812_6,
        );
        // N s_3812_8: return
        return;
    }
    fn block_3813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3813_0: read-var opc2:u8
        let s_3813_0: u8 = fn_state.opc2;
        // D s_3813_1: cast zx s_3813_0 -> bv
        let s_3813_1: Bits = Bits::new(s_3813_0 as u128, 3u16);
        // C s_3813_2: const #1u : u8
        let s_3813_2: u8 = 1;
        // C s_3813_3: cast zx s_3813_2 -> bv
        let s_3813_3: Bits = Bits::new(s_3813_2 as u128, 3u16);
        // D s_3813_4: cmp-eq s_3813_1 s_3813_3
        let s_3813_4: bool = ((s_3813_1) == (s_3813_3));
        // D s_3813_5: write-var gs#136011 <= s_3813_4
        fn_state.gs_136011 = s_3813_4;
        // N s_3813_6: jump b3446
        return block_3446(state, tracer, fn_state);
    }
    fn block_3814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3814_0: read-var opc1:u8
        let s_3814_0: u8 = fn_state.opc1;
        // D s_3814_1: cast zx s_3814_0 -> bv
        let s_3814_1: Bits = Bits::new(s_3814_0 as u128, 3u16);
        // C s_3814_2: const #0u : u8
        let s_3814_2: u8 = 0;
        // C s_3814_3: cast zx s_3814_2 -> bv
        let s_3814_3: Bits = Bits::new(s_3814_2 as u128, 3u16);
        // D s_3814_4: cmp-eq s_3814_1 s_3814_3
        let s_3814_4: bool = ((s_3814_1) == (s_3814_3));
        // D s_3814_5: write-var gs#136010 <= s_3814_4
        fn_state.gs_136010 = s_3814_4;
        // N s_3814_6: jump b3444
        return block_3444(state, tracer, fn_state);
    }
    fn block_3815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3815_0: read-var coproc:u8
        let s_3815_0: u8 = fn_state.coproc;
        // D s_3815_1: cast zx s_3815_0 -> bv
        let s_3815_1: Bits = Bits::new(s_3815_0 as u128, 4u16);
        // C s_3815_2: const #15u : u8
        let s_3815_2: u8 = 15;
        // C s_3815_3: cast zx s_3815_2 -> bv
        let s_3815_3: Bits = Bits::new(s_3815_2 as u128, 4u16);
        // D s_3815_4: cmp-eq s_3815_1 s_3815_3
        let s_3815_4: bool = ((s_3815_1) == (s_3815_3));
        // D s_3815_5: write-var gs#136009 <= s_3815_4
        fn_state.gs_136009 = s_3815_4;
        // N s_3815_6: jump b3442
        return block_3442(state, tracer, fn_state);
    }
    fn block_3816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3816_0: read-var CRn:u8
        let s_3816_0: u8 = fn_state.CRn;
        // D s_3816_1: cast zx s_3816_0 -> bv
        let s_3816_1: Bits = Bits::new(s_3816_0 as u128, 4u16);
        // C s_3816_2: const #12u : u8
        let s_3816_2: u8 = 12;
        // C s_3816_3: cast zx s_3816_2 -> bv
        let s_3816_3: Bits = Bits::new(s_3816_2 as u128, 4u16);
        // D s_3816_4: cmp-eq s_3816_1 s_3816_3
        let s_3816_4: bool = ((s_3816_1) == (s_3816_3));
        // D s_3816_5: write-var gs#136008 <= s_3816_4
        fn_state.gs_136008 = s_3816_4;
        // N s_3816_6: jump b3440
        return block_3440(state, tracer, fn_state);
    }
    fn block_3817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3817_0: read-var el:u8
        let s_3817_0: u8 = fn_state.el;
        // D s_3817_1: read-var coproc:u8
        let s_3817_1: u8 = fn_state.coproc;
        // D s_3817_2: read-var opc1:u8
        let s_3817_2: u8 = fn_state.opc1;
        // D s_3817_3: read-var CRn:u8
        let s_3817_3: u8 = fn_state.CRn;
        // D s_3817_4: read-var opc2:u8
        let s_3817_4: u8 = fn_state.opc2;
        // D s_3817_5: read-var CRm:u8
        let s_3817_5: u8 = fn_state.CRm;
        // D s_3817_6: read-var t:i
        let s_3817_6: i128 = fn_state.t;
        // D s_3817_7: call ERXCTLR2_SysRegWrite32_0da36f801d9231d1(s_3817_0, s_3817_1, s_3817_2, s_3817_3, s_3817_4, s_3817_5, s_3817_6)
        let s_3817_7: () = ERXCTLR2_SysRegWrite32_0da36f801d9231d1(
            state,
            tracer,
            s_3817_0,
            s_3817_1,
            s_3817_2,
            s_3817_3,
            s_3817_4,
            s_3817_5,
            s_3817_6,
        );
        // N s_3817_8: return
        return;
    }
    fn block_3818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3818_0: read-var opc2:u8
        let s_3818_0: u8 = fn_state.opc2;
        // D s_3818_1: cast zx s_3818_0 -> bv
        let s_3818_1: Bits = Bits::new(s_3818_0 as u128, 3u16);
        // C s_3818_2: const #5u : u8
        let s_3818_2: u8 = 5;
        // C s_3818_3: cast zx s_3818_2 -> bv
        let s_3818_3: Bits = Bits::new(s_3818_2 as u128, 3u16);
        // D s_3818_4: cmp-eq s_3818_1 s_3818_3
        let s_3818_4: bool = ((s_3818_1) == (s_3818_3));
        // D s_3818_5: write-var gs#136007 <= s_3818_4
        fn_state.gs_136007 = s_3818_4;
        // N s_3818_6: jump b3437
        return block_3437(state, tracer, fn_state);
    }
    fn block_3819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3819_0: read-var opc1:u8
        let s_3819_0: u8 = fn_state.opc1;
        // D s_3819_1: cast zx s_3819_0 -> bv
        let s_3819_1: Bits = Bits::new(s_3819_0 as u128, 3u16);
        // C s_3819_2: const #0u : u8
        let s_3819_2: u8 = 0;
        // C s_3819_3: cast zx s_3819_2 -> bv
        let s_3819_3: Bits = Bits::new(s_3819_2 as u128, 3u16);
        // D s_3819_4: cmp-eq s_3819_1 s_3819_3
        let s_3819_4: bool = ((s_3819_1) == (s_3819_3));
        // D s_3819_5: write-var gs#136006 <= s_3819_4
        fn_state.gs_136006 = s_3819_4;
        // N s_3819_6: jump b3435
        return block_3435(state, tracer, fn_state);
    }
    fn block_3820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3820_0: read-var coproc:u8
        let s_3820_0: u8 = fn_state.coproc;
        // D s_3820_1: cast zx s_3820_0 -> bv
        let s_3820_1: Bits = Bits::new(s_3820_0 as u128, 4u16);
        // C s_3820_2: const #15u : u8
        let s_3820_2: u8 = 15;
        // C s_3820_3: cast zx s_3820_2 -> bv
        let s_3820_3: Bits = Bits::new(s_3820_2 as u128, 4u16);
        // D s_3820_4: cmp-eq s_3820_1 s_3820_3
        let s_3820_4: bool = ((s_3820_1) == (s_3820_3));
        // D s_3820_5: write-var gs#136005 <= s_3820_4
        fn_state.gs_136005 = s_3820_4;
        // N s_3820_6: jump b3433
        return block_3433(state, tracer, fn_state);
    }
    fn block_3821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3821_0: read-var CRn:u8
        let s_3821_0: u8 = fn_state.CRn;
        // D s_3821_1: cast zx s_3821_0 -> bv
        let s_3821_1: Bits = Bits::new(s_3821_0 as u128, 4u16);
        // C s_3821_2: const #5u : u8
        let s_3821_2: u8 = 5;
        // C s_3821_3: cast zx s_3821_2 -> bv
        let s_3821_3: Bits = Bits::new(s_3821_2 as u128, 4u16);
        // D s_3821_4: cmp-eq s_3821_1 s_3821_3
        let s_3821_4: bool = ((s_3821_1) == (s_3821_3));
        // D s_3821_5: write-var gs#136004 <= s_3821_4
        fn_state.gs_136004 = s_3821_4;
        // N s_3821_6: jump b3431
        return block_3431(state, tracer, fn_state);
    }
    fn block_3822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3822_0: read-var el:u8
        let s_3822_0: u8 = fn_state.el;
        // D s_3822_1: read-var coproc:u8
        let s_3822_1: u8 = fn_state.coproc;
        // D s_3822_2: read-var opc1:u8
        let s_3822_2: u8 = fn_state.opc1;
        // D s_3822_3: read-var CRn:u8
        let s_3822_3: u8 = fn_state.CRn;
        // D s_3822_4: read-var opc2:u8
        let s_3822_4: u8 = fn_state.opc2;
        // D s_3822_5: read-var CRm:u8
        let s_3822_5: u8 = fn_state.CRm;
        // D s_3822_6: read-var t:i
        let s_3822_6: i128 = fn_state.t;
        // D s_3822_7: call ERRSELR_SysRegWrite32_e1b5ff755f2cd46d(s_3822_0, s_3822_1, s_3822_2, s_3822_3, s_3822_4, s_3822_5, s_3822_6)
        let s_3822_7: () = ERRSELR_SysRegWrite32_e1b5ff755f2cd46d(
            state,
            tracer,
            s_3822_0,
            s_3822_1,
            s_3822_2,
            s_3822_3,
            s_3822_4,
            s_3822_5,
            s_3822_6,
        );
        // N s_3822_8: return
        return;
    }
    fn block_3823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3823_0: read-var opc2:u8
        let s_3823_0: u8 = fn_state.opc2;
        // D s_3823_1: cast zx s_3823_0 -> bv
        let s_3823_1: Bits = Bits::new(s_3823_0 as u128, 3u16);
        // C s_3823_2: const #1u : u8
        let s_3823_2: u8 = 1;
        // C s_3823_3: cast zx s_3823_2 -> bv
        let s_3823_3: Bits = Bits::new(s_3823_2 as u128, 3u16);
        // D s_3823_4: cmp-eq s_3823_1 s_3823_3
        let s_3823_4: bool = ((s_3823_1) == (s_3823_3));
        // D s_3823_5: write-var gs#136003 <= s_3823_4
        fn_state.gs_136003 = s_3823_4;
        // N s_3823_6: jump b3428
        return block_3428(state, tracer, fn_state);
    }
    fn block_3824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3824_0: read-var opc1:u8
        let s_3824_0: u8 = fn_state.opc1;
        // D s_3824_1: cast zx s_3824_0 -> bv
        let s_3824_1: Bits = Bits::new(s_3824_0 as u128, 3u16);
        // C s_3824_2: const #0u : u8
        let s_3824_2: u8 = 0;
        // C s_3824_3: cast zx s_3824_2 -> bv
        let s_3824_3: Bits = Bits::new(s_3824_2 as u128, 3u16);
        // D s_3824_4: cmp-eq s_3824_1 s_3824_3
        let s_3824_4: bool = ((s_3824_1) == (s_3824_3));
        // D s_3824_5: write-var gs#136002 <= s_3824_4
        fn_state.gs_136002 = s_3824_4;
        // N s_3824_6: jump b3426
        return block_3426(state, tracer, fn_state);
    }
    fn block_3825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3825_0: read-var coproc:u8
        let s_3825_0: u8 = fn_state.coproc;
        // D s_3825_1: cast zx s_3825_0 -> bv
        let s_3825_1: Bits = Bits::new(s_3825_0 as u128, 4u16);
        // C s_3825_2: const #15u : u8
        let s_3825_2: u8 = 15;
        // C s_3825_3: cast zx s_3825_2 -> bv
        let s_3825_3: Bits = Bits::new(s_3825_2 as u128, 4u16);
        // D s_3825_4: cmp-eq s_3825_1 s_3825_3
        let s_3825_4: bool = ((s_3825_1) == (s_3825_3));
        // D s_3825_5: write-var gs#136001 <= s_3825_4
        fn_state.gs_136001 = s_3825_4;
        // N s_3825_6: jump b3424
        return block_3424(state, tracer, fn_state);
    }
    fn block_3826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3826_0: read-var CRn:u8
        let s_3826_0: u8 = fn_state.CRn;
        // D s_3826_1: cast zx s_3826_0 -> bv
        let s_3826_1: Bits = Bits::new(s_3826_0 as u128, 4u16);
        // C s_3826_2: const #5u : u8
        let s_3826_2: u8 = 5;
        // C s_3826_3: cast zx s_3826_2 -> bv
        let s_3826_3: Bits = Bits::new(s_3826_2 as u128, 4u16);
        // D s_3826_4: cmp-eq s_3826_1 s_3826_3
        let s_3826_4: bool = ((s_3826_1) == (s_3826_3));
        // D s_3826_5: write-var gs#136000 <= s_3826_4
        fn_state.gs_136000 = s_3826_4;
        // N s_3826_6: jump b3422
        return block_3422(state, tracer, fn_state);
    }
    fn block_3827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3827_0: read-var el:u8
        let s_3827_0: u8 = fn_state.el;
        // D s_3827_1: read-var coproc:u8
        let s_3827_1: u8 = fn_state.coproc;
        // D s_3827_2: read-var opc1:u8
        let s_3827_2: u8 = fn_state.opc1;
        // D s_3827_3: read-var CRn:u8
        let s_3827_3: u8 = fn_state.CRn;
        // D s_3827_4: read-var opc2:u8
        let s_3827_4: u8 = fn_state.opc2;
        // D s_3827_5: read-var CRm:u8
        let s_3827_5: u8 = fn_state.CRm;
        // D s_3827_6: read-var t:i
        let s_3827_6: i128 = fn_state.t;
        // D s_3827_7: call ERXMISC5_SysRegWrite32_2205a9b0403bca94(s_3827_0, s_3827_1, s_3827_2, s_3827_3, s_3827_4, s_3827_5, s_3827_6)
        let s_3827_7: () = ERXMISC5_SysRegWrite32_2205a9b0403bca94(
            state,
            tracer,
            s_3827_0,
            s_3827_1,
            s_3827_2,
            s_3827_3,
            s_3827_4,
            s_3827_5,
            s_3827_6,
        );
        // N s_3827_8: return
        return;
    }
    fn block_3828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3828_0: read-var opc2:u8
        let s_3828_0: u8 = fn_state.opc2;
        // D s_3828_1: cast zx s_3828_0 -> bv
        let s_3828_1: Bits = Bits::new(s_3828_0 as u128, 3u16);
        // C s_3828_2: const #3u : u8
        let s_3828_2: u8 = 3;
        // C s_3828_3: cast zx s_3828_2 -> bv
        let s_3828_3: Bits = Bits::new(s_3828_2 as u128, 3u16);
        // D s_3828_4: cmp-eq s_3828_1 s_3828_3
        let s_3828_4: bool = ((s_3828_1) == (s_3828_3));
        // D s_3828_5: write-var gs#135999 <= s_3828_4
        fn_state.gs_135999 = s_3828_4;
        // N s_3828_6: jump b3419
        return block_3419(state, tracer, fn_state);
    }
    fn block_3829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3829_0: read-var opc1:u8
        let s_3829_0: u8 = fn_state.opc1;
        // D s_3829_1: cast zx s_3829_0 -> bv
        let s_3829_1: Bits = Bits::new(s_3829_0 as u128, 3u16);
        // C s_3829_2: const #0u : u8
        let s_3829_2: u8 = 0;
        // C s_3829_3: cast zx s_3829_2 -> bv
        let s_3829_3: Bits = Bits::new(s_3829_2 as u128, 3u16);
        // D s_3829_4: cmp-eq s_3829_1 s_3829_3
        let s_3829_4: bool = ((s_3829_1) == (s_3829_3));
        // D s_3829_5: write-var gs#135998 <= s_3829_4
        fn_state.gs_135998 = s_3829_4;
        // N s_3829_6: jump b3417
        return block_3417(state, tracer, fn_state);
    }
    fn block_3830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3830_0: read-var coproc:u8
        let s_3830_0: u8 = fn_state.coproc;
        // D s_3830_1: cast zx s_3830_0 -> bv
        let s_3830_1: Bits = Bits::new(s_3830_0 as u128, 4u16);
        // C s_3830_2: const #15u : u8
        let s_3830_2: u8 = 15;
        // C s_3830_3: cast zx s_3830_2 -> bv
        let s_3830_3: Bits = Bits::new(s_3830_2 as u128, 4u16);
        // D s_3830_4: cmp-eq s_3830_1 s_3830_3
        let s_3830_4: bool = ((s_3830_1) == (s_3830_3));
        // D s_3830_5: write-var gs#135997 <= s_3830_4
        fn_state.gs_135997 = s_3830_4;
        // N s_3830_6: jump b3415
        return block_3415(state, tracer, fn_state);
    }
    fn block_3831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3831_0: read-var CRn:u8
        let s_3831_0: u8 = fn_state.CRn;
        // D s_3831_1: cast zx s_3831_0 -> bv
        let s_3831_1: Bits = Bits::new(s_3831_0 as u128, 4u16);
        // C s_3831_2: const #5u : u8
        let s_3831_2: u8 = 5;
        // C s_3831_3: cast zx s_3831_2 -> bv
        let s_3831_3: Bits = Bits::new(s_3831_2 as u128, 4u16);
        // D s_3831_4: cmp-eq s_3831_1 s_3831_3
        let s_3831_4: bool = ((s_3831_1) == (s_3831_3));
        // D s_3831_5: write-var gs#135996 <= s_3831_4
        fn_state.gs_135996 = s_3831_4;
        // N s_3831_6: jump b3413
        return block_3413(state, tracer, fn_state);
    }
    fn block_3832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3832_0: read-var el:u8
        let s_3832_0: u8 = fn_state.el;
        // D s_3832_1: read-var coproc:u8
        let s_3832_1: u8 = fn_state.coproc;
        // D s_3832_2: read-var opc1:u8
        let s_3832_2: u8 = fn_state.opc1;
        // D s_3832_3: read-var CRn:u8
        let s_3832_3: u8 = fn_state.CRn;
        // D s_3832_4: read-var opc2:u8
        let s_3832_4: u8 = fn_state.opc2;
        // D s_3832_5: read-var CRm:u8
        let s_3832_5: u8 = fn_state.CRm;
        // D s_3832_6: read-var t:i
        let s_3832_6: i128 = fn_state.t;
        // D s_3832_7: call ERXMISC0_SysRegWrite32_2c4882992476fc04(s_3832_0, s_3832_1, s_3832_2, s_3832_3, s_3832_4, s_3832_5, s_3832_6)
        let s_3832_7: () = ERXMISC0_SysRegWrite32_2c4882992476fc04(
            state,
            tracer,
            s_3832_0,
            s_3832_1,
            s_3832_2,
            s_3832_3,
            s_3832_4,
            s_3832_5,
            s_3832_6,
        );
        // N s_3832_8: return
        return;
    }
    fn block_3833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3833_0: read-var opc2:u8
        let s_3833_0: u8 = fn_state.opc2;
        // D s_3833_1: cast zx s_3833_0 -> bv
        let s_3833_1: Bits = Bits::new(s_3833_0 as u128, 3u16);
        // C s_3833_2: const #0u : u8
        let s_3833_2: u8 = 0;
        // C s_3833_3: cast zx s_3833_2 -> bv
        let s_3833_3: Bits = Bits::new(s_3833_2 as u128, 3u16);
        // D s_3833_4: cmp-eq s_3833_1 s_3833_3
        let s_3833_4: bool = ((s_3833_1) == (s_3833_3));
        // D s_3833_5: write-var gs#135995 <= s_3833_4
        fn_state.gs_135995 = s_3833_4;
        // N s_3833_6: jump b3410
        return block_3410(state, tracer, fn_state);
    }
    fn block_3834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3834_0: read-var opc1:u8
        let s_3834_0: u8 = fn_state.opc1;
        // D s_3834_1: cast zx s_3834_0 -> bv
        let s_3834_1: Bits = Bits::new(s_3834_0 as u128, 3u16);
        // C s_3834_2: const #0u : u8
        let s_3834_2: u8 = 0;
        // C s_3834_3: cast zx s_3834_2 -> bv
        let s_3834_3: Bits = Bits::new(s_3834_2 as u128, 3u16);
        // D s_3834_4: cmp-eq s_3834_1 s_3834_3
        let s_3834_4: bool = ((s_3834_1) == (s_3834_3));
        // D s_3834_5: write-var gs#135994 <= s_3834_4
        fn_state.gs_135994 = s_3834_4;
        // N s_3834_6: jump b3408
        return block_3408(state, tracer, fn_state);
    }
    fn block_3835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3835_0: read-var coproc:u8
        let s_3835_0: u8 = fn_state.coproc;
        // D s_3835_1: cast zx s_3835_0 -> bv
        let s_3835_1: Bits = Bits::new(s_3835_0 as u128, 4u16);
        // C s_3835_2: const #15u : u8
        let s_3835_2: u8 = 15;
        // C s_3835_3: cast zx s_3835_2 -> bv
        let s_3835_3: Bits = Bits::new(s_3835_2 as u128, 4u16);
        // D s_3835_4: cmp-eq s_3835_1 s_3835_3
        let s_3835_4: bool = ((s_3835_1) == (s_3835_3));
        // D s_3835_5: write-var gs#135993 <= s_3835_4
        fn_state.gs_135993 = s_3835_4;
        // N s_3835_6: jump b3406
        return block_3406(state, tracer, fn_state);
    }
    fn block_3836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3836_0: read-var CRn:u8
        let s_3836_0: u8 = fn_state.CRn;
        // D s_3836_1: cast zx s_3836_0 -> bv
        let s_3836_1: Bits = Bits::new(s_3836_0 as u128, 4u16);
        // C s_3836_2: const #5u : u8
        let s_3836_2: u8 = 5;
        // C s_3836_3: cast zx s_3836_2 -> bv
        let s_3836_3: Bits = Bits::new(s_3836_2 as u128, 4u16);
        // D s_3836_4: cmp-eq s_3836_1 s_3836_3
        let s_3836_4: bool = ((s_3836_1) == (s_3836_3));
        // D s_3836_5: write-var gs#135992 <= s_3836_4
        fn_state.gs_135992 = s_3836_4;
        // N s_3836_6: jump b3404
        return block_3404(state, tracer, fn_state);
    }
    fn block_3837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3837_0: read-var el:u8
        let s_3837_0: u8 = fn_state.el;
        // D s_3837_1: read-var coproc:u8
        let s_3837_1: u8 = fn_state.coproc;
        // D s_3837_2: read-var opc1:u8
        let s_3837_2: u8 = fn_state.opc1;
        // D s_3837_3: read-var CRn:u8
        let s_3837_3: u8 = fn_state.CRn;
        // D s_3837_4: read-var opc2:u8
        let s_3837_4: u8 = fn_state.opc2;
        // D s_3837_5: read-var CRm:u8
        let s_3837_5: u8 = fn_state.CRm;
        // D s_3837_6: read-var t:i
        let s_3837_6: i128 = fn_state.t;
        // D s_3837_7: call ERXADDR_SysRegWrite32_5df6ccfc72dd739d(s_3837_0, s_3837_1, s_3837_2, s_3837_3, s_3837_4, s_3837_5, s_3837_6)
        let s_3837_7: () = ERXADDR_SysRegWrite32_5df6ccfc72dd739d(
            state,
            tracer,
            s_3837_0,
            s_3837_1,
            s_3837_2,
            s_3837_3,
            s_3837_4,
            s_3837_5,
            s_3837_6,
        );
        // N s_3837_8: return
        return;
    }
    fn block_3838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3838_0: read-var opc2:u8
        let s_3838_0: u8 = fn_state.opc2;
        // D s_3838_1: cast zx s_3838_0 -> bv
        let s_3838_1: Bits = Bits::new(s_3838_0 as u128, 3u16);
        // C s_3838_2: const #3u : u8
        let s_3838_2: u8 = 3;
        // C s_3838_3: cast zx s_3838_2 -> bv
        let s_3838_3: Bits = Bits::new(s_3838_2 as u128, 3u16);
        // D s_3838_4: cmp-eq s_3838_1 s_3838_3
        let s_3838_4: bool = ((s_3838_1) == (s_3838_3));
        // D s_3838_5: write-var gs#135991 <= s_3838_4
        fn_state.gs_135991 = s_3838_4;
        // N s_3838_6: jump b3401
        return block_3401(state, tracer, fn_state);
    }
    fn block_3839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3839_0: read-var opc1:u8
        let s_3839_0: u8 = fn_state.opc1;
        // D s_3839_1: cast zx s_3839_0 -> bv
        let s_3839_1: Bits = Bits::new(s_3839_0 as u128, 3u16);
        // C s_3839_2: const #0u : u8
        let s_3839_2: u8 = 0;
        // C s_3839_3: cast zx s_3839_2 -> bv
        let s_3839_3: Bits = Bits::new(s_3839_2 as u128, 3u16);
        // D s_3839_4: cmp-eq s_3839_1 s_3839_3
        let s_3839_4: bool = ((s_3839_1) == (s_3839_3));
        // D s_3839_5: write-var gs#135990 <= s_3839_4
        fn_state.gs_135990 = s_3839_4;
        // N s_3839_6: jump b3399
        return block_3399(state, tracer, fn_state);
    }
    fn block_3840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3840_0: read-var coproc:u8
        let s_3840_0: u8 = fn_state.coproc;
        // D s_3840_1: cast zx s_3840_0 -> bv
        let s_3840_1: Bits = Bits::new(s_3840_0 as u128, 4u16);
        // C s_3840_2: const #15u : u8
        let s_3840_2: u8 = 15;
        // C s_3840_3: cast zx s_3840_2 -> bv
        let s_3840_3: Bits = Bits::new(s_3840_2 as u128, 4u16);
        // D s_3840_4: cmp-eq s_3840_1 s_3840_3
        let s_3840_4: bool = ((s_3840_1) == (s_3840_3));
        // D s_3840_5: write-var gs#135989 <= s_3840_4
        fn_state.gs_135989 = s_3840_4;
        // N s_3840_6: jump b3397
        return block_3397(state, tracer, fn_state);
    }
    fn block_3841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3841_0: read-var CRn:u8
        let s_3841_0: u8 = fn_state.CRn;
        // D s_3841_1: cast zx s_3841_0 -> bv
        let s_3841_1: Bits = Bits::new(s_3841_0 as u128, 4u16);
        // C s_3841_2: const #5u : u8
        let s_3841_2: u8 = 5;
        // C s_3841_3: cast zx s_3841_2 -> bv
        let s_3841_3: Bits = Bits::new(s_3841_2 as u128, 4u16);
        // D s_3841_4: cmp-eq s_3841_1 s_3841_3
        let s_3841_4: bool = ((s_3841_1) == (s_3841_3));
        // D s_3841_5: write-var gs#135988 <= s_3841_4
        fn_state.gs_135988 = s_3841_4;
        // N s_3841_6: jump b3395
        return block_3395(state, tracer, fn_state);
    }
    fn block_3842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3842_0: read-var el:u8
        let s_3842_0: u8 = fn_state.el;
        // D s_3842_1: read-var coproc:u8
        let s_3842_1: u8 = fn_state.coproc;
        // D s_3842_2: read-var opc1:u8
        let s_3842_2: u8 = fn_state.opc1;
        // D s_3842_3: read-var CRn:u8
        let s_3842_3: u8 = fn_state.CRn;
        // D s_3842_4: read-var opc2:u8
        let s_3842_4: u8 = fn_state.opc2;
        // D s_3842_5: read-var CRm:u8
        let s_3842_5: u8 = fn_state.CRm;
        // D s_3842_6: read-var t:i
        let s_3842_6: i128 = fn_state.t;
        // D s_3842_7: call ERXMISC2_SysRegWrite32_3da1683956813628(s_3842_0, s_3842_1, s_3842_2, s_3842_3, s_3842_4, s_3842_5, s_3842_6)
        let s_3842_7: () = ERXMISC2_SysRegWrite32_3da1683956813628(
            state,
            tracer,
            s_3842_0,
            s_3842_1,
            s_3842_2,
            s_3842_3,
            s_3842_4,
            s_3842_5,
            s_3842_6,
        );
        // N s_3842_8: return
        return;
    }
    fn block_3843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3843_0: read-var opc2:u8
        let s_3843_0: u8 = fn_state.opc2;
        // D s_3843_1: cast zx s_3843_0 -> bv
        let s_3843_1: Bits = Bits::new(s_3843_0 as u128, 3u16);
        // C s_3843_2: const #4u : u8
        let s_3843_2: u8 = 4;
        // C s_3843_3: cast zx s_3843_2 -> bv
        let s_3843_3: Bits = Bits::new(s_3843_2 as u128, 3u16);
        // D s_3843_4: cmp-eq s_3843_1 s_3843_3
        let s_3843_4: bool = ((s_3843_1) == (s_3843_3));
        // D s_3843_5: write-var gs#135987 <= s_3843_4
        fn_state.gs_135987 = s_3843_4;
        // N s_3843_6: jump b3392
        return block_3392(state, tracer, fn_state);
    }
    fn block_3844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3844_0: read-var opc1:u8
        let s_3844_0: u8 = fn_state.opc1;
        // D s_3844_1: cast zx s_3844_0 -> bv
        let s_3844_1: Bits = Bits::new(s_3844_0 as u128, 3u16);
        // C s_3844_2: const #0u : u8
        let s_3844_2: u8 = 0;
        // C s_3844_3: cast zx s_3844_2 -> bv
        let s_3844_3: Bits = Bits::new(s_3844_2 as u128, 3u16);
        // D s_3844_4: cmp-eq s_3844_1 s_3844_3
        let s_3844_4: bool = ((s_3844_1) == (s_3844_3));
        // D s_3844_5: write-var gs#135986 <= s_3844_4
        fn_state.gs_135986 = s_3844_4;
        // N s_3844_6: jump b3390
        return block_3390(state, tracer, fn_state);
    }
    fn block_3845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3845_0: read-var coproc:u8
        let s_3845_0: u8 = fn_state.coproc;
        // D s_3845_1: cast zx s_3845_0 -> bv
        let s_3845_1: Bits = Bits::new(s_3845_0 as u128, 4u16);
        // C s_3845_2: const #15u : u8
        let s_3845_2: u8 = 15;
        // C s_3845_3: cast zx s_3845_2 -> bv
        let s_3845_3: Bits = Bits::new(s_3845_2 as u128, 4u16);
        // D s_3845_4: cmp-eq s_3845_1 s_3845_3
        let s_3845_4: bool = ((s_3845_1) == (s_3845_3));
        // D s_3845_5: write-var gs#135985 <= s_3845_4
        fn_state.gs_135985 = s_3845_4;
        // N s_3845_6: jump b3388
        return block_3388(state, tracer, fn_state);
    }
    fn block_3846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3846_0: read-var CRn:u8
        let s_3846_0: u8 = fn_state.CRn;
        // D s_3846_1: cast zx s_3846_0 -> bv
        let s_3846_1: Bits = Bits::new(s_3846_0 as u128, 4u16);
        // C s_3846_2: const #5u : u8
        let s_3846_2: u8 = 5;
        // C s_3846_3: cast zx s_3846_2 -> bv
        let s_3846_3: Bits = Bits::new(s_3846_2 as u128, 4u16);
        // D s_3846_4: cmp-eq s_3846_1 s_3846_3
        let s_3846_4: bool = ((s_3846_1) == (s_3846_3));
        // D s_3846_5: write-var gs#135984 <= s_3846_4
        fn_state.gs_135984 = s_3846_4;
        // N s_3846_6: jump b3386
        return block_3386(state, tracer, fn_state);
    }
    fn block_3847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3847_0: read-var el:u8
        let s_3847_0: u8 = fn_state.el;
        // D s_3847_1: read-var coproc:u8
        let s_3847_1: u8 = fn_state.coproc;
        // D s_3847_2: read-var opc1:u8
        let s_3847_2: u8 = fn_state.opc1;
        // D s_3847_3: read-var CRn:u8
        let s_3847_3: u8 = fn_state.CRn;
        // D s_3847_4: read-var opc2:u8
        let s_3847_4: u8 = fn_state.opc2;
        // D s_3847_5: read-var CRm:u8
        let s_3847_5: u8 = fn_state.CRm;
        // D s_3847_6: read-var t:i
        let s_3847_6: i128 = fn_state.t;
        // D s_3847_7: call AMCR_SysRegWrite32_0a36aa89c00db4ab(s_3847_0, s_3847_1, s_3847_2, s_3847_3, s_3847_4, s_3847_5, s_3847_6)
        let s_3847_7: () = AMCR_SysRegWrite32_0a36aa89c00db4ab(
            state,
            tracer,
            s_3847_0,
            s_3847_1,
            s_3847_2,
            s_3847_3,
            s_3847_4,
            s_3847_5,
            s_3847_6,
        );
        // N s_3847_8: return
        return;
    }
    fn block_3848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3848_0: read-var opc2:u8
        let s_3848_0: u8 = fn_state.opc2;
        // D s_3848_1: cast zx s_3848_0 -> bv
        let s_3848_1: Bits = Bits::new(s_3848_0 as u128, 3u16);
        // C s_3848_2: const #0u : u8
        let s_3848_2: u8 = 0;
        // C s_3848_3: cast zx s_3848_2 -> bv
        let s_3848_3: Bits = Bits::new(s_3848_2 as u128, 3u16);
        // D s_3848_4: cmp-eq s_3848_1 s_3848_3
        let s_3848_4: bool = ((s_3848_1) == (s_3848_3));
        // D s_3848_5: write-var gs#135983 <= s_3848_4
        fn_state.gs_135983 = s_3848_4;
        // N s_3848_6: jump b3383
        return block_3383(state, tracer, fn_state);
    }
    fn block_3849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3849_0: read-var opc1:u8
        let s_3849_0: u8 = fn_state.opc1;
        // D s_3849_1: cast zx s_3849_0 -> bv
        let s_3849_1: Bits = Bits::new(s_3849_0 as u128, 3u16);
        // C s_3849_2: const #0u : u8
        let s_3849_2: u8 = 0;
        // C s_3849_3: cast zx s_3849_2 -> bv
        let s_3849_3: Bits = Bits::new(s_3849_2 as u128, 3u16);
        // D s_3849_4: cmp-eq s_3849_1 s_3849_3
        let s_3849_4: bool = ((s_3849_1) == (s_3849_3));
        // D s_3849_5: write-var gs#135982 <= s_3849_4
        fn_state.gs_135982 = s_3849_4;
        // N s_3849_6: jump b3381
        return block_3381(state, tracer, fn_state);
    }
    fn block_3850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3850_0: read-var coproc:u8
        let s_3850_0: u8 = fn_state.coproc;
        // D s_3850_1: cast zx s_3850_0 -> bv
        let s_3850_1: Bits = Bits::new(s_3850_0 as u128, 4u16);
        // C s_3850_2: const #15u : u8
        let s_3850_2: u8 = 15;
        // C s_3850_3: cast zx s_3850_2 -> bv
        let s_3850_3: Bits = Bits::new(s_3850_2 as u128, 4u16);
        // D s_3850_4: cmp-eq s_3850_1 s_3850_3
        let s_3850_4: bool = ((s_3850_1) == (s_3850_3));
        // D s_3850_5: write-var gs#135981 <= s_3850_4
        fn_state.gs_135981 = s_3850_4;
        // N s_3850_6: jump b3379
        return block_3379(state, tracer, fn_state);
    }
    fn block_3851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3851_0: read-var CRn:u8
        let s_3851_0: u8 = fn_state.CRn;
        // D s_3851_1: cast zx s_3851_0 -> bv
        let s_3851_1: Bits = Bits::new(s_3851_0 as u128, 4u16);
        // C s_3851_2: const #13u : u8
        let s_3851_2: u8 = 13;
        // C s_3851_3: cast zx s_3851_2 -> bv
        let s_3851_3: Bits = Bits::new(s_3851_2 as u128, 4u16);
        // D s_3851_4: cmp-eq s_3851_1 s_3851_3
        let s_3851_4: bool = ((s_3851_1) == (s_3851_3));
        // D s_3851_5: write-var gs#135980 <= s_3851_4
        fn_state.gs_135980 = s_3851_4;
        // N s_3851_6: jump b3377
        return block_3377(state, tracer, fn_state);
    }
    fn block_3852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3852_0: read-var el:u8
        let s_3852_0: u8 = fn_state.el;
        // D s_3852_1: read-var coproc:u8
        let s_3852_1: u8 = fn_state.coproc;
        // D s_3852_2: read-var opc1:u8
        let s_3852_2: u8 = fn_state.opc1;
        // D s_3852_3: read-var CRn:u8
        let s_3852_3: u8 = fn_state.CRn;
        // D s_3852_4: read-var opc2:u8
        let s_3852_4: u8 = fn_state.opc2;
        // D s_3852_5: read-var CRm:u8
        let s_3852_5: u8 = fn_state.CRm;
        // D s_3852_6: read-var t:i
        let s_3852_6: i128 = fn_state.t;
        // D s_3852_7: call AMCNTENSET1_SysRegWrite32_c9fde2d74a2eae8e(s_3852_0, s_3852_1, s_3852_2, s_3852_3, s_3852_4, s_3852_5, s_3852_6)
        let s_3852_7: () = AMCNTENSET1_SysRegWrite32_c9fde2d74a2eae8e(
            state,
            tracer,
            s_3852_0,
            s_3852_1,
            s_3852_2,
            s_3852_3,
            s_3852_4,
            s_3852_5,
            s_3852_6,
        );
        // N s_3852_8: return
        return;
    }
    fn block_3853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3853_0: read-var opc2:u8
        let s_3853_0: u8 = fn_state.opc2;
        // D s_3853_1: cast zx s_3853_0 -> bv
        let s_3853_1: Bits = Bits::new(s_3853_0 as u128, 3u16);
        // C s_3853_2: const #1u : u8
        let s_3853_2: u8 = 1;
        // C s_3853_3: cast zx s_3853_2 -> bv
        let s_3853_3: Bits = Bits::new(s_3853_2 as u128, 3u16);
        // D s_3853_4: cmp-eq s_3853_1 s_3853_3
        let s_3853_4: bool = ((s_3853_1) == (s_3853_3));
        // D s_3853_5: write-var gs#135979 <= s_3853_4
        fn_state.gs_135979 = s_3853_4;
        // N s_3853_6: jump b3374
        return block_3374(state, tracer, fn_state);
    }
    fn block_3854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3854_0: read-var opc1:u8
        let s_3854_0: u8 = fn_state.opc1;
        // D s_3854_1: cast zx s_3854_0 -> bv
        let s_3854_1: Bits = Bits::new(s_3854_0 as u128, 3u16);
        // C s_3854_2: const #0u : u8
        let s_3854_2: u8 = 0;
        // C s_3854_3: cast zx s_3854_2 -> bv
        let s_3854_3: Bits = Bits::new(s_3854_2 as u128, 3u16);
        // D s_3854_4: cmp-eq s_3854_1 s_3854_3
        let s_3854_4: bool = ((s_3854_1) == (s_3854_3));
        // D s_3854_5: write-var gs#135978 <= s_3854_4
        fn_state.gs_135978 = s_3854_4;
        // N s_3854_6: jump b3372
        return block_3372(state, tracer, fn_state);
    }
    fn block_3855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3855_0: read-var coproc:u8
        let s_3855_0: u8 = fn_state.coproc;
        // D s_3855_1: cast zx s_3855_0 -> bv
        let s_3855_1: Bits = Bits::new(s_3855_0 as u128, 4u16);
        // C s_3855_2: const #15u : u8
        let s_3855_2: u8 = 15;
        // C s_3855_3: cast zx s_3855_2 -> bv
        let s_3855_3: Bits = Bits::new(s_3855_2 as u128, 4u16);
        // D s_3855_4: cmp-eq s_3855_1 s_3855_3
        let s_3855_4: bool = ((s_3855_1) == (s_3855_3));
        // D s_3855_5: write-var gs#135977 <= s_3855_4
        fn_state.gs_135977 = s_3855_4;
        // N s_3855_6: jump b3370
        return block_3370(state, tracer, fn_state);
    }
    fn block_3856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3856_0: read-var CRn:u8
        let s_3856_0: u8 = fn_state.CRn;
        // D s_3856_1: cast zx s_3856_0 -> bv
        let s_3856_1: Bits = Bits::new(s_3856_0 as u128, 4u16);
        // C s_3856_2: const #13u : u8
        let s_3856_2: u8 = 13;
        // C s_3856_3: cast zx s_3856_2 -> bv
        let s_3856_3: Bits = Bits::new(s_3856_2 as u128, 4u16);
        // D s_3856_4: cmp-eq s_3856_1 s_3856_3
        let s_3856_4: bool = ((s_3856_1) == (s_3856_3));
        // D s_3856_5: write-var gs#135976 <= s_3856_4
        fn_state.gs_135976 = s_3856_4;
        // N s_3856_6: jump b3368
        return block_3368(state, tracer, fn_state);
    }
    fn block_3857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3857_0: read-var el:u8
        let s_3857_0: u8 = fn_state.el;
        // D s_3857_1: read-var coproc:u8
        let s_3857_1: u8 = fn_state.coproc;
        // D s_3857_2: read-var opc1:u8
        let s_3857_2: u8 = fn_state.opc1;
        // D s_3857_3: read-var CRn:u8
        let s_3857_3: u8 = fn_state.CRn;
        // D s_3857_4: read-var opc2:u8
        let s_3857_4: u8 = fn_state.opc2;
        // D s_3857_5: read-var CRm:u8
        let s_3857_5: u8 = fn_state.CRm;
        // D s_3857_6: read-var t:i
        let s_3857_6: i128 = fn_state.t;
        // D s_3857_7: call AMCNTENCLR0_SysRegWrite32_38bf5168732af700(s_3857_0, s_3857_1, s_3857_2, s_3857_3, s_3857_4, s_3857_5, s_3857_6)
        let s_3857_7: () = AMCNTENCLR0_SysRegWrite32_38bf5168732af700(
            state,
            tracer,
            s_3857_0,
            s_3857_1,
            s_3857_2,
            s_3857_3,
            s_3857_4,
            s_3857_5,
            s_3857_6,
        );
        // N s_3857_8: return
        return;
    }
    fn block_3858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3858_0: read-var opc2:u8
        let s_3858_0: u8 = fn_state.opc2;
        // D s_3858_1: cast zx s_3858_0 -> bv
        let s_3858_1: Bits = Bits::new(s_3858_0 as u128, 3u16);
        // C s_3858_2: const #4u : u8
        let s_3858_2: u8 = 4;
        // C s_3858_3: cast zx s_3858_2 -> bv
        let s_3858_3: Bits = Bits::new(s_3858_2 as u128, 3u16);
        // D s_3858_4: cmp-eq s_3858_1 s_3858_3
        let s_3858_4: bool = ((s_3858_1) == (s_3858_3));
        // D s_3858_5: write-var gs#135975 <= s_3858_4
        fn_state.gs_135975 = s_3858_4;
        // N s_3858_6: jump b3365
        return block_3365(state, tracer, fn_state);
    }
    fn block_3859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3859_0: read-var opc1:u8
        let s_3859_0: u8 = fn_state.opc1;
        // D s_3859_1: cast zx s_3859_0 -> bv
        let s_3859_1: Bits = Bits::new(s_3859_0 as u128, 3u16);
        // C s_3859_2: const #0u : u8
        let s_3859_2: u8 = 0;
        // C s_3859_3: cast zx s_3859_2 -> bv
        let s_3859_3: Bits = Bits::new(s_3859_2 as u128, 3u16);
        // D s_3859_4: cmp-eq s_3859_1 s_3859_3
        let s_3859_4: bool = ((s_3859_1) == (s_3859_3));
        // D s_3859_5: write-var gs#135974 <= s_3859_4
        fn_state.gs_135974 = s_3859_4;
        // N s_3859_6: jump b3363
        return block_3363(state, tracer, fn_state);
    }
    fn block_3860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3860_0: read-var coproc:u8
        let s_3860_0: u8 = fn_state.coproc;
        // D s_3860_1: cast zx s_3860_0 -> bv
        let s_3860_1: Bits = Bits::new(s_3860_0 as u128, 4u16);
        // C s_3860_2: const #15u : u8
        let s_3860_2: u8 = 15;
        // C s_3860_3: cast zx s_3860_2 -> bv
        let s_3860_3: Bits = Bits::new(s_3860_2 as u128, 4u16);
        // D s_3860_4: cmp-eq s_3860_1 s_3860_3
        let s_3860_4: bool = ((s_3860_1) == (s_3860_3));
        // D s_3860_5: write-var gs#135973 <= s_3860_4
        fn_state.gs_135973 = s_3860_4;
        // N s_3860_6: jump b3361
        return block_3361(state, tracer, fn_state);
    }
    fn block_3861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3861_0: read-var CRn:u8
        let s_3861_0: u8 = fn_state.CRn;
        // D s_3861_1: cast zx s_3861_0 -> bv
        let s_3861_1: Bits = Bits::new(s_3861_0 as u128, 4u16);
        // C s_3861_2: const #13u : u8
        let s_3861_2: u8 = 13;
        // C s_3861_3: cast zx s_3861_2 -> bv
        let s_3861_3: Bits = Bits::new(s_3861_2 as u128, 4u16);
        // D s_3861_4: cmp-eq s_3861_1 s_3861_3
        let s_3861_4: bool = ((s_3861_1) == (s_3861_3));
        // D s_3861_5: write-var gs#135972 <= s_3861_4
        fn_state.gs_135972 = s_3861_4;
        // N s_3861_6: jump b3359
        return block_3359(state, tracer, fn_state);
    }
    fn block_3862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3862_0: read-var el:u8
        let s_3862_0: u8 = fn_state.el;
        // D s_3862_1: read-var coproc:u8
        let s_3862_1: u8 = fn_state.coproc;
        // D s_3862_2: read-var opc1:u8
        let s_3862_2: u8 = fn_state.opc1;
        // D s_3862_3: read-var CRn:u8
        let s_3862_3: u8 = fn_state.CRn;
        // D s_3862_4: read-var opc2:u8
        let s_3862_4: u8 = fn_state.opc2;
        // D s_3862_5: read-var CRm:u8
        let s_3862_5: u8 = fn_state.CRm;
        // D s_3862_6: read-var t:i
        let s_3862_6: i128 = fn_state.t;
        // D s_3862_7: call AMCNTENSET0_SysRegWrite32_e19916620d98350a(s_3862_0, s_3862_1, s_3862_2, s_3862_3, s_3862_4, s_3862_5, s_3862_6)
        let s_3862_7: () = AMCNTENSET0_SysRegWrite32_e19916620d98350a(
            state,
            tracer,
            s_3862_0,
            s_3862_1,
            s_3862_2,
            s_3862_3,
            s_3862_4,
            s_3862_5,
            s_3862_6,
        );
        // N s_3862_8: return
        return;
    }
    fn block_3863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3863_0: read-var opc2:u8
        let s_3863_0: u8 = fn_state.opc2;
        // D s_3863_1: cast zx s_3863_0 -> bv
        let s_3863_1: Bits = Bits::new(s_3863_0 as u128, 3u16);
        // C s_3863_2: const #5u : u8
        let s_3863_2: u8 = 5;
        // C s_3863_3: cast zx s_3863_2 -> bv
        let s_3863_3: Bits = Bits::new(s_3863_2 as u128, 3u16);
        // D s_3863_4: cmp-eq s_3863_1 s_3863_3
        let s_3863_4: bool = ((s_3863_1) == (s_3863_3));
        // D s_3863_5: write-var gs#135971 <= s_3863_4
        fn_state.gs_135971 = s_3863_4;
        // N s_3863_6: jump b3356
        return block_3356(state, tracer, fn_state);
    }
    fn block_3864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3864_0: read-var opc1:u8
        let s_3864_0: u8 = fn_state.opc1;
        // D s_3864_1: cast zx s_3864_0 -> bv
        let s_3864_1: Bits = Bits::new(s_3864_0 as u128, 3u16);
        // C s_3864_2: const #0u : u8
        let s_3864_2: u8 = 0;
        // C s_3864_3: cast zx s_3864_2 -> bv
        let s_3864_3: Bits = Bits::new(s_3864_2 as u128, 3u16);
        // D s_3864_4: cmp-eq s_3864_1 s_3864_3
        let s_3864_4: bool = ((s_3864_1) == (s_3864_3));
        // D s_3864_5: write-var gs#135970 <= s_3864_4
        fn_state.gs_135970 = s_3864_4;
        // N s_3864_6: jump b3354
        return block_3354(state, tracer, fn_state);
    }
    fn block_3865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3865_0: read-var coproc:u8
        let s_3865_0: u8 = fn_state.coproc;
        // D s_3865_1: cast zx s_3865_0 -> bv
        let s_3865_1: Bits = Bits::new(s_3865_0 as u128, 4u16);
        // C s_3865_2: const #15u : u8
        let s_3865_2: u8 = 15;
        // C s_3865_3: cast zx s_3865_2 -> bv
        let s_3865_3: Bits = Bits::new(s_3865_2 as u128, 4u16);
        // D s_3865_4: cmp-eq s_3865_1 s_3865_3
        let s_3865_4: bool = ((s_3865_1) == (s_3865_3));
        // D s_3865_5: write-var gs#135969 <= s_3865_4
        fn_state.gs_135969 = s_3865_4;
        // N s_3865_6: jump b3352
        return block_3352(state, tracer, fn_state);
    }
    fn block_3866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3866_0: read-var CRn:u8
        let s_3866_0: u8 = fn_state.CRn;
        // D s_3866_1: cast zx s_3866_0 -> bv
        let s_3866_1: Bits = Bits::new(s_3866_0 as u128, 4u16);
        // C s_3866_2: const #13u : u8
        let s_3866_2: u8 = 13;
        // C s_3866_3: cast zx s_3866_2 -> bv
        let s_3866_3: Bits = Bits::new(s_3866_2 as u128, 4u16);
        // D s_3866_4: cmp-eq s_3866_1 s_3866_3
        let s_3866_4: bool = ((s_3866_1) == (s_3866_3));
        // D s_3866_5: write-var gs#135968 <= s_3866_4
        fn_state.gs_135968 = s_3866_4;
        // N s_3866_6: jump b3350
        return block_3350(state, tracer, fn_state);
    }
    fn block_3867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3867_0: read-var el:u8
        let s_3867_0: u8 = fn_state.el;
        // D s_3867_1: read-var coproc:u8
        let s_3867_1: u8 = fn_state.coproc;
        // D s_3867_2: read-var opc1:u8
        let s_3867_2: u8 = fn_state.opc1;
        // D s_3867_3: read-var CRn:u8
        let s_3867_3: u8 = fn_state.CRn;
        // D s_3867_4: read-var opc2:u8
        let s_3867_4: u8 = fn_state.opc2;
        // D s_3867_5: read-var CRm:u8
        let s_3867_5: u8 = fn_state.CRm;
        // D s_3867_6: read-var t:i
        let s_3867_6: i128 = fn_state.t;
        // D s_3867_7: call AMCNTENCLR1_SysRegWrite32_54f7ea48fcecb714(s_3867_0, s_3867_1, s_3867_2, s_3867_3, s_3867_4, s_3867_5, s_3867_6)
        let s_3867_7: () = AMCNTENCLR1_SysRegWrite32_54f7ea48fcecb714(
            state,
            tracer,
            s_3867_0,
            s_3867_1,
            s_3867_2,
            s_3867_3,
            s_3867_4,
            s_3867_5,
            s_3867_6,
        );
        // N s_3867_8: return
        return;
    }
    fn block_3868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3868_0: read-var opc2:u8
        let s_3868_0: u8 = fn_state.opc2;
        // D s_3868_1: cast zx s_3868_0 -> bv
        let s_3868_1: Bits = Bits::new(s_3868_0 as u128, 3u16);
        // C s_3868_2: const #0u : u8
        let s_3868_2: u8 = 0;
        // C s_3868_3: cast zx s_3868_2 -> bv
        let s_3868_3: Bits = Bits::new(s_3868_2 as u128, 3u16);
        // D s_3868_4: cmp-eq s_3868_1 s_3868_3
        let s_3868_4: bool = ((s_3868_1) == (s_3868_3));
        // D s_3868_5: write-var gs#135967 <= s_3868_4
        fn_state.gs_135967 = s_3868_4;
        // N s_3868_6: jump b3347
        return block_3347(state, tracer, fn_state);
    }
    fn block_3869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3869_0: read-var opc1:u8
        let s_3869_0: u8 = fn_state.opc1;
        // D s_3869_1: cast zx s_3869_0 -> bv
        let s_3869_1: Bits = Bits::new(s_3869_0 as u128, 3u16);
        // C s_3869_2: const #0u : u8
        let s_3869_2: u8 = 0;
        // C s_3869_3: cast zx s_3869_2 -> bv
        let s_3869_3: Bits = Bits::new(s_3869_2 as u128, 3u16);
        // D s_3869_4: cmp-eq s_3869_1 s_3869_3
        let s_3869_4: bool = ((s_3869_1) == (s_3869_3));
        // D s_3869_5: write-var gs#135966 <= s_3869_4
        fn_state.gs_135966 = s_3869_4;
        // N s_3869_6: jump b3345
        return block_3345(state, tracer, fn_state);
    }
    fn block_3870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3870_0: read-var coproc:u8
        let s_3870_0: u8 = fn_state.coproc;
        // D s_3870_1: cast zx s_3870_0 -> bv
        let s_3870_1: Bits = Bits::new(s_3870_0 as u128, 4u16);
        // C s_3870_2: const #15u : u8
        let s_3870_2: u8 = 15;
        // C s_3870_3: cast zx s_3870_2 -> bv
        let s_3870_3: Bits = Bits::new(s_3870_2 as u128, 4u16);
        // D s_3870_4: cmp-eq s_3870_1 s_3870_3
        let s_3870_4: bool = ((s_3870_1) == (s_3870_3));
        // D s_3870_5: write-var gs#135965 <= s_3870_4
        fn_state.gs_135965 = s_3870_4;
        // N s_3870_6: jump b3343
        return block_3343(state, tracer, fn_state);
    }
    fn block_3871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3871_0: read-var CRn:u8
        let s_3871_0: u8 = fn_state.CRn;
        // D s_3871_1: cast zx s_3871_0 -> bv
        let s_3871_1: Bits = Bits::new(s_3871_0 as u128, 4u16);
        // C s_3871_2: const #13u : u8
        let s_3871_2: u8 = 13;
        // C s_3871_3: cast zx s_3871_2 -> bv
        let s_3871_3: Bits = Bits::new(s_3871_2 as u128, 4u16);
        // D s_3871_4: cmp-eq s_3871_1 s_3871_3
        let s_3871_4: bool = ((s_3871_1) == (s_3871_3));
        // D s_3871_5: write-var gs#135964 <= s_3871_4
        fn_state.gs_135964 = s_3871_4;
        // N s_3871_6: jump b3341
        return block_3341(state, tracer, fn_state);
    }
    fn block_3872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3872_0: read-var el:u8
        let s_3872_0: u8 = fn_state.el;
        // D s_3872_1: read-var coproc:u8
        let s_3872_1: u8 = fn_state.coproc;
        // D s_3872_2: read-var opc1:u8
        let s_3872_2: u8 = fn_state.opc1;
        // D s_3872_3: read-var CRn:u8
        let s_3872_3: u8 = fn_state.CRn;
        // D s_3872_4: read-var opc2:u8
        let s_3872_4: u8 = fn_state.opc2;
        // D s_3872_5: read-var CRm:u8
        let s_3872_5: u8 = fn_state.CRm;
        // D s_3872_6: read-var t:i
        let s_3872_6: i128 = fn_state.t;
        // D s_3872_7: call AMEVTYPER1_SysRegWrite32_4f4eada85dcde70a(s_3872_0, s_3872_1, s_3872_2, s_3872_3, s_3872_4, s_3872_5, s_3872_6)
        let s_3872_7: () = AMEVTYPER1_SysRegWrite32_4f4eada85dcde70a(
            state,
            tracer,
            s_3872_0,
            s_3872_1,
            s_3872_2,
            s_3872_3,
            s_3872_4,
            s_3872_5,
            s_3872_6,
        );
        // N s_3872_8: return
        return;
    }
    fn block_3873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3873_0: read-var opc2:u8
        let s_3873_0: u8 = fn_state.opc2;
        // D s_3873_1: cast zx s_3873_0 -> bv
        let s_3873_1: Bits = Bits::new(s_3873_0 as u128, 3u16);
        // C s_3873_2: const #0u : u8
        let s_3873_2: u8 = 0;
        // C s_3873_3: cast zx s_3873_2 -> bv
        let s_3873_3: Bits = Bits::new(s_3873_2 as u128, 3u16);
        // D s_3873_4: cmp-eq s_3873_1 s_3873_3
        let s_3873_4: bool = ((s_3873_1) == (s_3873_3));
        // D s_3873_5: write-var gs#135963 <= s_3873_4
        fn_state.gs_135963 = s_3873_4;
        // N s_3873_6: jump b3338
        return block_3338(state, tracer, fn_state);
    }
    fn block_3874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3874_0: read-var opc1:u8
        let s_3874_0: u8 = fn_state.opc1;
        // D s_3874_1: cast zx s_3874_0 -> bv
        let s_3874_1: Bits = Bits::new(s_3874_0 as u128, 3u16);
        // C s_3874_2: const #0u : u8
        let s_3874_2: u8 = 0;
        // C s_3874_3: cast zx s_3874_2 -> bv
        let s_3874_3: Bits = Bits::new(s_3874_2 as u128, 3u16);
        // D s_3874_4: cmp-eq s_3874_1 s_3874_3
        let s_3874_4: bool = ((s_3874_1) == (s_3874_3));
        // D s_3874_5: write-var gs#135962 <= s_3874_4
        fn_state.gs_135962 = s_3874_4;
        // N s_3874_6: jump b3336
        return block_3336(state, tracer, fn_state);
    }
    fn block_3875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3875_0: read-var coproc:u8
        let s_3875_0: u8 = fn_state.coproc;
        // D s_3875_1: cast zx s_3875_0 -> bv
        let s_3875_1: Bits = Bits::new(s_3875_0 as u128, 4u16);
        // C s_3875_2: const #15u : u8
        let s_3875_2: u8 = 15;
        // C s_3875_3: cast zx s_3875_2 -> bv
        let s_3875_3: Bits = Bits::new(s_3875_2 as u128, 4u16);
        // D s_3875_4: cmp-eq s_3875_1 s_3875_3
        let s_3875_4: bool = ((s_3875_1) == (s_3875_3));
        // D s_3875_5: write-var gs#135961 <= s_3875_4
        fn_state.gs_135961 = s_3875_4;
        // N s_3875_6: jump b3334
        return block_3334(state, tracer, fn_state);
    }
    fn block_3876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3876_0: read-var CRn:u8
        let s_3876_0: u8 = fn_state.CRn;
        // D s_3876_1: cast zx s_3876_0 -> bv
        let s_3876_1: Bits = Bits::new(s_3876_0 as u128, 4u16);
        // C s_3876_2: const #13u : u8
        let s_3876_2: u8 = 13;
        // C s_3876_3: cast zx s_3876_2 -> bv
        let s_3876_3: Bits = Bits::new(s_3876_2 as u128, 4u16);
        // D s_3876_4: cmp-eq s_3876_1 s_3876_3
        let s_3876_4: bool = ((s_3876_1) == (s_3876_3));
        // D s_3876_5: write-var gs#135960 <= s_3876_4
        fn_state.gs_135960 = s_3876_4;
        // N s_3876_6: jump b3332
        return block_3332(state, tracer, fn_state);
    }
    fn block_3877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3877_0: read-var el:u8
        let s_3877_0: u8 = fn_state.el;
        // D s_3877_1: read-var coproc:u8
        let s_3877_1: u8 = fn_state.coproc;
        // D s_3877_2: read-var opc1:u8
        let s_3877_2: u8 = fn_state.opc1;
        // D s_3877_3: read-var CRn:u8
        let s_3877_3: u8 = fn_state.CRn;
        // D s_3877_4: read-var opc2:u8
        let s_3877_4: u8 = fn_state.opc2;
        // D s_3877_5: read-var CRm:u8
        let s_3877_5: u8 = fn_state.CRm;
        // D s_3877_6: read-var t:i
        let s_3877_6: i128 = fn_state.t;
        // D s_3877_7: call AMEVTYPER1_SysRegWrite32_10f3aef13e8663a1(s_3877_0, s_3877_1, s_3877_2, s_3877_3, s_3877_4, s_3877_5, s_3877_6)
        let s_3877_7: () = AMEVTYPER1_SysRegWrite32_10f3aef13e8663a1(
            state,
            tracer,
            s_3877_0,
            s_3877_1,
            s_3877_2,
            s_3877_3,
            s_3877_4,
            s_3877_5,
            s_3877_6,
        );
        // N s_3877_8: return
        return;
    }
    fn block_3878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3878_0: read-var opc2:u8
        let s_3878_0: u8 = fn_state.opc2;
        // D s_3878_1: cast zx s_3878_0 -> bv
        let s_3878_1: Bits = Bits::new(s_3878_0 as u128, 3u16);
        // C s_3878_2: const #1u : u8
        let s_3878_2: u8 = 1;
        // C s_3878_3: cast zx s_3878_2 -> bv
        let s_3878_3: Bits = Bits::new(s_3878_2 as u128, 3u16);
        // D s_3878_4: cmp-eq s_3878_1 s_3878_3
        let s_3878_4: bool = ((s_3878_1) == (s_3878_3));
        // D s_3878_5: write-var gs#135959 <= s_3878_4
        fn_state.gs_135959 = s_3878_4;
        // N s_3878_6: jump b3329
        return block_3329(state, tracer, fn_state);
    }
    fn block_3879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3879_0: read-var opc1:u8
        let s_3879_0: u8 = fn_state.opc1;
        // D s_3879_1: cast zx s_3879_0 -> bv
        let s_3879_1: Bits = Bits::new(s_3879_0 as u128, 3u16);
        // C s_3879_2: const #0u : u8
        let s_3879_2: u8 = 0;
        // C s_3879_3: cast zx s_3879_2 -> bv
        let s_3879_3: Bits = Bits::new(s_3879_2 as u128, 3u16);
        // D s_3879_4: cmp-eq s_3879_1 s_3879_3
        let s_3879_4: bool = ((s_3879_1) == (s_3879_3));
        // D s_3879_5: write-var gs#135958 <= s_3879_4
        fn_state.gs_135958 = s_3879_4;
        // N s_3879_6: jump b3327
        return block_3327(state, tracer, fn_state);
    }
    fn block_3880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3880_0: read-var coproc:u8
        let s_3880_0: u8 = fn_state.coproc;
        // D s_3880_1: cast zx s_3880_0 -> bv
        let s_3880_1: Bits = Bits::new(s_3880_0 as u128, 4u16);
        // C s_3880_2: const #15u : u8
        let s_3880_2: u8 = 15;
        // C s_3880_3: cast zx s_3880_2 -> bv
        let s_3880_3: Bits = Bits::new(s_3880_2 as u128, 4u16);
        // D s_3880_4: cmp-eq s_3880_1 s_3880_3
        let s_3880_4: bool = ((s_3880_1) == (s_3880_3));
        // D s_3880_5: write-var gs#135957 <= s_3880_4
        fn_state.gs_135957 = s_3880_4;
        // N s_3880_6: jump b3325
        return block_3325(state, tracer, fn_state);
    }
    fn block_3881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3881_0: read-var CRn:u8
        let s_3881_0: u8 = fn_state.CRn;
        // D s_3881_1: cast zx s_3881_0 -> bv
        let s_3881_1: Bits = Bits::new(s_3881_0 as u128, 4u16);
        // C s_3881_2: const #13u : u8
        let s_3881_2: u8 = 13;
        // C s_3881_3: cast zx s_3881_2 -> bv
        let s_3881_3: Bits = Bits::new(s_3881_2 as u128, 4u16);
        // D s_3881_4: cmp-eq s_3881_1 s_3881_3
        let s_3881_4: bool = ((s_3881_1) == (s_3881_3));
        // D s_3881_5: write-var gs#135956 <= s_3881_4
        fn_state.gs_135956 = s_3881_4;
        // N s_3881_6: jump b3323
        return block_3323(state, tracer, fn_state);
    }
    fn block_3882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3882_0: read-var el:u8
        let s_3882_0: u8 = fn_state.el;
        // D s_3882_1: read-var coproc:u8
        let s_3882_1: u8 = fn_state.coproc;
        // D s_3882_2: read-var opc1:u8
        let s_3882_2: u8 = fn_state.opc1;
        // D s_3882_3: read-var CRn:u8
        let s_3882_3: u8 = fn_state.CRn;
        // D s_3882_4: read-var opc2:u8
        let s_3882_4: u8 = fn_state.opc2;
        // D s_3882_5: read-var CRm:u8
        let s_3882_5: u8 = fn_state.CRm;
        // D s_3882_6: read-var t:i
        let s_3882_6: i128 = fn_state.t;
        // D s_3882_7: call AMEVTYPER1_SysRegWrite32_d066b294b71fc9c6(s_3882_0, s_3882_1, s_3882_2, s_3882_3, s_3882_4, s_3882_5, s_3882_6)
        let s_3882_7: () = AMEVTYPER1_SysRegWrite32_d066b294b71fc9c6(
            state,
            tracer,
            s_3882_0,
            s_3882_1,
            s_3882_2,
            s_3882_3,
            s_3882_4,
            s_3882_5,
            s_3882_6,
        );
        // N s_3882_8: return
        return;
    }
    fn block_3883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3883_0: read-var opc2:u8
        let s_3883_0: u8 = fn_state.opc2;
        // D s_3883_1: cast zx s_3883_0 -> bv
        let s_3883_1: Bits = Bits::new(s_3883_0 as u128, 3u16);
        // C s_3883_2: const #2u : u8
        let s_3883_2: u8 = 2;
        // C s_3883_3: cast zx s_3883_2 -> bv
        let s_3883_3: Bits = Bits::new(s_3883_2 as u128, 3u16);
        // D s_3883_4: cmp-eq s_3883_1 s_3883_3
        let s_3883_4: bool = ((s_3883_1) == (s_3883_3));
        // D s_3883_5: write-var gs#135955 <= s_3883_4
        fn_state.gs_135955 = s_3883_4;
        // N s_3883_6: jump b3320
        return block_3320(state, tracer, fn_state);
    }
    fn block_3884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3884_0: read-var opc1:u8
        let s_3884_0: u8 = fn_state.opc1;
        // D s_3884_1: cast zx s_3884_0 -> bv
        let s_3884_1: Bits = Bits::new(s_3884_0 as u128, 3u16);
        // C s_3884_2: const #0u : u8
        let s_3884_2: u8 = 0;
        // C s_3884_3: cast zx s_3884_2 -> bv
        let s_3884_3: Bits = Bits::new(s_3884_2 as u128, 3u16);
        // D s_3884_4: cmp-eq s_3884_1 s_3884_3
        let s_3884_4: bool = ((s_3884_1) == (s_3884_3));
        // D s_3884_5: write-var gs#135954 <= s_3884_4
        fn_state.gs_135954 = s_3884_4;
        // N s_3884_6: jump b3318
        return block_3318(state, tracer, fn_state);
    }
    fn block_3885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3885_0: read-var coproc:u8
        let s_3885_0: u8 = fn_state.coproc;
        // D s_3885_1: cast zx s_3885_0 -> bv
        let s_3885_1: Bits = Bits::new(s_3885_0 as u128, 4u16);
        // C s_3885_2: const #15u : u8
        let s_3885_2: u8 = 15;
        // C s_3885_3: cast zx s_3885_2 -> bv
        let s_3885_3: Bits = Bits::new(s_3885_2 as u128, 4u16);
        // D s_3885_4: cmp-eq s_3885_1 s_3885_3
        let s_3885_4: bool = ((s_3885_1) == (s_3885_3));
        // D s_3885_5: write-var gs#135953 <= s_3885_4
        fn_state.gs_135953 = s_3885_4;
        // N s_3885_6: jump b3316
        return block_3316(state, tracer, fn_state);
    }
    fn block_3886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3886_0: read-var CRn:u8
        let s_3886_0: u8 = fn_state.CRn;
        // D s_3886_1: cast zx s_3886_0 -> bv
        let s_3886_1: Bits = Bits::new(s_3886_0 as u128, 4u16);
        // C s_3886_2: const #13u : u8
        let s_3886_2: u8 = 13;
        // C s_3886_3: cast zx s_3886_2 -> bv
        let s_3886_3: Bits = Bits::new(s_3886_2 as u128, 4u16);
        // D s_3886_4: cmp-eq s_3886_1 s_3886_3
        let s_3886_4: bool = ((s_3886_1) == (s_3886_3));
        // D s_3886_5: write-var gs#135952 <= s_3886_4
        fn_state.gs_135952 = s_3886_4;
        // N s_3886_6: jump b3314
        return block_3314(state, tracer, fn_state);
    }
    fn block_3887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3887_0: read-var el:u8
        let s_3887_0: u8 = fn_state.el;
        // D s_3887_1: read-var coproc:u8
        let s_3887_1: u8 = fn_state.coproc;
        // D s_3887_2: read-var opc1:u8
        let s_3887_2: u8 = fn_state.opc1;
        // D s_3887_3: read-var CRn:u8
        let s_3887_3: u8 = fn_state.CRn;
        // D s_3887_4: read-var opc2:u8
        let s_3887_4: u8 = fn_state.opc2;
        // D s_3887_5: read-var CRm:u8
        let s_3887_5: u8 = fn_state.CRm;
        // D s_3887_6: read-var t:i
        let s_3887_6: i128 = fn_state.t;
        // D s_3887_7: call AMEVTYPER1_SysRegWrite32_fe1a95b5287339db(s_3887_0, s_3887_1, s_3887_2, s_3887_3, s_3887_4, s_3887_5, s_3887_6)
        let s_3887_7: () = AMEVTYPER1_SysRegWrite32_fe1a95b5287339db(
            state,
            tracer,
            s_3887_0,
            s_3887_1,
            s_3887_2,
            s_3887_3,
            s_3887_4,
            s_3887_5,
            s_3887_6,
        );
        // N s_3887_8: return
        return;
    }
    fn block_3888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3888_0: read-var opc2:u8
        let s_3888_0: u8 = fn_state.opc2;
        // D s_3888_1: cast zx s_3888_0 -> bv
        let s_3888_1: Bits = Bits::new(s_3888_0 as u128, 3u16);
        // C s_3888_2: const #3u : u8
        let s_3888_2: u8 = 3;
        // C s_3888_3: cast zx s_3888_2 -> bv
        let s_3888_3: Bits = Bits::new(s_3888_2 as u128, 3u16);
        // D s_3888_4: cmp-eq s_3888_1 s_3888_3
        let s_3888_4: bool = ((s_3888_1) == (s_3888_3));
        // D s_3888_5: write-var gs#135951 <= s_3888_4
        fn_state.gs_135951 = s_3888_4;
        // N s_3888_6: jump b3311
        return block_3311(state, tracer, fn_state);
    }
    fn block_3889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3889_0: read-var opc1:u8
        let s_3889_0: u8 = fn_state.opc1;
        // D s_3889_1: cast zx s_3889_0 -> bv
        let s_3889_1: Bits = Bits::new(s_3889_0 as u128, 3u16);
        // C s_3889_2: const #0u : u8
        let s_3889_2: u8 = 0;
        // C s_3889_3: cast zx s_3889_2 -> bv
        let s_3889_3: Bits = Bits::new(s_3889_2 as u128, 3u16);
        // D s_3889_4: cmp-eq s_3889_1 s_3889_3
        let s_3889_4: bool = ((s_3889_1) == (s_3889_3));
        // D s_3889_5: write-var gs#135950 <= s_3889_4
        fn_state.gs_135950 = s_3889_4;
        // N s_3889_6: jump b3309
        return block_3309(state, tracer, fn_state);
    }
    fn block_3890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3890_0: read-var coproc:u8
        let s_3890_0: u8 = fn_state.coproc;
        // D s_3890_1: cast zx s_3890_0 -> bv
        let s_3890_1: Bits = Bits::new(s_3890_0 as u128, 4u16);
        // C s_3890_2: const #15u : u8
        let s_3890_2: u8 = 15;
        // C s_3890_3: cast zx s_3890_2 -> bv
        let s_3890_3: Bits = Bits::new(s_3890_2 as u128, 4u16);
        // D s_3890_4: cmp-eq s_3890_1 s_3890_3
        let s_3890_4: bool = ((s_3890_1) == (s_3890_3));
        // D s_3890_5: write-var gs#135949 <= s_3890_4
        fn_state.gs_135949 = s_3890_4;
        // N s_3890_6: jump b3307
        return block_3307(state, tracer, fn_state);
    }
    fn block_3891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3891_0: read-var CRn:u8
        let s_3891_0: u8 = fn_state.CRn;
        // D s_3891_1: cast zx s_3891_0 -> bv
        let s_3891_1: Bits = Bits::new(s_3891_0 as u128, 4u16);
        // C s_3891_2: const #13u : u8
        let s_3891_2: u8 = 13;
        // C s_3891_3: cast zx s_3891_2 -> bv
        let s_3891_3: Bits = Bits::new(s_3891_2 as u128, 4u16);
        // D s_3891_4: cmp-eq s_3891_1 s_3891_3
        let s_3891_4: bool = ((s_3891_1) == (s_3891_3));
        // D s_3891_5: write-var gs#135948 <= s_3891_4
        fn_state.gs_135948 = s_3891_4;
        // N s_3891_6: jump b3305
        return block_3305(state, tracer, fn_state);
    }
    fn block_3892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3892_0: read-var el:u8
        let s_3892_0: u8 = fn_state.el;
        // D s_3892_1: read-var coproc:u8
        let s_3892_1: u8 = fn_state.coproc;
        // D s_3892_2: read-var opc1:u8
        let s_3892_2: u8 = fn_state.opc1;
        // D s_3892_3: read-var CRn:u8
        let s_3892_3: u8 = fn_state.CRn;
        // D s_3892_4: read-var opc2:u8
        let s_3892_4: u8 = fn_state.opc2;
        // D s_3892_5: read-var CRm:u8
        let s_3892_5: u8 = fn_state.CRm;
        // D s_3892_6: read-var t:i
        let s_3892_6: i128 = fn_state.t;
        // D s_3892_7: call AMEVTYPER1_SysRegWrite32_3549526a1f7ad5a9(s_3892_0, s_3892_1, s_3892_2, s_3892_3, s_3892_4, s_3892_5, s_3892_6)
        let s_3892_7: () = AMEVTYPER1_SysRegWrite32_3549526a1f7ad5a9(
            state,
            tracer,
            s_3892_0,
            s_3892_1,
            s_3892_2,
            s_3892_3,
            s_3892_4,
            s_3892_5,
            s_3892_6,
        );
        // N s_3892_8: return
        return;
    }
    fn block_3893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3893_0: read-var opc2:u8
        let s_3893_0: u8 = fn_state.opc2;
        // D s_3893_1: cast zx s_3893_0 -> bv
        let s_3893_1: Bits = Bits::new(s_3893_0 as u128, 3u16);
        // C s_3893_2: const #4u : u8
        let s_3893_2: u8 = 4;
        // C s_3893_3: cast zx s_3893_2 -> bv
        let s_3893_3: Bits = Bits::new(s_3893_2 as u128, 3u16);
        // D s_3893_4: cmp-eq s_3893_1 s_3893_3
        let s_3893_4: bool = ((s_3893_1) == (s_3893_3));
        // D s_3893_5: write-var gs#135947 <= s_3893_4
        fn_state.gs_135947 = s_3893_4;
        // N s_3893_6: jump b3302
        return block_3302(state, tracer, fn_state);
    }
    fn block_3894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3894_0: read-var opc1:u8
        let s_3894_0: u8 = fn_state.opc1;
        // D s_3894_1: cast zx s_3894_0 -> bv
        let s_3894_1: Bits = Bits::new(s_3894_0 as u128, 3u16);
        // C s_3894_2: const #0u : u8
        let s_3894_2: u8 = 0;
        // C s_3894_3: cast zx s_3894_2 -> bv
        let s_3894_3: Bits = Bits::new(s_3894_2 as u128, 3u16);
        // D s_3894_4: cmp-eq s_3894_1 s_3894_3
        let s_3894_4: bool = ((s_3894_1) == (s_3894_3));
        // D s_3894_5: write-var gs#135946 <= s_3894_4
        fn_state.gs_135946 = s_3894_4;
        // N s_3894_6: jump b3300
        return block_3300(state, tracer, fn_state);
    }
    fn block_3895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3895_0: read-var coproc:u8
        let s_3895_0: u8 = fn_state.coproc;
        // D s_3895_1: cast zx s_3895_0 -> bv
        let s_3895_1: Bits = Bits::new(s_3895_0 as u128, 4u16);
        // C s_3895_2: const #15u : u8
        let s_3895_2: u8 = 15;
        // C s_3895_3: cast zx s_3895_2 -> bv
        let s_3895_3: Bits = Bits::new(s_3895_2 as u128, 4u16);
        // D s_3895_4: cmp-eq s_3895_1 s_3895_3
        let s_3895_4: bool = ((s_3895_1) == (s_3895_3));
        // D s_3895_5: write-var gs#135945 <= s_3895_4
        fn_state.gs_135945 = s_3895_4;
        // N s_3895_6: jump b3298
        return block_3298(state, tracer, fn_state);
    }
    fn block_3896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3896_0: read-var CRn:u8
        let s_3896_0: u8 = fn_state.CRn;
        // D s_3896_1: cast zx s_3896_0 -> bv
        let s_3896_1: Bits = Bits::new(s_3896_0 as u128, 4u16);
        // C s_3896_2: const #13u : u8
        let s_3896_2: u8 = 13;
        // C s_3896_3: cast zx s_3896_2 -> bv
        let s_3896_3: Bits = Bits::new(s_3896_2 as u128, 4u16);
        // D s_3896_4: cmp-eq s_3896_1 s_3896_3
        let s_3896_4: bool = ((s_3896_1) == (s_3896_3));
        // D s_3896_5: write-var gs#135944 <= s_3896_4
        fn_state.gs_135944 = s_3896_4;
        // N s_3896_6: jump b3296
        return block_3296(state, tracer, fn_state);
    }
    fn block_3897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3897_0: read-var el:u8
        let s_3897_0: u8 = fn_state.el;
        // D s_3897_1: read-var coproc:u8
        let s_3897_1: u8 = fn_state.coproc;
        // D s_3897_2: read-var opc1:u8
        let s_3897_2: u8 = fn_state.opc1;
        // D s_3897_3: read-var CRn:u8
        let s_3897_3: u8 = fn_state.CRn;
        // D s_3897_4: read-var opc2:u8
        let s_3897_4: u8 = fn_state.opc2;
        // D s_3897_5: read-var CRm:u8
        let s_3897_5: u8 = fn_state.CRm;
        // D s_3897_6: read-var t:i
        let s_3897_6: i128 = fn_state.t;
        // D s_3897_7: call AMEVTYPER1_SysRegWrite32_381d8337f3d30ba8(s_3897_0, s_3897_1, s_3897_2, s_3897_3, s_3897_4, s_3897_5, s_3897_6)
        let s_3897_7: () = AMEVTYPER1_SysRegWrite32_381d8337f3d30ba8(
            state,
            tracer,
            s_3897_0,
            s_3897_1,
            s_3897_2,
            s_3897_3,
            s_3897_4,
            s_3897_5,
            s_3897_6,
        );
        // N s_3897_8: return
        return;
    }
    fn block_3898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3898_0: read-var opc2:u8
        let s_3898_0: u8 = fn_state.opc2;
        // D s_3898_1: cast zx s_3898_0 -> bv
        let s_3898_1: Bits = Bits::new(s_3898_0 as u128, 3u16);
        // C s_3898_2: const #5u : u8
        let s_3898_2: u8 = 5;
        // C s_3898_3: cast zx s_3898_2 -> bv
        let s_3898_3: Bits = Bits::new(s_3898_2 as u128, 3u16);
        // D s_3898_4: cmp-eq s_3898_1 s_3898_3
        let s_3898_4: bool = ((s_3898_1) == (s_3898_3));
        // D s_3898_5: write-var gs#135943 <= s_3898_4
        fn_state.gs_135943 = s_3898_4;
        // N s_3898_6: jump b3293
        return block_3293(state, tracer, fn_state);
    }
    fn block_3899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3899_0: read-var opc1:u8
        let s_3899_0: u8 = fn_state.opc1;
        // D s_3899_1: cast zx s_3899_0 -> bv
        let s_3899_1: Bits = Bits::new(s_3899_0 as u128, 3u16);
        // C s_3899_2: const #0u : u8
        let s_3899_2: u8 = 0;
        // C s_3899_3: cast zx s_3899_2 -> bv
        let s_3899_3: Bits = Bits::new(s_3899_2 as u128, 3u16);
        // D s_3899_4: cmp-eq s_3899_1 s_3899_3
        let s_3899_4: bool = ((s_3899_1) == (s_3899_3));
        // D s_3899_5: write-var gs#135942 <= s_3899_4
        fn_state.gs_135942 = s_3899_4;
        // N s_3899_6: jump b3291
        return block_3291(state, tracer, fn_state);
    }
    fn block_3900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3900_0: read-var coproc:u8
        let s_3900_0: u8 = fn_state.coproc;
        // D s_3900_1: cast zx s_3900_0 -> bv
        let s_3900_1: Bits = Bits::new(s_3900_0 as u128, 4u16);
        // C s_3900_2: const #15u : u8
        let s_3900_2: u8 = 15;
        // C s_3900_3: cast zx s_3900_2 -> bv
        let s_3900_3: Bits = Bits::new(s_3900_2 as u128, 4u16);
        // D s_3900_4: cmp-eq s_3900_1 s_3900_3
        let s_3900_4: bool = ((s_3900_1) == (s_3900_3));
        // D s_3900_5: write-var gs#135941 <= s_3900_4
        fn_state.gs_135941 = s_3900_4;
        // N s_3900_6: jump b3289
        return block_3289(state, tracer, fn_state);
    }
    fn block_3901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3901_0: read-var CRn:u8
        let s_3901_0: u8 = fn_state.CRn;
        // D s_3901_1: cast zx s_3901_0 -> bv
        let s_3901_1: Bits = Bits::new(s_3901_0 as u128, 4u16);
        // C s_3901_2: const #13u : u8
        let s_3901_2: u8 = 13;
        // C s_3901_3: cast zx s_3901_2 -> bv
        let s_3901_3: Bits = Bits::new(s_3901_2 as u128, 4u16);
        // D s_3901_4: cmp-eq s_3901_1 s_3901_3
        let s_3901_4: bool = ((s_3901_1) == (s_3901_3));
        // D s_3901_5: write-var gs#135940 <= s_3901_4
        fn_state.gs_135940 = s_3901_4;
        // N s_3901_6: jump b3287
        return block_3287(state, tracer, fn_state);
    }
    fn block_3902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3902_0: read-var el:u8
        let s_3902_0: u8 = fn_state.el;
        // D s_3902_1: read-var coproc:u8
        let s_3902_1: u8 = fn_state.coproc;
        // D s_3902_2: read-var opc1:u8
        let s_3902_2: u8 = fn_state.opc1;
        // D s_3902_3: read-var CRn:u8
        let s_3902_3: u8 = fn_state.CRn;
        // D s_3902_4: read-var opc2:u8
        let s_3902_4: u8 = fn_state.opc2;
        // D s_3902_5: read-var CRm:u8
        let s_3902_5: u8 = fn_state.CRm;
        // D s_3902_6: read-var t:i
        let s_3902_6: i128 = fn_state.t;
        // D s_3902_7: call AMEVTYPER1_SysRegWrite32_d612c920e0f1e095(s_3902_0, s_3902_1, s_3902_2, s_3902_3, s_3902_4, s_3902_5, s_3902_6)
        let s_3902_7: () = AMEVTYPER1_SysRegWrite32_d612c920e0f1e095(
            state,
            tracer,
            s_3902_0,
            s_3902_1,
            s_3902_2,
            s_3902_3,
            s_3902_4,
            s_3902_5,
            s_3902_6,
        );
        // N s_3902_8: return
        return;
    }
    fn block_3903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3903_0: read-var opc2:u8
        let s_3903_0: u8 = fn_state.opc2;
        // D s_3903_1: cast zx s_3903_0 -> bv
        let s_3903_1: Bits = Bits::new(s_3903_0 as u128, 3u16);
        // C s_3903_2: const #6u : u8
        let s_3903_2: u8 = 6;
        // C s_3903_3: cast zx s_3903_2 -> bv
        let s_3903_3: Bits = Bits::new(s_3903_2 as u128, 3u16);
        // D s_3903_4: cmp-eq s_3903_1 s_3903_3
        let s_3903_4: bool = ((s_3903_1) == (s_3903_3));
        // D s_3903_5: write-var gs#135939 <= s_3903_4
        fn_state.gs_135939 = s_3903_4;
        // N s_3903_6: jump b3284
        return block_3284(state, tracer, fn_state);
    }
    fn block_3904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3904_0: read-var opc1:u8
        let s_3904_0: u8 = fn_state.opc1;
        // D s_3904_1: cast zx s_3904_0 -> bv
        let s_3904_1: Bits = Bits::new(s_3904_0 as u128, 3u16);
        // C s_3904_2: const #0u : u8
        let s_3904_2: u8 = 0;
        // C s_3904_3: cast zx s_3904_2 -> bv
        let s_3904_3: Bits = Bits::new(s_3904_2 as u128, 3u16);
        // D s_3904_4: cmp-eq s_3904_1 s_3904_3
        let s_3904_4: bool = ((s_3904_1) == (s_3904_3));
        // D s_3904_5: write-var gs#135938 <= s_3904_4
        fn_state.gs_135938 = s_3904_4;
        // N s_3904_6: jump b3282
        return block_3282(state, tracer, fn_state);
    }
    fn block_3905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3905_0: read-var coproc:u8
        let s_3905_0: u8 = fn_state.coproc;
        // D s_3905_1: cast zx s_3905_0 -> bv
        let s_3905_1: Bits = Bits::new(s_3905_0 as u128, 4u16);
        // C s_3905_2: const #15u : u8
        let s_3905_2: u8 = 15;
        // C s_3905_3: cast zx s_3905_2 -> bv
        let s_3905_3: Bits = Bits::new(s_3905_2 as u128, 4u16);
        // D s_3905_4: cmp-eq s_3905_1 s_3905_3
        let s_3905_4: bool = ((s_3905_1) == (s_3905_3));
        // D s_3905_5: write-var gs#135937 <= s_3905_4
        fn_state.gs_135937 = s_3905_4;
        // N s_3905_6: jump b3280
        return block_3280(state, tracer, fn_state);
    }
    fn block_3906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3906_0: read-var CRn:u8
        let s_3906_0: u8 = fn_state.CRn;
        // D s_3906_1: cast zx s_3906_0 -> bv
        let s_3906_1: Bits = Bits::new(s_3906_0 as u128, 4u16);
        // C s_3906_2: const #13u : u8
        let s_3906_2: u8 = 13;
        // C s_3906_3: cast zx s_3906_2 -> bv
        let s_3906_3: Bits = Bits::new(s_3906_2 as u128, 4u16);
        // D s_3906_4: cmp-eq s_3906_1 s_3906_3
        let s_3906_4: bool = ((s_3906_1) == (s_3906_3));
        // D s_3906_5: write-var gs#135936 <= s_3906_4
        fn_state.gs_135936 = s_3906_4;
        // N s_3906_6: jump b3278
        return block_3278(state, tracer, fn_state);
    }
    fn block_3907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3907_0: read-var el:u8
        let s_3907_0: u8 = fn_state.el;
        // D s_3907_1: read-var coproc:u8
        let s_3907_1: u8 = fn_state.coproc;
        // D s_3907_2: read-var opc1:u8
        let s_3907_2: u8 = fn_state.opc1;
        // D s_3907_3: read-var CRn:u8
        let s_3907_3: u8 = fn_state.CRn;
        // D s_3907_4: read-var opc2:u8
        let s_3907_4: u8 = fn_state.opc2;
        // D s_3907_5: read-var CRm:u8
        let s_3907_5: u8 = fn_state.CRm;
        // D s_3907_6: read-var t:i
        let s_3907_6: i128 = fn_state.t;
        // D s_3907_7: call AMEVTYPER1_SysRegWrite32_1c15a0e3b00864c2(s_3907_0, s_3907_1, s_3907_2, s_3907_3, s_3907_4, s_3907_5, s_3907_6)
        let s_3907_7: () = AMEVTYPER1_SysRegWrite32_1c15a0e3b00864c2(
            state,
            tracer,
            s_3907_0,
            s_3907_1,
            s_3907_2,
            s_3907_3,
            s_3907_4,
            s_3907_5,
            s_3907_6,
        );
        // N s_3907_8: return
        return;
    }
    fn block_3908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3908_0: read-var opc2:u8
        let s_3908_0: u8 = fn_state.opc2;
        // D s_3908_1: cast zx s_3908_0 -> bv
        let s_3908_1: Bits = Bits::new(s_3908_0 as u128, 3u16);
        // C s_3908_2: const #7u : u8
        let s_3908_2: u8 = 7;
        // C s_3908_3: cast zx s_3908_2 -> bv
        let s_3908_3: Bits = Bits::new(s_3908_2 as u128, 3u16);
        // D s_3908_4: cmp-eq s_3908_1 s_3908_3
        let s_3908_4: bool = ((s_3908_1) == (s_3908_3));
        // D s_3908_5: write-var gs#135935 <= s_3908_4
        fn_state.gs_135935 = s_3908_4;
        // N s_3908_6: jump b3275
        return block_3275(state, tracer, fn_state);
    }
    fn block_3909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3909_0: read-var opc1:u8
        let s_3909_0: u8 = fn_state.opc1;
        // D s_3909_1: cast zx s_3909_0 -> bv
        let s_3909_1: Bits = Bits::new(s_3909_0 as u128, 3u16);
        // C s_3909_2: const #0u : u8
        let s_3909_2: u8 = 0;
        // C s_3909_3: cast zx s_3909_2 -> bv
        let s_3909_3: Bits = Bits::new(s_3909_2 as u128, 3u16);
        // D s_3909_4: cmp-eq s_3909_1 s_3909_3
        let s_3909_4: bool = ((s_3909_1) == (s_3909_3));
        // D s_3909_5: write-var gs#135934 <= s_3909_4
        fn_state.gs_135934 = s_3909_4;
        // N s_3909_6: jump b3273
        return block_3273(state, tracer, fn_state);
    }
    fn block_3910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3910_0: read-var coproc:u8
        let s_3910_0: u8 = fn_state.coproc;
        // D s_3910_1: cast zx s_3910_0 -> bv
        let s_3910_1: Bits = Bits::new(s_3910_0 as u128, 4u16);
        // C s_3910_2: const #15u : u8
        let s_3910_2: u8 = 15;
        // C s_3910_3: cast zx s_3910_2 -> bv
        let s_3910_3: Bits = Bits::new(s_3910_2 as u128, 4u16);
        // D s_3910_4: cmp-eq s_3910_1 s_3910_3
        let s_3910_4: bool = ((s_3910_1) == (s_3910_3));
        // D s_3910_5: write-var gs#135933 <= s_3910_4
        fn_state.gs_135933 = s_3910_4;
        // N s_3910_6: jump b3271
        return block_3271(state, tracer, fn_state);
    }
    fn block_3911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3911_0: read-var CRn:u8
        let s_3911_0: u8 = fn_state.CRn;
        // D s_3911_1: cast zx s_3911_0 -> bv
        let s_3911_1: Bits = Bits::new(s_3911_0 as u128, 4u16);
        // C s_3911_2: const #13u : u8
        let s_3911_2: u8 = 13;
        // C s_3911_3: cast zx s_3911_2 -> bv
        let s_3911_3: Bits = Bits::new(s_3911_2 as u128, 4u16);
        // D s_3911_4: cmp-eq s_3911_1 s_3911_3
        let s_3911_4: bool = ((s_3911_1) == (s_3911_3));
        // D s_3911_5: write-var gs#135932 <= s_3911_4
        fn_state.gs_135932 = s_3911_4;
        // N s_3911_6: jump b3269
        return block_3269(state, tracer, fn_state);
    }
    fn block_3912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3912_0: read-var el:u8
        let s_3912_0: u8 = fn_state.el;
        // D s_3912_1: read-var coproc:u8
        let s_3912_1: u8 = fn_state.coproc;
        // D s_3912_2: read-var opc1:u8
        let s_3912_2: u8 = fn_state.opc1;
        // D s_3912_3: read-var CRn:u8
        let s_3912_3: u8 = fn_state.CRn;
        // D s_3912_4: read-var opc2:u8
        let s_3912_4: u8 = fn_state.opc2;
        // D s_3912_5: read-var CRm:u8
        let s_3912_5: u8 = fn_state.CRm;
        // D s_3912_6: read-var t:i
        let s_3912_6: i128 = fn_state.t;
        // D s_3912_7: call AMEVTYPER1_SysRegWrite32_c08be1aaf0c6ac78(s_3912_0, s_3912_1, s_3912_2, s_3912_3, s_3912_4, s_3912_5, s_3912_6)
        let s_3912_7: () = AMEVTYPER1_SysRegWrite32_c08be1aaf0c6ac78(
            state,
            tracer,
            s_3912_0,
            s_3912_1,
            s_3912_2,
            s_3912_3,
            s_3912_4,
            s_3912_5,
            s_3912_6,
        );
        // N s_3912_8: return
        return;
    }
    fn block_3913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3913_0: read-var opc2:u8
        let s_3913_0: u8 = fn_state.opc2;
        // D s_3913_1: cast zx s_3913_0 -> bv
        let s_3913_1: Bits = Bits::new(s_3913_0 as u128, 3u16);
        // C s_3913_2: const #0u : u8
        let s_3913_2: u8 = 0;
        // C s_3913_3: cast zx s_3913_2 -> bv
        let s_3913_3: Bits = Bits::new(s_3913_2 as u128, 3u16);
        // D s_3913_4: cmp-eq s_3913_1 s_3913_3
        let s_3913_4: bool = ((s_3913_1) == (s_3913_3));
        // D s_3913_5: write-var gs#135931 <= s_3913_4
        fn_state.gs_135931 = s_3913_4;
        // N s_3913_6: jump b3266
        return block_3266(state, tracer, fn_state);
    }
    fn block_3914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3914_0: read-var opc1:u8
        let s_3914_0: u8 = fn_state.opc1;
        // D s_3914_1: cast zx s_3914_0 -> bv
        let s_3914_1: Bits = Bits::new(s_3914_0 as u128, 3u16);
        // C s_3914_2: const #0u : u8
        let s_3914_2: u8 = 0;
        // C s_3914_3: cast zx s_3914_2 -> bv
        let s_3914_3: Bits = Bits::new(s_3914_2 as u128, 3u16);
        // D s_3914_4: cmp-eq s_3914_1 s_3914_3
        let s_3914_4: bool = ((s_3914_1) == (s_3914_3));
        // D s_3914_5: write-var gs#135930 <= s_3914_4
        fn_state.gs_135930 = s_3914_4;
        // N s_3914_6: jump b3264
        return block_3264(state, tracer, fn_state);
    }
    fn block_3915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3915_0: read-var coproc:u8
        let s_3915_0: u8 = fn_state.coproc;
        // D s_3915_1: cast zx s_3915_0 -> bv
        let s_3915_1: Bits = Bits::new(s_3915_0 as u128, 4u16);
        // C s_3915_2: const #15u : u8
        let s_3915_2: u8 = 15;
        // C s_3915_3: cast zx s_3915_2 -> bv
        let s_3915_3: Bits = Bits::new(s_3915_2 as u128, 4u16);
        // D s_3915_4: cmp-eq s_3915_1 s_3915_3
        let s_3915_4: bool = ((s_3915_1) == (s_3915_3));
        // D s_3915_5: write-var gs#135929 <= s_3915_4
        fn_state.gs_135929 = s_3915_4;
        // N s_3915_6: jump b3262
        return block_3262(state, tracer, fn_state);
    }
    fn block_3916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3916_0: read-var CRn:u8
        let s_3916_0: u8 = fn_state.CRn;
        // D s_3916_1: cast zx s_3916_0 -> bv
        let s_3916_1: Bits = Bits::new(s_3916_0 as u128, 4u16);
        // C s_3916_2: const #13u : u8
        let s_3916_2: u8 = 13;
        // C s_3916_3: cast zx s_3916_2 -> bv
        let s_3916_3: Bits = Bits::new(s_3916_2 as u128, 4u16);
        // D s_3916_4: cmp-eq s_3916_1 s_3916_3
        let s_3916_4: bool = ((s_3916_1) == (s_3916_3));
        // D s_3916_5: write-var gs#135928 <= s_3916_4
        fn_state.gs_135928 = s_3916_4;
        // N s_3916_6: jump b3260
        return block_3260(state, tracer, fn_state);
    }
    fn block_3917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3917_0: read-var el:u8
        let s_3917_0: u8 = fn_state.el;
        // D s_3917_1: read-var coproc:u8
        let s_3917_1: u8 = fn_state.coproc;
        // D s_3917_2: read-var opc1:u8
        let s_3917_2: u8 = fn_state.opc1;
        // D s_3917_3: read-var CRn:u8
        let s_3917_3: u8 = fn_state.CRn;
        // D s_3917_4: read-var opc2:u8
        let s_3917_4: u8 = fn_state.opc2;
        // D s_3917_5: read-var CRm:u8
        let s_3917_5: u8 = fn_state.CRm;
        // D s_3917_6: read-var t:i
        let s_3917_6: i128 = fn_state.t;
        // D s_3917_7: call AMEVTYPER1_SysRegWrite32_5157ae2713cc2d9d(s_3917_0, s_3917_1, s_3917_2, s_3917_3, s_3917_4, s_3917_5, s_3917_6)
        let s_3917_7: () = AMEVTYPER1_SysRegWrite32_5157ae2713cc2d9d(
            state,
            tracer,
            s_3917_0,
            s_3917_1,
            s_3917_2,
            s_3917_3,
            s_3917_4,
            s_3917_5,
            s_3917_6,
        );
        // N s_3917_8: return
        return;
    }
    fn block_3918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3918_0: read-var opc2:u8
        let s_3918_0: u8 = fn_state.opc2;
        // D s_3918_1: cast zx s_3918_0 -> bv
        let s_3918_1: Bits = Bits::new(s_3918_0 as u128, 3u16);
        // C s_3918_2: const #1u : u8
        let s_3918_2: u8 = 1;
        // C s_3918_3: cast zx s_3918_2 -> bv
        let s_3918_3: Bits = Bits::new(s_3918_2 as u128, 3u16);
        // D s_3918_4: cmp-eq s_3918_1 s_3918_3
        let s_3918_4: bool = ((s_3918_1) == (s_3918_3));
        // D s_3918_5: write-var gs#135927 <= s_3918_4
        fn_state.gs_135927 = s_3918_4;
        // N s_3918_6: jump b3257
        return block_3257(state, tracer, fn_state);
    }
    fn block_3919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3919_0: read-var opc1:u8
        let s_3919_0: u8 = fn_state.opc1;
        // D s_3919_1: cast zx s_3919_0 -> bv
        let s_3919_1: Bits = Bits::new(s_3919_0 as u128, 3u16);
        // C s_3919_2: const #0u : u8
        let s_3919_2: u8 = 0;
        // C s_3919_3: cast zx s_3919_2 -> bv
        let s_3919_3: Bits = Bits::new(s_3919_2 as u128, 3u16);
        // D s_3919_4: cmp-eq s_3919_1 s_3919_3
        let s_3919_4: bool = ((s_3919_1) == (s_3919_3));
        // D s_3919_5: write-var gs#135926 <= s_3919_4
        fn_state.gs_135926 = s_3919_4;
        // N s_3919_6: jump b3255
        return block_3255(state, tracer, fn_state);
    }
    fn block_3920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3920_0: read-var coproc:u8
        let s_3920_0: u8 = fn_state.coproc;
        // D s_3920_1: cast zx s_3920_0 -> bv
        let s_3920_1: Bits = Bits::new(s_3920_0 as u128, 4u16);
        // C s_3920_2: const #15u : u8
        let s_3920_2: u8 = 15;
        // C s_3920_3: cast zx s_3920_2 -> bv
        let s_3920_3: Bits = Bits::new(s_3920_2 as u128, 4u16);
        // D s_3920_4: cmp-eq s_3920_1 s_3920_3
        let s_3920_4: bool = ((s_3920_1) == (s_3920_3));
        // D s_3920_5: write-var gs#135925 <= s_3920_4
        fn_state.gs_135925 = s_3920_4;
        // N s_3920_6: jump b3253
        return block_3253(state, tracer, fn_state);
    }
    fn block_3921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3921_0: read-var CRn:u8
        let s_3921_0: u8 = fn_state.CRn;
        // D s_3921_1: cast zx s_3921_0 -> bv
        let s_3921_1: Bits = Bits::new(s_3921_0 as u128, 4u16);
        // C s_3921_2: const #13u : u8
        let s_3921_2: u8 = 13;
        // C s_3921_3: cast zx s_3921_2 -> bv
        let s_3921_3: Bits = Bits::new(s_3921_2 as u128, 4u16);
        // D s_3921_4: cmp-eq s_3921_1 s_3921_3
        let s_3921_4: bool = ((s_3921_1) == (s_3921_3));
        // D s_3921_5: write-var gs#135924 <= s_3921_4
        fn_state.gs_135924 = s_3921_4;
        // N s_3921_6: jump b3251
        return block_3251(state, tracer, fn_state);
    }
    fn block_3922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3922_0: read-var el:u8
        let s_3922_0: u8 = fn_state.el;
        // D s_3922_1: read-var coproc:u8
        let s_3922_1: u8 = fn_state.coproc;
        // D s_3922_2: read-var opc1:u8
        let s_3922_2: u8 = fn_state.opc1;
        // D s_3922_3: read-var CRn:u8
        let s_3922_3: u8 = fn_state.CRn;
        // D s_3922_4: read-var opc2:u8
        let s_3922_4: u8 = fn_state.opc2;
        // D s_3922_5: read-var CRm:u8
        let s_3922_5: u8 = fn_state.CRm;
        // D s_3922_6: read-var t:i
        let s_3922_6: i128 = fn_state.t;
        // D s_3922_7: call AMEVTYPER1_SysRegWrite32_405b1a2a28f91a31(s_3922_0, s_3922_1, s_3922_2, s_3922_3, s_3922_4, s_3922_5, s_3922_6)
        let s_3922_7: () = AMEVTYPER1_SysRegWrite32_405b1a2a28f91a31(
            state,
            tracer,
            s_3922_0,
            s_3922_1,
            s_3922_2,
            s_3922_3,
            s_3922_4,
            s_3922_5,
            s_3922_6,
        );
        // N s_3922_8: return
        return;
    }
    fn block_3923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3923_0: read-var opc2:u8
        let s_3923_0: u8 = fn_state.opc2;
        // D s_3923_1: cast zx s_3923_0 -> bv
        let s_3923_1: Bits = Bits::new(s_3923_0 as u128, 3u16);
        // C s_3923_2: const #2u : u8
        let s_3923_2: u8 = 2;
        // C s_3923_3: cast zx s_3923_2 -> bv
        let s_3923_3: Bits = Bits::new(s_3923_2 as u128, 3u16);
        // D s_3923_4: cmp-eq s_3923_1 s_3923_3
        let s_3923_4: bool = ((s_3923_1) == (s_3923_3));
        // D s_3923_5: write-var gs#135923 <= s_3923_4
        fn_state.gs_135923 = s_3923_4;
        // N s_3923_6: jump b3248
        return block_3248(state, tracer, fn_state);
    }
    fn block_3924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3924_0: read-var opc1:u8
        let s_3924_0: u8 = fn_state.opc1;
        // D s_3924_1: cast zx s_3924_0 -> bv
        let s_3924_1: Bits = Bits::new(s_3924_0 as u128, 3u16);
        // C s_3924_2: const #0u : u8
        let s_3924_2: u8 = 0;
        // C s_3924_3: cast zx s_3924_2 -> bv
        let s_3924_3: Bits = Bits::new(s_3924_2 as u128, 3u16);
        // D s_3924_4: cmp-eq s_3924_1 s_3924_3
        let s_3924_4: bool = ((s_3924_1) == (s_3924_3));
        // D s_3924_5: write-var gs#135922 <= s_3924_4
        fn_state.gs_135922 = s_3924_4;
        // N s_3924_6: jump b3246
        return block_3246(state, tracer, fn_state);
    }
    fn block_3925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3925_0: read-var coproc:u8
        let s_3925_0: u8 = fn_state.coproc;
        // D s_3925_1: cast zx s_3925_0 -> bv
        let s_3925_1: Bits = Bits::new(s_3925_0 as u128, 4u16);
        // C s_3925_2: const #15u : u8
        let s_3925_2: u8 = 15;
        // C s_3925_3: cast zx s_3925_2 -> bv
        let s_3925_3: Bits = Bits::new(s_3925_2 as u128, 4u16);
        // D s_3925_4: cmp-eq s_3925_1 s_3925_3
        let s_3925_4: bool = ((s_3925_1) == (s_3925_3));
        // D s_3925_5: write-var gs#135921 <= s_3925_4
        fn_state.gs_135921 = s_3925_4;
        // N s_3925_6: jump b3244
        return block_3244(state, tracer, fn_state);
    }
    fn block_3926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3926_0: read-var CRn:u8
        let s_3926_0: u8 = fn_state.CRn;
        // D s_3926_1: cast zx s_3926_0 -> bv
        let s_3926_1: Bits = Bits::new(s_3926_0 as u128, 4u16);
        // C s_3926_2: const #13u : u8
        let s_3926_2: u8 = 13;
        // C s_3926_3: cast zx s_3926_2 -> bv
        let s_3926_3: Bits = Bits::new(s_3926_2 as u128, 4u16);
        // D s_3926_4: cmp-eq s_3926_1 s_3926_3
        let s_3926_4: bool = ((s_3926_1) == (s_3926_3));
        // D s_3926_5: write-var gs#135920 <= s_3926_4
        fn_state.gs_135920 = s_3926_4;
        // N s_3926_6: jump b3242
        return block_3242(state, tracer, fn_state);
    }
    fn block_3927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3927_0: read-var el:u8
        let s_3927_0: u8 = fn_state.el;
        // D s_3927_1: read-var coproc:u8
        let s_3927_1: u8 = fn_state.coproc;
        // D s_3927_2: read-var opc1:u8
        let s_3927_2: u8 = fn_state.opc1;
        // D s_3927_3: read-var CRn:u8
        let s_3927_3: u8 = fn_state.CRn;
        // D s_3927_4: read-var opc2:u8
        let s_3927_4: u8 = fn_state.opc2;
        // D s_3927_5: read-var CRm:u8
        let s_3927_5: u8 = fn_state.CRm;
        // D s_3927_6: read-var t:i
        let s_3927_6: i128 = fn_state.t;
        // D s_3927_7: call AMEVTYPER1_SysRegWrite32_5a1635be7bbcd05b(s_3927_0, s_3927_1, s_3927_2, s_3927_3, s_3927_4, s_3927_5, s_3927_6)
        let s_3927_7: () = AMEVTYPER1_SysRegWrite32_5a1635be7bbcd05b(
            state,
            tracer,
            s_3927_0,
            s_3927_1,
            s_3927_2,
            s_3927_3,
            s_3927_4,
            s_3927_5,
            s_3927_6,
        );
        // N s_3927_8: return
        return;
    }
    fn block_3928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3928_0: read-var opc2:u8
        let s_3928_0: u8 = fn_state.opc2;
        // D s_3928_1: cast zx s_3928_0 -> bv
        let s_3928_1: Bits = Bits::new(s_3928_0 as u128, 3u16);
        // C s_3928_2: const #3u : u8
        let s_3928_2: u8 = 3;
        // C s_3928_3: cast zx s_3928_2 -> bv
        let s_3928_3: Bits = Bits::new(s_3928_2 as u128, 3u16);
        // D s_3928_4: cmp-eq s_3928_1 s_3928_3
        let s_3928_4: bool = ((s_3928_1) == (s_3928_3));
        // D s_3928_5: write-var gs#135919 <= s_3928_4
        fn_state.gs_135919 = s_3928_4;
        // N s_3928_6: jump b3239
        return block_3239(state, tracer, fn_state);
    }
    fn block_3929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3929_0: read-var opc1:u8
        let s_3929_0: u8 = fn_state.opc1;
        // D s_3929_1: cast zx s_3929_0 -> bv
        let s_3929_1: Bits = Bits::new(s_3929_0 as u128, 3u16);
        // C s_3929_2: const #0u : u8
        let s_3929_2: u8 = 0;
        // C s_3929_3: cast zx s_3929_2 -> bv
        let s_3929_3: Bits = Bits::new(s_3929_2 as u128, 3u16);
        // D s_3929_4: cmp-eq s_3929_1 s_3929_3
        let s_3929_4: bool = ((s_3929_1) == (s_3929_3));
        // D s_3929_5: write-var gs#135918 <= s_3929_4
        fn_state.gs_135918 = s_3929_4;
        // N s_3929_6: jump b3237
        return block_3237(state, tracer, fn_state);
    }
    fn block_3930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3930_0: read-var coproc:u8
        let s_3930_0: u8 = fn_state.coproc;
        // D s_3930_1: cast zx s_3930_0 -> bv
        let s_3930_1: Bits = Bits::new(s_3930_0 as u128, 4u16);
        // C s_3930_2: const #15u : u8
        let s_3930_2: u8 = 15;
        // C s_3930_3: cast zx s_3930_2 -> bv
        let s_3930_3: Bits = Bits::new(s_3930_2 as u128, 4u16);
        // D s_3930_4: cmp-eq s_3930_1 s_3930_3
        let s_3930_4: bool = ((s_3930_1) == (s_3930_3));
        // D s_3930_5: write-var gs#135917 <= s_3930_4
        fn_state.gs_135917 = s_3930_4;
        // N s_3930_6: jump b3235
        return block_3235(state, tracer, fn_state);
    }
    fn block_3931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3931_0: read-var CRn:u8
        let s_3931_0: u8 = fn_state.CRn;
        // D s_3931_1: cast zx s_3931_0 -> bv
        let s_3931_1: Bits = Bits::new(s_3931_0 as u128, 4u16);
        // C s_3931_2: const #13u : u8
        let s_3931_2: u8 = 13;
        // C s_3931_3: cast zx s_3931_2 -> bv
        let s_3931_3: Bits = Bits::new(s_3931_2 as u128, 4u16);
        // D s_3931_4: cmp-eq s_3931_1 s_3931_3
        let s_3931_4: bool = ((s_3931_1) == (s_3931_3));
        // D s_3931_5: write-var gs#135916 <= s_3931_4
        fn_state.gs_135916 = s_3931_4;
        // N s_3931_6: jump b3233
        return block_3233(state, tracer, fn_state);
    }
    fn block_3932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3932_0: read-var el:u8
        let s_3932_0: u8 = fn_state.el;
        // D s_3932_1: read-var coproc:u8
        let s_3932_1: u8 = fn_state.coproc;
        // D s_3932_2: read-var opc1:u8
        let s_3932_2: u8 = fn_state.opc1;
        // D s_3932_3: read-var CRn:u8
        let s_3932_3: u8 = fn_state.CRn;
        // D s_3932_4: read-var opc2:u8
        let s_3932_4: u8 = fn_state.opc2;
        // D s_3932_5: read-var CRm:u8
        let s_3932_5: u8 = fn_state.CRm;
        // D s_3932_6: read-var t:i
        let s_3932_6: i128 = fn_state.t;
        // D s_3932_7: call AMEVTYPER1_SysRegWrite32_a868a5149842a50f(s_3932_0, s_3932_1, s_3932_2, s_3932_3, s_3932_4, s_3932_5, s_3932_6)
        let s_3932_7: () = AMEVTYPER1_SysRegWrite32_a868a5149842a50f(
            state,
            tracer,
            s_3932_0,
            s_3932_1,
            s_3932_2,
            s_3932_3,
            s_3932_4,
            s_3932_5,
            s_3932_6,
        );
        // N s_3932_8: return
        return;
    }
    fn block_3933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3933_0: read-var opc2:u8
        let s_3933_0: u8 = fn_state.opc2;
        // D s_3933_1: cast zx s_3933_0 -> bv
        let s_3933_1: Bits = Bits::new(s_3933_0 as u128, 3u16);
        // C s_3933_2: const #4u : u8
        let s_3933_2: u8 = 4;
        // C s_3933_3: cast zx s_3933_2 -> bv
        let s_3933_3: Bits = Bits::new(s_3933_2 as u128, 3u16);
        // D s_3933_4: cmp-eq s_3933_1 s_3933_3
        let s_3933_4: bool = ((s_3933_1) == (s_3933_3));
        // D s_3933_5: write-var gs#135915 <= s_3933_4
        fn_state.gs_135915 = s_3933_4;
        // N s_3933_6: jump b3230
        return block_3230(state, tracer, fn_state);
    }
    fn block_3934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3934_0: read-var opc1:u8
        let s_3934_0: u8 = fn_state.opc1;
        // D s_3934_1: cast zx s_3934_0 -> bv
        let s_3934_1: Bits = Bits::new(s_3934_0 as u128, 3u16);
        // C s_3934_2: const #0u : u8
        let s_3934_2: u8 = 0;
        // C s_3934_3: cast zx s_3934_2 -> bv
        let s_3934_3: Bits = Bits::new(s_3934_2 as u128, 3u16);
        // D s_3934_4: cmp-eq s_3934_1 s_3934_3
        let s_3934_4: bool = ((s_3934_1) == (s_3934_3));
        // D s_3934_5: write-var gs#135914 <= s_3934_4
        fn_state.gs_135914 = s_3934_4;
        // N s_3934_6: jump b3228
        return block_3228(state, tracer, fn_state);
    }
    fn block_3935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3935_0: read-var coproc:u8
        let s_3935_0: u8 = fn_state.coproc;
        // D s_3935_1: cast zx s_3935_0 -> bv
        let s_3935_1: Bits = Bits::new(s_3935_0 as u128, 4u16);
        // C s_3935_2: const #15u : u8
        let s_3935_2: u8 = 15;
        // C s_3935_3: cast zx s_3935_2 -> bv
        let s_3935_3: Bits = Bits::new(s_3935_2 as u128, 4u16);
        // D s_3935_4: cmp-eq s_3935_1 s_3935_3
        let s_3935_4: bool = ((s_3935_1) == (s_3935_3));
        // D s_3935_5: write-var gs#135913 <= s_3935_4
        fn_state.gs_135913 = s_3935_4;
        // N s_3935_6: jump b3226
        return block_3226(state, tracer, fn_state);
    }
    fn block_3936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3936_0: read-var CRn:u8
        let s_3936_0: u8 = fn_state.CRn;
        // D s_3936_1: cast zx s_3936_0 -> bv
        let s_3936_1: Bits = Bits::new(s_3936_0 as u128, 4u16);
        // C s_3936_2: const #13u : u8
        let s_3936_2: u8 = 13;
        // C s_3936_3: cast zx s_3936_2 -> bv
        let s_3936_3: Bits = Bits::new(s_3936_2 as u128, 4u16);
        // D s_3936_4: cmp-eq s_3936_1 s_3936_3
        let s_3936_4: bool = ((s_3936_1) == (s_3936_3));
        // D s_3936_5: write-var gs#135912 <= s_3936_4
        fn_state.gs_135912 = s_3936_4;
        // N s_3936_6: jump b3224
        return block_3224(state, tracer, fn_state);
    }
    fn block_3937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3937_0: read-var el:u8
        let s_3937_0: u8 = fn_state.el;
        // D s_3937_1: read-var coproc:u8
        let s_3937_1: u8 = fn_state.coproc;
        // D s_3937_2: read-var opc1:u8
        let s_3937_2: u8 = fn_state.opc1;
        // D s_3937_3: read-var CRn:u8
        let s_3937_3: u8 = fn_state.CRn;
        // D s_3937_4: read-var opc2:u8
        let s_3937_4: u8 = fn_state.opc2;
        // D s_3937_5: read-var CRm:u8
        let s_3937_5: u8 = fn_state.CRm;
        // D s_3937_6: read-var t:i
        let s_3937_6: i128 = fn_state.t;
        // D s_3937_7: call AMEVTYPER1_SysRegWrite32_3f6816ffcd57dccb(s_3937_0, s_3937_1, s_3937_2, s_3937_3, s_3937_4, s_3937_5, s_3937_6)
        let s_3937_7: () = AMEVTYPER1_SysRegWrite32_3f6816ffcd57dccb(
            state,
            tracer,
            s_3937_0,
            s_3937_1,
            s_3937_2,
            s_3937_3,
            s_3937_4,
            s_3937_5,
            s_3937_6,
        );
        // N s_3937_8: return
        return;
    }
    fn block_3938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3938_0: read-var opc2:u8
        let s_3938_0: u8 = fn_state.opc2;
        // D s_3938_1: cast zx s_3938_0 -> bv
        let s_3938_1: Bits = Bits::new(s_3938_0 as u128, 3u16);
        // C s_3938_2: const #5u : u8
        let s_3938_2: u8 = 5;
        // C s_3938_3: cast zx s_3938_2 -> bv
        let s_3938_3: Bits = Bits::new(s_3938_2 as u128, 3u16);
        // D s_3938_4: cmp-eq s_3938_1 s_3938_3
        let s_3938_4: bool = ((s_3938_1) == (s_3938_3));
        // D s_3938_5: write-var gs#135911 <= s_3938_4
        fn_state.gs_135911 = s_3938_4;
        // N s_3938_6: jump b3221
        return block_3221(state, tracer, fn_state);
    }
    fn block_3939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3939_0: read-var opc1:u8
        let s_3939_0: u8 = fn_state.opc1;
        // D s_3939_1: cast zx s_3939_0 -> bv
        let s_3939_1: Bits = Bits::new(s_3939_0 as u128, 3u16);
        // C s_3939_2: const #0u : u8
        let s_3939_2: u8 = 0;
        // C s_3939_3: cast zx s_3939_2 -> bv
        let s_3939_3: Bits = Bits::new(s_3939_2 as u128, 3u16);
        // D s_3939_4: cmp-eq s_3939_1 s_3939_3
        let s_3939_4: bool = ((s_3939_1) == (s_3939_3));
        // D s_3939_5: write-var gs#135910 <= s_3939_4
        fn_state.gs_135910 = s_3939_4;
        // N s_3939_6: jump b3219
        return block_3219(state, tracer, fn_state);
    }
    fn block_3940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3940_0: read-var coproc:u8
        let s_3940_0: u8 = fn_state.coproc;
        // D s_3940_1: cast zx s_3940_0 -> bv
        let s_3940_1: Bits = Bits::new(s_3940_0 as u128, 4u16);
        // C s_3940_2: const #15u : u8
        let s_3940_2: u8 = 15;
        // C s_3940_3: cast zx s_3940_2 -> bv
        let s_3940_3: Bits = Bits::new(s_3940_2 as u128, 4u16);
        // D s_3940_4: cmp-eq s_3940_1 s_3940_3
        let s_3940_4: bool = ((s_3940_1) == (s_3940_3));
        // D s_3940_5: write-var gs#135909 <= s_3940_4
        fn_state.gs_135909 = s_3940_4;
        // N s_3940_6: jump b3217
        return block_3217(state, tracer, fn_state);
    }
    fn block_3941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3941_0: read-var CRn:u8
        let s_3941_0: u8 = fn_state.CRn;
        // D s_3941_1: cast zx s_3941_0 -> bv
        let s_3941_1: Bits = Bits::new(s_3941_0 as u128, 4u16);
        // C s_3941_2: const #13u : u8
        let s_3941_2: u8 = 13;
        // C s_3941_3: cast zx s_3941_2 -> bv
        let s_3941_3: Bits = Bits::new(s_3941_2 as u128, 4u16);
        // D s_3941_4: cmp-eq s_3941_1 s_3941_3
        let s_3941_4: bool = ((s_3941_1) == (s_3941_3));
        // D s_3941_5: write-var gs#135908 <= s_3941_4
        fn_state.gs_135908 = s_3941_4;
        // N s_3941_6: jump b3215
        return block_3215(state, tracer, fn_state);
    }
    fn block_3942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3942_0: read-var el:u8
        let s_3942_0: u8 = fn_state.el;
        // D s_3942_1: read-var coproc:u8
        let s_3942_1: u8 = fn_state.coproc;
        // D s_3942_2: read-var opc1:u8
        let s_3942_2: u8 = fn_state.opc1;
        // D s_3942_3: read-var CRn:u8
        let s_3942_3: u8 = fn_state.CRn;
        // D s_3942_4: read-var opc2:u8
        let s_3942_4: u8 = fn_state.opc2;
        // D s_3942_5: read-var CRm:u8
        let s_3942_5: u8 = fn_state.CRm;
        // D s_3942_6: read-var t:i
        let s_3942_6: i128 = fn_state.t;
        // D s_3942_7: call AMEVTYPER1_SysRegWrite32_cb60b5ebc90e745e(s_3942_0, s_3942_1, s_3942_2, s_3942_3, s_3942_4, s_3942_5, s_3942_6)
        let s_3942_7: () = AMEVTYPER1_SysRegWrite32_cb60b5ebc90e745e(
            state,
            tracer,
            s_3942_0,
            s_3942_1,
            s_3942_2,
            s_3942_3,
            s_3942_4,
            s_3942_5,
            s_3942_6,
        );
        // N s_3942_8: return
        return;
    }
    fn block_3943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3943_0: read-var opc2:u8
        let s_3943_0: u8 = fn_state.opc2;
        // D s_3943_1: cast zx s_3943_0 -> bv
        let s_3943_1: Bits = Bits::new(s_3943_0 as u128, 3u16);
        // C s_3943_2: const #6u : u8
        let s_3943_2: u8 = 6;
        // C s_3943_3: cast zx s_3943_2 -> bv
        let s_3943_3: Bits = Bits::new(s_3943_2 as u128, 3u16);
        // D s_3943_4: cmp-eq s_3943_1 s_3943_3
        let s_3943_4: bool = ((s_3943_1) == (s_3943_3));
        // D s_3943_5: write-var gs#135907 <= s_3943_4
        fn_state.gs_135907 = s_3943_4;
        // N s_3943_6: jump b3212
        return block_3212(state, tracer, fn_state);
    }
    fn block_3944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3944_0: read-var opc1:u8
        let s_3944_0: u8 = fn_state.opc1;
        // D s_3944_1: cast zx s_3944_0 -> bv
        let s_3944_1: Bits = Bits::new(s_3944_0 as u128, 3u16);
        // C s_3944_2: const #0u : u8
        let s_3944_2: u8 = 0;
        // C s_3944_3: cast zx s_3944_2 -> bv
        let s_3944_3: Bits = Bits::new(s_3944_2 as u128, 3u16);
        // D s_3944_4: cmp-eq s_3944_1 s_3944_3
        let s_3944_4: bool = ((s_3944_1) == (s_3944_3));
        // D s_3944_5: write-var gs#135906 <= s_3944_4
        fn_state.gs_135906 = s_3944_4;
        // N s_3944_6: jump b3210
        return block_3210(state, tracer, fn_state);
    }
    fn block_3945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3945_0: read-var coproc:u8
        let s_3945_0: u8 = fn_state.coproc;
        // D s_3945_1: cast zx s_3945_0 -> bv
        let s_3945_1: Bits = Bits::new(s_3945_0 as u128, 4u16);
        // C s_3945_2: const #15u : u8
        let s_3945_2: u8 = 15;
        // C s_3945_3: cast zx s_3945_2 -> bv
        let s_3945_3: Bits = Bits::new(s_3945_2 as u128, 4u16);
        // D s_3945_4: cmp-eq s_3945_1 s_3945_3
        let s_3945_4: bool = ((s_3945_1) == (s_3945_3));
        // D s_3945_5: write-var gs#135905 <= s_3945_4
        fn_state.gs_135905 = s_3945_4;
        // N s_3945_6: jump b3208
        return block_3208(state, tracer, fn_state);
    }
    fn block_3946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3946_0: read-var CRn:u8
        let s_3946_0: u8 = fn_state.CRn;
        // D s_3946_1: cast zx s_3946_0 -> bv
        let s_3946_1: Bits = Bits::new(s_3946_0 as u128, 4u16);
        // C s_3946_2: const #13u : u8
        let s_3946_2: u8 = 13;
        // C s_3946_3: cast zx s_3946_2 -> bv
        let s_3946_3: Bits = Bits::new(s_3946_2 as u128, 4u16);
        // D s_3946_4: cmp-eq s_3946_1 s_3946_3
        let s_3946_4: bool = ((s_3946_1) == (s_3946_3));
        // D s_3946_5: write-var gs#135904 <= s_3946_4
        fn_state.gs_135904 = s_3946_4;
        // N s_3946_6: jump b3206
        return block_3206(state, tracer, fn_state);
    }
    fn block_3947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3947_0: read-var el:u8
        let s_3947_0: u8 = fn_state.el;
        // D s_3947_1: read-var coproc:u8
        let s_3947_1: u8 = fn_state.coproc;
        // D s_3947_2: read-var opc1:u8
        let s_3947_2: u8 = fn_state.opc1;
        // D s_3947_3: read-var CRn:u8
        let s_3947_3: u8 = fn_state.CRn;
        // D s_3947_4: read-var opc2:u8
        let s_3947_4: u8 = fn_state.opc2;
        // D s_3947_5: read-var CRm:u8
        let s_3947_5: u8 = fn_state.CRm;
        // D s_3947_6: read-var t:i
        let s_3947_6: i128 = fn_state.t;
        // D s_3947_7: call AMEVTYPER1_SysRegWrite32_4c73d953aff0e20b(s_3947_0, s_3947_1, s_3947_2, s_3947_3, s_3947_4, s_3947_5, s_3947_6)
        let s_3947_7: () = AMEVTYPER1_SysRegWrite32_4c73d953aff0e20b(
            state,
            tracer,
            s_3947_0,
            s_3947_1,
            s_3947_2,
            s_3947_3,
            s_3947_4,
            s_3947_5,
            s_3947_6,
        );
        // N s_3947_8: return
        return;
    }
    fn block_3948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3948_0: read-var opc2:u8
        let s_3948_0: u8 = fn_state.opc2;
        // D s_3948_1: cast zx s_3948_0 -> bv
        let s_3948_1: Bits = Bits::new(s_3948_0 as u128, 3u16);
        // C s_3948_2: const #7u : u8
        let s_3948_2: u8 = 7;
        // C s_3948_3: cast zx s_3948_2 -> bv
        let s_3948_3: Bits = Bits::new(s_3948_2 as u128, 3u16);
        // D s_3948_4: cmp-eq s_3948_1 s_3948_3
        let s_3948_4: bool = ((s_3948_1) == (s_3948_3));
        // D s_3948_5: write-var gs#135903 <= s_3948_4
        fn_state.gs_135903 = s_3948_4;
        // N s_3948_6: jump b3203
        return block_3203(state, tracer, fn_state);
    }
    fn block_3949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3949_0: read-var opc1:u8
        let s_3949_0: u8 = fn_state.opc1;
        // D s_3949_1: cast zx s_3949_0 -> bv
        let s_3949_1: Bits = Bits::new(s_3949_0 as u128, 3u16);
        // C s_3949_2: const #0u : u8
        let s_3949_2: u8 = 0;
        // C s_3949_3: cast zx s_3949_2 -> bv
        let s_3949_3: Bits = Bits::new(s_3949_2 as u128, 3u16);
        // D s_3949_4: cmp-eq s_3949_1 s_3949_3
        let s_3949_4: bool = ((s_3949_1) == (s_3949_3));
        // D s_3949_5: write-var gs#135902 <= s_3949_4
        fn_state.gs_135902 = s_3949_4;
        // N s_3949_6: jump b3201
        return block_3201(state, tracer, fn_state);
    }
    fn block_3950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3950_0: read-var coproc:u8
        let s_3950_0: u8 = fn_state.coproc;
        // D s_3950_1: cast zx s_3950_0 -> bv
        let s_3950_1: Bits = Bits::new(s_3950_0 as u128, 4u16);
        // C s_3950_2: const #15u : u8
        let s_3950_2: u8 = 15;
        // C s_3950_3: cast zx s_3950_2 -> bv
        let s_3950_3: Bits = Bits::new(s_3950_2 as u128, 4u16);
        // D s_3950_4: cmp-eq s_3950_1 s_3950_3
        let s_3950_4: bool = ((s_3950_1) == (s_3950_3));
        // D s_3950_5: write-var gs#135901 <= s_3950_4
        fn_state.gs_135901 = s_3950_4;
        // N s_3950_6: jump b3199
        return block_3199(state, tracer, fn_state);
    }
    fn block_3951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3951_0: read-var CRn:u8
        let s_3951_0: u8 = fn_state.CRn;
        // D s_3951_1: cast zx s_3951_0 -> bv
        let s_3951_1: Bits = Bits::new(s_3951_0 as u128, 4u16);
        // C s_3951_2: const #13u : u8
        let s_3951_2: u8 = 13;
        // C s_3951_3: cast zx s_3951_2 -> bv
        let s_3951_3: Bits = Bits::new(s_3951_2 as u128, 4u16);
        // D s_3951_4: cmp-eq s_3951_1 s_3951_3
        let s_3951_4: bool = ((s_3951_1) == (s_3951_3));
        // D s_3951_5: write-var gs#135900 <= s_3951_4
        fn_state.gs_135900 = s_3951_4;
        // N s_3951_6: jump b3197
        return block_3197(state, tracer, fn_state);
    }
    fn block_3952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3952_0: read-var el:u8
        let s_3952_0: u8 = fn_state.el;
        // D s_3952_1: read-var coproc:u8
        let s_3952_1: u8 = fn_state.coproc;
        // D s_3952_2: read-var opc1:u8
        let s_3952_2: u8 = fn_state.opc1;
        // D s_3952_3: read-var CRn:u8
        let s_3952_3: u8 = fn_state.CRn;
        // D s_3952_4: read-var opc2:u8
        let s_3952_4: u8 = fn_state.opc2;
        // D s_3952_5: read-var CRm:u8
        let s_3952_5: u8 = fn_state.CRm;
        // D s_3952_6: read-var t:i
        let s_3952_6: i128 = fn_state.t;
        // D s_3952_7: call AMUSERENR_SysRegWrite32_2ac4dae68b0ff25f(s_3952_0, s_3952_1, s_3952_2, s_3952_3, s_3952_4, s_3952_5, s_3952_6)
        let s_3952_7: () = AMUSERENR_SysRegWrite32_2ac4dae68b0ff25f(
            state,
            tracer,
            s_3952_0,
            s_3952_1,
            s_3952_2,
            s_3952_3,
            s_3952_4,
            s_3952_5,
            s_3952_6,
        );
        // N s_3952_8: return
        return;
    }
    fn block_3953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3953_0: read-var opc2:u8
        let s_3953_0: u8 = fn_state.opc2;
        // D s_3953_1: cast zx s_3953_0 -> bv
        let s_3953_1: Bits = Bits::new(s_3953_0 as u128, 3u16);
        // C s_3953_2: const #3u : u8
        let s_3953_2: u8 = 3;
        // C s_3953_3: cast zx s_3953_2 -> bv
        let s_3953_3: Bits = Bits::new(s_3953_2 as u128, 3u16);
        // D s_3953_4: cmp-eq s_3953_1 s_3953_3
        let s_3953_4: bool = ((s_3953_1) == (s_3953_3));
        // D s_3953_5: write-var gs#135899 <= s_3953_4
        fn_state.gs_135899 = s_3953_4;
        // N s_3953_6: jump b3194
        return block_3194(state, tracer, fn_state);
    }
    fn block_3954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3954_0: read-var opc1:u8
        let s_3954_0: u8 = fn_state.opc1;
        // D s_3954_1: cast zx s_3954_0 -> bv
        let s_3954_1: Bits = Bits::new(s_3954_0 as u128, 3u16);
        // C s_3954_2: const #0u : u8
        let s_3954_2: u8 = 0;
        // C s_3954_3: cast zx s_3954_2 -> bv
        let s_3954_3: Bits = Bits::new(s_3954_2 as u128, 3u16);
        // D s_3954_4: cmp-eq s_3954_1 s_3954_3
        let s_3954_4: bool = ((s_3954_1) == (s_3954_3));
        // D s_3954_5: write-var gs#135898 <= s_3954_4
        fn_state.gs_135898 = s_3954_4;
        // N s_3954_6: jump b3192
        return block_3192(state, tracer, fn_state);
    }
    fn block_3955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3955_0: read-var coproc:u8
        let s_3955_0: u8 = fn_state.coproc;
        // D s_3955_1: cast zx s_3955_0 -> bv
        let s_3955_1: Bits = Bits::new(s_3955_0 as u128, 4u16);
        // C s_3955_2: const #15u : u8
        let s_3955_2: u8 = 15;
        // C s_3955_3: cast zx s_3955_2 -> bv
        let s_3955_3: Bits = Bits::new(s_3955_2 as u128, 4u16);
        // D s_3955_4: cmp-eq s_3955_1 s_3955_3
        let s_3955_4: bool = ((s_3955_1) == (s_3955_3));
        // D s_3955_5: write-var gs#135897 <= s_3955_4
        fn_state.gs_135897 = s_3955_4;
        // N s_3955_6: jump b3190
        return block_3190(state, tracer, fn_state);
    }
    fn block_3956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3956_0: read-var CRn:u8
        let s_3956_0: u8 = fn_state.CRn;
        // D s_3956_1: cast zx s_3956_0 -> bv
        let s_3956_1: Bits = Bits::new(s_3956_0 as u128, 4u16);
        // C s_3956_2: const #13u : u8
        let s_3956_2: u8 = 13;
        // C s_3956_3: cast zx s_3956_2 -> bv
        let s_3956_3: Bits = Bits::new(s_3956_2 as u128, 4u16);
        // D s_3956_4: cmp-eq s_3956_1 s_3956_3
        let s_3956_4: bool = ((s_3956_1) == (s_3956_3));
        // D s_3956_5: write-var gs#135896 <= s_3956_4
        fn_state.gs_135896 = s_3956_4;
        // N s_3956_6: jump b3188
        return block_3188(state, tracer, fn_state);
    }
    fn block_3957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3957_0: read-var el:u8
        let s_3957_0: u8 = fn_state.el;
        // D s_3957_1: read-var coproc:u8
        let s_3957_1: u8 = fn_state.coproc;
        // D s_3957_2: read-var opc1:u8
        let s_3957_2: u8 = fn_state.opc1;
        // D s_3957_3: read-var CRn:u8
        let s_3957_3: u8 = fn_state.CRn;
        // D s_3957_4: read-var opc2:u8
        let s_3957_4: u8 = fn_state.opc2;
        // D s_3957_5: read-var CRm:u8
        let s_3957_5: u8 = fn_state.CRm;
        // D s_3957_6: read-var t:i
        let s_3957_6: i128 = fn_state.t;
        // D s_3957_7: call DLR_SysRegWrite32_aff2e156d6e1196e(s_3957_0, s_3957_1, s_3957_2, s_3957_3, s_3957_4, s_3957_5, s_3957_6)
        let s_3957_7: () = DLR_SysRegWrite32_aff2e156d6e1196e(
            state,
            tracer,
            s_3957_0,
            s_3957_1,
            s_3957_2,
            s_3957_3,
            s_3957_4,
            s_3957_5,
            s_3957_6,
        );
        // N s_3957_8: return
        return;
    }
    fn block_3958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3958_0: read-var opc2:u8
        let s_3958_0: u8 = fn_state.opc2;
        // D s_3958_1: cast zx s_3958_0 -> bv
        let s_3958_1: Bits = Bits::new(s_3958_0 as u128, 3u16);
        // C s_3958_2: const #1u : u8
        let s_3958_2: u8 = 1;
        // C s_3958_3: cast zx s_3958_2 -> bv
        let s_3958_3: Bits = Bits::new(s_3958_2 as u128, 3u16);
        // D s_3958_4: cmp-eq s_3958_1 s_3958_3
        let s_3958_4: bool = ((s_3958_1) == (s_3958_3));
        // D s_3958_5: write-var gs#135895 <= s_3958_4
        fn_state.gs_135895 = s_3958_4;
        // N s_3958_6: jump b3185
        return block_3185(state, tracer, fn_state);
    }
    fn block_3959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3959_0: read-var opc1:u8
        let s_3959_0: u8 = fn_state.opc1;
        // D s_3959_1: cast zx s_3959_0 -> bv
        let s_3959_1: Bits = Bits::new(s_3959_0 as u128, 3u16);
        // C s_3959_2: const #3u : u8
        let s_3959_2: u8 = 3;
        // C s_3959_3: cast zx s_3959_2 -> bv
        let s_3959_3: Bits = Bits::new(s_3959_2 as u128, 3u16);
        // D s_3959_4: cmp-eq s_3959_1 s_3959_3
        let s_3959_4: bool = ((s_3959_1) == (s_3959_3));
        // D s_3959_5: write-var gs#135894 <= s_3959_4
        fn_state.gs_135894 = s_3959_4;
        // N s_3959_6: jump b3183
        return block_3183(state, tracer, fn_state);
    }
    fn block_3960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3960_0: read-var coproc:u8
        let s_3960_0: u8 = fn_state.coproc;
        // D s_3960_1: cast zx s_3960_0 -> bv
        let s_3960_1: Bits = Bits::new(s_3960_0 as u128, 4u16);
        // C s_3960_2: const #15u : u8
        let s_3960_2: u8 = 15;
        // C s_3960_3: cast zx s_3960_2 -> bv
        let s_3960_3: Bits = Bits::new(s_3960_2 as u128, 4u16);
        // D s_3960_4: cmp-eq s_3960_1 s_3960_3
        let s_3960_4: bool = ((s_3960_1) == (s_3960_3));
        // D s_3960_5: write-var gs#135893 <= s_3960_4
        fn_state.gs_135893 = s_3960_4;
        // N s_3960_6: jump b3181
        return block_3181(state, tracer, fn_state);
    }
    fn block_3961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3961_0: read-var CRn:u8
        let s_3961_0: u8 = fn_state.CRn;
        // D s_3961_1: cast zx s_3961_0 -> bv
        let s_3961_1: Bits = Bits::new(s_3961_0 as u128, 4u16);
        // C s_3961_2: const #4u : u8
        let s_3961_2: u8 = 4;
        // C s_3961_3: cast zx s_3961_2 -> bv
        let s_3961_3: Bits = Bits::new(s_3961_2 as u128, 4u16);
        // D s_3961_4: cmp-eq s_3961_1 s_3961_3
        let s_3961_4: bool = ((s_3961_1) == (s_3961_3));
        // D s_3961_5: write-var gs#135892 <= s_3961_4
        fn_state.gs_135892 = s_3961_4;
        // N s_3961_6: jump b3179
        return block_3179(state, tracer, fn_state);
    }
    fn block_3962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3962_0: read-var el:u8
        let s_3962_0: u8 = fn_state.el;
        // D s_3962_1: read-var coproc:u8
        let s_3962_1: u8 = fn_state.coproc;
        // D s_3962_2: read-var opc1:u8
        let s_3962_2: u8 = fn_state.opc1;
        // D s_3962_3: read-var CRn:u8
        let s_3962_3: u8 = fn_state.CRn;
        // D s_3962_4: read-var opc2:u8
        let s_3962_4: u8 = fn_state.opc2;
        // D s_3962_5: read-var CRm:u8
        let s_3962_5: u8 = fn_state.CRm;
        // D s_3962_6: read-var t:i
        let s_3962_6: i128 = fn_state.t;
        // D s_3962_7: call TLBIIPAS2IS_SysRegWrite32_e4867c386886a0ac(s_3962_0, s_3962_1, s_3962_2, s_3962_3, s_3962_4, s_3962_5, s_3962_6)
        let s_3962_7: () = TLBIIPAS2IS_SysRegWrite32_e4867c386886a0ac(
            state,
            tracer,
            s_3962_0,
            s_3962_1,
            s_3962_2,
            s_3962_3,
            s_3962_4,
            s_3962_5,
            s_3962_6,
        );
        // N s_3962_8: return
        return;
    }
    fn block_3963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3963_0: read-var opc2:u8
        let s_3963_0: u8 = fn_state.opc2;
        // D s_3963_1: cast zx s_3963_0 -> bv
        let s_3963_1: Bits = Bits::new(s_3963_0 as u128, 3u16);
        // C s_3963_2: const #1u : u8
        let s_3963_2: u8 = 1;
        // C s_3963_3: cast zx s_3963_2 -> bv
        let s_3963_3: Bits = Bits::new(s_3963_2 as u128, 3u16);
        // D s_3963_4: cmp-eq s_3963_1 s_3963_3
        let s_3963_4: bool = ((s_3963_1) == (s_3963_3));
        // D s_3963_5: write-var gs#135891 <= s_3963_4
        fn_state.gs_135891 = s_3963_4;
        // N s_3963_6: jump b3176
        return block_3176(state, tracer, fn_state);
    }
    fn block_3964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3964_0: read-var opc1:u8
        let s_3964_0: u8 = fn_state.opc1;
        // D s_3964_1: cast zx s_3964_0 -> bv
        let s_3964_1: Bits = Bits::new(s_3964_0 as u128, 3u16);
        // C s_3964_2: const #4u : u8
        let s_3964_2: u8 = 4;
        // C s_3964_3: cast zx s_3964_2 -> bv
        let s_3964_3: Bits = Bits::new(s_3964_2 as u128, 3u16);
        // D s_3964_4: cmp-eq s_3964_1 s_3964_3
        let s_3964_4: bool = ((s_3964_1) == (s_3964_3));
        // D s_3964_5: write-var gs#135890 <= s_3964_4
        fn_state.gs_135890 = s_3964_4;
        // N s_3964_6: jump b3174
        return block_3174(state, tracer, fn_state);
    }
    fn block_3965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3965_0: read-var coproc:u8
        let s_3965_0: u8 = fn_state.coproc;
        // D s_3965_1: cast zx s_3965_0 -> bv
        let s_3965_1: Bits = Bits::new(s_3965_0 as u128, 4u16);
        // C s_3965_2: const #15u : u8
        let s_3965_2: u8 = 15;
        // C s_3965_3: cast zx s_3965_2 -> bv
        let s_3965_3: Bits = Bits::new(s_3965_2 as u128, 4u16);
        // D s_3965_4: cmp-eq s_3965_1 s_3965_3
        let s_3965_4: bool = ((s_3965_1) == (s_3965_3));
        // D s_3965_5: write-var gs#135889 <= s_3965_4
        fn_state.gs_135889 = s_3965_4;
        // N s_3965_6: jump b3172
        return block_3172(state, tracer, fn_state);
    }
    fn block_3966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3966_0: read-var CRn:u8
        let s_3966_0: u8 = fn_state.CRn;
        // D s_3966_1: cast zx s_3966_0 -> bv
        let s_3966_1: Bits = Bits::new(s_3966_0 as u128, 4u16);
        // C s_3966_2: const #8u : u8
        let s_3966_2: u8 = 8;
        // C s_3966_3: cast zx s_3966_2 -> bv
        let s_3966_3: Bits = Bits::new(s_3966_2 as u128, 4u16);
        // D s_3966_4: cmp-eq s_3966_1 s_3966_3
        let s_3966_4: bool = ((s_3966_1) == (s_3966_3));
        // D s_3966_5: write-var gs#135888 <= s_3966_4
        fn_state.gs_135888 = s_3966_4;
        // N s_3966_6: jump b3170
        return block_3170(state, tracer, fn_state);
    }
    fn block_3967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3967_0: read-var el:u8
        let s_3967_0: u8 = fn_state.el;
        // D s_3967_1: read-var coproc:u8
        let s_3967_1: u8 = fn_state.coproc;
        // D s_3967_2: read-var opc1:u8
        let s_3967_2: u8 = fn_state.opc1;
        // D s_3967_3: read-var CRn:u8
        let s_3967_3: u8 = fn_state.CRn;
        // D s_3967_4: read-var opc2:u8
        let s_3967_4: u8 = fn_state.opc2;
        // D s_3967_5: read-var CRm:u8
        let s_3967_5: u8 = fn_state.CRm;
        // D s_3967_6: read-var t:i
        let s_3967_6: i128 = fn_state.t;
        // D s_3967_7: call BPIMVA_SysRegWrite32_913ce21249c53f0d(s_3967_0, s_3967_1, s_3967_2, s_3967_3, s_3967_4, s_3967_5, s_3967_6)
        let s_3967_7: () = BPIMVA_SysRegWrite32_913ce21249c53f0d(
            state,
            tracer,
            s_3967_0,
            s_3967_1,
            s_3967_2,
            s_3967_3,
            s_3967_4,
            s_3967_5,
            s_3967_6,
        );
        // N s_3967_8: return
        return;
    }
    fn block_3968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3968_0: read-var opc2:u8
        let s_3968_0: u8 = fn_state.opc2;
        // D s_3968_1: cast zx s_3968_0 -> bv
        let s_3968_1: Bits = Bits::new(s_3968_0 as u128, 3u16);
        // C s_3968_2: const #7u : u8
        let s_3968_2: u8 = 7;
        // C s_3968_3: cast zx s_3968_2 -> bv
        let s_3968_3: Bits = Bits::new(s_3968_2 as u128, 3u16);
        // D s_3968_4: cmp-eq s_3968_1 s_3968_3
        let s_3968_4: bool = ((s_3968_1) == (s_3968_3));
        // D s_3968_5: write-var gs#135887 <= s_3968_4
        fn_state.gs_135887 = s_3968_4;
        // N s_3968_6: jump b3167
        return block_3167(state, tracer, fn_state);
    }
    fn block_3969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3969_0: read-var opc1:u8
        let s_3969_0: u8 = fn_state.opc1;
        // D s_3969_1: cast zx s_3969_0 -> bv
        let s_3969_1: Bits = Bits::new(s_3969_0 as u128, 3u16);
        // C s_3969_2: const #0u : u8
        let s_3969_2: u8 = 0;
        // C s_3969_3: cast zx s_3969_2 -> bv
        let s_3969_3: Bits = Bits::new(s_3969_2 as u128, 3u16);
        // D s_3969_4: cmp-eq s_3969_1 s_3969_3
        let s_3969_4: bool = ((s_3969_1) == (s_3969_3));
        // D s_3969_5: write-var gs#135886 <= s_3969_4
        fn_state.gs_135886 = s_3969_4;
        // N s_3969_6: jump b3165
        return block_3165(state, tracer, fn_state);
    }
    fn block_3970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3970_0: read-var coproc:u8
        let s_3970_0: u8 = fn_state.coproc;
        // D s_3970_1: cast zx s_3970_0 -> bv
        let s_3970_1: Bits = Bits::new(s_3970_0 as u128, 4u16);
        // C s_3970_2: const #15u : u8
        let s_3970_2: u8 = 15;
        // C s_3970_3: cast zx s_3970_2 -> bv
        let s_3970_3: Bits = Bits::new(s_3970_2 as u128, 4u16);
        // D s_3970_4: cmp-eq s_3970_1 s_3970_3
        let s_3970_4: bool = ((s_3970_1) == (s_3970_3));
        // D s_3970_5: write-var gs#135885 <= s_3970_4
        fn_state.gs_135885 = s_3970_4;
        // N s_3970_6: jump b3163
        return block_3163(state, tracer, fn_state);
    }
    fn block_3971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3971_0: read-var CRn:u8
        let s_3971_0: u8 = fn_state.CRn;
        // D s_3971_1: cast zx s_3971_0 -> bv
        let s_3971_1: Bits = Bits::new(s_3971_0 as u128, 4u16);
        // C s_3971_2: const #7u : u8
        let s_3971_2: u8 = 7;
        // C s_3971_3: cast zx s_3971_2 -> bv
        let s_3971_3: Bits = Bits::new(s_3971_2 as u128, 4u16);
        // D s_3971_4: cmp-eq s_3971_1 s_3971_3
        let s_3971_4: bool = ((s_3971_1) == (s_3971_3));
        // D s_3971_5: write-var gs#135884 <= s_3971_4
        fn_state.gs_135884 = s_3971_4;
        // N s_3971_6: jump b3161
        return block_3161(state, tracer, fn_state);
    }
    fn block_3972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3972_0: read-var el:u8
        let s_3972_0: u8 = fn_state.el;
        // D s_3972_1: read-var coproc:u8
        let s_3972_1: u8 = fn_state.coproc;
        // D s_3972_2: read-var opc1:u8
        let s_3972_2: u8 = fn_state.opc1;
        // D s_3972_3: read-var CRn:u8
        let s_3972_3: u8 = fn_state.CRn;
        // D s_3972_4: read-var opc2:u8
        let s_3972_4: u8 = fn_state.opc2;
        // D s_3972_5: read-var CRm:u8
        let s_3972_5: u8 = fn_state.CRm;
        // D s_3972_6: read-var t:i
        let s_3972_6: i128 = fn_state.t;
        // D s_3972_7: call SDCR_SysRegWrite32_4a9ed44cdafd01dd(s_3972_0, s_3972_1, s_3972_2, s_3972_3, s_3972_4, s_3972_5, s_3972_6)
        let s_3972_7: () = SDCR_SysRegWrite32_4a9ed44cdafd01dd(
            state,
            tracer,
            s_3972_0,
            s_3972_1,
            s_3972_2,
            s_3972_3,
            s_3972_4,
            s_3972_5,
            s_3972_6,
        );
        // N s_3972_8: return
        return;
    }
    fn block_3973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3973_0: read-var opc2:u8
        let s_3973_0: u8 = fn_state.opc2;
        // D s_3973_1: cast zx s_3973_0 -> bv
        let s_3973_1: Bits = Bits::new(s_3973_0 as u128, 3u16);
        // C s_3973_2: const #1u : u8
        let s_3973_2: u8 = 1;
        // C s_3973_3: cast zx s_3973_2 -> bv
        let s_3973_3: Bits = Bits::new(s_3973_2 as u128, 3u16);
        // D s_3973_4: cmp-eq s_3973_1 s_3973_3
        let s_3973_4: bool = ((s_3973_1) == (s_3973_3));
        // D s_3973_5: write-var gs#135883 <= s_3973_4
        fn_state.gs_135883 = s_3973_4;
        // N s_3973_6: jump b3158
        return block_3158(state, tracer, fn_state);
    }
    fn block_3974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3974_0: read-var opc1:u8
        let s_3974_0: u8 = fn_state.opc1;
        // D s_3974_1: cast zx s_3974_0 -> bv
        let s_3974_1: Bits = Bits::new(s_3974_0 as u128, 3u16);
        // C s_3974_2: const #0u : u8
        let s_3974_2: u8 = 0;
        // C s_3974_3: cast zx s_3974_2 -> bv
        let s_3974_3: Bits = Bits::new(s_3974_2 as u128, 3u16);
        // D s_3974_4: cmp-eq s_3974_1 s_3974_3
        let s_3974_4: bool = ((s_3974_1) == (s_3974_3));
        // D s_3974_5: write-var gs#135882 <= s_3974_4
        fn_state.gs_135882 = s_3974_4;
        // N s_3974_6: jump b3156
        return block_3156(state, tracer, fn_state);
    }
    fn block_3975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3975_0: read-var coproc:u8
        let s_3975_0: u8 = fn_state.coproc;
        // D s_3975_1: cast zx s_3975_0 -> bv
        let s_3975_1: Bits = Bits::new(s_3975_0 as u128, 4u16);
        // C s_3975_2: const #15u : u8
        let s_3975_2: u8 = 15;
        // C s_3975_3: cast zx s_3975_2 -> bv
        let s_3975_3: Bits = Bits::new(s_3975_2 as u128, 4u16);
        // D s_3975_4: cmp-eq s_3975_1 s_3975_3
        let s_3975_4: bool = ((s_3975_1) == (s_3975_3));
        // D s_3975_5: write-var gs#135881 <= s_3975_4
        fn_state.gs_135881 = s_3975_4;
        // N s_3975_6: jump b3154
        return block_3154(state, tracer, fn_state);
    }
    fn block_3976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3976_0: read-var CRn:u8
        let s_3976_0: u8 = fn_state.CRn;
        // D s_3976_1: cast zx s_3976_0 -> bv
        let s_3976_1: Bits = Bits::new(s_3976_0 as u128, 4u16);
        // C s_3976_2: const #1u : u8
        let s_3976_2: u8 = 1;
        // C s_3976_3: cast zx s_3976_2 -> bv
        let s_3976_3: Bits = Bits::new(s_3976_2 as u128, 4u16);
        // D s_3976_4: cmp-eq s_3976_1 s_3976_3
        let s_3976_4: bool = ((s_3976_1) == (s_3976_3));
        // D s_3976_5: write-var gs#135880 <= s_3976_4
        fn_state.gs_135880 = s_3976_4;
        // N s_3976_6: jump b3152
        return block_3152(state, tracer, fn_state);
    }
    fn block_3977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3977_0: read-var el:u8
        let s_3977_0: u8 = fn_state.el;
        // D s_3977_1: read-var coproc:u8
        let s_3977_1: u8 = fn_state.coproc;
        // D s_3977_2: read-var opc1:u8
        let s_3977_2: u8 = fn_state.opc1;
        // D s_3977_3: read-var CRn:u8
        let s_3977_3: u8 = fn_state.CRn;
        // D s_3977_4: read-var opc2:u8
        let s_3977_4: u8 = fn_state.opc2;
        // D s_3977_5: read-var CRm:u8
        let s_3977_5: u8 = fn_state.CRm;
        // D s_3977_6: read-var t:i
        let s_3977_6: i128 = fn_state.t;
        // D s_3977_7: call ICC_SRE_SysRegWrite32_9b4f583336a77d42(s_3977_0, s_3977_1, s_3977_2, s_3977_3, s_3977_4, s_3977_5, s_3977_6)
        let s_3977_7: () = ICC_SRE_SysRegWrite32_9b4f583336a77d42(
            state,
            tracer,
            s_3977_0,
            s_3977_1,
            s_3977_2,
            s_3977_3,
            s_3977_4,
            s_3977_5,
            s_3977_6,
        );
        // N s_3977_8: return
        return;
    }
    fn block_3978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3978_0: read-var opc2:u8
        let s_3978_0: u8 = fn_state.opc2;
        // D s_3978_1: cast zx s_3978_0 -> bv
        let s_3978_1: Bits = Bits::new(s_3978_0 as u128, 3u16);
        // C s_3978_2: const #5u : u8
        let s_3978_2: u8 = 5;
        // C s_3978_3: cast zx s_3978_2 -> bv
        let s_3978_3: Bits = Bits::new(s_3978_2 as u128, 3u16);
        // D s_3978_4: cmp-eq s_3978_1 s_3978_3
        let s_3978_4: bool = ((s_3978_1) == (s_3978_3));
        // D s_3978_5: write-var gs#135879 <= s_3978_4
        fn_state.gs_135879 = s_3978_4;
        // N s_3978_6: jump b3149
        return block_3149(state, tracer, fn_state);
    }
    fn block_3979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3979_0: read-var opc1:u8
        let s_3979_0: u8 = fn_state.opc1;
        // D s_3979_1: cast zx s_3979_0 -> bv
        let s_3979_1: Bits = Bits::new(s_3979_0 as u128, 3u16);
        // C s_3979_2: const #0u : u8
        let s_3979_2: u8 = 0;
        // C s_3979_3: cast zx s_3979_2 -> bv
        let s_3979_3: Bits = Bits::new(s_3979_2 as u128, 3u16);
        // D s_3979_4: cmp-eq s_3979_1 s_3979_3
        let s_3979_4: bool = ((s_3979_1) == (s_3979_3));
        // D s_3979_5: write-var gs#135878 <= s_3979_4
        fn_state.gs_135878 = s_3979_4;
        // N s_3979_6: jump b3147
        return block_3147(state, tracer, fn_state);
    }
    fn block_3980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3980_0: read-var coproc:u8
        let s_3980_0: u8 = fn_state.coproc;
        // D s_3980_1: cast zx s_3980_0 -> bv
        let s_3980_1: Bits = Bits::new(s_3980_0 as u128, 4u16);
        // C s_3980_2: const #15u : u8
        let s_3980_2: u8 = 15;
        // C s_3980_3: cast zx s_3980_2 -> bv
        let s_3980_3: Bits = Bits::new(s_3980_2 as u128, 4u16);
        // D s_3980_4: cmp-eq s_3980_1 s_3980_3
        let s_3980_4: bool = ((s_3980_1) == (s_3980_3));
        // D s_3980_5: write-var gs#135877 <= s_3980_4
        fn_state.gs_135877 = s_3980_4;
        // N s_3980_6: jump b3145
        return block_3145(state, tracer, fn_state);
    }
    fn block_3981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3981_0: read-var CRn:u8
        let s_3981_0: u8 = fn_state.CRn;
        // D s_3981_1: cast zx s_3981_0 -> bv
        let s_3981_1: Bits = Bits::new(s_3981_0 as u128, 4u16);
        // C s_3981_2: const #12u : u8
        let s_3981_2: u8 = 12;
        // C s_3981_3: cast zx s_3981_2 -> bv
        let s_3981_3: Bits = Bits::new(s_3981_2 as u128, 4u16);
        // D s_3981_4: cmp-eq s_3981_1 s_3981_3
        let s_3981_4: bool = ((s_3981_1) == (s_3981_3));
        // D s_3981_5: write-var gs#135876 <= s_3981_4
        fn_state.gs_135876 = s_3981_4;
        // N s_3981_6: jump b3143
        return block_3143(state, tracer, fn_state);
    }
    fn block_3982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3982_0: read-var el:u8
        let s_3982_0: u8 = fn_state.el;
        // D s_3982_1: read-var coproc:u8
        let s_3982_1: u8 = fn_state.coproc;
        // D s_3982_2: read-var opc1:u8
        let s_3982_2: u8 = fn_state.opc1;
        // D s_3982_3: read-var CRn:u8
        let s_3982_3: u8 = fn_state.CRn;
        // D s_3982_4: read-var opc2:u8
        let s_3982_4: u8 = fn_state.opc2;
        // D s_3982_5: read-var CRm:u8
        let s_3982_5: u8 = fn_state.CRm;
        // D s_3982_6: read-var t:i
        let s_3982_6: i128 = fn_state.t;
        // D s_3982_7: call ATS1CPWP_SysRegWrite32_9f529f7ec0bf0000(s_3982_0, s_3982_1, s_3982_2, s_3982_3, s_3982_4, s_3982_5, s_3982_6)
        let s_3982_7: () = ATS1CPWP_SysRegWrite32_9f529f7ec0bf0000(
            state,
            tracer,
            s_3982_0,
            s_3982_1,
            s_3982_2,
            s_3982_3,
            s_3982_4,
            s_3982_5,
            s_3982_6,
        );
        // N s_3982_8: return
        return;
    }
    fn block_3983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3983_0: read-var opc2:u8
        let s_3983_0: u8 = fn_state.opc2;
        // D s_3983_1: cast zx s_3983_0 -> bv
        let s_3983_1: Bits = Bits::new(s_3983_0 as u128, 3u16);
        // C s_3983_2: const #1u : u8
        let s_3983_2: u8 = 1;
        // C s_3983_3: cast zx s_3983_2 -> bv
        let s_3983_3: Bits = Bits::new(s_3983_2 as u128, 3u16);
        // D s_3983_4: cmp-eq s_3983_1 s_3983_3
        let s_3983_4: bool = ((s_3983_1) == (s_3983_3));
        // D s_3983_5: write-var gs#135875 <= s_3983_4
        fn_state.gs_135875 = s_3983_4;
        // N s_3983_6: jump b3140
        return block_3140(state, tracer, fn_state);
    }
    fn block_3984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3984_0: read-var opc1:u8
        let s_3984_0: u8 = fn_state.opc1;
        // D s_3984_1: cast zx s_3984_0 -> bv
        let s_3984_1: Bits = Bits::new(s_3984_0 as u128, 3u16);
        // C s_3984_2: const #0u : u8
        let s_3984_2: u8 = 0;
        // C s_3984_3: cast zx s_3984_2 -> bv
        let s_3984_3: Bits = Bits::new(s_3984_2 as u128, 3u16);
        // D s_3984_4: cmp-eq s_3984_1 s_3984_3
        let s_3984_4: bool = ((s_3984_1) == (s_3984_3));
        // D s_3984_5: write-var gs#135874 <= s_3984_4
        fn_state.gs_135874 = s_3984_4;
        // N s_3984_6: jump b3138
        return block_3138(state, tracer, fn_state);
    }
    fn block_3985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3985_0: read-var coproc:u8
        let s_3985_0: u8 = fn_state.coproc;
        // D s_3985_1: cast zx s_3985_0 -> bv
        let s_3985_1: Bits = Bits::new(s_3985_0 as u128, 4u16);
        // C s_3985_2: const #15u : u8
        let s_3985_2: u8 = 15;
        // C s_3985_3: cast zx s_3985_2 -> bv
        let s_3985_3: Bits = Bits::new(s_3985_2 as u128, 4u16);
        // D s_3985_4: cmp-eq s_3985_1 s_3985_3
        let s_3985_4: bool = ((s_3985_1) == (s_3985_3));
        // D s_3985_5: write-var gs#135873 <= s_3985_4
        fn_state.gs_135873 = s_3985_4;
        // N s_3985_6: jump b3136
        return block_3136(state, tracer, fn_state);
    }
    fn block_3986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3986_0: read-var CRn:u8
        let s_3986_0: u8 = fn_state.CRn;
        // D s_3986_1: cast zx s_3986_0 -> bv
        let s_3986_1: Bits = Bits::new(s_3986_0 as u128, 4u16);
        // C s_3986_2: const #7u : u8
        let s_3986_2: u8 = 7;
        // C s_3986_3: cast zx s_3986_2 -> bv
        let s_3986_3: Bits = Bits::new(s_3986_2 as u128, 4u16);
        // D s_3986_4: cmp-eq s_3986_1 s_3986_3
        let s_3986_4: bool = ((s_3986_1) == (s_3986_3));
        // D s_3986_5: write-var gs#135872 <= s_3986_4
        fn_state.gs_135872 = s_3986_4;
        // N s_3986_6: jump b3134
        return block_3134(state, tracer, fn_state);
    }
    fn block_3987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3987_0: read-var el:u8
        let s_3987_0: u8 = fn_state.el;
        // D s_3987_1: read-var coproc:u8
        let s_3987_1: u8 = fn_state.coproc;
        // D s_3987_2: read-var opc1:u8
        let s_3987_2: u8 = fn_state.opc1;
        // D s_3987_3: read-var CRn:u8
        let s_3987_3: u8 = fn_state.CRn;
        // D s_3987_4: read-var opc2:u8
        let s_3987_4: u8 = fn_state.opc2;
        // D s_3987_5: read-var CRm:u8
        let s_3987_5: u8 = fn_state.CRm;
        // D s_3987_6: read-var t:i
        let s_3987_6: i128 = fn_state.t;
        // D s_3987_7: call TLBIMVAAL_SysRegWrite32_b622dab84122dbc0(s_3987_0, s_3987_1, s_3987_2, s_3987_3, s_3987_4, s_3987_5, s_3987_6)
        let s_3987_7: () = TLBIMVAAL_SysRegWrite32_b622dab84122dbc0(
            state,
            tracer,
            s_3987_0,
            s_3987_1,
            s_3987_2,
            s_3987_3,
            s_3987_4,
            s_3987_5,
            s_3987_6,
        );
        // N s_3987_8: return
        return;
    }
    fn block_3988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3988_0: read-var opc2:u8
        let s_3988_0: u8 = fn_state.opc2;
        // D s_3988_1: cast zx s_3988_0 -> bv
        let s_3988_1: Bits = Bits::new(s_3988_0 as u128, 3u16);
        // C s_3988_2: const #7u : u8
        let s_3988_2: u8 = 7;
        // C s_3988_3: cast zx s_3988_2 -> bv
        let s_3988_3: Bits = Bits::new(s_3988_2 as u128, 3u16);
        // D s_3988_4: cmp-eq s_3988_1 s_3988_3
        let s_3988_4: bool = ((s_3988_1) == (s_3988_3));
        // D s_3988_5: write-var gs#135871 <= s_3988_4
        fn_state.gs_135871 = s_3988_4;
        // N s_3988_6: jump b3131
        return block_3131(state, tracer, fn_state);
    }
    fn block_3989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3989_0: read-var opc1:u8
        let s_3989_0: u8 = fn_state.opc1;
        // D s_3989_1: cast zx s_3989_0 -> bv
        let s_3989_1: Bits = Bits::new(s_3989_0 as u128, 3u16);
        // C s_3989_2: const #0u : u8
        let s_3989_2: u8 = 0;
        // C s_3989_3: cast zx s_3989_2 -> bv
        let s_3989_3: Bits = Bits::new(s_3989_2 as u128, 3u16);
        // D s_3989_4: cmp-eq s_3989_1 s_3989_3
        let s_3989_4: bool = ((s_3989_1) == (s_3989_3));
        // D s_3989_5: write-var gs#135870 <= s_3989_4
        fn_state.gs_135870 = s_3989_4;
        // N s_3989_6: jump b3129
        return block_3129(state, tracer, fn_state);
    }
    fn block_3990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3990_0: read-var coproc:u8
        let s_3990_0: u8 = fn_state.coproc;
        // D s_3990_1: cast zx s_3990_0 -> bv
        let s_3990_1: Bits = Bits::new(s_3990_0 as u128, 4u16);
        // C s_3990_2: const #15u : u8
        let s_3990_2: u8 = 15;
        // C s_3990_3: cast zx s_3990_2 -> bv
        let s_3990_3: Bits = Bits::new(s_3990_2 as u128, 4u16);
        // D s_3990_4: cmp-eq s_3990_1 s_3990_3
        let s_3990_4: bool = ((s_3990_1) == (s_3990_3));
        // D s_3990_5: write-var gs#135869 <= s_3990_4
        fn_state.gs_135869 = s_3990_4;
        // N s_3990_6: jump b3127
        return block_3127(state, tracer, fn_state);
    }
    fn block_3991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3991_0: read-var CRn:u8
        let s_3991_0: u8 = fn_state.CRn;
        // D s_3991_1: cast zx s_3991_0 -> bv
        let s_3991_1: Bits = Bits::new(s_3991_0 as u128, 4u16);
        // C s_3991_2: const #8u : u8
        let s_3991_2: u8 = 8;
        // C s_3991_3: cast zx s_3991_2 -> bv
        let s_3991_3: Bits = Bits::new(s_3991_2 as u128, 4u16);
        // D s_3991_4: cmp-eq s_3991_1 s_3991_3
        let s_3991_4: bool = ((s_3991_1) == (s_3991_3));
        // D s_3991_5: write-var gs#135868 <= s_3991_4
        fn_state.gs_135868 = s_3991_4;
        // N s_3991_6: jump b3125
        return block_3125(state, tracer, fn_state);
    }
    fn block_3992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3992_0: read-var el:u8
        let s_3992_0: u8 = fn_state.el;
        // D s_3992_1: read-var coproc:u8
        let s_3992_1: u8 = fn_state.coproc;
        // D s_3992_2: read-var opc1:u8
        let s_3992_2: u8 = fn_state.opc1;
        // D s_3992_3: read-var CRn:u8
        let s_3992_3: u8 = fn_state.CRn;
        // D s_3992_4: read-var opc2:u8
        let s_3992_4: u8 = fn_state.opc2;
        // D s_3992_5: read-var CRm:u8
        let s_3992_5: u8 = fn_state.CRm;
        // D s_3992_6: read-var t:i
        let s_3992_6: i128 = fn_state.t;
        // D s_3992_7: call DSPSR2_SysRegWrite32_d1d98bc563bc83d5(s_3992_0, s_3992_1, s_3992_2, s_3992_3, s_3992_4, s_3992_5, s_3992_6)
        let s_3992_7: () = DSPSR2_SysRegWrite32_d1d98bc563bc83d5(
            state,
            tracer,
            s_3992_0,
            s_3992_1,
            s_3992_2,
            s_3992_3,
            s_3992_4,
            s_3992_5,
            s_3992_6,
        );
        // N s_3992_8: return
        return;
    }
    fn block_3993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3993_0: read-var opc2:u8
        let s_3993_0: u8 = fn_state.opc2;
        // D s_3993_1: cast zx s_3993_0 -> bv
        let s_3993_1: Bits = Bits::new(s_3993_0 as u128, 3u16);
        // C s_3993_2: const #2u : u8
        let s_3993_2: u8 = 2;
        // C s_3993_3: cast zx s_3993_2 -> bv
        let s_3993_3: Bits = Bits::new(s_3993_2 as u128, 3u16);
        // D s_3993_4: cmp-eq s_3993_1 s_3993_3
        let s_3993_4: bool = ((s_3993_1) == (s_3993_3));
        // D s_3993_5: write-var gs#135867 <= s_3993_4
        fn_state.gs_135867 = s_3993_4;
        // N s_3993_6: jump b3122
        return block_3122(state, tracer, fn_state);
    }
    fn block_3994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3994_0: read-var opc1:u8
        let s_3994_0: u8 = fn_state.opc1;
        // D s_3994_1: cast zx s_3994_0 -> bv
        let s_3994_1: Bits = Bits::new(s_3994_0 as u128, 3u16);
        // C s_3994_2: const #3u : u8
        let s_3994_2: u8 = 3;
        // C s_3994_3: cast zx s_3994_2 -> bv
        let s_3994_3: Bits = Bits::new(s_3994_2 as u128, 3u16);
        // D s_3994_4: cmp-eq s_3994_1 s_3994_3
        let s_3994_4: bool = ((s_3994_1) == (s_3994_3));
        // D s_3994_5: write-var gs#135866 <= s_3994_4
        fn_state.gs_135866 = s_3994_4;
        // N s_3994_6: jump b3120
        return block_3120(state, tracer, fn_state);
    }
    fn block_3995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3995_0: read-var coproc:u8
        let s_3995_0: u8 = fn_state.coproc;
        // D s_3995_1: cast zx s_3995_0 -> bv
        let s_3995_1: Bits = Bits::new(s_3995_0 as u128, 4u16);
        // C s_3995_2: const #15u : u8
        let s_3995_2: u8 = 15;
        // C s_3995_3: cast zx s_3995_2 -> bv
        let s_3995_3: Bits = Bits::new(s_3995_2 as u128, 4u16);
        // D s_3995_4: cmp-eq s_3995_1 s_3995_3
        let s_3995_4: bool = ((s_3995_1) == (s_3995_3));
        // D s_3995_5: write-var gs#135865 <= s_3995_4
        fn_state.gs_135865 = s_3995_4;
        // N s_3995_6: jump b3118
        return block_3118(state, tracer, fn_state);
    }
    fn block_3996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3996_0: read-var CRn:u8
        let s_3996_0: u8 = fn_state.CRn;
        // D s_3996_1: cast zx s_3996_0 -> bv
        let s_3996_1: Bits = Bits::new(s_3996_0 as u128, 4u16);
        // C s_3996_2: const #4u : u8
        let s_3996_2: u8 = 4;
        // C s_3996_3: cast zx s_3996_2 -> bv
        let s_3996_3: Bits = Bits::new(s_3996_2 as u128, 4u16);
        // D s_3996_4: cmp-eq s_3996_1 s_3996_3
        let s_3996_4: bool = ((s_3996_1) == (s_3996_3));
        // D s_3996_5: write-var gs#135864 <= s_3996_4
        fn_state.gs_135864 = s_3996_4;
        // N s_3996_6: jump b3116
        return block_3116(state, tracer, fn_state);
    }
    fn block_3997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3997_0: read-var el:u8
        let s_3997_0: u8 = fn_state.el;
        // D s_3997_1: read-var coproc:u8
        let s_3997_1: u8 = fn_state.coproc;
        // D s_3997_2: read-var opc1:u8
        let s_3997_2: u8 = fn_state.opc1;
        // D s_3997_3: read-var CRn:u8
        let s_3997_3: u8 = fn_state.CRn;
        // D s_3997_4: read-var opc2:u8
        let s_3997_4: u8 = fn_state.opc2;
        // D s_3997_5: read-var CRm:u8
        let s_3997_5: u8 = fn_state.CRm;
        // D s_3997_6: read-var t:i
        let s_3997_6: i128 = fn_state.t;
        // D s_3997_7: call ICH_LRC_SysRegWrite32_fa0ed50b180dc30b(s_3997_0, s_3997_1, s_3997_2, s_3997_3, s_3997_4, s_3997_5, s_3997_6)
        let s_3997_7: () = ICH_LRC_SysRegWrite32_fa0ed50b180dc30b(
            state,
            tracer,
            s_3997_0,
            s_3997_1,
            s_3997_2,
            s_3997_3,
            s_3997_4,
            s_3997_5,
            s_3997_6,
        );
        // N s_3997_8: return
        return;
    }
    fn block_3998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3998_0: read-var opc2:u8
        let s_3998_0: u8 = fn_state.opc2;
        // D s_3998_1: cast zx s_3998_0 -> bv
        let s_3998_1: Bits = Bits::new(s_3998_0 as u128, 3u16);
        // C s_3998_2: const #0u : u8
        let s_3998_2: u8 = 0;
        // C s_3998_3: cast zx s_3998_2 -> bv
        let s_3998_3: Bits = Bits::new(s_3998_2 as u128, 3u16);
        // D s_3998_4: cmp-eq s_3998_1 s_3998_3
        let s_3998_4: bool = ((s_3998_1) == (s_3998_3));
        // D s_3998_5: write-var gs#135863 <= s_3998_4
        fn_state.gs_135863 = s_3998_4;
        // N s_3998_6: jump b3113
        return block_3113(state, tracer, fn_state);
    }
    fn block_3999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3999_0: read-var opc1:u8
        let s_3999_0: u8 = fn_state.opc1;
        // D s_3999_1: cast zx s_3999_0 -> bv
        let s_3999_1: Bits = Bits::new(s_3999_0 as u128, 3u16);
        // C s_3999_2: const #4u : u8
        let s_3999_2: u8 = 4;
        // C s_3999_3: cast zx s_3999_2 -> bv
        let s_3999_3: Bits = Bits::new(s_3999_2 as u128, 3u16);
        // D s_3999_4: cmp-eq s_3999_1 s_3999_3
        let s_3999_4: bool = ((s_3999_1) == (s_3999_3));
        // D s_3999_5: write-var gs#135862 <= s_3999_4
        fn_state.gs_135862 = s_3999_4;
        // N s_3999_6: jump b3111
        return block_3111(state, tracer, fn_state);
    }
    fn block_4000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4000_0: read-var coproc:u8
        let s_4000_0: u8 = fn_state.coproc;
        // D s_4000_1: cast zx s_4000_0 -> bv
        let s_4000_1: Bits = Bits::new(s_4000_0 as u128, 4u16);
        // C s_4000_2: const #15u : u8
        let s_4000_2: u8 = 15;
        // C s_4000_3: cast zx s_4000_2 -> bv
        let s_4000_3: Bits = Bits::new(s_4000_2 as u128, 4u16);
        // D s_4000_4: cmp-eq s_4000_1 s_4000_3
        let s_4000_4: bool = ((s_4000_1) == (s_4000_3));
        // D s_4000_5: write-var gs#135861 <= s_4000_4
        fn_state.gs_135861 = s_4000_4;
        // N s_4000_6: jump b3109
        return block_3109(state, tracer, fn_state);
    }
    fn block_4001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4001_0: read-var CRn:u8
        let s_4001_0: u8 = fn_state.CRn;
        // D s_4001_1: cast zx s_4001_0 -> bv
        let s_4001_1: Bits = Bits::new(s_4001_0 as u128, 4u16);
        // C s_4001_2: const #12u : u8
        let s_4001_2: u8 = 12;
        // C s_4001_3: cast zx s_4001_2 -> bv
        let s_4001_3: Bits = Bits::new(s_4001_2 as u128, 4u16);
        // D s_4001_4: cmp-eq s_4001_1 s_4001_3
        let s_4001_4: bool = ((s_4001_1) == (s_4001_3));
        // D s_4001_5: write-var gs#135860 <= s_4001_4
        fn_state.gs_135860 = s_4001_4;
        // N s_4001_6: jump b3107
        return block_3107(state, tracer, fn_state);
    }
    fn block_4002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4002_0: read-var el:u8
        let s_4002_0: u8 = fn_state.el;
        // D s_4002_1: read-var coproc:u8
        let s_4002_1: u8 = fn_state.coproc;
        // D s_4002_2: read-var opc1:u8
        let s_4002_2: u8 = fn_state.opc1;
        // D s_4002_3: read-var CRn:u8
        let s_4002_3: u8 = fn_state.CRn;
        // D s_4002_4: read-var opc2:u8
        let s_4002_4: u8 = fn_state.opc2;
        // D s_4002_5: read-var CRm:u8
        let s_4002_5: u8 = fn_state.CRm;
        // D s_4002_6: read-var t:i
        let s_4002_6: i128 = fn_state.t;
        // D s_4002_7: call ICH_LRC_SysRegWrite32_9511e78c9b2df1ea(s_4002_0, s_4002_1, s_4002_2, s_4002_3, s_4002_4, s_4002_5, s_4002_6)
        let s_4002_7: () = ICH_LRC_SysRegWrite32_9511e78c9b2df1ea(
            state,
            tracer,
            s_4002_0,
            s_4002_1,
            s_4002_2,
            s_4002_3,
            s_4002_4,
            s_4002_5,
            s_4002_6,
        );
        // N s_4002_8: return
        return;
    }
    fn block_4003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4003_0: read-var opc2:u8
        let s_4003_0: u8 = fn_state.opc2;
        // D s_4003_1: cast zx s_4003_0 -> bv
        let s_4003_1: Bits = Bits::new(s_4003_0 as u128, 3u16);
        // C s_4003_2: const #1u : u8
        let s_4003_2: u8 = 1;
        // C s_4003_3: cast zx s_4003_2 -> bv
        let s_4003_3: Bits = Bits::new(s_4003_2 as u128, 3u16);
        // D s_4003_4: cmp-eq s_4003_1 s_4003_3
        let s_4003_4: bool = ((s_4003_1) == (s_4003_3));
        // D s_4003_5: write-var gs#135859 <= s_4003_4
        fn_state.gs_135859 = s_4003_4;
        // N s_4003_6: jump b3104
        return block_3104(state, tracer, fn_state);
    }
    fn block_4004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4004_0: read-var opc1:u8
        let s_4004_0: u8 = fn_state.opc1;
        // D s_4004_1: cast zx s_4004_0 -> bv
        let s_4004_1: Bits = Bits::new(s_4004_0 as u128, 3u16);
        // C s_4004_2: const #4u : u8
        let s_4004_2: u8 = 4;
        // C s_4004_3: cast zx s_4004_2 -> bv
        let s_4004_3: Bits = Bits::new(s_4004_2 as u128, 3u16);
        // D s_4004_4: cmp-eq s_4004_1 s_4004_3
        let s_4004_4: bool = ((s_4004_1) == (s_4004_3));
        // D s_4004_5: write-var gs#135858 <= s_4004_4
        fn_state.gs_135858 = s_4004_4;
        // N s_4004_6: jump b3102
        return block_3102(state, tracer, fn_state);
    }
    fn block_4005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4005_0: read-var coproc:u8
        let s_4005_0: u8 = fn_state.coproc;
        // D s_4005_1: cast zx s_4005_0 -> bv
        let s_4005_1: Bits = Bits::new(s_4005_0 as u128, 4u16);
        // C s_4005_2: const #15u : u8
        let s_4005_2: u8 = 15;
        // C s_4005_3: cast zx s_4005_2 -> bv
        let s_4005_3: Bits = Bits::new(s_4005_2 as u128, 4u16);
        // D s_4005_4: cmp-eq s_4005_1 s_4005_3
        let s_4005_4: bool = ((s_4005_1) == (s_4005_3));
        // D s_4005_5: write-var gs#135857 <= s_4005_4
        fn_state.gs_135857 = s_4005_4;
        // N s_4005_6: jump b3100
        return block_3100(state, tracer, fn_state);
    }
    fn block_4006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4006_0: read-var CRn:u8
        let s_4006_0: u8 = fn_state.CRn;
        // D s_4006_1: cast zx s_4006_0 -> bv
        let s_4006_1: Bits = Bits::new(s_4006_0 as u128, 4u16);
        // C s_4006_2: const #12u : u8
        let s_4006_2: u8 = 12;
        // C s_4006_3: cast zx s_4006_2 -> bv
        let s_4006_3: Bits = Bits::new(s_4006_2 as u128, 4u16);
        // D s_4006_4: cmp-eq s_4006_1 s_4006_3
        let s_4006_4: bool = ((s_4006_1) == (s_4006_3));
        // D s_4006_5: write-var gs#135856 <= s_4006_4
        fn_state.gs_135856 = s_4006_4;
        // N s_4006_6: jump b3098
        return block_3098(state, tracer, fn_state);
    }
    fn block_4007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4007_0: read-var el:u8
        let s_4007_0: u8 = fn_state.el;
        // D s_4007_1: read-var coproc:u8
        let s_4007_1: u8 = fn_state.coproc;
        // D s_4007_2: read-var opc1:u8
        let s_4007_2: u8 = fn_state.opc1;
        // D s_4007_3: read-var CRn:u8
        let s_4007_3: u8 = fn_state.CRn;
        // D s_4007_4: read-var opc2:u8
        let s_4007_4: u8 = fn_state.opc2;
        // D s_4007_5: read-var CRm:u8
        let s_4007_5: u8 = fn_state.CRm;
        // D s_4007_6: read-var t:i
        let s_4007_6: i128 = fn_state.t;
        // D s_4007_7: call ICH_LRC_SysRegWrite32_dfd8b885b691ae03(s_4007_0, s_4007_1, s_4007_2, s_4007_3, s_4007_4, s_4007_5, s_4007_6)
        let s_4007_7: () = ICH_LRC_SysRegWrite32_dfd8b885b691ae03(
            state,
            tracer,
            s_4007_0,
            s_4007_1,
            s_4007_2,
            s_4007_3,
            s_4007_4,
            s_4007_5,
            s_4007_6,
        );
        // N s_4007_8: return
        return;
    }
    fn block_4008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4008_0: read-var opc2:u8
        let s_4008_0: u8 = fn_state.opc2;
        // D s_4008_1: cast zx s_4008_0 -> bv
        let s_4008_1: Bits = Bits::new(s_4008_0 as u128, 3u16);
        // C s_4008_2: const #2u : u8
        let s_4008_2: u8 = 2;
        // C s_4008_3: cast zx s_4008_2 -> bv
        let s_4008_3: Bits = Bits::new(s_4008_2 as u128, 3u16);
        // D s_4008_4: cmp-eq s_4008_1 s_4008_3
        let s_4008_4: bool = ((s_4008_1) == (s_4008_3));
        // D s_4008_5: write-var gs#135855 <= s_4008_4
        fn_state.gs_135855 = s_4008_4;
        // N s_4008_6: jump b3095
        return block_3095(state, tracer, fn_state);
    }
    fn block_4009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4009_0: read-var opc1:u8
        let s_4009_0: u8 = fn_state.opc1;
        // D s_4009_1: cast zx s_4009_0 -> bv
        let s_4009_1: Bits = Bits::new(s_4009_0 as u128, 3u16);
        // C s_4009_2: const #4u : u8
        let s_4009_2: u8 = 4;
        // C s_4009_3: cast zx s_4009_2 -> bv
        let s_4009_3: Bits = Bits::new(s_4009_2 as u128, 3u16);
        // D s_4009_4: cmp-eq s_4009_1 s_4009_3
        let s_4009_4: bool = ((s_4009_1) == (s_4009_3));
        // D s_4009_5: write-var gs#135854 <= s_4009_4
        fn_state.gs_135854 = s_4009_4;
        // N s_4009_6: jump b3093
        return block_3093(state, tracer, fn_state);
    }
    fn block_4010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4010_0: read-var coproc:u8
        let s_4010_0: u8 = fn_state.coproc;
        // D s_4010_1: cast zx s_4010_0 -> bv
        let s_4010_1: Bits = Bits::new(s_4010_0 as u128, 4u16);
        // C s_4010_2: const #15u : u8
        let s_4010_2: u8 = 15;
        // C s_4010_3: cast zx s_4010_2 -> bv
        let s_4010_3: Bits = Bits::new(s_4010_2 as u128, 4u16);
        // D s_4010_4: cmp-eq s_4010_1 s_4010_3
        let s_4010_4: bool = ((s_4010_1) == (s_4010_3));
        // D s_4010_5: write-var gs#135853 <= s_4010_4
        fn_state.gs_135853 = s_4010_4;
        // N s_4010_6: jump b3091
        return block_3091(state, tracer, fn_state);
    }
    fn block_4011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4011_0: read-var CRn:u8
        let s_4011_0: u8 = fn_state.CRn;
        // D s_4011_1: cast zx s_4011_0 -> bv
        let s_4011_1: Bits = Bits::new(s_4011_0 as u128, 4u16);
        // C s_4011_2: const #12u : u8
        let s_4011_2: u8 = 12;
        // C s_4011_3: cast zx s_4011_2 -> bv
        let s_4011_3: Bits = Bits::new(s_4011_2 as u128, 4u16);
        // D s_4011_4: cmp-eq s_4011_1 s_4011_3
        let s_4011_4: bool = ((s_4011_1) == (s_4011_3));
        // D s_4011_5: write-var gs#135852 <= s_4011_4
        fn_state.gs_135852 = s_4011_4;
        // N s_4011_6: jump b3089
        return block_3089(state, tracer, fn_state);
    }
    fn block_4012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4012_0: read-var el:u8
        let s_4012_0: u8 = fn_state.el;
        // D s_4012_1: read-var coproc:u8
        let s_4012_1: u8 = fn_state.coproc;
        // D s_4012_2: read-var opc1:u8
        let s_4012_2: u8 = fn_state.opc1;
        // D s_4012_3: read-var CRn:u8
        let s_4012_3: u8 = fn_state.CRn;
        // D s_4012_4: read-var opc2:u8
        let s_4012_4: u8 = fn_state.opc2;
        // D s_4012_5: read-var CRm:u8
        let s_4012_5: u8 = fn_state.CRm;
        // D s_4012_6: read-var t:i
        let s_4012_6: i128 = fn_state.t;
        // D s_4012_7: call ICH_LRC_SysRegWrite32_e225401f886e4760(s_4012_0, s_4012_1, s_4012_2, s_4012_3, s_4012_4, s_4012_5, s_4012_6)
        let s_4012_7: () = ICH_LRC_SysRegWrite32_e225401f886e4760(
            state,
            tracer,
            s_4012_0,
            s_4012_1,
            s_4012_2,
            s_4012_3,
            s_4012_4,
            s_4012_5,
            s_4012_6,
        );
        // N s_4012_8: return
        return;
    }
    fn block_4013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4013_0: read-var opc2:u8
        let s_4013_0: u8 = fn_state.opc2;
        // D s_4013_1: cast zx s_4013_0 -> bv
        let s_4013_1: Bits = Bits::new(s_4013_0 as u128, 3u16);
        // C s_4013_2: const #3u : u8
        let s_4013_2: u8 = 3;
        // C s_4013_3: cast zx s_4013_2 -> bv
        let s_4013_3: Bits = Bits::new(s_4013_2 as u128, 3u16);
        // D s_4013_4: cmp-eq s_4013_1 s_4013_3
        let s_4013_4: bool = ((s_4013_1) == (s_4013_3));
        // D s_4013_5: write-var gs#135851 <= s_4013_4
        fn_state.gs_135851 = s_4013_4;
        // N s_4013_6: jump b3086
        return block_3086(state, tracer, fn_state);
    }
    fn block_4014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4014_0: read-var opc1:u8
        let s_4014_0: u8 = fn_state.opc1;
        // D s_4014_1: cast zx s_4014_0 -> bv
        let s_4014_1: Bits = Bits::new(s_4014_0 as u128, 3u16);
        // C s_4014_2: const #4u : u8
        let s_4014_2: u8 = 4;
        // C s_4014_3: cast zx s_4014_2 -> bv
        let s_4014_3: Bits = Bits::new(s_4014_2 as u128, 3u16);
        // D s_4014_4: cmp-eq s_4014_1 s_4014_3
        let s_4014_4: bool = ((s_4014_1) == (s_4014_3));
        // D s_4014_5: write-var gs#135850 <= s_4014_4
        fn_state.gs_135850 = s_4014_4;
        // N s_4014_6: jump b3084
        return block_3084(state, tracer, fn_state);
    }
    fn block_4015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4015_0: read-var coproc:u8
        let s_4015_0: u8 = fn_state.coproc;
        // D s_4015_1: cast zx s_4015_0 -> bv
        let s_4015_1: Bits = Bits::new(s_4015_0 as u128, 4u16);
        // C s_4015_2: const #15u : u8
        let s_4015_2: u8 = 15;
        // C s_4015_3: cast zx s_4015_2 -> bv
        let s_4015_3: Bits = Bits::new(s_4015_2 as u128, 4u16);
        // D s_4015_4: cmp-eq s_4015_1 s_4015_3
        let s_4015_4: bool = ((s_4015_1) == (s_4015_3));
        // D s_4015_5: write-var gs#135849 <= s_4015_4
        fn_state.gs_135849 = s_4015_4;
        // N s_4015_6: jump b3082
        return block_3082(state, tracer, fn_state);
    }
    fn block_4016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4016_0: read-var CRn:u8
        let s_4016_0: u8 = fn_state.CRn;
        // D s_4016_1: cast zx s_4016_0 -> bv
        let s_4016_1: Bits = Bits::new(s_4016_0 as u128, 4u16);
        // C s_4016_2: const #12u : u8
        let s_4016_2: u8 = 12;
        // C s_4016_3: cast zx s_4016_2 -> bv
        let s_4016_3: Bits = Bits::new(s_4016_2 as u128, 4u16);
        // D s_4016_4: cmp-eq s_4016_1 s_4016_3
        let s_4016_4: bool = ((s_4016_1) == (s_4016_3));
        // D s_4016_5: write-var gs#135848 <= s_4016_4
        fn_state.gs_135848 = s_4016_4;
        // N s_4016_6: jump b3080
        return block_3080(state, tracer, fn_state);
    }
    fn block_4017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4017_0: read-var el:u8
        let s_4017_0: u8 = fn_state.el;
        // D s_4017_1: read-var coproc:u8
        let s_4017_1: u8 = fn_state.coproc;
        // D s_4017_2: read-var opc1:u8
        let s_4017_2: u8 = fn_state.opc1;
        // D s_4017_3: read-var CRn:u8
        let s_4017_3: u8 = fn_state.CRn;
        // D s_4017_4: read-var opc2:u8
        let s_4017_4: u8 = fn_state.opc2;
        // D s_4017_5: read-var CRm:u8
        let s_4017_5: u8 = fn_state.CRm;
        // D s_4017_6: read-var t:i
        let s_4017_6: i128 = fn_state.t;
        // D s_4017_7: call ICH_LRC_SysRegWrite32_b623b068212a51e1(s_4017_0, s_4017_1, s_4017_2, s_4017_3, s_4017_4, s_4017_5, s_4017_6)
        let s_4017_7: () = ICH_LRC_SysRegWrite32_b623b068212a51e1(
            state,
            tracer,
            s_4017_0,
            s_4017_1,
            s_4017_2,
            s_4017_3,
            s_4017_4,
            s_4017_5,
            s_4017_6,
        );
        // N s_4017_8: return
        return;
    }
    fn block_4018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4018_0: read-var opc2:u8
        let s_4018_0: u8 = fn_state.opc2;
        // D s_4018_1: cast zx s_4018_0 -> bv
        let s_4018_1: Bits = Bits::new(s_4018_0 as u128, 3u16);
        // C s_4018_2: const #4u : u8
        let s_4018_2: u8 = 4;
        // C s_4018_3: cast zx s_4018_2 -> bv
        let s_4018_3: Bits = Bits::new(s_4018_2 as u128, 3u16);
        // D s_4018_4: cmp-eq s_4018_1 s_4018_3
        let s_4018_4: bool = ((s_4018_1) == (s_4018_3));
        // D s_4018_5: write-var gs#135847 <= s_4018_4
        fn_state.gs_135847 = s_4018_4;
        // N s_4018_6: jump b3077
        return block_3077(state, tracer, fn_state);
    }
    fn block_4019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4019_0: read-var opc1:u8
        let s_4019_0: u8 = fn_state.opc1;
        // D s_4019_1: cast zx s_4019_0 -> bv
        let s_4019_1: Bits = Bits::new(s_4019_0 as u128, 3u16);
        // C s_4019_2: const #4u : u8
        let s_4019_2: u8 = 4;
        // C s_4019_3: cast zx s_4019_2 -> bv
        let s_4019_3: Bits = Bits::new(s_4019_2 as u128, 3u16);
        // D s_4019_4: cmp-eq s_4019_1 s_4019_3
        let s_4019_4: bool = ((s_4019_1) == (s_4019_3));
        // D s_4019_5: write-var gs#135846 <= s_4019_4
        fn_state.gs_135846 = s_4019_4;
        // N s_4019_6: jump b3075
        return block_3075(state, tracer, fn_state);
    }
    fn block_4020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4020_0: read-var coproc:u8
        let s_4020_0: u8 = fn_state.coproc;
        // D s_4020_1: cast zx s_4020_0 -> bv
        let s_4020_1: Bits = Bits::new(s_4020_0 as u128, 4u16);
        // C s_4020_2: const #15u : u8
        let s_4020_2: u8 = 15;
        // C s_4020_3: cast zx s_4020_2 -> bv
        let s_4020_3: Bits = Bits::new(s_4020_2 as u128, 4u16);
        // D s_4020_4: cmp-eq s_4020_1 s_4020_3
        let s_4020_4: bool = ((s_4020_1) == (s_4020_3));
        // D s_4020_5: write-var gs#135845 <= s_4020_4
        fn_state.gs_135845 = s_4020_4;
        // N s_4020_6: jump b3073
        return block_3073(state, tracer, fn_state);
    }
    fn block_4021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4021_0: read-var CRn:u8
        let s_4021_0: u8 = fn_state.CRn;
        // D s_4021_1: cast zx s_4021_0 -> bv
        let s_4021_1: Bits = Bits::new(s_4021_0 as u128, 4u16);
        // C s_4021_2: const #12u : u8
        let s_4021_2: u8 = 12;
        // C s_4021_3: cast zx s_4021_2 -> bv
        let s_4021_3: Bits = Bits::new(s_4021_2 as u128, 4u16);
        // D s_4021_4: cmp-eq s_4021_1 s_4021_3
        let s_4021_4: bool = ((s_4021_1) == (s_4021_3));
        // D s_4021_5: write-var gs#135844 <= s_4021_4
        fn_state.gs_135844 = s_4021_4;
        // N s_4021_6: jump b3071
        return block_3071(state, tracer, fn_state);
    }
    fn block_4022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4022_0: read-var el:u8
        let s_4022_0: u8 = fn_state.el;
        // D s_4022_1: read-var coproc:u8
        let s_4022_1: u8 = fn_state.coproc;
        // D s_4022_2: read-var opc1:u8
        let s_4022_2: u8 = fn_state.opc1;
        // D s_4022_3: read-var CRn:u8
        let s_4022_3: u8 = fn_state.CRn;
        // D s_4022_4: read-var opc2:u8
        let s_4022_4: u8 = fn_state.opc2;
        // D s_4022_5: read-var CRm:u8
        let s_4022_5: u8 = fn_state.CRm;
        // D s_4022_6: read-var t:i
        let s_4022_6: i128 = fn_state.t;
        // D s_4022_7: call ICH_LRC_SysRegWrite32_a1a007d19312bc57(s_4022_0, s_4022_1, s_4022_2, s_4022_3, s_4022_4, s_4022_5, s_4022_6)
        let s_4022_7: () = ICH_LRC_SysRegWrite32_a1a007d19312bc57(
            state,
            tracer,
            s_4022_0,
            s_4022_1,
            s_4022_2,
            s_4022_3,
            s_4022_4,
            s_4022_5,
            s_4022_6,
        );
        // N s_4022_8: return
        return;
    }
    fn block_4023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4023_0: read-var opc2:u8
        let s_4023_0: u8 = fn_state.opc2;
        // D s_4023_1: cast zx s_4023_0 -> bv
        let s_4023_1: Bits = Bits::new(s_4023_0 as u128, 3u16);
        // C s_4023_2: const #5u : u8
        let s_4023_2: u8 = 5;
        // C s_4023_3: cast zx s_4023_2 -> bv
        let s_4023_3: Bits = Bits::new(s_4023_2 as u128, 3u16);
        // D s_4023_4: cmp-eq s_4023_1 s_4023_3
        let s_4023_4: bool = ((s_4023_1) == (s_4023_3));
        // D s_4023_5: write-var gs#135843 <= s_4023_4
        fn_state.gs_135843 = s_4023_4;
        // N s_4023_6: jump b3068
        return block_3068(state, tracer, fn_state);
    }
    fn block_4024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4024_0: read-var opc1:u8
        let s_4024_0: u8 = fn_state.opc1;
        // D s_4024_1: cast zx s_4024_0 -> bv
        let s_4024_1: Bits = Bits::new(s_4024_0 as u128, 3u16);
        // C s_4024_2: const #4u : u8
        let s_4024_2: u8 = 4;
        // C s_4024_3: cast zx s_4024_2 -> bv
        let s_4024_3: Bits = Bits::new(s_4024_2 as u128, 3u16);
        // D s_4024_4: cmp-eq s_4024_1 s_4024_3
        let s_4024_4: bool = ((s_4024_1) == (s_4024_3));
        // D s_4024_5: write-var gs#135842 <= s_4024_4
        fn_state.gs_135842 = s_4024_4;
        // N s_4024_6: jump b3066
        return block_3066(state, tracer, fn_state);
    }
    fn block_4025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4025_0: read-var coproc:u8
        let s_4025_0: u8 = fn_state.coproc;
        // D s_4025_1: cast zx s_4025_0 -> bv
        let s_4025_1: Bits = Bits::new(s_4025_0 as u128, 4u16);
        // C s_4025_2: const #15u : u8
        let s_4025_2: u8 = 15;
        // C s_4025_3: cast zx s_4025_2 -> bv
        let s_4025_3: Bits = Bits::new(s_4025_2 as u128, 4u16);
        // D s_4025_4: cmp-eq s_4025_1 s_4025_3
        let s_4025_4: bool = ((s_4025_1) == (s_4025_3));
        // D s_4025_5: write-var gs#135841 <= s_4025_4
        fn_state.gs_135841 = s_4025_4;
        // N s_4025_6: jump b3064
        return block_3064(state, tracer, fn_state);
    }
    fn block_4026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4026_0: read-var CRn:u8
        let s_4026_0: u8 = fn_state.CRn;
        // D s_4026_1: cast zx s_4026_0 -> bv
        let s_4026_1: Bits = Bits::new(s_4026_0 as u128, 4u16);
        // C s_4026_2: const #12u : u8
        let s_4026_2: u8 = 12;
        // C s_4026_3: cast zx s_4026_2 -> bv
        let s_4026_3: Bits = Bits::new(s_4026_2 as u128, 4u16);
        // D s_4026_4: cmp-eq s_4026_1 s_4026_3
        let s_4026_4: bool = ((s_4026_1) == (s_4026_3));
        // D s_4026_5: write-var gs#135840 <= s_4026_4
        fn_state.gs_135840 = s_4026_4;
        // N s_4026_6: jump b3062
        return block_3062(state, tracer, fn_state);
    }
    fn block_4027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4027_0: read-var el:u8
        let s_4027_0: u8 = fn_state.el;
        // D s_4027_1: read-var coproc:u8
        let s_4027_1: u8 = fn_state.coproc;
        // D s_4027_2: read-var opc1:u8
        let s_4027_2: u8 = fn_state.opc1;
        // D s_4027_3: read-var CRn:u8
        let s_4027_3: u8 = fn_state.CRn;
        // D s_4027_4: read-var opc2:u8
        let s_4027_4: u8 = fn_state.opc2;
        // D s_4027_5: read-var CRm:u8
        let s_4027_5: u8 = fn_state.CRm;
        // D s_4027_6: read-var t:i
        let s_4027_6: i128 = fn_state.t;
        // D s_4027_7: call ICH_LRC_SysRegWrite32_9859737df8ae4807(s_4027_0, s_4027_1, s_4027_2, s_4027_3, s_4027_4, s_4027_5, s_4027_6)
        let s_4027_7: () = ICH_LRC_SysRegWrite32_9859737df8ae4807(
            state,
            tracer,
            s_4027_0,
            s_4027_1,
            s_4027_2,
            s_4027_3,
            s_4027_4,
            s_4027_5,
            s_4027_6,
        );
        // N s_4027_8: return
        return;
    }
    fn block_4028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4028_0: read-var opc2:u8
        let s_4028_0: u8 = fn_state.opc2;
        // D s_4028_1: cast zx s_4028_0 -> bv
        let s_4028_1: Bits = Bits::new(s_4028_0 as u128, 3u16);
        // C s_4028_2: const #6u : u8
        let s_4028_2: u8 = 6;
        // C s_4028_3: cast zx s_4028_2 -> bv
        let s_4028_3: Bits = Bits::new(s_4028_2 as u128, 3u16);
        // D s_4028_4: cmp-eq s_4028_1 s_4028_3
        let s_4028_4: bool = ((s_4028_1) == (s_4028_3));
        // D s_4028_5: write-var gs#135839 <= s_4028_4
        fn_state.gs_135839 = s_4028_4;
        // N s_4028_6: jump b3059
        return block_3059(state, tracer, fn_state);
    }
    fn block_4029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4029_0: read-var opc1:u8
        let s_4029_0: u8 = fn_state.opc1;
        // D s_4029_1: cast zx s_4029_0 -> bv
        let s_4029_1: Bits = Bits::new(s_4029_0 as u128, 3u16);
        // C s_4029_2: const #4u : u8
        let s_4029_2: u8 = 4;
        // C s_4029_3: cast zx s_4029_2 -> bv
        let s_4029_3: Bits = Bits::new(s_4029_2 as u128, 3u16);
        // D s_4029_4: cmp-eq s_4029_1 s_4029_3
        let s_4029_4: bool = ((s_4029_1) == (s_4029_3));
        // D s_4029_5: write-var gs#135838 <= s_4029_4
        fn_state.gs_135838 = s_4029_4;
        // N s_4029_6: jump b3057
        return block_3057(state, tracer, fn_state);
    }
    fn block_4030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4030_0: read-var coproc:u8
        let s_4030_0: u8 = fn_state.coproc;
        // D s_4030_1: cast zx s_4030_0 -> bv
        let s_4030_1: Bits = Bits::new(s_4030_0 as u128, 4u16);
        // C s_4030_2: const #15u : u8
        let s_4030_2: u8 = 15;
        // C s_4030_3: cast zx s_4030_2 -> bv
        let s_4030_3: Bits = Bits::new(s_4030_2 as u128, 4u16);
        // D s_4030_4: cmp-eq s_4030_1 s_4030_3
        let s_4030_4: bool = ((s_4030_1) == (s_4030_3));
        // D s_4030_5: write-var gs#135837 <= s_4030_4
        fn_state.gs_135837 = s_4030_4;
        // N s_4030_6: jump b3055
        return block_3055(state, tracer, fn_state);
    }
    fn block_4031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4031_0: read-var CRn:u8
        let s_4031_0: u8 = fn_state.CRn;
        // D s_4031_1: cast zx s_4031_0 -> bv
        let s_4031_1: Bits = Bits::new(s_4031_0 as u128, 4u16);
        // C s_4031_2: const #12u : u8
        let s_4031_2: u8 = 12;
        // C s_4031_3: cast zx s_4031_2 -> bv
        let s_4031_3: Bits = Bits::new(s_4031_2 as u128, 4u16);
        // D s_4031_4: cmp-eq s_4031_1 s_4031_3
        let s_4031_4: bool = ((s_4031_1) == (s_4031_3));
        // D s_4031_5: write-var gs#135836 <= s_4031_4
        fn_state.gs_135836 = s_4031_4;
        // N s_4031_6: jump b3053
        return block_3053(state, tracer, fn_state);
    }
    fn block_4032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4032_0: read-var el:u8
        let s_4032_0: u8 = fn_state.el;
        // D s_4032_1: read-var coproc:u8
        let s_4032_1: u8 = fn_state.coproc;
        // D s_4032_2: read-var opc1:u8
        let s_4032_2: u8 = fn_state.opc1;
        // D s_4032_3: read-var CRn:u8
        let s_4032_3: u8 = fn_state.CRn;
        // D s_4032_4: read-var opc2:u8
        let s_4032_4: u8 = fn_state.opc2;
        // D s_4032_5: read-var CRm:u8
        let s_4032_5: u8 = fn_state.CRm;
        // D s_4032_6: read-var t:i
        let s_4032_6: i128 = fn_state.t;
        // D s_4032_7: call ICH_LRC_SysRegWrite32_386394d9b9080275(s_4032_0, s_4032_1, s_4032_2, s_4032_3, s_4032_4, s_4032_5, s_4032_6)
        let s_4032_7: () = ICH_LRC_SysRegWrite32_386394d9b9080275(
            state,
            tracer,
            s_4032_0,
            s_4032_1,
            s_4032_2,
            s_4032_3,
            s_4032_4,
            s_4032_5,
            s_4032_6,
        );
        // N s_4032_8: return
        return;
    }
    fn block_4033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4033_0: read-var opc2:u8
        let s_4033_0: u8 = fn_state.opc2;
        // D s_4033_1: cast zx s_4033_0 -> bv
        let s_4033_1: Bits = Bits::new(s_4033_0 as u128, 3u16);
        // C s_4033_2: const #7u : u8
        let s_4033_2: u8 = 7;
        // C s_4033_3: cast zx s_4033_2 -> bv
        let s_4033_3: Bits = Bits::new(s_4033_2 as u128, 3u16);
        // D s_4033_4: cmp-eq s_4033_1 s_4033_3
        let s_4033_4: bool = ((s_4033_1) == (s_4033_3));
        // D s_4033_5: write-var gs#135835 <= s_4033_4
        fn_state.gs_135835 = s_4033_4;
        // N s_4033_6: jump b3050
        return block_3050(state, tracer, fn_state);
    }
    fn block_4034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4034_0: read-var opc1:u8
        let s_4034_0: u8 = fn_state.opc1;
        // D s_4034_1: cast zx s_4034_0 -> bv
        let s_4034_1: Bits = Bits::new(s_4034_0 as u128, 3u16);
        // C s_4034_2: const #4u : u8
        let s_4034_2: u8 = 4;
        // C s_4034_3: cast zx s_4034_2 -> bv
        let s_4034_3: Bits = Bits::new(s_4034_2 as u128, 3u16);
        // D s_4034_4: cmp-eq s_4034_1 s_4034_3
        let s_4034_4: bool = ((s_4034_1) == (s_4034_3));
        // D s_4034_5: write-var gs#135834 <= s_4034_4
        fn_state.gs_135834 = s_4034_4;
        // N s_4034_6: jump b3048
        return block_3048(state, tracer, fn_state);
    }
    fn block_4035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4035_0: read-var coproc:u8
        let s_4035_0: u8 = fn_state.coproc;
        // D s_4035_1: cast zx s_4035_0 -> bv
        let s_4035_1: Bits = Bits::new(s_4035_0 as u128, 4u16);
        // C s_4035_2: const #15u : u8
        let s_4035_2: u8 = 15;
        // C s_4035_3: cast zx s_4035_2 -> bv
        let s_4035_3: Bits = Bits::new(s_4035_2 as u128, 4u16);
        // D s_4035_4: cmp-eq s_4035_1 s_4035_3
        let s_4035_4: bool = ((s_4035_1) == (s_4035_3));
        // D s_4035_5: write-var gs#135833 <= s_4035_4
        fn_state.gs_135833 = s_4035_4;
        // N s_4035_6: jump b3046
        return block_3046(state, tracer, fn_state);
    }
    fn block_4036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4036_0: read-var CRn:u8
        let s_4036_0: u8 = fn_state.CRn;
        // D s_4036_1: cast zx s_4036_0 -> bv
        let s_4036_1: Bits = Bits::new(s_4036_0 as u128, 4u16);
        // C s_4036_2: const #12u : u8
        let s_4036_2: u8 = 12;
        // C s_4036_3: cast zx s_4036_2 -> bv
        let s_4036_3: Bits = Bits::new(s_4036_2 as u128, 4u16);
        // D s_4036_4: cmp-eq s_4036_1 s_4036_3
        let s_4036_4: bool = ((s_4036_1) == (s_4036_3));
        // D s_4036_5: write-var gs#135832 <= s_4036_4
        fn_state.gs_135832 = s_4036_4;
        // N s_4036_6: jump b3044
        return block_3044(state, tracer, fn_state);
    }
    fn block_4037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4037_0: read-var el:u8
        let s_4037_0: u8 = fn_state.el;
        // D s_4037_1: read-var coproc:u8
        let s_4037_1: u8 = fn_state.coproc;
        // D s_4037_2: read-var opc1:u8
        let s_4037_2: u8 = fn_state.opc1;
        // D s_4037_3: read-var CRn:u8
        let s_4037_3: u8 = fn_state.CRn;
        // D s_4037_4: read-var opc2:u8
        let s_4037_4: u8 = fn_state.opc2;
        // D s_4037_5: read-var CRm:u8
        let s_4037_5: u8 = fn_state.CRm;
        // D s_4037_6: read-var t:i
        let s_4037_6: i128 = fn_state.t;
        // D s_4037_7: call ICH_LRC_SysRegWrite32_51763a756078a699(s_4037_0, s_4037_1, s_4037_2, s_4037_3, s_4037_4, s_4037_5, s_4037_6)
        let s_4037_7: () = ICH_LRC_SysRegWrite32_51763a756078a699(
            state,
            tracer,
            s_4037_0,
            s_4037_1,
            s_4037_2,
            s_4037_3,
            s_4037_4,
            s_4037_5,
            s_4037_6,
        );
        // N s_4037_8: return
        return;
    }
    fn block_4038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4038_0: read-var opc2:u8
        let s_4038_0: u8 = fn_state.opc2;
        // D s_4038_1: cast zx s_4038_0 -> bv
        let s_4038_1: Bits = Bits::new(s_4038_0 as u128, 3u16);
        // C s_4038_2: const #0u : u8
        let s_4038_2: u8 = 0;
        // C s_4038_3: cast zx s_4038_2 -> bv
        let s_4038_3: Bits = Bits::new(s_4038_2 as u128, 3u16);
        // D s_4038_4: cmp-eq s_4038_1 s_4038_3
        let s_4038_4: bool = ((s_4038_1) == (s_4038_3));
        // D s_4038_5: write-var gs#135831 <= s_4038_4
        fn_state.gs_135831 = s_4038_4;
        // N s_4038_6: jump b3041
        return block_3041(state, tracer, fn_state);
    }
    fn block_4039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4039_0: read-var opc1:u8
        let s_4039_0: u8 = fn_state.opc1;
        // D s_4039_1: cast zx s_4039_0 -> bv
        let s_4039_1: Bits = Bits::new(s_4039_0 as u128, 3u16);
        // C s_4039_2: const #4u : u8
        let s_4039_2: u8 = 4;
        // C s_4039_3: cast zx s_4039_2 -> bv
        let s_4039_3: Bits = Bits::new(s_4039_2 as u128, 3u16);
        // D s_4039_4: cmp-eq s_4039_1 s_4039_3
        let s_4039_4: bool = ((s_4039_1) == (s_4039_3));
        // D s_4039_5: write-var gs#135830 <= s_4039_4
        fn_state.gs_135830 = s_4039_4;
        // N s_4039_6: jump b3039
        return block_3039(state, tracer, fn_state);
    }
    fn block_4040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4040_0: read-var coproc:u8
        let s_4040_0: u8 = fn_state.coproc;
        // D s_4040_1: cast zx s_4040_0 -> bv
        let s_4040_1: Bits = Bits::new(s_4040_0 as u128, 4u16);
        // C s_4040_2: const #15u : u8
        let s_4040_2: u8 = 15;
        // C s_4040_3: cast zx s_4040_2 -> bv
        let s_4040_3: Bits = Bits::new(s_4040_2 as u128, 4u16);
        // D s_4040_4: cmp-eq s_4040_1 s_4040_3
        let s_4040_4: bool = ((s_4040_1) == (s_4040_3));
        // D s_4040_5: write-var gs#135829 <= s_4040_4
        fn_state.gs_135829 = s_4040_4;
        // N s_4040_6: jump b3037
        return block_3037(state, tracer, fn_state);
    }
    fn block_4041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4041_0: read-var CRn:u8
        let s_4041_0: u8 = fn_state.CRn;
        // D s_4041_1: cast zx s_4041_0 -> bv
        let s_4041_1: Bits = Bits::new(s_4041_0 as u128, 4u16);
        // C s_4041_2: const #12u : u8
        let s_4041_2: u8 = 12;
        // C s_4041_3: cast zx s_4041_2 -> bv
        let s_4041_3: Bits = Bits::new(s_4041_2 as u128, 4u16);
        // D s_4041_4: cmp-eq s_4041_1 s_4041_3
        let s_4041_4: bool = ((s_4041_1) == (s_4041_3));
        // D s_4041_5: write-var gs#135828 <= s_4041_4
        fn_state.gs_135828 = s_4041_4;
        // N s_4041_6: jump b3035
        return block_3035(state, tracer, fn_state);
    }
    fn block_4042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4042_0: read-var el:u8
        let s_4042_0: u8 = fn_state.el;
        // D s_4042_1: read-var coproc:u8
        let s_4042_1: u8 = fn_state.coproc;
        // D s_4042_2: read-var opc1:u8
        let s_4042_2: u8 = fn_state.opc1;
        // D s_4042_3: read-var CRn:u8
        let s_4042_3: u8 = fn_state.CRn;
        // D s_4042_4: read-var opc2:u8
        let s_4042_4: u8 = fn_state.opc2;
        // D s_4042_5: read-var CRm:u8
        let s_4042_5: u8 = fn_state.CRm;
        // D s_4042_6: read-var t:i
        let s_4042_6: i128 = fn_state.t;
        // D s_4042_7: call ICH_LRC_SysRegWrite32_43a5c55815de94d9(s_4042_0, s_4042_1, s_4042_2, s_4042_3, s_4042_4, s_4042_5, s_4042_6)
        let s_4042_7: () = ICH_LRC_SysRegWrite32_43a5c55815de94d9(
            state,
            tracer,
            s_4042_0,
            s_4042_1,
            s_4042_2,
            s_4042_3,
            s_4042_4,
            s_4042_5,
            s_4042_6,
        );
        // N s_4042_8: return
        return;
    }
    fn block_4043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4043_0: read-var opc2:u8
        let s_4043_0: u8 = fn_state.opc2;
        // D s_4043_1: cast zx s_4043_0 -> bv
        let s_4043_1: Bits = Bits::new(s_4043_0 as u128, 3u16);
        // C s_4043_2: const #1u : u8
        let s_4043_2: u8 = 1;
        // C s_4043_3: cast zx s_4043_2 -> bv
        let s_4043_3: Bits = Bits::new(s_4043_2 as u128, 3u16);
        // D s_4043_4: cmp-eq s_4043_1 s_4043_3
        let s_4043_4: bool = ((s_4043_1) == (s_4043_3));
        // D s_4043_5: write-var gs#135827 <= s_4043_4
        fn_state.gs_135827 = s_4043_4;
        // N s_4043_6: jump b3032
        return block_3032(state, tracer, fn_state);
    }
    fn block_4044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4044_0: read-var opc1:u8
        let s_4044_0: u8 = fn_state.opc1;
        // D s_4044_1: cast zx s_4044_0 -> bv
        let s_4044_1: Bits = Bits::new(s_4044_0 as u128, 3u16);
        // C s_4044_2: const #4u : u8
        let s_4044_2: u8 = 4;
        // C s_4044_3: cast zx s_4044_2 -> bv
        let s_4044_3: Bits = Bits::new(s_4044_2 as u128, 3u16);
        // D s_4044_4: cmp-eq s_4044_1 s_4044_3
        let s_4044_4: bool = ((s_4044_1) == (s_4044_3));
        // D s_4044_5: write-var gs#135826 <= s_4044_4
        fn_state.gs_135826 = s_4044_4;
        // N s_4044_6: jump b3030
        return block_3030(state, tracer, fn_state);
    }
    fn block_4045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4045_0: read-var coproc:u8
        let s_4045_0: u8 = fn_state.coproc;
        // D s_4045_1: cast zx s_4045_0 -> bv
        let s_4045_1: Bits = Bits::new(s_4045_0 as u128, 4u16);
        // C s_4045_2: const #15u : u8
        let s_4045_2: u8 = 15;
        // C s_4045_3: cast zx s_4045_2 -> bv
        let s_4045_3: Bits = Bits::new(s_4045_2 as u128, 4u16);
        // D s_4045_4: cmp-eq s_4045_1 s_4045_3
        let s_4045_4: bool = ((s_4045_1) == (s_4045_3));
        // D s_4045_5: write-var gs#135825 <= s_4045_4
        fn_state.gs_135825 = s_4045_4;
        // N s_4045_6: jump b3028
        return block_3028(state, tracer, fn_state);
    }
    fn block_4046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4046_0: read-var CRn:u8
        let s_4046_0: u8 = fn_state.CRn;
        // D s_4046_1: cast zx s_4046_0 -> bv
        let s_4046_1: Bits = Bits::new(s_4046_0 as u128, 4u16);
        // C s_4046_2: const #12u : u8
        let s_4046_2: u8 = 12;
        // C s_4046_3: cast zx s_4046_2 -> bv
        let s_4046_3: Bits = Bits::new(s_4046_2 as u128, 4u16);
        // D s_4046_4: cmp-eq s_4046_1 s_4046_3
        let s_4046_4: bool = ((s_4046_1) == (s_4046_3));
        // D s_4046_5: write-var gs#135824 <= s_4046_4
        fn_state.gs_135824 = s_4046_4;
        // N s_4046_6: jump b3026
        return block_3026(state, tracer, fn_state);
    }
    fn block_4047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4047_0: read-var el:u8
        let s_4047_0: u8 = fn_state.el;
        // D s_4047_1: read-var coproc:u8
        let s_4047_1: u8 = fn_state.coproc;
        // D s_4047_2: read-var opc1:u8
        let s_4047_2: u8 = fn_state.opc1;
        // D s_4047_3: read-var CRn:u8
        let s_4047_3: u8 = fn_state.CRn;
        // D s_4047_4: read-var opc2:u8
        let s_4047_4: u8 = fn_state.opc2;
        // D s_4047_5: read-var CRm:u8
        let s_4047_5: u8 = fn_state.CRm;
        // D s_4047_6: read-var t:i
        let s_4047_6: i128 = fn_state.t;
        // D s_4047_7: call ICH_LRC_SysRegWrite32_bc7eed7f83c8b68e(s_4047_0, s_4047_1, s_4047_2, s_4047_3, s_4047_4, s_4047_5, s_4047_6)
        let s_4047_7: () = ICH_LRC_SysRegWrite32_bc7eed7f83c8b68e(
            state,
            tracer,
            s_4047_0,
            s_4047_1,
            s_4047_2,
            s_4047_3,
            s_4047_4,
            s_4047_5,
            s_4047_6,
        );
        // N s_4047_8: return
        return;
    }
    fn block_4048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4048_0: read-var opc2:u8
        let s_4048_0: u8 = fn_state.opc2;
        // D s_4048_1: cast zx s_4048_0 -> bv
        let s_4048_1: Bits = Bits::new(s_4048_0 as u128, 3u16);
        // C s_4048_2: const #2u : u8
        let s_4048_2: u8 = 2;
        // C s_4048_3: cast zx s_4048_2 -> bv
        let s_4048_3: Bits = Bits::new(s_4048_2 as u128, 3u16);
        // D s_4048_4: cmp-eq s_4048_1 s_4048_3
        let s_4048_4: bool = ((s_4048_1) == (s_4048_3));
        // D s_4048_5: write-var gs#135823 <= s_4048_4
        fn_state.gs_135823 = s_4048_4;
        // N s_4048_6: jump b3023
        return block_3023(state, tracer, fn_state);
    }
    fn block_4049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4049_0: read-var opc1:u8
        let s_4049_0: u8 = fn_state.opc1;
        // D s_4049_1: cast zx s_4049_0 -> bv
        let s_4049_1: Bits = Bits::new(s_4049_0 as u128, 3u16);
        // C s_4049_2: const #4u : u8
        let s_4049_2: u8 = 4;
        // C s_4049_3: cast zx s_4049_2 -> bv
        let s_4049_3: Bits = Bits::new(s_4049_2 as u128, 3u16);
        // D s_4049_4: cmp-eq s_4049_1 s_4049_3
        let s_4049_4: bool = ((s_4049_1) == (s_4049_3));
        // D s_4049_5: write-var gs#135822 <= s_4049_4
        fn_state.gs_135822 = s_4049_4;
        // N s_4049_6: jump b3021
        return block_3021(state, tracer, fn_state);
    }
    fn block_4050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4050_0: read-var coproc:u8
        let s_4050_0: u8 = fn_state.coproc;
        // D s_4050_1: cast zx s_4050_0 -> bv
        let s_4050_1: Bits = Bits::new(s_4050_0 as u128, 4u16);
        // C s_4050_2: const #15u : u8
        let s_4050_2: u8 = 15;
        // C s_4050_3: cast zx s_4050_2 -> bv
        let s_4050_3: Bits = Bits::new(s_4050_2 as u128, 4u16);
        // D s_4050_4: cmp-eq s_4050_1 s_4050_3
        let s_4050_4: bool = ((s_4050_1) == (s_4050_3));
        // D s_4050_5: write-var gs#135821 <= s_4050_4
        fn_state.gs_135821 = s_4050_4;
        // N s_4050_6: jump b3019
        return block_3019(state, tracer, fn_state);
    }
    fn block_4051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4051_0: read-var CRn:u8
        let s_4051_0: u8 = fn_state.CRn;
        // D s_4051_1: cast zx s_4051_0 -> bv
        let s_4051_1: Bits = Bits::new(s_4051_0 as u128, 4u16);
        // C s_4051_2: const #12u : u8
        let s_4051_2: u8 = 12;
        // C s_4051_3: cast zx s_4051_2 -> bv
        let s_4051_3: Bits = Bits::new(s_4051_2 as u128, 4u16);
        // D s_4051_4: cmp-eq s_4051_1 s_4051_3
        let s_4051_4: bool = ((s_4051_1) == (s_4051_3));
        // D s_4051_5: write-var gs#135820 <= s_4051_4
        fn_state.gs_135820 = s_4051_4;
        // N s_4051_6: jump b3017
        return block_3017(state, tracer, fn_state);
    }
    fn block_4052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4052_0: read-var el:u8
        let s_4052_0: u8 = fn_state.el;
        // D s_4052_1: read-var coproc:u8
        let s_4052_1: u8 = fn_state.coproc;
        // D s_4052_2: read-var opc1:u8
        let s_4052_2: u8 = fn_state.opc1;
        // D s_4052_3: read-var CRn:u8
        let s_4052_3: u8 = fn_state.CRn;
        // D s_4052_4: read-var opc2:u8
        let s_4052_4: u8 = fn_state.opc2;
        // D s_4052_5: read-var CRm:u8
        let s_4052_5: u8 = fn_state.CRm;
        // D s_4052_6: read-var t:i
        let s_4052_6: i128 = fn_state.t;
        // D s_4052_7: call ICH_LRC_SysRegWrite32_26a1b63afe3dfd72(s_4052_0, s_4052_1, s_4052_2, s_4052_3, s_4052_4, s_4052_5, s_4052_6)
        let s_4052_7: () = ICH_LRC_SysRegWrite32_26a1b63afe3dfd72(
            state,
            tracer,
            s_4052_0,
            s_4052_1,
            s_4052_2,
            s_4052_3,
            s_4052_4,
            s_4052_5,
            s_4052_6,
        );
        // N s_4052_8: return
        return;
    }
    fn block_4053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4053_0: read-var opc2:u8
        let s_4053_0: u8 = fn_state.opc2;
        // D s_4053_1: cast zx s_4053_0 -> bv
        let s_4053_1: Bits = Bits::new(s_4053_0 as u128, 3u16);
        // C s_4053_2: const #3u : u8
        let s_4053_2: u8 = 3;
        // C s_4053_3: cast zx s_4053_2 -> bv
        let s_4053_3: Bits = Bits::new(s_4053_2 as u128, 3u16);
        // D s_4053_4: cmp-eq s_4053_1 s_4053_3
        let s_4053_4: bool = ((s_4053_1) == (s_4053_3));
        // D s_4053_5: write-var gs#135819 <= s_4053_4
        fn_state.gs_135819 = s_4053_4;
        // N s_4053_6: jump b3014
        return block_3014(state, tracer, fn_state);
    }
    fn block_4054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4054_0: read-var opc1:u8
        let s_4054_0: u8 = fn_state.opc1;
        // D s_4054_1: cast zx s_4054_0 -> bv
        let s_4054_1: Bits = Bits::new(s_4054_0 as u128, 3u16);
        // C s_4054_2: const #4u : u8
        let s_4054_2: u8 = 4;
        // C s_4054_3: cast zx s_4054_2 -> bv
        let s_4054_3: Bits = Bits::new(s_4054_2 as u128, 3u16);
        // D s_4054_4: cmp-eq s_4054_1 s_4054_3
        let s_4054_4: bool = ((s_4054_1) == (s_4054_3));
        // D s_4054_5: write-var gs#135818 <= s_4054_4
        fn_state.gs_135818 = s_4054_4;
        // N s_4054_6: jump b3012
        return block_3012(state, tracer, fn_state);
    }
    fn block_4055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4055_0: read-var coproc:u8
        let s_4055_0: u8 = fn_state.coproc;
        // D s_4055_1: cast zx s_4055_0 -> bv
        let s_4055_1: Bits = Bits::new(s_4055_0 as u128, 4u16);
        // C s_4055_2: const #15u : u8
        let s_4055_2: u8 = 15;
        // C s_4055_3: cast zx s_4055_2 -> bv
        let s_4055_3: Bits = Bits::new(s_4055_2 as u128, 4u16);
        // D s_4055_4: cmp-eq s_4055_1 s_4055_3
        let s_4055_4: bool = ((s_4055_1) == (s_4055_3));
        // D s_4055_5: write-var gs#135817 <= s_4055_4
        fn_state.gs_135817 = s_4055_4;
        // N s_4055_6: jump b3010
        return block_3010(state, tracer, fn_state);
    }
    fn block_4056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4056_0: read-var CRn:u8
        let s_4056_0: u8 = fn_state.CRn;
        // D s_4056_1: cast zx s_4056_0 -> bv
        let s_4056_1: Bits = Bits::new(s_4056_0 as u128, 4u16);
        // C s_4056_2: const #12u : u8
        let s_4056_2: u8 = 12;
        // C s_4056_3: cast zx s_4056_2 -> bv
        let s_4056_3: Bits = Bits::new(s_4056_2 as u128, 4u16);
        // D s_4056_4: cmp-eq s_4056_1 s_4056_3
        let s_4056_4: bool = ((s_4056_1) == (s_4056_3));
        // D s_4056_5: write-var gs#135816 <= s_4056_4
        fn_state.gs_135816 = s_4056_4;
        // N s_4056_6: jump b3008
        return block_3008(state, tracer, fn_state);
    }
    fn block_4057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4057_0: read-var el:u8
        let s_4057_0: u8 = fn_state.el;
        // D s_4057_1: read-var coproc:u8
        let s_4057_1: u8 = fn_state.coproc;
        // D s_4057_2: read-var opc1:u8
        let s_4057_2: u8 = fn_state.opc1;
        // D s_4057_3: read-var CRn:u8
        let s_4057_3: u8 = fn_state.CRn;
        // D s_4057_4: read-var opc2:u8
        let s_4057_4: u8 = fn_state.opc2;
        // D s_4057_5: read-var CRm:u8
        let s_4057_5: u8 = fn_state.CRm;
        // D s_4057_6: read-var t:i
        let s_4057_6: i128 = fn_state.t;
        // D s_4057_7: call ICH_LRC_SysRegWrite32_5dd9fb114b3c7d62(s_4057_0, s_4057_1, s_4057_2, s_4057_3, s_4057_4, s_4057_5, s_4057_6)
        let s_4057_7: () = ICH_LRC_SysRegWrite32_5dd9fb114b3c7d62(
            state,
            tracer,
            s_4057_0,
            s_4057_1,
            s_4057_2,
            s_4057_3,
            s_4057_4,
            s_4057_5,
            s_4057_6,
        );
        // N s_4057_8: return
        return;
    }
    fn block_4058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4058_0: read-var opc2:u8
        let s_4058_0: u8 = fn_state.opc2;
        // D s_4058_1: cast zx s_4058_0 -> bv
        let s_4058_1: Bits = Bits::new(s_4058_0 as u128, 3u16);
        // C s_4058_2: const #4u : u8
        let s_4058_2: u8 = 4;
        // C s_4058_3: cast zx s_4058_2 -> bv
        let s_4058_3: Bits = Bits::new(s_4058_2 as u128, 3u16);
        // D s_4058_4: cmp-eq s_4058_1 s_4058_3
        let s_4058_4: bool = ((s_4058_1) == (s_4058_3));
        // D s_4058_5: write-var gs#135815 <= s_4058_4
        fn_state.gs_135815 = s_4058_4;
        // N s_4058_6: jump b3005
        return block_3005(state, tracer, fn_state);
    }
    fn block_4059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4059_0: read-var opc1:u8
        let s_4059_0: u8 = fn_state.opc1;
        // D s_4059_1: cast zx s_4059_0 -> bv
        let s_4059_1: Bits = Bits::new(s_4059_0 as u128, 3u16);
        // C s_4059_2: const #4u : u8
        let s_4059_2: u8 = 4;
        // C s_4059_3: cast zx s_4059_2 -> bv
        let s_4059_3: Bits = Bits::new(s_4059_2 as u128, 3u16);
        // D s_4059_4: cmp-eq s_4059_1 s_4059_3
        let s_4059_4: bool = ((s_4059_1) == (s_4059_3));
        // D s_4059_5: write-var gs#135814 <= s_4059_4
        fn_state.gs_135814 = s_4059_4;
        // N s_4059_6: jump b3003
        return block_3003(state, tracer, fn_state);
    }
    fn block_4060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4060_0: read-var coproc:u8
        let s_4060_0: u8 = fn_state.coproc;
        // D s_4060_1: cast zx s_4060_0 -> bv
        let s_4060_1: Bits = Bits::new(s_4060_0 as u128, 4u16);
        // C s_4060_2: const #15u : u8
        let s_4060_2: u8 = 15;
        // C s_4060_3: cast zx s_4060_2 -> bv
        let s_4060_3: Bits = Bits::new(s_4060_2 as u128, 4u16);
        // D s_4060_4: cmp-eq s_4060_1 s_4060_3
        let s_4060_4: bool = ((s_4060_1) == (s_4060_3));
        // D s_4060_5: write-var gs#135813 <= s_4060_4
        fn_state.gs_135813 = s_4060_4;
        // N s_4060_6: jump b3001
        return block_3001(state, tracer, fn_state);
    }
    fn block_4061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4061_0: read-var CRn:u8
        let s_4061_0: u8 = fn_state.CRn;
        // D s_4061_1: cast zx s_4061_0 -> bv
        let s_4061_1: Bits = Bits::new(s_4061_0 as u128, 4u16);
        // C s_4061_2: const #12u : u8
        let s_4061_2: u8 = 12;
        // C s_4061_3: cast zx s_4061_2 -> bv
        let s_4061_3: Bits = Bits::new(s_4061_2 as u128, 4u16);
        // D s_4061_4: cmp-eq s_4061_1 s_4061_3
        let s_4061_4: bool = ((s_4061_1) == (s_4061_3));
        // D s_4061_5: write-var gs#135812 <= s_4061_4
        fn_state.gs_135812 = s_4061_4;
        // N s_4061_6: jump b2999
        return block_2999(state, tracer, fn_state);
    }
    fn block_4062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4062_0: read-var el:u8
        let s_4062_0: u8 = fn_state.el;
        // D s_4062_1: read-var coproc:u8
        let s_4062_1: u8 = fn_state.coproc;
        // D s_4062_2: read-var opc1:u8
        let s_4062_2: u8 = fn_state.opc1;
        // D s_4062_3: read-var CRn:u8
        let s_4062_3: u8 = fn_state.CRn;
        // D s_4062_4: read-var opc2:u8
        let s_4062_4: u8 = fn_state.opc2;
        // D s_4062_5: read-var CRm:u8
        let s_4062_5: u8 = fn_state.CRm;
        // D s_4062_6: read-var t:i
        let s_4062_6: i128 = fn_state.t;
        // D s_4062_7: call ICH_LRC_SysRegWrite32_5036a59d7b5ab1d9(s_4062_0, s_4062_1, s_4062_2, s_4062_3, s_4062_4, s_4062_5, s_4062_6)
        let s_4062_7: () = ICH_LRC_SysRegWrite32_5036a59d7b5ab1d9(
            state,
            tracer,
            s_4062_0,
            s_4062_1,
            s_4062_2,
            s_4062_3,
            s_4062_4,
            s_4062_5,
            s_4062_6,
        );
        // N s_4062_8: return
        return;
    }
    fn block_4063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4063_0: read-var opc2:u8
        let s_4063_0: u8 = fn_state.opc2;
        // D s_4063_1: cast zx s_4063_0 -> bv
        let s_4063_1: Bits = Bits::new(s_4063_0 as u128, 3u16);
        // C s_4063_2: const #5u : u8
        let s_4063_2: u8 = 5;
        // C s_4063_3: cast zx s_4063_2 -> bv
        let s_4063_3: Bits = Bits::new(s_4063_2 as u128, 3u16);
        // D s_4063_4: cmp-eq s_4063_1 s_4063_3
        let s_4063_4: bool = ((s_4063_1) == (s_4063_3));
        // D s_4063_5: write-var gs#135811 <= s_4063_4
        fn_state.gs_135811 = s_4063_4;
        // N s_4063_6: jump b2996
        return block_2996(state, tracer, fn_state);
    }
    fn block_4064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4064_0: read-var opc1:u8
        let s_4064_0: u8 = fn_state.opc1;
        // D s_4064_1: cast zx s_4064_0 -> bv
        let s_4064_1: Bits = Bits::new(s_4064_0 as u128, 3u16);
        // C s_4064_2: const #4u : u8
        let s_4064_2: u8 = 4;
        // C s_4064_3: cast zx s_4064_2 -> bv
        let s_4064_3: Bits = Bits::new(s_4064_2 as u128, 3u16);
        // D s_4064_4: cmp-eq s_4064_1 s_4064_3
        let s_4064_4: bool = ((s_4064_1) == (s_4064_3));
        // D s_4064_5: write-var gs#135810 <= s_4064_4
        fn_state.gs_135810 = s_4064_4;
        // N s_4064_6: jump b2994
        return block_2994(state, tracer, fn_state);
    }
    fn block_4065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4065_0: read-var coproc:u8
        let s_4065_0: u8 = fn_state.coproc;
        // D s_4065_1: cast zx s_4065_0 -> bv
        let s_4065_1: Bits = Bits::new(s_4065_0 as u128, 4u16);
        // C s_4065_2: const #15u : u8
        let s_4065_2: u8 = 15;
        // C s_4065_3: cast zx s_4065_2 -> bv
        let s_4065_3: Bits = Bits::new(s_4065_2 as u128, 4u16);
        // D s_4065_4: cmp-eq s_4065_1 s_4065_3
        let s_4065_4: bool = ((s_4065_1) == (s_4065_3));
        // D s_4065_5: write-var gs#135809 <= s_4065_4
        fn_state.gs_135809 = s_4065_4;
        // N s_4065_6: jump b2992
        return block_2992(state, tracer, fn_state);
    }
    fn block_4066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4066_0: read-var CRn:u8
        let s_4066_0: u8 = fn_state.CRn;
        // D s_4066_1: cast zx s_4066_0 -> bv
        let s_4066_1: Bits = Bits::new(s_4066_0 as u128, 4u16);
        // C s_4066_2: const #12u : u8
        let s_4066_2: u8 = 12;
        // C s_4066_3: cast zx s_4066_2 -> bv
        let s_4066_3: Bits = Bits::new(s_4066_2 as u128, 4u16);
        // D s_4066_4: cmp-eq s_4066_1 s_4066_3
        let s_4066_4: bool = ((s_4066_1) == (s_4066_3));
        // D s_4066_5: write-var gs#135808 <= s_4066_4
        fn_state.gs_135808 = s_4066_4;
        // N s_4066_6: jump b2990
        return block_2990(state, tracer, fn_state);
    }
    fn block_4067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4067_0: read-var el:u8
        let s_4067_0: u8 = fn_state.el;
        // D s_4067_1: read-var coproc:u8
        let s_4067_1: u8 = fn_state.coproc;
        // D s_4067_2: read-var opc1:u8
        let s_4067_2: u8 = fn_state.opc1;
        // D s_4067_3: read-var CRn:u8
        let s_4067_3: u8 = fn_state.CRn;
        // D s_4067_4: read-var opc2:u8
        let s_4067_4: u8 = fn_state.opc2;
        // D s_4067_5: read-var CRm:u8
        let s_4067_5: u8 = fn_state.CRm;
        // D s_4067_6: read-var t:i
        let s_4067_6: i128 = fn_state.t;
        // D s_4067_7: call ICH_LRC_SysRegWrite32_f00162b6acc3532f(s_4067_0, s_4067_1, s_4067_2, s_4067_3, s_4067_4, s_4067_5, s_4067_6)
        let s_4067_7: () = ICH_LRC_SysRegWrite32_f00162b6acc3532f(
            state,
            tracer,
            s_4067_0,
            s_4067_1,
            s_4067_2,
            s_4067_3,
            s_4067_4,
            s_4067_5,
            s_4067_6,
        );
        // N s_4067_8: return
        return;
    }
    fn block_4068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4068_0: read-var opc2:u8
        let s_4068_0: u8 = fn_state.opc2;
        // D s_4068_1: cast zx s_4068_0 -> bv
        let s_4068_1: Bits = Bits::new(s_4068_0 as u128, 3u16);
        // C s_4068_2: const #6u : u8
        let s_4068_2: u8 = 6;
        // C s_4068_3: cast zx s_4068_2 -> bv
        let s_4068_3: Bits = Bits::new(s_4068_2 as u128, 3u16);
        // D s_4068_4: cmp-eq s_4068_1 s_4068_3
        let s_4068_4: bool = ((s_4068_1) == (s_4068_3));
        // D s_4068_5: write-var gs#135807 <= s_4068_4
        fn_state.gs_135807 = s_4068_4;
        // N s_4068_6: jump b2987
        return block_2987(state, tracer, fn_state);
    }
    fn block_4069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4069_0: read-var opc1:u8
        let s_4069_0: u8 = fn_state.opc1;
        // D s_4069_1: cast zx s_4069_0 -> bv
        let s_4069_1: Bits = Bits::new(s_4069_0 as u128, 3u16);
        // C s_4069_2: const #4u : u8
        let s_4069_2: u8 = 4;
        // C s_4069_3: cast zx s_4069_2 -> bv
        let s_4069_3: Bits = Bits::new(s_4069_2 as u128, 3u16);
        // D s_4069_4: cmp-eq s_4069_1 s_4069_3
        let s_4069_4: bool = ((s_4069_1) == (s_4069_3));
        // D s_4069_5: write-var gs#135806 <= s_4069_4
        fn_state.gs_135806 = s_4069_4;
        // N s_4069_6: jump b2985
        return block_2985(state, tracer, fn_state);
    }
    fn block_4070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4070_0: read-var coproc:u8
        let s_4070_0: u8 = fn_state.coproc;
        // D s_4070_1: cast zx s_4070_0 -> bv
        let s_4070_1: Bits = Bits::new(s_4070_0 as u128, 4u16);
        // C s_4070_2: const #15u : u8
        let s_4070_2: u8 = 15;
        // C s_4070_3: cast zx s_4070_2 -> bv
        let s_4070_3: Bits = Bits::new(s_4070_2 as u128, 4u16);
        // D s_4070_4: cmp-eq s_4070_1 s_4070_3
        let s_4070_4: bool = ((s_4070_1) == (s_4070_3));
        // D s_4070_5: write-var gs#135805 <= s_4070_4
        fn_state.gs_135805 = s_4070_4;
        // N s_4070_6: jump b2983
        return block_2983(state, tracer, fn_state);
    }
    fn block_4071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4071_0: read-var CRn:u8
        let s_4071_0: u8 = fn_state.CRn;
        // D s_4071_1: cast zx s_4071_0 -> bv
        let s_4071_1: Bits = Bits::new(s_4071_0 as u128, 4u16);
        // C s_4071_2: const #12u : u8
        let s_4071_2: u8 = 12;
        // C s_4071_3: cast zx s_4071_2 -> bv
        let s_4071_3: Bits = Bits::new(s_4071_2 as u128, 4u16);
        // D s_4071_4: cmp-eq s_4071_1 s_4071_3
        let s_4071_4: bool = ((s_4071_1) == (s_4071_3));
        // D s_4071_5: write-var gs#135804 <= s_4071_4
        fn_state.gs_135804 = s_4071_4;
        // N s_4071_6: jump b2981
        return block_2981(state, tracer, fn_state);
    }
    fn block_4072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4072_0: read-var el:u8
        let s_4072_0: u8 = fn_state.el;
        // D s_4072_1: read-var coproc:u8
        let s_4072_1: u8 = fn_state.coproc;
        // D s_4072_2: read-var opc1:u8
        let s_4072_2: u8 = fn_state.opc1;
        // D s_4072_3: read-var CRn:u8
        let s_4072_3: u8 = fn_state.CRn;
        // D s_4072_4: read-var opc2:u8
        let s_4072_4: u8 = fn_state.opc2;
        // D s_4072_5: read-var CRm:u8
        let s_4072_5: u8 = fn_state.CRm;
        // D s_4072_6: read-var t:i
        let s_4072_6: i128 = fn_state.t;
        // D s_4072_7: call ICH_LRC_SysRegWrite32_ed5a361acf9b81f0(s_4072_0, s_4072_1, s_4072_2, s_4072_3, s_4072_4, s_4072_5, s_4072_6)
        let s_4072_7: () = ICH_LRC_SysRegWrite32_ed5a361acf9b81f0(
            state,
            tracer,
            s_4072_0,
            s_4072_1,
            s_4072_2,
            s_4072_3,
            s_4072_4,
            s_4072_5,
            s_4072_6,
        );
        // N s_4072_8: return
        return;
    }
    fn block_4073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4073_0: read-var opc2:u8
        let s_4073_0: u8 = fn_state.opc2;
        // D s_4073_1: cast zx s_4073_0 -> bv
        let s_4073_1: Bits = Bits::new(s_4073_0 as u128, 3u16);
        // C s_4073_2: const #7u : u8
        let s_4073_2: u8 = 7;
        // C s_4073_3: cast zx s_4073_2 -> bv
        let s_4073_3: Bits = Bits::new(s_4073_2 as u128, 3u16);
        // D s_4073_4: cmp-eq s_4073_1 s_4073_3
        let s_4073_4: bool = ((s_4073_1) == (s_4073_3));
        // D s_4073_5: write-var gs#135803 <= s_4073_4
        fn_state.gs_135803 = s_4073_4;
        // N s_4073_6: jump b2978
        return block_2978(state, tracer, fn_state);
    }
    fn block_4074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4074_0: read-var opc1:u8
        let s_4074_0: u8 = fn_state.opc1;
        // D s_4074_1: cast zx s_4074_0 -> bv
        let s_4074_1: Bits = Bits::new(s_4074_0 as u128, 3u16);
        // C s_4074_2: const #4u : u8
        let s_4074_2: u8 = 4;
        // C s_4074_3: cast zx s_4074_2 -> bv
        let s_4074_3: Bits = Bits::new(s_4074_2 as u128, 3u16);
        // D s_4074_4: cmp-eq s_4074_1 s_4074_3
        let s_4074_4: bool = ((s_4074_1) == (s_4074_3));
        // D s_4074_5: write-var gs#135802 <= s_4074_4
        fn_state.gs_135802 = s_4074_4;
        // N s_4074_6: jump b2976
        return block_2976(state, tracer, fn_state);
    }
    fn block_4075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4075_0: read-var coproc:u8
        let s_4075_0: u8 = fn_state.coproc;
        // D s_4075_1: cast zx s_4075_0 -> bv
        let s_4075_1: Bits = Bits::new(s_4075_0 as u128, 4u16);
        // C s_4075_2: const #15u : u8
        let s_4075_2: u8 = 15;
        // C s_4075_3: cast zx s_4075_2 -> bv
        let s_4075_3: Bits = Bits::new(s_4075_2 as u128, 4u16);
        // D s_4075_4: cmp-eq s_4075_1 s_4075_3
        let s_4075_4: bool = ((s_4075_1) == (s_4075_3));
        // D s_4075_5: write-var gs#135801 <= s_4075_4
        fn_state.gs_135801 = s_4075_4;
        // N s_4075_6: jump b2974
        return block_2974(state, tracer, fn_state);
    }
    fn block_4076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4076_0: read-var CRn:u8
        let s_4076_0: u8 = fn_state.CRn;
        // D s_4076_1: cast zx s_4076_0 -> bv
        let s_4076_1: Bits = Bits::new(s_4076_0 as u128, 4u16);
        // C s_4076_2: const #12u : u8
        let s_4076_2: u8 = 12;
        // C s_4076_3: cast zx s_4076_2 -> bv
        let s_4076_3: Bits = Bits::new(s_4076_2 as u128, 4u16);
        // D s_4076_4: cmp-eq s_4076_1 s_4076_3
        let s_4076_4: bool = ((s_4076_1) == (s_4076_3));
        // D s_4076_5: write-var gs#135800 <= s_4076_4
        fn_state.gs_135800 = s_4076_4;
        // N s_4076_6: jump b2972
        return block_2972(state, tracer, fn_state);
    }
    fn block_4077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4077_0: read-var el:u8
        let s_4077_0: u8 = fn_state.el;
        // D s_4077_1: read-var coproc:u8
        let s_4077_1: u8 = fn_state.coproc;
        // D s_4077_2: read-var opc1:u8
        let s_4077_2: u8 = fn_state.opc1;
        // D s_4077_3: read-var CRn:u8
        let s_4077_3: u8 = fn_state.CRn;
        // D s_4077_4: read-var opc2:u8
        let s_4077_4: u8 = fn_state.opc2;
        // D s_4077_5: read-var CRm:u8
        let s_4077_5: u8 = fn_state.CRm;
        // D s_4077_6: read-var t:i
        let s_4077_6: i128 = fn_state.t;
        // D s_4077_7: call ATS1HR_SysRegWrite32_dc67c53b4eef830a(s_4077_0, s_4077_1, s_4077_2, s_4077_3, s_4077_4, s_4077_5, s_4077_6)
        let s_4077_7: () = ATS1HR_SysRegWrite32_dc67c53b4eef830a(
            state,
            tracer,
            s_4077_0,
            s_4077_1,
            s_4077_2,
            s_4077_3,
            s_4077_4,
            s_4077_5,
            s_4077_6,
        );
        // N s_4077_8: return
        return;
    }
    fn block_4078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4078_0: read-var opc2:u8
        let s_4078_0: u8 = fn_state.opc2;
        // D s_4078_1: cast zx s_4078_0 -> bv
        let s_4078_1: Bits = Bits::new(s_4078_0 as u128, 3u16);
        // C s_4078_2: const #0u : u8
        let s_4078_2: u8 = 0;
        // C s_4078_3: cast zx s_4078_2 -> bv
        let s_4078_3: Bits = Bits::new(s_4078_2 as u128, 3u16);
        // D s_4078_4: cmp-eq s_4078_1 s_4078_3
        let s_4078_4: bool = ((s_4078_1) == (s_4078_3));
        // D s_4078_5: write-var gs#135799 <= s_4078_4
        fn_state.gs_135799 = s_4078_4;
        // N s_4078_6: jump b2969
        return block_2969(state, tracer, fn_state);
    }
    fn block_4079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4079_0: read-var opc1:u8
        let s_4079_0: u8 = fn_state.opc1;
        // D s_4079_1: cast zx s_4079_0 -> bv
        let s_4079_1: Bits = Bits::new(s_4079_0 as u128, 3u16);
        // C s_4079_2: const #4u : u8
        let s_4079_2: u8 = 4;
        // C s_4079_3: cast zx s_4079_2 -> bv
        let s_4079_3: Bits = Bits::new(s_4079_2 as u128, 3u16);
        // D s_4079_4: cmp-eq s_4079_1 s_4079_3
        let s_4079_4: bool = ((s_4079_1) == (s_4079_3));
        // D s_4079_5: write-var gs#135798 <= s_4079_4
        fn_state.gs_135798 = s_4079_4;
        // N s_4079_6: jump b2967
        return block_2967(state, tracer, fn_state);
    }
    fn block_4080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4080_0: read-var coproc:u8
        let s_4080_0: u8 = fn_state.coproc;
        // D s_4080_1: cast zx s_4080_0 -> bv
        let s_4080_1: Bits = Bits::new(s_4080_0 as u128, 4u16);
        // C s_4080_2: const #15u : u8
        let s_4080_2: u8 = 15;
        // C s_4080_3: cast zx s_4080_2 -> bv
        let s_4080_3: Bits = Bits::new(s_4080_2 as u128, 4u16);
        // D s_4080_4: cmp-eq s_4080_1 s_4080_3
        let s_4080_4: bool = ((s_4080_1) == (s_4080_3));
        // D s_4080_5: write-var gs#135797 <= s_4080_4
        fn_state.gs_135797 = s_4080_4;
        // N s_4080_6: jump b2965
        return block_2965(state, tracer, fn_state);
    }
    fn block_4081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4081_0: read-var CRn:u8
        let s_4081_0: u8 = fn_state.CRn;
        // D s_4081_1: cast zx s_4081_0 -> bv
        let s_4081_1: Bits = Bits::new(s_4081_0 as u128, 4u16);
        // C s_4081_2: const #7u : u8
        let s_4081_2: u8 = 7;
        // C s_4081_3: cast zx s_4081_2 -> bv
        let s_4081_3: Bits = Bits::new(s_4081_2 as u128, 4u16);
        // D s_4081_4: cmp-eq s_4081_1 s_4081_3
        let s_4081_4: bool = ((s_4081_1) == (s_4081_3));
        // D s_4081_5: write-var gs#135796 <= s_4081_4
        fn_state.gs_135796 = s_4081_4;
        // N s_4081_6: jump b2963
        return block_2963(state, tracer, fn_state);
    }
    fn block_4082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4082_0: read-var el:u8
        let s_4082_0: u8 = fn_state.el;
        // D s_4082_1: read-var coproc:u8
        let s_4082_1: u8 = fn_state.coproc;
        // D s_4082_2: read-var opc1:u8
        let s_4082_2: u8 = fn_state.opc1;
        // D s_4082_3: read-var CRn:u8
        let s_4082_3: u8 = fn_state.CRn;
        // D s_4082_4: read-var opc2:u8
        let s_4082_4: u8 = fn_state.opc2;
        // D s_4082_5: read-var CRm:u8
        let s_4082_5: u8 = fn_state.CRm;
        // D s_4082_6: read-var t:i
        let s_4082_6: i128 = fn_state.t;
        // D s_4082_7: call DCCSW_SysRegWrite32_0bd93e8a60e2ab27(s_4082_0, s_4082_1, s_4082_2, s_4082_3, s_4082_4, s_4082_5, s_4082_6)
        let s_4082_7: () = DCCSW_SysRegWrite32_0bd93e8a60e2ab27(
            state,
            tracer,
            s_4082_0,
            s_4082_1,
            s_4082_2,
            s_4082_3,
            s_4082_4,
            s_4082_5,
            s_4082_6,
        );
        // N s_4082_8: return
        return;
    }
    fn block_4083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4083_0: read-var opc2:u8
        let s_4083_0: u8 = fn_state.opc2;
        // D s_4083_1: cast zx s_4083_0 -> bv
        let s_4083_1: Bits = Bits::new(s_4083_0 as u128, 3u16);
        // C s_4083_2: const #2u : u8
        let s_4083_2: u8 = 2;
        // C s_4083_3: cast zx s_4083_2 -> bv
        let s_4083_3: Bits = Bits::new(s_4083_2 as u128, 3u16);
        // D s_4083_4: cmp-eq s_4083_1 s_4083_3
        let s_4083_4: bool = ((s_4083_1) == (s_4083_3));
        // D s_4083_5: write-var gs#135795 <= s_4083_4
        fn_state.gs_135795 = s_4083_4;
        // N s_4083_6: jump b2960
        return block_2960(state, tracer, fn_state);
    }
    fn block_4084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4084_0: read-var opc1:u8
        let s_4084_0: u8 = fn_state.opc1;
        // D s_4084_1: cast zx s_4084_0 -> bv
        let s_4084_1: Bits = Bits::new(s_4084_0 as u128, 3u16);
        // C s_4084_2: const #0u : u8
        let s_4084_2: u8 = 0;
        // C s_4084_3: cast zx s_4084_2 -> bv
        let s_4084_3: Bits = Bits::new(s_4084_2 as u128, 3u16);
        // D s_4084_4: cmp-eq s_4084_1 s_4084_3
        let s_4084_4: bool = ((s_4084_1) == (s_4084_3));
        // D s_4084_5: write-var gs#135794 <= s_4084_4
        fn_state.gs_135794 = s_4084_4;
        // N s_4084_6: jump b2958
        return block_2958(state, tracer, fn_state);
    }
    fn block_4085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4085_0: read-var coproc:u8
        let s_4085_0: u8 = fn_state.coproc;
        // D s_4085_1: cast zx s_4085_0 -> bv
        let s_4085_1: Bits = Bits::new(s_4085_0 as u128, 4u16);
        // C s_4085_2: const #15u : u8
        let s_4085_2: u8 = 15;
        // C s_4085_3: cast zx s_4085_2 -> bv
        let s_4085_3: Bits = Bits::new(s_4085_2 as u128, 4u16);
        // D s_4085_4: cmp-eq s_4085_1 s_4085_3
        let s_4085_4: bool = ((s_4085_1) == (s_4085_3));
        // D s_4085_5: write-var gs#135793 <= s_4085_4
        fn_state.gs_135793 = s_4085_4;
        // N s_4085_6: jump b2956
        return block_2956(state, tracer, fn_state);
    }
    fn block_4086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4086_0: read-var CRn:u8
        let s_4086_0: u8 = fn_state.CRn;
        // D s_4086_1: cast zx s_4086_0 -> bv
        let s_4086_1: Bits = Bits::new(s_4086_0 as u128, 4u16);
        // C s_4086_2: const #7u : u8
        let s_4086_2: u8 = 7;
        // C s_4086_3: cast zx s_4086_2 -> bv
        let s_4086_3: Bits = Bits::new(s_4086_2 as u128, 4u16);
        // D s_4086_4: cmp-eq s_4086_1 s_4086_3
        let s_4086_4: bool = ((s_4086_1) == (s_4086_3));
        // D s_4086_5: write-var gs#135792 <= s_4086_4
        fn_state.gs_135792 = s_4086_4;
        // N s_4086_6: jump b2954
        return block_2954(state, tracer, fn_state);
    }
    fn block_4087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4087_0: read-var el:u8
        let s_4087_0: u8 = fn_state.el;
        // D s_4087_1: read-var coproc:u8
        let s_4087_1: u8 = fn_state.coproc;
        // D s_4087_2: read-var opc1:u8
        let s_4087_2: u8 = fn_state.opc1;
        // D s_4087_3: read-var CRn:u8
        let s_4087_3: u8 = fn_state.CRn;
        // D s_4087_4: read-var opc2:u8
        let s_4087_4: u8 = fn_state.opc2;
        // D s_4087_5: read-var CRm:u8
        let s_4087_5: u8 = fn_state.CRm;
        // D s_4087_6: read-var t:i
        let s_4087_6: i128 = fn_state.t;
        // D s_4087_7: call TLBIMVAH_SysRegWrite32_4fb355f41064966b(s_4087_0, s_4087_1, s_4087_2, s_4087_3, s_4087_4, s_4087_5, s_4087_6)
        let s_4087_7: () = TLBIMVAH_SysRegWrite32_4fb355f41064966b(
            state,
            tracer,
            s_4087_0,
            s_4087_1,
            s_4087_2,
            s_4087_3,
            s_4087_4,
            s_4087_5,
            s_4087_6,
        );
        // N s_4087_8: return
        return;
    }
    fn block_4088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4088_0: read-var opc2:u8
        let s_4088_0: u8 = fn_state.opc2;
        // D s_4088_1: cast zx s_4088_0 -> bv
        let s_4088_1: Bits = Bits::new(s_4088_0 as u128, 3u16);
        // C s_4088_2: const #1u : u8
        let s_4088_2: u8 = 1;
        // C s_4088_3: cast zx s_4088_2 -> bv
        let s_4088_3: Bits = Bits::new(s_4088_2 as u128, 3u16);
        // D s_4088_4: cmp-eq s_4088_1 s_4088_3
        let s_4088_4: bool = ((s_4088_1) == (s_4088_3));
        // D s_4088_5: write-var gs#135791 <= s_4088_4
        fn_state.gs_135791 = s_4088_4;
        // N s_4088_6: jump b2951
        return block_2951(state, tracer, fn_state);
    }
    fn block_4089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4089_0: read-var opc1:u8
        let s_4089_0: u8 = fn_state.opc1;
        // D s_4089_1: cast zx s_4089_0 -> bv
        let s_4089_1: Bits = Bits::new(s_4089_0 as u128, 3u16);
        // C s_4089_2: const #4u : u8
        let s_4089_2: u8 = 4;
        // C s_4089_3: cast zx s_4089_2 -> bv
        let s_4089_3: Bits = Bits::new(s_4089_2 as u128, 3u16);
        // D s_4089_4: cmp-eq s_4089_1 s_4089_3
        let s_4089_4: bool = ((s_4089_1) == (s_4089_3));
        // D s_4089_5: write-var gs#135790 <= s_4089_4
        fn_state.gs_135790 = s_4089_4;
        // N s_4089_6: jump b2949
        return block_2949(state, tracer, fn_state);
    }
    fn block_4090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4090_0: read-var coproc:u8
        let s_4090_0: u8 = fn_state.coproc;
        // D s_4090_1: cast zx s_4090_0 -> bv
        let s_4090_1: Bits = Bits::new(s_4090_0 as u128, 4u16);
        // C s_4090_2: const #15u : u8
        let s_4090_2: u8 = 15;
        // C s_4090_3: cast zx s_4090_2 -> bv
        let s_4090_3: Bits = Bits::new(s_4090_2 as u128, 4u16);
        // D s_4090_4: cmp-eq s_4090_1 s_4090_3
        let s_4090_4: bool = ((s_4090_1) == (s_4090_3));
        // D s_4090_5: write-var gs#135789 <= s_4090_4
        fn_state.gs_135789 = s_4090_4;
        // N s_4090_6: jump b2947
        return block_2947(state, tracer, fn_state);
    }
    fn block_4091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4091_0: read-var CRn:u8
        let s_4091_0: u8 = fn_state.CRn;
        // D s_4091_1: cast zx s_4091_0 -> bv
        let s_4091_1: Bits = Bits::new(s_4091_0 as u128, 4u16);
        // C s_4091_2: const #8u : u8
        let s_4091_2: u8 = 8;
        // C s_4091_3: cast zx s_4091_2 -> bv
        let s_4091_3: Bits = Bits::new(s_4091_2 as u128, 4u16);
        // D s_4091_4: cmp-eq s_4091_1 s_4091_3
        let s_4091_4: bool = ((s_4091_1) == (s_4091_3));
        // D s_4091_5: write-var gs#135788 <= s_4091_4
        fn_state.gs_135788 = s_4091_4;
        // N s_4091_6: jump b2945
        return block_2945(state, tracer, fn_state);
    }
    fn block_4092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4092_0: read-var el:u8
        let s_4092_0: u8 = fn_state.el;
        // D s_4092_1: read-var coproc:u8
        let s_4092_1: u8 = fn_state.coproc;
        // D s_4092_2: read-var opc1:u8
        let s_4092_2: u8 = fn_state.opc1;
        // D s_4092_3: read-var CRn:u8
        let s_4092_3: u8 = fn_state.CRn;
        // D s_4092_4: read-var opc2:u8
        let s_4092_4: u8 = fn_state.opc2;
        // D s_4092_5: read-var CRm:u8
        let s_4092_5: u8 = fn_state.CRm;
        // D s_4092_6: read-var t:i
        let s_4092_6: i128 = fn_state.t;
        // D s_4092_7: call TLBIMVAA_SysRegWrite32_cb49c2a9a16e5968(s_4092_0, s_4092_1, s_4092_2, s_4092_3, s_4092_4, s_4092_5, s_4092_6)
        let s_4092_7: () = TLBIMVAA_SysRegWrite32_cb49c2a9a16e5968(
            state,
            tracer,
            s_4092_0,
            s_4092_1,
            s_4092_2,
            s_4092_3,
            s_4092_4,
            s_4092_5,
            s_4092_6,
        );
        // N s_4092_8: return
        return;
    }
    fn block_4093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4093_0: read-var opc2:u8
        let s_4093_0: u8 = fn_state.opc2;
        // D s_4093_1: cast zx s_4093_0 -> bv
        let s_4093_1: Bits = Bits::new(s_4093_0 as u128, 3u16);
        // C s_4093_2: const #3u : u8
        let s_4093_2: u8 = 3;
        // C s_4093_3: cast zx s_4093_2 -> bv
        let s_4093_3: Bits = Bits::new(s_4093_2 as u128, 3u16);
        // D s_4093_4: cmp-eq s_4093_1 s_4093_3
        let s_4093_4: bool = ((s_4093_1) == (s_4093_3));
        // D s_4093_5: write-var gs#135787 <= s_4093_4
        fn_state.gs_135787 = s_4093_4;
        // N s_4093_6: jump b2942
        return block_2942(state, tracer, fn_state);
    }
    fn block_4094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4094_0: read-var opc1:u8
        let s_4094_0: u8 = fn_state.opc1;
        // D s_4094_1: cast zx s_4094_0 -> bv
        let s_4094_1: Bits = Bits::new(s_4094_0 as u128, 3u16);
        // C s_4094_2: const #0u : u8
        let s_4094_2: u8 = 0;
        // C s_4094_3: cast zx s_4094_2 -> bv
        let s_4094_3: Bits = Bits::new(s_4094_2 as u128, 3u16);
        // D s_4094_4: cmp-eq s_4094_1 s_4094_3
        let s_4094_4: bool = ((s_4094_1) == (s_4094_3));
        // D s_4094_5: write-var gs#135786 <= s_4094_4
        fn_state.gs_135786 = s_4094_4;
        // N s_4094_6: jump b2940
        return block_2940(state, tracer, fn_state);
    }
    fn block_4095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4095_0: read-var coproc:u8
        let s_4095_0: u8 = fn_state.coproc;
        // D s_4095_1: cast zx s_4095_0 -> bv
        let s_4095_1: Bits = Bits::new(s_4095_0 as u128, 4u16);
        // C s_4095_2: const #15u : u8
        let s_4095_2: u8 = 15;
        // C s_4095_3: cast zx s_4095_2 -> bv
        let s_4095_3: Bits = Bits::new(s_4095_2 as u128, 4u16);
        // D s_4095_4: cmp-eq s_4095_1 s_4095_3
        let s_4095_4: bool = ((s_4095_1) == (s_4095_3));
        // D s_4095_5: write-var gs#135785 <= s_4095_4
        fn_state.gs_135785 = s_4095_4;
        // N s_4095_6: jump b2938
        return block_2938(state, tracer, fn_state);
    }
    fn block_4096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4096_0: read-var CRn:u8
        let s_4096_0: u8 = fn_state.CRn;
        // D s_4096_1: cast zx s_4096_0 -> bv
        let s_4096_1: Bits = Bits::new(s_4096_0 as u128, 4u16);
        // C s_4096_2: const #8u : u8
        let s_4096_2: u8 = 8;
        // C s_4096_3: cast zx s_4096_2 -> bv
        let s_4096_3: Bits = Bits::new(s_4096_2 as u128, 4u16);
        // D s_4096_4: cmp-eq s_4096_1 s_4096_3
        let s_4096_4: bool = ((s_4096_1) == (s_4096_3));
        // D s_4096_5: write-var gs#135784 <= s_4096_4
        fn_state.gs_135784 = s_4096_4;
        // N s_4096_6: jump b2936
        return block_2936(state, tracer, fn_state);
    }
    fn block_4097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4097_0: read-var el:u8
        let s_4097_0: u8 = fn_state.el;
        // D s_4097_1: read-var coproc:u8
        let s_4097_1: u8 = fn_state.coproc;
        // D s_4097_2: read-var opc1:u8
        let s_4097_2: u8 = fn_state.opc1;
        // D s_4097_3: read-var CRn:u8
        let s_4097_3: u8 = fn_state.CRn;
        // D s_4097_4: read-var opc2:u8
        let s_4097_4: u8 = fn_state.opc2;
        // D s_4097_5: read-var CRm:u8
        let s_4097_5: u8 = fn_state.CRm;
        // D s_4097_6: read-var t:i
        let s_4097_6: i128 = fn_state.t;
        // D s_4097_7: call AMAIR1_SysRegWrite32_3836d7092d627787(s_4097_0, s_4097_1, s_4097_2, s_4097_3, s_4097_4, s_4097_5, s_4097_6)
        let s_4097_7: () = AMAIR1_SysRegWrite32_3836d7092d627787(
            state,
            tracer,
            s_4097_0,
            s_4097_1,
            s_4097_2,
            s_4097_3,
            s_4097_4,
            s_4097_5,
            s_4097_6,
        );
        // N s_4097_8: return
        return;
    }
    fn block_4098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4098_0: read-var opc2:u8
        let s_4098_0: u8 = fn_state.opc2;
        // D s_4098_1: cast zx s_4098_0 -> bv
        let s_4098_1: Bits = Bits::new(s_4098_0 as u128, 3u16);
        // C s_4098_2: const #1u : u8
        let s_4098_2: u8 = 1;
        // C s_4098_3: cast zx s_4098_2 -> bv
        let s_4098_3: Bits = Bits::new(s_4098_2 as u128, 3u16);
        // D s_4098_4: cmp-eq s_4098_1 s_4098_3
        let s_4098_4: bool = ((s_4098_1) == (s_4098_3));
        // D s_4098_5: write-var gs#135783 <= s_4098_4
        fn_state.gs_135783 = s_4098_4;
        // N s_4098_6: jump b2933
        return block_2933(state, tracer, fn_state);
    }
    fn block_4099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4099_0: read-var opc1:u8
        let s_4099_0: u8 = fn_state.opc1;
        // D s_4099_1: cast zx s_4099_0 -> bv
        let s_4099_1: Bits = Bits::new(s_4099_0 as u128, 3u16);
        // C s_4099_2: const #0u : u8
        let s_4099_2: u8 = 0;
        // C s_4099_3: cast zx s_4099_2 -> bv
        let s_4099_3: Bits = Bits::new(s_4099_2 as u128, 3u16);
        // D s_4099_4: cmp-eq s_4099_1 s_4099_3
        let s_4099_4: bool = ((s_4099_1) == (s_4099_3));
        // D s_4099_5: write-var gs#135782 <= s_4099_4
        fn_state.gs_135782 = s_4099_4;
        // N s_4099_6: jump b2931
        return block_2931(state, tracer, fn_state);
    }
    fn block_4100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4100_0: read-var coproc:u8
        let s_4100_0: u8 = fn_state.coproc;
        // D s_4100_1: cast zx s_4100_0 -> bv
        let s_4100_1: Bits = Bits::new(s_4100_0 as u128, 4u16);
        // C s_4100_2: const #15u : u8
        let s_4100_2: u8 = 15;
        // C s_4100_3: cast zx s_4100_2 -> bv
        let s_4100_3: Bits = Bits::new(s_4100_2 as u128, 4u16);
        // D s_4100_4: cmp-eq s_4100_1 s_4100_3
        let s_4100_4: bool = ((s_4100_1) == (s_4100_3));
        // D s_4100_5: write-var gs#135781 <= s_4100_4
        fn_state.gs_135781 = s_4100_4;
        // N s_4100_6: jump b2929
        return block_2929(state, tracer, fn_state);
    }
    fn block_4101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4101_0: read-var CRn:u8
        let s_4101_0: u8 = fn_state.CRn;
        // D s_4101_1: cast zx s_4101_0 -> bv
        let s_4101_1: Bits = Bits::new(s_4101_0 as u128, 4u16);
        // C s_4101_2: const #10u : u8
        let s_4101_2: u8 = 10;
        // C s_4101_3: cast zx s_4101_2 -> bv
        let s_4101_3: Bits = Bits::new(s_4101_2 as u128, 4u16);
        // D s_4101_4: cmp-eq s_4101_1 s_4101_3
        let s_4101_4: bool = ((s_4101_1) == (s_4101_3));
        // D s_4101_5: write-var gs#135780 <= s_4101_4
        fn_state.gs_135780 = s_4101_4;
        // N s_4101_6: jump b2927
        return block_2927(state, tracer, fn_state);
    }
    fn block_4102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4102_0: read-var el:u8
        let s_4102_0: u8 = fn_state.el;
        // D s_4102_1: read-var coproc:u8
        let s_4102_1: u8 = fn_state.coproc;
        // D s_4102_2: read-var opc1:u8
        let s_4102_2: u8 = fn_state.opc1;
        // D s_4102_3: read-var CRn:u8
        let s_4102_3: u8 = fn_state.CRn;
        // D s_4102_4: read-var opc2:u8
        let s_4102_4: u8 = fn_state.opc2;
        // D s_4102_5: read-var CRm:u8
        let s_4102_5: u8 = fn_state.CRm;
        // D s_4102_6: read-var t:i
        let s_4102_6: i128 = fn_state.t;
        // D s_4102_7: call DCCMVAU_SysRegWrite32_39870f723165ce38(s_4102_0, s_4102_1, s_4102_2, s_4102_3, s_4102_4, s_4102_5, s_4102_6)
        let s_4102_7: () = DCCMVAU_SysRegWrite32_39870f723165ce38(
            state,
            tracer,
            s_4102_0,
            s_4102_1,
            s_4102_2,
            s_4102_3,
            s_4102_4,
            s_4102_5,
            s_4102_6,
        );
        // N s_4102_8: return
        return;
    }
    fn block_4103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4103_0: read-var opc2:u8
        let s_4103_0: u8 = fn_state.opc2;
        // D s_4103_1: cast zx s_4103_0 -> bv
        let s_4103_1: Bits = Bits::new(s_4103_0 as u128, 3u16);
        // C s_4103_2: const #1u : u8
        let s_4103_2: u8 = 1;
        // C s_4103_3: cast zx s_4103_2 -> bv
        let s_4103_3: Bits = Bits::new(s_4103_2 as u128, 3u16);
        // D s_4103_4: cmp-eq s_4103_1 s_4103_3
        let s_4103_4: bool = ((s_4103_1) == (s_4103_3));
        // D s_4103_5: write-var gs#135779 <= s_4103_4
        fn_state.gs_135779 = s_4103_4;
        // N s_4103_6: jump b2924
        return block_2924(state, tracer, fn_state);
    }
    fn block_4104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4104_0: read-var opc1:u8
        let s_4104_0: u8 = fn_state.opc1;
        // D s_4104_1: cast zx s_4104_0 -> bv
        let s_4104_1: Bits = Bits::new(s_4104_0 as u128, 3u16);
        // C s_4104_2: const #0u : u8
        let s_4104_2: u8 = 0;
        // C s_4104_3: cast zx s_4104_2 -> bv
        let s_4104_3: Bits = Bits::new(s_4104_2 as u128, 3u16);
        // D s_4104_4: cmp-eq s_4104_1 s_4104_3
        let s_4104_4: bool = ((s_4104_1) == (s_4104_3));
        // D s_4104_5: write-var gs#135778 <= s_4104_4
        fn_state.gs_135778 = s_4104_4;
        // N s_4104_6: jump b2922
        return block_2922(state, tracer, fn_state);
    }
    fn block_4105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4105_0: read-var coproc:u8
        let s_4105_0: u8 = fn_state.coproc;
        // D s_4105_1: cast zx s_4105_0 -> bv
        let s_4105_1: Bits = Bits::new(s_4105_0 as u128, 4u16);
        // C s_4105_2: const #15u : u8
        let s_4105_2: u8 = 15;
        // C s_4105_3: cast zx s_4105_2 -> bv
        let s_4105_3: Bits = Bits::new(s_4105_2 as u128, 4u16);
        // D s_4105_4: cmp-eq s_4105_1 s_4105_3
        let s_4105_4: bool = ((s_4105_1) == (s_4105_3));
        // D s_4105_5: write-var gs#135777 <= s_4105_4
        fn_state.gs_135777 = s_4105_4;
        // N s_4105_6: jump b2920
        return block_2920(state, tracer, fn_state);
    }
    fn block_4106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4106_0: read-var CRn:u8
        let s_4106_0: u8 = fn_state.CRn;
        // D s_4106_1: cast zx s_4106_0 -> bv
        let s_4106_1: Bits = Bits::new(s_4106_0 as u128, 4u16);
        // C s_4106_2: const #7u : u8
        let s_4106_2: u8 = 7;
        // C s_4106_3: cast zx s_4106_2 -> bv
        let s_4106_3: Bits = Bits::new(s_4106_2 as u128, 4u16);
        // D s_4106_4: cmp-eq s_4106_1 s_4106_3
        let s_4106_4: bool = ((s_4106_1) == (s_4106_3));
        // D s_4106_5: write-var gs#135776 <= s_4106_4
        fn_state.gs_135776 = s_4106_4;
        // N s_4106_6: jump b2918
        return block_2918(state, tracer, fn_state);
    }
    fn block_4107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4107_0: read-var el:u8
        let s_4107_0: u8 = fn_state.el;
        // D s_4107_1: read-var coproc:u8
        let s_4107_1: u8 = fn_state.coproc;
        // D s_4107_2: read-var opc1:u8
        let s_4107_2: u8 = fn_state.opc1;
        // D s_4107_3: read-var CRn:u8
        let s_4107_3: u8 = fn_state.CRn;
        // D s_4107_4: read-var opc2:u8
        let s_4107_4: u8 = fn_state.opc2;
        // D s_4107_5: read-var CRm:u8
        let s_4107_5: u8 = fn_state.CRm;
        // D s_4107_6: read-var t:i
        let s_4107_6: i128 = fn_state.t;
        // D s_4107_7: call CNTHP_CTL_SysRegWrite32_ed680b861de2ac5b(s_4107_0, s_4107_1, s_4107_2, s_4107_3, s_4107_4, s_4107_5, s_4107_6)
        let s_4107_7: () = CNTHP_CTL_SysRegWrite32_ed680b861de2ac5b(
            state,
            tracer,
            s_4107_0,
            s_4107_1,
            s_4107_2,
            s_4107_3,
            s_4107_4,
            s_4107_5,
            s_4107_6,
        );
        // N s_4107_8: return
        return;
    }
    fn block_4108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4108_0: read-var opc2:u8
        let s_4108_0: u8 = fn_state.opc2;
        // D s_4108_1: cast zx s_4108_0 -> bv
        let s_4108_1: Bits = Bits::new(s_4108_0 as u128, 3u16);
        // C s_4108_2: const #1u : u8
        let s_4108_2: u8 = 1;
        // C s_4108_3: cast zx s_4108_2 -> bv
        let s_4108_3: Bits = Bits::new(s_4108_2 as u128, 3u16);
        // D s_4108_4: cmp-eq s_4108_1 s_4108_3
        let s_4108_4: bool = ((s_4108_1) == (s_4108_3));
        // D s_4108_5: write-var gs#135775 <= s_4108_4
        fn_state.gs_135775 = s_4108_4;
        // N s_4108_6: jump b2915
        return block_2915(state, tracer, fn_state);
    }
    fn block_4109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4109_0: read-var opc1:u8
        let s_4109_0: u8 = fn_state.opc1;
        // D s_4109_1: cast zx s_4109_0 -> bv
        let s_4109_1: Bits = Bits::new(s_4109_0 as u128, 3u16);
        // C s_4109_2: const #4u : u8
        let s_4109_2: u8 = 4;
        // C s_4109_3: cast zx s_4109_2 -> bv
        let s_4109_3: Bits = Bits::new(s_4109_2 as u128, 3u16);
        // D s_4109_4: cmp-eq s_4109_1 s_4109_3
        let s_4109_4: bool = ((s_4109_1) == (s_4109_3));
        // D s_4109_5: write-var gs#135774 <= s_4109_4
        fn_state.gs_135774 = s_4109_4;
        // N s_4109_6: jump b2913
        return block_2913(state, tracer, fn_state);
    }
    fn block_4110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4110_0: read-var coproc:u8
        let s_4110_0: u8 = fn_state.coproc;
        // D s_4110_1: cast zx s_4110_0 -> bv
        let s_4110_1: Bits = Bits::new(s_4110_0 as u128, 4u16);
        // C s_4110_2: const #15u : u8
        let s_4110_2: u8 = 15;
        // C s_4110_3: cast zx s_4110_2 -> bv
        let s_4110_3: Bits = Bits::new(s_4110_2 as u128, 4u16);
        // D s_4110_4: cmp-eq s_4110_1 s_4110_3
        let s_4110_4: bool = ((s_4110_1) == (s_4110_3));
        // D s_4110_5: write-var gs#135773 <= s_4110_4
        fn_state.gs_135773 = s_4110_4;
        // N s_4110_6: jump b2911
        return block_2911(state, tracer, fn_state);
    }
    fn block_4111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4111_0: read-var CRn:u8
        let s_4111_0: u8 = fn_state.CRn;
        // D s_4111_1: cast zx s_4111_0 -> bv
        let s_4111_1: Bits = Bits::new(s_4111_0 as u128, 4u16);
        // C s_4111_2: const #14u : u8
        let s_4111_2: u8 = 14;
        // C s_4111_3: cast zx s_4111_2 -> bv
        let s_4111_3: Bits = Bits::new(s_4111_2 as u128, 4u16);
        // D s_4111_4: cmp-eq s_4111_1 s_4111_3
        let s_4111_4: bool = ((s_4111_1) == (s_4111_3));
        // D s_4111_5: write-var gs#135772 <= s_4111_4
        fn_state.gs_135772 = s_4111_4;
        // N s_4111_6: jump b2909
        return block_2909(state, tracer, fn_state);
    }
    fn block_4112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4112_0: read-var el:u8
        let s_4112_0: u8 = fn_state.el;
        // D s_4112_1: read-var coproc:u8
        let s_4112_1: u8 = fn_state.coproc;
        // D s_4112_2: read-var opc1:u8
        let s_4112_2: u8 = fn_state.opc1;
        // D s_4112_3: read-var CRn:u8
        let s_4112_3: u8 = fn_state.CRn;
        // D s_4112_4: read-var opc2:u8
        let s_4112_4: u8 = fn_state.opc2;
        // D s_4112_5: read-var CRm:u8
        let s_4112_5: u8 = fn_state.CRm;
        // D s_4112_6: read-var t:i
        let s_4112_6: i128 = fn_state.t;
        // D s_4112_7: call TRFCR_SysRegWrite32_e7012a38712cc44a(s_4112_0, s_4112_1, s_4112_2, s_4112_3, s_4112_4, s_4112_5, s_4112_6)
        let s_4112_7: () = TRFCR_SysRegWrite32_e7012a38712cc44a(
            state,
            tracer,
            s_4112_0,
            s_4112_1,
            s_4112_2,
            s_4112_3,
            s_4112_4,
            s_4112_5,
            s_4112_6,
        );
        // N s_4112_8: return
        return;
    }
    fn block_4113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4113_0: read-var opc2:u8
        let s_4113_0: u8 = fn_state.opc2;
        // D s_4113_1: cast zx s_4113_0 -> bv
        let s_4113_1: Bits = Bits::new(s_4113_0 as u128, 3u16);
        // C s_4113_2: const #1u : u8
        let s_4113_2: u8 = 1;
        // C s_4113_3: cast zx s_4113_2 -> bv
        let s_4113_3: Bits = Bits::new(s_4113_2 as u128, 3u16);
        // D s_4113_4: cmp-eq s_4113_1 s_4113_3
        let s_4113_4: bool = ((s_4113_1) == (s_4113_3));
        // D s_4113_5: write-var gs#135771 <= s_4113_4
        fn_state.gs_135771 = s_4113_4;
        // N s_4113_6: jump b2906
        return block_2906(state, tracer, fn_state);
    }
    fn block_4114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4114_0: read-var opc1:u8
        let s_4114_0: u8 = fn_state.opc1;
        // D s_4114_1: cast zx s_4114_0 -> bv
        let s_4114_1: Bits = Bits::new(s_4114_0 as u128, 3u16);
        // C s_4114_2: const #0u : u8
        let s_4114_2: u8 = 0;
        // C s_4114_3: cast zx s_4114_2 -> bv
        let s_4114_3: Bits = Bits::new(s_4114_2 as u128, 3u16);
        // D s_4114_4: cmp-eq s_4114_1 s_4114_3
        let s_4114_4: bool = ((s_4114_1) == (s_4114_3));
        // D s_4114_5: write-var gs#135770 <= s_4114_4
        fn_state.gs_135770 = s_4114_4;
        // N s_4114_6: jump b2904
        return block_2904(state, tracer, fn_state);
    }
    fn block_4115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4115_0: read-var coproc:u8
        let s_4115_0: u8 = fn_state.coproc;
        // D s_4115_1: cast zx s_4115_0 -> bv
        let s_4115_1: Bits = Bits::new(s_4115_0 as u128, 4u16);
        // C s_4115_2: const #15u : u8
        let s_4115_2: u8 = 15;
        // C s_4115_3: cast zx s_4115_2 -> bv
        let s_4115_3: Bits = Bits::new(s_4115_2 as u128, 4u16);
        // D s_4115_4: cmp-eq s_4115_1 s_4115_3
        let s_4115_4: bool = ((s_4115_1) == (s_4115_3));
        // D s_4115_5: write-var gs#135769 <= s_4115_4
        fn_state.gs_135769 = s_4115_4;
        // N s_4115_6: jump b2902
        return block_2902(state, tracer, fn_state);
    }
    fn block_4116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4116_0: read-var CRn:u8
        let s_4116_0: u8 = fn_state.CRn;
        // D s_4116_1: cast zx s_4116_0 -> bv
        let s_4116_1: Bits = Bits::new(s_4116_0 as u128, 4u16);
        // C s_4116_2: const #1u : u8
        let s_4116_2: u8 = 1;
        // C s_4116_3: cast zx s_4116_2 -> bv
        let s_4116_3: Bits = Bits::new(s_4116_2 as u128, 4u16);
        // D s_4116_4: cmp-eq s_4116_1 s_4116_3
        let s_4116_4: bool = ((s_4116_1) == (s_4116_3));
        // D s_4116_5: write-var gs#135768 <= s_4116_4
        fn_state.gs_135768 = s_4116_4;
        // N s_4116_6: jump b2900
        return block_2900(state, tracer, fn_state);
    }
    fn block_4117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4117_0: read-var el:u8
        let s_4117_0: u8 = fn_state.el;
        // D s_4117_1: read-var coproc:u8
        let s_4117_1: u8 = fn_state.coproc;
        // D s_4117_2: read-var opc1:u8
        let s_4117_2: u8 = fn_state.opc1;
        // D s_4117_3: read-var CRn:u8
        let s_4117_3: u8 = fn_state.CRn;
        // D s_4117_4: read-var opc2:u8
        let s_4117_4: u8 = fn_state.opc2;
        // D s_4117_5: read-var CRm:u8
        let s_4117_5: u8 = fn_state.CRm;
        // D s_4117_6: read-var t:i
        let s_4117_6: i128 = fn_state.t;
        // D s_4117_7: call DBGDTRTXint_SysRegWrite32_bf0ab983b07d829c(s_4117_0, s_4117_1, s_4117_2, s_4117_3, s_4117_4, s_4117_5, s_4117_6)
        let s_4117_7: () = DBGDTRTXint_SysRegWrite32_bf0ab983b07d829c(
            state,
            tracer,
            s_4117_0,
            s_4117_1,
            s_4117_2,
            s_4117_3,
            s_4117_4,
            s_4117_5,
            s_4117_6,
        );
        // N s_4117_8: return
        return;
    }
    fn block_4118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4118_0: read-var opc2:u8
        let s_4118_0: u8 = fn_state.opc2;
        // D s_4118_1: cast zx s_4118_0 -> bv
        let s_4118_1: Bits = Bits::new(s_4118_0 as u128, 3u16);
        // C s_4118_2: const #0u : u8
        let s_4118_2: u8 = 0;
        // C s_4118_3: cast zx s_4118_2 -> bv
        let s_4118_3: Bits = Bits::new(s_4118_2 as u128, 3u16);
        // D s_4118_4: cmp-eq s_4118_1 s_4118_3
        let s_4118_4: bool = ((s_4118_1) == (s_4118_3));
        // D s_4118_5: write-var gs#135767 <= s_4118_4
        fn_state.gs_135767 = s_4118_4;
        // N s_4118_6: jump b2897
        return block_2897(state, tracer, fn_state);
    }
    fn block_4119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4119_0: read-var opc1:u8
        let s_4119_0: u8 = fn_state.opc1;
        // D s_4119_1: cast zx s_4119_0 -> bv
        let s_4119_1: Bits = Bits::new(s_4119_0 as u128, 3u16);
        // C s_4119_2: const #0u : u8
        let s_4119_2: u8 = 0;
        // C s_4119_3: cast zx s_4119_2 -> bv
        let s_4119_3: Bits = Bits::new(s_4119_2 as u128, 3u16);
        // D s_4119_4: cmp-eq s_4119_1 s_4119_3
        let s_4119_4: bool = ((s_4119_1) == (s_4119_3));
        // D s_4119_5: write-var gs#135766 <= s_4119_4
        fn_state.gs_135766 = s_4119_4;
        // N s_4119_6: jump b2895
        return block_2895(state, tracer, fn_state);
    }
    fn block_4120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4120_0: read-var coproc:u8
        let s_4120_0: u8 = fn_state.coproc;
        // D s_4120_1: cast zx s_4120_0 -> bv
        let s_4120_1: Bits = Bits::new(s_4120_0 as u128, 4u16);
        // C s_4120_2: const #14u : u8
        let s_4120_2: u8 = 14;
        // C s_4120_3: cast zx s_4120_2 -> bv
        let s_4120_3: Bits = Bits::new(s_4120_2 as u128, 4u16);
        // D s_4120_4: cmp-eq s_4120_1 s_4120_3
        let s_4120_4: bool = ((s_4120_1) == (s_4120_3));
        // D s_4120_5: write-var gs#135765 <= s_4120_4
        fn_state.gs_135765 = s_4120_4;
        // N s_4120_6: jump b2893
        return block_2893(state, tracer, fn_state);
    }
    fn block_4121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4121_0: read-var CRn:u8
        let s_4121_0: u8 = fn_state.CRn;
        // D s_4121_1: cast zx s_4121_0 -> bv
        let s_4121_1: Bits = Bits::new(s_4121_0 as u128, 4u16);
        // C s_4121_2: const #0u : u8
        let s_4121_2: u8 = 0;
        // C s_4121_3: cast zx s_4121_2 -> bv
        let s_4121_3: Bits = Bits::new(s_4121_2 as u128, 4u16);
        // D s_4121_4: cmp-eq s_4121_1 s_4121_3
        let s_4121_4: bool = ((s_4121_1) == (s_4121_3));
        // D s_4121_5: write-var gs#135764 <= s_4121_4
        fn_state.gs_135764 = s_4121_4;
        // N s_4121_6: jump b2891
        return block_2891(state, tracer, fn_state);
    }
    fn block_4122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4122_0: read-var el:u8
        let s_4122_0: u8 = fn_state.el;
        // D s_4122_1: read-var coproc:u8
        let s_4122_1: u8 = fn_state.coproc;
        // D s_4122_2: read-var opc1:u8
        let s_4122_2: u8 = fn_state.opc1;
        // D s_4122_3: read-var CRn:u8
        let s_4122_3: u8 = fn_state.CRn;
        // D s_4122_4: read-var opc2:u8
        let s_4122_4: u8 = fn_state.opc2;
        // D s_4122_5: read-var CRm:u8
        let s_4122_5: u8 = fn_state.CRm;
        // D s_4122_6: read-var t:i
        let s_4122_6: i128 = fn_state.t;
        // D s_4122_7: call ATS1CUW_SysRegWrite32_eb4fd0807cfcfcfb(s_4122_0, s_4122_1, s_4122_2, s_4122_3, s_4122_4, s_4122_5, s_4122_6)
        let s_4122_7: () = ATS1CUW_SysRegWrite32_eb4fd0807cfcfcfb(
            state,
            tracer,
            s_4122_0,
            s_4122_1,
            s_4122_2,
            s_4122_3,
            s_4122_4,
            s_4122_5,
            s_4122_6,
        );
        // N s_4122_8: return
        return;
    }
    fn block_4123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4123_0: read-var opc2:u8
        let s_4123_0: u8 = fn_state.opc2;
        // D s_4123_1: cast zx s_4123_0 -> bv
        let s_4123_1: Bits = Bits::new(s_4123_0 as u128, 3u16);
        // C s_4123_2: const #3u : u8
        let s_4123_2: u8 = 3;
        // C s_4123_3: cast zx s_4123_2 -> bv
        let s_4123_3: Bits = Bits::new(s_4123_2 as u128, 3u16);
        // D s_4123_4: cmp-eq s_4123_1 s_4123_3
        let s_4123_4: bool = ((s_4123_1) == (s_4123_3));
        // D s_4123_5: write-var gs#135763 <= s_4123_4
        fn_state.gs_135763 = s_4123_4;
        // N s_4123_6: jump b2888
        return block_2888(state, tracer, fn_state);
    }
    fn block_4124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4124_0: read-var opc1:u8
        let s_4124_0: u8 = fn_state.opc1;
        // D s_4124_1: cast zx s_4124_0 -> bv
        let s_4124_1: Bits = Bits::new(s_4124_0 as u128, 3u16);
        // C s_4124_2: const #0u : u8
        let s_4124_2: u8 = 0;
        // C s_4124_3: cast zx s_4124_2 -> bv
        let s_4124_3: Bits = Bits::new(s_4124_2 as u128, 3u16);
        // D s_4124_4: cmp-eq s_4124_1 s_4124_3
        let s_4124_4: bool = ((s_4124_1) == (s_4124_3));
        // D s_4124_5: write-var gs#135762 <= s_4124_4
        fn_state.gs_135762 = s_4124_4;
        // N s_4124_6: jump b2886
        return block_2886(state, tracer, fn_state);
    }
    fn block_4125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4125_0: read-var coproc:u8
        let s_4125_0: u8 = fn_state.coproc;
        // D s_4125_1: cast zx s_4125_0 -> bv
        let s_4125_1: Bits = Bits::new(s_4125_0 as u128, 4u16);
        // C s_4125_2: const #15u : u8
        let s_4125_2: u8 = 15;
        // C s_4125_3: cast zx s_4125_2 -> bv
        let s_4125_3: Bits = Bits::new(s_4125_2 as u128, 4u16);
        // D s_4125_4: cmp-eq s_4125_1 s_4125_3
        let s_4125_4: bool = ((s_4125_1) == (s_4125_3));
        // D s_4125_5: write-var gs#135761 <= s_4125_4
        fn_state.gs_135761 = s_4125_4;
        // N s_4125_6: jump b2884
        return block_2884(state, tracer, fn_state);
    }
    fn block_4126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4126_0: read-var CRn:u8
        let s_4126_0: u8 = fn_state.CRn;
        // D s_4126_1: cast zx s_4126_0 -> bv
        let s_4126_1: Bits = Bits::new(s_4126_0 as u128, 4u16);
        // C s_4126_2: const #7u : u8
        let s_4126_2: u8 = 7;
        // C s_4126_3: cast zx s_4126_2 -> bv
        let s_4126_3: Bits = Bits::new(s_4126_2 as u128, 4u16);
        // D s_4126_4: cmp-eq s_4126_1 s_4126_3
        let s_4126_4: bool = ((s_4126_1) == (s_4126_3));
        // D s_4126_5: write-var gs#135760 <= s_4126_4
        fn_state.gs_135760 = s_4126_4;
        // N s_4126_6: jump b2882
        return block_2882(state, tracer, fn_state);
    }
    fn block_4127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4127_0: read-var el:u8
        let s_4127_0: u8 = fn_state.el;
        // D s_4127_1: read-var coproc:u8
        let s_4127_1: u8 = fn_state.coproc;
        // D s_4127_2: read-var opc1:u8
        let s_4127_2: u8 = fn_state.opc1;
        // D s_4127_3: read-var CRn:u8
        let s_4127_3: u8 = fn_state.CRn;
        // D s_4127_4: read-var opc2:u8
        let s_4127_4: u8 = fn_state.opc2;
        // D s_4127_5: read-var CRm:u8
        let s_4127_5: u8 = fn_state.CRm;
        // D s_4127_6: read-var t:i
        let s_4127_6: i128 = fn_state.t;
        // D s_4127_7: call PMCNTENCLR_SysRegWrite32_b4dfc0dbab472345(s_4127_0, s_4127_1, s_4127_2, s_4127_3, s_4127_4, s_4127_5, s_4127_6)
        let s_4127_7: () = PMCNTENCLR_SysRegWrite32_b4dfc0dbab472345(
            state,
            tracer,
            s_4127_0,
            s_4127_1,
            s_4127_2,
            s_4127_3,
            s_4127_4,
            s_4127_5,
            s_4127_6,
        );
        // N s_4127_8: return
        return;
    }
    fn block_4128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4128_0: read-var opc2:u8
        let s_4128_0: u8 = fn_state.opc2;
        // D s_4128_1: cast zx s_4128_0 -> bv
        let s_4128_1: Bits = Bits::new(s_4128_0 as u128, 3u16);
        // C s_4128_2: const #2u : u8
        let s_4128_2: u8 = 2;
        // C s_4128_3: cast zx s_4128_2 -> bv
        let s_4128_3: Bits = Bits::new(s_4128_2 as u128, 3u16);
        // D s_4128_4: cmp-eq s_4128_1 s_4128_3
        let s_4128_4: bool = ((s_4128_1) == (s_4128_3));
        // D s_4128_5: write-var gs#135759 <= s_4128_4
        fn_state.gs_135759 = s_4128_4;
        // N s_4128_6: jump b2879
        return block_2879(state, tracer, fn_state);
    }
    fn block_4129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4129_0: read-var opc1:u8
        let s_4129_0: u8 = fn_state.opc1;
        // D s_4129_1: cast zx s_4129_0 -> bv
        let s_4129_1: Bits = Bits::new(s_4129_0 as u128, 3u16);
        // C s_4129_2: const #0u : u8
        let s_4129_2: u8 = 0;
        // C s_4129_3: cast zx s_4129_2 -> bv
        let s_4129_3: Bits = Bits::new(s_4129_2 as u128, 3u16);
        // D s_4129_4: cmp-eq s_4129_1 s_4129_3
        let s_4129_4: bool = ((s_4129_1) == (s_4129_3));
        // D s_4129_5: write-var gs#135758 <= s_4129_4
        fn_state.gs_135758 = s_4129_4;
        // N s_4129_6: jump b2877
        return block_2877(state, tracer, fn_state);
    }
    fn block_4130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4130_0: read-var coproc:u8
        let s_4130_0: u8 = fn_state.coproc;
        // D s_4130_1: cast zx s_4130_0 -> bv
        let s_4130_1: Bits = Bits::new(s_4130_0 as u128, 4u16);
        // C s_4130_2: const #15u : u8
        let s_4130_2: u8 = 15;
        // C s_4130_3: cast zx s_4130_2 -> bv
        let s_4130_3: Bits = Bits::new(s_4130_2 as u128, 4u16);
        // D s_4130_4: cmp-eq s_4130_1 s_4130_3
        let s_4130_4: bool = ((s_4130_1) == (s_4130_3));
        // D s_4130_5: write-var gs#135757 <= s_4130_4
        fn_state.gs_135757 = s_4130_4;
        // N s_4130_6: jump b2875
        return block_2875(state, tracer, fn_state);
    }
    fn block_4131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4131_0: read-var CRn:u8
        let s_4131_0: u8 = fn_state.CRn;
        // D s_4131_1: cast zx s_4131_0 -> bv
        let s_4131_1: Bits = Bits::new(s_4131_0 as u128, 4u16);
        // C s_4131_2: const #9u : u8
        let s_4131_2: u8 = 9;
        // C s_4131_3: cast zx s_4131_2 -> bv
        let s_4131_3: Bits = Bits::new(s_4131_2 as u128, 4u16);
        // D s_4131_4: cmp-eq s_4131_1 s_4131_3
        let s_4131_4: bool = ((s_4131_1) == (s_4131_3));
        // D s_4131_5: write-var gs#135756 <= s_4131_4
        fn_state.gs_135756 = s_4131_4;
        // N s_4131_6: jump b2873
        return block_2873(state, tracer, fn_state);
    }
    fn block_4132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4132_0: read-var el:u8
        let s_4132_0: u8 = fn_state.el;
        // D s_4132_1: read-var coproc:u8
        let s_4132_1: u8 = fn_state.coproc;
        // D s_4132_2: read-var opc1:u8
        let s_4132_2: u8 = fn_state.opc1;
        // D s_4132_3: read-var CRn:u8
        let s_4132_3: u8 = fn_state.CRn;
        // D s_4132_4: read-var opc2:u8
        let s_4132_4: u8 = fn_state.opc2;
        // D s_4132_5: read-var CRm:u8
        let s_4132_5: u8 = fn_state.CRm;
        // D s_4132_6: read-var t:i
        let s_4132_6: i128 = fn_state.t;
        // D s_4132_7: call DFAR_SysRegWrite32_27a6ae6fd1c0c709(s_4132_0, s_4132_1, s_4132_2, s_4132_3, s_4132_4, s_4132_5, s_4132_6)
        let s_4132_7: () = DFAR_SysRegWrite32_27a6ae6fd1c0c709(
            state,
            tracer,
            s_4132_0,
            s_4132_1,
            s_4132_2,
            s_4132_3,
            s_4132_4,
            s_4132_5,
            s_4132_6,
        );
        // N s_4132_8: return
        return;
    }
    fn block_4133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4133_0: read-var opc2:u8
        let s_4133_0: u8 = fn_state.opc2;
        // D s_4133_1: cast zx s_4133_0 -> bv
        let s_4133_1: Bits = Bits::new(s_4133_0 as u128, 3u16);
        // C s_4133_2: const #0u : u8
        let s_4133_2: u8 = 0;
        // C s_4133_3: cast zx s_4133_2 -> bv
        let s_4133_3: Bits = Bits::new(s_4133_2 as u128, 3u16);
        // D s_4133_4: cmp-eq s_4133_1 s_4133_3
        let s_4133_4: bool = ((s_4133_1) == (s_4133_3));
        // D s_4133_5: write-var gs#135755 <= s_4133_4
        fn_state.gs_135755 = s_4133_4;
        // N s_4133_6: jump b2870
        return block_2870(state, tracer, fn_state);
    }
    fn block_4134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4134_0: read-var opc1:u8
        let s_4134_0: u8 = fn_state.opc1;
        // D s_4134_1: cast zx s_4134_0 -> bv
        let s_4134_1: Bits = Bits::new(s_4134_0 as u128, 3u16);
        // C s_4134_2: const #0u : u8
        let s_4134_2: u8 = 0;
        // C s_4134_3: cast zx s_4134_2 -> bv
        let s_4134_3: Bits = Bits::new(s_4134_2 as u128, 3u16);
        // D s_4134_4: cmp-eq s_4134_1 s_4134_3
        let s_4134_4: bool = ((s_4134_1) == (s_4134_3));
        // D s_4134_5: write-var gs#135754 <= s_4134_4
        fn_state.gs_135754 = s_4134_4;
        // N s_4134_6: jump b2868
        return block_2868(state, tracer, fn_state);
    }
    fn block_4135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4135_0: read-var coproc:u8
        let s_4135_0: u8 = fn_state.coproc;
        // D s_4135_1: cast zx s_4135_0 -> bv
        let s_4135_1: Bits = Bits::new(s_4135_0 as u128, 4u16);
        // C s_4135_2: const #15u : u8
        let s_4135_2: u8 = 15;
        // C s_4135_3: cast zx s_4135_2 -> bv
        let s_4135_3: Bits = Bits::new(s_4135_2 as u128, 4u16);
        // D s_4135_4: cmp-eq s_4135_1 s_4135_3
        let s_4135_4: bool = ((s_4135_1) == (s_4135_3));
        // D s_4135_5: write-var gs#135753 <= s_4135_4
        fn_state.gs_135753 = s_4135_4;
        // N s_4135_6: jump b2866
        return block_2866(state, tracer, fn_state);
    }
    fn block_4136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4136_0: read-var CRn:u8
        let s_4136_0: u8 = fn_state.CRn;
        // D s_4136_1: cast zx s_4136_0 -> bv
        let s_4136_1: Bits = Bits::new(s_4136_0 as u128, 4u16);
        // C s_4136_2: const #6u : u8
        let s_4136_2: u8 = 6;
        // C s_4136_3: cast zx s_4136_2 -> bv
        let s_4136_3: Bits = Bits::new(s_4136_2 as u128, 4u16);
        // D s_4136_4: cmp-eq s_4136_1 s_4136_3
        let s_4136_4: bool = ((s_4136_1) == (s_4136_3));
        // D s_4136_5: write-var gs#135752 <= s_4136_4
        fn_state.gs_135752 = s_4136_4;
        // N s_4136_6: jump b2864
        return block_2864(state, tracer, fn_state);
    }
    fn block_4137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4137_0: read-var el:u8
        let s_4137_0: u8 = fn_state.el;
        // D s_4137_1: read-var coproc:u8
        let s_4137_1: u8 = fn_state.coproc;
        // D s_4137_2: read-var opc1:u8
        let s_4137_2: u8 = fn_state.opc1;
        // D s_4137_3: read-var CRn:u8
        let s_4137_3: u8 = fn_state.CRn;
        // D s_4137_4: read-var opc2:u8
        let s_4137_4: u8 = fn_state.opc2;
        // D s_4137_5: read-var CRm:u8
        let s_4137_5: u8 = fn_state.CRm;
        // D s_4137_6: read-var t:i
        let s_4137_6: i128 = fn_state.t;
        // D s_4137_7: call TLBIMVALIS_SysRegWrite32_ff59541f99afcbcf(s_4137_0, s_4137_1, s_4137_2, s_4137_3, s_4137_4, s_4137_5, s_4137_6)
        let s_4137_7: () = TLBIMVALIS_SysRegWrite32_ff59541f99afcbcf(
            state,
            tracer,
            s_4137_0,
            s_4137_1,
            s_4137_2,
            s_4137_3,
            s_4137_4,
            s_4137_5,
            s_4137_6,
        );
        // N s_4137_8: return
        return;
    }
    fn block_4138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4138_0: read-var opc2:u8
        let s_4138_0: u8 = fn_state.opc2;
        // D s_4138_1: cast zx s_4138_0 -> bv
        let s_4138_1: Bits = Bits::new(s_4138_0 as u128, 3u16);
        // C s_4138_2: const #5u : u8
        let s_4138_2: u8 = 5;
        // C s_4138_3: cast zx s_4138_2 -> bv
        let s_4138_3: Bits = Bits::new(s_4138_2 as u128, 3u16);
        // D s_4138_4: cmp-eq s_4138_1 s_4138_3
        let s_4138_4: bool = ((s_4138_1) == (s_4138_3));
        // D s_4138_5: write-var gs#135751 <= s_4138_4
        fn_state.gs_135751 = s_4138_4;
        // N s_4138_6: jump b2861
        return block_2861(state, tracer, fn_state);
    }
    fn block_4139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4139_0: read-var opc1:u8
        let s_4139_0: u8 = fn_state.opc1;
        // D s_4139_1: cast zx s_4139_0 -> bv
        let s_4139_1: Bits = Bits::new(s_4139_0 as u128, 3u16);
        // C s_4139_2: const #0u : u8
        let s_4139_2: u8 = 0;
        // C s_4139_3: cast zx s_4139_2 -> bv
        let s_4139_3: Bits = Bits::new(s_4139_2 as u128, 3u16);
        // D s_4139_4: cmp-eq s_4139_1 s_4139_3
        let s_4139_4: bool = ((s_4139_1) == (s_4139_3));
        // D s_4139_5: write-var gs#135750 <= s_4139_4
        fn_state.gs_135750 = s_4139_4;
        // N s_4139_6: jump b2859
        return block_2859(state, tracer, fn_state);
    }
    fn block_4140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4140_0: read-var coproc:u8
        let s_4140_0: u8 = fn_state.coproc;
        // D s_4140_1: cast zx s_4140_0 -> bv
        let s_4140_1: Bits = Bits::new(s_4140_0 as u128, 4u16);
        // C s_4140_2: const #15u : u8
        let s_4140_2: u8 = 15;
        // C s_4140_3: cast zx s_4140_2 -> bv
        let s_4140_3: Bits = Bits::new(s_4140_2 as u128, 4u16);
        // D s_4140_4: cmp-eq s_4140_1 s_4140_3
        let s_4140_4: bool = ((s_4140_1) == (s_4140_3));
        // D s_4140_5: write-var gs#135749 <= s_4140_4
        fn_state.gs_135749 = s_4140_4;
        // N s_4140_6: jump b2857
        return block_2857(state, tracer, fn_state);
    }
    fn block_4141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4141_0: read-var CRn:u8
        let s_4141_0: u8 = fn_state.CRn;
        // D s_4141_1: cast zx s_4141_0 -> bv
        let s_4141_1: Bits = Bits::new(s_4141_0 as u128, 4u16);
        // C s_4141_2: const #8u : u8
        let s_4141_2: u8 = 8;
        // C s_4141_3: cast zx s_4141_2 -> bv
        let s_4141_3: Bits = Bits::new(s_4141_2 as u128, 4u16);
        // D s_4141_4: cmp-eq s_4141_1 s_4141_3
        let s_4141_4: bool = ((s_4141_1) == (s_4141_3));
        // D s_4141_5: write-var gs#135748 <= s_4141_4
        fn_state.gs_135748 = s_4141_4;
        // N s_4141_6: jump b2855
        return block_2855(state, tracer, fn_state);
    }
    fn block_4142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4142_0: read-var el:u8
        let s_4142_0: u8 = fn_state.el;
        // D s_4142_1: read-var coproc:u8
        let s_4142_1: u8 = fn_state.coproc;
        // D s_4142_2: read-var opc1:u8
        let s_4142_2: u8 = fn_state.opc1;
        // D s_4142_3: read-var CRn:u8
        let s_4142_3: u8 = fn_state.CRn;
        // D s_4142_4: read-var opc2:u8
        let s_4142_4: u8 = fn_state.opc2;
        // D s_4142_5: read-var CRm:u8
        let s_4142_5: u8 = fn_state.CRm;
        // D s_4142_6: read-var t:i
        let s_4142_6: i128 = fn_state.t;
        // D s_4142_7: call DCCIMVAC_SysRegWrite32_9ec7bae67091217f(s_4142_0, s_4142_1, s_4142_2, s_4142_3, s_4142_4, s_4142_5, s_4142_6)
        let s_4142_7: () = DCCIMVAC_SysRegWrite32_9ec7bae67091217f(
            state,
            tracer,
            s_4142_0,
            s_4142_1,
            s_4142_2,
            s_4142_3,
            s_4142_4,
            s_4142_5,
            s_4142_6,
        );
        // N s_4142_8: return
        return;
    }
    fn block_4143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4143_0: read-var opc2:u8
        let s_4143_0: u8 = fn_state.opc2;
        // D s_4143_1: cast zx s_4143_0 -> bv
        let s_4143_1: Bits = Bits::new(s_4143_0 as u128, 3u16);
        // C s_4143_2: const #1u : u8
        let s_4143_2: u8 = 1;
        // C s_4143_3: cast zx s_4143_2 -> bv
        let s_4143_3: Bits = Bits::new(s_4143_2 as u128, 3u16);
        // D s_4143_4: cmp-eq s_4143_1 s_4143_3
        let s_4143_4: bool = ((s_4143_1) == (s_4143_3));
        // D s_4143_5: write-var gs#135747 <= s_4143_4
        fn_state.gs_135747 = s_4143_4;
        // N s_4143_6: jump b2852
        return block_2852(state, tracer, fn_state);
    }
    fn block_4144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4144_0: read-var opc1:u8
        let s_4144_0: u8 = fn_state.opc1;
        // D s_4144_1: cast zx s_4144_0 -> bv
        let s_4144_1: Bits = Bits::new(s_4144_0 as u128, 3u16);
        // C s_4144_2: const #0u : u8
        let s_4144_2: u8 = 0;
        // C s_4144_3: cast zx s_4144_2 -> bv
        let s_4144_3: Bits = Bits::new(s_4144_2 as u128, 3u16);
        // D s_4144_4: cmp-eq s_4144_1 s_4144_3
        let s_4144_4: bool = ((s_4144_1) == (s_4144_3));
        // D s_4144_5: write-var gs#135746 <= s_4144_4
        fn_state.gs_135746 = s_4144_4;
        // N s_4144_6: jump b2850
        return block_2850(state, tracer, fn_state);
    }
    fn block_4145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4145_0: read-var coproc:u8
        let s_4145_0: u8 = fn_state.coproc;
        // D s_4145_1: cast zx s_4145_0 -> bv
        let s_4145_1: Bits = Bits::new(s_4145_0 as u128, 4u16);
        // C s_4145_2: const #15u : u8
        let s_4145_2: u8 = 15;
        // C s_4145_3: cast zx s_4145_2 -> bv
        let s_4145_3: Bits = Bits::new(s_4145_2 as u128, 4u16);
        // D s_4145_4: cmp-eq s_4145_1 s_4145_3
        let s_4145_4: bool = ((s_4145_1) == (s_4145_3));
        // D s_4145_5: write-var gs#135745 <= s_4145_4
        fn_state.gs_135745 = s_4145_4;
        // N s_4145_6: jump b2848
        return block_2848(state, tracer, fn_state);
    }
    fn block_4146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4146_0: read-var CRn:u8
        let s_4146_0: u8 = fn_state.CRn;
        // D s_4146_1: cast zx s_4146_0 -> bv
        let s_4146_1: Bits = Bits::new(s_4146_0 as u128, 4u16);
        // C s_4146_2: const #7u : u8
        let s_4146_2: u8 = 7;
        // C s_4146_3: cast zx s_4146_2 -> bv
        let s_4146_3: Bits = Bits::new(s_4146_2 as u128, 4u16);
        // D s_4146_4: cmp-eq s_4146_1 s_4146_3
        let s_4146_4: bool = ((s_4146_1) == (s_4146_3));
        // D s_4146_5: write-var gs#135744 <= s_4146_4
        fn_state.gs_135744 = s_4146_4;
        // N s_4146_6: jump b2846
        return block_2846(state, tracer, fn_state);
    }
    fn block_4147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4147_0: read-var el:u8
        let s_4147_0: u8 = fn_state.el;
        // D s_4147_1: read-var coproc:u8
        let s_4147_1: u8 = fn_state.coproc;
        // D s_4147_2: read-var opc1:u8
        let s_4147_2: u8 = fn_state.opc1;
        // D s_4147_3: read-var CRn:u8
        let s_4147_3: u8 = fn_state.CRn;
        // D s_4147_4: read-var opc2:u8
        let s_4147_4: u8 = fn_state.opc2;
        // D s_4147_5: read-var CRm:u8
        let s_4147_5: u8 = fn_state.CRm;
        // D s_4147_6: read-var t:i
        let s_4147_6: i128 = fn_state.t;
        // D s_4147_7: call CONTEXTIDR_SysRegWrite32_3295051c92606610(s_4147_0, s_4147_1, s_4147_2, s_4147_3, s_4147_4, s_4147_5, s_4147_6)
        let s_4147_7: () = CONTEXTIDR_SysRegWrite32_3295051c92606610(
            state,
            tracer,
            s_4147_0,
            s_4147_1,
            s_4147_2,
            s_4147_3,
            s_4147_4,
            s_4147_5,
            s_4147_6,
        );
        // N s_4147_8: return
        return;
    }
    fn block_4148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4148_0: read-var opc2:u8
        let s_4148_0: u8 = fn_state.opc2;
        // D s_4148_1: cast zx s_4148_0 -> bv
        let s_4148_1: Bits = Bits::new(s_4148_0 as u128, 3u16);
        // C s_4148_2: const #1u : u8
        let s_4148_2: u8 = 1;
        // C s_4148_3: cast zx s_4148_2 -> bv
        let s_4148_3: Bits = Bits::new(s_4148_2 as u128, 3u16);
        // D s_4148_4: cmp-eq s_4148_1 s_4148_3
        let s_4148_4: bool = ((s_4148_1) == (s_4148_3));
        // D s_4148_5: write-var gs#135743 <= s_4148_4
        fn_state.gs_135743 = s_4148_4;
        // N s_4148_6: jump b2843
        return block_2843(state, tracer, fn_state);
    }
    fn block_4149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4149_0: read-var opc1:u8
        let s_4149_0: u8 = fn_state.opc1;
        // D s_4149_1: cast zx s_4149_0 -> bv
        let s_4149_1: Bits = Bits::new(s_4149_0 as u128, 3u16);
        // C s_4149_2: const #0u : u8
        let s_4149_2: u8 = 0;
        // C s_4149_3: cast zx s_4149_2 -> bv
        let s_4149_3: Bits = Bits::new(s_4149_2 as u128, 3u16);
        // D s_4149_4: cmp-eq s_4149_1 s_4149_3
        let s_4149_4: bool = ((s_4149_1) == (s_4149_3));
        // D s_4149_5: write-var gs#135742 <= s_4149_4
        fn_state.gs_135742 = s_4149_4;
        // N s_4149_6: jump b2841
        return block_2841(state, tracer, fn_state);
    }
    fn block_4150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4150_0: read-var coproc:u8
        let s_4150_0: u8 = fn_state.coproc;
        // D s_4150_1: cast zx s_4150_0 -> bv
        let s_4150_1: Bits = Bits::new(s_4150_0 as u128, 4u16);
        // C s_4150_2: const #15u : u8
        let s_4150_2: u8 = 15;
        // C s_4150_3: cast zx s_4150_2 -> bv
        let s_4150_3: Bits = Bits::new(s_4150_2 as u128, 4u16);
        // D s_4150_4: cmp-eq s_4150_1 s_4150_3
        let s_4150_4: bool = ((s_4150_1) == (s_4150_3));
        // D s_4150_5: write-var gs#135741 <= s_4150_4
        fn_state.gs_135741 = s_4150_4;
        // N s_4150_6: jump b2839
        return block_2839(state, tracer, fn_state);
    }
    fn block_4151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4151_0: read-var CRn:u8
        let s_4151_0: u8 = fn_state.CRn;
        // D s_4151_1: cast zx s_4151_0 -> bv
        let s_4151_1: Bits = Bits::new(s_4151_0 as u128, 4u16);
        // C s_4151_2: const #13u : u8
        let s_4151_2: u8 = 13;
        // C s_4151_3: cast zx s_4151_2 -> bv
        let s_4151_3: Bits = Bits::new(s_4151_2 as u128, 4u16);
        // D s_4151_4: cmp-eq s_4151_1 s_4151_3
        let s_4151_4: bool = ((s_4151_1) == (s_4151_3));
        // D s_4151_5: write-var gs#135740 <= s_4151_4
        fn_state.gs_135740 = s_4151_4;
        // N s_4151_6: jump b2837
        return block_2837(state, tracer, fn_state);
    }
    fn block_4152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4152_0: read-var el:u8
        let s_4152_0: u8 = fn_state.el;
        // D s_4152_1: read-var coproc:u8
        let s_4152_1: u8 = fn_state.coproc;
        // D s_4152_2: read-var opc1:u8
        let s_4152_2: u8 = fn_state.opc1;
        // D s_4152_3: read-var CRn:u8
        let s_4152_3: u8 = fn_state.CRn;
        // D s_4152_4: read-var opc2:u8
        let s_4152_4: u8 = fn_state.opc2;
        // D s_4152_5: read-var CRm:u8
        let s_4152_5: u8 = fn_state.CRm;
        // D s_4152_6: read-var t:i
        let s_4152_6: i128 = fn_state.t;
        // D s_4152_7: call HTPIDR_SysRegWrite32_5bae00c8ab3297a3(s_4152_0, s_4152_1, s_4152_2, s_4152_3, s_4152_4, s_4152_5, s_4152_6)
        let s_4152_7: () = HTPIDR_SysRegWrite32_5bae00c8ab3297a3(
            state,
            tracer,
            s_4152_0,
            s_4152_1,
            s_4152_2,
            s_4152_3,
            s_4152_4,
            s_4152_5,
            s_4152_6,
        );
        // N s_4152_8: return
        return;
    }
    fn block_4153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4153_0: read-var opc2:u8
        let s_4153_0: u8 = fn_state.opc2;
        // D s_4153_1: cast zx s_4153_0 -> bv
        let s_4153_1: Bits = Bits::new(s_4153_0 as u128, 3u16);
        // C s_4153_2: const #2u : u8
        let s_4153_2: u8 = 2;
        // C s_4153_3: cast zx s_4153_2 -> bv
        let s_4153_3: Bits = Bits::new(s_4153_2 as u128, 3u16);
        // D s_4153_4: cmp-eq s_4153_1 s_4153_3
        let s_4153_4: bool = ((s_4153_1) == (s_4153_3));
        // D s_4153_5: write-var gs#135739 <= s_4153_4
        fn_state.gs_135739 = s_4153_4;
        // N s_4153_6: jump b2834
        return block_2834(state, tracer, fn_state);
    }
    fn block_4154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4154_0: read-var opc1:u8
        let s_4154_0: u8 = fn_state.opc1;
        // D s_4154_1: cast zx s_4154_0 -> bv
        let s_4154_1: Bits = Bits::new(s_4154_0 as u128, 3u16);
        // C s_4154_2: const #4u : u8
        let s_4154_2: u8 = 4;
        // C s_4154_3: cast zx s_4154_2 -> bv
        let s_4154_3: Bits = Bits::new(s_4154_2 as u128, 3u16);
        // D s_4154_4: cmp-eq s_4154_1 s_4154_3
        let s_4154_4: bool = ((s_4154_1) == (s_4154_3));
        // D s_4154_5: write-var gs#135738 <= s_4154_4
        fn_state.gs_135738 = s_4154_4;
        // N s_4154_6: jump b2832
        return block_2832(state, tracer, fn_state);
    }
    fn block_4155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4155_0: read-var coproc:u8
        let s_4155_0: u8 = fn_state.coproc;
        // D s_4155_1: cast zx s_4155_0 -> bv
        let s_4155_1: Bits = Bits::new(s_4155_0 as u128, 4u16);
        // C s_4155_2: const #15u : u8
        let s_4155_2: u8 = 15;
        // C s_4155_3: cast zx s_4155_2 -> bv
        let s_4155_3: Bits = Bits::new(s_4155_2 as u128, 4u16);
        // D s_4155_4: cmp-eq s_4155_1 s_4155_3
        let s_4155_4: bool = ((s_4155_1) == (s_4155_3));
        // D s_4155_5: write-var gs#135737 <= s_4155_4
        fn_state.gs_135737 = s_4155_4;
        // N s_4155_6: jump b2830
        return block_2830(state, tracer, fn_state);
    }
    fn block_4156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4156_0: read-var CRn:u8
        let s_4156_0: u8 = fn_state.CRn;
        // D s_4156_1: cast zx s_4156_0 -> bv
        let s_4156_1: Bits = Bits::new(s_4156_0 as u128, 4u16);
        // C s_4156_2: const #13u : u8
        let s_4156_2: u8 = 13;
        // C s_4156_3: cast zx s_4156_2 -> bv
        let s_4156_3: Bits = Bits::new(s_4156_2 as u128, 4u16);
        // D s_4156_4: cmp-eq s_4156_1 s_4156_3
        let s_4156_4: bool = ((s_4156_1) == (s_4156_3));
        // D s_4156_5: write-var gs#135736 <= s_4156_4
        fn_state.gs_135736 = s_4156_4;
        // N s_4156_6: jump b2828
        return block_2828(state, tracer, fn_state);
    }
    fn block_4157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4157_0: read-var el:u8
        let s_4157_0: u8 = fn_state.el;
        // D s_4157_1: read-var coproc:u8
        let s_4157_1: u8 = fn_state.coproc;
        // D s_4157_2: read-var opc1:u8
        let s_4157_2: u8 = fn_state.opc1;
        // D s_4157_3: read-var CRn:u8
        let s_4157_3: u8 = fn_state.CRn;
        // D s_4157_4: read-var opc2:u8
        let s_4157_4: u8 = fn_state.opc2;
        // D s_4157_5: read-var CRm:u8
        let s_4157_5: u8 = fn_state.CRm;
        // D s_4157_6: read-var t:i
        let s_4157_6: i128 = fn_state.t;
        // D s_4157_7: call PMEVTYPER_SysRegWrite32_172e7a30c1ece78a(s_4157_0, s_4157_1, s_4157_2, s_4157_3, s_4157_4, s_4157_5, s_4157_6)
        let s_4157_7: () = PMEVTYPER_SysRegWrite32_172e7a30c1ece78a(
            state,
            tracer,
            s_4157_0,
            s_4157_1,
            s_4157_2,
            s_4157_3,
            s_4157_4,
            s_4157_5,
            s_4157_6,
        );
        // N s_4157_8: return
        return;
    }
    fn block_4158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4158_0: read-var opc2:u8
        let s_4158_0: u8 = fn_state.opc2;
        // D s_4158_1: cast zx s_4158_0 -> bv
        let s_4158_1: Bits = Bits::new(s_4158_0 as u128, 3u16);
        // C s_4158_2: const #0u : u8
        let s_4158_2: u8 = 0;
        // C s_4158_3: cast zx s_4158_2 -> bv
        let s_4158_3: Bits = Bits::new(s_4158_2 as u128, 3u16);
        // D s_4158_4: cmp-eq s_4158_1 s_4158_3
        let s_4158_4: bool = ((s_4158_1) == (s_4158_3));
        // D s_4158_5: write-var gs#135735 <= s_4158_4
        fn_state.gs_135735 = s_4158_4;
        // N s_4158_6: jump b2825
        return block_2825(state, tracer, fn_state);
    }
    fn block_4159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4159_0: read-var opc1:u8
        let s_4159_0: u8 = fn_state.opc1;
        // D s_4159_1: cast zx s_4159_0 -> bv
        let s_4159_1: Bits = Bits::new(s_4159_0 as u128, 3u16);
        // C s_4159_2: const #0u : u8
        let s_4159_2: u8 = 0;
        // C s_4159_3: cast zx s_4159_2 -> bv
        let s_4159_3: Bits = Bits::new(s_4159_2 as u128, 3u16);
        // D s_4159_4: cmp-eq s_4159_1 s_4159_3
        let s_4159_4: bool = ((s_4159_1) == (s_4159_3));
        // D s_4159_5: write-var gs#135734 <= s_4159_4
        fn_state.gs_135734 = s_4159_4;
        // N s_4159_6: jump b2823
        return block_2823(state, tracer, fn_state);
    }
    fn block_4160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4160_0: read-var coproc:u8
        let s_4160_0: u8 = fn_state.coproc;
        // D s_4160_1: cast zx s_4160_0 -> bv
        let s_4160_1: Bits = Bits::new(s_4160_0 as u128, 4u16);
        // C s_4160_2: const #15u : u8
        let s_4160_2: u8 = 15;
        // C s_4160_3: cast zx s_4160_2 -> bv
        let s_4160_3: Bits = Bits::new(s_4160_2 as u128, 4u16);
        // D s_4160_4: cmp-eq s_4160_1 s_4160_3
        let s_4160_4: bool = ((s_4160_1) == (s_4160_3));
        // D s_4160_5: write-var gs#135733 <= s_4160_4
        fn_state.gs_135733 = s_4160_4;
        // N s_4160_6: jump b2821
        return block_2821(state, tracer, fn_state);
    }
    fn block_4161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4161_0: read-var CRn:u8
        let s_4161_0: u8 = fn_state.CRn;
        // D s_4161_1: cast zx s_4161_0 -> bv
        let s_4161_1: Bits = Bits::new(s_4161_0 as u128, 4u16);
        // C s_4161_2: const #14u : u8
        let s_4161_2: u8 = 14;
        // C s_4161_3: cast zx s_4161_2 -> bv
        let s_4161_3: Bits = Bits::new(s_4161_2 as u128, 4u16);
        // D s_4161_4: cmp-eq s_4161_1 s_4161_3
        let s_4161_4: bool = ((s_4161_1) == (s_4161_3));
        // D s_4161_5: write-var gs#135732 <= s_4161_4
        fn_state.gs_135732 = s_4161_4;
        // N s_4161_6: jump b2819
        return block_2819(state, tracer, fn_state);
    }
    fn block_4162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4162_0: read-var el:u8
        let s_4162_0: u8 = fn_state.el;
        // D s_4162_1: read-var coproc:u8
        let s_4162_1: u8 = fn_state.coproc;
        // D s_4162_2: read-var opc1:u8
        let s_4162_2: u8 = fn_state.opc1;
        // D s_4162_3: read-var CRn:u8
        let s_4162_3: u8 = fn_state.CRn;
        // D s_4162_4: read-var opc2:u8
        let s_4162_4: u8 = fn_state.opc2;
        // D s_4162_5: read-var CRm:u8
        let s_4162_5: u8 = fn_state.CRm;
        // D s_4162_6: read-var t:i
        let s_4162_6: i128 = fn_state.t;
        // D s_4162_7: call PMEVTYPER_SysRegWrite32_51fb35106f5676b7(s_4162_0, s_4162_1, s_4162_2, s_4162_3, s_4162_4, s_4162_5, s_4162_6)
        let s_4162_7: () = PMEVTYPER_SysRegWrite32_51fb35106f5676b7(
            state,
            tracer,
            s_4162_0,
            s_4162_1,
            s_4162_2,
            s_4162_3,
            s_4162_4,
            s_4162_5,
            s_4162_6,
        );
        // N s_4162_8: return
        return;
    }
    fn block_4163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4163_0: read-var opc2:u8
        let s_4163_0: u8 = fn_state.opc2;
        // D s_4163_1: cast zx s_4163_0 -> bv
        let s_4163_1: Bits = Bits::new(s_4163_0 as u128, 3u16);
        // C s_4163_2: const #1u : u8
        let s_4163_2: u8 = 1;
        // C s_4163_3: cast zx s_4163_2 -> bv
        let s_4163_3: Bits = Bits::new(s_4163_2 as u128, 3u16);
        // D s_4163_4: cmp-eq s_4163_1 s_4163_3
        let s_4163_4: bool = ((s_4163_1) == (s_4163_3));
        // D s_4163_5: write-var gs#135731 <= s_4163_4
        fn_state.gs_135731 = s_4163_4;
        // N s_4163_6: jump b2816
        return block_2816(state, tracer, fn_state);
    }
    fn block_4164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4164_0: read-var opc1:u8
        let s_4164_0: u8 = fn_state.opc1;
        // D s_4164_1: cast zx s_4164_0 -> bv
        let s_4164_1: Bits = Bits::new(s_4164_0 as u128, 3u16);
        // C s_4164_2: const #0u : u8
        let s_4164_2: u8 = 0;
        // C s_4164_3: cast zx s_4164_2 -> bv
        let s_4164_3: Bits = Bits::new(s_4164_2 as u128, 3u16);
        // D s_4164_4: cmp-eq s_4164_1 s_4164_3
        let s_4164_4: bool = ((s_4164_1) == (s_4164_3));
        // D s_4164_5: write-var gs#135730 <= s_4164_4
        fn_state.gs_135730 = s_4164_4;
        // N s_4164_6: jump b2814
        return block_2814(state, tracer, fn_state);
    }
    fn block_4165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4165_0: read-var coproc:u8
        let s_4165_0: u8 = fn_state.coproc;
        // D s_4165_1: cast zx s_4165_0 -> bv
        let s_4165_1: Bits = Bits::new(s_4165_0 as u128, 4u16);
        // C s_4165_2: const #15u : u8
        let s_4165_2: u8 = 15;
        // C s_4165_3: cast zx s_4165_2 -> bv
        let s_4165_3: Bits = Bits::new(s_4165_2 as u128, 4u16);
        // D s_4165_4: cmp-eq s_4165_1 s_4165_3
        let s_4165_4: bool = ((s_4165_1) == (s_4165_3));
        // D s_4165_5: write-var gs#135729 <= s_4165_4
        fn_state.gs_135729 = s_4165_4;
        // N s_4165_6: jump b2812
        return block_2812(state, tracer, fn_state);
    }
    fn block_4166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4166_0: read-var CRn:u8
        let s_4166_0: u8 = fn_state.CRn;
        // D s_4166_1: cast zx s_4166_0 -> bv
        let s_4166_1: Bits = Bits::new(s_4166_0 as u128, 4u16);
        // C s_4166_2: const #14u : u8
        let s_4166_2: u8 = 14;
        // C s_4166_3: cast zx s_4166_2 -> bv
        let s_4166_3: Bits = Bits::new(s_4166_2 as u128, 4u16);
        // D s_4166_4: cmp-eq s_4166_1 s_4166_3
        let s_4166_4: bool = ((s_4166_1) == (s_4166_3));
        // D s_4166_5: write-var gs#135728 <= s_4166_4
        fn_state.gs_135728 = s_4166_4;
        // N s_4166_6: jump b2810
        return block_2810(state, tracer, fn_state);
    }
    fn block_4167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4167_0: read-var el:u8
        let s_4167_0: u8 = fn_state.el;
        // D s_4167_1: read-var coproc:u8
        let s_4167_1: u8 = fn_state.coproc;
        // D s_4167_2: read-var opc1:u8
        let s_4167_2: u8 = fn_state.opc1;
        // D s_4167_3: read-var CRn:u8
        let s_4167_3: u8 = fn_state.CRn;
        // D s_4167_4: read-var opc2:u8
        let s_4167_4: u8 = fn_state.opc2;
        // D s_4167_5: read-var CRm:u8
        let s_4167_5: u8 = fn_state.CRm;
        // D s_4167_6: read-var t:i
        let s_4167_6: i128 = fn_state.t;
        // D s_4167_7: call PMEVTYPER_SysRegWrite32_82b4f80451193782(s_4167_0, s_4167_1, s_4167_2, s_4167_3, s_4167_4, s_4167_5, s_4167_6)
        let s_4167_7: () = PMEVTYPER_SysRegWrite32_82b4f80451193782(
            state,
            tracer,
            s_4167_0,
            s_4167_1,
            s_4167_2,
            s_4167_3,
            s_4167_4,
            s_4167_5,
            s_4167_6,
        );
        // N s_4167_8: return
        return;
    }
    fn block_4168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4168_0: read-var opc2:u8
        let s_4168_0: u8 = fn_state.opc2;
        // D s_4168_1: cast zx s_4168_0 -> bv
        let s_4168_1: Bits = Bits::new(s_4168_0 as u128, 3u16);
        // C s_4168_2: const #2u : u8
        let s_4168_2: u8 = 2;
        // C s_4168_3: cast zx s_4168_2 -> bv
        let s_4168_3: Bits = Bits::new(s_4168_2 as u128, 3u16);
        // D s_4168_4: cmp-eq s_4168_1 s_4168_3
        let s_4168_4: bool = ((s_4168_1) == (s_4168_3));
        // D s_4168_5: write-var gs#135727 <= s_4168_4
        fn_state.gs_135727 = s_4168_4;
        // N s_4168_6: jump b2807
        return block_2807(state, tracer, fn_state);
    }
    fn block_4169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4169_0: read-var opc1:u8
        let s_4169_0: u8 = fn_state.opc1;
        // D s_4169_1: cast zx s_4169_0 -> bv
        let s_4169_1: Bits = Bits::new(s_4169_0 as u128, 3u16);
        // C s_4169_2: const #0u : u8
        let s_4169_2: u8 = 0;
        // C s_4169_3: cast zx s_4169_2 -> bv
        let s_4169_3: Bits = Bits::new(s_4169_2 as u128, 3u16);
        // D s_4169_4: cmp-eq s_4169_1 s_4169_3
        let s_4169_4: bool = ((s_4169_1) == (s_4169_3));
        // D s_4169_5: write-var gs#135726 <= s_4169_4
        fn_state.gs_135726 = s_4169_4;
        // N s_4169_6: jump b2805
        return block_2805(state, tracer, fn_state);
    }
    fn block_4170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4170_0: read-var coproc:u8
        let s_4170_0: u8 = fn_state.coproc;
        // D s_4170_1: cast zx s_4170_0 -> bv
        let s_4170_1: Bits = Bits::new(s_4170_0 as u128, 4u16);
        // C s_4170_2: const #15u : u8
        let s_4170_2: u8 = 15;
        // C s_4170_3: cast zx s_4170_2 -> bv
        let s_4170_3: Bits = Bits::new(s_4170_2 as u128, 4u16);
        // D s_4170_4: cmp-eq s_4170_1 s_4170_3
        let s_4170_4: bool = ((s_4170_1) == (s_4170_3));
        // D s_4170_5: write-var gs#135725 <= s_4170_4
        fn_state.gs_135725 = s_4170_4;
        // N s_4170_6: jump b2803
        return block_2803(state, tracer, fn_state);
    }
    fn block_4171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4171_0: read-var CRn:u8
        let s_4171_0: u8 = fn_state.CRn;
        // D s_4171_1: cast zx s_4171_0 -> bv
        let s_4171_1: Bits = Bits::new(s_4171_0 as u128, 4u16);
        // C s_4171_2: const #14u : u8
        let s_4171_2: u8 = 14;
        // C s_4171_3: cast zx s_4171_2 -> bv
        let s_4171_3: Bits = Bits::new(s_4171_2 as u128, 4u16);
        // D s_4171_4: cmp-eq s_4171_1 s_4171_3
        let s_4171_4: bool = ((s_4171_1) == (s_4171_3));
        // D s_4171_5: write-var gs#135724 <= s_4171_4
        fn_state.gs_135724 = s_4171_4;
        // N s_4171_6: jump b2801
        return block_2801(state, tracer, fn_state);
    }
    fn block_4172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4172_0: read-var el:u8
        let s_4172_0: u8 = fn_state.el;
        // D s_4172_1: read-var coproc:u8
        let s_4172_1: u8 = fn_state.coproc;
        // D s_4172_2: read-var opc1:u8
        let s_4172_2: u8 = fn_state.opc1;
        // D s_4172_3: read-var CRn:u8
        let s_4172_3: u8 = fn_state.CRn;
        // D s_4172_4: read-var opc2:u8
        let s_4172_4: u8 = fn_state.opc2;
        // D s_4172_5: read-var CRm:u8
        let s_4172_5: u8 = fn_state.CRm;
        // D s_4172_6: read-var t:i
        let s_4172_6: i128 = fn_state.t;
        // D s_4172_7: call PMEVTYPER_SysRegWrite32_5328bc51c618fc92(s_4172_0, s_4172_1, s_4172_2, s_4172_3, s_4172_4, s_4172_5, s_4172_6)
        let s_4172_7: () = PMEVTYPER_SysRegWrite32_5328bc51c618fc92(
            state,
            tracer,
            s_4172_0,
            s_4172_1,
            s_4172_2,
            s_4172_3,
            s_4172_4,
            s_4172_5,
            s_4172_6,
        );
        // N s_4172_8: return
        return;
    }
    fn block_4173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4173_0: read-var opc2:u8
        let s_4173_0: u8 = fn_state.opc2;
        // D s_4173_1: cast zx s_4173_0 -> bv
        let s_4173_1: Bits = Bits::new(s_4173_0 as u128, 3u16);
        // C s_4173_2: const #3u : u8
        let s_4173_2: u8 = 3;
        // C s_4173_3: cast zx s_4173_2 -> bv
        let s_4173_3: Bits = Bits::new(s_4173_2 as u128, 3u16);
        // D s_4173_4: cmp-eq s_4173_1 s_4173_3
        let s_4173_4: bool = ((s_4173_1) == (s_4173_3));
        // D s_4173_5: write-var gs#135723 <= s_4173_4
        fn_state.gs_135723 = s_4173_4;
        // N s_4173_6: jump b2798
        return block_2798(state, tracer, fn_state);
    }
    fn block_4174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4174_0: read-var opc1:u8
        let s_4174_0: u8 = fn_state.opc1;
        // D s_4174_1: cast zx s_4174_0 -> bv
        let s_4174_1: Bits = Bits::new(s_4174_0 as u128, 3u16);
        // C s_4174_2: const #0u : u8
        let s_4174_2: u8 = 0;
        // C s_4174_3: cast zx s_4174_2 -> bv
        let s_4174_3: Bits = Bits::new(s_4174_2 as u128, 3u16);
        // D s_4174_4: cmp-eq s_4174_1 s_4174_3
        let s_4174_4: bool = ((s_4174_1) == (s_4174_3));
        // D s_4174_5: write-var gs#135722 <= s_4174_4
        fn_state.gs_135722 = s_4174_4;
        // N s_4174_6: jump b2796
        return block_2796(state, tracer, fn_state);
    }
    fn block_4175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4175_0: read-var coproc:u8
        let s_4175_0: u8 = fn_state.coproc;
        // D s_4175_1: cast zx s_4175_0 -> bv
        let s_4175_1: Bits = Bits::new(s_4175_0 as u128, 4u16);
        // C s_4175_2: const #15u : u8
        let s_4175_2: u8 = 15;
        // C s_4175_3: cast zx s_4175_2 -> bv
        let s_4175_3: Bits = Bits::new(s_4175_2 as u128, 4u16);
        // D s_4175_4: cmp-eq s_4175_1 s_4175_3
        let s_4175_4: bool = ((s_4175_1) == (s_4175_3));
        // D s_4175_5: write-var gs#135721 <= s_4175_4
        fn_state.gs_135721 = s_4175_4;
        // N s_4175_6: jump b2794
        return block_2794(state, tracer, fn_state);
    }
    fn block_4176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4176_0: read-var CRn:u8
        let s_4176_0: u8 = fn_state.CRn;
        // D s_4176_1: cast zx s_4176_0 -> bv
        let s_4176_1: Bits = Bits::new(s_4176_0 as u128, 4u16);
        // C s_4176_2: const #14u : u8
        let s_4176_2: u8 = 14;
        // C s_4176_3: cast zx s_4176_2 -> bv
        let s_4176_3: Bits = Bits::new(s_4176_2 as u128, 4u16);
        // D s_4176_4: cmp-eq s_4176_1 s_4176_3
        let s_4176_4: bool = ((s_4176_1) == (s_4176_3));
        // D s_4176_5: write-var gs#135720 <= s_4176_4
        fn_state.gs_135720 = s_4176_4;
        // N s_4176_6: jump b2792
        return block_2792(state, tracer, fn_state);
    }
    fn block_4177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4177_0: read-var el:u8
        let s_4177_0: u8 = fn_state.el;
        // D s_4177_1: read-var coproc:u8
        let s_4177_1: u8 = fn_state.coproc;
        // D s_4177_2: read-var opc1:u8
        let s_4177_2: u8 = fn_state.opc1;
        // D s_4177_3: read-var CRn:u8
        let s_4177_3: u8 = fn_state.CRn;
        // D s_4177_4: read-var opc2:u8
        let s_4177_4: u8 = fn_state.opc2;
        // D s_4177_5: read-var CRm:u8
        let s_4177_5: u8 = fn_state.CRm;
        // D s_4177_6: read-var t:i
        let s_4177_6: i128 = fn_state.t;
        // D s_4177_7: call PMEVTYPER_SysRegWrite32_3e4eb9eb36921364(s_4177_0, s_4177_1, s_4177_2, s_4177_3, s_4177_4, s_4177_5, s_4177_6)
        let s_4177_7: () = PMEVTYPER_SysRegWrite32_3e4eb9eb36921364(
            state,
            tracer,
            s_4177_0,
            s_4177_1,
            s_4177_2,
            s_4177_3,
            s_4177_4,
            s_4177_5,
            s_4177_6,
        );
        // N s_4177_8: return
        return;
    }
    fn block_4178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4178_0: read-var opc2:u8
        let s_4178_0: u8 = fn_state.opc2;
        // D s_4178_1: cast zx s_4178_0 -> bv
        let s_4178_1: Bits = Bits::new(s_4178_0 as u128, 3u16);
        // C s_4178_2: const #4u : u8
        let s_4178_2: u8 = 4;
        // C s_4178_3: cast zx s_4178_2 -> bv
        let s_4178_3: Bits = Bits::new(s_4178_2 as u128, 3u16);
        // D s_4178_4: cmp-eq s_4178_1 s_4178_3
        let s_4178_4: bool = ((s_4178_1) == (s_4178_3));
        // D s_4178_5: write-var gs#135719 <= s_4178_4
        fn_state.gs_135719 = s_4178_4;
        // N s_4178_6: jump b2789
        return block_2789(state, tracer, fn_state);
    }
    fn block_4179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4179_0: read-var opc1:u8
        let s_4179_0: u8 = fn_state.opc1;
        // D s_4179_1: cast zx s_4179_0 -> bv
        let s_4179_1: Bits = Bits::new(s_4179_0 as u128, 3u16);
        // C s_4179_2: const #0u : u8
        let s_4179_2: u8 = 0;
        // C s_4179_3: cast zx s_4179_2 -> bv
        let s_4179_3: Bits = Bits::new(s_4179_2 as u128, 3u16);
        // D s_4179_4: cmp-eq s_4179_1 s_4179_3
        let s_4179_4: bool = ((s_4179_1) == (s_4179_3));
        // D s_4179_5: write-var gs#135718 <= s_4179_4
        fn_state.gs_135718 = s_4179_4;
        // N s_4179_6: jump b2787
        return block_2787(state, tracer, fn_state);
    }
    fn block_4180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4180_0: read-var coproc:u8
        let s_4180_0: u8 = fn_state.coproc;
        // D s_4180_1: cast zx s_4180_0 -> bv
        let s_4180_1: Bits = Bits::new(s_4180_0 as u128, 4u16);
        // C s_4180_2: const #15u : u8
        let s_4180_2: u8 = 15;
        // C s_4180_3: cast zx s_4180_2 -> bv
        let s_4180_3: Bits = Bits::new(s_4180_2 as u128, 4u16);
        // D s_4180_4: cmp-eq s_4180_1 s_4180_3
        let s_4180_4: bool = ((s_4180_1) == (s_4180_3));
        // D s_4180_5: write-var gs#135717 <= s_4180_4
        fn_state.gs_135717 = s_4180_4;
        // N s_4180_6: jump b2785
        return block_2785(state, tracer, fn_state);
    }
    fn block_4181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4181_0: read-var CRn:u8
        let s_4181_0: u8 = fn_state.CRn;
        // D s_4181_1: cast zx s_4181_0 -> bv
        let s_4181_1: Bits = Bits::new(s_4181_0 as u128, 4u16);
        // C s_4181_2: const #14u : u8
        let s_4181_2: u8 = 14;
        // C s_4181_3: cast zx s_4181_2 -> bv
        let s_4181_3: Bits = Bits::new(s_4181_2 as u128, 4u16);
        // D s_4181_4: cmp-eq s_4181_1 s_4181_3
        let s_4181_4: bool = ((s_4181_1) == (s_4181_3));
        // D s_4181_5: write-var gs#135716 <= s_4181_4
        fn_state.gs_135716 = s_4181_4;
        // N s_4181_6: jump b2783
        return block_2783(state, tracer, fn_state);
    }
    fn block_4182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4182_0: read-var el:u8
        let s_4182_0: u8 = fn_state.el;
        // D s_4182_1: read-var coproc:u8
        let s_4182_1: u8 = fn_state.coproc;
        // D s_4182_2: read-var opc1:u8
        let s_4182_2: u8 = fn_state.opc1;
        // D s_4182_3: read-var CRn:u8
        let s_4182_3: u8 = fn_state.CRn;
        // D s_4182_4: read-var opc2:u8
        let s_4182_4: u8 = fn_state.opc2;
        // D s_4182_5: read-var CRm:u8
        let s_4182_5: u8 = fn_state.CRm;
        // D s_4182_6: read-var t:i
        let s_4182_6: i128 = fn_state.t;
        // D s_4182_7: call PMEVTYPER_SysRegWrite32_51b82d68052aa3e2(s_4182_0, s_4182_1, s_4182_2, s_4182_3, s_4182_4, s_4182_5, s_4182_6)
        let s_4182_7: () = PMEVTYPER_SysRegWrite32_51b82d68052aa3e2(
            state,
            tracer,
            s_4182_0,
            s_4182_1,
            s_4182_2,
            s_4182_3,
            s_4182_4,
            s_4182_5,
            s_4182_6,
        );
        // N s_4182_8: return
        return;
    }
    fn block_4183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4183_0: read-var opc2:u8
        let s_4183_0: u8 = fn_state.opc2;
        // D s_4183_1: cast zx s_4183_0 -> bv
        let s_4183_1: Bits = Bits::new(s_4183_0 as u128, 3u16);
        // C s_4183_2: const #5u : u8
        let s_4183_2: u8 = 5;
        // C s_4183_3: cast zx s_4183_2 -> bv
        let s_4183_3: Bits = Bits::new(s_4183_2 as u128, 3u16);
        // D s_4183_4: cmp-eq s_4183_1 s_4183_3
        let s_4183_4: bool = ((s_4183_1) == (s_4183_3));
        // D s_4183_5: write-var gs#135715 <= s_4183_4
        fn_state.gs_135715 = s_4183_4;
        // N s_4183_6: jump b2780
        return block_2780(state, tracer, fn_state);
    }
    fn block_4184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4184_0: read-var opc1:u8
        let s_4184_0: u8 = fn_state.opc1;
        // D s_4184_1: cast zx s_4184_0 -> bv
        let s_4184_1: Bits = Bits::new(s_4184_0 as u128, 3u16);
        // C s_4184_2: const #0u : u8
        let s_4184_2: u8 = 0;
        // C s_4184_3: cast zx s_4184_2 -> bv
        let s_4184_3: Bits = Bits::new(s_4184_2 as u128, 3u16);
        // D s_4184_4: cmp-eq s_4184_1 s_4184_3
        let s_4184_4: bool = ((s_4184_1) == (s_4184_3));
        // D s_4184_5: write-var gs#135714 <= s_4184_4
        fn_state.gs_135714 = s_4184_4;
        // N s_4184_6: jump b2778
        return block_2778(state, tracer, fn_state);
    }
    fn block_4185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4185_0: read-var coproc:u8
        let s_4185_0: u8 = fn_state.coproc;
        // D s_4185_1: cast zx s_4185_0 -> bv
        let s_4185_1: Bits = Bits::new(s_4185_0 as u128, 4u16);
        // C s_4185_2: const #15u : u8
        let s_4185_2: u8 = 15;
        // C s_4185_3: cast zx s_4185_2 -> bv
        let s_4185_3: Bits = Bits::new(s_4185_2 as u128, 4u16);
        // D s_4185_4: cmp-eq s_4185_1 s_4185_3
        let s_4185_4: bool = ((s_4185_1) == (s_4185_3));
        // D s_4185_5: write-var gs#135713 <= s_4185_4
        fn_state.gs_135713 = s_4185_4;
        // N s_4185_6: jump b2776
        return block_2776(state, tracer, fn_state);
    }
    fn block_4186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4186_0: read-var CRn:u8
        let s_4186_0: u8 = fn_state.CRn;
        // D s_4186_1: cast zx s_4186_0 -> bv
        let s_4186_1: Bits = Bits::new(s_4186_0 as u128, 4u16);
        // C s_4186_2: const #14u : u8
        let s_4186_2: u8 = 14;
        // C s_4186_3: cast zx s_4186_2 -> bv
        let s_4186_3: Bits = Bits::new(s_4186_2 as u128, 4u16);
        // D s_4186_4: cmp-eq s_4186_1 s_4186_3
        let s_4186_4: bool = ((s_4186_1) == (s_4186_3));
        // D s_4186_5: write-var gs#135712 <= s_4186_4
        fn_state.gs_135712 = s_4186_4;
        // N s_4186_6: jump b2774
        return block_2774(state, tracer, fn_state);
    }
    fn block_4187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4187_0: read-var el:u8
        let s_4187_0: u8 = fn_state.el;
        // D s_4187_1: read-var coproc:u8
        let s_4187_1: u8 = fn_state.coproc;
        // D s_4187_2: read-var opc1:u8
        let s_4187_2: u8 = fn_state.opc1;
        // D s_4187_3: read-var CRn:u8
        let s_4187_3: u8 = fn_state.CRn;
        // D s_4187_4: read-var opc2:u8
        let s_4187_4: u8 = fn_state.opc2;
        // D s_4187_5: read-var CRm:u8
        let s_4187_5: u8 = fn_state.CRm;
        // D s_4187_6: read-var t:i
        let s_4187_6: i128 = fn_state.t;
        // D s_4187_7: call PMEVTYPER_SysRegWrite32_225a412cd5799c58(s_4187_0, s_4187_1, s_4187_2, s_4187_3, s_4187_4, s_4187_5, s_4187_6)
        let s_4187_7: () = PMEVTYPER_SysRegWrite32_225a412cd5799c58(
            state,
            tracer,
            s_4187_0,
            s_4187_1,
            s_4187_2,
            s_4187_3,
            s_4187_4,
            s_4187_5,
            s_4187_6,
        );
        // N s_4187_8: return
        return;
    }
    fn block_4188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4188_0: read-var opc2:u8
        let s_4188_0: u8 = fn_state.opc2;
        // D s_4188_1: cast zx s_4188_0 -> bv
        let s_4188_1: Bits = Bits::new(s_4188_0 as u128, 3u16);
        // C s_4188_2: const #6u : u8
        let s_4188_2: u8 = 6;
        // C s_4188_3: cast zx s_4188_2 -> bv
        let s_4188_3: Bits = Bits::new(s_4188_2 as u128, 3u16);
        // D s_4188_4: cmp-eq s_4188_1 s_4188_3
        let s_4188_4: bool = ((s_4188_1) == (s_4188_3));
        // D s_4188_5: write-var gs#135711 <= s_4188_4
        fn_state.gs_135711 = s_4188_4;
        // N s_4188_6: jump b2771
        return block_2771(state, tracer, fn_state);
    }
    fn block_4189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4189_0: read-var opc1:u8
        let s_4189_0: u8 = fn_state.opc1;
        // D s_4189_1: cast zx s_4189_0 -> bv
        let s_4189_1: Bits = Bits::new(s_4189_0 as u128, 3u16);
        // C s_4189_2: const #0u : u8
        let s_4189_2: u8 = 0;
        // C s_4189_3: cast zx s_4189_2 -> bv
        let s_4189_3: Bits = Bits::new(s_4189_2 as u128, 3u16);
        // D s_4189_4: cmp-eq s_4189_1 s_4189_3
        let s_4189_4: bool = ((s_4189_1) == (s_4189_3));
        // D s_4189_5: write-var gs#135710 <= s_4189_4
        fn_state.gs_135710 = s_4189_4;
        // N s_4189_6: jump b2769
        return block_2769(state, tracer, fn_state);
    }
    fn block_4190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4190_0: read-var coproc:u8
        let s_4190_0: u8 = fn_state.coproc;
        // D s_4190_1: cast zx s_4190_0 -> bv
        let s_4190_1: Bits = Bits::new(s_4190_0 as u128, 4u16);
        // C s_4190_2: const #15u : u8
        let s_4190_2: u8 = 15;
        // C s_4190_3: cast zx s_4190_2 -> bv
        let s_4190_3: Bits = Bits::new(s_4190_2 as u128, 4u16);
        // D s_4190_4: cmp-eq s_4190_1 s_4190_3
        let s_4190_4: bool = ((s_4190_1) == (s_4190_3));
        // D s_4190_5: write-var gs#135709 <= s_4190_4
        fn_state.gs_135709 = s_4190_4;
        // N s_4190_6: jump b2767
        return block_2767(state, tracer, fn_state);
    }
    fn block_4191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4191_0: read-var CRn:u8
        let s_4191_0: u8 = fn_state.CRn;
        // D s_4191_1: cast zx s_4191_0 -> bv
        let s_4191_1: Bits = Bits::new(s_4191_0 as u128, 4u16);
        // C s_4191_2: const #14u : u8
        let s_4191_2: u8 = 14;
        // C s_4191_3: cast zx s_4191_2 -> bv
        let s_4191_3: Bits = Bits::new(s_4191_2 as u128, 4u16);
        // D s_4191_4: cmp-eq s_4191_1 s_4191_3
        let s_4191_4: bool = ((s_4191_1) == (s_4191_3));
        // D s_4191_5: write-var gs#135708 <= s_4191_4
        fn_state.gs_135708 = s_4191_4;
        // N s_4191_6: jump b2765
        return block_2765(state, tracer, fn_state);
    }
    fn block_4192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4192_0: read-var el:u8
        let s_4192_0: u8 = fn_state.el;
        // D s_4192_1: read-var coproc:u8
        let s_4192_1: u8 = fn_state.coproc;
        // D s_4192_2: read-var opc1:u8
        let s_4192_2: u8 = fn_state.opc1;
        // D s_4192_3: read-var CRn:u8
        let s_4192_3: u8 = fn_state.CRn;
        // D s_4192_4: read-var opc2:u8
        let s_4192_4: u8 = fn_state.opc2;
        // D s_4192_5: read-var CRm:u8
        let s_4192_5: u8 = fn_state.CRm;
        // D s_4192_6: read-var t:i
        let s_4192_6: i128 = fn_state.t;
        // D s_4192_7: call PMEVTYPER_SysRegWrite32_8790f8c36b20943f(s_4192_0, s_4192_1, s_4192_2, s_4192_3, s_4192_4, s_4192_5, s_4192_6)
        let s_4192_7: () = PMEVTYPER_SysRegWrite32_8790f8c36b20943f(
            state,
            tracer,
            s_4192_0,
            s_4192_1,
            s_4192_2,
            s_4192_3,
            s_4192_4,
            s_4192_5,
            s_4192_6,
        );
        // N s_4192_8: return
        return;
    }
    fn block_4193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4193_0: read-var opc2:u8
        let s_4193_0: u8 = fn_state.opc2;
        // D s_4193_1: cast zx s_4193_0 -> bv
        let s_4193_1: Bits = Bits::new(s_4193_0 as u128, 3u16);
        // C s_4193_2: const #7u : u8
        let s_4193_2: u8 = 7;
        // C s_4193_3: cast zx s_4193_2 -> bv
        let s_4193_3: Bits = Bits::new(s_4193_2 as u128, 3u16);
        // D s_4193_4: cmp-eq s_4193_1 s_4193_3
        let s_4193_4: bool = ((s_4193_1) == (s_4193_3));
        // D s_4193_5: write-var gs#135707 <= s_4193_4
        fn_state.gs_135707 = s_4193_4;
        // N s_4193_6: jump b2762
        return block_2762(state, tracer, fn_state);
    }
    fn block_4194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4194_0: read-var opc1:u8
        let s_4194_0: u8 = fn_state.opc1;
        // D s_4194_1: cast zx s_4194_0 -> bv
        let s_4194_1: Bits = Bits::new(s_4194_0 as u128, 3u16);
        // C s_4194_2: const #0u : u8
        let s_4194_2: u8 = 0;
        // C s_4194_3: cast zx s_4194_2 -> bv
        let s_4194_3: Bits = Bits::new(s_4194_2 as u128, 3u16);
        // D s_4194_4: cmp-eq s_4194_1 s_4194_3
        let s_4194_4: bool = ((s_4194_1) == (s_4194_3));
        // D s_4194_5: write-var gs#135706 <= s_4194_4
        fn_state.gs_135706 = s_4194_4;
        // N s_4194_6: jump b2760
        return block_2760(state, tracer, fn_state);
    }
    fn block_4195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4195_0: read-var coproc:u8
        let s_4195_0: u8 = fn_state.coproc;
        // D s_4195_1: cast zx s_4195_0 -> bv
        let s_4195_1: Bits = Bits::new(s_4195_0 as u128, 4u16);
        // C s_4195_2: const #15u : u8
        let s_4195_2: u8 = 15;
        // C s_4195_3: cast zx s_4195_2 -> bv
        let s_4195_3: Bits = Bits::new(s_4195_2 as u128, 4u16);
        // D s_4195_4: cmp-eq s_4195_1 s_4195_3
        let s_4195_4: bool = ((s_4195_1) == (s_4195_3));
        // D s_4195_5: write-var gs#135705 <= s_4195_4
        fn_state.gs_135705 = s_4195_4;
        // N s_4195_6: jump b2758
        return block_2758(state, tracer, fn_state);
    }
    fn block_4196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4196_0: read-var CRn:u8
        let s_4196_0: u8 = fn_state.CRn;
        // D s_4196_1: cast zx s_4196_0 -> bv
        let s_4196_1: Bits = Bits::new(s_4196_0 as u128, 4u16);
        // C s_4196_2: const #14u : u8
        let s_4196_2: u8 = 14;
        // C s_4196_3: cast zx s_4196_2 -> bv
        let s_4196_3: Bits = Bits::new(s_4196_2 as u128, 4u16);
        // D s_4196_4: cmp-eq s_4196_1 s_4196_3
        let s_4196_4: bool = ((s_4196_1) == (s_4196_3));
        // D s_4196_5: write-var gs#135704 <= s_4196_4
        fn_state.gs_135704 = s_4196_4;
        // N s_4196_6: jump b2756
        return block_2756(state, tracer, fn_state);
    }
    fn block_4197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4197_0: read-var el:u8
        let s_4197_0: u8 = fn_state.el;
        // D s_4197_1: read-var coproc:u8
        let s_4197_1: u8 = fn_state.coproc;
        // D s_4197_2: read-var opc1:u8
        let s_4197_2: u8 = fn_state.opc1;
        // D s_4197_3: read-var CRn:u8
        let s_4197_3: u8 = fn_state.CRn;
        // D s_4197_4: read-var opc2:u8
        let s_4197_4: u8 = fn_state.opc2;
        // D s_4197_5: read-var CRm:u8
        let s_4197_5: u8 = fn_state.CRm;
        // D s_4197_6: read-var t:i
        let s_4197_6: i128 = fn_state.t;
        // D s_4197_7: call PMEVTYPER_SysRegWrite32_2577251aa43d9dc4(s_4197_0, s_4197_1, s_4197_2, s_4197_3, s_4197_4, s_4197_5, s_4197_6)
        let s_4197_7: () = PMEVTYPER_SysRegWrite32_2577251aa43d9dc4(
            state,
            tracer,
            s_4197_0,
            s_4197_1,
            s_4197_2,
            s_4197_3,
            s_4197_4,
            s_4197_5,
            s_4197_6,
        );
        // N s_4197_8: return
        return;
    }
    fn block_4198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4198_0: read-var opc2:u8
        let s_4198_0: u8 = fn_state.opc2;
        // D s_4198_1: cast zx s_4198_0 -> bv
        let s_4198_1: Bits = Bits::new(s_4198_0 as u128, 3u16);
        // C s_4198_2: const #0u : u8
        let s_4198_2: u8 = 0;
        // C s_4198_3: cast zx s_4198_2 -> bv
        let s_4198_3: Bits = Bits::new(s_4198_2 as u128, 3u16);
        // D s_4198_4: cmp-eq s_4198_1 s_4198_3
        let s_4198_4: bool = ((s_4198_1) == (s_4198_3));
        // D s_4198_5: write-var gs#135703 <= s_4198_4
        fn_state.gs_135703 = s_4198_4;
        // N s_4198_6: jump b2753
        return block_2753(state, tracer, fn_state);
    }
    fn block_4199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4199_0: read-var opc1:u8
        let s_4199_0: u8 = fn_state.opc1;
        // D s_4199_1: cast zx s_4199_0 -> bv
        let s_4199_1: Bits = Bits::new(s_4199_0 as u128, 3u16);
        // C s_4199_2: const #0u : u8
        let s_4199_2: u8 = 0;
        // C s_4199_3: cast zx s_4199_2 -> bv
        let s_4199_3: Bits = Bits::new(s_4199_2 as u128, 3u16);
        // D s_4199_4: cmp-eq s_4199_1 s_4199_3
        let s_4199_4: bool = ((s_4199_1) == (s_4199_3));
        // D s_4199_5: write-var gs#135702 <= s_4199_4
        fn_state.gs_135702 = s_4199_4;
        // N s_4199_6: jump b2751
        return block_2751(state, tracer, fn_state);
    }
    fn block_4200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4200_0: read-var coproc:u8
        let s_4200_0: u8 = fn_state.coproc;
        // D s_4200_1: cast zx s_4200_0 -> bv
        let s_4200_1: Bits = Bits::new(s_4200_0 as u128, 4u16);
        // C s_4200_2: const #15u : u8
        let s_4200_2: u8 = 15;
        // C s_4200_3: cast zx s_4200_2 -> bv
        let s_4200_3: Bits = Bits::new(s_4200_2 as u128, 4u16);
        // D s_4200_4: cmp-eq s_4200_1 s_4200_3
        let s_4200_4: bool = ((s_4200_1) == (s_4200_3));
        // D s_4200_5: write-var gs#135701 <= s_4200_4
        fn_state.gs_135701 = s_4200_4;
        // N s_4200_6: jump b2749
        return block_2749(state, tracer, fn_state);
    }
    fn block_4201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4201_0: read-var CRn:u8
        let s_4201_0: u8 = fn_state.CRn;
        // D s_4201_1: cast zx s_4201_0 -> bv
        let s_4201_1: Bits = Bits::new(s_4201_0 as u128, 4u16);
        // C s_4201_2: const #14u : u8
        let s_4201_2: u8 = 14;
        // C s_4201_3: cast zx s_4201_2 -> bv
        let s_4201_3: Bits = Bits::new(s_4201_2 as u128, 4u16);
        // D s_4201_4: cmp-eq s_4201_1 s_4201_3
        let s_4201_4: bool = ((s_4201_1) == (s_4201_3));
        // D s_4201_5: write-var gs#135700 <= s_4201_4
        fn_state.gs_135700 = s_4201_4;
        // N s_4201_6: jump b2747
        return block_2747(state, tracer, fn_state);
    }
    fn block_4202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4202_0: read-var el:u8
        let s_4202_0: u8 = fn_state.el;
        // D s_4202_1: read-var coproc:u8
        let s_4202_1: u8 = fn_state.coproc;
        // D s_4202_2: read-var opc1:u8
        let s_4202_2: u8 = fn_state.opc1;
        // D s_4202_3: read-var CRn:u8
        let s_4202_3: u8 = fn_state.CRn;
        // D s_4202_4: read-var opc2:u8
        let s_4202_4: u8 = fn_state.opc2;
        // D s_4202_5: read-var CRm:u8
        let s_4202_5: u8 = fn_state.CRm;
        // D s_4202_6: read-var t:i
        let s_4202_6: i128 = fn_state.t;
        // D s_4202_7: call PMEVTYPER_SysRegWrite32_11835dd6069bfdf3(s_4202_0, s_4202_1, s_4202_2, s_4202_3, s_4202_4, s_4202_5, s_4202_6)
        let s_4202_7: () = PMEVTYPER_SysRegWrite32_11835dd6069bfdf3(
            state,
            tracer,
            s_4202_0,
            s_4202_1,
            s_4202_2,
            s_4202_3,
            s_4202_4,
            s_4202_5,
            s_4202_6,
        );
        // N s_4202_8: return
        return;
    }
    fn block_4203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4203_0: read-var opc2:u8
        let s_4203_0: u8 = fn_state.opc2;
        // D s_4203_1: cast zx s_4203_0 -> bv
        let s_4203_1: Bits = Bits::new(s_4203_0 as u128, 3u16);
        // C s_4203_2: const #1u : u8
        let s_4203_2: u8 = 1;
        // C s_4203_3: cast zx s_4203_2 -> bv
        let s_4203_3: Bits = Bits::new(s_4203_2 as u128, 3u16);
        // D s_4203_4: cmp-eq s_4203_1 s_4203_3
        let s_4203_4: bool = ((s_4203_1) == (s_4203_3));
        // D s_4203_5: write-var gs#135699 <= s_4203_4
        fn_state.gs_135699 = s_4203_4;
        // N s_4203_6: jump b2744
        return block_2744(state, tracer, fn_state);
    }
    fn block_4204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4204_0: read-var opc1:u8
        let s_4204_0: u8 = fn_state.opc1;
        // D s_4204_1: cast zx s_4204_0 -> bv
        let s_4204_1: Bits = Bits::new(s_4204_0 as u128, 3u16);
        // C s_4204_2: const #0u : u8
        let s_4204_2: u8 = 0;
        // C s_4204_3: cast zx s_4204_2 -> bv
        let s_4204_3: Bits = Bits::new(s_4204_2 as u128, 3u16);
        // D s_4204_4: cmp-eq s_4204_1 s_4204_3
        let s_4204_4: bool = ((s_4204_1) == (s_4204_3));
        // D s_4204_5: write-var gs#135698 <= s_4204_4
        fn_state.gs_135698 = s_4204_4;
        // N s_4204_6: jump b2742
        return block_2742(state, tracer, fn_state);
    }
    fn block_4205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4205_0: read-var coproc:u8
        let s_4205_0: u8 = fn_state.coproc;
        // D s_4205_1: cast zx s_4205_0 -> bv
        let s_4205_1: Bits = Bits::new(s_4205_0 as u128, 4u16);
        // C s_4205_2: const #15u : u8
        let s_4205_2: u8 = 15;
        // C s_4205_3: cast zx s_4205_2 -> bv
        let s_4205_3: Bits = Bits::new(s_4205_2 as u128, 4u16);
        // D s_4205_4: cmp-eq s_4205_1 s_4205_3
        let s_4205_4: bool = ((s_4205_1) == (s_4205_3));
        // D s_4205_5: write-var gs#135697 <= s_4205_4
        fn_state.gs_135697 = s_4205_4;
        // N s_4205_6: jump b2740
        return block_2740(state, tracer, fn_state);
    }
    fn block_4206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4206_0: read-var CRn:u8
        let s_4206_0: u8 = fn_state.CRn;
        // D s_4206_1: cast zx s_4206_0 -> bv
        let s_4206_1: Bits = Bits::new(s_4206_0 as u128, 4u16);
        // C s_4206_2: const #14u : u8
        let s_4206_2: u8 = 14;
        // C s_4206_3: cast zx s_4206_2 -> bv
        let s_4206_3: Bits = Bits::new(s_4206_2 as u128, 4u16);
        // D s_4206_4: cmp-eq s_4206_1 s_4206_3
        let s_4206_4: bool = ((s_4206_1) == (s_4206_3));
        // D s_4206_5: write-var gs#135696 <= s_4206_4
        fn_state.gs_135696 = s_4206_4;
        // N s_4206_6: jump b2738
        return block_2738(state, tracer, fn_state);
    }
    fn block_4207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4207_0: read-var el:u8
        let s_4207_0: u8 = fn_state.el;
        // D s_4207_1: read-var coproc:u8
        let s_4207_1: u8 = fn_state.coproc;
        // D s_4207_2: read-var opc1:u8
        let s_4207_2: u8 = fn_state.opc1;
        // D s_4207_3: read-var CRn:u8
        let s_4207_3: u8 = fn_state.CRn;
        // D s_4207_4: read-var opc2:u8
        let s_4207_4: u8 = fn_state.opc2;
        // D s_4207_5: read-var CRm:u8
        let s_4207_5: u8 = fn_state.CRm;
        // D s_4207_6: read-var t:i
        let s_4207_6: i128 = fn_state.t;
        // D s_4207_7: call PMEVTYPER_SysRegWrite32_3330ec8a9fad7b9b(s_4207_0, s_4207_1, s_4207_2, s_4207_3, s_4207_4, s_4207_5, s_4207_6)
        let s_4207_7: () = PMEVTYPER_SysRegWrite32_3330ec8a9fad7b9b(
            state,
            tracer,
            s_4207_0,
            s_4207_1,
            s_4207_2,
            s_4207_3,
            s_4207_4,
            s_4207_5,
            s_4207_6,
        );
        // N s_4207_8: return
        return;
    }
    fn block_4208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4208_0: read-var opc2:u8
        let s_4208_0: u8 = fn_state.opc2;
        // D s_4208_1: cast zx s_4208_0 -> bv
        let s_4208_1: Bits = Bits::new(s_4208_0 as u128, 3u16);
        // C s_4208_2: const #2u : u8
        let s_4208_2: u8 = 2;
        // C s_4208_3: cast zx s_4208_2 -> bv
        let s_4208_3: Bits = Bits::new(s_4208_2 as u128, 3u16);
        // D s_4208_4: cmp-eq s_4208_1 s_4208_3
        let s_4208_4: bool = ((s_4208_1) == (s_4208_3));
        // D s_4208_5: write-var gs#135695 <= s_4208_4
        fn_state.gs_135695 = s_4208_4;
        // N s_4208_6: jump b2735
        return block_2735(state, tracer, fn_state);
    }
    fn block_4209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4209_0: read-var opc1:u8
        let s_4209_0: u8 = fn_state.opc1;
        // D s_4209_1: cast zx s_4209_0 -> bv
        let s_4209_1: Bits = Bits::new(s_4209_0 as u128, 3u16);
        // C s_4209_2: const #0u : u8
        let s_4209_2: u8 = 0;
        // C s_4209_3: cast zx s_4209_2 -> bv
        let s_4209_3: Bits = Bits::new(s_4209_2 as u128, 3u16);
        // D s_4209_4: cmp-eq s_4209_1 s_4209_3
        let s_4209_4: bool = ((s_4209_1) == (s_4209_3));
        // D s_4209_5: write-var gs#135694 <= s_4209_4
        fn_state.gs_135694 = s_4209_4;
        // N s_4209_6: jump b2733
        return block_2733(state, tracer, fn_state);
    }
    fn block_4210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4210_0: read-var coproc:u8
        let s_4210_0: u8 = fn_state.coproc;
        // D s_4210_1: cast zx s_4210_0 -> bv
        let s_4210_1: Bits = Bits::new(s_4210_0 as u128, 4u16);
        // C s_4210_2: const #15u : u8
        let s_4210_2: u8 = 15;
        // C s_4210_3: cast zx s_4210_2 -> bv
        let s_4210_3: Bits = Bits::new(s_4210_2 as u128, 4u16);
        // D s_4210_4: cmp-eq s_4210_1 s_4210_3
        let s_4210_4: bool = ((s_4210_1) == (s_4210_3));
        // D s_4210_5: write-var gs#135693 <= s_4210_4
        fn_state.gs_135693 = s_4210_4;
        // N s_4210_6: jump b2731
        return block_2731(state, tracer, fn_state);
    }
    fn block_4211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4211_0: read-var CRn:u8
        let s_4211_0: u8 = fn_state.CRn;
        // D s_4211_1: cast zx s_4211_0 -> bv
        let s_4211_1: Bits = Bits::new(s_4211_0 as u128, 4u16);
        // C s_4211_2: const #14u : u8
        let s_4211_2: u8 = 14;
        // C s_4211_3: cast zx s_4211_2 -> bv
        let s_4211_3: Bits = Bits::new(s_4211_2 as u128, 4u16);
        // D s_4211_4: cmp-eq s_4211_1 s_4211_3
        let s_4211_4: bool = ((s_4211_1) == (s_4211_3));
        // D s_4211_5: write-var gs#135692 <= s_4211_4
        fn_state.gs_135692 = s_4211_4;
        // N s_4211_6: jump b2729
        return block_2729(state, tracer, fn_state);
    }
    fn block_4212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4212_0: read-var el:u8
        let s_4212_0: u8 = fn_state.el;
        // D s_4212_1: read-var coproc:u8
        let s_4212_1: u8 = fn_state.coproc;
        // D s_4212_2: read-var opc1:u8
        let s_4212_2: u8 = fn_state.opc1;
        // D s_4212_3: read-var CRn:u8
        let s_4212_3: u8 = fn_state.CRn;
        // D s_4212_4: read-var opc2:u8
        let s_4212_4: u8 = fn_state.opc2;
        // D s_4212_5: read-var CRm:u8
        let s_4212_5: u8 = fn_state.CRm;
        // D s_4212_6: read-var t:i
        let s_4212_6: i128 = fn_state.t;
        // D s_4212_7: call PMEVTYPER_SysRegWrite32_863b5087474e4a64(s_4212_0, s_4212_1, s_4212_2, s_4212_3, s_4212_4, s_4212_5, s_4212_6)
        let s_4212_7: () = PMEVTYPER_SysRegWrite32_863b5087474e4a64(
            state,
            tracer,
            s_4212_0,
            s_4212_1,
            s_4212_2,
            s_4212_3,
            s_4212_4,
            s_4212_5,
            s_4212_6,
        );
        // N s_4212_8: return
        return;
    }
    fn block_4213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4213_0: read-var opc2:u8
        let s_4213_0: u8 = fn_state.opc2;
        // D s_4213_1: cast zx s_4213_0 -> bv
        let s_4213_1: Bits = Bits::new(s_4213_0 as u128, 3u16);
        // C s_4213_2: const #3u : u8
        let s_4213_2: u8 = 3;
        // C s_4213_3: cast zx s_4213_2 -> bv
        let s_4213_3: Bits = Bits::new(s_4213_2 as u128, 3u16);
        // D s_4213_4: cmp-eq s_4213_1 s_4213_3
        let s_4213_4: bool = ((s_4213_1) == (s_4213_3));
        // D s_4213_5: write-var gs#135691 <= s_4213_4
        fn_state.gs_135691 = s_4213_4;
        // N s_4213_6: jump b2726
        return block_2726(state, tracer, fn_state);
    }
    fn block_4214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4214_0: read-var opc1:u8
        let s_4214_0: u8 = fn_state.opc1;
        // D s_4214_1: cast zx s_4214_0 -> bv
        let s_4214_1: Bits = Bits::new(s_4214_0 as u128, 3u16);
        // C s_4214_2: const #0u : u8
        let s_4214_2: u8 = 0;
        // C s_4214_3: cast zx s_4214_2 -> bv
        let s_4214_3: Bits = Bits::new(s_4214_2 as u128, 3u16);
        // D s_4214_4: cmp-eq s_4214_1 s_4214_3
        let s_4214_4: bool = ((s_4214_1) == (s_4214_3));
        // D s_4214_5: write-var gs#135690 <= s_4214_4
        fn_state.gs_135690 = s_4214_4;
        // N s_4214_6: jump b2724
        return block_2724(state, tracer, fn_state);
    }
    fn block_4215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4215_0: read-var coproc:u8
        let s_4215_0: u8 = fn_state.coproc;
        // D s_4215_1: cast zx s_4215_0 -> bv
        let s_4215_1: Bits = Bits::new(s_4215_0 as u128, 4u16);
        // C s_4215_2: const #15u : u8
        let s_4215_2: u8 = 15;
        // C s_4215_3: cast zx s_4215_2 -> bv
        let s_4215_3: Bits = Bits::new(s_4215_2 as u128, 4u16);
        // D s_4215_4: cmp-eq s_4215_1 s_4215_3
        let s_4215_4: bool = ((s_4215_1) == (s_4215_3));
        // D s_4215_5: write-var gs#135689 <= s_4215_4
        fn_state.gs_135689 = s_4215_4;
        // N s_4215_6: jump b2722
        return block_2722(state, tracer, fn_state);
    }
    fn block_4216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4216_0: read-var CRn:u8
        let s_4216_0: u8 = fn_state.CRn;
        // D s_4216_1: cast zx s_4216_0 -> bv
        let s_4216_1: Bits = Bits::new(s_4216_0 as u128, 4u16);
        // C s_4216_2: const #14u : u8
        let s_4216_2: u8 = 14;
        // C s_4216_3: cast zx s_4216_2 -> bv
        let s_4216_3: Bits = Bits::new(s_4216_2 as u128, 4u16);
        // D s_4216_4: cmp-eq s_4216_1 s_4216_3
        let s_4216_4: bool = ((s_4216_1) == (s_4216_3));
        // D s_4216_5: write-var gs#135688 <= s_4216_4
        fn_state.gs_135688 = s_4216_4;
        // N s_4216_6: jump b2720
        return block_2720(state, tracer, fn_state);
    }
    fn block_4217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4217_0: read-var el:u8
        let s_4217_0: u8 = fn_state.el;
        // D s_4217_1: read-var coproc:u8
        let s_4217_1: u8 = fn_state.coproc;
        // D s_4217_2: read-var opc1:u8
        let s_4217_2: u8 = fn_state.opc1;
        // D s_4217_3: read-var CRn:u8
        let s_4217_3: u8 = fn_state.CRn;
        // D s_4217_4: read-var opc2:u8
        let s_4217_4: u8 = fn_state.opc2;
        // D s_4217_5: read-var CRm:u8
        let s_4217_5: u8 = fn_state.CRm;
        // D s_4217_6: read-var t:i
        let s_4217_6: i128 = fn_state.t;
        // D s_4217_7: call PMEVTYPER_SysRegWrite32_4034283bec67f894(s_4217_0, s_4217_1, s_4217_2, s_4217_3, s_4217_4, s_4217_5, s_4217_6)
        let s_4217_7: () = PMEVTYPER_SysRegWrite32_4034283bec67f894(
            state,
            tracer,
            s_4217_0,
            s_4217_1,
            s_4217_2,
            s_4217_3,
            s_4217_4,
            s_4217_5,
            s_4217_6,
        );
        // N s_4217_8: return
        return;
    }
    fn block_4218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4218_0: read-var opc2:u8
        let s_4218_0: u8 = fn_state.opc2;
        // D s_4218_1: cast zx s_4218_0 -> bv
        let s_4218_1: Bits = Bits::new(s_4218_0 as u128, 3u16);
        // C s_4218_2: const #4u : u8
        let s_4218_2: u8 = 4;
        // C s_4218_3: cast zx s_4218_2 -> bv
        let s_4218_3: Bits = Bits::new(s_4218_2 as u128, 3u16);
        // D s_4218_4: cmp-eq s_4218_1 s_4218_3
        let s_4218_4: bool = ((s_4218_1) == (s_4218_3));
        // D s_4218_5: write-var gs#135687 <= s_4218_4
        fn_state.gs_135687 = s_4218_4;
        // N s_4218_6: jump b2717
        return block_2717(state, tracer, fn_state);
    }
    fn block_4219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4219_0: read-var opc1:u8
        let s_4219_0: u8 = fn_state.opc1;
        // D s_4219_1: cast zx s_4219_0 -> bv
        let s_4219_1: Bits = Bits::new(s_4219_0 as u128, 3u16);
        // C s_4219_2: const #0u : u8
        let s_4219_2: u8 = 0;
        // C s_4219_3: cast zx s_4219_2 -> bv
        let s_4219_3: Bits = Bits::new(s_4219_2 as u128, 3u16);
        // D s_4219_4: cmp-eq s_4219_1 s_4219_3
        let s_4219_4: bool = ((s_4219_1) == (s_4219_3));
        // D s_4219_5: write-var gs#135686 <= s_4219_4
        fn_state.gs_135686 = s_4219_4;
        // N s_4219_6: jump b2715
        return block_2715(state, tracer, fn_state);
    }
    fn block_4220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4220_0: read-var coproc:u8
        let s_4220_0: u8 = fn_state.coproc;
        // D s_4220_1: cast zx s_4220_0 -> bv
        let s_4220_1: Bits = Bits::new(s_4220_0 as u128, 4u16);
        // C s_4220_2: const #15u : u8
        let s_4220_2: u8 = 15;
        // C s_4220_3: cast zx s_4220_2 -> bv
        let s_4220_3: Bits = Bits::new(s_4220_2 as u128, 4u16);
        // D s_4220_4: cmp-eq s_4220_1 s_4220_3
        let s_4220_4: bool = ((s_4220_1) == (s_4220_3));
        // D s_4220_5: write-var gs#135685 <= s_4220_4
        fn_state.gs_135685 = s_4220_4;
        // N s_4220_6: jump b2713
        return block_2713(state, tracer, fn_state);
    }
    fn block_4221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4221_0: read-var CRn:u8
        let s_4221_0: u8 = fn_state.CRn;
        // D s_4221_1: cast zx s_4221_0 -> bv
        let s_4221_1: Bits = Bits::new(s_4221_0 as u128, 4u16);
        // C s_4221_2: const #14u : u8
        let s_4221_2: u8 = 14;
        // C s_4221_3: cast zx s_4221_2 -> bv
        let s_4221_3: Bits = Bits::new(s_4221_2 as u128, 4u16);
        // D s_4221_4: cmp-eq s_4221_1 s_4221_3
        let s_4221_4: bool = ((s_4221_1) == (s_4221_3));
        // D s_4221_5: write-var gs#135684 <= s_4221_4
        fn_state.gs_135684 = s_4221_4;
        // N s_4221_6: jump b2711
        return block_2711(state, tracer, fn_state);
    }
    fn block_4222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4222_0: read-var el:u8
        let s_4222_0: u8 = fn_state.el;
        // D s_4222_1: read-var coproc:u8
        let s_4222_1: u8 = fn_state.coproc;
        // D s_4222_2: read-var opc1:u8
        let s_4222_2: u8 = fn_state.opc1;
        // D s_4222_3: read-var CRn:u8
        let s_4222_3: u8 = fn_state.CRn;
        // D s_4222_4: read-var opc2:u8
        let s_4222_4: u8 = fn_state.opc2;
        // D s_4222_5: read-var CRm:u8
        let s_4222_5: u8 = fn_state.CRm;
        // D s_4222_6: read-var t:i
        let s_4222_6: i128 = fn_state.t;
        // D s_4222_7: call PMEVTYPER_SysRegWrite32_3fdce9a0d75c4d7a(s_4222_0, s_4222_1, s_4222_2, s_4222_3, s_4222_4, s_4222_5, s_4222_6)
        let s_4222_7: () = PMEVTYPER_SysRegWrite32_3fdce9a0d75c4d7a(
            state,
            tracer,
            s_4222_0,
            s_4222_1,
            s_4222_2,
            s_4222_3,
            s_4222_4,
            s_4222_5,
            s_4222_6,
        );
        // N s_4222_8: return
        return;
    }
    fn block_4223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4223_0: read-var opc2:u8
        let s_4223_0: u8 = fn_state.opc2;
        // D s_4223_1: cast zx s_4223_0 -> bv
        let s_4223_1: Bits = Bits::new(s_4223_0 as u128, 3u16);
        // C s_4223_2: const #5u : u8
        let s_4223_2: u8 = 5;
        // C s_4223_3: cast zx s_4223_2 -> bv
        let s_4223_3: Bits = Bits::new(s_4223_2 as u128, 3u16);
        // D s_4223_4: cmp-eq s_4223_1 s_4223_3
        let s_4223_4: bool = ((s_4223_1) == (s_4223_3));
        // D s_4223_5: write-var gs#135683 <= s_4223_4
        fn_state.gs_135683 = s_4223_4;
        // N s_4223_6: jump b2708
        return block_2708(state, tracer, fn_state);
    }
    fn block_4224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4224_0: read-var opc1:u8
        let s_4224_0: u8 = fn_state.opc1;
        // D s_4224_1: cast zx s_4224_0 -> bv
        let s_4224_1: Bits = Bits::new(s_4224_0 as u128, 3u16);
        // C s_4224_2: const #0u : u8
        let s_4224_2: u8 = 0;
        // C s_4224_3: cast zx s_4224_2 -> bv
        let s_4224_3: Bits = Bits::new(s_4224_2 as u128, 3u16);
        // D s_4224_4: cmp-eq s_4224_1 s_4224_3
        let s_4224_4: bool = ((s_4224_1) == (s_4224_3));
        // D s_4224_5: write-var gs#135682 <= s_4224_4
        fn_state.gs_135682 = s_4224_4;
        // N s_4224_6: jump b2706
        return block_2706(state, tracer, fn_state);
    }
    fn block_4225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4225_0: read-var coproc:u8
        let s_4225_0: u8 = fn_state.coproc;
        // D s_4225_1: cast zx s_4225_0 -> bv
        let s_4225_1: Bits = Bits::new(s_4225_0 as u128, 4u16);
        // C s_4225_2: const #15u : u8
        let s_4225_2: u8 = 15;
        // C s_4225_3: cast zx s_4225_2 -> bv
        let s_4225_3: Bits = Bits::new(s_4225_2 as u128, 4u16);
        // D s_4225_4: cmp-eq s_4225_1 s_4225_3
        let s_4225_4: bool = ((s_4225_1) == (s_4225_3));
        // D s_4225_5: write-var gs#135681 <= s_4225_4
        fn_state.gs_135681 = s_4225_4;
        // N s_4225_6: jump b2704
        return block_2704(state, tracer, fn_state);
    }
    fn block_4226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4226_0: read-var CRn:u8
        let s_4226_0: u8 = fn_state.CRn;
        // D s_4226_1: cast zx s_4226_0 -> bv
        let s_4226_1: Bits = Bits::new(s_4226_0 as u128, 4u16);
        // C s_4226_2: const #14u : u8
        let s_4226_2: u8 = 14;
        // C s_4226_3: cast zx s_4226_2 -> bv
        let s_4226_3: Bits = Bits::new(s_4226_2 as u128, 4u16);
        // D s_4226_4: cmp-eq s_4226_1 s_4226_3
        let s_4226_4: bool = ((s_4226_1) == (s_4226_3));
        // D s_4226_5: write-var gs#135680 <= s_4226_4
        fn_state.gs_135680 = s_4226_4;
        // N s_4226_6: jump b2702
        return block_2702(state, tracer, fn_state);
    }
    fn block_4227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4227_0: read-var el:u8
        let s_4227_0: u8 = fn_state.el;
        // D s_4227_1: read-var coproc:u8
        let s_4227_1: u8 = fn_state.coproc;
        // D s_4227_2: read-var opc1:u8
        let s_4227_2: u8 = fn_state.opc1;
        // D s_4227_3: read-var CRn:u8
        let s_4227_3: u8 = fn_state.CRn;
        // D s_4227_4: read-var opc2:u8
        let s_4227_4: u8 = fn_state.opc2;
        // D s_4227_5: read-var CRm:u8
        let s_4227_5: u8 = fn_state.CRm;
        // D s_4227_6: read-var t:i
        let s_4227_6: i128 = fn_state.t;
        // D s_4227_7: call PMEVTYPER_SysRegWrite32_73416eaea2ea531d(s_4227_0, s_4227_1, s_4227_2, s_4227_3, s_4227_4, s_4227_5, s_4227_6)
        let s_4227_7: () = PMEVTYPER_SysRegWrite32_73416eaea2ea531d(
            state,
            tracer,
            s_4227_0,
            s_4227_1,
            s_4227_2,
            s_4227_3,
            s_4227_4,
            s_4227_5,
            s_4227_6,
        );
        // N s_4227_8: return
        return;
    }
    fn block_4228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4228_0: read-var opc2:u8
        let s_4228_0: u8 = fn_state.opc2;
        // D s_4228_1: cast zx s_4228_0 -> bv
        let s_4228_1: Bits = Bits::new(s_4228_0 as u128, 3u16);
        // C s_4228_2: const #6u : u8
        let s_4228_2: u8 = 6;
        // C s_4228_3: cast zx s_4228_2 -> bv
        let s_4228_3: Bits = Bits::new(s_4228_2 as u128, 3u16);
        // D s_4228_4: cmp-eq s_4228_1 s_4228_3
        let s_4228_4: bool = ((s_4228_1) == (s_4228_3));
        // D s_4228_5: write-var gs#135679 <= s_4228_4
        fn_state.gs_135679 = s_4228_4;
        // N s_4228_6: jump b2699
        return block_2699(state, tracer, fn_state);
    }
    fn block_4229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4229_0: read-var opc1:u8
        let s_4229_0: u8 = fn_state.opc1;
        // D s_4229_1: cast zx s_4229_0 -> bv
        let s_4229_1: Bits = Bits::new(s_4229_0 as u128, 3u16);
        // C s_4229_2: const #0u : u8
        let s_4229_2: u8 = 0;
        // C s_4229_3: cast zx s_4229_2 -> bv
        let s_4229_3: Bits = Bits::new(s_4229_2 as u128, 3u16);
        // D s_4229_4: cmp-eq s_4229_1 s_4229_3
        let s_4229_4: bool = ((s_4229_1) == (s_4229_3));
        // D s_4229_5: write-var gs#135678 <= s_4229_4
        fn_state.gs_135678 = s_4229_4;
        // N s_4229_6: jump b2697
        return block_2697(state, tracer, fn_state);
    }
    fn block_4230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4230_0: read-var coproc:u8
        let s_4230_0: u8 = fn_state.coproc;
        // D s_4230_1: cast zx s_4230_0 -> bv
        let s_4230_1: Bits = Bits::new(s_4230_0 as u128, 4u16);
        // C s_4230_2: const #15u : u8
        let s_4230_2: u8 = 15;
        // C s_4230_3: cast zx s_4230_2 -> bv
        let s_4230_3: Bits = Bits::new(s_4230_2 as u128, 4u16);
        // D s_4230_4: cmp-eq s_4230_1 s_4230_3
        let s_4230_4: bool = ((s_4230_1) == (s_4230_3));
        // D s_4230_5: write-var gs#135677 <= s_4230_4
        fn_state.gs_135677 = s_4230_4;
        // N s_4230_6: jump b2695
        return block_2695(state, tracer, fn_state);
    }
    fn block_4231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4231_0: read-var CRn:u8
        let s_4231_0: u8 = fn_state.CRn;
        // D s_4231_1: cast zx s_4231_0 -> bv
        let s_4231_1: Bits = Bits::new(s_4231_0 as u128, 4u16);
        // C s_4231_2: const #14u : u8
        let s_4231_2: u8 = 14;
        // C s_4231_3: cast zx s_4231_2 -> bv
        let s_4231_3: Bits = Bits::new(s_4231_2 as u128, 4u16);
        // D s_4231_4: cmp-eq s_4231_1 s_4231_3
        let s_4231_4: bool = ((s_4231_1) == (s_4231_3));
        // D s_4231_5: write-var gs#135676 <= s_4231_4
        fn_state.gs_135676 = s_4231_4;
        // N s_4231_6: jump b2693
        return block_2693(state, tracer, fn_state);
    }
    fn block_4232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4232_0: read-var el:u8
        let s_4232_0: u8 = fn_state.el;
        // D s_4232_1: read-var coproc:u8
        let s_4232_1: u8 = fn_state.coproc;
        // D s_4232_2: read-var opc1:u8
        let s_4232_2: u8 = fn_state.opc1;
        // D s_4232_3: read-var CRn:u8
        let s_4232_3: u8 = fn_state.CRn;
        // D s_4232_4: read-var opc2:u8
        let s_4232_4: u8 = fn_state.opc2;
        // D s_4232_5: read-var CRm:u8
        let s_4232_5: u8 = fn_state.CRm;
        // D s_4232_6: read-var t:i
        let s_4232_6: i128 = fn_state.t;
        // D s_4232_7: call PMEVTYPER_SysRegWrite32_1c8ef4dc87b91a11(s_4232_0, s_4232_1, s_4232_2, s_4232_3, s_4232_4, s_4232_5, s_4232_6)
        let s_4232_7: () = PMEVTYPER_SysRegWrite32_1c8ef4dc87b91a11(
            state,
            tracer,
            s_4232_0,
            s_4232_1,
            s_4232_2,
            s_4232_3,
            s_4232_4,
            s_4232_5,
            s_4232_6,
        );
        // N s_4232_8: return
        return;
    }
    fn block_4233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4233_0: read-var opc2:u8
        let s_4233_0: u8 = fn_state.opc2;
        // D s_4233_1: cast zx s_4233_0 -> bv
        let s_4233_1: Bits = Bits::new(s_4233_0 as u128, 3u16);
        // C s_4233_2: const #7u : u8
        let s_4233_2: u8 = 7;
        // C s_4233_3: cast zx s_4233_2 -> bv
        let s_4233_3: Bits = Bits::new(s_4233_2 as u128, 3u16);
        // D s_4233_4: cmp-eq s_4233_1 s_4233_3
        let s_4233_4: bool = ((s_4233_1) == (s_4233_3));
        // D s_4233_5: write-var gs#135675 <= s_4233_4
        fn_state.gs_135675 = s_4233_4;
        // N s_4233_6: jump b2690
        return block_2690(state, tracer, fn_state);
    }
    fn block_4234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4234_0: read-var opc1:u8
        let s_4234_0: u8 = fn_state.opc1;
        // D s_4234_1: cast zx s_4234_0 -> bv
        let s_4234_1: Bits = Bits::new(s_4234_0 as u128, 3u16);
        // C s_4234_2: const #0u : u8
        let s_4234_2: u8 = 0;
        // C s_4234_3: cast zx s_4234_2 -> bv
        let s_4234_3: Bits = Bits::new(s_4234_2 as u128, 3u16);
        // D s_4234_4: cmp-eq s_4234_1 s_4234_3
        let s_4234_4: bool = ((s_4234_1) == (s_4234_3));
        // D s_4234_5: write-var gs#135674 <= s_4234_4
        fn_state.gs_135674 = s_4234_4;
        // N s_4234_6: jump b2688
        return block_2688(state, tracer, fn_state);
    }
    fn block_4235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4235_0: read-var coproc:u8
        let s_4235_0: u8 = fn_state.coproc;
        // D s_4235_1: cast zx s_4235_0 -> bv
        let s_4235_1: Bits = Bits::new(s_4235_0 as u128, 4u16);
        // C s_4235_2: const #15u : u8
        let s_4235_2: u8 = 15;
        // C s_4235_3: cast zx s_4235_2 -> bv
        let s_4235_3: Bits = Bits::new(s_4235_2 as u128, 4u16);
        // D s_4235_4: cmp-eq s_4235_1 s_4235_3
        let s_4235_4: bool = ((s_4235_1) == (s_4235_3));
        // D s_4235_5: write-var gs#135673 <= s_4235_4
        fn_state.gs_135673 = s_4235_4;
        // N s_4235_6: jump b2686
        return block_2686(state, tracer, fn_state);
    }
    fn block_4236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4236_0: read-var CRn:u8
        let s_4236_0: u8 = fn_state.CRn;
        // D s_4236_1: cast zx s_4236_0 -> bv
        let s_4236_1: Bits = Bits::new(s_4236_0 as u128, 4u16);
        // C s_4236_2: const #14u : u8
        let s_4236_2: u8 = 14;
        // C s_4236_3: cast zx s_4236_2 -> bv
        let s_4236_3: Bits = Bits::new(s_4236_2 as u128, 4u16);
        // D s_4236_4: cmp-eq s_4236_1 s_4236_3
        let s_4236_4: bool = ((s_4236_1) == (s_4236_3));
        // D s_4236_5: write-var gs#135672 <= s_4236_4
        fn_state.gs_135672 = s_4236_4;
        // N s_4236_6: jump b2684
        return block_2684(state, tracer, fn_state);
    }
    fn block_4237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4237_0: read-var el:u8
        let s_4237_0: u8 = fn_state.el;
        // D s_4237_1: read-var coproc:u8
        let s_4237_1: u8 = fn_state.coproc;
        // D s_4237_2: read-var opc1:u8
        let s_4237_2: u8 = fn_state.opc1;
        // D s_4237_3: read-var CRn:u8
        let s_4237_3: u8 = fn_state.CRn;
        // D s_4237_4: read-var opc2:u8
        let s_4237_4: u8 = fn_state.opc2;
        // D s_4237_5: read-var CRm:u8
        let s_4237_5: u8 = fn_state.CRm;
        // D s_4237_6: read-var t:i
        let s_4237_6: i128 = fn_state.t;
        // D s_4237_7: call PMEVTYPER_SysRegWrite32_944684756672e51b(s_4237_0, s_4237_1, s_4237_2, s_4237_3, s_4237_4, s_4237_5, s_4237_6)
        let s_4237_7: () = PMEVTYPER_SysRegWrite32_944684756672e51b(
            state,
            tracer,
            s_4237_0,
            s_4237_1,
            s_4237_2,
            s_4237_3,
            s_4237_4,
            s_4237_5,
            s_4237_6,
        );
        // N s_4237_8: return
        return;
    }
    fn block_4238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4238_0: read-var opc2:u8
        let s_4238_0: u8 = fn_state.opc2;
        // D s_4238_1: cast zx s_4238_0 -> bv
        let s_4238_1: Bits = Bits::new(s_4238_0 as u128, 3u16);
        // C s_4238_2: const #0u : u8
        let s_4238_2: u8 = 0;
        // C s_4238_3: cast zx s_4238_2 -> bv
        let s_4238_3: Bits = Bits::new(s_4238_2 as u128, 3u16);
        // D s_4238_4: cmp-eq s_4238_1 s_4238_3
        let s_4238_4: bool = ((s_4238_1) == (s_4238_3));
        // D s_4238_5: write-var gs#135671 <= s_4238_4
        fn_state.gs_135671 = s_4238_4;
        // N s_4238_6: jump b2681
        return block_2681(state, tracer, fn_state);
    }
    fn block_4239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4239_0: read-var opc1:u8
        let s_4239_0: u8 = fn_state.opc1;
        // D s_4239_1: cast zx s_4239_0 -> bv
        let s_4239_1: Bits = Bits::new(s_4239_0 as u128, 3u16);
        // C s_4239_2: const #0u : u8
        let s_4239_2: u8 = 0;
        // C s_4239_3: cast zx s_4239_2 -> bv
        let s_4239_3: Bits = Bits::new(s_4239_2 as u128, 3u16);
        // D s_4239_4: cmp-eq s_4239_1 s_4239_3
        let s_4239_4: bool = ((s_4239_1) == (s_4239_3));
        // D s_4239_5: write-var gs#135670 <= s_4239_4
        fn_state.gs_135670 = s_4239_4;
        // N s_4239_6: jump b2679
        return block_2679(state, tracer, fn_state);
    }
    fn block_4240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4240_0: read-var coproc:u8
        let s_4240_0: u8 = fn_state.coproc;
        // D s_4240_1: cast zx s_4240_0 -> bv
        let s_4240_1: Bits = Bits::new(s_4240_0 as u128, 4u16);
        // C s_4240_2: const #15u : u8
        let s_4240_2: u8 = 15;
        // C s_4240_3: cast zx s_4240_2 -> bv
        let s_4240_3: Bits = Bits::new(s_4240_2 as u128, 4u16);
        // D s_4240_4: cmp-eq s_4240_1 s_4240_3
        let s_4240_4: bool = ((s_4240_1) == (s_4240_3));
        // D s_4240_5: write-var gs#135669 <= s_4240_4
        fn_state.gs_135669 = s_4240_4;
        // N s_4240_6: jump b2677
        return block_2677(state, tracer, fn_state);
    }
    fn block_4241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4241_0: read-var CRn:u8
        let s_4241_0: u8 = fn_state.CRn;
        // D s_4241_1: cast zx s_4241_0 -> bv
        let s_4241_1: Bits = Bits::new(s_4241_0 as u128, 4u16);
        // C s_4241_2: const #14u : u8
        let s_4241_2: u8 = 14;
        // C s_4241_3: cast zx s_4241_2 -> bv
        let s_4241_3: Bits = Bits::new(s_4241_2 as u128, 4u16);
        // D s_4241_4: cmp-eq s_4241_1 s_4241_3
        let s_4241_4: bool = ((s_4241_1) == (s_4241_3));
        // D s_4241_5: write-var gs#135668 <= s_4241_4
        fn_state.gs_135668 = s_4241_4;
        // N s_4241_6: jump b2675
        return block_2675(state, tracer, fn_state);
    }
    fn block_4242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4242_0: read-var el:u8
        let s_4242_0: u8 = fn_state.el;
        // D s_4242_1: read-var coproc:u8
        let s_4242_1: u8 = fn_state.coproc;
        // D s_4242_2: read-var opc1:u8
        let s_4242_2: u8 = fn_state.opc1;
        // D s_4242_3: read-var CRn:u8
        let s_4242_3: u8 = fn_state.CRn;
        // D s_4242_4: read-var opc2:u8
        let s_4242_4: u8 = fn_state.opc2;
        // D s_4242_5: read-var CRm:u8
        let s_4242_5: u8 = fn_state.CRm;
        // D s_4242_6: read-var t:i
        let s_4242_6: i128 = fn_state.t;
        // D s_4242_7: call PMEVTYPER_SysRegWrite32_59d93d7cd130a144(s_4242_0, s_4242_1, s_4242_2, s_4242_3, s_4242_4, s_4242_5, s_4242_6)
        let s_4242_7: () = PMEVTYPER_SysRegWrite32_59d93d7cd130a144(
            state,
            tracer,
            s_4242_0,
            s_4242_1,
            s_4242_2,
            s_4242_3,
            s_4242_4,
            s_4242_5,
            s_4242_6,
        );
        // N s_4242_8: return
        return;
    }
    fn block_4243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4243_0: read-var opc2:u8
        let s_4243_0: u8 = fn_state.opc2;
        // D s_4243_1: cast zx s_4243_0 -> bv
        let s_4243_1: Bits = Bits::new(s_4243_0 as u128, 3u16);
        // C s_4243_2: const #1u : u8
        let s_4243_2: u8 = 1;
        // C s_4243_3: cast zx s_4243_2 -> bv
        let s_4243_3: Bits = Bits::new(s_4243_2 as u128, 3u16);
        // D s_4243_4: cmp-eq s_4243_1 s_4243_3
        let s_4243_4: bool = ((s_4243_1) == (s_4243_3));
        // D s_4243_5: write-var gs#135667 <= s_4243_4
        fn_state.gs_135667 = s_4243_4;
        // N s_4243_6: jump b2672
        return block_2672(state, tracer, fn_state);
    }
    fn block_4244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4244_0: read-var opc1:u8
        let s_4244_0: u8 = fn_state.opc1;
        // D s_4244_1: cast zx s_4244_0 -> bv
        let s_4244_1: Bits = Bits::new(s_4244_0 as u128, 3u16);
        // C s_4244_2: const #0u : u8
        let s_4244_2: u8 = 0;
        // C s_4244_3: cast zx s_4244_2 -> bv
        let s_4244_3: Bits = Bits::new(s_4244_2 as u128, 3u16);
        // D s_4244_4: cmp-eq s_4244_1 s_4244_3
        let s_4244_4: bool = ((s_4244_1) == (s_4244_3));
        // D s_4244_5: write-var gs#135666 <= s_4244_4
        fn_state.gs_135666 = s_4244_4;
        // N s_4244_6: jump b2670
        return block_2670(state, tracer, fn_state);
    }
    fn block_4245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4245_0: read-var coproc:u8
        let s_4245_0: u8 = fn_state.coproc;
        // D s_4245_1: cast zx s_4245_0 -> bv
        let s_4245_1: Bits = Bits::new(s_4245_0 as u128, 4u16);
        // C s_4245_2: const #15u : u8
        let s_4245_2: u8 = 15;
        // C s_4245_3: cast zx s_4245_2 -> bv
        let s_4245_3: Bits = Bits::new(s_4245_2 as u128, 4u16);
        // D s_4245_4: cmp-eq s_4245_1 s_4245_3
        let s_4245_4: bool = ((s_4245_1) == (s_4245_3));
        // D s_4245_5: write-var gs#135665 <= s_4245_4
        fn_state.gs_135665 = s_4245_4;
        // N s_4245_6: jump b2668
        return block_2668(state, tracer, fn_state);
    }
    fn block_4246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4246_0: read-var CRn:u8
        let s_4246_0: u8 = fn_state.CRn;
        // D s_4246_1: cast zx s_4246_0 -> bv
        let s_4246_1: Bits = Bits::new(s_4246_0 as u128, 4u16);
        // C s_4246_2: const #14u : u8
        let s_4246_2: u8 = 14;
        // C s_4246_3: cast zx s_4246_2 -> bv
        let s_4246_3: Bits = Bits::new(s_4246_2 as u128, 4u16);
        // D s_4246_4: cmp-eq s_4246_1 s_4246_3
        let s_4246_4: bool = ((s_4246_1) == (s_4246_3));
        // D s_4246_5: write-var gs#135664 <= s_4246_4
        fn_state.gs_135664 = s_4246_4;
        // N s_4246_6: jump b2666
        return block_2666(state, tracer, fn_state);
    }
    fn block_4247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4247_0: read-var el:u8
        let s_4247_0: u8 = fn_state.el;
        // D s_4247_1: read-var coproc:u8
        let s_4247_1: u8 = fn_state.coproc;
        // D s_4247_2: read-var opc1:u8
        let s_4247_2: u8 = fn_state.opc1;
        // D s_4247_3: read-var CRn:u8
        let s_4247_3: u8 = fn_state.CRn;
        // D s_4247_4: read-var opc2:u8
        let s_4247_4: u8 = fn_state.opc2;
        // D s_4247_5: read-var CRm:u8
        let s_4247_5: u8 = fn_state.CRm;
        // D s_4247_6: read-var t:i
        let s_4247_6: i128 = fn_state.t;
        // D s_4247_7: call PMEVTYPER_SysRegWrite32_7a2ddec1dbe177e8(s_4247_0, s_4247_1, s_4247_2, s_4247_3, s_4247_4, s_4247_5, s_4247_6)
        let s_4247_7: () = PMEVTYPER_SysRegWrite32_7a2ddec1dbe177e8(
            state,
            tracer,
            s_4247_0,
            s_4247_1,
            s_4247_2,
            s_4247_3,
            s_4247_4,
            s_4247_5,
            s_4247_6,
        );
        // N s_4247_8: return
        return;
    }
    fn block_4248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4248_0: read-var opc2:u8
        let s_4248_0: u8 = fn_state.opc2;
        // D s_4248_1: cast zx s_4248_0 -> bv
        let s_4248_1: Bits = Bits::new(s_4248_0 as u128, 3u16);
        // C s_4248_2: const #2u : u8
        let s_4248_2: u8 = 2;
        // C s_4248_3: cast zx s_4248_2 -> bv
        let s_4248_3: Bits = Bits::new(s_4248_2 as u128, 3u16);
        // D s_4248_4: cmp-eq s_4248_1 s_4248_3
        let s_4248_4: bool = ((s_4248_1) == (s_4248_3));
        // D s_4248_5: write-var gs#135663 <= s_4248_4
        fn_state.gs_135663 = s_4248_4;
        // N s_4248_6: jump b2663
        return block_2663(state, tracer, fn_state);
    }
    fn block_4249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4249_0: read-var opc1:u8
        let s_4249_0: u8 = fn_state.opc1;
        // D s_4249_1: cast zx s_4249_0 -> bv
        let s_4249_1: Bits = Bits::new(s_4249_0 as u128, 3u16);
        // C s_4249_2: const #0u : u8
        let s_4249_2: u8 = 0;
        // C s_4249_3: cast zx s_4249_2 -> bv
        let s_4249_3: Bits = Bits::new(s_4249_2 as u128, 3u16);
        // D s_4249_4: cmp-eq s_4249_1 s_4249_3
        let s_4249_4: bool = ((s_4249_1) == (s_4249_3));
        // D s_4249_5: write-var gs#135662 <= s_4249_4
        fn_state.gs_135662 = s_4249_4;
        // N s_4249_6: jump b2661
        return block_2661(state, tracer, fn_state);
    }
    fn block_4250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4250_0: read-var coproc:u8
        let s_4250_0: u8 = fn_state.coproc;
        // D s_4250_1: cast zx s_4250_0 -> bv
        let s_4250_1: Bits = Bits::new(s_4250_0 as u128, 4u16);
        // C s_4250_2: const #15u : u8
        let s_4250_2: u8 = 15;
        // C s_4250_3: cast zx s_4250_2 -> bv
        let s_4250_3: Bits = Bits::new(s_4250_2 as u128, 4u16);
        // D s_4250_4: cmp-eq s_4250_1 s_4250_3
        let s_4250_4: bool = ((s_4250_1) == (s_4250_3));
        // D s_4250_5: write-var gs#135661 <= s_4250_4
        fn_state.gs_135661 = s_4250_4;
        // N s_4250_6: jump b2659
        return block_2659(state, tracer, fn_state);
    }
    fn block_4251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4251_0: read-var CRn:u8
        let s_4251_0: u8 = fn_state.CRn;
        // D s_4251_1: cast zx s_4251_0 -> bv
        let s_4251_1: Bits = Bits::new(s_4251_0 as u128, 4u16);
        // C s_4251_2: const #14u : u8
        let s_4251_2: u8 = 14;
        // C s_4251_3: cast zx s_4251_2 -> bv
        let s_4251_3: Bits = Bits::new(s_4251_2 as u128, 4u16);
        // D s_4251_4: cmp-eq s_4251_1 s_4251_3
        let s_4251_4: bool = ((s_4251_1) == (s_4251_3));
        // D s_4251_5: write-var gs#135660 <= s_4251_4
        fn_state.gs_135660 = s_4251_4;
        // N s_4251_6: jump b2657
        return block_2657(state, tracer, fn_state);
    }
    fn block_4252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4252_0: read-var el:u8
        let s_4252_0: u8 = fn_state.el;
        // D s_4252_1: read-var coproc:u8
        let s_4252_1: u8 = fn_state.coproc;
        // D s_4252_2: read-var opc1:u8
        let s_4252_2: u8 = fn_state.opc1;
        // D s_4252_3: read-var CRn:u8
        let s_4252_3: u8 = fn_state.CRn;
        // D s_4252_4: read-var opc2:u8
        let s_4252_4: u8 = fn_state.opc2;
        // D s_4252_5: read-var CRm:u8
        let s_4252_5: u8 = fn_state.CRm;
        // D s_4252_6: read-var t:i
        let s_4252_6: i128 = fn_state.t;
        // D s_4252_7: call PMEVTYPER_SysRegWrite32_6446dee6893e6f0c(s_4252_0, s_4252_1, s_4252_2, s_4252_3, s_4252_4, s_4252_5, s_4252_6)
        let s_4252_7: () = PMEVTYPER_SysRegWrite32_6446dee6893e6f0c(
            state,
            tracer,
            s_4252_0,
            s_4252_1,
            s_4252_2,
            s_4252_3,
            s_4252_4,
            s_4252_5,
            s_4252_6,
        );
        // N s_4252_8: return
        return;
    }
    fn block_4253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4253_0: read-var opc2:u8
        let s_4253_0: u8 = fn_state.opc2;
        // D s_4253_1: cast zx s_4253_0 -> bv
        let s_4253_1: Bits = Bits::new(s_4253_0 as u128, 3u16);
        // C s_4253_2: const #3u : u8
        let s_4253_2: u8 = 3;
        // C s_4253_3: cast zx s_4253_2 -> bv
        let s_4253_3: Bits = Bits::new(s_4253_2 as u128, 3u16);
        // D s_4253_4: cmp-eq s_4253_1 s_4253_3
        let s_4253_4: bool = ((s_4253_1) == (s_4253_3));
        // D s_4253_5: write-var gs#135659 <= s_4253_4
        fn_state.gs_135659 = s_4253_4;
        // N s_4253_6: jump b2654
        return block_2654(state, tracer, fn_state);
    }
    fn block_4254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4254_0: read-var opc1:u8
        let s_4254_0: u8 = fn_state.opc1;
        // D s_4254_1: cast zx s_4254_0 -> bv
        let s_4254_1: Bits = Bits::new(s_4254_0 as u128, 3u16);
        // C s_4254_2: const #0u : u8
        let s_4254_2: u8 = 0;
        // C s_4254_3: cast zx s_4254_2 -> bv
        let s_4254_3: Bits = Bits::new(s_4254_2 as u128, 3u16);
        // D s_4254_4: cmp-eq s_4254_1 s_4254_3
        let s_4254_4: bool = ((s_4254_1) == (s_4254_3));
        // D s_4254_5: write-var gs#135658 <= s_4254_4
        fn_state.gs_135658 = s_4254_4;
        // N s_4254_6: jump b2652
        return block_2652(state, tracer, fn_state);
    }
    fn block_4255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4255_0: read-var coproc:u8
        let s_4255_0: u8 = fn_state.coproc;
        // D s_4255_1: cast zx s_4255_0 -> bv
        let s_4255_1: Bits = Bits::new(s_4255_0 as u128, 4u16);
        // C s_4255_2: const #15u : u8
        let s_4255_2: u8 = 15;
        // C s_4255_3: cast zx s_4255_2 -> bv
        let s_4255_3: Bits = Bits::new(s_4255_2 as u128, 4u16);
        // D s_4255_4: cmp-eq s_4255_1 s_4255_3
        let s_4255_4: bool = ((s_4255_1) == (s_4255_3));
        // D s_4255_5: write-var gs#135657 <= s_4255_4
        fn_state.gs_135657 = s_4255_4;
        // N s_4255_6: jump b2650
        return block_2650(state, tracer, fn_state);
    }
    fn block_4256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4256_0: read-var CRn:u8
        let s_4256_0: u8 = fn_state.CRn;
        // D s_4256_1: cast zx s_4256_0 -> bv
        let s_4256_1: Bits = Bits::new(s_4256_0 as u128, 4u16);
        // C s_4256_2: const #14u : u8
        let s_4256_2: u8 = 14;
        // C s_4256_3: cast zx s_4256_2 -> bv
        let s_4256_3: Bits = Bits::new(s_4256_2 as u128, 4u16);
        // D s_4256_4: cmp-eq s_4256_1 s_4256_3
        let s_4256_4: bool = ((s_4256_1) == (s_4256_3));
        // D s_4256_5: write-var gs#135656 <= s_4256_4
        fn_state.gs_135656 = s_4256_4;
        // N s_4256_6: jump b2648
        return block_2648(state, tracer, fn_state);
    }
    fn block_4257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4257_0: read-var el:u8
        let s_4257_0: u8 = fn_state.el;
        // D s_4257_1: read-var coproc:u8
        let s_4257_1: u8 = fn_state.coproc;
        // D s_4257_2: read-var opc1:u8
        let s_4257_2: u8 = fn_state.opc1;
        // D s_4257_3: read-var CRn:u8
        let s_4257_3: u8 = fn_state.CRn;
        // D s_4257_4: read-var opc2:u8
        let s_4257_4: u8 = fn_state.opc2;
        // D s_4257_5: read-var CRm:u8
        let s_4257_5: u8 = fn_state.CRm;
        // D s_4257_6: read-var t:i
        let s_4257_6: i128 = fn_state.t;
        // D s_4257_7: call PMEVTYPER_SysRegWrite32_1acb3b092d3b80ff(s_4257_0, s_4257_1, s_4257_2, s_4257_3, s_4257_4, s_4257_5, s_4257_6)
        let s_4257_7: () = PMEVTYPER_SysRegWrite32_1acb3b092d3b80ff(
            state,
            tracer,
            s_4257_0,
            s_4257_1,
            s_4257_2,
            s_4257_3,
            s_4257_4,
            s_4257_5,
            s_4257_6,
        );
        // N s_4257_8: return
        return;
    }
    fn block_4258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4258_0: read-var opc2:u8
        let s_4258_0: u8 = fn_state.opc2;
        // D s_4258_1: cast zx s_4258_0 -> bv
        let s_4258_1: Bits = Bits::new(s_4258_0 as u128, 3u16);
        // C s_4258_2: const #4u : u8
        let s_4258_2: u8 = 4;
        // C s_4258_3: cast zx s_4258_2 -> bv
        let s_4258_3: Bits = Bits::new(s_4258_2 as u128, 3u16);
        // D s_4258_4: cmp-eq s_4258_1 s_4258_3
        let s_4258_4: bool = ((s_4258_1) == (s_4258_3));
        // D s_4258_5: write-var gs#135655 <= s_4258_4
        fn_state.gs_135655 = s_4258_4;
        // N s_4258_6: jump b2645
        return block_2645(state, tracer, fn_state);
    }
    fn block_4259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4259_0: read-var opc1:u8
        let s_4259_0: u8 = fn_state.opc1;
        // D s_4259_1: cast zx s_4259_0 -> bv
        let s_4259_1: Bits = Bits::new(s_4259_0 as u128, 3u16);
        // C s_4259_2: const #0u : u8
        let s_4259_2: u8 = 0;
        // C s_4259_3: cast zx s_4259_2 -> bv
        let s_4259_3: Bits = Bits::new(s_4259_2 as u128, 3u16);
        // D s_4259_4: cmp-eq s_4259_1 s_4259_3
        let s_4259_4: bool = ((s_4259_1) == (s_4259_3));
        // D s_4259_5: write-var gs#135654 <= s_4259_4
        fn_state.gs_135654 = s_4259_4;
        // N s_4259_6: jump b2643
        return block_2643(state, tracer, fn_state);
    }
    fn block_4260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4260_0: read-var coproc:u8
        let s_4260_0: u8 = fn_state.coproc;
        // D s_4260_1: cast zx s_4260_0 -> bv
        let s_4260_1: Bits = Bits::new(s_4260_0 as u128, 4u16);
        // C s_4260_2: const #15u : u8
        let s_4260_2: u8 = 15;
        // C s_4260_3: cast zx s_4260_2 -> bv
        let s_4260_3: Bits = Bits::new(s_4260_2 as u128, 4u16);
        // D s_4260_4: cmp-eq s_4260_1 s_4260_3
        let s_4260_4: bool = ((s_4260_1) == (s_4260_3));
        // D s_4260_5: write-var gs#135653 <= s_4260_4
        fn_state.gs_135653 = s_4260_4;
        // N s_4260_6: jump b2641
        return block_2641(state, tracer, fn_state);
    }
    fn block_4261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4261_0: read-var CRn:u8
        let s_4261_0: u8 = fn_state.CRn;
        // D s_4261_1: cast zx s_4261_0 -> bv
        let s_4261_1: Bits = Bits::new(s_4261_0 as u128, 4u16);
        // C s_4261_2: const #14u : u8
        let s_4261_2: u8 = 14;
        // C s_4261_3: cast zx s_4261_2 -> bv
        let s_4261_3: Bits = Bits::new(s_4261_2 as u128, 4u16);
        // D s_4261_4: cmp-eq s_4261_1 s_4261_3
        let s_4261_4: bool = ((s_4261_1) == (s_4261_3));
        // D s_4261_5: write-var gs#135652 <= s_4261_4
        fn_state.gs_135652 = s_4261_4;
        // N s_4261_6: jump b2639
        return block_2639(state, tracer, fn_state);
    }
    fn block_4262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4262_0: read-var el:u8
        let s_4262_0: u8 = fn_state.el;
        // D s_4262_1: read-var coproc:u8
        let s_4262_1: u8 = fn_state.coproc;
        // D s_4262_2: read-var opc1:u8
        let s_4262_2: u8 = fn_state.opc1;
        // D s_4262_3: read-var CRn:u8
        let s_4262_3: u8 = fn_state.CRn;
        // D s_4262_4: read-var opc2:u8
        let s_4262_4: u8 = fn_state.opc2;
        // D s_4262_5: read-var CRm:u8
        let s_4262_5: u8 = fn_state.CRm;
        // D s_4262_6: read-var t:i
        let s_4262_6: i128 = fn_state.t;
        // D s_4262_7: call PMEVTYPER_SysRegWrite32_d731b0e32007816c(s_4262_0, s_4262_1, s_4262_2, s_4262_3, s_4262_4, s_4262_5, s_4262_6)
        let s_4262_7: () = PMEVTYPER_SysRegWrite32_d731b0e32007816c(
            state,
            tracer,
            s_4262_0,
            s_4262_1,
            s_4262_2,
            s_4262_3,
            s_4262_4,
            s_4262_5,
            s_4262_6,
        );
        // N s_4262_8: return
        return;
    }
    fn block_4263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4263_0: read-var opc2:u8
        let s_4263_0: u8 = fn_state.opc2;
        // D s_4263_1: cast zx s_4263_0 -> bv
        let s_4263_1: Bits = Bits::new(s_4263_0 as u128, 3u16);
        // C s_4263_2: const #5u : u8
        let s_4263_2: u8 = 5;
        // C s_4263_3: cast zx s_4263_2 -> bv
        let s_4263_3: Bits = Bits::new(s_4263_2 as u128, 3u16);
        // D s_4263_4: cmp-eq s_4263_1 s_4263_3
        let s_4263_4: bool = ((s_4263_1) == (s_4263_3));
        // D s_4263_5: write-var gs#135651 <= s_4263_4
        fn_state.gs_135651 = s_4263_4;
        // N s_4263_6: jump b2636
        return block_2636(state, tracer, fn_state);
    }
    fn block_4264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4264_0: read-var opc1:u8
        let s_4264_0: u8 = fn_state.opc1;
        // D s_4264_1: cast zx s_4264_0 -> bv
        let s_4264_1: Bits = Bits::new(s_4264_0 as u128, 3u16);
        // C s_4264_2: const #0u : u8
        let s_4264_2: u8 = 0;
        // C s_4264_3: cast zx s_4264_2 -> bv
        let s_4264_3: Bits = Bits::new(s_4264_2 as u128, 3u16);
        // D s_4264_4: cmp-eq s_4264_1 s_4264_3
        let s_4264_4: bool = ((s_4264_1) == (s_4264_3));
        // D s_4264_5: write-var gs#135650 <= s_4264_4
        fn_state.gs_135650 = s_4264_4;
        // N s_4264_6: jump b2634
        return block_2634(state, tracer, fn_state);
    }
    fn block_4265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4265_0: read-var coproc:u8
        let s_4265_0: u8 = fn_state.coproc;
        // D s_4265_1: cast zx s_4265_0 -> bv
        let s_4265_1: Bits = Bits::new(s_4265_0 as u128, 4u16);
        // C s_4265_2: const #15u : u8
        let s_4265_2: u8 = 15;
        // C s_4265_3: cast zx s_4265_2 -> bv
        let s_4265_3: Bits = Bits::new(s_4265_2 as u128, 4u16);
        // D s_4265_4: cmp-eq s_4265_1 s_4265_3
        let s_4265_4: bool = ((s_4265_1) == (s_4265_3));
        // D s_4265_5: write-var gs#135649 <= s_4265_4
        fn_state.gs_135649 = s_4265_4;
        // N s_4265_6: jump b2632
        return block_2632(state, tracer, fn_state);
    }
    fn block_4266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4266_0: read-var CRn:u8
        let s_4266_0: u8 = fn_state.CRn;
        // D s_4266_1: cast zx s_4266_0 -> bv
        let s_4266_1: Bits = Bits::new(s_4266_0 as u128, 4u16);
        // C s_4266_2: const #14u : u8
        let s_4266_2: u8 = 14;
        // C s_4266_3: cast zx s_4266_2 -> bv
        let s_4266_3: Bits = Bits::new(s_4266_2 as u128, 4u16);
        // D s_4266_4: cmp-eq s_4266_1 s_4266_3
        let s_4266_4: bool = ((s_4266_1) == (s_4266_3));
        // D s_4266_5: write-var gs#135648 <= s_4266_4
        fn_state.gs_135648 = s_4266_4;
        // N s_4266_6: jump b2630
        return block_2630(state, tracer, fn_state);
    }
    fn block_4267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4267_0: read-var el:u8
        let s_4267_0: u8 = fn_state.el;
        // D s_4267_1: read-var coproc:u8
        let s_4267_1: u8 = fn_state.coproc;
        // D s_4267_2: read-var opc1:u8
        let s_4267_2: u8 = fn_state.opc1;
        // D s_4267_3: read-var CRn:u8
        let s_4267_3: u8 = fn_state.CRn;
        // D s_4267_4: read-var opc2:u8
        let s_4267_4: u8 = fn_state.opc2;
        // D s_4267_5: read-var CRm:u8
        let s_4267_5: u8 = fn_state.CRm;
        // D s_4267_6: read-var t:i
        let s_4267_6: i128 = fn_state.t;
        // D s_4267_7: call PMEVTYPER_SysRegWrite32_5d6bbab43fdc82f0(s_4267_0, s_4267_1, s_4267_2, s_4267_3, s_4267_4, s_4267_5, s_4267_6)
        let s_4267_7: () = PMEVTYPER_SysRegWrite32_5d6bbab43fdc82f0(
            state,
            tracer,
            s_4267_0,
            s_4267_1,
            s_4267_2,
            s_4267_3,
            s_4267_4,
            s_4267_5,
            s_4267_6,
        );
        // N s_4267_8: return
        return;
    }
    fn block_4268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4268_0: read-var opc2:u8
        let s_4268_0: u8 = fn_state.opc2;
        // D s_4268_1: cast zx s_4268_0 -> bv
        let s_4268_1: Bits = Bits::new(s_4268_0 as u128, 3u16);
        // C s_4268_2: const #6u : u8
        let s_4268_2: u8 = 6;
        // C s_4268_3: cast zx s_4268_2 -> bv
        let s_4268_3: Bits = Bits::new(s_4268_2 as u128, 3u16);
        // D s_4268_4: cmp-eq s_4268_1 s_4268_3
        let s_4268_4: bool = ((s_4268_1) == (s_4268_3));
        // D s_4268_5: write-var gs#135647 <= s_4268_4
        fn_state.gs_135647 = s_4268_4;
        // N s_4268_6: jump b2627
        return block_2627(state, tracer, fn_state);
    }
    fn block_4269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4269_0: read-var opc1:u8
        let s_4269_0: u8 = fn_state.opc1;
        // D s_4269_1: cast zx s_4269_0 -> bv
        let s_4269_1: Bits = Bits::new(s_4269_0 as u128, 3u16);
        // C s_4269_2: const #0u : u8
        let s_4269_2: u8 = 0;
        // C s_4269_3: cast zx s_4269_2 -> bv
        let s_4269_3: Bits = Bits::new(s_4269_2 as u128, 3u16);
        // D s_4269_4: cmp-eq s_4269_1 s_4269_3
        let s_4269_4: bool = ((s_4269_1) == (s_4269_3));
        // D s_4269_5: write-var gs#135646 <= s_4269_4
        fn_state.gs_135646 = s_4269_4;
        // N s_4269_6: jump b2625
        return block_2625(state, tracer, fn_state);
    }
    fn block_4270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4270_0: read-var coproc:u8
        let s_4270_0: u8 = fn_state.coproc;
        // D s_4270_1: cast zx s_4270_0 -> bv
        let s_4270_1: Bits = Bits::new(s_4270_0 as u128, 4u16);
        // C s_4270_2: const #15u : u8
        let s_4270_2: u8 = 15;
        // C s_4270_3: cast zx s_4270_2 -> bv
        let s_4270_3: Bits = Bits::new(s_4270_2 as u128, 4u16);
        // D s_4270_4: cmp-eq s_4270_1 s_4270_3
        let s_4270_4: bool = ((s_4270_1) == (s_4270_3));
        // D s_4270_5: write-var gs#135645 <= s_4270_4
        fn_state.gs_135645 = s_4270_4;
        // N s_4270_6: jump b2623
        return block_2623(state, tracer, fn_state);
    }
    fn block_4271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4271_0: read-var CRn:u8
        let s_4271_0: u8 = fn_state.CRn;
        // D s_4271_1: cast zx s_4271_0 -> bv
        let s_4271_1: Bits = Bits::new(s_4271_0 as u128, 4u16);
        // C s_4271_2: const #14u : u8
        let s_4271_2: u8 = 14;
        // C s_4271_3: cast zx s_4271_2 -> bv
        let s_4271_3: Bits = Bits::new(s_4271_2 as u128, 4u16);
        // D s_4271_4: cmp-eq s_4271_1 s_4271_3
        let s_4271_4: bool = ((s_4271_1) == (s_4271_3));
        // D s_4271_5: write-var gs#135644 <= s_4271_4
        fn_state.gs_135644 = s_4271_4;
        // N s_4271_6: jump b2621
        return block_2621(state, tracer, fn_state);
    }
    fn block_4272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4272_0: read-var el:u8
        let s_4272_0: u8 = fn_state.el;
        // D s_4272_1: read-var coproc:u8
        let s_4272_1: u8 = fn_state.coproc;
        // D s_4272_2: read-var opc1:u8
        let s_4272_2: u8 = fn_state.opc1;
        // D s_4272_3: read-var CRn:u8
        let s_4272_3: u8 = fn_state.CRn;
        // D s_4272_4: read-var opc2:u8
        let s_4272_4: u8 = fn_state.opc2;
        // D s_4272_5: read-var CRm:u8
        let s_4272_5: u8 = fn_state.CRm;
        // D s_4272_6: read-var t:i
        let s_4272_6: i128 = fn_state.t;
        // D s_4272_7: call PMEVTYPER_SysRegWrite32_fc6d24db3b587aa8(s_4272_0, s_4272_1, s_4272_2, s_4272_3, s_4272_4, s_4272_5, s_4272_6)
        let s_4272_7: () = PMEVTYPER_SysRegWrite32_fc6d24db3b587aa8(
            state,
            tracer,
            s_4272_0,
            s_4272_1,
            s_4272_2,
            s_4272_3,
            s_4272_4,
            s_4272_5,
            s_4272_6,
        );
        // N s_4272_8: return
        return;
    }
    fn block_4273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4273_0: read-var opc2:u8
        let s_4273_0: u8 = fn_state.opc2;
        // D s_4273_1: cast zx s_4273_0 -> bv
        let s_4273_1: Bits = Bits::new(s_4273_0 as u128, 3u16);
        // C s_4273_2: const #7u : u8
        let s_4273_2: u8 = 7;
        // C s_4273_3: cast zx s_4273_2 -> bv
        let s_4273_3: Bits = Bits::new(s_4273_2 as u128, 3u16);
        // D s_4273_4: cmp-eq s_4273_1 s_4273_3
        let s_4273_4: bool = ((s_4273_1) == (s_4273_3));
        // D s_4273_5: write-var gs#135643 <= s_4273_4
        fn_state.gs_135643 = s_4273_4;
        // N s_4273_6: jump b2618
        return block_2618(state, tracer, fn_state);
    }
    fn block_4274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4274_0: read-var opc1:u8
        let s_4274_0: u8 = fn_state.opc1;
        // D s_4274_1: cast zx s_4274_0 -> bv
        let s_4274_1: Bits = Bits::new(s_4274_0 as u128, 3u16);
        // C s_4274_2: const #0u : u8
        let s_4274_2: u8 = 0;
        // C s_4274_3: cast zx s_4274_2 -> bv
        let s_4274_3: Bits = Bits::new(s_4274_2 as u128, 3u16);
        // D s_4274_4: cmp-eq s_4274_1 s_4274_3
        let s_4274_4: bool = ((s_4274_1) == (s_4274_3));
        // D s_4274_5: write-var gs#135642 <= s_4274_4
        fn_state.gs_135642 = s_4274_4;
        // N s_4274_6: jump b2616
        return block_2616(state, tracer, fn_state);
    }
    fn block_4275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4275_0: read-var coproc:u8
        let s_4275_0: u8 = fn_state.coproc;
        // D s_4275_1: cast zx s_4275_0 -> bv
        let s_4275_1: Bits = Bits::new(s_4275_0 as u128, 4u16);
        // C s_4275_2: const #15u : u8
        let s_4275_2: u8 = 15;
        // C s_4275_3: cast zx s_4275_2 -> bv
        let s_4275_3: Bits = Bits::new(s_4275_2 as u128, 4u16);
        // D s_4275_4: cmp-eq s_4275_1 s_4275_3
        let s_4275_4: bool = ((s_4275_1) == (s_4275_3));
        // D s_4275_5: write-var gs#135641 <= s_4275_4
        fn_state.gs_135641 = s_4275_4;
        // N s_4275_6: jump b2614
        return block_2614(state, tracer, fn_state);
    }
    fn block_4276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4276_0: read-var CRn:u8
        let s_4276_0: u8 = fn_state.CRn;
        // D s_4276_1: cast zx s_4276_0 -> bv
        let s_4276_1: Bits = Bits::new(s_4276_0 as u128, 4u16);
        // C s_4276_2: const #14u : u8
        let s_4276_2: u8 = 14;
        // C s_4276_3: cast zx s_4276_2 -> bv
        let s_4276_3: Bits = Bits::new(s_4276_2 as u128, 4u16);
        // D s_4276_4: cmp-eq s_4276_1 s_4276_3
        let s_4276_4: bool = ((s_4276_1) == (s_4276_3));
        // D s_4276_5: write-var gs#135640 <= s_4276_4
        fn_state.gs_135640 = s_4276_4;
        // N s_4276_6: jump b2612
        return block_2612(state, tracer, fn_state);
    }
    fn block_4277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4277_0: read-var el:u8
        let s_4277_0: u8 = fn_state.el;
        // D s_4277_1: read-var coproc:u8
        let s_4277_1: u8 = fn_state.coproc;
        // D s_4277_2: read-var opc1:u8
        let s_4277_2: u8 = fn_state.opc1;
        // D s_4277_3: read-var CRn:u8
        let s_4277_3: u8 = fn_state.CRn;
        // D s_4277_4: read-var opc2:u8
        let s_4277_4: u8 = fn_state.opc2;
        // D s_4277_5: read-var CRm:u8
        let s_4277_5: u8 = fn_state.CRm;
        // D s_4277_6: read-var t:i
        let s_4277_6: i128 = fn_state.t;
        // D s_4277_7: call PMEVTYPER_SysRegWrite32_6b959d889d3d66da(s_4277_0, s_4277_1, s_4277_2, s_4277_3, s_4277_4, s_4277_5, s_4277_6)
        let s_4277_7: () = PMEVTYPER_SysRegWrite32_6b959d889d3d66da(
            state,
            tracer,
            s_4277_0,
            s_4277_1,
            s_4277_2,
            s_4277_3,
            s_4277_4,
            s_4277_5,
            s_4277_6,
        );
        // N s_4277_8: return
        return;
    }
    fn block_4278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4278_0: read-var opc2:u8
        let s_4278_0: u8 = fn_state.opc2;
        // D s_4278_1: cast zx s_4278_0 -> bv
        let s_4278_1: Bits = Bits::new(s_4278_0 as u128, 3u16);
        // C s_4278_2: const #0u : u8
        let s_4278_2: u8 = 0;
        // C s_4278_3: cast zx s_4278_2 -> bv
        let s_4278_3: Bits = Bits::new(s_4278_2 as u128, 3u16);
        // D s_4278_4: cmp-eq s_4278_1 s_4278_3
        let s_4278_4: bool = ((s_4278_1) == (s_4278_3));
        // D s_4278_5: write-var gs#135639 <= s_4278_4
        fn_state.gs_135639 = s_4278_4;
        // N s_4278_6: jump b2609
        return block_2609(state, tracer, fn_state);
    }
    fn block_4279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4279_0: read-var opc1:u8
        let s_4279_0: u8 = fn_state.opc1;
        // D s_4279_1: cast zx s_4279_0 -> bv
        let s_4279_1: Bits = Bits::new(s_4279_0 as u128, 3u16);
        // C s_4279_2: const #0u : u8
        let s_4279_2: u8 = 0;
        // C s_4279_3: cast zx s_4279_2 -> bv
        let s_4279_3: Bits = Bits::new(s_4279_2 as u128, 3u16);
        // D s_4279_4: cmp-eq s_4279_1 s_4279_3
        let s_4279_4: bool = ((s_4279_1) == (s_4279_3));
        // D s_4279_5: write-var gs#135638 <= s_4279_4
        fn_state.gs_135638 = s_4279_4;
        // N s_4279_6: jump b2607
        return block_2607(state, tracer, fn_state);
    }
    fn block_4280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4280_0: read-var coproc:u8
        let s_4280_0: u8 = fn_state.coproc;
        // D s_4280_1: cast zx s_4280_0 -> bv
        let s_4280_1: Bits = Bits::new(s_4280_0 as u128, 4u16);
        // C s_4280_2: const #15u : u8
        let s_4280_2: u8 = 15;
        // C s_4280_3: cast zx s_4280_2 -> bv
        let s_4280_3: Bits = Bits::new(s_4280_2 as u128, 4u16);
        // D s_4280_4: cmp-eq s_4280_1 s_4280_3
        let s_4280_4: bool = ((s_4280_1) == (s_4280_3));
        // D s_4280_5: write-var gs#135637 <= s_4280_4
        fn_state.gs_135637 = s_4280_4;
        // N s_4280_6: jump b2605
        return block_2605(state, tracer, fn_state);
    }
    fn block_4281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4281_0: read-var CRn:u8
        let s_4281_0: u8 = fn_state.CRn;
        // D s_4281_1: cast zx s_4281_0 -> bv
        let s_4281_1: Bits = Bits::new(s_4281_0 as u128, 4u16);
        // C s_4281_2: const #14u : u8
        let s_4281_2: u8 = 14;
        // C s_4281_3: cast zx s_4281_2 -> bv
        let s_4281_3: Bits = Bits::new(s_4281_2 as u128, 4u16);
        // D s_4281_4: cmp-eq s_4281_1 s_4281_3
        let s_4281_4: bool = ((s_4281_1) == (s_4281_3));
        // D s_4281_5: write-var gs#135636 <= s_4281_4
        fn_state.gs_135636 = s_4281_4;
        // N s_4281_6: jump b2603
        return block_2603(state, tracer, fn_state);
    }
    fn block_4282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4282_0: read-var el:u8
        let s_4282_0: u8 = fn_state.el;
        // D s_4282_1: read-var coproc:u8
        let s_4282_1: u8 = fn_state.coproc;
        // D s_4282_2: read-var opc1:u8
        let s_4282_2: u8 = fn_state.opc1;
        // D s_4282_3: read-var CRn:u8
        let s_4282_3: u8 = fn_state.CRn;
        // D s_4282_4: read-var opc2:u8
        let s_4282_4: u8 = fn_state.opc2;
        // D s_4282_5: read-var CRm:u8
        let s_4282_5: u8 = fn_state.CRm;
        // D s_4282_6: read-var t:i
        let s_4282_6: i128 = fn_state.t;
        // D s_4282_7: call PMEVTYPER_SysRegWrite32_5e6a7eed513b84e1(s_4282_0, s_4282_1, s_4282_2, s_4282_3, s_4282_4, s_4282_5, s_4282_6)
        let s_4282_7: () = PMEVTYPER_SysRegWrite32_5e6a7eed513b84e1(
            state,
            tracer,
            s_4282_0,
            s_4282_1,
            s_4282_2,
            s_4282_3,
            s_4282_4,
            s_4282_5,
            s_4282_6,
        );
        // N s_4282_8: return
        return;
    }
    fn block_4283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4283_0: read-var opc2:u8
        let s_4283_0: u8 = fn_state.opc2;
        // D s_4283_1: cast zx s_4283_0 -> bv
        let s_4283_1: Bits = Bits::new(s_4283_0 as u128, 3u16);
        // C s_4283_2: const #1u : u8
        let s_4283_2: u8 = 1;
        // C s_4283_3: cast zx s_4283_2 -> bv
        let s_4283_3: Bits = Bits::new(s_4283_2 as u128, 3u16);
        // D s_4283_4: cmp-eq s_4283_1 s_4283_3
        let s_4283_4: bool = ((s_4283_1) == (s_4283_3));
        // D s_4283_5: write-var gs#135635 <= s_4283_4
        fn_state.gs_135635 = s_4283_4;
        // N s_4283_6: jump b2600
        return block_2600(state, tracer, fn_state);
    }
    fn block_4284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4284_0: read-var opc1:u8
        let s_4284_0: u8 = fn_state.opc1;
        // D s_4284_1: cast zx s_4284_0 -> bv
        let s_4284_1: Bits = Bits::new(s_4284_0 as u128, 3u16);
        // C s_4284_2: const #0u : u8
        let s_4284_2: u8 = 0;
        // C s_4284_3: cast zx s_4284_2 -> bv
        let s_4284_3: Bits = Bits::new(s_4284_2 as u128, 3u16);
        // D s_4284_4: cmp-eq s_4284_1 s_4284_3
        let s_4284_4: bool = ((s_4284_1) == (s_4284_3));
        // D s_4284_5: write-var gs#135634 <= s_4284_4
        fn_state.gs_135634 = s_4284_4;
        // N s_4284_6: jump b2598
        return block_2598(state, tracer, fn_state);
    }
    fn block_4285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4285_0: read-var coproc:u8
        let s_4285_0: u8 = fn_state.coproc;
        // D s_4285_1: cast zx s_4285_0 -> bv
        let s_4285_1: Bits = Bits::new(s_4285_0 as u128, 4u16);
        // C s_4285_2: const #15u : u8
        let s_4285_2: u8 = 15;
        // C s_4285_3: cast zx s_4285_2 -> bv
        let s_4285_3: Bits = Bits::new(s_4285_2 as u128, 4u16);
        // D s_4285_4: cmp-eq s_4285_1 s_4285_3
        let s_4285_4: bool = ((s_4285_1) == (s_4285_3));
        // D s_4285_5: write-var gs#135633 <= s_4285_4
        fn_state.gs_135633 = s_4285_4;
        // N s_4285_6: jump b2596
        return block_2596(state, tracer, fn_state);
    }
    fn block_4286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4286_0: read-var CRn:u8
        let s_4286_0: u8 = fn_state.CRn;
        // D s_4286_1: cast zx s_4286_0 -> bv
        let s_4286_1: Bits = Bits::new(s_4286_0 as u128, 4u16);
        // C s_4286_2: const #14u : u8
        let s_4286_2: u8 = 14;
        // C s_4286_3: cast zx s_4286_2 -> bv
        let s_4286_3: Bits = Bits::new(s_4286_2 as u128, 4u16);
        // D s_4286_4: cmp-eq s_4286_1 s_4286_3
        let s_4286_4: bool = ((s_4286_1) == (s_4286_3));
        // D s_4286_5: write-var gs#135632 <= s_4286_4
        fn_state.gs_135632 = s_4286_4;
        // N s_4286_6: jump b2594
        return block_2594(state, tracer, fn_state);
    }
    fn block_4287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4287_0: read-var el:u8
        let s_4287_0: u8 = fn_state.el;
        // D s_4287_1: read-var coproc:u8
        let s_4287_1: u8 = fn_state.coproc;
        // D s_4287_2: read-var opc1:u8
        let s_4287_2: u8 = fn_state.opc1;
        // D s_4287_3: read-var CRn:u8
        let s_4287_3: u8 = fn_state.CRn;
        // D s_4287_4: read-var opc2:u8
        let s_4287_4: u8 = fn_state.opc2;
        // D s_4287_5: read-var CRm:u8
        let s_4287_5: u8 = fn_state.CRm;
        // D s_4287_6: read-var t:i
        let s_4287_6: i128 = fn_state.t;
        // D s_4287_7: call PMEVTYPER_SysRegWrite32_0dcdf6f29f657a14(s_4287_0, s_4287_1, s_4287_2, s_4287_3, s_4287_4, s_4287_5, s_4287_6)
        let s_4287_7: () = PMEVTYPER_SysRegWrite32_0dcdf6f29f657a14(
            state,
            tracer,
            s_4287_0,
            s_4287_1,
            s_4287_2,
            s_4287_3,
            s_4287_4,
            s_4287_5,
            s_4287_6,
        );
        // N s_4287_8: return
        return;
    }
    fn block_4288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4288_0: read-var opc2:u8
        let s_4288_0: u8 = fn_state.opc2;
        // D s_4288_1: cast zx s_4288_0 -> bv
        let s_4288_1: Bits = Bits::new(s_4288_0 as u128, 3u16);
        // C s_4288_2: const #2u : u8
        let s_4288_2: u8 = 2;
        // C s_4288_3: cast zx s_4288_2 -> bv
        let s_4288_3: Bits = Bits::new(s_4288_2 as u128, 3u16);
        // D s_4288_4: cmp-eq s_4288_1 s_4288_3
        let s_4288_4: bool = ((s_4288_1) == (s_4288_3));
        // D s_4288_5: write-var gs#135631 <= s_4288_4
        fn_state.gs_135631 = s_4288_4;
        // N s_4288_6: jump b2591
        return block_2591(state, tracer, fn_state);
    }
    fn block_4289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4289_0: read-var opc1:u8
        let s_4289_0: u8 = fn_state.opc1;
        // D s_4289_1: cast zx s_4289_0 -> bv
        let s_4289_1: Bits = Bits::new(s_4289_0 as u128, 3u16);
        // C s_4289_2: const #0u : u8
        let s_4289_2: u8 = 0;
        // C s_4289_3: cast zx s_4289_2 -> bv
        let s_4289_3: Bits = Bits::new(s_4289_2 as u128, 3u16);
        // D s_4289_4: cmp-eq s_4289_1 s_4289_3
        let s_4289_4: bool = ((s_4289_1) == (s_4289_3));
        // D s_4289_5: write-var gs#135630 <= s_4289_4
        fn_state.gs_135630 = s_4289_4;
        // N s_4289_6: jump b2589
        return block_2589(state, tracer, fn_state);
    }
    fn block_4290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4290_0: read-var coproc:u8
        let s_4290_0: u8 = fn_state.coproc;
        // D s_4290_1: cast zx s_4290_0 -> bv
        let s_4290_1: Bits = Bits::new(s_4290_0 as u128, 4u16);
        // C s_4290_2: const #15u : u8
        let s_4290_2: u8 = 15;
        // C s_4290_3: cast zx s_4290_2 -> bv
        let s_4290_3: Bits = Bits::new(s_4290_2 as u128, 4u16);
        // D s_4290_4: cmp-eq s_4290_1 s_4290_3
        let s_4290_4: bool = ((s_4290_1) == (s_4290_3));
        // D s_4290_5: write-var gs#135629 <= s_4290_4
        fn_state.gs_135629 = s_4290_4;
        // N s_4290_6: jump b2587
        return block_2587(state, tracer, fn_state);
    }
    fn block_4291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4291_0: read-var CRn:u8
        let s_4291_0: u8 = fn_state.CRn;
        // D s_4291_1: cast zx s_4291_0 -> bv
        let s_4291_1: Bits = Bits::new(s_4291_0 as u128, 4u16);
        // C s_4291_2: const #14u : u8
        let s_4291_2: u8 = 14;
        // C s_4291_3: cast zx s_4291_2 -> bv
        let s_4291_3: Bits = Bits::new(s_4291_2 as u128, 4u16);
        // D s_4291_4: cmp-eq s_4291_1 s_4291_3
        let s_4291_4: bool = ((s_4291_1) == (s_4291_3));
        // D s_4291_5: write-var gs#135628 <= s_4291_4
        fn_state.gs_135628 = s_4291_4;
        // N s_4291_6: jump b2585
        return block_2585(state, tracer, fn_state);
    }
    fn block_4292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4292_0: read-var el:u8
        let s_4292_0: u8 = fn_state.el;
        // D s_4292_1: read-var coproc:u8
        let s_4292_1: u8 = fn_state.coproc;
        // D s_4292_2: read-var opc1:u8
        let s_4292_2: u8 = fn_state.opc1;
        // D s_4292_3: read-var CRn:u8
        let s_4292_3: u8 = fn_state.CRn;
        // D s_4292_4: read-var opc2:u8
        let s_4292_4: u8 = fn_state.opc2;
        // D s_4292_5: read-var CRm:u8
        let s_4292_5: u8 = fn_state.CRm;
        // D s_4292_6: read-var t:i
        let s_4292_6: i128 = fn_state.t;
        // D s_4292_7: call PMEVTYPER_SysRegWrite32_30cfe1e62bad0f9c(s_4292_0, s_4292_1, s_4292_2, s_4292_3, s_4292_4, s_4292_5, s_4292_6)
        let s_4292_7: () = PMEVTYPER_SysRegWrite32_30cfe1e62bad0f9c(
            state,
            tracer,
            s_4292_0,
            s_4292_1,
            s_4292_2,
            s_4292_3,
            s_4292_4,
            s_4292_5,
            s_4292_6,
        );
        // N s_4292_8: return
        return;
    }
    fn block_4293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4293_0: read-var opc2:u8
        let s_4293_0: u8 = fn_state.opc2;
        // D s_4293_1: cast zx s_4293_0 -> bv
        let s_4293_1: Bits = Bits::new(s_4293_0 as u128, 3u16);
        // C s_4293_2: const #3u : u8
        let s_4293_2: u8 = 3;
        // C s_4293_3: cast zx s_4293_2 -> bv
        let s_4293_3: Bits = Bits::new(s_4293_2 as u128, 3u16);
        // D s_4293_4: cmp-eq s_4293_1 s_4293_3
        let s_4293_4: bool = ((s_4293_1) == (s_4293_3));
        // D s_4293_5: write-var gs#135627 <= s_4293_4
        fn_state.gs_135627 = s_4293_4;
        // N s_4293_6: jump b2582
        return block_2582(state, tracer, fn_state);
    }
    fn block_4294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4294_0: read-var opc1:u8
        let s_4294_0: u8 = fn_state.opc1;
        // D s_4294_1: cast zx s_4294_0 -> bv
        let s_4294_1: Bits = Bits::new(s_4294_0 as u128, 3u16);
        // C s_4294_2: const #0u : u8
        let s_4294_2: u8 = 0;
        // C s_4294_3: cast zx s_4294_2 -> bv
        let s_4294_3: Bits = Bits::new(s_4294_2 as u128, 3u16);
        // D s_4294_4: cmp-eq s_4294_1 s_4294_3
        let s_4294_4: bool = ((s_4294_1) == (s_4294_3));
        // D s_4294_5: write-var gs#135626 <= s_4294_4
        fn_state.gs_135626 = s_4294_4;
        // N s_4294_6: jump b2580
        return block_2580(state, tracer, fn_state);
    }
    fn block_4295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4295_0: read-var coproc:u8
        let s_4295_0: u8 = fn_state.coproc;
        // D s_4295_1: cast zx s_4295_0 -> bv
        let s_4295_1: Bits = Bits::new(s_4295_0 as u128, 4u16);
        // C s_4295_2: const #15u : u8
        let s_4295_2: u8 = 15;
        // C s_4295_3: cast zx s_4295_2 -> bv
        let s_4295_3: Bits = Bits::new(s_4295_2 as u128, 4u16);
        // D s_4295_4: cmp-eq s_4295_1 s_4295_3
        let s_4295_4: bool = ((s_4295_1) == (s_4295_3));
        // D s_4295_5: write-var gs#135625 <= s_4295_4
        fn_state.gs_135625 = s_4295_4;
        // N s_4295_6: jump b2578
        return block_2578(state, tracer, fn_state);
    }
    fn block_4296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4296_0: read-var CRn:u8
        let s_4296_0: u8 = fn_state.CRn;
        // D s_4296_1: cast zx s_4296_0 -> bv
        let s_4296_1: Bits = Bits::new(s_4296_0 as u128, 4u16);
        // C s_4296_2: const #14u : u8
        let s_4296_2: u8 = 14;
        // C s_4296_3: cast zx s_4296_2 -> bv
        let s_4296_3: Bits = Bits::new(s_4296_2 as u128, 4u16);
        // D s_4296_4: cmp-eq s_4296_1 s_4296_3
        let s_4296_4: bool = ((s_4296_1) == (s_4296_3));
        // D s_4296_5: write-var gs#135624 <= s_4296_4
        fn_state.gs_135624 = s_4296_4;
        // N s_4296_6: jump b2576
        return block_2576(state, tracer, fn_state);
    }
    fn block_4297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4297_0: read-var el:u8
        let s_4297_0: u8 = fn_state.el;
        // D s_4297_1: read-var coproc:u8
        let s_4297_1: u8 = fn_state.coproc;
        // D s_4297_2: read-var opc1:u8
        let s_4297_2: u8 = fn_state.opc1;
        // D s_4297_3: read-var CRn:u8
        let s_4297_3: u8 = fn_state.CRn;
        // D s_4297_4: read-var opc2:u8
        let s_4297_4: u8 = fn_state.opc2;
        // D s_4297_5: read-var CRm:u8
        let s_4297_5: u8 = fn_state.CRm;
        // D s_4297_6: read-var t:i
        let s_4297_6: i128 = fn_state.t;
        // D s_4297_7: call PMEVTYPER_SysRegWrite32_a8d64216580bbaf2(s_4297_0, s_4297_1, s_4297_2, s_4297_3, s_4297_4, s_4297_5, s_4297_6)
        let s_4297_7: () = PMEVTYPER_SysRegWrite32_a8d64216580bbaf2(
            state,
            tracer,
            s_4297_0,
            s_4297_1,
            s_4297_2,
            s_4297_3,
            s_4297_4,
            s_4297_5,
            s_4297_6,
        );
        // N s_4297_8: return
        return;
    }
    fn block_4298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4298_0: read-var opc2:u8
        let s_4298_0: u8 = fn_state.opc2;
        // D s_4298_1: cast zx s_4298_0 -> bv
        let s_4298_1: Bits = Bits::new(s_4298_0 as u128, 3u16);
        // C s_4298_2: const #4u : u8
        let s_4298_2: u8 = 4;
        // C s_4298_3: cast zx s_4298_2 -> bv
        let s_4298_3: Bits = Bits::new(s_4298_2 as u128, 3u16);
        // D s_4298_4: cmp-eq s_4298_1 s_4298_3
        let s_4298_4: bool = ((s_4298_1) == (s_4298_3));
        // D s_4298_5: write-var gs#135623 <= s_4298_4
        fn_state.gs_135623 = s_4298_4;
        // N s_4298_6: jump b2573
        return block_2573(state, tracer, fn_state);
    }
    fn block_4299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4299_0: read-var opc1:u8
        let s_4299_0: u8 = fn_state.opc1;
        // D s_4299_1: cast zx s_4299_0 -> bv
        let s_4299_1: Bits = Bits::new(s_4299_0 as u128, 3u16);
        // C s_4299_2: const #0u : u8
        let s_4299_2: u8 = 0;
        // C s_4299_3: cast zx s_4299_2 -> bv
        let s_4299_3: Bits = Bits::new(s_4299_2 as u128, 3u16);
        // D s_4299_4: cmp-eq s_4299_1 s_4299_3
        let s_4299_4: bool = ((s_4299_1) == (s_4299_3));
        // D s_4299_5: write-var gs#135622 <= s_4299_4
        fn_state.gs_135622 = s_4299_4;
        // N s_4299_6: jump b2571
        return block_2571(state, tracer, fn_state);
    }
    fn block_4300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4300_0: read-var coproc:u8
        let s_4300_0: u8 = fn_state.coproc;
        // D s_4300_1: cast zx s_4300_0 -> bv
        let s_4300_1: Bits = Bits::new(s_4300_0 as u128, 4u16);
        // C s_4300_2: const #15u : u8
        let s_4300_2: u8 = 15;
        // C s_4300_3: cast zx s_4300_2 -> bv
        let s_4300_3: Bits = Bits::new(s_4300_2 as u128, 4u16);
        // D s_4300_4: cmp-eq s_4300_1 s_4300_3
        let s_4300_4: bool = ((s_4300_1) == (s_4300_3));
        // D s_4300_5: write-var gs#135621 <= s_4300_4
        fn_state.gs_135621 = s_4300_4;
        // N s_4300_6: jump b2569
        return block_2569(state, tracer, fn_state);
    }
    fn block_4301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4301_0: read-var CRn:u8
        let s_4301_0: u8 = fn_state.CRn;
        // D s_4301_1: cast zx s_4301_0 -> bv
        let s_4301_1: Bits = Bits::new(s_4301_0 as u128, 4u16);
        // C s_4301_2: const #14u : u8
        let s_4301_2: u8 = 14;
        // C s_4301_3: cast zx s_4301_2 -> bv
        let s_4301_3: Bits = Bits::new(s_4301_2 as u128, 4u16);
        // D s_4301_4: cmp-eq s_4301_1 s_4301_3
        let s_4301_4: bool = ((s_4301_1) == (s_4301_3));
        // D s_4301_5: write-var gs#135620 <= s_4301_4
        fn_state.gs_135620 = s_4301_4;
        // N s_4301_6: jump b2567
        return block_2567(state, tracer, fn_state);
    }
    fn block_4302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4302_0: read-var el:u8
        let s_4302_0: u8 = fn_state.el;
        // D s_4302_1: read-var coproc:u8
        let s_4302_1: u8 = fn_state.coproc;
        // D s_4302_2: read-var opc1:u8
        let s_4302_2: u8 = fn_state.opc1;
        // D s_4302_3: read-var CRn:u8
        let s_4302_3: u8 = fn_state.CRn;
        // D s_4302_4: read-var opc2:u8
        let s_4302_4: u8 = fn_state.opc2;
        // D s_4302_5: read-var CRm:u8
        let s_4302_5: u8 = fn_state.CRm;
        // D s_4302_6: read-var t:i
        let s_4302_6: i128 = fn_state.t;
        // D s_4302_7: call PMEVTYPER_SysRegWrite32_1340de29f3c858ee(s_4302_0, s_4302_1, s_4302_2, s_4302_3, s_4302_4, s_4302_5, s_4302_6)
        let s_4302_7: () = PMEVTYPER_SysRegWrite32_1340de29f3c858ee(
            state,
            tracer,
            s_4302_0,
            s_4302_1,
            s_4302_2,
            s_4302_3,
            s_4302_4,
            s_4302_5,
            s_4302_6,
        );
        // N s_4302_8: return
        return;
    }
    fn block_4303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4303_0: read-var opc2:u8
        let s_4303_0: u8 = fn_state.opc2;
        // D s_4303_1: cast zx s_4303_0 -> bv
        let s_4303_1: Bits = Bits::new(s_4303_0 as u128, 3u16);
        // C s_4303_2: const #5u : u8
        let s_4303_2: u8 = 5;
        // C s_4303_3: cast zx s_4303_2 -> bv
        let s_4303_3: Bits = Bits::new(s_4303_2 as u128, 3u16);
        // D s_4303_4: cmp-eq s_4303_1 s_4303_3
        let s_4303_4: bool = ((s_4303_1) == (s_4303_3));
        // D s_4303_5: write-var gs#135619 <= s_4303_4
        fn_state.gs_135619 = s_4303_4;
        // N s_4303_6: jump b2564
        return block_2564(state, tracer, fn_state);
    }
    fn block_4304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4304_0: read-var opc1:u8
        let s_4304_0: u8 = fn_state.opc1;
        // D s_4304_1: cast zx s_4304_0 -> bv
        let s_4304_1: Bits = Bits::new(s_4304_0 as u128, 3u16);
        // C s_4304_2: const #0u : u8
        let s_4304_2: u8 = 0;
        // C s_4304_3: cast zx s_4304_2 -> bv
        let s_4304_3: Bits = Bits::new(s_4304_2 as u128, 3u16);
        // D s_4304_4: cmp-eq s_4304_1 s_4304_3
        let s_4304_4: bool = ((s_4304_1) == (s_4304_3));
        // D s_4304_5: write-var gs#135618 <= s_4304_4
        fn_state.gs_135618 = s_4304_4;
        // N s_4304_6: jump b2562
        return block_2562(state, tracer, fn_state);
    }
    fn block_4305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4305_0: read-var coproc:u8
        let s_4305_0: u8 = fn_state.coproc;
        // D s_4305_1: cast zx s_4305_0 -> bv
        let s_4305_1: Bits = Bits::new(s_4305_0 as u128, 4u16);
        // C s_4305_2: const #15u : u8
        let s_4305_2: u8 = 15;
        // C s_4305_3: cast zx s_4305_2 -> bv
        let s_4305_3: Bits = Bits::new(s_4305_2 as u128, 4u16);
        // D s_4305_4: cmp-eq s_4305_1 s_4305_3
        let s_4305_4: bool = ((s_4305_1) == (s_4305_3));
        // D s_4305_5: write-var gs#135617 <= s_4305_4
        fn_state.gs_135617 = s_4305_4;
        // N s_4305_6: jump b2560
        return block_2560(state, tracer, fn_state);
    }
    fn block_4306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4306_0: read-var CRn:u8
        let s_4306_0: u8 = fn_state.CRn;
        // D s_4306_1: cast zx s_4306_0 -> bv
        let s_4306_1: Bits = Bits::new(s_4306_0 as u128, 4u16);
        // C s_4306_2: const #14u : u8
        let s_4306_2: u8 = 14;
        // C s_4306_3: cast zx s_4306_2 -> bv
        let s_4306_3: Bits = Bits::new(s_4306_2 as u128, 4u16);
        // D s_4306_4: cmp-eq s_4306_1 s_4306_3
        let s_4306_4: bool = ((s_4306_1) == (s_4306_3));
        // D s_4306_5: write-var gs#135616 <= s_4306_4
        fn_state.gs_135616 = s_4306_4;
        // N s_4306_6: jump b2558
        return block_2558(state, tracer, fn_state);
    }
    fn block_4307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4307_0: read-var el:u8
        let s_4307_0: u8 = fn_state.el;
        // D s_4307_1: read-var coproc:u8
        let s_4307_1: u8 = fn_state.coproc;
        // D s_4307_2: read-var opc1:u8
        let s_4307_2: u8 = fn_state.opc1;
        // D s_4307_3: read-var CRn:u8
        let s_4307_3: u8 = fn_state.CRn;
        // D s_4307_4: read-var opc2:u8
        let s_4307_4: u8 = fn_state.opc2;
        // D s_4307_5: read-var CRm:u8
        let s_4307_5: u8 = fn_state.CRm;
        // D s_4307_6: read-var t:i
        let s_4307_6: i128 = fn_state.t;
        // D s_4307_7: call PMEVTYPER_SysRegWrite32_5cfcde71ee84f007(s_4307_0, s_4307_1, s_4307_2, s_4307_3, s_4307_4, s_4307_5, s_4307_6)
        let s_4307_7: () = PMEVTYPER_SysRegWrite32_5cfcde71ee84f007(
            state,
            tracer,
            s_4307_0,
            s_4307_1,
            s_4307_2,
            s_4307_3,
            s_4307_4,
            s_4307_5,
            s_4307_6,
        );
        // N s_4307_8: return
        return;
    }
    fn block_4308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4308_0: read-var opc2:u8
        let s_4308_0: u8 = fn_state.opc2;
        // D s_4308_1: cast zx s_4308_0 -> bv
        let s_4308_1: Bits = Bits::new(s_4308_0 as u128, 3u16);
        // C s_4308_2: const #6u : u8
        let s_4308_2: u8 = 6;
        // C s_4308_3: cast zx s_4308_2 -> bv
        let s_4308_3: Bits = Bits::new(s_4308_2 as u128, 3u16);
        // D s_4308_4: cmp-eq s_4308_1 s_4308_3
        let s_4308_4: bool = ((s_4308_1) == (s_4308_3));
        // D s_4308_5: write-var gs#135615 <= s_4308_4
        fn_state.gs_135615 = s_4308_4;
        // N s_4308_6: jump b2555
        return block_2555(state, tracer, fn_state);
    }
    fn block_4309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4309_0: read-var opc1:u8
        let s_4309_0: u8 = fn_state.opc1;
        // D s_4309_1: cast zx s_4309_0 -> bv
        let s_4309_1: Bits = Bits::new(s_4309_0 as u128, 3u16);
        // C s_4309_2: const #0u : u8
        let s_4309_2: u8 = 0;
        // C s_4309_3: cast zx s_4309_2 -> bv
        let s_4309_3: Bits = Bits::new(s_4309_2 as u128, 3u16);
        // D s_4309_4: cmp-eq s_4309_1 s_4309_3
        let s_4309_4: bool = ((s_4309_1) == (s_4309_3));
        // D s_4309_5: write-var gs#135614 <= s_4309_4
        fn_state.gs_135614 = s_4309_4;
        // N s_4309_6: jump b2553
        return block_2553(state, tracer, fn_state);
    }
    fn block_4310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4310_0: read-var coproc:u8
        let s_4310_0: u8 = fn_state.coproc;
        // D s_4310_1: cast zx s_4310_0 -> bv
        let s_4310_1: Bits = Bits::new(s_4310_0 as u128, 4u16);
        // C s_4310_2: const #15u : u8
        let s_4310_2: u8 = 15;
        // C s_4310_3: cast zx s_4310_2 -> bv
        let s_4310_3: Bits = Bits::new(s_4310_2 as u128, 4u16);
        // D s_4310_4: cmp-eq s_4310_1 s_4310_3
        let s_4310_4: bool = ((s_4310_1) == (s_4310_3));
        // D s_4310_5: write-var gs#135613 <= s_4310_4
        fn_state.gs_135613 = s_4310_4;
        // N s_4310_6: jump b2551
        return block_2551(state, tracer, fn_state);
    }
    fn block_4311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4311_0: read-var CRn:u8
        let s_4311_0: u8 = fn_state.CRn;
        // D s_4311_1: cast zx s_4311_0 -> bv
        let s_4311_1: Bits = Bits::new(s_4311_0 as u128, 4u16);
        // C s_4311_2: const #14u : u8
        let s_4311_2: u8 = 14;
        // C s_4311_3: cast zx s_4311_2 -> bv
        let s_4311_3: Bits = Bits::new(s_4311_2 as u128, 4u16);
        // D s_4311_4: cmp-eq s_4311_1 s_4311_3
        let s_4311_4: bool = ((s_4311_1) == (s_4311_3));
        // D s_4311_5: write-var gs#135612 <= s_4311_4
        fn_state.gs_135612 = s_4311_4;
        // N s_4311_6: jump b2549
        return block_2549(state, tracer, fn_state);
    }
    fn block_4312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4312_0: read-var el:u8
        let s_4312_0: u8 = fn_state.el;
        // D s_4312_1: read-var coproc:u8
        let s_4312_1: u8 = fn_state.coproc;
        // D s_4312_2: read-var opc1:u8
        let s_4312_2: u8 = fn_state.opc1;
        // D s_4312_3: read-var CRn:u8
        let s_4312_3: u8 = fn_state.CRn;
        // D s_4312_4: read-var opc2:u8
        let s_4312_4: u8 = fn_state.opc2;
        // D s_4312_5: read-var CRm:u8
        let s_4312_5: u8 = fn_state.CRm;
        // D s_4312_6: read-var t:i
        let s_4312_6: i128 = fn_state.t;
        // D s_4312_7: call PMSWINC_SysRegWrite32_9b4c9b84c8e7597b(s_4312_0, s_4312_1, s_4312_2, s_4312_3, s_4312_4, s_4312_5, s_4312_6)
        let s_4312_7: () = PMSWINC_SysRegWrite32_9b4c9b84c8e7597b(
            state,
            tracer,
            s_4312_0,
            s_4312_1,
            s_4312_2,
            s_4312_3,
            s_4312_4,
            s_4312_5,
            s_4312_6,
        );
        // N s_4312_8: return
        return;
    }
    fn block_4313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4313_0: read-var opc2:u8
        let s_4313_0: u8 = fn_state.opc2;
        // D s_4313_1: cast zx s_4313_0 -> bv
        let s_4313_1: Bits = Bits::new(s_4313_0 as u128, 3u16);
        // C s_4313_2: const #4u : u8
        let s_4313_2: u8 = 4;
        // C s_4313_3: cast zx s_4313_2 -> bv
        let s_4313_3: Bits = Bits::new(s_4313_2 as u128, 3u16);
        // D s_4313_4: cmp-eq s_4313_1 s_4313_3
        let s_4313_4: bool = ((s_4313_1) == (s_4313_3));
        // D s_4313_5: write-var gs#135611 <= s_4313_4
        fn_state.gs_135611 = s_4313_4;
        // N s_4313_6: jump b2546
        return block_2546(state, tracer, fn_state);
    }
    fn block_4314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4314_0: read-var opc1:u8
        let s_4314_0: u8 = fn_state.opc1;
        // D s_4314_1: cast zx s_4314_0 -> bv
        let s_4314_1: Bits = Bits::new(s_4314_0 as u128, 3u16);
        // C s_4314_2: const #0u : u8
        let s_4314_2: u8 = 0;
        // C s_4314_3: cast zx s_4314_2 -> bv
        let s_4314_3: Bits = Bits::new(s_4314_2 as u128, 3u16);
        // D s_4314_4: cmp-eq s_4314_1 s_4314_3
        let s_4314_4: bool = ((s_4314_1) == (s_4314_3));
        // D s_4314_5: write-var gs#135610 <= s_4314_4
        fn_state.gs_135610 = s_4314_4;
        // N s_4314_6: jump b2544
        return block_2544(state, tracer, fn_state);
    }
    fn block_4315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4315_0: read-var coproc:u8
        let s_4315_0: u8 = fn_state.coproc;
        // D s_4315_1: cast zx s_4315_0 -> bv
        let s_4315_1: Bits = Bits::new(s_4315_0 as u128, 4u16);
        // C s_4315_2: const #15u : u8
        let s_4315_2: u8 = 15;
        // C s_4315_3: cast zx s_4315_2 -> bv
        let s_4315_3: Bits = Bits::new(s_4315_2 as u128, 4u16);
        // D s_4315_4: cmp-eq s_4315_1 s_4315_3
        let s_4315_4: bool = ((s_4315_1) == (s_4315_3));
        // D s_4315_5: write-var gs#135609 <= s_4315_4
        fn_state.gs_135609 = s_4315_4;
        // N s_4315_6: jump b2542
        return block_2542(state, tracer, fn_state);
    }
    fn block_4316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4316_0: read-var CRn:u8
        let s_4316_0: u8 = fn_state.CRn;
        // D s_4316_1: cast zx s_4316_0 -> bv
        let s_4316_1: Bits = Bits::new(s_4316_0 as u128, 4u16);
        // C s_4316_2: const #9u : u8
        let s_4316_2: u8 = 9;
        // C s_4316_3: cast zx s_4316_2 -> bv
        let s_4316_3: Bits = Bits::new(s_4316_2 as u128, 4u16);
        // D s_4316_4: cmp-eq s_4316_1 s_4316_3
        let s_4316_4: bool = ((s_4316_1) == (s_4316_3));
        // D s_4316_5: write-var gs#135608 <= s_4316_4
        fn_state.gs_135608 = s_4316_4;
        // N s_4316_6: jump b2540
        return block_2540(state, tracer, fn_state);
    }
    fn block_4317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4317_0: read-var el:u8
        let s_4317_0: u8 = fn_state.el;
        // D s_4317_1: read-var coproc:u8
        let s_4317_1: u8 = fn_state.coproc;
        // D s_4317_2: read-var opc1:u8
        let s_4317_2: u8 = fn_state.opc1;
        // D s_4317_3: read-var CRn:u8
        let s_4317_3: u8 = fn_state.CRn;
        // D s_4317_4: read-var opc2:u8
        let s_4317_4: u8 = fn_state.opc2;
        // D s_4317_5: read-var CRm:u8
        let s_4317_5: u8 = fn_state.CRm;
        // D s_4317_6: read-var t:i
        let s_4317_6: i128 = fn_state.t;
        // D s_4317_7: call VPIDR_SysRegWrite32_deaaa2df067d2d32(s_4317_0, s_4317_1, s_4317_2, s_4317_3, s_4317_4, s_4317_5, s_4317_6)
        let s_4317_7: () = VPIDR_SysRegWrite32_deaaa2df067d2d32(
            state,
            tracer,
            s_4317_0,
            s_4317_1,
            s_4317_2,
            s_4317_3,
            s_4317_4,
            s_4317_5,
            s_4317_6,
        );
        // N s_4317_8: return
        return;
    }
    fn block_4318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4318_0: read-var opc2:u8
        let s_4318_0: u8 = fn_state.opc2;
        // D s_4318_1: cast zx s_4318_0 -> bv
        let s_4318_1: Bits = Bits::new(s_4318_0 as u128, 3u16);
        // C s_4318_2: const #0u : u8
        let s_4318_2: u8 = 0;
        // C s_4318_3: cast zx s_4318_2 -> bv
        let s_4318_3: Bits = Bits::new(s_4318_2 as u128, 3u16);
        // D s_4318_4: cmp-eq s_4318_1 s_4318_3
        let s_4318_4: bool = ((s_4318_1) == (s_4318_3));
        // D s_4318_5: write-var gs#135607 <= s_4318_4
        fn_state.gs_135607 = s_4318_4;
        // N s_4318_6: jump b2537
        return block_2537(state, tracer, fn_state);
    }
    fn block_4319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4319_0: read-var opc1:u8
        let s_4319_0: u8 = fn_state.opc1;
        // D s_4319_1: cast zx s_4319_0 -> bv
        let s_4319_1: Bits = Bits::new(s_4319_0 as u128, 3u16);
        // C s_4319_2: const #4u : u8
        let s_4319_2: u8 = 4;
        // C s_4319_3: cast zx s_4319_2 -> bv
        let s_4319_3: Bits = Bits::new(s_4319_2 as u128, 3u16);
        // D s_4319_4: cmp-eq s_4319_1 s_4319_3
        let s_4319_4: bool = ((s_4319_1) == (s_4319_3));
        // D s_4319_5: write-var gs#135606 <= s_4319_4
        fn_state.gs_135606 = s_4319_4;
        // N s_4319_6: jump b2535
        return block_2535(state, tracer, fn_state);
    }
    fn block_4320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4320_0: read-var coproc:u8
        let s_4320_0: u8 = fn_state.coproc;
        // D s_4320_1: cast zx s_4320_0 -> bv
        let s_4320_1: Bits = Bits::new(s_4320_0 as u128, 4u16);
        // C s_4320_2: const #15u : u8
        let s_4320_2: u8 = 15;
        // C s_4320_3: cast zx s_4320_2 -> bv
        let s_4320_3: Bits = Bits::new(s_4320_2 as u128, 4u16);
        // D s_4320_4: cmp-eq s_4320_1 s_4320_3
        let s_4320_4: bool = ((s_4320_1) == (s_4320_3));
        // D s_4320_5: write-var gs#135605 <= s_4320_4
        fn_state.gs_135605 = s_4320_4;
        // N s_4320_6: jump b2533
        return block_2533(state, tracer, fn_state);
    }
    fn block_4321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4321_0: read-var CRn:u8
        let s_4321_0: u8 = fn_state.CRn;
        // D s_4321_1: cast zx s_4321_0 -> bv
        let s_4321_1: Bits = Bits::new(s_4321_0 as u128, 4u16);
        // C s_4321_2: const #0u : u8
        let s_4321_2: u8 = 0;
        // C s_4321_3: cast zx s_4321_2 -> bv
        let s_4321_3: Bits = Bits::new(s_4321_2 as u128, 4u16);
        // D s_4321_4: cmp-eq s_4321_1 s_4321_3
        let s_4321_4: bool = ((s_4321_1) == (s_4321_3));
        // D s_4321_5: write-var gs#135604 <= s_4321_4
        fn_state.gs_135604 = s_4321_4;
        // N s_4321_6: jump b2531
        return block_2531(state, tracer, fn_state);
    }
    fn block_4322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4322_0: read-var el:u8
        let s_4322_0: u8 = fn_state.el;
        // D s_4322_1: read-var coproc:u8
        let s_4322_1: u8 = fn_state.coproc;
        // D s_4322_2: read-var opc1:u8
        let s_4322_2: u8 = fn_state.opc1;
        // D s_4322_3: read-var CRn:u8
        let s_4322_3: u8 = fn_state.CRn;
        // D s_4322_4: read-var opc2:u8
        let s_4322_4: u8 = fn_state.opc2;
        // D s_4322_5: read-var CRm:u8
        let s_4322_5: u8 = fn_state.CRm;
        // D s_4322_6: read-var t:i
        let s_4322_6: i128 = fn_state.t;
        // D s_4322_7: call HTRFCR_SysRegWrite32_6d3975a6f673d36e(s_4322_0, s_4322_1, s_4322_2, s_4322_3, s_4322_4, s_4322_5, s_4322_6)
        let s_4322_7: () = HTRFCR_SysRegWrite32_6d3975a6f673d36e(
            state,
            tracer,
            s_4322_0,
            s_4322_1,
            s_4322_2,
            s_4322_3,
            s_4322_4,
            s_4322_5,
            s_4322_6,
        );
        // N s_4322_8: return
        return;
    }
    fn block_4323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4323_0: read-var opc2:u8
        let s_4323_0: u8 = fn_state.opc2;
        // D s_4323_1: cast zx s_4323_0 -> bv
        let s_4323_1: Bits = Bits::new(s_4323_0 as u128, 3u16);
        // C s_4323_2: const #1u : u8
        let s_4323_2: u8 = 1;
        // C s_4323_3: cast zx s_4323_2 -> bv
        let s_4323_3: Bits = Bits::new(s_4323_2 as u128, 3u16);
        // D s_4323_4: cmp-eq s_4323_1 s_4323_3
        let s_4323_4: bool = ((s_4323_1) == (s_4323_3));
        // D s_4323_5: write-var gs#135603 <= s_4323_4
        fn_state.gs_135603 = s_4323_4;
        // N s_4323_6: jump b2528
        return block_2528(state, tracer, fn_state);
    }
    fn block_4324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4324_0: read-var opc1:u8
        let s_4324_0: u8 = fn_state.opc1;
        // D s_4324_1: cast zx s_4324_0 -> bv
        let s_4324_1: Bits = Bits::new(s_4324_0 as u128, 3u16);
        // C s_4324_2: const #4u : u8
        let s_4324_2: u8 = 4;
        // C s_4324_3: cast zx s_4324_2 -> bv
        let s_4324_3: Bits = Bits::new(s_4324_2 as u128, 3u16);
        // D s_4324_4: cmp-eq s_4324_1 s_4324_3
        let s_4324_4: bool = ((s_4324_1) == (s_4324_3));
        // D s_4324_5: write-var gs#135602 <= s_4324_4
        fn_state.gs_135602 = s_4324_4;
        // N s_4324_6: jump b2526
        return block_2526(state, tracer, fn_state);
    }
    fn block_4325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4325_0: read-var coproc:u8
        let s_4325_0: u8 = fn_state.coproc;
        // D s_4325_1: cast zx s_4325_0 -> bv
        let s_4325_1: Bits = Bits::new(s_4325_0 as u128, 4u16);
        // C s_4325_2: const #15u : u8
        let s_4325_2: u8 = 15;
        // C s_4325_3: cast zx s_4325_2 -> bv
        let s_4325_3: Bits = Bits::new(s_4325_2 as u128, 4u16);
        // D s_4325_4: cmp-eq s_4325_1 s_4325_3
        let s_4325_4: bool = ((s_4325_1) == (s_4325_3));
        // D s_4325_5: write-var gs#135601 <= s_4325_4
        fn_state.gs_135601 = s_4325_4;
        // N s_4325_6: jump b2524
        return block_2524(state, tracer, fn_state);
    }
    fn block_4326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4326_0: read-var CRn:u8
        let s_4326_0: u8 = fn_state.CRn;
        // D s_4326_1: cast zx s_4326_0 -> bv
        let s_4326_1: Bits = Bits::new(s_4326_0 as u128, 4u16);
        // C s_4326_2: const #1u : u8
        let s_4326_2: u8 = 1;
        // C s_4326_3: cast zx s_4326_2 -> bv
        let s_4326_3: Bits = Bits::new(s_4326_2 as u128, 4u16);
        // D s_4326_4: cmp-eq s_4326_1 s_4326_3
        let s_4326_4: bool = ((s_4326_1) == (s_4326_3));
        // D s_4326_5: write-var gs#135600 <= s_4326_4
        fn_state.gs_135600 = s_4326_4;
        // N s_4326_6: jump b2522
        return block_2522(state, tracer, fn_state);
    }
    fn block_4327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4327_0: read-var el:u8
        let s_4327_0: u8 = fn_state.el;
        // D s_4327_1: read-var coproc:u8
        let s_4327_1: u8 = fn_state.coproc;
        // D s_4327_2: read-var opc1:u8
        let s_4327_2: u8 = fn_state.opc1;
        // D s_4327_3: read-var CRn:u8
        let s_4327_3: u8 = fn_state.CRn;
        // D s_4327_4: read-var opc2:u8
        let s_4327_4: u8 = fn_state.opc2;
        // D s_4327_5: read-var CRm:u8
        let s_4327_5: u8 = fn_state.CRm;
        // D s_4327_6: read-var t:i
        let s_4327_6: i128 = fn_state.t;
        // D s_4327_7: call IFAR_SysRegWrite32_7cf35b53506c7522(s_4327_0, s_4327_1, s_4327_2, s_4327_3, s_4327_4, s_4327_5, s_4327_6)
        let s_4327_7: () = IFAR_SysRegWrite32_7cf35b53506c7522(
            state,
            tracer,
            s_4327_0,
            s_4327_1,
            s_4327_2,
            s_4327_3,
            s_4327_4,
            s_4327_5,
            s_4327_6,
        );
        // N s_4327_8: return
        return;
    }
    fn block_4328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4328_0: read-var opc2:u8
        let s_4328_0: u8 = fn_state.opc2;
        // D s_4328_1: cast zx s_4328_0 -> bv
        let s_4328_1: Bits = Bits::new(s_4328_0 as u128, 3u16);
        // C s_4328_2: const #2u : u8
        let s_4328_2: u8 = 2;
        // C s_4328_3: cast zx s_4328_2 -> bv
        let s_4328_3: Bits = Bits::new(s_4328_2 as u128, 3u16);
        // D s_4328_4: cmp-eq s_4328_1 s_4328_3
        let s_4328_4: bool = ((s_4328_1) == (s_4328_3));
        // D s_4328_5: write-var gs#135599 <= s_4328_4
        fn_state.gs_135599 = s_4328_4;
        // N s_4328_6: jump b2519
        return block_2519(state, tracer, fn_state);
    }
    fn block_4329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4329_0: read-var opc1:u8
        let s_4329_0: u8 = fn_state.opc1;
        // D s_4329_1: cast zx s_4329_0 -> bv
        let s_4329_1: Bits = Bits::new(s_4329_0 as u128, 3u16);
        // C s_4329_2: const #0u : u8
        let s_4329_2: u8 = 0;
        // C s_4329_3: cast zx s_4329_2 -> bv
        let s_4329_3: Bits = Bits::new(s_4329_2 as u128, 3u16);
        // D s_4329_4: cmp-eq s_4329_1 s_4329_3
        let s_4329_4: bool = ((s_4329_1) == (s_4329_3));
        // D s_4329_5: write-var gs#135598 <= s_4329_4
        fn_state.gs_135598 = s_4329_4;
        // N s_4329_6: jump b2517
        return block_2517(state, tracer, fn_state);
    }
    fn block_4330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4330_0: read-var coproc:u8
        let s_4330_0: u8 = fn_state.coproc;
        // D s_4330_1: cast zx s_4330_0 -> bv
        let s_4330_1: Bits = Bits::new(s_4330_0 as u128, 4u16);
        // C s_4330_2: const #15u : u8
        let s_4330_2: u8 = 15;
        // C s_4330_3: cast zx s_4330_2 -> bv
        let s_4330_3: Bits = Bits::new(s_4330_2 as u128, 4u16);
        // D s_4330_4: cmp-eq s_4330_1 s_4330_3
        let s_4330_4: bool = ((s_4330_1) == (s_4330_3));
        // D s_4330_5: write-var gs#135597 <= s_4330_4
        fn_state.gs_135597 = s_4330_4;
        // N s_4330_6: jump b2515
        return block_2515(state, tracer, fn_state);
    }
    fn block_4331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4331_0: read-var CRn:u8
        let s_4331_0: u8 = fn_state.CRn;
        // D s_4331_1: cast zx s_4331_0 -> bv
        let s_4331_1: Bits = Bits::new(s_4331_0 as u128, 4u16);
        // C s_4331_2: const #6u : u8
        let s_4331_2: u8 = 6;
        // C s_4331_3: cast zx s_4331_2 -> bv
        let s_4331_3: Bits = Bits::new(s_4331_2 as u128, 4u16);
        // D s_4331_4: cmp-eq s_4331_1 s_4331_3
        let s_4331_4: bool = ((s_4331_1) == (s_4331_3));
        // D s_4331_5: write-var gs#135596 <= s_4331_4
        fn_state.gs_135596 = s_4331_4;
        // N s_4331_6: jump b2513
        return block_2513(state, tracer, fn_state);
    }
    fn block_4332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4332_0: read-var el:u8
        let s_4332_0: u8 = fn_state.el;
        // D s_4332_1: read-var coproc:u8
        let s_4332_1: u8 = fn_state.coproc;
        // D s_4332_2: read-var opc1:u8
        let s_4332_2: u8 = fn_state.opc1;
        // D s_4332_3: read-var CRn:u8
        let s_4332_3: u8 = fn_state.CRn;
        // D s_4332_4: read-var opc2:u8
        let s_4332_4: u8 = fn_state.opc2;
        // D s_4332_5: read-var CRm:u8
        let s_4332_5: u8 = fn_state.CRm;
        // D s_4332_6: read-var t:i
        let s_4332_6: i128 = fn_state.t;
        // D s_4332_7: call TPIDRPRW_SysRegWrite32_5caaac18c68f924b(s_4332_0, s_4332_1, s_4332_2, s_4332_3, s_4332_4, s_4332_5, s_4332_6)
        let s_4332_7: () = TPIDRPRW_SysRegWrite32_5caaac18c68f924b(
            state,
            tracer,
            s_4332_0,
            s_4332_1,
            s_4332_2,
            s_4332_3,
            s_4332_4,
            s_4332_5,
            s_4332_6,
        );
        // N s_4332_8: return
        return;
    }
    fn block_4333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4333_0: read-var opc2:u8
        let s_4333_0: u8 = fn_state.opc2;
        // D s_4333_1: cast zx s_4333_0 -> bv
        let s_4333_1: Bits = Bits::new(s_4333_0 as u128, 3u16);
        // C s_4333_2: const #4u : u8
        let s_4333_2: u8 = 4;
        // C s_4333_3: cast zx s_4333_2 -> bv
        let s_4333_3: Bits = Bits::new(s_4333_2 as u128, 3u16);
        // D s_4333_4: cmp-eq s_4333_1 s_4333_3
        let s_4333_4: bool = ((s_4333_1) == (s_4333_3));
        // D s_4333_5: write-var gs#135595 <= s_4333_4
        fn_state.gs_135595 = s_4333_4;
        // N s_4333_6: jump b2510
        return block_2510(state, tracer, fn_state);
    }
    fn block_4334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4334_0: read-var opc1:u8
        let s_4334_0: u8 = fn_state.opc1;
        // D s_4334_1: cast zx s_4334_0 -> bv
        let s_4334_1: Bits = Bits::new(s_4334_0 as u128, 3u16);
        // C s_4334_2: const #0u : u8
        let s_4334_2: u8 = 0;
        // C s_4334_3: cast zx s_4334_2 -> bv
        let s_4334_3: Bits = Bits::new(s_4334_2 as u128, 3u16);
        // D s_4334_4: cmp-eq s_4334_1 s_4334_3
        let s_4334_4: bool = ((s_4334_1) == (s_4334_3));
        // D s_4334_5: write-var gs#135594 <= s_4334_4
        fn_state.gs_135594 = s_4334_4;
        // N s_4334_6: jump b2508
        return block_2508(state, tracer, fn_state);
    }
    fn block_4335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4335_0: read-var coproc:u8
        let s_4335_0: u8 = fn_state.coproc;
        // D s_4335_1: cast zx s_4335_0 -> bv
        let s_4335_1: Bits = Bits::new(s_4335_0 as u128, 4u16);
        // C s_4335_2: const #15u : u8
        let s_4335_2: u8 = 15;
        // C s_4335_3: cast zx s_4335_2 -> bv
        let s_4335_3: Bits = Bits::new(s_4335_2 as u128, 4u16);
        // D s_4335_4: cmp-eq s_4335_1 s_4335_3
        let s_4335_4: bool = ((s_4335_1) == (s_4335_3));
        // D s_4335_5: write-var gs#135593 <= s_4335_4
        fn_state.gs_135593 = s_4335_4;
        // N s_4335_6: jump b2506
        return block_2506(state, tracer, fn_state);
    }
    fn block_4336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4336_0: read-var CRn:u8
        let s_4336_0: u8 = fn_state.CRn;
        // D s_4336_1: cast zx s_4336_0 -> bv
        let s_4336_1: Bits = Bits::new(s_4336_0 as u128, 4u16);
        // C s_4336_2: const #13u : u8
        let s_4336_2: u8 = 13;
        // C s_4336_3: cast zx s_4336_2 -> bv
        let s_4336_3: Bits = Bits::new(s_4336_2 as u128, 4u16);
        // D s_4336_4: cmp-eq s_4336_1 s_4336_3
        let s_4336_4: bool = ((s_4336_1) == (s_4336_3));
        // D s_4336_5: write-var gs#135592 <= s_4336_4
        fn_state.gs_135592 = s_4336_4;
        // N s_4336_6: jump b2504
        return block_2504(state, tracer, fn_state);
    }
    fn block_4337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4337_0: read-var el:u8
        let s_4337_0: u8 = fn_state.el;
        // D s_4337_1: read-var coproc:u8
        let s_4337_1: u8 = fn_state.coproc;
        // D s_4337_2: read-var opc1:u8
        let s_4337_2: u8 = fn_state.opc1;
        // D s_4337_3: read-var CRn:u8
        let s_4337_3: u8 = fn_state.CRn;
        // D s_4337_4: read-var opc2:u8
        let s_4337_4: u8 = fn_state.opc2;
        // D s_4337_5: read-var CRm:u8
        let s_4337_5: u8 = fn_state.CRm;
        // D s_4337_6: read-var t:i
        let s_4337_6: i128 = fn_state.t;
        // D s_4337_7: call ATS1CPR_SysRegWrite32_810a4a7e2785c9d5(s_4337_0, s_4337_1, s_4337_2, s_4337_3, s_4337_4, s_4337_5, s_4337_6)
        let s_4337_7: () = ATS1CPR_SysRegWrite32_810a4a7e2785c9d5(
            state,
            tracer,
            s_4337_0,
            s_4337_1,
            s_4337_2,
            s_4337_3,
            s_4337_4,
            s_4337_5,
            s_4337_6,
        );
        // N s_4337_8: return
        return;
    }
    fn block_4338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4338_0: read-var opc2:u8
        let s_4338_0: u8 = fn_state.opc2;
        // D s_4338_1: cast zx s_4338_0 -> bv
        let s_4338_1: Bits = Bits::new(s_4338_0 as u128, 3u16);
        // C s_4338_2: const #0u : u8
        let s_4338_2: u8 = 0;
        // C s_4338_3: cast zx s_4338_2 -> bv
        let s_4338_3: Bits = Bits::new(s_4338_2 as u128, 3u16);
        // D s_4338_4: cmp-eq s_4338_1 s_4338_3
        let s_4338_4: bool = ((s_4338_1) == (s_4338_3));
        // D s_4338_5: write-var gs#135591 <= s_4338_4
        fn_state.gs_135591 = s_4338_4;
        // N s_4338_6: jump b2501
        return block_2501(state, tracer, fn_state);
    }
    fn block_4339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4339_0: read-var opc1:u8
        let s_4339_0: u8 = fn_state.opc1;
        // D s_4339_1: cast zx s_4339_0 -> bv
        let s_4339_1: Bits = Bits::new(s_4339_0 as u128, 3u16);
        // C s_4339_2: const #0u : u8
        let s_4339_2: u8 = 0;
        // C s_4339_3: cast zx s_4339_2 -> bv
        let s_4339_3: Bits = Bits::new(s_4339_2 as u128, 3u16);
        // D s_4339_4: cmp-eq s_4339_1 s_4339_3
        let s_4339_4: bool = ((s_4339_1) == (s_4339_3));
        // D s_4339_5: write-var gs#135590 <= s_4339_4
        fn_state.gs_135590 = s_4339_4;
        // N s_4339_6: jump b2499
        return block_2499(state, tracer, fn_state);
    }
    fn block_4340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4340_0: read-var coproc:u8
        let s_4340_0: u8 = fn_state.coproc;
        // D s_4340_1: cast zx s_4340_0 -> bv
        let s_4340_1: Bits = Bits::new(s_4340_0 as u128, 4u16);
        // C s_4340_2: const #15u : u8
        let s_4340_2: u8 = 15;
        // C s_4340_3: cast zx s_4340_2 -> bv
        let s_4340_3: Bits = Bits::new(s_4340_2 as u128, 4u16);
        // D s_4340_4: cmp-eq s_4340_1 s_4340_3
        let s_4340_4: bool = ((s_4340_1) == (s_4340_3));
        // D s_4340_5: write-var gs#135589 <= s_4340_4
        fn_state.gs_135589 = s_4340_4;
        // N s_4340_6: jump b2497
        return block_2497(state, tracer, fn_state);
    }
    fn block_4341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4341_0: read-var CRn:u8
        let s_4341_0: u8 = fn_state.CRn;
        // D s_4341_1: cast zx s_4341_0 -> bv
        let s_4341_1: Bits = Bits::new(s_4341_0 as u128, 4u16);
        // C s_4341_2: const #7u : u8
        let s_4341_2: u8 = 7;
        // C s_4341_3: cast zx s_4341_2 -> bv
        let s_4341_3: Bits = Bits::new(s_4341_2 as u128, 4u16);
        // D s_4341_4: cmp-eq s_4341_1 s_4341_3
        let s_4341_4: bool = ((s_4341_1) == (s_4341_3));
        // D s_4341_5: write-var gs#135588 <= s_4341_4
        fn_state.gs_135588 = s_4341_4;
        // N s_4341_6: jump b2495
        return block_2495(state, tracer, fn_state);
    }
    fn block_4342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4342_0: read-var el:u8
        let s_4342_0: u8 = fn_state.el;
        // D s_4342_1: read-var coproc:u8
        let s_4342_1: u8 = fn_state.coproc;
        // D s_4342_2: read-var opc1:u8
        let s_4342_2: u8 = fn_state.opc1;
        // D s_4342_3: read-var CRn:u8
        let s_4342_3: u8 = fn_state.CRn;
        // D s_4342_4: read-var opc2:u8
        let s_4342_4: u8 = fn_state.opc2;
        // D s_4342_5: read-var CRm:u8
        let s_4342_5: u8 = fn_state.CRm;
        // D s_4342_6: read-var t:i
        let s_4342_6: i128 = fn_state.t;
        // D s_4342_7: call ITLBIASID_SysRegWrite32_4c595ca2314b7198(s_4342_0, s_4342_1, s_4342_2, s_4342_3, s_4342_4, s_4342_5, s_4342_6)
        let s_4342_7: () = ITLBIASID_SysRegWrite32_4c595ca2314b7198(
            state,
            tracer,
            s_4342_0,
            s_4342_1,
            s_4342_2,
            s_4342_3,
            s_4342_4,
            s_4342_5,
            s_4342_6,
        );
        // N s_4342_8: return
        return;
    }
    fn block_4343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4343_0: read-var opc2:u8
        let s_4343_0: u8 = fn_state.opc2;
        // D s_4343_1: cast zx s_4343_0 -> bv
        let s_4343_1: Bits = Bits::new(s_4343_0 as u128, 3u16);
        // C s_4343_2: const #2u : u8
        let s_4343_2: u8 = 2;
        // C s_4343_3: cast zx s_4343_2 -> bv
        let s_4343_3: Bits = Bits::new(s_4343_2 as u128, 3u16);
        // D s_4343_4: cmp-eq s_4343_1 s_4343_3
        let s_4343_4: bool = ((s_4343_1) == (s_4343_3));
        // D s_4343_5: write-var gs#135587 <= s_4343_4
        fn_state.gs_135587 = s_4343_4;
        // N s_4343_6: jump b2492
        return block_2492(state, tracer, fn_state);
    }
    fn block_4344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4344_0: read-var opc1:u8
        let s_4344_0: u8 = fn_state.opc1;
        // D s_4344_1: cast zx s_4344_0 -> bv
        let s_4344_1: Bits = Bits::new(s_4344_0 as u128, 3u16);
        // C s_4344_2: const #0u : u8
        let s_4344_2: u8 = 0;
        // C s_4344_3: cast zx s_4344_2 -> bv
        let s_4344_3: Bits = Bits::new(s_4344_2 as u128, 3u16);
        // D s_4344_4: cmp-eq s_4344_1 s_4344_3
        let s_4344_4: bool = ((s_4344_1) == (s_4344_3));
        // D s_4344_5: write-var gs#135586 <= s_4344_4
        fn_state.gs_135586 = s_4344_4;
        // N s_4344_6: jump b2490
        return block_2490(state, tracer, fn_state);
    }
    fn block_4345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4345_0: read-var coproc:u8
        let s_4345_0: u8 = fn_state.coproc;
        // D s_4345_1: cast zx s_4345_0 -> bv
        let s_4345_1: Bits = Bits::new(s_4345_0 as u128, 4u16);
        // C s_4345_2: const #15u : u8
        let s_4345_2: u8 = 15;
        // C s_4345_3: cast zx s_4345_2 -> bv
        let s_4345_3: Bits = Bits::new(s_4345_2 as u128, 4u16);
        // D s_4345_4: cmp-eq s_4345_1 s_4345_3
        let s_4345_4: bool = ((s_4345_1) == (s_4345_3));
        // D s_4345_5: write-var gs#135585 <= s_4345_4
        fn_state.gs_135585 = s_4345_4;
        // N s_4345_6: jump b2488
        return block_2488(state, tracer, fn_state);
    }
    fn block_4346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4346_0: read-var CRn:u8
        let s_4346_0: u8 = fn_state.CRn;
        // D s_4346_1: cast zx s_4346_0 -> bv
        let s_4346_1: Bits = Bits::new(s_4346_0 as u128, 4u16);
        // C s_4346_2: const #8u : u8
        let s_4346_2: u8 = 8;
        // C s_4346_3: cast zx s_4346_2 -> bv
        let s_4346_3: Bits = Bits::new(s_4346_2 as u128, 4u16);
        // D s_4346_4: cmp-eq s_4346_1 s_4346_3
        let s_4346_4: bool = ((s_4346_1) == (s_4346_3));
        // D s_4346_5: write-var gs#135584 <= s_4346_4
        fn_state.gs_135584 = s_4346_4;
        // N s_4346_6: jump b2486
        return block_2486(state, tracer, fn_state);
    }
    fn block_4347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4347_0: read-var el:u8
        let s_4347_0: u8 = fn_state.el;
        // D s_4347_1: read-var coproc:u8
        let s_4347_1: u8 = fn_state.coproc;
        // D s_4347_2: read-var opc1:u8
        let s_4347_2: u8 = fn_state.opc1;
        // D s_4347_3: read-var CRn:u8
        let s_4347_3: u8 = fn_state.CRn;
        // D s_4347_4: read-var opc2:u8
        let s_4347_4: u8 = fn_state.opc2;
        // D s_4347_5: read-var CRm:u8
        let s_4347_5: u8 = fn_state.CRm;
        // D s_4347_6: read-var t:i
        let s_4347_6: i128 = fn_state.t;
        // D s_4347_7: call HDFAR_SysRegWrite32_6e5ea51e474140cb(s_4347_0, s_4347_1, s_4347_2, s_4347_3, s_4347_4, s_4347_5, s_4347_6)
        let s_4347_7: () = HDFAR_SysRegWrite32_6e5ea51e474140cb(
            state,
            tracer,
            s_4347_0,
            s_4347_1,
            s_4347_2,
            s_4347_3,
            s_4347_4,
            s_4347_5,
            s_4347_6,
        );
        // N s_4347_8: return
        return;
    }
    fn block_4348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4348_0: read-var opc2:u8
        let s_4348_0: u8 = fn_state.opc2;
        // D s_4348_1: cast zx s_4348_0 -> bv
        let s_4348_1: Bits = Bits::new(s_4348_0 as u128, 3u16);
        // C s_4348_2: const #0u : u8
        let s_4348_2: u8 = 0;
        // C s_4348_3: cast zx s_4348_2 -> bv
        let s_4348_3: Bits = Bits::new(s_4348_2 as u128, 3u16);
        // D s_4348_4: cmp-eq s_4348_1 s_4348_3
        let s_4348_4: bool = ((s_4348_1) == (s_4348_3));
        // D s_4348_5: write-var gs#135583 <= s_4348_4
        fn_state.gs_135583 = s_4348_4;
        // N s_4348_6: jump b2483
        return block_2483(state, tracer, fn_state);
    }
    fn block_4349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4349_0: read-var opc1:u8
        let s_4349_0: u8 = fn_state.opc1;
        // D s_4349_1: cast zx s_4349_0 -> bv
        let s_4349_1: Bits = Bits::new(s_4349_0 as u128, 3u16);
        // C s_4349_2: const #4u : u8
        let s_4349_2: u8 = 4;
        // C s_4349_3: cast zx s_4349_2 -> bv
        let s_4349_3: Bits = Bits::new(s_4349_2 as u128, 3u16);
        // D s_4349_4: cmp-eq s_4349_1 s_4349_3
        let s_4349_4: bool = ((s_4349_1) == (s_4349_3));
        // D s_4349_5: write-var gs#135582 <= s_4349_4
        fn_state.gs_135582 = s_4349_4;
        // N s_4349_6: jump b2481
        return block_2481(state, tracer, fn_state);
    }
    fn block_4350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4350_0: read-var coproc:u8
        let s_4350_0: u8 = fn_state.coproc;
        // D s_4350_1: cast zx s_4350_0 -> bv
        let s_4350_1: Bits = Bits::new(s_4350_0 as u128, 4u16);
        // C s_4350_2: const #15u : u8
        let s_4350_2: u8 = 15;
        // C s_4350_3: cast zx s_4350_2 -> bv
        let s_4350_3: Bits = Bits::new(s_4350_2 as u128, 4u16);
        // D s_4350_4: cmp-eq s_4350_1 s_4350_3
        let s_4350_4: bool = ((s_4350_1) == (s_4350_3));
        // D s_4350_5: write-var gs#135581 <= s_4350_4
        fn_state.gs_135581 = s_4350_4;
        // N s_4350_6: jump b2479
        return block_2479(state, tracer, fn_state);
    }
    fn block_4351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4351_0: read-var CRn:u8
        let s_4351_0: u8 = fn_state.CRn;
        // D s_4351_1: cast zx s_4351_0 -> bv
        let s_4351_1: Bits = Bits::new(s_4351_0 as u128, 4u16);
        // C s_4351_2: const #6u : u8
        let s_4351_2: u8 = 6;
        // C s_4351_3: cast zx s_4351_2 -> bv
        let s_4351_3: Bits = Bits::new(s_4351_2 as u128, 4u16);
        // D s_4351_4: cmp-eq s_4351_1 s_4351_3
        let s_4351_4: bool = ((s_4351_1) == (s_4351_3));
        // D s_4351_5: write-var gs#135580 <= s_4351_4
        fn_state.gs_135580 = s_4351_4;
        // N s_4351_6: jump b2477
        return block_2477(state, tracer, fn_state);
    }
    fn block_4352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4352_0: read-var el:u8
        let s_4352_0: u8 = fn_state.el;
        // D s_4352_1: read-var coproc:u8
        let s_4352_1: u8 = fn_state.coproc;
        // D s_4352_2: read-var opc1:u8
        let s_4352_2: u8 = fn_state.opc1;
        // D s_4352_3: read-var CRn:u8
        let s_4352_3: u8 = fn_state.CRn;
        // D s_4352_4: read-var opc2:u8
        let s_4352_4: u8 = fn_state.opc2;
        // D s_4352_5: read-var CRm:u8
        let s_4352_5: u8 = fn_state.CRm;
        // D s_4352_6: read-var t:i
        let s_4352_6: i128 = fn_state.t;
        // D s_4352_7: call IFSR_SysRegWrite32_86456fc11d1622be(s_4352_0, s_4352_1, s_4352_2, s_4352_3, s_4352_4, s_4352_5, s_4352_6)
        let s_4352_7: () = IFSR_SysRegWrite32_86456fc11d1622be(
            state,
            tracer,
            s_4352_0,
            s_4352_1,
            s_4352_2,
            s_4352_3,
            s_4352_4,
            s_4352_5,
            s_4352_6,
        );
        // N s_4352_8: return
        return;
    }
    fn block_4353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4353_0: read-var opc2:u8
        let s_4353_0: u8 = fn_state.opc2;
        // D s_4353_1: cast zx s_4353_0 -> bv
        let s_4353_1: Bits = Bits::new(s_4353_0 as u128, 3u16);
        // C s_4353_2: const #1u : u8
        let s_4353_2: u8 = 1;
        // C s_4353_3: cast zx s_4353_2 -> bv
        let s_4353_3: Bits = Bits::new(s_4353_2 as u128, 3u16);
        // D s_4353_4: cmp-eq s_4353_1 s_4353_3
        let s_4353_4: bool = ((s_4353_1) == (s_4353_3));
        // D s_4353_5: write-var gs#135579 <= s_4353_4
        fn_state.gs_135579 = s_4353_4;
        // N s_4353_6: jump b2474
        return block_2474(state, tracer, fn_state);
    }
    fn block_4354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4354_0: read-var opc1:u8
        let s_4354_0: u8 = fn_state.opc1;
        // D s_4354_1: cast zx s_4354_0 -> bv
        let s_4354_1: Bits = Bits::new(s_4354_0 as u128, 3u16);
        // C s_4354_2: const #0u : u8
        let s_4354_2: u8 = 0;
        // C s_4354_3: cast zx s_4354_2 -> bv
        let s_4354_3: Bits = Bits::new(s_4354_2 as u128, 3u16);
        // D s_4354_4: cmp-eq s_4354_1 s_4354_3
        let s_4354_4: bool = ((s_4354_1) == (s_4354_3));
        // D s_4354_5: write-var gs#135578 <= s_4354_4
        fn_state.gs_135578 = s_4354_4;
        // N s_4354_6: jump b2472
        return block_2472(state, tracer, fn_state);
    }
    fn block_4355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4355_0: read-var coproc:u8
        let s_4355_0: u8 = fn_state.coproc;
        // D s_4355_1: cast zx s_4355_0 -> bv
        let s_4355_1: Bits = Bits::new(s_4355_0 as u128, 4u16);
        // C s_4355_2: const #15u : u8
        let s_4355_2: u8 = 15;
        // C s_4355_3: cast zx s_4355_2 -> bv
        let s_4355_3: Bits = Bits::new(s_4355_2 as u128, 4u16);
        // D s_4355_4: cmp-eq s_4355_1 s_4355_3
        let s_4355_4: bool = ((s_4355_1) == (s_4355_3));
        // D s_4355_5: write-var gs#135577 <= s_4355_4
        fn_state.gs_135577 = s_4355_4;
        // N s_4355_6: jump b2470
        return block_2470(state, tracer, fn_state);
    }
    fn block_4356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4356_0: read-var CRn:u8
        let s_4356_0: u8 = fn_state.CRn;
        // D s_4356_1: cast zx s_4356_0 -> bv
        let s_4356_1: Bits = Bits::new(s_4356_0 as u128, 4u16);
        // C s_4356_2: const #5u : u8
        let s_4356_2: u8 = 5;
        // C s_4356_3: cast zx s_4356_2 -> bv
        let s_4356_3: Bits = Bits::new(s_4356_2 as u128, 4u16);
        // D s_4356_4: cmp-eq s_4356_1 s_4356_3
        let s_4356_4: bool = ((s_4356_1) == (s_4356_3));
        // D s_4356_5: write-var gs#135576 <= s_4356_4
        fn_state.gs_135576 = s_4356_4;
        // N s_4356_6: jump b2468
        return block_2468(state, tracer, fn_state);
    }
    fn block_4357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4357_0: read-var el:u8
        let s_4357_0: u8 = fn_state.el;
        // D s_4357_1: read-var coproc:u8
        let s_4357_1: u8 = fn_state.coproc;
        // D s_4357_2: read-var opc1:u8
        let s_4357_2: u8 = fn_state.opc1;
        // D s_4357_3: read-var CRn:u8
        let s_4357_3: u8 = fn_state.CRn;
        // D s_4357_4: read-var opc2:u8
        let s_4357_4: u8 = fn_state.opc2;
        // D s_4357_5: read-var CRm:u8
        let s_4357_5: u8 = fn_state.CRm;
        // D s_4357_6: read-var t:i
        let s_4357_6: i128 = fn_state.t;
        // D s_4357_7: call DBGDSCRext_SysRegWrite32_4b0433917fc9c43d(s_4357_0, s_4357_1, s_4357_2, s_4357_3, s_4357_4, s_4357_5, s_4357_6)
        let s_4357_7: () = DBGDSCRext_SysRegWrite32_4b0433917fc9c43d(
            state,
            tracer,
            s_4357_0,
            s_4357_1,
            s_4357_2,
            s_4357_3,
            s_4357_4,
            s_4357_5,
            s_4357_6,
        );
        // N s_4357_8: return
        return;
    }
    fn block_4358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4358_0: read-var opc2:u8
        let s_4358_0: u8 = fn_state.opc2;
        // D s_4358_1: cast zx s_4358_0 -> bv
        let s_4358_1: Bits = Bits::new(s_4358_0 as u128, 3u16);
        // C s_4358_2: const #2u : u8
        let s_4358_2: u8 = 2;
        // C s_4358_3: cast zx s_4358_2 -> bv
        let s_4358_3: Bits = Bits::new(s_4358_2 as u128, 3u16);
        // D s_4358_4: cmp-eq s_4358_1 s_4358_3
        let s_4358_4: bool = ((s_4358_1) == (s_4358_3));
        // D s_4358_5: write-var gs#135575 <= s_4358_4
        fn_state.gs_135575 = s_4358_4;
        // N s_4358_6: jump b2465
        return block_2465(state, tracer, fn_state);
    }
    fn block_4359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4359_0: read-var opc1:u8
        let s_4359_0: u8 = fn_state.opc1;
        // D s_4359_1: cast zx s_4359_0 -> bv
        let s_4359_1: Bits = Bits::new(s_4359_0 as u128, 3u16);
        // C s_4359_2: const #0u : u8
        let s_4359_2: u8 = 0;
        // C s_4359_3: cast zx s_4359_2 -> bv
        let s_4359_3: Bits = Bits::new(s_4359_2 as u128, 3u16);
        // D s_4359_4: cmp-eq s_4359_1 s_4359_3
        let s_4359_4: bool = ((s_4359_1) == (s_4359_3));
        // D s_4359_5: write-var gs#135574 <= s_4359_4
        fn_state.gs_135574 = s_4359_4;
        // N s_4359_6: jump b2463
        return block_2463(state, tracer, fn_state);
    }
    fn block_4360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4360_0: read-var coproc:u8
        let s_4360_0: u8 = fn_state.coproc;
        // D s_4360_1: cast zx s_4360_0 -> bv
        let s_4360_1: Bits = Bits::new(s_4360_0 as u128, 4u16);
        // C s_4360_2: const #14u : u8
        let s_4360_2: u8 = 14;
        // C s_4360_3: cast zx s_4360_2 -> bv
        let s_4360_3: Bits = Bits::new(s_4360_2 as u128, 4u16);
        // D s_4360_4: cmp-eq s_4360_1 s_4360_3
        let s_4360_4: bool = ((s_4360_1) == (s_4360_3));
        // D s_4360_5: write-var gs#135573 <= s_4360_4
        fn_state.gs_135573 = s_4360_4;
        // N s_4360_6: jump b2461
        return block_2461(state, tracer, fn_state);
    }
    fn block_4361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4361_0: read-var CRn:u8
        let s_4361_0: u8 = fn_state.CRn;
        // D s_4361_1: cast zx s_4361_0 -> bv
        let s_4361_1: Bits = Bits::new(s_4361_0 as u128, 4u16);
        // C s_4361_2: const #0u : u8
        let s_4361_2: u8 = 0;
        // C s_4361_3: cast zx s_4361_2 -> bv
        let s_4361_3: Bits = Bits::new(s_4361_2 as u128, 4u16);
        // D s_4361_4: cmp-eq s_4361_1 s_4361_3
        let s_4361_4: bool = ((s_4361_1) == (s_4361_3));
        // D s_4361_5: write-var gs#135572 <= s_4361_4
        fn_state.gs_135572 = s_4361_4;
        // N s_4361_6: jump b2459
        return block_2459(state, tracer, fn_state);
    }
    fn block_4362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4362_0: read-var el:u8
        let s_4362_0: u8 = fn_state.el;
        // D s_4362_1: read-var coproc:u8
        let s_4362_1: u8 = fn_state.coproc;
        // D s_4362_2: read-var opc1:u8
        let s_4362_2: u8 = fn_state.opc1;
        // D s_4362_3: read-var CRn:u8
        let s_4362_3: u8 = fn_state.CRn;
        // D s_4362_4: read-var opc2:u8
        let s_4362_4: u8 = fn_state.opc2;
        // D s_4362_5: read-var CRm:u8
        let s_4362_5: u8 = fn_state.CRm;
        // D s_4362_6: read-var t:i
        let s_4362_6: i128 = fn_state.t;
        // D s_4362_7: call DBGDCCINT_SysRegWrite32_6f112e4954747b48(s_4362_0, s_4362_1, s_4362_2, s_4362_3, s_4362_4, s_4362_5, s_4362_6)
        let s_4362_7: () = DBGDCCINT_SysRegWrite32_6f112e4954747b48(
            state,
            tracer,
            s_4362_0,
            s_4362_1,
            s_4362_2,
            s_4362_3,
            s_4362_4,
            s_4362_5,
            s_4362_6,
        );
        // N s_4362_8: return
        return;
    }
    fn block_4363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4363_0: read-var opc2:u8
        let s_4363_0: u8 = fn_state.opc2;
        // D s_4363_1: cast zx s_4363_0 -> bv
        let s_4363_1: Bits = Bits::new(s_4363_0 as u128, 3u16);
        // C s_4363_2: const #0u : u8
        let s_4363_2: u8 = 0;
        // C s_4363_3: cast zx s_4363_2 -> bv
        let s_4363_3: Bits = Bits::new(s_4363_2 as u128, 3u16);
        // D s_4363_4: cmp-eq s_4363_1 s_4363_3
        let s_4363_4: bool = ((s_4363_1) == (s_4363_3));
        // D s_4363_5: write-var gs#135571 <= s_4363_4
        fn_state.gs_135571 = s_4363_4;
        // N s_4363_6: jump b2456
        return block_2456(state, tracer, fn_state);
    }
    fn block_4364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4364_0: read-var opc1:u8
        let s_4364_0: u8 = fn_state.opc1;
        // D s_4364_1: cast zx s_4364_0 -> bv
        let s_4364_1: Bits = Bits::new(s_4364_0 as u128, 3u16);
        // C s_4364_2: const #0u : u8
        let s_4364_2: u8 = 0;
        // C s_4364_3: cast zx s_4364_2 -> bv
        let s_4364_3: Bits = Bits::new(s_4364_2 as u128, 3u16);
        // D s_4364_4: cmp-eq s_4364_1 s_4364_3
        let s_4364_4: bool = ((s_4364_1) == (s_4364_3));
        // D s_4364_5: write-var gs#135570 <= s_4364_4
        fn_state.gs_135570 = s_4364_4;
        // N s_4364_6: jump b2454
        return block_2454(state, tracer, fn_state);
    }
    fn block_4365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4365_0: read-var coproc:u8
        let s_4365_0: u8 = fn_state.coproc;
        // D s_4365_1: cast zx s_4365_0 -> bv
        let s_4365_1: Bits = Bits::new(s_4365_0 as u128, 4u16);
        // C s_4365_2: const #14u : u8
        let s_4365_2: u8 = 14;
        // C s_4365_3: cast zx s_4365_2 -> bv
        let s_4365_3: Bits = Bits::new(s_4365_2 as u128, 4u16);
        // D s_4365_4: cmp-eq s_4365_1 s_4365_3
        let s_4365_4: bool = ((s_4365_1) == (s_4365_3));
        // D s_4365_5: write-var gs#135569 <= s_4365_4
        fn_state.gs_135569 = s_4365_4;
        // N s_4365_6: jump b2452
        return block_2452(state, tracer, fn_state);
    }
    fn block_4366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4366_0: read-var CRn:u8
        let s_4366_0: u8 = fn_state.CRn;
        // D s_4366_1: cast zx s_4366_0 -> bv
        let s_4366_1: Bits = Bits::new(s_4366_0 as u128, 4u16);
        // C s_4366_2: const #0u : u8
        let s_4366_2: u8 = 0;
        // C s_4366_3: cast zx s_4366_2 -> bv
        let s_4366_3: Bits = Bits::new(s_4366_2 as u128, 4u16);
        // D s_4366_4: cmp-eq s_4366_1 s_4366_3
        let s_4366_4: bool = ((s_4366_1) == (s_4366_3));
        // D s_4366_5: write-var gs#135568 <= s_4366_4
        fn_state.gs_135568 = s_4366_4;
        // N s_4366_6: jump b2450
        return block_2450(state, tracer, fn_state);
    }
    fn block_4367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4367_0: read-var el:u8
        let s_4367_0: u8 = fn_state.el;
        // D s_4367_1: read-var coproc:u8
        let s_4367_1: u8 = fn_state.coproc;
        // D s_4367_2: read-var opc1:u8
        let s_4367_2: u8 = fn_state.opc1;
        // D s_4367_3: read-var CRn:u8
        let s_4367_3: u8 = fn_state.CRn;
        // D s_4367_4: read-var opc2:u8
        let s_4367_4: u8 = fn_state.opc2;
        // D s_4367_5: read-var CRm:u8
        let s_4367_5: u8 = fn_state.CRm;
        // D s_4367_6: read-var t:i
        let s_4367_6: i128 = fn_state.t;
        // D s_4367_7: call SCTLR_SysRegWrite32_88c9496795c226a4(s_4367_0, s_4367_1, s_4367_2, s_4367_3, s_4367_4, s_4367_5, s_4367_6)
        let s_4367_7: () = SCTLR_SysRegWrite32_88c9496795c226a4(
            state,
            tracer,
            s_4367_0,
            s_4367_1,
            s_4367_2,
            s_4367_3,
            s_4367_4,
            s_4367_5,
            s_4367_6,
        );
        // N s_4367_8: return
        return;
    }
    fn block_4368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4368_0: read-var opc2:u8
        let s_4368_0: u8 = fn_state.opc2;
        // D s_4368_1: cast zx s_4368_0 -> bv
        let s_4368_1: Bits = Bits::new(s_4368_0 as u128, 3u16);
        // C s_4368_2: const #0u : u8
        let s_4368_2: u8 = 0;
        // C s_4368_3: cast zx s_4368_2 -> bv
        let s_4368_3: Bits = Bits::new(s_4368_2 as u128, 3u16);
        // D s_4368_4: cmp-eq s_4368_1 s_4368_3
        let s_4368_4: bool = ((s_4368_1) == (s_4368_3));
        // D s_4368_5: write-var gs#135567 <= s_4368_4
        fn_state.gs_135567 = s_4368_4;
        // N s_4368_6: jump b2447
        return block_2447(state, tracer, fn_state);
    }
    fn block_4369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4369_0: read-var opc1:u8
        let s_4369_0: u8 = fn_state.opc1;
        // D s_4369_1: cast zx s_4369_0 -> bv
        let s_4369_1: Bits = Bits::new(s_4369_0 as u128, 3u16);
        // C s_4369_2: const #0u : u8
        let s_4369_2: u8 = 0;
        // C s_4369_3: cast zx s_4369_2 -> bv
        let s_4369_3: Bits = Bits::new(s_4369_2 as u128, 3u16);
        // D s_4369_4: cmp-eq s_4369_1 s_4369_3
        let s_4369_4: bool = ((s_4369_1) == (s_4369_3));
        // D s_4369_5: write-var gs#135566 <= s_4369_4
        fn_state.gs_135566 = s_4369_4;
        // N s_4369_6: jump b2445
        return block_2445(state, tracer, fn_state);
    }
    fn block_4370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4370_0: read-var coproc:u8
        let s_4370_0: u8 = fn_state.coproc;
        // D s_4370_1: cast zx s_4370_0 -> bv
        let s_4370_1: Bits = Bits::new(s_4370_0 as u128, 4u16);
        // C s_4370_2: const #15u : u8
        let s_4370_2: u8 = 15;
        // C s_4370_3: cast zx s_4370_2 -> bv
        let s_4370_3: Bits = Bits::new(s_4370_2 as u128, 4u16);
        // D s_4370_4: cmp-eq s_4370_1 s_4370_3
        let s_4370_4: bool = ((s_4370_1) == (s_4370_3));
        // D s_4370_5: write-var gs#135565 <= s_4370_4
        fn_state.gs_135565 = s_4370_4;
        // N s_4370_6: jump b2443
        return block_2443(state, tracer, fn_state);
    }
    fn block_4371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4371_0: read-var CRn:u8
        let s_4371_0: u8 = fn_state.CRn;
        // D s_4371_1: cast zx s_4371_0 -> bv
        let s_4371_1: Bits = Bits::new(s_4371_0 as u128, 4u16);
        // C s_4371_2: const #1u : u8
        let s_4371_2: u8 = 1;
        // C s_4371_3: cast zx s_4371_2 -> bv
        let s_4371_3: Bits = Bits::new(s_4371_2 as u128, 4u16);
        // D s_4371_4: cmp-eq s_4371_1 s_4371_3
        let s_4371_4: bool = ((s_4371_1) == (s_4371_3));
        // D s_4371_5: write-var gs#135564 <= s_4371_4
        fn_state.gs_135564 = s_4371_4;
        // N s_4371_6: jump b2441
        return block_2441(state, tracer, fn_state);
    }
    fn block_4372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4372_0: read-var el:u8
        let s_4372_0: u8 = fn_state.el;
        // D s_4372_1: read-var coproc:u8
        let s_4372_1: u8 = fn_state.coproc;
        // D s_4372_2: read-var opc1:u8
        let s_4372_2: u8 = fn_state.opc1;
        // D s_4372_3: read-var CRn:u8
        let s_4372_3: u8 = fn_state.CRn;
        // D s_4372_4: read-var opc2:u8
        let s_4372_4: u8 = fn_state.opc2;
        // D s_4372_5: read-var CRm:u8
        let s_4372_5: u8 = fn_state.CRm;
        // D s_4372_6: read-var t:i
        let s_4372_6: i128 = fn_state.t;
        // D s_4372_7: call HAIFSR_SysRegWrite32_a1d071280f147e46(s_4372_0, s_4372_1, s_4372_2, s_4372_3, s_4372_4, s_4372_5, s_4372_6)
        let s_4372_7: () = HAIFSR_SysRegWrite32_a1d071280f147e46(
            state,
            tracer,
            s_4372_0,
            s_4372_1,
            s_4372_2,
            s_4372_3,
            s_4372_4,
            s_4372_5,
            s_4372_6,
        );
        // N s_4372_8: return
        return;
    }
    fn block_4373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4373_0: read-var opc2:u8
        let s_4373_0: u8 = fn_state.opc2;
        // D s_4373_1: cast zx s_4373_0 -> bv
        let s_4373_1: Bits = Bits::new(s_4373_0 as u128, 3u16);
        // C s_4373_2: const #1u : u8
        let s_4373_2: u8 = 1;
        // C s_4373_3: cast zx s_4373_2 -> bv
        let s_4373_3: Bits = Bits::new(s_4373_2 as u128, 3u16);
        // D s_4373_4: cmp-eq s_4373_1 s_4373_3
        let s_4373_4: bool = ((s_4373_1) == (s_4373_3));
        // D s_4373_5: write-var gs#135563 <= s_4373_4
        fn_state.gs_135563 = s_4373_4;
        // N s_4373_6: jump b2438
        return block_2438(state, tracer, fn_state);
    }
    fn block_4374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4374_0: read-var opc1:u8
        let s_4374_0: u8 = fn_state.opc1;
        // D s_4374_1: cast zx s_4374_0 -> bv
        let s_4374_1: Bits = Bits::new(s_4374_0 as u128, 3u16);
        // C s_4374_2: const #4u : u8
        let s_4374_2: u8 = 4;
        // C s_4374_3: cast zx s_4374_2 -> bv
        let s_4374_3: Bits = Bits::new(s_4374_2 as u128, 3u16);
        // D s_4374_4: cmp-eq s_4374_1 s_4374_3
        let s_4374_4: bool = ((s_4374_1) == (s_4374_3));
        // D s_4374_5: write-var gs#135562 <= s_4374_4
        fn_state.gs_135562 = s_4374_4;
        // N s_4374_6: jump b2436
        return block_2436(state, tracer, fn_state);
    }
    fn block_4375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4375_0: read-var coproc:u8
        let s_4375_0: u8 = fn_state.coproc;
        // D s_4375_1: cast zx s_4375_0 -> bv
        let s_4375_1: Bits = Bits::new(s_4375_0 as u128, 4u16);
        // C s_4375_2: const #15u : u8
        let s_4375_2: u8 = 15;
        // C s_4375_3: cast zx s_4375_2 -> bv
        let s_4375_3: Bits = Bits::new(s_4375_2 as u128, 4u16);
        // D s_4375_4: cmp-eq s_4375_1 s_4375_3
        let s_4375_4: bool = ((s_4375_1) == (s_4375_3));
        // D s_4375_5: write-var gs#135561 <= s_4375_4
        fn_state.gs_135561 = s_4375_4;
        // N s_4375_6: jump b2434
        return block_2434(state, tracer, fn_state);
    }
    fn block_4376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4376_0: read-var CRn:u8
        let s_4376_0: u8 = fn_state.CRn;
        // D s_4376_1: cast zx s_4376_0 -> bv
        let s_4376_1: Bits = Bits::new(s_4376_0 as u128, 4u16);
        // C s_4376_2: const #5u : u8
        let s_4376_2: u8 = 5;
        // C s_4376_3: cast zx s_4376_2 -> bv
        let s_4376_3: Bits = Bits::new(s_4376_2 as u128, 4u16);
        // D s_4376_4: cmp-eq s_4376_1 s_4376_3
        let s_4376_4: bool = ((s_4376_1) == (s_4376_3));
        // D s_4376_5: write-var gs#135560 <= s_4376_4
        fn_state.gs_135560 = s_4376_4;
        // N s_4376_6: jump b2432
        return block_2432(state, tracer, fn_state);
    }
    fn block_4377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4377_0: read-var el:u8
        let s_4377_0: u8 = fn_state.el;
        // D s_4377_1: read-var coproc:u8
        let s_4377_1: u8 = fn_state.coproc;
        // D s_4377_2: read-var opc1:u8
        let s_4377_2: u8 = fn_state.opc1;
        // D s_4377_3: read-var CRn:u8
        let s_4377_3: u8 = fn_state.CRn;
        // D s_4377_4: read-var opc2:u8
        let s_4377_4: u8 = fn_state.opc2;
        // D s_4377_5: read-var CRm:u8
        let s_4377_5: u8 = fn_state.CRm;
        // D s_4377_6: read-var t:i
        let s_4377_6: i128 = fn_state.t;
        // D s_4377_7: call ATS1CPRP_SysRegWrite32_42119243d95c582f(s_4377_0, s_4377_1, s_4377_2, s_4377_3, s_4377_4, s_4377_5, s_4377_6)
        let s_4377_7: () = ATS1CPRP_SysRegWrite32_42119243d95c582f(
            state,
            tracer,
            s_4377_0,
            s_4377_1,
            s_4377_2,
            s_4377_3,
            s_4377_4,
            s_4377_5,
            s_4377_6,
        );
        // N s_4377_8: return
        return;
    }
    fn block_4378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4378_0: read-var opc2:u8
        let s_4378_0: u8 = fn_state.opc2;
        // D s_4378_1: cast zx s_4378_0 -> bv
        let s_4378_1: Bits = Bits::new(s_4378_0 as u128, 3u16);
        // C s_4378_2: const #0u : u8
        let s_4378_2: u8 = 0;
        // C s_4378_3: cast zx s_4378_2 -> bv
        let s_4378_3: Bits = Bits::new(s_4378_2 as u128, 3u16);
        // D s_4378_4: cmp-eq s_4378_1 s_4378_3
        let s_4378_4: bool = ((s_4378_1) == (s_4378_3));
        // D s_4378_5: write-var gs#135559 <= s_4378_4
        fn_state.gs_135559 = s_4378_4;
        // N s_4378_6: jump b2429
        return block_2429(state, tracer, fn_state);
    }
    fn block_4379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4379_0: read-var opc1:u8
        let s_4379_0: u8 = fn_state.opc1;
        // D s_4379_1: cast zx s_4379_0 -> bv
        let s_4379_1: Bits = Bits::new(s_4379_0 as u128, 3u16);
        // C s_4379_2: const #0u : u8
        let s_4379_2: u8 = 0;
        // C s_4379_3: cast zx s_4379_2 -> bv
        let s_4379_3: Bits = Bits::new(s_4379_2 as u128, 3u16);
        // D s_4379_4: cmp-eq s_4379_1 s_4379_3
        let s_4379_4: bool = ((s_4379_1) == (s_4379_3));
        // D s_4379_5: write-var gs#135558 <= s_4379_4
        fn_state.gs_135558 = s_4379_4;
        // N s_4379_6: jump b2427
        return block_2427(state, tracer, fn_state);
    }
    fn block_4380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4380_0: read-var coproc:u8
        let s_4380_0: u8 = fn_state.coproc;
        // D s_4380_1: cast zx s_4380_0 -> bv
        let s_4380_1: Bits = Bits::new(s_4380_0 as u128, 4u16);
        // C s_4380_2: const #15u : u8
        let s_4380_2: u8 = 15;
        // C s_4380_3: cast zx s_4380_2 -> bv
        let s_4380_3: Bits = Bits::new(s_4380_2 as u128, 4u16);
        // D s_4380_4: cmp-eq s_4380_1 s_4380_3
        let s_4380_4: bool = ((s_4380_1) == (s_4380_3));
        // D s_4380_5: write-var gs#135557 <= s_4380_4
        fn_state.gs_135557 = s_4380_4;
        // N s_4380_6: jump b2425
        return block_2425(state, tracer, fn_state);
    }
    fn block_4381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4381_0: read-var CRn:u8
        let s_4381_0: u8 = fn_state.CRn;
        // D s_4381_1: cast zx s_4381_0 -> bv
        let s_4381_1: Bits = Bits::new(s_4381_0 as u128, 4u16);
        // C s_4381_2: const #7u : u8
        let s_4381_2: u8 = 7;
        // C s_4381_3: cast zx s_4381_2 -> bv
        let s_4381_3: Bits = Bits::new(s_4381_2 as u128, 4u16);
        // D s_4381_4: cmp-eq s_4381_1 s_4381_3
        let s_4381_4: bool = ((s_4381_1) == (s_4381_3));
        // D s_4381_5: write-var gs#135556 <= s_4381_4
        fn_state.gs_135556 = s_4381_4;
        // N s_4381_6: jump b2423
        return block_2423(state, tracer, fn_state);
    }
    fn block_4382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4382_0: read-var el:u8
        let s_4382_0: u8 = fn_state.el;
        // D s_4382_1: read-var coproc:u8
        let s_4382_1: u8 = fn_state.coproc;
        // D s_4382_2: read-var opc1:u8
        let s_4382_2: u8 = fn_state.opc1;
        // D s_4382_3: read-var CRn:u8
        let s_4382_3: u8 = fn_state.CRn;
        // D s_4382_4: read-var opc2:u8
        let s_4382_4: u8 = fn_state.opc2;
        // D s_4382_5: read-var CRm:u8
        let s_4382_5: u8 = fn_state.CRm;
        // D s_4382_6: read-var t:i
        let s_4382_6: i128 = fn_state.t;
        // D s_4382_7: call DCCMVAC_SysRegWrite32_acc09968a78b7280(s_4382_0, s_4382_1, s_4382_2, s_4382_3, s_4382_4, s_4382_5, s_4382_6)
        let s_4382_7: () = DCCMVAC_SysRegWrite32_acc09968a78b7280(
            state,
            tracer,
            s_4382_0,
            s_4382_1,
            s_4382_2,
            s_4382_3,
            s_4382_4,
            s_4382_5,
            s_4382_6,
        );
        // N s_4382_8: return
        return;
    }
    fn block_4383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4383_0: read-var opc2:u8
        let s_4383_0: u8 = fn_state.opc2;
        // D s_4383_1: cast zx s_4383_0 -> bv
        let s_4383_1: Bits = Bits::new(s_4383_0 as u128, 3u16);
        // C s_4383_2: const #1u : u8
        let s_4383_2: u8 = 1;
        // C s_4383_3: cast zx s_4383_2 -> bv
        let s_4383_3: Bits = Bits::new(s_4383_2 as u128, 3u16);
        // D s_4383_4: cmp-eq s_4383_1 s_4383_3
        let s_4383_4: bool = ((s_4383_1) == (s_4383_3));
        // D s_4383_5: write-var gs#135555 <= s_4383_4
        fn_state.gs_135555 = s_4383_4;
        // N s_4383_6: jump b2420
        return block_2420(state, tracer, fn_state);
    }
    fn block_4384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4384_0: read-var opc1:u8
        let s_4384_0: u8 = fn_state.opc1;
        // D s_4384_1: cast zx s_4384_0 -> bv
        let s_4384_1: Bits = Bits::new(s_4384_0 as u128, 3u16);
        // C s_4384_2: const #0u : u8
        let s_4384_2: u8 = 0;
        // C s_4384_3: cast zx s_4384_2 -> bv
        let s_4384_3: Bits = Bits::new(s_4384_2 as u128, 3u16);
        // D s_4384_4: cmp-eq s_4384_1 s_4384_3
        let s_4384_4: bool = ((s_4384_1) == (s_4384_3));
        // D s_4384_5: write-var gs#135554 <= s_4384_4
        fn_state.gs_135554 = s_4384_4;
        // N s_4384_6: jump b2418
        return block_2418(state, tracer, fn_state);
    }
    fn block_4385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4385_0: read-var coproc:u8
        let s_4385_0: u8 = fn_state.coproc;
        // D s_4385_1: cast zx s_4385_0 -> bv
        let s_4385_1: Bits = Bits::new(s_4385_0 as u128, 4u16);
        // C s_4385_2: const #15u : u8
        let s_4385_2: u8 = 15;
        // C s_4385_3: cast zx s_4385_2 -> bv
        let s_4385_3: Bits = Bits::new(s_4385_2 as u128, 4u16);
        // D s_4385_4: cmp-eq s_4385_1 s_4385_3
        let s_4385_4: bool = ((s_4385_1) == (s_4385_3));
        // D s_4385_5: write-var gs#135553 <= s_4385_4
        fn_state.gs_135553 = s_4385_4;
        // N s_4385_6: jump b2416
        return block_2416(state, tracer, fn_state);
    }
    fn block_4386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4386_0: read-var CRn:u8
        let s_4386_0: u8 = fn_state.CRn;
        // D s_4386_1: cast zx s_4386_0 -> bv
        let s_4386_1: Bits = Bits::new(s_4386_0 as u128, 4u16);
        // C s_4386_2: const #7u : u8
        let s_4386_2: u8 = 7;
        // C s_4386_3: cast zx s_4386_2 -> bv
        let s_4386_3: Bits = Bits::new(s_4386_2 as u128, 4u16);
        // D s_4386_4: cmp-eq s_4386_1 s_4386_3
        let s_4386_4: bool = ((s_4386_1) == (s_4386_3));
        // D s_4386_5: write-var gs#135552 <= s_4386_4
        fn_state.gs_135552 = s_4386_4;
        // N s_4386_6: jump b2414
        return block_2414(state, tracer, fn_state);
    }
    fn block_4387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4387_0: read-var el:u8
        let s_4387_0: u8 = fn_state.el;
        // D s_4387_1: read-var coproc:u8
        let s_4387_1: u8 = fn_state.coproc;
        // D s_4387_2: read-var opc1:u8
        let s_4387_2: u8 = fn_state.opc1;
        // D s_4387_3: read-var CRn:u8
        let s_4387_3: u8 = fn_state.CRn;
        // D s_4387_4: read-var opc2:u8
        let s_4387_4: u8 = fn_state.opc2;
        // D s_4387_5: read-var CRm:u8
        let s_4387_5: u8 = fn_state.CRm;
        // D s_4387_6: read-var t:i
        let s_4387_6: i128 = fn_state.t;
        // D s_4387_7: call HAMAIR1_SysRegWrite32_65d7b8ceff16c815(s_4387_0, s_4387_1, s_4387_2, s_4387_3, s_4387_4, s_4387_5, s_4387_6)
        let s_4387_7: () = HAMAIR1_SysRegWrite32_65d7b8ceff16c815(
            state,
            tracer,
            s_4387_0,
            s_4387_1,
            s_4387_2,
            s_4387_3,
            s_4387_4,
            s_4387_5,
            s_4387_6,
        );
        // N s_4387_8: return
        return;
    }
    fn block_4388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4388_0: read-var opc2:u8
        let s_4388_0: u8 = fn_state.opc2;
        // D s_4388_1: cast zx s_4388_0 -> bv
        let s_4388_1: Bits = Bits::new(s_4388_0 as u128, 3u16);
        // C s_4388_2: const #1u : u8
        let s_4388_2: u8 = 1;
        // C s_4388_3: cast zx s_4388_2 -> bv
        let s_4388_3: Bits = Bits::new(s_4388_2 as u128, 3u16);
        // D s_4388_4: cmp-eq s_4388_1 s_4388_3
        let s_4388_4: bool = ((s_4388_1) == (s_4388_3));
        // D s_4388_5: write-var gs#135551 <= s_4388_4
        fn_state.gs_135551 = s_4388_4;
        // N s_4388_6: jump b2411
        return block_2411(state, tracer, fn_state);
    }
    fn block_4389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4389_0: read-var opc1:u8
        let s_4389_0: u8 = fn_state.opc1;
        // D s_4389_1: cast zx s_4389_0 -> bv
        let s_4389_1: Bits = Bits::new(s_4389_0 as u128, 3u16);
        // C s_4389_2: const #4u : u8
        let s_4389_2: u8 = 4;
        // C s_4389_3: cast zx s_4389_2 -> bv
        let s_4389_3: Bits = Bits::new(s_4389_2 as u128, 3u16);
        // D s_4389_4: cmp-eq s_4389_1 s_4389_3
        let s_4389_4: bool = ((s_4389_1) == (s_4389_3));
        // D s_4389_5: write-var gs#135550 <= s_4389_4
        fn_state.gs_135550 = s_4389_4;
        // N s_4389_6: jump b2409
        return block_2409(state, tracer, fn_state);
    }
    fn block_4390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4390_0: read-var coproc:u8
        let s_4390_0: u8 = fn_state.coproc;
        // D s_4390_1: cast zx s_4390_0 -> bv
        let s_4390_1: Bits = Bits::new(s_4390_0 as u128, 4u16);
        // C s_4390_2: const #15u : u8
        let s_4390_2: u8 = 15;
        // C s_4390_3: cast zx s_4390_2 -> bv
        let s_4390_3: Bits = Bits::new(s_4390_2 as u128, 4u16);
        // D s_4390_4: cmp-eq s_4390_1 s_4390_3
        let s_4390_4: bool = ((s_4390_1) == (s_4390_3));
        // D s_4390_5: write-var gs#135549 <= s_4390_4
        fn_state.gs_135549 = s_4390_4;
        // N s_4390_6: jump b2407
        return block_2407(state, tracer, fn_state);
    }
    fn block_4391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4391_0: read-var CRn:u8
        let s_4391_0: u8 = fn_state.CRn;
        // D s_4391_1: cast zx s_4391_0 -> bv
        let s_4391_1: Bits = Bits::new(s_4391_0 as u128, 4u16);
        // C s_4391_2: const #10u : u8
        let s_4391_2: u8 = 10;
        // C s_4391_3: cast zx s_4391_2 -> bv
        let s_4391_3: Bits = Bits::new(s_4391_2 as u128, 4u16);
        // D s_4391_4: cmp-eq s_4391_1 s_4391_3
        let s_4391_4: bool = ((s_4391_1) == (s_4391_3));
        // D s_4391_5: write-var gs#135548 <= s_4391_4
        fn_state.gs_135548 = s_4391_4;
        // N s_4391_6: jump b2405
        return block_2405(state, tracer, fn_state);
    }
    fn block_4392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4392_0: read-var el:u8
        let s_4392_0: u8 = fn_state.el;
        // D s_4392_1: read-var coproc:u8
        let s_4392_1: u8 = fn_state.coproc;
        // D s_4392_2: read-var opc1:u8
        let s_4392_2: u8 = fn_state.opc1;
        // D s_4392_3: read-var CRn:u8
        let s_4392_3: u8 = fn_state.CRn;
        // D s_4392_4: read-var opc2:u8
        let s_4392_4: u8 = fn_state.opc2;
        // D s_4392_5: read-var CRm:u8
        let s_4392_5: u8 = fn_state.CRm;
        // D s_4392_6: read-var t:i
        let s_4392_6: i128 = fn_state.t;
        // D s_4392_7: call DTLBIASID_SysRegWrite32_58b10d925491a590(s_4392_0, s_4392_1, s_4392_2, s_4392_3, s_4392_4, s_4392_5, s_4392_6)
        let s_4392_7: () = DTLBIASID_SysRegWrite32_58b10d925491a590(
            state,
            tracer,
            s_4392_0,
            s_4392_1,
            s_4392_2,
            s_4392_3,
            s_4392_4,
            s_4392_5,
            s_4392_6,
        );
        // N s_4392_8: return
        return;
    }
    fn block_4393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4393_0: read-var opc2:u8
        let s_4393_0: u8 = fn_state.opc2;
        // D s_4393_1: cast zx s_4393_0 -> bv
        let s_4393_1: Bits = Bits::new(s_4393_0 as u128, 3u16);
        // C s_4393_2: const #2u : u8
        let s_4393_2: u8 = 2;
        // C s_4393_3: cast zx s_4393_2 -> bv
        let s_4393_3: Bits = Bits::new(s_4393_2 as u128, 3u16);
        // D s_4393_4: cmp-eq s_4393_1 s_4393_3
        let s_4393_4: bool = ((s_4393_1) == (s_4393_3));
        // D s_4393_5: write-var gs#135547 <= s_4393_4
        fn_state.gs_135547 = s_4393_4;
        // N s_4393_6: jump b2402
        return block_2402(state, tracer, fn_state);
    }
    fn block_4394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4394_0: read-var opc1:u8
        let s_4394_0: u8 = fn_state.opc1;
        // D s_4394_1: cast zx s_4394_0 -> bv
        let s_4394_1: Bits = Bits::new(s_4394_0 as u128, 3u16);
        // C s_4394_2: const #0u : u8
        let s_4394_2: u8 = 0;
        // C s_4394_3: cast zx s_4394_2 -> bv
        let s_4394_3: Bits = Bits::new(s_4394_2 as u128, 3u16);
        // D s_4394_4: cmp-eq s_4394_1 s_4394_3
        let s_4394_4: bool = ((s_4394_1) == (s_4394_3));
        // D s_4394_5: write-var gs#135546 <= s_4394_4
        fn_state.gs_135546 = s_4394_4;
        // N s_4394_6: jump b2400
        return block_2400(state, tracer, fn_state);
    }
    fn block_4395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4395_0: read-var coproc:u8
        let s_4395_0: u8 = fn_state.coproc;
        // D s_4395_1: cast zx s_4395_0 -> bv
        let s_4395_1: Bits = Bits::new(s_4395_0 as u128, 4u16);
        // C s_4395_2: const #15u : u8
        let s_4395_2: u8 = 15;
        // C s_4395_3: cast zx s_4395_2 -> bv
        let s_4395_3: Bits = Bits::new(s_4395_2 as u128, 4u16);
        // D s_4395_4: cmp-eq s_4395_1 s_4395_3
        let s_4395_4: bool = ((s_4395_1) == (s_4395_3));
        // D s_4395_5: write-var gs#135545 <= s_4395_4
        fn_state.gs_135545 = s_4395_4;
        // N s_4395_6: jump b2398
        return block_2398(state, tracer, fn_state);
    }
    fn block_4396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4396_0: read-var CRn:u8
        let s_4396_0: u8 = fn_state.CRn;
        // D s_4396_1: cast zx s_4396_0 -> bv
        let s_4396_1: Bits = Bits::new(s_4396_0 as u128, 4u16);
        // C s_4396_2: const #8u : u8
        let s_4396_2: u8 = 8;
        // C s_4396_3: cast zx s_4396_2 -> bv
        let s_4396_3: Bits = Bits::new(s_4396_2 as u128, 4u16);
        // D s_4396_4: cmp-eq s_4396_1 s_4396_3
        let s_4396_4: bool = ((s_4396_1) == (s_4396_3));
        // D s_4396_5: write-var gs#135544 <= s_4396_4
        fn_state.gs_135544 = s_4396_4;
        // N s_4396_6: jump b2396
        return block_2396(state, tracer, fn_state);
    }
    fn block_4397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4397_0: read-var el:u8
        let s_4397_0: u8 = fn_state.el;
        // D s_4397_1: read-var coproc:u8
        let s_4397_1: u8 = fn_state.coproc;
        // D s_4397_2: read-var opc1:u8
        let s_4397_2: u8 = fn_state.opc1;
        // D s_4397_3: read-var CRn:u8
        let s_4397_3: u8 = fn_state.CRn;
        // D s_4397_4: read-var opc2:u8
        let s_4397_4: u8 = fn_state.opc2;
        // D s_4397_5: read-var CRm:u8
        let s_4397_5: u8 = fn_state.CRm;
        // D s_4397_6: read-var t:i
        let s_4397_6: i128 = fn_state.t;
        // D s_4397_7: call CPACR_SysRegWrite32_512a962d4019b387(s_4397_0, s_4397_1, s_4397_2, s_4397_3, s_4397_4, s_4397_5, s_4397_6)
        let s_4397_7: () = CPACR_SysRegWrite32_512a962d4019b387(
            state,
            tracer,
            s_4397_0,
            s_4397_1,
            s_4397_2,
            s_4397_3,
            s_4397_4,
            s_4397_5,
            s_4397_6,
        );
        // N s_4397_8: return
        return;
    }
    fn block_4398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4398_0: read-var opc2:u8
        let s_4398_0: u8 = fn_state.opc2;
        // D s_4398_1: cast zx s_4398_0 -> bv
        let s_4398_1: Bits = Bits::new(s_4398_0 as u128, 3u16);
        // C s_4398_2: const #2u : u8
        let s_4398_2: u8 = 2;
        // C s_4398_3: cast zx s_4398_2 -> bv
        let s_4398_3: Bits = Bits::new(s_4398_2 as u128, 3u16);
        // D s_4398_4: cmp-eq s_4398_1 s_4398_3
        let s_4398_4: bool = ((s_4398_1) == (s_4398_3));
        // D s_4398_5: write-var gs#135543 <= s_4398_4
        fn_state.gs_135543 = s_4398_4;
        // N s_4398_6: jump b2393
        return block_2393(state, tracer, fn_state);
    }
    fn block_4399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4399_0: read-var opc1:u8
        let s_4399_0: u8 = fn_state.opc1;
        // D s_4399_1: cast zx s_4399_0 -> bv
        let s_4399_1: Bits = Bits::new(s_4399_0 as u128, 3u16);
        // C s_4399_2: const #0u : u8
        let s_4399_2: u8 = 0;
        // C s_4399_3: cast zx s_4399_2 -> bv
        let s_4399_3: Bits = Bits::new(s_4399_2 as u128, 3u16);
        // D s_4399_4: cmp-eq s_4399_1 s_4399_3
        let s_4399_4: bool = ((s_4399_1) == (s_4399_3));
        // D s_4399_5: write-var gs#135542 <= s_4399_4
        fn_state.gs_135542 = s_4399_4;
        // N s_4399_6: jump b2391
        return block_2391(state, tracer, fn_state);
    }
    fn block_4400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4400_0: read-var coproc:u8
        let s_4400_0: u8 = fn_state.coproc;
        // D s_4400_1: cast zx s_4400_0 -> bv
        let s_4400_1: Bits = Bits::new(s_4400_0 as u128, 4u16);
        // C s_4400_2: const #15u : u8
        let s_4400_2: u8 = 15;
        // C s_4400_3: cast zx s_4400_2 -> bv
        let s_4400_3: Bits = Bits::new(s_4400_2 as u128, 4u16);
        // D s_4400_4: cmp-eq s_4400_1 s_4400_3
        let s_4400_4: bool = ((s_4400_1) == (s_4400_3));
        // D s_4400_5: write-var gs#135541 <= s_4400_4
        fn_state.gs_135541 = s_4400_4;
        // N s_4400_6: jump b2389
        return block_2389(state, tracer, fn_state);
    }
    fn block_4401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4401_0: read-var CRn:u8
        let s_4401_0: u8 = fn_state.CRn;
        // D s_4401_1: cast zx s_4401_0 -> bv
        let s_4401_1: Bits = Bits::new(s_4401_0 as u128, 4u16);
        // C s_4401_2: const #1u : u8
        let s_4401_2: u8 = 1;
        // C s_4401_3: cast zx s_4401_2 -> bv
        let s_4401_3: Bits = Bits::new(s_4401_2 as u128, 4u16);
        // D s_4401_4: cmp-eq s_4401_1 s_4401_3
        let s_4401_4: bool = ((s_4401_1) == (s_4401_3));
        // D s_4401_5: write-var gs#135540 <= s_4401_4
        fn_state.gs_135540 = s_4401_4;
        // N s_4401_6: jump b2387
        return block_2387(state, tracer, fn_state);
    }
    fn block_4402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4402_0: read-var el:u8
        let s_4402_0: u8 = fn_state.el;
        // D s_4402_1: read-var coproc:u8
        let s_4402_1: u8 = fn_state.coproc;
        // D s_4402_2: read-var opc1:u8
        let s_4402_2: u8 = fn_state.opc1;
        // D s_4402_3: read-var CRn:u8
        let s_4402_3: u8 = fn_state.CRn;
        // D s_4402_4: read-var opc2:u8
        let s_4402_4: u8 = fn_state.opc2;
        // D s_4402_5: read-var CRm:u8
        let s_4402_5: u8 = fn_state.CRm;
        // D s_4402_6: read-var t:i
        let s_4402_6: i128 = fn_state.t;
        // D s_4402_7: call ACTLR2_SysRegWrite32_282be907bf9b1055(s_4402_0, s_4402_1, s_4402_2, s_4402_3, s_4402_4, s_4402_5, s_4402_6)
        let s_4402_7: () = ACTLR2_SysRegWrite32_282be907bf9b1055(
            state,
            tracer,
            s_4402_0,
            s_4402_1,
            s_4402_2,
            s_4402_3,
            s_4402_4,
            s_4402_5,
            s_4402_6,
        );
        // N s_4402_8: return
        return;
    }
    fn block_4403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4403_0: read-var opc2:u8
        let s_4403_0: u8 = fn_state.opc2;
        // D s_4403_1: cast zx s_4403_0 -> bv
        let s_4403_1: Bits = Bits::new(s_4403_0 as u128, 3u16);
        // C s_4403_2: const #3u : u8
        let s_4403_2: u8 = 3;
        // C s_4403_3: cast zx s_4403_2 -> bv
        let s_4403_3: Bits = Bits::new(s_4403_2 as u128, 3u16);
        // D s_4403_4: cmp-eq s_4403_1 s_4403_3
        let s_4403_4: bool = ((s_4403_1) == (s_4403_3));
        // D s_4403_5: write-var gs#135539 <= s_4403_4
        fn_state.gs_135539 = s_4403_4;
        // N s_4403_6: jump b2384
        return block_2384(state, tracer, fn_state);
    }
    fn block_4404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4404_0: read-var opc1:u8
        let s_4404_0: u8 = fn_state.opc1;
        // D s_4404_1: cast zx s_4404_0 -> bv
        let s_4404_1: Bits = Bits::new(s_4404_0 as u128, 3u16);
        // C s_4404_2: const #0u : u8
        let s_4404_2: u8 = 0;
        // C s_4404_3: cast zx s_4404_2 -> bv
        let s_4404_3: Bits = Bits::new(s_4404_2 as u128, 3u16);
        // D s_4404_4: cmp-eq s_4404_1 s_4404_3
        let s_4404_4: bool = ((s_4404_1) == (s_4404_3));
        // D s_4404_5: write-var gs#135538 <= s_4404_4
        fn_state.gs_135538 = s_4404_4;
        // N s_4404_6: jump b2382
        return block_2382(state, tracer, fn_state);
    }
    fn block_4405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4405_0: read-var coproc:u8
        let s_4405_0: u8 = fn_state.coproc;
        // D s_4405_1: cast zx s_4405_0 -> bv
        let s_4405_1: Bits = Bits::new(s_4405_0 as u128, 4u16);
        // C s_4405_2: const #15u : u8
        let s_4405_2: u8 = 15;
        // C s_4405_3: cast zx s_4405_2 -> bv
        let s_4405_3: Bits = Bits::new(s_4405_2 as u128, 4u16);
        // D s_4405_4: cmp-eq s_4405_1 s_4405_3
        let s_4405_4: bool = ((s_4405_1) == (s_4405_3));
        // D s_4405_5: write-var gs#135537 <= s_4405_4
        fn_state.gs_135537 = s_4405_4;
        // N s_4405_6: jump b2380
        return block_2380(state, tracer, fn_state);
    }
    fn block_4406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4406_0: read-var CRn:u8
        let s_4406_0: u8 = fn_state.CRn;
        // D s_4406_1: cast zx s_4406_0 -> bv
        let s_4406_1: Bits = Bits::new(s_4406_0 as u128, 4u16);
        // C s_4406_2: const #1u : u8
        let s_4406_2: u8 = 1;
        // C s_4406_3: cast zx s_4406_2 -> bv
        let s_4406_3: Bits = Bits::new(s_4406_2 as u128, 4u16);
        // D s_4406_4: cmp-eq s_4406_1 s_4406_3
        let s_4406_4: bool = ((s_4406_1) == (s_4406_3));
        // D s_4406_5: write-var gs#135536 <= s_4406_4
        fn_state.gs_135536 = s_4406_4;
        // N s_4406_6: jump b2378
        return block_2378(state, tracer, fn_state);
    }
    fn block_4407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4407_0: read-var el:u8
        let s_4407_0: u8 = fn_state.el;
        // D s_4407_1: read-var coproc:u8
        let s_4407_1: u8 = fn_state.coproc;
        // D s_4407_2: read-var opc1:u8
        let s_4407_2: u8 = fn_state.opc1;
        // D s_4407_3: read-var CRn:u8
        let s_4407_3: u8 = fn_state.CRn;
        // D s_4407_4: read-var opc2:u8
        let s_4407_4: u8 = fn_state.opc2;
        // D s_4407_5: read-var CRm:u8
        let s_4407_5: u8 = fn_state.CRm;
        // D s_4407_6: read-var t:i
        let s_4407_6: i128 = fn_state.t;
        // D s_4407_7: call MVBAR_SysRegWrite32_b51bf66bf3dc6e40(s_4407_0, s_4407_1, s_4407_2, s_4407_3, s_4407_4, s_4407_5, s_4407_6)
        let s_4407_7: () = MVBAR_SysRegWrite32_b51bf66bf3dc6e40(
            state,
            tracer,
            s_4407_0,
            s_4407_1,
            s_4407_2,
            s_4407_3,
            s_4407_4,
            s_4407_5,
            s_4407_6,
        );
        // N s_4407_8: return
        return;
    }
    fn block_4408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4408_0: read-var opc2:u8
        let s_4408_0: u8 = fn_state.opc2;
        // D s_4408_1: cast zx s_4408_0 -> bv
        let s_4408_1: Bits = Bits::new(s_4408_0 as u128, 3u16);
        // C s_4408_2: const #1u : u8
        let s_4408_2: u8 = 1;
        // C s_4408_3: cast zx s_4408_2 -> bv
        let s_4408_3: Bits = Bits::new(s_4408_2 as u128, 3u16);
        // D s_4408_4: cmp-eq s_4408_1 s_4408_3
        let s_4408_4: bool = ((s_4408_1) == (s_4408_3));
        // D s_4408_5: write-var gs#135535 <= s_4408_4
        fn_state.gs_135535 = s_4408_4;
        // N s_4408_6: jump b2375
        return block_2375(state, tracer, fn_state);
    }
    fn block_4409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4409_0: read-var opc1:u8
        let s_4409_0: u8 = fn_state.opc1;
        // D s_4409_1: cast zx s_4409_0 -> bv
        let s_4409_1: Bits = Bits::new(s_4409_0 as u128, 3u16);
        // C s_4409_2: const #0u : u8
        let s_4409_2: u8 = 0;
        // C s_4409_3: cast zx s_4409_2 -> bv
        let s_4409_3: Bits = Bits::new(s_4409_2 as u128, 3u16);
        // D s_4409_4: cmp-eq s_4409_1 s_4409_3
        let s_4409_4: bool = ((s_4409_1) == (s_4409_3));
        // D s_4409_5: write-var gs#135534 <= s_4409_4
        fn_state.gs_135534 = s_4409_4;
        // N s_4409_6: jump b2373
        return block_2373(state, tracer, fn_state);
    }
    fn block_4410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4410_0: read-var coproc:u8
        let s_4410_0: u8 = fn_state.coproc;
        // D s_4410_1: cast zx s_4410_0 -> bv
        let s_4410_1: Bits = Bits::new(s_4410_0 as u128, 4u16);
        // C s_4410_2: const #15u : u8
        let s_4410_2: u8 = 15;
        // C s_4410_3: cast zx s_4410_2 -> bv
        let s_4410_3: Bits = Bits::new(s_4410_2 as u128, 4u16);
        // D s_4410_4: cmp-eq s_4410_1 s_4410_3
        let s_4410_4: bool = ((s_4410_1) == (s_4410_3));
        // D s_4410_5: write-var gs#135533 <= s_4410_4
        fn_state.gs_135533 = s_4410_4;
        // N s_4410_6: jump b2371
        return block_2371(state, tracer, fn_state);
    }
    fn block_4411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4411_0: read-var CRn:u8
        let s_4411_0: u8 = fn_state.CRn;
        // D s_4411_1: cast zx s_4411_0 -> bv
        let s_4411_1: Bits = Bits::new(s_4411_0 as u128, 4u16);
        // C s_4411_2: const #12u : u8
        let s_4411_2: u8 = 12;
        // C s_4411_3: cast zx s_4411_2 -> bv
        let s_4411_3: Bits = Bits::new(s_4411_2 as u128, 4u16);
        // D s_4411_4: cmp-eq s_4411_1 s_4411_3
        let s_4411_4: bool = ((s_4411_1) == (s_4411_3));
        // D s_4411_5: write-var gs#135532 <= s_4411_4
        fn_state.gs_135532 = s_4411_4;
        // N s_4411_6: jump b2369
        return block_2369(state, tracer, fn_state);
    }
    fn block_4412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4412_0: read-var el:u8
        let s_4412_0: u8 = fn_state.el;
        // D s_4412_1: read-var coproc:u8
        let s_4412_1: u8 = fn_state.coproc;
        // D s_4412_2: read-var opc1:u8
        let s_4412_2: u8 = fn_state.opc1;
        // D s_4412_3: read-var CRn:u8
        let s_4412_3: u8 = fn_state.CRn;
        // D s_4412_4: read-var opc2:u8
        let s_4412_4: u8 = fn_state.opc2;
        // D s_4412_5: read-var CRm:u8
        let s_4412_5: u8 = fn_state.CRm;
        // D s_4412_6: read-var t:i
        let s_4412_6: i128 = fn_state.t;
        // D s_4412_7: call DBGOSECCR_SysRegWrite32_87878830bf235bef(s_4412_0, s_4412_1, s_4412_2, s_4412_3, s_4412_4, s_4412_5, s_4412_6)
        let s_4412_7: () = DBGOSECCR_SysRegWrite32_87878830bf235bef(
            state,
            tracer,
            s_4412_0,
            s_4412_1,
            s_4412_2,
            s_4412_3,
            s_4412_4,
            s_4412_5,
            s_4412_6,
        );
        // N s_4412_8: return
        return;
    }
    fn block_4413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4413_0: read-var opc2:u8
        let s_4413_0: u8 = fn_state.opc2;
        // D s_4413_1: cast zx s_4413_0 -> bv
        let s_4413_1: Bits = Bits::new(s_4413_0 as u128, 3u16);
        // C s_4413_2: const #2u : u8
        let s_4413_2: u8 = 2;
        // C s_4413_3: cast zx s_4413_2 -> bv
        let s_4413_3: Bits = Bits::new(s_4413_2 as u128, 3u16);
        // D s_4413_4: cmp-eq s_4413_1 s_4413_3
        let s_4413_4: bool = ((s_4413_1) == (s_4413_3));
        // D s_4413_5: write-var gs#135531 <= s_4413_4
        fn_state.gs_135531 = s_4413_4;
        // N s_4413_6: jump b2366
        return block_2366(state, tracer, fn_state);
    }
    fn block_4414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4414_0: read-var opc1:u8
        let s_4414_0: u8 = fn_state.opc1;
        // D s_4414_1: cast zx s_4414_0 -> bv
        let s_4414_1: Bits = Bits::new(s_4414_0 as u128, 3u16);
        // C s_4414_2: const #0u : u8
        let s_4414_2: u8 = 0;
        // C s_4414_3: cast zx s_4414_2 -> bv
        let s_4414_3: Bits = Bits::new(s_4414_2 as u128, 3u16);
        // D s_4414_4: cmp-eq s_4414_1 s_4414_3
        let s_4414_4: bool = ((s_4414_1) == (s_4414_3));
        // D s_4414_5: write-var gs#135530 <= s_4414_4
        fn_state.gs_135530 = s_4414_4;
        // N s_4414_6: jump b2364
        return block_2364(state, tracer, fn_state);
    }
    fn block_4415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4415_0: read-var coproc:u8
        let s_4415_0: u8 = fn_state.coproc;
        // D s_4415_1: cast zx s_4415_0 -> bv
        let s_4415_1: Bits = Bits::new(s_4415_0 as u128, 4u16);
        // C s_4415_2: const #14u : u8
        let s_4415_2: u8 = 14;
        // C s_4415_3: cast zx s_4415_2 -> bv
        let s_4415_3: Bits = Bits::new(s_4415_2 as u128, 4u16);
        // D s_4415_4: cmp-eq s_4415_1 s_4415_3
        let s_4415_4: bool = ((s_4415_1) == (s_4415_3));
        // D s_4415_5: write-var gs#135529 <= s_4415_4
        fn_state.gs_135529 = s_4415_4;
        // N s_4415_6: jump b2362
        return block_2362(state, tracer, fn_state);
    }
    fn block_4416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4416_0: read-var CRn:u8
        let s_4416_0: u8 = fn_state.CRn;
        // D s_4416_1: cast zx s_4416_0 -> bv
        let s_4416_1: Bits = Bits::new(s_4416_0 as u128, 4u16);
        // C s_4416_2: const #0u : u8
        let s_4416_2: u8 = 0;
        // C s_4416_3: cast zx s_4416_2 -> bv
        let s_4416_3: Bits = Bits::new(s_4416_2 as u128, 4u16);
        // D s_4416_4: cmp-eq s_4416_1 s_4416_3
        let s_4416_4: bool = ((s_4416_1) == (s_4416_3));
        // D s_4416_5: write-var gs#135528 <= s_4416_4
        fn_state.gs_135528 = s_4416_4;
        // N s_4416_6: jump b2360
        return block_2360(state, tracer, fn_state);
    }
    fn block_4417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4417_0: read-var el:u8
        let s_4417_0: u8 = fn_state.el;
        // D s_4417_1: read-var coproc:u8
        let s_4417_1: u8 = fn_state.coproc;
        // D s_4417_2: read-var opc1:u8
        let s_4417_2: u8 = fn_state.opc1;
        // D s_4417_3: read-var CRn:u8
        let s_4417_3: u8 = fn_state.CRn;
        // D s_4417_4: read-var opc2:u8
        let s_4417_4: u8 = fn_state.opc2;
        // D s_4417_5: read-var CRm:u8
        let s_4417_5: u8 = fn_state.CRm;
        // D s_4417_6: read-var t:i
        let s_4417_6: i128 = fn_state.t;
        // D s_4417_7: call ATS12NSOUW_SysRegWrite32_67f712d7e127f198(s_4417_0, s_4417_1, s_4417_2, s_4417_3, s_4417_4, s_4417_5, s_4417_6)
        let s_4417_7: () = ATS12NSOUW_SysRegWrite32_67f712d7e127f198(
            state,
            tracer,
            s_4417_0,
            s_4417_1,
            s_4417_2,
            s_4417_3,
            s_4417_4,
            s_4417_5,
            s_4417_6,
        );
        // N s_4417_8: return
        return;
    }
    fn block_4418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4418_0: read-var opc2:u8
        let s_4418_0: u8 = fn_state.opc2;
        // D s_4418_1: cast zx s_4418_0 -> bv
        let s_4418_1: Bits = Bits::new(s_4418_0 as u128, 3u16);
        // C s_4418_2: const #7u : u8
        let s_4418_2: u8 = 7;
        // C s_4418_3: cast zx s_4418_2 -> bv
        let s_4418_3: Bits = Bits::new(s_4418_2 as u128, 3u16);
        // D s_4418_4: cmp-eq s_4418_1 s_4418_3
        let s_4418_4: bool = ((s_4418_1) == (s_4418_3));
        // D s_4418_5: write-var gs#135527 <= s_4418_4
        fn_state.gs_135527 = s_4418_4;
        // N s_4418_6: jump b2357
        return block_2357(state, tracer, fn_state);
    }
    fn block_4419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4419_0: read-var opc1:u8
        let s_4419_0: u8 = fn_state.opc1;
        // D s_4419_1: cast zx s_4419_0 -> bv
        let s_4419_1: Bits = Bits::new(s_4419_0 as u128, 3u16);
        // C s_4419_2: const #0u : u8
        let s_4419_2: u8 = 0;
        // C s_4419_3: cast zx s_4419_2 -> bv
        let s_4419_3: Bits = Bits::new(s_4419_2 as u128, 3u16);
        // D s_4419_4: cmp-eq s_4419_1 s_4419_3
        let s_4419_4: bool = ((s_4419_1) == (s_4419_3));
        // D s_4419_5: write-var gs#135526 <= s_4419_4
        fn_state.gs_135526 = s_4419_4;
        // N s_4419_6: jump b2355
        return block_2355(state, tracer, fn_state);
    }
    fn block_4420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4420_0: read-var coproc:u8
        let s_4420_0: u8 = fn_state.coproc;
        // D s_4420_1: cast zx s_4420_0 -> bv
        let s_4420_1: Bits = Bits::new(s_4420_0 as u128, 4u16);
        // C s_4420_2: const #15u : u8
        let s_4420_2: u8 = 15;
        // C s_4420_3: cast zx s_4420_2 -> bv
        let s_4420_3: Bits = Bits::new(s_4420_2 as u128, 4u16);
        // D s_4420_4: cmp-eq s_4420_1 s_4420_3
        let s_4420_4: bool = ((s_4420_1) == (s_4420_3));
        // D s_4420_5: write-var gs#135525 <= s_4420_4
        fn_state.gs_135525 = s_4420_4;
        // N s_4420_6: jump b2353
        return block_2353(state, tracer, fn_state);
    }
    fn block_4421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4421_0: read-var CRn:u8
        let s_4421_0: u8 = fn_state.CRn;
        // D s_4421_1: cast zx s_4421_0 -> bv
        let s_4421_1: Bits = Bits::new(s_4421_0 as u128, 4u16);
        // C s_4421_2: const #7u : u8
        let s_4421_2: u8 = 7;
        // C s_4421_3: cast zx s_4421_2 -> bv
        let s_4421_3: Bits = Bits::new(s_4421_2 as u128, 4u16);
        // D s_4421_4: cmp-eq s_4421_1 s_4421_3
        let s_4421_4: bool = ((s_4421_1) == (s_4421_3));
        // D s_4421_5: write-var gs#135524 <= s_4421_4
        fn_state.gs_135524 = s_4421_4;
        // N s_4421_6: jump b2351
        return block_2351(state, tracer, fn_state);
    }
    fn block_4422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4422_0: read-var el:u8
        let s_4422_0: u8 = fn_state.el;
        // D s_4422_1: read-var coproc:u8
        let s_4422_1: u8 = fn_state.coproc;
        // D s_4422_2: read-var opc1:u8
        let s_4422_2: u8 = fn_state.opc1;
        // D s_4422_3: read-var CRn:u8
        let s_4422_3: u8 = fn_state.CRn;
        // D s_4422_4: read-var opc2:u8
        let s_4422_4: u8 = fn_state.opc2;
        // D s_4422_5: read-var CRm:u8
        let s_4422_5: u8 = fn_state.CRm;
        // D s_4422_6: read-var t:i
        let s_4422_6: i128 = fn_state.t;
        // D s_4422_7: call DFSR_SysRegWrite32_d19afe00f293902c(s_4422_0, s_4422_1, s_4422_2, s_4422_3, s_4422_4, s_4422_5, s_4422_6)
        let s_4422_7: () = DFSR_SysRegWrite32_d19afe00f293902c(
            state,
            tracer,
            s_4422_0,
            s_4422_1,
            s_4422_2,
            s_4422_3,
            s_4422_4,
            s_4422_5,
            s_4422_6,
        );
        // N s_4422_8: return
        return;
    }
    fn block_4423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4423_0: read-var opc2:u8
        let s_4423_0: u8 = fn_state.opc2;
        // D s_4423_1: cast zx s_4423_0 -> bv
        let s_4423_1: Bits = Bits::new(s_4423_0 as u128, 3u16);
        // C s_4423_2: const #0u : u8
        let s_4423_2: u8 = 0;
        // C s_4423_3: cast zx s_4423_2 -> bv
        let s_4423_3: Bits = Bits::new(s_4423_2 as u128, 3u16);
        // D s_4423_4: cmp-eq s_4423_1 s_4423_3
        let s_4423_4: bool = ((s_4423_1) == (s_4423_3));
        // D s_4423_5: write-var gs#135523 <= s_4423_4
        fn_state.gs_135523 = s_4423_4;
        // N s_4423_6: jump b2348
        return block_2348(state, tracer, fn_state);
    }
    fn block_4424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4424_0: read-var opc1:u8
        let s_4424_0: u8 = fn_state.opc1;
        // D s_4424_1: cast zx s_4424_0 -> bv
        let s_4424_1: Bits = Bits::new(s_4424_0 as u128, 3u16);
        // C s_4424_2: const #0u : u8
        let s_4424_2: u8 = 0;
        // C s_4424_3: cast zx s_4424_2 -> bv
        let s_4424_3: Bits = Bits::new(s_4424_2 as u128, 3u16);
        // D s_4424_4: cmp-eq s_4424_1 s_4424_3
        let s_4424_4: bool = ((s_4424_1) == (s_4424_3));
        // D s_4424_5: write-var gs#135522 <= s_4424_4
        fn_state.gs_135522 = s_4424_4;
        // N s_4424_6: jump b2346
        return block_2346(state, tracer, fn_state);
    }
    fn block_4425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4425_0: read-var coproc:u8
        let s_4425_0: u8 = fn_state.coproc;
        // D s_4425_1: cast zx s_4425_0 -> bv
        let s_4425_1: Bits = Bits::new(s_4425_0 as u128, 4u16);
        // C s_4425_2: const #15u : u8
        let s_4425_2: u8 = 15;
        // C s_4425_3: cast zx s_4425_2 -> bv
        let s_4425_3: Bits = Bits::new(s_4425_2 as u128, 4u16);
        // D s_4425_4: cmp-eq s_4425_1 s_4425_3
        let s_4425_4: bool = ((s_4425_1) == (s_4425_3));
        // D s_4425_5: write-var gs#135521 <= s_4425_4
        fn_state.gs_135521 = s_4425_4;
        // N s_4425_6: jump b2344
        return block_2344(state, tracer, fn_state);
    }
    fn block_4426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4426_0: read-var CRn:u8
        let s_4426_0: u8 = fn_state.CRn;
        // D s_4426_1: cast zx s_4426_0 -> bv
        let s_4426_1: Bits = Bits::new(s_4426_0 as u128, 4u16);
        // C s_4426_2: const #5u : u8
        let s_4426_2: u8 = 5;
        // C s_4426_3: cast zx s_4426_2 -> bv
        let s_4426_3: Bits = Bits::new(s_4426_2 as u128, 4u16);
        // D s_4426_4: cmp-eq s_4426_1 s_4426_3
        let s_4426_4: bool = ((s_4426_1) == (s_4426_3));
        // D s_4426_5: write-var gs#135520 <= s_4426_4
        fn_state.gs_135520 = s_4426_4;
        // N s_4426_6: jump b2342
        return block_2342(state, tracer, fn_state);
    }
    fn block_4427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4427_0: read-var el:u8
        let s_4427_0: u8 = fn_state.el;
        // D s_4427_1: read-var coproc:u8
        let s_4427_1: u8 = fn_state.coproc;
        // D s_4427_2: read-var opc1:u8
        let s_4427_2: u8 = fn_state.opc1;
        // D s_4427_3: read-var CRn:u8
        let s_4427_3: u8 = fn_state.CRn;
        // D s_4427_4: read-var opc2:u8
        let s_4427_4: u8 = fn_state.opc2;
        // D s_4427_5: read-var CRm:u8
        let s_4427_5: u8 = fn_state.CRm;
        // D s_4427_6: read-var t:i
        let s_4427_6: i128 = fn_state.t;
        // D s_4427_7: call PMINTENSET_SysRegWrite32_068b645854413351(s_4427_0, s_4427_1, s_4427_2, s_4427_3, s_4427_4, s_4427_5, s_4427_6)
        let s_4427_7: () = PMINTENSET_SysRegWrite32_068b645854413351(
            state,
            tracer,
            s_4427_0,
            s_4427_1,
            s_4427_2,
            s_4427_3,
            s_4427_4,
            s_4427_5,
            s_4427_6,
        );
        // N s_4427_8: return
        return;
    }
    fn block_4428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4428_0: read-var opc2:u8
        let s_4428_0: u8 = fn_state.opc2;
        // D s_4428_1: cast zx s_4428_0 -> bv
        let s_4428_1: Bits = Bits::new(s_4428_0 as u128, 3u16);
        // C s_4428_2: const #1u : u8
        let s_4428_2: u8 = 1;
        // C s_4428_3: cast zx s_4428_2 -> bv
        let s_4428_3: Bits = Bits::new(s_4428_2 as u128, 3u16);
        // D s_4428_4: cmp-eq s_4428_1 s_4428_3
        let s_4428_4: bool = ((s_4428_1) == (s_4428_3));
        // D s_4428_5: write-var gs#135519 <= s_4428_4
        fn_state.gs_135519 = s_4428_4;
        // N s_4428_6: jump b2339
        return block_2339(state, tracer, fn_state);
    }
    fn block_4429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4429_0: read-var opc1:u8
        let s_4429_0: u8 = fn_state.opc1;
        // D s_4429_1: cast zx s_4429_0 -> bv
        let s_4429_1: Bits = Bits::new(s_4429_0 as u128, 3u16);
        // C s_4429_2: const #0u : u8
        let s_4429_2: u8 = 0;
        // C s_4429_3: cast zx s_4429_2 -> bv
        let s_4429_3: Bits = Bits::new(s_4429_2 as u128, 3u16);
        // D s_4429_4: cmp-eq s_4429_1 s_4429_3
        let s_4429_4: bool = ((s_4429_1) == (s_4429_3));
        // D s_4429_5: write-var gs#135518 <= s_4429_4
        fn_state.gs_135518 = s_4429_4;
        // N s_4429_6: jump b2337
        return block_2337(state, tracer, fn_state);
    }
    fn block_4430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4430_0: read-var coproc:u8
        let s_4430_0: u8 = fn_state.coproc;
        // D s_4430_1: cast zx s_4430_0 -> bv
        let s_4430_1: Bits = Bits::new(s_4430_0 as u128, 4u16);
        // C s_4430_2: const #15u : u8
        let s_4430_2: u8 = 15;
        // C s_4430_3: cast zx s_4430_2 -> bv
        let s_4430_3: Bits = Bits::new(s_4430_2 as u128, 4u16);
        // D s_4430_4: cmp-eq s_4430_1 s_4430_3
        let s_4430_4: bool = ((s_4430_1) == (s_4430_3));
        // D s_4430_5: write-var gs#135517 <= s_4430_4
        fn_state.gs_135517 = s_4430_4;
        // N s_4430_6: jump b2335
        return block_2335(state, tracer, fn_state);
    }
    fn block_4431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4431_0: read-var CRn:u8
        let s_4431_0: u8 = fn_state.CRn;
        // D s_4431_1: cast zx s_4431_0 -> bv
        let s_4431_1: Bits = Bits::new(s_4431_0 as u128, 4u16);
        // C s_4431_2: const #9u : u8
        let s_4431_2: u8 = 9;
        // C s_4431_3: cast zx s_4431_2 -> bv
        let s_4431_3: Bits = Bits::new(s_4431_2 as u128, 4u16);
        // D s_4431_4: cmp-eq s_4431_1 s_4431_3
        let s_4431_4: bool = ((s_4431_1) == (s_4431_3));
        // D s_4431_5: write-var gs#135516 <= s_4431_4
        fn_state.gs_135516 = s_4431_4;
        // N s_4431_6: jump b2333
        return block_2333(state, tracer, fn_state);
    }
    fn block_4432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4432_0: read-var el:u8
        let s_4432_0: u8 = fn_state.el;
        // D s_4432_1: read-var coproc:u8
        let s_4432_1: u8 = fn_state.coproc;
        // D s_4432_2: read-var opc1:u8
        let s_4432_2: u8 = fn_state.opc1;
        // D s_4432_3: read-var CRn:u8
        let s_4432_3: u8 = fn_state.CRn;
        // D s_4432_4: read-var opc2:u8
        let s_4432_4: u8 = fn_state.opc2;
        // D s_4432_5: read-var CRm:u8
        let s_4432_5: u8 = fn_state.CRm;
        // D s_4432_6: read-var t:i
        let s_4432_6: i128 = fn_state.t;
        // D s_4432_7: call CNTFRQ_SysRegWrite32_bb1fcec10c61c758(s_4432_0, s_4432_1, s_4432_2, s_4432_3, s_4432_4, s_4432_5, s_4432_6)
        let s_4432_7: () = CNTFRQ_SysRegWrite32_bb1fcec10c61c758(
            state,
            tracer,
            s_4432_0,
            s_4432_1,
            s_4432_2,
            s_4432_3,
            s_4432_4,
            s_4432_5,
            s_4432_6,
        );
        // N s_4432_8: return
        return;
    }
    fn block_4433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4433_0: read-var opc2:u8
        let s_4433_0: u8 = fn_state.opc2;
        // D s_4433_1: cast zx s_4433_0 -> bv
        let s_4433_1: Bits = Bits::new(s_4433_0 as u128, 3u16);
        // C s_4433_2: const #0u : u8
        let s_4433_2: u8 = 0;
        // C s_4433_3: cast zx s_4433_2 -> bv
        let s_4433_3: Bits = Bits::new(s_4433_2 as u128, 3u16);
        // D s_4433_4: cmp-eq s_4433_1 s_4433_3
        let s_4433_4: bool = ((s_4433_1) == (s_4433_3));
        // D s_4433_5: write-var gs#135515 <= s_4433_4
        fn_state.gs_135515 = s_4433_4;
        // N s_4433_6: jump b2330
        return block_2330(state, tracer, fn_state);
    }
    fn block_4434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4434_0: read-var opc1:u8
        let s_4434_0: u8 = fn_state.opc1;
        // D s_4434_1: cast zx s_4434_0 -> bv
        let s_4434_1: Bits = Bits::new(s_4434_0 as u128, 3u16);
        // C s_4434_2: const #0u : u8
        let s_4434_2: u8 = 0;
        // C s_4434_3: cast zx s_4434_2 -> bv
        let s_4434_3: Bits = Bits::new(s_4434_2 as u128, 3u16);
        // D s_4434_4: cmp-eq s_4434_1 s_4434_3
        let s_4434_4: bool = ((s_4434_1) == (s_4434_3));
        // D s_4434_5: write-var gs#135514 <= s_4434_4
        fn_state.gs_135514 = s_4434_4;
        // N s_4434_6: jump b2328
        return block_2328(state, tracer, fn_state);
    }
    fn block_4435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4435_0: read-var coproc:u8
        let s_4435_0: u8 = fn_state.coproc;
        // D s_4435_1: cast zx s_4435_0 -> bv
        let s_4435_1: Bits = Bits::new(s_4435_0 as u128, 4u16);
        // C s_4435_2: const #15u : u8
        let s_4435_2: u8 = 15;
        // C s_4435_3: cast zx s_4435_2 -> bv
        let s_4435_3: Bits = Bits::new(s_4435_2 as u128, 4u16);
        // D s_4435_4: cmp-eq s_4435_1 s_4435_3
        let s_4435_4: bool = ((s_4435_1) == (s_4435_3));
        // D s_4435_5: write-var gs#135513 <= s_4435_4
        fn_state.gs_135513 = s_4435_4;
        // N s_4435_6: jump b2326
        return block_2326(state, tracer, fn_state);
    }
    fn block_4436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4436_0: read-var CRn:u8
        let s_4436_0: u8 = fn_state.CRn;
        // D s_4436_1: cast zx s_4436_0 -> bv
        let s_4436_1: Bits = Bits::new(s_4436_0 as u128, 4u16);
        // C s_4436_2: const #14u : u8
        let s_4436_2: u8 = 14;
        // C s_4436_3: cast zx s_4436_2 -> bv
        let s_4436_3: Bits = Bits::new(s_4436_2 as u128, 4u16);
        // D s_4436_4: cmp-eq s_4436_1 s_4436_3
        let s_4436_4: bool = ((s_4436_1) == (s_4436_3));
        // D s_4436_5: write-var gs#135512 <= s_4436_4
        fn_state.gs_135512 = s_4436_4;
        // N s_4436_6: jump b2324
        return block_2324(state, tracer, fn_state);
    }
    fn block_4437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4437_0: read-var el:u8
        let s_4437_0: u8 = fn_state.el;
        // D s_4437_1: read-var coproc:u8
        let s_4437_1: u8 = fn_state.coproc;
        // D s_4437_2: read-var opc1:u8
        let s_4437_2: u8 = fn_state.opc1;
        // D s_4437_3: read-var CRn:u8
        let s_4437_3: u8 = fn_state.CRn;
        // D s_4437_4: read-var opc2:u8
        let s_4437_4: u8 = fn_state.opc2;
        // D s_4437_5: read-var CRm:u8
        let s_4437_5: u8 = fn_state.CRm;
        // D s_4437_6: read-var t:i
        let s_4437_6: i128 = fn_state.t;
        // D s_4437_7: call ICC_MGRPEN1_SysRegWrite32_a295be12c6cd3191(s_4437_0, s_4437_1, s_4437_2, s_4437_3, s_4437_4, s_4437_5, s_4437_6)
        let s_4437_7: () = ICC_MGRPEN1_SysRegWrite32_a295be12c6cd3191(
            state,
            tracer,
            s_4437_0,
            s_4437_1,
            s_4437_2,
            s_4437_3,
            s_4437_4,
            s_4437_5,
            s_4437_6,
        );
        // N s_4437_8: return
        return;
    }
    fn block_4438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4438_0: read-var opc2:u8
        let s_4438_0: u8 = fn_state.opc2;
        // D s_4438_1: cast zx s_4438_0 -> bv
        let s_4438_1: Bits = Bits::new(s_4438_0 as u128, 3u16);
        // C s_4438_2: const #7u : u8
        let s_4438_2: u8 = 7;
        // C s_4438_3: cast zx s_4438_2 -> bv
        let s_4438_3: Bits = Bits::new(s_4438_2 as u128, 3u16);
        // D s_4438_4: cmp-eq s_4438_1 s_4438_3
        let s_4438_4: bool = ((s_4438_1) == (s_4438_3));
        // D s_4438_5: write-var gs#135511 <= s_4438_4
        fn_state.gs_135511 = s_4438_4;
        // N s_4438_6: jump b2321
        return block_2321(state, tracer, fn_state);
    }
    fn block_4439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4439_0: read-var opc1:u8
        let s_4439_0: u8 = fn_state.opc1;
        // D s_4439_1: cast zx s_4439_0 -> bv
        let s_4439_1: Bits = Bits::new(s_4439_0 as u128, 3u16);
        // C s_4439_2: const #6u : u8
        let s_4439_2: u8 = 6;
        // C s_4439_3: cast zx s_4439_2 -> bv
        let s_4439_3: Bits = Bits::new(s_4439_2 as u128, 3u16);
        // D s_4439_4: cmp-eq s_4439_1 s_4439_3
        let s_4439_4: bool = ((s_4439_1) == (s_4439_3));
        // D s_4439_5: write-var gs#135510 <= s_4439_4
        fn_state.gs_135510 = s_4439_4;
        // N s_4439_6: jump b2319
        return block_2319(state, tracer, fn_state);
    }
    fn block_4440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4440_0: read-var coproc:u8
        let s_4440_0: u8 = fn_state.coproc;
        // D s_4440_1: cast zx s_4440_0 -> bv
        let s_4440_1: Bits = Bits::new(s_4440_0 as u128, 4u16);
        // C s_4440_2: const #15u : u8
        let s_4440_2: u8 = 15;
        // C s_4440_3: cast zx s_4440_2 -> bv
        let s_4440_3: Bits = Bits::new(s_4440_2 as u128, 4u16);
        // D s_4440_4: cmp-eq s_4440_1 s_4440_3
        let s_4440_4: bool = ((s_4440_1) == (s_4440_3));
        // D s_4440_5: write-var gs#135509 <= s_4440_4
        fn_state.gs_135509 = s_4440_4;
        // N s_4440_6: jump b2317
        return block_2317(state, tracer, fn_state);
    }
    fn block_4441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4441_0: read-var CRn:u8
        let s_4441_0: u8 = fn_state.CRn;
        // D s_4441_1: cast zx s_4441_0 -> bv
        let s_4441_1: Bits = Bits::new(s_4441_0 as u128, 4u16);
        // C s_4441_2: const #12u : u8
        let s_4441_2: u8 = 12;
        // C s_4441_3: cast zx s_4441_2 -> bv
        let s_4441_3: Bits = Bits::new(s_4441_2 as u128, 4u16);
        // D s_4441_4: cmp-eq s_4441_1 s_4441_3
        let s_4441_4: bool = ((s_4441_1) == (s_4441_3));
        // D s_4441_5: write-var gs#135508 <= s_4441_4
        fn_state.gs_135508 = s_4441_4;
        // N s_4441_6: jump b2315
        return block_2315(state, tracer, fn_state);
    }
    fn block_4442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4442_0: read-var el:u8
        let s_4442_0: u8 = fn_state.el;
        // D s_4442_1: read-var coproc:u8
        let s_4442_1: u8 = fn_state.coproc;
        // D s_4442_2: read-var opc1:u8
        let s_4442_2: u8 = fn_state.opc1;
        // D s_4442_3: read-var CRn:u8
        let s_4442_3: u8 = fn_state.CRn;
        // D s_4442_4: read-var opc2:u8
        let s_4442_4: u8 = fn_state.opc2;
        // D s_4442_5: read-var CRm:u8
        let s_4442_5: u8 = fn_state.CRm;
        // D s_4442_6: read-var t:i
        let s_4442_6: i128 = fn_state.t;
        // D s_4442_7: call VTCR_SysRegWrite32_481811658d5f359e(s_4442_0, s_4442_1, s_4442_2, s_4442_3, s_4442_4, s_4442_5, s_4442_6)
        let s_4442_7: () = VTCR_SysRegWrite32_481811658d5f359e(
            state,
            tracer,
            s_4442_0,
            s_4442_1,
            s_4442_2,
            s_4442_3,
            s_4442_4,
            s_4442_5,
            s_4442_6,
        );
        // N s_4442_8: return
        return;
    }
    fn block_4443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4443_0: read-var opc2:u8
        let s_4443_0: u8 = fn_state.opc2;
        // D s_4443_1: cast zx s_4443_0 -> bv
        let s_4443_1: Bits = Bits::new(s_4443_0 as u128, 3u16);
        // C s_4443_2: const #2u : u8
        let s_4443_2: u8 = 2;
        // C s_4443_3: cast zx s_4443_2 -> bv
        let s_4443_3: Bits = Bits::new(s_4443_2 as u128, 3u16);
        // D s_4443_4: cmp-eq s_4443_1 s_4443_3
        let s_4443_4: bool = ((s_4443_1) == (s_4443_3));
        // D s_4443_5: write-var gs#135507 <= s_4443_4
        fn_state.gs_135507 = s_4443_4;
        // N s_4443_6: jump b2312
        return block_2312(state, tracer, fn_state);
    }
    fn block_4444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4444_0: read-var opc1:u8
        let s_4444_0: u8 = fn_state.opc1;
        // D s_4444_1: cast zx s_4444_0 -> bv
        let s_4444_1: Bits = Bits::new(s_4444_0 as u128, 3u16);
        // C s_4444_2: const #4u : u8
        let s_4444_2: u8 = 4;
        // C s_4444_3: cast zx s_4444_2 -> bv
        let s_4444_3: Bits = Bits::new(s_4444_2 as u128, 3u16);
        // D s_4444_4: cmp-eq s_4444_1 s_4444_3
        let s_4444_4: bool = ((s_4444_1) == (s_4444_3));
        // D s_4444_5: write-var gs#135506 <= s_4444_4
        fn_state.gs_135506 = s_4444_4;
        // N s_4444_6: jump b2310
        return block_2310(state, tracer, fn_state);
    }
    fn block_4445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4445_0: read-var coproc:u8
        let s_4445_0: u8 = fn_state.coproc;
        // D s_4445_1: cast zx s_4445_0 -> bv
        let s_4445_1: Bits = Bits::new(s_4445_0 as u128, 4u16);
        // C s_4445_2: const #15u : u8
        let s_4445_2: u8 = 15;
        // C s_4445_3: cast zx s_4445_2 -> bv
        let s_4445_3: Bits = Bits::new(s_4445_2 as u128, 4u16);
        // D s_4445_4: cmp-eq s_4445_1 s_4445_3
        let s_4445_4: bool = ((s_4445_1) == (s_4445_3));
        // D s_4445_5: write-var gs#135505 <= s_4445_4
        fn_state.gs_135505 = s_4445_4;
        // N s_4445_6: jump b2308
        return block_2308(state, tracer, fn_state);
    }
    fn block_4446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4446_0: read-var CRn:u8
        let s_4446_0: u8 = fn_state.CRn;
        // D s_4446_1: cast zx s_4446_0 -> bv
        let s_4446_1: Bits = Bits::new(s_4446_0 as u128, 4u16);
        // C s_4446_2: const #2u : u8
        let s_4446_2: u8 = 2;
        // C s_4446_3: cast zx s_4446_2 -> bv
        let s_4446_3: Bits = Bits::new(s_4446_2 as u128, 4u16);
        // D s_4446_4: cmp-eq s_4446_1 s_4446_3
        let s_4446_4: bool = ((s_4446_1) == (s_4446_3));
        // D s_4446_5: write-var gs#135504 <= s_4446_4
        fn_state.gs_135504 = s_4446_4;
        // N s_4446_6: jump b2306
        return block_2306(state, tracer, fn_state);
    }
    fn block_4447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4447_0: read-var el:u8
        let s_4447_0: u8 = fn_state.el;
        // D s_4447_1: read-var coproc:u8
        let s_4447_1: u8 = fn_state.coproc;
        // D s_4447_2: read-var opc1:u8
        let s_4447_2: u8 = fn_state.opc1;
        // D s_4447_3: read-var CRn:u8
        let s_4447_3: u8 = fn_state.CRn;
        // D s_4447_4: read-var opc2:u8
        let s_4447_4: u8 = fn_state.opc2;
        // D s_4447_5: read-var CRm:u8
        let s_4447_5: u8 = fn_state.CRm;
        // D s_4447_6: read-var t:i
        let s_4447_6: i128 = fn_state.t;
        // D s_4447_7: call HSCTLR_SysRegWrite32_1fcc439d9224580e(s_4447_0, s_4447_1, s_4447_2, s_4447_3, s_4447_4, s_4447_5, s_4447_6)
        let s_4447_7: () = HSCTLR_SysRegWrite32_1fcc439d9224580e(
            state,
            tracer,
            s_4447_0,
            s_4447_1,
            s_4447_2,
            s_4447_3,
            s_4447_4,
            s_4447_5,
            s_4447_6,
        );
        // N s_4447_8: return
        return;
    }
    fn block_4448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4448_0: read-var opc2:u8
        let s_4448_0: u8 = fn_state.opc2;
        // D s_4448_1: cast zx s_4448_0 -> bv
        let s_4448_1: Bits = Bits::new(s_4448_0 as u128, 3u16);
        // C s_4448_2: const #0u : u8
        let s_4448_2: u8 = 0;
        // C s_4448_3: cast zx s_4448_2 -> bv
        let s_4448_3: Bits = Bits::new(s_4448_2 as u128, 3u16);
        // D s_4448_4: cmp-eq s_4448_1 s_4448_3
        let s_4448_4: bool = ((s_4448_1) == (s_4448_3));
        // D s_4448_5: write-var gs#135503 <= s_4448_4
        fn_state.gs_135503 = s_4448_4;
        // N s_4448_6: jump b2303
        return block_2303(state, tracer, fn_state);
    }
    fn block_4449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4449_0: read-var opc1:u8
        let s_4449_0: u8 = fn_state.opc1;
        // D s_4449_1: cast zx s_4449_0 -> bv
        let s_4449_1: Bits = Bits::new(s_4449_0 as u128, 3u16);
        // C s_4449_2: const #4u : u8
        let s_4449_2: u8 = 4;
        // C s_4449_3: cast zx s_4449_2 -> bv
        let s_4449_3: Bits = Bits::new(s_4449_2 as u128, 3u16);
        // D s_4449_4: cmp-eq s_4449_1 s_4449_3
        let s_4449_4: bool = ((s_4449_1) == (s_4449_3));
        // D s_4449_5: write-var gs#135502 <= s_4449_4
        fn_state.gs_135502 = s_4449_4;
        // N s_4449_6: jump b2301
        return block_2301(state, tracer, fn_state);
    }
    fn block_4450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4450_0: read-var coproc:u8
        let s_4450_0: u8 = fn_state.coproc;
        // D s_4450_1: cast zx s_4450_0 -> bv
        let s_4450_1: Bits = Bits::new(s_4450_0 as u128, 4u16);
        // C s_4450_2: const #15u : u8
        let s_4450_2: u8 = 15;
        // C s_4450_3: cast zx s_4450_2 -> bv
        let s_4450_3: Bits = Bits::new(s_4450_2 as u128, 4u16);
        // D s_4450_4: cmp-eq s_4450_1 s_4450_3
        let s_4450_4: bool = ((s_4450_1) == (s_4450_3));
        // D s_4450_5: write-var gs#135501 <= s_4450_4
        fn_state.gs_135501 = s_4450_4;
        // N s_4450_6: jump b2299
        return block_2299(state, tracer, fn_state);
    }
    fn block_4451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4451_0: read-var CRn:u8
        let s_4451_0: u8 = fn_state.CRn;
        // D s_4451_1: cast zx s_4451_0 -> bv
        let s_4451_1: Bits = Bits::new(s_4451_0 as u128, 4u16);
        // C s_4451_2: const #1u : u8
        let s_4451_2: u8 = 1;
        // C s_4451_3: cast zx s_4451_2 -> bv
        let s_4451_3: Bits = Bits::new(s_4451_2 as u128, 4u16);
        // D s_4451_4: cmp-eq s_4451_1 s_4451_3
        let s_4451_4: bool = ((s_4451_1) == (s_4451_3));
        // D s_4451_5: write-var gs#135500 <= s_4451_4
        fn_state.gs_135500 = s_4451_4;
        // N s_4451_6: jump b2297
        return block_2297(state, tracer, fn_state);
    }
    fn block_4452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4452_0: read-var el:u8
        let s_4452_0: u8 = fn_state.el;
        // D s_4452_1: read-var coproc:u8
        let s_4452_1: u8 = fn_state.coproc;
        // D s_4452_2: read-var opc1:u8
        let s_4452_2: u8 = fn_state.opc1;
        // D s_4452_3: read-var CRn:u8
        let s_4452_3: u8 = fn_state.CRn;
        // D s_4452_4: read-var opc2:u8
        let s_4452_4: u8 = fn_state.opc2;
        // D s_4452_5: read-var CRm:u8
        let s_4452_5: u8 = fn_state.CRm;
        // D s_4452_6: read-var t:i
        let s_4452_6: i128 = fn_state.t;
        // D s_4452_7: call DBGWFAR_SysRegWrite32_a92f4990bd564fb8(s_4452_0, s_4452_1, s_4452_2, s_4452_3, s_4452_4, s_4452_5, s_4452_6)
        let s_4452_7: () = DBGWFAR_SysRegWrite32_a92f4990bd564fb8(
            state,
            tracer,
            s_4452_0,
            s_4452_1,
            s_4452_2,
            s_4452_3,
            s_4452_4,
            s_4452_5,
            s_4452_6,
        );
        // N s_4452_8: return
        return;
    }
    fn block_4453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4453_0: read-var opc2:u8
        let s_4453_0: u8 = fn_state.opc2;
        // D s_4453_1: cast zx s_4453_0 -> bv
        let s_4453_1: Bits = Bits::new(s_4453_0 as u128, 3u16);
        // C s_4453_2: const #0u : u8
        let s_4453_2: u8 = 0;
        // C s_4453_3: cast zx s_4453_2 -> bv
        let s_4453_3: Bits = Bits::new(s_4453_2 as u128, 3u16);
        // D s_4453_4: cmp-eq s_4453_1 s_4453_3
        let s_4453_4: bool = ((s_4453_1) == (s_4453_3));
        // D s_4453_5: write-var gs#135499 <= s_4453_4
        fn_state.gs_135499 = s_4453_4;
        // N s_4453_6: jump b2294
        return block_2294(state, tracer, fn_state);
    }
    fn block_4454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4454_0: read-var opc1:u8
        let s_4454_0: u8 = fn_state.opc1;
        // D s_4454_1: cast zx s_4454_0 -> bv
        let s_4454_1: Bits = Bits::new(s_4454_0 as u128, 3u16);
        // C s_4454_2: const #0u : u8
        let s_4454_2: u8 = 0;
        // C s_4454_3: cast zx s_4454_2 -> bv
        let s_4454_3: Bits = Bits::new(s_4454_2 as u128, 3u16);
        // D s_4454_4: cmp-eq s_4454_1 s_4454_3
        let s_4454_4: bool = ((s_4454_1) == (s_4454_3));
        // D s_4454_5: write-var gs#135498 <= s_4454_4
        fn_state.gs_135498 = s_4454_4;
        // N s_4454_6: jump b2292
        return block_2292(state, tracer, fn_state);
    }
    fn block_4455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4455_0: read-var coproc:u8
        let s_4455_0: u8 = fn_state.coproc;
        // D s_4455_1: cast zx s_4455_0 -> bv
        let s_4455_1: Bits = Bits::new(s_4455_0 as u128, 4u16);
        // C s_4455_2: const #14u : u8
        let s_4455_2: u8 = 14;
        // C s_4455_3: cast zx s_4455_2 -> bv
        let s_4455_3: Bits = Bits::new(s_4455_2 as u128, 4u16);
        // D s_4455_4: cmp-eq s_4455_1 s_4455_3
        let s_4455_4: bool = ((s_4455_1) == (s_4455_3));
        // D s_4455_5: write-var gs#135497 <= s_4455_4
        fn_state.gs_135497 = s_4455_4;
        // N s_4455_6: jump b2290
        return block_2290(state, tracer, fn_state);
    }
    fn block_4456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4456_0: read-var CRn:u8
        let s_4456_0: u8 = fn_state.CRn;
        // D s_4456_1: cast zx s_4456_0 -> bv
        let s_4456_1: Bits = Bits::new(s_4456_0 as u128, 4u16);
        // C s_4456_2: const #0u : u8
        let s_4456_2: u8 = 0;
        // C s_4456_3: cast zx s_4456_2 -> bv
        let s_4456_3: Bits = Bits::new(s_4456_2 as u128, 4u16);
        // D s_4456_4: cmp-eq s_4456_1 s_4456_3
        let s_4456_4: bool = ((s_4456_1) == (s_4456_3));
        // D s_4456_5: write-var gs#135496 <= s_4456_4
        fn_state.gs_135496 = s_4456_4;
        // N s_4456_6: jump b2288
        return block_2288(state, tracer, fn_state);
    }
    fn block_4457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4457_0: read-var el:u8
        let s_4457_0: u8 = fn_state.el;
        // D s_4457_1: read-var coproc:u8
        let s_4457_1: u8 = fn_state.coproc;
        // D s_4457_2: read-var opc1:u8
        let s_4457_2: u8 = fn_state.opc1;
        // D s_4457_3: read-var CRn:u8
        let s_4457_3: u8 = fn_state.CRn;
        // D s_4457_4: read-var opc2:u8
        let s_4457_4: u8 = fn_state.opc2;
        // D s_4457_5: read-var CRm:u8
        let s_4457_5: u8 = fn_state.CRm;
        // D s_4457_6: read-var t:i
        let s_4457_6: i128 = fn_state.t;
        // D s_4457_7: call DBGBCR_SysRegWrite32_c77332e4c2ad23f2(s_4457_0, s_4457_1, s_4457_2, s_4457_3, s_4457_4, s_4457_5, s_4457_6)
        let s_4457_7: () = DBGBCR_SysRegWrite32_c77332e4c2ad23f2(
            state,
            tracer,
            s_4457_0,
            s_4457_1,
            s_4457_2,
            s_4457_3,
            s_4457_4,
            s_4457_5,
            s_4457_6,
        );
        // N s_4457_8: return
        return;
    }
    fn block_4458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4458_0: read-var opc2:u8
        let s_4458_0: u8 = fn_state.opc2;
        // D s_4458_1: cast zx s_4458_0 -> bv
        let s_4458_1: Bits = Bits::new(s_4458_0 as u128, 3u16);
        // C s_4458_2: const #5u : u8
        let s_4458_2: u8 = 5;
        // C s_4458_3: cast zx s_4458_2 -> bv
        let s_4458_3: Bits = Bits::new(s_4458_2 as u128, 3u16);
        // D s_4458_4: cmp-eq s_4458_1 s_4458_3
        let s_4458_4: bool = ((s_4458_1) == (s_4458_3));
        // D s_4458_5: write-var gs#135495 <= s_4458_4
        fn_state.gs_135495 = s_4458_4;
        // N s_4458_6: jump b2285
        return block_2285(state, tracer, fn_state);
    }
    fn block_4459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4459_0: read-var opc1:u8
        let s_4459_0: u8 = fn_state.opc1;
        // D s_4459_1: cast zx s_4459_0 -> bv
        let s_4459_1: Bits = Bits::new(s_4459_0 as u128, 3u16);
        // C s_4459_2: const #0u : u8
        let s_4459_2: u8 = 0;
        // C s_4459_3: cast zx s_4459_2 -> bv
        let s_4459_3: Bits = Bits::new(s_4459_2 as u128, 3u16);
        // D s_4459_4: cmp-eq s_4459_1 s_4459_3
        let s_4459_4: bool = ((s_4459_1) == (s_4459_3));
        // D s_4459_5: write-var gs#135494 <= s_4459_4
        fn_state.gs_135494 = s_4459_4;
        // N s_4459_6: jump b2283
        return block_2283(state, tracer, fn_state);
    }
    fn block_4460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4460_0: read-var coproc:u8
        let s_4460_0: u8 = fn_state.coproc;
        // D s_4460_1: cast zx s_4460_0 -> bv
        let s_4460_1: Bits = Bits::new(s_4460_0 as u128, 4u16);
        // C s_4460_2: const #14u : u8
        let s_4460_2: u8 = 14;
        // C s_4460_3: cast zx s_4460_2 -> bv
        let s_4460_3: Bits = Bits::new(s_4460_2 as u128, 4u16);
        // D s_4460_4: cmp-eq s_4460_1 s_4460_3
        let s_4460_4: bool = ((s_4460_1) == (s_4460_3));
        // D s_4460_5: write-var gs#135493 <= s_4460_4
        fn_state.gs_135493 = s_4460_4;
        // N s_4460_6: jump b2281
        return block_2281(state, tracer, fn_state);
    }
    fn block_4461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4461_0: read-var CRn:u8
        let s_4461_0: u8 = fn_state.CRn;
        // D s_4461_1: cast zx s_4461_0 -> bv
        let s_4461_1: Bits = Bits::new(s_4461_0 as u128, 4u16);
        // C s_4461_2: const #0u : u8
        let s_4461_2: u8 = 0;
        // C s_4461_3: cast zx s_4461_2 -> bv
        let s_4461_3: Bits = Bits::new(s_4461_2 as u128, 4u16);
        // D s_4461_4: cmp-eq s_4461_1 s_4461_3
        let s_4461_4: bool = ((s_4461_1) == (s_4461_3));
        // D s_4461_5: write-var gs#135492 <= s_4461_4
        fn_state.gs_135492 = s_4461_4;
        // N s_4461_6: jump b2279
        return block_2279(state, tracer, fn_state);
    }
    fn block_4462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4462_0: read-var el:u8
        let s_4462_0: u8 = fn_state.el;
        // D s_4462_1: read-var coproc:u8
        let s_4462_1: u8 = fn_state.coproc;
        // D s_4462_2: read-var opc1:u8
        let s_4462_2: u8 = fn_state.opc1;
        // D s_4462_3: read-var CRn:u8
        let s_4462_3: u8 = fn_state.CRn;
        // D s_4462_4: read-var opc2:u8
        let s_4462_4: u8 = fn_state.opc2;
        // D s_4462_5: read-var CRm:u8
        let s_4462_5: u8 = fn_state.CRm;
        // D s_4462_6: read-var t:i
        let s_4462_6: i128 = fn_state.t;
        // D s_4462_7: call DBGBCR_SysRegWrite32_122d009e13ded976(s_4462_0, s_4462_1, s_4462_2, s_4462_3, s_4462_4, s_4462_5, s_4462_6)
        let s_4462_7: () = DBGBCR_SysRegWrite32_122d009e13ded976(
            state,
            tracer,
            s_4462_0,
            s_4462_1,
            s_4462_2,
            s_4462_3,
            s_4462_4,
            s_4462_5,
            s_4462_6,
        );
        // N s_4462_8: return
        return;
    }
    fn block_4463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4463_0: read-var opc2:u8
        let s_4463_0: u8 = fn_state.opc2;
        // D s_4463_1: cast zx s_4463_0 -> bv
        let s_4463_1: Bits = Bits::new(s_4463_0 as u128, 3u16);
        // C s_4463_2: const #5u : u8
        let s_4463_2: u8 = 5;
        // C s_4463_3: cast zx s_4463_2 -> bv
        let s_4463_3: Bits = Bits::new(s_4463_2 as u128, 3u16);
        // D s_4463_4: cmp-eq s_4463_1 s_4463_3
        let s_4463_4: bool = ((s_4463_1) == (s_4463_3));
        // D s_4463_5: write-var gs#135491 <= s_4463_4
        fn_state.gs_135491 = s_4463_4;
        // N s_4463_6: jump b2276
        return block_2276(state, tracer, fn_state);
    }
    fn block_4464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4464_0: read-var opc1:u8
        let s_4464_0: u8 = fn_state.opc1;
        // D s_4464_1: cast zx s_4464_0 -> bv
        let s_4464_1: Bits = Bits::new(s_4464_0 as u128, 3u16);
        // C s_4464_2: const #0u : u8
        let s_4464_2: u8 = 0;
        // C s_4464_3: cast zx s_4464_2 -> bv
        let s_4464_3: Bits = Bits::new(s_4464_2 as u128, 3u16);
        // D s_4464_4: cmp-eq s_4464_1 s_4464_3
        let s_4464_4: bool = ((s_4464_1) == (s_4464_3));
        // D s_4464_5: write-var gs#135490 <= s_4464_4
        fn_state.gs_135490 = s_4464_4;
        // N s_4464_6: jump b2274
        return block_2274(state, tracer, fn_state);
    }
    fn block_4465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4465_0: read-var coproc:u8
        let s_4465_0: u8 = fn_state.coproc;
        // D s_4465_1: cast zx s_4465_0 -> bv
        let s_4465_1: Bits = Bits::new(s_4465_0 as u128, 4u16);
        // C s_4465_2: const #14u : u8
        let s_4465_2: u8 = 14;
        // C s_4465_3: cast zx s_4465_2 -> bv
        let s_4465_3: Bits = Bits::new(s_4465_2 as u128, 4u16);
        // D s_4465_4: cmp-eq s_4465_1 s_4465_3
        let s_4465_4: bool = ((s_4465_1) == (s_4465_3));
        // D s_4465_5: write-var gs#135489 <= s_4465_4
        fn_state.gs_135489 = s_4465_4;
        // N s_4465_6: jump b2272
        return block_2272(state, tracer, fn_state);
    }
    fn block_4466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4466_0: read-var CRn:u8
        let s_4466_0: u8 = fn_state.CRn;
        // D s_4466_1: cast zx s_4466_0 -> bv
        let s_4466_1: Bits = Bits::new(s_4466_0 as u128, 4u16);
        // C s_4466_2: const #0u : u8
        let s_4466_2: u8 = 0;
        // C s_4466_3: cast zx s_4466_2 -> bv
        let s_4466_3: Bits = Bits::new(s_4466_2 as u128, 4u16);
        // D s_4466_4: cmp-eq s_4466_1 s_4466_3
        let s_4466_4: bool = ((s_4466_1) == (s_4466_3));
        // D s_4466_5: write-var gs#135488 <= s_4466_4
        fn_state.gs_135488 = s_4466_4;
        // N s_4466_6: jump b2270
        return block_2270(state, tracer, fn_state);
    }
    fn block_4467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4467_0: read-var el:u8
        let s_4467_0: u8 = fn_state.el;
        // D s_4467_1: read-var coproc:u8
        let s_4467_1: u8 = fn_state.coproc;
        // D s_4467_2: read-var opc1:u8
        let s_4467_2: u8 = fn_state.opc1;
        // D s_4467_3: read-var CRn:u8
        let s_4467_3: u8 = fn_state.CRn;
        // D s_4467_4: read-var opc2:u8
        let s_4467_4: u8 = fn_state.opc2;
        // D s_4467_5: read-var CRm:u8
        let s_4467_5: u8 = fn_state.CRm;
        // D s_4467_6: read-var t:i
        let s_4467_6: i128 = fn_state.t;
        // D s_4467_7: call DBGBCR_SysRegWrite32_4d31a2bbe5418934(s_4467_0, s_4467_1, s_4467_2, s_4467_3, s_4467_4, s_4467_5, s_4467_6)
        let s_4467_7: () = DBGBCR_SysRegWrite32_4d31a2bbe5418934(
            state,
            tracer,
            s_4467_0,
            s_4467_1,
            s_4467_2,
            s_4467_3,
            s_4467_4,
            s_4467_5,
            s_4467_6,
        );
        // N s_4467_8: return
        return;
    }
    fn block_4468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4468_0: read-var opc2:u8
        let s_4468_0: u8 = fn_state.opc2;
        // D s_4468_1: cast zx s_4468_0 -> bv
        let s_4468_1: Bits = Bits::new(s_4468_0 as u128, 3u16);
        // C s_4468_2: const #5u : u8
        let s_4468_2: u8 = 5;
        // C s_4468_3: cast zx s_4468_2 -> bv
        let s_4468_3: Bits = Bits::new(s_4468_2 as u128, 3u16);
        // D s_4468_4: cmp-eq s_4468_1 s_4468_3
        let s_4468_4: bool = ((s_4468_1) == (s_4468_3));
        // D s_4468_5: write-var gs#135487 <= s_4468_4
        fn_state.gs_135487 = s_4468_4;
        // N s_4468_6: jump b2267
        return block_2267(state, tracer, fn_state);
    }
    fn block_4469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4469_0: read-var opc1:u8
        let s_4469_0: u8 = fn_state.opc1;
        // D s_4469_1: cast zx s_4469_0 -> bv
        let s_4469_1: Bits = Bits::new(s_4469_0 as u128, 3u16);
        // C s_4469_2: const #0u : u8
        let s_4469_2: u8 = 0;
        // C s_4469_3: cast zx s_4469_2 -> bv
        let s_4469_3: Bits = Bits::new(s_4469_2 as u128, 3u16);
        // D s_4469_4: cmp-eq s_4469_1 s_4469_3
        let s_4469_4: bool = ((s_4469_1) == (s_4469_3));
        // D s_4469_5: write-var gs#135486 <= s_4469_4
        fn_state.gs_135486 = s_4469_4;
        // N s_4469_6: jump b2265
        return block_2265(state, tracer, fn_state);
    }
    fn block_4470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4470_0: read-var coproc:u8
        let s_4470_0: u8 = fn_state.coproc;
        // D s_4470_1: cast zx s_4470_0 -> bv
        let s_4470_1: Bits = Bits::new(s_4470_0 as u128, 4u16);
        // C s_4470_2: const #14u : u8
        let s_4470_2: u8 = 14;
        // C s_4470_3: cast zx s_4470_2 -> bv
        let s_4470_3: Bits = Bits::new(s_4470_2 as u128, 4u16);
        // D s_4470_4: cmp-eq s_4470_1 s_4470_3
        let s_4470_4: bool = ((s_4470_1) == (s_4470_3));
        // D s_4470_5: write-var gs#135485 <= s_4470_4
        fn_state.gs_135485 = s_4470_4;
        // N s_4470_6: jump b2263
        return block_2263(state, tracer, fn_state);
    }
    fn block_4471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4471_0: read-var CRn:u8
        let s_4471_0: u8 = fn_state.CRn;
        // D s_4471_1: cast zx s_4471_0 -> bv
        let s_4471_1: Bits = Bits::new(s_4471_0 as u128, 4u16);
        // C s_4471_2: const #0u : u8
        let s_4471_2: u8 = 0;
        // C s_4471_3: cast zx s_4471_2 -> bv
        let s_4471_3: Bits = Bits::new(s_4471_2 as u128, 4u16);
        // D s_4471_4: cmp-eq s_4471_1 s_4471_3
        let s_4471_4: bool = ((s_4471_1) == (s_4471_3));
        // D s_4471_5: write-var gs#135484 <= s_4471_4
        fn_state.gs_135484 = s_4471_4;
        // N s_4471_6: jump b2261
        return block_2261(state, tracer, fn_state);
    }
    fn block_4472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4472_0: read-var el:u8
        let s_4472_0: u8 = fn_state.el;
        // D s_4472_1: read-var coproc:u8
        let s_4472_1: u8 = fn_state.coproc;
        // D s_4472_2: read-var opc1:u8
        let s_4472_2: u8 = fn_state.opc1;
        // D s_4472_3: read-var CRn:u8
        let s_4472_3: u8 = fn_state.CRn;
        // D s_4472_4: read-var opc2:u8
        let s_4472_4: u8 = fn_state.opc2;
        // D s_4472_5: read-var CRm:u8
        let s_4472_5: u8 = fn_state.CRm;
        // D s_4472_6: read-var t:i
        let s_4472_6: i128 = fn_state.t;
        // D s_4472_7: call DBGBCR_SysRegWrite32_77964c377a44e2ca(s_4472_0, s_4472_1, s_4472_2, s_4472_3, s_4472_4, s_4472_5, s_4472_6)
        let s_4472_7: () = DBGBCR_SysRegWrite32_77964c377a44e2ca(
            state,
            tracer,
            s_4472_0,
            s_4472_1,
            s_4472_2,
            s_4472_3,
            s_4472_4,
            s_4472_5,
            s_4472_6,
        );
        // N s_4472_8: return
        return;
    }
    fn block_4473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4473_0: read-var opc2:u8
        let s_4473_0: u8 = fn_state.opc2;
        // D s_4473_1: cast zx s_4473_0 -> bv
        let s_4473_1: Bits = Bits::new(s_4473_0 as u128, 3u16);
        // C s_4473_2: const #5u : u8
        let s_4473_2: u8 = 5;
        // C s_4473_3: cast zx s_4473_2 -> bv
        let s_4473_3: Bits = Bits::new(s_4473_2 as u128, 3u16);
        // D s_4473_4: cmp-eq s_4473_1 s_4473_3
        let s_4473_4: bool = ((s_4473_1) == (s_4473_3));
        // D s_4473_5: write-var gs#135483 <= s_4473_4
        fn_state.gs_135483 = s_4473_4;
        // N s_4473_6: jump b2258
        return block_2258(state, tracer, fn_state);
    }
    fn block_4474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4474_0: read-var opc1:u8
        let s_4474_0: u8 = fn_state.opc1;
        // D s_4474_1: cast zx s_4474_0 -> bv
        let s_4474_1: Bits = Bits::new(s_4474_0 as u128, 3u16);
        // C s_4474_2: const #0u : u8
        let s_4474_2: u8 = 0;
        // C s_4474_3: cast zx s_4474_2 -> bv
        let s_4474_3: Bits = Bits::new(s_4474_2 as u128, 3u16);
        // D s_4474_4: cmp-eq s_4474_1 s_4474_3
        let s_4474_4: bool = ((s_4474_1) == (s_4474_3));
        // D s_4474_5: write-var gs#135482 <= s_4474_4
        fn_state.gs_135482 = s_4474_4;
        // N s_4474_6: jump b2256
        return block_2256(state, tracer, fn_state);
    }
    fn block_4475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4475_0: read-var coproc:u8
        let s_4475_0: u8 = fn_state.coproc;
        // D s_4475_1: cast zx s_4475_0 -> bv
        let s_4475_1: Bits = Bits::new(s_4475_0 as u128, 4u16);
        // C s_4475_2: const #14u : u8
        let s_4475_2: u8 = 14;
        // C s_4475_3: cast zx s_4475_2 -> bv
        let s_4475_3: Bits = Bits::new(s_4475_2 as u128, 4u16);
        // D s_4475_4: cmp-eq s_4475_1 s_4475_3
        let s_4475_4: bool = ((s_4475_1) == (s_4475_3));
        // D s_4475_5: write-var gs#135481 <= s_4475_4
        fn_state.gs_135481 = s_4475_4;
        // N s_4475_6: jump b2254
        return block_2254(state, tracer, fn_state);
    }
    fn block_4476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4476_0: read-var CRn:u8
        let s_4476_0: u8 = fn_state.CRn;
        // D s_4476_1: cast zx s_4476_0 -> bv
        let s_4476_1: Bits = Bits::new(s_4476_0 as u128, 4u16);
        // C s_4476_2: const #0u : u8
        let s_4476_2: u8 = 0;
        // C s_4476_3: cast zx s_4476_2 -> bv
        let s_4476_3: Bits = Bits::new(s_4476_2 as u128, 4u16);
        // D s_4476_4: cmp-eq s_4476_1 s_4476_3
        let s_4476_4: bool = ((s_4476_1) == (s_4476_3));
        // D s_4476_5: write-var gs#135480 <= s_4476_4
        fn_state.gs_135480 = s_4476_4;
        // N s_4476_6: jump b2252
        return block_2252(state, tracer, fn_state);
    }
    fn block_4477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4477_0: read-var el:u8
        let s_4477_0: u8 = fn_state.el;
        // D s_4477_1: read-var coproc:u8
        let s_4477_1: u8 = fn_state.coproc;
        // D s_4477_2: read-var opc1:u8
        let s_4477_2: u8 = fn_state.opc1;
        // D s_4477_3: read-var CRn:u8
        let s_4477_3: u8 = fn_state.CRn;
        // D s_4477_4: read-var opc2:u8
        let s_4477_4: u8 = fn_state.opc2;
        // D s_4477_5: read-var CRm:u8
        let s_4477_5: u8 = fn_state.CRm;
        // D s_4477_6: read-var t:i
        let s_4477_6: i128 = fn_state.t;
        // D s_4477_7: call DBGBCR_SysRegWrite32_951097733e549f18(s_4477_0, s_4477_1, s_4477_2, s_4477_3, s_4477_4, s_4477_5, s_4477_6)
        let s_4477_7: () = DBGBCR_SysRegWrite32_951097733e549f18(
            state,
            tracer,
            s_4477_0,
            s_4477_1,
            s_4477_2,
            s_4477_3,
            s_4477_4,
            s_4477_5,
            s_4477_6,
        );
        // N s_4477_8: return
        return;
    }
    fn block_4478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4478_0: read-var opc2:u8
        let s_4478_0: u8 = fn_state.opc2;
        // D s_4478_1: cast zx s_4478_0 -> bv
        let s_4478_1: Bits = Bits::new(s_4478_0 as u128, 3u16);
        // C s_4478_2: const #5u : u8
        let s_4478_2: u8 = 5;
        // C s_4478_3: cast zx s_4478_2 -> bv
        let s_4478_3: Bits = Bits::new(s_4478_2 as u128, 3u16);
        // D s_4478_4: cmp-eq s_4478_1 s_4478_3
        let s_4478_4: bool = ((s_4478_1) == (s_4478_3));
        // D s_4478_5: write-var gs#135479 <= s_4478_4
        fn_state.gs_135479 = s_4478_4;
        // N s_4478_6: jump b2249
        return block_2249(state, tracer, fn_state);
    }
    fn block_4479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4479_0: read-var opc1:u8
        let s_4479_0: u8 = fn_state.opc1;
        // D s_4479_1: cast zx s_4479_0 -> bv
        let s_4479_1: Bits = Bits::new(s_4479_0 as u128, 3u16);
        // C s_4479_2: const #0u : u8
        let s_4479_2: u8 = 0;
        // C s_4479_3: cast zx s_4479_2 -> bv
        let s_4479_3: Bits = Bits::new(s_4479_2 as u128, 3u16);
        // D s_4479_4: cmp-eq s_4479_1 s_4479_3
        let s_4479_4: bool = ((s_4479_1) == (s_4479_3));
        // D s_4479_5: write-var gs#135478 <= s_4479_4
        fn_state.gs_135478 = s_4479_4;
        // N s_4479_6: jump b2247
        return block_2247(state, tracer, fn_state);
    }
    fn block_4480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4480_0: read-var coproc:u8
        let s_4480_0: u8 = fn_state.coproc;
        // D s_4480_1: cast zx s_4480_0 -> bv
        let s_4480_1: Bits = Bits::new(s_4480_0 as u128, 4u16);
        // C s_4480_2: const #14u : u8
        let s_4480_2: u8 = 14;
        // C s_4480_3: cast zx s_4480_2 -> bv
        let s_4480_3: Bits = Bits::new(s_4480_2 as u128, 4u16);
        // D s_4480_4: cmp-eq s_4480_1 s_4480_3
        let s_4480_4: bool = ((s_4480_1) == (s_4480_3));
        // D s_4480_5: write-var gs#135477 <= s_4480_4
        fn_state.gs_135477 = s_4480_4;
        // N s_4480_6: jump b2245
        return block_2245(state, tracer, fn_state);
    }
    fn block_4481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4481_0: read-var CRn:u8
        let s_4481_0: u8 = fn_state.CRn;
        // D s_4481_1: cast zx s_4481_0 -> bv
        let s_4481_1: Bits = Bits::new(s_4481_0 as u128, 4u16);
        // C s_4481_2: const #0u : u8
        let s_4481_2: u8 = 0;
        // C s_4481_3: cast zx s_4481_2 -> bv
        let s_4481_3: Bits = Bits::new(s_4481_2 as u128, 4u16);
        // D s_4481_4: cmp-eq s_4481_1 s_4481_3
        let s_4481_4: bool = ((s_4481_1) == (s_4481_3));
        // D s_4481_5: write-var gs#135476 <= s_4481_4
        fn_state.gs_135476 = s_4481_4;
        // N s_4481_6: jump b2243
        return block_2243(state, tracer, fn_state);
    }
    fn block_4482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4482_0: read-var el:u8
        let s_4482_0: u8 = fn_state.el;
        // D s_4482_1: read-var coproc:u8
        let s_4482_1: u8 = fn_state.coproc;
        // D s_4482_2: read-var opc1:u8
        let s_4482_2: u8 = fn_state.opc1;
        // D s_4482_3: read-var CRn:u8
        let s_4482_3: u8 = fn_state.CRn;
        // D s_4482_4: read-var opc2:u8
        let s_4482_4: u8 = fn_state.opc2;
        // D s_4482_5: read-var CRm:u8
        let s_4482_5: u8 = fn_state.CRm;
        // D s_4482_6: read-var t:i
        let s_4482_6: i128 = fn_state.t;
        // D s_4482_7: call DBGBCR_SysRegWrite32_56e01e085292f5f1(s_4482_0, s_4482_1, s_4482_2, s_4482_3, s_4482_4, s_4482_5, s_4482_6)
        let s_4482_7: () = DBGBCR_SysRegWrite32_56e01e085292f5f1(
            state,
            tracer,
            s_4482_0,
            s_4482_1,
            s_4482_2,
            s_4482_3,
            s_4482_4,
            s_4482_5,
            s_4482_6,
        );
        // N s_4482_8: return
        return;
    }
    fn block_4483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4483_0: read-var opc2:u8
        let s_4483_0: u8 = fn_state.opc2;
        // D s_4483_1: cast zx s_4483_0 -> bv
        let s_4483_1: Bits = Bits::new(s_4483_0 as u128, 3u16);
        // C s_4483_2: const #5u : u8
        let s_4483_2: u8 = 5;
        // C s_4483_3: cast zx s_4483_2 -> bv
        let s_4483_3: Bits = Bits::new(s_4483_2 as u128, 3u16);
        // D s_4483_4: cmp-eq s_4483_1 s_4483_3
        let s_4483_4: bool = ((s_4483_1) == (s_4483_3));
        // D s_4483_5: write-var gs#135475 <= s_4483_4
        fn_state.gs_135475 = s_4483_4;
        // N s_4483_6: jump b2240
        return block_2240(state, tracer, fn_state);
    }
    fn block_4484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4484_0: read-var opc1:u8
        let s_4484_0: u8 = fn_state.opc1;
        // D s_4484_1: cast zx s_4484_0 -> bv
        let s_4484_1: Bits = Bits::new(s_4484_0 as u128, 3u16);
        // C s_4484_2: const #0u : u8
        let s_4484_2: u8 = 0;
        // C s_4484_3: cast zx s_4484_2 -> bv
        let s_4484_3: Bits = Bits::new(s_4484_2 as u128, 3u16);
        // D s_4484_4: cmp-eq s_4484_1 s_4484_3
        let s_4484_4: bool = ((s_4484_1) == (s_4484_3));
        // D s_4484_5: write-var gs#135474 <= s_4484_4
        fn_state.gs_135474 = s_4484_4;
        // N s_4484_6: jump b2238
        return block_2238(state, tracer, fn_state);
    }
    fn block_4485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4485_0: read-var coproc:u8
        let s_4485_0: u8 = fn_state.coproc;
        // D s_4485_1: cast zx s_4485_0 -> bv
        let s_4485_1: Bits = Bits::new(s_4485_0 as u128, 4u16);
        // C s_4485_2: const #14u : u8
        let s_4485_2: u8 = 14;
        // C s_4485_3: cast zx s_4485_2 -> bv
        let s_4485_3: Bits = Bits::new(s_4485_2 as u128, 4u16);
        // D s_4485_4: cmp-eq s_4485_1 s_4485_3
        let s_4485_4: bool = ((s_4485_1) == (s_4485_3));
        // D s_4485_5: write-var gs#135473 <= s_4485_4
        fn_state.gs_135473 = s_4485_4;
        // N s_4485_6: jump b2236
        return block_2236(state, tracer, fn_state);
    }
    fn block_4486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4486_0: read-var CRn:u8
        let s_4486_0: u8 = fn_state.CRn;
        // D s_4486_1: cast zx s_4486_0 -> bv
        let s_4486_1: Bits = Bits::new(s_4486_0 as u128, 4u16);
        // C s_4486_2: const #0u : u8
        let s_4486_2: u8 = 0;
        // C s_4486_3: cast zx s_4486_2 -> bv
        let s_4486_3: Bits = Bits::new(s_4486_2 as u128, 4u16);
        // D s_4486_4: cmp-eq s_4486_1 s_4486_3
        let s_4486_4: bool = ((s_4486_1) == (s_4486_3));
        // D s_4486_5: write-var gs#135472 <= s_4486_4
        fn_state.gs_135472 = s_4486_4;
        // N s_4486_6: jump b2234
        return block_2234(state, tracer, fn_state);
    }
    fn block_4487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4487_0: read-var el:u8
        let s_4487_0: u8 = fn_state.el;
        // D s_4487_1: read-var coproc:u8
        let s_4487_1: u8 = fn_state.coproc;
        // D s_4487_2: read-var opc1:u8
        let s_4487_2: u8 = fn_state.opc1;
        // D s_4487_3: read-var CRn:u8
        let s_4487_3: u8 = fn_state.CRn;
        // D s_4487_4: read-var opc2:u8
        let s_4487_4: u8 = fn_state.opc2;
        // D s_4487_5: read-var CRm:u8
        let s_4487_5: u8 = fn_state.CRm;
        // D s_4487_6: read-var t:i
        let s_4487_6: i128 = fn_state.t;
        // D s_4487_7: call DBGBCR_SysRegWrite32_4811ff3f924f49d2(s_4487_0, s_4487_1, s_4487_2, s_4487_3, s_4487_4, s_4487_5, s_4487_6)
        let s_4487_7: () = DBGBCR_SysRegWrite32_4811ff3f924f49d2(
            state,
            tracer,
            s_4487_0,
            s_4487_1,
            s_4487_2,
            s_4487_3,
            s_4487_4,
            s_4487_5,
            s_4487_6,
        );
        // N s_4487_8: return
        return;
    }
    fn block_4488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4488_0: read-var opc2:u8
        let s_4488_0: u8 = fn_state.opc2;
        // D s_4488_1: cast zx s_4488_0 -> bv
        let s_4488_1: Bits = Bits::new(s_4488_0 as u128, 3u16);
        // C s_4488_2: const #5u : u8
        let s_4488_2: u8 = 5;
        // C s_4488_3: cast zx s_4488_2 -> bv
        let s_4488_3: Bits = Bits::new(s_4488_2 as u128, 3u16);
        // D s_4488_4: cmp-eq s_4488_1 s_4488_3
        let s_4488_4: bool = ((s_4488_1) == (s_4488_3));
        // D s_4488_5: write-var gs#135471 <= s_4488_4
        fn_state.gs_135471 = s_4488_4;
        // N s_4488_6: jump b2231
        return block_2231(state, tracer, fn_state);
    }
    fn block_4489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4489_0: read-var opc1:u8
        let s_4489_0: u8 = fn_state.opc1;
        // D s_4489_1: cast zx s_4489_0 -> bv
        let s_4489_1: Bits = Bits::new(s_4489_0 as u128, 3u16);
        // C s_4489_2: const #0u : u8
        let s_4489_2: u8 = 0;
        // C s_4489_3: cast zx s_4489_2 -> bv
        let s_4489_3: Bits = Bits::new(s_4489_2 as u128, 3u16);
        // D s_4489_4: cmp-eq s_4489_1 s_4489_3
        let s_4489_4: bool = ((s_4489_1) == (s_4489_3));
        // D s_4489_5: write-var gs#135470 <= s_4489_4
        fn_state.gs_135470 = s_4489_4;
        // N s_4489_6: jump b2229
        return block_2229(state, tracer, fn_state);
    }
    fn block_4490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4490_0: read-var coproc:u8
        let s_4490_0: u8 = fn_state.coproc;
        // D s_4490_1: cast zx s_4490_0 -> bv
        let s_4490_1: Bits = Bits::new(s_4490_0 as u128, 4u16);
        // C s_4490_2: const #14u : u8
        let s_4490_2: u8 = 14;
        // C s_4490_3: cast zx s_4490_2 -> bv
        let s_4490_3: Bits = Bits::new(s_4490_2 as u128, 4u16);
        // D s_4490_4: cmp-eq s_4490_1 s_4490_3
        let s_4490_4: bool = ((s_4490_1) == (s_4490_3));
        // D s_4490_5: write-var gs#135469 <= s_4490_4
        fn_state.gs_135469 = s_4490_4;
        // N s_4490_6: jump b2227
        return block_2227(state, tracer, fn_state);
    }
    fn block_4491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4491_0: read-var CRn:u8
        let s_4491_0: u8 = fn_state.CRn;
        // D s_4491_1: cast zx s_4491_0 -> bv
        let s_4491_1: Bits = Bits::new(s_4491_0 as u128, 4u16);
        // C s_4491_2: const #0u : u8
        let s_4491_2: u8 = 0;
        // C s_4491_3: cast zx s_4491_2 -> bv
        let s_4491_3: Bits = Bits::new(s_4491_2 as u128, 4u16);
        // D s_4491_4: cmp-eq s_4491_1 s_4491_3
        let s_4491_4: bool = ((s_4491_1) == (s_4491_3));
        // D s_4491_5: write-var gs#135468 <= s_4491_4
        fn_state.gs_135468 = s_4491_4;
        // N s_4491_6: jump b2225
        return block_2225(state, tracer, fn_state);
    }
    fn block_4492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4492_0: read-var el:u8
        let s_4492_0: u8 = fn_state.el;
        // D s_4492_1: read-var coproc:u8
        let s_4492_1: u8 = fn_state.coproc;
        // D s_4492_2: read-var opc1:u8
        let s_4492_2: u8 = fn_state.opc1;
        // D s_4492_3: read-var CRn:u8
        let s_4492_3: u8 = fn_state.CRn;
        // D s_4492_4: read-var opc2:u8
        let s_4492_4: u8 = fn_state.opc2;
        // D s_4492_5: read-var CRm:u8
        let s_4492_5: u8 = fn_state.CRm;
        // D s_4492_6: read-var t:i
        let s_4492_6: i128 = fn_state.t;
        // D s_4492_7: call DBGBCR_SysRegWrite32_ca879b07da5bfe93(s_4492_0, s_4492_1, s_4492_2, s_4492_3, s_4492_4, s_4492_5, s_4492_6)
        let s_4492_7: () = DBGBCR_SysRegWrite32_ca879b07da5bfe93(
            state,
            tracer,
            s_4492_0,
            s_4492_1,
            s_4492_2,
            s_4492_3,
            s_4492_4,
            s_4492_5,
            s_4492_6,
        );
        // N s_4492_8: return
        return;
    }
    fn block_4493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4493_0: read-var opc2:u8
        let s_4493_0: u8 = fn_state.opc2;
        // D s_4493_1: cast zx s_4493_0 -> bv
        let s_4493_1: Bits = Bits::new(s_4493_0 as u128, 3u16);
        // C s_4493_2: const #5u : u8
        let s_4493_2: u8 = 5;
        // C s_4493_3: cast zx s_4493_2 -> bv
        let s_4493_3: Bits = Bits::new(s_4493_2 as u128, 3u16);
        // D s_4493_4: cmp-eq s_4493_1 s_4493_3
        let s_4493_4: bool = ((s_4493_1) == (s_4493_3));
        // D s_4493_5: write-var gs#135467 <= s_4493_4
        fn_state.gs_135467 = s_4493_4;
        // N s_4493_6: jump b2222
        return block_2222(state, tracer, fn_state);
    }
    fn block_4494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4494_0: read-var opc1:u8
        let s_4494_0: u8 = fn_state.opc1;
        // D s_4494_1: cast zx s_4494_0 -> bv
        let s_4494_1: Bits = Bits::new(s_4494_0 as u128, 3u16);
        // C s_4494_2: const #0u : u8
        let s_4494_2: u8 = 0;
        // C s_4494_3: cast zx s_4494_2 -> bv
        let s_4494_3: Bits = Bits::new(s_4494_2 as u128, 3u16);
        // D s_4494_4: cmp-eq s_4494_1 s_4494_3
        let s_4494_4: bool = ((s_4494_1) == (s_4494_3));
        // D s_4494_5: write-var gs#135466 <= s_4494_4
        fn_state.gs_135466 = s_4494_4;
        // N s_4494_6: jump b2220
        return block_2220(state, tracer, fn_state);
    }
    fn block_4495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4495_0: read-var coproc:u8
        let s_4495_0: u8 = fn_state.coproc;
        // D s_4495_1: cast zx s_4495_0 -> bv
        let s_4495_1: Bits = Bits::new(s_4495_0 as u128, 4u16);
        // C s_4495_2: const #14u : u8
        let s_4495_2: u8 = 14;
        // C s_4495_3: cast zx s_4495_2 -> bv
        let s_4495_3: Bits = Bits::new(s_4495_2 as u128, 4u16);
        // D s_4495_4: cmp-eq s_4495_1 s_4495_3
        let s_4495_4: bool = ((s_4495_1) == (s_4495_3));
        // D s_4495_5: write-var gs#135465 <= s_4495_4
        fn_state.gs_135465 = s_4495_4;
        // N s_4495_6: jump b2218
        return block_2218(state, tracer, fn_state);
    }
    fn block_4496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4496_0: read-var CRn:u8
        let s_4496_0: u8 = fn_state.CRn;
        // D s_4496_1: cast zx s_4496_0 -> bv
        let s_4496_1: Bits = Bits::new(s_4496_0 as u128, 4u16);
        // C s_4496_2: const #0u : u8
        let s_4496_2: u8 = 0;
        // C s_4496_3: cast zx s_4496_2 -> bv
        let s_4496_3: Bits = Bits::new(s_4496_2 as u128, 4u16);
        // D s_4496_4: cmp-eq s_4496_1 s_4496_3
        let s_4496_4: bool = ((s_4496_1) == (s_4496_3));
        // D s_4496_5: write-var gs#135464 <= s_4496_4
        fn_state.gs_135464 = s_4496_4;
        // N s_4496_6: jump b2216
        return block_2216(state, tracer, fn_state);
    }
    fn block_4497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4497_0: read-var el:u8
        let s_4497_0: u8 = fn_state.el;
        // D s_4497_1: read-var coproc:u8
        let s_4497_1: u8 = fn_state.coproc;
        // D s_4497_2: read-var opc1:u8
        let s_4497_2: u8 = fn_state.opc1;
        // D s_4497_3: read-var CRn:u8
        let s_4497_3: u8 = fn_state.CRn;
        // D s_4497_4: read-var opc2:u8
        let s_4497_4: u8 = fn_state.opc2;
        // D s_4497_5: read-var CRm:u8
        let s_4497_5: u8 = fn_state.CRm;
        // D s_4497_6: read-var t:i
        let s_4497_6: i128 = fn_state.t;
        // D s_4497_7: call DBGBCR_SysRegWrite32_08e08cceb84c7c71(s_4497_0, s_4497_1, s_4497_2, s_4497_3, s_4497_4, s_4497_5, s_4497_6)
        let s_4497_7: () = DBGBCR_SysRegWrite32_08e08cceb84c7c71(
            state,
            tracer,
            s_4497_0,
            s_4497_1,
            s_4497_2,
            s_4497_3,
            s_4497_4,
            s_4497_5,
            s_4497_6,
        );
        // N s_4497_8: return
        return;
    }
    fn block_4498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4498_0: read-var opc2:u8
        let s_4498_0: u8 = fn_state.opc2;
        // D s_4498_1: cast zx s_4498_0 -> bv
        let s_4498_1: Bits = Bits::new(s_4498_0 as u128, 3u16);
        // C s_4498_2: const #5u : u8
        let s_4498_2: u8 = 5;
        // C s_4498_3: cast zx s_4498_2 -> bv
        let s_4498_3: Bits = Bits::new(s_4498_2 as u128, 3u16);
        // D s_4498_4: cmp-eq s_4498_1 s_4498_3
        let s_4498_4: bool = ((s_4498_1) == (s_4498_3));
        // D s_4498_5: write-var gs#135463 <= s_4498_4
        fn_state.gs_135463 = s_4498_4;
        // N s_4498_6: jump b2213
        return block_2213(state, tracer, fn_state);
    }
    fn block_4499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4499_0: read-var opc1:u8
        let s_4499_0: u8 = fn_state.opc1;
        // D s_4499_1: cast zx s_4499_0 -> bv
        let s_4499_1: Bits = Bits::new(s_4499_0 as u128, 3u16);
        // C s_4499_2: const #0u : u8
        let s_4499_2: u8 = 0;
        // C s_4499_3: cast zx s_4499_2 -> bv
        let s_4499_3: Bits = Bits::new(s_4499_2 as u128, 3u16);
        // D s_4499_4: cmp-eq s_4499_1 s_4499_3
        let s_4499_4: bool = ((s_4499_1) == (s_4499_3));
        // D s_4499_5: write-var gs#135462 <= s_4499_4
        fn_state.gs_135462 = s_4499_4;
        // N s_4499_6: jump b2211
        return block_2211(state, tracer, fn_state);
    }
    fn block_4500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4500_0: read-var coproc:u8
        let s_4500_0: u8 = fn_state.coproc;
        // D s_4500_1: cast zx s_4500_0 -> bv
        let s_4500_1: Bits = Bits::new(s_4500_0 as u128, 4u16);
        // C s_4500_2: const #14u : u8
        let s_4500_2: u8 = 14;
        // C s_4500_3: cast zx s_4500_2 -> bv
        let s_4500_3: Bits = Bits::new(s_4500_2 as u128, 4u16);
        // D s_4500_4: cmp-eq s_4500_1 s_4500_3
        let s_4500_4: bool = ((s_4500_1) == (s_4500_3));
        // D s_4500_5: write-var gs#135461 <= s_4500_4
        fn_state.gs_135461 = s_4500_4;
        // N s_4500_6: jump b2209
        return block_2209(state, tracer, fn_state);
    }
    fn block_4501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4501_0: read-var CRn:u8
        let s_4501_0: u8 = fn_state.CRn;
        // D s_4501_1: cast zx s_4501_0 -> bv
        let s_4501_1: Bits = Bits::new(s_4501_0 as u128, 4u16);
        // C s_4501_2: const #0u : u8
        let s_4501_2: u8 = 0;
        // C s_4501_3: cast zx s_4501_2 -> bv
        let s_4501_3: Bits = Bits::new(s_4501_2 as u128, 4u16);
        // D s_4501_4: cmp-eq s_4501_1 s_4501_3
        let s_4501_4: bool = ((s_4501_1) == (s_4501_3));
        // D s_4501_5: write-var gs#135460 <= s_4501_4
        fn_state.gs_135460 = s_4501_4;
        // N s_4501_6: jump b2207
        return block_2207(state, tracer, fn_state);
    }
    fn block_4502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4502_0: read-var el:u8
        let s_4502_0: u8 = fn_state.el;
        // D s_4502_1: read-var coproc:u8
        let s_4502_1: u8 = fn_state.coproc;
        // D s_4502_2: read-var opc1:u8
        let s_4502_2: u8 = fn_state.opc1;
        // D s_4502_3: read-var CRn:u8
        let s_4502_3: u8 = fn_state.CRn;
        // D s_4502_4: read-var opc2:u8
        let s_4502_4: u8 = fn_state.opc2;
        // D s_4502_5: read-var CRm:u8
        let s_4502_5: u8 = fn_state.CRm;
        // D s_4502_6: read-var t:i
        let s_4502_6: i128 = fn_state.t;
        // D s_4502_7: call DBGBCR_SysRegWrite32_e9d51eb4b51754d0(s_4502_0, s_4502_1, s_4502_2, s_4502_3, s_4502_4, s_4502_5, s_4502_6)
        let s_4502_7: () = DBGBCR_SysRegWrite32_e9d51eb4b51754d0(
            state,
            tracer,
            s_4502_0,
            s_4502_1,
            s_4502_2,
            s_4502_3,
            s_4502_4,
            s_4502_5,
            s_4502_6,
        );
        // N s_4502_8: return
        return;
    }
    fn block_4503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4503_0: read-var opc2:u8
        let s_4503_0: u8 = fn_state.opc2;
        // D s_4503_1: cast zx s_4503_0 -> bv
        let s_4503_1: Bits = Bits::new(s_4503_0 as u128, 3u16);
        // C s_4503_2: const #5u : u8
        let s_4503_2: u8 = 5;
        // C s_4503_3: cast zx s_4503_2 -> bv
        let s_4503_3: Bits = Bits::new(s_4503_2 as u128, 3u16);
        // D s_4503_4: cmp-eq s_4503_1 s_4503_3
        let s_4503_4: bool = ((s_4503_1) == (s_4503_3));
        // D s_4503_5: write-var gs#135459 <= s_4503_4
        fn_state.gs_135459 = s_4503_4;
        // N s_4503_6: jump b2204
        return block_2204(state, tracer, fn_state);
    }
    fn block_4504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4504_0: read-var opc1:u8
        let s_4504_0: u8 = fn_state.opc1;
        // D s_4504_1: cast zx s_4504_0 -> bv
        let s_4504_1: Bits = Bits::new(s_4504_0 as u128, 3u16);
        // C s_4504_2: const #0u : u8
        let s_4504_2: u8 = 0;
        // C s_4504_3: cast zx s_4504_2 -> bv
        let s_4504_3: Bits = Bits::new(s_4504_2 as u128, 3u16);
        // D s_4504_4: cmp-eq s_4504_1 s_4504_3
        let s_4504_4: bool = ((s_4504_1) == (s_4504_3));
        // D s_4504_5: write-var gs#135458 <= s_4504_4
        fn_state.gs_135458 = s_4504_4;
        // N s_4504_6: jump b2202
        return block_2202(state, tracer, fn_state);
    }
    fn block_4505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4505_0: read-var coproc:u8
        let s_4505_0: u8 = fn_state.coproc;
        // D s_4505_1: cast zx s_4505_0 -> bv
        let s_4505_1: Bits = Bits::new(s_4505_0 as u128, 4u16);
        // C s_4505_2: const #14u : u8
        let s_4505_2: u8 = 14;
        // C s_4505_3: cast zx s_4505_2 -> bv
        let s_4505_3: Bits = Bits::new(s_4505_2 as u128, 4u16);
        // D s_4505_4: cmp-eq s_4505_1 s_4505_3
        let s_4505_4: bool = ((s_4505_1) == (s_4505_3));
        // D s_4505_5: write-var gs#135457 <= s_4505_4
        fn_state.gs_135457 = s_4505_4;
        // N s_4505_6: jump b2200
        return block_2200(state, tracer, fn_state);
    }
    fn block_4506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4506_0: read-var CRn:u8
        let s_4506_0: u8 = fn_state.CRn;
        // D s_4506_1: cast zx s_4506_0 -> bv
        let s_4506_1: Bits = Bits::new(s_4506_0 as u128, 4u16);
        // C s_4506_2: const #0u : u8
        let s_4506_2: u8 = 0;
        // C s_4506_3: cast zx s_4506_2 -> bv
        let s_4506_3: Bits = Bits::new(s_4506_2 as u128, 4u16);
        // D s_4506_4: cmp-eq s_4506_1 s_4506_3
        let s_4506_4: bool = ((s_4506_1) == (s_4506_3));
        // D s_4506_5: write-var gs#135456 <= s_4506_4
        fn_state.gs_135456 = s_4506_4;
        // N s_4506_6: jump b2198
        return block_2198(state, tracer, fn_state);
    }
    fn block_4507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4507_0: read-var el:u8
        let s_4507_0: u8 = fn_state.el;
        // D s_4507_1: read-var coproc:u8
        let s_4507_1: u8 = fn_state.coproc;
        // D s_4507_2: read-var opc1:u8
        let s_4507_2: u8 = fn_state.opc1;
        // D s_4507_3: read-var CRn:u8
        let s_4507_3: u8 = fn_state.CRn;
        // D s_4507_4: read-var opc2:u8
        let s_4507_4: u8 = fn_state.opc2;
        // D s_4507_5: read-var CRm:u8
        let s_4507_5: u8 = fn_state.CRm;
        // D s_4507_6: read-var t:i
        let s_4507_6: i128 = fn_state.t;
        // D s_4507_7: call DBGBCR_SysRegWrite32_9fe4284f184fd88f(s_4507_0, s_4507_1, s_4507_2, s_4507_3, s_4507_4, s_4507_5, s_4507_6)
        let s_4507_7: () = DBGBCR_SysRegWrite32_9fe4284f184fd88f(
            state,
            tracer,
            s_4507_0,
            s_4507_1,
            s_4507_2,
            s_4507_3,
            s_4507_4,
            s_4507_5,
            s_4507_6,
        );
        // N s_4507_8: return
        return;
    }
    fn block_4508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4508_0: read-var opc2:u8
        let s_4508_0: u8 = fn_state.opc2;
        // D s_4508_1: cast zx s_4508_0 -> bv
        let s_4508_1: Bits = Bits::new(s_4508_0 as u128, 3u16);
        // C s_4508_2: const #5u : u8
        let s_4508_2: u8 = 5;
        // C s_4508_3: cast zx s_4508_2 -> bv
        let s_4508_3: Bits = Bits::new(s_4508_2 as u128, 3u16);
        // D s_4508_4: cmp-eq s_4508_1 s_4508_3
        let s_4508_4: bool = ((s_4508_1) == (s_4508_3));
        // D s_4508_5: write-var gs#135455 <= s_4508_4
        fn_state.gs_135455 = s_4508_4;
        // N s_4508_6: jump b2195
        return block_2195(state, tracer, fn_state);
    }
    fn block_4509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4509_0: read-var opc1:u8
        let s_4509_0: u8 = fn_state.opc1;
        // D s_4509_1: cast zx s_4509_0 -> bv
        let s_4509_1: Bits = Bits::new(s_4509_0 as u128, 3u16);
        // C s_4509_2: const #0u : u8
        let s_4509_2: u8 = 0;
        // C s_4509_3: cast zx s_4509_2 -> bv
        let s_4509_3: Bits = Bits::new(s_4509_2 as u128, 3u16);
        // D s_4509_4: cmp-eq s_4509_1 s_4509_3
        let s_4509_4: bool = ((s_4509_1) == (s_4509_3));
        // D s_4509_5: write-var gs#135454 <= s_4509_4
        fn_state.gs_135454 = s_4509_4;
        // N s_4509_6: jump b2193
        return block_2193(state, tracer, fn_state);
    }
    fn block_4510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4510_0: read-var coproc:u8
        let s_4510_0: u8 = fn_state.coproc;
        // D s_4510_1: cast zx s_4510_0 -> bv
        let s_4510_1: Bits = Bits::new(s_4510_0 as u128, 4u16);
        // C s_4510_2: const #14u : u8
        let s_4510_2: u8 = 14;
        // C s_4510_3: cast zx s_4510_2 -> bv
        let s_4510_3: Bits = Bits::new(s_4510_2 as u128, 4u16);
        // D s_4510_4: cmp-eq s_4510_1 s_4510_3
        let s_4510_4: bool = ((s_4510_1) == (s_4510_3));
        // D s_4510_5: write-var gs#135453 <= s_4510_4
        fn_state.gs_135453 = s_4510_4;
        // N s_4510_6: jump b2191
        return block_2191(state, tracer, fn_state);
    }
    fn block_4511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4511_0: read-var CRn:u8
        let s_4511_0: u8 = fn_state.CRn;
        // D s_4511_1: cast zx s_4511_0 -> bv
        let s_4511_1: Bits = Bits::new(s_4511_0 as u128, 4u16);
        // C s_4511_2: const #0u : u8
        let s_4511_2: u8 = 0;
        // C s_4511_3: cast zx s_4511_2 -> bv
        let s_4511_3: Bits = Bits::new(s_4511_2 as u128, 4u16);
        // D s_4511_4: cmp-eq s_4511_1 s_4511_3
        let s_4511_4: bool = ((s_4511_1) == (s_4511_3));
        // D s_4511_5: write-var gs#135452 <= s_4511_4
        fn_state.gs_135452 = s_4511_4;
        // N s_4511_6: jump b2189
        return block_2189(state, tracer, fn_state);
    }
    fn block_4512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4512_0: read-var el:u8
        let s_4512_0: u8 = fn_state.el;
        // D s_4512_1: read-var coproc:u8
        let s_4512_1: u8 = fn_state.coproc;
        // D s_4512_2: read-var opc1:u8
        let s_4512_2: u8 = fn_state.opc1;
        // D s_4512_3: read-var CRn:u8
        let s_4512_3: u8 = fn_state.CRn;
        // D s_4512_4: read-var opc2:u8
        let s_4512_4: u8 = fn_state.opc2;
        // D s_4512_5: read-var CRm:u8
        let s_4512_5: u8 = fn_state.CRm;
        // D s_4512_6: read-var t:i
        let s_4512_6: i128 = fn_state.t;
        // D s_4512_7: call DBGBCR_SysRegWrite32_2d689254949b32aa(s_4512_0, s_4512_1, s_4512_2, s_4512_3, s_4512_4, s_4512_5, s_4512_6)
        let s_4512_7: () = DBGBCR_SysRegWrite32_2d689254949b32aa(
            state,
            tracer,
            s_4512_0,
            s_4512_1,
            s_4512_2,
            s_4512_3,
            s_4512_4,
            s_4512_5,
            s_4512_6,
        );
        // N s_4512_8: return
        return;
    }
    fn block_4513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4513_0: read-var opc2:u8
        let s_4513_0: u8 = fn_state.opc2;
        // D s_4513_1: cast zx s_4513_0 -> bv
        let s_4513_1: Bits = Bits::new(s_4513_0 as u128, 3u16);
        // C s_4513_2: const #5u : u8
        let s_4513_2: u8 = 5;
        // C s_4513_3: cast zx s_4513_2 -> bv
        let s_4513_3: Bits = Bits::new(s_4513_2 as u128, 3u16);
        // D s_4513_4: cmp-eq s_4513_1 s_4513_3
        let s_4513_4: bool = ((s_4513_1) == (s_4513_3));
        // D s_4513_5: write-var gs#135451 <= s_4513_4
        fn_state.gs_135451 = s_4513_4;
        // N s_4513_6: jump b2186
        return block_2186(state, tracer, fn_state);
    }
    fn block_4514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4514_0: read-var opc1:u8
        let s_4514_0: u8 = fn_state.opc1;
        // D s_4514_1: cast zx s_4514_0 -> bv
        let s_4514_1: Bits = Bits::new(s_4514_0 as u128, 3u16);
        // C s_4514_2: const #0u : u8
        let s_4514_2: u8 = 0;
        // C s_4514_3: cast zx s_4514_2 -> bv
        let s_4514_3: Bits = Bits::new(s_4514_2 as u128, 3u16);
        // D s_4514_4: cmp-eq s_4514_1 s_4514_3
        let s_4514_4: bool = ((s_4514_1) == (s_4514_3));
        // D s_4514_5: write-var gs#135450 <= s_4514_4
        fn_state.gs_135450 = s_4514_4;
        // N s_4514_6: jump b2184
        return block_2184(state, tracer, fn_state);
    }
    fn block_4515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4515_0: read-var coproc:u8
        let s_4515_0: u8 = fn_state.coproc;
        // D s_4515_1: cast zx s_4515_0 -> bv
        let s_4515_1: Bits = Bits::new(s_4515_0 as u128, 4u16);
        // C s_4515_2: const #14u : u8
        let s_4515_2: u8 = 14;
        // C s_4515_3: cast zx s_4515_2 -> bv
        let s_4515_3: Bits = Bits::new(s_4515_2 as u128, 4u16);
        // D s_4515_4: cmp-eq s_4515_1 s_4515_3
        let s_4515_4: bool = ((s_4515_1) == (s_4515_3));
        // D s_4515_5: write-var gs#135449 <= s_4515_4
        fn_state.gs_135449 = s_4515_4;
        // N s_4515_6: jump b2182
        return block_2182(state, tracer, fn_state);
    }
    fn block_4516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4516_0: read-var CRn:u8
        let s_4516_0: u8 = fn_state.CRn;
        // D s_4516_1: cast zx s_4516_0 -> bv
        let s_4516_1: Bits = Bits::new(s_4516_0 as u128, 4u16);
        // C s_4516_2: const #0u : u8
        let s_4516_2: u8 = 0;
        // C s_4516_3: cast zx s_4516_2 -> bv
        let s_4516_3: Bits = Bits::new(s_4516_2 as u128, 4u16);
        // D s_4516_4: cmp-eq s_4516_1 s_4516_3
        let s_4516_4: bool = ((s_4516_1) == (s_4516_3));
        // D s_4516_5: write-var gs#135448 <= s_4516_4
        fn_state.gs_135448 = s_4516_4;
        // N s_4516_6: jump b2180
        return block_2180(state, tracer, fn_state);
    }
    fn block_4517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4517_0: read-var el:u8
        let s_4517_0: u8 = fn_state.el;
        // D s_4517_1: read-var coproc:u8
        let s_4517_1: u8 = fn_state.coproc;
        // D s_4517_2: read-var opc1:u8
        let s_4517_2: u8 = fn_state.opc1;
        // D s_4517_3: read-var CRn:u8
        let s_4517_3: u8 = fn_state.CRn;
        // D s_4517_4: read-var opc2:u8
        let s_4517_4: u8 = fn_state.opc2;
        // D s_4517_5: read-var CRm:u8
        let s_4517_5: u8 = fn_state.CRm;
        // D s_4517_6: read-var t:i
        let s_4517_6: i128 = fn_state.t;
        // D s_4517_7: call DBGBCR_SysRegWrite32_e67a829e0c397974(s_4517_0, s_4517_1, s_4517_2, s_4517_3, s_4517_4, s_4517_5, s_4517_6)
        let s_4517_7: () = DBGBCR_SysRegWrite32_e67a829e0c397974(
            state,
            tracer,
            s_4517_0,
            s_4517_1,
            s_4517_2,
            s_4517_3,
            s_4517_4,
            s_4517_5,
            s_4517_6,
        );
        // N s_4517_8: return
        return;
    }
    fn block_4518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4518_0: read-var opc2:u8
        let s_4518_0: u8 = fn_state.opc2;
        // D s_4518_1: cast zx s_4518_0 -> bv
        let s_4518_1: Bits = Bits::new(s_4518_0 as u128, 3u16);
        // C s_4518_2: const #5u : u8
        let s_4518_2: u8 = 5;
        // C s_4518_3: cast zx s_4518_2 -> bv
        let s_4518_3: Bits = Bits::new(s_4518_2 as u128, 3u16);
        // D s_4518_4: cmp-eq s_4518_1 s_4518_3
        let s_4518_4: bool = ((s_4518_1) == (s_4518_3));
        // D s_4518_5: write-var gs#135447 <= s_4518_4
        fn_state.gs_135447 = s_4518_4;
        // N s_4518_6: jump b2177
        return block_2177(state, tracer, fn_state);
    }
    fn block_4519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4519_0: read-var opc1:u8
        let s_4519_0: u8 = fn_state.opc1;
        // D s_4519_1: cast zx s_4519_0 -> bv
        let s_4519_1: Bits = Bits::new(s_4519_0 as u128, 3u16);
        // C s_4519_2: const #0u : u8
        let s_4519_2: u8 = 0;
        // C s_4519_3: cast zx s_4519_2 -> bv
        let s_4519_3: Bits = Bits::new(s_4519_2 as u128, 3u16);
        // D s_4519_4: cmp-eq s_4519_1 s_4519_3
        let s_4519_4: bool = ((s_4519_1) == (s_4519_3));
        // D s_4519_5: write-var gs#135446 <= s_4519_4
        fn_state.gs_135446 = s_4519_4;
        // N s_4519_6: jump b2175
        return block_2175(state, tracer, fn_state);
    }
    fn block_4520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4520_0: read-var coproc:u8
        let s_4520_0: u8 = fn_state.coproc;
        // D s_4520_1: cast zx s_4520_0 -> bv
        let s_4520_1: Bits = Bits::new(s_4520_0 as u128, 4u16);
        // C s_4520_2: const #14u : u8
        let s_4520_2: u8 = 14;
        // C s_4520_3: cast zx s_4520_2 -> bv
        let s_4520_3: Bits = Bits::new(s_4520_2 as u128, 4u16);
        // D s_4520_4: cmp-eq s_4520_1 s_4520_3
        let s_4520_4: bool = ((s_4520_1) == (s_4520_3));
        // D s_4520_5: write-var gs#135445 <= s_4520_4
        fn_state.gs_135445 = s_4520_4;
        // N s_4520_6: jump b2173
        return block_2173(state, tracer, fn_state);
    }
    fn block_4521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4521_0: read-var CRn:u8
        let s_4521_0: u8 = fn_state.CRn;
        // D s_4521_1: cast zx s_4521_0 -> bv
        let s_4521_1: Bits = Bits::new(s_4521_0 as u128, 4u16);
        // C s_4521_2: const #0u : u8
        let s_4521_2: u8 = 0;
        // C s_4521_3: cast zx s_4521_2 -> bv
        let s_4521_3: Bits = Bits::new(s_4521_2 as u128, 4u16);
        // D s_4521_4: cmp-eq s_4521_1 s_4521_3
        let s_4521_4: bool = ((s_4521_1) == (s_4521_3));
        // D s_4521_5: write-var gs#135444 <= s_4521_4
        fn_state.gs_135444 = s_4521_4;
        // N s_4521_6: jump b2171
        return block_2171(state, tracer, fn_state);
    }
    fn block_4522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4522_0: read-var el:u8
        let s_4522_0: u8 = fn_state.el;
        // D s_4522_1: read-var coproc:u8
        let s_4522_1: u8 = fn_state.coproc;
        // D s_4522_2: read-var opc1:u8
        let s_4522_2: u8 = fn_state.opc1;
        // D s_4522_3: read-var CRn:u8
        let s_4522_3: u8 = fn_state.CRn;
        // D s_4522_4: read-var opc2:u8
        let s_4522_4: u8 = fn_state.opc2;
        // D s_4522_5: read-var CRm:u8
        let s_4522_5: u8 = fn_state.CRm;
        // D s_4522_6: read-var t:i
        let s_4522_6: i128 = fn_state.t;
        // D s_4522_7: call DBGBCR_SysRegWrite32_df57cf6a3ef389f5(s_4522_0, s_4522_1, s_4522_2, s_4522_3, s_4522_4, s_4522_5, s_4522_6)
        let s_4522_7: () = DBGBCR_SysRegWrite32_df57cf6a3ef389f5(
            state,
            tracer,
            s_4522_0,
            s_4522_1,
            s_4522_2,
            s_4522_3,
            s_4522_4,
            s_4522_5,
            s_4522_6,
        );
        // N s_4522_8: return
        return;
    }
    fn block_4523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4523_0: read-var opc2:u8
        let s_4523_0: u8 = fn_state.opc2;
        // D s_4523_1: cast zx s_4523_0 -> bv
        let s_4523_1: Bits = Bits::new(s_4523_0 as u128, 3u16);
        // C s_4523_2: const #5u : u8
        let s_4523_2: u8 = 5;
        // C s_4523_3: cast zx s_4523_2 -> bv
        let s_4523_3: Bits = Bits::new(s_4523_2 as u128, 3u16);
        // D s_4523_4: cmp-eq s_4523_1 s_4523_3
        let s_4523_4: bool = ((s_4523_1) == (s_4523_3));
        // D s_4523_5: write-var gs#135443 <= s_4523_4
        fn_state.gs_135443 = s_4523_4;
        // N s_4523_6: jump b2168
        return block_2168(state, tracer, fn_state);
    }
    fn block_4524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4524_0: read-var opc1:u8
        let s_4524_0: u8 = fn_state.opc1;
        // D s_4524_1: cast zx s_4524_0 -> bv
        let s_4524_1: Bits = Bits::new(s_4524_0 as u128, 3u16);
        // C s_4524_2: const #0u : u8
        let s_4524_2: u8 = 0;
        // C s_4524_3: cast zx s_4524_2 -> bv
        let s_4524_3: Bits = Bits::new(s_4524_2 as u128, 3u16);
        // D s_4524_4: cmp-eq s_4524_1 s_4524_3
        let s_4524_4: bool = ((s_4524_1) == (s_4524_3));
        // D s_4524_5: write-var gs#135442 <= s_4524_4
        fn_state.gs_135442 = s_4524_4;
        // N s_4524_6: jump b2166
        return block_2166(state, tracer, fn_state);
    }
    fn block_4525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4525_0: read-var coproc:u8
        let s_4525_0: u8 = fn_state.coproc;
        // D s_4525_1: cast zx s_4525_0 -> bv
        let s_4525_1: Bits = Bits::new(s_4525_0 as u128, 4u16);
        // C s_4525_2: const #14u : u8
        let s_4525_2: u8 = 14;
        // C s_4525_3: cast zx s_4525_2 -> bv
        let s_4525_3: Bits = Bits::new(s_4525_2 as u128, 4u16);
        // D s_4525_4: cmp-eq s_4525_1 s_4525_3
        let s_4525_4: bool = ((s_4525_1) == (s_4525_3));
        // D s_4525_5: write-var gs#135441 <= s_4525_4
        fn_state.gs_135441 = s_4525_4;
        // N s_4525_6: jump b2164
        return block_2164(state, tracer, fn_state);
    }
    fn block_4526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4526_0: read-var CRn:u8
        let s_4526_0: u8 = fn_state.CRn;
        // D s_4526_1: cast zx s_4526_0 -> bv
        let s_4526_1: Bits = Bits::new(s_4526_0 as u128, 4u16);
        // C s_4526_2: const #0u : u8
        let s_4526_2: u8 = 0;
        // C s_4526_3: cast zx s_4526_2 -> bv
        let s_4526_3: Bits = Bits::new(s_4526_2 as u128, 4u16);
        // D s_4526_4: cmp-eq s_4526_1 s_4526_3
        let s_4526_4: bool = ((s_4526_1) == (s_4526_3));
        // D s_4526_5: write-var gs#135440 <= s_4526_4
        fn_state.gs_135440 = s_4526_4;
        // N s_4526_6: jump b2162
        return block_2162(state, tracer, fn_state);
    }
    fn block_4527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4527_0: read-var el:u8
        let s_4527_0: u8 = fn_state.el;
        // D s_4527_1: read-var coproc:u8
        let s_4527_1: u8 = fn_state.coproc;
        // D s_4527_2: read-var opc1:u8
        let s_4527_2: u8 = fn_state.opc1;
        // D s_4527_3: read-var CRn:u8
        let s_4527_3: u8 = fn_state.CRn;
        // D s_4527_4: read-var opc2:u8
        let s_4527_4: u8 = fn_state.opc2;
        // D s_4527_5: read-var CRm:u8
        let s_4527_5: u8 = fn_state.CRm;
        // D s_4527_6: read-var t:i
        let s_4527_6: i128 = fn_state.t;
        // D s_4527_7: call DBGBCR_SysRegWrite32_c3126c422a78b6f5(s_4527_0, s_4527_1, s_4527_2, s_4527_3, s_4527_4, s_4527_5, s_4527_6)
        let s_4527_7: () = DBGBCR_SysRegWrite32_c3126c422a78b6f5(
            state,
            tracer,
            s_4527_0,
            s_4527_1,
            s_4527_2,
            s_4527_3,
            s_4527_4,
            s_4527_5,
            s_4527_6,
        );
        // N s_4527_8: return
        return;
    }
    fn block_4528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4528_0: read-var opc2:u8
        let s_4528_0: u8 = fn_state.opc2;
        // D s_4528_1: cast zx s_4528_0 -> bv
        let s_4528_1: Bits = Bits::new(s_4528_0 as u128, 3u16);
        // C s_4528_2: const #5u : u8
        let s_4528_2: u8 = 5;
        // C s_4528_3: cast zx s_4528_2 -> bv
        let s_4528_3: Bits = Bits::new(s_4528_2 as u128, 3u16);
        // D s_4528_4: cmp-eq s_4528_1 s_4528_3
        let s_4528_4: bool = ((s_4528_1) == (s_4528_3));
        // D s_4528_5: write-var gs#135439 <= s_4528_4
        fn_state.gs_135439 = s_4528_4;
        // N s_4528_6: jump b2159
        return block_2159(state, tracer, fn_state);
    }
    fn block_4529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4529_0: read-var opc1:u8
        let s_4529_0: u8 = fn_state.opc1;
        // D s_4529_1: cast zx s_4529_0 -> bv
        let s_4529_1: Bits = Bits::new(s_4529_0 as u128, 3u16);
        // C s_4529_2: const #0u : u8
        let s_4529_2: u8 = 0;
        // C s_4529_3: cast zx s_4529_2 -> bv
        let s_4529_3: Bits = Bits::new(s_4529_2 as u128, 3u16);
        // D s_4529_4: cmp-eq s_4529_1 s_4529_3
        let s_4529_4: bool = ((s_4529_1) == (s_4529_3));
        // D s_4529_5: write-var gs#135438 <= s_4529_4
        fn_state.gs_135438 = s_4529_4;
        // N s_4529_6: jump b2157
        return block_2157(state, tracer, fn_state);
    }
    fn block_4530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4530_0: read-var coproc:u8
        let s_4530_0: u8 = fn_state.coproc;
        // D s_4530_1: cast zx s_4530_0 -> bv
        let s_4530_1: Bits = Bits::new(s_4530_0 as u128, 4u16);
        // C s_4530_2: const #14u : u8
        let s_4530_2: u8 = 14;
        // C s_4530_3: cast zx s_4530_2 -> bv
        let s_4530_3: Bits = Bits::new(s_4530_2 as u128, 4u16);
        // D s_4530_4: cmp-eq s_4530_1 s_4530_3
        let s_4530_4: bool = ((s_4530_1) == (s_4530_3));
        // D s_4530_5: write-var gs#135437 <= s_4530_4
        fn_state.gs_135437 = s_4530_4;
        // N s_4530_6: jump b2155
        return block_2155(state, tracer, fn_state);
    }
    fn block_4531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4531_0: read-var CRn:u8
        let s_4531_0: u8 = fn_state.CRn;
        // D s_4531_1: cast zx s_4531_0 -> bv
        let s_4531_1: Bits = Bits::new(s_4531_0 as u128, 4u16);
        // C s_4531_2: const #0u : u8
        let s_4531_2: u8 = 0;
        // C s_4531_3: cast zx s_4531_2 -> bv
        let s_4531_3: Bits = Bits::new(s_4531_2 as u128, 4u16);
        // D s_4531_4: cmp-eq s_4531_1 s_4531_3
        let s_4531_4: bool = ((s_4531_1) == (s_4531_3));
        // D s_4531_5: write-var gs#135436 <= s_4531_4
        fn_state.gs_135436 = s_4531_4;
        // N s_4531_6: jump b2153
        return block_2153(state, tracer, fn_state);
    }
    fn block_4532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4532_0: read-var el:u8
        let s_4532_0: u8 = fn_state.el;
        // D s_4532_1: read-var coproc:u8
        let s_4532_1: u8 = fn_state.coproc;
        // D s_4532_2: read-var opc1:u8
        let s_4532_2: u8 = fn_state.opc1;
        // D s_4532_3: read-var CRn:u8
        let s_4532_3: u8 = fn_state.CRn;
        // D s_4532_4: read-var opc2:u8
        let s_4532_4: u8 = fn_state.opc2;
        // D s_4532_5: read-var CRm:u8
        let s_4532_5: u8 = fn_state.CRm;
        // D s_4532_6: read-var t:i
        let s_4532_6: i128 = fn_state.t;
        // D s_4532_7: call DBGBCR_SysRegWrite32_28709afae2cd2b96(s_4532_0, s_4532_1, s_4532_2, s_4532_3, s_4532_4, s_4532_5, s_4532_6)
        let s_4532_7: () = DBGBCR_SysRegWrite32_28709afae2cd2b96(
            state,
            tracer,
            s_4532_0,
            s_4532_1,
            s_4532_2,
            s_4532_3,
            s_4532_4,
            s_4532_5,
            s_4532_6,
        );
        // N s_4532_8: return
        return;
    }
    fn block_4533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4533_0: read-var opc2:u8
        let s_4533_0: u8 = fn_state.opc2;
        // D s_4533_1: cast zx s_4533_0 -> bv
        let s_4533_1: Bits = Bits::new(s_4533_0 as u128, 3u16);
        // C s_4533_2: const #5u : u8
        let s_4533_2: u8 = 5;
        // C s_4533_3: cast zx s_4533_2 -> bv
        let s_4533_3: Bits = Bits::new(s_4533_2 as u128, 3u16);
        // D s_4533_4: cmp-eq s_4533_1 s_4533_3
        let s_4533_4: bool = ((s_4533_1) == (s_4533_3));
        // D s_4533_5: write-var gs#135435 <= s_4533_4
        fn_state.gs_135435 = s_4533_4;
        // N s_4533_6: jump b2150
        return block_2150(state, tracer, fn_state);
    }
    fn block_4534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4534_0: read-var opc1:u8
        let s_4534_0: u8 = fn_state.opc1;
        // D s_4534_1: cast zx s_4534_0 -> bv
        let s_4534_1: Bits = Bits::new(s_4534_0 as u128, 3u16);
        // C s_4534_2: const #0u : u8
        let s_4534_2: u8 = 0;
        // C s_4534_3: cast zx s_4534_2 -> bv
        let s_4534_3: Bits = Bits::new(s_4534_2 as u128, 3u16);
        // D s_4534_4: cmp-eq s_4534_1 s_4534_3
        let s_4534_4: bool = ((s_4534_1) == (s_4534_3));
        // D s_4534_5: write-var gs#135434 <= s_4534_4
        fn_state.gs_135434 = s_4534_4;
        // N s_4534_6: jump b2148
        return block_2148(state, tracer, fn_state);
    }
    fn block_4535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4535_0: read-var coproc:u8
        let s_4535_0: u8 = fn_state.coproc;
        // D s_4535_1: cast zx s_4535_0 -> bv
        let s_4535_1: Bits = Bits::new(s_4535_0 as u128, 4u16);
        // C s_4535_2: const #14u : u8
        let s_4535_2: u8 = 14;
        // C s_4535_3: cast zx s_4535_2 -> bv
        let s_4535_3: Bits = Bits::new(s_4535_2 as u128, 4u16);
        // D s_4535_4: cmp-eq s_4535_1 s_4535_3
        let s_4535_4: bool = ((s_4535_1) == (s_4535_3));
        // D s_4535_5: write-var gs#135433 <= s_4535_4
        fn_state.gs_135433 = s_4535_4;
        // N s_4535_6: jump b2146
        return block_2146(state, tracer, fn_state);
    }
    fn block_4536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4536_0: read-var CRn:u8
        let s_4536_0: u8 = fn_state.CRn;
        // D s_4536_1: cast zx s_4536_0 -> bv
        let s_4536_1: Bits = Bits::new(s_4536_0 as u128, 4u16);
        // C s_4536_2: const #0u : u8
        let s_4536_2: u8 = 0;
        // C s_4536_3: cast zx s_4536_2 -> bv
        let s_4536_3: Bits = Bits::new(s_4536_2 as u128, 4u16);
        // D s_4536_4: cmp-eq s_4536_1 s_4536_3
        let s_4536_4: bool = ((s_4536_1) == (s_4536_3));
        // D s_4536_5: write-var gs#135432 <= s_4536_4
        fn_state.gs_135432 = s_4536_4;
        // N s_4536_6: jump b2144
        return block_2144(state, tracer, fn_state);
    }
    fn block_4537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4537_0: read-var el:u8
        let s_4537_0: u8 = fn_state.el;
        // D s_4537_1: read-var coproc:u8
        let s_4537_1: u8 = fn_state.coproc;
        // D s_4537_2: read-var opc1:u8
        let s_4537_2: u8 = fn_state.opc1;
        // D s_4537_3: read-var CRn:u8
        let s_4537_3: u8 = fn_state.CRn;
        // D s_4537_4: read-var opc2:u8
        let s_4537_4: u8 = fn_state.opc2;
        // D s_4537_5: read-var CRm:u8
        let s_4537_5: u8 = fn_state.CRm;
        // D s_4537_6: read-var t:i
        let s_4537_6: i128 = fn_state.t;
        // D s_4537_7: call PMOVSSET_SysRegWrite32_d042c47fdd8f3705(s_4537_0, s_4537_1, s_4537_2, s_4537_3, s_4537_4, s_4537_5, s_4537_6)
        let s_4537_7: () = PMOVSSET_SysRegWrite32_d042c47fdd8f3705(
            state,
            tracer,
            s_4537_0,
            s_4537_1,
            s_4537_2,
            s_4537_3,
            s_4537_4,
            s_4537_5,
            s_4537_6,
        );
        // N s_4537_8: return
        return;
    }
    fn block_4538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4538_0: read-var opc2:u8
        let s_4538_0: u8 = fn_state.opc2;
        // D s_4538_1: cast zx s_4538_0 -> bv
        let s_4538_1: Bits = Bits::new(s_4538_0 as u128, 3u16);
        // C s_4538_2: const #3u : u8
        let s_4538_2: u8 = 3;
        // C s_4538_3: cast zx s_4538_2 -> bv
        let s_4538_3: Bits = Bits::new(s_4538_2 as u128, 3u16);
        // D s_4538_4: cmp-eq s_4538_1 s_4538_3
        let s_4538_4: bool = ((s_4538_1) == (s_4538_3));
        // D s_4538_5: write-var gs#135431 <= s_4538_4
        fn_state.gs_135431 = s_4538_4;
        // N s_4538_6: jump b2141
        return block_2141(state, tracer, fn_state);
    }
    fn block_4539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4539_0: read-var opc1:u8
        let s_4539_0: u8 = fn_state.opc1;
        // D s_4539_1: cast zx s_4539_0 -> bv
        let s_4539_1: Bits = Bits::new(s_4539_0 as u128, 3u16);
        // C s_4539_2: const #0u : u8
        let s_4539_2: u8 = 0;
        // C s_4539_3: cast zx s_4539_2 -> bv
        let s_4539_3: Bits = Bits::new(s_4539_2 as u128, 3u16);
        // D s_4539_4: cmp-eq s_4539_1 s_4539_3
        let s_4539_4: bool = ((s_4539_1) == (s_4539_3));
        // D s_4539_5: write-var gs#135430 <= s_4539_4
        fn_state.gs_135430 = s_4539_4;
        // N s_4539_6: jump b2139
        return block_2139(state, tracer, fn_state);
    }
    fn block_4540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4540_0: read-var coproc:u8
        let s_4540_0: u8 = fn_state.coproc;
        // D s_4540_1: cast zx s_4540_0 -> bv
        let s_4540_1: Bits = Bits::new(s_4540_0 as u128, 4u16);
        // C s_4540_2: const #15u : u8
        let s_4540_2: u8 = 15;
        // C s_4540_3: cast zx s_4540_2 -> bv
        let s_4540_3: Bits = Bits::new(s_4540_2 as u128, 4u16);
        // D s_4540_4: cmp-eq s_4540_1 s_4540_3
        let s_4540_4: bool = ((s_4540_1) == (s_4540_3));
        // D s_4540_5: write-var gs#135429 <= s_4540_4
        fn_state.gs_135429 = s_4540_4;
        // N s_4540_6: jump b2137
        return block_2137(state, tracer, fn_state);
    }
    fn block_4541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4541_0: read-var CRn:u8
        let s_4541_0: u8 = fn_state.CRn;
        // D s_4541_1: cast zx s_4541_0 -> bv
        let s_4541_1: Bits = Bits::new(s_4541_0 as u128, 4u16);
        // C s_4541_2: const #9u : u8
        let s_4541_2: u8 = 9;
        // C s_4541_3: cast zx s_4541_2 -> bv
        let s_4541_3: Bits = Bits::new(s_4541_2 as u128, 4u16);
        // D s_4541_4: cmp-eq s_4541_1 s_4541_3
        let s_4541_4: bool = ((s_4541_1) == (s_4541_3));
        // D s_4541_5: write-var gs#135428 <= s_4541_4
        fn_state.gs_135428 = s_4541_4;
        // N s_4541_6: jump b2135
        return block_2135(state, tracer, fn_state);
    }
    fn block_4542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4542_0: read-var el:u8
        let s_4542_0: u8 = fn_state.el;
        // D s_4542_1: read-var coproc:u8
        let s_4542_1: u8 = fn_state.coproc;
        // D s_4542_2: read-var opc1:u8
        let s_4542_2: u8 = fn_state.opc1;
        // D s_4542_3: read-var CRn:u8
        let s_4542_3: u8 = fn_state.CRn;
        // D s_4542_4: read-var opc2:u8
        let s_4542_4: u8 = fn_state.opc2;
        // D s_4542_5: read-var CRm:u8
        let s_4542_5: u8 = fn_state.CRm;
        // D s_4542_6: read-var t:i
        let s_4542_6: i128 = fn_state.t;
        // D s_4542_7: call ATS1HW_SysRegWrite32_6bb51bbf34dda57b(s_4542_0, s_4542_1, s_4542_2, s_4542_3, s_4542_4, s_4542_5, s_4542_6)
        let s_4542_7: () = ATS1HW_SysRegWrite32_6bb51bbf34dda57b(
            state,
            tracer,
            s_4542_0,
            s_4542_1,
            s_4542_2,
            s_4542_3,
            s_4542_4,
            s_4542_5,
            s_4542_6,
        );
        // N s_4542_8: return
        return;
    }
    fn block_4543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4543_0: read-var opc2:u8
        let s_4543_0: u8 = fn_state.opc2;
        // D s_4543_1: cast zx s_4543_0 -> bv
        let s_4543_1: Bits = Bits::new(s_4543_0 as u128, 3u16);
        // C s_4543_2: const #1u : u8
        let s_4543_2: u8 = 1;
        // C s_4543_3: cast zx s_4543_2 -> bv
        let s_4543_3: Bits = Bits::new(s_4543_2 as u128, 3u16);
        // D s_4543_4: cmp-eq s_4543_1 s_4543_3
        let s_4543_4: bool = ((s_4543_1) == (s_4543_3));
        // D s_4543_5: write-var gs#135427 <= s_4543_4
        fn_state.gs_135427 = s_4543_4;
        // N s_4543_6: jump b2132
        return block_2132(state, tracer, fn_state);
    }
    fn block_4544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4544_0: read-var opc1:u8
        let s_4544_0: u8 = fn_state.opc1;
        // D s_4544_1: cast zx s_4544_0 -> bv
        let s_4544_1: Bits = Bits::new(s_4544_0 as u128, 3u16);
        // C s_4544_2: const #4u : u8
        let s_4544_2: u8 = 4;
        // C s_4544_3: cast zx s_4544_2 -> bv
        let s_4544_3: Bits = Bits::new(s_4544_2 as u128, 3u16);
        // D s_4544_4: cmp-eq s_4544_1 s_4544_3
        let s_4544_4: bool = ((s_4544_1) == (s_4544_3));
        // D s_4544_5: write-var gs#135426 <= s_4544_4
        fn_state.gs_135426 = s_4544_4;
        // N s_4544_6: jump b2130
        return block_2130(state, tracer, fn_state);
    }
    fn block_4545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4545_0: read-var coproc:u8
        let s_4545_0: u8 = fn_state.coproc;
        // D s_4545_1: cast zx s_4545_0 -> bv
        let s_4545_1: Bits = Bits::new(s_4545_0 as u128, 4u16);
        // C s_4545_2: const #15u : u8
        let s_4545_2: u8 = 15;
        // C s_4545_3: cast zx s_4545_2 -> bv
        let s_4545_3: Bits = Bits::new(s_4545_2 as u128, 4u16);
        // D s_4545_4: cmp-eq s_4545_1 s_4545_3
        let s_4545_4: bool = ((s_4545_1) == (s_4545_3));
        // D s_4545_5: write-var gs#135425 <= s_4545_4
        fn_state.gs_135425 = s_4545_4;
        // N s_4545_6: jump b2128
        return block_2128(state, tracer, fn_state);
    }
    fn block_4546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4546_0: read-var CRn:u8
        let s_4546_0: u8 = fn_state.CRn;
        // D s_4546_1: cast zx s_4546_0 -> bv
        let s_4546_1: Bits = Bits::new(s_4546_0 as u128, 4u16);
        // C s_4546_2: const #7u : u8
        let s_4546_2: u8 = 7;
        // C s_4546_3: cast zx s_4546_2 -> bv
        let s_4546_3: Bits = Bits::new(s_4546_2 as u128, 4u16);
        // D s_4546_4: cmp-eq s_4546_1 s_4546_3
        let s_4546_4: bool = ((s_4546_1) == (s_4546_3));
        // D s_4546_5: write-var gs#135424 <= s_4546_4
        fn_state.gs_135424 = s_4546_4;
        // N s_4546_6: jump b2126
        return block_2126(state, tracer, fn_state);
    }
    fn block_4547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4547_0: read-var el:u8
        let s_4547_0: u8 = fn_state.el;
        // D s_4547_1: read-var coproc:u8
        let s_4547_1: u8 = fn_state.coproc;
        // D s_4547_2: read-var opc1:u8
        let s_4547_2: u8 = fn_state.opc1;
        // D s_4547_3: read-var CRn:u8
        let s_4547_3: u8 = fn_state.CRn;
        // D s_4547_4: read-var opc2:u8
        let s_4547_4: u8 = fn_state.opc2;
        // D s_4547_5: read-var CRm:u8
        let s_4547_5: u8 = fn_state.CRm;
        // D s_4547_6: read-var t:i
        let s_4547_6: i128 = fn_state.t;
        // D s_4547_7: call CNTKCTL_SysRegWrite32_e68a84be701ace4f(s_4547_0, s_4547_1, s_4547_2, s_4547_3, s_4547_4, s_4547_5, s_4547_6)
        let s_4547_7: () = CNTKCTL_SysRegWrite32_e68a84be701ace4f(
            state,
            tracer,
            s_4547_0,
            s_4547_1,
            s_4547_2,
            s_4547_3,
            s_4547_4,
            s_4547_5,
            s_4547_6,
        );
        // N s_4547_8: return
        return;
    }
    fn block_4548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4548_0: read-var opc2:u8
        let s_4548_0: u8 = fn_state.opc2;
        // D s_4548_1: cast zx s_4548_0 -> bv
        let s_4548_1: Bits = Bits::new(s_4548_0 as u128, 3u16);
        // C s_4548_2: const #0u : u8
        let s_4548_2: u8 = 0;
        // C s_4548_3: cast zx s_4548_2 -> bv
        let s_4548_3: Bits = Bits::new(s_4548_2 as u128, 3u16);
        // D s_4548_4: cmp-eq s_4548_1 s_4548_3
        let s_4548_4: bool = ((s_4548_1) == (s_4548_3));
        // D s_4548_5: write-var gs#135423 <= s_4548_4
        fn_state.gs_135423 = s_4548_4;
        // N s_4548_6: jump b2123
        return block_2123(state, tracer, fn_state);
    }
    fn block_4549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4549_0: read-var opc1:u8
        let s_4549_0: u8 = fn_state.opc1;
        // D s_4549_1: cast zx s_4549_0 -> bv
        let s_4549_1: Bits = Bits::new(s_4549_0 as u128, 3u16);
        // C s_4549_2: const #0u : u8
        let s_4549_2: u8 = 0;
        // C s_4549_3: cast zx s_4549_2 -> bv
        let s_4549_3: Bits = Bits::new(s_4549_2 as u128, 3u16);
        // D s_4549_4: cmp-eq s_4549_1 s_4549_3
        let s_4549_4: bool = ((s_4549_1) == (s_4549_3));
        // D s_4549_5: write-var gs#135422 <= s_4549_4
        fn_state.gs_135422 = s_4549_4;
        // N s_4549_6: jump b2121
        return block_2121(state, tracer, fn_state);
    }
    fn block_4550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4550_0: read-var coproc:u8
        let s_4550_0: u8 = fn_state.coproc;
        // D s_4550_1: cast zx s_4550_0 -> bv
        let s_4550_1: Bits = Bits::new(s_4550_0 as u128, 4u16);
        // C s_4550_2: const #15u : u8
        let s_4550_2: u8 = 15;
        // C s_4550_3: cast zx s_4550_2 -> bv
        let s_4550_3: Bits = Bits::new(s_4550_2 as u128, 4u16);
        // D s_4550_4: cmp-eq s_4550_1 s_4550_3
        let s_4550_4: bool = ((s_4550_1) == (s_4550_3));
        // D s_4550_5: write-var gs#135421 <= s_4550_4
        fn_state.gs_135421 = s_4550_4;
        // N s_4550_6: jump b2119
        return block_2119(state, tracer, fn_state);
    }
    fn block_4551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4551_0: read-var CRn:u8
        let s_4551_0: u8 = fn_state.CRn;
        // D s_4551_1: cast zx s_4551_0 -> bv
        let s_4551_1: Bits = Bits::new(s_4551_0 as u128, 4u16);
        // C s_4551_2: const #14u : u8
        let s_4551_2: u8 = 14;
        // C s_4551_3: cast zx s_4551_2 -> bv
        let s_4551_3: Bits = Bits::new(s_4551_2 as u128, 4u16);
        // D s_4551_4: cmp-eq s_4551_1 s_4551_3
        let s_4551_4: bool = ((s_4551_1) == (s_4551_3));
        // D s_4551_5: write-var gs#135420 <= s_4551_4
        fn_state.gs_135420 = s_4551_4;
        // N s_4551_6: jump b2117
        return block_2117(state, tracer, fn_state);
    }
    fn block_4552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4552_0: read-var el:u8
        let s_4552_0: u8 = fn_state.el;
        // D s_4552_1: read-var coproc:u8
        let s_4552_1: u8 = fn_state.coproc;
        // D s_4552_2: read-var opc1:u8
        let s_4552_2: u8 = fn_state.opc1;
        // D s_4552_3: read-var CRn:u8
        let s_4552_3: u8 = fn_state.CRn;
        // D s_4552_4: read-var opc2:u8
        let s_4552_4: u8 = fn_state.opc2;
        // D s_4552_5: read-var CRm:u8
        let s_4552_5: u8 = fn_state.CRm;
        // D s_4552_6: read-var t:i
        let s_4552_6: i128 = fn_state.t;
        // D s_4552_7: call JMCR_SysRegWrite32_5cdfe87c581e3185(s_4552_0, s_4552_1, s_4552_2, s_4552_3, s_4552_4, s_4552_5, s_4552_6)
        let s_4552_7: () = JMCR_SysRegWrite32_5cdfe87c581e3185(
            state,
            tracer,
            s_4552_0,
            s_4552_1,
            s_4552_2,
            s_4552_3,
            s_4552_4,
            s_4552_5,
            s_4552_6,
        );
        // N s_4552_8: return
        return;
    }
    fn block_4553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4553_0: read-var opc2:u8
        let s_4553_0: u8 = fn_state.opc2;
        // D s_4553_1: cast zx s_4553_0 -> bv
        let s_4553_1: Bits = Bits::new(s_4553_0 as u128, 3u16);
        // C s_4553_2: const #0u : u8
        let s_4553_2: u8 = 0;
        // C s_4553_3: cast zx s_4553_2 -> bv
        let s_4553_3: Bits = Bits::new(s_4553_2 as u128, 3u16);
        // D s_4553_4: cmp-eq s_4553_1 s_4553_3
        let s_4553_4: bool = ((s_4553_1) == (s_4553_3));
        // D s_4553_5: write-var gs#135419 <= s_4553_4
        fn_state.gs_135419 = s_4553_4;
        // N s_4553_6: jump b2114
        return block_2114(state, tracer, fn_state);
    }
    fn block_4554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4554_0: read-var opc1:u8
        let s_4554_0: u8 = fn_state.opc1;
        // D s_4554_1: cast zx s_4554_0 -> bv
        let s_4554_1: Bits = Bits::new(s_4554_0 as u128, 3u16);
        // C s_4554_2: const #7u : u8
        let s_4554_2: u8 = 7;
        // C s_4554_3: cast zx s_4554_2 -> bv
        let s_4554_3: Bits = Bits::new(s_4554_2 as u128, 3u16);
        // D s_4554_4: cmp-eq s_4554_1 s_4554_3
        let s_4554_4: bool = ((s_4554_1) == (s_4554_3));
        // D s_4554_5: write-var gs#135418 <= s_4554_4
        fn_state.gs_135418 = s_4554_4;
        // N s_4554_6: jump b2112
        return block_2112(state, tracer, fn_state);
    }
    fn block_4555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4555_0: read-var coproc:u8
        let s_4555_0: u8 = fn_state.coproc;
        // D s_4555_1: cast zx s_4555_0 -> bv
        let s_4555_1: Bits = Bits::new(s_4555_0 as u128, 4u16);
        // C s_4555_2: const #14u : u8
        let s_4555_2: u8 = 14;
        // C s_4555_3: cast zx s_4555_2 -> bv
        let s_4555_3: Bits = Bits::new(s_4555_2 as u128, 4u16);
        // D s_4555_4: cmp-eq s_4555_1 s_4555_3
        let s_4555_4: bool = ((s_4555_1) == (s_4555_3));
        // D s_4555_5: write-var gs#135417 <= s_4555_4
        fn_state.gs_135417 = s_4555_4;
        // N s_4555_6: jump b2110
        return block_2110(state, tracer, fn_state);
    }
    fn block_4556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4556_0: read-var CRn:u8
        let s_4556_0: u8 = fn_state.CRn;
        // D s_4556_1: cast zx s_4556_0 -> bv
        let s_4556_1: Bits = Bits::new(s_4556_0 as u128, 4u16);
        // C s_4556_2: const #2u : u8
        let s_4556_2: u8 = 2;
        // C s_4556_3: cast zx s_4556_2 -> bv
        let s_4556_3: Bits = Bits::new(s_4556_2 as u128, 4u16);
        // D s_4556_4: cmp-eq s_4556_1 s_4556_3
        let s_4556_4: bool = ((s_4556_1) == (s_4556_3));
        // D s_4556_5: write-var gs#135416 <= s_4556_4
        fn_state.gs_135416 = s_4556_4;
        // N s_4556_6: jump b2108
        return block_2108(state, tracer, fn_state);
    }
    fn block_4557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4557_0: read-var el:u8
        let s_4557_0: u8 = fn_state.el;
        // D s_4557_1: read-var coproc:u8
        let s_4557_1: u8 = fn_state.coproc;
        // D s_4557_2: read-var opc1:u8
        let s_4557_2: u8 = fn_state.opc1;
        // D s_4557_3: read-var CRn:u8
        let s_4557_3: u8 = fn_state.CRn;
        // D s_4557_4: read-var opc2:u8
        let s_4557_4: u8 = fn_state.opc2;
        // D s_4557_5: read-var CRm:u8
        let s_4557_5: u8 = fn_state.CRm;
        // D s_4557_6: read-var t:i
        let s_4557_6: i128 = fn_state.t;
        // D s_4557_7: call HADFSR_SysRegWrite32_700a8776afbb1761(s_4557_0, s_4557_1, s_4557_2, s_4557_3, s_4557_4, s_4557_5, s_4557_6)
        let s_4557_7: () = HADFSR_SysRegWrite32_700a8776afbb1761(
            state,
            tracer,
            s_4557_0,
            s_4557_1,
            s_4557_2,
            s_4557_3,
            s_4557_4,
            s_4557_5,
            s_4557_6,
        );
        // N s_4557_8: return
        return;
    }
    fn block_4558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4558_0: read-var opc2:u8
        let s_4558_0: u8 = fn_state.opc2;
        // D s_4558_1: cast zx s_4558_0 -> bv
        let s_4558_1: Bits = Bits::new(s_4558_0 as u128, 3u16);
        // C s_4558_2: const #0u : u8
        let s_4558_2: u8 = 0;
        // C s_4558_3: cast zx s_4558_2 -> bv
        let s_4558_3: Bits = Bits::new(s_4558_2 as u128, 3u16);
        // D s_4558_4: cmp-eq s_4558_1 s_4558_3
        let s_4558_4: bool = ((s_4558_1) == (s_4558_3));
        // D s_4558_5: write-var gs#135415 <= s_4558_4
        fn_state.gs_135415 = s_4558_4;
        // N s_4558_6: jump b2105
        return block_2105(state, tracer, fn_state);
    }
    fn block_4559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4559_0: read-var opc1:u8
        let s_4559_0: u8 = fn_state.opc1;
        // D s_4559_1: cast zx s_4559_0 -> bv
        let s_4559_1: Bits = Bits::new(s_4559_0 as u128, 3u16);
        // C s_4559_2: const #4u : u8
        let s_4559_2: u8 = 4;
        // C s_4559_3: cast zx s_4559_2 -> bv
        let s_4559_3: Bits = Bits::new(s_4559_2 as u128, 3u16);
        // D s_4559_4: cmp-eq s_4559_1 s_4559_3
        let s_4559_4: bool = ((s_4559_1) == (s_4559_3));
        // D s_4559_5: write-var gs#135414 <= s_4559_4
        fn_state.gs_135414 = s_4559_4;
        // N s_4559_6: jump b2103
        return block_2103(state, tracer, fn_state);
    }
    fn block_4560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4560_0: read-var coproc:u8
        let s_4560_0: u8 = fn_state.coproc;
        // D s_4560_1: cast zx s_4560_0 -> bv
        let s_4560_1: Bits = Bits::new(s_4560_0 as u128, 4u16);
        // C s_4560_2: const #15u : u8
        let s_4560_2: u8 = 15;
        // C s_4560_3: cast zx s_4560_2 -> bv
        let s_4560_3: Bits = Bits::new(s_4560_2 as u128, 4u16);
        // D s_4560_4: cmp-eq s_4560_1 s_4560_3
        let s_4560_4: bool = ((s_4560_1) == (s_4560_3));
        // D s_4560_5: write-var gs#135413 <= s_4560_4
        fn_state.gs_135413 = s_4560_4;
        // N s_4560_6: jump b2101
        return block_2101(state, tracer, fn_state);
    }
    fn block_4561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4561_0: read-var CRn:u8
        let s_4561_0: u8 = fn_state.CRn;
        // D s_4561_1: cast zx s_4561_0 -> bv
        let s_4561_1: Bits = Bits::new(s_4561_0 as u128, 4u16);
        // C s_4561_2: const #5u : u8
        let s_4561_2: u8 = 5;
        // C s_4561_3: cast zx s_4561_2 -> bv
        let s_4561_3: Bits = Bits::new(s_4561_2 as u128, 4u16);
        // D s_4561_4: cmp-eq s_4561_1 s_4561_3
        let s_4561_4: bool = ((s_4561_1) == (s_4561_3));
        // D s_4561_5: write-var gs#135412 <= s_4561_4
        fn_state.gs_135412 = s_4561_4;
        // N s_4561_6: jump b2099
        return block_2099(state, tracer, fn_state);
    }
    fn block_4562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4562_0: read-var el:u8
        let s_4562_0: u8 = fn_state.el;
        // D s_4562_1: read-var coproc:u8
        let s_4562_1: u8 = fn_state.coproc;
        // D s_4562_2: read-var opc1:u8
        let s_4562_2: u8 = fn_state.opc1;
        // D s_4562_3: read-var CRn:u8
        let s_4562_3: u8 = fn_state.CRn;
        // D s_4562_4: read-var opc2:u8
        let s_4562_4: u8 = fn_state.opc2;
        // D s_4562_5: read-var CRm:u8
        let s_4562_5: u8 = fn_state.CRm;
        // D s_4562_6: read-var t:i
        let s_4562_6: i128 = fn_state.t;
        // D s_4562_7: call TLBIMVAIS_SysRegWrite32_bfc80b2d7757a07f(s_4562_0, s_4562_1, s_4562_2, s_4562_3, s_4562_4, s_4562_5, s_4562_6)
        let s_4562_7: () = TLBIMVAIS_SysRegWrite32_bfc80b2d7757a07f(
            state,
            tracer,
            s_4562_0,
            s_4562_1,
            s_4562_2,
            s_4562_3,
            s_4562_4,
            s_4562_5,
            s_4562_6,
        );
        // N s_4562_8: return
        return;
    }
    fn block_4563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4563_0: read-var opc2:u8
        let s_4563_0: u8 = fn_state.opc2;
        // D s_4563_1: cast zx s_4563_0 -> bv
        let s_4563_1: Bits = Bits::new(s_4563_0 as u128, 3u16);
        // C s_4563_2: const #1u : u8
        let s_4563_2: u8 = 1;
        // C s_4563_3: cast zx s_4563_2 -> bv
        let s_4563_3: Bits = Bits::new(s_4563_2 as u128, 3u16);
        // D s_4563_4: cmp-eq s_4563_1 s_4563_3
        let s_4563_4: bool = ((s_4563_1) == (s_4563_3));
        // D s_4563_5: write-var gs#135411 <= s_4563_4
        fn_state.gs_135411 = s_4563_4;
        // N s_4563_6: jump b2096
        return block_2096(state, tracer, fn_state);
    }
    fn block_4564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4564_0: read-var opc1:u8
        let s_4564_0: u8 = fn_state.opc1;
        // D s_4564_1: cast zx s_4564_0 -> bv
        let s_4564_1: Bits = Bits::new(s_4564_0 as u128, 3u16);
        // C s_4564_2: const #0u : u8
        let s_4564_2: u8 = 0;
        // C s_4564_3: cast zx s_4564_2 -> bv
        let s_4564_3: Bits = Bits::new(s_4564_2 as u128, 3u16);
        // D s_4564_4: cmp-eq s_4564_1 s_4564_3
        let s_4564_4: bool = ((s_4564_1) == (s_4564_3));
        // D s_4564_5: write-var gs#135410 <= s_4564_4
        fn_state.gs_135410 = s_4564_4;
        // N s_4564_6: jump b2094
        return block_2094(state, tracer, fn_state);
    }
    fn block_4565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4565_0: read-var coproc:u8
        let s_4565_0: u8 = fn_state.coproc;
        // D s_4565_1: cast zx s_4565_0 -> bv
        let s_4565_1: Bits = Bits::new(s_4565_0 as u128, 4u16);
        // C s_4565_2: const #15u : u8
        let s_4565_2: u8 = 15;
        // C s_4565_3: cast zx s_4565_2 -> bv
        let s_4565_3: Bits = Bits::new(s_4565_2 as u128, 4u16);
        // D s_4565_4: cmp-eq s_4565_1 s_4565_3
        let s_4565_4: bool = ((s_4565_1) == (s_4565_3));
        // D s_4565_5: write-var gs#135409 <= s_4565_4
        fn_state.gs_135409 = s_4565_4;
        // N s_4565_6: jump b2092
        return block_2092(state, tracer, fn_state);
    }
    fn block_4566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4566_0: read-var CRn:u8
        let s_4566_0: u8 = fn_state.CRn;
        // D s_4566_1: cast zx s_4566_0 -> bv
        let s_4566_1: Bits = Bits::new(s_4566_0 as u128, 4u16);
        // C s_4566_2: const #8u : u8
        let s_4566_2: u8 = 8;
        // C s_4566_3: cast zx s_4566_2 -> bv
        let s_4566_3: Bits = Bits::new(s_4566_2 as u128, 4u16);
        // D s_4566_4: cmp-eq s_4566_1 s_4566_3
        let s_4566_4: bool = ((s_4566_1) == (s_4566_3));
        // D s_4566_5: write-var gs#135408 <= s_4566_4
        fn_state.gs_135408 = s_4566_4;
        // N s_4566_6: jump b2090
        return block_2090(state, tracer, fn_state);
    }
    fn block_4567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4567_0: read-var el:u8
        let s_4567_0: u8 = fn_state.el;
        // D s_4567_1: read-var coproc:u8
        let s_4567_1: u8 = fn_state.coproc;
        // D s_4567_2: read-var opc1:u8
        let s_4567_2: u8 = fn_state.opc1;
        // D s_4567_3: read-var CRn:u8
        let s_4567_3: u8 = fn_state.CRn;
        // D s_4567_4: read-var opc2:u8
        let s_4567_4: u8 = fn_state.opc2;
        // D s_4567_5: read-var CRm:u8
        let s_4567_5: u8 = fn_state.CRm;
        // D s_4567_6: read-var t:i
        let s_4567_6: i128 = fn_state.t;
        // D s_4567_7: call ICH_LR_SysRegWrite32_29c49b66d9046e0a(s_4567_0, s_4567_1, s_4567_2, s_4567_3, s_4567_4, s_4567_5, s_4567_6)
        let s_4567_7: () = ICH_LR_SysRegWrite32_29c49b66d9046e0a(
            state,
            tracer,
            s_4567_0,
            s_4567_1,
            s_4567_2,
            s_4567_3,
            s_4567_4,
            s_4567_5,
            s_4567_6,
        );
        // N s_4567_8: return
        return;
    }
    fn block_4568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4568_0: read-var opc2:u8
        let s_4568_0: u8 = fn_state.opc2;
        // D s_4568_1: cast zx s_4568_0 -> bv
        let s_4568_1: Bits = Bits::new(s_4568_0 as u128, 3u16);
        // C s_4568_2: const #0u : u8
        let s_4568_2: u8 = 0;
        // C s_4568_3: cast zx s_4568_2 -> bv
        let s_4568_3: Bits = Bits::new(s_4568_2 as u128, 3u16);
        // D s_4568_4: cmp-eq s_4568_1 s_4568_3
        let s_4568_4: bool = ((s_4568_1) == (s_4568_3));
        // D s_4568_5: write-var gs#135407 <= s_4568_4
        fn_state.gs_135407 = s_4568_4;
        // N s_4568_6: jump b2087
        return block_2087(state, tracer, fn_state);
    }
    fn block_4569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4569_0: read-var opc1:u8
        let s_4569_0: u8 = fn_state.opc1;
        // D s_4569_1: cast zx s_4569_0 -> bv
        let s_4569_1: Bits = Bits::new(s_4569_0 as u128, 3u16);
        // C s_4569_2: const #4u : u8
        let s_4569_2: u8 = 4;
        // C s_4569_3: cast zx s_4569_2 -> bv
        let s_4569_3: Bits = Bits::new(s_4569_2 as u128, 3u16);
        // D s_4569_4: cmp-eq s_4569_1 s_4569_3
        let s_4569_4: bool = ((s_4569_1) == (s_4569_3));
        // D s_4569_5: write-var gs#135406 <= s_4569_4
        fn_state.gs_135406 = s_4569_4;
        // N s_4569_6: jump b2085
        return block_2085(state, tracer, fn_state);
    }
    fn block_4570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4570_0: read-var coproc:u8
        let s_4570_0: u8 = fn_state.coproc;
        // D s_4570_1: cast zx s_4570_0 -> bv
        let s_4570_1: Bits = Bits::new(s_4570_0 as u128, 4u16);
        // C s_4570_2: const #15u : u8
        let s_4570_2: u8 = 15;
        // C s_4570_3: cast zx s_4570_2 -> bv
        let s_4570_3: Bits = Bits::new(s_4570_2 as u128, 4u16);
        // D s_4570_4: cmp-eq s_4570_1 s_4570_3
        let s_4570_4: bool = ((s_4570_1) == (s_4570_3));
        // D s_4570_5: write-var gs#135405 <= s_4570_4
        fn_state.gs_135405 = s_4570_4;
        // N s_4570_6: jump b2083
        return block_2083(state, tracer, fn_state);
    }
    fn block_4571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4571_0: read-var CRn:u8
        let s_4571_0: u8 = fn_state.CRn;
        // D s_4571_1: cast zx s_4571_0 -> bv
        let s_4571_1: Bits = Bits::new(s_4571_0 as u128, 4u16);
        // C s_4571_2: const #12u : u8
        let s_4571_2: u8 = 12;
        // C s_4571_3: cast zx s_4571_2 -> bv
        let s_4571_3: Bits = Bits::new(s_4571_2 as u128, 4u16);
        // D s_4571_4: cmp-eq s_4571_1 s_4571_3
        let s_4571_4: bool = ((s_4571_1) == (s_4571_3));
        // D s_4571_5: write-var gs#135404 <= s_4571_4
        fn_state.gs_135404 = s_4571_4;
        // N s_4571_6: jump b2081
        return block_2081(state, tracer, fn_state);
    }
    fn block_4572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4572_0: read-var el:u8
        let s_4572_0: u8 = fn_state.el;
        // D s_4572_1: read-var coproc:u8
        let s_4572_1: u8 = fn_state.coproc;
        // D s_4572_2: read-var opc1:u8
        let s_4572_2: u8 = fn_state.opc1;
        // D s_4572_3: read-var CRn:u8
        let s_4572_3: u8 = fn_state.CRn;
        // D s_4572_4: read-var opc2:u8
        let s_4572_4: u8 = fn_state.opc2;
        // D s_4572_5: read-var CRm:u8
        let s_4572_5: u8 = fn_state.CRm;
        // D s_4572_6: read-var t:i
        let s_4572_6: i128 = fn_state.t;
        // D s_4572_7: call ICH_LR_SysRegWrite32_66cfea86c7608fe1(s_4572_0, s_4572_1, s_4572_2, s_4572_3, s_4572_4, s_4572_5, s_4572_6)
        let s_4572_7: () = ICH_LR_SysRegWrite32_66cfea86c7608fe1(
            state,
            tracer,
            s_4572_0,
            s_4572_1,
            s_4572_2,
            s_4572_3,
            s_4572_4,
            s_4572_5,
            s_4572_6,
        );
        // N s_4572_8: return
        return;
    }
    fn block_4573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4573_0: read-var opc2:u8
        let s_4573_0: u8 = fn_state.opc2;
        // D s_4573_1: cast zx s_4573_0 -> bv
        let s_4573_1: Bits = Bits::new(s_4573_0 as u128, 3u16);
        // C s_4573_2: const #1u : u8
        let s_4573_2: u8 = 1;
        // C s_4573_3: cast zx s_4573_2 -> bv
        let s_4573_3: Bits = Bits::new(s_4573_2 as u128, 3u16);
        // D s_4573_4: cmp-eq s_4573_1 s_4573_3
        let s_4573_4: bool = ((s_4573_1) == (s_4573_3));
        // D s_4573_5: write-var gs#135403 <= s_4573_4
        fn_state.gs_135403 = s_4573_4;
        // N s_4573_6: jump b2078
        return block_2078(state, tracer, fn_state);
    }
    fn block_4574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4574_0: read-var opc1:u8
        let s_4574_0: u8 = fn_state.opc1;
        // D s_4574_1: cast zx s_4574_0 -> bv
        let s_4574_1: Bits = Bits::new(s_4574_0 as u128, 3u16);
        // C s_4574_2: const #4u : u8
        let s_4574_2: u8 = 4;
        // C s_4574_3: cast zx s_4574_2 -> bv
        let s_4574_3: Bits = Bits::new(s_4574_2 as u128, 3u16);
        // D s_4574_4: cmp-eq s_4574_1 s_4574_3
        let s_4574_4: bool = ((s_4574_1) == (s_4574_3));
        // D s_4574_5: write-var gs#135402 <= s_4574_4
        fn_state.gs_135402 = s_4574_4;
        // N s_4574_6: jump b2076
        return block_2076(state, tracer, fn_state);
    }
    fn block_4575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4575_0: read-var coproc:u8
        let s_4575_0: u8 = fn_state.coproc;
        // D s_4575_1: cast zx s_4575_0 -> bv
        let s_4575_1: Bits = Bits::new(s_4575_0 as u128, 4u16);
        // C s_4575_2: const #15u : u8
        let s_4575_2: u8 = 15;
        // C s_4575_3: cast zx s_4575_2 -> bv
        let s_4575_3: Bits = Bits::new(s_4575_2 as u128, 4u16);
        // D s_4575_4: cmp-eq s_4575_1 s_4575_3
        let s_4575_4: bool = ((s_4575_1) == (s_4575_3));
        // D s_4575_5: write-var gs#135401 <= s_4575_4
        fn_state.gs_135401 = s_4575_4;
        // N s_4575_6: jump b2074
        return block_2074(state, tracer, fn_state);
    }
    fn block_4576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4576_0: read-var CRn:u8
        let s_4576_0: u8 = fn_state.CRn;
        // D s_4576_1: cast zx s_4576_0 -> bv
        let s_4576_1: Bits = Bits::new(s_4576_0 as u128, 4u16);
        // C s_4576_2: const #12u : u8
        let s_4576_2: u8 = 12;
        // C s_4576_3: cast zx s_4576_2 -> bv
        let s_4576_3: Bits = Bits::new(s_4576_2 as u128, 4u16);
        // D s_4576_4: cmp-eq s_4576_1 s_4576_3
        let s_4576_4: bool = ((s_4576_1) == (s_4576_3));
        // D s_4576_5: write-var gs#135400 <= s_4576_4
        fn_state.gs_135400 = s_4576_4;
        // N s_4576_6: jump b2072
        return block_2072(state, tracer, fn_state);
    }
    fn block_4577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4577_0: read-var el:u8
        let s_4577_0: u8 = fn_state.el;
        // D s_4577_1: read-var coproc:u8
        let s_4577_1: u8 = fn_state.coproc;
        // D s_4577_2: read-var opc1:u8
        let s_4577_2: u8 = fn_state.opc1;
        // D s_4577_3: read-var CRn:u8
        let s_4577_3: u8 = fn_state.CRn;
        // D s_4577_4: read-var opc2:u8
        let s_4577_4: u8 = fn_state.opc2;
        // D s_4577_5: read-var CRm:u8
        let s_4577_5: u8 = fn_state.CRm;
        // D s_4577_6: read-var t:i
        let s_4577_6: i128 = fn_state.t;
        // D s_4577_7: call ICH_LR_SysRegWrite32_64e5be949dba10fe(s_4577_0, s_4577_1, s_4577_2, s_4577_3, s_4577_4, s_4577_5, s_4577_6)
        let s_4577_7: () = ICH_LR_SysRegWrite32_64e5be949dba10fe(
            state,
            tracer,
            s_4577_0,
            s_4577_1,
            s_4577_2,
            s_4577_3,
            s_4577_4,
            s_4577_5,
            s_4577_6,
        );
        // N s_4577_8: return
        return;
    }
    fn block_4578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4578_0: read-var opc2:u8
        let s_4578_0: u8 = fn_state.opc2;
        // D s_4578_1: cast zx s_4578_0 -> bv
        let s_4578_1: Bits = Bits::new(s_4578_0 as u128, 3u16);
        // C s_4578_2: const #2u : u8
        let s_4578_2: u8 = 2;
        // C s_4578_3: cast zx s_4578_2 -> bv
        let s_4578_3: Bits = Bits::new(s_4578_2 as u128, 3u16);
        // D s_4578_4: cmp-eq s_4578_1 s_4578_3
        let s_4578_4: bool = ((s_4578_1) == (s_4578_3));
        // D s_4578_5: write-var gs#135399 <= s_4578_4
        fn_state.gs_135399 = s_4578_4;
        // N s_4578_6: jump b2069
        return block_2069(state, tracer, fn_state);
    }
    fn block_4579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4579_0: read-var opc1:u8
        let s_4579_0: u8 = fn_state.opc1;
        // D s_4579_1: cast zx s_4579_0 -> bv
        let s_4579_1: Bits = Bits::new(s_4579_0 as u128, 3u16);
        // C s_4579_2: const #4u : u8
        let s_4579_2: u8 = 4;
        // C s_4579_3: cast zx s_4579_2 -> bv
        let s_4579_3: Bits = Bits::new(s_4579_2 as u128, 3u16);
        // D s_4579_4: cmp-eq s_4579_1 s_4579_3
        let s_4579_4: bool = ((s_4579_1) == (s_4579_3));
        // D s_4579_5: write-var gs#135398 <= s_4579_4
        fn_state.gs_135398 = s_4579_4;
        // N s_4579_6: jump b2067
        return block_2067(state, tracer, fn_state);
    }
    fn block_4580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4580_0: read-var coproc:u8
        let s_4580_0: u8 = fn_state.coproc;
        // D s_4580_1: cast zx s_4580_0 -> bv
        let s_4580_1: Bits = Bits::new(s_4580_0 as u128, 4u16);
        // C s_4580_2: const #15u : u8
        let s_4580_2: u8 = 15;
        // C s_4580_3: cast zx s_4580_2 -> bv
        let s_4580_3: Bits = Bits::new(s_4580_2 as u128, 4u16);
        // D s_4580_4: cmp-eq s_4580_1 s_4580_3
        let s_4580_4: bool = ((s_4580_1) == (s_4580_3));
        // D s_4580_5: write-var gs#135397 <= s_4580_4
        fn_state.gs_135397 = s_4580_4;
        // N s_4580_6: jump b2065
        return block_2065(state, tracer, fn_state);
    }
    fn block_4581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4581_0: read-var CRn:u8
        let s_4581_0: u8 = fn_state.CRn;
        // D s_4581_1: cast zx s_4581_0 -> bv
        let s_4581_1: Bits = Bits::new(s_4581_0 as u128, 4u16);
        // C s_4581_2: const #12u : u8
        let s_4581_2: u8 = 12;
        // C s_4581_3: cast zx s_4581_2 -> bv
        let s_4581_3: Bits = Bits::new(s_4581_2 as u128, 4u16);
        // D s_4581_4: cmp-eq s_4581_1 s_4581_3
        let s_4581_4: bool = ((s_4581_1) == (s_4581_3));
        // D s_4581_5: write-var gs#135396 <= s_4581_4
        fn_state.gs_135396 = s_4581_4;
        // N s_4581_6: jump b2063
        return block_2063(state, tracer, fn_state);
    }
    fn block_4582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4582_0: read-var el:u8
        let s_4582_0: u8 = fn_state.el;
        // D s_4582_1: read-var coproc:u8
        let s_4582_1: u8 = fn_state.coproc;
        // D s_4582_2: read-var opc1:u8
        let s_4582_2: u8 = fn_state.opc1;
        // D s_4582_3: read-var CRn:u8
        let s_4582_3: u8 = fn_state.CRn;
        // D s_4582_4: read-var opc2:u8
        let s_4582_4: u8 = fn_state.opc2;
        // D s_4582_5: read-var CRm:u8
        let s_4582_5: u8 = fn_state.CRm;
        // D s_4582_6: read-var t:i
        let s_4582_6: i128 = fn_state.t;
        // D s_4582_7: call ICH_LR_SysRegWrite32_2360c70ac77c896c(s_4582_0, s_4582_1, s_4582_2, s_4582_3, s_4582_4, s_4582_5, s_4582_6)
        let s_4582_7: () = ICH_LR_SysRegWrite32_2360c70ac77c896c(
            state,
            tracer,
            s_4582_0,
            s_4582_1,
            s_4582_2,
            s_4582_3,
            s_4582_4,
            s_4582_5,
            s_4582_6,
        );
        // N s_4582_8: return
        return;
    }
    fn block_4583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4583_0: read-var opc2:u8
        let s_4583_0: u8 = fn_state.opc2;
        // D s_4583_1: cast zx s_4583_0 -> bv
        let s_4583_1: Bits = Bits::new(s_4583_0 as u128, 3u16);
        // C s_4583_2: const #3u : u8
        let s_4583_2: u8 = 3;
        // C s_4583_3: cast zx s_4583_2 -> bv
        let s_4583_3: Bits = Bits::new(s_4583_2 as u128, 3u16);
        // D s_4583_4: cmp-eq s_4583_1 s_4583_3
        let s_4583_4: bool = ((s_4583_1) == (s_4583_3));
        // D s_4583_5: write-var gs#135395 <= s_4583_4
        fn_state.gs_135395 = s_4583_4;
        // N s_4583_6: jump b2060
        return block_2060(state, tracer, fn_state);
    }
    fn block_4584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4584_0: read-var opc1:u8
        let s_4584_0: u8 = fn_state.opc1;
        // D s_4584_1: cast zx s_4584_0 -> bv
        let s_4584_1: Bits = Bits::new(s_4584_0 as u128, 3u16);
        // C s_4584_2: const #4u : u8
        let s_4584_2: u8 = 4;
        // C s_4584_3: cast zx s_4584_2 -> bv
        let s_4584_3: Bits = Bits::new(s_4584_2 as u128, 3u16);
        // D s_4584_4: cmp-eq s_4584_1 s_4584_3
        let s_4584_4: bool = ((s_4584_1) == (s_4584_3));
        // D s_4584_5: write-var gs#135394 <= s_4584_4
        fn_state.gs_135394 = s_4584_4;
        // N s_4584_6: jump b2058
        return block_2058(state, tracer, fn_state);
    }
    fn block_4585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4585_0: read-var coproc:u8
        let s_4585_0: u8 = fn_state.coproc;
        // D s_4585_1: cast zx s_4585_0 -> bv
        let s_4585_1: Bits = Bits::new(s_4585_0 as u128, 4u16);
        // C s_4585_2: const #15u : u8
        let s_4585_2: u8 = 15;
        // C s_4585_3: cast zx s_4585_2 -> bv
        let s_4585_3: Bits = Bits::new(s_4585_2 as u128, 4u16);
        // D s_4585_4: cmp-eq s_4585_1 s_4585_3
        let s_4585_4: bool = ((s_4585_1) == (s_4585_3));
        // D s_4585_5: write-var gs#135393 <= s_4585_4
        fn_state.gs_135393 = s_4585_4;
        // N s_4585_6: jump b2056
        return block_2056(state, tracer, fn_state);
    }
    fn block_4586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4586_0: read-var CRn:u8
        let s_4586_0: u8 = fn_state.CRn;
        // D s_4586_1: cast zx s_4586_0 -> bv
        let s_4586_1: Bits = Bits::new(s_4586_0 as u128, 4u16);
        // C s_4586_2: const #12u : u8
        let s_4586_2: u8 = 12;
        // C s_4586_3: cast zx s_4586_2 -> bv
        let s_4586_3: Bits = Bits::new(s_4586_2 as u128, 4u16);
        // D s_4586_4: cmp-eq s_4586_1 s_4586_3
        let s_4586_4: bool = ((s_4586_1) == (s_4586_3));
        // D s_4586_5: write-var gs#135392 <= s_4586_4
        fn_state.gs_135392 = s_4586_4;
        // N s_4586_6: jump b2054
        return block_2054(state, tracer, fn_state);
    }
    fn block_4587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4587_0: read-var el:u8
        let s_4587_0: u8 = fn_state.el;
        // D s_4587_1: read-var coproc:u8
        let s_4587_1: u8 = fn_state.coproc;
        // D s_4587_2: read-var opc1:u8
        let s_4587_2: u8 = fn_state.opc1;
        // D s_4587_3: read-var CRn:u8
        let s_4587_3: u8 = fn_state.CRn;
        // D s_4587_4: read-var opc2:u8
        let s_4587_4: u8 = fn_state.opc2;
        // D s_4587_5: read-var CRm:u8
        let s_4587_5: u8 = fn_state.CRm;
        // D s_4587_6: read-var t:i
        let s_4587_6: i128 = fn_state.t;
        // D s_4587_7: call ICH_LR_SysRegWrite32_5f330d948f9246f1(s_4587_0, s_4587_1, s_4587_2, s_4587_3, s_4587_4, s_4587_5, s_4587_6)
        let s_4587_7: () = ICH_LR_SysRegWrite32_5f330d948f9246f1(
            state,
            tracer,
            s_4587_0,
            s_4587_1,
            s_4587_2,
            s_4587_3,
            s_4587_4,
            s_4587_5,
            s_4587_6,
        );
        // N s_4587_8: return
        return;
    }
    fn block_4588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4588_0: read-var opc2:u8
        let s_4588_0: u8 = fn_state.opc2;
        // D s_4588_1: cast zx s_4588_0 -> bv
        let s_4588_1: Bits = Bits::new(s_4588_0 as u128, 3u16);
        // C s_4588_2: const #4u : u8
        let s_4588_2: u8 = 4;
        // C s_4588_3: cast zx s_4588_2 -> bv
        let s_4588_3: Bits = Bits::new(s_4588_2 as u128, 3u16);
        // D s_4588_4: cmp-eq s_4588_1 s_4588_3
        let s_4588_4: bool = ((s_4588_1) == (s_4588_3));
        // D s_4588_5: write-var gs#135391 <= s_4588_4
        fn_state.gs_135391 = s_4588_4;
        // N s_4588_6: jump b2051
        return block_2051(state, tracer, fn_state);
    }
    fn block_4589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4589_0: read-var opc1:u8
        let s_4589_0: u8 = fn_state.opc1;
        // D s_4589_1: cast zx s_4589_0 -> bv
        let s_4589_1: Bits = Bits::new(s_4589_0 as u128, 3u16);
        // C s_4589_2: const #4u : u8
        let s_4589_2: u8 = 4;
        // C s_4589_3: cast zx s_4589_2 -> bv
        let s_4589_3: Bits = Bits::new(s_4589_2 as u128, 3u16);
        // D s_4589_4: cmp-eq s_4589_1 s_4589_3
        let s_4589_4: bool = ((s_4589_1) == (s_4589_3));
        // D s_4589_5: write-var gs#135390 <= s_4589_4
        fn_state.gs_135390 = s_4589_4;
        // N s_4589_6: jump b2049
        return block_2049(state, tracer, fn_state);
    }
    fn block_4590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4590_0: read-var coproc:u8
        let s_4590_0: u8 = fn_state.coproc;
        // D s_4590_1: cast zx s_4590_0 -> bv
        let s_4590_1: Bits = Bits::new(s_4590_0 as u128, 4u16);
        // C s_4590_2: const #15u : u8
        let s_4590_2: u8 = 15;
        // C s_4590_3: cast zx s_4590_2 -> bv
        let s_4590_3: Bits = Bits::new(s_4590_2 as u128, 4u16);
        // D s_4590_4: cmp-eq s_4590_1 s_4590_3
        let s_4590_4: bool = ((s_4590_1) == (s_4590_3));
        // D s_4590_5: write-var gs#135389 <= s_4590_4
        fn_state.gs_135389 = s_4590_4;
        // N s_4590_6: jump b2047
        return block_2047(state, tracer, fn_state);
    }
    fn block_4591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4591_0: read-var CRn:u8
        let s_4591_0: u8 = fn_state.CRn;
        // D s_4591_1: cast zx s_4591_0 -> bv
        let s_4591_1: Bits = Bits::new(s_4591_0 as u128, 4u16);
        // C s_4591_2: const #12u : u8
        let s_4591_2: u8 = 12;
        // C s_4591_3: cast zx s_4591_2 -> bv
        let s_4591_3: Bits = Bits::new(s_4591_2 as u128, 4u16);
        // D s_4591_4: cmp-eq s_4591_1 s_4591_3
        let s_4591_4: bool = ((s_4591_1) == (s_4591_3));
        // D s_4591_5: write-var gs#135388 <= s_4591_4
        fn_state.gs_135388 = s_4591_4;
        // N s_4591_6: jump b2045
        return block_2045(state, tracer, fn_state);
    }
    fn block_4592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4592_0: read-var el:u8
        let s_4592_0: u8 = fn_state.el;
        // D s_4592_1: read-var coproc:u8
        let s_4592_1: u8 = fn_state.coproc;
        // D s_4592_2: read-var opc1:u8
        let s_4592_2: u8 = fn_state.opc1;
        // D s_4592_3: read-var CRn:u8
        let s_4592_3: u8 = fn_state.CRn;
        // D s_4592_4: read-var opc2:u8
        let s_4592_4: u8 = fn_state.opc2;
        // D s_4592_5: read-var CRm:u8
        let s_4592_5: u8 = fn_state.CRm;
        // D s_4592_6: read-var t:i
        let s_4592_6: i128 = fn_state.t;
        // D s_4592_7: call ICH_LR_SysRegWrite32_d1e236ff7c3dc751(s_4592_0, s_4592_1, s_4592_2, s_4592_3, s_4592_4, s_4592_5, s_4592_6)
        let s_4592_7: () = ICH_LR_SysRegWrite32_d1e236ff7c3dc751(
            state,
            tracer,
            s_4592_0,
            s_4592_1,
            s_4592_2,
            s_4592_3,
            s_4592_4,
            s_4592_5,
            s_4592_6,
        );
        // N s_4592_8: return
        return;
    }
    fn block_4593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4593_0: read-var opc2:u8
        let s_4593_0: u8 = fn_state.opc2;
        // D s_4593_1: cast zx s_4593_0 -> bv
        let s_4593_1: Bits = Bits::new(s_4593_0 as u128, 3u16);
        // C s_4593_2: const #5u : u8
        let s_4593_2: u8 = 5;
        // C s_4593_3: cast zx s_4593_2 -> bv
        let s_4593_3: Bits = Bits::new(s_4593_2 as u128, 3u16);
        // D s_4593_4: cmp-eq s_4593_1 s_4593_3
        let s_4593_4: bool = ((s_4593_1) == (s_4593_3));
        // D s_4593_5: write-var gs#135387 <= s_4593_4
        fn_state.gs_135387 = s_4593_4;
        // N s_4593_6: jump b2042
        return block_2042(state, tracer, fn_state);
    }
    fn block_4594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4594_0: read-var opc1:u8
        let s_4594_0: u8 = fn_state.opc1;
        // D s_4594_1: cast zx s_4594_0 -> bv
        let s_4594_1: Bits = Bits::new(s_4594_0 as u128, 3u16);
        // C s_4594_2: const #4u : u8
        let s_4594_2: u8 = 4;
        // C s_4594_3: cast zx s_4594_2 -> bv
        let s_4594_3: Bits = Bits::new(s_4594_2 as u128, 3u16);
        // D s_4594_4: cmp-eq s_4594_1 s_4594_3
        let s_4594_4: bool = ((s_4594_1) == (s_4594_3));
        // D s_4594_5: write-var gs#135386 <= s_4594_4
        fn_state.gs_135386 = s_4594_4;
        // N s_4594_6: jump b2040
        return block_2040(state, tracer, fn_state);
    }
    fn block_4595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4595_0: read-var coproc:u8
        let s_4595_0: u8 = fn_state.coproc;
        // D s_4595_1: cast zx s_4595_0 -> bv
        let s_4595_1: Bits = Bits::new(s_4595_0 as u128, 4u16);
        // C s_4595_2: const #15u : u8
        let s_4595_2: u8 = 15;
        // C s_4595_3: cast zx s_4595_2 -> bv
        let s_4595_3: Bits = Bits::new(s_4595_2 as u128, 4u16);
        // D s_4595_4: cmp-eq s_4595_1 s_4595_3
        let s_4595_4: bool = ((s_4595_1) == (s_4595_3));
        // D s_4595_5: write-var gs#135385 <= s_4595_4
        fn_state.gs_135385 = s_4595_4;
        // N s_4595_6: jump b2038
        return block_2038(state, tracer, fn_state);
    }
    fn block_4596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4596_0: read-var CRn:u8
        let s_4596_0: u8 = fn_state.CRn;
        // D s_4596_1: cast zx s_4596_0 -> bv
        let s_4596_1: Bits = Bits::new(s_4596_0 as u128, 4u16);
        // C s_4596_2: const #12u : u8
        let s_4596_2: u8 = 12;
        // C s_4596_3: cast zx s_4596_2 -> bv
        let s_4596_3: Bits = Bits::new(s_4596_2 as u128, 4u16);
        // D s_4596_4: cmp-eq s_4596_1 s_4596_3
        let s_4596_4: bool = ((s_4596_1) == (s_4596_3));
        // D s_4596_5: write-var gs#135384 <= s_4596_4
        fn_state.gs_135384 = s_4596_4;
        // N s_4596_6: jump b2036
        return block_2036(state, tracer, fn_state);
    }
    fn block_4597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4597_0: read-var el:u8
        let s_4597_0: u8 = fn_state.el;
        // D s_4597_1: read-var coproc:u8
        let s_4597_1: u8 = fn_state.coproc;
        // D s_4597_2: read-var opc1:u8
        let s_4597_2: u8 = fn_state.opc1;
        // D s_4597_3: read-var CRn:u8
        let s_4597_3: u8 = fn_state.CRn;
        // D s_4597_4: read-var opc2:u8
        let s_4597_4: u8 = fn_state.opc2;
        // D s_4597_5: read-var CRm:u8
        let s_4597_5: u8 = fn_state.CRm;
        // D s_4597_6: read-var t:i
        let s_4597_6: i128 = fn_state.t;
        // D s_4597_7: call ICH_LR_SysRegWrite32_eaa9053ceb4916d6(s_4597_0, s_4597_1, s_4597_2, s_4597_3, s_4597_4, s_4597_5, s_4597_6)
        let s_4597_7: () = ICH_LR_SysRegWrite32_eaa9053ceb4916d6(
            state,
            tracer,
            s_4597_0,
            s_4597_1,
            s_4597_2,
            s_4597_3,
            s_4597_4,
            s_4597_5,
            s_4597_6,
        );
        // N s_4597_8: return
        return;
    }
    fn block_4598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4598_0: read-var opc2:u8
        let s_4598_0: u8 = fn_state.opc2;
        // D s_4598_1: cast zx s_4598_0 -> bv
        let s_4598_1: Bits = Bits::new(s_4598_0 as u128, 3u16);
        // C s_4598_2: const #6u : u8
        let s_4598_2: u8 = 6;
        // C s_4598_3: cast zx s_4598_2 -> bv
        let s_4598_3: Bits = Bits::new(s_4598_2 as u128, 3u16);
        // D s_4598_4: cmp-eq s_4598_1 s_4598_3
        let s_4598_4: bool = ((s_4598_1) == (s_4598_3));
        // D s_4598_5: write-var gs#135383 <= s_4598_4
        fn_state.gs_135383 = s_4598_4;
        // N s_4598_6: jump b2033
        return block_2033(state, tracer, fn_state);
    }
    fn block_4599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4599_0: read-var opc1:u8
        let s_4599_0: u8 = fn_state.opc1;
        // D s_4599_1: cast zx s_4599_0 -> bv
        let s_4599_1: Bits = Bits::new(s_4599_0 as u128, 3u16);
        // C s_4599_2: const #4u : u8
        let s_4599_2: u8 = 4;
        // C s_4599_3: cast zx s_4599_2 -> bv
        let s_4599_3: Bits = Bits::new(s_4599_2 as u128, 3u16);
        // D s_4599_4: cmp-eq s_4599_1 s_4599_3
        let s_4599_4: bool = ((s_4599_1) == (s_4599_3));
        // D s_4599_5: write-var gs#135382 <= s_4599_4
        fn_state.gs_135382 = s_4599_4;
        // N s_4599_6: jump b2031
        return block_2031(state, tracer, fn_state);
    }
    fn block_4600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4600_0: read-var coproc:u8
        let s_4600_0: u8 = fn_state.coproc;
        // D s_4600_1: cast zx s_4600_0 -> bv
        let s_4600_1: Bits = Bits::new(s_4600_0 as u128, 4u16);
        // C s_4600_2: const #15u : u8
        let s_4600_2: u8 = 15;
        // C s_4600_3: cast zx s_4600_2 -> bv
        let s_4600_3: Bits = Bits::new(s_4600_2 as u128, 4u16);
        // D s_4600_4: cmp-eq s_4600_1 s_4600_3
        let s_4600_4: bool = ((s_4600_1) == (s_4600_3));
        // D s_4600_5: write-var gs#135381 <= s_4600_4
        fn_state.gs_135381 = s_4600_4;
        // N s_4600_6: jump b2029
        return block_2029(state, tracer, fn_state);
    }
    fn block_4601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4601_0: read-var CRn:u8
        let s_4601_0: u8 = fn_state.CRn;
        // D s_4601_1: cast zx s_4601_0 -> bv
        let s_4601_1: Bits = Bits::new(s_4601_0 as u128, 4u16);
        // C s_4601_2: const #12u : u8
        let s_4601_2: u8 = 12;
        // C s_4601_3: cast zx s_4601_2 -> bv
        let s_4601_3: Bits = Bits::new(s_4601_2 as u128, 4u16);
        // D s_4601_4: cmp-eq s_4601_1 s_4601_3
        let s_4601_4: bool = ((s_4601_1) == (s_4601_3));
        // D s_4601_5: write-var gs#135380 <= s_4601_4
        fn_state.gs_135380 = s_4601_4;
        // N s_4601_6: jump b2027
        return block_2027(state, tracer, fn_state);
    }
    fn block_4602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4602_0: read-var el:u8
        let s_4602_0: u8 = fn_state.el;
        // D s_4602_1: read-var coproc:u8
        let s_4602_1: u8 = fn_state.coproc;
        // D s_4602_2: read-var opc1:u8
        let s_4602_2: u8 = fn_state.opc1;
        // D s_4602_3: read-var CRn:u8
        let s_4602_3: u8 = fn_state.CRn;
        // D s_4602_4: read-var opc2:u8
        let s_4602_4: u8 = fn_state.opc2;
        // D s_4602_5: read-var CRm:u8
        let s_4602_5: u8 = fn_state.CRm;
        // D s_4602_6: read-var t:i
        let s_4602_6: i128 = fn_state.t;
        // D s_4602_7: call ICH_LR_SysRegWrite32_69f059200b508494(s_4602_0, s_4602_1, s_4602_2, s_4602_3, s_4602_4, s_4602_5, s_4602_6)
        let s_4602_7: () = ICH_LR_SysRegWrite32_69f059200b508494(
            state,
            tracer,
            s_4602_0,
            s_4602_1,
            s_4602_2,
            s_4602_3,
            s_4602_4,
            s_4602_5,
            s_4602_6,
        );
        // N s_4602_8: return
        return;
    }
    fn block_4603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4603_0: read-var opc2:u8
        let s_4603_0: u8 = fn_state.opc2;
        // D s_4603_1: cast zx s_4603_0 -> bv
        let s_4603_1: Bits = Bits::new(s_4603_0 as u128, 3u16);
        // C s_4603_2: const #7u : u8
        let s_4603_2: u8 = 7;
        // C s_4603_3: cast zx s_4603_2 -> bv
        let s_4603_3: Bits = Bits::new(s_4603_2 as u128, 3u16);
        // D s_4603_4: cmp-eq s_4603_1 s_4603_3
        let s_4603_4: bool = ((s_4603_1) == (s_4603_3));
        // D s_4603_5: write-var gs#135379 <= s_4603_4
        fn_state.gs_135379 = s_4603_4;
        // N s_4603_6: jump b2024
        return block_2024(state, tracer, fn_state);
    }
    fn block_4604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4604_0: read-var opc1:u8
        let s_4604_0: u8 = fn_state.opc1;
        // D s_4604_1: cast zx s_4604_0 -> bv
        let s_4604_1: Bits = Bits::new(s_4604_0 as u128, 3u16);
        // C s_4604_2: const #4u : u8
        let s_4604_2: u8 = 4;
        // C s_4604_3: cast zx s_4604_2 -> bv
        let s_4604_3: Bits = Bits::new(s_4604_2 as u128, 3u16);
        // D s_4604_4: cmp-eq s_4604_1 s_4604_3
        let s_4604_4: bool = ((s_4604_1) == (s_4604_3));
        // D s_4604_5: write-var gs#135378 <= s_4604_4
        fn_state.gs_135378 = s_4604_4;
        // N s_4604_6: jump b2022
        return block_2022(state, tracer, fn_state);
    }
    fn block_4605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4605_0: read-var coproc:u8
        let s_4605_0: u8 = fn_state.coproc;
        // D s_4605_1: cast zx s_4605_0 -> bv
        let s_4605_1: Bits = Bits::new(s_4605_0 as u128, 4u16);
        // C s_4605_2: const #15u : u8
        let s_4605_2: u8 = 15;
        // C s_4605_3: cast zx s_4605_2 -> bv
        let s_4605_3: Bits = Bits::new(s_4605_2 as u128, 4u16);
        // D s_4605_4: cmp-eq s_4605_1 s_4605_3
        let s_4605_4: bool = ((s_4605_1) == (s_4605_3));
        // D s_4605_5: write-var gs#135377 <= s_4605_4
        fn_state.gs_135377 = s_4605_4;
        // N s_4605_6: jump b2020
        return block_2020(state, tracer, fn_state);
    }
    fn block_4606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4606_0: read-var CRn:u8
        let s_4606_0: u8 = fn_state.CRn;
        // D s_4606_1: cast zx s_4606_0 -> bv
        let s_4606_1: Bits = Bits::new(s_4606_0 as u128, 4u16);
        // C s_4606_2: const #12u : u8
        let s_4606_2: u8 = 12;
        // C s_4606_3: cast zx s_4606_2 -> bv
        let s_4606_3: Bits = Bits::new(s_4606_2 as u128, 4u16);
        // D s_4606_4: cmp-eq s_4606_1 s_4606_3
        let s_4606_4: bool = ((s_4606_1) == (s_4606_3));
        // D s_4606_5: write-var gs#135376 <= s_4606_4
        fn_state.gs_135376 = s_4606_4;
        // N s_4606_6: jump b2018
        return block_2018(state, tracer, fn_state);
    }
    fn block_4607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4607_0: read-var el:u8
        let s_4607_0: u8 = fn_state.el;
        // D s_4607_1: read-var coproc:u8
        let s_4607_1: u8 = fn_state.coproc;
        // D s_4607_2: read-var opc1:u8
        let s_4607_2: u8 = fn_state.opc1;
        // D s_4607_3: read-var CRn:u8
        let s_4607_3: u8 = fn_state.CRn;
        // D s_4607_4: read-var opc2:u8
        let s_4607_4: u8 = fn_state.opc2;
        // D s_4607_5: read-var CRm:u8
        let s_4607_5: u8 = fn_state.CRm;
        // D s_4607_6: read-var t:i
        let s_4607_6: i128 = fn_state.t;
        // D s_4607_7: call ICH_LR_SysRegWrite32_721fa51d485f4b0a(s_4607_0, s_4607_1, s_4607_2, s_4607_3, s_4607_4, s_4607_5, s_4607_6)
        let s_4607_7: () = ICH_LR_SysRegWrite32_721fa51d485f4b0a(
            state,
            tracer,
            s_4607_0,
            s_4607_1,
            s_4607_2,
            s_4607_3,
            s_4607_4,
            s_4607_5,
            s_4607_6,
        );
        // N s_4607_8: return
        return;
    }
    fn block_4608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4608_0: read-var opc2:u8
        let s_4608_0: u8 = fn_state.opc2;
        // D s_4608_1: cast zx s_4608_0 -> bv
        let s_4608_1: Bits = Bits::new(s_4608_0 as u128, 3u16);
        // C s_4608_2: const #0u : u8
        let s_4608_2: u8 = 0;
        // C s_4608_3: cast zx s_4608_2 -> bv
        let s_4608_3: Bits = Bits::new(s_4608_2 as u128, 3u16);
        // D s_4608_4: cmp-eq s_4608_1 s_4608_3
        let s_4608_4: bool = ((s_4608_1) == (s_4608_3));
        // D s_4608_5: write-var gs#135375 <= s_4608_4
        fn_state.gs_135375 = s_4608_4;
        // N s_4608_6: jump b2015
        return block_2015(state, tracer, fn_state);
    }
    fn block_4609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4609_0: read-var opc1:u8
        let s_4609_0: u8 = fn_state.opc1;
        // D s_4609_1: cast zx s_4609_0 -> bv
        let s_4609_1: Bits = Bits::new(s_4609_0 as u128, 3u16);
        // C s_4609_2: const #4u : u8
        let s_4609_2: u8 = 4;
        // C s_4609_3: cast zx s_4609_2 -> bv
        let s_4609_3: Bits = Bits::new(s_4609_2 as u128, 3u16);
        // D s_4609_4: cmp-eq s_4609_1 s_4609_3
        let s_4609_4: bool = ((s_4609_1) == (s_4609_3));
        // D s_4609_5: write-var gs#135374 <= s_4609_4
        fn_state.gs_135374 = s_4609_4;
        // N s_4609_6: jump b2013
        return block_2013(state, tracer, fn_state);
    }
    fn block_4610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4610_0: read-var coproc:u8
        let s_4610_0: u8 = fn_state.coproc;
        // D s_4610_1: cast zx s_4610_0 -> bv
        let s_4610_1: Bits = Bits::new(s_4610_0 as u128, 4u16);
        // C s_4610_2: const #15u : u8
        let s_4610_2: u8 = 15;
        // C s_4610_3: cast zx s_4610_2 -> bv
        let s_4610_3: Bits = Bits::new(s_4610_2 as u128, 4u16);
        // D s_4610_4: cmp-eq s_4610_1 s_4610_3
        let s_4610_4: bool = ((s_4610_1) == (s_4610_3));
        // D s_4610_5: write-var gs#135373 <= s_4610_4
        fn_state.gs_135373 = s_4610_4;
        // N s_4610_6: jump b2011
        return block_2011(state, tracer, fn_state);
    }
    fn block_4611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4611_0: read-var CRn:u8
        let s_4611_0: u8 = fn_state.CRn;
        // D s_4611_1: cast zx s_4611_0 -> bv
        let s_4611_1: Bits = Bits::new(s_4611_0 as u128, 4u16);
        // C s_4611_2: const #12u : u8
        let s_4611_2: u8 = 12;
        // C s_4611_3: cast zx s_4611_2 -> bv
        let s_4611_3: Bits = Bits::new(s_4611_2 as u128, 4u16);
        // D s_4611_4: cmp-eq s_4611_1 s_4611_3
        let s_4611_4: bool = ((s_4611_1) == (s_4611_3));
        // D s_4611_5: write-var gs#135372 <= s_4611_4
        fn_state.gs_135372 = s_4611_4;
        // N s_4611_6: jump b2009
        return block_2009(state, tracer, fn_state);
    }
    fn block_4612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4612_0: read-var el:u8
        let s_4612_0: u8 = fn_state.el;
        // D s_4612_1: read-var coproc:u8
        let s_4612_1: u8 = fn_state.coproc;
        // D s_4612_2: read-var opc1:u8
        let s_4612_2: u8 = fn_state.opc1;
        // D s_4612_3: read-var CRn:u8
        let s_4612_3: u8 = fn_state.CRn;
        // D s_4612_4: read-var opc2:u8
        let s_4612_4: u8 = fn_state.opc2;
        // D s_4612_5: read-var CRm:u8
        let s_4612_5: u8 = fn_state.CRm;
        // D s_4612_6: read-var t:i
        let s_4612_6: i128 = fn_state.t;
        // D s_4612_7: call ICH_LR_SysRegWrite32_514fb9fa160b7dee(s_4612_0, s_4612_1, s_4612_2, s_4612_3, s_4612_4, s_4612_5, s_4612_6)
        let s_4612_7: () = ICH_LR_SysRegWrite32_514fb9fa160b7dee(
            state,
            tracer,
            s_4612_0,
            s_4612_1,
            s_4612_2,
            s_4612_3,
            s_4612_4,
            s_4612_5,
            s_4612_6,
        );
        // N s_4612_8: return
        return;
    }
    fn block_4613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4613_0: read-var opc2:u8
        let s_4613_0: u8 = fn_state.opc2;
        // D s_4613_1: cast zx s_4613_0 -> bv
        let s_4613_1: Bits = Bits::new(s_4613_0 as u128, 3u16);
        // C s_4613_2: const #1u : u8
        let s_4613_2: u8 = 1;
        // C s_4613_3: cast zx s_4613_2 -> bv
        let s_4613_3: Bits = Bits::new(s_4613_2 as u128, 3u16);
        // D s_4613_4: cmp-eq s_4613_1 s_4613_3
        let s_4613_4: bool = ((s_4613_1) == (s_4613_3));
        // D s_4613_5: write-var gs#135371 <= s_4613_4
        fn_state.gs_135371 = s_4613_4;
        // N s_4613_6: jump b2006
        return block_2006(state, tracer, fn_state);
    }
    fn block_4614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4614_0: read-var opc1:u8
        let s_4614_0: u8 = fn_state.opc1;
        // D s_4614_1: cast zx s_4614_0 -> bv
        let s_4614_1: Bits = Bits::new(s_4614_0 as u128, 3u16);
        // C s_4614_2: const #4u : u8
        let s_4614_2: u8 = 4;
        // C s_4614_3: cast zx s_4614_2 -> bv
        let s_4614_3: Bits = Bits::new(s_4614_2 as u128, 3u16);
        // D s_4614_4: cmp-eq s_4614_1 s_4614_3
        let s_4614_4: bool = ((s_4614_1) == (s_4614_3));
        // D s_4614_5: write-var gs#135370 <= s_4614_4
        fn_state.gs_135370 = s_4614_4;
        // N s_4614_6: jump b2004
        return block_2004(state, tracer, fn_state);
    }
    fn block_4615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4615_0: read-var coproc:u8
        let s_4615_0: u8 = fn_state.coproc;
        // D s_4615_1: cast zx s_4615_0 -> bv
        let s_4615_1: Bits = Bits::new(s_4615_0 as u128, 4u16);
        // C s_4615_2: const #15u : u8
        let s_4615_2: u8 = 15;
        // C s_4615_3: cast zx s_4615_2 -> bv
        let s_4615_3: Bits = Bits::new(s_4615_2 as u128, 4u16);
        // D s_4615_4: cmp-eq s_4615_1 s_4615_3
        let s_4615_4: bool = ((s_4615_1) == (s_4615_3));
        // D s_4615_5: write-var gs#135369 <= s_4615_4
        fn_state.gs_135369 = s_4615_4;
        // N s_4615_6: jump b2002
        return block_2002(state, tracer, fn_state);
    }
    fn block_4616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4616_0: read-var CRn:u8
        let s_4616_0: u8 = fn_state.CRn;
        // D s_4616_1: cast zx s_4616_0 -> bv
        let s_4616_1: Bits = Bits::new(s_4616_0 as u128, 4u16);
        // C s_4616_2: const #12u : u8
        let s_4616_2: u8 = 12;
        // C s_4616_3: cast zx s_4616_2 -> bv
        let s_4616_3: Bits = Bits::new(s_4616_2 as u128, 4u16);
        // D s_4616_4: cmp-eq s_4616_1 s_4616_3
        let s_4616_4: bool = ((s_4616_1) == (s_4616_3));
        // D s_4616_5: write-var gs#135368 <= s_4616_4
        fn_state.gs_135368 = s_4616_4;
        // N s_4616_6: jump b2000
        return block_2000(state, tracer, fn_state);
    }
    fn block_4617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4617_0: read-var el:u8
        let s_4617_0: u8 = fn_state.el;
        // D s_4617_1: read-var coproc:u8
        let s_4617_1: u8 = fn_state.coproc;
        // D s_4617_2: read-var opc1:u8
        let s_4617_2: u8 = fn_state.opc1;
        // D s_4617_3: read-var CRn:u8
        let s_4617_3: u8 = fn_state.CRn;
        // D s_4617_4: read-var opc2:u8
        let s_4617_4: u8 = fn_state.opc2;
        // D s_4617_5: read-var CRm:u8
        let s_4617_5: u8 = fn_state.CRm;
        // D s_4617_6: read-var t:i
        let s_4617_6: i128 = fn_state.t;
        // D s_4617_7: call ICH_LR_SysRegWrite32_c3bfb21b3a349563(s_4617_0, s_4617_1, s_4617_2, s_4617_3, s_4617_4, s_4617_5, s_4617_6)
        let s_4617_7: () = ICH_LR_SysRegWrite32_c3bfb21b3a349563(
            state,
            tracer,
            s_4617_0,
            s_4617_1,
            s_4617_2,
            s_4617_3,
            s_4617_4,
            s_4617_5,
            s_4617_6,
        );
        // N s_4617_8: return
        return;
    }
    fn block_4618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4618_0: read-var opc2:u8
        let s_4618_0: u8 = fn_state.opc2;
        // D s_4618_1: cast zx s_4618_0 -> bv
        let s_4618_1: Bits = Bits::new(s_4618_0 as u128, 3u16);
        // C s_4618_2: const #2u : u8
        let s_4618_2: u8 = 2;
        // C s_4618_3: cast zx s_4618_2 -> bv
        let s_4618_3: Bits = Bits::new(s_4618_2 as u128, 3u16);
        // D s_4618_4: cmp-eq s_4618_1 s_4618_3
        let s_4618_4: bool = ((s_4618_1) == (s_4618_3));
        // D s_4618_5: write-var gs#135367 <= s_4618_4
        fn_state.gs_135367 = s_4618_4;
        // N s_4618_6: jump b1997
        return block_1997(state, tracer, fn_state);
    }
    fn block_4619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4619_0: read-var opc1:u8
        let s_4619_0: u8 = fn_state.opc1;
        // D s_4619_1: cast zx s_4619_0 -> bv
        let s_4619_1: Bits = Bits::new(s_4619_0 as u128, 3u16);
        // C s_4619_2: const #4u : u8
        let s_4619_2: u8 = 4;
        // C s_4619_3: cast zx s_4619_2 -> bv
        let s_4619_3: Bits = Bits::new(s_4619_2 as u128, 3u16);
        // D s_4619_4: cmp-eq s_4619_1 s_4619_3
        let s_4619_4: bool = ((s_4619_1) == (s_4619_3));
        // D s_4619_5: write-var gs#135366 <= s_4619_4
        fn_state.gs_135366 = s_4619_4;
        // N s_4619_6: jump b1995
        return block_1995(state, tracer, fn_state);
    }
    fn block_4620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4620_0: read-var coproc:u8
        let s_4620_0: u8 = fn_state.coproc;
        // D s_4620_1: cast zx s_4620_0 -> bv
        let s_4620_1: Bits = Bits::new(s_4620_0 as u128, 4u16);
        // C s_4620_2: const #15u : u8
        let s_4620_2: u8 = 15;
        // C s_4620_3: cast zx s_4620_2 -> bv
        let s_4620_3: Bits = Bits::new(s_4620_2 as u128, 4u16);
        // D s_4620_4: cmp-eq s_4620_1 s_4620_3
        let s_4620_4: bool = ((s_4620_1) == (s_4620_3));
        // D s_4620_5: write-var gs#135365 <= s_4620_4
        fn_state.gs_135365 = s_4620_4;
        // N s_4620_6: jump b1993
        return block_1993(state, tracer, fn_state);
    }
    fn block_4621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4621_0: read-var CRn:u8
        let s_4621_0: u8 = fn_state.CRn;
        // D s_4621_1: cast zx s_4621_0 -> bv
        let s_4621_1: Bits = Bits::new(s_4621_0 as u128, 4u16);
        // C s_4621_2: const #12u : u8
        let s_4621_2: u8 = 12;
        // C s_4621_3: cast zx s_4621_2 -> bv
        let s_4621_3: Bits = Bits::new(s_4621_2 as u128, 4u16);
        // D s_4621_4: cmp-eq s_4621_1 s_4621_3
        let s_4621_4: bool = ((s_4621_1) == (s_4621_3));
        // D s_4621_5: write-var gs#135364 <= s_4621_4
        fn_state.gs_135364 = s_4621_4;
        // N s_4621_6: jump b1991
        return block_1991(state, tracer, fn_state);
    }
    fn block_4622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4622_0: read-var el:u8
        let s_4622_0: u8 = fn_state.el;
        // D s_4622_1: read-var coproc:u8
        let s_4622_1: u8 = fn_state.coproc;
        // D s_4622_2: read-var opc1:u8
        let s_4622_2: u8 = fn_state.opc1;
        // D s_4622_3: read-var CRn:u8
        let s_4622_3: u8 = fn_state.CRn;
        // D s_4622_4: read-var opc2:u8
        let s_4622_4: u8 = fn_state.opc2;
        // D s_4622_5: read-var CRm:u8
        let s_4622_5: u8 = fn_state.CRm;
        // D s_4622_6: read-var t:i
        let s_4622_6: i128 = fn_state.t;
        // D s_4622_7: call ICH_LR_SysRegWrite32_f689ea0e1ff8a941(s_4622_0, s_4622_1, s_4622_2, s_4622_3, s_4622_4, s_4622_5, s_4622_6)
        let s_4622_7: () = ICH_LR_SysRegWrite32_f689ea0e1ff8a941(
            state,
            tracer,
            s_4622_0,
            s_4622_1,
            s_4622_2,
            s_4622_3,
            s_4622_4,
            s_4622_5,
            s_4622_6,
        );
        // N s_4622_8: return
        return;
    }
    fn block_4623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4623_0: read-var opc2:u8
        let s_4623_0: u8 = fn_state.opc2;
        // D s_4623_1: cast zx s_4623_0 -> bv
        let s_4623_1: Bits = Bits::new(s_4623_0 as u128, 3u16);
        // C s_4623_2: const #3u : u8
        let s_4623_2: u8 = 3;
        // C s_4623_3: cast zx s_4623_2 -> bv
        let s_4623_3: Bits = Bits::new(s_4623_2 as u128, 3u16);
        // D s_4623_4: cmp-eq s_4623_1 s_4623_3
        let s_4623_4: bool = ((s_4623_1) == (s_4623_3));
        // D s_4623_5: write-var gs#135363 <= s_4623_4
        fn_state.gs_135363 = s_4623_4;
        // N s_4623_6: jump b1988
        return block_1988(state, tracer, fn_state);
    }
    fn block_4624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4624_0: read-var opc1:u8
        let s_4624_0: u8 = fn_state.opc1;
        // D s_4624_1: cast zx s_4624_0 -> bv
        let s_4624_1: Bits = Bits::new(s_4624_0 as u128, 3u16);
        // C s_4624_2: const #4u : u8
        let s_4624_2: u8 = 4;
        // C s_4624_3: cast zx s_4624_2 -> bv
        let s_4624_3: Bits = Bits::new(s_4624_2 as u128, 3u16);
        // D s_4624_4: cmp-eq s_4624_1 s_4624_3
        let s_4624_4: bool = ((s_4624_1) == (s_4624_3));
        // D s_4624_5: write-var gs#135362 <= s_4624_4
        fn_state.gs_135362 = s_4624_4;
        // N s_4624_6: jump b1986
        return block_1986(state, tracer, fn_state);
    }
    fn block_4625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4625_0: read-var coproc:u8
        let s_4625_0: u8 = fn_state.coproc;
        // D s_4625_1: cast zx s_4625_0 -> bv
        let s_4625_1: Bits = Bits::new(s_4625_0 as u128, 4u16);
        // C s_4625_2: const #15u : u8
        let s_4625_2: u8 = 15;
        // C s_4625_3: cast zx s_4625_2 -> bv
        let s_4625_3: Bits = Bits::new(s_4625_2 as u128, 4u16);
        // D s_4625_4: cmp-eq s_4625_1 s_4625_3
        let s_4625_4: bool = ((s_4625_1) == (s_4625_3));
        // D s_4625_5: write-var gs#135361 <= s_4625_4
        fn_state.gs_135361 = s_4625_4;
        // N s_4625_6: jump b1984
        return block_1984(state, tracer, fn_state);
    }
    fn block_4626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4626_0: read-var CRn:u8
        let s_4626_0: u8 = fn_state.CRn;
        // D s_4626_1: cast zx s_4626_0 -> bv
        let s_4626_1: Bits = Bits::new(s_4626_0 as u128, 4u16);
        // C s_4626_2: const #12u : u8
        let s_4626_2: u8 = 12;
        // C s_4626_3: cast zx s_4626_2 -> bv
        let s_4626_3: Bits = Bits::new(s_4626_2 as u128, 4u16);
        // D s_4626_4: cmp-eq s_4626_1 s_4626_3
        let s_4626_4: bool = ((s_4626_1) == (s_4626_3));
        // D s_4626_5: write-var gs#135360 <= s_4626_4
        fn_state.gs_135360 = s_4626_4;
        // N s_4626_6: jump b1982
        return block_1982(state, tracer, fn_state);
    }
    fn block_4627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4627_0: read-var el:u8
        let s_4627_0: u8 = fn_state.el;
        // D s_4627_1: read-var coproc:u8
        let s_4627_1: u8 = fn_state.coproc;
        // D s_4627_2: read-var opc1:u8
        let s_4627_2: u8 = fn_state.opc1;
        // D s_4627_3: read-var CRn:u8
        let s_4627_3: u8 = fn_state.CRn;
        // D s_4627_4: read-var opc2:u8
        let s_4627_4: u8 = fn_state.opc2;
        // D s_4627_5: read-var CRm:u8
        let s_4627_5: u8 = fn_state.CRm;
        // D s_4627_6: read-var t:i
        let s_4627_6: i128 = fn_state.t;
        // D s_4627_7: call ICH_LR_SysRegWrite32_8da50c378e183c13(s_4627_0, s_4627_1, s_4627_2, s_4627_3, s_4627_4, s_4627_5, s_4627_6)
        let s_4627_7: () = ICH_LR_SysRegWrite32_8da50c378e183c13(
            state,
            tracer,
            s_4627_0,
            s_4627_1,
            s_4627_2,
            s_4627_3,
            s_4627_4,
            s_4627_5,
            s_4627_6,
        );
        // N s_4627_8: return
        return;
    }
    fn block_4628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4628_0: read-var opc2:u8
        let s_4628_0: u8 = fn_state.opc2;
        // D s_4628_1: cast zx s_4628_0 -> bv
        let s_4628_1: Bits = Bits::new(s_4628_0 as u128, 3u16);
        // C s_4628_2: const #4u : u8
        let s_4628_2: u8 = 4;
        // C s_4628_3: cast zx s_4628_2 -> bv
        let s_4628_3: Bits = Bits::new(s_4628_2 as u128, 3u16);
        // D s_4628_4: cmp-eq s_4628_1 s_4628_3
        let s_4628_4: bool = ((s_4628_1) == (s_4628_3));
        // D s_4628_5: write-var gs#135359 <= s_4628_4
        fn_state.gs_135359 = s_4628_4;
        // N s_4628_6: jump b1979
        return block_1979(state, tracer, fn_state);
    }
    fn block_4629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4629_0: read-var opc1:u8
        let s_4629_0: u8 = fn_state.opc1;
        // D s_4629_1: cast zx s_4629_0 -> bv
        let s_4629_1: Bits = Bits::new(s_4629_0 as u128, 3u16);
        // C s_4629_2: const #4u : u8
        let s_4629_2: u8 = 4;
        // C s_4629_3: cast zx s_4629_2 -> bv
        let s_4629_3: Bits = Bits::new(s_4629_2 as u128, 3u16);
        // D s_4629_4: cmp-eq s_4629_1 s_4629_3
        let s_4629_4: bool = ((s_4629_1) == (s_4629_3));
        // D s_4629_5: write-var gs#135358 <= s_4629_4
        fn_state.gs_135358 = s_4629_4;
        // N s_4629_6: jump b1977
        return block_1977(state, tracer, fn_state);
    }
    fn block_4630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4630_0: read-var coproc:u8
        let s_4630_0: u8 = fn_state.coproc;
        // D s_4630_1: cast zx s_4630_0 -> bv
        let s_4630_1: Bits = Bits::new(s_4630_0 as u128, 4u16);
        // C s_4630_2: const #15u : u8
        let s_4630_2: u8 = 15;
        // C s_4630_3: cast zx s_4630_2 -> bv
        let s_4630_3: Bits = Bits::new(s_4630_2 as u128, 4u16);
        // D s_4630_4: cmp-eq s_4630_1 s_4630_3
        let s_4630_4: bool = ((s_4630_1) == (s_4630_3));
        // D s_4630_5: write-var gs#135357 <= s_4630_4
        fn_state.gs_135357 = s_4630_4;
        // N s_4630_6: jump b1975
        return block_1975(state, tracer, fn_state);
    }
    fn block_4631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4631_0: read-var CRn:u8
        let s_4631_0: u8 = fn_state.CRn;
        // D s_4631_1: cast zx s_4631_0 -> bv
        let s_4631_1: Bits = Bits::new(s_4631_0 as u128, 4u16);
        // C s_4631_2: const #12u : u8
        let s_4631_2: u8 = 12;
        // C s_4631_3: cast zx s_4631_2 -> bv
        let s_4631_3: Bits = Bits::new(s_4631_2 as u128, 4u16);
        // D s_4631_4: cmp-eq s_4631_1 s_4631_3
        let s_4631_4: bool = ((s_4631_1) == (s_4631_3));
        // D s_4631_5: write-var gs#135356 <= s_4631_4
        fn_state.gs_135356 = s_4631_4;
        // N s_4631_6: jump b1973
        return block_1973(state, tracer, fn_state);
    }
    fn block_4632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4632_0: read-var el:u8
        let s_4632_0: u8 = fn_state.el;
        // D s_4632_1: read-var coproc:u8
        let s_4632_1: u8 = fn_state.coproc;
        // D s_4632_2: read-var opc1:u8
        let s_4632_2: u8 = fn_state.opc1;
        // D s_4632_3: read-var CRn:u8
        let s_4632_3: u8 = fn_state.CRn;
        // D s_4632_4: read-var opc2:u8
        let s_4632_4: u8 = fn_state.opc2;
        // D s_4632_5: read-var CRm:u8
        let s_4632_5: u8 = fn_state.CRm;
        // D s_4632_6: read-var t:i
        let s_4632_6: i128 = fn_state.t;
        // D s_4632_7: call ICH_LR_SysRegWrite32_a7e50c74ffa894c4(s_4632_0, s_4632_1, s_4632_2, s_4632_3, s_4632_4, s_4632_5, s_4632_6)
        let s_4632_7: () = ICH_LR_SysRegWrite32_a7e50c74ffa894c4(
            state,
            tracer,
            s_4632_0,
            s_4632_1,
            s_4632_2,
            s_4632_3,
            s_4632_4,
            s_4632_5,
            s_4632_6,
        );
        // N s_4632_8: return
        return;
    }
    fn block_4633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4633_0: read-var opc2:u8
        let s_4633_0: u8 = fn_state.opc2;
        // D s_4633_1: cast zx s_4633_0 -> bv
        let s_4633_1: Bits = Bits::new(s_4633_0 as u128, 3u16);
        // C s_4633_2: const #5u : u8
        let s_4633_2: u8 = 5;
        // C s_4633_3: cast zx s_4633_2 -> bv
        let s_4633_3: Bits = Bits::new(s_4633_2 as u128, 3u16);
        // D s_4633_4: cmp-eq s_4633_1 s_4633_3
        let s_4633_4: bool = ((s_4633_1) == (s_4633_3));
        // D s_4633_5: write-var gs#135355 <= s_4633_4
        fn_state.gs_135355 = s_4633_4;
        // N s_4633_6: jump b1970
        return block_1970(state, tracer, fn_state);
    }
    fn block_4634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4634_0: read-var opc1:u8
        let s_4634_0: u8 = fn_state.opc1;
        // D s_4634_1: cast zx s_4634_0 -> bv
        let s_4634_1: Bits = Bits::new(s_4634_0 as u128, 3u16);
        // C s_4634_2: const #4u : u8
        let s_4634_2: u8 = 4;
        // C s_4634_3: cast zx s_4634_2 -> bv
        let s_4634_3: Bits = Bits::new(s_4634_2 as u128, 3u16);
        // D s_4634_4: cmp-eq s_4634_1 s_4634_3
        let s_4634_4: bool = ((s_4634_1) == (s_4634_3));
        // D s_4634_5: write-var gs#135354 <= s_4634_4
        fn_state.gs_135354 = s_4634_4;
        // N s_4634_6: jump b1968
        return block_1968(state, tracer, fn_state);
    }
    fn block_4635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4635_0: read-var coproc:u8
        let s_4635_0: u8 = fn_state.coproc;
        // D s_4635_1: cast zx s_4635_0 -> bv
        let s_4635_1: Bits = Bits::new(s_4635_0 as u128, 4u16);
        // C s_4635_2: const #15u : u8
        let s_4635_2: u8 = 15;
        // C s_4635_3: cast zx s_4635_2 -> bv
        let s_4635_3: Bits = Bits::new(s_4635_2 as u128, 4u16);
        // D s_4635_4: cmp-eq s_4635_1 s_4635_3
        let s_4635_4: bool = ((s_4635_1) == (s_4635_3));
        // D s_4635_5: write-var gs#135353 <= s_4635_4
        fn_state.gs_135353 = s_4635_4;
        // N s_4635_6: jump b1966
        return block_1966(state, tracer, fn_state);
    }
    fn block_4636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4636_0: read-var CRn:u8
        let s_4636_0: u8 = fn_state.CRn;
        // D s_4636_1: cast zx s_4636_0 -> bv
        let s_4636_1: Bits = Bits::new(s_4636_0 as u128, 4u16);
        // C s_4636_2: const #12u : u8
        let s_4636_2: u8 = 12;
        // C s_4636_3: cast zx s_4636_2 -> bv
        let s_4636_3: Bits = Bits::new(s_4636_2 as u128, 4u16);
        // D s_4636_4: cmp-eq s_4636_1 s_4636_3
        let s_4636_4: bool = ((s_4636_1) == (s_4636_3));
        // D s_4636_5: write-var gs#135352 <= s_4636_4
        fn_state.gs_135352 = s_4636_4;
        // N s_4636_6: jump b1964
        return block_1964(state, tracer, fn_state);
    }
    fn block_4637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4637_0: read-var el:u8
        let s_4637_0: u8 = fn_state.el;
        // D s_4637_1: read-var coproc:u8
        let s_4637_1: u8 = fn_state.coproc;
        // D s_4637_2: read-var opc1:u8
        let s_4637_2: u8 = fn_state.opc1;
        // D s_4637_3: read-var CRn:u8
        let s_4637_3: u8 = fn_state.CRn;
        // D s_4637_4: read-var opc2:u8
        let s_4637_4: u8 = fn_state.opc2;
        // D s_4637_5: read-var CRm:u8
        let s_4637_5: u8 = fn_state.CRm;
        // D s_4637_6: read-var t:i
        let s_4637_6: i128 = fn_state.t;
        // D s_4637_7: call ICH_LR_SysRegWrite32_9a10116a6dad894d(s_4637_0, s_4637_1, s_4637_2, s_4637_3, s_4637_4, s_4637_5, s_4637_6)
        let s_4637_7: () = ICH_LR_SysRegWrite32_9a10116a6dad894d(
            state,
            tracer,
            s_4637_0,
            s_4637_1,
            s_4637_2,
            s_4637_3,
            s_4637_4,
            s_4637_5,
            s_4637_6,
        );
        // N s_4637_8: return
        return;
    }
    fn block_4638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4638_0: read-var opc2:u8
        let s_4638_0: u8 = fn_state.opc2;
        // D s_4638_1: cast zx s_4638_0 -> bv
        let s_4638_1: Bits = Bits::new(s_4638_0 as u128, 3u16);
        // C s_4638_2: const #6u : u8
        let s_4638_2: u8 = 6;
        // C s_4638_3: cast zx s_4638_2 -> bv
        let s_4638_3: Bits = Bits::new(s_4638_2 as u128, 3u16);
        // D s_4638_4: cmp-eq s_4638_1 s_4638_3
        let s_4638_4: bool = ((s_4638_1) == (s_4638_3));
        // D s_4638_5: write-var gs#135351 <= s_4638_4
        fn_state.gs_135351 = s_4638_4;
        // N s_4638_6: jump b1961
        return block_1961(state, tracer, fn_state);
    }
    fn block_4639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4639_0: read-var opc1:u8
        let s_4639_0: u8 = fn_state.opc1;
        // D s_4639_1: cast zx s_4639_0 -> bv
        let s_4639_1: Bits = Bits::new(s_4639_0 as u128, 3u16);
        // C s_4639_2: const #4u : u8
        let s_4639_2: u8 = 4;
        // C s_4639_3: cast zx s_4639_2 -> bv
        let s_4639_3: Bits = Bits::new(s_4639_2 as u128, 3u16);
        // D s_4639_4: cmp-eq s_4639_1 s_4639_3
        let s_4639_4: bool = ((s_4639_1) == (s_4639_3));
        // D s_4639_5: write-var gs#135350 <= s_4639_4
        fn_state.gs_135350 = s_4639_4;
        // N s_4639_6: jump b1959
        return block_1959(state, tracer, fn_state);
    }
    fn block_4640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4640_0: read-var coproc:u8
        let s_4640_0: u8 = fn_state.coproc;
        // D s_4640_1: cast zx s_4640_0 -> bv
        let s_4640_1: Bits = Bits::new(s_4640_0 as u128, 4u16);
        // C s_4640_2: const #15u : u8
        let s_4640_2: u8 = 15;
        // C s_4640_3: cast zx s_4640_2 -> bv
        let s_4640_3: Bits = Bits::new(s_4640_2 as u128, 4u16);
        // D s_4640_4: cmp-eq s_4640_1 s_4640_3
        let s_4640_4: bool = ((s_4640_1) == (s_4640_3));
        // D s_4640_5: write-var gs#135349 <= s_4640_4
        fn_state.gs_135349 = s_4640_4;
        // N s_4640_6: jump b1957
        return block_1957(state, tracer, fn_state);
    }
    fn block_4641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4641_0: read-var CRn:u8
        let s_4641_0: u8 = fn_state.CRn;
        // D s_4641_1: cast zx s_4641_0 -> bv
        let s_4641_1: Bits = Bits::new(s_4641_0 as u128, 4u16);
        // C s_4641_2: const #12u : u8
        let s_4641_2: u8 = 12;
        // C s_4641_3: cast zx s_4641_2 -> bv
        let s_4641_3: Bits = Bits::new(s_4641_2 as u128, 4u16);
        // D s_4641_4: cmp-eq s_4641_1 s_4641_3
        let s_4641_4: bool = ((s_4641_1) == (s_4641_3));
        // D s_4641_5: write-var gs#135348 <= s_4641_4
        fn_state.gs_135348 = s_4641_4;
        // N s_4641_6: jump b1955
        return block_1955(state, tracer, fn_state);
    }
    fn block_4642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4642_0: read-var el:u8
        let s_4642_0: u8 = fn_state.el;
        // D s_4642_1: read-var coproc:u8
        let s_4642_1: u8 = fn_state.coproc;
        // D s_4642_2: read-var opc1:u8
        let s_4642_2: u8 = fn_state.opc1;
        // D s_4642_3: read-var CRn:u8
        let s_4642_3: u8 = fn_state.CRn;
        // D s_4642_4: read-var opc2:u8
        let s_4642_4: u8 = fn_state.opc2;
        // D s_4642_5: read-var CRm:u8
        let s_4642_5: u8 = fn_state.CRm;
        // D s_4642_6: read-var t:i
        let s_4642_6: i128 = fn_state.t;
        // D s_4642_7: call ICH_LR_SysRegWrite32_2e1b19b394d8f1f7(s_4642_0, s_4642_1, s_4642_2, s_4642_3, s_4642_4, s_4642_5, s_4642_6)
        let s_4642_7: () = ICH_LR_SysRegWrite32_2e1b19b394d8f1f7(
            state,
            tracer,
            s_4642_0,
            s_4642_1,
            s_4642_2,
            s_4642_3,
            s_4642_4,
            s_4642_5,
            s_4642_6,
        );
        // N s_4642_8: return
        return;
    }
    fn block_4643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4643_0: read-var opc2:u8
        let s_4643_0: u8 = fn_state.opc2;
        // D s_4643_1: cast zx s_4643_0 -> bv
        let s_4643_1: Bits = Bits::new(s_4643_0 as u128, 3u16);
        // C s_4643_2: const #7u : u8
        let s_4643_2: u8 = 7;
        // C s_4643_3: cast zx s_4643_2 -> bv
        let s_4643_3: Bits = Bits::new(s_4643_2 as u128, 3u16);
        // D s_4643_4: cmp-eq s_4643_1 s_4643_3
        let s_4643_4: bool = ((s_4643_1) == (s_4643_3));
        // D s_4643_5: write-var gs#135347 <= s_4643_4
        fn_state.gs_135347 = s_4643_4;
        // N s_4643_6: jump b1952
        return block_1952(state, tracer, fn_state);
    }
    fn block_4644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4644_0: read-var opc1:u8
        let s_4644_0: u8 = fn_state.opc1;
        // D s_4644_1: cast zx s_4644_0 -> bv
        let s_4644_1: Bits = Bits::new(s_4644_0 as u128, 3u16);
        // C s_4644_2: const #4u : u8
        let s_4644_2: u8 = 4;
        // C s_4644_3: cast zx s_4644_2 -> bv
        let s_4644_3: Bits = Bits::new(s_4644_2 as u128, 3u16);
        // D s_4644_4: cmp-eq s_4644_1 s_4644_3
        let s_4644_4: bool = ((s_4644_1) == (s_4644_3));
        // D s_4644_5: write-var gs#135346 <= s_4644_4
        fn_state.gs_135346 = s_4644_4;
        // N s_4644_6: jump b1950
        return block_1950(state, tracer, fn_state);
    }
    fn block_4645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4645_0: read-var coproc:u8
        let s_4645_0: u8 = fn_state.coproc;
        // D s_4645_1: cast zx s_4645_0 -> bv
        let s_4645_1: Bits = Bits::new(s_4645_0 as u128, 4u16);
        // C s_4645_2: const #15u : u8
        let s_4645_2: u8 = 15;
        // C s_4645_3: cast zx s_4645_2 -> bv
        let s_4645_3: Bits = Bits::new(s_4645_2 as u128, 4u16);
        // D s_4645_4: cmp-eq s_4645_1 s_4645_3
        let s_4645_4: bool = ((s_4645_1) == (s_4645_3));
        // D s_4645_5: write-var gs#135345 <= s_4645_4
        fn_state.gs_135345 = s_4645_4;
        // N s_4645_6: jump b1948
        return block_1948(state, tracer, fn_state);
    }
    fn block_4646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4646_0: read-var CRn:u8
        let s_4646_0: u8 = fn_state.CRn;
        // D s_4646_1: cast zx s_4646_0 -> bv
        let s_4646_1: Bits = Bits::new(s_4646_0 as u128, 4u16);
        // C s_4646_2: const #12u : u8
        let s_4646_2: u8 = 12;
        // C s_4646_3: cast zx s_4646_2 -> bv
        let s_4646_3: Bits = Bits::new(s_4646_2 as u128, 4u16);
        // D s_4646_4: cmp-eq s_4646_1 s_4646_3
        let s_4646_4: bool = ((s_4646_1) == (s_4646_3));
        // D s_4646_5: write-var gs#135344 <= s_4646_4
        fn_state.gs_135344 = s_4646_4;
        // N s_4646_6: jump b1946
        return block_1946(state, tracer, fn_state);
    }
    fn block_4647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4647_0: read-var el:u8
        let s_4647_0: u8 = fn_state.el;
        // D s_4647_1: read-var coproc:u8
        let s_4647_1: u8 = fn_state.coproc;
        // D s_4647_2: read-var opc1:u8
        let s_4647_2: u8 = fn_state.opc1;
        // D s_4647_3: read-var CRn:u8
        let s_4647_3: u8 = fn_state.CRn;
        // D s_4647_4: read-var opc2:u8
        let s_4647_4: u8 = fn_state.opc2;
        // D s_4647_5: read-var CRm:u8
        let s_4647_5: u8 = fn_state.CRm;
        // D s_4647_6: read-var t:i
        let s_4647_6: i128 = fn_state.t;
        // D s_4647_7: call FCSEIDR_SysRegWrite32_b64bdb1e5e7f2391(s_4647_0, s_4647_1, s_4647_2, s_4647_3, s_4647_4, s_4647_5, s_4647_6)
        let s_4647_7: () = FCSEIDR_SysRegWrite32_b64bdb1e5e7f2391(
            state,
            tracer,
            s_4647_0,
            s_4647_1,
            s_4647_2,
            s_4647_3,
            s_4647_4,
            s_4647_5,
            s_4647_6,
        );
        // N s_4647_8: return
        return;
    }
    fn block_4648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4648_0: read-var opc2:u8
        let s_4648_0: u8 = fn_state.opc2;
        // D s_4648_1: cast zx s_4648_0 -> bv
        let s_4648_1: Bits = Bits::new(s_4648_0 as u128, 3u16);
        // C s_4648_2: const #0u : u8
        let s_4648_2: u8 = 0;
        // C s_4648_3: cast zx s_4648_2 -> bv
        let s_4648_3: Bits = Bits::new(s_4648_2 as u128, 3u16);
        // D s_4648_4: cmp-eq s_4648_1 s_4648_3
        let s_4648_4: bool = ((s_4648_1) == (s_4648_3));
        // D s_4648_5: write-var gs#135343 <= s_4648_4
        fn_state.gs_135343 = s_4648_4;
        // N s_4648_6: jump b1943
        return block_1943(state, tracer, fn_state);
    }
    fn block_4649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4649_0: read-var opc1:u8
        let s_4649_0: u8 = fn_state.opc1;
        // D s_4649_1: cast zx s_4649_0 -> bv
        let s_4649_1: Bits = Bits::new(s_4649_0 as u128, 3u16);
        // C s_4649_2: const #0u : u8
        let s_4649_2: u8 = 0;
        // C s_4649_3: cast zx s_4649_2 -> bv
        let s_4649_3: Bits = Bits::new(s_4649_2 as u128, 3u16);
        // D s_4649_4: cmp-eq s_4649_1 s_4649_3
        let s_4649_4: bool = ((s_4649_1) == (s_4649_3));
        // D s_4649_5: write-var gs#135342 <= s_4649_4
        fn_state.gs_135342 = s_4649_4;
        // N s_4649_6: jump b1941
        return block_1941(state, tracer, fn_state);
    }
    fn block_4650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4650_0: read-var coproc:u8
        let s_4650_0: u8 = fn_state.coproc;
        // D s_4650_1: cast zx s_4650_0 -> bv
        let s_4650_1: Bits = Bits::new(s_4650_0 as u128, 4u16);
        // C s_4650_2: const #15u : u8
        let s_4650_2: u8 = 15;
        // C s_4650_3: cast zx s_4650_2 -> bv
        let s_4650_3: Bits = Bits::new(s_4650_2 as u128, 4u16);
        // D s_4650_4: cmp-eq s_4650_1 s_4650_3
        let s_4650_4: bool = ((s_4650_1) == (s_4650_3));
        // D s_4650_5: write-var gs#135341 <= s_4650_4
        fn_state.gs_135341 = s_4650_4;
        // N s_4650_6: jump b1939
        return block_1939(state, tracer, fn_state);
    }
    fn block_4651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4651_0: read-var CRn:u8
        let s_4651_0: u8 = fn_state.CRn;
        // D s_4651_1: cast zx s_4651_0 -> bv
        let s_4651_1: Bits = Bits::new(s_4651_0 as u128, 4u16);
        // C s_4651_2: const #13u : u8
        let s_4651_2: u8 = 13;
        // C s_4651_3: cast zx s_4651_2 -> bv
        let s_4651_3: Bits = Bits::new(s_4651_2 as u128, 4u16);
        // D s_4651_4: cmp-eq s_4651_1 s_4651_3
        let s_4651_4: bool = ((s_4651_1) == (s_4651_3));
        // D s_4651_5: write-var gs#135340 <= s_4651_4
        fn_state.gs_135340 = s_4651_4;
        // N s_4651_6: jump b1937
        return block_1937(state, tracer, fn_state);
    }
    fn block_4652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4652_0: read-var el:u8
        let s_4652_0: u8 = fn_state.el;
        // D s_4652_1: read-var coproc:u8
        let s_4652_1: u8 = fn_state.coproc;
        // D s_4652_2: read-var opc1:u8
        let s_4652_2: u8 = fn_state.opc1;
        // D s_4652_3: read-var CRn:u8
        let s_4652_3: u8 = fn_state.CRn;
        // D s_4652_4: read-var opc2:u8
        let s_4652_4: u8 = fn_state.opc2;
        // D s_4652_5: read-var CRm:u8
        let s_4652_5: u8 = fn_state.CRm;
        // D s_4652_6: read-var t:i
        let s_4652_6: i128 = fn_state.t;
        // D s_4652_7: call HSR_SysRegWrite32_d1b5afc988459b67(s_4652_0, s_4652_1, s_4652_2, s_4652_3, s_4652_4, s_4652_5, s_4652_6)
        let s_4652_7: () = HSR_SysRegWrite32_d1b5afc988459b67(
            state,
            tracer,
            s_4652_0,
            s_4652_1,
            s_4652_2,
            s_4652_3,
            s_4652_4,
            s_4652_5,
            s_4652_6,
        );
        // N s_4652_8: return
        return;
    }
    fn block_4653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4653_0: read-var opc2:u8
        let s_4653_0: u8 = fn_state.opc2;
        // D s_4653_1: cast zx s_4653_0 -> bv
        let s_4653_1: Bits = Bits::new(s_4653_0 as u128, 3u16);
        // C s_4653_2: const #0u : u8
        let s_4653_2: u8 = 0;
        // C s_4653_3: cast zx s_4653_2 -> bv
        let s_4653_3: Bits = Bits::new(s_4653_2 as u128, 3u16);
        // D s_4653_4: cmp-eq s_4653_1 s_4653_3
        let s_4653_4: bool = ((s_4653_1) == (s_4653_3));
        // D s_4653_5: write-var gs#135339 <= s_4653_4
        fn_state.gs_135339 = s_4653_4;
        // N s_4653_6: jump b1934
        return block_1934(state, tracer, fn_state);
    }
    fn block_4654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4654_0: read-var opc1:u8
        let s_4654_0: u8 = fn_state.opc1;
        // D s_4654_1: cast zx s_4654_0 -> bv
        let s_4654_1: Bits = Bits::new(s_4654_0 as u128, 3u16);
        // C s_4654_2: const #4u : u8
        let s_4654_2: u8 = 4;
        // C s_4654_3: cast zx s_4654_2 -> bv
        let s_4654_3: Bits = Bits::new(s_4654_2 as u128, 3u16);
        // D s_4654_4: cmp-eq s_4654_1 s_4654_3
        let s_4654_4: bool = ((s_4654_1) == (s_4654_3));
        // D s_4654_5: write-var gs#135338 <= s_4654_4
        fn_state.gs_135338 = s_4654_4;
        // N s_4654_6: jump b1932
        return block_1932(state, tracer, fn_state);
    }
    fn block_4655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4655_0: read-var coproc:u8
        let s_4655_0: u8 = fn_state.coproc;
        // D s_4655_1: cast zx s_4655_0 -> bv
        let s_4655_1: Bits = Bits::new(s_4655_0 as u128, 4u16);
        // C s_4655_2: const #15u : u8
        let s_4655_2: u8 = 15;
        // C s_4655_3: cast zx s_4655_2 -> bv
        let s_4655_3: Bits = Bits::new(s_4655_2 as u128, 4u16);
        // D s_4655_4: cmp-eq s_4655_1 s_4655_3
        let s_4655_4: bool = ((s_4655_1) == (s_4655_3));
        // D s_4655_5: write-var gs#135337 <= s_4655_4
        fn_state.gs_135337 = s_4655_4;
        // N s_4655_6: jump b1930
        return block_1930(state, tracer, fn_state);
    }
    fn block_4656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4656_0: read-var CRn:u8
        let s_4656_0: u8 = fn_state.CRn;
        // D s_4656_1: cast zx s_4656_0 -> bv
        let s_4656_1: Bits = Bits::new(s_4656_0 as u128, 4u16);
        // C s_4656_2: const #5u : u8
        let s_4656_2: u8 = 5;
        // C s_4656_3: cast zx s_4656_2 -> bv
        let s_4656_3: Bits = Bits::new(s_4656_2 as u128, 4u16);
        // D s_4656_4: cmp-eq s_4656_1 s_4656_3
        let s_4656_4: bool = ((s_4656_1) == (s_4656_3));
        // D s_4656_5: write-var gs#135336 <= s_4656_4
        fn_state.gs_135336 = s_4656_4;
        // N s_4656_6: jump b1928
        return block_1928(state, tracer, fn_state);
    }
    fn block_4657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4657_0: read-var el:u8
        let s_4657_0: u8 = fn_state.el;
        // D s_4657_1: read-var coproc:u8
        let s_4657_1: u8 = fn_state.coproc;
        // D s_4657_2: read-var opc1:u8
        let s_4657_2: u8 = fn_state.opc1;
        // D s_4657_3: read-var CRn:u8
        let s_4657_3: u8 = fn_state.CRn;
        // D s_4657_4: read-var opc2:u8
        let s_4657_4: u8 = fn_state.opc2;
        // D s_4657_5: read-var CRm:u8
        let s_4657_5: u8 = fn_state.CRm;
        // D s_4657_6: read-var t:i
        let s_4657_6: i128 = fn_state.t;
        // D s_4657_7: call CFPRCTX_SysRegWrite32_5c2c25bf2b1d12d6(s_4657_0, s_4657_1, s_4657_2, s_4657_3, s_4657_4, s_4657_5, s_4657_6)
        let s_4657_7: () = CFPRCTX_SysRegWrite32_5c2c25bf2b1d12d6(
            state,
            tracer,
            s_4657_0,
            s_4657_1,
            s_4657_2,
            s_4657_3,
            s_4657_4,
            s_4657_5,
            s_4657_6,
        );
        // N s_4657_8: return
        return;
    }
    fn block_4658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4658_0: read-var opc2:u8
        let s_4658_0: u8 = fn_state.opc2;
        // D s_4658_1: cast zx s_4658_0 -> bv
        let s_4658_1: Bits = Bits::new(s_4658_0 as u128, 3u16);
        // C s_4658_2: const #4u : u8
        let s_4658_2: u8 = 4;
        // C s_4658_3: cast zx s_4658_2 -> bv
        let s_4658_3: Bits = Bits::new(s_4658_2 as u128, 3u16);
        // D s_4658_4: cmp-eq s_4658_1 s_4658_3
        let s_4658_4: bool = ((s_4658_1) == (s_4658_3));
        // D s_4658_5: write-var gs#135335 <= s_4658_4
        fn_state.gs_135335 = s_4658_4;
        // N s_4658_6: jump b1925
        return block_1925(state, tracer, fn_state);
    }
    fn block_4659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4659_0: read-var opc1:u8
        let s_4659_0: u8 = fn_state.opc1;
        // D s_4659_1: cast zx s_4659_0 -> bv
        let s_4659_1: Bits = Bits::new(s_4659_0 as u128, 3u16);
        // C s_4659_2: const #0u : u8
        let s_4659_2: u8 = 0;
        // C s_4659_3: cast zx s_4659_2 -> bv
        let s_4659_3: Bits = Bits::new(s_4659_2 as u128, 3u16);
        // D s_4659_4: cmp-eq s_4659_1 s_4659_3
        let s_4659_4: bool = ((s_4659_1) == (s_4659_3));
        // D s_4659_5: write-var gs#135334 <= s_4659_4
        fn_state.gs_135334 = s_4659_4;
        // N s_4659_6: jump b1923
        return block_1923(state, tracer, fn_state);
    }
    fn block_4660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4660_0: read-var coproc:u8
        let s_4660_0: u8 = fn_state.coproc;
        // D s_4660_1: cast zx s_4660_0 -> bv
        let s_4660_1: Bits = Bits::new(s_4660_0 as u128, 4u16);
        // C s_4660_2: const #15u : u8
        let s_4660_2: u8 = 15;
        // C s_4660_3: cast zx s_4660_2 -> bv
        let s_4660_3: Bits = Bits::new(s_4660_2 as u128, 4u16);
        // D s_4660_4: cmp-eq s_4660_1 s_4660_3
        let s_4660_4: bool = ((s_4660_1) == (s_4660_3));
        // D s_4660_5: write-var gs#135333 <= s_4660_4
        fn_state.gs_135333 = s_4660_4;
        // N s_4660_6: jump b1921
        return block_1921(state, tracer, fn_state);
    }
    fn block_4661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4661_0: read-var CRn:u8
        let s_4661_0: u8 = fn_state.CRn;
        // D s_4661_1: cast zx s_4661_0 -> bv
        let s_4661_1: Bits = Bits::new(s_4661_0 as u128, 4u16);
        // C s_4661_2: const #7u : u8
        let s_4661_2: u8 = 7;
        // C s_4661_3: cast zx s_4661_2 -> bv
        let s_4661_3: Bits = Bits::new(s_4661_2 as u128, 4u16);
        // D s_4661_4: cmp-eq s_4661_1 s_4661_3
        let s_4661_4: bool = ((s_4661_1) == (s_4661_3));
        // D s_4661_5: write-var gs#135332 <= s_4661_4
        fn_state.gs_135332 = s_4661_4;
        // N s_4661_6: jump b1919
        return block_1919(state, tracer, fn_state);
    }
    fn block_4662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4662_0: read-var el:u8
        let s_4662_0: u8 = fn_state.el;
        // D s_4662_1: read-var coproc:u8
        let s_4662_1: u8 = fn_state.coproc;
        // D s_4662_2: read-var opc1:u8
        let s_4662_2: u8 = fn_state.opc1;
        // D s_4662_3: read-var CRn:u8
        let s_4662_3: u8 = fn_state.CRn;
        // D s_4662_4: read-var opc2:u8
        let s_4662_4: u8 = fn_state.opc2;
        // D s_4662_5: read-var CRm:u8
        let s_4662_5: u8 = fn_state.CRm;
        // D s_4662_6: read-var t:i
        let s_4662_6: i128 = fn_state.t;
        // D s_4662_7: call TTBCR2_SysRegWrite32_06c6fc8db37664f3(s_4662_0, s_4662_1, s_4662_2, s_4662_3, s_4662_4, s_4662_5, s_4662_6)
        let s_4662_7: () = TTBCR2_SysRegWrite32_06c6fc8db37664f3(
            state,
            tracer,
            s_4662_0,
            s_4662_1,
            s_4662_2,
            s_4662_3,
            s_4662_4,
            s_4662_5,
            s_4662_6,
        );
        // N s_4662_8: return
        return;
    }
    fn block_4663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4663_0: read-var opc2:u8
        let s_4663_0: u8 = fn_state.opc2;
        // D s_4663_1: cast zx s_4663_0 -> bv
        let s_4663_1: Bits = Bits::new(s_4663_0 as u128, 3u16);
        // C s_4663_2: const #3u : u8
        let s_4663_2: u8 = 3;
        // C s_4663_3: cast zx s_4663_2 -> bv
        let s_4663_3: Bits = Bits::new(s_4663_2 as u128, 3u16);
        // D s_4663_4: cmp-eq s_4663_1 s_4663_3
        let s_4663_4: bool = ((s_4663_1) == (s_4663_3));
        // D s_4663_5: write-var gs#135331 <= s_4663_4
        fn_state.gs_135331 = s_4663_4;
        // N s_4663_6: jump b1916
        return block_1916(state, tracer, fn_state);
    }
    fn block_4664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4664_0: read-var opc1:u8
        let s_4664_0: u8 = fn_state.opc1;
        // D s_4664_1: cast zx s_4664_0 -> bv
        let s_4664_1: Bits = Bits::new(s_4664_0 as u128, 3u16);
        // C s_4664_2: const #0u : u8
        let s_4664_2: u8 = 0;
        // C s_4664_3: cast zx s_4664_2 -> bv
        let s_4664_3: Bits = Bits::new(s_4664_2 as u128, 3u16);
        // D s_4664_4: cmp-eq s_4664_1 s_4664_3
        let s_4664_4: bool = ((s_4664_1) == (s_4664_3));
        // D s_4664_5: write-var gs#135330 <= s_4664_4
        fn_state.gs_135330 = s_4664_4;
        // N s_4664_6: jump b1914
        return block_1914(state, tracer, fn_state);
    }
    fn block_4665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4665_0: read-var coproc:u8
        let s_4665_0: u8 = fn_state.coproc;
        // D s_4665_1: cast zx s_4665_0 -> bv
        let s_4665_1: Bits = Bits::new(s_4665_0 as u128, 4u16);
        // C s_4665_2: const #15u : u8
        let s_4665_2: u8 = 15;
        // C s_4665_3: cast zx s_4665_2 -> bv
        let s_4665_3: Bits = Bits::new(s_4665_2 as u128, 4u16);
        // D s_4665_4: cmp-eq s_4665_1 s_4665_3
        let s_4665_4: bool = ((s_4665_1) == (s_4665_3));
        // D s_4665_5: write-var gs#135329 <= s_4665_4
        fn_state.gs_135329 = s_4665_4;
        // N s_4665_6: jump b1912
        return block_1912(state, tracer, fn_state);
    }
    fn block_4666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4666_0: read-var CRn:u8
        let s_4666_0: u8 = fn_state.CRn;
        // D s_4666_1: cast zx s_4666_0 -> bv
        let s_4666_1: Bits = Bits::new(s_4666_0 as u128, 4u16);
        // C s_4666_2: const #2u : u8
        let s_4666_2: u8 = 2;
        // C s_4666_3: cast zx s_4666_2 -> bv
        let s_4666_3: Bits = Bits::new(s_4666_2 as u128, 4u16);
        // D s_4666_4: cmp-eq s_4666_1 s_4666_3
        let s_4666_4: bool = ((s_4666_1) == (s_4666_3));
        // D s_4666_5: write-var gs#135328 <= s_4666_4
        fn_state.gs_135328 = s_4666_4;
        // N s_4666_6: jump b1910
        return block_1910(state, tracer, fn_state);
    }
    fn block_4667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4667_0: read-var el:u8
        let s_4667_0: u8 = fn_state.el;
        // D s_4667_1: read-var coproc:u8
        let s_4667_1: u8 = fn_state.coproc;
        // D s_4667_2: read-var opc1:u8
        let s_4667_2: u8 = fn_state.opc1;
        // D s_4667_3: read-var CRn:u8
        let s_4667_3: u8 = fn_state.CRn;
        // D s_4667_4: read-var opc2:u8
        let s_4667_4: u8 = fn_state.opc2;
        // D s_4667_5: read-var CRm:u8
        let s_4667_5: u8 = fn_state.CRm;
        // D s_4667_6: read-var t:i
        let s_4667_6: i128 = fn_state.t;
        // D s_4667_7: call HMAIR1_SysRegWrite32_0de1027f448e168d(s_4667_0, s_4667_1, s_4667_2, s_4667_3, s_4667_4, s_4667_5, s_4667_6)
        let s_4667_7: () = HMAIR1_SysRegWrite32_0de1027f448e168d(
            state,
            tracer,
            s_4667_0,
            s_4667_1,
            s_4667_2,
            s_4667_3,
            s_4667_4,
            s_4667_5,
            s_4667_6,
        );
        // N s_4667_8: return
        return;
    }
    fn block_4668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4668_0: read-var opc2:u8
        let s_4668_0: u8 = fn_state.opc2;
        // D s_4668_1: cast zx s_4668_0 -> bv
        let s_4668_1: Bits = Bits::new(s_4668_0 as u128, 3u16);
        // C s_4668_2: const #1u : u8
        let s_4668_2: u8 = 1;
        // C s_4668_3: cast zx s_4668_2 -> bv
        let s_4668_3: Bits = Bits::new(s_4668_2 as u128, 3u16);
        // D s_4668_4: cmp-eq s_4668_1 s_4668_3
        let s_4668_4: bool = ((s_4668_1) == (s_4668_3));
        // D s_4668_5: write-var gs#135327 <= s_4668_4
        fn_state.gs_135327 = s_4668_4;
        // N s_4668_6: jump b1907
        return block_1907(state, tracer, fn_state);
    }
    fn block_4669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4669_0: read-var opc1:u8
        let s_4669_0: u8 = fn_state.opc1;
        // D s_4669_1: cast zx s_4669_0 -> bv
        let s_4669_1: Bits = Bits::new(s_4669_0 as u128, 3u16);
        // C s_4669_2: const #4u : u8
        let s_4669_2: u8 = 4;
        // C s_4669_3: cast zx s_4669_2 -> bv
        let s_4669_3: Bits = Bits::new(s_4669_2 as u128, 3u16);
        // D s_4669_4: cmp-eq s_4669_1 s_4669_3
        let s_4669_4: bool = ((s_4669_1) == (s_4669_3));
        // D s_4669_5: write-var gs#135326 <= s_4669_4
        fn_state.gs_135326 = s_4669_4;
        // N s_4669_6: jump b1905
        return block_1905(state, tracer, fn_state);
    }
    fn block_4670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4670_0: read-var coproc:u8
        let s_4670_0: u8 = fn_state.coproc;
        // D s_4670_1: cast zx s_4670_0 -> bv
        let s_4670_1: Bits = Bits::new(s_4670_0 as u128, 4u16);
        // C s_4670_2: const #15u : u8
        let s_4670_2: u8 = 15;
        // C s_4670_3: cast zx s_4670_2 -> bv
        let s_4670_3: Bits = Bits::new(s_4670_2 as u128, 4u16);
        // D s_4670_4: cmp-eq s_4670_1 s_4670_3
        let s_4670_4: bool = ((s_4670_1) == (s_4670_3));
        // D s_4670_5: write-var gs#135325 <= s_4670_4
        fn_state.gs_135325 = s_4670_4;
        // N s_4670_6: jump b1903
        return block_1903(state, tracer, fn_state);
    }
    fn block_4671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4671_0: read-var CRn:u8
        let s_4671_0: u8 = fn_state.CRn;
        // D s_4671_1: cast zx s_4671_0 -> bv
        let s_4671_1: Bits = Bits::new(s_4671_0 as u128, 4u16);
        // C s_4671_2: const #10u : u8
        let s_4671_2: u8 = 10;
        // C s_4671_3: cast zx s_4671_2 -> bv
        let s_4671_3: Bits = Bits::new(s_4671_2 as u128, 4u16);
        // D s_4671_4: cmp-eq s_4671_1 s_4671_3
        let s_4671_4: bool = ((s_4671_1) == (s_4671_3));
        // D s_4671_5: write-var gs#135324 <= s_4671_4
        fn_state.gs_135324 = s_4671_4;
        // N s_4671_6: jump b1901
        return block_1901(state, tracer, fn_state);
    }
    fn block_4672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4672_0: read-var el:u8
        let s_4672_0: u8 = fn_state.el;
        // D s_4672_1: read-var coproc:u8
        let s_4672_1: u8 = fn_state.coproc;
        // D s_4672_2: read-var opc1:u8
        let s_4672_2: u8 = fn_state.opc1;
        // D s_4672_3: read-var CRn:u8
        let s_4672_3: u8 = fn_state.CRn;
        // D s_4672_4: read-var opc2:u8
        let s_4672_4: u8 = fn_state.opc2;
        // D s_4672_5: read-var CRm:u8
        let s_4672_5: u8 = fn_state.CRm;
        // D s_4672_6: read-var t:i
        let s_4672_6: i128 = fn_state.t;
        // D s_4672_7: call RMR_SysRegWrite32_9dfdd4710efdf52a(s_4672_0, s_4672_1, s_4672_2, s_4672_3, s_4672_4, s_4672_5, s_4672_6)
        let s_4672_7: () = RMR_SysRegWrite32_9dfdd4710efdf52a(
            state,
            tracer,
            s_4672_0,
            s_4672_1,
            s_4672_2,
            s_4672_3,
            s_4672_4,
            s_4672_5,
            s_4672_6,
        );
        // N s_4672_8: return
        return;
    }
    fn block_4673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4673_0: read-var opc2:u8
        let s_4673_0: u8 = fn_state.opc2;
        // D s_4673_1: cast zx s_4673_0 -> bv
        let s_4673_1: Bits = Bits::new(s_4673_0 as u128, 3u16);
        // C s_4673_2: const #2u : u8
        let s_4673_2: u8 = 2;
        // C s_4673_3: cast zx s_4673_2 -> bv
        let s_4673_3: Bits = Bits::new(s_4673_2 as u128, 3u16);
        // D s_4673_4: cmp-eq s_4673_1 s_4673_3
        let s_4673_4: bool = ((s_4673_1) == (s_4673_3));
        // D s_4673_5: write-var gs#135323 <= s_4673_4
        fn_state.gs_135323 = s_4673_4;
        // N s_4673_6: jump b1898
        return block_1898(state, tracer, fn_state);
    }
    fn block_4674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4674_0: read-var opc1:u8
        let s_4674_0: u8 = fn_state.opc1;
        // D s_4674_1: cast zx s_4674_0 -> bv
        let s_4674_1: Bits = Bits::new(s_4674_0 as u128, 3u16);
        // C s_4674_2: const #0u : u8
        let s_4674_2: u8 = 0;
        // C s_4674_3: cast zx s_4674_2 -> bv
        let s_4674_3: Bits = Bits::new(s_4674_2 as u128, 3u16);
        // D s_4674_4: cmp-eq s_4674_1 s_4674_3
        let s_4674_4: bool = ((s_4674_1) == (s_4674_3));
        // D s_4674_5: write-var gs#135322 <= s_4674_4
        fn_state.gs_135322 = s_4674_4;
        // N s_4674_6: jump b1896
        return block_1896(state, tracer, fn_state);
    }
    fn block_4675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4675_0: read-var coproc:u8
        let s_4675_0: u8 = fn_state.coproc;
        // D s_4675_1: cast zx s_4675_0 -> bv
        let s_4675_1: Bits = Bits::new(s_4675_0 as u128, 4u16);
        // C s_4675_2: const #15u : u8
        let s_4675_2: u8 = 15;
        // C s_4675_3: cast zx s_4675_2 -> bv
        let s_4675_3: Bits = Bits::new(s_4675_2 as u128, 4u16);
        // D s_4675_4: cmp-eq s_4675_1 s_4675_3
        let s_4675_4: bool = ((s_4675_1) == (s_4675_3));
        // D s_4675_5: write-var gs#135321 <= s_4675_4
        fn_state.gs_135321 = s_4675_4;
        // N s_4675_6: jump b1894
        return block_1894(state, tracer, fn_state);
    }
    fn block_4676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4676_0: read-var CRn:u8
        let s_4676_0: u8 = fn_state.CRn;
        // D s_4676_1: cast zx s_4676_0 -> bv
        let s_4676_1: Bits = Bits::new(s_4676_0 as u128, 4u16);
        // C s_4676_2: const #12u : u8
        let s_4676_2: u8 = 12;
        // C s_4676_3: cast zx s_4676_2 -> bv
        let s_4676_3: Bits = Bits::new(s_4676_2 as u128, 4u16);
        // D s_4676_4: cmp-eq s_4676_1 s_4676_3
        let s_4676_4: bool = ((s_4676_1) == (s_4676_3));
        // D s_4676_5: write-var gs#135320 <= s_4676_4
        fn_state.gs_135320 = s_4676_4;
        // N s_4676_6: jump b1892
        return block_1892(state, tracer, fn_state);
    }
    fn block_4677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4677_0: read-var el:u8
        let s_4677_0: u8 = fn_state.el;
        // D s_4677_1: read-var coproc:u8
        let s_4677_1: u8 = fn_state.coproc;
        // D s_4677_2: read-var opc1:u8
        let s_4677_2: u8 = fn_state.opc1;
        // D s_4677_3: read-var CRn:u8
        let s_4677_3: u8 = fn_state.CRn;
        // D s_4677_4: read-var opc2:u8
        let s_4677_4: u8 = fn_state.opc2;
        // D s_4677_5: read-var CRm:u8
        let s_4677_5: u8 = fn_state.CRm;
        // D s_4677_6: read-var t:i
        let s_4677_6: i128 = fn_state.t;
        // D s_4677_7: call ICH_HCR_SysRegWrite32_391df800f72b5649(s_4677_0, s_4677_1, s_4677_2, s_4677_3, s_4677_4, s_4677_5, s_4677_6)
        let s_4677_7: () = ICH_HCR_SysRegWrite32_391df800f72b5649(
            state,
            tracer,
            s_4677_0,
            s_4677_1,
            s_4677_2,
            s_4677_3,
            s_4677_4,
            s_4677_5,
            s_4677_6,
        );
        // N s_4677_8: return
        return;
    }
    fn block_4678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4678_0: read-var opc2:u8
        let s_4678_0: u8 = fn_state.opc2;
        // D s_4678_1: cast zx s_4678_0 -> bv
        let s_4678_1: Bits = Bits::new(s_4678_0 as u128, 3u16);
        // C s_4678_2: const #0u : u8
        let s_4678_2: u8 = 0;
        // C s_4678_3: cast zx s_4678_2 -> bv
        let s_4678_3: Bits = Bits::new(s_4678_2 as u128, 3u16);
        // D s_4678_4: cmp-eq s_4678_1 s_4678_3
        let s_4678_4: bool = ((s_4678_1) == (s_4678_3));
        // D s_4678_5: write-var gs#135319 <= s_4678_4
        fn_state.gs_135319 = s_4678_4;
        // N s_4678_6: jump b1889
        return block_1889(state, tracer, fn_state);
    }
    fn block_4679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4679_0: read-var opc1:u8
        let s_4679_0: u8 = fn_state.opc1;
        // D s_4679_1: cast zx s_4679_0 -> bv
        let s_4679_1: Bits = Bits::new(s_4679_0 as u128, 3u16);
        // C s_4679_2: const #4u : u8
        let s_4679_2: u8 = 4;
        // C s_4679_3: cast zx s_4679_2 -> bv
        let s_4679_3: Bits = Bits::new(s_4679_2 as u128, 3u16);
        // D s_4679_4: cmp-eq s_4679_1 s_4679_3
        let s_4679_4: bool = ((s_4679_1) == (s_4679_3));
        // D s_4679_5: write-var gs#135318 <= s_4679_4
        fn_state.gs_135318 = s_4679_4;
        // N s_4679_6: jump b1887
        return block_1887(state, tracer, fn_state);
    }
    fn block_4680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4680_0: read-var coproc:u8
        let s_4680_0: u8 = fn_state.coproc;
        // D s_4680_1: cast zx s_4680_0 -> bv
        let s_4680_1: Bits = Bits::new(s_4680_0 as u128, 4u16);
        // C s_4680_2: const #15u : u8
        let s_4680_2: u8 = 15;
        // C s_4680_3: cast zx s_4680_2 -> bv
        let s_4680_3: Bits = Bits::new(s_4680_2 as u128, 4u16);
        // D s_4680_4: cmp-eq s_4680_1 s_4680_3
        let s_4680_4: bool = ((s_4680_1) == (s_4680_3));
        // D s_4680_5: write-var gs#135317 <= s_4680_4
        fn_state.gs_135317 = s_4680_4;
        // N s_4680_6: jump b1885
        return block_1885(state, tracer, fn_state);
    }
    fn block_4681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4681_0: read-var CRn:u8
        let s_4681_0: u8 = fn_state.CRn;
        // D s_4681_1: cast zx s_4681_0 -> bv
        let s_4681_1: Bits = Bits::new(s_4681_0 as u128, 4u16);
        // C s_4681_2: const #12u : u8
        let s_4681_2: u8 = 12;
        // C s_4681_3: cast zx s_4681_2 -> bv
        let s_4681_3: Bits = Bits::new(s_4681_2 as u128, 4u16);
        // D s_4681_4: cmp-eq s_4681_1 s_4681_3
        let s_4681_4: bool = ((s_4681_1) == (s_4681_3));
        // D s_4681_5: write-var gs#135316 <= s_4681_4
        fn_state.gs_135316 = s_4681_4;
        // N s_4681_6: jump b1883
        return block_1883(state, tracer, fn_state);
    }
    fn block_4682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4682_0: read-var el:u8
        let s_4682_0: u8 = fn_state.el;
        // D s_4682_1: read-var coproc:u8
        let s_4682_1: u8 = fn_state.coproc;
        // D s_4682_2: read-var opc1:u8
        let s_4682_2: u8 = fn_state.opc1;
        // D s_4682_3: read-var CRn:u8
        let s_4682_3: u8 = fn_state.CRn;
        // D s_4682_4: read-var opc2:u8
        let s_4682_4: u8 = fn_state.opc2;
        // D s_4682_5: read-var CRm:u8
        let s_4682_5: u8 = fn_state.CRm;
        // D s_4682_6: read-var t:i
        let s_4682_6: i128 = fn_state.t;
        // D s_4682_7: call ICC_PMR_SysRegWrite32_b23a221ce6bd2853(s_4682_0, s_4682_1, s_4682_2, s_4682_3, s_4682_4, s_4682_5, s_4682_6)
        let s_4682_7: () = ICC_PMR_SysRegWrite32_b23a221ce6bd2853(
            state,
            tracer,
            s_4682_0,
            s_4682_1,
            s_4682_2,
            s_4682_3,
            s_4682_4,
            s_4682_5,
            s_4682_6,
        );
        // N s_4682_8: return
        return;
    }
    fn block_4683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4683_0: read-var opc2:u8
        let s_4683_0: u8 = fn_state.opc2;
        // D s_4683_1: cast zx s_4683_0 -> bv
        let s_4683_1: Bits = Bits::new(s_4683_0 as u128, 3u16);
        // C s_4683_2: const #0u : u8
        let s_4683_2: u8 = 0;
        // C s_4683_3: cast zx s_4683_2 -> bv
        let s_4683_3: Bits = Bits::new(s_4683_2 as u128, 3u16);
        // D s_4683_4: cmp-eq s_4683_1 s_4683_3
        let s_4683_4: bool = ((s_4683_1) == (s_4683_3));
        // D s_4683_5: write-var gs#135315 <= s_4683_4
        fn_state.gs_135315 = s_4683_4;
        // N s_4683_6: jump b1880
        return block_1880(state, tracer, fn_state);
    }
    fn block_4684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4684_0: read-var opc1:u8
        let s_4684_0: u8 = fn_state.opc1;
        // D s_4684_1: cast zx s_4684_0 -> bv
        let s_4684_1: Bits = Bits::new(s_4684_0 as u128, 3u16);
        // C s_4684_2: const #0u : u8
        let s_4684_2: u8 = 0;
        // C s_4684_3: cast zx s_4684_2 -> bv
        let s_4684_3: Bits = Bits::new(s_4684_2 as u128, 3u16);
        // D s_4684_4: cmp-eq s_4684_1 s_4684_3
        let s_4684_4: bool = ((s_4684_1) == (s_4684_3));
        // D s_4684_5: write-var gs#135314 <= s_4684_4
        fn_state.gs_135314 = s_4684_4;
        // N s_4684_6: jump b1878
        return block_1878(state, tracer, fn_state);
    }
    fn block_4685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4685_0: read-var coproc:u8
        let s_4685_0: u8 = fn_state.coproc;
        // D s_4685_1: cast zx s_4685_0 -> bv
        let s_4685_1: Bits = Bits::new(s_4685_0 as u128, 4u16);
        // C s_4685_2: const #15u : u8
        let s_4685_2: u8 = 15;
        // C s_4685_3: cast zx s_4685_2 -> bv
        let s_4685_3: Bits = Bits::new(s_4685_2 as u128, 4u16);
        // D s_4685_4: cmp-eq s_4685_1 s_4685_3
        let s_4685_4: bool = ((s_4685_1) == (s_4685_3));
        // D s_4685_5: write-var gs#135313 <= s_4685_4
        fn_state.gs_135313 = s_4685_4;
        // N s_4685_6: jump b1876
        return block_1876(state, tracer, fn_state);
    }
    fn block_4686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4686_0: read-var CRn:u8
        let s_4686_0: u8 = fn_state.CRn;
        // D s_4686_1: cast zx s_4686_0 -> bv
        let s_4686_1: Bits = Bits::new(s_4686_0 as u128, 4u16);
        // C s_4686_2: const #4u : u8
        let s_4686_2: u8 = 4;
        // C s_4686_3: cast zx s_4686_2 -> bv
        let s_4686_3: Bits = Bits::new(s_4686_2 as u128, 4u16);
        // D s_4686_4: cmp-eq s_4686_1 s_4686_3
        let s_4686_4: bool = ((s_4686_1) == (s_4686_3));
        // D s_4686_5: write-var gs#135312 <= s_4686_4
        fn_state.gs_135312 = s_4686_4;
        // N s_4686_6: jump b1874
        return block_1874(state, tracer, fn_state);
    }
    fn block_4687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4687_0: read-var el:u8
        let s_4687_0: u8 = fn_state.el;
        // D s_4687_1: read-var coproc:u8
        let s_4687_1: u8 = fn_state.coproc;
        // D s_4687_2: read-var opc1:u8
        let s_4687_2: u8 = fn_state.opc1;
        // D s_4687_3: read-var CRn:u8
        let s_4687_3: u8 = fn_state.CRn;
        // D s_4687_4: read-var opc2:u8
        let s_4687_4: u8 = fn_state.opc2;
        // D s_4687_5: read-var CRm:u8
        let s_4687_5: u8 = fn_state.CRm;
        // D s_4687_6: read-var t:i
        let s_4687_6: i128 = fn_state.t;
        // D s_4687_7: call HTCR_SysRegWrite32_0a66990c7e5298a5(s_4687_0, s_4687_1, s_4687_2, s_4687_3, s_4687_4, s_4687_5, s_4687_6)
        let s_4687_7: () = HTCR_SysRegWrite32_0a66990c7e5298a5(
            state,
            tracer,
            s_4687_0,
            s_4687_1,
            s_4687_2,
            s_4687_3,
            s_4687_4,
            s_4687_5,
            s_4687_6,
        );
        // N s_4687_8: return
        return;
    }
    fn block_4688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4688_0: read-var opc2:u8
        let s_4688_0: u8 = fn_state.opc2;
        // D s_4688_1: cast zx s_4688_0 -> bv
        let s_4688_1: Bits = Bits::new(s_4688_0 as u128, 3u16);
        // C s_4688_2: const #2u : u8
        let s_4688_2: u8 = 2;
        // C s_4688_3: cast zx s_4688_2 -> bv
        let s_4688_3: Bits = Bits::new(s_4688_2 as u128, 3u16);
        // D s_4688_4: cmp-eq s_4688_1 s_4688_3
        let s_4688_4: bool = ((s_4688_1) == (s_4688_3));
        // D s_4688_5: write-var gs#135311 <= s_4688_4
        fn_state.gs_135311 = s_4688_4;
        // N s_4688_6: jump b1871
        return block_1871(state, tracer, fn_state);
    }
    fn block_4689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4689_0: read-var opc1:u8
        let s_4689_0: u8 = fn_state.opc1;
        // D s_4689_1: cast zx s_4689_0 -> bv
        let s_4689_1: Bits = Bits::new(s_4689_0 as u128, 3u16);
        // C s_4689_2: const #4u : u8
        let s_4689_2: u8 = 4;
        // C s_4689_3: cast zx s_4689_2 -> bv
        let s_4689_3: Bits = Bits::new(s_4689_2 as u128, 3u16);
        // D s_4689_4: cmp-eq s_4689_1 s_4689_3
        let s_4689_4: bool = ((s_4689_1) == (s_4689_3));
        // D s_4689_5: write-var gs#135310 <= s_4689_4
        fn_state.gs_135310 = s_4689_4;
        // N s_4689_6: jump b1869
        return block_1869(state, tracer, fn_state);
    }
    fn block_4690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4690_0: read-var coproc:u8
        let s_4690_0: u8 = fn_state.coproc;
        // D s_4690_1: cast zx s_4690_0 -> bv
        let s_4690_1: Bits = Bits::new(s_4690_0 as u128, 4u16);
        // C s_4690_2: const #15u : u8
        let s_4690_2: u8 = 15;
        // C s_4690_3: cast zx s_4690_2 -> bv
        let s_4690_3: Bits = Bits::new(s_4690_2 as u128, 4u16);
        // D s_4690_4: cmp-eq s_4690_1 s_4690_3
        let s_4690_4: bool = ((s_4690_1) == (s_4690_3));
        // D s_4690_5: write-var gs#135309 <= s_4690_4
        fn_state.gs_135309 = s_4690_4;
        // N s_4690_6: jump b1867
        return block_1867(state, tracer, fn_state);
    }
    fn block_4691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4691_0: read-var CRn:u8
        let s_4691_0: u8 = fn_state.CRn;
        // D s_4691_1: cast zx s_4691_0 -> bv
        let s_4691_1: Bits = Bits::new(s_4691_0 as u128, 4u16);
        // C s_4691_2: const #2u : u8
        let s_4691_2: u8 = 2;
        // C s_4691_3: cast zx s_4691_2 -> bv
        let s_4691_3: Bits = Bits::new(s_4691_2 as u128, 4u16);
        // D s_4691_4: cmp-eq s_4691_1 s_4691_3
        let s_4691_4: bool = ((s_4691_1) == (s_4691_3));
        // D s_4691_5: write-var gs#135308 <= s_4691_4
        fn_state.gs_135308 = s_4691_4;
        // N s_4691_6: jump b1865
        return block_1865(state, tracer, fn_state);
    }
    fn block_4692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4692_0: read-var el:u8
        let s_4692_0: u8 = fn_state.el;
        // D s_4692_1: read-var coproc:u8
        let s_4692_1: u8 = fn_state.coproc;
        // D s_4692_2: read-var opc1:u8
        let s_4692_2: u8 = fn_state.opc1;
        // D s_4692_3: read-var CRn:u8
        let s_4692_3: u8 = fn_state.CRn;
        // D s_4692_4: read-var opc2:u8
        let s_4692_4: u8 = fn_state.opc2;
        // D s_4692_5: read-var CRm:u8
        let s_4692_5: u8 = fn_state.CRm;
        // D s_4692_6: read-var t:i
        let s_4692_6: i128 = fn_state.t;
        // D s_4692_7: call ICH_AP0R_SysRegWrite32_776121746bc0b6a3(s_4692_0, s_4692_1, s_4692_2, s_4692_3, s_4692_4, s_4692_5, s_4692_6)
        let s_4692_7: () = ICH_AP0R_SysRegWrite32_776121746bc0b6a3(
            state,
            tracer,
            s_4692_0,
            s_4692_1,
            s_4692_2,
            s_4692_3,
            s_4692_4,
            s_4692_5,
            s_4692_6,
        );
        // N s_4692_8: return
        return;
    }
    fn block_4693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4693_0: read-var opc2:u8
        let s_4693_0: u8 = fn_state.opc2;
        // D s_4693_1: cast zx s_4693_0 -> bv
        let s_4693_1: Bits = Bits::new(s_4693_0 as u128, 3u16);
        // C s_4693_2: const #0u : u8
        let s_4693_2: u8 = 0;
        // C s_4693_3: cast zx s_4693_2 -> bv
        let s_4693_3: Bits = Bits::new(s_4693_2 as u128, 3u16);
        // D s_4693_4: cmp-eq s_4693_1 s_4693_3
        let s_4693_4: bool = ((s_4693_1) == (s_4693_3));
        // D s_4693_5: write-var gs#135307 <= s_4693_4
        fn_state.gs_135307 = s_4693_4;
        // N s_4693_6: jump b1862
        return block_1862(state, tracer, fn_state);
    }
    fn block_4694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4694_0: read-var opc1:u8
        let s_4694_0: u8 = fn_state.opc1;
        // D s_4694_1: cast zx s_4694_0 -> bv
        let s_4694_1: Bits = Bits::new(s_4694_0 as u128, 3u16);
        // C s_4694_2: const #4u : u8
        let s_4694_2: u8 = 4;
        // C s_4694_3: cast zx s_4694_2 -> bv
        let s_4694_3: Bits = Bits::new(s_4694_2 as u128, 3u16);
        // D s_4694_4: cmp-eq s_4694_1 s_4694_3
        let s_4694_4: bool = ((s_4694_1) == (s_4694_3));
        // D s_4694_5: write-var gs#135306 <= s_4694_4
        fn_state.gs_135306 = s_4694_4;
        // N s_4694_6: jump b1860
        return block_1860(state, tracer, fn_state);
    }
    fn block_4695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4695_0: read-var coproc:u8
        let s_4695_0: u8 = fn_state.coproc;
        // D s_4695_1: cast zx s_4695_0 -> bv
        let s_4695_1: Bits = Bits::new(s_4695_0 as u128, 4u16);
        // C s_4695_2: const #15u : u8
        let s_4695_2: u8 = 15;
        // C s_4695_3: cast zx s_4695_2 -> bv
        let s_4695_3: Bits = Bits::new(s_4695_2 as u128, 4u16);
        // D s_4695_4: cmp-eq s_4695_1 s_4695_3
        let s_4695_4: bool = ((s_4695_1) == (s_4695_3));
        // D s_4695_5: write-var gs#135305 <= s_4695_4
        fn_state.gs_135305 = s_4695_4;
        // N s_4695_6: jump b1858
        return block_1858(state, tracer, fn_state);
    }
    fn block_4696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4696_0: read-var CRn:u8
        let s_4696_0: u8 = fn_state.CRn;
        // D s_4696_1: cast zx s_4696_0 -> bv
        let s_4696_1: Bits = Bits::new(s_4696_0 as u128, 4u16);
        // C s_4696_2: const #12u : u8
        let s_4696_2: u8 = 12;
        // C s_4696_3: cast zx s_4696_2 -> bv
        let s_4696_3: Bits = Bits::new(s_4696_2 as u128, 4u16);
        // D s_4696_4: cmp-eq s_4696_1 s_4696_3
        let s_4696_4: bool = ((s_4696_1) == (s_4696_3));
        // D s_4696_5: write-var gs#135304 <= s_4696_4
        fn_state.gs_135304 = s_4696_4;
        // N s_4696_6: jump b1856
        return block_1856(state, tracer, fn_state);
    }
    fn block_4697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4697_0: read-var el:u8
        let s_4697_0: u8 = fn_state.el;
        // D s_4697_1: read-var coproc:u8
        let s_4697_1: u8 = fn_state.coproc;
        // D s_4697_2: read-var opc1:u8
        let s_4697_2: u8 = fn_state.opc1;
        // D s_4697_3: read-var CRn:u8
        let s_4697_3: u8 = fn_state.CRn;
        // D s_4697_4: read-var opc2:u8
        let s_4697_4: u8 = fn_state.opc2;
        // D s_4697_5: read-var CRm:u8
        let s_4697_5: u8 = fn_state.CRm;
        // D s_4697_6: read-var t:i
        let s_4697_6: i128 = fn_state.t;
        // D s_4697_7: call ICH_AP0R_SysRegWrite32_e8e0b6211baf6183(s_4697_0, s_4697_1, s_4697_2, s_4697_3, s_4697_4, s_4697_5, s_4697_6)
        let s_4697_7: () = ICH_AP0R_SysRegWrite32_e8e0b6211baf6183(
            state,
            tracer,
            s_4697_0,
            s_4697_1,
            s_4697_2,
            s_4697_3,
            s_4697_4,
            s_4697_5,
            s_4697_6,
        );
        // N s_4697_8: return
        return;
    }
    fn block_4698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4698_0: read-var opc2:u8
        let s_4698_0: u8 = fn_state.opc2;
        // D s_4698_1: cast zx s_4698_0 -> bv
        let s_4698_1: Bits = Bits::new(s_4698_0 as u128, 3u16);
        // C s_4698_2: const #1u : u8
        let s_4698_2: u8 = 1;
        // C s_4698_3: cast zx s_4698_2 -> bv
        let s_4698_3: Bits = Bits::new(s_4698_2 as u128, 3u16);
        // D s_4698_4: cmp-eq s_4698_1 s_4698_3
        let s_4698_4: bool = ((s_4698_1) == (s_4698_3));
        // D s_4698_5: write-var gs#135303 <= s_4698_4
        fn_state.gs_135303 = s_4698_4;
        // N s_4698_6: jump b1853
        return block_1853(state, tracer, fn_state);
    }
    fn block_4699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4699_0: read-var opc1:u8
        let s_4699_0: u8 = fn_state.opc1;
        // D s_4699_1: cast zx s_4699_0 -> bv
        let s_4699_1: Bits = Bits::new(s_4699_0 as u128, 3u16);
        // C s_4699_2: const #4u : u8
        let s_4699_2: u8 = 4;
        // C s_4699_3: cast zx s_4699_2 -> bv
        let s_4699_3: Bits = Bits::new(s_4699_2 as u128, 3u16);
        // D s_4699_4: cmp-eq s_4699_1 s_4699_3
        let s_4699_4: bool = ((s_4699_1) == (s_4699_3));
        // D s_4699_5: write-var gs#135302 <= s_4699_4
        fn_state.gs_135302 = s_4699_4;
        // N s_4699_6: jump b1851
        return block_1851(state, tracer, fn_state);
    }
    fn block_4700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4700_0: read-var coproc:u8
        let s_4700_0: u8 = fn_state.coproc;
        // D s_4700_1: cast zx s_4700_0 -> bv
        let s_4700_1: Bits = Bits::new(s_4700_0 as u128, 4u16);
        // C s_4700_2: const #15u : u8
        let s_4700_2: u8 = 15;
        // C s_4700_3: cast zx s_4700_2 -> bv
        let s_4700_3: Bits = Bits::new(s_4700_2 as u128, 4u16);
        // D s_4700_4: cmp-eq s_4700_1 s_4700_3
        let s_4700_4: bool = ((s_4700_1) == (s_4700_3));
        // D s_4700_5: write-var gs#135301 <= s_4700_4
        fn_state.gs_135301 = s_4700_4;
        // N s_4700_6: jump b1849
        return block_1849(state, tracer, fn_state);
    }
    fn block_4701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4701_0: read-var CRn:u8
        let s_4701_0: u8 = fn_state.CRn;
        // D s_4701_1: cast zx s_4701_0 -> bv
        let s_4701_1: Bits = Bits::new(s_4701_0 as u128, 4u16);
        // C s_4701_2: const #12u : u8
        let s_4701_2: u8 = 12;
        // C s_4701_3: cast zx s_4701_2 -> bv
        let s_4701_3: Bits = Bits::new(s_4701_2 as u128, 4u16);
        // D s_4701_4: cmp-eq s_4701_1 s_4701_3
        let s_4701_4: bool = ((s_4701_1) == (s_4701_3));
        // D s_4701_5: write-var gs#135300 <= s_4701_4
        fn_state.gs_135300 = s_4701_4;
        // N s_4701_6: jump b1847
        return block_1847(state, tracer, fn_state);
    }
    fn block_4702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4702_0: read-var el:u8
        let s_4702_0: u8 = fn_state.el;
        // D s_4702_1: read-var coproc:u8
        let s_4702_1: u8 = fn_state.coproc;
        // D s_4702_2: read-var opc1:u8
        let s_4702_2: u8 = fn_state.opc1;
        // D s_4702_3: read-var CRn:u8
        let s_4702_3: u8 = fn_state.CRn;
        // D s_4702_4: read-var opc2:u8
        let s_4702_4: u8 = fn_state.opc2;
        // D s_4702_5: read-var CRm:u8
        let s_4702_5: u8 = fn_state.CRm;
        // D s_4702_6: read-var t:i
        let s_4702_6: i128 = fn_state.t;
        // D s_4702_7: call ICH_AP0R_SysRegWrite32_0687237dd975d38e(s_4702_0, s_4702_1, s_4702_2, s_4702_3, s_4702_4, s_4702_5, s_4702_6)
        let s_4702_7: () = ICH_AP0R_SysRegWrite32_0687237dd975d38e(
            state,
            tracer,
            s_4702_0,
            s_4702_1,
            s_4702_2,
            s_4702_3,
            s_4702_4,
            s_4702_5,
            s_4702_6,
        );
        // N s_4702_8: return
        return;
    }
    fn block_4703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4703_0: read-var opc2:u8
        let s_4703_0: u8 = fn_state.opc2;
        // D s_4703_1: cast zx s_4703_0 -> bv
        let s_4703_1: Bits = Bits::new(s_4703_0 as u128, 3u16);
        // C s_4703_2: const #2u : u8
        let s_4703_2: u8 = 2;
        // C s_4703_3: cast zx s_4703_2 -> bv
        let s_4703_3: Bits = Bits::new(s_4703_2 as u128, 3u16);
        // D s_4703_4: cmp-eq s_4703_1 s_4703_3
        let s_4703_4: bool = ((s_4703_1) == (s_4703_3));
        // D s_4703_5: write-var gs#135299 <= s_4703_4
        fn_state.gs_135299 = s_4703_4;
        // N s_4703_6: jump b1844
        return block_1844(state, tracer, fn_state);
    }
    fn block_4704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4704_0: read-var opc1:u8
        let s_4704_0: u8 = fn_state.opc1;
        // D s_4704_1: cast zx s_4704_0 -> bv
        let s_4704_1: Bits = Bits::new(s_4704_0 as u128, 3u16);
        // C s_4704_2: const #4u : u8
        let s_4704_2: u8 = 4;
        // C s_4704_3: cast zx s_4704_2 -> bv
        let s_4704_3: Bits = Bits::new(s_4704_2 as u128, 3u16);
        // D s_4704_4: cmp-eq s_4704_1 s_4704_3
        let s_4704_4: bool = ((s_4704_1) == (s_4704_3));
        // D s_4704_5: write-var gs#135298 <= s_4704_4
        fn_state.gs_135298 = s_4704_4;
        // N s_4704_6: jump b1842
        return block_1842(state, tracer, fn_state);
    }
    fn block_4705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4705_0: read-var coproc:u8
        let s_4705_0: u8 = fn_state.coproc;
        // D s_4705_1: cast zx s_4705_0 -> bv
        let s_4705_1: Bits = Bits::new(s_4705_0 as u128, 4u16);
        // C s_4705_2: const #15u : u8
        let s_4705_2: u8 = 15;
        // C s_4705_3: cast zx s_4705_2 -> bv
        let s_4705_3: Bits = Bits::new(s_4705_2 as u128, 4u16);
        // D s_4705_4: cmp-eq s_4705_1 s_4705_3
        let s_4705_4: bool = ((s_4705_1) == (s_4705_3));
        // D s_4705_5: write-var gs#135297 <= s_4705_4
        fn_state.gs_135297 = s_4705_4;
        // N s_4705_6: jump b1840
        return block_1840(state, tracer, fn_state);
    }
    fn block_4706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4706_0: read-var CRn:u8
        let s_4706_0: u8 = fn_state.CRn;
        // D s_4706_1: cast zx s_4706_0 -> bv
        let s_4706_1: Bits = Bits::new(s_4706_0 as u128, 4u16);
        // C s_4706_2: const #12u : u8
        let s_4706_2: u8 = 12;
        // C s_4706_3: cast zx s_4706_2 -> bv
        let s_4706_3: Bits = Bits::new(s_4706_2 as u128, 4u16);
        // D s_4706_4: cmp-eq s_4706_1 s_4706_3
        let s_4706_4: bool = ((s_4706_1) == (s_4706_3));
        // D s_4706_5: write-var gs#135296 <= s_4706_4
        fn_state.gs_135296 = s_4706_4;
        // N s_4706_6: jump b1838
        return block_1838(state, tracer, fn_state);
    }
    fn block_4707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4707_0: read-var el:u8
        let s_4707_0: u8 = fn_state.el;
        // D s_4707_1: read-var coproc:u8
        let s_4707_1: u8 = fn_state.coproc;
        // D s_4707_2: read-var opc1:u8
        let s_4707_2: u8 = fn_state.opc1;
        // D s_4707_3: read-var CRn:u8
        let s_4707_3: u8 = fn_state.CRn;
        // D s_4707_4: read-var opc2:u8
        let s_4707_4: u8 = fn_state.opc2;
        // D s_4707_5: read-var CRm:u8
        let s_4707_5: u8 = fn_state.CRm;
        // D s_4707_6: read-var t:i
        let s_4707_6: i128 = fn_state.t;
        // D s_4707_7: call ICH_AP0R_SysRegWrite32_e8bf01c9f2e53161(s_4707_0, s_4707_1, s_4707_2, s_4707_3, s_4707_4, s_4707_5, s_4707_6)
        let s_4707_7: () = ICH_AP0R_SysRegWrite32_e8bf01c9f2e53161(
            state,
            tracer,
            s_4707_0,
            s_4707_1,
            s_4707_2,
            s_4707_3,
            s_4707_4,
            s_4707_5,
            s_4707_6,
        );
        // N s_4707_8: return
        return;
    }
    fn block_4708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4708_0: read-var opc2:u8
        let s_4708_0: u8 = fn_state.opc2;
        // D s_4708_1: cast zx s_4708_0 -> bv
        let s_4708_1: Bits = Bits::new(s_4708_0 as u128, 3u16);
        // C s_4708_2: const #3u : u8
        let s_4708_2: u8 = 3;
        // C s_4708_3: cast zx s_4708_2 -> bv
        let s_4708_3: Bits = Bits::new(s_4708_2 as u128, 3u16);
        // D s_4708_4: cmp-eq s_4708_1 s_4708_3
        let s_4708_4: bool = ((s_4708_1) == (s_4708_3));
        // D s_4708_5: write-var gs#135295 <= s_4708_4
        fn_state.gs_135295 = s_4708_4;
        // N s_4708_6: jump b1835
        return block_1835(state, tracer, fn_state);
    }
    fn block_4709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4709_0: read-var opc1:u8
        let s_4709_0: u8 = fn_state.opc1;
        // D s_4709_1: cast zx s_4709_0 -> bv
        let s_4709_1: Bits = Bits::new(s_4709_0 as u128, 3u16);
        // C s_4709_2: const #4u : u8
        let s_4709_2: u8 = 4;
        // C s_4709_3: cast zx s_4709_2 -> bv
        let s_4709_3: Bits = Bits::new(s_4709_2 as u128, 3u16);
        // D s_4709_4: cmp-eq s_4709_1 s_4709_3
        let s_4709_4: bool = ((s_4709_1) == (s_4709_3));
        // D s_4709_5: write-var gs#135294 <= s_4709_4
        fn_state.gs_135294 = s_4709_4;
        // N s_4709_6: jump b1833
        return block_1833(state, tracer, fn_state);
    }
    fn block_4710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4710_0: read-var coproc:u8
        let s_4710_0: u8 = fn_state.coproc;
        // D s_4710_1: cast zx s_4710_0 -> bv
        let s_4710_1: Bits = Bits::new(s_4710_0 as u128, 4u16);
        // C s_4710_2: const #15u : u8
        let s_4710_2: u8 = 15;
        // C s_4710_3: cast zx s_4710_2 -> bv
        let s_4710_3: Bits = Bits::new(s_4710_2 as u128, 4u16);
        // D s_4710_4: cmp-eq s_4710_1 s_4710_3
        let s_4710_4: bool = ((s_4710_1) == (s_4710_3));
        // D s_4710_5: write-var gs#135293 <= s_4710_4
        fn_state.gs_135293 = s_4710_4;
        // N s_4710_6: jump b1831
        return block_1831(state, tracer, fn_state);
    }
    fn block_4711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4711_0: read-var CRn:u8
        let s_4711_0: u8 = fn_state.CRn;
        // D s_4711_1: cast zx s_4711_0 -> bv
        let s_4711_1: Bits = Bits::new(s_4711_0 as u128, 4u16);
        // C s_4711_2: const #12u : u8
        let s_4711_2: u8 = 12;
        // C s_4711_3: cast zx s_4711_2 -> bv
        let s_4711_3: Bits = Bits::new(s_4711_2 as u128, 4u16);
        // D s_4711_4: cmp-eq s_4711_1 s_4711_3
        let s_4711_4: bool = ((s_4711_1) == (s_4711_3));
        // D s_4711_5: write-var gs#135292 <= s_4711_4
        fn_state.gs_135292 = s_4711_4;
        // N s_4711_6: jump b1829
        return block_1829(state, tracer, fn_state);
    }
    fn block_4712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4712_0: read-var el:u8
        let s_4712_0: u8 = fn_state.el;
        // D s_4712_1: read-var coproc:u8
        let s_4712_1: u8 = fn_state.coproc;
        // D s_4712_2: read-var opc1:u8
        let s_4712_2: u8 = fn_state.opc1;
        // D s_4712_3: read-var CRn:u8
        let s_4712_3: u8 = fn_state.CRn;
        // D s_4712_4: read-var opc2:u8
        let s_4712_4: u8 = fn_state.opc2;
        // D s_4712_5: read-var CRm:u8
        let s_4712_5: u8 = fn_state.CRm;
        // D s_4712_6: read-var t:i
        let s_4712_6: i128 = fn_state.t;
        // D s_4712_7: call DVPRCTX_SysRegWrite32_60021502cabbda39(s_4712_0, s_4712_1, s_4712_2, s_4712_3, s_4712_4, s_4712_5, s_4712_6)
        let s_4712_7: () = DVPRCTX_SysRegWrite32_60021502cabbda39(
            state,
            tracer,
            s_4712_0,
            s_4712_1,
            s_4712_2,
            s_4712_3,
            s_4712_4,
            s_4712_5,
            s_4712_6,
        );
        // N s_4712_8: return
        return;
    }
    fn block_4713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4713_0: read-var opc2:u8
        let s_4713_0: u8 = fn_state.opc2;
        // D s_4713_1: cast zx s_4713_0 -> bv
        let s_4713_1: Bits = Bits::new(s_4713_0 as u128, 3u16);
        // C s_4713_2: const #5u : u8
        let s_4713_2: u8 = 5;
        // C s_4713_3: cast zx s_4713_2 -> bv
        let s_4713_3: Bits = Bits::new(s_4713_2 as u128, 3u16);
        // D s_4713_4: cmp-eq s_4713_1 s_4713_3
        let s_4713_4: bool = ((s_4713_1) == (s_4713_3));
        // D s_4713_5: write-var gs#135291 <= s_4713_4
        fn_state.gs_135291 = s_4713_4;
        // N s_4713_6: jump b1826
        return block_1826(state, tracer, fn_state);
    }
    fn block_4714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4714_0: read-var opc1:u8
        let s_4714_0: u8 = fn_state.opc1;
        // D s_4714_1: cast zx s_4714_0 -> bv
        let s_4714_1: Bits = Bits::new(s_4714_0 as u128, 3u16);
        // C s_4714_2: const #0u : u8
        let s_4714_2: u8 = 0;
        // C s_4714_3: cast zx s_4714_2 -> bv
        let s_4714_3: Bits = Bits::new(s_4714_2 as u128, 3u16);
        // D s_4714_4: cmp-eq s_4714_1 s_4714_3
        let s_4714_4: bool = ((s_4714_1) == (s_4714_3));
        // D s_4714_5: write-var gs#135290 <= s_4714_4
        fn_state.gs_135290 = s_4714_4;
        // N s_4714_6: jump b1824
        return block_1824(state, tracer, fn_state);
    }
    fn block_4715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4715_0: read-var coproc:u8
        let s_4715_0: u8 = fn_state.coproc;
        // D s_4715_1: cast zx s_4715_0 -> bv
        let s_4715_1: Bits = Bits::new(s_4715_0 as u128, 4u16);
        // C s_4715_2: const #15u : u8
        let s_4715_2: u8 = 15;
        // C s_4715_3: cast zx s_4715_2 -> bv
        let s_4715_3: Bits = Bits::new(s_4715_2 as u128, 4u16);
        // D s_4715_4: cmp-eq s_4715_1 s_4715_3
        let s_4715_4: bool = ((s_4715_1) == (s_4715_3));
        // D s_4715_5: write-var gs#135289 <= s_4715_4
        fn_state.gs_135289 = s_4715_4;
        // N s_4715_6: jump b1822
        return block_1822(state, tracer, fn_state);
    }
    fn block_4716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4716_0: read-var CRn:u8
        let s_4716_0: u8 = fn_state.CRn;
        // D s_4716_1: cast zx s_4716_0 -> bv
        let s_4716_1: Bits = Bits::new(s_4716_0 as u128, 4u16);
        // C s_4716_2: const #7u : u8
        let s_4716_2: u8 = 7;
        // C s_4716_3: cast zx s_4716_2 -> bv
        let s_4716_3: Bits = Bits::new(s_4716_2 as u128, 4u16);
        // D s_4716_4: cmp-eq s_4716_1 s_4716_3
        let s_4716_4: bool = ((s_4716_1) == (s_4716_3));
        // D s_4716_5: write-var gs#135288 <= s_4716_4
        fn_state.gs_135288 = s_4716_4;
        // N s_4716_6: jump b1820
        return block_1820(state, tracer, fn_state);
    }
    fn block_4717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4717_0: read-var el:u8
        let s_4717_0: u8 = fn_state.el;
        // D s_4717_1: read-var coproc:u8
        let s_4717_1: u8 = fn_state.coproc;
        // D s_4717_2: read-var opc1:u8
        let s_4717_2: u8 = fn_state.opc1;
        // D s_4717_3: read-var CRn:u8
        let s_4717_3: u8 = fn_state.CRn;
        // D s_4717_4: read-var opc2:u8
        let s_4717_4: u8 = fn_state.opc2;
        // D s_4717_5: read-var CRm:u8
        let s_4717_5: u8 = fn_state.CRm;
        // D s_4717_6: read-var t:i
        let s_4717_6: i128 = fn_state.t;
        // D s_4717_7: call PMCCFILTR_SysRegWrite32_380c0e93b25f3214(s_4717_0, s_4717_1, s_4717_2, s_4717_3, s_4717_4, s_4717_5, s_4717_6)
        let s_4717_7: () = PMCCFILTR_SysRegWrite32_380c0e93b25f3214(
            state,
            tracer,
            s_4717_0,
            s_4717_1,
            s_4717_2,
            s_4717_3,
            s_4717_4,
            s_4717_5,
            s_4717_6,
        );
        // N s_4717_8: return
        return;
    }
    fn block_4718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4718_0: read-var opc2:u8
        let s_4718_0: u8 = fn_state.opc2;
        // D s_4718_1: cast zx s_4718_0 -> bv
        let s_4718_1: Bits = Bits::new(s_4718_0 as u128, 3u16);
        // C s_4718_2: const #7u : u8
        let s_4718_2: u8 = 7;
        // C s_4718_3: cast zx s_4718_2 -> bv
        let s_4718_3: Bits = Bits::new(s_4718_2 as u128, 3u16);
        // D s_4718_4: cmp-eq s_4718_1 s_4718_3
        let s_4718_4: bool = ((s_4718_1) == (s_4718_3));
        // D s_4718_5: write-var gs#135287 <= s_4718_4
        fn_state.gs_135287 = s_4718_4;
        // N s_4718_6: jump b1817
        return block_1817(state, tracer, fn_state);
    }
    fn block_4719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4719_0: read-var opc1:u8
        let s_4719_0: u8 = fn_state.opc1;
        // D s_4719_1: cast zx s_4719_0 -> bv
        let s_4719_1: Bits = Bits::new(s_4719_0 as u128, 3u16);
        // C s_4719_2: const #0u : u8
        let s_4719_2: u8 = 0;
        // C s_4719_3: cast zx s_4719_2 -> bv
        let s_4719_3: Bits = Bits::new(s_4719_2 as u128, 3u16);
        // D s_4719_4: cmp-eq s_4719_1 s_4719_3
        let s_4719_4: bool = ((s_4719_1) == (s_4719_3));
        // D s_4719_5: write-var gs#135286 <= s_4719_4
        fn_state.gs_135286 = s_4719_4;
        // N s_4719_6: jump b1815
        return block_1815(state, tracer, fn_state);
    }
    fn block_4720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4720_0: read-var coproc:u8
        let s_4720_0: u8 = fn_state.coproc;
        // D s_4720_1: cast zx s_4720_0 -> bv
        let s_4720_1: Bits = Bits::new(s_4720_0 as u128, 4u16);
        // C s_4720_2: const #15u : u8
        let s_4720_2: u8 = 15;
        // C s_4720_3: cast zx s_4720_2 -> bv
        let s_4720_3: Bits = Bits::new(s_4720_2 as u128, 4u16);
        // D s_4720_4: cmp-eq s_4720_1 s_4720_3
        let s_4720_4: bool = ((s_4720_1) == (s_4720_3));
        // D s_4720_5: write-var gs#135285 <= s_4720_4
        fn_state.gs_135285 = s_4720_4;
        // N s_4720_6: jump b1813
        return block_1813(state, tracer, fn_state);
    }
    fn block_4721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4721_0: read-var CRn:u8
        let s_4721_0: u8 = fn_state.CRn;
        // D s_4721_1: cast zx s_4721_0 -> bv
        let s_4721_1: Bits = Bits::new(s_4721_0 as u128, 4u16);
        // C s_4721_2: const #14u : u8
        let s_4721_2: u8 = 14;
        // C s_4721_3: cast zx s_4721_2 -> bv
        let s_4721_3: Bits = Bits::new(s_4721_2 as u128, 4u16);
        // D s_4721_4: cmp-eq s_4721_1 s_4721_3
        let s_4721_4: bool = ((s_4721_1) == (s_4721_3));
        // D s_4721_5: write-var gs#135284 <= s_4721_4
        fn_state.gs_135284 = s_4721_4;
        // N s_4721_6: jump b1811
        return block_1811(state, tracer, fn_state);
    }
    fn block_4722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4722_0: read-var el:u8
        let s_4722_0: u8 = fn_state.el;
        // D s_4722_1: read-var coproc:u8
        let s_4722_1: u8 = fn_state.coproc;
        // D s_4722_2: read-var opc1:u8
        let s_4722_2: u8 = fn_state.opc1;
        // D s_4722_3: read-var CRn:u8
        let s_4722_3: u8 = fn_state.CRn;
        // D s_4722_4: read-var opc2:u8
        let s_4722_4: u8 = fn_state.opc2;
        // D s_4722_5: read-var CRm:u8
        let s_4722_5: u8 = fn_state.CRm;
        // D s_4722_6: read-var t:i
        let s_4722_6: i128 = fn_state.t;
        // D s_4722_7: call ICC_HSRE_SysRegWrite32_3352216733a79da7(s_4722_0, s_4722_1, s_4722_2, s_4722_3, s_4722_4, s_4722_5, s_4722_6)
        let s_4722_7: () = ICC_HSRE_SysRegWrite32_3352216733a79da7(
            state,
            tracer,
            s_4722_0,
            s_4722_1,
            s_4722_2,
            s_4722_3,
            s_4722_4,
            s_4722_5,
            s_4722_6,
        );
        // N s_4722_8: return
        return;
    }
    fn block_4723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4723_0: read-var opc2:u8
        let s_4723_0: u8 = fn_state.opc2;
        // D s_4723_1: cast zx s_4723_0 -> bv
        let s_4723_1: Bits = Bits::new(s_4723_0 as u128, 3u16);
        // C s_4723_2: const #5u : u8
        let s_4723_2: u8 = 5;
        // C s_4723_3: cast zx s_4723_2 -> bv
        let s_4723_3: Bits = Bits::new(s_4723_2 as u128, 3u16);
        // D s_4723_4: cmp-eq s_4723_1 s_4723_3
        let s_4723_4: bool = ((s_4723_1) == (s_4723_3));
        // D s_4723_5: write-var gs#135283 <= s_4723_4
        fn_state.gs_135283 = s_4723_4;
        // N s_4723_6: jump b1808
        return block_1808(state, tracer, fn_state);
    }
    fn block_4724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4724_0: read-var opc1:u8
        let s_4724_0: u8 = fn_state.opc1;
        // D s_4724_1: cast zx s_4724_0 -> bv
        let s_4724_1: Bits = Bits::new(s_4724_0 as u128, 3u16);
        // C s_4724_2: const #4u : u8
        let s_4724_2: u8 = 4;
        // C s_4724_3: cast zx s_4724_2 -> bv
        let s_4724_3: Bits = Bits::new(s_4724_2 as u128, 3u16);
        // D s_4724_4: cmp-eq s_4724_1 s_4724_3
        let s_4724_4: bool = ((s_4724_1) == (s_4724_3));
        // D s_4724_5: write-var gs#135282 <= s_4724_4
        fn_state.gs_135282 = s_4724_4;
        // N s_4724_6: jump b1806
        return block_1806(state, tracer, fn_state);
    }
    fn block_4725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4725_0: read-var coproc:u8
        let s_4725_0: u8 = fn_state.coproc;
        // D s_4725_1: cast zx s_4725_0 -> bv
        let s_4725_1: Bits = Bits::new(s_4725_0 as u128, 4u16);
        // C s_4725_2: const #15u : u8
        let s_4725_2: u8 = 15;
        // C s_4725_3: cast zx s_4725_2 -> bv
        let s_4725_3: Bits = Bits::new(s_4725_2 as u128, 4u16);
        // D s_4725_4: cmp-eq s_4725_1 s_4725_3
        let s_4725_4: bool = ((s_4725_1) == (s_4725_3));
        // D s_4725_5: write-var gs#135281 <= s_4725_4
        fn_state.gs_135281 = s_4725_4;
        // N s_4725_6: jump b1804
        return block_1804(state, tracer, fn_state);
    }
    fn block_4726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4726_0: read-var CRn:u8
        let s_4726_0: u8 = fn_state.CRn;
        // D s_4726_1: cast zx s_4726_0 -> bv
        let s_4726_1: Bits = Bits::new(s_4726_0 as u128, 4u16);
        // C s_4726_2: const #12u : u8
        let s_4726_2: u8 = 12;
        // C s_4726_3: cast zx s_4726_2 -> bv
        let s_4726_3: Bits = Bits::new(s_4726_2 as u128, 4u16);
        // D s_4726_4: cmp-eq s_4726_1 s_4726_3
        let s_4726_4: bool = ((s_4726_1) == (s_4726_3));
        // D s_4726_5: write-var gs#135280 <= s_4726_4
        fn_state.gs_135280 = s_4726_4;
        // N s_4726_6: jump b1802
        return block_1802(state, tracer, fn_state);
    }
    fn block_4727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4727_0: read-var el:u8
        let s_4727_0: u8 = fn_state.el;
        // D s_4727_1: read-var coproc:u8
        let s_4727_1: u8 = fn_state.coproc;
        // D s_4727_2: read-var opc1:u8
        let s_4727_2: u8 = fn_state.opc1;
        // D s_4727_3: read-var CRn:u8
        let s_4727_3: u8 = fn_state.CRn;
        // D s_4727_4: read-var opc2:u8
        let s_4727_4: u8 = fn_state.opc2;
        // D s_4727_5: read-var CRm:u8
        let s_4727_5: u8 = fn_state.CRm;
        // D s_4727_6: read-var t:i
        let s_4727_6: i128 = fn_state.t;
        // D s_4727_7: call TLBIMVAAIS_SysRegWrite32_96d1aeda66ab1386(s_4727_0, s_4727_1, s_4727_2, s_4727_3, s_4727_4, s_4727_5, s_4727_6)
        let s_4727_7: () = TLBIMVAAIS_SysRegWrite32_96d1aeda66ab1386(
            state,
            tracer,
            s_4727_0,
            s_4727_1,
            s_4727_2,
            s_4727_3,
            s_4727_4,
            s_4727_5,
            s_4727_6,
        );
        // N s_4727_8: return
        return;
    }
    fn block_4728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4728_0: read-var opc2:u8
        let s_4728_0: u8 = fn_state.opc2;
        // D s_4728_1: cast zx s_4728_0 -> bv
        let s_4728_1: Bits = Bits::new(s_4728_0 as u128, 3u16);
        // C s_4728_2: const #3u : u8
        let s_4728_2: u8 = 3;
        // C s_4728_3: cast zx s_4728_2 -> bv
        let s_4728_3: Bits = Bits::new(s_4728_2 as u128, 3u16);
        // D s_4728_4: cmp-eq s_4728_1 s_4728_3
        let s_4728_4: bool = ((s_4728_1) == (s_4728_3));
        // D s_4728_5: write-var gs#135279 <= s_4728_4
        fn_state.gs_135279 = s_4728_4;
        // N s_4728_6: jump b1799
        return block_1799(state, tracer, fn_state);
    }
    fn block_4729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4729_0: read-var opc1:u8
        let s_4729_0: u8 = fn_state.opc1;
        // D s_4729_1: cast zx s_4729_0 -> bv
        let s_4729_1: Bits = Bits::new(s_4729_0 as u128, 3u16);
        // C s_4729_2: const #0u : u8
        let s_4729_2: u8 = 0;
        // C s_4729_3: cast zx s_4729_2 -> bv
        let s_4729_3: Bits = Bits::new(s_4729_2 as u128, 3u16);
        // D s_4729_4: cmp-eq s_4729_1 s_4729_3
        let s_4729_4: bool = ((s_4729_1) == (s_4729_3));
        // D s_4729_5: write-var gs#135278 <= s_4729_4
        fn_state.gs_135278 = s_4729_4;
        // N s_4729_6: jump b1797
        return block_1797(state, tracer, fn_state);
    }
    fn block_4730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4730_0: read-var coproc:u8
        let s_4730_0: u8 = fn_state.coproc;
        // D s_4730_1: cast zx s_4730_0 -> bv
        let s_4730_1: Bits = Bits::new(s_4730_0 as u128, 4u16);
        // C s_4730_2: const #15u : u8
        let s_4730_2: u8 = 15;
        // C s_4730_3: cast zx s_4730_2 -> bv
        let s_4730_3: Bits = Bits::new(s_4730_2 as u128, 4u16);
        // D s_4730_4: cmp-eq s_4730_1 s_4730_3
        let s_4730_4: bool = ((s_4730_1) == (s_4730_3));
        // D s_4730_5: write-var gs#135277 <= s_4730_4
        fn_state.gs_135277 = s_4730_4;
        // N s_4730_6: jump b1795
        return block_1795(state, tracer, fn_state);
    }
    fn block_4731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4731_0: read-var CRn:u8
        let s_4731_0: u8 = fn_state.CRn;
        // D s_4731_1: cast zx s_4731_0 -> bv
        let s_4731_1: Bits = Bits::new(s_4731_0 as u128, 4u16);
        // C s_4731_2: const #8u : u8
        let s_4731_2: u8 = 8;
        // C s_4731_3: cast zx s_4731_2 -> bv
        let s_4731_3: Bits = Bits::new(s_4731_2 as u128, 4u16);
        // D s_4731_4: cmp-eq s_4731_1 s_4731_3
        let s_4731_4: bool = ((s_4731_1) == (s_4731_3));
        // D s_4731_5: write-var gs#135276 <= s_4731_4
        fn_state.gs_135276 = s_4731_4;
        // N s_4731_6: jump b1793
        return block_1793(state, tracer, fn_state);
    }
    fn block_4732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4732_0: read-var el:u8
        let s_4732_0: u8 = fn_state.el;
        // D s_4732_1: read-var coproc:u8
        let s_4732_1: u8 = fn_state.coproc;
        // D s_4732_2: read-var opc1:u8
        let s_4732_2: u8 = fn_state.opc1;
        // D s_4732_3: read-var CRn:u8
        let s_4732_3: u8 = fn_state.CRn;
        // D s_4732_4: read-var opc2:u8
        let s_4732_4: u8 = fn_state.opc2;
        // D s_4732_5: read-var CRm:u8
        let s_4732_5: u8 = fn_state.CRm;
        // D s_4732_6: read-var t:i
        let s_4732_6: i128 = fn_state.t;
        // D s_4732_7: call HAMAIR0_SysRegWrite32_8ce8a9ddd18b4f42(s_4732_0, s_4732_1, s_4732_2, s_4732_3, s_4732_4, s_4732_5, s_4732_6)
        let s_4732_7: () = HAMAIR0_SysRegWrite32_8ce8a9ddd18b4f42(
            state,
            tracer,
            s_4732_0,
            s_4732_1,
            s_4732_2,
            s_4732_3,
            s_4732_4,
            s_4732_5,
            s_4732_6,
        );
        // N s_4732_8: return
        return;
    }
    fn block_4733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4733_0: read-var opc2:u8
        let s_4733_0: u8 = fn_state.opc2;
        // D s_4733_1: cast zx s_4733_0 -> bv
        let s_4733_1: Bits = Bits::new(s_4733_0 as u128, 3u16);
        // C s_4733_2: const #0u : u8
        let s_4733_2: u8 = 0;
        // C s_4733_3: cast zx s_4733_2 -> bv
        let s_4733_3: Bits = Bits::new(s_4733_2 as u128, 3u16);
        // D s_4733_4: cmp-eq s_4733_1 s_4733_3
        let s_4733_4: bool = ((s_4733_1) == (s_4733_3));
        // D s_4733_5: write-var gs#135275 <= s_4733_4
        fn_state.gs_135275 = s_4733_4;
        // N s_4733_6: jump b1790
        return block_1790(state, tracer, fn_state);
    }
    fn block_4734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4734_0: read-var opc1:u8
        let s_4734_0: u8 = fn_state.opc1;
        // D s_4734_1: cast zx s_4734_0 -> bv
        let s_4734_1: Bits = Bits::new(s_4734_0 as u128, 3u16);
        // C s_4734_2: const #4u : u8
        let s_4734_2: u8 = 4;
        // C s_4734_3: cast zx s_4734_2 -> bv
        let s_4734_3: Bits = Bits::new(s_4734_2 as u128, 3u16);
        // D s_4734_4: cmp-eq s_4734_1 s_4734_3
        let s_4734_4: bool = ((s_4734_1) == (s_4734_3));
        // D s_4734_5: write-var gs#135274 <= s_4734_4
        fn_state.gs_135274 = s_4734_4;
        // N s_4734_6: jump b1788
        return block_1788(state, tracer, fn_state);
    }
    fn block_4735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4735_0: read-var coproc:u8
        let s_4735_0: u8 = fn_state.coproc;
        // D s_4735_1: cast zx s_4735_0 -> bv
        let s_4735_1: Bits = Bits::new(s_4735_0 as u128, 4u16);
        // C s_4735_2: const #15u : u8
        let s_4735_2: u8 = 15;
        // C s_4735_3: cast zx s_4735_2 -> bv
        let s_4735_3: Bits = Bits::new(s_4735_2 as u128, 4u16);
        // D s_4735_4: cmp-eq s_4735_1 s_4735_3
        let s_4735_4: bool = ((s_4735_1) == (s_4735_3));
        // D s_4735_5: write-var gs#135273 <= s_4735_4
        fn_state.gs_135273 = s_4735_4;
        // N s_4735_6: jump b1786
        return block_1786(state, tracer, fn_state);
    }
    fn block_4736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4736_0: read-var CRn:u8
        let s_4736_0: u8 = fn_state.CRn;
        // D s_4736_1: cast zx s_4736_0 -> bv
        let s_4736_1: Bits = Bits::new(s_4736_0 as u128, 4u16);
        // C s_4736_2: const #10u : u8
        let s_4736_2: u8 = 10;
        // C s_4736_3: cast zx s_4736_2 -> bv
        let s_4736_3: Bits = Bits::new(s_4736_2 as u128, 4u16);
        // D s_4736_4: cmp-eq s_4736_1 s_4736_3
        let s_4736_4: bool = ((s_4736_1) == (s_4736_3));
        // D s_4736_5: write-var gs#135272 <= s_4736_4
        fn_state.gs_135272 = s_4736_4;
        // N s_4736_6: jump b1784
        return block_1784(state, tracer, fn_state);
    }
    fn block_4737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4737_0: read-var el:u8
        let s_4737_0: u8 = fn_state.el;
        // D s_4737_1: read-var coproc:u8
        let s_4737_1: u8 = fn_state.coproc;
        // D s_4737_2: read-var opc1:u8
        let s_4737_2: u8 = fn_state.opc1;
        // D s_4737_3: read-var CRn:u8
        let s_4737_3: u8 = fn_state.CRn;
        // D s_4737_4: read-var opc2:u8
        let s_4737_4: u8 = fn_state.opc2;
        // D s_4737_5: read-var CRm:u8
        let s_4737_5: u8 = fn_state.CRm;
        // D s_4737_6: read-var t:i
        let s_4737_6: i128 = fn_state.t;
        // D s_4737_7: call HDCR_SysRegWrite32_b3fcbdce17e7337b(s_4737_0, s_4737_1, s_4737_2, s_4737_3, s_4737_4, s_4737_5, s_4737_6)
        let s_4737_7: () = HDCR_SysRegWrite32_b3fcbdce17e7337b(
            state,
            tracer,
            s_4737_0,
            s_4737_1,
            s_4737_2,
            s_4737_3,
            s_4737_4,
            s_4737_5,
            s_4737_6,
        );
        // N s_4737_8: return
        return;
    }
    fn block_4738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4738_0: read-var opc2:u8
        let s_4738_0: u8 = fn_state.opc2;
        // D s_4738_1: cast zx s_4738_0 -> bv
        let s_4738_1: Bits = Bits::new(s_4738_0 as u128, 3u16);
        // C s_4738_2: const #1u : u8
        let s_4738_2: u8 = 1;
        // C s_4738_3: cast zx s_4738_2 -> bv
        let s_4738_3: Bits = Bits::new(s_4738_2 as u128, 3u16);
        // D s_4738_4: cmp-eq s_4738_1 s_4738_3
        let s_4738_4: bool = ((s_4738_1) == (s_4738_3));
        // D s_4738_5: write-var gs#135271 <= s_4738_4
        fn_state.gs_135271 = s_4738_4;
        // N s_4738_6: jump b1781
        return block_1781(state, tracer, fn_state);
    }
    fn block_4739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4739_0: read-var opc1:u8
        let s_4739_0: u8 = fn_state.opc1;
        // D s_4739_1: cast zx s_4739_0 -> bv
        let s_4739_1: Bits = Bits::new(s_4739_0 as u128, 3u16);
        // C s_4739_2: const #4u : u8
        let s_4739_2: u8 = 4;
        // C s_4739_3: cast zx s_4739_2 -> bv
        let s_4739_3: Bits = Bits::new(s_4739_2 as u128, 3u16);
        // D s_4739_4: cmp-eq s_4739_1 s_4739_3
        let s_4739_4: bool = ((s_4739_1) == (s_4739_3));
        // D s_4739_5: write-var gs#135270 <= s_4739_4
        fn_state.gs_135270 = s_4739_4;
        // N s_4739_6: jump b1779
        return block_1779(state, tracer, fn_state);
    }
    fn block_4740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4740_0: read-var coproc:u8
        let s_4740_0: u8 = fn_state.coproc;
        // D s_4740_1: cast zx s_4740_0 -> bv
        let s_4740_1: Bits = Bits::new(s_4740_0 as u128, 4u16);
        // C s_4740_2: const #15u : u8
        let s_4740_2: u8 = 15;
        // C s_4740_3: cast zx s_4740_2 -> bv
        let s_4740_3: Bits = Bits::new(s_4740_2 as u128, 4u16);
        // D s_4740_4: cmp-eq s_4740_1 s_4740_3
        let s_4740_4: bool = ((s_4740_1) == (s_4740_3));
        // D s_4740_5: write-var gs#135269 <= s_4740_4
        fn_state.gs_135269 = s_4740_4;
        // N s_4740_6: jump b1777
        return block_1777(state, tracer, fn_state);
    }
    fn block_4741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4741_0: read-var CRn:u8
        let s_4741_0: u8 = fn_state.CRn;
        // D s_4741_1: cast zx s_4741_0 -> bv
        let s_4741_1: Bits = Bits::new(s_4741_0 as u128, 4u16);
        // C s_4741_2: const #1u : u8
        let s_4741_2: u8 = 1;
        // C s_4741_3: cast zx s_4741_2 -> bv
        let s_4741_3: Bits = Bits::new(s_4741_2 as u128, 4u16);
        // D s_4741_4: cmp-eq s_4741_1 s_4741_3
        let s_4741_4: bool = ((s_4741_1) == (s_4741_3));
        // D s_4741_5: write-var gs#135268 <= s_4741_4
        fn_state.gs_135268 = s_4741_4;
        // N s_4741_6: jump b1775
        return block_1775(state, tracer, fn_state);
    }
    fn block_4742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4742_0: read-var el:u8
        let s_4742_0: u8 = fn_state.el;
        // D s_4742_1: read-var coproc:u8
        let s_4742_1: u8 = fn_state.coproc;
        // D s_4742_2: read-var opc1:u8
        let s_4742_2: u8 = fn_state.opc1;
        // D s_4742_3: read-var CRn:u8
        let s_4742_3: u8 = fn_state.CRn;
        // D s_4742_4: read-var opc2:u8
        let s_4742_4: u8 = fn_state.opc2;
        // D s_4742_5: read-var CRm:u8
        let s_4742_5: u8 = fn_state.CRm;
        // D s_4742_6: read-var t:i
        let s_4742_6: i128 = fn_state.t;
        // D s_4742_7: call AMAIR0_SysRegWrite32_c80dd68970641167(s_4742_0, s_4742_1, s_4742_2, s_4742_3, s_4742_4, s_4742_5, s_4742_6)
        let s_4742_7: () = AMAIR0_SysRegWrite32_c80dd68970641167(
            state,
            tracer,
            s_4742_0,
            s_4742_1,
            s_4742_2,
            s_4742_3,
            s_4742_4,
            s_4742_5,
            s_4742_6,
        );
        // N s_4742_8: return
        return;
    }
    fn block_4743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4743_0: read-var opc2:u8
        let s_4743_0: u8 = fn_state.opc2;
        // D s_4743_1: cast zx s_4743_0 -> bv
        let s_4743_1: Bits = Bits::new(s_4743_0 as u128, 3u16);
        // C s_4743_2: const #0u : u8
        let s_4743_2: u8 = 0;
        // C s_4743_3: cast zx s_4743_2 -> bv
        let s_4743_3: Bits = Bits::new(s_4743_2 as u128, 3u16);
        // D s_4743_4: cmp-eq s_4743_1 s_4743_3
        let s_4743_4: bool = ((s_4743_1) == (s_4743_3));
        // D s_4743_5: write-var gs#135267 <= s_4743_4
        fn_state.gs_135267 = s_4743_4;
        // N s_4743_6: jump b1772
        return block_1772(state, tracer, fn_state);
    }
    fn block_4744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4744_0: read-var opc1:u8
        let s_4744_0: u8 = fn_state.opc1;
        // D s_4744_1: cast zx s_4744_0 -> bv
        let s_4744_1: Bits = Bits::new(s_4744_0 as u128, 3u16);
        // C s_4744_2: const #0u : u8
        let s_4744_2: u8 = 0;
        // C s_4744_3: cast zx s_4744_2 -> bv
        let s_4744_3: Bits = Bits::new(s_4744_2 as u128, 3u16);
        // D s_4744_4: cmp-eq s_4744_1 s_4744_3
        let s_4744_4: bool = ((s_4744_1) == (s_4744_3));
        // D s_4744_5: write-var gs#135266 <= s_4744_4
        fn_state.gs_135266 = s_4744_4;
        // N s_4744_6: jump b1770
        return block_1770(state, tracer, fn_state);
    }
    fn block_4745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4745_0: read-var coproc:u8
        let s_4745_0: u8 = fn_state.coproc;
        // D s_4745_1: cast zx s_4745_0 -> bv
        let s_4745_1: Bits = Bits::new(s_4745_0 as u128, 4u16);
        // C s_4745_2: const #15u : u8
        let s_4745_2: u8 = 15;
        // C s_4745_3: cast zx s_4745_2 -> bv
        let s_4745_3: Bits = Bits::new(s_4745_2 as u128, 4u16);
        // D s_4745_4: cmp-eq s_4745_1 s_4745_3
        let s_4745_4: bool = ((s_4745_1) == (s_4745_3));
        // D s_4745_5: write-var gs#135265 <= s_4745_4
        fn_state.gs_135265 = s_4745_4;
        // N s_4745_6: jump b1768
        return block_1768(state, tracer, fn_state);
    }
    fn block_4746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4746_0: read-var CRn:u8
        let s_4746_0: u8 = fn_state.CRn;
        // D s_4746_1: cast zx s_4746_0 -> bv
        let s_4746_1: Bits = Bits::new(s_4746_0 as u128, 4u16);
        // C s_4746_2: const #10u : u8
        let s_4746_2: u8 = 10;
        // C s_4746_3: cast zx s_4746_2 -> bv
        let s_4746_3: Bits = Bits::new(s_4746_2 as u128, 4u16);
        // D s_4746_4: cmp-eq s_4746_1 s_4746_3
        let s_4746_4: bool = ((s_4746_1) == (s_4746_3));
        // D s_4746_5: write-var gs#135264 <= s_4746_4
        fn_state.gs_135264 = s_4746_4;
        // N s_4746_6: jump b1766
        return block_1766(state, tracer, fn_state);
    }
    fn block_4747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4747_0: read-var el:u8
        let s_4747_0: u8 = fn_state.el;
        // D s_4747_1: read-var coproc:u8
        let s_4747_1: u8 = fn_state.coproc;
        // D s_4747_2: read-var opc1:u8
        let s_4747_2: u8 = fn_state.opc1;
        // D s_4747_3: read-var CRn:u8
        let s_4747_3: u8 = fn_state.CRn;
        // D s_4747_4: read-var opc2:u8
        let s_4747_4: u8 = fn_state.opc2;
        // D s_4747_5: read-var CRm:u8
        let s_4747_5: u8 = fn_state.CRm;
        // D s_4747_6: read-var t:i
        let s_4747_6: i128 = fn_state.t;
        // D s_4747_7: call ICH_AP1R_SysRegWrite32_28a69956588386f7(s_4747_0, s_4747_1, s_4747_2, s_4747_3, s_4747_4, s_4747_5, s_4747_6)
        let s_4747_7: () = ICH_AP1R_SysRegWrite32_28a69956588386f7(
            state,
            tracer,
            s_4747_0,
            s_4747_1,
            s_4747_2,
            s_4747_3,
            s_4747_4,
            s_4747_5,
            s_4747_6,
        );
        // N s_4747_8: return
        return;
    }
    fn block_4748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4748_0: read-var opc2:u8
        let s_4748_0: u8 = fn_state.opc2;
        // D s_4748_1: cast zx s_4748_0 -> bv
        let s_4748_1: Bits = Bits::new(s_4748_0 as u128, 3u16);
        // C s_4748_2: const #0u : u8
        let s_4748_2: u8 = 0;
        // C s_4748_3: cast zx s_4748_2 -> bv
        let s_4748_3: Bits = Bits::new(s_4748_2 as u128, 3u16);
        // D s_4748_4: cmp-eq s_4748_1 s_4748_3
        let s_4748_4: bool = ((s_4748_1) == (s_4748_3));
        // D s_4748_5: write-var gs#135263 <= s_4748_4
        fn_state.gs_135263 = s_4748_4;
        // N s_4748_6: jump b1763
        return block_1763(state, tracer, fn_state);
    }
    fn block_4749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4749_0: read-var opc1:u8
        let s_4749_0: u8 = fn_state.opc1;
        // D s_4749_1: cast zx s_4749_0 -> bv
        let s_4749_1: Bits = Bits::new(s_4749_0 as u128, 3u16);
        // C s_4749_2: const #4u : u8
        let s_4749_2: u8 = 4;
        // C s_4749_3: cast zx s_4749_2 -> bv
        let s_4749_3: Bits = Bits::new(s_4749_2 as u128, 3u16);
        // D s_4749_4: cmp-eq s_4749_1 s_4749_3
        let s_4749_4: bool = ((s_4749_1) == (s_4749_3));
        // D s_4749_5: write-var gs#135262 <= s_4749_4
        fn_state.gs_135262 = s_4749_4;
        // N s_4749_6: jump b1761
        return block_1761(state, tracer, fn_state);
    }
    fn block_4750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4750_0: read-var coproc:u8
        let s_4750_0: u8 = fn_state.coproc;
        // D s_4750_1: cast zx s_4750_0 -> bv
        let s_4750_1: Bits = Bits::new(s_4750_0 as u128, 4u16);
        // C s_4750_2: const #15u : u8
        let s_4750_2: u8 = 15;
        // C s_4750_3: cast zx s_4750_2 -> bv
        let s_4750_3: Bits = Bits::new(s_4750_2 as u128, 4u16);
        // D s_4750_4: cmp-eq s_4750_1 s_4750_3
        let s_4750_4: bool = ((s_4750_1) == (s_4750_3));
        // D s_4750_5: write-var gs#135261 <= s_4750_4
        fn_state.gs_135261 = s_4750_4;
        // N s_4750_6: jump b1759
        return block_1759(state, tracer, fn_state);
    }
    fn block_4751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4751_0: read-var CRn:u8
        let s_4751_0: u8 = fn_state.CRn;
        // D s_4751_1: cast zx s_4751_0 -> bv
        let s_4751_1: Bits = Bits::new(s_4751_0 as u128, 4u16);
        // C s_4751_2: const #12u : u8
        let s_4751_2: u8 = 12;
        // C s_4751_3: cast zx s_4751_2 -> bv
        let s_4751_3: Bits = Bits::new(s_4751_2 as u128, 4u16);
        // D s_4751_4: cmp-eq s_4751_1 s_4751_3
        let s_4751_4: bool = ((s_4751_1) == (s_4751_3));
        // D s_4751_5: write-var gs#135260 <= s_4751_4
        fn_state.gs_135260 = s_4751_4;
        // N s_4751_6: jump b1757
        return block_1757(state, tracer, fn_state);
    }
    fn block_4752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4752_0: read-var el:u8
        let s_4752_0: u8 = fn_state.el;
        // D s_4752_1: read-var coproc:u8
        let s_4752_1: u8 = fn_state.coproc;
        // D s_4752_2: read-var opc1:u8
        let s_4752_2: u8 = fn_state.opc1;
        // D s_4752_3: read-var CRn:u8
        let s_4752_3: u8 = fn_state.CRn;
        // D s_4752_4: read-var opc2:u8
        let s_4752_4: u8 = fn_state.opc2;
        // D s_4752_5: read-var CRm:u8
        let s_4752_5: u8 = fn_state.CRm;
        // D s_4752_6: read-var t:i
        let s_4752_6: i128 = fn_state.t;
        // D s_4752_7: call ICH_AP1R_SysRegWrite32_9d0709acdf26e0db(s_4752_0, s_4752_1, s_4752_2, s_4752_3, s_4752_4, s_4752_5, s_4752_6)
        let s_4752_7: () = ICH_AP1R_SysRegWrite32_9d0709acdf26e0db(
            state,
            tracer,
            s_4752_0,
            s_4752_1,
            s_4752_2,
            s_4752_3,
            s_4752_4,
            s_4752_5,
            s_4752_6,
        );
        // N s_4752_8: return
        return;
    }
    fn block_4753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4753_0: read-var opc2:u8
        let s_4753_0: u8 = fn_state.opc2;
        // D s_4753_1: cast zx s_4753_0 -> bv
        let s_4753_1: Bits = Bits::new(s_4753_0 as u128, 3u16);
        // C s_4753_2: const #1u : u8
        let s_4753_2: u8 = 1;
        // C s_4753_3: cast zx s_4753_2 -> bv
        let s_4753_3: Bits = Bits::new(s_4753_2 as u128, 3u16);
        // D s_4753_4: cmp-eq s_4753_1 s_4753_3
        let s_4753_4: bool = ((s_4753_1) == (s_4753_3));
        // D s_4753_5: write-var gs#135259 <= s_4753_4
        fn_state.gs_135259 = s_4753_4;
        // N s_4753_6: jump b1754
        return block_1754(state, tracer, fn_state);
    }
    fn block_4754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4754_0: read-var opc1:u8
        let s_4754_0: u8 = fn_state.opc1;
        // D s_4754_1: cast zx s_4754_0 -> bv
        let s_4754_1: Bits = Bits::new(s_4754_0 as u128, 3u16);
        // C s_4754_2: const #4u : u8
        let s_4754_2: u8 = 4;
        // C s_4754_3: cast zx s_4754_2 -> bv
        let s_4754_3: Bits = Bits::new(s_4754_2 as u128, 3u16);
        // D s_4754_4: cmp-eq s_4754_1 s_4754_3
        let s_4754_4: bool = ((s_4754_1) == (s_4754_3));
        // D s_4754_5: write-var gs#135258 <= s_4754_4
        fn_state.gs_135258 = s_4754_4;
        // N s_4754_6: jump b1752
        return block_1752(state, tracer, fn_state);
    }
    fn block_4755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4755_0: read-var coproc:u8
        let s_4755_0: u8 = fn_state.coproc;
        // D s_4755_1: cast zx s_4755_0 -> bv
        let s_4755_1: Bits = Bits::new(s_4755_0 as u128, 4u16);
        // C s_4755_2: const #15u : u8
        let s_4755_2: u8 = 15;
        // C s_4755_3: cast zx s_4755_2 -> bv
        let s_4755_3: Bits = Bits::new(s_4755_2 as u128, 4u16);
        // D s_4755_4: cmp-eq s_4755_1 s_4755_3
        let s_4755_4: bool = ((s_4755_1) == (s_4755_3));
        // D s_4755_5: write-var gs#135257 <= s_4755_4
        fn_state.gs_135257 = s_4755_4;
        // N s_4755_6: jump b1750
        return block_1750(state, tracer, fn_state);
    }
    fn block_4756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4756_0: read-var CRn:u8
        let s_4756_0: u8 = fn_state.CRn;
        // D s_4756_1: cast zx s_4756_0 -> bv
        let s_4756_1: Bits = Bits::new(s_4756_0 as u128, 4u16);
        // C s_4756_2: const #12u : u8
        let s_4756_2: u8 = 12;
        // C s_4756_3: cast zx s_4756_2 -> bv
        let s_4756_3: Bits = Bits::new(s_4756_2 as u128, 4u16);
        // D s_4756_4: cmp-eq s_4756_1 s_4756_3
        let s_4756_4: bool = ((s_4756_1) == (s_4756_3));
        // D s_4756_5: write-var gs#135256 <= s_4756_4
        fn_state.gs_135256 = s_4756_4;
        // N s_4756_6: jump b1748
        return block_1748(state, tracer, fn_state);
    }
    fn block_4757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4757_0: read-var el:u8
        let s_4757_0: u8 = fn_state.el;
        // D s_4757_1: read-var coproc:u8
        let s_4757_1: u8 = fn_state.coproc;
        // D s_4757_2: read-var opc1:u8
        let s_4757_2: u8 = fn_state.opc1;
        // D s_4757_3: read-var CRn:u8
        let s_4757_3: u8 = fn_state.CRn;
        // D s_4757_4: read-var opc2:u8
        let s_4757_4: u8 = fn_state.opc2;
        // D s_4757_5: read-var CRm:u8
        let s_4757_5: u8 = fn_state.CRm;
        // D s_4757_6: read-var t:i
        let s_4757_6: i128 = fn_state.t;
        // D s_4757_7: call ICH_AP1R_SysRegWrite32_100dab3ceee19d37(s_4757_0, s_4757_1, s_4757_2, s_4757_3, s_4757_4, s_4757_5, s_4757_6)
        let s_4757_7: () = ICH_AP1R_SysRegWrite32_100dab3ceee19d37(
            state,
            tracer,
            s_4757_0,
            s_4757_1,
            s_4757_2,
            s_4757_3,
            s_4757_4,
            s_4757_5,
            s_4757_6,
        );
        // N s_4757_8: return
        return;
    }
    fn block_4758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4758_0: read-var opc2:u8
        let s_4758_0: u8 = fn_state.opc2;
        // D s_4758_1: cast zx s_4758_0 -> bv
        let s_4758_1: Bits = Bits::new(s_4758_0 as u128, 3u16);
        // C s_4758_2: const #2u : u8
        let s_4758_2: u8 = 2;
        // C s_4758_3: cast zx s_4758_2 -> bv
        let s_4758_3: Bits = Bits::new(s_4758_2 as u128, 3u16);
        // D s_4758_4: cmp-eq s_4758_1 s_4758_3
        let s_4758_4: bool = ((s_4758_1) == (s_4758_3));
        // D s_4758_5: write-var gs#135255 <= s_4758_4
        fn_state.gs_135255 = s_4758_4;
        // N s_4758_6: jump b1745
        return block_1745(state, tracer, fn_state);
    }
    fn block_4759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4759_0: read-var opc1:u8
        let s_4759_0: u8 = fn_state.opc1;
        // D s_4759_1: cast zx s_4759_0 -> bv
        let s_4759_1: Bits = Bits::new(s_4759_0 as u128, 3u16);
        // C s_4759_2: const #4u : u8
        let s_4759_2: u8 = 4;
        // C s_4759_3: cast zx s_4759_2 -> bv
        let s_4759_3: Bits = Bits::new(s_4759_2 as u128, 3u16);
        // D s_4759_4: cmp-eq s_4759_1 s_4759_3
        let s_4759_4: bool = ((s_4759_1) == (s_4759_3));
        // D s_4759_5: write-var gs#135254 <= s_4759_4
        fn_state.gs_135254 = s_4759_4;
        // N s_4759_6: jump b1743
        return block_1743(state, tracer, fn_state);
    }
    fn block_4760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4760_0: read-var coproc:u8
        let s_4760_0: u8 = fn_state.coproc;
        // D s_4760_1: cast zx s_4760_0 -> bv
        let s_4760_1: Bits = Bits::new(s_4760_0 as u128, 4u16);
        // C s_4760_2: const #15u : u8
        let s_4760_2: u8 = 15;
        // C s_4760_3: cast zx s_4760_2 -> bv
        let s_4760_3: Bits = Bits::new(s_4760_2 as u128, 4u16);
        // D s_4760_4: cmp-eq s_4760_1 s_4760_3
        let s_4760_4: bool = ((s_4760_1) == (s_4760_3));
        // D s_4760_5: write-var gs#135253 <= s_4760_4
        fn_state.gs_135253 = s_4760_4;
        // N s_4760_6: jump b1741
        return block_1741(state, tracer, fn_state);
    }
    fn block_4761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4761_0: read-var CRn:u8
        let s_4761_0: u8 = fn_state.CRn;
        // D s_4761_1: cast zx s_4761_0 -> bv
        let s_4761_1: Bits = Bits::new(s_4761_0 as u128, 4u16);
        // C s_4761_2: const #12u : u8
        let s_4761_2: u8 = 12;
        // C s_4761_3: cast zx s_4761_2 -> bv
        let s_4761_3: Bits = Bits::new(s_4761_2 as u128, 4u16);
        // D s_4761_4: cmp-eq s_4761_1 s_4761_3
        let s_4761_4: bool = ((s_4761_1) == (s_4761_3));
        // D s_4761_5: write-var gs#135252 <= s_4761_4
        fn_state.gs_135252 = s_4761_4;
        // N s_4761_6: jump b1739
        return block_1739(state, tracer, fn_state);
    }
    fn block_4762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4762_0: read-var el:u8
        let s_4762_0: u8 = fn_state.el;
        // D s_4762_1: read-var coproc:u8
        let s_4762_1: u8 = fn_state.coproc;
        // D s_4762_2: read-var opc1:u8
        let s_4762_2: u8 = fn_state.opc1;
        // D s_4762_3: read-var CRn:u8
        let s_4762_3: u8 = fn_state.CRn;
        // D s_4762_4: read-var opc2:u8
        let s_4762_4: u8 = fn_state.opc2;
        // D s_4762_5: read-var CRm:u8
        let s_4762_5: u8 = fn_state.CRm;
        // D s_4762_6: read-var t:i
        let s_4762_6: i128 = fn_state.t;
        // D s_4762_7: call ICH_AP1R_SysRegWrite32_4eff4ec729dbfa39(s_4762_0, s_4762_1, s_4762_2, s_4762_3, s_4762_4, s_4762_5, s_4762_6)
        let s_4762_7: () = ICH_AP1R_SysRegWrite32_4eff4ec729dbfa39(
            state,
            tracer,
            s_4762_0,
            s_4762_1,
            s_4762_2,
            s_4762_3,
            s_4762_4,
            s_4762_5,
            s_4762_6,
        );
        // N s_4762_8: return
        return;
    }
    fn block_4763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4763_0: read-var opc2:u8
        let s_4763_0: u8 = fn_state.opc2;
        // D s_4763_1: cast zx s_4763_0 -> bv
        let s_4763_1: Bits = Bits::new(s_4763_0 as u128, 3u16);
        // C s_4763_2: const #3u : u8
        let s_4763_2: u8 = 3;
        // C s_4763_3: cast zx s_4763_2 -> bv
        let s_4763_3: Bits = Bits::new(s_4763_2 as u128, 3u16);
        // D s_4763_4: cmp-eq s_4763_1 s_4763_3
        let s_4763_4: bool = ((s_4763_1) == (s_4763_3));
        // D s_4763_5: write-var gs#135251 <= s_4763_4
        fn_state.gs_135251 = s_4763_4;
        // N s_4763_6: jump b1736
        return block_1736(state, tracer, fn_state);
    }
    fn block_4764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4764_0: read-var opc1:u8
        let s_4764_0: u8 = fn_state.opc1;
        // D s_4764_1: cast zx s_4764_0 -> bv
        let s_4764_1: Bits = Bits::new(s_4764_0 as u128, 3u16);
        // C s_4764_2: const #4u : u8
        let s_4764_2: u8 = 4;
        // C s_4764_3: cast zx s_4764_2 -> bv
        let s_4764_3: Bits = Bits::new(s_4764_2 as u128, 3u16);
        // D s_4764_4: cmp-eq s_4764_1 s_4764_3
        let s_4764_4: bool = ((s_4764_1) == (s_4764_3));
        // D s_4764_5: write-var gs#135250 <= s_4764_4
        fn_state.gs_135250 = s_4764_4;
        // N s_4764_6: jump b1734
        return block_1734(state, tracer, fn_state);
    }
    fn block_4765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4765_0: read-var coproc:u8
        let s_4765_0: u8 = fn_state.coproc;
        // D s_4765_1: cast zx s_4765_0 -> bv
        let s_4765_1: Bits = Bits::new(s_4765_0 as u128, 4u16);
        // C s_4765_2: const #15u : u8
        let s_4765_2: u8 = 15;
        // C s_4765_3: cast zx s_4765_2 -> bv
        let s_4765_3: Bits = Bits::new(s_4765_2 as u128, 4u16);
        // D s_4765_4: cmp-eq s_4765_1 s_4765_3
        let s_4765_4: bool = ((s_4765_1) == (s_4765_3));
        // D s_4765_5: write-var gs#135249 <= s_4765_4
        fn_state.gs_135249 = s_4765_4;
        // N s_4765_6: jump b1732
        return block_1732(state, tracer, fn_state);
    }
    fn block_4766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4766_0: read-var CRn:u8
        let s_4766_0: u8 = fn_state.CRn;
        // D s_4766_1: cast zx s_4766_0 -> bv
        let s_4766_1: Bits = Bits::new(s_4766_0 as u128, 4u16);
        // C s_4766_2: const #12u : u8
        let s_4766_2: u8 = 12;
        // C s_4766_3: cast zx s_4766_2 -> bv
        let s_4766_3: Bits = Bits::new(s_4766_2 as u128, 4u16);
        // D s_4766_4: cmp-eq s_4766_1 s_4766_3
        let s_4766_4: bool = ((s_4766_1) == (s_4766_3));
        // D s_4766_5: write-var gs#135248 <= s_4766_4
        fn_state.gs_135248 = s_4766_4;
        // N s_4766_6: jump b1730
        return block_1730(state, tracer, fn_state);
    }
    fn block_4767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4767_0: read-var el:u8
        let s_4767_0: u8 = fn_state.el;
        // D s_4767_1: read-var coproc:u8
        let s_4767_1: u8 = fn_state.coproc;
        // D s_4767_2: read-var opc1:u8
        let s_4767_2: u8 = fn_state.opc1;
        // D s_4767_3: read-var CRn:u8
        let s_4767_3: u8 = fn_state.CRn;
        // D s_4767_4: read-var opc2:u8
        let s_4767_4: u8 = fn_state.opc2;
        // D s_4767_5: read-var CRm:u8
        let s_4767_5: u8 = fn_state.CRm;
        // D s_4767_6: read-var t:i
        let s_4767_6: i128 = fn_state.t;
        // D s_4767_7: call NSACR_SysRegWrite32_78181d9f16e34b35(s_4767_0, s_4767_1, s_4767_2, s_4767_3, s_4767_4, s_4767_5, s_4767_6)
        let s_4767_7: () = NSACR_SysRegWrite32_78181d9f16e34b35(
            state,
            tracer,
            s_4767_0,
            s_4767_1,
            s_4767_2,
            s_4767_3,
            s_4767_4,
            s_4767_5,
            s_4767_6,
        );
        // N s_4767_8: return
        return;
    }
    fn block_4768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4768_0: read-var opc2:u8
        let s_4768_0: u8 = fn_state.opc2;
        // D s_4768_1: cast zx s_4768_0 -> bv
        let s_4768_1: Bits = Bits::new(s_4768_0 as u128, 3u16);
        // C s_4768_2: const #2u : u8
        let s_4768_2: u8 = 2;
        // C s_4768_3: cast zx s_4768_2 -> bv
        let s_4768_3: Bits = Bits::new(s_4768_2 as u128, 3u16);
        // D s_4768_4: cmp-eq s_4768_1 s_4768_3
        let s_4768_4: bool = ((s_4768_1) == (s_4768_3));
        // D s_4768_5: write-var gs#135247 <= s_4768_4
        fn_state.gs_135247 = s_4768_4;
        // N s_4768_6: jump b1727
        return block_1727(state, tracer, fn_state);
    }
    fn block_4769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4769_0: read-var opc1:u8
        let s_4769_0: u8 = fn_state.opc1;
        // D s_4769_1: cast zx s_4769_0 -> bv
        let s_4769_1: Bits = Bits::new(s_4769_0 as u128, 3u16);
        // C s_4769_2: const #0u : u8
        let s_4769_2: u8 = 0;
        // C s_4769_3: cast zx s_4769_2 -> bv
        let s_4769_3: Bits = Bits::new(s_4769_2 as u128, 3u16);
        // D s_4769_4: cmp-eq s_4769_1 s_4769_3
        let s_4769_4: bool = ((s_4769_1) == (s_4769_3));
        // D s_4769_5: write-var gs#135246 <= s_4769_4
        fn_state.gs_135246 = s_4769_4;
        // N s_4769_6: jump b1725
        return block_1725(state, tracer, fn_state);
    }
    fn block_4770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4770_0: read-var coproc:u8
        let s_4770_0: u8 = fn_state.coproc;
        // D s_4770_1: cast zx s_4770_0 -> bv
        let s_4770_1: Bits = Bits::new(s_4770_0 as u128, 4u16);
        // C s_4770_2: const #15u : u8
        let s_4770_2: u8 = 15;
        // C s_4770_3: cast zx s_4770_2 -> bv
        let s_4770_3: Bits = Bits::new(s_4770_2 as u128, 4u16);
        // D s_4770_4: cmp-eq s_4770_1 s_4770_3
        let s_4770_4: bool = ((s_4770_1) == (s_4770_3));
        // D s_4770_5: write-var gs#135245 <= s_4770_4
        fn_state.gs_135245 = s_4770_4;
        // N s_4770_6: jump b1723
        return block_1723(state, tracer, fn_state);
    }
    fn block_4771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4771_0: read-var CRn:u8
        let s_4771_0: u8 = fn_state.CRn;
        // D s_4771_1: cast zx s_4771_0 -> bv
        let s_4771_1: Bits = Bits::new(s_4771_0 as u128, 4u16);
        // C s_4771_2: const #1u : u8
        let s_4771_2: u8 = 1;
        // C s_4771_3: cast zx s_4771_2 -> bv
        let s_4771_3: Bits = Bits::new(s_4771_2 as u128, 4u16);
        // D s_4771_4: cmp-eq s_4771_1 s_4771_3
        let s_4771_4: bool = ((s_4771_1) == (s_4771_3));
        // D s_4771_5: write-var gs#135244 <= s_4771_4
        fn_state.gs_135244 = s_4771_4;
        // N s_4771_6: jump b1721
        return block_1721(state, tracer, fn_state);
    }
    fn block_4772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4772_0: read-var el:u8
        let s_4772_0: u8 = fn_state.el;
        // D s_4772_1: read-var coproc:u8
        let s_4772_1: u8 = fn_state.coproc;
        // D s_4772_2: read-var opc1:u8
        let s_4772_2: u8 = fn_state.opc1;
        // D s_4772_3: read-var CRn:u8
        let s_4772_3: u8 = fn_state.CRn;
        // D s_4772_4: read-var opc2:u8
        let s_4772_4: u8 = fn_state.opc2;
        // D s_4772_5: read-var CRm:u8
        let s_4772_5: u8 = fn_state.CRm;
        // D s_4772_6: read-var t:i
        let s_4772_6: i128 = fn_state.t;
        // D s_4772_7: call SCR_SysRegWrite32_4891195fead51a46(s_4772_0, s_4772_1, s_4772_2, s_4772_3, s_4772_4, s_4772_5, s_4772_6)
        let s_4772_7: () = SCR_SysRegWrite32_4891195fead51a46(
            state,
            tracer,
            s_4772_0,
            s_4772_1,
            s_4772_2,
            s_4772_3,
            s_4772_4,
            s_4772_5,
            s_4772_6,
        );
        // N s_4772_8: return
        return;
    }
    fn block_4773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4773_0: read-var opc2:u8
        let s_4773_0: u8 = fn_state.opc2;
        // D s_4773_1: cast zx s_4773_0 -> bv
        let s_4773_1: Bits = Bits::new(s_4773_0 as u128, 3u16);
        // C s_4773_2: const #0u : u8
        let s_4773_2: u8 = 0;
        // C s_4773_3: cast zx s_4773_2 -> bv
        let s_4773_3: Bits = Bits::new(s_4773_2 as u128, 3u16);
        // D s_4773_4: cmp-eq s_4773_1 s_4773_3
        let s_4773_4: bool = ((s_4773_1) == (s_4773_3));
        // D s_4773_5: write-var gs#135243 <= s_4773_4
        fn_state.gs_135243 = s_4773_4;
        // N s_4773_6: jump b1718
        return block_1718(state, tracer, fn_state);
    }
    fn block_4774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4774_0: read-var opc1:u8
        let s_4774_0: u8 = fn_state.opc1;
        // D s_4774_1: cast zx s_4774_0 -> bv
        let s_4774_1: Bits = Bits::new(s_4774_0 as u128, 3u16);
        // C s_4774_2: const #0u : u8
        let s_4774_2: u8 = 0;
        // C s_4774_3: cast zx s_4774_2 -> bv
        let s_4774_3: Bits = Bits::new(s_4774_2 as u128, 3u16);
        // D s_4774_4: cmp-eq s_4774_1 s_4774_3
        let s_4774_4: bool = ((s_4774_1) == (s_4774_3));
        // D s_4774_5: write-var gs#135242 <= s_4774_4
        fn_state.gs_135242 = s_4774_4;
        // N s_4774_6: jump b1716
        return block_1716(state, tracer, fn_state);
    }
    fn block_4775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4775_0: read-var coproc:u8
        let s_4775_0: u8 = fn_state.coproc;
        // D s_4775_1: cast zx s_4775_0 -> bv
        let s_4775_1: Bits = Bits::new(s_4775_0 as u128, 4u16);
        // C s_4775_2: const #15u : u8
        let s_4775_2: u8 = 15;
        // C s_4775_3: cast zx s_4775_2 -> bv
        let s_4775_3: Bits = Bits::new(s_4775_2 as u128, 4u16);
        // D s_4775_4: cmp-eq s_4775_1 s_4775_3
        let s_4775_4: bool = ((s_4775_1) == (s_4775_3));
        // D s_4775_5: write-var gs#135241 <= s_4775_4
        fn_state.gs_135241 = s_4775_4;
        // N s_4775_6: jump b1714
        return block_1714(state, tracer, fn_state);
    }
    fn block_4776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4776_0: read-var CRn:u8
        let s_4776_0: u8 = fn_state.CRn;
        // D s_4776_1: cast zx s_4776_0 -> bv
        let s_4776_1: Bits = Bits::new(s_4776_0 as u128, 4u16);
        // C s_4776_2: const #1u : u8
        let s_4776_2: u8 = 1;
        // C s_4776_3: cast zx s_4776_2 -> bv
        let s_4776_3: Bits = Bits::new(s_4776_2 as u128, 4u16);
        // D s_4776_4: cmp-eq s_4776_1 s_4776_3
        let s_4776_4: bool = ((s_4776_1) == (s_4776_3));
        // D s_4776_5: write-var gs#135240 <= s_4776_4
        fn_state.gs_135240 = s_4776_4;
        // N s_4776_6: jump b1712
        return block_1712(state, tracer, fn_state);
    }
    fn block_4777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4777_0: read-var el:u8
        let s_4777_0: u8 = fn_state.el;
        // D s_4777_1: read-var coproc:u8
        let s_4777_1: u8 = fn_state.coproc;
        // D s_4777_2: read-var opc1:u8
        let s_4777_2: u8 = fn_state.opc1;
        // D s_4777_3: read-var CRn:u8
        let s_4777_3: u8 = fn_state.CRn;
        // D s_4777_4: read-var opc2:u8
        let s_4777_4: u8 = fn_state.opc2;
        // D s_4777_5: read-var CRm:u8
        let s_4777_5: u8 = fn_state.CRm;
        // D s_4777_6: read-var t:i
        let s_4777_6: i128 = fn_state.t;
        // D s_4777_7: call CNTHVS_CTL_SysRegWrite32_018e2cf152f109f9(s_4777_0, s_4777_1, s_4777_2, s_4777_3, s_4777_4, s_4777_5, s_4777_6)
        let s_4777_7: () = CNTHVS_CTL_SysRegWrite32_018e2cf152f109f9(
            state,
            tracer,
            s_4777_0,
            s_4777_1,
            s_4777_2,
            s_4777_3,
            s_4777_4,
            s_4777_5,
            s_4777_6,
        );
        // N s_4777_8: return
        return;
    }
    fn block_4778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4778_0: read-var opc2:u8
        let s_4778_0: u8 = fn_state.opc2;
        // D s_4778_1: cast zx s_4778_0 -> bv
        let s_4778_1: Bits = Bits::new(s_4778_0 as u128, 3u16);
        // C s_4778_2: const #1u : u8
        let s_4778_2: u8 = 1;
        // C s_4778_3: cast zx s_4778_2 -> bv
        let s_4778_3: Bits = Bits::new(s_4778_2 as u128, 3u16);
        // D s_4778_4: cmp-eq s_4778_1 s_4778_3
        let s_4778_4: bool = ((s_4778_1) == (s_4778_3));
        // D s_4778_5: write-var gs#135239 <= s_4778_4
        fn_state.gs_135239 = s_4778_4;
        // N s_4778_6: jump b1709
        return block_1709(state, tracer, fn_state);
    }
    fn block_4779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4779_0: read-var opc1:u8
        let s_4779_0: u8 = fn_state.opc1;
        // D s_4779_1: cast zx s_4779_0 -> bv
        let s_4779_1: Bits = Bits::new(s_4779_0 as u128, 3u16);
        // C s_4779_2: const #0u : u8
        let s_4779_2: u8 = 0;
        // C s_4779_3: cast zx s_4779_2 -> bv
        let s_4779_3: Bits = Bits::new(s_4779_2 as u128, 3u16);
        // D s_4779_4: cmp-eq s_4779_1 s_4779_3
        let s_4779_4: bool = ((s_4779_1) == (s_4779_3));
        // D s_4779_5: write-var gs#135238 <= s_4779_4
        fn_state.gs_135238 = s_4779_4;
        // N s_4779_6: jump b1707
        return block_1707(state, tracer, fn_state);
    }
    fn block_4780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4780_0: read-var coproc:u8
        let s_4780_0: u8 = fn_state.coproc;
        // D s_4780_1: cast zx s_4780_0 -> bv
        let s_4780_1: Bits = Bits::new(s_4780_0 as u128, 4u16);
        // C s_4780_2: const #15u : u8
        let s_4780_2: u8 = 15;
        // C s_4780_3: cast zx s_4780_2 -> bv
        let s_4780_3: Bits = Bits::new(s_4780_2 as u128, 4u16);
        // D s_4780_4: cmp-eq s_4780_1 s_4780_3
        let s_4780_4: bool = ((s_4780_1) == (s_4780_3));
        // D s_4780_5: write-var gs#135237 <= s_4780_4
        fn_state.gs_135237 = s_4780_4;
        // N s_4780_6: jump b1705
        return block_1705(state, tracer, fn_state);
    }
    fn block_4781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4781_0: read-var CRn:u8
        let s_4781_0: u8 = fn_state.CRn;
        // D s_4781_1: cast zx s_4781_0 -> bv
        let s_4781_1: Bits = Bits::new(s_4781_0 as u128, 4u16);
        // C s_4781_2: const #14u : u8
        let s_4781_2: u8 = 14;
        // C s_4781_3: cast zx s_4781_2 -> bv
        let s_4781_3: Bits = Bits::new(s_4781_2 as u128, 4u16);
        // D s_4781_4: cmp-eq s_4781_1 s_4781_3
        let s_4781_4: bool = ((s_4781_1) == (s_4781_3));
        // D s_4781_5: write-var gs#135236 <= s_4781_4
        fn_state.gs_135236 = s_4781_4;
        // N s_4781_6: jump b1703
        return block_1703(state, tracer, fn_state);
    }
    fn block_4782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4782_0: read-var el:u8
        let s_4782_0: u8 = fn_state.el;
        // D s_4782_1: read-var coproc:u8
        let s_4782_1: u8 = fn_state.coproc;
        // D s_4782_2: read-var opc1:u8
        let s_4782_2: u8 = fn_state.opc1;
        // D s_4782_3: read-var CRn:u8
        let s_4782_3: u8 = fn_state.CRn;
        // D s_4782_4: read-var opc2:u8
        let s_4782_4: u8 = fn_state.opc2;
        // D s_4782_5: read-var CRm:u8
        let s_4782_5: u8 = fn_state.CRm;
        // D s_4782_6: read-var t:i
        let s_4782_6: i128 = fn_state.t;
        // D s_4782_7: call DCIMVAC_SysRegWrite32_5e319c6b6a0107ac(s_4782_0, s_4782_1, s_4782_2, s_4782_3, s_4782_4, s_4782_5, s_4782_6)
        let s_4782_7: () = DCIMVAC_SysRegWrite32_5e319c6b6a0107ac(
            state,
            tracer,
            s_4782_0,
            s_4782_1,
            s_4782_2,
            s_4782_3,
            s_4782_4,
            s_4782_5,
            s_4782_6,
        );
        // N s_4782_8: return
        return;
    }
    fn block_4783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4783_0: read-var opc2:u8
        let s_4783_0: u8 = fn_state.opc2;
        // D s_4783_1: cast zx s_4783_0 -> bv
        let s_4783_1: Bits = Bits::new(s_4783_0 as u128, 3u16);
        // C s_4783_2: const #1u : u8
        let s_4783_2: u8 = 1;
        // C s_4783_3: cast zx s_4783_2 -> bv
        let s_4783_3: Bits = Bits::new(s_4783_2 as u128, 3u16);
        // D s_4783_4: cmp-eq s_4783_1 s_4783_3
        let s_4783_4: bool = ((s_4783_1) == (s_4783_3));
        // D s_4783_5: write-var gs#135235 <= s_4783_4
        fn_state.gs_135235 = s_4783_4;
        // N s_4783_6: jump b1700
        return block_1700(state, tracer, fn_state);
    }
    fn block_4784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4784_0: read-var opc1:u8
        let s_4784_0: u8 = fn_state.opc1;
        // D s_4784_1: cast zx s_4784_0 -> bv
        let s_4784_1: Bits = Bits::new(s_4784_0 as u128, 3u16);
        // C s_4784_2: const #0u : u8
        let s_4784_2: u8 = 0;
        // C s_4784_3: cast zx s_4784_2 -> bv
        let s_4784_3: Bits = Bits::new(s_4784_2 as u128, 3u16);
        // D s_4784_4: cmp-eq s_4784_1 s_4784_3
        let s_4784_4: bool = ((s_4784_1) == (s_4784_3));
        // D s_4784_5: write-var gs#135234 <= s_4784_4
        fn_state.gs_135234 = s_4784_4;
        // N s_4784_6: jump b1698
        return block_1698(state, tracer, fn_state);
    }
    fn block_4785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4785_0: read-var coproc:u8
        let s_4785_0: u8 = fn_state.coproc;
        // D s_4785_1: cast zx s_4785_0 -> bv
        let s_4785_1: Bits = Bits::new(s_4785_0 as u128, 4u16);
        // C s_4785_2: const #15u : u8
        let s_4785_2: u8 = 15;
        // C s_4785_3: cast zx s_4785_2 -> bv
        let s_4785_3: Bits = Bits::new(s_4785_2 as u128, 4u16);
        // D s_4785_4: cmp-eq s_4785_1 s_4785_3
        let s_4785_4: bool = ((s_4785_1) == (s_4785_3));
        // D s_4785_5: write-var gs#135233 <= s_4785_4
        fn_state.gs_135233 = s_4785_4;
        // N s_4785_6: jump b1696
        return block_1696(state, tracer, fn_state);
    }
    fn block_4786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4786_0: read-var CRn:u8
        let s_4786_0: u8 = fn_state.CRn;
        // D s_4786_1: cast zx s_4786_0 -> bv
        let s_4786_1: Bits = Bits::new(s_4786_0 as u128, 4u16);
        // C s_4786_2: const #7u : u8
        let s_4786_2: u8 = 7;
        // C s_4786_3: cast zx s_4786_2 -> bv
        let s_4786_3: Bits = Bits::new(s_4786_2 as u128, 4u16);
        // D s_4786_4: cmp-eq s_4786_1 s_4786_3
        let s_4786_4: bool = ((s_4786_1) == (s_4786_3));
        // D s_4786_5: write-var gs#135232 <= s_4786_4
        fn_state.gs_135232 = s_4786_4;
        // N s_4786_6: jump b1694
        return block_1694(state, tracer, fn_state);
    }
    fn block_4787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4787_0: read-var el:u8
        let s_4787_0: u8 = fn_state.el;
        // D s_4787_1: read-var coproc:u8
        let s_4787_1: u8 = fn_state.coproc;
        // D s_4787_2: read-var opc1:u8
        let s_4787_2: u8 = fn_state.opc1;
        // D s_4787_3: read-var CRn:u8
        let s_4787_3: u8 = fn_state.CRn;
        // D s_4787_4: read-var opc2:u8
        let s_4787_4: u8 = fn_state.opc2;
        // D s_4787_5: read-var CRm:u8
        let s_4787_5: u8 = fn_state.CRm;
        // D s_4787_6: read-var t:i
        let s_4787_6: i128 = fn_state.t;
        // D s_4787_7: call DBGDTRRXext_SysRegWrite32_b2264bfa940c912c(s_4787_0, s_4787_1, s_4787_2, s_4787_3, s_4787_4, s_4787_5, s_4787_6)
        let s_4787_7: () = DBGDTRRXext_SysRegWrite32_b2264bfa940c912c(
            state,
            tracer,
            s_4787_0,
            s_4787_1,
            s_4787_2,
            s_4787_3,
            s_4787_4,
            s_4787_5,
            s_4787_6,
        );
        // N s_4787_8: return
        return;
    }
    fn block_4788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4788_0: read-var opc2:u8
        let s_4788_0: u8 = fn_state.opc2;
        // D s_4788_1: cast zx s_4788_0 -> bv
        let s_4788_1: Bits = Bits::new(s_4788_0 as u128, 3u16);
        // C s_4788_2: const #2u : u8
        let s_4788_2: u8 = 2;
        // C s_4788_3: cast zx s_4788_2 -> bv
        let s_4788_3: Bits = Bits::new(s_4788_2 as u128, 3u16);
        // D s_4788_4: cmp-eq s_4788_1 s_4788_3
        let s_4788_4: bool = ((s_4788_1) == (s_4788_3));
        // D s_4788_5: write-var gs#135231 <= s_4788_4
        fn_state.gs_135231 = s_4788_4;
        // N s_4788_6: jump b1691
        return block_1691(state, tracer, fn_state);
    }
    fn block_4789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4789_0: read-var opc1:u8
        let s_4789_0: u8 = fn_state.opc1;
        // D s_4789_1: cast zx s_4789_0 -> bv
        let s_4789_1: Bits = Bits::new(s_4789_0 as u128, 3u16);
        // C s_4789_2: const #0u : u8
        let s_4789_2: u8 = 0;
        // C s_4789_3: cast zx s_4789_2 -> bv
        let s_4789_3: Bits = Bits::new(s_4789_2 as u128, 3u16);
        // D s_4789_4: cmp-eq s_4789_1 s_4789_3
        let s_4789_4: bool = ((s_4789_1) == (s_4789_3));
        // D s_4789_5: write-var gs#135230 <= s_4789_4
        fn_state.gs_135230 = s_4789_4;
        // N s_4789_6: jump b1689
        return block_1689(state, tracer, fn_state);
    }
    fn block_4790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4790_0: read-var coproc:u8
        let s_4790_0: u8 = fn_state.coproc;
        // D s_4790_1: cast zx s_4790_0 -> bv
        let s_4790_1: Bits = Bits::new(s_4790_0 as u128, 4u16);
        // C s_4790_2: const #14u : u8
        let s_4790_2: u8 = 14;
        // C s_4790_3: cast zx s_4790_2 -> bv
        let s_4790_3: Bits = Bits::new(s_4790_2 as u128, 4u16);
        // D s_4790_4: cmp-eq s_4790_1 s_4790_3
        let s_4790_4: bool = ((s_4790_1) == (s_4790_3));
        // D s_4790_5: write-var gs#135229 <= s_4790_4
        fn_state.gs_135229 = s_4790_4;
        // N s_4790_6: jump b1687
        return block_1687(state, tracer, fn_state);
    }
    fn block_4791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4791_0: read-var CRn:u8
        let s_4791_0: u8 = fn_state.CRn;
        // D s_4791_1: cast zx s_4791_0 -> bv
        let s_4791_1: Bits = Bits::new(s_4791_0 as u128, 4u16);
        // C s_4791_2: const #0u : u8
        let s_4791_2: u8 = 0;
        // C s_4791_3: cast zx s_4791_2 -> bv
        let s_4791_3: Bits = Bits::new(s_4791_2 as u128, 4u16);
        // D s_4791_4: cmp-eq s_4791_1 s_4791_3
        let s_4791_4: bool = ((s_4791_1) == (s_4791_3));
        // D s_4791_5: write-var gs#135228 <= s_4791_4
        fn_state.gs_135228 = s_4791_4;
        // N s_4791_6: jump b1685
        return block_1685(state, tracer, fn_state);
    }
    fn block_4792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4792_0: read-var el:u8
        let s_4792_0: u8 = fn_state.el;
        // D s_4792_1: read-var coproc:u8
        let s_4792_1: u8 = fn_state.coproc;
        // D s_4792_2: read-var opc1:u8
        let s_4792_2: u8 = fn_state.opc1;
        // D s_4792_3: read-var CRn:u8
        let s_4792_3: u8 = fn_state.CRn;
        // D s_4792_4: read-var opc2:u8
        let s_4792_4: u8 = fn_state.opc2;
        // D s_4792_5: read-var CRm:u8
        let s_4792_5: u8 = fn_state.CRm;
        // D s_4792_6: read-var t:i
        let s_4792_6: i128 = fn_state.t;
        // D s_4792_7: call DBGOSLAR_SysRegWrite32_38360f8339ba583f(s_4792_0, s_4792_1, s_4792_2, s_4792_3, s_4792_4, s_4792_5, s_4792_6)
        let s_4792_7: () = DBGOSLAR_SysRegWrite32_38360f8339ba583f(
            state,
            tracer,
            s_4792_0,
            s_4792_1,
            s_4792_2,
            s_4792_3,
            s_4792_4,
            s_4792_5,
            s_4792_6,
        );
        // N s_4792_8: return
        return;
    }
    fn block_4793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4793_0: read-var opc2:u8
        let s_4793_0: u8 = fn_state.opc2;
        // D s_4793_1: cast zx s_4793_0 -> bv
        let s_4793_1: Bits = Bits::new(s_4793_0 as u128, 3u16);
        // C s_4793_2: const #4u : u8
        let s_4793_2: u8 = 4;
        // C s_4793_3: cast zx s_4793_2 -> bv
        let s_4793_3: Bits = Bits::new(s_4793_2 as u128, 3u16);
        // D s_4793_4: cmp-eq s_4793_1 s_4793_3
        let s_4793_4: bool = ((s_4793_1) == (s_4793_3));
        // D s_4793_5: write-var gs#135227 <= s_4793_4
        fn_state.gs_135227 = s_4793_4;
        // N s_4793_6: jump b1682
        return block_1682(state, tracer, fn_state);
    }
    fn block_4794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4794_0: read-var opc1:u8
        let s_4794_0: u8 = fn_state.opc1;
        // D s_4794_1: cast zx s_4794_0 -> bv
        let s_4794_1: Bits = Bits::new(s_4794_0 as u128, 3u16);
        // C s_4794_2: const #0u : u8
        let s_4794_2: u8 = 0;
        // C s_4794_3: cast zx s_4794_2 -> bv
        let s_4794_3: Bits = Bits::new(s_4794_2 as u128, 3u16);
        // D s_4794_4: cmp-eq s_4794_1 s_4794_3
        let s_4794_4: bool = ((s_4794_1) == (s_4794_3));
        // D s_4794_5: write-var gs#135226 <= s_4794_4
        fn_state.gs_135226 = s_4794_4;
        // N s_4794_6: jump b1680
        return block_1680(state, tracer, fn_state);
    }
    fn block_4795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4795_0: read-var coproc:u8
        let s_4795_0: u8 = fn_state.coproc;
        // D s_4795_1: cast zx s_4795_0 -> bv
        let s_4795_1: Bits = Bits::new(s_4795_0 as u128, 4u16);
        // C s_4795_2: const #14u : u8
        let s_4795_2: u8 = 14;
        // C s_4795_3: cast zx s_4795_2 -> bv
        let s_4795_3: Bits = Bits::new(s_4795_2 as u128, 4u16);
        // D s_4795_4: cmp-eq s_4795_1 s_4795_3
        let s_4795_4: bool = ((s_4795_1) == (s_4795_3));
        // D s_4795_5: write-var gs#135225 <= s_4795_4
        fn_state.gs_135225 = s_4795_4;
        // N s_4795_6: jump b1678
        return block_1678(state, tracer, fn_state);
    }
    fn block_4796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4796_0: read-var CRn:u8
        let s_4796_0: u8 = fn_state.CRn;
        // D s_4796_1: cast zx s_4796_0 -> bv
        let s_4796_1: Bits = Bits::new(s_4796_0 as u128, 4u16);
        // C s_4796_2: const #1u : u8
        let s_4796_2: u8 = 1;
        // C s_4796_3: cast zx s_4796_2 -> bv
        let s_4796_3: Bits = Bits::new(s_4796_2 as u128, 4u16);
        // D s_4796_4: cmp-eq s_4796_1 s_4796_3
        let s_4796_4: bool = ((s_4796_1) == (s_4796_3));
        // D s_4796_5: write-var gs#135224 <= s_4796_4
        fn_state.gs_135224 = s_4796_4;
        // N s_4796_6: jump b1676
        return block_1676(state, tracer, fn_state);
    }
    fn block_4797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4797_0: read-var el:u8
        let s_4797_0: u8 = fn_state.el;
        // D s_4797_1: read-var coproc:u8
        let s_4797_1: u8 = fn_state.coproc;
        // D s_4797_2: read-var opc1:u8
        let s_4797_2: u8 = fn_state.opc1;
        // D s_4797_3: read-var CRn:u8
        let s_4797_3: u8 = fn_state.CRn;
        // D s_4797_4: read-var opc2:u8
        let s_4797_4: u8 = fn_state.opc2;
        // D s_4797_5: read-var CRm:u8
        let s_4797_5: u8 = fn_state.CRm;
        // D s_4797_6: read-var t:i
        let s_4797_6: i128 = fn_state.t;
        // D s_4797_7: call TLBIASID_SysRegWrite32_fb38392a6a11d341(s_4797_0, s_4797_1, s_4797_2, s_4797_3, s_4797_4, s_4797_5, s_4797_6)
        let s_4797_7: () = TLBIASID_SysRegWrite32_fb38392a6a11d341(
            state,
            tracer,
            s_4797_0,
            s_4797_1,
            s_4797_2,
            s_4797_3,
            s_4797_4,
            s_4797_5,
            s_4797_6,
        );
        // N s_4797_8: return
        return;
    }
    fn block_4798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4798_0: read-var opc2:u8
        let s_4798_0: u8 = fn_state.opc2;
        // D s_4798_1: cast zx s_4798_0 -> bv
        let s_4798_1: Bits = Bits::new(s_4798_0 as u128, 3u16);
        // C s_4798_2: const #2u : u8
        let s_4798_2: u8 = 2;
        // C s_4798_3: cast zx s_4798_2 -> bv
        let s_4798_3: Bits = Bits::new(s_4798_2 as u128, 3u16);
        // D s_4798_4: cmp-eq s_4798_1 s_4798_3
        let s_4798_4: bool = ((s_4798_1) == (s_4798_3));
        // D s_4798_5: write-var gs#135223 <= s_4798_4
        fn_state.gs_135223 = s_4798_4;
        // N s_4798_6: jump b1673
        return block_1673(state, tracer, fn_state);
    }
    fn block_4799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4799_0: read-var opc1:u8
        let s_4799_0: u8 = fn_state.opc1;
        // D s_4799_1: cast zx s_4799_0 -> bv
        let s_4799_1: Bits = Bits::new(s_4799_0 as u128, 3u16);
        // C s_4799_2: const #0u : u8
        let s_4799_2: u8 = 0;
        // C s_4799_3: cast zx s_4799_2 -> bv
        let s_4799_3: Bits = Bits::new(s_4799_2 as u128, 3u16);
        // D s_4799_4: cmp-eq s_4799_1 s_4799_3
        let s_4799_4: bool = ((s_4799_1) == (s_4799_3));
        // D s_4799_5: write-var gs#135222 <= s_4799_4
        fn_state.gs_135222 = s_4799_4;
        // N s_4799_6: jump b1671
        return block_1671(state, tracer, fn_state);
    }
    fn block_4800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4800_0: read-var coproc:u8
        let s_4800_0: u8 = fn_state.coproc;
        // D s_4800_1: cast zx s_4800_0 -> bv
        let s_4800_1: Bits = Bits::new(s_4800_0 as u128, 4u16);
        // C s_4800_2: const #15u : u8
        let s_4800_2: u8 = 15;
        // C s_4800_3: cast zx s_4800_2 -> bv
        let s_4800_3: Bits = Bits::new(s_4800_2 as u128, 4u16);
        // D s_4800_4: cmp-eq s_4800_1 s_4800_3
        let s_4800_4: bool = ((s_4800_1) == (s_4800_3));
        // D s_4800_5: write-var gs#135221 <= s_4800_4
        fn_state.gs_135221 = s_4800_4;
        // N s_4800_6: jump b1669
        return block_1669(state, tracer, fn_state);
    }
    fn block_4801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4801_0: read-var CRn:u8
        let s_4801_0: u8 = fn_state.CRn;
        // D s_4801_1: cast zx s_4801_0 -> bv
        let s_4801_1: Bits = Bits::new(s_4801_0 as u128, 4u16);
        // C s_4801_2: const #8u : u8
        let s_4801_2: u8 = 8;
        // C s_4801_3: cast zx s_4801_2 -> bv
        let s_4801_3: Bits = Bits::new(s_4801_2 as u128, 4u16);
        // D s_4801_4: cmp-eq s_4801_1 s_4801_3
        let s_4801_4: bool = ((s_4801_1) == (s_4801_3));
        // D s_4801_5: write-var gs#135220 <= s_4801_4
        fn_state.gs_135220 = s_4801_4;
        // N s_4801_6: jump b1667
        return block_1667(state, tracer, fn_state);
    }
    fn block_4802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4802_0: read-var el:u8
        let s_4802_0: u8 = fn_state.el;
        // D s_4802_1: read-var coproc:u8
        let s_4802_1: u8 = fn_state.coproc;
        // D s_4802_2: read-var opc1:u8
        let s_4802_2: u8 = fn_state.opc1;
        // D s_4802_3: read-var CRn:u8
        let s_4802_3: u8 = fn_state.CRn;
        // D s_4802_4: read-var opc2:u8
        let s_4802_4: u8 = fn_state.opc2;
        // D s_4802_5: read-var CRm:u8
        let s_4802_5: u8 = fn_state.CRm;
        // D s_4802_6: read-var t:i
        let s_4802_6: i128 = fn_state.t;
        // D s_4802_7: call ACTLR_SysRegWrite32_5d9dcbc79ea74dc0(s_4802_0, s_4802_1, s_4802_2, s_4802_3, s_4802_4, s_4802_5, s_4802_6)
        let s_4802_7: () = ACTLR_SysRegWrite32_5d9dcbc79ea74dc0(
            state,
            tracer,
            s_4802_0,
            s_4802_1,
            s_4802_2,
            s_4802_3,
            s_4802_4,
            s_4802_5,
            s_4802_6,
        );
        // N s_4802_8: return
        return;
    }
    fn block_4803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4803_0: read-var opc2:u8
        let s_4803_0: u8 = fn_state.opc2;
        // D s_4803_1: cast zx s_4803_0 -> bv
        let s_4803_1: Bits = Bits::new(s_4803_0 as u128, 3u16);
        // C s_4803_2: const #1u : u8
        let s_4803_2: u8 = 1;
        // C s_4803_3: cast zx s_4803_2 -> bv
        let s_4803_3: Bits = Bits::new(s_4803_2 as u128, 3u16);
        // D s_4803_4: cmp-eq s_4803_1 s_4803_3
        let s_4803_4: bool = ((s_4803_1) == (s_4803_3));
        // D s_4803_5: write-var gs#135219 <= s_4803_4
        fn_state.gs_135219 = s_4803_4;
        // N s_4803_6: jump b1664
        return block_1664(state, tracer, fn_state);
    }
    fn block_4804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4804_0: read-var opc1:u8
        let s_4804_0: u8 = fn_state.opc1;
        // D s_4804_1: cast zx s_4804_0 -> bv
        let s_4804_1: Bits = Bits::new(s_4804_0 as u128, 3u16);
        // C s_4804_2: const #0u : u8
        let s_4804_2: u8 = 0;
        // C s_4804_3: cast zx s_4804_2 -> bv
        let s_4804_3: Bits = Bits::new(s_4804_2 as u128, 3u16);
        // D s_4804_4: cmp-eq s_4804_1 s_4804_3
        let s_4804_4: bool = ((s_4804_1) == (s_4804_3));
        // D s_4804_5: write-var gs#135218 <= s_4804_4
        fn_state.gs_135218 = s_4804_4;
        // N s_4804_6: jump b1662
        return block_1662(state, tracer, fn_state);
    }
    fn block_4805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4805_0: read-var coproc:u8
        let s_4805_0: u8 = fn_state.coproc;
        // D s_4805_1: cast zx s_4805_0 -> bv
        let s_4805_1: Bits = Bits::new(s_4805_0 as u128, 4u16);
        // C s_4805_2: const #15u : u8
        let s_4805_2: u8 = 15;
        // C s_4805_3: cast zx s_4805_2 -> bv
        let s_4805_3: Bits = Bits::new(s_4805_2 as u128, 4u16);
        // D s_4805_4: cmp-eq s_4805_1 s_4805_3
        let s_4805_4: bool = ((s_4805_1) == (s_4805_3));
        // D s_4805_5: write-var gs#135217 <= s_4805_4
        fn_state.gs_135217 = s_4805_4;
        // N s_4805_6: jump b1660
        return block_1660(state, tracer, fn_state);
    }
    fn block_4806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4806_0: read-var CRn:u8
        let s_4806_0: u8 = fn_state.CRn;
        // D s_4806_1: cast zx s_4806_0 -> bv
        let s_4806_1: Bits = Bits::new(s_4806_0 as u128, 4u16);
        // C s_4806_2: const #1u : u8
        let s_4806_2: u8 = 1;
        // C s_4806_3: cast zx s_4806_2 -> bv
        let s_4806_3: Bits = Bits::new(s_4806_2 as u128, 4u16);
        // D s_4806_4: cmp-eq s_4806_1 s_4806_3
        let s_4806_4: bool = ((s_4806_1) == (s_4806_3));
        // D s_4806_5: write-var gs#135216 <= s_4806_4
        fn_state.gs_135216 = s_4806_4;
        // N s_4806_6: jump b1658
        return block_1658(state, tracer, fn_state);
    }
    fn block_4807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4807_0: read-var el:u8
        let s_4807_0: u8 = fn_state.el;
        // D s_4807_1: read-var coproc:u8
        let s_4807_1: u8 = fn_state.coproc;
        // D s_4807_2: read-var opc1:u8
        let s_4807_2: u8 = fn_state.opc1;
        // D s_4807_3: read-var CRn:u8
        let s_4807_3: u8 = fn_state.CRn;
        // D s_4807_4: read-var opc2:u8
        let s_4807_4: u8 = fn_state.opc2;
        // D s_4807_5: read-var CRm:u8
        let s_4807_5: u8 = fn_state.CRm;
        // D s_4807_6: read-var t:i
        let s_4807_6: i128 = fn_state.t;
        // D s_4807_7: call DBGDTRTXext_SysRegWrite32_ed4d54f3969e2f78(s_4807_0, s_4807_1, s_4807_2, s_4807_3, s_4807_4, s_4807_5, s_4807_6)
        let s_4807_7: () = DBGDTRTXext_SysRegWrite32_ed4d54f3969e2f78(
            state,
            tracer,
            s_4807_0,
            s_4807_1,
            s_4807_2,
            s_4807_3,
            s_4807_4,
            s_4807_5,
            s_4807_6,
        );
        // N s_4807_8: return
        return;
    }
    fn block_4808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4808_0: read-var opc2:u8
        let s_4808_0: u8 = fn_state.opc2;
        // D s_4808_1: cast zx s_4808_0 -> bv
        let s_4808_1: Bits = Bits::new(s_4808_0 as u128, 3u16);
        // C s_4808_2: const #2u : u8
        let s_4808_2: u8 = 2;
        // C s_4808_3: cast zx s_4808_2 -> bv
        let s_4808_3: Bits = Bits::new(s_4808_2 as u128, 3u16);
        // D s_4808_4: cmp-eq s_4808_1 s_4808_3
        let s_4808_4: bool = ((s_4808_1) == (s_4808_3));
        // D s_4808_5: write-var gs#135215 <= s_4808_4
        fn_state.gs_135215 = s_4808_4;
        // N s_4808_6: jump b1655
        return block_1655(state, tracer, fn_state);
    }
    fn block_4809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4809_0: read-var opc1:u8
        let s_4809_0: u8 = fn_state.opc1;
        // D s_4809_1: cast zx s_4809_0 -> bv
        let s_4809_1: Bits = Bits::new(s_4809_0 as u128, 3u16);
        // C s_4809_2: const #0u : u8
        let s_4809_2: u8 = 0;
        // C s_4809_3: cast zx s_4809_2 -> bv
        let s_4809_3: Bits = Bits::new(s_4809_2 as u128, 3u16);
        // D s_4809_4: cmp-eq s_4809_1 s_4809_3
        let s_4809_4: bool = ((s_4809_1) == (s_4809_3));
        // D s_4809_5: write-var gs#135214 <= s_4809_4
        fn_state.gs_135214 = s_4809_4;
        // N s_4809_6: jump b1653
        return block_1653(state, tracer, fn_state);
    }
    fn block_4810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4810_0: read-var coproc:u8
        let s_4810_0: u8 = fn_state.coproc;
        // D s_4810_1: cast zx s_4810_0 -> bv
        let s_4810_1: Bits = Bits::new(s_4810_0 as u128, 4u16);
        // C s_4810_2: const #14u : u8
        let s_4810_2: u8 = 14;
        // C s_4810_3: cast zx s_4810_2 -> bv
        let s_4810_3: Bits = Bits::new(s_4810_2 as u128, 4u16);
        // D s_4810_4: cmp-eq s_4810_1 s_4810_3
        let s_4810_4: bool = ((s_4810_1) == (s_4810_3));
        // D s_4810_5: write-var gs#135213 <= s_4810_4
        fn_state.gs_135213 = s_4810_4;
        // N s_4810_6: jump b1651
        return block_1651(state, tracer, fn_state);
    }
    fn block_4811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4811_0: read-var CRn:u8
        let s_4811_0: u8 = fn_state.CRn;
        // D s_4811_1: cast zx s_4811_0 -> bv
        let s_4811_1: Bits = Bits::new(s_4811_0 as u128, 4u16);
        // C s_4811_2: const #0u : u8
        let s_4811_2: u8 = 0;
        // C s_4811_3: cast zx s_4811_2 -> bv
        let s_4811_3: Bits = Bits::new(s_4811_2 as u128, 4u16);
        // D s_4811_4: cmp-eq s_4811_1 s_4811_3
        let s_4811_4: bool = ((s_4811_1) == (s_4811_3));
        // D s_4811_5: write-var gs#135212 <= s_4811_4
        fn_state.gs_135212 = s_4811_4;
        // N s_4811_6: jump b1649
        return block_1649(state, tracer, fn_state);
    }
    fn block_4812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4812_0: read-var el:u8
        let s_4812_0: u8 = fn_state.el;
        // D s_4812_1: read-var coproc:u8
        let s_4812_1: u8 = fn_state.coproc;
        // D s_4812_2: read-var opc1:u8
        let s_4812_2: u8 = fn_state.opc1;
        // D s_4812_3: read-var CRn:u8
        let s_4812_3: u8 = fn_state.CRn;
        // D s_4812_4: read-var opc2:u8
        let s_4812_4: u8 = fn_state.opc2;
        // D s_4812_5: read-var CRm:u8
        let s_4812_5: u8 = fn_state.CRm;
        // D s_4812_6: read-var t:i
        let s_4812_6: i128 = fn_state.t;
        // D s_4812_7: call PMEVCNTR_SysRegWrite32_77aaca2b0146bfed(s_4812_0, s_4812_1, s_4812_2, s_4812_3, s_4812_4, s_4812_5, s_4812_6)
        let s_4812_7: () = PMEVCNTR_SysRegWrite32_77aaca2b0146bfed(
            state,
            tracer,
            s_4812_0,
            s_4812_1,
            s_4812_2,
            s_4812_3,
            s_4812_4,
            s_4812_5,
            s_4812_6,
        );
        // N s_4812_8: return
        return;
    }
    fn block_4813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4813_0: read-var opc2:u8
        let s_4813_0: u8 = fn_state.opc2;
        // D s_4813_1: cast zx s_4813_0 -> bv
        let s_4813_1: Bits = Bits::new(s_4813_0 as u128, 3u16);
        // C s_4813_2: const #0u : u8
        let s_4813_2: u8 = 0;
        // C s_4813_3: cast zx s_4813_2 -> bv
        let s_4813_3: Bits = Bits::new(s_4813_2 as u128, 3u16);
        // D s_4813_4: cmp-eq s_4813_1 s_4813_3
        let s_4813_4: bool = ((s_4813_1) == (s_4813_3));
        // D s_4813_5: write-var gs#135211 <= s_4813_4
        fn_state.gs_135211 = s_4813_4;
        // N s_4813_6: jump b1646
        return block_1646(state, tracer, fn_state);
    }
    fn block_4814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4814_0: read-var opc1:u8
        let s_4814_0: u8 = fn_state.opc1;
        // D s_4814_1: cast zx s_4814_0 -> bv
        let s_4814_1: Bits = Bits::new(s_4814_0 as u128, 3u16);
        // C s_4814_2: const #0u : u8
        let s_4814_2: u8 = 0;
        // C s_4814_3: cast zx s_4814_2 -> bv
        let s_4814_3: Bits = Bits::new(s_4814_2 as u128, 3u16);
        // D s_4814_4: cmp-eq s_4814_1 s_4814_3
        let s_4814_4: bool = ((s_4814_1) == (s_4814_3));
        // D s_4814_5: write-var gs#135210 <= s_4814_4
        fn_state.gs_135210 = s_4814_4;
        // N s_4814_6: jump b1644
        return block_1644(state, tracer, fn_state);
    }
    fn block_4815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4815_0: read-var coproc:u8
        let s_4815_0: u8 = fn_state.coproc;
        // D s_4815_1: cast zx s_4815_0 -> bv
        let s_4815_1: Bits = Bits::new(s_4815_0 as u128, 4u16);
        // C s_4815_2: const #15u : u8
        let s_4815_2: u8 = 15;
        // C s_4815_3: cast zx s_4815_2 -> bv
        let s_4815_3: Bits = Bits::new(s_4815_2 as u128, 4u16);
        // D s_4815_4: cmp-eq s_4815_1 s_4815_3
        let s_4815_4: bool = ((s_4815_1) == (s_4815_3));
        // D s_4815_5: write-var gs#135209 <= s_4815_4
        fn_state.gs_135209 = s_4815_4;
        // N s_4815_6: jump b1642
        return block_1642(state, tracer, fn_state);
    }
    fn block_4816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4816_0: read-var CRn:u8
        let s_4816_0: u8 = fn_state.CRn;
        // D s_4816_1: cast zx s_4816_0 -> bv
        let s_4816_1: Bits = Bits::new(s_4816_0 as u128, 4u16);
        // C s_4816_2: const #14u : u8
        let s_4816_2: u8 = 14;
        // C s_4816_3: cast zx s_4816_2 -> bv
        let s_4816_3: Bits = Bits::new(s_4816_2 as u128, 4u16);
        // D s_4816_4: cmp-eq s_4816_1 s_4816_3
        let s_4816_4: bool = ((s_4816_1) == (s_4816_3));
        // D s_4816_5: write-var gs#135208 <= s_4816_4
        fn_state.gs_135208 = s_4816_4;
        // N s_4816_6: jump b1640
        return block_1640(state, tracer, fn_state);
    }
    fn block_4817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4817_0: read-var el:u8
        let s_4817_0: u8 = fn_state.el;
        // D s_4817_1: read-var coproc:u8
        let s_4817_1: u8 = fn_state.coproc;
        // D s_4817_2: read-var opc1:u8
        let s_4817_2: u8 = fn_state.opc1;
        // D s_4817_3: read-var CRn:u8
        let s_4817_3: u8 = fn_state.CRn;
        // D s_4817_4: read-var opc2:u8
        let s_4817_4: u8 = fn_state.opc2;
        // D s_4817_5: read-var CRm:u8
        let s_4817_5: u8 = fn_state.CRm;
        // D s_4817_6: read-var t:i
        let s_4817_6: i128 = fn_state.t;
        // D s_4817_7: call PMEVCNTR_SysRegWrite32_91fa7b9aaafbca9c(s_4817_0, s_4817_1, s_4817_2, s_4817_3, s_4817_4, s_4817_5, s_4817_6)
        let s_4817_7: () = PMEVCNTR_SysRegWrite32_91fa7b9aaafbca9c(
            state,
            tracer,
            s_4817_0,
            s_4817_1,
            s_4817_2,
            s_4817_3,
            s_4817_4,
            s_4817_5,
            s_4817_6,
        );
        // N s_4817_8: return
        return;
    }
    fn block_4818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4818_0: read-var opc2:u8
        let s_4818_0: u8 = fn_state.opc2;
        // D s_4818_1: cast zx s_4818_0 -> bv
        let s_4818_1: Bits = Bits::new(s_4818_0 as u128, 3u16);
        // C s_4818_2: const #1u : u8
        let s_4818_2: u8 = 1;
        // C s_4818_3: cast zx s_4818_2 -> bv
        let s_4818_3: Bits = Bits::new(s_4818_2 as u128, 3u16);
        // D s_4818_4: cmp-eq s_4818_1 s_4818_3
        let s_4818_4: bool = ((s_4818_1) == (s_4818_3));
        // D s_4818_5: write-var gs#135207 <= s_4818_4
        fn_state.gs_135207 = s_4818_4;
        // N s_4818_6: jump b1637
        return block_1637(state, tracer, fn_state);
    }
    fn block_4819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4819_0: read-var opc1:u8
        let s_4819_0: u8 = fn_state.opc1;
        // D s_4819_1: cast zx s_4819_0 -> bv
        let s_4819_1: Bits = Bits::new(s_4819_0 as u128, 3u16);
        // C s_4819_2: const #0u : u8
        let s_4819_2: u8 = 0;
        // C s_4819_3: cast zx s_4819_2 -> bv
        let s_4819_3: Bits = Bits::new(s_4819_2 as u128, 3u16);
        // D s_4819_4: cmp-eq s_4819_1 s_4819_3
        let s_4819_4: bool = ((s_4819_1) == (s_4819_3));
        // D s_4819_5: write-var gs#135206 <= s_4819_4
        fn_state.gs_135206 = s_4819_4;
        // N s_4819_6: jump b1635
        return block_1635(state, tracer, fn_state);
    }
    fn block_4820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4820_0: read-var coproc:u8
        let s_4820_0: u8 = fn_state.coproc;
        // D s_4820_1: cast zx s_4820_0 -> bv
        let s_4820_1: Bits = Bits::new(s_4820_0 as u128, 4u16);
        // C s_4820_2: const #15u : u8
        let s_4820_2: u8 = 15;
        // C s_4820_3: cast zx s_4820_2 -> bv
        let s_4820_3: Bits = Bits::new(s_4820_2 as u128, 4u16);
        // D s_4820_4: cmp-eq s_4820_1 s_4820_3
        let s_4820_4: bool = ((s_4820_1) == (s_4820_3));
        // D s_4820_5: write-var gs#135205 <= s_4820_4
        fn_state.gs_135205 = s_4820_4;
        // N s_4820_6: jump b1633
        return block_1633(state, tracer, fn_state);
    }
    fn block_4821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4821_0: read-var CRn:u8
        let s_4821_0: u8 = fn_state.CRn;
        // D s_4821_1: cast zx s_4821_0 -> bv
        let s_4821_1: Bits = Bits::new(s_4821_0 as u128, 4u16);
        // C s_4821_2: const #14u : u8
        let s_4821_2: u8 = 14;
        // C s_4821_3: cast zx s_4821_2 -> bv
        let s_4821_3: Bits = Bits::new(s_4821_2 as u128, 4u16);
        // D s_4821_4: cmp-eq s_4821_1 s_4821_3
        let s_4821_4: bool = ((s_4821_1) == (s_4821_3));
        // D s_4821_5: write-var gs#135204 <= s_4821_4
        fn_state.gs_135204 = s_4821_4;
        // N s_4821_6: jump b1631
        return block_1631(state, tracer, fn_state);
    }
    fn block_4822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4822_0: read-var el:u8
        let s_4822_0: u8 = fn_state.el;
        // D s_4822_1: read-var coproc:u8
        let s_4822_1: u8 = fn_state.coproc;
        // D s_4822_2: read-var opc1:u8
        let s_4822_2: u8 = fn_state.opc1;
        // D s_4822_3: read-var CRn:u8
        let s_4822_3: u8 = fn_state.CRn;
        // D s_4822_4: read-var opc2:u8
        let s_4822_4: u8 = fn_state.opc2;
        // D s_4822_5: read-var CRm:u8
        let s_4822_5: u8 = fn_state.CRm;
        // D s_4822_6: read-var t:i
        let s_4822_6: i128 = fn_state.t;
        // D s_4822_7: call PMEVCNTR_SysRegWrite32_9d177fd83b74425d(s_4822_0, s_4822_1, s_4822_2, s_4822_3, s_4822_4, s_4822_5, s_4822_6)
        let s_4822_7: () = PMEVCNTR_SysRegWrite32_9d177fd83b74425d(
            state,
            tracer,
            s_4822_0,
            s_4822_1,
            s_4822_2,
            s_4822_3,
            s_4822_4,
            s_4822_5,
            s_4822_6,
        );
        // N s_4822_8: return
        return;
    }
    fn block_4823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4823_0: read-var opc2:u8
        let s_4823_0: u8 = fn_state.opc2;
        // D s_4823_1: cast zx s_4823_0 -> bv
        let s_4823_1: Bits = Bits::new(s_4823_0 as u128, 3u16);
        // C s_4823_2: const #2u : u8
        let s_4823_2: u8 = 2;
        // C s_4823_3: cast zx s_4823_2 -> bv
        let s_4823_3: Bits = Bits::new(s_4823_2 as u128, 3u16);
        // D s_4823_4: cmp-eq s_4823_1 s_4823_3
        let s_4823_4: bool = ((s_4823_1) == (s_4823_3));
        // D s_4823_5: write-var gs#135203 <= s_4823_4
        fn_state.gs_135203 = s_4823_4;
        // N s_4823_6: jump b1628
        return block_1628(state, tracer, fn_state);
    }
    fn block_4824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4824_0: read-var opc1:u8
        let s_4824_0: u8 = fn_state.opc1;
        // D s_4824_1: cast zx s_4824_0 -> bv
        let s_4824_1: Bits = Bits::new(s_4824_0 as u128, 3u16);
        // C s_4824_2: const #0u : u8
        let s_4824_2: u8 = 0;
        // C s_4824_3: cast zx s_4824_2 -> bv
        let s_4824_3: Bits = Bits::new(s_4824_2 as u128, 3u16);
        // D s_4824_4: cmp-eq s_4824_1 s_4824_3
        let s_4824_4: bool = ((s_4824_1) == (s_4824_3));
        // D s_4824_5: write-var gs#135202 <= s_4824_4
        fn_state.gs_135202 = s_4824_4;
        // N s_4824_6: jump b1626
        return block_1626(state, tracer, fn_state);
    }
    fn block_4825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4825_0: read-var coproc:u8
        let s_4825_0: u8 = fn_state.coproc;
        // D s_4825_1: cast zx s_4825_0 -> bv
        let s_4825_1: Bits = Bits::new(s_4825_0 as u128, 4u16);
        // C s_4825_2: const #15u : u8
        let s_4825_2: u8 = 15;
        // C s_4825_3: cast zx s_4825_2 -> bv
        let s_4825_3: Bits = Bits::new(s_4825_2 as u128, 4u16);
        // D s_4825_4: cmp-eq s_4825_1 s_4825_3
        let s_4825_4: bool = ((s_4825_1) == (s_4825_3));
        // D s_4825_5: write-var gs#135201 <= s_4825_4
        fn_state.gs_135201 = s_4825_4;
        // N s_4825_6: jump b1624
        return block_1624(state, tracer, fn_state);
    }
    fn block_4826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4826_0: read-var CRn:u8
        let s_4826_0: u8 = fn_state.CRn;
        // D s_4826_1: cast zx s_4826_0 -> bv
        let s_4826_1: Bits = Bits::new(s_4826_0 as u128, 4u16);
        // C s_4826_2: const #14u : u8
        let s_4826_2: u8 = 14;
        // C s_4826_3: cast zx s_4826_2 -> bv
        let s_4826_3: Bits = Bits::new(s_4826_2 as u128, 4u16);
        // D s_4826_4: cmp-eq s_4826_1 s_4826_3
        let s_4826_4: bool = ((s_4826_1) == (s_4826_3));
        // D s_4826_5: write-var gs#135200 <= s_4826_4
        fn_state.gs_135200 = s_4826_4;
        // N s_4826_6: jump b1622
        return block_1622(state, tracer, fn_state);
    }
    fn block_4827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4827_0: read-var el:u8
        let s_4827_0: u8 = fn_state.el;
        // D s_4827_1: read-var coproc:u8
        let s_4827_1: u8 = fn_state.coproc;
        // D s_4827_2: read-var opc1:u8
        let s_4827_2: u8 = fn_state.opc1;
        // D s_4827_3: read-var CRn:u8
        let s_4827_3: u8 = fn_state.CRn;
        // D s_4827_4: read-var opc2:u8
        let s_4827_4: u8 = fn_state.opc2;
        // D s_4827_5: read-var CRm:u8
        let s_4827_5: u8 = fn_state.CRm;
        // D s_4827_6: read-var t:i
        let s_4827_6: i128 = fn_state.t;
        // D s_4827_7: call PMEVCNTR_SysRegWrite32_1402236c25c3ee30(s_4827_0, s_4827_1, s_4827_2, s_4827_3, s_4827_4, s_4827_5, s_4827_6)
        let s_4827_7: () = PMEVCNTR_SysRegWrite32_1402236c25c3ee30(
            state,
            tracer,
            s_4827_0,
            s_4827_1,
            s_4827_2,
            s_4827_3,
            s_4827_4,
            s_4827_5,
            s_4827_6,
        );
        // N s_4827_8: return
        return;
    }
    fn block_4828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4828_0: read-var opc2:u8
        let s_4828_0: u8 = fn_state.opc2;
        // D s_4828_1: cast zx s_4828_0 -> bv
        let s_4828_1: Bits = Bits::new(s_4828_0 as u128, 3u16);
        // C s_4828_2: const #3u : u8
        let s_4828_2: u8 = 3;
        // C s_4828_3: cast zx s_4828_2 -> bv
        let s_4828_3: Bits = Bits::new(s_4828_2 as u128, 3u16);
        // D s_4828_4: cmp-eq s_4828_1 s_4828_3
        let s_4828_4: bool = ((s_4828_1) == (s_4828_3));
        // D s_4828_5: write-var gs#135199 <= s_4828_4
        fn_state.gs_135199 = s_4828_4;
        // N s_4828_6: jump b1619
        return block_1619(state, tracer, fn_state);
    }
    fn block_4829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4829_0: read-var opc1:u8
        let s_4829_0: u8 = fn_state.opc1;
        // D s_4829_1: cast zx s_4829_0 -> bv
        let s_4829_1: Bits = Bits::new(s_4829_0 as u128, 3u16);
        // C s_4829_2: const #0u : u8
        let s_4829_2: u8 = 0;
        // C s_4829_3: cast zx s_4829_2 -> bv
        let s_4829_3: Bits = Bits::new(s_4829_2 as u128, 3u16);
        // D s_4829_4: cmp-eq s_4829_1 s_4829_3
        let s_4829_4: bool = ((s_4829_1) == (s_4829_3));
        // D s_4829_5: write-var gs#135198 <= s_4829_4
        fn_state.gs_135198 = s_4829_4;
        // N s_4829_6: jump b1617
        return block_1617(state, tracer, fn_state);
    }
    fn block_4830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4830_0: read-var coproc:u8
        let s_4830_0: u8 = fn_state.coproc;
        // D s_4830_1: cast zx s_4830_0 -> bv
        let s_4830_1: Bits = Bits::new(s_4830_0 as u128, 4u16);
        // C s_4830_2: const #15u : u8
        let s_4830_2: u8 = 15;
        // C s_4830_3: cast zx s_4830_2 -> bv
        let s_4830_3: Bits = Bits::new(s_4830_2 as u128, 4u16);
        // D s_4830_4: cmp-eq s_4830_1 s_4830_3
        let s_4830_4: bool = ((s_4830_1) == (s_4830_3));
        // D s_4830_5: write-var gs#135197 <= s_4830_4
        fn_state.gs_135197 = s_4830_4;
        // N s_4830_6: jump b1615
        return block_1615(state, tracer, fn_state);
    }
    fn block_4831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4831_0: read-var CRn:u8
        let s_4831_0: u8 = fn_state.CRn;
        // D s_4831_1: cast zx s_4831_0 -> bv
        let s_4831_1: Bits = Bits::new(s_4831_0 as u128, 4u16);
        // C s_4831_2: const #14u : u8
        let s_4831_2: u8 = 14;
        // C s_4831_3: cast zx s_4831_2 -> bv
        let s_4831_3: Bits = Bits::new(s_4831_2 as u128, 4u16);
        // D s_4831_4: cmp-eq s_4831_1 s_4831_3
        let s_4831_4: bool = ((s_4831_1) == (s_4831_3));
        // D s_4831_5: write-var gs#135196 <= s_4831_4
        fn_state.gs_135196 = s_4831_4;
        // N s_4831_6: jump b1613
        return block_1613(state, tracer, fn_state);
    }
    fn block_4832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4832_0: read-var el:u8
        let s_4832_0: u8 = fn_state.el;
        // D s_4832_1: read-var coproc:u8
        let s_4832_1: u8 = fn_state.coproc;
        // D s_4832_2: read-var opc1:u8
        let s_4832_2: u8 = fn_state.opc1;
        // D s_4832_3: read-var CRn:u8
        let s_4832_3: u8 = fn_state.CRn;
        // D s_4832_4: read-var opc2:u8
        let s_4832_4: u8 = fn_state.opc2;
        // D s_4832_5: read-var CRm:u8
        let s_4832_5: u8 = fn_state.CRm;
        // D s_4832_6: read-var t:i
        let s_4832_6: i128 = fn_state.t;
        // D s_4832_7: call PMEVCNTR_SysRegWrite32_77f99f1f07c86e99(s_4832_0, s_4832_1, s_4832_2, s_4832_3, s_4832_4, s_4832_5, s_4832_6)
        let s_4832_7: () = PMEVCNTR_SysRegWrite32_77f99f1f07c86e99(
            state,
            tracer,
            s_4832_0,
            s_4832_1,
            s_4832_2,
            s_4832_3,
            s_4832_4,
            s_4832_5,
            s_4832_6,
        );
        // N s_4832_8: return
        return;
    }
    fn block_4833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4833_0: read-var opc2:u8
        let s_4833_0: u8 = fn_state.opc2;
        // D s_4833_1: cast zx s_4833_0 -> bv
        let s_4833_1: Bits = Bits::new(s_4833_0 as u128, 3u16);
        // C s_4833_2: const #4u : u8
        let s_4833_2: u8 = 4;
        // C s_4833_3: cast zx s_4833_2 -> bv
        let s_4833_3: Bits = Bits::new(s_4833_2 as u128, 3u16);
        // D s_4833_4: cmp-eq s_4833_1 s_4833_3
        let s_4833_4: bool = ((s_4833_1) == (s_4833_3));
        // D s_4833_5: write-var gs#135195 <= s_4833_4
        fn_state.gs_135195 = s_4833_4;
        // N s_4833_6: jump b1610
        return block_1610(state, tracer, fn_state);
    }
    fn block_4834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4834_0: read-var opc1:u8
        let s_4834_0: u8 = fn_state.opc1;
        // D s_4834_1: cast zx s_4834_0 -> bv
        let s_4834_1: Bits = Bits::new(s_4834_0 as u128, 3u16);
        // C s_4834_2: const #0u : u8
        let s_4834_2: u8 = 0;
        // C s_4834_3: cast zx s_4834_2 -> bv
        let s_4834_3: Bits = Bits::new(s_4834_2 as u128, 3u16);
        // D s_4834_4: cmp-eq s_4834_1 s_4834_3
        let s_4834_4: bool = ((s_4834_1) == (s_4834_3));
        // D s_4834_5: write-var gs#135194 <= s_4834_4
        fn_state.gs_135194 = s_4834_4;
        // N s_4834_6: jump b1608
        return block_1608(state, tracer, fn_state);
    }
    fn block_4835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4835_0: read-var coproc:u8
        let s_4835_0: u8 = fn_state.coproc;
        // D s_4835_1: cast zx s_4835_0 -> bv
        let s_4835_1: Bits = Bits::new(s_4835_0 as u128, 4u16);
        // C s_4835_2: const #15u : u8
        let s_4835_2: u8 = 15;
        // C s_4835_3: cast zx s_4835_2 -> bv
        let s_4835_3: Bits = Bits::new(s_4835_2 as u128, 4u16);
        // D s_4835_4: cmp-eq s_4835_1 s_4835_3
        let s_4835_4: bool = ((s_4835_1) == (s_4835_3));
        // D s_4835_5: write-var gs#135193 <= s_4835_4
        fn_state.gs_135193 = s_4835_4;
        // N s_4835_6: jump b1606
        return block_1606(state, tracer, fn_state);
    }
    fn block_4836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4836_0: read-var CRn:u8
        let s_4836_0: u8 = fn_state.CRn;
        // D s_4836_1: cast zx s_4836_0 -> bv
        let s_4836_1: Bits = Bits::new(s_4836_0 as u128, 4u16);
        // C s_4836_2: const #14u : u8
        let s_4836_2: u8 = 14;
        // C s_4836_3: cast zx s_4836_2 -> bv
        let s_4836_3: Bits = Bits::new(s_4836_2 as u128, 4u16);
        // D s_4836_4: cmp-eq s_4836_1 s_4836_3
        let s_4836_4: bool = ((s_4836_1) == (s_4836_3));
        // D s_4836_5: write-var gs#135192 <= s_4836_4
        fn_state.gs_135192 = s_4836_4;
        // N s_4836_6: jump b1604
        return block_1604(state, tracer, fn_state);
    }
    fn block_4837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4837_0: read-var el:u8
        let s_4837_0: u8 = fn_state.el;
        // D s_4837_1: read-var coproc:u8
        let s_4837_1: u8 = fn_state.coproc;
        // D s_4837_2: read-var opc1:u8
        let s_4837_2: u8 = fn_state.opc1;
        // D s_4837_3: read-var CRn:u8
        let s_4837_3: u8 = fn_state.CRn;
        // D s_4837_4: read-var opc2:u8
        let s_4837_4: u8 = fn_state.opc2;
        // D s_4837_5: read-var CRm:u8
        let s_4837_5: u8 = fn_state.CRm;
        // D s_4837_6: read-var t:i
        let s_4837_6: i128 = fn_state.t;
        // D s_4837_7: call PMEVCNTR_SysRegWrite32_aaa5edab79dc57c7(s_4837_0, s_4837_1, s_4837_2, s_4837_3, s_4837_4, s_4837_5, s_4837_6)
        let s_4837_7: () = PMEVCNTR_SysRegWrite32_aaa5edab79dc57c7(
            state,
            tracer,
            s_4837_0,
            s_4837_1,
            s_4837_2,
            s_4837_3,
            s_4837_4,
            s_4837_5,
            s_4837_6,
        );
        // N s_4837_8: return
        return;
    }
    fn block_4838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4838_0: read-var opc2:u8
        let s_4838_0: u8 = fn_state.opc2;
        // D s_4838_1: cast zx s_4838_0 -> bv
        let s_4838_1: Bits = Bits::new(s_4838_0 as u128, 3u16);
        // C s_4838_2: const #5u : u8
        let s_4838_2: u8 = 5;
        // C s_4838_3: cast zx s_4838_2 -> bv
        let s_4838_3: Bits = Bits::new(s_4838_2 as u128, 3u16);
        // D s_4838_4: cmp-eq s_4838_1 s_4838_3
        let s_4838_4: bool = ((s_4838_1) == (s_4838_3));
        // D s_4838_5: write-var gs#135191 <= s_4838_4
        fn_state.gs_135191 = s_4838_4;
        // N s_4838_6: jump b1601
        return block_1601(state, tracer, fn_state);
    }
    fn block_4839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4839_0: read-var opc1:u8
        let s_4839_0: u8 = fn_state.opc1;
        // D s_4839_1: cast zx s_4839_0 -> bv
        let s_4839_1: Bits = Bits::new(s_4839_0 as u128, 3u16);
        // C s_4839_2: const #0u : u8
        let s_4839_2: u8 = 0;
        // C s_4839_3: cast zx s_4839_2 -> bv
        let s_4839_3: Bits = Bits::new(s_4839_2 as u128, 3u16);
        // D s_4839_4: cmp-eq s_4839_1 s_4839_3
        let s_4839_4: bool = ((s_4839_1) == (s_4839_3));
        // D s_4839_5: write-var gs#135190 <= s_4839_4
        fn_state.gs_135190 = s_4839_4;
        // N s_4839_6: jump b1599
        return block_1599(state, tracer, fn_state);
    }
    fn block_4840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4840_0: read-var coproc:u8
        let s_4840_0: u8 = fn_state.coproc;
        // D s_4840_1: cast zx s_4840_0 -> bv
        let s_4840_1: Bits = Bits::new(s_4840_0 as u128, 4u16);
        // C s_4840_2: const #15u : u8
        let s_4840_2: u8 = 15;
        // C s_4840_3: cast zx s_4840_2 -> bv
        let s_4840_3: Bits = Bits::new(s_4840_2 as u128, 4u16);
        // D s_4840_4: cmp-eq s_4840_1 s_4840_3
        let s_4840_4: bool = ((s_4840_1) == (s_4840_3));
        // D s_4840_5: write-var gs#135189 <= s_4840_4
        fn_state.gs_135189 = s_4840_4;
        // N s_4840_6: jump b1597
        return block_1597(state, tracer, fn_state);
    }
    fn block_4841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4841_0: read-var CRn:u8
        let s_4841_0: u8 = fn_state.CRn;
        // D s_4841_1: cast zx s_4841_0 -> bv
        let s_4841_1: Bits = Bits::new(s_4841_0 as u128, 4u16);
        // C s_4841_2: const #14u : u8
        let s_4841_2: u8 = 14;
        // C s_4841_3: cast zx s_4841_2 -> bv
        let s_4841_3: Bits = Bits::new(s_4841_2 as u128, 4u16);
        // D s_4841_4: cmp-eq s_4841_1 s_4841_3
        let s_4841_4: bool = ((s_4841_1) == (s_4841_3));
        // D s_4841_5: write-var gs#135188 <= s_4841_4
        fn_state.gs_135188 = s_4841_4;
        // N s_4841_6: jump b1595
        return block_1595(state, tracer, fn_state);
    }
    fn block_4842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4842_0: read-var el:u8
        let s_4842_0: u8 = fn_state.el;
        // D s_4842_1: read-var coproc:u8
        let s_4842_1: u8 = fn_state.coproc;
        // D s_4842_2: read-var opc1:u8
        let s_4842_2: u8 = fn_state.opc1;
        // D s_4842_3: read-var CRn:u8
        let s_4842_3: u8 = fn_state.CRn;
        // D s_4842_4: read-var opc2:u8
        let s_4842_4: u8 = fn_state.opc2;
        // D s_4842_5: read-var CRm:u8
        let s_4842_5: u8 = fn_state.CRm;
        // D s_4842_6: read-var t:i
        let s_4842_6: i128 = fn_state.t;
        // D s_4842_7: call PMEVCNTR_SysRegWrite32_ae28080fa13bf9dd(s_4842_0, s_4842_1, s_4842_2, s_4842_3, s_4842_4, s_4842_5, s_4842_6)
        let s_4842_7: () = PMEVCNTR_SysRegWrite32_ae28080fa13bf9dd(
            state,
            tracer,
            s_4842_0,
            s_4842_1,
            s_4842_2,
            s_4842_3,
            s_4842_4,
            s_4842_5,
            s_4842_6,
        );
        // N s_4842_8: return
        return;
    }
    fn block_4843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4843_0: read-var opc2:u8
        let s_4843_0: u8 = fn_state.opc2;
        // D s_4843_1: cast zx s_4843_0 -> bv
        let s_4843_1: Bits = Bits::new(s_4843_0 as u128, 3u16);
        // C s_4843_2: const #6u : u8
        let s_4843_2: u8 = 6;
        // C s_4843_3: cast zx s_4843_2 -> bv
        let s_4843_3: Bits = Bits::new(s_4843_2 as u128, 3u16);
        // D s_4843_4: cmp-eq s_4843_1 s_4843_3
        let s_4843_4: bool = ((s_4843_1) == (s_4843_3));
        // D s_4843_5: write-var gs#135187 <= s_4843_4
        fn_state.gs_135187 = s_4843_4;
        // N s_4843_6: jump b1592
        return block_1592(state, tracer, fn_state);
    }
    fn block_4844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4844_0: read-var opc1:u8
        let s_4844_0: u8 = fn_state.opc1;
        // D s_4844_1: cast zx s_4844_0 -> bv
        let s_4844_1: Bits = Bits::new(s_4844_0 as u128, 3u16);
        // C s_4844_2: const #0u : u8
        let s_4844_2: u8 = 0;
        // C s_4844_3: cast zx s_4844_2 -> bv
        let s_4844_3: Bits = Bits::new(s_4844_2 as u128, 3u16);
        // D s_4844_4: cmp-eq s_4844_1 s_4844_3
        let s_4844_4: bool = ((s_4844_1) == (s_4844_3));
        // D s_4844_5: write-var gs#135186 <= s_4844_4
        fn_state.gs_135186 = s_4844_4;
        // N s_4844_6: jump b1590
        return block_1590(state, tracer, fn_state);
    }
    fn block_4845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4845_0: read-var coproc:u8
        let s_4845_0: u8 = fn_state.coproc;
        // D s_4845_1: cast zx s_4845_0 -> bv
        let s_4845_1: Bits = Bits::new(s_4845_0 as u128, 4u16);
        // C s_4845_2: const #15u : u8
        let s_4845_2: u8 = 15;
        // C s_4845_3: cast zx s_4845_2 -> bv
        let s_4845_3: Bits = Bits::new(s_4845_2 as u128, 4u16);
        // D s_4845_4: cmp-eq s_4845_1 s_4845_3
        let s_4845_4: bool = ((s_4845_1) == (s_4845_3));
        // D s_4845_5: write-var gs#135185 <= s_4845_4
        fn_state.gs_135185 = s_4845_4;
        // N s_4845_6: jump b1588
        return block_1588(state, tracer, fn_state);
    }
    fn block_4846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4846_0: read-var CRn:u8
        let s_4846_0: u8 = fn_state.CRn;
        // D s_4846_1: cast zx s_4846_0 -> bv
        let s_4846_1: Bits = Bits::new(s_4846_0 as u128, 4u16);
        // C s_4846_2: const #14u : u8
        let s_4846_2: u8 = 14;
        // C s_4846_3: cast zx s_4846_2 -> bv
        let s_4846_3: Bits = Bits::new(s_4846_2 as u128, 4u16);
        // D s_4846_4: cmp-eq s_4846_1 s_4846_3
        let s_4846_4: bool = ((s_4846_1) == (s_4846_3));
        // D s_4846_5: write-var gs#135184 <= s_4846_4
        fn_state.gs_135184 = s_4846_4;
        // N s_4846_6: jump b1586
        return block_1586(state, tracer, fn_state);
    }
    fn block_4847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4847_0: read-var el:u8
        let s_4847_0: u8 = fn_state.el;
        // D s_4847_1: read-var coproc:u8
        let s_4847_1: u8 = fn_state.coproc;
        // D s_4847_2: read-var opc1:u8
        let s_4847_2: u8 = fn_state.opc1;
        // D s_4847_3: read-var CRn:u8
        let s_4847_3: u8 = fn_state.CRn;
        // D s_4847_4: read-var opc2:u8
        let s_4847_4: u8 = fn_state.opc2;
        // D s_4847_5: read-var CRm:u8
        let s_4847_5: u8 = fn_state.CRm;
        // D s_4847_6: read-var t:i
        let s_4847_6: i128 = fn_state.t;
        // D s_4847_7: call PMEVCNTR_SysRegWrite32_85d8fbb3220badc7(s_4847_0, s_4847_1, s_4847_2, s_4847_3, s_4847_4, s_4847_5, s_4847_6)
        let s_4847_7: () = PMEVCNTR_SysRegWrite32_85d8fbb3220badc7(
            state,
            tracer,
            s_4847_0,
            s_4847_1,
            s_4847_2,
            s_4847_3,
            s_4847_4,
            s_4847_5,
            s_4847_6,
        );
        // N s_4847_8: return
        return;
    }
    fn block_4848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4848_0: read-var opc2:u8
        let s_4848_0: u8 = fn_state.opc2;
        // D s_4848_1: cast zx s_4848_0 -> bv
        let s_4848_1: Bits = Bits::new(s_4848_0 as u128, 3u16);
        // C s_4848_2: const #7u : u8
        let s_4848_2: u8 = 7;
        // C s_4848_3: cast zx s_4848_2 -> bv
        let s_4848_3: Bits = Bits::new(s_4848_2 as u128, 3u16);
        // D s_4848_4: cmp-eq s_4848_1 s_4848_3
        let s_4848_4: bool = ((s_4848_1) == (s_4848_3));
        // D s_4848_5: write-var gs#135183 <= s_4848_4
        fn_state.gs_135183 = s_4848_4;
        // N s_4848_6: jump b1583
        return block_1583(state, tracer, fn_state);
    }
    fn block_4849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4849_0: read-var opc1:u8
        let s_4849_0: u8 = fn_state.opc1;
        // D s_4849_1: cast zx s_4849_0 -> bv
        let s_4849_1: Bits = Bits::new(s_4849_0 as u128, 3u16);
        // C s_4849_2: const #0u : u8
        let s_4849_2: u8 = 0;
        // C s_4849_3: cast zx s_4849_2 -> bv
        let s_4849_3: Bits = Bits::new(s_4849_2 as u128, 3u16);
        // D s_4849_4: cmp-eq s_4849_1 s_4849_3
        let s_4849_4: bool = ((s_4849_1) == (s_4849_3));
        // D s_4849_5: write-var gs#135182 <= s_4849_4
        fn_state.gs_135182 = s_4849_4;
        // N s_4849_6: jump b1581
        return block_1581(state, tracer, fn_state);
    }
    fn block_4850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4850_0: read-var coproc:u8
        let s_4850_0: u8 = fn_state.coproc;
        // D s_4850_1: cast zx s_4850_0 -> bv
        let s_4850_1: Bits = Bits::new(s_4850_0 as u128, 4u16);
        // C s_4850_2: const #15u : u8
        let s_4850_2: u8 = 15;
        // C s_4850_3: cast zx s_4850_2 -> bv
        let s_4850_3: Bits = Bits::new(s_4850_2 as u128, 4u16);
        // D s_4850_4: cmp-eq s_4850_1 s_4850_3
        let s_4850_4: bool = ((s_4850_1) == (s_4850_3));
        // D s_4850_5: write-var gs#135181 <= s_4850_4
        fn_state.gs_135181 = s_4850_4;
        // N s_4850_6: jump b1579
        return block_1579(state, tracer, fn_state);
    }
    fn block_4851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4851_0: read-var CRn:u8
        let s_4851_0: u8 = fn_state.CRn;
        // D s_4851_1: cast zx s_4851_0 -> bv
        let s_4851_1: Bits = Bits::new(s_4851_0 as u128, 4u16);
        // C s_4851_2: const #14u : u8
        let s_4851_2: u8 = 14;
        // C s_4851_3: cast zx s_4851_2 -> bv
        let s_4851_3: Bits = Bits::new(s_4851_2 as u128, 4u16);
        // D s_4851_4: cmp-eq s_4851_1 s_4851_3
        let s_4851_4: bool = ((s_4851_1) == (s_4851_3));
        // D s_4851_5: write-var gs#135180 <= s_4851_4
        fn_state.gs_135180 = s_4851_4;
        // N s_4851_6: jump b1577
        return block_1577(state, tracer, fn_state);
    }
    fn block_4852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4852_0: read-var el:u8
        let s_4852_0: u8 = fn_state.el;
        // D s_4852_1: read-var coproc:u8
        let s_4852_1: u8 = fn_state.coproc;
        // D s_4852_2: read-var opc1:u8
        let s_4852_2: u8 = fn_state.opc1;
        // D s_4852_3: read-var CRn:u8
        let s_4852_3: u8 = fn_state.CRn;
        // D s_4852_4: read-var opc2:u8
        let s_4852_4: u8 = fn_state.opc2;
        // D s_4852_5: read-var CRm:u8
        let s_4852_5: u8 = fn_state.CRm;
        // D s_4852_6: read-var t:i
        let s_4852_6: i128 = fn_state.t;
        // D s_4852_7: call PMEVCNTR_SysRegWrite32_80d48f0ea7518cab(s_4852_0, s_4852_1, s_4852_2, s_4852_3, s_4852_4, s_4852_5, s_4852_6)
        let s_4852_7: () = PMEVCNTR_SysRegWrite32_80d48f0ea7518cab(
            state,
            tracer,
            s_4852_0,
            s_4852_1,
            s_4852_2,
            s_4852_3,
            s_4852_4,
            s_4852_5,
            s_4852_6,
        );
        // N s_4852_8: return
        return;
    }
    fn block_4853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4853_0: read-var opc2:u8
        let s_4853_0: u8 = fn_state.opc2;
        // D s_4853_1: cast zx s_4853_0 -> bv
        let s_4853_1: Bits = Bits::new(s_4853_0 as u128, 3u16);
        // C s_4853_2: const #0u : u8
        let s_4853_2: u8 = 0;
        // C s_4853_3: cast zx s_4853_2 -> bv
        let s_4853_3: Bits = Bits::new(s_4853_2 as u128, 3u16);
        // D s_4853_4: cmp-eq s_4853_1 s_4853_3
        let s_4853_4: bool = ((s_4853_1) == (s_4853_3));
        // D s_4853_5: write-var gs#135179 <= s_4853_4
        fn_state.gs_135179 = s_4853_4;
        // N s_4853_6: jump b1574
        return block_1574(state, tracer, fn_state);
    }
    fn block_4854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4854_0: read-var opc1:u8
        let s_4854_0: u8 = fn_state.opc1;
        // D s_4854_1: cast zx s_4854_0 -> bv
        let s_4854_1: Bits = Bits::new(s_4854_0 as u128, 3u16);
        // C s_4854_2: const #0u : u8
        let s_4854_2: u8 = 0;
        // C s_4854_3: cast zx s_4854_2 -> bv
        let s_4854_3: Bits = Bits::new(s_4854_2 as u128, 3u16);
        // D s_4854_4: cmp-eq s_4854_1 s_4854_3
        let s_4854_4: bool = ((s_4854_1) == (s_4854_3));
        // D s_4854_5: write-var gs#135178 <= s_4854_4
        fn_state.gs_135178 = s_4854_4;
        // N s_4854_6: jump b1572
        return block_1572(state, tracer, fn_state);
    }
    fn block_4855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4855_0: read-var coproc:u8
        let s_4855_0: u8 = fn_state.coproc;
        // D s_4855_1: cast zx s_4855_0 -> bv
        let s_4855_1: Bits = Bits::new(s_4855_0 as u128, 4u16);
        // C s_4855_2: const #15u : u8
        let s_4855_2: u8 = 15;
        // C s_4855_3: cast zx s_4855_2 -> bv
        let s_4855_3: Bits = Bits::new(s_4855_2 as u128, 4u16);
        // D s_4855_4: cmp-eq s_4855_1 s_4855_3
        let s_4855_4: bool = ((s_4855_1) == (s_4855_3));
        // D s_4855_5: write-var gs#135177 <= s_4855_4
        fn_state.gs_135177 = s_4855_4;
        // N s_4855_6: jump b1570
        return block_1570(state, tracer, fn_state);
    }
    fn block_4856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4856_0: read-var CRn:u8
        let s_4856_0: u8 = fn_state.CRn;
        // D s_4856_1: cast zx s_4856_0 -> bv
        let s_4856_1: Bits = Bits::new(s_4856_0 as u128, 4u16);
        // C s_4856_2: const #14u : u8
        let s_4856_2: u8 = 14;
        // C s_4856_3: cast zx s_4856_2 -> bv
        let s_4856_3: Bits = Bits::new(s_4856_2 as u128, 4u16);
        // D s_4856_4: cmp-eq s_4856_1 s_4856_3
        let s_4856_4: bool = ((s_4856_1) == (s_4856_3));
        // D s_4856_5: write-var gs#135176 <= s_4856_4
        fn_state.gs_135176 = s_4856_4;
        // N s_4856_6: jump b1568
        return block_1568(state, tracer, fn_state);
    }
    fn block_4857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4857_0: read-var el:u8
        let s_4857_0: u8 = fn_state.el;
        // D s_4857_1: read-var coproc:u8
        let s_4857_1: u8 = fn_state.coproc;
        // D s_4857_2: read-var opc1:u8
        let s_4857_2: u8 = fn_state.opc1;
        // D s_4857_3: read-var CRn:u8
        let s_4857_3: u8 = fn_state.CRn;
        // D s_4857_4: read-var opc2:u8
        let s_4857_4: u8 = fn_state.opc2;
        // D s_4857_5: read-var CRm:u8
        let s_4857_5: u8 = fn_state.CRm;
        // D s_4857_6: read-var t:i
        let s_4857_6: i128 = fn_state.t;
        // D s_4857_7: call PMEVCNTR_SysRegWrite32_dabf302752d231bf(s_4857_0, s_4857_1, s_4857_2, s_4857_3, s_4857_4, s_4857_5, s_4857_6)
        let s_4857_7: () = PMEVCNTR_SysRegWrite32_dabf302752d231bf(
            state,
            tracer,
            s_4857_0,
            s_4857_1,
            s_4857_2,
            s_4857_3,
            s_4857_4,
            s_4857_5,
            s_4857_6,
        );
        // N s_4857_8: return
        return;
    }
    fn block_4858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4858_0: read-var opc2:u8
        let s_4858_0: u8 = fn_state.opc2;
        // D s_4858_1: cast zx s_4858_0 -> bv
        let s_4858_1: Bits = Bits::new(s_4858_0 as u128, 3u16);
        // C s_4858_2: const #1u : u8
        let s_4858_2: u8 = 1;
        // C s_4858_3: cast zx s_4858_2 -> bv
        let s_4858_3: Bits = Bits::new(s_4858_2 as u128, 3u16);
        // D s_4858_4: cmp-eq s_4858_1 s_4858_3
        let s_4858_4: bool = ((s_4858_1) == (s_4858_3));
        // D s_4858_5: write-var gs#135175 <= s_4858_4
        fn_state.gs_135175 = s_4858_4;
        // N s_4858_6: jump b1565
        return block_1565(state, tracer, fn_state);
    }
    fn block_4859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4859_0: read-var opc1:u8
        let s_4859_0: u8 = fn_state.opc1;
        // D s_4859_1: cast zx s_4859_0 -> bv
        let s_4859_1: Bits = Bits::new(s_4859_0 as u128, 3u16);
        // C s_4859_2: const #0u : u8
        let s_4859_2: u8 = 0;
        // C s_4859_3: cast zx s_4859_2 -> bv
        let s_4859_3: Bits = Bits::new(s_4859_2 as u128, 3u16);
        // D s_4859_4: cmp-eq s_4859_1 s_4859_3
        let s_4859_4: bool = ((s_4859_1) == (s_4859_3));
        // D s_4859_5: write-var gs#135174 <= s_4859_4
        fn_state.gs_135174 = s_4859_4;
        // N s_4859_6: jump b1563
        return block_1563(state, tracer, fn_state);
    }
    fn block_4860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4860_0: read-var coproc:u8
        let s_4860_0: u8 = fn_state.coproc;
        // D s_4860_1: cast zx s_4860_0 -> bv
        let s_4860_1: Bits = Bits::new(s_4860_0 as u128, 4u16);
        // C s_4860_2: const #15u : u8
        let s_4860_2: u8 = 15;
        // C s_4860_3: cast zx s_4860_2 -> bv
        let s_4860_3: Bits = Bits::new(s_4860_2 as u128, 4u16);
        // D s_4860_4: cmp-eq s_4860_1 s_4860_3
        let s_4860_4: bool = ((s_4860_1) == (s_4860_3));
        // D s_4860_5: write-var gs#135173 <= s_4860_4
        fn_state.gs_135173 = s_4860_4;
        // N s_4860_6: jump b1561
        return block_1561(state, tracer, fn_state);
    }
    fn block_4861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4861_0: read-var CRn:u8
        let s_4861_0: u8 = fn_state.CRn;
        // D s_4861_1: cast zx s_4861_0 -> bv
        let s_4861_1: Bits = Bits::new(s_4861_0 as u128, 4u16);
        // C s_4861_2: const #14u : u8
        let s_4861_2: u8 = 14;
        // C s_4861_3: cast zx s_4861_2 -> bv
        let s_4861_3: Bits = Bits::new(s_4861_2 as u128, 4u16);
        // D s_4861_4: cmp-eq s_4861_1 s_4861_3
        let s_4861_4: bool = ((s_4861_1) == (s_4861_3));
        // D s_4861_5: write-var gs#135172 <= s_4861_4
        fn_state.gs_135172 = s_4861_4;
        // N s_4861_6: jump b1559
        return block_1559(state, tracer, fn_state);
    }
    fn block_4862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4862_0: read-var el:u8
        let s_4862_0: u8 = fn_state.el;
        // D s_4862_1: read-var coproc:u8
        let s_4862_1: u8 = fn_state.coproc;
        // D s_4862_2: read-var opc1:u8
        let s_4862_2: u8 = fn_state.opc1;
        // D s_4862_3: read-var CRn:u8
        let s_4862_3: u8 = fn_state.CRn;
        // D s_4862_4: read-var opc2:u8
        let s_4862_4: u8 = fn_state.opc2;
        // D s_4862_5: read-var CRm:u8
        let s_4862_5: u8 = fn_state.CRm;
        // D s_4862_6: read-var t:i
        let s_4862_6: i128 = fn_state.t;
        // D s_4862_7: call PMEVCNTR_SysRegWrite32_379354bb12604d68(s_4862_0, s_4862_1, s_4862_2, s_4862_3, s_4862_4, s_4862_5, s_4862_6)
        let s_4862_7: () = PMEVCNTR_SysRegWrite32_379354bb12604d68(
            state,
            tracer,
            s_4862_0,
            s_4862_1,
            s_4862_2,
            s_4862_3,
            s_4862_4,
            s_4862_5,
            s_4862_6,
        );
        // N s_4862_8: return
        return;
    }
    fn block_4863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4863_0: read-var opc2:u8
        let s_4863_0: u8 = fn_state.opc2;
        // D s_4863_1: cast zx s_4863_0 -> bv
        let s_4863_1: Bits = Bits::new(s_4863_0 as u128, 3u16);
        // C s_4863_2: const #2u : u8
        let s_4863_2: u8 = 2;
        // C s_4863_3: cast zx s_4863_2 -> bv
        let s_4863_3: Bits = Bits::new(s_4863_2 as u128, 3u16);
        // D s_4863_4: cmp-eq s_4863_1 s_4863_3
        let s_4863_4: bool = ((s_4863_1) == (s_4863_3));
        // D s_4863_5: write-var gs#135171 <= s_4863_4
        fn_state.gs_135171 = s_4863_4;
        // N s_4863_6: jump b1556
        return block_1556(state, tracer, fn_state);
    }
    fn block_4864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4864_0: read-var opc1:u8
        let s_4864_0: u8 = fn_state.opc1;
        // D s_4864_1: cast zx s_4864_0 -> bv
        let s_4864_1: Bits = Bits::new(s_4864_0 as u128, 3u16);
        // C s_4864_2: const #0u : u8
        let s_4864_2: u8 = 0;
        // C s_4864_3: cast zx s_4864_2 -> bv
        let s_4864_3: Bits = Bits::new(s_4864_2 as u128, 3u16);
        // D s_4864_4: cmp-eq s_4864_1 s_4864_3
        let s_4864_4: bool = ((s_4864_1) == (s_4864_3));
        // D s_4864_5: write-var gs#135170 <= s_4864_4
        fn_state.gs_135170 = s_4864_4;
        // N s_4864_6: jump b1554
        return block_1554(state, tracer, fn_state);
    }
    fn block_4865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4865_0: read-var coproc:u8
        let s_4865_0: u8 = fn_state.coproc;
        // D s_4865_1: cast zx s_4865_0 -> bv
        let s_4865_1: Bits = Bits::new(s_4865_0 as u128, 4u16);
        // C s_4865_2: const #15u : u8
        let s_4865_2: u8 = 15;
        // C s_4865_3: cast zx s_4865_2 -> bv
        let s_4865_3: Bits = Bits::new(s_4865_2 as u128, 4u16);
        // D s_4865_4: cmp-eq s_4865_1 s_4865_3
        let s_4865_4: bool = ((s_4865_1) == (s_4865_3));
        // D s_4865_5: write-var gs#135169 <= s_4865_4
        fn_state.gs_135169 = s_4865_4;
        // N s_4865_6: jump b1552
        return block_1552(state, tracer, fn_state);
    }
    fn block_4866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4866_0: read-var CRn:u8
        let s_4866_0: u8 = fn_state.CRn;
        // D s_4866_1: cast zx s_4866_0 -> bv
        let s_4866_1: Bits = Bits::new(s_4866_0 as u128, 4u16);
        // C s_4866_2: const #14u : u8
        let s_4866_2: u8 = 14;
        // C s_4866_3: cast zx s_4866_2 -> bv
        let s_4866_3: Bits = Bits::new(s_4866_2 as u128, 4u16);
        // D s_4866_4: cmp-eq s_4866_1 s_4866_3
        let s_4866_4: bool = ((s_4866_1) == (s_4866_3));
        // D s_4866_5: write-var gs#135168 <= s_4866_4
        fn_state.gs_135168 = s_4866_4;
        // N s_4866_6: jump b1550
        return block_1550(state, tracer, fn_state);
    }
    fn block_4867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4867_0: read-var el:u8
        let s_4867_0: u8 = fn_state.el;
        // D s_4867_1: read-var coproc:u8
        let s_4867_1: u8 = fn_state.coproc;
        // D s_4867_2: read-var opc1:u8
        let s_4867_2: u8 = fn_state.opc1;
        // D s_4867_3: read-var CRn:u8
        let s_4867_3: u8 = fn_state.CRn;
        // D s_4867_4: read-var opc2:u8
        let s_4867_4: u8 = fn_state.opc2;
        // D s_4867_5: read-var CRm:u8
        let s_4867_5: u8 = fn_state.CRm;
        // D s_4867_6: read-var t:i
        let s_4867_6: i128 = fn_state.t;
        // D s_4867_7: call PMEVCNTR_SysRegWrite32_3c9cffad5c0f5aa1(s_4867_0, s_4867_1, s_4867_2, s_4867_3, s_4867_4, s_4867_5, s_4867_6)
        let s_4867_7: () = PMEVCNTR_SysRegWrite32_3c9cffad5c0f5aa1(
            state,
            tracer,
            s_4867_0,
            s_4867_1,
            s_4867_2,
            s_4867_3,
            s_4867_4,
            s_4867_5,
            s_4867_6,
        );
        // N s_4867_8: return
        return;
    }
    fn block_4868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4868_0: read-var opc2:u8
        let s_4868_0: u8 = fn_state.opc2;
        // D s_4868_1: cast zx s_4868_0 -> bv
        let s_4868_1: Bits = Bits::new(s_4868_0 as u128, 3u16);
        // C s_4868_2: const #3u : u8
        let s_4868_2: u8 = 3;
        // C s_4868_3: cast zx s_4868_2 -> bv
        let s_4868_3: Bits = Bits::new(s_4868_2 as u128, 3u16);
        // D s_4868_4: cmp-eq s_4868_1 s_4868_3
        let s_4868_4: bool = ((s_4868_1) == (s_4868_3));
        // D s_4868_5: write-var gs#135167 <= s_4868_4
        fn_state.gs_135167 = s_4868_4;
        // N s_4868_6: jump b1547
        return block_1547(state, tracer, fn_state);
    }
    fn block_4869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4869_0: read-var opc1:u8
        let s_4869_0: u8 = fn_state.opc1;
        // D s_4869_1: cast zx s_4869_0 -> bv
        let s_4869_1: Bits = Bits::new(s_4869_0 as u128, 3u16);
        // C s_4869_2: const #0u : u8
        let s_4869_2: u8 = 0;
        // C s_4869_3: cast zx s_4869_2 -> bv
        let s_4869_3: Bits = Bits::new(s_4869_2 as u128, 3u16);
        // D s_4869_4: cmp-eq s_4869_1 s_4869_3
        let s_4869_4: bool = ((s_4869_1) == (s_4869_3));
        // D s_4869_5: write-var gs#135166 <= s_4869_4
        fn_state.gs_135166 = s_4869_4;
        // N s_4869_6: jump b1545
        return block_1545(state, tracer, fn_state);
    }
    fn block_4870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4870_0: read-var coproc:u8
        let s_4870_0: u8 = fn_state.coproc;
        // D s_4870_1: cast zx s_4870_0 -> bv
        let s_4870_1: Bits = Bits::new(s_4870_0 as u128, 4u16);
        // C s_4870_2: const #15u : u8
        let s_4870_2: u8 = 15;
        // C s_4870_3: cast zx s_4870_2 -> bv
        let s_4870_3: Bits = Bits::new(s_4870_2 as u128, 4u16);
        // D s_4870_4: cmp-eq s_4870_1 s_4870_3
        let s_4870_4: bool = ((s_4870_1) == (s_4870_3));
        // D s_4870_5: write-var gs#135165 <= s_4870_4
        fn_state.gs_135165 = s_4870_4;
        // N s_4870_6: jump b1543
        return block_1543(state, tracer, fn_state);
    }
    fn block_4871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4871_0: read-var CRn:u8
        let s_4871_0: u8 = fn_state.CRn;
        // D s_4871_1: cast zx s_4871_0 -> bv
        let s_4871_1: Bits = Bits::new(s_4871_0 as u128, 4u16);
        // C s_4871_2: const #14u : u8
        let s_4871_2: u8 = 14;
        // C s_4871_3: cast zx s_4871_2 -> bv
        let s_4871_3: Bits = Bits::new(s_4871_2 as u128, 4u16);
        // D s_4871_4: cmp-eq s_4871_1 s_4871_3
        let s_4871_4: bool = ((s_4871_1) == (s_4871_3));
        // D s_4871_5: write-var gs#135164 <= s_4871_4
        fn_state.gs_135164 = s_4871_4;
        // N s_4871_6: jump b1541
        return block_1541(state, tracer, fn_state);
    }
    fn block_4872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4872_0: read-var el:u8
        let s_4872_0: u8 = fn_state.el;
        // D s_4872_1: read-var coproc:u8
        let s_4872_1: u8 = fn_state.coproc;
        // D s_4872_2: read-var opc1:u8
        let s_4872_2: u8 = fn_state.opc1;
        // D s_4872_3: read-var CRn:u8
        let s_4872_3: u8 = fn_state.CRn;
        // D s_4872_4: read-var opc2:u8
        let s_4872_4: u8 = fn_state.opc2;
        // D s_4872_5: read-var CRm:u8
        let s_4872_5: u8 = fn_state.CRm;
        // D s_4872_6: read-var t:i
        let s_4872_6: i128 = fn_state.t;
        // D s_4872_7: call PMEVCNTR_SysRegWrite32_9aa0227f42759948(s_4872_0, s_4872_1, s_4872_2, s_4872_3, s_4872_4, s_4872_5, s_4872_6)
        let s_4872_7: () = PMEVCNTR_SysRegWrite32_9aa0227f42759948(
            state,
            tracer,
            s_4872_0,
            s_4872_1,
            s_4872_2,
            s_4872_3,
            s_4872_4,
            s_4872_5,
            s_4872_6,
        );
        // N s_4872_8: return
        return;
    }
    fn block_4873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4873_0: read-var opc2:u8
        let s_4873_0: u8 = fn_state.opc2;
        // D s_4873_1: cast zx s_4873_0 -> bv
        let s_4873_1: Bits = Bits::new(s_4873_0 as u128, 3u16);
        // C s_4873_2: const #4u : u8
        let s_4873_2: u8 = 4;
        // C s_4873_3: cast zx s_4873_2 -> bv
        let s_4873_3: Bits = Bits::new(s_4873_2 as u128, 3u16);
        // D s_4873_4: cmp-eq s_4873_1 s_4873_3
        let s_4873_4: bool = ((s_4873_1) == (s_4873_3));
        // D s_4873_5: write-var gs#135163 <= s_4873_4
        fn_state.gs_135163 = s_4873_4;
        // N s_4873_6: jump b1538
        return block_1538(state, tracer, fn_state);
    }
    fn block_4874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4874_0: read-var opc1:u8
        let s_4874_0: u8 = fn_state.opc1;
        // D s_4874_1: cast zx s_4874_0 -> bv
        let s_4874_1: Bits = Bits::new(s_4874_0 as u128, 3u16);
        // C s_4874_2: const #0u : u8
        let s_4874_2: u8 = 0;
        // C s_4874_3: cast zx s_4874_2 -> bv
        let s_4874_3: Bits = Bits::new(s_4874_2 as u128, 3u16);
        // D s_4874_4: cmp-eq s_4874_1 s_4874_3
        let s_4874_4: bool = ((s_4874_1) == (s_4874_3));
        // D s_4874_5: write-var gs#135162 <= s_4874_4
        fn_state.gs_135162 = s_4874_4;
        // N s_4874_6: jump b1536
        return block_1536(state, tracer, fn_state);
    }
    fn block_4875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4875_0: read-var coproc:u8
        let s_4875_0: u8 = fn_state.coproc;
        // D s_4875_1: cast zx s_4875_0 -> bv
        let s_4875_1: Bits = Bits::new(s_4875_0 as u128, 4u16);
        // C s_4875_2: const #15u : u8
        let s_4875_2: u8 = 15;
        // C s_4875_3: cast zx s_4875_2 -> bv
        let s_4875_3: Bits = Bits::new(s_4875_2 as u128, 4u16);
        // D s_4875_4: cmp-eq s_4875_1 s_4875_3
        let s_4875_4: bool = ((s_4875_1) == (s_4875_3));
        // D s_4875_5: write-var gs#135161 <= s_4875_4
        fn_state.gs_135161 = s_4875_4;
        // N s_4875_6: jump b1534
        return block_1534(state, tracer, fn_state);
    }
    fn block_4876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4876_0: read-var CRn:u8
        let s_4876_0: u8 = fn_state.CRn;
        // D s_4876_1: cast zx s_4876_0 -> bv
        let s_4876_1: Bits = Bits::new(s_4876_0 as u128, 4u16);
        // C s_4876_2: const #14u : u8
        let s_4876_2: u8 = 14;
        // C s_4876_3: cast zx s_4876_2 -> bv
        let s_4876_3: Bits = Bits::new(s_4876_2 as u128, 4u16);
        // D s_4876_4: cmp-eq s_4876_1 s_4876_3
        let s_4876_4: bool = ((s_4876_1) == (s_4876_3));
        // D s_4876_5: write-var gs#135160 <= s_4876_4
        fn_state.gs_135160 = s_4876_4;
        // N s_4876_6: jump b1532
        return block_1532(state, tracer, fn_state);
    }
    fn block_4877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4877_0: read-var el:u8
        let s_4877_0: u8 = fn_state.el;
        // D s_4877_1: read-var coproc:u8
        let s_4877_1: u8 = fn_state.coproc;
        // D s_4877_2: read-var opc1:u8
        let s_4877_2: u8 = fn_state.opc1;
        // D s_4877_3: read-var CRn:u8
        let s_4877_3: u8 = fn_state.CRn;
        // D s_4877_4: read-var opc2:u8
        let s_4877_4: u8 = fn_state.opc2;
        // D s_4877_5: read-var CRm:u8
        let s_4877_5: u8 = fn_state.CRm;
        // D s_4877_6: read-var t:i
        let s_4877_6: i128 = fn_state.t;
        // D s_4877_7: call PMEVCNTR_SysRegWrite32_272a6440ad5e9b96(s_4877_0, s_4877_1, s_4877_2, s_4877_3, s_4877_4, s_4877_5, s_4877_6)
        let s_4877_7: () = PMEVCNTR_SysRegWrite32_272a6440ad5e9b96(
            state,
            tracer,
            s_4877_0,
            s_4877_1,
            s_4877_2,
            s_4877_3,
            s_4877_4,
            s_4877_5,
            s_4877_6,
        );
        // N s_4877_8: return
        return;
    }
    fn block_4878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4878_0: read-var opc2:u8
        let s_4878_0: u8 = fn_state.opc2;
        // D s_4878_1: cast zx s_4878_0 -> bv
        let s_4878_1: Bits = Bits::new(s_4878_0 as u128, 3u16);
        // C s_4878_2: const #5u : u8
        let s_4878_2: u8 = 5;
        // C s_4878_3: cast zx s_4878_2 -> bv
        let s_4878_3: Bits = Bits::new(s_4878_2 as u128, 3u16);
        // D s_4878_4: cmp-eq s_4878_1 s_4878_3
        let s_4878_4: bool = ((s_4878_1) == (s_4878_3));
        // D s_4878_5: write-var gs#135159 <= s_4878_4
        fn_state.gs_135159 = s_4878_4;
        // N s_4878_6: jump b1529
        return block_1529(state, tracer, fn_state);
    }
    fn block_4879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4879_0: read-var opc1:u8
        let s_4879_0: u8 = fn_state.opc1;
        // D s_4879_1: cast zx s_4879_0 -> bv
        let s_4879_1: Bits = Bits::new(s_4879_0 as u128, 3u16);
        // C s_4879_2: const #0u : u8
        let s_4879_2: u8 = 0;
        // C s_4879_3: cast zx s_4879_2 -> bv
        let s_4879_3: Bits = Bits::new(s_4879_2 as u128, 3u16);
        // D s_4879_4: cmp-eq s_4879_1 s_4879_3
        let s_4879_4: bool = ((s_4879_1) == (s_4879_3));
        // D s_4879_5: write-var gs#135158 <= s_4879_4
        fn_state.gs_135158 = s_4879_4;
        // N s_4879_6: jump b1527
        return block_1527(state, tracer, fn_state);
    }
    fn block_4880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4880_0: read-var coproc:u8
        let s_4880_0: u8 = fn_state.coproc;
        // D s_4880_1: cast zx s_4880_0 -> bv
        let s_4880_1: Bits = Bits::new(s_4880_0 as u128, 4u16);
        // C s_4880_2: const #15u : u8
        let s_4880_2: u8 = 15;
        // C s_4880_3: cast zx s_4880_2 -> bv
        let s_4880_3: Bits = Bits::new(s_4880_2 as u128, 4u16);
        // D s_4880_4: cmp-eq s_4880_1 s_4880_3
        let s_4880_4: bool = ((s_4880_1) == (s_4880_3));
        // D s_4880_5: write-var gs#135157 <= s_4880_4
        fn_state.gs_135157 = s_4880_4;
        // N s_4880_6: jump b1525
        return block_1525(state, tracer, fn_state);
    }
    fn block_4881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4881_0: read-var CRn:u8
        let s_4881_0: u8 = fn_state.CRn;
        // D s_4881_1: cast zx s_4881_0 -> bv
        let s_4881_1: Bits = Bits::new(s_4881_0 as u128, 4u16);
        // C s_4881_2: const #14u : u8
        let s_4881_2: u8 = 14;
        // C s_4881_3: cast zx s_4881_2 -> bv
        let s_4881_3: Bits = Bits::new(s_4881_2 as u128, 4u16);
        // D s_4881_4: cmp-eq s_4881_1 s_4881_3
        let s_4881_4: bool = ((s_4881_1) == (s_4881_3));
        // D s_4881_5: write-var gs#135156 <= s_4881_4
        fn_state.gs_135156 = s_4881_4;
        // N s_4881_6: jump b1523
        return block_1523(state, tracer, fn_state);
    }
    fn block_4882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4882_0: read-var el:u8
        let s_4882_0: u8 = fn_state.el;
        // D s_4882_1: read-var coproc:u8
        let s_4882_1: u8 = fn_state.coproc;
        // D s_4882_2: read-var opc1:u8
        let s_4882_2: u8 = fn_state.opc1;
        // D s_4882_3: read-var CRn:u8
        let s_4882_3: u8 = fn_state.CRn;
        // D s_4882_4: read-var opc2:u8
        let s_4882_4: u8 = fn_state.opc2;
        // D s_4882_5: read-var CRm:u8
        let s_4882_5: u8 = fn_state.CRm;
        // D s_4882_6: read-var t:i
        let s_4882_6: i128 = fn_state.t;
        // D s_4882_7: call PMEVCNTR_SysRegWrite32_f95277b9a9856b04(s_4882_0, s_4882_1, s_4882_2, s_4882_3, s_4882_4, s_4882_5, s_4882_6)
        let s_4882_7: () = PMEVCNTR_SysRegWrite32_f95277b9a9856b04(
            state,
            tracer,
            s_4882_0,
            s_4882_1,
            s_4882_2,
            s_4882_3,
            s_4882_4,
            s_4882_5,
            s_4882_6,
        );
        // N s_4882_8: return
        return;
    }
    fn block_4883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4883_0: read-var opc2:u8
        let s_4883_0: u8 = fn_state.opc2;
        // D s_4883_1: cast zx s_4883_0 -> bv
        let s_4883_1: Bits = Bits::new(s_4883_0 as u128, 3u16);
        // C s_4883_2: const #6u : u8
        let s_4883_2: u8 = 6;
        // C s_4883_3: cast zx s_4883_2 -> bv
        let s_4883_3: Bits = Bits::new(s_4883_2 as u128, 3u16);
        // D s_4883_4: cmp-eq s_4883_1 s_4883_3
        let s_4883_4: bool = ((s_4883_1) == (s_4883_3));
        // D s_4883_5: write-var gs#135155 <= s_4883_4
        fn_state.gs_135155 = s_4883_4;
        // N s_4883_6: jump b1520
        return block_1520(state, tracer, fn_state);
    }
    fn block_4884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4884_0: read-var opc1:u8
        let s_4884_0: u8 = fn_state.opc1;
        // D s_4884_1: cast zx s_4884_0 -> bv
        let s_4884_1: Bits = Bits::new(s_4884_0 as u128, 3u16);
        // C s_4884_2: const #0u : u8
        let s_4884_2: u8 = 0;
        // C s_4884_3: cast zx s_4884_2 -> bv
        let s_4884_3: Bits = Bits::new(s_4884_2 as u128, 3u16);
        // D s_4884_4: cmp-eq s_4884_1 s_4884_3
        let s_4884_4: bool = ((s_4884_1) == (s_4884_3));
        // D s_4884_5: write-var gs#135154 <= s_4884_4
        fn_state.gs_135154 = s_4884_4;
        // N s_4884_6: jump b1518
        return block_1518(state, tracer, fn_state);
    }
    fn block_4885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4885_0: read-var coproc:u8
        let s_4885_0: u8 = fn_state.coproc;
        // D s_4885_1: cast zx s_4885_0 -> bv
        let s_4885_1: Bits = Bits::new(s_4885_0 as u128, 4u16);
        // C s_4885_2: const #15u : u8
        let s_4885_2: u8 = 15;
        // C s_4885_3: cast zx s_4885_2 -> bv
        let s_4885_3: Bits = Bits::new(s_4885_2 as u128, 4u16);
        // D s_4885_4: cmp-eq s_4885_1 s_4885_3
        let s_4885_4: bool = ((s_4885_1) == (s_4885_3));
        // D s_4885_5: write-var gs#135153 <= s_4885_4
        fn_state.gs_135153 = s_4885_4;
        // N s_4885_6: jump b1516
        return block_1516(state, tracer, fn_state);
    }
    fn block_4886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4886_0: read-var CRn:u8
        let s_4886_0: u8 = fn_state.CRn;
        // D s_4886_1: cast zx s_4886_0 -> bv
        let s_4886_1: Bits = Bits::new(s_4886_0 as u128, 4u16);
        // C s_4886_2: const #14u : u8
        let s_4886_2: u8 = 14;
        // C s_4886_3: cast zx s_4886_2 -> bv
        let s_4886_3: Bits = Bits::new(s_4886_2 as u128, 4u16);
        // D s_4886_4: cmp-eq s_4886_1 s_4886_3
        let s_4886_4: bool = ((s_4886_1) == (s_4886_3));
        // D s_4886_5: write-var gs#135152 <= s_4886_4
        fn_state.gs_135152 = s_4886_4;
        // N s_4886_6: jump b1514
        return block_1514(state, tracer, fn_state);
    }
    fn block_4887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4887_0: read-var el:u8
        let s_4887_0: u8 = fn_state.el;
        // D s_4887_1: read-var coproc:u8
        let s_4887_1: u8 = fn_state.coproc;
        // D s_4887_2: read-var opc1:u8
        let s_4887_2: u8 = fn_state.opc1;
        // D s_4887_3: read-var CRn:u8
        let s_4887_3: u8 = fn_state.CRn;
        // D s_4887_4: read-var opc2:u8
        let s_4887_4: u8 = fn_state.opc2;
        // D s_4887_5: read-var CRm:u8
        let s_4887_5: u8 = fn_state.CRm;
        // D s_4887_6: read-var t:i
        let s_4887_6: i128 = fn_state.t;
        // D s_4887_7: call PMEVCNTR_SysRegWrite32_731843d10cb3a6ff(s_4887_0, s_4887_1, s_4887_2, s_4887_3, s_4887_4, s_4887_5, s_4887_6)
        let s_4887_7: () = PMEVCNTR_SysRegWrite32_731843d10cb3a6ff(
            state,
            tracer,
            s_4887_0,
            s_4887_1,
            s_4887_2,
            s_4887_3,
            s_4887_4,
            s_4887_5,
            s_4887_6,
        );
        // N s_4887_8: return
        return;
    }
    fn block_4888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4888_0: read-var opc2:u8
        let s_4888_0: u8 = fn_state.opc2;
        // D s_4888_1: cast zx s_4888_0 -> bv
        let s_4888_1: Bits = Bits::new(s_4888_0 as u128, 3u16);
        // C s_4888_2: const #7u : u8
        let s_4888_2: u8 = 7;
        // C s_4888_3: cast zx s_4888_2 -> bv
        let s_4888_3: Bits = Bits::new(s_4888_2 as u128, 3u16);
        // D s_4888_4: cmp-eq s_4888_1 s_4888_3
        let s_4888_4: bool = ((s_4888_1) == (s_4888_3));
        // D s_4888_5: write-var gs#135151 <= s_4888_4
        fn_state.gs_135151 = s_4888_4;
        // N s_4888_6: jump b1511
        return block_1511(state, tracer, fn_state);
    }
    fn block_4889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4889_0: read-var opc1:u8
        let s_4889_0: u8 = fn_state.opc1;
        // D s_4889_1: cast zx s_4889_0 -> bv
        let s_4889_1: Bits = Bits::new(s_4889_0 as u128, 3u16);
        // C s_4889_2: const #0u : u8
        let s_4889_2: u8 = 0;
        // C s_4889_3: cast zx s_4889_2 -> bv
        let s_4889_3: Bits = Bits::new(s_4889_2 as u128, 3u16);
        // D s_4889_4: cmp-eq s_4889_1 s_4889_3
        let s_4889_4: bool = ((s_4889_1) == (s_4889_3));
        // D s_4889_5: write-var gs#135150 <= s_4889_4
        fn_state.gs_135150 = s_4889_4;
        // N s_4889_6: jump b1509
        return block_1509(state, tracer, fn_state);
    }
    fn block_4890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4890_0: read-var coproc:u8
        let s_4890_0: u8 = fn_state.coproc;
        // D s_4890_1: cast zx s_4890_0 -> bv
        let s_4890_1: Bits = Bits::new(s_4890_0 as u128, 4u16);
        // C s_4890_2: const #15u : u8
        let s_4890_2: u8 = 15;
        // C s_4890_3: cast zx s_4890_2 -> bv
        let s_4890_3: Bits = Bits::new(s_4890_2 as u128, 4u16);
        // D s_4890_4: cmp-eq s_4890_1 s_4890_3
        let s_4890_4: bool = ((s_4890_1) == (s_4890_3));
        // D s_4890_5: write-var gs#135149 <= s_4890_4
        fn_state.gs_135149 = s_4890_4;
        // N s_4890_6: jump b1507
        return block_1507(state, tracer, fn_state);
    }
    fn block_4891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4891_0: read-var CRn:u8
        let s_4891_0: u8 = fn_state.CRn;
        // D s_4891_1: cast zx s_4891_0 -> bv
        let s_4891_1: Bits = Bits::new(s_4891_0 as u128, 4u16);
        // C s_4891_2: const #14u : u8
        let s_4891_2: u8 = 14;
        // C s_4891_3: cast zx s_4891_2 -> bv
        let s_4891_3: Bits = Bits::new(s_4891_2 as u128, 4u16);
        // D s_4891_4: cmp-eq s_4891_1 s_4891_3
        let s_4891_4: bool = ((s_4891_1) == (s_4891_3));
        // D s_4891_5: write-var gs#135148 <= s_4891_4
        fn_state.gs_135148 = s_4891_4;
        // N s_4891_6: jump b1505
        return block_1505(state, tracer, fn_state);
    }
    fn block_4892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4892_0: read-var el:u8
        let s_4892_0: u8 = fn_state.el;
        // D s_4892_1: read-var coproc:u8
        let s_4892_1: u8 = fn_state.coproc;
        // D s_4892_2: read-var opc1:u8
        let s_4892_2: u8 = fn_state.opc1;
        // D s_4892_3: read-var CRn:u8
        let s_4892_3: u8 = fn_state.CRn;
        // D s_4892_4: read-var opc2:u8
        let s_4892_4: u8 = fn_state.opc2;
        // D s_4892_5: read-var CRm:u8
        let s_4892_5: u8 = fn_state.CRm;
        // D s_4892_6: read-var t:i
        let s_4892_6: i128 = fn_state.t;
        // D s_4892_7: call PMEVCNTR_SysRegWrite32_7ee2623ac7e31637(s_4892_0, s_4892_1, s_4892_2, s_4892_3, s_4892_4, s_4892_5, s_4892_6)
        let s_4892_7: () = PMEVCNTR_SysRegWrite32_7ee2623ac7e31637(
            state,
            tracer,
            s_4892_0,
            s_4892_1,
            s_4892_2,
            s_4892_3,
            s_4892_4,
            s_4892_5,
            s_4892_6,
        );
        // N s_4892_8: return
        return;
    }
    fn block_4893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4893_0: read-var opc2:u8
        let s_4893_0: u8 = fn_state.opc2;
        // D s_4893_1: cast zx s_4893_0 -> bv
        let s_4893_1: Bits = Bits::new(s_4893_0 as u128, 3u16);
        // C s_4893_2: const #0u : u8
        let s_4893_2: u8 = 0;
        // C s_4893_3: cast zx s_4893_2 -> bv
        let s_4893_3: Bits = Bits::new(s_4893_2 as u128, 3u16);
        // D s_4893_4: cmp-eq s_4893_1 s_4893_3
        let s_4893_4: bool = ((s_4893_1) == (s_4893_3));
        // D s_4893_5: write-var gs#135147 <= s_4893_4
        fn_state.gs_135147 = s_4893_4;
        // N s_4893_6: jump b1502
        return block_1502(state, tracer, fn_state);
    }
    fn block_4894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4894_0: read-var opc1:u8
        let s_4894_0: u8 = fn_state.opc1;
        // D s_4894_1: cast zx s_4894_0 -> bv
        let s_4894_1: Bits = Bits::new(s_4894_0 as u128, 3u16);
        // C s_4894_2: const #0u : u8
        let s_4894_2: u8 = 0;
        // C s_4894_3: cast zx s_4894_2 -> bv
        let s_4894_3: Bits = Bits::new(s_4894_2 as u128, 3u16);
        // D s_4894_4: cmp-eq s_4894_1 s_4894_3
        let s_4894_4: bool = ((s_4894_1) == (s_4894_3));
        // D s_4894_5: write-var gs#135146 <= s_4894_4
        fn_state.gs_135146 = s_4894_4;
        // N s_4894_6: jump b1500
        return block_1500(state, tracer, fn_state);
    }
    fn block_4895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4895_0: read-var coproc:u8
        let s_4895_0: u8 = fn_state.coproc;
        // D s_4895_1: cast zx s_4895_0 -> bv
        let s_4895_1: Bits = Bits::new(s_4895_0 as u128, 4u16);
        // C s_4895_2: const #15u : u8
        let s_4895_2: u8 = 15;
        // C s_4895_3: cast zx s_4895_2 -> bv
        let s_4895_3: Bits = Bits::new(s_4895_2 as u128, 4u16);
        // D s_4895_4: cmp-eq s_4895_1 s_4895_3
        let s_4895_4: bool = ((s_4895_1) == (s_4895_3));
        // D s_4895_5: write-var gs#135145 <= s_4895_4
        fn_state.gs_135145 = s_4895_4;
        // N s_4895_6: jump b1498
        return block_1498(state, tracer, fn_state);
    }
    fn block_4896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4896_0: read-var CRn:u8
        let s_4896_0: u8 = fn_state.CRn;
        // D s_4896_1: cast zx s_4896_0 -> bv
        let s_4896_1: Bits = Bits::new(s_4896_0 as u128, 4u16);
        // C s_4896_2: const #14u : u8
        let s_4896_2: u8 = 14;
        // C s_4896_3: cast zx s_4896_2 -> bv
        let s_4896_3: Bits = Bits::new(s_4896_2 as u128, 4u16);
        // D s_4896_4: cmp-eq s_4896_1 s_4896_3
        let s_4896_4: bool = ((s_4896_1) == (s_4896_3));
        // D s_4896_5: write-var gs#135144 <= s_4896_4
        fn_state.gs_135144 = s_4896_4;
        // N s_4896_6: jump b1496
        return block_1496(state, tracer, fn_state);
    }
    fn block_4897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4897_0: read-var el:u8
        let s_4897_0: u8 = fn_state.el;
        // D s_4897_1: read-var coproc:u8
        let s_4897_1: u8 = fn_state.coproc;
        // D s_4897_2: read-var opc1:u8
        let s_4897_2: u8 = fn_state.opc1;
        // D s_4897_3: read-var CRn:u8
        let s_4897_3: u8 = fn_state.CRn;
        // D s_4897_4: read-var opc2:u8
        let s_4897_4: u8 = fn_state.opc2;
        // D s_4897_5: read-var CRm:u8
        let s_4897_5: u8 = fn_state.CRm;
        // D s_4897_6: read-var t:i
        let s_4897_6: i128 = fn_state.t;
        // D s_4897_7: call PMEVCNTR_SysRegWrite32_e55f104293c82cc7(s_4897_0, s_4897_1, s_4897_2, s_4897_3, s_4897_4, s_4897_5, s_4897_6)
        let s_4897_7: () = PMEVCNTR_SysRegWrite32_e55f104293c82cc7(
            state,
            tracer,
            s_4897_0,
            s_4897_1,
            s_4897_2,
            s_4897_3,
            s_4897_4,
            s_4897_5,
            s_4897_6,
        );
        // N s_4897_8: return
        return;
    }
    fn block_4898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4898_0: read-var opc2:u8
        let s_4898_0: u8 = fn_state.opc2;
        // D s_4898_1: cast zx s_4898_0 -> bv
        let s_4898_1: Bits = Bits::new(s_4898_0 as u128, 3u16);
        // C s_4898_2: const #1u : u8
        let s_4898_2: u8 = 1;
        // C s_4898_3: cast zx s_4898_2 -> bv
        let s_4898_3: Bits = Bits::new(s_4898_2 as u128, 3u16);
        // D s_4898_4: cmp-eq s_4898_1 s_4898_3
        let s_4898_4: bool = ((s_4898_1) == (s_4898_3));
        // D s_4898_5: write-var gs#135143 <= s_4898_4
        fn_state.gs_135143 = s_4898_4;
        // N s_4898_6: jump b1493
        return block_1493(state, tracer, fn_state);
    }
    fn block_4899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4899_0: read-var opc1:u8
        let s_4899_0: u8 = fn_state.opc1;
        // D s_4899_1: cast zx s_4899_0 -> bv
        let s_4899_1: Bits = Bits::new(s_4899_0 as u128, 3u16);
        // C s_4899_2: const #0u : u8
        let s_4899_2: u8 = 0;
        // C s_4899_3: cast zx s_4899_2 -> bv
        let s_4899_3: Bits = Bits::new(s_4899_2 as u128, 3u16);
        // D s_4899_4: cmp-eq s_4899_1 s_4899_3
        let s_4899_4: bool = ((s_4899_1) == (s_4899_3));
        // D s_4899_5: write-var gs#135142 <= s_4899_4
        fn_state.gs_135142 = s_4899_4;
        // N s_4899_6: jump b1491
        return block_1491(state, tracer, fn_state);
    }
    fn block_4900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4900_0: read-var coproc:u8
        let s_4900_0: u8 = fn_state.coproc;
        // D s_4900_1: cast zx s_4900_0 -> bv
        let s_4900_1: Bits = Bits::new(s_4900_0 as u128, 4u16);
        // C s_4900_2: const #15u : u8
        let s_4900_2: u8 = 15;
        // C s_4900_3: cast zx s_4900_2 -> bv
        let s_4900_3: Bits = Bits::new(s_4900_2 as u128, 4u16);
        // D s_4900_4: cmp-eq s_4900_1 s_4900_3
        let s_4900_4: bool = ((s_4900_1) == (s_4900_3));
        // D s_4900_5: write-var gs#135141 <= s_4900_4
        fn_state.gs_135141 = s_4900_4;
        // N s_4900_6: jump b1489
        return block_1489(state, tracer, fn_state);
    }
    fn block_4901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4901_0: read-var CRn:u8
        let s_4901_0: u8 = fn_state.CRn;
        // D s_4901_1: cast zx s_4901_0 -> bv
        let s_4901_1: Bits = Bits::new(s_4901_0 as u128, 4u16);
        // C s_4901_2: const #14u : u8
        let s_4901_2: u8 = 14;
        // C s_4901_3: cast zx s_4901_2 -> bv
        let s_4901_3: Bits = Bits::new(s_4901_2 as u128, 4u16);
        // D s_4901_4: cmp-eq s_4901_1 s_4901_3
        let s_4901_4: bool = ((s_4901_1) == (s_4901_3));
        // D s_4901_5: write-var gs#135140 <= s_4901_4
        fn_state.gs_135140 = s_4901_4;
        // N s_4901_6: jump b1487
        return block_1487(state, tracer, fn_state);
    }
    fn block_4902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4902_0: read-var el:u8
        let s_4902_0: u8 = fn_state.el;
        // D s_4902_1: read-var coproc:u8
        let s_4902_1: u8 = fn_state.coproc;
        // D s_4902_2: read-var opc1:u8
        let s_4902_2: u8 = fn_state.opc1;
        // D s_4902_3: read-var CRn:u8
        let s_4902_3: u8 = fn_state.CRn;
        // D s_4902_4: read-var opc2:u8
        let s_4902_4: u8 = fn_state.opc2;
        // D s_4902_5: read-var CRm:u8
        let s_4902_5: u8 = fn_state.CRm;
        // D s_4902_6: read-var t:i
        let s_4902_6: i128 = fn_state.t;
        // D s_4902_7: call PMEVCNTR_SysRegWrite32_ea82053afec3aa68(s_4902_0, s_4902_1, s_4902_2, s_4902_3, s_4902_4, s_4902_5, s_4902_6)
        let s_4902_7: () = PMEVCNTR_SysRegWrite32_ea82053afec3aa68(
            state,
            tracer,
            s_4902_0,
            s_4902_1,
            s_4902_2,
            s_4902_3,
            s_4902_4,
            s_4902_5,
            s_4902_6,
        );
        // N s_4902_8: return
        return;
    }
    fn block_4903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4903_0: read-var opc2:u8
        let s_4903_0: u8 = fn_state.opc2;
        // D s_4903_1: cast zx s_4903_0 -> bv
        let s_4903_1: Bits = Bits::new(s_4903_0 as u128, 3u16);
        // C s_4903_2: const #2u : u8
        let s_4903_2: u8 = 2;
        // C s_4903_3: cast zx s_4903_2 -> bv
        let s_4903_3: Bits = Bits::new(s_4903_2 as u128, 3u16);
        // D s_4903_4: cmp-eq s_4903_1 s_4903_3
        let s_4903_4: bool = ((s_4903_1) == (s_4903_3));
        // D s_4903_5: write-var gs#135139 <= s_4903_4
        fn_state.gs_135139 = s_4903_4;
        // N s_4903_6: jump b1484
        return block_1484(state, tracer, fn_state);
    }
    fn block_4904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4904_0: read-var opc1:u8
        let s_4904_0: u8 = fn_state.opc1;
        // D s_4904_1: cast zx s_4904_0 -> bv
        let s_4904_1: Bits = Bits::new(s_4904_0 as u128, 3u16);
        // C s_4904_2: const #0u : u8
        let s_4904_2: u8 = 0;
        // C s_4904_3: cast zx s_4904_2 -> bv
        let s_4904_3: Bits = Bits::new(s_4904_2 as u128, 3u16);
        // D s_4904_4: cmp-eq s_4904_1 s_4904_3
        let s_4904_4: bool = ((s_4904_1) == (s_4904_3));
        // D s_4904_5: write-var gs#135138 <= s_4904_4
        fn_state.gs_135138 = s_4904_4;
        // N s_4904_6: jump b1482
        return block_1482(state, tracer, fn_state);
    }
    fn block_4905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4905_0: read-var coproc:u8
        let s_4905_0: u8 = fn_state.coproc;
        // D s_4905_1: cast zx s_4905_0 -> bv
        let s_4905_1: Bits = Bits::new(s_4905_0 as u128, 4u16);
        // C s_4905_2: const #15u : u8
        let s_4905_2: u8 = 15;
        // C s_4905_3: cast zx s_4905_2 -> bv
        let s_4905_3: Bits = Bits::new(s_4905_2 as u128, 4u16);
        // D s_4905_4: cmp-eq s_4905_1 s_4905_3
        let s_4905_4: bool = ((s_4905_1) == (s_4905_3));
        // D s_4905_5: write-var gs#135137 <= s_4905_4
        fn_state.gs_135137 = s_4905_4;
        // N s_4905_6: jump b1480
        return block_1480(state, tracer, fn_state);
    }
    fn block_4906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4906_0: read-var CRn:u8
        let s_4906_0: u8 = fn_state.CRn;
        // D s_4906_1: cast zx s_4906_0 -> bv
        let s_4906_1: Bits = Bits::new(s_4906_0 as u128, 4u16);
        // C s_4906_2: const #14u : u8
        let s_4906_2: u8 = 14;
        // C s_4906_3: cast zx s_4906_2 -> bv
        let s_4906_3: Bits = Bits::new(s_4906_2 as u128, 4u16);
        // D s_4906_4: cmp-eq s_4906_1 s_4906_3
        let s_4906_4: bool = ((s_4906_1) == (s_4906_3));
        // D s_4906_5: write-var gs#135136 <= s_4906_4
        fn_state.gs_135136 = s_4906_4;
        // N s_4906_6: jump b1478
        return block_1478(state, tracer, fn_state);
    }
    fn block_4907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4907_0: read-var el:u8
        let s_4907_0: u8 = fn_state.el;
        // D s_4907_1: read-var coproc:u8
        let s_4907_1: u8 = fn_state.coproc;
        // D s_4907_2: read-var opc1:u8
        let s_4907_2: u8 = fn_state.opc1;
        // D s_4907_3: read-var CRn:u8
        let s_4907_3: u8 = fn_state.CRn;
        // D s_4907_4: read-var opc2:u8
        let s_4907_4: u8 = fn_state.opc2;
        // D s_4907_5: read-var CRm:u8
        let s_4907_5: u8 = fn_state.CRm;
        // D s_4907_6: read-var t:i
        let s_4907_6: i128 = fn_state.t;
        // D s_4907_7: call PMEVCNTR_SysRegWrite32_3f499998ad4dfc7e(s_4907_0, s_4907_1, s_4907_2, s_4907_3, s_4907_4, s_4907_5, s_4907_6)
        let s_4907_7: () = PMEVCNTR_SysRegWrite32_3f499998ad4dfc7e(
            state,
            tracer,
            s_4907_0,
            s_4907_1,
            s_4907_2,
            s_4907_3,
            s_4907_4,
            s_4907_5,
            s_4907_6,
        );
        // N s_4907_8: return
        return;
    }
    fn block_4908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4908_0: read-var opc2:u8
        let s_4908_0: u8 = fn_state.opc2;
        // D s_4908_1: cast zx s_4908_0 -> bv
        let s_4908_1: Bits = Bits::new(s_4908_0 as u128, 3u16);
        // C s_4908_2: const #3u : u8
        let s_4908_2: u8 = 3;
        // C s_4908_3: cast zx s_4908_2 -> bv
        let s_4908_3: Bits = Bits::new(s_4908_2 as u128, 3u16);
        // D s_4908_4: cmp-eq s_4908_1 s_4908_3
        let s_4908_4: bool = ((s_4908_1) == (s_4908_3));
        // D s_4908_5: write-var gs#135135 <= s_4908_4
        fn_state.gs_135135 = s_4908_4;
        // N s_4908_6: jump b1475
        return block_1475(state, tracer, fn_state);
    }
    fn block_4909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4909_0: read-var opc1:u8
        let s_4909_0: u8 = fn_state.opc1;
        // D s_4909_1: cast zx s_4909_0 -> bv
        let s_4909_1: Bits = Bits::new(s_4909_0 as u128, 3u16);
        // C s_4909_2: const #0u : u8
        let s_4909_2: u8 = 0;
        // C s_4909_3: cast zx s_4909_2 -> bv
        let s_4909_3: Bits = Bits::new(s_4909_2 as u128, 3u16);
        // D s_4909_4: cmp-eq s_4909_1 s_4909_3
        let s_4909_4: bool = ((s_4909_1) == (s_4909_3));
        // D s_4909_5: write-var gs#135134 <= s_4909_4
        fn_state.gs_135134 = s_4909_4;
        // N s_4909_6: jump b1473
        return block_1473(state, tracer, fn_state);
    }
    fn block_4910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4910_0: read-var coproc:u8
        let s_4910_0: u8 = fn_state.coproc;
        // D s_4910_1: cast zx s_4910_0 -> bv
        let s_4910_1: Bits = Bits::new(s_4910_0 as u128, 4u16);
        // C s_4910_2: const #15u : u8
        let s_4910_2: u8 = 15;
        // C s_4910_3: cast zx s_4910_2 -> bv
        let s_4910_3: Bits = Bits::new(s_4910_2 as u128, 4u16);
        // D s_4910_4: cmp-eq s_4910_1 s_4910_3
        let s_4910_4: bool = ((s_4910_1) == (s_4910_3));
        // D s_4910_5: write-var gs#135133 <= s_4910_4
        fn_state.gs_135133 = s_4910_4;
        // N s_4910_6: jump b1471
        return block_1471(state, tracer, fn_state);
    }
    fn block_4911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4911_0: read-var CRn:u8
        let s_4911_0: u8 = fn_state.CRn;
        // D s_4911_1: cast zx s_4911_0 -> bv
        let s_4911_1: Bits = Bits::new(s_4911_0 as u128, 4u16);
        // C s_4911_2: const #14u : u8
        let s_4911_2: u8 = 14;
        // C s_4911_3: cast zx s_4911_2 -> bv
        let s_4911_3: Bits = Bits::new(s_4911_2 as u128, 4u16);
        // D s_4911_4: cmp-eq s_4911_1 s_4911_3
        let s_4911_4: bool = ((s_4911_1) == (s_4911_3));
        // D s_4911_5: write-var gs#135132 <= s_4911_4
        fn_state.gs_135132 = s_4911_4;
        // N s_4911_6: jump b1469
        return block_1469(state, tracer, fn_state);
    }
    fn block_4912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4912_0: read-var el:u8
        let s_4912_0: u8 = fn_state.el;
        // D s_4912_1: read-var coproc:u8
        let s_4912_1: u8 = fn_state.coproc;
        // D s_4912_2: read-var opc1:u8
        let s_4912_2: u8 = fn_state.opc1;
        // D s_4912_3: read-var CRn:u8
        let s_4912_3: u8 = fn_state.CRn;
        // D s_4912_4: read-var opc2:u8
        let s_4912_4: u8 = fn_state.opc2;
        // D s_4912_5: read-var CRm:u8
        let s_4912_5: u8 = fn_state.CRm;
        // D s_4912_6: read-var t:i
        let s_4912_6: i128 = fn_state.t;
        // D s_4912_7: call PMEVCNTR_SysRegWrite32_1b282b60cc4c6447(s_4912_0, s_4912_1, s_4912_2, s_4912_3, s_4912_4, s_4912_5, s_4912_6)
        let s_4912_7: () = PMEVCNTR_SysRegWrite32_1b282b60cc4c6447(
            state,
            tracer,
            s_4912_0,
            s_4912_1,
            s_4912_2,
            s_4912_3,
            s_4912_4,
            s_4912_5,
            s_4912_6,
        );
        // N s_4912_8: return
        return;
    }
    fn block_4913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4913_0: read-var opc2:u8
        let s_4913_0: u8 = fn_state.opc2;
        // D s_4913_1: cast zx s_4913_0 -> bv
        let s_4913_1: Bits = Bits::new(s_4913_0 as u128, 3u16);
        // C s_4913_2: const #4u : u8
        let s_4913_2: u8 = 4;
        // C s_4913_3: cast zx s_4913_2 -> bv
        let s_4913_3: Bits = Bits::new(s_4913_2 as u128, 3u16);
        // D s_4913_4: cmp-eq s_4913_1 s_4913_3
        let s_4913_4: bool = ((s_4913_1) == (s_4913_3));
        // D s_4913_5: write-var gs#135131 <= s_4913_4
        fn_state.gs_135131 = s_4913_4;
        // N s_4913_6: jump b1466
        return block_1466(state, tracer, fn_state);
    }
    fn block_4914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4914_0: read-var opc1:u8
        let s_4914_0: u8 = fn_state.opc1;
        // D s_4914_1: cast zx s_4914_0 -> bv
        let s_4914_1: Bits = Bits::new(s_4914_0 as u128, 3u16);
        // C s_4914_2: const #0u : u8
        let s_4914_2: u8 = 0;
        // C s_4914_3: cast zx s_4914_2 -> bv
        let s_4914_3: Bits = Bits::new(s_4914_2 as u128, 3u16);
        // D s_4914_4: cmp-eq s_4914_1 s_4914_3
        let s_4914_4: bool = ((s_4914_1) == (s_4914_3));
        // D s_4914_5: write-var gs#135130 <= s_4914_4
        fn_state.gs_135130 = s_4914_4;
        // N s_4914_6: jump b1464
        return block_1464(state, tracer, fn_state);
    }
    fn block_4915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4915_0: read-var coproc:u8
        let s_4915_0: u8 = fn_state.coproc;
        // D s_4915_1: cast zx s_4915_0 -> bv
        let s_4915_1: Bits = Bits::new(s_4915_0 as u128, 4u16);
        // C s_4915_2: const #15u : u8
        let s_4915_2: u8 = 15;
        // C s_4915_3: cast zx s_4915_2 -> bv
        let s_4915_3: Bits = Bits::new(s_4915_2 as u128, 4u16);
        // D s_4915_4: cmp-eq s_4915_1 s_4915_3
        let s_4915_4: bool = ((s_4915_1) == (s_4915_3));
        // D s_4915_5: write-var gs#135129 <= s_4915_4
        fn_state.gs_135129 = s_4915_4;
        // N s_4915_6: jump b1462
        return block_1462(state, tracer, fn_state);
    }
    fn block_4916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4916_0: read-var CRn:u8
        let s_4916_0: u8 = fn_state.CRn;
        // D s_4916_1: cast zx s_4916_0 -> bv
        let s_4916_1: Bits = Bits::new(s_4916_0 as u128, 4u16);
        // C s_4916_2: const #14u : u8
        let s_4916_2: u8 = 14;
        // C s_4916_3: cast zx s_4916_2 -> bv
        let s_4916_3: Bits = Bits::new(s_4916_2 as u128, 4u16);
        // D s_4916_4: cmp-eq s_4916_1 s_4916_3
        let s_4916_4: bool = ((s_4916_1) == (s_4916_3));
        // D s_4916_5: write-var gs#135128 <= s_4916_4
        fn_state.gs_135128 = s_4916_4;
        // N s_4916_6: jump b1460
        return block_1460(state, tracer, fn_state);
    }
    fn block_4917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4917_0: read-var el:u8
        let s_4917_0: u8 = fn_state.el;
        // D s_4917_1: read-var coproc:u8
        let s_4917_1: u8 = fn_state.coproc;
        // D s_4917_2: read-var opc1:u8
        let s_4917_2: u8 = fn_state.opc1;
        // D s_4917_3: read-var CRn:u8
        let s_4917_3: u8 = fn_state.CRn;
        // D s_4917_4: read-var opc2:u8
        let s_4917_4: u8 = fn_state.opc2;
        // D s_4917_5: read-var CRm:u8
        let s_4917_5: u8 = fn_state.CRm;
        // D s_4917_6: read-var t:i
        let s_4917_6: i128 = fn_state.t;
        // D s_4917_7: call PMEVCNTR_SysRegWrite32_659a321a15f83618(s_4917_0, s_4917_1, s_4917_2, s_4917_3, s_4917_4, s_4917_5, s_4917_6)
        let s_4917_7: () = PMEVCNTR_SysRegWrite32_659a321a15f83618(
            state,
            tracer,
            s_4917_0,
            s_4917_1,
            s_4917_2,
            s_4917_3,
            s_4917_4,
            s_4917_5,
            s_4917_6,
        );
        // N s_4917_8: return
        return;
    }
    fn block_4918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4918_0: read-var opc2:u8
        let s_4918_0: u8 = fn_state.opc2;
        // D s_4918_1: cast zx s_4918_0 -> bv
        let s_4918_1: Bits = Bits::new(s_4918_0 as u128, 3u16);
        // C s_4918_2: const #5u : u8
        let s_4918_2: u8 = 5;
        // C s_4918_3: cast zx s_4918_2 -> bv
        let s_4918_3: Bits = Bits::new(s_4918_2 as u128, 3u16);
        // D s_4918_4: cmp-eq s_4918_1 s_4918_3
        let s_4918_4: bool = ((s_4918_1) == (s_4918_3));
        // D s_4918_5: write-var gs#135127 <= s_4918_4
        fn_state.gs_135127 = s_4918_4;
        // N s_4918_6: jump b1457
        return block_1457(state, tracer, fn_state);
    }
    fn block_4919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4919_0: read-var opc1:u8
        let s_4919_0: u8 = fn_state.opc1;
        // D s_4919_1: cast zx s_4919_0 -> bv
        let s_4919_1: Bits = Bits::new(s_4919_0 as u128, 3u16);
        // C s_4919_2: const #0u : u8
        let s_4919_2: u8 = 0;
        // C s_4919_3: cast zx s_4919_2 -> bv
        let s_4919_3: Bits = Bits::new(s_4919_2 as u128, 3u16);
        // D s_4919_4: cmp-eq s_4919_1 s_4919_3
        let s_4919_4: bool = ((s_4919_1) == (s_4919_3));
        // D s_4919_5: write-var gs#135126 <= s_4919_4
        fn_state.gs_135126 = s_4919_4;
        // N s_4919_6: jump b1455
        return block_1455(state, tracer, fn_state);
    }
    fn block_4920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4920_0: read-var coproc:u8
        let s_4920_0: u8 = fn_state.coproc;
        // D s_4920_1: cast zx s_4920_0 -> bv
        let s_4920_1: Bits = Bits::new(s_4920_0 as u128, 4u16);
        // C s_4920_2: const #15u : u8
        let s_4920_2: u8 = 15;
        // C s_4920_3: cast zx s_4920_2 -> bv
        let s_4920_3: Bits = Bits::new(s_4920_2 as u128, 4u16);
        // D s_4920_4: cmp-eq s_4920_1 s_4920_3
        let s_4920_4: bool = ((s_4920_1) == (s_4920_3));
        // D s_4920_5: write-var gs#135125 <= s_4920_4
        fn_state.gs_135125 = s_4920_4;
        // N s_4920_6: jump b1453
        return block_1453(state, tracer, fn_state);
    }
    fn block_4921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4921_0: read-var CRn:u8
        let s_4921_0: u8 = fn_state.CRn;
        // D s_4921_1: cast zx s_4921_0 -> bv
        let s_4921_1: Bits = Bits::new(s_4921_0 as u128, 4u16);
        // C s_4921_2: const #14u : u8
        let s_4921_2: u8 = 14;
        // C s_4921_3: cast zx s_4921_2 -> bv
        let s_4921_3: Bits = Bits::new(s_4921_2 as u128, 4u16);
        // D s_4921_4: cmp-eq s_4921_1 s_4921_3
        let s_4921_4: bool = ((s_4921_1) == (s_4921_3));
        // D s_4921_5: write-var gs#135124 <= s_4921_4
        fn_state.gs_135124 = s_4921_4;
        // N s_4921_6: jump b1451
        return block_1451(state, tracer, fn_state);
    }
    fn block_4922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4922_0: read-var el:u8
        let s_4922_0: u8 = fn_state.el;
        // D s_4922_1: read-var coproc:u8
        let s_4922_1: u8 = fn_state.coproc;
        // D s_4922_2: read-var opc1:u8
        let s_4922_2: u8 = fn_state.opc1;
        // D s_4922_3: read-var CRn:u8
        let s_4922_3: u8 = fn_state.CRn;
        // D s_4922_4: read-var opc2:u8
        let s_4922_4: u8 = fn_state.opc2;
        // D s_4922_5: read-var CRm:u8
        let s_4922_5: u8 = fn_state.CRm;
        // D s_4922_6: read-var t:i
        let s_4922_6: i128 = fn_state.t;
        // D s_4922_7: call PMEVCNTR_SysRegWrite32_93be8ea1078adab4(s_4922_0, s_4922_1, s_4922_2, s_4922_3, s_4922_4, s_4922_5, s_4922_6)
        let s_4922_7: () = PMEVCNTR_SysRegWrite32_93be8ea1078adab4(
            state,
            tracer,
            s_4922_0,
            s_4922_1,
            s_4922_2,
            s_4922_3,
            s_4922_4,
            s_4922_5,
            s_4922_6,
        );
        // N s_4922_8: return
        return;
    }
    fn block_4923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4923_0: read-var opc2:u8
        let s_4923_0: u8 = fn_state.opc2;
        // D s_4923_1: cast zx s_4923_0 -> bv
        let s_4923_1: Bits = Bits::new(s_4923_0 as u128, 3u16);
        // C s_4923_2: const #6u : u8
        let s_4923_2: u8 = 6;
        // C s_4923_3: cast zx s_4923_2 -> bv
        let s_4923_3: Bits = Bits::new(s_4923_2 as u128, 3u16);
        // D s_4923_4: cmp-eq s_4923_1 s_4923_3
        let s_4923_4: bool = ((s_4923_1) == (s_4923_3));
        // D s_4923_5: write-var gs#135123 <= s_4923_4
        fn_state.gs_135123 = s_4923_4;
        // N s_4923_6: jump b1448
        return block_1448(state, tracer, fn_state);
    }
    fn block_4924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4924_0: read-var opc1:u8
        let s_4924_0: u8 = fn_state.opc1;
        // D s_4924_1: cast zx s_4924_0 -> bv
        let s_4924_1: Bits = Bits::new(s_4924_0 as u128, 3u16);
        // C s_4924_2: const #0u : u8
        let s_4924_2: u8 = 0;
        // C s_4924_3: cast zx s_4924_2 -> bv
        let s_4924_3: Bits = Bits::new(s_4924_2 as u128, 3u16);
        // D s_4924_4: cmp-eq s_4924_1 s_4924_3
        let s_4924_4: bool = ((s_4924_1) == (s_4924_3));
        // D s_4924_5: write-var gs#135122 <= s_4924_4
        fn_state.gs_135122 = s_4924_4;
        // N s_4924_6: jump b1446
        return block_1446(state, tracer, fn_state);
    }
    fn block_4925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4925_0: read-var coproc:u8
        let s_4925_0: u8 = fn_state.coproc;
        // D s_4925_1: cast zx s_4925_0 -> bv
        let s_4925_1: Bits = Bits::new(s_4925_0 as u128, 4u16);
        // C s_4925_2: const #15u : u8
        let s_4925_2: u8 = 15;
        // C s_4925_3: cast zx s_4925_2 -> bv
        let s_4925_3: Bits = Bits::new(s_4925_2 as u128, 4u16);
        // D s_4925_4: cmp-eq s_4925_1 s_4925_3
        let s_4925_4: bool = ((s_4925_1) == (s_4925_3));
        // D s_4925_5: write-var gs#135121 <= s_4925_4
        fn_state.gs_135121 = s_4925_4;
        // N s_4925_6: jump b1444
        return block_1444(state, tracer, fn_state);
    }
    fn block_4926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4926_0: read-var CRn:u8
        let s_4926_0: u8 = fn_state.CRn;
        // D s_4926_1: cast zx s_4926_0 -> bv
        let s_4926_1: Bits = Bits::new(s_4926_0 as u128, 4u16);
        // C s_4926_2: const #14u : u8
        let s_4926_2: u8 = 14;
        // C s_4926_3: cast zx s_4926_2 -> bv
        let s_4926_3: Bits = Bits::new(s_4926_2 as u128, 4u16);
        // D s_4926_4: cmp-eq s_4926_1 s_4926_3
        let s_4926_4: bool = ((s_4926_1) == (s_4926_3));
        // D s_4926_5: write-var gs#135120 <= s_4926_4
        fn_state.gs_135120 = s_4926_4;
        // N s_4926_6: jump b1442
        return block_1442(state, tracer, fn_state);
    }
    fn block_4927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4927_0: read-var el:u8
        let s_4927_0: u8 = fn_state.el;
        // D s_4927_1: read-var coproc:u8
        let s_4927_1: u8 = fn_state.coproc;
        // D s_4927_2: read-var opc1:u8
        let s_4927_2: u8 = fn_state.opc1;
        // D s_4927_3: read-var CRn:u8
        let s_4927_3: u8 = fn_state.CRn;
        // D s_4927_4: read-var opc2:u8
        let s_4927_4: u8 = fn_state.opc2;
        // D s_4927_5: read-var CRm:u8
        let s_4927_5: u8 = fn_state.CRm;
        // D s_4927_6: read-var t:i
        let s_4927_6: i128 = fn_state.t;
        // D s_4927_7: call PMEVCNTR_SysRegWrite32_b7abf79765976a11(s_4927_0, s_4927_1, s_4927_2, s_4927_3, s_4927_4, s_4927_5, s_4927_6)
        let s_4927_7: () = PMEVCNTR_SysRegWrite32_b7abf79765976a11(
            state,
            tracer,
            s_4927_0,
            s_4927_1,
            s_4927_2,
            s_4927_3,
            s_4927_4,
            s_4927_5,
            s_4927_6,
        );
        // N s_4927_8: return
        return;
    }
    fn block_4928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4928_0: read-var opc2:u8
        let s_4928_0: u8 = fn_state.opc2;
        // D s_4928_1: cast zx s_4928_0 -> bv
        let s_4928_1: Bits = Bits::new(s_4928_0 as u128, 3u16);
        // C s_4928_2: const #7u : u8
        let s_4928_2: u8 = 7;
        // C s_4928_3: cast zx s_4928_2 -> bv
        let s_4928_3: Bits = Bits::new(s_4928_2 as u128, 3u16);
        // D s_4928_4: cmp-eq s_4928_1 s_4928_3
        let s_4928_4: bool = ((s_4928_1) == (s_4928_3));
        // D s_4928_5: write-var gs#135119 <= s_4928_4
        fn_state.gs_135119 = s_4928_4;
        // N s_4928_6: jump b1439
        return block_1439(state, tracer, fn_state);
    }
    fn block_4929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4929_0: read-var opc1:u8
        let s_4929_0: u8 = fn_state.opc1;
        // D s_4929_1: cast zx s_4929_0 -> bv
        let s_4929_1: Bits = Bits::new(s_4929_0 as u128, 3u16);
        // C s_4929_2: const #0u : u8
        let s_4929_2: u8 = 0;
        // C s_4929_3: cast zx s_4929_2 -> bv
        let s_4929_3: Bits = Bits::new(s_4929_2 as u128, 3u16);
        // D s_4929_4: cmp-eq s_4929_1 s_4929_3
        let s_4929_4: bool = ((s_4929_1) == (s_4929_3));
        // D s_4929_5: write-var gs#135118 <= s_4929_4
        fn_state.gs_135118 = s_4929_4;
        // N s_4929_6: jump b1437
        return block_1437(state, tracer, fn_state);
    }
    fn block_4930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4930_0: read-var coproc:u8
        let s_4930_0: u8 = fn_state.coproc;
        // D s_4930_1: cast zx s_4930_0 -> bv
        let s_4930_1: Bits = Bits::new(s_4930_0 as u128, 4u16);
        // C s_4930_2: const #15u : u8
        let s_4930_2: u8 = 15;
        // C s_4930_3: cast zx s_4930_2 -> bv
        let s_4930_3: Bits = Bits::new(s_4930_2 as u128, 4u16);
        // D s_4930_4: cmp-eq s_4930_1 s_4930_3
        let s_4930_4: bool = ((s_4930_1) == (s_4930_3));
        // D s_4930_5: write-var gs#135117 <= s_4930_4
        fn_state.gs_135117 = s_4930_4;
        // N s_4930_6: jump b1435
        return block_1435(state, tracer, fn_state);
    }
    fn block_4931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4931_0: read-var CRn:u8
        let s_4931_0: u8 = fn_state.CRn;
        // D s_4931_1: cast zx s_4931_0 -> bv
        let s_4931_1: Bits = Bits::new(s_4931_0 as u128, 4u16);
        // C s_4931_2: const #14u : u8
        let s_4931_2: u8 = 14;
        // C s_4931_3: cast zx s_4931_2 -> bv
        let s_4931_3: Bits = Bits::new(s_4931_2 as u128, 4u16);
        // D s_4931_4: cmp-eq s_4931_1 s_4931_3
        let s_4931_4: bool = ((s_4931_1) == (s_4931_3));
        // D s_4931_5: write-var gs#135116 <= s_4931_4
        fn_state.gs_135116 = s_4931_4;
        // N s_4931_6: jump b1433
        return block_1433(state, tracer, fn_state);
    }
    fn block_4932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4932_0: read-var el:u8
        let s_4932_0: u8 = fn_state.el;
        // D s_4932_1: read-var coproc:u8
        let s_4932_1: u8 = fn_state.coproc;
        // D s_4932_2: read-var opc1:u8
        let s_4932_2: u8 = fn_state.opc1;
        // D s_4932_3: read-var CRn:u8
        let s_4932_3: u8 = fn_state.CRn;
        // D s_4932_4: read-var opc2:u8
        let s_4932_4: u8 = fn_state.opc2;
        // D s_4932_5: read-var CRm:u8
        let s_4932_5: u8 = fn_state.CRm;
        // D s_4932_6: read-var t:i
        let s_4932_6: i128 = fn_state.t;
        // D s_4932_7: call PMEVCNTR_SysRegWrite32_cdcaf594688625d5(s_4932_0, s_4932_1, s_4932_2, s_4932_3, s_4932_4, s_4932_5, s_4932_6)
        let s_4932_7: () = PMEVCNTR_SysRegWrite32_cdcaf594688625d5(
            state,
            tracer,
            s_4932_0,
            s_4932_1,
            s_4932_2,
            s_4932_3,
            s_4932_4,
            s_4932_5,
            s_4932_6,
        );
        // N s_4932_8: return
        return;
    }
    fn block_4933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4933_0: read-var opc2:u8
        let s_4933_0: u8 = fn_state.opc2;
        // D s_4933_1: cast zx s_4933_0 -> bv
        let s_4933_1: Bits = Bits::new(s_4933_0 as u128, 3u16);
        // C s_4933_2: const #0u : u8
        let s_4933_2: u8 = 0;
        // C s_4933_3: cast zx s_4933_2 -> bv
        let s_4933_3: Bits = Bits::new(s_4933_2 as u128, 3u16);
        // D s_4933_4: cmp-eq s_4933_1 s_4933_3
        let s_4933_4: bool = ((s_4933_1) == (s_4933_3));
        // D s_4933_5: write-var gs#135115 <= s_4933_4
        fn_state.gs_135115 = s_4933_4;
        // N s_4933_6: jump b1430
        return block_1430(state, tracer, fn_state);
    }
    fn block_4934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4934_0: read-var opc1:u8
        let s_4934_0: u8 = fn_state.opc1;
        // D s_4934_1: cast zx s_4934_0 -> bv
        let s_4934_1: Bits = Bits::new(s_4934_0 as u128, 3u16);
        // C s_4934_2: const #0u : u8
        let s_4934_2: u8 = 0;
        // C s_4934_3: cast zx s_4934_2 -> bv
        let s_4934_3: Bits = Bits::new(s_4934_2 as u128, 3u16);
        // D s_4934_4: cmp-eq s_4934_1 s_4934_3
        let s_4934_4: bool = ((s_4934_1) == (s_4934_3));
        // D s_4934_5: write-var gs#135114 <= s_4934_4
        fn_state.gs_135114 = s_4934_4;
        // N s_4934_6: jump b1428
        return block_1428(state, tracer, fn_state);
    }
    fn block_4935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4935_0: read-var coproc:u8
        let s_4935_0: u8 = fn_state.coproc;
        // D s_4935_1: cast zx s_4935_0 -> bv
        let s_4935_1: Bits = Bits::new(s_4935_0 as u128, 4u16);
        // C s_4935_2: const #15u : u8
        let s_4935_2: u8 = 15;
        // C s_4935_3: cast zx s_4935_2 -> bv
        let s_4935_3: Bits = Bits::new(s_4935_2 as u128, 4u16);
        // D s_4935_4: cmp-eq s_4935_1 s_4935_3
        let s_4935_4: bool = ((s_4935_1) == (s_4935_3));
        // D s_4935_5: write-var gs#135113 <= s_4935_4
        fn_state.gs_135113 = s_4935_4;
        // N s_4935_6: jump b1426
        return block_1426(state, tracer, fn_state);
    }
    fn block_4936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4936_0: read-var CRn:u8
        let s_4936_0: u8 = fn_state.CRn;
        // D s_4936_1: cast zx s_4936_0 -> bv
        let s_4936_1: Bits = Bits::new(s_4936_0 as u128, 4u16);
        // C s_4936_2: const #14u : u8
        let s_4936_2: u8 = 14;
        // C s_4936_3: cast zx s_4936_2 -> bv
        let s_4936_3: Bits = Bits::new(s_4936_2 as u128, 4u16);
        // D s_4936_4: cmp-eq s_4936_1 s_4936_3
        let s_4936_4: bool = ((s_4936_1) == (s_4936_3));
        // D s_4936_5: write-var gs#135112 <= s_4936_4
        fn_state.gs_135112 = s_4936_4;
        // N s_4936_6: jump b1424
        return block_1424(state, tracer, fn_state);
    }
    fn block_4937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4937_0: read-var el:u8
        let s_4937_0: u8 = fn_state.el;
        // D s_4937_1: read-var coproc:u8
        let s_4937_1: u8 = fn_state.coproc;
        // D s_4937_2: read-var opc1:u8
        let s_4937_2: u8 = fn_state.opc1;
        // D s_4937_3: read-var CRn:u8
        let s_4937_3: u8 = fn_state.CRn;
        // D s_4937_4: read-var opc2:u8
        let s_4937_4: u8 = fn_state.opc2;
        // D s_4937_5: read-var CRm:u8
        let s_4937_5: u8 = fn_state.CRm;
        // D s_4937_6: read-var t:i
        let s_4937_6: i128 = fn_state.t;
        // D s_4937_7: call PMEVCNTR_SysRegWrite32_9dd8faac045ac370(s_4937_0, s_4937_1, s_4937_2, s_4937_3, s_4937_4, s_4937_5, s_4937_6)
        let s_4937_7: () = PMEVCNTR_SysRegWrite32_9dd8faac045ac370(
            state,
            tracer,
            s_4937_0,
            s_4937_1,
            s_4937_2,
            s_4937_3,
            s_4937_4,
            s_4937_5,
            s_4937_6,
        );
        // N s_4937_8: return
        return;
    }
    fn block_4938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4938_0: read-var opc2:u8
        let s_4938_0: u8 = fn_state.opc2;
        // D s_4938_1: cast zx s_4938_0 -> bv
        let s_4938_1: Bits = Bits::new(s_4938_0 as u128, 3u16);
        // C s_4938_2: const #1u : u8
        let s_4938_2: u8 = 1;
        // C s_4938_3: cast zx s_4938_2 -> bv
        let s_4938_3: Bits = Bits::new(s_4938_2 as u128, 3u16);
        // D s_4938_4: cmp-eq s_4938_1 s_4938_3
        let s_4938_4: bool = ((s_4938_1) == (s_4938_3));
        // D s_4938_5: write-var gs#135111 <= s_4938_4
        fn_state.gs_135111 = s_4938_4;
        // N s_4938_6: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_4939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4939_0: read-var opc1:u8
        let s_4939_0: u8 = fn_state.opc1;
        // D s_4939_1: cast zx s_4939_0 -> bv
        let s_4939_1: Bits = Bits::new(s_4939_0 as u128, 3u16);
        // C s_4939_2: const #0u : u8
        let s_4939_2: u8 = 0;
        // C s_4939_3: cast zx s_4939_2 -> bv
        let s_4939_3: Bits = Bits::new(s_4939_2 as u128, 3u16);
        // D s_4939_4: cmp-eq s_4939_1 s_4939_3
        let s_4939_4: bool = ((s_4939_1) == (s_4939_3));
        // D s_4939_5: write-var gs#135110 <= s_4939_4
        fn_state.gs_135110 = s_4939_4;
        // N s_4939_6: jump b1419
        return block_1419(state, tracer, fn_state);
    }
    fn block_4940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4940_0: read-var coproc:u8
        let s_4940_0: u8 = fn_state.coproc;
        // D s_4940_1: cast zx s_4940_0 -> bv
        let s_4940_1: Bits = Bits::new(s_4940_0 as u128, 4u16);
        // C s_4940_2: const #15u : u8
        let s_4940_2: u8 = 15;
        // C s_4940_3: cast zx s_4940_2 -> bv
        let s_4940_3: Bits = Bits::new(s_4940_2 as u128, 4u16);
        // D s_4940_4: cmp-eq s_4940_1 s_4940_3
        let s_4940_4: bool = ((s_4940_1) == (s_4940_3));
        // D s_4940_5: write-var gs#135109 <= s_4940_4
        fn_state.gs_135109 = s_4940_4;
        // N s_4940_6: jump b1417
        return block_1417(state, tracer, fn_state);
    }
    fn block_4941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4941_0: read-var CRn:u8
        let s_4941_0: u8 = fn_state.CRn;
        // D s_4941_1: cast zx s_4941_0 -> bv
        let s_4941_1: Bits = Bits::new(s_4941_0 as u128, 4u16);
        // C s_4941_2: const #14u : u8
        let s_4941_2: u8 = 14;
        // C s_4941_3: cast zx s_4941_2 -> bv
        let s_4941_3: Bits = Bits::new(s_4941_2 as u128, 4u16);
        // D s_4941_4: cmp-eq s_4941_1 s_4941_3
        let s_4941_4: bool = ((s_4941_1) == (s_4941_3));
        // D s_4941_5: write-var gs#135108 <= s_4941_4
        fn_state.gs_135108 = s_4941_4;
        // N s_4941_6: jump b1415
        return block_1415(state, tracer, fn_state);
    }
    fn block_4942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4942_0: read-var el:u8
        let s_4942_0: u8 = fn_state.el;
        // D s_4942_1: read-var coproc:u8
        let s_4942_1: u8 = fn_state.coproc;
        // D s_4942_2: read-var opc1:u8
        let s_4942_2: u8 = fn_state.opc1;
        // D s_4942_3: read-var CRn:u8
        let s_4942_3: u8 = fn_state.CRn;
        // D s_4942_4: read-var opc2:u8
        let s_4942_4: u8 = fn_state.opc2;
        // D s_4942_5: read-var CRm:u8
        let s_4942_5: u8 = fn_state.CRm;
        // D s_4942_6: read-var t:i
        let s_4942_6: i128 = fn_state.t;
        // D s_4942_7: call PMEVCNTR_SysRegWrite32_8cf807c9cfa50ec9(s_4942_0, s_4942_1, s_4942_2, s_4942_3, s_4942_4, s_4942_5, s_4942_6)
        let s_4942_7: () = PMEVCNTR_SysRegWrite32_8cf807c9cfa50ec9(
            state,
            tracer,
            s_4942_0,
            s_4942_1,
            s_4942_2,
            s_4942_3,
            s_4942_4,
            s_4942_5,
            s_4942_6,
        );
        // N s_4942_8: return
        return;
    }
    fn block_4943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4943_0: read-var opc2:u8
        let s_4943_0: u8 = fn_state.opc2;
        // D s_4943_1: cast zx s_4943_0 -> bv
        let s_4943_1: Bits = Bits::new(s_4943_0 as u128, 3u16);
        // C s_4943_2: const #2u : u8
        let s_4943_2: u8 = 2;
        // C s_4943_3: cast zx s_4943_2 -> bv
        let s_4943_3: Bits = Bits::new(s_4943_2 as u128, 3u16);
        // D s_4943_4: cmp-eq s_4943_1 s_4943_3
        let s_4943_4: bool = ((s_4943_1) == (s_4943_3));
        // D s_4943_5: write-var gs#135107 <= s_4943_4
        fn_state.gs_135107 = s_4943_4;
        // N s_4943_6: jump b1412
        return block_1412(state, tracer, fn_state);
    }
    fn block_4944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4944_0: read-var opc1:u8
        let s_4944_0: u8 = fn_state.opc1;
        // D s_4944_1: cast zx s_4944_0 -> bv
        let s_4944_1: Bits = Bits::new(s_4944_0 as u128, 3u16);
        // C s_4944_2: const #0u : u8
        let s_4944_2: u8 = 0;
        // C s_4944_3: cast zx s_4944_2 -> bv
        let s_4944_3: Bits = Bits::new(s_4944_2 as u128, 3u16);
        // D s_4944_4: cmp-eq s_4944_1 s_4944_3
        let s_4944_4: bool = ((s_4944_1) == (s_4944_3));
        // D s_4944_5: write-var gs#135106 <= s_4944_4
        fn_state.gs_135106 = s_4944_4;
        // N s_4944_6: jump b1410
        return block_1410(state, tracer, fn_state);
    }
    fn block_4945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4945_0: read-var coproc:u8
        let s_4945_0: u8 = fn_state.coproc;
        // D s_4945_1: cast zx s_4945_0 -> bv
        let s_4945_1: Bits = Bits::new(s_4945_0 as u128, 4u16);
        // C s_4945_2: const #15u : u8
        let s_4945_2: u8 = 15;
        // C s_4945_3: cast zx s_4945_2 -> bv
        let s_4945_3: Bits = Bits::new(s_4945_2 as u128, 4u16);
        // D s_4945_4: cmp-eq s_4945_1 s_4945_3
        let s_4945_4: bool = ((s_4945_1) == (s_4945_3));
        // D s_4945_5: write-var gs#135105 <= s_4945_4
        fn_state.gs_135105 = s_4945_4;
        // N s_4945_6: jump b1408
        return block_1408(state, tracer, fn_state);
    }
    fn block_4946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4946_0: read-var CRn:u8
        let s_4946_0: u8 = fn_state.CRn;
        // D s_4946_1: cast zx s_4946_0 -> bv
        let s_4946_1: Bits = Bits::new(s_4946_0 as u128, 4u16);
        // C s_4946_2: const #14u : u8
        let s_4946_2: u8 = 14;
        // C s_4946_3: cast zx s_4946_2 -> bv
        let s_4946_3: Bits = Bits::new(s_4946_2 as u128, 4u16);
        // D s_4946_4: cmp-eq s_4946_1 s_4946_3
        let s_4946_4: bool = ((s_4946_1) == (s_4946_3));
        // D s_4946_5: write-var gs#135104 <= s_4946_4
        fn_state.gs_135104 = s_4946_4;
        // N s_4946_6: jump b1406
        return block_1406(state, tracer, fn_state);
    }
    fn block_4947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4947_0: read-var el:u8
        let s_4947_0: u8 = fn_state.el;
        // D s_4947_1: read-var coproc:u8
        let s_4947_1: u8 = fn_state.coproc;
        // D s_4947_2: read-var opc1:u8
        let s_4947_2: u8 = fn_state.opc1;
        // D s_4947_3: read-var CRn:u8
        let s_4947_3: u8 = fn_state.CRn;
        // D s_4947_4: read-var opc2:u8
        let s_4947_4: u8 = fn_state.opc2;
        // D s_4947_5: read-var CRm:u8
        let s_4947_5: u8 = fn_state.CRm;
        // D s_4947_6: read-var t:i
        let s_4947_6: i128 = fn_state.t;
        // D s_4947_7: call PMEVCNTR_SysRegWrite32_e848e1982619415c(s_4947_0, s_4947_1, s_4947_2, s_4947_3, s_4947_4, s_4947_5, s_4947_6)
        let s_4947_7: () = PMEVCNTR_SysRegWrite32_e848e1982619415c(
            state,
            tracer,
            s_4947_0,
            s_4947_1,
            s_4947_2,
            s_4947_3,
            s_4947_4,
            s_4947_5,
            s_4947_6,
        );
        // N s_4947_8: return
        return;
    }
    fn block_4948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4948_0: read-var opc2:u8
        let s_4948_0: u8 = fn_state.opc2;
        // D s_4948_1: cast zx s_4948_0 -> bv
        let s_4948_1: Bits = Bits::new(s_4948_0 as u128, 3u16);
        // C s_4948_2: const #3u : u8
        let s_4948_2: u8 = 3;
        // C s_4948_3: cast zx s_4948_2 -> bv
        let s_4948_3: Bits = Bits::new(s_4948_2 as u128, 3u16);
        // D s_4948_4: cmp-eq s_4948_1 s_4948_3
        let s_4948_4: bool = ((s_4948_1) == (s_4948_3));
        // D s_4948_5: write-var gs#135103 <= s_4948_4
        fn_state.gs_135103 = s_4948_4;
        // N s_4948_6: jump b1403
        return block_1403(state, tracer, fn_state);
    }
    fn block_4949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4949_0: read-var opc1:u8
        let s_4949_0: u8 = fn_state.opc1;
        // D s_4949_1: cast zx s_4949_0 -> bv
        let s_4949_1: Bits = Bits::new(s_4949_0 as u128, 3u16);
        // C s_4949_2: const #0u : u8
        let s_4949_2: u8 = 0;
        // C s_4949_3: cast zx s_4949_2 -> bv
        let s_4949_3: Bits = Bits::new(s_4949_2 as u128, 3u16);
        // D s_4949_4: cmp-eq s_4949_1 s_4949_3
        let s_4949_4: bool = ((s_4949_1) == (s_4949_3));
        // D s_4949_5: write-var gs#135102 <= s_4949_4
        fn_state.gs_135102 = s_4949_4;
        // N s_4949_6: jump b1401
        return block_1401(state, tracer, fn_state);
    }
    fn block_4950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4950_0: read-var coproc:u8
        let s_4950_0: u8 = fn_state.coproc;
        // D s_4950_1: cast zx s_4950_0 -> bv
        let s_4950_1: Bits = Bits::new(s_4950_0 as u128, 4u16);
        // C s_4950_2: const #15u : u8
        let s_4950_2: u8 = 15;
        // C s_4950_3: cast zx s_4950_2 -> bv
        let s_4950_3: Bits = Bits::new(s_4950_2 as u128, 4u16);
        // D s_4950_4: cmp-eq s_4950_1 s_4950_3
        let s_4950_4: bool = ((s_4950_1) == (s_4950_3));
        // D s_4950_5: write-var gs#135101 <= s_4950_4
        fn_state.gs_135101 = s_4950_4;
        // N s_4950_6: jump b1399
        return block_1399(state, tracer, fn_state);
    }
    fn block_4951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4951_0: read-var CRn:u8
        let s_4951_0: u8 = fn_state.CRn;
        // D s_4951_1: cast zx s_4951_0 -> bv
        let s_4951_1: Bits = Bits::new(s_4951_0 as u128, 4u16);
        // C s_4951_2: const #14u : u8
        let s_4951_2: u8 = 14;
        // C s_4951_3: cast zx s_4951_2 -> bv
        let s_4951_3: Bits = Bits::new(s_4951_2 as u128, 4u16);
        // D s_4951_4: cmp-eq s_4951_1 s_4951_3
        let s_4951_4: bool = ((s_4951_1) == (s_4951_3));
        // D s_4951_5: write-var gs#135100 <= s_4951_4
        fn_state.gs_135100 = s_4951_4;
        // N s_4951_6: jump b1397
        return block_1397(state, tracer, fn_state);
    }
    fn block_4952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4952_0: read-var el:u8
        let s_4952_0: u8 = fn_state.el;
        // D s_4952_1: read-var coproc:u8
        let s_4952_1: u8 = fn_state.coproc;
        // D s_4952_2: read-var opc1:u8
        let s_4952_2: u8 = fn_state.opc1;
        // D s_4952_3: read-var CRn:u8
        let s_4952_3: u8 = fn_state.CRn;
        // D s_4952_4: read-var opc2:u8
        let s_4952_4: u8 = fn_state.opc2;
        // D s_4952_5: read-var CRm:u8
        let s_4952_5: u8 = fn_state.CRm;
        // D s_4952_6: read-var t:i
        let s_4952_6: i128 = fn_state.t;
        // D s_4952_7: call PMEVCNTR_SysRegWrite32_a333b5034a3b86cb(s_4952_0, s_4952_1, s_4952_2, s_4952_3, s_4952_4, s_4952_5, s_4952_6)
        let s_4952_7: () = PMEVCNTR_SysRegWrite32_a333b5034a3b86cb(
            state,
            tracer,
            s_4952_0,
            s_4952_1,
            s_4952_2,
            s_4952_3,
            s_4952_4,
            s_4952_5,
            s_4952_6,
        );
        // N s_4952_8: return
        return;
    }
    fn block_4953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4953_0: read-var opc2:u8
        let s_4953_0: u8 = fn_state.opc2;
        // D s_4953_1: cast zx s_4953_0 -> bv
        let s_4953_1: Bits = Bits::new(s_4953_0 as u128, 3u16);
        // C s_4953_2: const #4u : u8
        let s_4953_2: u8 = 4;
        // C s_4953_3: cast zx s_4953_2 -> bv
        let s_4953_3: Bits = Bits::new(s_4953_2 as u128, 3u16);
        // D s_4953_4: cmp-eq s_4953_1 s_4953_3
        let s_4953_4: bool = ((s_4953_1) == (s_4953_3));
        // D s_4953_5: write-var gs#135099 <= s_4953_4
        fn_state.gs_135099 = s_4953_4;
        // N s_4953_6: jump b1394
        return block_1394(state, tracer, fn_state);
    }
    fn block_4954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4954_0: read-var opc1:u8
        let s_4954_0: u8 = fn_state.opc1;
        // D s_4954_1: cast zx s_4954_0 -> bv
        let s_4954_1: Bits = Bits::new(s_4954_0 as u128, 3u16);
        // C s_4954_2: const #0u : u8
        let s_4954_2: u8 = 0;
        // C s_4954_3: cast zx s_4954_2 -> bv
        let s_4954_3: Bits = Bits::new(s_4954_2 as u128, 3u16);
        // D s_4954_4: cmp-eq s_4954_1 s_4954_3
        let s_4954_4: bool = ((s_4954_1) == (s_4954_3));
        // D s_4954_5: write-var gs#135098 <= s_4954_4
        fn_state.gs_135098 = s_4954_4;
        // N s_4954_6: jump b1392
        return block_1392(state, tracer, fn_state);
    }
    fn block_4955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4955_0: read-var coproc:u8
        let s_4955_0: u8 = fn_state.coproc;
        // D s_4955_1: cast zx s_4955_0 -> bv
        let s_4955_1: Bits = Bits::new(s_4955_0 as u128, 4u16);
        // C s_4955_2: const #15u : u8
        let s_4955_2: u8 = 15;
        // C s_4955_3: cast zx s_4955_2 -> bv
        let s_4955_3: Bits = Bits::new(s_4955_2 as u128, 4u16);
        // D s_4955_4: cmp-eq s_4955_1 s_4955_3
        let s_4955_4: bool = ((s_4955_1) == (s_4955_3));
        // D s_4955_5: write-var gs#135097 <= s_4955_4
        fn_state.gs_135097 = s_4955_4;
        // N s_4955_6: jump b1390
        return block_1390(state, tracer, fn_state);
    }
    fn block_4956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4956_0: read-var CRn:u8
        let s_4956_0: u8 = fn_state.CRn;
        // D s_4956_1: cast zx s_4956_0 -> bv
        let s_4956_1: Bits = Bits::new(s_4956_0 as u128, 4u16);
        // C s_4956_2: const #14u : u8
        let s_4956_2: u8 = 14;
        // C s_4956_3: cast zx s_4956_2 -> bv
        let s_4956_3: Bits = Bits::new(s_4956_2 as u128, 4u16);
        // D s_4956_4: cmp-eq s_4956_1 s_4956_3
        let s_4956_4: bool = ((s_4956_1) == (s_4956_3));
        // D s_4956_5: write-var gs#135096 <= s_4956_4
        fn_state.gs_135096 = s_4956_4;
        // N s_4956_6: jump b1388
        return block_1388(state, tracer, fn_state);
    }
    fn block_4957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4957_0: read-var el:u8
        let s_4957_0: u8 = fn_state.el;
        // D s_4957_1: read-var coproc:u8
        let s_4957_1: u8 = fn_state.coproc;
        // D s_4957_2: read-var opc1:u8
        let s_4957_2: u8 = fn_state.opc1;
        // D s_4957_3: read-var CRn:u8
        let s_4957_3: u8 = fn_state.CRn;
        // D s_4957_4: read-var opc2:u8
        let s_4957_4: u8 = fn_state.opc2;
        // D s_4957_5: read-var CRm:u8
        let s_4957_5: u8 = fn_state.CRm;
        // D s_4957_6: read-var t:i
        let s_4957_6: i128 = fn_state.t;
        // D s_4957_7: call PMEVCNTR_SysRegWrite32_65d523b551bc8ca5(s_4957_0, s_4957_1, s_4957_2, s_4957_3, s_4957_4, s_4957_5, s_4957_6)
        let s_4957_7: () = PMEVCNTR_SysRegWrite32_65d523b551bc8ca5(
            state,
            tracer,
            s_4957_0,
            s_4957_1,
            s_4957_2,
            s_4957_3,
            s_4957_4,
            s_4957_5,
            s_4957_6,
        );
        // N s_4957_8: return
        return;
    }
    fn block_4958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4958_0: read-var opc2:u8
        let s_4958_0: u8 = fn_state.opc2;
        // D s_4958_1: cast zx s_4958_0 -> bv
        let s_4958_1: Bits = Bits::new(s_4958_0 as u128, 3u16);
        // C s_4958_2: const #5u : u8
        let s_4958_2: u8 = 5;
        // C s_4958_3: cast zx s_4958_2 -> bv
        let s_4958_3: Bits = Bits::new(s_4958_2 as u128, 3u16);
        // D s_4958_4: cmp-eq s_4958_1 s_4958_3
        let s_4958_4: bool = ((s_4958_1) == (s_4958_3));
        // D s_4958_5: write-var gs#135095 <= s_4958_4
        fn_state.gs_135095 = s_4958_4;
        // N s_4958_6: jump b1385
        return block_1385(state, tracer, fn_state);
    }
    fn block_4959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4959_0: read-var opc1:u8
        let s_4959_0: u8 = fn_state.opc1;
        // D s_4959_1: cast zx s_4959_0 -> bv
        let s_4959_1: Bits = Bits::new(s_4959_0 as u128, 3u16);
        // C s_4959_2: const #0u : u8
        let s_4959_2: u8 = 0;
        // C s_4959_3: cast zx s_4959_2 -> bv
        let s_4959_3: Bits = Bits::new(s_4959_2 as u128, 3u16);
        // D s_4959_4: cmp-eq s_4959_1 s_4959_3
        let s_4959_4: bool = ((s_4959_1) == (s_4959_3));
        // D s_4959_5: write-var gs#135094 <= s_4959_4
        fn_state.gs_135094 = s_4959_4;
        // N s_4959_6: jump b1383
        return block_1383(state, tracer, fn_state);
    }
    fn block_4960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4960_0: read-var coproc:u8
        let s_4960_0: u8 = fn_state.coproc;
        // D s_4960_1: cast zx s_4960_0 -> bv
        let s_4960_1: Bits = Bits::new(s_4960_0 as u128, 4u16);
        // C s_4960_2: const #15u : u8
        let s_4960_2: u8 = 15;
        // C s_4960_3: cast zx s_4960_2 -> bv
        let s_4960_3: Bits = Bits::new(s_4960_2 as u128, 4u16);
        // D s_4960_4: cmp-eq s_4960_1 s_4960_3
        let s_4960_4: bool = ((s_4960_1) == (s_4960_3));
        // D s_4960_5: write-var gs#135093 <= s_4960_4
        fn_state.gs_135093 = s_4960_4;
        // N s_4960_6: jump b1381
        return block_1381(state, tracer, fn_state);
    }
    fn block_4961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4961_0: read-var CRn:u8
        let s_4961_0: u8 = fn_state.CRn;
        // D s_4961_1: cast zx s_4961_0 -> bv
        let s_4961_1: Bits = Bits::new(s_4961_0 as u128, 4u16);
        // C s_4961_2: const #14u : u8
        let s_4961_2: u8 = 14;
        // C s_4961_3: cast zx s_4961_2 -> bv
        let s_4961_3: Bits = Bits::new(s_4961_2 as u128, 4u16);
        // D s_4961_4: cmp-eq s_4961_1 s_4961_3
        let s_4961_4: bool = ((s_4961_1) == (s_4961_3));
        // D s_4961_5: write-var gs#135092 <= s_4961_4
        fn_state.gs_135092 = s_4961_4;
        // N s_4961_6: jump b1379
        return block_1379(state, tracer, fn_state);
    }
    fn block_4962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4962_0: read-var el:u8
        let s_4962_0: u8 = fn_state.el;
        // D s_4962_1: read-var coproc:u8
        let s_4962_1: u8 = fn_state.coproc;
        // D s_4962_2: read-var opc1:u8
        let s_4962_2: u8 = fn_state.opc1;
        // D s_4962_3: read-var CRn:u8
        let s_4962_3: u8 = fn_state.CRn;
        // D s_4962_4: read-var opc2:u8
        let s_4962_4: u8 = fn_state.opc2;
        // D s_4962_5: read-var CRm:u8
        let s_4962_5: u8 = fn_state.CRm;
        // D s_4962_6: read-var t:i
        let s_4962_6: i128 = fn_state.t;
        // D s_4962_7: call PMEVCNTR_SysRegWrite32_7b729c1912b85359(s_4962_0, s_4962_1, s_4962_2, s_4962_3, s_4962_4, s_4962_5, s_4962_6)
        let s_4962_7: () = PMEVCNTR_SysRegWrite32_7b729c1912b85359(
            state,
            tracer,
            s_4962_0,
            s_4962_1,
            s_4962_2,
            s_4962_3,
            s_4962_4,
            s_4962_5,
            s_4962_6,
        );
        // N s_4962_8: return
        return;
    }
    fn block_4963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4963_0: read-var opc2:u8
        let s_4963_0: u8 = fn_state.opc2;
        // D s_4963_1: cast zx s_4963_0 -> bv
        let s_4963_1: Bits = Bits::new(s_4963_0 as u128, 3u16);
        // C s_4963_2: const #6u : u8
        let s_4963_2: u8 = 6;
        // C s_4963_3: cast zx s_4963_2 -> bv
        let s_4963_3: Bits = Bits::new(s_4963_2 as u128, 3u16);
        // D s_4963_4: cmp-eq s_4963_1 s_4963_3
        let s_4963_4: bool = ((s_4963_1) == (s_4963_3));
        // D s_4963_5: write-var gs#135091 <= s_4963_4
        fn_state.gs_135091 = s_4963_4;
        // N s_4963_6: jump b1376
        return block_1376(state, tracer, fn_state);
    }
    fn block_4964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4964_0: read-var opc1:u8
        let s_4964_0: u8 = fn_state.opc1;
        // D s_4964_1: cast zx s_4964_0 -> bv
        let s_4964_1: Bits = Bits::new(s_4964_0 as u128, 3u16);
        // C s_4964_2: const #0u : u8
        let s_4964_2: u8 = 0;
        // C s_4964_3: cast zx s_4964_2 -> bv
        let s_4964_3: Bits = Bits::new(s_4964_2 as u128, 3u16);
        // D s_4964_4: cmp-eq s_4964_1 s_4964_3
        let s_4964_4: bool = ((s_4964_1) == (s_4964_3));
        // D s_4964_5: write-var gs#135090 <= s_4964_4
        fn_state.gs_135090 = s_4964_4;
        // N s_4964_6: jump b1374
        return block_1374(state, tracer, fn_state);
    }
    fn block_4965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4965_0: read-var coproc:u8
        let s_4965_0: u8 = fn_state.coproc;
        // D s_4965_1: cast zx s_4965_0 -> bv
        let s_4965_1: Bits = Bits::new(s_4965_0 as u128, 4u16);
        // C s_4965_2: const #15u : u8
        let s_4965_2: u8 = 15;
        // C s_4965_3: cast zx s_4965_2 -> bv
        let s_4965_3: Bits = Bits::new(s_4965_2 as u128, 4u16);
        // D s_4965_4: cmp-eq s_4965_1 s_4965_3
        let s_4965_4: bool = ((s_4965_1) == (s_4965_3));
        // D s_4965_5: write-var gs#135089 <= s_4965_4
        fn_state.gs_135089 = s_4965_4;
        // N s_4965_6: jump b1372
        return block_1372(state, tracer, fn_state);
    }
    fn block_4966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4966_0: read-var CRn:u8
        let s_4966_0: u8 = fn_state.CRn;
        // D s_4966_1: cast zx s_4966_0 -> bv
        let s_4966_1: Bits = Bits::new(s_4966_0 as u128, 4u16);
        // C s_4966_2: const #14u : u8
        let s_4966_2: u8 = 14;
        // C s_4966_3: cast zx s_4966_2 -> bv
        let s_4966_3: Bits = Bits::new(s_4966_2 as u128, 4u16);
        // D s_4966_4: cmp-eq s_4966_1 s_4966_3
        let s_4966_4: bool = ((s_4966_1) == (s_4966_3));
        // D s_4966_5: write-var gs#135088 <= s_4966_4
        fn_state.gs_135088 = s_4966_4;
        // N s_4966_6: jump b1370
        return block_1370(state, tracer, fn_state);
    }
    fn block_4967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4967_0: read-var el:u8
        let s_4967_0: u8 = fn_state.el;
        // D s_4967_1: read-var coproc:u8
        let s_4967_1: u8 = fn_state.coproc;
        // D s_4967_2: read-var opc1:u8
        let s_4967_2: u8 = fn_state.opc1;
        // D s_4967_3: read-var CRn:u8
        let s_4967_3: u8 = fn_state.CRn;
        // D s_4967_4: read-var opc2:u8
        let s_4967_4: u8 = fn_state.opc2;
        // D s_4967_5: read-var CRm:u8
        let s_4967_5: u8 = fn_state.CRm;
        // D s_4967_6: read-var t:i
        let s_4967_6: i128 = fn_state.t;
        // D s_4967_7: call DCISW_SysRegWrite32_e734ad2cce77231d(s_4967_0, s_4967_1, s_4967_2, s_4967_3, s_4967_4, s_4967_5, s_4967_6)
        let s_4967_7: () = DCISW_SysRegWrite32_e734ad2cce77231d(
            state,
            tracer,
            s_4967_0,
            s_4967_1,
            s_4967_2,
            s_4967_3,
            s_4967_4,
            s_4967_5,
            s_4967_6,
        );
        // N s_4967_8: return
        return;
    }
    fn block_4968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4968_0: read-var opc2:u8
        let s_4968_0: u8 = fn_state.opc2;
        // D s_4968_1: cast zx s_4968_0 -> bv
        let s_4968_1: Bits = Bits::new(s_4968_0 as u128, 3u16);
        // C s_4968_2: const #2u : u8
        let s_4968_2: u8 = 2;
        // C s_4968_3: cast zx s_4968_2 -> bv
        let s_4968_3: Bits = Bits::new(s_4968_2 as u128, 3u16);
        // D s_4968_4: cmp-eq s_4968_1 s_4968_3
        let s_4968_4: bool = ((s_4968_1) == (s_4968_3));
        // D s_4968_5: write-var gs#135087 <= s_4968_4
        fn_state.gs_135087 = s_4968_4;
        // N s_4968_6: jump b1367
        return block_1367(state, tracer, fn_state);
    }
    fn block_4969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4969_0: read-var opc1:u8
        let s_4969_0: u8 = fn_state.opc1;
        // D s_4969_1: cast zx s_4969_0 -> bv
        let s_4969_1: Bits = Bits::new(s_4969_0 as u128, 3u16);
        // C s_4969_2: const #0u : u8
        let s_4969_2: u8 = 0;
        // C s_4969_3: cast zx s_4969_2 -> bv
        let s_4969_3: Bits = Bits::new(s_4969_2 as u128, 3u16);
        // D s_4969_4: cmp-eq s_4969_1 s_4969_3
        let s_4969_4: bool = ((s_4969_1) == (s_4969_3));
        // D s_4969_5: write-var gs#135086 <= s_4969_4
        fn_state.gs_135086 = s_4969_4;
        // N s_4969_6: jump b1365
        return block_1365(state, tracer, fn_state);
    }
    fn block_4970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4970_0: read-var coproc:u8
        let s_4970_0: u8 = fn_state.coproc;
        // D s_4970_1: cast zx s_4970_0 -> bv
        let s_4970_1: Bits = Bits::new(s_4970_0 as u128, 4u16);
        // C s_4970_2: const #15u : u8
        let s_4970_2: u8 = 15;
        // C s_4970_3: cast zx s_4970_2 -> bv
        let s_4970_3: Bits = Bits::new(s_4970_2 as u128, 4u16);
        // D s_4970_4: cmp-eq s_4970_1 s_4970_3
        let s_4970_4: bool = ((s_4970_1) == (s_4970_3));
        // D s_4970_5: write-var gs#135085 <= s_4970_4
        fn_state.gs_135085 = s_4970_4;
        // N s_4970_6: jump b1363
        return block_1363(state, tracer, fn_state);
    }
    fn block_4971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4971_0: read-var CRn:u8
        let s_4971_0: u8 = fn_state.CRn;
        // D s_4971_1: cast zx s_4971_0 -> bv
        let s_4971_1: Bits = Bits::new(s_4971_0 as u128, 4u16);
        // C s_4971_2: const #7u : u8
        let s_4971_2: u8 = 7;
        // C s_4971_3: cast zx s_4971_2 -> bv
        let s_4971_3: Bits = Bits::new(s_4971_2 as u128, 4u16);
        // D s_4971_4: cmp-eq s_4971_1 s_4971_3
        let s_4971_4: bool = ((s_4971_1) == (s_4971_3));
        // D s_4971_5: write-var gs#135084 <= s_4971_4
        fn_state.gs_135084 = s_4971_4;
        // N s_4971_6: jump b1361
        return block_1361(state, tracer, fn_state);
    }
    fn block_4972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4972_0: read-var el:u8
        let s_4972_0: u8 = fn_state.el;
        // D s_4972_1: read-var coproc:u8
        let s_4972_1: u8 = fn_state.coproc;
        // D s_4972_2: read-var opc1:u8
        let s_4972_2: u8 = fn_state.opc1;
        // D s_4972_3: read-var CRn:u8
        let s_4972_3: u8 = fn_state.CRn;
        // D s_4972_4: read-var opc2:u8
        let s_4972_4: u8 = fn_state.opc2;
        // D s_4972_5: read-var CRm:u8
        let s_4972_5: u8 = fn_state.CRm;
        // D s_4972_6: read-var t:i
        let s_4972_6: i128 = fn_state.t;
        // D s_4972_7: call TPIDRURO_SysRegWrite32_2b144f3027758b96(s_4972_0, s_4972_1, s_4972_2, s_4972_3, s_4972_4, s_4972_5, s_4972_6)
        let s_4972_7: () = TPIDRURO_SysRegWrite32_2b144f3027758b96(
            state,
            tracer,
            s_4972_0,
            s_4972_1,
            s_4972_2,
            s_4972_3,
            s_4972_4,
            s_4972_5,
            s_4972_6,
        );
        // N s_4972_8: return
        return;
    }
    fn block_4973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4973_0: read-var opc2:u8
        let s_4973_0: u8 = fn_state.opc2;
        // D s_4973_1: cast zx s_4973_0 -> bv
        let s_4973_1: Bits = Bits::new(s_4973_0 as u128, 3u16);
        // C s_4973_2: const #3u : u8
        let s_4973_2: u8 = 3;
        // C s_4973_3: cast zx s_4973_2 -> bv
        let s_4973_3: Bits = Bits::new(s_4973_2 as u128, 3u16);
        // D s_4973_4: cmp-eq s_4973_1 s_4973_3
        let s_4973_4: bool = ((s_4973_1) == (s_4973_3));
        // D s_4973_5: write-var gs#135083 <= s_4973_4
        fn_state.gs_135083 = s_4973_4;
        // N s_4973_6: jump b1358
        return block_1358(state, tracer, fn_state);
    }
    fn block_4974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4974_0: read-var opc1:u8
        let s_4974_0: u8 = fn_state.opc1;
        // D s_4974_1: cast zx s_4974_0 -> bv
        let s_4974_1: Bits = Bits::new(s_4974_0 as u128, 3u16);
        // C s_4974_2: const #0u : u8
        let s_4974_2: u8 = 0;
        // C s_4974_3: cast zx s_4974_2 -> bv
        let s_4974_3: Bits = Bits::new(s_4974_2 as u128, 3u16);
        // D s_4974_4: cmp-eq s_4974_1 s_4974_3
        let s_4974_4: bool = ((s_4974_1) == (s_4974_3));
        // D s_4974_5: write-var gs#135082 <= s_4974_4
        fn_state.gs_135082 = s_4974_4;
        // N s_4974_6: jump b1356
        return block_1356(state, tracer, fn_state);
    }
    fn block_4975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4975_0: read-var coproc:u8
        let s_4975_0: u8 = fn_state.coproc;
        // D s_4975_1: cast zx s_4975_0 -> bv
        let s_4975_1: Bits = Bits::new(s_4975_0 as u128, 4u16);
        // C s_4975_2: const #15u : u8
        let s_4975_2: u8 = 15;
        // C s_4975_3: cast zx s_4975_2 -> bv
        let s_4975_3: Bits = Bits::new(s_4975_2 as u128, 4u16);
        // D s_4975_4: cmp-eq s_4975_1 s_4975_3
        let s_4975_4: bool = ((s_4975_1) == (s_4975_3));
        // D s_4975_5: write-var gs#135081 <= s_4975_4
        fn_state.gs_135081 = s_4975_4;
        // N s_4975_6: jump b1354
        return block_1354(state, tracer, fn_state);
    }
    fn block_4976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4976_0: read-var CRn:u8
        let s_4976_0: u8 = fn_state.CRn;
        // D s_4976_1: cast zx s_4976_0 -> bv
        let s_4976_1: Bits = Bits::new(s_4976_0 as u128, 4u16);
        // C s_4976_2: const #13u : u8
        let s_4976_2: u8 = 13;
        // C s_4976_3: cast zx s_4976_2 -> bv
        let s_4976_3: Bits = Bits::new(s_4976_2 as u128, 4u16);
        // D s_4976_4: cmp-eq s_4976_1 s_4976_3
        let s_4976_4: bool = ((s_4976_1) == (s_4976_3));
        // D s_4976_5: write-var gs#135080 <= s_4976_4
        fn_state.gs_135080 = s_4976_4;
        // N s_4976_6: jump b1352
        return block_1352(state, tracer, fn_state);
    }
    fn block_4977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4977_0: read-var el:u8
        let s_4977_0: u8 = fn_state.el;
        // D s_4977_1: read-var coproc:u8
        let s_4977_1: u8 = fn_state.coproc;
        // D s_4977_2: read-var opc1:u8
        let s_4977_2: u8 = fn_state.opc1;
        // D s_4977_3: read-var CRn:u8
        let s_4977_3: u8 = fn_state.CRn;
        // D s_4977_4: read-var opc2:u8
        let s_4977_4: u8 = fn_state.opc2;
        // D s_4977_5: read-var CRm:u8
        let s_4977_5: u8 = fn_state.CRm;
        // D s_4977_6: read-var t:i
        let s_4977_6: i128 = fn_state.t;
        // D s_4977_7: call NMRR_SysRegWrite32_d7c63fb9ed572aa1(s_4977_0, s_4977_1, s_4977_2, s_4977_3, s_4977_4, s_4977_5, s_4977_6)
        let s_4977_7: () = NMRR_SysRegWrite32_d7c63fb9ed572aa1(
            state,
            tracer,
            s_4977_0,
            s_4977_1,
            s_4977_2,
            s_4977_3,
            s_4977_4,
            s_4977_5,
            s_4977_6,
        );
        // N s_4977_8: return
        return;
    }
    fn block_4978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4978_0: read-var opc2:u8
        let s_4978_0: u8 = fn_state.opc2;
        // D s_4978_1: cast zx s_4978_0 -> bv
        let s_4978_1: Bits = Bits::new(s_4978_0 as u128, 3u16);
        // C s_4978_2: const #1u : u8
        let s_4978_2: u8 = 1;
        // C s_4978_3: cast zx s_4978_2 -> bv
        let s_4978_3: Bits = Bits::new(s_4978_2 as u128, 3u16);
        // D s_4978_4: cmp-eq s_4978_1 s_4978_3
        let s_4978_4: bool = ((s_4978_1) == (s_4978_3));
        // D s_4978_5: write-var gs#135079 <= s_4978_4
        fn_state.gs_135079 = s_4978_4;
        // N s_4978_6: jump b1349
        return block_1349(state, tracer, fn_state);
    }
    fn block_4979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4979_0: read-var opc1:u8
        let s_4979_0: u8 = fn_state.opc1;
        // D s_4979_1: cast zx s_4979_0 -> bv
        let s_4979_1: Bits = Bits::new(s_4979_0 as u128, 3u16);
        // C s_4979_2: const #0u : u8
        let s_4979_2: u8 = 0;
        // C s_4979_3: cast zx s_4979_2 -> bv
        let s_4979_3: Bits = Bits::new(s_4979_2 as u128, 3u16);
        // D s_4979_4: cmp-eq s_4979_1 s_4979_3
        let s_4979_4: bool = ((s_4979_1) == (s_4979_3));
        // D s_4979_5: write-var gs#135078 <= s_4979_4
        fn_state.gs_135078 = s_4979_4;
        // N s_4979_6: jump b1347
        return block_1347(state, tracer, fn_state);
    }
    fn block_4980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4980_0: read-var coproc:u8
        let s_4980_0: u8 = fn_state.coproc;
        // D s_4980_1: cast zx s_4980_0 -> bv
        let s_4980_1: Bits = Bits::new(s_4980_0 as u128, 4u16);
        // C s_4980_2: const #15u : u8
        let s_4980_2: u8 = 15;
        // C s_4980_3: cast zx s_4980_2 -> bv
        let s_4980_3: Bits = Bits::new(s_4980_2 as u128, 4u16);
        // D s_4980_4: cmp-eq s_4980_1 s_4980_3
        let s_4980_4: bool = ((s_4980_1) == (s_4980_3));
        // D s_4980_5: write-var gs#135077 <= s_4980_4
        fn_state.gs_135077 = s_4980_4;
        // N s_4980_6: jump b1345
        return block_1345(state, tracer, fn_state);
    }
    fn block_4981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4981_0: read-var CRn:u8
        let s_4981_0: u8 = fn_state.CRn;
        // D s_4981_1: cast zx s_4981_0 -> bv
        let s_4981_1: Bits = Bits::new(s_4981_0 as u128, 4u16);
        // C s_4981_2: const #10u : u8
        let s_4981_2: u8 = 10;
        // C s_4981_3: cast zx s_4981_2 -> bv
        let s_4981_3: Bits = Bits::new(s_4981_2 as u128, 4u16);
        // D s_4981_4: cmp-eq s_4981_1 s_4981_3
        let s_4981_4: bool = ((s_4981_1) == (s_4981_3));
        // D s_4981_5: write-var gs#135076 <= s_4981_4
        fn_state.gs_135076 = s_4981_4;
        // N s_4981_6: jump b1343
        return block_1343(state, tracer, fn_state);
    }
    fn block_4982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4982_0: read-var el:u8
        let s_4982_0: u8 = fn_state.el;
        // D s_4982_1: read-var coproc:u8
        let s_4982_1: u8 = fn_state.coproc;
        // D s_4982_2: read-var opc1:u8
        let s_4982_2: u8 = fn_state.opc1;
        // D s_4982_3: read-var CRn:u8
        let s_4982_3: u8 = fn_state.CRn;
        // D s_4982_4: read-var opc2:u8
        let s_4982_4: u8 = fn_state.opc2;
        // D s_4982_5: read-var CRm:u8
        let s_4982_5: u8 = fn_state.CRm;
        // D s_4982_6: read-var t:i
        let s_4982_6: i128 = fn_state.t;
        // D s_4982_7: call DBGCLAIMSET_SysRegWrite32_edbb66d3027b713a(s_4982_0, s_4982_1, s_4982_2, s_4982_3, s_4982_4, s_4982_5, s_4982_6)
        let s_4982_7: () = DBGCLAIMSET_SysRegWrite32_edbb66d3027b713a(
            state,
            tracer,
            s_4982_0,
            s_4982_1,
            s_4982_2,
            s_4982_3,
            s_4982_4,
            s_4982_5,
            s_4982_6,
        );
        // N s_4982_8: return
        return;
    }
    fn block_4983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4983_0: read-var opc2:u8
        let s_4983_0: u8 = fn_state.opc2;
        // D s_4983_1: cast zx s_4983_0 -> bv
        let s_4983_1: Bits = Bits::new(s_4983_0 as u128, 3u16);
        // C s_4983_2: const #6u : u8
        let s_4983_2: u8 = 6;
        // C s_4983_3: cast zx s_4983_2 -> bv
        let s_4983_3: Bits = Bits::new(s_4983_2 as u128, 3u16);
        // D s_4983_4: cmp-eq s_4983_1 s_4983_3
        let s_4983_4: bool = ((s_4983_1) == (s_4983_3));
        // D s_4983_5: write-var gs#135075 <= s_4983_4
        fn_state.gs_135075 = s_4983_4;
        // N s_4983_6: jump b1340
        return block_1340(state, tracer, fn_state);
    }
    fn block_4984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4984_0: read-var opc1:u8
        let s_4984_0: u8 = fn_state.opc1;
        // D s_4984_1: cast zx s_4984_0 -> bv
        let s_4984_1: Bits = Bits::new(s_4984_0 as u128, 3u16);
        // C s_4984_2: const #0u : u8
        let s_4984_2: u8 = 0;
        // C s_4984_3: cast zx s_4984_2 -> bv
        let s_4984_3: Bits = Bits::new(s_4984_2 as u128, 3u16);
        // D s_4984_4: cmp-eq s_4984_1 s_4984_3
        let s_4984_4: bool = ((s_4984_1) == (s_4984_3));
        // D s_4984_5: write-var gs#135074 <= s_4984_4
        fn_state.gs_135074 = s_4984_4;
        // N s_4984_6: jump b1338
        return block_1338(state, tracer, fn_state);
    }
    fn block_4985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4985_0: read-var coproc:u8
        let s_4985_0: u8 = fn_state.coproc;
        // D s_4985_1: cast zx s_4985_0 -> bv
        let s_4985_1: Bits = Bits::new(s_4985_0 as u128, 4u16);
        // C s_4985_2: const #14u : u8
        let s_4985_2: u8 = 14;
        // C s_4985_3: cast zx s_4985_2 -> bv
        let s_4985_3: Bits = Bits::new(s_4985_2 as u128, 4u16);
        // D s_4985_4: cmp-eq s_4985_1 s_4985_3
        let s_4985_4: bool = ((s_4985_1) == (s_4985_3));
        // D s_4985_5: write-var gs#135073 <= s_4985_4
        fn_state.gs_135073 = s_4985_4;
        // N s_4985_6: jump b1336
        return block_1336(state, tracer, fn_state);
    }
    fn block_4986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4986_0: read-var CRn:u8
        let s_4986_0: u8 = fn_state.CRn;
        // D s_4986_1: cast zx s_4986_0 -> bv
        let s_4986_1: Bits = Bits::new(s_4986_0 as u128, 4u16);
        // C s_4986_2: const #7u : u8
        let s_4986_2: u8 = 7;
        // C s_4986_3: cast zx s_4986_2 -> bv
        let s_4986_3: Bits = Bits::new(s_4986_2 as u128, 4u16);
        // D s_4986_4: cmp-eq s_4986_1 s_4986_3
        let s_4986_4: bool = ((s_4986_1) == (s_4986_3));
        // D s_4986_5: write-var gs#135072 <= s_4986_4
        fn_state.gs_135072 = s_4986_4;
        // N s_4986_6: jump b1334
        return block_1334(state, tracer, fn_state);
    }
    fn block_4987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4987_0: read-var el:u8
        let s_4987_0: u8 = fn_state.el;
        // D s_4987_1: read-var coproc:u8
        let s_4987_1: u8 = fn_state.coproc;
        // D s_4987_2: read-var opc1:u8
        let s_4987_2: u8 = fn_state.opc1;
        // D s_4987_3: read-var CRn:u8
        let s_4987_3: u8 = fn_state.CRn;
        // D s_4987_4: read-var opc2:u8
        let s_4987_4: u8 = fn_state.opc2;
        // D s_4987_5: read-var CRm:u8
        let s_4987_5: u8 = fn_state.CRm;
        // D s_4987_6: read-var t:i
        let s_4987_6: i128 = fn_state.t;
        // D s_4987_7: call ICIMVAU_SysRegWrite32_98e4788d39c19ba0(s_4987_0, s_4987_1, s_4987_2, s_4987_3, s_4987_4, s_4987_5, s_4987_6)
        let s_4987_7: () = ICIMVAU_SysRegWrite32_98e4788d39c19ba0(
            state,
            tracer,
            s_4987_0,
            s_4987_1,
            s_4987_2,
            s_4987_3,
            s_4987_4,
            s_4987_5,
            s_4987_6,
        );
        // N s_4987_8: return
        return;
    }
    fn block_4988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4988_0: read-var opc2:u8
        let s_4988_0: u8 = fn_state.opc2;
        // D s_4988_1: cast zx s_4988_0 -> bv
        let s_4988_1: Bits = Bits::new(s_4988_0 as u128, 3u16);
        // C s_4988_2: const #1u : u8
        let s_4988_2: u8 = 1;
        // C s_4988_3: cast zx s_4988_2 -> bv
        let s_4988_3: Bits = Bits::new(s_4988_2 as u128, 3u16);
        // D s_4988_4: cmp-eq s_4988_1 s_4988_3
        let s_4988_4: bool = ((s_4988_1) == (s_4988_3));
        // D s_4988_5: write-var gs#135071 <= s_4988_4
        fn_state.gs_135071 = s_4988_4;
        // N s_4988_6: jump b1331
        return block_1331(state, tracer, fn_state);
    }
    fn block_4989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4989_0: read-var opc1:u8
        let s_4989_0: u8 = fn_state.opc1;
        // D s_4989_1: cast zx s_4989_0 -> bv
        let s_4989_1: Bits = Bits::new(s_4989_0 as u128, 3u16);
        // C s_4989_2: const #0u : u8
        let s_4989_2: u8 = 0;
        // C s_4989_3: cast zx s_4989_2 -> bv
        let s_4989_3: Bits = Bits::new(s_4989_2 as u128, 3u16);
        // D s_4989_4: cmp-eq s_4989_1 s_4989_3
        let s_4989_4: bool = ((s_4989_1) == (s_4989_3));
        // D s_4989_5: write-var gs#135070 <= s_4989_4
        fn_state.gs_135070 = s_4989_4;
        // N s_4989_6: jump b1329
        return block_1329(state, tracer, fn_state);
    }
    fn block_4990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4990_0: read-var coproc:u8
        let s_4990_0: u8 = fn_state.coproc;
        // D s_4990_1: cast zx s_4990_0 -> bv
        let s_4990_1: Bits = Bits::new(s_4990_0 as u128, 4u16);
        // C s_4990_2: const #15u : u8
        let s_4990_2: u8 = 15;
        // C s_4990_3: cast zx s_4990_2 -> bv
        let s_4990_3: Bits = Bits::new(s_4990_2 as u128, 4u16);
        // D s_4990_4: cmp-eq s_4990_1 s_4990_3
        let s_4990_4: bool = ((s_4990_1) == (s_4990_3));
        // D s_4990_5: write-var gs#135069 <= s_4990_4
        fn_state.gs_135069 = s_4990_4;
        // N s_4990_6: jump b1327
        return block_1327(state, tracer, fn_state);
    }
    fn block_4991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4991_0: read-var CRn:u8
        let s_4991_0: u8 = fn_state.CRn;
        // D s_4991_1: cast zx s_4991_0 -> bv
        let s_4991_1: Bits = Bits::new(s_4991_0 as u128, 4u16);
        // C s_4991_2: const #7u : u8
        let s_4991_2: u8 = 7;
        // C s_4991_3: cast zx s_4991_2 -> bv
        let s_4991_3: Bits = Bits::new(s_4991_2 as u128, 4u16);
        // D s_4991_4: cmp-eq s_4991_1 s_4991_3
        let s_4991_4: bool = ((s_4991_1) == (s_4991_3));
        // D s_4991_5: write-var gs#135068 <= s_4991_4
        fn_state.gs_135068 = s_4991_4;
        // N s_4991_6: jump b1325
        return block_1325(state, tracer, fn_state);
    }
    fn block_4992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4992_0: read-var el:u8
        let s_4992_0: u8 = fn_state.el;
        // D s_4992_1: read-var coproc:u8
        let s_4992_1: u8 = fn_state.coproc;
        // D s_4992_2: read-var opc1:u8
        let s_4992_2: u8 = fn_state.opc1;
        // D s_4992_3: read-var CRn:u8
        let s_4992_3: u8 = fn_state.CRn;
        // D s_4992_4: read-var opc2:u8
        let s_4992_4: u8 = fn_state.opc2;
        // D s_4992_5: read-var CRm:u8
        let s_4992_5: u8 = fn_state.CRm;
        // D s_4992_6: read-var t:i
        let s_4992_6: i128 = fn_state.t;
        // D s_4992_7: call PMSELR_SysRegWrite32_3f6f0842c8047d3f(s_4992_0, s_4992_1, s_4992_2, s_4992_3, s_4992_4, s_4992_5, s_4992_6)
        let s_4992_7: () = PMSELR_SysRegWrite32_3f6f0842c8047d3f(
            state,
            tracer,
            s_4992_0,
            s_4992_1,
            s_4992_2,
            s_4992_3,
            s_4992_4,
            s_4992_5,
            s_4992_6,
        );
        // N s_4992_8: return
        return;
    }
    fn block_4993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4993_0: read-var opc2:u8
        let s_4993_0: u8 = fn_state.opc2;
        // D s_4993_1: cast zx s_4993_0 -> bv
        let s_4993_1: Bits = Bits::new(s_4993_0 as u128, 3u16);
        // C s_4993_2: const #5u : u8
        let s_4993_2: u8 = 5;
        // C s_4993_3: cast zx s_4993_2 -> bv
        let s_4993_3: Bits = Bits::new(s_4993_2 as u128, 3u16);
        // D s_4993_4: cmp-eq s_4993_1 s_4993_3
        let s_4993_4: bool = ((s_4993_1) == (s_4993_3));
        // D s_4993_5: write-var gs#135067 <= s_4993_4
        fn_state.gs_135067 = s_4993_4;
        // N s_4993_6: jump b1322
        return block_1322(state, tracer, fn_state);
    }
    fn block_4994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4994_0: read-var opc1:u8
        let s_4994_0: u8 = fn_state.opc1;
        // D s_4994_1: cast zx s_4994_0 -> bv
        let s_4994_1: Bits = Bits::new(s_4994_0 as u128, 3u16);
        // C s_4994_2: const #0u : u8
        let s_4994_2: u8 = 0;
        // C s_4994_3: cast zx s_4994_2 -> bv
        let s_4994_3: Bits = Bits::new(s_4994_2 as u128, 3u16);
        // D s_4994_4: cmp-eq s_4994_1 s_4994_3
        let s_4994_4: bool = ((s_4994_1) == (s_4994_3));
        // D s_4994_5: write-var gs#135066 <= s_4994_4
        fn_state.gs_135066 = s_4994_4;
        // N s_4994_6: jump b1320
        return block_1320(state, tracer, fn_state);
    }
    fn block_4995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4995_0: read-var coproc:u8
        let s_4995_0: u8 = fn_state.coproc;
        // D s_4995_1: cast zx s_4995_0 -> bv
        let s_4995_1: Bits = Bits::new(s_4995_0 as u128, 4u16);
        // C s_4995_2: const #15u : u8
        let s_4995_2: u8 = 15;
        // C s_4995_3: cast zx s_4995_2 -> bv
        let s_4995_3: Bits = Bits::new(s_4995_2 as u128, 4u16);
        // D s_4995_4: cmp-eq s_4995_1 s_4995_3
        let s_4995_4: bool = ((s_4995_1) == (s_4995_3));
        // D s_4995_5: write-var gs#135065 <= s_4995_4
        fn_state.gs_135065 = s_4995_4;
        // N s_4995_6: jump b1318
        return block_1318(state, tracer, fn_state);
    }
    fn block_4996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4996_0: read-var CRn:u8
        let s_4996_0: u8 = fn_state.CRn;
        // D s_4996_1: cast zx s_4996_0 -> bv
        let s_4996_1: Bits = Bits::new(s_4996_0 as u128, 4u16);
        // C s_4996_2: const #9u : u8
        let s_4996_2: u8 = 9;
        // C s_4996_3: cast zx s_4996_2 -> bv
        let s_4996_3: Bits = Bits::new(s_4996_2 as u128, 4u16);
        // D s_4996_4: cmp-eq s_4996_1 s_4996_3
        let s_4996_4: bool = ((s_4996_1) == (s_4996_3));
        // D s_4996_5: write-var gs#135064 <= s_4996_4
        fn_state.gs_135064 = s_4996_4;
        // N s_4996_6: jump b1316
        return block_1316(state, tracer, fn_state);
    }
    fn block_4997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4997_0: read-var el:u8
        let s_4997_0: u8 = fn_state.el;
        // D s_4997_1: read-var coproc:u8
        let s_4997_1: u8 = fn_state.coproc;
        // D s_4997_2: read-var opc1:u8
        let s_4997_2: u8 = fn_state.opc1;
        // D s_4997_3: read-var CRn:u8
        let s_4997_3: u8 = fn_state.CRn;
        // D s_4997_4: read-var opc2:u8
        let s_4997_4: u8 = fn_state.opc2;
        // D s_4997_5: read-var CRm:u8
        let s_4997_5: u8 = fn_state.CRm;
        // D s_4997_6: read-var t:i
        let s_4997_6: i128 = fn_state.t;
        // D s_4997_7: call ICC_DIR_SysRegWrite32_5d925e0a6cd7195a(s_4997_0, s_4997_1, s_4997_2, s_4997_3, s_4997_4, s_4997_5, s_4997_6)
        let s_4997_7: () = ICC_DIR_SysRegWrite32_5d925e0a6cd7195a(
            state,
            tracer,
            s_4997_0,
            s_4997_1,
            s_4997_2,
            s_4997_3,
            s_4997_4,
            s_4997_5,
            s_4997_6,
        );
        // N s_4997_8: return
        return;
    }
    fn block_4998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4998_0: read-var opc2:u8
        let s_4998_0: u8 = fn_state.opc2;
        // D s_4998_1: cast zx s_4998_0 -> bv
        let s_4998_1: Bits = Bits::new(s_4998_0 as u128, 3u16);
        // C s_4998_2: const #1u : u8
        let s_4998_2: u8 = 1;
        // C s_4998_3: cast zx s_4998_2 -> bv
        let s_4998_3: Bits = Bits::new(s_4998_2 as u128, 3u16);
        // D s_4998_4: cmp-eq s_4998_1 s_4998_3
        let s_4998_4: bool = ((s_4998_1) == (s_4998_3));
        // D s_4998_5: write-var gs#135063 <= s_4998_4
        fn_state.gs_135063 = s_4998_4;
        // N s_4998_6: jump b1313
        return block_1313(state, tracer, fn_state);
    }
    fn block_4999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4999_0: read-var opc1:u8
        let s_4999_0: u8 = fn_state.opc1;
        // D s_4999_1: cast zx s_4999_0 -> bv
        let s_4999_1: Bits = Bits::new(s_4999_0 as u128, 3u16);
        // C s_4999_2: const #0u : u8
        let s_4999_2: u8 = 0;
        // C s_4999_3: cast zx s_4999_2 -> bv
        let s_4999_3: Bits = Bits::new(s_4999_2 as u128, 3u16);
        // D s_4999_4: cmp-eq s_4999_1 s_4999_3
        let s_4999_4: bool = ((s_4999_1) == (s_4999_3));
        // D s_4999_5: write-var gs#135062 <= s_4999_4
        fn_state.gs_135062 = s_4999_4;
        // N s_4999_6: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_5000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5000_0: read-var coproc:u8
        let s_5000_0: u8 = fn_state.coproc;
        // D s_5000_1: cast zx s_5000_0 -> bv
        let s_5000_1: Bits = Bits::new(s_5000_0 as u128, 4u16);
        // C s_5000_2: const #15u : u8
        let s_5000_2: u8 = 15;
        // C s_5000_3: cast zx s_5000_2 -> bv
        let s_5000_3: Bits = Bits::new(s_5000_2 as u128, 4u16);
        // D s_5000_4: cmp-eq s_5000_1 s_5000_3
        let s_5000_4: bool = ((s_5000_1) == (s_5000_3));
        // D s_5000_5: write-var gs#135061 <= s_5000_4
        fn_state.gs_135061 = s_5000_4;
        // N s_5000_6: jump b1309
        return block_1309(state, tracer, fn_state);
    }
    fn block_5001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5001_0: read-var CRn:u8
        let s_5001_0: u8 = fn_state.CRn;
        // D s_5001_1: cast zx s_5001_0 -> bv
        let s_5001_1: Bits = Bits::new(s_5001_0 as u128, 4u16);
        // C s_5001_2: const #12u : u8
        let s_5001_2: u8 = 12;
        // C s_5001_3: cast zx s_5001_2 -> bv
        let s_5001_3: Bits = Bits::new(s_5001_2 as u128, 4u16);
        // D s_5001_4: cmp-eq s_5001_1 s_5001_3
        let s_5001_4: bool = ((s_5001_1) == (s_5001_3));
        // D s_5001_5: write-var gs#135060 <= s_5001_4
        fn_state.gs_135060 = s_5001_4;
        // N s_5001_6: jump b1307
        return block_1307(state, tracer, fn_state);
    }
    fn block_5002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5002_0: read-var el:u8
        let s_5002_0: u8 = fn_state.el;
        // D s_5002_1: read-var coproc:u8
        let s_5002_1: u8 = fn_state.coproc;
        // D s_5002_2: read-var opc1:u8
        let s_5002_2: u8 = fn_state.opc1;
        // D s_5002_3: read-var CRn:u8
        let s_5002_3: u8 = fn_state.CRn;
        // D s_5002_4: read-var opc2:u8
        let s_5002_4: u8 = fn_state.opc2;
        // D s_5002_5: read-var CRm:u8
        let s_5002_5: u8 = fn_state.CRm;
        // D s_5002_6: read-var t:i
        let s_5002_6: i128 = fn_state.t;
        // D s_5002_7: call ICC_MCTLR_SysRegWrite32_c2e3c881e988dc90(s_5002_0, s_5002_1, s_5002_2, s_5002_3, s_5002_4, s_5002_5, s_5002_6)
        let s_5002_7: () = ICC_MCTLR_SysRegWrite32_c2e3c881e988dc90(
            state,
            tracer,
            s_5002_0,
            s_5002_1,
            s_5002_2,
            s_5002_3,
            s_5002_4,
            s_5002_5,
            s_5002_6,
        );
        // N s_5002_8: return
        return;
    }
    fn block_5003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5003_0: read-var opc2:u8
        let s_5003_0: u8 = fn_state.opc2;
        // D s_5003_1: cast zx s_5003_0 -> bv
        let s_5003_1: Bits = Bits::new(s_5003_0 as u128, 3u16);
        // C s_5003_2: const #4u : u8
        let s_5003_2: u8 = 4;
        // C s_5003_3: cast zx s_5003_2 -> bv
        let s_5003_3: Bits = Bits::new(s_5003_2 as u128, 3u16);
        // D s_5003_4: cmp-eq s_5003_1 s_5003_3
        let s_5003_4: bool = ((s_5003_1) == (s_5003_3));
        // D s_5003_5: write-var gs#135059 <= s_5003_4
        fn_state.gs_135059 = s_5003_4;
        // N s_5003_6: jump b1304
        return block_1304(state, tracer, fn_state);
    }
    fn block_5004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5004_0: read-var opc1:u8
        let s_5004_0: u8 = fn_state.opc1;
        // D s_5004_1: cast zx s_5004_0 -> bv
        let s_5004_1: Bits = Bits::new(s_5004_0 as u128, 3u16);
        // C s_5004_2: const #6u : u8
        let s_5004_2: u8 = 6;
        // C s_5004_3: cast zx s_5004_2 -> bv
        let s_5004_3: Bits = Bits::new(s_5004_2 as u128, 3u16);
        // D s_5004_4: cmp-eq s_5004_1 s_5004_3
        let s_5004_4: bool = ((s_5004_1) == (s_5004_3));
        // D s_5004_5: write-var gs#135058 <= s_5004_4
        fn_state.gs_135058 = s_5004_4;
        // N s_5004_6: jump b1302
        return block_1302(state, tracer, fn_state);
    }
    fn block_5005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5005_0: read-var coproc:u8
        let s_5005_0: u8 = fn_state.coproc;
        // D s_5005_1: cast zx s_5005_0 -> bv
        let s_5005_1: Bits = Bits::new(s_5005_0 as u128, 4u16);
        // C s_5005_2: const #15u : u8
        let s_5005_2: u8 = 15;
        // C s_5005_3: cast zx s_5005_2 -> bv
        let s_5005_3: Bits = Bits::new(s_5005_2 as u128, 4u16);
        // D s_5005_4: cmp-eq s_5005_1 s_5005_3
        let s_5005_4: bool = ((s_5005_1) == (s_5005_3));
        // D s_5005_5: write-var gs#135057 <= s_5005_4
        fn_state.gs_135057 = s_5005_4;
        // N s_5005_6: jump b1300
        return block_1300(state, tracer, fn_state);
    }
    fn block_5006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5006_0: read-var CRn:u8
        let s_5006_0: u8 = fn_state.CRn;
        // D s_5006_1: cast zx s_5006_0 -> bv
        let s_5006_1: Bits = Bits::new(s_5006_0 as u128, 4u16);
        // C s_5006_2: const #12u : u8
        let s_5006_2: u8 = 12;
        // C s_5006_3: cast zx s_5006_2 -> bv
        let s_5006_3: Bits = Bits::new(s_5006_2 as u128, 4u16);
        // D s_5006_4: cmp-eq s_5006_1 s_5006_3
        let s_5006_4: bool = ((s_5006_1) == (s_5006_3));
        // D s_5006_5: write-var gs#135056 <= s_5006_4
        fn_state.gs_135056 = s_5006_4;
        // N s_5006_6: jump b1298
        return block_1298(state, tracer, fn_state);
    }
    fn block_5007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5007_0: read-var el:u8
        let s_5007_0: u8 = fn_state.el;
        // D s_5007_1: read-var coproc:u8
        let s_5007_1: u8 = fn_state.coproc;
        // D s_5007_2: read-var opc1:u8
        let s_5007_2: u8 = fn_state.opc1;
        // D s_5007_3: read-var CRn:u8
        let s_5007_3: u8 = fn_state.CRn;
        // D s_5007_4: read-var opc2:u8
        let s_5007_4: u8 = fn_state.opc2;
        // D s_5007_5: read-var CRm:u8
        let s_5007_5: u8 = fn_state.CRm;
        // D s_5007_6: read-var t:i
        let s_5007_6: i128 = fn_state.t;
        // D s_5007_7: call HSTR_SysRegWrite32_f0139fe1b83ebb72(s_5007_0, s_5007_1, s_5007_2, s_5007_3, s_5007_4, s_5007_5, s_5007_6)
        let s_5007_7: () = HSTR_SysRegWrite32_f0139fe1b83ebb72(
            state,
            tracer,
            s_5007_0,
            s_5007_1,
            s_5007_2,
            s_5007_3,
            s_5007_4,
            s_5007_5,
            s_5007_6,
        );
        // N s_5007_8: return
        return;
    }
    fn block_5008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5008_0: read-var opc2:u8
        let s_5008_0: u8 = fn_state.opc2;
        // D s_5008_1: cast zx s_5008_0 -> bv
        let s_5008_1: Bits = Bits::new(s_5008_0 as u128, 3u16);
        // C s_5008_2: const #3u : u8
        let s_5008_2: u8 = 3;
        // C s_5008_3: cast zx s_5008_2 -> bv
        let s_5008_3: Bits = Bits::new(s_5008_2 as u128, 3u16);
        // D s_5008_4: cmp-eq s_5008_1 s_5008_3
        let s_5008_4: bool = ((s_5008_1) == (s_5008_3));
        // D s_5008_5: write-var gs#135055 <= s_5008_4
        fn_state.gs_135055 = s_5008_4;
        // N s_5008_6: jump b1295
        return block_1295(state, tracer, fn_state);
    }
    fn block_5009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5009_0: read-var opc1:u8
        let s_5009_0: u8 = fn_state.opc1;
        // D s_5009_1: cast zx s_5009_0 -> bv
        let s_5009_1: Bits = Bits::new(s_5009_0 as u128, 3u16);
        // C s_5009_2: const #4u : u8
        let s_5009_2: u8 = 4;
        // C s_5009_3: cast zx s_5009_2 -> bv
        let s_5009_3: Bits = Bits::new(s_5009_2 as u128, 3u16);
        // D s_5009_4: cmp-eq s_5009_1 s_5009_3
        let s_5009_4: bool = ((s_5009_1) == (s_5009_3));
        // D s_5009_5: write-var gs#135054 <= s_5009_4
        fn_state.gs_135054 = s_5009_4;
        // N s_5009_6: jump b1293
        return block_1293(state, tracer, fn_state);
    }
    fn block_5010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5010_0: read-var coproc:u8
        let s_5010_0: u8 = fn_state.coproc;
        // D s_5010_1: cast zx s_5010_0 -> bv
        let s_5010_1: Bits = Bits::new(s_5010_0 as u128, 4u16);
        // C s_5010_2: const #15u : u8
        let s_5010_2: u8 = 15;
        // C s_5010_3: cast zx s_5010_2 -> bv
        let s_5010_3: Bits = Bits::new(s_5010_2 as u128, 4u16);
        // D s_5010_4: cmp-eq s_5010_1 s_5010_3
        let s_5010_4: bool = ((s_5010_1) == (s_5010_3));
        // D s_5010_5: write-var gs#135053 <= s_5010_4
        fn_state.gs_135053 = s_5010_4;
        // N s_5010_6: jump b1291
        return block_1291(state, tracer, fn_state);
    }
    fn block_5011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5011_0: read-var CRn:u8
        let s_5011_0: u8 = fn_state.CRn;
        // D s_5011_1: cast zx s_5011_0 -> bv
        let s_5011_1: Bits = Bits::new(s_5011_0 as u128, 4u16);
        // C s_5011_2: const #1u : u8
        let s_5011_2: u8 = 1;
        // C s_5011_3: cast zx s_5011_2 -> bv
        let s_5011_3: Bits = Bits::new(s_5011_2 as u128, 4u16);
        // D s_5011_4: cmp-eq s_5011_1 s_5011_3
        let s_5011_4: bool = ((s_5011_1) == (s_5011_3));
        // D s_5011_5: write-var gs#135052 <= s_5011_4
        fn_state.gs_135052 = s_5011_4;
        // N s_5011_6: jump b1289
        return block_1289(state, tracer, fn_state);
    }
    fn block_5012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5012_0: read-var el:u8
        let s_5012_0: u8 = fn_state.el;
        // D s_5012_1: read-var coproc:u8
        let s_5012_1: u8 = fn_state.coproc;
        // D s_5012_2: read-var opc1:u8
        let s_5012_2: u8 = fn_state.opc1;
        // D s_5012_3: read-var CRn:u8
        let s_5012_3: u8 = fn_state.CRn;
        // D s_5012_4: read-var opc2:u8
        let s_5012_4: u8 = fn_state.opc2;
        // D s_5012_5: read-var CRm:u8
        let s_5012_5: u8 = fn_state.CRm;
        // D s_5012_6: read-var t:i
        let s_5012_6: i128 = fn_state.t;
        // D s_5012_7: call DSPSR_SysRegWrite32_eb89215986db3057(s_5012_0, s_5012_1, s_5012_2, s_5012_3, s_5012_4, s_5012_5, s_5012_6)
        let s_5012_7: () = DSPSR_SysRegWrite32_eb89215986db3057(
            state,
            tracer,
            s_5012_0,
            s_5012_1,
            s_5012_2,
            s_5012_3,
            s_5012_4,
            s_5012_5,
            s_5012_6,
        );
        // N s_5012_8: return
        return;
    }
    fn block_5013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5013_0: read-var opc2:u8
        let s_5013_0: u8 = fn_state.opc2;
        // D s_5013_1: cast zx s_5013_0 -> bv
        let s_5013_1: Bits = Bits::new(s_5013_0 as u128, 3u16);
        // C s_5013_2: const #0u : u8
        let s_5013_2: u8 = 0;
        // C s_5013_3: cast zx s_5013_2 -> bv
        let s_5013_3: Bits = Bits::new(s_5013_2 as u128, 3u16);
        // D s_5013_4: cmp-eq s_5013_1 s_5013_3
        let s_5013_4: bool = ((s_5013_1) == (s_5013_3));
        // D s_5013_5: write-var gs#135051 <= s_5013_4
        fn_state.gs_135051 = s_5013_4;
        // N s_5013_6: jump b1286
        return block_1286(state, tracer, fn_state);
    }
    fn block_5014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5014_0: read-var opc1:u8
        let s_5014_0: u8 = fn_state.opc1;
        // D s_5014_1: cast zx s_5014_0 -> bv
        let s_5014_1: Bits = Bits::new(s_5014_0 as u128, 3u16);
        // C s_5014_2: const #3u : u8
        let s_5014_2: u8 = 3;
        // C s_5014_3: cast zx s_5014_2 -> bv
        let s_5014_3: Bits = Bits::new(s_5014_2 as u128, 3u16);
        // D s_5014_4: cmp-eq s_5014_1 s_5014_3
        let s_5014_4: bool = ((s_5014_1) == (s_5014_3));
        // D s_5014_5: write-var gs#135050 <= s_5014_4
        fn_state.gs_135050 = s_5014_4;
        // N s_5014_6: jump b1284
        return block_1284(state, tracer, fn_state);
    }
    fn block_5015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5015_0: read-var coproc:u8
        let s_5015_0: u8 = fn_state.coproc;
        // D s_5015_1: cast zx s_5015_0 -> bv
        let s_5015_1: Bits = Bits::new(s_5015_0 as u128, 4u16);
        // C s_5015_2: const #15u : u8
        let s_5015_2: u8 = 15;
        // C s_5015_3: cast zx s_5015_2 -> bv
        let s_5015_3: Bits = Bits::new(s_5015_2 as u128, 4u16);
        // D s_5015_4: cmp-eq s_5015_1 s_5015_3
        let s_5015_4: bool = ((s_5015_1) == (s_5015_3));
        // D s_5015_5: write-var gs#135049 <= s_5015_4
        fn_state.gs_135049 = s_5015_4;
        // N s_5015_6: jump b1282
        return block_1282(state, tracer, fn_state);
    }
    fn block_5016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5016_0: read-var CRn:u8
        let s_5016_0: u8 = fn_state.CRn;
        // D s_5016_1: cast zx s_5016_0 -> bv
        let s_5016_1: Bits = Bits::new(s_5016_0 as u128, 4u16);
        // C s_5016_2: const #4u : u8
        let s_5016_2: u8 = 4;
        // C s_5016_3: cast zx s_5016_2 -> bv
        let s_5016_3: Bits = Bits::new(s_5016_2 as u128, 4u16);
        // D s_5016_4: cmp-eq s_5016_1 s_5016_3
        let s_5016_4: bool = ((s_5016_1) == (s_5016_3));
        // D s_5016_5: write-var gs#135048 <= s_5016_4
        fn_state.gs_135048 = s_5016_4;
        // N s_5016_6: jump b1280
        return block_1280(state, tracer, fn_state);
    }
    fn block_5017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5017_0: read-var el:u8
        let s_5017_0: u8 = fn_state.el;
        // D s_5017_1: read-var coproc:u8
        let s_5017_1: u8 = fn_state.coproc;
        // D s_5017_2: read-var opc1:u8
        let s_5017_2: u8 = fn_state.opc1;
        // D s_5017_3: read-var CRn:u8
        let s_5017_3: u8 = fn_state.CRn;
        // D s_5017_4: read-var opc2:u8
        let s_5017_4: u8 = fn_state.opc2;
        // D s_5017_5: read-var CRm:u8
        let s_5017_5: u8 = fn_state.CRm;
        // D s_5017_6: read-var t:i
        let s_5017_6: i128 = fn_state.t;
        // D s_5017_7: call HVBAR_SysRegWrite32_ebefed79e41064af(s_5017_0, s_5017_1, s_5017_2, s_5017_3, s_5017_4, s_5017_5, s_5017_6)
        let s_5017_7: () = HVBAR_SysRegWrite32_ebefed79e41064af(
            state,
            tracer,
            s_5017_0,
            s_5017_1,
            s_5017_2,
            s_5017_3,
            s_5017_4,
            s_5017_5,
            s_5017_6,
        );
        // N s_5017_8: return
        return;
    }
    fn block_5018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5018_0: read-var opc2:u8
        let s_5018_0: u8 = fn_state.opc2;
        // D s_5018_1: cast zx s_5018_0 -> bv
        let s_5018_1: Bits = Bits::new(s_5018_0 as u128, 3u16);
        // C s_5018_2: const #0u : u8
        let s_5018_2: u8 = 0;
        // C s_5018_3: cast zx s_5018_2 -> bv
        let s_5018_3: Bits = Bits::new(s_5018_2 as u128, 3u16);
        // D s_5018_4: cmp-eq s_5018_1 s_5018_3
        let s_5018_4: bool = ((s_5018_1) == (s_5018_3));
        // D s_5018_5: write-var gs#135047 <= s_5018_4
        fn_state.gs_135047 = s_5018_4;
        // N s_5018_6: jump b1277
        return block_1277(state, tracer, fn_state);
    }
    fn block_5019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5019_0: read-var opc1:u8
        let s_5019_0: u8 = fn_state.opc1;
        // D s_5019_1: cast zx s_5019_0 -> bv
        let s_5019_1: Bits = Bits::new(s_5019_0 as u128, 3u16);
        // C s_5019_2: const #4u : u8
        let s_5019_2: u8 = 4;
        // C s_5019_3: cast zx s_5019_2 -> bv
        let s_5019_3: Bits = Bits::new(s_5019_2 as u128, 3u16);
        // D s_5019_4: cmp-eq s_5019_1 s_5019_3
        let s_5019_4: bool = ((s_5019_1) == (s_5019_3));
        // D s_5019_5: write-var gs#135046 <= s_5019_4
        fn_state.gs_135046 = s_5019_4;
        // N s_5019_6: jump b1275
        return block_1275(state, tracer, fn_state);
    }
    fn block_5020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5020_0: read-var coproc:u8
        let s_5020_0: u8 = fn_state.coproc;
        // D s_5020_1: cast zx s_5020_0 -> bv
        let s_5020_1: Bits = Bits::new(s_5020_0 as u128, 4u16);
        // C s_5020_2: const #15u : u8
        let s_5020_2: u8 = 15;
        // C s_5020_3: cast zx s_5020_2 -> bv
        let s_5020_3: Bits = Bits::new(s_5020_2 as u128, 4u16);
        // D s_5020_4: cmp-eq s_5020_1 s_5020_3
        let s_5020_4: bool = ((s_5020_1) == (s_5020_3));
        // D s_5020_5: write-var gs#135045 <= s_5020_4
        fn_state.gs_135045 = s_5020_4;
        // N s_5020_6: jump b1273
        return block_1273(state, tracer, fn_state);
    }
    fn block_5021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5021_0: read-var CRn:u8
        let s_5021_0: u8 = fn_state.CRn;
        // D s_5021_1: cast zx s_5021_0 -> bv
        let s_5021_1: Bits = Bits::new(s_5021_0 as u128, 4u16);
        // C s_5021_2: const #12u : u8
        let s_5021_2: u8 = 12;
        // C s_5021_3: cast zx s_5021_2 -> bv
        let s_5021_3: Bits = Bits::new(s_5021_2 as u128, 4u16);
        // D s_5021_4: cmp-eq s_5021_1 s_5021_3
        let s_5021_4: bool = ((s_5021_1) == (s_5021_3));
        // D s_5021_5: write-var gs#135044 <= s_5021_4
        fn_state.gs_135044 = s_5021_4;
        // N s_5021_6: jump b1271
        return block_1271(state, tracer, fn_state);
    }
    fn block_5022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5022_0: read-var el:u8
        let s_5022_0: u8 = fn_state.el;
        // D s_5022_1: read-var coproc:u8
        let s_5022_1: u8 = fn_state.coproc;
        // D s_5022_2: read-var opc1:u8
        let s_5022_2: u8 = fn_state.opc1;
        // D s_5022_3: read-var CRn:u8
        let s_5022_3: u8 = fn_state.CRn;
        // D s_5022_4: read-var opc2:u8
        let s_5022_4: u8 = fn_state.opc2;
        // D s_5022_5: read-var CRm:u8
        let s_5022_5: u8 = fn_state.CRm;
        // D s_5022_6: read-var t:i
        let s_5022_6: i128 = fn_state.t;
        // D s_5022_7: call VMPIDR_SysRegWrite32_954adcfdf7aeec04(s_5022_0, s_5022_1, s_5022_2, s_5022_3, s_5022_4, s_5022_5, s_5022_6)
        let s_5022_7: () = VMPIDR_SysRegWrite32_954adcfdf7aeec04(
            state,
            tracer,
            s_5022_0,
            s_5022_1,
            s_5022_2,
            s_5022_3,
            s_5022_4,
            s_5022_5,
            s_5022_6,
        );
        // N s_5022_8: return
        return;
    }
    fn block_5023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5023_0: read-var opc2:u8
        let s_5023_0: u8 = fn_state.opc2;
        // D s_5023_1: cast zx s_5023_0 -> bv
        let s_5023_1: Bits = Bits::new(s_5023_0 as u128, 3u16);
        // C s_5023_2: const #5u : u8
        let s_5023_2: u8 = 5;
        // C s_5023_3: cast zx s_5023_2 -> bv
        let s_5023_3: Bits = Bits::new(s_5023_2 as u128, 3u16);
        // D s_5023_4: cmp-eq s_5023_1 s_5023_3
        let s_5023_4: bool = ((s_5023_1) == (s_5023_3));
        // D s_5023_5: write-var gs#135043 <= s_5023_4
        fn_state.gs_135043 = s_5023_4;
        // N s_5023_6: jump b1268
        return block_1268(state, tracer, fn_state);
    }
    fn block_5024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5024_0: read-var opc1:u8
        let s_5024_0: u8 = fn_state.opc1;
        // D s_5024_1: cast zx s_5024_0 -> bv
        let s_5024_1: Bits = Bits::new(s_5024_0 as u128, 3u16);
        // C s_5024_2: const #4u : u8
        let s_5024_2: u8 = 4;
        // C s_5024_3: cast zx s_5024_2 -> bv
        let s_5024_3: Bits = Bits::new(s_5024_2 as u128, 3u16);
        // D s_5024_4: cmp-eq s_5024_1 s_5024_3
        let s_5024_4: bool = ((s_5024_1) == (s_5024_3));
        // D s_5024_5: write-var gs#135042 <= s_5024_4
        fn_state.gs_135042 = s_5024_4;
        // N s_5024_6: jump b1266
        return block_1266(state, tracer, fn_state);
    }
    fn block_5025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5025_0: read-var coproc:u8
        let s_5025_0: u8 = fn_state.coproc;
        // D s_5025_1: cast zx s_5025_0 -> bv
        let s_5025_1: Bits = Bits::new(s_5025_0 as u128, 4u16);
        // C s_5025_2: const #15u : u8
        let s_5025_2: u8 = 15;
        // C s_5025_3: cast zx s_5025_2 -> bv
        let s_5025_3: Bits = Bits::new(s_5025_2 as u128, 4u16);
        // D s_5025_4: cmp-eq s_5025_1 s_5025_3
        let s_5025_4: bool = ((s_5025_1) == (s_5025_3));
        // D s_5025_5: write-var gs#135041 <= s_5025_4
        fn_state.gs_135041 = s_5025_4;
        // N s_5025_6: jump b1264
        return block_1264(state, tracer, fn_state);
    }
    fn block_5026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5026_0: read-var CRn:u8
        let s_5026_0: u8 = fn_state.CRn;
        // D s_5026_1: cast zx s_5026_0 -> bv
        let s_5026_1: Bits = Bits::new(s_5026_0 as u128, 4u16);
        // C s_5026_2: const #0u : u8
        let s_5026_2: u8 = 0;
        // C s_5026_3: cast zx s_5026_2 -> bv
        let s_5026_3: Bits = Bits::new(s_5026_2 as u128, 4u16);
        // D s_5026_4: cmp-eq s_5026_1 s_5026_3
        let s_5026_4: bool = ((s_5026_1) == (s_5026_3));
        // D s_5026_5: write-var gs#135040 <= s_5026_4
        fn_state.gs_135040 = s_5026_4;
        // N s_5026_6: jump b1262
        return block_1262(state, tracer, fn_state);
    }
    fn block_5027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5027_0: read-var el:u8
        let s_5027_0: u8 = fn_state.el;
        // D s_5027_1: read-var coproc:u8
        let s_5027_1: u8 = fn_state.coproc;
        // D s_5027_2: read-var opc1:u8
        let s_5027_2: u8 = fn_state.opc1;
        // D s_5027_3: read-var CRn:u8
        let s_5027_3: u8 = fn_state.CRn;
        // D s_5027_4: read-var opc2:u8
        let s_5027_4: u8 = fn_state.opc2;
        // D s_5027_5: read-var CRm:u8
        let s_5027_5: u8 = fn_state.CRm;
        // D s_5027_6: read-var t:i
        let s_5027_6: i128 = fn_state.t;
        // D s_5027_7: call DCCISW_SysRegWrite32_419e334023bc59ed(s_5027_0, s_5027_1, s_5027_2, s_5027_3, s_5027_4, s_5027_5, s_5027_6)
        let s_5027_7: () = DCCISW_SysRegWrite32_419e334023bc59ed(
            state,
            tracer,
            s_5027_0,
            s_5027_1,
            s_5027_2,
            s_5027_3,
            s_5027_4,
            s_5027_5,
            s_5027_6,
        );
        // N s_5027_8: return
        return;
    }
    fn block_5028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5028_0: read-var opc2:u8
        let s_5028_0: u8 = fn_state.opc2;
        // D s_5028_1: cast zx s_5028_0 -> bv
        let s_5028_1: Bits = Bits::new(s_5028_0 as u128, 3u16);
        // C s_5028_2: const #2u : u8
        let s_5028_2: u8 = 2;
        // C s_5028_3: cast zx s_5028_2 -> bv
        let s_5028_3: Bits = Bits::new(s_5028_2 as u128, 3u16);
        // D s_5028_4: cmp-eq s_5028_1 s_5028_3
        let s_5028_4: bool = ((s_5028_1) == (s_5028_3));
        // D s_5028_5: write-var gs#135039 <= s_5028_4
        fn_state.gs_135039 = s_5028_4;
        // N s_5028_6: jump b1259
        return block_1259(state, tracer, fn_state);
    }
    fn block_5029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5029_0: read-var opc1:u8
        let s_5029_0: u8 = fn_state.opc1;
        // D s_5029_1: cast zx s_5029_0 -> bv
        let s_5029_1: Bits = Bits::new(s_5029_0 as u128, 3u16);
        // C s_5029_2: const #0u : u8
        let s_5029_2: u8 = 0;
        // C s_5029_3: cast zx s_5029_2 -> bv
        let s_5029_3: Bits = Bits::new(s_5029_2 as u128, 3u16);
        // D s_5029_4: cmp-eq s_5029_1 s_5029_3
        let s_5029_4: bool = ((s_5029_1) == (s_5029_3));
        // D s_5029_5: write-var gs#135038 <= s_5029_4
        fn_state.gs_135038 = s_5029_4;
        // N s_5029_6: jump b1257
        return block_1257(state, tracer, fn_state);
    }
    fn block_5030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5030_0: read-var coproc:u8
        let s_5030_0: u8 = fn_state.coproc;
        // D s_5030_1: cast zx s_5030_0 -> bv
        let s_5030_1: Bits = Bits::new(s_5030_0 as u128, 4u16);
        // C s_5030_2: const #15u : u8
        let s_5030_2: u8 = 15;
        // C s_5030_3: cast zx s_5030_2 -> bv
        let s_5030_3: Bits = Bits::new(s_5030_2 as u128, 4u16);
        // D s_5030_4: cmp-eq s_5030_1 s_5030_3
        let s_5030_4: bool = ((s_5030_1) == (s_5030_3));
        // D s_5030_5: write-var gs#135037 <= s_5030_4
        fn_state.gs_135037 = s_5030_4;
        // N s_5030_6: jump b1255
        return block_1255(state, tracer, fn_state);
    }
    fn block_5031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5031_0: read-var CRn:u8
        let s_5031_0: u8 = fn_state.CRn;
        // D s_5031_1: cast zx s_5031_0 -> bv
        let s_5031_1: Bits = Bits::new(s_5031_0 as u128, 4u16);
        // C s_5031_2: const #7u : u8
        let s_5031_2: u8 = 7;
        // C s_5031_3: cast zx s_5031_2 -> bv
        let s_5031_3: Bits = Bits::new(s_5031_2 as u128, 4u16);
        // D s_5031_4: cmp-eq s_5031_1 s_5031_3
        let s_5031_4: bool = ((s_5031_1) == (s_5031_3));
        // D s_5031_5: write-var gs#135036 <= s_5031_4
        fn_state.gs_135036 = s_5031_4;
        // N s_5031_6: jump b1253
        return block_1253(state, tracer, fn_state);
    }
    fn block_5032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5032_0: read-var el:u8
        let s_5032_0: u8 = fn_state.el;
        // D s_5032_1: read-var coproc:u8
        let s_5032_1: u8 = fn_state.coproc;
        // D s_5032_2: read-var opc1:u8
        let s_5032_2: u8 = fn_state.opc1;
        // D s_5032_3: read-var CRn:u8
        let s_5032_3: u8 = fn_state.CRn;
        // D s_5032_4: read-var opc2:u8
        let s_5032_4: u8 = fn_state.opc2;
        // D s_5032_5: read-var CRm:u8
        let s_5032_5: u8 = fn_state.CRm;
        // D s_5032_6: read-var t:i
        let s_5032_6: i128 = fn_state.t;
        // D s_5032_7: call ICC_MSRE_SysRegWrite32_3238a1354a48916c(s_5032_0, s_5032_1, s_5032_2, s_5032_3, s_5032_4, s_5032_5, s_5032_6)
        let s_5032_7: () = ICC_MSRE_SysRegWrite32_3238a1354a48916c(
            state,
            tracer,
            s_5032_0,
            s_5032_1,
            s_5032_2,
            s_5032_3,
            s_5032_4,
            s_5032_5,
            s_5032_6,
        );
        // N s_5032_8: return
        return;
    }
    fn block_5033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5033_0: read-var opc2:u8
        let s_5033_0: u8 = fn_state.opc2;
        // D s_5033_1: cast zx s_5033_0 -> bv
        let s_5033_1: Bits = Bits::new(s_5033_0 as u128, 3u16);
        // C s_5033_2: const #5u : u8
        let s_5033_2: u8 = 5;
        // C s_5033_3: cast zx s_5033_2 -> bv
        let s_5033_3: Bits = Bits::new(s_5033_2 as u128, 3u16);
        // D s_5033_4: cmp-eq s_5033_1 s_5033_3
        let s_5033_4: bool = ((s_5033_1) == (s_5033_3));
        // D s_5033_5: write-var gs#135035 <= s_5033_4
        fn_state.gs_135035 = s_5033_4;
        // N s_5033_6: jump b1250
        return block_1250(state, tracer, fn_state);
    }
    fn block_5034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5034_0: read-var opc1:u8
        let s_5034_0: u8 = fn_state.opc1;
        // D s_5034_1: cast zx s_5034_0 -> bv
        let s_5034_1: Bits = Bits::new(s_5034_0 as u128, 3u16);
        // C s_5034_2: const #6u : u8
        let s_5034_2: u8 = 6;
        // C s_5034_3: cast zx s_5034_2 -> bv
        let s_5034_3: Bits = Bits::new(s_5034_2 as u128, 3u16);
        // D s_5034_4: cmp-eq s_5034_1 s_5034_3
        let s_5034_4: bool = ((s_5034_1) == (s_5034_3));
        // D s_5034_5: write-var gs#135034 <= s_5034_4
        fn_state.gs_135034 = s_5034_4;
        // N s_5034_6: jump b1248
        return block_1248(state, tracer, fn_state);
    }
    fn block_5035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5035_0: read-var coproc:u8
        let s_5035_0: u8 = fn_state.coproc;
        // D s_5035_1: cast zx s_5035_0 -> bv
        let s_5035_1: Bits = Bits::new(s_5035_0 as u128, 4u16);
        // C s_5035_2: const #15u : u8
        let s_5035_2: u8 = 15;
        // C s_5035_3: cast zx s_5035_2 -> bv
        let s_5035_3: Bits = Bits::new(s_5035_2 as u128, 4u16);
        // D s_5035_4: cmp-eq s_5035_1 s_5035_3
        let s_5035_4: bool = ((s_5035_1) == (s_5035_3));
        // D s_5035_5: write-var gs#135033 <= s_5035_4
        fn_state.gs_135033 = s_5035_4;
        // N s_5035_6: jump b1246
        return block_1246(state, tracer, fn_state);
    }
    fn block_5036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5036_0: read-var CRn:u8
        let s_5036_0: u8 = fn_state.CRn;
        // D s_5036_1: cast zx s_5036_0 -> bv
        let s_5036_1: Bits = Bits::new(s_5036_0 as u128, 4u16);
        // C s_5036_2: const #12u : u8
        let s_5036_2: u8 = 12;
        // C s_5036_3: cast zx s_5036_2 -> bv
        let s_5036_3: Bits = Bits::new(s_5036_2 as u128, 4u16);
        // D s_5036_4: cmp-eq s_5036_1 s_5036_3
        let s_5036_4: bool = ((s_5036_1) == (s_5036_3));
        // D s_5036_5: write-var gs#135032 <= s_5036_4
        fn_state.gs_135032 = s_5036_4;
        // N s_5036_6: jump b1244
        return block_1244(state, tracer, fn_state);
    }
    fn block_5037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5037_0: read-var el:u8
        let s_5037_0: u8 = fn_state.el;
        // D s_5037_1: read-var coproc:u8
        let s_5037_1: u8 = fn_state.coproc;
        // D s_5037_2: read-var opc1:u8
        let s_5037_2: u8 = fn_state.opc1;
        // D s_5037_3: read-var CRn:u8
        let s_5037_3: u8 = fn_state.CRn;
        // D s_5037_4: read-var opc2:u8
        let s_5037_4: u8 = fn_state.opc2;
        // D s_5037_5: read-var CRm:u8
        let s_5037_5: u8 = fn_state.CRm;
        // D s_5037_6: read-var t:i
        let s_5037_6: i128 = fn_state.t;
        // D s_5037_7: call TLBIIPAS2LIS_SysRegWrite32_4ae44938f6bf59ab(s_5037_0, s_5037_1, s_5037_2, s_5037_3, s_5037_4, s_5037_5, s_5037_6)
        let s_5037_7: () = TLBIIPAS2LIS_SysRegWrite32_4ae44938f6bf59ab(
            state,
            tracer,
            s_5037_0,
            s_5037_1,
            s_5037_2,
            s_5037_3,
            s_5037_4,
            s_5037_5,
            s_5037_6,
        );
        // N s_5037_8: return
        return;
    }
    fn block_5038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5038_0: read-var opc2:u8
        let s_5038_0: u8 = fn_state.opc2;
        // D s_5038_1: cast zx s_5038_0 -> bv
        let s_5038_1: Bits = Bits::new(s_5038_0 as u128, 3u16);
        // C s_5038_2: const #5u : u8
        let s_5038_2: u8 = 5;
        // C s_5038_3: cast zx s_5038_2 -> bv
        let s_5038_3: Bits = Bits::new(s_5038_2 as u128, 3u16);
        // D s_5038_4: cmp-eq s_5038_1 s_5038_3
        let s_5038_4: bool = ((s_5038_1) == (s_5038_3));
        // D s_5038_5: write-var gs#135031 <= s_5038_4
        fn_state.gs_135031 = s_5038_4;
        // N s_5038_6: jump b1241
        return block_1241(state, tracer, fn_state);
    }
    fn block_5039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5039_0: read-var opc1:u8
        let s_5039_0: u8 = fn_state.opc1;
        // D s_5039_1: cast zx s_5039_0 -> bv
        let s_5039_1: Bits = Bits::new(s_5039_0 as u128, 3u16);
        // C s_5039_2: const #4u : u8
        let s_5039_2: u8 = 4;
        // C s_5039_3: cast zx s_5039_2 -> bv
        let s_5039_3: Bits = Bits::new(s_5039_2 as u128, 3u16);
        // D s_5039_4: cmp-eq s_5039_1 s_5039_3
        let s_5039_4: bool = ((s_5039_1) == (s_5039_3));
        // D s_5039_5: write-var gs#135030 <= s_5039_4
        fn_state.gs_135030 = s_5039_4;
        // N s_5039_6: jump b1239
        return block_1239(state, tracer, fn_state);
    }
    fn block_5040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5040_0: read-var coproc:u8
        let s_5040_0: u8 = fn_state.coproc;
        // D s_5040_1: cast zx s_5040_0 -> bv
        let s_5040_1: Bits = Bits::new(s_5040_0 as u128, 4u16);
        // C s_5040_2: const #15u : u8
        let s_5040_2: u8 = 15;
        // C s_5040_3: cast zx s_5040_2 -> bv
        let s_5040_3: Bits = Bits::new(s_5040_2 as u128, 4u16);
        // D s_5040_4: cmp-eq s_5040_1 s_5040_3
        let s_5040_4: bool = ((s_5040_1) == (s_5040_3));
        // D s_5040_5: write-var gs#135029 <= s_5040_4
        fn_state.gs_135029 = s_5040_4;
        // N s_5040_6: jump b1237
        return block_1237(state, tracer, fn_state);
    }
    fn block_5041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5041_0: read-var CRn:u8
        let s_5041_0: u8 = fn_state.CRn;
        // D s_5041_1: cast zx s_5041_0 -> bv
        let s_5041_1: Bits = Bits::new(s_5041_0 as u128, 4u16);
        // C s_5041_2: const #8u : u8
        let s_5041_2: u8 = 8;
        // C s_5041_3: cast zx s_5041_2 -> bv
        let s_5041_3: Bits = Bits::new(s_5041_2 as u128, 4u16);
        // D s_5041_4: cmp-eq s_5041_1 s_5041_3
        let s_5041_4: bool = ((s_5041_1) == (s_5041_3));
        // D s_5041_5: write-var gs#135028 <= s_5041_4
        fn_state.gs_135028 = s_5041_4;
        // N s_5041_6: jump b1235
        return block_1235(state, tracer, fn_state);
    }
    fn block_5042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5042_0: read-var el:u8
        let s_5042_0: u8 = fn_state.el;
        // D s_5042_1: read-var coproc:u8
        let s_5042_1: u8 = fn_state.coproc;
        // D s_5042_2: read-var opc1:u8
        let s_5042_2: u8 = fn_state.opc1;
        // D s_5042_3: read-var CRn:u8
        let s_5042_3: u8 = fn_state.CRn;
        // D s_5042_4: read-var opc2:u8
        let s_5042_4: u8 = fn_state.opc2;
        // D s_5042_5: read-var CRm:u8
        let s_5042_5: u8 = fn_state.CRm;
        // D s_5042_6: read-var t:i
        let s_5042_6: i128 = fn_state.t;
        // D s_5042_7: call TLBIMVALHIS_SysRegWrite32_89a451ea9208e882(s_5042_0, s_5042_1, s_5042_2, s_5042_3, s_5042_4, s_5042_5, s_5042_6)
        let s_5042_7: () = TLBIMVALHIS_SysRegWrite32_89a451ea9208e882(
            state,
            tracer,
            s_5042_0,
            s_5042_1,
            s_5042_2,
            s_5042_3,
            s_5042_4,
            s_5042_5,
            s_5042_6,
        );
        // N s_5042_8: return
        return;
    }
    fn block_5043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5043_0: read-var opc2:u8
        let s_5043_0: u8 = fn_state.opc2;
        // D s_5043_1: cast zx s_5043_0 -> bv
        let s_5043_1: Bits = Bits::new(s_5043_0 as u128, 3u16);
        // C s_5043_2: const #5u : u8
        let s_5043_2: u8 = 5;
        // C s_5043_3: cast zx s_5043_2 -> bv
        let s_5043_3: Bits = Bits::new(s_5043_2 as u128, 3u16);
        // D s_5043_4: cmp-eq s_5043_1 s_5043_3
        let s_5043_4: bool = ((s_5043_1) == (s_5043_3));
        // D s_5043_5: write-var gs#135027 <= s_5043_4
        fn_state.gs_135027 = s_5043_4;
        // N s_5043_6: jump b1232
        return block_1232(state, tracer, fn_state);
    }
    fn block_5044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5044_0: read-var opc1:u8
        let s_5044_0: u8 = fn_state.opc1;
        // D s_5044_1: cast zx s_5044_0 -> bv
        let s_5044_1: Bits = Bits::new(s_5044_0 as u128, 3u16);
        // C s_5044_2: const #4u : u8
        let s_5044_2: u8 = 4;
        // C s_5044_3: cast zx s_5044_2 -> bv
        let s_5044_3: Bits = Bits::new(s_5044_2 as u128, 3u16);
        // D s_5044_4: cmp-eq s_5044_1 s_5044_3
        let s_5044_4: bool = ((s_5044_1) == (s_5044_3));
        // D s_5044_5: write-var gs#135026 <= s_5044_4
        fn_state.gs_135026 = s_5044_4;
        // N s_5044_6: jump b1230
        return block_1230(state, tracer, fn_state);
    }
    fn block_5045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5045_0: read-var coproc:u8
        let s_5045_0: u8 = fn_state.coproc;
        // D s_5045_1: cast zx s_5045_0 -> bv
        let s_5045_1: Bits = Bits::new(s_5045_0 as u128, 4u16);
        // C s_5045_2: const #15u : u8
        let s_5045_2: u8 = 15;
        // C s_5045_3: cast zx s_5045_2 -> bv
        let s_5045_3: Bits = Bits::new(s_5045_2 as u128, 4u16);
        // D s_5045_4: cmp-eq s_5045_1 s_5045_3
        let s_5045_4: bool = ((s_5045_1) == (s_5045_3));
        // D s_5045_5: write-var gs#135025 <= s_5045_4
        fn_state.gs_135025 = s_5045_4;
        // N s_5045_6: jump b1228
        return block_1228(state, tracer, fn_state);
    }
    fn block_5046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5046_0: read-var CRn:u8
        let s_5046_0: u8 = fn_state.CRn;
        // D s_5046_1: cast zx s_5046_0 -> bv
        let s_5046_1: Bits = Bits::new(s_5046_0 as u128, 4u16);
        // C s_5046_2: const #8u : u8
        let s_5046_2: u8 = 8;
        // C s_5046_3: cast zx s_5046_2 -> bv
        let s_5046_3: Bits = Bits::new(s_5046_2 as u128, 4u16);
        // D s_5046_4: cmp-eq s_5046_1 s_5046_3
        let s_5046_4: bool = ((s_5046_1) == (s_5046_3));
        // D s_5046_5: write-var gs#135024 <= s_5046_4
        fn_state.gs_135024 = s_5046_4;
        // N s_5046_6: jump b1226
        return block_1226(state, tracer, fn_state);
    }
    fn block_5047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5047_0: read-var el:u8
        let s_5047_0: u8 = fn_state.el;
        // D s_5047_1: read-var coproc:u8
        let s_5047_1: u8 = fn_state.coproc;
        // D s_5047_2: read-var opc1:u8
        let s_5047_2: u8 = fn_state.opc1;
        // D s_5047_3: read-var CRn:u8
        let s_5047_3: u8 = fn_state.CRn;
        // D s_5047_4: read-var opc2:u8
        let s_5047_4: u8 = fn_state.opc2;
        // D s_5047_5: read-var CRm:u8
        let s_5047_5: u8 = fn_state.CRm;
        // D s_5047_6: read-var t:i
        let s_5047_6: i128 = fn_state.t;
        // D s_5047_7: call ATS1CUR_SysRegWrite32_592c369d819e223e(s_5047_0, s_5047_1, s_5047_2, s_5047_3, s_5047_4, s_5047_5, s_5047_6)
        let s_5047_7: () = ATS1CUR_SysRegWrite32_592c369d819e223e(
            state,
            tracer,
            s_5047_0,
            s_5047_1,
            s_5047_2,
            s_5047_3,
            s_5047_4,
            s_5047_5,
            s_5047_6,
        );
        // N s_5047_8: return
        return;
    }
    fn block_5048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5048_0: read-var opc2:u8
        let s_5048_0: u8 = fn_state.opc2;
        // D s_5048_1: cast zx s_5048_0 -> bv
        let s_5048_1: Bits = Bits::new(s_5048_0 as u128, 3u16);
        // C s_5048_2: const #2u : u8
        let s_5048_2: u8 = 2;
        // C s_5048_3: cast zx s_5048_2 -> bv
        let s_5048_3: Bits = Bits::new(s_5048_2 as u128, 3u16);
        // D s_5048_4: cmp-eq s_5048_1 s_5048_3
        let s_5048_4: bool = ((s_5048_1) == (s_5048_3));
        // D s_5048_5: write-var gs#135023 <= s_5048_4
        fn_state.gs_135023 = s_5048_4;
        // N s_5048_6: jump b1223
        return block_1223(state, tracer, fn_state);
    }
    fn block_5049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5049_0: read-var opc1:u8
        let s_5049_0: u8 = fn_state.opc1;
        // D s_5049_1: cast zx s_5049_0 -> bv
        let s_5049_1: Bits = Bits::new(s_5049_0 as u128, 3u16);
        // C s_5049_2: const #0u : u8
        let s_5049_2: u8 = 0;
        // C s_5049_3: cast zx s_5049_2 -> bv
        let s_5049_3: Bits = Bits::new(s_5049_2 as u128, 3u16);
        // D s_5049_4: cmp-eq s_5049_1 s_5049_3
        let s_5049_4: bool = ((s_5049_1) == (s_5049_3));
        // D s_5049_5: write-var gs#135022 <= s_5049_4
        fn_state.gs_135022 = s_5049_4;
        // N s_5049_6: jump b1221
        return block_1221(state, tracer, fn_state);
    }
    fn block_5050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5050_0: read-var coproc:u8
        let s_5050_0: u8 = fn_state.coproc;
        // D s_5050_1: cast zx s_5050_0 -> bv
        let s_5050_1: Bits = Bits::new(s_5050_0 as u128, 4u16);
        // C s_5050_2: const #15u : u8
        let s_5050_2: u8 = 15;
        // C s_5050_3: cast zx s_5050_2 -> bv
        let s_5050_3: Bits = Bits::new(s_5050_2 as u128, 4u16);
        // D s_5050_4: cmp-eq s_5050_1 s_5050_3
        let s_5050_4: bool = ((s_5050_1) == (s_5050_3));
        // D s_5050_5: write-var gs#135021 <= s_5050_4
        fn_state.gs_135021 = s_5050_4;
        // N s_5050_6: jump b1219
        return block_1219(state, tracer, fn_state);
    }
    fn block_5051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5051_0: read-var CRn:u8
        let s_5051_0: u8 = fn_state.CRn;
        // D s_5051_1: cast zx s_5051_0 -> bv
        let s_5051_1: Bits = Bits::new(s_5051_0 as u128, 4u16);
        // C s_5051_2: const #7u : u8
        let s_5051_2: u8 = 7;
        // C s_5051_3: cast zx s_5051_2 -> bv
        let s_5051_3: Bits = Bits::new(s_5051_2 as u128, 4u16);
        // D s_5051_4: cmp-eq s_5051_1 s_5051_3
        let s_5051_4: bool = ((s_5051_1) == (s_5051_3));
        // D s_5051_5: write-var gs#135020 <= s_5051_4
        fn_state.gs_135020 = s_5051_4;
        // N s_5051_6: jump b1217
        return block_1217(state, tracer, fn_state);
    }
    fn block_5052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5052_0: read-var el:u8
        let s_5052_0: u8 = fn_state.el;
        // D s_5052_1: read-var coproc:u8
        let s_5052_1: u8 = fn_state.coproc;
        // D s_5052_2: read-var opc1:u8
        let s_5052_2: u8 = fn_state.opc1;
        // D s_5052_3: read-var CRn:u8
        let s_5052_3: u8 = fn_state.CRn;
        // D s_5052_4: read-var opc2:u8
        let s_5052_4: u8 = fn_state.opc2;
        // D s_5052_5: read-var CRm:u8
        let s_5052_5: u8 = fn_state.CRm;
        // D s_5052_6: read-var t:i
        let s_5052_6: i128 = fn_state.t;
        // D s_5052_7: call TLBIASIDIS_SysRegWrite32_03d2fed54ae109c3(s_5052_0, s_5052_1, s_5052_2, s_5052_3, s_5052_4, s_5052_5, s_5052_6)
        let s_5052_7: () = TLBIASIDIS_SysRegWrite32_03d2fed54ae109c3(
            state,
            tracer,
            s_5052_0,
            s_5052_1,
            s_5052_2,
            s_5052_3,
            s_5052_4,
            s_5052_5,
            s_5052_6,
        );
        // N s_5052_8: return
        return;
    }
    fn block_5053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5053_0: read-var opc2:u8
        let s_5053_0: u8 = fn_state.opc2;
        // D s_5053_1: cast zx s_5053_0 -> bv
        let s_5053_1: Bits = Bits::new(s_5053_0 as u128, 3u16);
        // C s_5053_2: const #2u : u8
        let s_5053_2: u8 = 2;
        // C s_5053_3: cast zx s_5053_2 -> bv
        let s_5053_3: Bits = Bits::new(s_5053_2 as u128, 3u16);
        // D s_5053_4: cmp-eq s_5053_1 s_5053_3
        let s_5053_4: bool = ((s_5053_1) == (s_5053_3));
        // D s_5053_5: write-var gs#135019 <= s_5053_4
        fn_state.gs_135019 = s_5053_4;
        // N s_5053_6: jump b1214
        return block_1214(state, tracer, fn_state);
    }
    fn block_5054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5054_0: read-var opc1:u8
        let s_5054_0: u8 = fn_state.opc1;
        // D s_5054_1: cast zx s_5054_0 -> bv
        let s_5054_1: Bits = Bits::new(s_5054_0 as u128, 3u16);
        // C s_5054_2: const #0u : u8
        let s_5054_2: u8 = 0;
        // C s_5054_3: cast zx s_5054_2 -> bv
        let s_5054_3: Bits = Bits::new(s_5054_2 as u128, 3u16);
        // D s_5054_4: cmp-eq s_5054_1 s_5054_3
        let s_5054_4: bool = ((s_5054_1) == (s_5054_3));
        // D s_5054_5: write-var gs#135018 <= s_5054_4
        fn_state.gs_135018 = s_5054_4;
        // N s_5054_6: jump b1212
        return block_1212(state, tracer, fn_state);
    }
    fn block_5055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5055_0: read-var coproc:u8
        let s_5055_0: u8 = fn_state.coproc;
        // D s_5055_1: cast zx s_5055_0 -> bv
        let s_5055_1: Bits = Bits::new(s_5055_0 as u128, 4u16);
        // C s_5055_2: const #15u : u8
        let s_5055_2: u8 = 15;
        // C s_5055_3: cast zx s_5055_2 -> bv
        let s_5055_3: Bits = Bits::new(s_5055_2 as u128, 4u16);
        // D s_5055_4: cmp-eq s_5055_1 s_5055_3
        let s_5055_4: bool = ((s_5055_1) == (s_5055_3));
        // D s_5055_5: write-var gs#135017 <= s_5055_4
        fn_state.gs_135017 = s_5055_4;
        // N s_5055_6: jump b1210
        return block_1210(state, tracer, fn_state);
    }
    fn block_5056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5056_0: read-var CRn:u8
        let s_5056_0: u8 = fn_state.CRn;
        // D s_5056_1: cast zx s_5056_0 -> bv
        let s_5056_1: Bits = Bits::new(s_5056_0 as u128, 4u16);
        // C s_5056_2: const #8u : u8
        let s_5056_2: u8 = 8;
        // C s_5056_3: cast zx s_5056_2 -> bv
        let s_5056_3: Bits = Bits::new(s_5056_2 as u128, 4u16);
        // D s_5056_4: cmp-eq s_5056_1 s_5056_3
        let s_5056_4: bool = ((s_5056_1) == (s_5056_3));
        // D s_5056_5: write-var gs#135016 <= s_5056_4
        fn_state.gs_135016 = s_5056_4;
        // N s_5056_6: jump b1208
        return block_1208(state, tracer, fn_state);
    }
    fn block_5057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5057_0: read-var el:u8
        let s_5057_0: u8 = fn_state.el;
        // D s_5057_1: read-var coproc:u8
        let s_5057_1: u8 = fn_state.coproc;
        // D s_5057_2: read-var opc1:u8
        let s_5057_2: u8 = fn_state.opc1;
        // D s_5057_3: read-var CRn:u8
        let s_5057_3: u8 = fn_state.CRn;
        // D s_5057_4: read-var opc2:u8
        let s_5057_4: u8 = fn_state.opc2;
        // D s_5057_5: read-var CRm:u8
        let s_5057_5: u8 = fn_state.CRm;
        // D s_5057_6: read-var t:i
        let s_5057_6: i128 = fn_state.t;
        // D s_5057_7: call DBGVCR_SysRegWrite32_fc44294faccd3e66(s_5057_0, s_5057_1, s_5057_2, s_5057_3, s_5057_4, s_5057_5, s_5057_6)
        let s_5057_7: () = DBGVCR_SysRegWrite32_fc44294faccd3e66(
            state,
            tracer,
            s_5057_0,
            s_5057_1,
            s_5057_2,
            s_5057_3,
            s_5057_4,
            s_5057_5,
            s_5057_6,
        );
        // N s_5057_8: return
        return;
    }
    fn block_5058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5058_0: read-var opc2:u8
        let s_5058_0: u8 = fn_state.opc2;
        // D s_5058_1: cast zx s_5058_0 -> bv
        let s_5058_1: Bits = Bits::new(s_5058_0 as u128, 3u16);
        // C s_5058_2: const #0u : u8
        let s_5058_2: u8 = 0;
        // C s_5058_3: cast zx s_5058_2 -> bv
        let s_5058_3: Bits = Bits::new(s_5058_2 as u128, 3u16);
        // D s_5058_4: cmp-eq s_5058_1 s_5058_3
        let s_5058_4: bool = ((s_5058_1) == (s_5058_3));
        // D s_5058_5: write-var gs#135015 <= s_5058_4
        fn_state.gs_135015 = s_5058_4;
        // N s_5058_6: jump b1205
        return block_1205(state, tracer, fn_state);
    }
    fn block_5059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5059_0: read-var opc1:u8
        let s_5059_0: u8 = fn_state.opc1;
        // D s_5059_1: cast zx s_5059_0 -> bv
        let s_5059_1: Bits = Bits::new(s_5059_0 as u128, 3u16);
        // C s_5059_2: const #0u : u8
        let s_5059_2: u8 = 0;
        // C s_5059_3: cast zx s_5059_2 -> bv
        let s_5059_3: Bits = Bits::new(s_5059_2 as u128, 3u16);
        // D s_5059_4: cmp-eq s_5059_1 s_5059_3
        let s_5059_4: bool = ((s_5059_1) == (s_5059_3));
        // D s_5059_5: write-var gs#135014 <= s_5059_4
        fn_state.gs_135014 = s_5059_4;
        // N s_5059_6: jump b1203
        return block_1203(state, tracer, fn_state);
    }
    fn block_5060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5060_0: read-var coproc:u8
        let s_5060_0: u8 = fn_state.coproc;
        // D s_5060_1: cast zx s_5060_0 -> bv
        let s_5060_1: Bits = Bits::new(s_5060_0 as u128, 4u16);
        // C s_5060_2: const #14u : u8
        let s_5060_2: u8 = 14;
        // C s_5060_3: cast zx s_5060_2 -> bv
        let s_5060_3: Bits = Bits::new(s_5060_2 as u128, 4u16);
        // D s_5060_4: cmp-eq s_5060_1 s_5060_3
        let s_5060_4: bool = ((s_5060_1) == (s_5060_3));
        // D s_5060_5: write-var gs#135013 <= s_5060_4
        fn_state.gs_135013 = s_5060_4;
        // N s_5060_6: jump b1201
        return block_1201(state, tracer, fn_state);
    }
    fn block_5061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5061_0: read-var CRn:u8
        let s_5061_0: u8 = fn_state.CRn;
        // D s_5061_1: cast zx s_5061_0 -> bv
        let s_5061_1: Bits = Bits::new(s_5061_0 as u128, 4u16);
        // C s_5061_2: const #0u : u8
        let s_5061_2: u8 = 0;
        // C s_5061_3: cast zx s_5061_2 -> bv
        let s_5061_3: Bits = Bits::new(s_5061_2 as u128, 4u16);
        // D s_5061_4: cmp-eq s_5061_1 s_5061_3
        let s_5061_4: bool = ((s_5061_1) == (s_5061_3));
        // D s_5061_5: write-var gs#135012 <= s_5061_4
        fn_state.gs_135012 = s_5061_4;
        // N s_5061_6: jump b1199
        return block_1199(state, tracer, fn_state);
    }
    fn block_5062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5062_0: read-var el:u8
        let s_5062_0: u8 = fn_state.el;
        // D s_5062_1: read-var coproc:u8
        let s_5062_1: u8 = fn_state.coproc;
        // D s_5062_2: read-var opc1:u8
        let s_5062_2: u8 = fn_state.opc1;
        // D s_5062_3: read-var CRn:u8
        let s_5062_3: u8 = fn_state.CRn;
        // D s_5062_4: read-var opc2:u8
        let s_5062_4: u8 = fn_state.opc2;
        // D s_5062_5: read-var CRm:u8
        let s_5062_5: u8 = fn_state.CRm;
        // D s_5062_6: read-var t:i
        let s_5062_6: i128 = fn_state.t;
        // D s_5062_7: call CNTHCTL_SysRegWrite32_7d97fc0c6abe59e3(s_5062_0, s_5062_1, s_5062_2, s_5062_3, s_5062_4, s_5062_5, s_5062_6)
        let s_5062_7: () = CNTHCTL_SysRegWrite32_7d97fc0c6abe59e3(
            state,
            tracer,
            s_5062_0,
            s_5062_1,
            s_5062_2,
            s_5062_3,
            s_5062_4,
            s_5062_5,
            s_5062_6,
        );
        // N s_5062_8: return
        return;
    }
    fn block_5063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5063_0: read-var opc2:u8
        let s_5063_0: u8 = fn_state.opc2;
        // D s_5063_1: cast zx s_5063_0 -> bv
        let s_5063_1: Bits = Bits::new(s_5063_0 as u128, 3u16);
        // C s_5063_2: const #0u : u8
        let s_5063_2: u8 = 0;
        // C s_5063_3: cast zx s_5063_2 -> bv
        let s_5063_3: Bits = Bits::new(s_5063_2 as u128, 3u16);
        // D s_5063_4: cmp-eq s_5063_1 s_5063_3
        let s_5063_4: bool = ((s_5063_1) == (s_5063_3));
        // D s_5063_5: write-var gs#135011 <= s_5063_4
        fn_state.gs_135011 = s_5063_4;
        // N s_5063_6: jump b1196
        return block_1196(state, tracer, fn_state);
    }
    fn block_5064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5064_0: read-var opc1:u8
        let s_5064_0: u8 = fn_state.opc1;
        // D s_5064_1: cast zx s_5064_0 -> bv
        let s_5064_1: Bits = Bits::new(s_5064_0 as u128, 3u16);
        // C s_5064_2: const #4u : u8
        let s_5064_2: u8 = 4;
        // C s_5064_3: cast zx s_5064_2 -> bv
        let s_5064_3: Bits = Bits::new(s_5064_2 as u128, 3u16);
        // D s_5064_4: cmp-eq s_5064_1 s_5064_3
        let s_5064_4: bool = ((s_5064_1) == (s_5064_3));
        // D s_5064_5: write-var gs#135010 <= s_5064_4
        fn_state.gs_135010 = s_5064_4;
        // N s_5064_6: jump b1194
        return block_1194(state, tracer, fn_state);
    }
    fn block_5065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5065_0: read-var coproc:u8
        let s_5065_0: u8 = fn_state.coproc;
        // D s_5065_1: cast zx s_5065_0 -> bv
        let s_5065_1: Bits = Bits::new(s_5065_0 as u128, 4u16);
        // C s_5065_2: const #15u : u8
        let s_5065_2: u8 = 15;
        // C s_5065_3: cast zx s_5065_2 -> bv
        let s_5065_3: Bits = Bits::new(s_5065_2 as u128, 4u16);
        // D s_5065_4: cmp-eq s_5065_1 s_5065_3
        let s_5065_4: bool = ((s_5065_1) == (s_5065_3));
        // D s_5065_5: write-var gs#135009 <= s_5065_4
        fn_state.gs_135009 = s_5065_4;
        // N s_5065_6: jump b1192
        return block_1192(state, tracer, fn_state);
    }
    fn block_5066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5066_0: read-var CRn:u8
        let s_5066_0: u8 = fn_state.CRn;
        // D s_5066_1: cast zx s_5066_0 -> bv
        let s_5066_1: Bits = Bits::new(s_5066_0 as u128, 4u16);
        // C s_5066_2: const #14u : u8
        let s_5066_2: u8 = 14;
        // C s_5066_3: cast zx s_5066_2 -> bv
        let s_5066_3: Bits = Bits::new(s_5066_2 as u128, 4u16);
        // D s_5066_4: cmp-eq s_5066_1 s_5066_3
        let s_5066_4: bool = ((s_5066_1) == (s_5066_3));
        // D s_5066_5: write-var gs#135008 <= s_5066_4
        fn_state.gs_135008 = s_5066_4;
        // N s_5066_6: jump b1190
        return block_1190(state, tracer, fn_state);
    }
    fn block_5067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5067_0: read-var el:u8
        let s_5067_0: u8 = fn_state.el;
        // D s_5067_1: read-var coproc:u8
        let s_5067_1: u8 = fn_state.coproc;
        // D s_5067_2: read-var opc1:u8
        let s_5067_2: u8 = fn_state.opc1;
        // D s_5067_3: read-var CRn:u8
        let s_5067_3: u8 = fn_state.CRn;
        // D s_5067_4: read-var opc2:u8
        let s_5067_4: u8 = fn_state.opc2;
        // D s_5067_5: read-var CRm:u8
        let s_5067_5: u8 = fn_state.CRm;
        // D s_5067_6: read-var t:i
        let s_5067_6: i128 = fn_state.t;
        // D s_5067_7: call ATS12NSOPW_SysRegWrite32_ed16ee3eca6aefe5(s_5067_0, s_5067_1, s_5067_2, s_5067_3, s_5067_4, s_5067_5, s_5067_6)
        let s_5067_7: () = ATS12NSOPW_SysRegWrite32_ed16ee3eca6aefe5(
            state,
            tracer,
            s_5067_0,
            s_5067_1,
            s_5067_2,
            s_5067_3,
            s_5067_4,
            s_5067_5,
            s_5067_6,
        );
        // N s_5067_8: return
        return;
    }
    fn block_5068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5068_0: read-var opc2:u8
        let s_5068_0: u8 = fn_state.opc2;
        // D s_5068_1: cast zx s_5068_0 -> bv
        let s_5068_1: Bits = Bits::new(s_5068_0 as u128, 3u16);
        // C s_5068_2: const #5u : u8
        let s_5068_2: u8 = 5;
        // C s_5068_3: cast zx s_5068_2 -> bv
        let s_5068_3: Bits = Bits::new(s_5068_2 as u128, 3u16);
        // D s_5068_4: cmp-eq s_5068_1 s_5068_3
        let s_5068_4: bool = ((s_5068_1) == (s_5068_3));
        // D s_5068_5: write-var gs#135007 <= s_5068_4
        fn_state.gs_135007 = s_5068_4;
        // N s_5068_6: jump b1187
        return block_1187(state, tracer, fn_state);
    }
    fn block_5069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5069_0: read-var opc1:u8
        let s_5069_0: u8 = fn_state.opc1;
        // D s_5069_1: cast zx s_5069_0 -> bv
        let s_5069_1: Bits = Bits::new(s_5069_0 as u128, 3u16);
        // C s_5069_2: const #0u : u8
        let s_5069_2: u8 = 0;
        // C s_5069_3: cast zx s_5069_2 -> bv
        let s_5069_3: Bits = Bits::new(s_5069_2 as u128, 3u16);
        // D s_5069_4: cmp-eq s_5069_1 s_5069_3
        let s_5069_4: bool = ((s_5069_1) == (s_5069_3));
        // D s_5069_5: write-var gs#135006 <= s_5069_4
        fn_state.gs_135006 = s_5069_4;
        // N s_5069_6: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_5070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5070_0: read-var coproc:u8
        let s_5070_0: u8 = fn_state.coproc;
        // D s_5070_1: cast zx s_5070_0 -> bv
        let s_5070_1: Bits = Bits::new(s_5070_0 as u128, 4u16);
        // C s_5070_2: const #15u : u8
        let s_5070_2: u8 = 15;
        // C s_5070_3: cast zx s_5070_2 -> bv
        let s_5070_3: Bits = Bits::new(s_5070_2 as u128, 4u16);
        // D s_5070_4: cmp-eq s_5070_1 s_5070_3
        let s_5070_4: bool = ((s_5070_1) == (s_5070_3));
        // D s_5070_5: write-var gs#135005 <= s_5070_4
        fn_state.gs_135005 = s_5070_4;
        // N s_5070_6: jump b1183
        return block_1183(state, tracer, fn_state);
    }
    fn block_5071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5071_0: read-var CRn:u8
        let s_5071_0: u8 = fn_state.CRn;
        // D s_5071_1: cast zx s_5071_0 -> bv
        let s_5071_1: Bits = Bits::new(s_5071_0 as u128, 4u16);
        // C s_5071_2: const #7u : u8
        let s_5071_2: u8 = 7;
        // C s_5071_3: cast zx s_5071_2 -> bv
        let s_5071_3: Bits = Bits::new(s_5071_2 as u128, 4u16);
        // D s_5071_4: cmp-eq s_5071_1 s_5071_3
        let s_5071_4: bool = ((s_5071_1) == (s_5071_3));
        // D s_5071_5: write-var gs#135004 <= s_5071_4
        fn_state.gs_135004 = s_5071_4;
        // N s_5071_6: jump b1181
        return block_1181(state, tracer, fn_state);
    }
    fn block_5072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5072_0: read-var el:u8
        let s_5072_0: u8 = fn_state.el;
        // D s_5072_1: read-var coproc:u8
        let s_5072_1: u8 = fn_state.coproc;
        // D s_5072_2: read-var opc1:u8
        let s_5072_2: u8 = fn_state.opc1;
        // D s_5072_3: read-var CRn:u8
        let s_5072_3: u8 = fn_state.CRn;
        // D s_5072_4: read-var opc2:u8
        let s_5072_4: u8 = fn_state.opc2;
        // D s_5072_5: read-var CRm:u8
        let s_5072_5: u8 = fn_state.CRm;
        // D s_5072_6: read-var t:i
        let s_5072_6: i128 = fn_state.t;
        // D s_5072_7: call ADFSR_SysRegWrite32_750ccc4b21c14510(s_5072_0, s_5072_1, s_5072_2, s_5072_3, s_5072_4, s_5072_5, s_5072_6)
        let s_5072_7: () = ADFSR_SysRegWrite32_750ccc4b21c14510(
            state,
            tracer,
            s_5072_0,
            s_5072_1,
            s_5072_2,
            s_5072_3,
            s_5072_4,
            s_5072_5,
            s_5072_6,
        );
        // N s_5072_8: return
        return;
    }
    fn block_5073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5073_0: read-var opc2:u8
        let s_5073_0: u8 = fn_state.opc2;
        // D s_5073_1: cast zx s_5073_0 -> bv
        let s_5073_1: Bits = Bits::new(s_5073_0 as u128, 3u16);
        // C s_5073_2: const #0u : u8
        let s_5073_2: u8 = 0;
        // C s_5073_3: cast zx s_5073_2 -> bv
        let s_5073_3: Bits = Bits::new(s_5073_2 as u128, 3u16);
        // D s_5073_4: cmp-eq s_5073_1 s_5073_3
        let s_5073_4: bool = ((s_5073_1) == (s_5073_3));
        // D s_5073_5: write-var gs#135003 <= s_5073_4
        fn_state.gs_135003 = s_5073_4;
        // N s_5073_6: jump b1178
        return block_1178(state, tracer, fn_state);
    }
    fn block_5074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5074_0: read-var opc1:u8
        let s_5074_0: u8 = fn_state.opc1;
        // D s_5074_1: cast zx s_5074_0 -> bv
        let s_5074_1: Bits = Bits::new(s_5074_0 as u128, 3u16);
        // C s_5074_2: const #0u : u8
        let s_5074_2: u8 = 0;
        // C s_5074_3: cast zx s_5074_2 -> bv
        let s_5074_3: Bits = Bits::new(s_5074_2 as u128, 3u16);
        // D s_5074_4: cmp-eq s_5074_1 s_5074_3
        let s_5074_4: bool = ((s_5074_1) == (s_5074_3));
        // D s_5074_5: write-var gs#135002 <= s_5074_4
        fn_state.gs_135002 = s_5074_4;
        // N s_5074_6: jump b1176
        return block_1176(state, tracer, fn_state);
    }
    fn block_5075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5075_0: read-var coproc:u8
        let s_5075_0: u8 = fn_state.coproc;
        // D s_5075_1: cast zx s_5075_0 -> bv
        let s_5075_1: Bits = Bits::new(s_5075_0 as u128, 4u16);
        // C s_5075_2: const #15u : u8
        let s_5075_2: u8 = 15;
        // C s_5075_3: cast zx s_5075_2 -> bv
        let s_5075_3: Bits = Bits::new(s_5075_2 as u128, 4u16);
        // D s_5075_4: cmp-eq s_5075_1 s_5075_3
        let s_5075_4: bool = ((s_5075_1) == (s_5075_3));
        // D s_5075_5: write-var gs#135001 <= s_5075_4
        fn_state.gs_135001 = s_5075_4;
        // N s_5075_6: jump b1174
        return block_1174(state, tracer, fn_state);
    }
    fn block_5076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5076_0: read-var CRn:u8
        let s_5076_0: u8 = fn_state.CRn;
        // D s_5076_1: cast zx s_5076_0 -> bv
        let s_5076_1: Bits = Bits::new(s_5076_0 as u128, 4u16);
        // C s_5076_2: const #5u : u8
        let s_5076_2: u8 = 5;
        // C s_5076_3: cast zx s_5076_2 -> bv
        let s_5076_3: Bits = Bits::new(s_5076_2 as u128, 4u16);
        // D s_5076_4: cmp-eq s_5076_1 s_5076_3
        let s_5076_4: bool = ((s_5076_1) == (s_5076_3));
        // D s_5076_5: write-var gs#135000 <= s_5076_4
        fn_state.gs_135000 = s_5076_4;
        // N s_5076_6: jump b1172
        return block_1172(state, tracer, fn_state);
    }
    fn block_5077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5077_0: read-var el:u8
        let s_5077_0: u8 = fn_state.el;
        // D s_5077_1: read-var coproc:u8
        let s_5077_1: u8 = fn_state.coproc;
        // D s_5077_2: read-var opc1:u8
        let s_5077_2: u8 = fn_state.opc1;
        // D s_5077_3: read-var CRn:u8
        let s_5077_3: u8 = fn_state.CRn;
        // D s_5077_4: read-var opc2:u8
        let s_5077_4: u8 = fn_state.opc2;
        // D s_5077_5: read-var CRm:u8
        let s_5077_5: u8 = fn_state.CRm;
        // D s_5077_6: read-var t:i
        let s_5077_6: i128 = fn_state.t;
        // D s_5077_7: call ICV_AP1R_SysRegWrite32_fcd6d6e80a079de9(s_5077_0, s_5077_1, s_5077_2, s_5077_3, s_5077_4, s_5077_5, s_5077_6)
        let s_5077_7: () = ICV_AP1R_SysRegWrite32_fcd6d6e80a079de9(
            state,
            tracer,
            s_5077_0,
            s_5077_1,
            s_5077_2,
            s_5077_3,
            s_5077_4,
            s_5077_5,
            s_5077_6,
        );
        // N s_5077_8: return
        return;
    }
    fn block_5078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5078_0: read-var opc2:u8
        let s_5078_0: u8 = fn_state.opc2;
        // D s_5078_1: cast zx s_5078_0 -> bv
        let s_5078_1: Bits = Bits::new(s_5078_0 as u128, 3u16);
        // C s_5078_2: const #0u : u8
        let s_5078_2: u8 = 0;
        // C s_5078_3: cast zx s_5078_2 -> bv
        let s_5078_3: Bits = Bits::new(s_5078_2 as u128, 3u16);
        // D s_5078_4: cmp-eq s_5078_1 s_5078_3
        let s_5078_4: bool = ((s_5078_1) == (s_5078_3));
        // D s_5078_5: write-var gs#134999 <= s_5078_4
        fn_state.gs_134999 = s_5078_4;
        // N s_5078_6: jump b1169
        return block_1169(state, tracer, fn_state);
    }
    fn block_5079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5079_0: read-var opc1:u8
        let s_5079_0: u8 = fn_state.opc1;
        // D s_5079_1: cast zx s_5079_0 -> bv
        let s_5079_1: Bits = Bits::new(s_5079_0 as u128, 3u16);
        // C s_5079_2: const #0u : u8
        let s_5079_2: u8 = 0;
        // C s_5079_3: cast zx s_5079_2 -> bv
        let s_5079_3: Bits = Bits::new(s_5079_2 as u128, 3u16);
        // D s_5079_4: cmp-eq s_5079_1 s_5079_3
        let s_5079_4: bool = ((s_5079_1) == (s_5079_3));
        // D s_5079_5: write-var gs#134998 <= s_5079_4
        fn_state.gs_134998 = s_5079_4;
        // N s_5079_6: jump b1167
        return block_1167(state, tracer, fn_state);
    }
    fn block_5080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5080_0: read-var coproc:u8
        let s_5080_0: u8 = fn_state.coproc;
        // D s_5080_1: cast zx s_5080_0 -> bv
        let s_5080_1: Bits = Bits::new(s_5080_0 as u128, 4u16);
        // C s_5080_2: const #15u : u8
        let s_5080_2: u8 = 15;
        // C s_5080_3: cast zx s_5080_2 -> bv
        let s_5080_3: Bits = Bits::new(s_5080_2 as u128, 4u16);
        // D s_5080_4: cmp-eq s_5080_1 s_5080_3
        let s_5080_4: bool = ((s_5080_1) == (s_5080_3));
        // D s_5080_5: write-var gs#134997 <= s_5080_4
        fn_state.gs_134997 = s_5080_4;
        // N s_5080_6: jump b1165
        return block_1165(state, tracer, fn_state);
    }
    fn block_5081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5081_0: read-var CRn:u8
        let s_5081_0: u8 = fn_state.CRn;
        // D s_5081_1: cast zx s_5081_0 -> bv
        let s_5081_1: Bits = Bits::new(s_5081_0 as u128, 4u16);
        // C s_5081_2: const #12u : u8
        let s_5081_2: u8 = 12;
        // C s_5081_3: cast zx s_5081_2 -> bv
        let s_5081_3: Bits = Bits::new(s_5081_2 as u128, 4u16);
        // D s_5081_4: cmp-eq s_5081_1 s_5081_3
        let s_5081_4: bool = ((s_5081_1) == (s_5081_3));
        // D s_5081_5: write-var gs#134996 <= s_5081_4
        fn_state.gs_134996 = s_5081_4;
        // N s_5081_6: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_5082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5082_0: read-var el:u8
        let s_5082_0: u8 = fn_state.el;
        // D s_5082_1: read-var coproc:u8
        let s_5082_1: u8 = fn_state.coproc;
        // D s_5082_2: read-var opc1:u8
        let s_5082_2: u8 = fn_state.opc1;
        // D s_5082_3: read-var CRn:u8
        let s_5082_3: u8 = fn_state.CRn;
        // D s_5082_4: read-var opc2:u8
        let s_5082_4: u8 = fn_state.opc2;
        // D s_5082_5: read-var CRm:u8
        let s_5082_5: u8 = fn_state.CRm;
        // D s_5082_6: read-var t:i
        let s_5082_6: i128 = fn_state.t;
        // D s_5082_7: call ICV_AP1R_SysRegWrite32_4f1e8bd1c2644b3a(s_5082_0, s_5082_1, s_5082_2, s_5082_3, s_5082_4, s_5082_5, s_5082_6)
        let s_5082_7: () = ICV_AP1R_SysRegWrite32_4f1e8bd1c2644b3a(
            state,
            tracer,
            s_5082_0,
            s_5082_1,
            s_5082_2,
            s_5082_3,
            s_5082_4,
            s_5082_5,
            s_5082_6,
        );
        // N s_5082_8: return
        return;
    }
    fn block_5083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5083_0: read-var opc2:u8
        let s_5083_0: u8 = fn_state.opc2;
        // D s_5083_1: cast zx s_5083_0 -> bv
        let s_5083_1: Bits = Bits::new(s_5083_0 as u128, 3u16);
        // C s_5083_2: const #1u : u8
        let s_5083_2: u8 = 1;
        // C s_5083_3: cast zx s_5083_2 -> bv
        let s_5083_3: Bits = Bits::new(s_5083_2 as u128, 3u16);
        // D s_5083_4: cmp-eq s_5083_1 s_5083_3
        let s_5083_4: bool = ((s_5083_1) == (s_5083_3));
        // D s_5083_5: write-var gs#134995 <= s_5083_4
        fn_state.gs_134995 = s_5083_4;
        // N s_5083_6: jump b1160
        return block_1160(state, tracer, fn_state);
    }
    fn block_5084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5084_0: read-var opc1:u8
        let s_5084_0: u8 = fn_state.opc1;
        // D s_5084_1: cast zx s_5084_0 -> bv
        let s_5084_1: Bits = Bits::new(s_5084_0 as u128, 3u16);
        // C s_5084_2: const #0u : u8
        let s_5084_2: u8 = 0;
        // C s_5084_3: cast zx s_5084_2 -> bv
        let s_5084_3: Bits = Bits::new(s_5084_2 as u128, 3u16);
        // D s_5084_4: cmp-eq s_5084_1 s_5084_3
        let s_5084_4: bool = ((s_5084_1) == (s_5084_3));
        // D s_5084_5: write-var gs#134994 <= s_5084_4
        fn_state.gs_134994 = s_5084_4;
        // N s_5084_6: jump b1158
        return block_1158(state, tracer, fn_state);
    }
    fn block_5085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5085_0: read-var coproc:u8
        let s_5085_0: u8 = fn_state.coproc;
        // D s_5085_1: cast zx s_5085_0 -> bv
        let s_5085_1: Bits = Bits::new(s_5085_0 as u128, 4u16);
        // C s_5085_2: const #15u : u8
        let s_5085_2: u8 = 15;
        // C s_5085_3: cast zx s_5085_2 -> bv
        let s_5085_3: Bits = Bits::new(s_5085_2 as u128, 4u16);
        // D s_5085_4: cmp-eq s_5085_1 s_5085_3
        let s_5085_4: bool = ((s_5085_1) == (s_5085_3));
        // D s_5085_5: write-var gs#134993 <= s_5085_4
        fn_state.gs_134993 = s_5085_4;
        // N s_5085_6: jump b1156
        return block_1156(state, tracer, fn_state);
    }
    fn block_5086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5086_0: read-var CRn:u8
        let s_5086_0: u8 = fn_state.CRn;
        // D s_5086_1: cast zx s_5086_0 -> bv
        let s_5086_1: Bits = Bits::new(s_5086_0 as u128, 4u16);
        // C s_5086_2: const #12u : u8
        let s_5086_2: u8 = 12;
        // C s_5086_3: cast zx s_5086_2 -> bv
        let s_5086_3: Bits = Bits::new(s_5086_2 as u128, 4u16);
        // D s_5086_4: cmp-eq s_5086_1 s_5086_3
        let s_5086_4: bool = ((s_5086_1) == (s_5086_3));
        // D s_5086_5: write-var gs#134992 <= s_5086_4
        fn_state.gs_134992 = s_5086_4;
        // N s_5086_6: jump b1154
        return block_1154(state, tracer, fn_state);
    }
    fn block_5087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5087_0: read-var el:u8
        let s_5087_0: u8 = fn_state.el;
        // D s_5087_1: read-var coproc:u8
        let s_5087_1: u8 = fn_state.coproc;
        // D s_5087_2: read-var opc1:u8
        let s_5087_2: u8 = fn_state.opc1;
        // D s_5087_3: read-var CRn:u8
        let s_5087_3: u8 = fn_state.CRn;
        // D s_5087_4: read-var opc2:u8
        let s_5087_4: u8 = fn_state.opc2;
        // D s_5087_5: read-var CRm:u8
        let s_5087_5: u8 = fn_state.CRm;
        // D s_5087_6: read-var t:i
        let s_5087_6: i128 = fn_state.t;
        // D s_5087_7: call ICV_AP1R_SysRegWrite32_726e2b6e8a63f123(s_5087_0, s_5087_1, s_5087_2, s_5087_3, s_5087_4, s_5087_5, s_5087_6)
        let s_5087_7: () = ICV_AP1R_SysRegWrite32_726e2b6e8a63f123(
            state,
            tracer,
            s_5087_0,
            s_5087_1,
            s_5087_2,
            s_5087_3,
            s_5087_4,
            s_5087_5,
            s_5087_6,
        );
        // N s_5087_8: return
        return;
    }
    fn block_5088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5088_0: read-var opc2:u8
        let s_5088_0: u8 = fn_state.opc2;
        // D s_5088_1: cast zx s_5088_0 -> bv
        let s_5088_1: Bits = Bits::new(s_5088_0 as u128, 3u16);
        // C s_5088_2: const #2u : u8
        let s_5088_2: u8 = 2;
        // C s_5088_3: cast zx s_5088_2 -> bv
        let s_5088_3: Bits = Bits::new(s_5088_2 as u128, 3u16);
        // D s_5088_4: cmp-eq s_5088_1 s_5088_3
        let s_5088_4: bool = ((s_5088_1) == (s_5088_3));
        // D s_5088_5: write-var gs#134991 <= s_5088_4
        fn_state.gs_134991 = s_5088_4;
        // N s_5088_6: jump b1151
        return block_1151(state, tracer, fn_state);
    }
    fn block_5089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5089_0: read-var opc1:u8
        let s_5089_0: u8 = fn_state.opc1;
        // D s_5089_1: cast zx s_5089_0 -> bv
        let s_5089_1: Bits = Bits::new(s_5089_0 as u128, 3u16);
        // C s_5089_2: const #0u : u8
        let s_5089_2: u8 = 0;
        // C s_5089_3: cast zx s_5089_2 -> bv
        let s_5089_3: Bits = Bits::new(s_5089_2 as u128, 3u16);
        // D s_5089_4: cmp-eq s_5089_1 s_5089_3
        let s_5089_4: bool = ((s_5089_1) == (s_5089_3));
        // D s_5089_5: write-var gs#134990 <= s_5089_4
        fn_state.gs_134990 = s_5089_4;
        // N s_5089_6: jump b1149
        return block_1149(state, tracer, fn_state);
    }
    fn block_5090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5090_0: read-var coproc:u8
        let s_5090_0: u8 = fn_state.coproc;
        // D s_5090_1: cast zx s_5090_0 -> bv
        let s_5090_1: Bits = Bits::new(s_5090_0 as u128, 4u16);
        // C s_5090_2: const #15u : u8
        let s_5090_2: u8 = 15;
        // C s_5090_3: cast zx s_5090_2 -> bv
        let s_5090_3: Bits = Bits::new(s_5090_2 as u128, 4u16);
        // D s_5090_4: cmp-eq s_5090_1 s_5090_3
        let s_5090_4: bool = ((s_5090_1) == (s_5090_3));
        // D s_5090_5: write-var gs#134989 <= s_5090_4
        fn_state.gs_134989 = s_5090_4;
        // N s_5090_6: jump b1147
        return block_1147(state, tracer, fn_state);
    }
    fn block_5091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5091_0: read-var CRn:u8
        let s_5091_0: u8 = fn_state.CRn;
        // D s_5091_1: cast zx s_5091_0 -> bv
        let s_5091_1: Bits = Bits::new(s_5091_0 as u128, 4u16);
        // C s_5091_2: const #12u : u8
        let s_5091_2: u8 = 12;
        // C s_5091_3: cast zx s_5091_2 -> bv
        let s_5091_3: Bits = Bits::new(s_5091_2 as u128, 4u16);
        // D s_5091_4: cmp-eq s_5091_1 s_5091_3
        let s_5091_4: bool = ((s_5091_1) == (s_5091_3));
        // D s_5091_5: write-var gs#134988 <= s_5091_4
        fn_state.gs_134988 = s_5091_4;
        // N s_5091_6: jump b1145
        return block_1145(state, tracer, fn_state);
    }
    fn block_5092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5092_0: read-var el:u8
        let s_5092_0: u8 = fn_state.el;
        // D s_5092_1: read-var coproc:u8
        let s_5092_1: u8 = fn_state.coproc;
        // D s_5092_2: read-var opc1:u8
        let s_5092_2: u8 = fn_state.opc1;
        // D s_5092_3: read-var CRn:u8
        let s_5092_3: u8 = fn_state.CRn;
        // D s_5092_4: read-var opc2:u8
        let s_5092_4: u8 = fn_state.opc2;
        // D s_5092_5: read-var CRm:u8
        let s_5092_5: u8 = fn_state.CRm;
        // D s_5092_6: read-var t:i
        let s_5092_6: i128 = fn_state.t;
        // D s_5092_7: call ICV_AP1R_SysRegWrite32_f4f5f3a432a35847(s_5092_0, s_5092_1, s_5092_2, s_5092_3, s_5092_4, s_5092_5, s_5092_6)
        let s_5092_7: () = ICV_AP1R_SysRegWrite32_f4f5f3a432a35847(
            state,
            tracer,
            s_5092_0,
            s_5092_1,
            s_5092_2,
            s_5092_3,
            s_5092_4,
            s_5092_5,
            s_5092_6,
        );
        // N s_5092_8: return
        return;
    }
    fn block_5093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5093_0: read-var opc2:u8
        let s_5093_0: u8 = fn_state.opc2;
        // D s_5093_1: cast zx s_5093_0 -> bv
        let s_5093_1: Bits = Bits::new(s_5093_0 as u128, 3u16);
        // C s_5093_2: const #3u : u8
        let s_5093_2: u8 = 3;
        // C s_5093_3: cast zx s_5093_2 -> bv
        let s_5093_3: Bits = Bits::new(s_5093_2 as u128, 3u16);
        // D s_5093_4: cmp-eq s_5093_1 s_5093_3
        let s_5093_4: bool = ((s_5093_1) == (s_5093_3));
        // D s_5093_5: write-var gs#134987 <= s_5093_4
        fn_state.gs_134987 = s_5093_4;
        // N s_5093_6: jump b1142
        return block_1142(state, tracer, fn_state);
    }
    fn block_5094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5094_0: read-var opc1:u8
        let s_5094_0: u8 = fn_state.opc1;
        // D s_5094_1: cast zx s_5094_0 -> bv
        let s_5094_1: Bits = Bits::new(s_5094_0 as u128, 3u16);
        // C s_5094_2: const #0u : u8
        let s_5094_2: u8 = 0;
        // C s_5094_3: cast zx s_5094_2 -> bv
        let s_5094_3: Bits = Bits::new(s_5094_2 as u128, 3u16);
        // D s_5094_4: cmp-eq s_5094_1 s_5094_3
        let s_5094_4: bool = ((s_5094_1) == (s_5094_3));
        // D s_5094_5: write-var gs#134986 <= s_5094_4
        fn_state.gs_134986 = s_5094_4;
        // N s_5094_6: jump b1140
        return block_1140(state, tracer, fn_state);
    }
    fn block_5095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5095_0: read-var coproc:u8
        let s_5095_0: u8 = fn_state.coproc;
        // D s_5095_1: cast zx s_5095_0 -> bv
        let s_5095_1: Bits = Bits::new(s_5095_0 as u128, 4u16);
        // C s_5095_2: const #15u : u8
        let s_5095_2: u8 = 15;
        // C s_5095_3: cast zx s_5095_2 -> bv
        let s_5095_3: Bits = Bits::new(s_5095_2 as u128, 4u16);
        // D s_5095_4: cmp-eq s_5095_1 s_5095_3
        let s_5095_4: bool = ((s_5095_1) == (s_5095_3));
        // D s_5095_5: write-var gs#134985 <= s_5095_4
        fn_state.gs_134985 = s_5095_4;
        // N s_5095_6: jump b1138
        return block_1138(state, tracer, fn_state);
    }
    fn block_5096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5096_0: read-var CRn:u8
        let s_5096_0: u8 = fn_state.CRn;
        // D s_5096_1: cast zx s_5096_0 -> bv
        let s_5096_1: Bits = Bits::new(s_5096_0 as u128, 4u16);
        // C s_5096_2: const #12u : u8
        let s_5096_2: u8 = 12;
        // C s_5096_3: cast zx s_5096_2 -> bv
        let s_5096_3: Bits = Bits::new(s_5096_2 as u128, 4u16);
        // D s_5096_4: cmp-eq s_5096_1 s_5096_3
        let s_5096_4: bool = ((s_5096_1) == (s_5096_3));
        // D s_5096_5: write-var gs#134984 <= s_5096_4
        fn_state.gs_134984 = s_5096_4;
        // N s_5096_6: jump b1136
        return block_1136(state, tracer, fn_state);
    }
    fn block_5097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5097_0: read-var el:u8
        let s_5097_0: u8 = fn_state.el;
        // D s_5097_1: read-var coproc:u8
        let s_5097_1: u8 = fn_state.coproc;
        // D s_5097_2: read-var opc1:u8
        let s_5097_2: u8 = fn_state.opc1;
        // D s_5097_3: read-var CRn:u8
        let s_5097_3: u8 = fn_state.CRn;
        // D s_5097_4: read-var opc2:u8
        let s_5097_4: u8 = fn_state.opc2;
        // D s_5097_5: read-var CRm:u8
        let s_5097_5: u8 = fn_state.CRm;
        // D s_5097_6: read-var t:i
        let s_5097_6: i128 = fn_state.t;
        // D s_5097_7: call ICC_BPR0_SysRegWrite32_953ba2861abee74a(s_5097_0, s_5097_1, s_5097_2, s_5097_3, s_5097_4, s_5097_5, s_5097_6)
        let s_5097_7: () = ICC_BPR0_SysRegWrite32_953ba2861abee74a(
            state,
            tracer,
            s_5097_0,
            s_5097_1,
            s_5097_2,
            s_5097_3,
            s_5097_4,
            s_5097_5,
            s_5097_6,
        );
        // N s_5097_8: return
        return;
    }
    fn block_5098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5098_0: read-var opc2:u8
        let s_5098_0: u8 = fn_state.opc2;
        // D s_5098_1: cast zx s_5098_0 -> bv
        let s_5098_1: Bits = Bits::new(s_5098_0 as u128, 3u16);
        // C s_5098_2: const #3u : u8
        let s_5098_2: u8 = 3;
        // C s_5098_3: cast zx s_5098_2 -> bv
        let s_5098_3: Bits = Bits::new(s_5098_2 as u128, 3u16);
        // D s_5098_4: cmp-eq s_5098_1 s_5098_3
        let s_5098_4: bool = ((s_5098_1) == (s_5098_3));
        // D s_5098_5: write-var gs#134983 <= s_5098_4
        fn_state.gs_134983 = s_5098_4;
        // N s_5098_6: jump b1133
        return block_1133(state, tracer, fn_state);
    }
    fn block_5099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5099_0: read-var opc1:u8
        let s_5099_0: u8 = fn_state.opc1;
        // D s_5099_1: cast zx s_5099_0 -> bv
        let s_5099_1: Bits = Bits::new(s_5099_0 as u128, 3u16);
        // C s_5099_2: const #0u : u8
        let s_5099_2: u8 = 0;
        // C s_5099_3: cast zx s_5099_2 -> bv
        let s_5099_3: Bits = Bits::new(s_5099_2 as u128, 3u16);
        // D s_5099_4: cmp-eq s_5099_1 s_5099_3
        let s_5099_4: bool = ((s_5099_1) == (s_5099_3));
        // D s_5099_5: write-var gs#134982 <= s_5099_4
        fn_state.gs_134982 = s_5099_4;
        // N s_5099_6: jump b1131
        return block_1131(state, tracer, fn_state);
    }
    fn block_5100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5100_0: read-var coproc:u8
        let s_5100_0: u8 = fn_state.coproc;
        // D s_5100_1: cast zx s_5100_0 -> bv
        let s_5100_1: Bits = Bits::new(s_5100_0 as u128, 4u16);
        // C s_5100_2: const #15u : u8
        let s_5100_2: u8 = 15;
        // C s_5100_3: cast zx s_5100_2 -> bv
        let s_5100_3: Bits = Bits::new(s_5100_2 as u128, 4u16);
        // D s_5100_4: cmp-eq s_5100_1 s_5100_3
        let s_5100_4: bool = ((s_5100_1) == (s_5100_3));
        // D s_5100_5: write-var gs#134981 <= s_5100_4
        fn_state.gs_134981 = s_5100_4;
        // N s_5100_6: jump b1129
        return block_1129(state, tracer, fn_state);
    }
    fn block_5101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5101_0: read-var CRn:u8
        let s_5101_0: u8 = fn_state.CRn;
        // D s_5101_1: cast zx s_5101_0 -> bv
        let s_5101_1: Bits = Bits::new(s_5101_0 as u128, 4u16);
        // C s_5101_2: const #12u : u8
        let s_5101_2: u8 = 12;
        // C s_5101_3: cast zx s_5101_2 -> bv
        let s_5101_3: Bits = Bits::new(s_5101_2 as u128, 4u16);
        // D s_5101_4: cmp-eq s_5101_1 s_5101_3
        let s_5101_4: bool = ((s_5101_1) == (s_5101_3));
        // D s_5101_5: write-var gs#134980 <= s_5101_4
        fn_state.gs_134980 = s_5101_4;
        // N s_5101_6: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_5102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5102_0: read-var el:u8
        let s_5102_0: u8 = fn_state.el;
        // D s_5102_1: read-var coproc:u8
        let s_5102_1: u8 = fn_state.coproc;
        // D s_5102_2: read-var opc1:u8
        let s_5102_2: u8 = fn_state.opc1;
        // D s_5102_3: read-var CRn:u8
        let s_5102_3: u8 = fn_state.CRn;
        // D s_5102_4: read-var opc2:u8
        let s_5102_4: u8 = fn_state.opc2;
        // D s_5102_5: read-var CRm:u8
        let s_5102_5: u8 = fn_state.CRm;
        // D s_5102_6: read-var t:i
        let s_5102_6: i128 = fn_state.t;
        // D s_5102_7: call TPIDRURW_SysRegWrite32_cb192fad8255358c(s_5102_0, s_5102_1, s_5102_2, s_5102_3, s_5102_4, s_5102_5, s_5102_6)
        let s_5102_7: () = TPIDRURW_SysRegWrite32_cb192fad8255358c(
            state,
            tracer,
            s_5102_0,
            s_5102_1,
            s_5102_2,
            s_5102_3,
            s_5102_4,
            s_5102_5,
            s_5102_6,
        );
        // N s_5102_8: return
        return;
    }
    fn block_5103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5103_0: read-var opc2:u8
        let s_5103_0: u8 = fn_state.opc2;
        // D s_5103_1: cast zx s_5103_0 -> bv
        let s_5103_1: Bits = Bits::new(s_5103_0 as u128, 3u16);
        // C s_5103_2: const #2u : u8
        let s_5103_2: u8 = 2;
        // C s_5103_3: cast zx s_5103_2 -> bv
        let s_5103_3: Bits = Bits::new(s_5103_2 as u128, 3u16);
        // D s_5103_4: cmp-eq s_5103_1 s_5103_3
        let s_5103_4: bool = ((s_5103_1) == (s_5103_3));
        // D s_5103_5: write-var gs#134979 <= s_5103_4
        fn_state.gs_134979 = s_5103_4;
        // N s_5103_6: jump b1124
        return block_1124(state, tracer, fn_state);
    }
    fn block_5104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5104_0: read-var opc1:u8
        let s_5104_0: u8 = fn_state.opc1;
        // D s_5104_1: cast zx s_5104_0 -> bv
        let s_5104_1: Bits = Bits::new(s_5104_0 as u128, 3u16);
        // C s_5104_2: const #0u : u8
        let s_5104_2: u8 = 0;
        // C s_5104_3: cast zx s_5104_2 -> bv
        let s_5104_3: Bits = Bits::new(s_5104_2 as u128, 3u16);
        // D s_5104_4: cmp-eq s_5104_1 s_5104_3
        let s_5104_4: bool = ((s_5104_1) == (s_5104_3));
        // D s_5104_5: write-var gs#134978 <= s_5104_4
        fn_state.gs_134978 = s_5104_4;
        // N s_5104_6: jump b1122
        return block_1122(state, tracer, fn_state);
    }
    fn block_5105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5105_0: read-var coproc:u8
        let s_5105_0: u8 = fn_state.coproc;
        // D s_5105_1: cast zx s_5105_0 -> bv
        let s_5105_1: Bits = Bits::new(s_5105_0 as u128, 4u16);
        // C s_5105_2: const #15u : u8
        let s_5105_2: u8 = 15;
        // C s_5105_3: cast zx s_5105_2 -> bv
        let s_5105_3: Bits = Bits::new(s_5105_2 as u128, 4u16);
        // D s_5105_4: cmp-eq s_5105_1 s_5105_3
        let s_5105_4: bool = ((s_5105_1) == (s_5105_3));
        // D s_5105_5: write-var gs#134977 <= s_5105_4
        fn_state.gs_134977 = s_5105_4;
        // N s_5105_6: jump b1120
        return block_1120(state, tracer, fn_state);
    }
    fn block_5106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5106_0: read-var CRn:u8
        let s_5106_0: u8 = fn_state.CRn;
        // D s_5106_1: cast zx s_5106_0 -> bv
        let s_5106_1: Bits = Bits::new(s_5106_0 as u128, 4u16);
        // C s_5106_2: const #13u : u8
        let s_5106_2: u8 = 13;
        // C s_5106_3: cast zx s_5106_2 -> bv
        let s_5106_3: Bits = Bits::new(s_5106_2 as u128, 4u16);
        // D s_5106_4: cmp-eq s_5106_1 s_5106_3
        let s_5106_4: bool = ((s_5106_1) == (s_5106_3));
        // D s_5106_5: write-var gs#134976 <= s_5106_4
        fn_state.gs_134976 = s_5106_4;
        // N s_5106_6: jump b1118
        return block_1118(state, tracer, fn_state);
    }
    fn block_5107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5107_0: read-var el:u8
        let s_5107_0: u8 = fn_state.el;
        // D s_5107_1: read-var coproc:u8
        let s_5107_1: u8 = fn_state.coproc;
        // D s_5107_2: read-var opc1:u8
        let s_5107_2: u8 = fn_state.opc1;
        // D s_5107_3: read-var CRn:u8
        let s_5107_3: u8 = fn_state.CRn;
        // D s_5107_4: read-var opc2:u8
        let s_5107_4: u8 = fn_state.opc2;
        // D s_5107_5: read-var CRm:u8
        let s_5107_5: u8 = fn_state.CRm;
        // D s_5107_6: read-var t:i
        let s_5107_6: i128 = fn_state.t;
        // D s_5107_7: call ICC_EOIR1_SysRegWrite32_b67c881f4f810bd8(s_5107_0, s_5107_1, s_5107_2, s_5107_3, s_5107_4, s_5107_5, s_5107_6)
        let s_5107_7: () = ICC_EOIR1_SysRegWrite32_b67c881f4f810bd8(
            state,
            tracer,
            s_5107_0,
            s_5107_1,
            s_5107_2,
            s_5107_3,
            s_5107_4,
            s_5107_5,
            s_5107_6,
        );
        // N s_5107_8: return
        return;
    }
    fn block_5108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5108_0: read-var opc2:u8
        let s_5108_0: u8 = fn_state.opc2;
        // D s_5108_1: cast zx s_5108_0 -> bv
        let s_5108_1: Bits = Bits::new(s_5108_0 as u128, 3u16);
        // C s_5108_2: const #1u : u8
        let s_5108_2: u8 = 1;
        // C s_5108_3: cast zx s_5108_2 -> bv
        let s_5108_3: Bits = Bits::new(s_5108_2 as u128, 3u16);
        // D s_5108_4: cmp-eq s_5108_1 s_5108_3
        let s_5108_4: bool = ((s_5108_1) == (s_5108_3));
        // D s_5108_5: write-var gs#134975 <= s_5108_4
        fn_state.gs_134975 = s_5108_4;
        // N s_5108_6: jump b1115
        return block_1115(state, tracer, fn_state);
    }
    fn block_5109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5109_0: read-var opc1:u8
        let s_5109_0: u8 = fn_state.opc1;
        // D s_5109_1: cast zx s_5109_0 -> bv
        let s_5109_1: Bits = Bits::new(s_5109_0 as u128, 3u16);
        // C s_5109_2: const #0u : u8
        let s_5109_2: u8 = 0;
        // C s_5109_3: cast zx s_5109_2 -> bv
        let s_5109_3: Bits = Bits::new(s_5109_2 as u128, 3u16);
        // D s_5109_4: cmp-eq s_5109_1 s_5109_3
        let s_5109_4: bool = ((s_5109_1) == (s_5109_3));
        // D s_5109_5: write-var gs#134974 <= s_5109_4
        fn_state.gs_134974 = s_5109_4;
        // N s_5109_6: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_5110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5110_0: read-var coproc:u8
        let s_5110_0: u8 = fn_state.coproc;
        // D s_5110_1: cast zx s_5110_0 -> bv
        let s_5110_1: Bits = Bits::new(s_5110_0 as u128, 4u16);
        // C s_5110_2: const #15u : u8
        let s_5110_2: u8 = 15;
        // C s_5110_3: cast zx s_5110_2 -> bv
        let s_5110_3: Bits = Bits::new(s_5110_2 as u128, 4u16);
        // D s_5110_4: cmp-eq s_5110_1 s_5110_3
        let s_5110_4: bool = ((s_5110_1) == (s_5110_3));
        // D s_5110_5: write-var gs#134973 <= s_5110_4
        fn_state.gs_134973 = s_5110_4;
        // N s_5110_6: jump b1111
        return block_1111(state, tracer, fn_state);
    }
    fn block_5111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5111_0: read-var CRn:u8
        let s_5111_0: u8 = fn_state.CRn;
        // D s_5111_1: cast zx s_5111_0 -> bv
        let s_5111_1: Bits = Bits::new(s_5111_0 as u128, 4u16);
        // C s_5111_2: const #12u : u8
        let s_5111_2: u8 = 12;
        // C s_5111_3: cast zx s_5111_2 -> bv
        let s_5111_3: Bits = Bits::new(s_5111_2 as u128, 4u16);
        // D s_5111_4: cmp-eq s_5111_1 s_5111_3
        let s_5111_4: bool = ((s_5111_1) == (s_5111_3));
        // D s_5111_5: write-var gs#134972 <= s_5111_4
        fn_state.gs_134972 = s_5111_4;
        // N s_5111_6: jump b1109
        return block_1109(state, tracer, fn_state);
    }
    fn block_5112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5112_0: read-var el:u8
        let s_5112_0: u8 = fn_state.el;
        // D s_5112_1: read-var coproc:u8
        let s_5112_1: u8 = fn_state.coproc;
        // D s_5112_2: read-var opc1:u8
        let s_5112_2: u8 = fn_state.opc1;
        // D s_5112_3: read-var CRn:u8
        let s_5112_3: u8 = fn_state.CRn;
        // D s_5112_4: read-var opc2:u8
        let s_5112_4: u8 = fn_state.opc2;
        // D s_5112_5: read-var CRm:u8
        let s_5112_5: u8 = fn_state.CRm;
        // D s_5112_6: read-var t:i
        let s_5112_6: i128 = fn_state.t;
        // D s_5112_7: call SDER_SysRegWrite32_78d36c9dd1d8d07c(s_5112_0, s_5112_1, s_5112_2, s_5112_3, s_5112_4, s_5112_5, s_5112_6)
        let s_5112_7: () = SDER_SysRegWrite32_78d36c9dd1d8d07c(
            state,
            tracer,
            s_5112_0,
            s_5112_1,
            s_5112_2,
            s_5112_3,
            s_5112_4,
            s_5112_5,
            s_5112_6,
        );
        // N s_5112_8: return
        return;
    }
    fn block_5113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5113_0: read-var opc2:u8
        let s_5113_0: u8 = fn_state.opc2;
        // D s_5113_1: cast zx s_5113_0 -> bv
        let s_5113_1: Bits = Bits::new(s_5113_0 as u128, 3u16);
        // C s_5113_2: const #1u : u8
        let s_5113_2: u8 = 1;
        // C s_5113_3: cast zx s_5113_2 -> bv
        let s_5113_3: Bits = Bits::new(s_5113_2 as u128, 3u16);
        // D s_5113_4: cmp-eq s_5113_1 s_5113_3
        let s_5113_4: bool = ((s_5113_1) == (s_5113_3));
        // D s_5113_5: write-var gs#134971 <= s_5113_4
        fn_state.gs_134971 = s_5113_4;
        // N s_5113_6: jump b1106
        return block_1106(state, tracer, fn_state);
    }
    fn block_5114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5114_0: read-var opc1:u8
        let s_5114_0: u8 = fn_state.opc1;
        // D s_5114_1: cast zx s_5114_0 -> bv
        let s_5114_1: Bits = Bits::new(s_5114_0 as u128, 3u16);
        // C s_5114_2: const #0u : u8
        let s_5114_2: u8 = 0;
        // C s_5114_3: cast zx s_5114_2 -> bv
        let s_5114_3: Bits = Bits::new(s_5114_2 as u128, 3u16);
        // D s_5114_4: cmp-eq s_5114_1 s_5114_3
        let s_5114_4: bool = ((s_5114_1) == (s_5114_3));
        // D s_5114_5: write-var gs#134970 <= s_5114_4
        fn_state.gs_134970 = s_5114_4;
        // N s_5114_6: jump b1104
        return block_1104(state, tracer, fn_state);
    }
    fn block_5115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5115_0: read-var coproc:u8
        let s_5115_0: u8 = fn_state.coproc;
        // D s_5115_1: cast zx s_5115_0 -> bv
        let s_5115_1: Bits = Bits::new(s_5115_0 as u128, 4u16);
        // C s_5115_2: const #15u : u8
        let s_5115_2: u8 = 15;
        // C s_5115_3: cast zx s_5115_2 -> bv
        let s_5115_3: Bits = Bits::new(s_5115_2 as u128, 4u16);
        // D s_5115_4: cmp-eq s_5115_1 s_5115_3
        let s_5115_4: bool = ((s_5115_1) == (s_5115_3));
        // D s_5115_5: write-var gs#134969 <= s_5115_4
        fn_state.gs_134969 = s_5115_4;
        // N s_5115_6: jump b1102
        return block_1102(state, tracer, fn_state);
    }
    fn block_5116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5116_0: read-var CRn:u8
        let s_5116_0: u8 = fn_state.CRn;
        // D s_5116_1: cast zx s_5116_0 -> bv
        let s_5116_1: Bits = Bits::new(s_5116_0 as u128, 4u16);
        // C s_5116_2: const #1u : u8
        let s_5116_2: u8 = 1;
        // C s_5116_3: cast zx s_5116_2 -> bv
        let s_5116_3: Bits = Bits::new(s_5116_2 as u128, 4u16);
        // D s_5116_4: cmp-eq s_5116_1 s_5116_3
        let s_5116_4: bool = ((s_5116_1) == (s_5116_3));
        // D s_5116_5: write-var gs#134968 <= s_5116_4
        fn_state.gs_134968 = s_5116_4;
        // N s_5116_6: jump b1100
        return block_1100(state, tracer, fn_state);
    }
    fn block_5117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5117_0: read-var el:u8
        let s_5117_0: u8 = fn_state.el;
        // D s_5117_1: read-var coproc:u8
        let s_5117_1: u8 = fn_state.coproc;
        // D s_5117_2: read-var opc1:u8
        let s_5117_2: u8 = fn_state.opc1;
        // D s_5117_3: read-var CRn:u8
        let s_5117_3: u8 = fn_state.CRn;
        // D s_5117_4: read-var opc2:u8
        let s_5117_4: u8 = fn_state.opc2;
        // D s_5117_5: read-var CRm:u8
        let s_5117_5: u8 = fn_state.CRm;
        // D s_5117_6: read-var t:i
        let s_5117_6: i128 = fn_state.t;
        // D s_5117_7: call DBGPRCR_SysRegWrite32_99fa790871277002(s_5117_0, s_5117_1, s_5117_2, s_5117_3, s_5117_4, s_5117_5, s_5117_6)
        let s_5117_7: () = DBGPRCR_SysRegWrite32_99fa790871277002(
            state,
            tracer,
            s_5117_0,
            s_5117_1,
            s_5117_2,
            s_5117_3,
            s_5117_4,
            s_5117_5,
            s_5117_6,
        );
        // N s_5117_8: return
        return;
    }
    fn block_5118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5118_0: read-var opc2:u8
        let s_5118_0: u8 = fn_state.opc2;
        // D s_5118_1: cast zx s_5118_0 -> bv
        let s_5118_1: Bits = Bits::new(s_5118_0 as u128, 3u16);
        // C s_5118_2: const #4u : u8
        let s_5118_2: u8 = 4;
        // C s_5118_3: cast zx s_5118_2 -> bv
        let s_5118_3: Bits = Bits::new(s_5118_2 as u128, 3u16);
        // D s_5118_4: cmp-eq s_5118_1 s_5118_3
        let s_5118_4: bool = ((s_5118_1) == (s_5118_3));
        // D s_5118_5: write-var gs#134967 <= s_5118_4
        fn_state.gs_134967 = s_5118_4;
        // N s_5118_6: jump b1097
        return block_1097(state, tracer, fn_state);
    }
    fn block_5119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5119_0: read-var opc1:u8
        let s_5119_0: u8 = fn_state.opc1;
        // D s_5119_1: cast zx s_5119_0 -> bv
        let s_5119_1: Bits = Bits::new(s_5119_0 as u128, 3u16);
        // C s_5119_2: const #0u : u8
        let s_5119_2: u8 = 0;
        // C s_5119_3: cast zx s_5119_2 -> bv
        let s_5119_3: Bits = Bits::new(s_5119_2 as u128, 3u16);
        // D s_5119_4: cmp-eq s_5119_1 s_5119_3
        let s_5119_4: bool = ((s_5119_1) == (s_5119_3));
        // D s_5119_5: write-var gs#134966 <= s_5119_4
        fn_state.gs_134966 = s_5119_4;
        // N s_5119_6: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_5120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5120_0: read-var coproc:u8
        let s_5120_0: u8 = fn_state.coproc;
        // D s_5120_1: cast zx s_5120_0 -> bv
        let s_5120_1: Bits = Bits::new(s_5120_0 as u128, 4u16);
        // C s_5120_2: const #14u : u8
        let s_5120_2: u8 = 14;
        // C s_5120_3: cast zx s_5120_2 -> bv
        let s_5120_3: Bits = Bits::new(s_5120_2 as u128, 4u16);
        // D s_5120_4: cmp-eq s_5120_1 s_5120_3
        let s_5120_4: bool = ((s_5120_1) == (s_5120_3));
        // D s_5120_5: write-var gs#134965 <= s_5120_4
        fn_state.gs_134965 = s_5120_4;
        // N s_5120_6: jump b1093
        return block_1093(state, tracer, fn_state);
    }
    fn block_5121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5121_0: read-var CRn:u8
        let s_5121_0: u8 = fn_state.CRn;
        // D s_5121_1: cast zx s_5121_0 -> bv
        let s_5121_1: Bits = Bits::new(s_5121_0 as u128, 4u16);
        // C s_5121_2: const #1u : u8
        let s_5121_2: u8 = 1;
        // C s_5121_3: cast zx s_5121_2 -> bv
        let s_5121_3: Bits = Bits::new(s_5121_2 as u128, 4u16);
        // D s_5121_4: cmp-eq s_5121_1 s_5121_3
        let s_5121_4: bool = ((s_5121_1) == (s_5121_3));
        // D s_5121_5: write-var gs#134964 <= s_5121_4
        fn_state.gs_134964 = s_5121_4;
        // N s_5121_6: jump b1091
        return block_1091(state, tracer, fn_state);
    }
    fn block_5122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5122_0: read-var el:u8
        let s_5122_0: u8 = fn_state.el;
        // D s_5122_1: read-var coproc:u8
        let s_5122_1: u8 = fn_state.coproc;
        // D s_5122_2: read-var opc1:u8
        let s_5122_2: u8 = fn_state.opc1;
        // D s_5122_3: read-var CRn:u8
        let s_5122_3: u8 = fn_state.CRn;
        // D s_5122_4: read-var opc2:u8
        let s_5122_4: u8 = fn_state.opc2;
        // D s_5122_5: read-var CRm:u8
        let s_5122_5: u8 = fn_state.CRm;
        // D s_5122_6: read-var t:i
        let s_5122_6: i128 = fn_state.t;
        // D s_5122_7: call TLBIMVA_SysRegWrite32_f66a0ca0f4cc9ff0(s_5122_0, s_5122_1, s_5122_2, s_5122_3, s_5122_4, s_5122_5, s_5122_6)
        let s_5122_7: () = TLBIMVA_SysRegWrite32_f66a0ca0f4cc9ff0(
            state,
            tracer,
            s_5122_0,
            s_5122_1,
            s_5122_2,
            s_5122_3,
            s_5122_4,
            s_5122_5,
            s_5122_6,
        );
        // N s_5122_8: return
        return;
    }
    fn block_5123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5123_0: read-var opc2:u8
        let s_5123_0: u8 = fn_state.opc2;
        // D s_5123_1: cast zx s_5123_0 -> bv
        let s_5123_1: Bits = Bits::new(s_5123_0 as u128, 3u16);
        // C s_5123_2: const #1u : u8
        let s_5123_2: u8 = 1;
        // C s_5123_3: cast zx s_5123_2 -> bv
        let s_5123_3: Bits = Bits::new(s_5123_2 as u128, 3u16);
        // D s_5123_4: cmp-eq s_5123_1 s_5123_3
        let s_5123_4: bool = ((s_5123_1) == (s_5123_3));
        // D s_5123_5: write-var gs#134963 <= s_5123_4
        fn_state.gs_134963 = s_5123_4;
        // N s_5123_6: jump b1088
        return block_1088(state, tracer, fn_state);
    }
    fn block_5124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5124_0: read-var opc1:u8
        let s_5124_0: u8 = fn_state.opc1;
        // D s_5124_1: cast zx s_5124_0 -> bv
        let s_5124_1: Bits = Bits::new(s_5124_0 as u128, 3u16);
        // C s_5124_2: const #0u : u8
        let s_5124_2: u8 = 0;
        // C s_5124_3: cast zx s_5124_2 -> bv
        let s_5124_3: Bits = Bits::new(s_5124_2 as u128, 3u16);
        // D s_5124_4: cmp-eq s_5124_1 s_5124_3
        let s_5124_4: bool = ((s_5124_1) == (s_5124_3));
        // D s_5124_5: write-var gs#134962 <= s_5124_4
        fn_state.gs_134962 = s_5124_4;
        // N s_5124_6: jump b1086
        return block_1086(state, tracer, fn_state);
    }
    fn block_5125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5125_0: read-var coproc:u8
        let s_5125_0: u8 = fn_state.coproc;
        // D s_5125_1: cast zx s_5125_0 -> bv
        let s_5125_1: Bits = Bits::new(s_5125_0 as u128, 4u16);
        // C s_5125_2: const #15u : u8
        let s_5125_2: u8 = 15;
        // C s_5125_3: cast zx s_5125_2 -> bv
        let s_5125_3: Bits = Bits::new(s_5125_2 as u128, 4u16);
        // D s_5125_4: cmp-eq s_5125_1 s_5125_3
        let s_5125_4: bool = ((s_5125_1) == (s_5125_3));
        // D s_5125_5: write-var gs#134961 <= s_5125_4
        fn_state.gs_134961 = s_5125_4;
        // N s_5125_6: jump b1084
        return block_1084(state, tracer, fn_state);
    }
    fn block_5126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5126_0: read-var CRn:u8
        let s_5126_0: u8 = fn_state.CRn;
        // D s_5126_1: cast zx s_5126_0 -> bv
        let s_5126_1: Bits = Bits::new(s_5126_0 as u128, 4u16);
        // C s_5126_2: const #8u : u8
        let s_5126_2: u8 = 8;
        // C s_5126_3: cast zx s_5126_2 -> bv
        let s_5126_3: Bits = Bits::new(s_5126_2 as u128, 4u16);
        // D s_5126_4: cmp-eq s_5126_1 s_5126_3
        let s_5126_4: bool = ((s_5126_1) == (s_5126_3));
        // D s_5126_5: write-var gs#134960 <= s_5126_4
        fn_state.gs_134960 = s_5126_4;
        // N s_5126_6: jump b1082
        return block_1082(state, tracer, fn_state);
    }
    fn block_5127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5127_0: read-var el:u8
        let s_5127_0: u8 = fn_state.el;
        // D s_5127_1: read-var coproc:u8
        let s_5127_1: u8 = fn_state.coproc;
        // D s_5127_2: read-var opc1:u8
        let s_5127_2: u8 = fn_state.opc1;
        // D s_5127_3: read-var CRn:u8
        let s_5127_3: u8 = fn_state.CRn;
        // D s_5127_4: read-var opc2:u8
        let s_5127_4: u8 = fn_state.opc2;
        // D s_5127_5: read-var CRm:u8
        let s_5127_5: u8 = fn_state.CRm;
        // D s_5127_6: read-var t:i
        let s_5127_6: i128 = fn_state.t;
        // D s_5127_7: call PMINTENCLR_SysRegWrite32_3861e4c2893d3032(s_5127_0, s_5127_1, s_5127_2, s_5127_3, s_5127_4, s_5127_5, s_5127_6)
        let s_5127_7: () = PMINTENCLR_SysRegWrite32_3861e4c2893d3032(
            state,
            tracer,
            s_5127_0,
            s_5127_1,
            s_5127_2,
            s_5127_3,
            s_5127_4,
            s_5127_5,
            s_5127_6,
        );
        // N s_5127_8: return
        return;
    }
    fn block_5128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5128_0: read-var opc2:u8
        let s_5128_0: u8 = fn_state.opc2;
        // D s_5128_1: cast zx s_5128_0 -> bv
        let s_5128_1: Bits = Bits::new(s_5128_0 as u128, 3u16);
        // C s_5128_2: const #2u : u8
        let s_5128_2: u8 = 2;
        // C s_5128_3: cast zx s_5128_2 -> bv
        let s_5128_3: Bits = Bits::new(s_5128_2 as u128, 3u16);
        // D s_5128_4: cmp-eq s_5128_1 s_5128_3
        let s_5128_4: bool = ((s_5128_1) == (s_5128_3));
        // D s_5128_5: write-var gs#134959 <= s_5128_4
        fn_state.gs_134959 = s_5128_4;
        // N s_5128_6: jump b1079
        return block_1079(state, tracer, fn_state);
    }
    fn block_5129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5129_0: read-var opc1:u8
        let s_5129_0: u8 = fn_state.opc1;
        // D s_5129_1: cast zx s_5129_0 -> bv
        let s_5129_1: Bits = Bits::new(s_5129_0 as u128, 3u16);
        // C s_5129_2: const #0u : u8
        let s_5129_2: u8 = 0;
        // C s_5129_3: cast zx s_5129_2 -> bv
        let s_5129_3: Bits = Bits::new(s_5129_2 as u128, 3u16);
        // D s_5129_4: cmp-eq s_5129_1 s_5129_3
        let s_5129_4: bool = ((s_5129_1) == (s_5129_3));
        // D s_5129_5: write-var gs#134958 <= s_5129_4
        fn_state.gs_134958 = s_5129_4;
        // N s_5129_6: jump b1077
        return block_1077(state, tracer, fn_state);
    }
    fn block_5130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5130_0: read-var coproc:u8
        let s_5130_0: u8 = fn_state.coproc;
        // D s_5130_1: cast zx s_5130_0 -> bv
        let s_5130_1: Bits = Bits::new(s_5130_0 as u128, 4u16);
        // C s_5130_2: const #15u : u8
        let s_5130_2: u8 = 15;
        // C s_5130_3: cast zx s_5130_2 -> bv
        let s_5130_3: Bits = Bits::new(s_5130_2 as u128, 4u16);
        // D s_5130_4: cmp-eq s_5130_1 s_5130_3
        let s_5130_4: bool = ((s_5130_1) == (s_5130_3));
        // D s_5130_5: write-var gs#134957 <= s_5130_4
        fn_state.gs_134957 = s_5130_4;
        // N s_5130_6: jump b1075
        return block_1075(state, tracer, fn_state);
    }
    fn block_5131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5131_0: read-var CRn:u8
        let s_5131_0: u8 = fn_state.CRn;
        // D s_5131_1: cast zx s_5131_0 -> bv
        let s_5131_1: Bits = Bits::new(s_5131_0 as u128, 4u16);
        // C s_5131_2: const #9u : u8
        let s_5131_2: u8 = 9;
        // C s_5131_3: cast zx s_5131_2 -> bv
        let s_5131_3: Bits = Bits::new(s_5131_2 as u128, 4u16);
        // D s_5131_4: cmp-eq s_5131_1 s_5131_3
        let s_5131_4: bool = ((s_5131_1) == (s_5131_3));
        // D s_5131_5: write-var gs#134956 <= s_5131_4
        fn_state.gs_134956 = s_5131_4;
        // N s_5131_6: jump b1073
        return block_1073(state, tracer, fn_state);
    }
    fn block_5132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5132_0: read-var el:u8
        let s_5132_0: u8 = fn_state.el;
        // D s_5132_1: read-var coproc:u8
        let s_5132_1: u8 = fn_state.coproc;
        // D s_5132_2: read-var opc1:u8
        let s_5132_2: u8 = fn_state.opc1;
        // D s_5132_3: read-var CRn:u8
        let s_5132_3: u8 = fn_state.CRn;
        // D s_5132_4: read-var opc2:u8
        let s_5132_4: u8 = fn_state.opc2;
        // D s_5132_5: read-var CRm:u8
        let s_5132_5: u8 = fn_state.CRm;
        // D s_5132_6: read-var t:i
        let s_5132_6: i128 = fn_state.t;
        // D s_5132_7: call VBAR_SysRegWrite32_bc2b5cd33d4ee53c(s_5132_0, s_5132_1, s_5132_2, s_5132_3, s_5132_4, s_5132_5, s_5132_6)
        let s_5132_7: () = VBAR_SysRegWrite32_bc2b5cd33d4ee53c(
            state,
            tracer,
            s_5132_0,
            s_5132_1,
            s_5132_2,
            s_5132_3,
            s_5132_4,
            s_5132_5,
            s_5132_6,
        );
        // N s_5132_8: return
        return;
    }
    fn block_5133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5133_0: read-var opc2:u8
        let s_5133_0: u8 = fn_state.opc2;
        // D s_5133_1: cast zx s_5133_0 -> bv
        let s_5133_1: Bits = Bits::new(s_5133_0 as u128, 3u16);
        // C s_5133_2: const #0u : u8
        let s_5133_2: u8 = 0;
        // C s_5133_3: cast zx s_5133_2 -> bv
        let s_5133_3: Bits = Bits::new(s_5133_2 as u128, 3u16);
        // D s_5133_4: cmp-eq s_5133_1 s_5133_3
        let s_5133_4: bool = ((s_5133_1) == (s_5133_3));
        // D s_5133_5: write-var gs#134955 <= s_5133_4
        fn_state.gs_134955 = s_5133_4;
        // N s_5133_6: jump b1070
        return block_1070(state, tracer, fn_state);
    }
    fn block_5134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5134_0: read-var opc1:u8
        let s_5134_0: u8 = fn_state.opc1;
        // D s_5134_1: cast zx s_5134_0 -> bv
        let s_5134_1: Bits = Bits::new(s_5134_0 as u128, 3u16);
        // C s_5134_2: const #0u : u8
        let s_5134_2: u8 = 0;
        // C s_5134_3: cast zx s_5134_2 -> bv
        let s_5134_3: Bits = Bits::new(s_5134_2 as u128, 3u16);
        // D s_5134_4: cmp-eq s_5134_1 s_5134_3
        let s_5134_4: bool = ((s_5134_1) == (s_5134_3));
        // D s_5134_5: write-var gs#134954 <= s_5134_4
        fn_state.gs_134954 = s_5134_4;
        // N s_5134_6: jump b1068
        return block_1068(state, tracer, fn_state);
    }
    fn block_5135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5135_0: read-var coproc:u8
        let s_5135_0: u8 = fn_state.coproc;
        // D s_5135_1: cast zx s_5135_0 -> bv
        let s_5135_1: Bits = Bits::new(s_5135_0 as u128, 4u16);
        // C s_5135_2: const #15u : u8
        let s_5135_2: u8 = 15;
        // C s_5135_3: cast zx s_5135_2 -> bv
        let s_5135_3: Bits = Bits::new(s_5135_2 as u128, 4u16);
        // D s_5135_4: cmp-eq s_5135_1 s_5135_3
        let s_5135_4: bool = ((s_5135_1) == (s_5135_3));
        // D s_5135_5: write-var gs#134953 <= s_5135_4
        fn_state.gs_134953 = s_5135_4;
        // N s_5135_6: jump b1066
        return block_1066(state, tracer, fn_state);
    }
    fn block_5136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5136_0: read-var CRn:u8
        let s_5136_0: u8 = fn_state.CRn;
        // D s_5136_1: cast zx s_5136_0 -> bv
        let s_5136_1: Bits = Bits::new(s_5136_0 as u128, 4u16);
        // C s_5136_2: const #12u : u8
        let s_5136_2: u8 = 12;
        // C s_5136_3: cast zx s_5136_2 -> bv
        let s_5136_3: Bits = Bits::new(s_5136_2 as u128, 4u16);
        // D s_5136_4: cmp-eq s_5136_1 s_5136_3
        let s_5136_4: bool = ((s_5136_1) == (s_5136_3));
        // D s_5136_5: write-var gs#134952 <= s_5136_4
        fn_state.gs_134952 = s_5136_4;
        // N s_5136_6: jump b1064
        return block_1064(state, tracer, fn_state);
    }
    fn block_5137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5137_0: read-var el:u8
        let s_5137_0: u8 = fn_state.el;
        // D s_5137_1: read-var coproc:u8
        let s_5137_1: u8 = fn_state.coproc;
        // D s_5137_2: read-var opc1:u8
        let s_5137_2: u8 = fn_state.opc1;
        // D s_5137_3: read-var CRn:u8
        let s_5137_3: u8 = fn_state.CRn;
        // D s_5137_4: read-var opc2:u8
        let s_5137_4: u8 = fn_state.opc2;
        // D s_5137_5: read-var CRm:u8
        let s_5137_5: u8 = fn_state.CRm;
        // D s_5137_6: read-var t:i
        let s_5137_6: i128 = fn_state.t;
        // D s_5137_7: call COSPRCTX_SysRegWrite32_4f4dd157b3f4905c(s_5137_0, s_5137_1, s_5137_2, s_5137_3, s_5137_4, s_5137_5, s_5137_6)
        let s_5137_7: () = COSPRCTX_SysRegWrite32_4f4dd157b3f4905c(
            state,
            tracer,
            s_5137_0,
            s_5137_1,
            s_5137_2,
            s_5137_3,
            s_5137_4,
            s_5137_5,
            s_5137_6,
        );
        // N s_5137_8: return
        return;
    }
    fn block_5138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5138_0: read-var opc2:u8
        let s_5138_0: u8 = fn_state.opc2;
        // D s_5138_1: cast zx s_5138_0 -> bv
        let s_5138_1: Bits = Bits::new(s_5138_0 as u128, 3u16);
        // C s_5138_2: const #6u : u8
        let s_5138_2: u8 = 6;
        // C s_5138_3: cast zx s_5138_2 -> bv
        let s_5138_3: Bits = Bits::new(s_5138_2 as u128, 3u16);
        // D s_5138_4: cmp-eq s_5138_1 s_5138_3
        let s_5138_4: bool = ((s_5138_1) == (s_5138_3));
        // D s_5138_5: write-var gs#134951 <= s_5138_4
        fn_state.gs_134951 = s_5138_4;
        // N s_5138_6: jump b1061
        return block_1061(state, tracer, fn_state);
    }
    fn block_5139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5139_0: read-var opc1:u8
        let s_5139_0: u8 = fn_state.opc1;
        // D s_5139_1: cast zx s_5139_0 -> bv
        let s_5139_1: Bits = Bits::new(s_5139_0 as u128, 3u16);
        // C s_5139_2: const #0u : u8
        let s_5139_2: u8 = 0;
        // C s_5139_3: cast zx s_5139_2 -> bv
        let s_5139_3: Bits = Bits::new(s_5139_2 as u128, 3u16);
        // D s_5139_4: cmp-eq s_5139_1 s_5139_3
        let s_5139_4: bool = ((s_5139_1) == (s_5139_3));
        // D s_5139_5: write-var gs#134950 <= s_5139_4
        fn_state.gs_134950 = s_5139_4;
        // N s_5139_6: jump b1059
        return block_1059(state, tracer, fn_state);
    }
    fn block_5140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5140_0: read-var coproc:u8
        let s_5140_0: u8 = fn_state.coproc;
        // D s_5140_1: cast zx s_5140_0 -> bv
        let s_5140_1: Bits = Bits::new(s_5140_0 as u128, 4u16);
        // C s_5140_2: const #15u : u8
        let s_5140_2: u8 = 15;
        // C s_5140_3: cast zx s_5140_2 -> bv
        let s_5140_3: Bits = Bits::new(s_5140_2 as u128, 4u16);
        // D s_5140_4: cmp-eq s_5140_1 s_5140_3
        let s_5140_4: bool = ((s_5140_1) == (s_5140_3));
        // D s_5140_5: write-var gs#134949 <= s_5140_4
        fn_state.gs_134949 = s_5140_4;
        // N s_5140_6: jump b1057
        return block_1057(state, tracer, fn_state);
    }
    fn block_5141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5141_0: read-var CRn:u8
        let s_5141_0: u8 = fn_state.CRn;
        // D s_5141_1: cast zx s_5141_0 -> bv
        let s_5141_1: Bits = Bits::new(s_5141_0 as u128, 4u16);
        // C s_5141_2: const #7u : u8
        let s_5141_2: u8 = 7;
        // C s_5141_3: cast zx s_5141_2 -> bv
        let s_5141_3: Bits = Bits::new(s_5141_2 as u128, 4u16);
        // D s_5141_4: cmp-eq s_5141_1 s_5141_3
        let s_5141_4: bool = ((s_5141_1) == (s_5141_3));
        // D s_5141_5: write-var gs#134948 <= s_5141_4
        fn_state.gs_134948 = s_5141_4;
        // N s_5141_6: jump b1055
        return block_1055(state, tracer, fn_state);
    }
    fn block_5142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5142_0: read-var el:u8
        let s_5142_0: u8 = fn_state.el;
        // D s_5142_1: read-var coproc:u8
        let s_5142_1: u8 = fn_state.coproc;
        // D s_5142_2: read-var opc1:u8
        let s_5142_2: u8 = fn_state.opc1;
        // D s_5142_3: read-var CRn:u8
        let s_5142_3: u8 = fn_state.CRn;
        // D s_5142_4: read-var opc2:u8
        let s_5142_4: u8 = fn_state.opc2;
        // D s_5142_5: read-var CRm:u8
        let s_5142_5: u8 = fn_state.CRm;
        // D s_5142_6: read-var t:i
        let s_5142_6: i128 = fn_state.t;
        // D s_5142_7: call PMXEVTYPER_SysRegWrite32_853b58a36392d331(s_5142_0, s_5142_1, s_5142_2, s_5142_3, s_5142_4, s_5142_5, s_5142_6)
        let s_5142_7: () = PMXEVTYPER_SysRegWrite32_853b58a36392d331(
            state,
            tracer,
            s_5142_0,
            s_5142_1,
            s_5142_2,
            s_5142_3,
            s_5142_4,
            s_5142_5,
            s_5142_6,
        );
        // N s_5142_8: return
        return;
    }
    fn block_5143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5143_0: read-var opc2:u8
        let s_5143_0: u8 = fn_state.opc2;
        // D s_5143_1: cast zx s_5143_0 -> bv
        let s_5143_1: Bits = Bits::new(s_5143_0 as u128, 3u16);
        // C s_5143_2: const #1u : u8
        let s_5143_2: u8 = 1;
        // C s_5143_3: cast zx s_5143_2 -> bv
        let s_5143_3: Bits = Bits::new(s_5143_2 as u128, 3u16);
        // D s_5143_4: cmp-eq s_5143_1 s_5143_3
        let s_5143_4: bool = ((s_5143_1) == (s_5143_3));
        // D s_5143_5: write-var gs#134947 <= s_5143_4
        fn_state.gs_134947 = s_5143_4;
        // N s_5143_6: jump b1052
        return block_1052(state, tracer, fn_state);
    }
    fn block_5144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5144_0: read-var opc1:u8
        let s_5144_0: u8 = fn_state.opc1;
        // D s_5144_1: cast zx s_5144_0 -> bv
        let s_5144_1: Bits = Bits::new(s_5144_0 as u128, 3u16);
        // C s_5144_2: const #0u : u8
        let s_5144_2: u8 = 0;
        // C s_5144_3: cast zx s_5144_2 -> bv
        let s_5144_3: Bits = Bits::new(s_5144_2 as u128, 3u16);
        // D s_5144_4: cmp-eq s_5144_1 s_5144_3
        let s_5144_4: bool = ((s_5144_1) == (s_5144_3));
        // D s_5144_5: write-var gs#134946 <= s_5144_4
        fn_state.gs_134946 = s_5144_4;
        // N s_5144_6: jump b1050
        return block_1050(state, tracer, fn_state);
    }
    fn block_5145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5145_0: read-var coproc:u8
        let s_5145_0: u8 = fn_state.coproc;
        // D s_5145_1: cast zx s_5145_0 -> bv
        let s_5145_1: Bits = Bits::new(s_5145_0 as u128, 4u16);
        // C s_5145_2: const #15u : u8
        let s_5145_2: u8 = 15;
        // C s_5145_3: cast zx s_5145_2 -> bv
        let s_5145_3: Bits = Bits::new(s_5145_2 as u128, 4u16);
        // D s_5145_4: cmp-eq s_5145_1 s_5145_3
        let s_5145_4: bool = ((s_5145_1) == (s_5145_3));
        // D s_5145_5: write-var gs#134945 <= s_5145_4
        fn_state.gs_134945 = s_5145_4;
        // N s_5145_6: jump b1048
        return block_1048(state, tracer, fn_state);
    }
    fn block_5146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5146_0: read-var CRn:u8
        let s_5146_0: u8 = fn_state.CRn;
        // D s_5146_1: cast zx s_5146_0 -> bv
        let s_5146_1: Bits = Bits::new(s_5146_0 as u128, 4u16);
        // C s_5146_2: const #9u : u8
        let s_5146_2: u8 = 9;
        // C s_5146_3: cast zx s_5146_2 -> bv
        let s_5146_3: Bits = Bits::new(s_5146_2 as u128, 4u16);
        // D s_5146_4: cmp-eq s_5146_1 s_5146_3
        let s_5146_4: bool = ((s_5146_1) == (s_5146_3));
        // D s_5146_5: write-var gs#134944 <= s_5146_4
        fn_state.gs_134944 = s_5146_4;
        // N s_5146_6: jump b1046
        return block_1046(state, tracer, fn_state);
    }
    fn block_5147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5147_0: read-var el:u8
        let s_5147_0: u8 = fn_state.el;
        // D s_5147_1: read-var coproc:u8
        let s_5147_1: u8 = fn_state.coproc;
        // D s_5147_2: read-var opc1:u8
        let s_5147_2: u8 = fn_state.opc1;
        // D s_5147_3: read-var CRn:u8
        let s_5147_3: u8 = fn_state.CRn;
        // D s_5147_4: read-var opc2:u8
        let s_5147_4: u8 = fn_state.opc2;
        // D s_5147_5: read-var CRm:u8
        let s_5147_5: u8 = fn_state.CRm;
        // D s_5147_6: read-var t:i
        let s_5147_6: i128 = fn_state.t;
        // D s_5147_7: call ATS1CPW_SysRegWrite32_c343c707514145e0(s_5147_0, s_5147_1, s_5147_2, s_5147_3, s_5147_4, s_5147_5, s_5147_6)
        let s_5147_7: () = ATS1CPW_SysRegWrite32_c343c707514145e0(
            state,
            tracer,
            s_5147_0,
            s_5147_1,
            s_5147_2,
            s_5147_3,
            s_5147_4,
            s_5147_5,
            s_5147_6,
        );
        // N s_5147_8: return
        return;
    }
    fn block_5148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5148_0: read-var opc2:u8
        let s_5148_0: u8 = fn_state.opc2;
        // D s_5148_1: cast zx s_5148_0 -> bv
        let s_5148_1: Bits = Bits::new(s_5148_0 as u128, 3u16);
        // C s_5148_2: const #1u : u8
        let s_5148_2: u8 = 1;
        // C s_5148_3: cast zx s_5148_2 -> bv
        let s_5148_3: Bits = Bits::new(s_5148_2 as u128, 3u16);
        // D s_5148_4: cmp-eq s_5148_1 s_5148_3
        let s_5148_4: bool = ((s_5148_1) == (s_5148_3));
        // D s_5148_5: write-var gs#134943 <= s_5148_4
        fn_state.gs_134943 = s_5148_4;
        // N s_5148_6: jump b1043
        return block_1043(state, tracer, fn_state);
    }
    fn block_5149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5149_0: read-var opc1:u8
        let s_5149_0: u8 = fn_state.opc1;
        // D s_5149_1: cast zx s_5149_0 -> bv
        let s_5149_1: Bits = Bits::new(s_5149_0 as u128, 3u16);
        // C s_5149_2: const #0u : u8
        let s_5149_2: u8 = 0;
        // C s_5149_3: cast zx s_5149_2 -> bv
        let s_5149_3: Bits = Bits::new(s_5149_2 as u128, 3u16);
        // D s_5149_4: cmp-eq s_5149_1 s_5149_3
        let s_5149_4: bool = ((s_5149_1) == (s_5149_3));
        // D s_5149_5: write-var gs#134942 <= s_5149_4
        fn_state.gs_134942 = s_5149_4;
        // N s_5149_6: jump b1041
        return block_1041(state, tracer, fn_state);
    }
    fn block_5150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5150_0: read-var coproc:u8
        let s_5150_0: u8 = fn_state.coproc;
        // D s_5150_1: cast zx s_5150_0 -> bv
        let s_5150_1: Bits = Bits::new(s_5150_0 as u128, 4u16);
        // C s_5150_2: const #15u : u8
        let s_5150_2: u8 = 15;
        // C s_5150_3: cast zx s_5150_2 -> bv
        let s_5150_3: Bits = Bits::new(s_5150_2 as u128, 4u16);
        // D s_5150_4: cmp-eq s_5150_1 s_5150_3
        let s_5150_4: bool = ((s_5150_1) == (s_5150_3));
        // D s_5150_5: write-var gs#134941 <= s_5150_4
        fn_state.gs_134941 = s_5150_4;
        // N s_5150_6: jump b1039
        return block_1039(state, tracer, fn_state);
    }
    fn block_5151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5151_0: read-var CRn:u8
        let s_5151_0: u8 = fn_state.CRn;
        // D s_5151_1: cast zx s_5151_0 -> bv
        let s_5151_1: Bits = Bits::new(s_5151_0 as u128, 4u16);
        // C s_5151_2: const #7u : u8
        let s_5151_2: u8 = 7;
        // C s_5151_3: cast zx s_5151_2 -> bv
        let s_5151_3: Bits = Bits::new(s_5151_2 as u128, 4u16);
        // D s_5151_4: cmp-eq s_5151_1 s_5151_3
        let s_5151_4: bool = ((s_5151_1) == (s_5151_3));
        // D s_5151_5: write-var gs#134940 <= s_5151_4
        fn_state.gs_134940 = s_5151_4;
        // N s_5151_6: jump b1037
        return block_1037(state, tracer, fn_state);
    }
    fn block_5152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5152_0: read-var el:u8
        let s_5152_0: u8 = fn_state.el;
        // D s_5152_1: read-var coproc:u8
        let s_5152_1: u8 = fn_state.coproc;
        // D s_5152_2: read-var opc1:u8
        let s_5152_2: u8 = fn_state.opc1;
        // D s_5152_3: read-var CRn:u8
        let s_5152_3: u8 = fn_state.CRn;
        // D s_5152_4: read-var opc2:u8
        let s_5152_4: u8 = fn_state.opc2;
        // D s_5152_5: read-var CRm:u8
        let s_5152_5: u8 = fn_state.CRm;
        // D s_5152_6: read-var t:i
        let s_5152_6: i128 = fn_state.t;
        // D s_5152_7: call ICC_BPR1_SysRegWrite32_fa0a3cea06e15e3e(s_5152_0, s_5152_1, s_5152_2, s_5152_3, s_5152_4, s_5152_5, s_5152_6)
        let s_5152_7: () = ICC_BPR1_SysRegWrite32_fa0a3cea06e15e3e(
            state,
            tracer,
            s_5152_0,
            s_5152_1,
            s_5152_2,
            s_5152_3,
            s_5152_4,
            s_5152_5,
            s_5152_6,
        );
        // N s_5152_8: return
        return;
    }
    fn block_5153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5153_0: read-var opc2:u8
        let s_5153_0: u8 = fn_state.opc2;
        // D s_5153_1: cast zx s_5153_0 -> bv
        let s_5153_1: Bits = Bits::new(s_5153_0 as u128, 3u16);
        // C s_5153_2: const #3u : u8
        let s_5153_2: u8 = 3;
        // C s_5153_3: cast zx s_5153_2 -> bv
        let s_5153_3: Bits = Bits::new(s_5153_2 as u128, 3u16);
        // D s_5153_4: cmp-eq s_5153_1 s_5153_3
        let s_5153_4: bool = ((s_5153_1) == (s_5153_3));
        // D s_5153_5: write-var gs#134939 <= s_5153_4
        fn_state.gs_134939 = s_5153_4;
        // N s_5153_6: jump b1034
        return block_1034(state, tracer, fn_state);
    }
    fn block_5154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5154_0: read-var opc1:u8
        let s_5154_0: u8 = fn_state.opc1;
        // D s_5154_1: cast zx s_5154_0 -> bv
        let s_5154_1: Bits = Bits::new(s_5154_0 as u128, 3u16);
        // C s_5154_2: const #0u : u8
        let s_5154_2: u8 = 0;
        // C s_5154_3: cast zx s_5154_2 -> bv
        let s_5154_3: Bits = Bits::new(s_5154_2 as u128, 3u16);
        // D s_5154_4: cmp-eq s_5154_1 s_5154_3
        let s_5154_4: bool = ((s_5154_1) == (s_5154_3));
        // D s_5154_5: write-var gs#134938 <= s_5154_4
        fn_state.gs_134938 = s_5154_4;
        // N s_5154_6: jump b1032
        return block_1032(state, tracer, fn_state);
    }
    fn block_5155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5155_0: read-var coproc:u8
        let s_5155_0: u8 = fn_state.coproc;
        // D s_5155_1: cast zx s_5155_0 -> bv
        let s_5155_1: Bits = Bits::new(s_5155_0 as u128, 4u16);
        // C s_5155_2: const #15u : u8
        let s_5155_2: u8 = 15;
        // C s_5155_3: cast zx s_5155_2 -> bv
        let s_5155_3: Bits = Bits::new(s_5155_2 as u128, 4u16);
        // D s_5155_4: cmp-eq s_5155_1 s_5155_3
        let s_5155_4: bool = ((s_5155_1) == (s_5155_3));
        // D s_5155_5: write-var gs#134937 <= s_5155_4
        fn_state.gs_134937 = s_5155_4;
        // N s_5155_6: jump b1030
        return block_1030(state, tracer, fn_state);
    }
    fn block_5156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5156_0: read-var CRn:u8
        let s_5156_0: u8 = fn_state.CRn;
        // D s_5156_1: cast zx s_5156_0 -> bv
        let s_5156_1: Bits = Bits::new(s_5156_0 as u128, 4u16);
        // C s_5156_2: const #12u : u8
        let s_5156_2: u8 = 12;
        // C s_5156_3: cast zx s_5156_2 -> bv
        let s_5156_3: Bits = Bits::new(s_5156_2 as u128, 4u16);
        // D s_5156_4: cmp-eq s_5156_1 s_5156_3
        let s_5156_4: bool = ((s_5156_1) == (s_5156_3));
        // D s_5156_5: write-var gs#134936 <= s_5156_4
        fn_state.gs_134936 = s_5156_4;
        // N s_5156_6: jump b1028
        return block_1028(state, tracer, fn_state);
    }
    fn block_5157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5157_0: read-var el:u8
        let s_5157_0: u8 = fn_state.el;
        // D s_5157_1: read-var coproc:u8
        let s_5157_1: u8 = fn_state.coproc;
        // D s_5157_2: read-var opc1:u8
        let s_5157_2: u8 = fn_state.opc1;
        // D s_5157_3: read-var CRn:u8
        let s_5157_3: u8 = fn_state.CRn;
        // D s_5157_4: read-var opc2:u8
        let s_5157_4: u8 = fn_state.opc2;
        // D s_5157_5: read-var CRm:u8
        let s_5157_5: u8 = fn_state.CRm;
        // D s_5157_6: read-var t:i
        let s_5157_6: i128 = fn_state.t;
        // D s_5157_7: call TLBIIPAS2_SysRegWrite32_0f58707a5d9a37dd(s_5157_0, s_5157_1, s_5157_2, s_5157_3, s_5157_4, s_5157_5, s_5157_6)
        let s_5157_7: () = TLBIIPAS2_SysRegWrite32_0f58707a5d9a37dd(
            state,
            tracer,
            s_5157_0,
            s_5157_1,
            s_5157_2,
            s_5157_3,
            s_5157_4,
            s_5157_5,
            s_5157_6,
        );
        // N s_5157_8: return
        return;
    }
    fn block_5158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5158_0: read-var opc2:u8
        let s_5158_0: u8 = fn_state.opc2;
        // D s_5158_1: cast zx s_5158_0 -> bv
        let s_5158_1: Bits = Bits::new(s_5158_0 as u128, 3u16);
        // C s_5158_2: const #1u : u8
        let s_5158_2: u8 = 1;
        // C s_5158_3: cast zx s_5158_2 -> bv
        let s_5158_3: Bits = Bits::new(s_5158_2 as u128, 3u16);
        // D s_5158_4: cmp-eq s_5158_1 s_5158_3
        let s_5158_4: bool = ((s_5158_1) == (s_5158_3));
        // D s_5158_5: write-var gs#134935 <= s_5158_4
        fn_state.gs_134935 = s_5158_4;
        // N s_5158_6: jump b1025
        return block_1025(state, tracer, fn_state);
    }
    fn block_5159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5159_0: read-var opc1:u8
        let s_5159_0: u8 = fn_state.opc1;
        // D s_5159_1: cast zx s_5159_0 -> bv
        let s_5159_1: Bits = Bits::new(s_5159_0 as u128, 3u16);
        // C s_5159_2: const #4u : u8
        let s_5159_2: u8 = 4;
        // C s_5159_3: cast zx s_5159_2 -> bv
        let s_5159_3: Bits = Bits::new(s_5159_2 as u128, 3u16);
        // D s_5159_4: cmp-eq s_5159_1 s_5159_3
        let s_5159_4: bool = ((s_5159_1) == (s_5159_3));
        // D s_5159_5: write-var gs#134934 <= s_5159_4
        fn_state.gs_134934 = s_5159_4;
        // N s_5159_6: jump b1023
        return block_1023(state, tracer, fn_state);
    }
    fn block_5160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5160_0: read-var coproc:u8
        let s_5160_0: u8 = fn_state.coproc;
        // D s_5160_1: cast zx s_5160_0 -> bv
        let s_5160_1: Bits = Bits::new(s_5160_0 as u128, 4u16);
        // C s_5160_2: const #15u : u8
        let s_5160_2: u8 = 15;
        // C s_5160_3: cast zx s_5160_2 -> bv
        let s_5160_3: Bits = Bits::new(s_5160_2 as u128, 4u16);
        // D s_5160_4: cmp-eq s_5160_1 s_5160_3
        let s_5160_4: bool = ((s_5160_1) == (s_5160_3));
        // D s_5160_5: write-var gs#134933 <= s_5160_4
        fn_state.gs_134933 = s_5160_4;
        // N s_5160_6: jump b1021
        return block_1021(state, tracer, fn_state);
    }
    fn block_5161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5161_0: read-var CRn:u8
        let s_5161_0: u8 = fn_state.CRn;
        // D s_5161_1: cast zx s_5161_0 -> bv
        let s_5161_1: Bits = Bits::new(s_5161_0 as u128, 4u16);
        // C s_5161_2: const #8u : u8
        let s_5161_2: u8 = 8;
        // C s_5161_3: cast zx s_5161_2 -> bv
        let s_5161_3: Bits = Bits::new(s_5161_2 as u128, 4u16);
        // D s_5161_4: cmp-eq s_5161_1 s_5161_3
        let s_5161_4: bool = ((s_5161_1) == (s_5161_3));
        // D s_5161_5: write-var gs#134932 <= s_5161_4
        fn_state.gs_134932 = s_5161_4;
        // N s_5161_6: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_5162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5162_0: read-var el:u8
        let s_5162_0: u8 = fn_state.el;
        // D s_5162_1: read-var coproc:u8
        let s_5162_1: u8 = fn_state.coproc;
        // D s_5162_2: read-var opc1:u8
        let s_5162_2: u8 = fn_state.opc1;
        // D s_5162_3: read-var CRn:u8
        let s_5162_3: u8 = fn_state.CRn;
        // D s_5162_4: read-var opc2:u8
        let s_5162_4: u8 = fn_state.opc2;
        // D s_5162_5: read-var CRm:u8
        let s_5162_5: u8 = fn_state.CRm;
        // D s_5162_6: read-var t:i
        let s_5162_6: i128 = fn_state.t;
        // D s_5162_7: call ICH_VMCR_SysRegWrite32_2eb356e2f10a122b(s_5162_0, s_5162_1, s_5162_2, s_5162_3, s_5162_4, s_5162_5, s_5162_6)
        let s_5162_7: () = ICH_VMCR_SysRegWrite32_2eb356e2f10a122b(
            state,
            tracer,
            s_5162_0,
            s_5162_1,
            s_5162_2,
            s_5162_3,
            s_5162_4,
            s_5162_5,
            s_5162_6,
        );
        // N s_5162_8: return
        return;
    }
    fn block_5163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5163_0: read-var opc2:u8
        let s_5163_0: u8 = fn_state.opc2;
        // D s_5163_1: cast zx s_5163_0 -> bv
        let s_5163_1: Bits = Bits::new(s_5163_0 as u128, 3u16);
        // C s_5163_2: const #7u : u8
        let s_5163_2: u8 = 7;
        // C s_5163_3: cast zx s_5163_2 -> bv
        let s_5163_3: Bits = Bits::new(s_5163_2 as u128, 3u16);
        // D s_5163_4: cmp-eq s_5163_1 s_5163_3
        let s_5163_4: bool = ((s_5163_1) == (s_5163_3));
        // D s_5163_5: write-var gs#134931 <= s_5163_4
        fn_state.gs_134931 = s_5163_4;
        // N s_5163_6: jump b1016
        return block_1016(state, tracer, fn_state);
    }
    fn block_5164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5164_0: read-var opc1:u8
        let s_5164_0: u8 = fn_state.opc1;
        // D s_5164_1: cast zx s_5164_0 -> bv
        let s_5164_1: Bits = Bits::new(s_5164_0 as u128, 3u16);
        // C s_5164_2: const #4u : u8
        let s_5164_2: u8 = 4;
        // C s_5164_3: cast zx s_5164_2 -> bv
        let s_5164_3: Bits = Bits::new(s_5164_2 as u128, 3u16);
        // D s_5164_4: cmp-eq s_5164_1 s_5164_3
        let s_5164_4: bool = ((s_5164_1) == (s_5164_3));
        // D s_5164_5: write-var gs#134930 <= s_5164_4
        fn_state.gs_134930 = s_5164_4;
        // N s_5164_6: jump b1014
        return block_1014(state, tracer, fn_state);
    }
    fn block_5165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5165_0: read-var coproc:u8
        let s_5165_0: u8 = fn_state.coproc;
        // D s_5165_1: cast zx s_5165_0 -> bv
        let s_5165_1: Bits = Bits::new(s_5165_0 as u128, 4u16);
        // C s_5165_2: const #15u : u8
        let s_5165_2: u8 = 15;
        // C s_5165_3: cast zx s_5165_2 -> bv
        let s_5165_3: Bits = Bits::new(s_5165_2 as u128, 4u16);
        // D s_5165_4: cmp-eq s_5165_1 s_5165_3
        let s_5165_4: bool = ((s_5165_1) == (s_5165_3));
        // D s_5165_5: write-var gs#134929 <= s_5165_4
        fn_state.gs_134929 = s_5165_4;
        // N s_5165_6: jump b1012
        return block_1012(state, tracer, fn_state);
    }
    fn block_5166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5166_0: read-var CRn:u8
        let s_5166_0: u8 = fn_state.CRn;
        // D s_5166_1: cast zx s_5166_0 -> bv
        let s_5166_1: Bits = Bits::new(s_5166_0 as u128, 4u16);
        // C s_5166_2: const #12u : u8
        let s_5166_2: u8 = 12;
        // C s_5166_3: cast zx s_5166_2 -> bv
        let s_5166_3: Bits = Bits::new(s_5166_2 as u128, 4u16);
        // D s_5166_4: cmp-eq s_5166_1 s_5166_3
        let s_5166_4: bool = ((s_5166_1) == (s_5166_3));
        // D s_5166_5: write-var gs#134928 <= s_5166_4
        fn_state.gs_134928 = s_5166_4;
        // N s_5166_6: jump b1010
        return block_1010(state, tracer, fn_state);
    }
    fn block_5167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5167_0: read-var el:u8
        let s_5167_0: u8 = fn_state.el;
        // D s_5167_1: read-var coproc:u8
        let s_5167_1: u8 = fn_state.coproc;
        // D s_5167_2: read-var opc1:u8
        let s_5167_2: u8 = fn_state.opc1;
        // D s_5167_3: read-var CRn:u8
        let s_5167_3: u8 = fn_state.CRn;
        // D s_5167_4: read-var opc2:u8
        let s_5167_4: u8 = fn_state.opc2;
        // D s_5167_5: read-var CRm:u8
        let s_5167_5: u8 = fn_state.CRm;
        // D s_5167_6: read-var t:i
        let s_5167_6: i128 = fn_state.t;
        // D s_5167_7: call DBGWCR_SysRegWrite32_ab8bacc16ba179ac(s_5167_0, s_5167_1, s_5167_2, s_5167_3, s_5167_4, s_5167_5, s_5167_6)
        let s_5167_7: () = DBGWCR_SysRegWrite32_ab8bacc16ba179ac(
            state,
            tracer,
            s_5167_0,
            s_5167_1,
            s_5167_2,
            s_5167_3,
            s_5167_4,
            s_5167_5,
            s_5167_6,
        );
        // N s_5167_8: return
        return;
    }
    fn block_5168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5168_0: read-var opc2:u8
        let s_5168_0: u8 = fn_state.opc2;
        // D s_5168_1: cast zx s_5168_0 -> bv
        let s_5168_1: Bits = Bits::new(s_5168_0 as u128, 3u16);
        // C s_5168_2: const #7u : u8
        let s_5168_2: u8 = 7;
        // C s_5168_3: cast zx s_5168_2 -> bv
        let s_5168_3: Bits = Bits::new(s_5168_2 as u128, 3u16);
        // D s_5168_4: cmp-eq s_5168_1 s_5168_3
        let s_5168_4: bool = ((s_5168_1) == (s_5168_3));
        // D s_5168_5: write-var gs#134927 <= s_5168_4
        fn_state.gs_134927 = s_5168_4;
        // N s_5168_6: jump b1007
        return block_1007(state, tracer, fn_state);
    }
    fn block_5169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5169_0: read-var opc1:u8
        let s_5169_0: u8 = fn_state.opc1;
        // D s_5169_1: cast zx s_5169_0 -> bv
        let s_5169_1: Bits = Bits::new(s_5169_0 as u128, 3u16);
        // C s_5169_2: const #0u : u8
        let s_5169_2: u8 = 0;
        // C s_5169_3: cast zx s_5169_2 -> bv
        let s_5169_3: Bits = Bits::new(s_5169_2 as u128, 3u16);
        // D s_5169_4: cmp-eq s_5169_1 s_5169_3
        let s_5169_4: bool = ((s_5169_1) == (s_5169_3));
        // D s_5169_5: write-var gs#134926 <= s_5169_4
        fn_state.gs_134926 = s_5169_4;
        // N s_5169_6: jump b1005
        return block_1005(state, tracer, fn_state);
    }
    fn block_5170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5170_0: read-var coproc:u8
        let s_5170_0: u8 = fn_state.coproc;
        // D s_5170_1: cast zx s_5170_0 -> bv
        let s_5170_1: Bits = Bits::new(s_5170_0 as u128, 4u16);
        // C s_5170_2: const #14u : u8
        let s_5170_2: u8 = 14;
        // C s_5170_3: cast zx s_5170_2 -> bv
        let s_5170_3: Bits = Bits::new(s_5170_2 as u128, 4u16);
        // D s_5170_4: cmp-eq s_5170_1 s_5170_3
        let s_5170_4: bool = ((s_5170_1) == (s_5170_3));
        // D s_5170_5: write-var gs#134925 <= s_5170_4
        fn_state.gs_134925 = s_5170_4;
        // N s_5170_6: jump b1003
        return block_1003(state, tracer, fn_state);
    }
    fn block_5171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5171_0: read-var CRn:u8
        let s_5171_0: u8 = fn_state.CRn;
        // D s_5171_1: cast zx s_5171_0 -> bv
        let s_5171_1: Bits = Bits::new(s_5171_0 as u128, 4u16);
        // C s_5171_2: const #0u : u8
        let s_5171_2: u8 = 0;
        // C s_5171_3: cast zx s_5171_2 -> bv
        let s_5171_3: Bits = Bits::new(s_5171_2 as u128, 4u16);
        // D s_5171_4: cmp-eq s_5171_1 s_5171_3
        let s_5171_4: bool = ((s_5171_1) == (s_5171_3));
        // D s_5171_5: write-var gs#134924 <= s_5171_4
        fn_state.gs_134924 = s_5171_4;
        // N s_5171_6: jump b1001
        return block_1001(state, tracer, fn_state);
    }
    fn block_5172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5172_0: read-var el:u8
        let s_5172_0: u8 = fn_state.el;
        // D s_5172_1: read-var coproc:u8
        let s_5172_1: u8 = fn_state.coproc;
        // D s_5172_2: read-var opc1:u8
        let s_5172_2: u8 = fn_state.opc1;
        // D s_5172_3: read-var CRn:u8
        let s_5172_3: u8 = fn_state.CRn;
        // D s_5172_4: read-var opc2:u8
        let s_5172_4: u8 = fn_state.opc2;
        // D s_5172_5: read-var CRm:u8
        let s_5172_5: u8 = fn_state.CRm;
        // D s_5172_6: read-var t:i
        let s_5172_6: i128 = fn_state.t;
        // D s_5172_7: call DBGWCR_SysRegWrite32_4f1045e329d8e2cf(s_5172_0, s_5172_1, s_5172_2, s_5172_3, s_5172_4, s_5172_5, s_5172_6)
        let s_5172_7: () = DBGWCR_SysRegWrite32_4f1045e329d8e2cf(
            state,
            tracer,
            s_5172_0,
            s_5172_1,
            s_5172_2,
            s_5172_3,
            s_5172_4,
            s_5172_5,
            s_5172_6,
        );
        // N s_5172_8: return
        return;
    }
    fn block_5173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5173_0: read-var opc2:u8
        let s_5173_0: u8 = fn_state.opc2;
        // D s_5173_1: cast zx s_5173_0 -> bv
        let s_5173_1: Bits = Bits::new(s_5173_0 as u128, 3u16);
        // C s_5173_2: const #7u : u8
        let s_5173_2: u8 = 7;
        // C s_5173_3: cast zx s_5173_2 -> bv
        let s_5173_3: Bits = Bits::new(s_5173_2 as u128, 3u16);
        // D s_5173_4: cmp-eq s_5173_1 s_5173_3
        let s_5173_4: bool = ((s_5173_1) == (s_5173_3));
        // D s_5173_5: write-var gs#134923 <= s_5173_4
        fn_state.gs_134923 = s_5173_4;
        // N s_5173_6: jump b998
        return block_998(state, tracer, fn_state);
    }
    fn block_5174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5174_0: read-var opc1:u8
        let s_5174_0: u8 = fn_state.opc1;
        // D s_5174_1: cast zx s_5174_0 -> bv
        let s_5174_1: Bits = Bits::new(s_5174_0 as u128, 3u16);
        // C s_5174_2: const #0u : u8
        let s_5174_2: u8 = 0;
        // C s_5174_3: cast zx s_5174_2 -> bv
        let s_5174_3: Bits = Bits::new(s_5174_2 as u128, 3u16);
        // D s_5174_4: cmp-eq s_5174_1 s_5174_3
        let s_5174_4: bool = ((s_5174_1) == (s_5174_3));
        // D s_5174_5: write-var gs#134922 <= s_5174_4
        fn_state.gs_134922 = s_5174_4;
        // N s_5174_6: jump b996
        return block_996(state, tracer, fn_state);
    }
    fn block_5175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5175_0: read-var coproc:u8
        let s_5175_0: u8 = fn_state.coproc;
        // D s_5175_1: cast zx s_5175_0 -> bv
        let s_5175_1: Bits = Bits::new(s_5175_0 as u128, 4u16);
        // C s_5175_2: const #14u : u8
        let s_5175_2: u8 = 14;
        // C s_5175_3: cast zx s_5175_2 -> bv
        let s_5175_3: Bits = Bits::new(s_5175_2 as u128, 4u16);
        // D s_5175_4: cmp-eq s_5175_1 s_5175_3
        let s_5175_4: bool = ((s_5175_1) == (s_5175_3));
        // D s_5175_5: write-var gs#134921 <= s_5175_4
        fn_state.gs_134921 = s_5175_4;
        // N s_5175_6: jump b994
        return block_994(state, tracer, fn_state);
    }
    fn block_5176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5176_0: read-var CRn:u8
        let s_5176_0: u8 = fn_state.CRn;
        // D s_5176_1: cast zx s_5176_0 -> bv
        let s_5176_1: Bits = Bits::new(s_5176_0 as u128, 4u16);
        // C s_5176_2: const #0u : u8
        let s_5176_2: u8 = 0;
        // C s_5176_3: cast zx s_5176_2 -> bv
        let s_5176_3: Bits = Bits::new(s_5176_2 as u128, 4u16);
        // D s_5176_4: cmp-eq s_5176_1 s_5176_3
        let s_5176_4: bool = ((s_5176_1) == (s_5176_3));
        // D s_5176_5: write-var gs#134920 <= s_5176_4
        fn_state.gs_134920 = s_5176_4;
        // N s_5176_6: jump b992
        return block_992(state, tracer, fn_state);
    }
    fn block_5177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5177_0: read-var el:u8
        let s_5177_0: u8 = fn_state.el;
        // D s_5177_1: read-var coproc:u8
        let s_5177_1: u8 = fn_state.coproc;
        // D s_5177_2: read-var opc1:u8
        let s_5177_2: u8 = fn_state.opc1;
        // D s_5177_3: read-var CRn:u8
        let s_5177_3: u8 = fn_state.CRn;
        // D s_5177_4: read-var opc2:u8
        let s_5177_4: u8 = fn_state.opc2;
        // D s_5177_5: read-var CRm:u8
        let s_5177_5: u8 = fn_state.CRm;
        // D s_5177_6: read-var t:i
        let s_5177_6: i128 = fn_state.t;
        // D s_5177_7: call DBGWCR_SysRegWrite32_c5827483af2959fc(s_5177_0, s_5177_1, s_5177_2, s_5177_3, s_5177_4, s_5177_5, s_5177_6)
        let s_5177_7: () = DBGWCR_SysRegWrite32_c5827483af2959fc(
            state,
            tracer,
            s_5177_0,
            s_5177_1,
            s_5177_2,
            s_5177_3,
            s_5177_4,
            s_5177_5,
            s_5177_6,
        );
        // N s_5177_8: return
        return;
    }
    fn block_5178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5178_0: read-var opc2:u8
        let s_5178_0: u8 = fn_state.opc2;
        // D s_5178_1: cast zx s_5178_0 -> bv
        let s_5178_1: Bits = Bits::new(s_5178_0 as u128, 3u16);
        // C s_5178_2: const #7u : u8
        let s_5178_2: u8 = 7;
        // C s_5178_3: cast zx s_5178_2 -> bv
        let s_5178_3: Bits = Bits::new(s_5178_2 as u128, 3u16);
        // D s_5178_4: cmp-eq s_5178_1 s_5178_3
        let s_5178_4: bool = ((s_5178_1) == (s_5178_3));
        // D s_5178_5: write-var gs#134919 <= s_5178_4
        fn_state.gs_134919 = s_5178_4;
        // N s_5178_6: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_5179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5179_0: read-var opc1:u8
        let s_5179_0: u8 = fn_state.opc1;
        // D s_5179_1: cast zx s_5179_0 -> bv
        let s_5179_1: Bits = Bits::new(s_5179_0 as u128, 3u16);
        // C s_5179_2: const #0u : u8
        let s_5179_2: u8 = 0;
        // C s_5179_3: cast zx s_5179_2 -> bv
        let s_5179_3: Bits = Bits::new(s_5179_2 as u128, 3u16);
        // D s_5179_4: cmp-eq s_5179_1 s_5179_3
        let s_5179_4: bool = ((s_5179_1) == (s_5179_3));
        // D s_5179_5: write-var gs#134918 <= s_5179_4
        fn_state.gs_134918 = s_5179_4;
        // N s_5179_6: jump b987
        return block_987(state, tracer, fn_state);
    }
    fn block_5180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5180_0: read-var coproc:u8
        let s_5180_0: u8 = fn_state.coproc;
        // D s_5180_1: cast zx s_5180_0 -> bv
        let s_5180_1: Bits = Bits::new(s_5180_0 as u128, 4u16);
        // C s_5180_2: const #14u : u8
        let s_5180_2: u8 = 14;
        // C s_5180_3: cast zx s_5180_2 -> bv
        let s_5180_3: Bits = Bits::new(s_5180_2 as u128, 4u16);
        // D s_5180_4: cmp-eq s_5180_1 s_5180_3
        let s_5180_4: bool = ((s_5180_1) == (s_5180_3));
        // D s_5180_5: write-var gs#134917 <= s_5180_4
        fn_state.gs_134917 = s_5180_4;
        // N s_5180_6: jump b985
        return block_985(state, tracer, fn_state);
    }
    fn block_5181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5181_0: read-var CRn:u8
        let s_5181_0: u8 = fn_state.CRn;
        // D s_5181_1: cast zx s_5181_0 -> bv
        let s_5181_1: Bits = Bits::new(s_5181_0 as u128, 4u16);
        // C s_5181_2: const #0u : u8
        let s_5181_2: u8 = 0;
        // C s_5181_3: cast zx s_5181_2 -> bv
        let s_5181_3: Bits = Bits::new(s_5181_2 as u128, 4u16);
        // D s_5181_4: cmp-eq s_5181_1 s_5181_3
        let s_5181_4: bool = ((s_5181_1) == (s_5181_3));
        // D s_5181_5: write-var gs#134916 <= s_5181_4
        fn_state.gs_134916 = s_5181_4;
        // N s_5181_6: jump b983
        return block_983(state, tracer, fn_state);
    }
    fn block_5182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5182_0: read-var el:u8
        let s_5182_0: u8 = fn_state.el;
        // D s_5182_1: read-var coproc:u8
        let s_5182_1: u8 = fn_state.coproc;
        // D s_5182_2: read-var opc1:u8
        let s_5182_2: u8 = fn_state.opc1;
        // D s_5182_3: read-var CRn:u8
        let s_5182_3: u8 = fn_state.CRn;
        // D s_5182_4: read-var opc2:u8
        let s_5182_4: u8 = fn_state.opc2;
        // D s_5182_5: read-var CRm:u8
        let s_5182_5: u8 = fn_state.CRm;
        // D s_5182_6: read-var t:i
        let s_5182_6: i128 = fn_state.t;
        // D s_5182_7: call DBGWCR_SysRegWrite32_370ee8f5d3ab6901(s_5182_0, s_5182_1, s_5182_2, s_5182_3, s_5182_4, s_5182_5, s_5182_6)
        let s_5182_7: () = DBGWCR_SysRegWrite32_370ee8f5d3ab6901(
            state,
            tracer,
            s_5182_0,
            s_5182_1,
            s_5182_2,
            s_5182_3,
            s_5182_4,
            s_5182_5,
            s_5182_6,
        );
        // N s_5182_8: return
        return;
    }
    fn block_5183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5183_0: read-var opc2:u8
        let s_5183_0: u8 = fn_state.opc2;
        // D s_5183_1: cast zx s_5183_0 -> bv
        let s_5183_1: Bits = Bits::new(s_5183_0 as u128, 3u16);
        // C s_5183_2: const #7u : u8
        let s_5183_2: u8 = 7;
        // C s_5183_3: cast zx s_5183_2 -> bv
        let s_5183_3: Bits = Bits::new(s_5183_2 as u128, 3u16);
        // D s_5183_4: cmp-eq s_5183_1 s_5183_3
        let s_5183_4: bool = ((s_5183_1) == (s_5183_3));
        // D s_5183_5: write-var gs#134915 <= s_5183_4
        fn_state.gs_134915 = s_5183_4;
        // N s_5183_6: jump b980
        return block_980(state, tracer, fn_state);
    }
    fn block_5184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5184_0: read-var opc1:u8
        let s_5184_0: u8 = fn_state.opc1;
        // D s_5184_1: cast zx s_5184_0 -> bv
        let s_5184_1: Bits = Bits::new(s_5184_0 as u128, 3u16);
        // C s_5184_2: const #0u : u8
        let s_5184_2: u8 = 0;
        // C s_5184_3: cast zx s_5184_2 -> bv
        let s_5184_3: Bits = Bits::new(s_5184_2 as u128, 3u16);
        // D s_5184_4: cmp-eq s_5184_1 s_5184_3
        let s_5184_4: bool = ((s_5184_1) == (s_5184_3));
        // D s_5184_5: write-var gs#134914 <= s_5184_4
        fn_state.gs_134914 = s_5184_4;
        // N s_5184_6: jump b978
        return block_978(state, tracer, fn_state);
    }
    fn block_5185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5185_0: read-var coproc:u8
        let s_5185_0: u8 = fn_state.coproc;
        // D s_5185_1: cast zx s_5185_0 -> bv
        let s_5185_1: Bits = Bits::new(s_5185_0 as u128, 4u16);
        // C s_5185_2: const #14u : u8
        let s_5185_2: u8 = 14;
        // C s_5185_3: cast zx s_5185_2 -> bv
        let s_5185_3: Bits = Bits::new(s_5185_2 as u128, 4u16);
        // D s_5185_4: cmp-eq s_5185_1 s_5185_3
        let s_5185_4: bool = ((s_5185_1) == (s_5185_3));
        // D s_5185_5: write-var gs#134913 <= s_5185_4
        fn_state.gs_134913 = s_5185_4;
        // N s_5185_6: jump b976
        return block_976(state, tracer, fn_state);
    }
    fn block_5186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5186_0: read-var CRn:u8
        let s_5186_0: u8 = fn_state.CRn;
        // D s_5186_1: cast zx s_5186_0 -> bv
        let s_5186_1: Bits = Bits::new(s_5186_0 as u128, 4u16);
        // C s_5186_2: const #0u : u8
        let s_5186_2: u8 = 0;
        // C s_5186_3: cast zx s_5186_2 -> bv
        let s_5186_3: Bits = Bits::new(s_5186_2 as u128, 4u16);
        // D s_5186_4: cmp-eq s_5186_1 s_5186_3
        let s_5186_4: bool = ((s_5186_1) == (s_5186_3));
        // D s_5186_5: write-var gs#134912 <= s_5186_4
        fn_state.gs_134912 = s_5186_4;
        // N s_5186_6: jump b974
        return block_974(state, tracer, fn_state);
    }
    fn block_5187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5187_0: read-var el:u8
        let s_5187_0: u8 = fn_state.el;
        // D s_5187_1: read-var coproc:u8
        let s_5187_1: u8 = fn_state.coproc;
        // D s_5187_2: read-var opc1:u8
        let s_5187_2: u8 = fn_state.opc1;
        // D s_5187_3: read-var CRn:u8
        let s_5187_3: u8 = fn_state.CRn;
        // D s_5187_4: read-var opc2:u8
        let s_5187_4: u8 = fn_state.opc2;
        // D s_5187_5: read-var CRm:u8
        let s_5187_5: u8 = fn_state.CRm;
        // D s_5187_6: read-var t:i
        let s_5187_6: i128 = fn_state.t;
        // D s_5187_7: call DBGWCR_SysRegWrite32_ef9a1ddd79a2bf16(s_5187_0, s_5187_1, s_5187_2, s_5187_3, s_5187_4, s_5187_5, s_5187_6)
        let s_5187_7: () = DBGWCR_SysRegWrite32_ef9a1ddd79a2bf16(
            state,
            tracer,
            s_5187_0,
            s_5187_1,
            s_5187_2,
            s_5187_3,
            s_5187_4,
            s_5187_5,
            s_5187_6,
        );
        // N s_5187_8: return
        return;
    }
    fn block_5188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5188_0: read-var opc2:u8
        let s_5188_0: u8 = fn_state.opc2;
        // D s_5188_1: cast zx s_5188_0 -> bv
        let s_5188_1: Bits = Bits::new(s_5188_0 as u128, 3u16);
        // C s_5188_2: const #7u : u8
        let s_5188_2: u8 = 7;
        // C s_5188_3: cast zx s_5188_2 -> bv
        let s_5188_3: Bits = Bits::new(s_5188_2 as u128, 3u16);
        // D s_5188_4: cmp-eq s_5188_1 s_5188_3
        let s_5188_4: bool = ((s_5188_1) == (s_5188_3));
        // D s_5188_5: write-var gs#134911 <= s_5188_4
        fn_state.gs_134911 = s_5188_4;
        // N s_5188_6: jump b971
        return block_971(state, tracer, fn_state);
    }
    fn block_5189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5189_0: read-var opc1:u8
        let s_5189_0: u8 = fn_state.opc1;
        // D s_5189_1: cast zx s_5189_0 -> bv
        let s_5189_1: Bits = Bits::new(s_5189_0 as u128, 3u16);
        // C s_5189_2: const #0u : u8
        let s_5189_2: u8 = 0;
        // C s_5189_3: cast zx s_5189_2 -> bv
        let s_5189_3: Bits = Bits::new(s_5189_2 as u128, 3u16);
        // D s_5189_4: cmp-eq s_5189_1 s_5189_3
        let s_5189_4: bool = ((s_5189_1) == (s_5189_3));
        // D s_5189_5: write-var gs#134910 <= s_5189_4
        fn_state.gs_134910 = s_5189_4;
        // N s_5189_6: jump b969
        return block_969(state, tracer, fn_state);
    }
    fn block_5190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5190_0: read-var coproc:u8
        let s_5190_0: u8 = fn_state.coproc;
        // D s_5190_1: cast zx s_5190_0 -> bv
        let s_5190_1: Bits = Bits::new(s_5190_0 as u128, 4u16);
        // C s_5190_2: const #14u : u8
        let s_5190_2: u8 = 14;
        // C s_5190_3: cast zx s_5190_2 -> bv
        let s_5190_3: Bits = Bits::new(s_5190_2 as u128, 4u16);
        // D s_5190_4: cmp-eq s_5190_1 s_5190_3
        let s_5190_4: bool = ((s_5190_1) == (s_5190_3));
        // D s_5190_5: write-var gs#134909 <= s_5190_4
        fn_state.gs_134909 = s_5190_4;
        // N s_5190_6: jump b967
        return block_967(state, tracer, fn_state);
    }
    fn block_5191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5191_0: read-var CRn:u8
        let s_5191_0: u8 = fn_state.CRn;
        // D s_5191_1: cast zx s_5191_0 -> bv
        let s_5191_1: Bits = Bits::new(s_5191_0 as u128, 4u16);
        // C s_5191_2: const #0u : u8
        let s_5191_2: u8 = 0;
        // C s_5191_3: cast zx s_5191_2 -> bv
        let s_5191_3: Bits = Bits::new(s_5191_2 as u128, 4u16);
        // D s_5191_4: cmp-eq s_5191_1 s_5191_3
        let s_5191_4: bool = ((s_5191_1) == (s_5191_3));
        // D s_5191_5: write-var gs#134908 <= s_5191_4
        fn_state.gs_134908 = s_5191_4;
        // N s_5191_6: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_5192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5192_0: read-var el:u8
        let s_5192_0: u8 = fn_state.el;
        // D s_5192_1: read-var coproc:u8
        let s_5192_1: u8 = fn_state.coproc;
        // D s_5192_2: read-var opc1:u8
        let s_5192_2: u8 = fn_state.opc1;
        // D s_5192_3: read-var CRn:u8
        let s_5192_3: u8 = fn_state.CRn;
        // D s_5192_4: read-var opc2:u8
        let s_5192_4: u8 = fn_state.opc2;
        // D s_5192_5: read-var CRm:u8
        let s_5192_5: u8 = fn_state.CRm;
        // D s_5192_6: read-var t:i
        let s_5192_6: i128 = fn_state.t;
        // D s_5192_7: call DBGWCR_SysRegWrite32_e4aea7ea030c28ea(s_5192_0, s_5192_1, s_5192_2, s_5192_3, s_5192_4, s_5192_5, s_5192_6)
        let s_5192_7: () = DBGWCR_SysRegWrite32_e4aea7ea030c28ea(
            state,
            tracer,
            s_5192_0,
            s_5192_1,
            s_5192_2,
            s_5192_3,
            s_5192_4,
            s_5192_5,
            s_5192_6,
        );
        // N s_5192_8: return
        return;
    }
    fn block_5193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5193_0: read-var opc2:u8
        let s_5193_0: u8 = fn_state.opc2;
        // D s_5193_1: cast zx s_5193_0 -> bv
        let s_5193_1: Bits = Bits::new(s_5193_0 as u128, 3u16);
        // C s_5193_2: const #7u : u8
        let s_5193_2: u8 = 7;
        // C s_5193_3: cast zx s_5193_2 -> bv
        let s_5193_3: Bits = Bits::new(s_5193_2 as u128, 3u16);
        // D s_5193_4: cmp-eq s_5193_1 s_5193_3
        let s_5193_4: bool = ((s_5193_1) == (s_5193_3));
        // D s_5193_5: write-var gs#134907 <= s_5193_4
        fn_state.gs_134907 = s_5193_4;
        // N s_5193_6: jump b962
        return block_962(state, tracer, fn_state);
    }
    fn block_5194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5194_0: read-var opc1:u8
        let s_5194_0: u8 = fn_state.opc1;
        // D s_5194_1: cast zx s_5194_0 -> bv
        let s_5194_1: Bits = Bits::new(s_5194_0 as u128, 3u16);
        // C s_5194_2: const #0u : u8
        let s_5194_2: u8 = 0;
        // C s_5194_3: cast zx s_5194_2 -> bv
        let s_5194_3: Bits = Bits::new(s_5194_2 as u128, 3u16);
        // D s_5194_4: cmp-eq s_5194_1 s_5194_3
        let s_5194_4: bool = ((s_5194_1) == (s_5194_3));
        // D s_5194_5: write-var gs#134906 <= s_5194_4
        fn_state.gs_134906 = s_5194_4;
        // N s_5194_6: jump b960
        return block_960(state, tracer, fn_state);
    }
    fn block_5195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5195_0: read-var coproc:u8
        let s_5195_0: u8 = fn_state.coproc;
        // D s_5195_1: cast zx s_5195_0 -> bv
        let s_5195_1: Bits = Bits::new(s_5195_0 as u128, 4u16);
        // C s_5195_2: const #14u : u8
        let s_5195_2: u8 = 14;
        // C s_5195_3: cast zx s_5195_2 -> bv
        let s_5195_3: Bits = Bits::new(s_5195_2 as u128, 4u16);
        // D s_5195_4: cmp-eq s_5195_1 s_5195_3
        let s_5195_4: bool = ((s_5195_1) == (s_5195_3));
        // D s_5195_5: write-var gs#134905 <= s_5195_4
        fn_state.gs_134905 = s_5195_4;
        // N s_5195_6: jump b958
        return block_958(state, tracer, fn_state);
    }
    fn block_5196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5196_0: read-var CRn:u8
        let s_5196_0: u8 = fn_state.CRn;
        // D s_5196_1: cast zx s_5196_0 -> bv
        let s_5196_1: Bits = Bits::new(s_5196_0 as u128, 4u16);
        // C s_5196_2: const #0u : u8
        let s_5196_2: u8 = 0;
        // C s_5196_3: cast zx s_5196_2 -> bv
        let s_5196_3: Bits = Bits::new(s_5196_2 as u128, 4u16);
        // D s_5196_4: cmp-eq s_5196_1 s_5196_3
        let s_5196_4: bool = ((s_5196_1) == (s_5196_3));
        // D s_5196_5: write-var gs#134904 <= s_5196_4
        fn_state.gs_134904 = s_5196_4;
        // N s_5196_6: jump b956
        return block_956(state, tracer, fn_state);
    }
    fn block_5197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5197_0: read-var el:u8
        let s_5197_0: u8 = fn_state.el;
        // D s_5197_1: read-var coproc:u8
        let s_5197_1: u8 = fn_state.coproc;
        // D s_5197_2: read-var opc1:u8
        let s_5197_2: u8 = fn_state.opc1;
        // D s_5197_3: read-var CRn:u8
        let s_5197_3: u8 = fn_state.CRn;
        // D s_5197_4: read-var opc2:u8
        let s_5197_4: u8 = fn_state.opc2;
        // D s_5197_5: read-var CRm:u8
        let s_5197_5: u8 = fn_state.CRm;
        // D s_5197_6: read-var t:i
        let s_5197_6: i128 = fn_state.t;
        // D s_5197_7: call DBGWCR_SysRegWrite32_505cf952454e62f6(s_5197_0, s_5197_1, s_5197_2, s_5197_3, s_5197_4, s_5197_5, s_5197_6)
        let s_5197_7: () = DBGWCR_SysRegWrite32_505cf952454e62f6(
            state,
            tracer,
            s_5197_0,
            s_5197_1,
            s_5197_2,
            s_5197_3,
            s_5197_4,
            s_5197_5,
            s_5197_6,
        );
        // N s_5197_8: return
        return;
    }
    fn block_5198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5198_0: read-var opc2:u8
        let s_5198_0: u8 = fn_state.opc2;
        // D s_5198_1: cast zx s_5198_0 -> bv
        let s_5198_1: Bits = Bits::new(s_5198_0 as u128, 3u16);
        // C s_5198_2: const #7u : u8
        let s_5198_2: u8 = 7;
        // C s_5198_3: cast zx s_5198_2 -> bv
        let s_5198_3: Bits = Bits::new(s_5198_2 as u128, 3u16);
        // D s_5198_4: cmp-eq s_5198_1 s_5198_3
        let s_5198_4: bool = ((s_5198_1) == (s_5198_3));
        // D s_5198_5: write-var gs#134903 <= s_5198_4
        fn_state.gs_134903 = s_5198_4;
        // N s_5198_6: jump b953
        return block_953(state, tracer, fn_state);
    }
    fn block_5199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5199_0: read-var opc1:u8
        let s_5199_0: u8 = fn_state.opc1;
        // D s_5199_1: cast zx s_5199_0 -> bv
        let s_5199_1: Bits = Bits::new(s_5199_0 as u128, 3u16);
        // C s_5199_2: const #0u : u8
        let s_5199_2: u8 = 0;
        // C s_5199_3: cast zx s_5199_2 -> bv
        let s_5199_3: Bits = Bits::new(s_5199_2 as u128, 3u16);
        // D s_5199_4: cmp-eq s_5199_1 s_5199_3
        let s_5199_4: bool = ((s_5199_1) == (s_5199_3));
        // D s_5199_5: write-var gs#134902 <= s_5199_4
        fn_state.gs_134902 = s_5199_4;
        // N s_5199_6: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_5200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5200_0: read-var coproc:u8
        let s_5200_0: u8 = fn_state.coproc;
        // D s_5200_1: cast zx s_5200_0 -> bv
        let s_5200_1: Bits = Bits::new(s_5200_0 as u128, 4u16);
        // C s_5200_2: const #14u : u8
        let s_5200_2: u8 = 14;
        // C s_5200_3: cast zx s_5200_2 -> bv
        let s_5200_3: Bits = Bits::new(s_5200_2 as u128, 4u16);
        // D s_5200_4: cmp-eq s_5200_1 s_5200_3
        let s_5200_4: bool = ((s_5200_1) == (s_5200_3));
        // D s_5200_5: write-var gs#134901 <= s_5200_4
        fn_state.gs_134901 = s_5200_4;
        // N s_5200_6: jump b949
        return block_949(state, tracer, fn_state);
    }
    fn block_5201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5201_0: read-var CRn:u8
        let s_5201_0: u8 = fn_state.CRn;
        // D s_5201_1: cast zx s_5201_0 -> bv
        let s_5201_1: Bits = Bits::new(s_5201_0 as u128, 4u16);
        // C s_5201_2: const #0u : u8
        let s_5201_2: u8 = 0;
        // C s_5201_3: cast zx s_5201_2 -> bv
        let s_5201_3: Bits = Bits::new(s_5201_2 as u128, 4u16);
        // D s_5201_4: cmp-eq s_5201_1 s_5201_3
        let s_5201_4: bool = ((s_5201_1) == (s_5201_3));
        // D s_5201_5: write-var gs#134900 <= s_5201_4
        fn_state.gs_134900 = s_5201_4;
        // N s_5201_6: jump b947
        return block_947(state, tracer, fn_state);
    }
    fn block_5202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5202_0: read-var el:u8
        let s_5202_0: u8 = fn_state.el;
        // D s_5202_1: read-var coproc:u8
        let s_5202_1: u8 = fn_state.coproc;
        // D s_5202_2: read-var opc1:u8
        let s_5202_2: u8 = fn_state.opc1;
        // D s_5202_3: read-var CRn:u8
        let s_5202_3: u8 = fn_state.CRn;
        // D s_5202_4: read-var opc2:u8
        let s_5202_4: u8 = fn_state.opc2;
        // D s_5202_5: read-var CRm:u8
        let s_5202_5: u8 = fn_state.CRm;
        // D s_5202_6: read-var t:i
        let s_5202_6: i128 = fn_state.t;
        // D s_5202_7: call DBGWCR_SysRegWrite32_ab57e15a1119cc89(s_5202_0, s_5202_1, s_5202_2, s_5202_3, s_5202_4, s_5202_5, s_5202_6)
        let s_5202_7: () = DBGWCR_SysRegWrite32_ab57e15a1119cc89(
            state,
            tracer,
            s_5202_0,
            s_5202_1,
            s_5202_2,
            s_5202_3,
            s_5202_4,
            s_5202_5,
            s_5202_6,
        );
        // N s_5202_8: return
        return;
    }
    fn block_5203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5203_0: read-var opc2:u8
        let s_5203_0: u8 = fn_state.opc2;
        // D s_5203_1: cast zx s_5203_0 -> bv
        let s_5203_1: Bits = Bits::new(s_5203_0 as u128, 3u16);
        // C s_5203_2: const #7u : u8
        let s_5203_2: u8 = 7;
        // C s_5203_3: cast zx s_5203_2 -> bv
        let s_5203_3: Bits = Bits::new(s_5203_2 as u128, 3u16);
        // D s_5203_4: cmp-eq s_5203_1 s_5203_3
        let s_5203_4: bool = ((s_5203_1) == (s_5203_3));
        // D s_5203_5: write-var gs#134899 <= s_5203_4
        fn_state.gs_134899 = s_5203_4;
        // N s_5203_6: jump b944
        return block_944(state, tracer, fn_state);
    }
    fn block_5204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5204_0: read-var opc1:u8
        let s_5204_0: u8 = fn_state.opc1;
        // D s_5204_1: cast zx s_5204_0 -> bv
        let s_5204_1: Bits = Bits::new(s_5204_0 as u128, 3u16);
        // C s_5204_2: const #0u : u8
        let s_5204_2: u8 = 0;
        // C s_5204_3: cast zx s_5204_2 -> bv
        let s_5204_3: Bits = Bits::new(s_5204_2 as u128, 3u16);
        // D s_5204_4: cmp-eq s_5204_1 s_5204_3
        let s_5204_4: bool = ((s_5204_1) == (s_5204_3));
        // D s_5204_5: write-var gs#134898 <= s_5204_4
        fn_state.gs_134898 = s_5204_4;
        // N s_5204_6: jump b942
        return block_942(state, tracer, fn_state);
    }
    fn block_5205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5205_0: read-var coproc:u8
        let s_5205_0: u8 = fn_state.coproc;
        // D s_5205_1: cast zx s_5205_0 -> bv
        let s_5205_1: Bits = Bits::new(s_5205_0 as u128, 4u16);
        // C s_5205_2: const #14u : u8
        let s_5205_2: u8 = 14;
        // C s_5205_3: cast zx s_5205_2 -> bv
        let s_5205_3: Bits = Bits::new(s_5205_2 as u128, 4u16);
        // D s_5205_4: cmp-eq s_5205_1 s_5205_3
        let s_5205_4: bool = ((s_5205_1) == (s_5205_3));
        // D s_5205_5: write-var gs#134897 <= s_5205_4
        fn_state.gs_134897 = s_5205_4;
        // N s_5205_6: jump b940
        return block_940(state, tracer, fn_state);
    }
    fn block_5206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5206_0: read-var CRn:u8
        let s_5206_0: u8 = fn_state.CRn;
        // D s_5206_1: cast zx s_5206_0 -> bv
        let s_5206_1: Bits = Bits::new(s_5206_0 as u128, 4u16);
        // C s_5206_2: const #0u : u8
        let s_5206_2: u8 = 0;
        // C s_5206_3: cast zx s_5206_2 -> bv
        let s_5206_3: Bits = Bits::new(s_5206_2 as u128, 4u16);
        // D s_5206_4: cmp-eq s_5206_1 s_5206_3
        let s_5206_4: bool = ((s_5206_1) == (s_5206_3));
        // D s_5206_5: write-var gs#134896 <= s_5206_4
        fn_state.gs_134896 = s_5206_4;
        // N s_5206_6: jump b938
        return block_938(state, tracer, fn_state);
    }
    fn block_5207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5207_0: read-var el:u8
        let s_5207_0: u8 = fn_state.el;
        // D s_5207_1: read-var coproc:u8
        let s_5207_1: u8 = fn_state.coproc;
        // D s_5207_2: read-var opc1:u8
        let s_5207_2: u8 = fn_state.opc1;
        // D s_5207_3: read-var CRn:u8
        let s_5207_3: u8 = fn_state.CRn;
        // D s_5207_4: read-var opc2:u8
        let s_5207_4: u8 = fn_state.opc2;
        // D s_5207_5: read-var CRm:u8
        let s_5207_5: u8 = fn_state.CRm;
        // D s_5207_6: read-var t:i
        let s_5207_6: i128 = fn_state.t;
        // D s_5207_7: call DBGWCR_SysRegWrite32_31697201fd39cd98(s_5207_0, s_5207_1, s_5207_2, s_5207_3, s_5207_4, s_5207_5, s_5207_6)
        let s_5207_7: () = DBGWCR_SysRegWrite32_31697201fd39cd98(
            state,
            tracer,
            s_5207_0,
            s_5207_1,
            s_5207_2,
            s_5207_3,
            s_5207_4,
            s_5207_5,
            s_5207_6,
        );
        // N s_5207_8: return
        return;
    }
    fn block_5208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5208_0: read-var opc2:u8
        let s_5208_0: u8 = fn_state.opc2;
        // D s_5208_1: cast zx s_5208_0 -> bv
        let s_5208_1: Bits = Bits::new(s_5208_0 as u128, 3u16);
        // C s_5208_2: const #7u : u8
        let s_5208_2: u8 = 7;
        // C s_5208_3: cast zx s_5208_2 -> bv
        let s_5208_3: Bits = Bits::new(s_5208_2 as u128, 3u16);
        // D s_5208_4: cmp-eq s_5208_1 s_5208_3
        let s_5208_4: bool = ((s_5208_1) == (s_5208_3));
        // D s_5208_5: write-var gs#134895 <= s_5208_4
        fn_state.gs_134895 = s_5208_4;
        // N s_5208_6: jump b935
        return block_935(state, tracer, fn_state);
    }
    fn block_5209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5209_0: read-var opc1:u8
        let s_5209_0: u8 = fn_state.opc1;
        // D s_5209_1: cast zx s_5209_0 -> bv
        let s_5209_1: Bits = Bits::new(s_5209_0 as u128, 3u16);
        // C s_5209_2: const #0u : u8
        let s_5209_2: u8 = 0;
        // C s_5209_3: cast zx s_5209_2 -> bv
        let s_5209_3: Bits = Bits::new(s_5209_2 as u128, 3u16);
        // D s_5209_4: cmp-eq s_5209_1 s_5209_3
        let s_5209_4: bool = ((s_5209_1) == (s_5209_3));
        // D s_5209_5: write-var gs#134894 <= s_5209_4
        fn_state.gs_134894 = s_5209_4;
        // N s_5209_6: jump b933
        return block_933(state, tracer, fn_state);
    }
    fn block_5210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5210_0: read-var coproc:u8
        let s_5210_0: u8 = fn_state.coproc;
        // D s_5210_1: cast zx s_5210_0 -> bv
        let s_5210_1: Bits = Bits::new(s_5210_0 as u128, 4u16);
        // C s_5210_2: const #14u : u8
        let s_5210_2: u8 = 14;
        // C s_5210_3: cast zx s_5210_2 -> bv
        let s_5210_3: Bits = Bits::new(s_5210_2 as u128, 4u16);
        // D s_5210_4: cmp-eq s_5210_1 s_5210_3
        let s_5210_4: bool = ((s_5210_1) == (s_5210_3));
        // D s_5210_5: write-var gs#134893 <= s_5210_4
        fn_state.gs_134893 = s_5210_4;
        // N s_5210_6: jump b931
        return block_931(state, tracer, fn_state);
    }
    fn block_5211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5211_0: read-var CRn:u8
        let s_5211_0: u8 = fn_state.CRn;
        // D s_5211_1: cast zx s_5211_0 -> bv
        let s_5211_1: Bits = Bits::new(s_5211_0 as u128, 4u16);
        // C s_5211_2: const #0u : u8
        let s_5211_2: u8 = 0;
        // C s_5211_3: cast zx s_5211_2 -> bv
        let s_5211_3: Bits = Bits::new(s_5211_2 as u128, 4u16);
        // D s_5211_4: cmp-eq s_5211_1 s_5211_3
        let s_5211_4: bool = ((s_5211_1) == (s_5211_3));
        // D s_5211_5: write-var gs#134892 <= s_5211_4
        fn_state.gs_134892 = s_5211_4;
        // N s_5211_6: jump b929
        return block_929(state, tracer, fn_state);
    }
    fn block_5212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5212_0: read-var el:u8
        let s_5212_0: u8 = fn_state.el;
        // D s_5212_1: read-var coproc:u8
        let s_5212_1: u8 = fn_state.coproc;
        // D s_5212_2: read-var opc1:u8
        let s_5212_2: u8 = fn_state.opc1;
        // D s_5212_3: read-var CRn:u8
        let s_5212_3: u8 = fn_state.CRn;
        // D s_5212_4: read-var opc2:u8
        let s_5212_4: u8 = fn_state.opc2;
        // D s_5212_5: read-var CRm:u8
        let s_5212_5: u8 = fn_state.CRm;
        // D s_5212_6: read-var t:i
        let s_5212_6: i128 = fn_state.t;
        // D s_5212_7: call DBGWCR_SysRegWrite32_7a1c0070fb5cde60(s_5212_0, s_5212_1, s_5212_2, s_5212_3, s_5212_4, s_5212_5, s_5212_6)
        let s_5212_7: () = DBGWCR_SysRegWrite32_7a1c0070fb5cde60(
            state,
            tracer,
            s_5212_0,
            s_5212_1,
            s_5212_2,
            s_5212_3,
            s_5212_4,
            s_5212_5,
            s_5212_6,
        );
        // N s_5212_8: return
        return;
    }
    fn block_5213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5213_0: read-var opc2:u8
        let s_5213_0: u8 = fn_state.opc2;
        // D s_5213_1: cast zx s_5213_0 -> bv
        let s_5213_1: Bits = Bits::new(s_5213_0 as u128, 3u16);
        // C s_5213_2: const #7u : u8
        let s_5213_2: u8 = 7;
        // C s_5213_3: cast zx s_5213_2 -> bv
        let s_5213_3: Bits = Bits::new(s_5213_2 as u128, 3u16);
        // D s_5213_4: cmp-eq s_5213_1 s_5213_3
        let s_5213_4: bool = ((s_5213_1) == (s_5213_3));
        // D s_5213_5: write-var gs#134891 <= s_5213_4
        fn_state.gs_134891 = s_5213_4;
        // N s_5213_6: jump b926
        return block_926(state, tracer, fn_state);
    }
    fn block_5214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5214_0: read-var opc1:u8
        let s_5214_0: u8 = fn_state.opc1;
        // D s_5214_1: cast zx s_5214_0 -> bv
        let s_5214_1: Bits = Bits::new(s_5214_0 as u128, 3u16);
        // C s_5214_2: const #0u : u8
        let s_5214_2: u8 = 0;
        // C s_5214_3: cast zx s_5214_2 -> bv
        let s_5214_3: Bits = Bits::new(s_5214_2 as u128, 3u16);
        // D s_5214_4: cmp-eq s_5214_1 s_5214_3
        let s_5214_4: bool = ((s_5214_1) == (s_5214_3));
        // D s_5214_5: write-var gs#134890 <= s_5214_4
        fn_state.gs_134890 = s_5214_4;
        // N s_5214_6: jump b924
        return block_924(state, tracer, fn_state);
    }
    fn block_5215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5215_0: read-var coproc:u8
        let s_5215_0: u8 = fn_state.coproc;
        // D s_5215_1: cast zx s_5215_0 -> bv
        let s_5215_1: Bits = Bits::new(s_5215_0 as u128, 4u16);
        // C s_5215_2: const #14u : u8
        let s_5215_2: u8 = 14;
        // C s_5215_3: cast zx s_5215_2 -> bv
        let s_5215_3: Bits = Bits::new(s_5215_2 as u128, 4u16);
        // D s_5215_4: cmp-eq s_5215_1 s_5215_3
        let s_5215_4: bool = ((s_5215_1) == (s_5215_3));
        // D s_5215_5: write-var gs#134889 <= s_5215_4
        fn_state.gs_134889 = s_5215_4;
        // N s_5215_6: jump b922
        return block_922(state, tracer, fn_state);
    }
    fn block_5216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5216_0: read-var CRn:u8
        let s_5216_0: u8 = fn_state.CRn;
        // D s_5216_1: cast zx s_5216_0 -> bv
        let s_5216_1: Bits = Bits::new(s_5216_0 as u128, 4u16);
        // C s_5216_2: const #0u : u8
        let s_5216_2: u8 = 0;
        // C s_5216_3: cast zx s_5216_2 -> bv
        let s_5216_3: Bits = Bits::new(s_5216_2 as u128, 4u16);
        // D s_5216_4: cmp-eq s_5216_1 s_5216_3
        let s_5216_4: bool = ((s_5216_1) == (s_5216_3));
        // D s_5216_5: write-var gs#134888 <= s_5216_4
        fn_state.gs_134888 = s_5216_4;
        // N s_5216_6: jump b920
        return block_920(state, tracer, fn_state);
    }
    fn block_5217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5217_0: read-var el:u8
        let s_5217_0: u8 = fn_state.el;
        // D s_5217_1: read-var coproc:u8
        let s_5217_1: u8 = fn_state.coproc;
        // D s_5217_2: read-var opc1:u8
        let s_5217_2: u8 = fn_state.opc1;
        // D s_5217_3: read-var CRn:u8
        let s_5217_3: u8 = fn_state.CRn;
        // D s_5217_4: read-var opc2:u8
        let s_5217_4: u8 = fn_state.opc2;
        // D s_5217_5: read-var CRm:u8
        let s_5217_5: u8 = fn_state.CRm;
        // D s_5217_6: read-var t:i
        let s_5217_6: i128 = fn_state.t;
        // D s_5217_7: call DBGWCR_SysRegWrite32_ff5d8b7776f3598d(s_5217_0, s_5217_1, s_5217_2, s_5217_3, s_5217_4, s_5217_5, s_5217_6)
        let s_5217_7: () = DBGWCR_SysRegWrite32_ff5d8b7776f3598d(
            state,
            tracer,
            s_5217_0,
            s_5217_1,
            s_5217_2,
            s_5217_3,
            s_5217_4,
            s_5217_5,
            s_5217_6,
        );
        // N s_5217_8: return
        return;
    }
    fn block_5218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5218_0: read-var opc2:u8
        let s_5218_0: u8 = fn_state.opc2;
        // D s_5218_1: cast zx s_5218_0 -> bv
        let s_5218_1: Bits = Bits::new(s_5218_0 as u128, 3u16);
        // C s_5218_2: const #7u : u8
        let s_5218_2: u8 = 7;
        // C s_5218_3: cast zx s_5218_2 -> bv
        let s_5218_3: Bits = Bits::new(s_5218_2 as u128, 3u16);
        // D s_5218_4: cmp-eq s_5218_1 s_5218_3
        let s_5218_4: bool = ((s_5218_1) == (s_5218_3));
        // D s_5218_5: write-var gs#134887 <= s_5218_4
        fn_state.gs_134887 = s_5218_4;
        // N s_5218_6: jump b917
        return block_917(state, tracer, fn_state);
    }
    fn block_5219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5219_0: read-var opc1:u8
        let s_5219_0: u8 = fn_state.opc1;
        // D s_5219_1: cast zx s_5219_0 -> bv
        let s_5219_1: Bits = Bits::new(s_5219_0 as u128, 3u16);
        // C s_5219_2: const #0u : u8
        let s_5219_2: u8 = 0;
        // C s_5219_3: cast zx s_5219_2 -> bv
        let s_5219_3: Bits = Bits::new(s_5219_2 as u128, 3u16);
        // D s_5219_4: cmp-eq s_5219_1 s_5219_3
        let s_5219_4: bool = ((s_5219_1) == (s_5219_3));
        // D s_5219_5: write-var gs#134886 <= s_5219_4
        fn_state.gs_134886 = s_5219_4;
        // N s_5219_6: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_5220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5220_0: read-var coproc:u8
        let s_5220_0: u8 = fn_state.coproc;
        // D s_5220_1: cast zx s_5220_0 -> bv
        let s_5220_1: Bits = Bits::new(s_5220_0 as u128, 4u16);
        // C s_5220_2: const #14u : u8
        let s_5220_2: u8 = 14;
        // C s_5220_3: cast zx s_5220_2 -> bv
        let s_5220_3: Bits = Bits::new(s_5220_2 as u128, 4u16);
        // D s_5220_4: cmp-eq s_5220_1 s_5220_3
        let s_5220_4: bool = ((s_5220_1) == (s_5220_3));
        // D s_5220_5: write-var gs#134885 <= s_5220_4
        fn_state.gs_134885 = s_5220_4;
        // N s_5220_6: jump b913
        return block_913(state, tracer, fn_state);
    }
    fn block_5221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5221_0: read-var CRn:u8
        let s_5221_0: u8 = fn_state.CRn;
        // D s_5221_1: cast zx s_5221_0 -> bv
        let s_5221_1: Bits = Bits::new(s_5221_0 as u128, 4u16);
        // C s_5221_2: const #0u : u8
        let s_5221_2: u8 = 0;
        // C s_5221_3: cast zx s_5221_2 -> bv
        let s_5221_3: Bits = Bits::new(s_5221_2 as u128, 4u16);
        // D s_5221_4: cmp-eq s_5221_1 s_5221_3
        let s_5221_4: bool = ((s_5221_1) == (s_5221_3));
        // D s_5221_5: write-var gs#134884 <= s_5221_4
        fn_state.gs_134884 = s_5221_4;
        // N s_5221_6: jump b911
        return block_911(state, tracer, fn_state);
    }
    fn block_5222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5222_0: read-var el:u8
        let s_5222_0: u8 = fn_state.el;
        // D s_5222_1: read-var coproc:u8
        let s_5222_1: u8 = fn_state.coproc;
        // D s_5222_2: read-var opc1:u8
        let s_5222_2: u8 = fn_state.opc1;
        // D s_5222_3: read-var CRn:u8
        let s_5222_3: u8 = fn_state.CRn;
        // D s_5222_4: read-var opc2:u8
        let s_5222_4: u8 = fn_state.opc2;
        // D s_5222_5: read-var CRm:u8
        let s_5222_5: u8 = fn_state.CRm;
        // D s_5222_6: read-var t:i
        let s_5222_6: i128 = fn_state.t;
        // D s_5222_7: call DBGWCR_SysRegWrite32_74267755c7b7026a(s_5222_0, s_5222_1, s_5222_2, s_5222_3, s_5222_4, s_5222_5, s_5222_6)
        let s_5222_7: () = DBGWCR_SysRegWrite32_74267755c7b7026a(
            state,
            tracer,
            s_5222_0,
            s_5222_1,
            s_5222_2,
            s_5222_3,
            s_5222_4,
            s_5222_5,
            s_5222_6,
        );
        // N s_5222_8: return
        return;
    }
    fn block_5223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5223_0: read-var opc2:u8
        let s_5223_0: u8 = fn_state.opc2;
        // D s_5223_1: cast zx s_5223_0 -> bv
        let s_5223_1: Bits = Bits::new(s_5223_0 as u128, 3u16);
        // C s_5223_2: const #7u : u8
        let s_5223_2: u8 = 7;
        // C s_5223_3: cast zx s_5223_2 -> bv
        let s_5223_3: Bits = Bits::new(s_5223_2 as u128, 3u16);
        // D s_5223_4: cmp-eq s_5223_1 s_5223_3
        let s_5223_4: bool = ((s_5223_1) == (s_5223_3));
        // D s_5223_5: write-var gs#134883 <= s_5223_4
        fn_state.gs_134883 = s_5223_4;
        // N s_5223_6: jump b908
        return block_908(state, tracer, fn_state);
    }
    fn block_5224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5224_0: read-var opc1:u8
        let s_5224_0: u8 = fn_state.opc1;
        // D s_5224_1: cast zx s_5224_0 -> bv
        let s_5224_1: Bits = Bits::new(s_5224_0 as u128, 3u16);
        // C s_5224_2: const #0u : u8
        let s_5224_2: u8 = 0;
        // C s_5224_3: cast zx s_5224_2 -> bv
        let s_5224_3: Bits = Bits::new(s_5224_2 as u128, 3u16);
        // D s_5224_4: cmp-eq s_5224_1 s_5224_3
        let s_5224_4: bool = ((s_5224_1) == (s_5224_3));
        // D s_5224_5: write-var gs#134882 <= s_5224_4
        fn_state.gs_134882 = s_5224_4;
        // N s_5224_6: jump b906
        return block_906(state, tracer, fn_state);
    }
    fn block_5225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5225_0: read-var coproc:u8
        let s_5225_0: u8 = fn_state.coproc;
        // D s_5225_1: cast zx s_5225_0 -> bv
        let s_5225_1: Bits = Bits::new(s_5225_0 as u128, 4u16);
        // C s_5225_2: const #14u : u8
        let s_5225_2: u8 = 14;
        // C s_5225_3: cast zx s_5225_2 -> bv
        let s_5225_3: Bits = Bits::new(s_5225_2 as u128, 4u16);
        // D s_5225_4: cmp-eq s_5225_1 s_5225_3
        let s_5225_4: bool = ((s_5225_1) == (s_5225_3));
        // D s_5225_5: write-var gs#134881 <= s_5225_4
        fn_state.gs_134881 = s_5225_4;
        // N s_5225_6: jump b904
        return block_904(state, tracer, fn_state);
    }
    fn block_5226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5226_0: read-var CRn:u8
        let s_5226_0: u8 = fn_state.CRn;
        // D s_5226_1: cast zx s_5226_0 -> bv
        let s_5226_1: Bits = Bits::new(s_5226_0 as u128, 4u16);
        // C s_5226_2: const #0u : u8
        let s_5226_2: u8 = 0;
        // C s_5226_3: cast zx s_5226_2 -> bv
        let s_5226_3: Bits = Bits::new(s_5226_2 as u128, 4u16);
        // D s_5226_4: cmp-eq s_5226_1 s_5226_3
        let s_5226_4: bool = ((s_5226_1) == (s_5226_3));
        // D s_5226_5: write-var gs#134880 <= s_5226_4
        fn_state.gs_134880 = s_5226_4;
        // N s_5226_6: jump b902
        return block_902(state, tracer, fn_state);
    }
    fn block_5227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5227_0: read-var el:u8
        let s_5227_0: u8 = fn_state.el;
        // D s_5227_1: read-var coproc:u8
        let s_5227_1: u8 = fn_state.coproc;
        // D s_5227_2: read-var opc1:u8
        let s_5227_2: u8 = fn_state.opc1;
        // D s_5227_3: read-var CRn:u8
        let s_5227_3: u8 = fn_state.CRn;
        // D s_5227_4: read-var opc2:u8
        let s_5227_4: u8 = fn_state.opc2;
        // D s_5227_5: read-var CRm:u8
        let s_5227_5: u8 = fn_state.CRm;
        // D s_5227_6: read-var t:i
        let s_5227_6: i128 = fn_state.t;
        // D s_5227_7: call DBGWCR_SysRegWrite32_b843cfc47f6433bd(s_5227_0, s_5227_1, s_5227_2, s_5227_3, s_5227_4, s_5227_5, s_5227_6)
        let s_5227_7: () = DBGWCR_SysRegWrite32_b843cfc47f6433bd(
            state,
            tracer,
            s_5227_0,
            s_5227_1,
            s_5227_2,
            s_5227_3,
            s_5227_4,
            s_5227_5,
            s_5227_6,
        );
        // N s_5227_8: return
        return;
    }
    fn block_5228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5228_0: read-var opc2:u8
        let s_5228_0: u8 = fn_state.opc2;
        // D s_5228_1: cast zx s_5228_0 -> bv
        let s_5228_1: Bits = Bits::new(s_5228_0 as u128, 3u16);
        // C s_5228_2: const #7u : u8
        let s_5228_2: u8 = 7;
        // C s_5228_3: cast zx s_5228_2 -> bv
        let s_5228_3: Bits = Bits::new(s_5228_2 as u128, 3u16);
        // D s_5228_4: cmp-eq s_5228_1 s_5228_3
        let s_5228_4: bool = ((s_5228_1) == (s_5228_3));
        // D s_5228_5: write-var gs#134879 <= s_5228_4
        fn_state.gs_134879 = s_5228_4;
        // N s_5228_6: jump b899
        return block_899(state, tracer, fn_state);
    }
    fn block_5229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5229_0: read-var opc1:u8
        let s_5229_0: u8 = fn_state.opc1;
        // D s_5229_1: cast zx s_5229_0 -> bv
        let s_5229_1: Bits = Bits::new(s_5229_0 as u128, 3u16);
        // C s_5229_2: const #0u : u8
        let s_5229_2: u8 = 0;
        // C s_5229_3: cast zx s_5229_2 -> bv
        let s_5229_3: Bits = Bits::new(s_5229_2 as u128, 3u16);
        // D s_5229_4: cmp-eq s_5229_1 s_5229_3
        let s_5229_4: bool = ((s_5229_1) == (s_5229_3));
        // D s_5229_5: write-var gs#134878 <= s_5229_4
        fn_state.gs_134878 = s_5229_4;
        // N s_5229_6: jump b897
        return block_897(state, tracer, fn_state);
    }
    fn block_5230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5230_0: read-var coproc:u8
        let s_5230_0: u8 = fn_state.coproc;
        // D s_5230_1: cast zx s_5230_0 -> bv
        let s_5230_1: Bits = Bits::new(s_5230_0 as u128, 4u16);
        // C s_5230_2: const #14u : u8
        let s_5230_2: u8 = 14;
        // C s_5230_3: cast zx s_5230_2 -> bv
        let s_5230_3: Bits = Bits::new(s_5230_2 as u128, 4u16);
        // D s_5230_4: cmp-eq s_5230_1 s_5230_3
        let s_5230_4: bool = ((s_5230_1) == (s_5230_3));
        // D s_5230_5: write-var gs#134877 <= s_5230_4
        fn_state.gs_134877 = s_5230_4;
        // N s_5230_6: jump b895
        return block_895(state, tracer, fn_state);
    }
    fn block_5231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5231_0: read-var CRn:u8
        let s_5231_0: u8 = fn_state.CRn;
        // D s_5231_1: cast zx s_5231_0 -> bv
        let s_5231_1: Bits = Bits::new(s_5231_0 as u128, 4u16);
        // C s_5231_2: const #0u : u8
        let s_5231_2: u8 = 0;
        // C s_5231_3: cast zx s_5231_2 -> bv
        let s_5231_3: Bits = Bits::new(s_5231_2 as u128, 4u16);
        // D s_5231_4: cmp-eq s_5231_1 s_5231_3
        let s_5231_4: bool = ((s_5231_1) == (s_5231_3));
        // D s_5231_5: write-var gs#134876 <= s_5231_4
        fn_state.gs_134876 = s_5231_4;
        // N s_5231_6: jump b893
        return block_893(state, tracer, fn_state);
    }
    fn block_5232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5232_0: read-var el:u8
        let s_5232_0: u8 = fn_state.el;
        // D s_5232_1: read-var coproc:u8
        let s_5232_1: u8 = fn_state.coproc;
        // D s_5232_2: read-var opc1:u8
        let s_5232_2: u8 = fn_state.opc1;
        // D s_5232_3: read-var CRn:u8
        let s_5232_3: u8 = fn_state.CRn;
        // D s_5232_4: read-var opc2:u8
        let s_5232_4: u8 = fn_state.opc2;
        // D s_5232_5: read-var CRm:u8
        let s_5232_5: u8 = fn_state.CRm;
        // D s_5232_6: read-var t:i
        let s_5232_6: i128 = fn_state.t;
        // D s_5232_7: call DBGWCR_SysRegWrite32_3b90b969bb7720ca(s_5232_0, s_5232_1, s_5232_2, s_5232_3, s_5232_4, s_5232_5, s_5232_6)
        let s_5232_7: () = DBGWCR_SysRegWrite32_3b90b969bb7720ca(
            state,
            tracer,
            s_5232_0,
            s_5232_1,
            s_5232_2,
            s_5232_3,
            s_5232_4,
            s_5232_5,
            s_5232_6,
        );
        // N s_5232_8: return
        return;
    }
    fn block_5233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5233_0: read-var opc2:u8
        let s_5233_0: u8 = fn_state.opc2;
        // D s_5233_1: cast zx s_5233_0 -> bv
        let s_5233_1: Bits = Bits::new(s_5233_0 as u128, 3u16);
        // C s_5233_2: const #7u : u8
        let s_5233_2: u8 = 7;
        // C s_5233_3: cast zx s_5233_2 -> bv
        let s_5233_3: Bits = Bits::new(s_5233_2 as u128, 3u16);
        // D s_5233_4: cmp-eq s_5233_1 s_5233_3
        let s_5233_4: bool = ((s_5233_1) == (s_5233_3));
        // D s_5233_5: write-var gs#134875 <= s_5233_4
        fn_state.gs_134875 = s_5233_4;
        // N s_5233_6: jump b890
        return block_890(state, tracer, fn_state);
    }
    fn block_5234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5234_0: read-var opc1:u8
        let s_5234_0: u8 = fn_state.opc1;
        // D s_5234_1: cast zx s_5234_0 -> bv
        let s_5234_1: Bits = Bits::new(s_5234_0 as u128, 3u16);
        // C s_5234_2: const #0u : u8
        let s_5234_2: u8 = 0;
        // C s_5234_3: cast zx s_5234_2 -> bv
        let s_5234_3: Bits = Bits::new(s_5234_2 as u128, 3u16);
        // D s_5234_4: cmp-eq s_5234_1 s_5234_3
        let s_5234_4: bool = ((s_5234_1) == (s_5234_3));
        // D s_5234_5: write-var gs#134874 <= s_5234_4
        fn_state.gs_134874 = s_5234_4;
        // N s_5234_6: jump b888
        return block_888(state, tracer, fn_state);
    }
    fn block_5235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5235_0: read-var coproc:u8
        let s_5235_0: u8 = fn_state.coproc;
        // D s_5235_1: cast zx s_5235_0 -> bv
        let s_5235_1: Bits = Bits::new(s_5235_0 as u128, 4u16);
        // C s_5235_2: const #14u : u8
        let s_5235_2: u8 = 14;
        // C s_5235_3: cast zx s_5235_2 -> bv
        let s_5235_3: Bits = Bits::new(s_5235_2 as u128, 4u16);
        // D s_5235_4: cmp-eq s_5235_1 s_5235_3
        let s_5235_4: bool = ((s_5235_1) == (s_5235_3));
        // D s_5235_5: write-var gs#134873 <= s_5235_4
        fn_state.gs_134873 = s_5235_4;
        // N s_5235_6: jump b886
        return block_886(state, tracer, fn_state);
    }
    fn block_5236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5236_0: read-var CRn:u8
        let s_5236_0: u8 = fn_state.CRn;
        // D s_5236_1: cast zx s_5236_0 -> bv
        let s_5236_1: Bits = Bits::new(s_5236_0 as u128, 4u16);
        // C s_5236_2: const #0u : u8
        let s_5236_2: u8 = 0;
        // C s_5236_3: cast zx s_5236_2 -> bv
        let s_5236_3: Bits = Bits::new(s_5236_2 as u128, 4u16);
        // D s_5236_4: cmp-eq s_5236_1 s_5236_3
        let s_5236_4: bool = ((s_5236_1) == (s_5236_3));
        // D s_5236_5: write-var gs#134872 <= s_5236_4
        fn_state.gs_134872 = s_5236_4;
        // N s_5236_6: jump b884
        return block_884(state, tracer, fn_state);
    }
    fn block_5237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5237_0: read-var el:u8
        let s_5237_0: u8 = fn_state.el;
        // D s_5237_1: read-var coproc:u8
        let s_5237_1: u8 = fn_state.coproc;
        // D s_5237_2: read-var opc1:u8
        let s_5237_2: u8 = fn_state.opc1;
        // D s_5237_3: read-var CRn:u8
        let s_5237_3: u8 = fn_state.CRn;
        // D s_5237_4: read-var opc2:u8
        let s_5237_4: u8 = fn_state.opc2;
        // D s_5237_5: read-var CRm:u8
        let s_5237_5: u8 = fn_state.CRm;
        // D s_5237_6: read-var t:i
        let s_5237_6: i128 = fn_state.t;
        // D s_5237_7: call DBGWCR_SysRegWrite32_16fb8a88dc2a6a09(s_5237_0, s_5237_1, s_5237_2, s_5237_3, s_5237_4, s_5237_5, s_5237_6)
        let s_5237_7: () = DBGWCR_SysRegWrite32_16fb8a88dc2a6a09(
            state,
            tracer,
            s_5237_0,
            s_5237_1,
            s_5237_2,
            s_5237_3,
            s_5237_4,
            s_5237_5,
            s_5237_6,
        );
        // N s_5237_8: return
        return;
    }
    fn block_5238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5238_0: read-var opc2:u8
        let s_5238_0: u8 = fn_state.opc2;
        // D s_5238_1: cast zx s_5238_0 -> bv
        let s_5238_1: Bits = Bits::new(s_5238_0 as u128, 3u16);
        // C s_5238_2: const #7u : u8
        let s_5238_2: u8 = 7;
        // C s_5238_3: cast zx s_5238_2 -> bv
        let s_5238_3: Bits = Bits::new(s_5238_2 as u128, 3u16);
        // D s_5238_4: cmp-eq s_5238_1 s_5238_3
        let s_5238_4: bool = ((s_5238_1) == (s_5238_3));
        // D s_5238_5: write-var gs#134871 <= s_5238_4
        fn_state.gs_134871 = s_5238_4;
        // N s_5238_6: jump b881
        return block_881(state, tracer, fn_state);
    }
    fn block_5239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5239_0: read-var opc1:u8
        let s_5239_0: u8 = fn_state.opc1;
        // D s_5239_1: cast zx s_5239_0 -> bv
        let s_5239_1: Bits = Bits::new(s_5239_0 as u128, 3u16);
        // C s_5239_2: const #0u : u8
        let s_5239_2: u8 = 0;
        // C s_5239_3: cast zx s_5239_2 -> bv
        let s_5239_3: Bits = Bits::new(s_5239_2 as u128, 3u16);
        // D s_5239_4: cmp-eq s_5239_1 s_5239_3
        let s_5239_4: bool = ((s_5239_1) == (s_5239_3));
        // D s_5239_5: write-var gs#134870 <= s_5239_4
        fn_state.gs_134870 = s_5239_4;
        // N s_5239_6: jump b879
        return block_879(state, tracer, fn_state);
    }
    fn block_5240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5240_0: read-var coproc:u8
        let s_5240_0: u8 = fn_state.coproc;
        // D s_5240_1: cast zx s_5240_0 -> bv
        let s_5240_1: Bits = Bits::new(s_5240_0 as u128, 4u16);
        // C s_5240_2: const #14u : u8
        let s_5240_2: u8 = 14;
        // C s_5240_3: cast zx s_5240_2 -> bv
        let s_5240_3: Bits = Bits::new(s_5240_2 as u128, 4u16);
        // D s_5240_4: cmp-eq s_5240_1 s_5240_3
        let s_5240_4: bool = ((s_5240_1) == (s_5240_3));
        // D s_5240_5: write-var gs#134869 <= s_5240_4
        fn_state.gs_134869 = s_5240_4;
        // N s_5240_6: jump b877
        return block_877(state, tracer, fn_state);
    }
    fn block_5241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5241_0: read-var CRn:u8
        let s_5241_0: u8 = fn_state.CRn;
        // D s_5241_1: cast zx s_5241_0 -> bv
        let s_5241_1: Bits = Bits::new(s_5241_0 as u128, 4u16);
        // C s_5241_2: const #0u : u8
        let s_5241_2: u8 = 0;
        // C s_5241_3: cast zx s_5241_2 -> bv
        let s_5241_3: Bits = Bits::new(s_5241_2 as u128, 4u16);
        // D s_5241_4: cmp-eq s_5241_1 s_5241_3
        let s_5241_4: bool = ((s_5241_1) == (s_5241_3));
        // D s_5241_5: write-var gs#134868 <= s_5241_4
        fn_state.gs_134868 = s_5241_4;
        // N s_5241_6: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_5242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5242_0: read-var el:u8
        let s_5242_0: u8 = fn_state.el;
        // D s_5242_1: read-var coproc:u8
        let s_5242_1: u8 = fn_state.coproc;
        // D s_5242_2: read-var opc1:u8
        let s_5242_2: u8 = fn_state.opc1;
        // D s_5242_3: read-var CRn:u8
        let s_5242_3: u8 = fn_state.CRn;
        // D s_5242_4: read-var opc2:u8
        let s_5242_4: u8 = fn_state.opc2;
        // D s_5242_5: read-var CRm:u8
        let s_5242_5: u8 = fn_state.CRm;
        // D s_5242_6: read-var t:i
        let s_5242_6: i128 = fn_state.t;
        // D s_5242_7: call DBGWCR_SysRegWrite32_0d78661888bb9fac(s_5242_0, s_5242_1, s_5242_2, s_5242_3, s_5242_4, s_5242_5, s_5242_6)
        let s_5242_7: () = DBGWCR_SysRegWrite32_0d78661888bb9fac(
            state,
            tracer,
            s_5242_0,
            s_5242_1,
            s_5242_2,
            s_5242_3,
            s_5242_4,
            s_5242_5,
            s_5242_6,
        );
        // N s_5242_8: return
        return;
    }
    fn block_5243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5243_0: read-var opc2:u8
        let s_5243_0: u8 = fn_state.opc2;
        // D s_5243_1: cast zx s_5243_0 -> bv
        let s_5243_1: Bits = Bits::new(s_5243_0 as u128, 3u16);
        // C s_5243_2: const #7u : u8
        let s_5243_2: u8 = 7;
        // C s_5243_3: cast zx s_5243_2 -> bv
        let s_5243_3: Bits = Bits::new(s_5243_2 as u128, 3u16);
        // D s_5243_4: cmp-eq s_5243_1 s_5243_3
        let s_5243_4: bool = ((s_5243_1) == (s_5243_3));
        // D s_5243_5: write-var gs#134867 <= s_5243_4
        fn_state.gs_134867 = s_5243_4;
        // N s_5243_6: jump b872
        return block_872(state, tracer, fn_state);
    }
    fn block_5244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5244_0: read-var opc1:u8
        let s_5244_0: u8 = fn_state.opc1;
        // D s_5244_1: cast zx s_5244_0 -> bv
        let s_5244_1: Bits = Bits::new(s_5244_0 as u128, 3u16);
        // C s_5244_2: const #0u : u8
        let s_5244_2: u8 = 0;
        // C s_5244_3: cast zx s_5244_2 -> bv
        let s_5244_3: Bits = Bits::new(s_5244_2 as u128, 3u16);
        // D s_5244_4: cmp-eq s_5244_1 s_5244_3
        let s_5244_4: bool = ((s_5244_1) == (s_5244_3));
        // D s_5244_5: write-var gs#134866 <= s_5244_4
        fn_state.gs_134866 = s_5244_4;
        // N s_5244_6: jump b870
        return block_870(state, tracer, fn_state);
    }
    fn block_5245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5245_0: read-var coproc:u8
        let s_5245_0: u8 = fn_state.coproc;
        // D s_5245_1: cast zx s_5245_0 -> bv
        let s_5245_1: Bits = Bits::new(s_5245_0 as u128, 4u16);
        // C s_5245_2: const #14u : u8
        let s_5245_2: u8 = 14;
        // C s_5245_3: cast zx s_5245_2 -> bv
        let s_5245_3: Bits = Bits::new(s_5245_2 as u128, 4u16);
        // D s_5245_4: cmp-eq s_5245_1 s_5245_3
        let s_5245_4: bool = ((s_5245_1) == (s_5245_3));
        // D s_5245_5: write-var gs#134865 <= s_5245_4
        fn_state.gs_134865 = s_5245_4;
        // N s_5245_6: jump b868
        return block_868(state, tracer, fn_state);
    }
    fn block_5246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5246_0: read-var CRn:u8
        let s_5246_0: u8 = fn_state.CRn;
        // D s_5246_1: cast zx s_5246_0 -> bv
        let s_5246_1: Bits = Bits::new(s_5246_0 as u128, 4u16);
        // C s_5246_2: const #0u : u8
        let s_5246_2: u8 = 0;
        // C s_5246_3: cast zx s_5246_2 -> bv
        let s_5246_3: Bits = Bits::new(s_5246_2 as u128, 4u16);
        // D s_5246_4: cmp-eq s_5246_1 s_5246_3
        let s_5246_4: bool = ((s_5246_1) == (s_5246_3));
        // D s_5246_5: write-var gs#134864 <= s_5246_4
        fn_state.gs_134864 = s_5246_4;
        // N s_5246_6: jump b866
        return block_866(state, tracer, fn_state);
    }
    fn block_5247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5247_0: read-var el:u8
        let s_5247_0: u8 = fn_state.el;
        // D s_5247_1: read-var coproc:u8
        let s_5247_1: u8 = fn_state.coproc;
        // D s_5247_2: read-var opc1:u8
        let s_5247_2: u8 = fn_state.opc1;
        // D s_5247_3: read-var CRn:u8
        let s_5247_3: u8 = fn_state.CRn;
        // D s_5247_4: read-var opc2:u8
        let s_5247_4: u8 = fn_state.opc2;
        // D s_5247_5: read-var CRm:u8
        let s_5247_5: u8 = fn_state.CRm;
        // D s_5247_6: read-var t:i
        let s_5247_6: i128 = fn_state.t;
        // D s_5247_7: call TLBIMVAL_SysRegWrite32_db84fa64000a2011(s_5247_0, s_5247_1, s_5247_2, s_5247_3, s_5247_4, s_5247_5, s_5247_6)
        let s_5247_7: () = TLBIMVAL_SysRegWrite32_db84fa64000a2011(
            state,
            tracer,
            s_5247_0,
            s_5247_1,
            s_5247_2,
            s_5247_3,
            s_5247_4,
            s_5247_5,
            s_5247_6,
        );
        // N s_5247_8: return
        return;
    }
    fn block_5248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5248_0: read-var opc2:u8
        let s_5248_0: u8 = fn_state.opc2;
        // D s_5248_1: cast zx s_5248_0 -> bv
        let s_5248_1: Bits = Bits::new(s_5248_0 as u128, 3u16);
        // C s_5248_2: const #5u : u8
        let s_5248_2: u8 = 5;
        // C s_5248_3: cast zx s_5248_2 -> bv
        let s_5248_3: Bits = Bits::new(s_5248_2 as u128, 3u16);
        // D s_5248_4: cmp-eq s_5248_1 s_5248_3
        let s_5248_4: bool = ((s_5248_1) == (s_5248_3));
        // D s_5248_5: write-var gs#134863 <= s_5248_4
        fn_state.gs_134863 = s_5248_4;
        // N s_5248_6: jump b863
        return block_863(state, tracer, fn_state);
    }
    fn block_5249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5249_0: read-var opc1:u8
        let s_5249_0: u8 = fn_state.opc1;
        // D s_5249_1: cast zx s_5249_0 -> bv
        let s_5249_1: Bits = Bits::new(s_5249_0 as u128, 3u16);
        // C s_5249_2: const #0u : u8
        let s_5249_2: u8 = 0;
        // C s_5249_3: cast zx s_5249_2 -> bv
        let s_5249_3: Bits = Bits::new(s_5249_2 as u128, 3u16);
        // D s_5249_4: cmp-eq s_5249_1 s_5249_3
        let s_5249_4: bool = ((s_5249_1) == (s_5249_3));
        // D s_5249_5: write-var gs#134862 <= s_5249_4
        fn_state.gs_134862 = s_5249_4;
        // N s_5249_6: jump b861
        return block_861(state, tracer, fn_state);
    }
    fn block_5250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5250_0: read-var coproc:u8
        let s_5250_0: u8 = fn_state.coproc;
        // D s_5250_1: cast zx s_5250_0 -> bv
        let s_5250_1: Bits = Bits::new(s_5250_0 as u128, 4u16);
        // C s_5250_2: const #15u : u8
        let s_5250_2: u8 = 15;
        // C s_5250_3: cast zx s_5250_2 -> bv
        let s_5250_3: Bits = Bits::new(s_5250_2 as u128, 4u16);
        // D s_5250_4: cmp-eq s_5250_1 s_5250_3
        let s_5250_4: bool = ((s_5250_1) == (s_5250_3));
        // D s_5250_5: write-var gs#134861 <= s_5250_4
        fn_state.gs_134861 = s_5250_4;
        // N s_5250_6: jump b859
        return block_859(state, tracer, fn_state);
    }
    fn block_5251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5251_0: read-var CRn:u8
        let s_5251_0: u8 = fn_state.CRn;
        // D s_5251_1: cast zx s_5251_0 -> bv
        let s_5251_1: Bits = Bits::new(s_5251_0 as u128, 4u16);
        // C s_5251_2: const #8u : u8
        let s_5251_2: u8 = 8;
        // C s_5251_3: cast zx s_5251_2 -> bv
        let s_5251_3: Bits = Bits::new(s_5251_2 as u128, 4u16);
        // D s_5251_4: cmp-eq s_5251_1 s_5251_3
        let s_5251_4: bool = ((s_5251_1) == (s_5251_3));
        // D s_5251_5: write-var gs#134860 <= s_5251_4
        fn_state.gs_134860 = s_5251_4;
        // N s_5251_6: jump b857
        return block_857(state, tracer, fn_state);
    }
    fn block_5252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5252_0: read-var el:u8
        let s_5252_0: u8 = fn_state.el;
        // D s_5252_1: read-var coproc:u8
        let s_5252_1: u8 = fn_state.coproc;
        // D s_5252_2: read-var opc1:u8
        let s_5252_2: u8 = fn_state.opc1;
        // D s_5252_3: read-var CRn:u8
        let s_5252_3: u8 = fn_state.CRn;
        // D s_5252_4: read-var opc2:u8
        let s_5252_4: u8 = fn_state.opc2;
        // D s_5252_5: read-var CRm:u8
        let s_5252_5: u8 = fn_state.CRm;
        // D s_5252_6: read-var t:i
        let s_5252_6: i128 = fn_state.t;
        // D s_5252_7: call PMCR_SysRegWrite32_ed58155cb22a3fd6(s_5252_0, s_5252_1, s_5252_2, s_5252_3, s_5252_4, s_5252_5, s_5252_6)
        let s_5252_7: () = PMCR_SysRegWrite32_ed58155cb22a3fd6(
            state,
            tracer,
            s_5252_0,
            s_5252_1,
            s_5252_2,
            s_5252_3,
            s_5252_4,
            s_5252_5,
            s_5252_6,
        );
        // N s_5252_8: return
        return;
    }
    fn block_5253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5253_0: read-var opc2:u8
        let s_5253_0: u8 = fn_state.opc2;
        // D s_5253_1: cast zx s_5253_0 -> bv
        let s_5253_1: Bits = Bits::new(s_5253_0 as u128, 3u16);
        // C s_5253_2: const #0u : u8
        let s_5253_2: u8 = 0;
        // C s_5253_3: cast zx s_5253_2 -> bv
        let s_5253_3: Bits = Bits::new(s_5253_2 as u128, 3u16);
        // D s_5253_4: cmp-eq s_5253_1 s_5253_3
        let s_5253_4: bool = ((s_5253_1) == (s_5253_3));
        // D s_5253_5: write-var gs#134859 <= s_5253_4
        fn_state.gs_134859 = s_5253_4;
        // N s_5253_6: jump b854
        return block_854(state, tracer, fn_state);
    }
    fn block_5254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5254_0: read-var opc1:u8
        let s_5254_0: u8 = fn_state.opc1;
        // D s_5254_1: cast zx s_5254_0 -> bv
        let s_5254_1: Bits = Bits::new(s_5254_0 as u128, 3u16);
        // C s_5254_2: const #0u : u8
        let s_5254_2: u8 = 0;
        // C s_5254_3: cast zx s_5254_2 -> bv
        let s_5254_3: Bits = Bits::new(s_5254_2 as u128, 3u16);
        // D s_5254_4: cmp-eq s_5254_1 s_5254_3
        let s_5254_4: bool = ((s_5254_1) == (s_5254_3));
        // D s_5254_5: write-var gs#134858 <= s_5254_4
        fn_state.gs_134858 = s_5254_4;
        // N s_5254_6: jump b852
        return block_852(state, tracer, fn_state);
    }
    fn block_5255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5255_0: read-var coproc:u8
        let s_5255_0: u8 = fn_state.coproc;
        // D s_5255_1: cast zx s_5255_0 -> bv
        let s_5255_1: Bits = Bits::new(s_5255_0 as u128, 4u16);
        // C s_5255_2: const #15u : u8
        let s_5255_2: u8 = 15;
        // C s_5255_3: cast zx s_5255_2 -> bv
        let s_5255_3: Bits = Bits::new(s_5255_2 as u128, 4u16);
        // D s_5255_4: cmp-eq s_5255_1 s_5255_3
        let s_5255_4: bool = ((s_5255_1) == (s_5255_3));
        // D s_5255_5: write-var gs#134857 <= s_5255_4
        fn_state.gs_134857 = s_5255_4;
        // N s_5255_6: jump b850
        return block_850(state, tracer, fn_state);
    }
    fn block_5256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5256_0: read-var CRn:u8
        let s_5256_0: u8 = fn_state.CRn;
        // D s_5256_1: cast zx s_5256_0 -> bv
        let s_5256_1: Bits = Bits::new(s_5256_0 as u128, 4u16);
        // C s_5256_2: const #9u : u8
        let s_5256_2: u8 = 9;
        // C s_5256_3: cast zx s_5256_2 -> bv
        let s_5256_3: Bits = Bits::new(s_5256_2 as u128, 4u16);
        // D s_5256_4: cmp-eq s_5256_1 s_5256_3
        let s_5256_4: bool = ((s_5256_1) == (s_5256_3));
        // D s_5256_5: write-var gs#134856 <= s_5256_4
        fn_state.gs_134856 = s_5256_4;
        // N s_5256_6: jump b848
        return block_848(state, tracer, fn_state);
    }
    fn block_5257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5257_0: read-var el:u8
        let s_5257_0: u8 = fn_state.el;
        // D s_5257_1: read-var coproc:u8
        let s_5257_1: u8 = fn_state.coproc;
        // D s_5257_2: read-var opc1:u8
        let s_5257_2: u8 = fn_state.opc1;
        // D s_5257_3: read-var CRn:u8
        let s_5257_3: u8 = fn_state.CRn;
        // D s_5257_4: read-var opc2:u8
        let s_5257_4: u8 = fn_state.opc2;
        // D s_5257_5: read-var CRm:u8
        let s_5257_5: u8 = fn_state.CRm;
        // D s_5257_6: read-var t:i
        let s_5257_6: i128 = fn_state.t;
        // D s_5257_7: call CSSELR_SysRegWrite32_707b283268d02f0f(s_5257_0, s_5257_1, s_5257_2, s_5257_3, s_5257_4, s_5257_5, s_5257_6)
        let s_5257_7: () = CSSELR_SysRegWrite32_707b283268d02f0f(
            state,
            tracer,
            s_5257_0,
            s_5257_1,
            s_5257_2,
            s_5257_3,
            s_5257_4,
            s_5257_5,
            s_5257_6,
        );
        // N s_5257_8: return
        return;
    }
    fn block_5258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5258_0: read-var opc2:u8
        let s_5258_0: u8 = fn_state.opc2;
        // D s_5258_1: cast zx s_5258_0 -> bv
        let s_5258_1: Bits = Bits::new(s_5258_0 as u128, 3u16);
        // C s_5258_2: const #0u : u8
        let s_5258_2: u8 = 0;
        // C s_5258_3: cast zx s_5258_2 -> bv
        let s_5258_3: Bits = Bits::new(s_5258_2 as u128, 3u16);
        // D s_5258_4: cmp-eq s_5258_1 s_5258_3
        let s_5258_4: bool = ((s_5258_1) == (s_5258_3));
        // D s_5258_5: write-var gs#134855 <= s_5258_4
        fn_state.gs_134855 = s_5258_4;
        // N s_5258_6: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_5259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5259_0: read-var opc1:u8
        let s_5259_0: u8 = fn_state.opc1;
        // D s_5259_1: cast zx s_5259_0 -> bv
        let s_5259_1: Bits = Bits::new(s_5259_0 as u128, 3u16);
        // C s_5259_2: const #2u : u8
        let s_5259_2: u8 = 2;
        // C s_5259_3: cast zx s_5259_2 -> bv
        let s_5259_3: Bits = Bits::new(s_5259_2 as u128, 3u16);
        // D s_5259_4: cmp-eq s_5259_1 s_5259_3
        let s_5259_4: bool = ((s_5259_1) == (s_5259_3));
        // D s_5259_5: write-var gs#134854 <= s_5259_4
        fn_state.gs_134854 = s_5259_4;
        // N s_5259_6: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_5260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5260_0: read-var coproc:u8
        let s_5260_0: u8 = fn_state.coproc;
        // D s_5260_1: cast zx s_5260_0 -> bv
        let s_5260_1: Bits = Bits::new(s_5260_0 as u128, 4u16);
        // C s_5260_2: const #15u : u8
        let s_5260_2: u8 = 15;
        // C s_5260_3: cast zx s_5260_2 -> bv
        let s_5260_3: Bits = Bits::new(s_5260_2 as u128, 4u16);
        // D s_5260_4: cmp-eq s_5260_1 s_5260_3
        let s_5260_4: bool = ((s_5260_1) == (s_5260_3));
        // D s_5260_5: write-var gs#134853 <= s_5260_4
        fn_state.gs_134853 = s_5260_4;
        // N s_5260_6: jump b841
        return block_841(state, tracer, fn_state);
    }
    fn block_5261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5261_0: read-var CRn:u8
        let s_5261_0: u8 = fn_state.CRn;
        // D s_5261_1: cast zx s_5261_0 -> bv
        let s_5261_1: Bits = Bits::new(s_5261_0 as u128, 4u16);
        // C s_5261_2: const #0u : u8
        let s_5261_2: u8 = 0;
        // C s_5261_3: cast zx s_5261_2 -> bv
        let s_5261_3: Bits = Bits::new(s_5261_2 as u128, 4u16);
        // D s_5261_4: cmp-eq s_5261_1 s_5261_3
        let s_5261_4: bool = ((s_5261_1) == (s_5261_3));
        // D s_5261_5: write-var gs#134852 <= s_5261_4
        fn_state.gs_134852 = s_5261_4;
        // N s_5261_6: jump b839
        return block_839(state, tracer, fn_state);
    }
    fn block_5262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5262_0: read-var el:u8
        let s_5262_0: u8 = fn_state.el;
        // D s_5262_1: read-var coproc:u8
        let s_5262_1: u8 = fn_state.coproc;
        // D s_5262_2: read-var opc1:u8
        let s_5262_2: u8 = fn_state.opc1;
        // D s_5262_3: read-var CRn:u8
        let s_5262_3: u8 = fn_state.CRn;
        // D s_5262_4: read-var opc2:u8
        let s_5262_4: u8 = fn_state.opc2;
        // D s_5262_5: read-var CRm:u8
        let s_5262_5: u8 = fn_state.CRm;
        // D s_5262_6: read-var t:i
        let s_5262_6: i128 = fn_state.t;
        // D s_5262_7: call DACR_SysRegWrite32_bfabed8f69d486b5(s_5262_0, s_5262_1, s_5262_2, s_5262_3, s_5262_4, s_5262_5, s_5262_6)
        let s_5262_7: () = DACR_SysRegWrite32_bfabed8f69d486b5(
            state,
            tracer,
            s_5262_0,
            s_5262_1,
            s_5262_2,
            s_5262_3,
            s_5262_4,
            s_5262_5,
            s_5262_6,
        );
        // N s_5262_8: return
        return;
    }
    fn block_5263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5263_0: read-var opc2:u8
        let s_5263_0: u8 = fn_state.opc2;
        // D s_5263_1: cast zx s_5263_0 -> bv
        let s_5263_1: Bits = Bits::new(s_5263_0 as u128, 3u16);
        // C s_5263_2: const #0u : u8
        let s_5263_2: u8 = 0;
        // C s_5263_3: cast zx s_5263_2 -> bv
        let s_5263_3: Bits = Bits::new(s_5263_2 as u128, 3u16);
        // D s_5263_4: cmp-eq s_5263_1 s_5263_3
        let s_5263_4: bool = ((s_5263_1) == (s_5263_3));
        // D s_5263_5: write-var gs#134851 <= s_5263_4
        fn_state.gs_134851 = s_5263_4;
        // N s_5263_6: jump b836
        return block_836(state, tracer, fn_state);
    }
    fn block_5264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5264_0: read-var opc1:u8
        let s_5264_0: u8 = fn_state.opc1;
        // D s_5264_1: cast zx s_5264_0 -> bv
        let s_5264_1: Bits = Bits::new(s_5264_0 as u128, 3u16);
        // C s_5264_2: const #0u : u8
        let s_5264_2: u8 = 0;
        // C s_5264_3: cast zx s_5264_2 -> bv
        let s_5264_3: Bits = Bits::new(s_5264_2 as u128, 3u16);
        // D s_5264_4: cmp-eq s_5264_1 s_5264_3
        let s_5264_4: bool = ((s_5264_1) == (s_5264_3));
        // D s_5264_5: write-var gs#134850 <= s_5264_4
        fn_state.gs_134850 = s_5264_4;
        // N s_5264_6: jump b834
        return block_834(state, tracer, fn_state);
    }
    fn block_5265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5265_0: read-var coproc:u8
        let s_5265_0: u8 = fn_state.coproc;
        // D s_5265_1: cast zx s_5265_0 -> bv
        let s_5265_1: Bits = Bits::new(s_5265_0 as u128, 4u16);
        // C s_5265_2: const #15u : u8
        let s_5265_2: u8 = 15;
        // C s_5265_3: cast zx s_5265_2 -> bv
        let s_5265_3: Bits = Bits::new(s_5265_2 as u128, 4u16);
        // D s_5265_4: cmp-eq s_5265_1 s_5265_3
        let s_5265_4: bool = ((s_5265_1) == (s_5265_3));
        // D s_5265_5: write-var gs#134849 <= s_5265_4
        fn_state.gs_134849 = s_5265_4;
        // N s_5265_6: jump b832
        return block_832(state, tracer, fn_state);
    }
    fn block_5266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5266_0: read-var CRn:u8
        let s_5266_0: u8 = fn_state.CRn;
        // D s_5266_1: cast zx s_5266_0 -> bv
        let s_5266_1: Bits = Bits::new(s_5266_0 as u128, 4u16);
        // C s_5266_2: const #3u : u8
        let s_5266_2: u8 = 3;
        // C s_5266_3: cast zx s_5266_2 -> bv
        let s_5266_3: Bits = Bits::new(s_5266_2 as u128, 4u16);
        // D s_5266_4: cmp-eq s_5266_1 s_5266_3
        let s_5266_4: bool = ((s_5266_1) == (s_5266_3));
        // D s_5266_5: write-var gs#134848 <= s_5266_4
        fn_state.gs_134848 = s_5266_4;
        // N s_5266_6: jump b830
        return block_830(state, tracer, fn_state);
    }
    fn block_5267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5267_0: read-var el:u8
        let s_5267_0: u8 = fn_state.el;
        // D s_5267_1: read-var coproc:u8
        let s_5267_1: u8 = fn_state.coproc;
        // D s_5267_2: read-var opc1:u8
        let s_5267_2: u8 = fn_state.opc1;
        // D s_5267_3: read-var CRn:u8
        let s_5267_3: u8 = fn_state.CRn;
        // D s_5267_4: read-var opc2:u8
        let s_5267_4: u8 = fn_state.opc2;
        // D s_5267_5: read-var CRm:u8
        let s_5267_5: u8 = fn_state.CRm;
        // D s_5267_6: read-var t:i
        let s_5267_6: i128 = fn_state.t;
        // D s_5267_7: call ICV_EOIR0_SysRegWrite32_a5e151ee536f5632(s_5267_0, s_5267_1, s_5267_2, s_5267_3, s_5267_4, s_5267_5, s_5267_6)
        let s_5267_7: () = ICV_EOIR0_SysRegWrite32_a5e151ee536f5632(
            state,
            tracer,
            s_5267_0,
            s_5267_1,
            s_5267_2,
            s_5267_3,
            s_5267_4,
            s_5267_5,
            s_5267_6,
        );
        // N s_5267_8: return
        return;
    }
    fn block_5268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5268_0: read-var opc2:u8
        let s_5268_0: u8 = fn_state.opc2;
        // D s_5268_1: cast zx s_5268_0 -> bv
        let s_5268_1: Bits = Bits::new(s_5268_0 as u128, 3u16);
        // C s_5268_2: const #1u : u8
        let s_5268_2: u8 = 1;
        // C s_5268_3: cast zx s_5268_2 -> bv
        let s_5268_3: Bits = Bits::new(s_5268_2 as u128, 3u16);
        // D s_5268_4: cmp-eq s_5268_1 s_5268_3
        let s_5268_4: bool = ((s_5268_1) == (s_5268_3));
        // D s_5268_5: write-var gs#134847 <= s_5268_4
        fn_state.gs_134847 = s_5268_4;
        // N s_5268_6: jump b827
        return block_827(state, tracer, fn_state);
    }
    fn block_5269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5269_0: read-var opc1:u8
        let s_5269_0: u8 = fn_state.opc1;
        // D s_5269_1: cast zx s_5269_0 -> bv
        let s_5269_1: Bits = Bits::new(s_5269_0 as u128, 3u16);
        // C s_5269_2: const #0u : u8
        let s_5269_2: u8 = 0;
        // C s_5269_3: cast zx s_5269_2 -> bv
        let s_5269_3: Bits = Bits::new(s_5269_2 as u128, 3u16);
        // D s_5269_4: cmp-eq s_5269_1 s_5269_3
        let s_5269_4: bool = ((s_5269_1) == (s_5269_3));
        // D s_5269_5: write-var gs#134846 <= s_5269_4
        fn_state.gs_134846 = s_5269_4;
        // N s_5269_6: jump b825
        return block_825(state, tracer, fn_state);
    }
    fn block_5270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5270_0: read-var coproc:u8
        let s_5270_0: u8 = fn_state.coproc;
        // D s_5270_1: cast zx s_5270_0 -> bv
        let s_5270_1: Bits = Bits::new(s_5270_0 as u128, 4u16);
        // C s_5270_2: const #15u : u8
        let s_5270_2: u8 = 15;
        // C s_5270_3: cast zx s_5270_2 -> bv
        let s_5270_3: Bits = Bits::new(s_5270_2 as u128, 4u16);
        // D s_5270_4: cmp-eq s_5270_1 s_5270_3
        let s_5270_4: bool = ((s_5270_1) == (s_5270_3));
        // D s_5270_5: write-var gs#134845 <= s_5270_4
        fn_state.gs_134845 = s_5270_4;
        // N s_5270_6: jump b823
        return block_823(state, tracer, fn_state);
    }
    fn block_5271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5271_0: read-var CRn:u8
        let s_5271_0: u8 = fn_state.CRn;
        // D s_5271_1: cast zx s_5271_0 -> bv
        let s_5271_1: Bits = Bits::new(s_5271_0 as u128, 4u16);
        // C s_5271_2: const #12u : u8
        let s_5271_2: u8 = 12;
        // C s_5271_3: cast zx s_5271_2 -> bv
        let s_5271_3: Bits = Bits::new(s_5271_2 as u128, 4u16);
        // D s_5271_4: cmp-eq s_5271_1 s_5271_3
        let s_5271_4: bool = ((s_5271_1) == (s_5271_3));
        // D s_5271_5: write-var gs#134844 <= s_5271_4
        fn_state.gs_134844 = s_5271_4;
        // N s_5271_6: jump b821
        return block_821(state, tracer, fn_state);
    }
    fn block_5272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5272_0: read-var el:u8
        let s_5272_0: u8 = fn_state.el;
        // D s_5272_1: read-var coproc:u8
        let s_5272_1: u8 = fn_state.coproc;
        // D s_5272_2: read-var opc1:u8
        let s_5272_2: u8 = fn_state.opc1;
        // D s_5272_3: read-var CRn:u8
        let s_5272_3: u8 = fn_state.CRn;
        // D s_5272_4: read-var opc2:u8
        let s_5272_4: u8 = fn_state.opc2;
        // D s_5272_5: read-var CRm:u8
        let s_5272_5: u8 = fn_state.CRm;
        // D s_5272_6: read-var t:i
        let s_5272_6: i128 = fn_state.t;
        // D s_5272_7: call HMAIR0_SysRegWrite32_57f89dde47ed87b4(s_5272_0, s_5272_1, s_5272_2, s_5272_3, s_5272_4, s_5272_5, s_5272_6)
        let s_5272_7: () = HMAIR0_SysRegWrite32_57f89dde47ed87b4(
            state,
            tracer,
            s_5272_0,
            s_5272_1,
            s_5272_2,
            s_5272_3,
            s_5272_4,
            s_5272_5,
            s_5272_6,
        );
        // N s_5272_8: return
        return;
    }
    fn block_5273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5273_0: read-var opc2:u8
        let s_5273_0: u8 = fn_state.opc2;
        // D s_5273_1: cast zx s_5273_0 -> bv
        let s_5273_1: Bits = Bits::new(s_5273_0 as u128, 3u16);
        // C s_5273_2: const #0u : u8
        let s_5273_2: u8 = 0;
        // C s_5273_3: cast zx s_5273_2 -> bv
        let s_5273_3: Bits = Bits::new(s_5273_2 as u128, 3u16);
        // D s_5273_4: cmp-eq s_5273_1 s_5273_3
        let s_5273_4: bool = ((s_5273_1) == (s_5273_3));
        // D s_5273_5: write-var gs#134843 <= s_5273_4
        fn_state.gs_134843 = s_5273_4;
        // N s_5273_6: jump b818
        return block_818(state, tracer, fn_state);
    }
    fn block_5274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5274_0: read-var opc1:u8
        let s_5274_0: u8 = fn_state.opc1;
        // D s_5274_1: cast zx s_5274_0 -> bv
        let s_5274_1: Bits = Bits::new(s_5274_0 as u128, 3u16);
        // C s_5274_2: const #4u : u8
        let s_5274_2: u8 = 4;
        // C s_5274_3: cast zx s_5274_2 -> bv
        let s_5274_3: Bits = Bits::new(s_5274_2 as u128, 3u16);
        // D s_5274_4: cmp-eq s_5274_1 s_5274_3
        let s_5274_4: bool = ((s_5274_1) == (s_5274_3));
        // D s_5274_5: write-var gs#134842 <= s_5274_4
        fn_state.gs_134842 = s_5274_4;
        // N s_5274_6: jump b816
        return block_816(state, tracer, fn_state);
    }
    fn block_5275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5275_0: read-var coproc:u8
        let s_5275_0: u8 = fn_state.coproc;
        // D s_5275_1: cast zx s_5275_0 -> bv
        let s_5275_1: Bits = Bits::new(s_5275_0 as u128, 4u16);
        // C s_5275_2: const #15u : u8
        let s_5275_2: u8 = 15;
        // C s_5275_3: cast zx s_5275_2 -> bv
        let s_5275_3: Bits = Bits::new(s_5275_2 as u128, 4u16);
        // D s_5275_4: cmp-eq s_5275_1 s_5275_3
        let s_5275_4: bool = ((s_5275_1) == (s_5275_3));
        // D s_5275_5: write-var gs#134841 <= s_5275_4
        fn_state.gs_134841 = s_5275_4;
        // N s_5275_6: jump b814
        return block_814(state, tracer, fn_state);
    }
    fn block_5276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5276_0: read-var CRn:u8
        let s_5276_0: u8 = fn_state.CRn;
        // D s_5276_1: cast zx s_5276_0 -> bv
        let s_5276_1: Bits = Bits::new(s_5276_0 as u128, 4u16);
        // C s_5276_2: const #10u : u8
        let s_5276_2: u8 = 10;
        // C s_5276_3: cast zx s_5276_2 -> bv
        let s_5276_3: Bits = Bits::new(s_5276_2 as u128, 4u16);
        // D s_5276_4: cmp-eq s_5276_1 s_5276_3
        let s_5276_4: bool = ((s_5276_1) == (s_5276_3));
        // D s_5276_5: write-var gs#134840 <= s_5276_4
        fn_state.gs_134840 = s_5276_4;
        // N s_5276_6: jump b812
        return block_812(state, tracer, fn_state);
    }
    fn block_5277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5277_0: read-var el:u8
        let s_5277_0: u8 = fn_state.el;
        // D s_5277_1: read-var coproc:u8
        let s_5277_1: u8 = fn_state.coproc;
        // D s_5277_2: read-var opc1:u8
        let s_5277_2: u8 = fn_state.opc1;
        // D s_5277_3: read-var CRn:u8
        let s_5277_3: u8 = fn_state.CRn;
        // D s_5277_4: read-var opc2:u8
        let s_5277_4: u8 = fn_state.opc2;
        // D s_5277_5: read-var CRm:u8
        let s_5277_5: u8 = fn_state.CRm;
        // D s_5277_6: read-var t:i
        let s_5277_6: i128 = fn_state.t;
        // D s_5277_7: call HCR2_SysRegWrite32_e09ead3d01a1f060(s_5277_0, s_5277_1, s_5277_2, s_5277_3, s_5277_4, s_5277_5, s_5277_6)
        let s_5277_7: () = HCR2_SysRegWrite32_e09ead3d01a1f060(
            state,
            tracer,
            s_5277_0,
            s_5277_1,
            s_5277_2,
            s_5277_3,
            s_5277_4,
            s_5277_5,
            s_5277_6,
        );
        // N s_5277_8: return
        return;
    }
    fn block_5278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5278_0: read-var opc2:u8
        let s_5278_0: u8 = fn_state.opc2;
        // D s_5278_1: cast zx s_5278_0 -> bv
        let s_5278_1: Bits = Bits::new(s_5278_0 as u128, 3u16);
        // C s_5278_2: const #4u : u8
        let s_5278_2: u8 = 4;
        // C s_5278_3: cast zx s_5278_2 -> bv
        let s_5278_3: Bits = Bits::new(s_5278_2 as u128, 3u16);
        // D s_5278_4: cmp-eq s_5278_1 s_5278_3
        let s_5278_4: bool = ((s_5278_1) == (s_5278_3));
        // D s_5278_5: write-var gs#134839 <= s_5278_4
        fn_state.gs_134839 = s_5278_4;
        // N s_5278_6: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_5279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5279_0: read-var opc1:u8
        let s_5279_0: u8 = fn_state.opc1;
        // D s_5279_1: cast zx s_5279_0 -> bv
        let s_5279_1: Bits = Bits::new(s_5279_0 as u128, 3u16);
        // C s_5279_2: const #4u : u8
        let s_5279_2: u8 = 4;
        // C s_5279_3: cast zx s_5279_2 -> bv
        let s_5279_3: Bits = Bits::new(s_5279_2 as u128, 3u16);
        // D s_5279_4: cmp-eq s_5279_1 s_5279_3
        let s_5279_4: bool = ((s_5279_1) == (s_5279_3));
        // D s_5279_5: write-var gs#134838 <= s_5279_4
        fn_state.gs_134838 = s_5279_4;
        // N s_5279_6: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_5280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5280_0: read-var coproc:u8
        let s_5280_0: u8 = fn_state.coproc;
        // D s_5280_1: cast zx s_5280_0 -> bv
        let s_5280_1: Bits = Bits::new(s_5280_0 as u128, 4u16);
        // C s_5280_2: const #15u : u8
        let s_5280_2: u8 = 15;
        // C s_5280_3: cast zx s_5280_2 -> bv
        let s_5280_3: Bits = Bits::new(s_5280_2 as u128, 4u16);
        // D s_5280_4: cmp-eq s_5280_1 s_5280_3
        let s_5280_4: bool = ((s_5280_1) == (s_5280_3));
        // D s_5280_5: write-var gs#134837 <= s_5280_4
        fn_state.gs_134837 = s_5280_4;
        // N s_5280_6: jump b805
        return block_805(state, tracer, fn_state);
    }
    fn block_5281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5281_0: read-var CRn:u8
        let s_5281_0: u8 = fn_state.CRn;
        // D s_5281_1: cast zx s_5281_0 -> bv
        let s_5281_1: Bits = Bits::new(s_5281_0 as u128, 4u16);
        // C s_5281_2: const #1u : u8
        let s_5281_2: u8 = 1;
        // C s_5281_3: cast zx s_5281_2 -> bv
        let s_5281_3: Bits = Bits::new(s_5281_2 as u128, 4u16);
        // D s_5281_4: cmp-eq s_5281_1 s_5281_3
        let s_5281_4: bool = ((s_5281_1) == (s_5281_3));
        // D s_5281_5: write-var gs#134836 <= s_5281_4
        fn_state.gs_134836 = s_5281_4;
        // N s_5281_6: jump b803
        return block_803(state, tracer, fn_state);
    }
    fn block_5282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5282_0: read-var el:u8
        let s_5282_0: u8 = fn_state.el;
        // D s_5282_1: read-var coproc:u8
        let s_5282_1: u8 = fn_state.coproc;
        // D s_5282_2: read-var opc1:u8
        let s_5282_2: u8 = fn_state.opc1;
        // D s_5282_3: read-var CRn:u8
        let s_5282_3: u8 = fn_state.CRn;
        // D s_5282_4: read-var opc2:u8
        let s_5282_4: u8 = fn_state.opc2;
        // D s_5282_5: read-var CRm:u8
        let s_5282_5: u8 = fn_state.CRm;
        // D s_5282_6: read-var t:i
        let s_5282_6: i128 = fn_state.t;
        // D s_5282_7: call HRMR_SysRegWrite32_da3e01dd793ebd87(s_5282_0, s_5282_1, s_5282_2, s_5282_3, s_5282_4, s_5282_5, s_5282_6)
        let s_5282_7: () = HRMR_SysRegWrite32_da3e01dd793ebd87(
            state,
            tracer,
            s_5282_0,
            s_5282_1,
            s_5282_2,
            s_5282_3,
            s_5282_4,
            s_5282_5,
            s_5282_6,
        );
        // N s_5282_8: return
        return;
    }
    fn block_5283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5283_0: read-var opc2:u8
        let s_5283_0: u8 = fn_state.opc2;
        // D s_5283_1: cast zx s_5283_0 -> bv
        let s_5283_1: Bits = Bits::new(s_5283_0 as u128, 3u16);
        // C s_5283_2: const #2u : u8
        let s_5283_2: u8 = 2;
        // C s_5283_3: cast zx s_5283_2 -> bv
        let s_5283_3: Bits = Bits::new(s_5283_2 as u128, 3u16);
        // D s_5283_4: cmp-eq s_5283_1 s_5283_3
        let s_5283_4: bool = ((s_5283_1) == (s_5283_3));
        // D s_5283_5: write-var gs#134835 <= s_5283_4
        fn_state.gs_134835 = s_5283_4;
        // N s_5283_6: jump b800
        return block_800(state, tracer, fn_state);
    }
    fn block_5284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5284_0: read-var opc1:u8
        let s_5284_0: u8 = fn_state.opc1;
        // D s_5284_1: cast zx s_5284_0 -> bv
        let s_5284_1: Bits = Bits::new(s_5284_0 as u128, 3u16);
        // C s_5284_2: const #4u : u8
        let s_5284_2: u8 = 4;
        // C s_5284_3: cast zx s_5284_2 -> bv
        let s_5284_3: Bits = Bits::new(s_5284_2 as u128, 3u16);
        // D s_5284_4: cmp-eq s_5284_1 s_5284_3
        let s_5284_4: bool = ((s_5284_1) == (s_5284_3));
        // D s_5284_5: write-var gs#134834 <= s_5284_4
        fn_state.gs_134834 = s_5284_4;
        // N s_5284_6: jump b798
        return block_798(state, tracer, fn_state);
    }
    fn block_5285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5285_0: read-var coproc:u8
        let s_5285_0: u8 = fn_state.coproc;
        // D s_5285_1: cast zx s_5285_0 -> bv
        let s_5285_1: Bits = Bits::new(s_5285_0 as u128, 4u16);
        // C s_5285_2: const #15u : u8
        let s_5285_2: u8 = 15;
        // C s_5285_3: cast zx s_5285_2 -> bv
        let s_5285_3: Bits = Bits::new(s_5285_2 as u128, 4u16);
        // D s_5285_4: cmp-eq s_5285_1 s_5285_3
        let s_5285_4: bool = ((s_5285_1) == (s_5285_3));
        // D s_5285_5: write-var gs#134833 <= s_5285_4
        fn_state.gs_134833 = s_5285_4;
        // N s_5285_6: jump b796
        return block_796(state, tracer, fn_state);
    }
    fn block_5286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5286_0: read-var CRn:u8
        let s_5286_0: u8 = fn_state.CRn;
        // D s_5286_1: cast zx s_5286_0 -> bv
        let s_5286_1: Bits = Bits::new(s_5286_0 as u128, 4u16);
        // C s_5286_2: const #12u : u8
        let s_5286_2: u8 = 12;
        // C s_5286_3: cast zx s_5286_2 -> bv
        let s_5286_3: Bits = Bits::new(s_5286_2 as u128, 4u16);
        // D s_5286_4: cmp-eq s_5286_1 s_5286_3
        let s_5286_4: bool = ((s_5286_1) == (s_5286_3));
        // D s_5286_5: write-var gs#134832 <= s_5286_4
        fn_state.gs_134832 = s_5286_4;
        // N s_5286_6: jump b794
        return block_794(state, tracer, fn_state);
    }
    fn block_5287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5287_0: read-var el:u8
        let s_5287_0: u8 = fn_state.el;
        // D s_5287_1: read-var coproc:u8
        let s_5287_1: u8 = fn_state.coproc;
        // D s_5287_2: read-var opc1:u8
        let s_5287_2: u8 = fn_state.opc1;
        // D s_5287_3: read-var CRn:u8
        let s_5287_3: u8 = fn_state.CRn;
        // D s_5287_4: read-var opc2:u8
        let s_5287_4: u8 = fn_state.opc2;
        // D s_5287_5: read-var CRm:u8
        let s_5287_5: u8 = fn_state.CRm;
        // D s_5287_6: read-var t:i
        let s_5287_6: i128 = fn_state.t;
        // D s_5287_7: call ICV_AP0R_SysRegWrite32_b2c1de53009da653(s_5287_0, s_5287_1, s_5287_2, s_5287_3, s_5287_4, s_5287_5, s_5287_6)
        let s_5287_7: () = ICV_AP0R_SysRegWrite32_b2c1de53009da653(
            state,
            tracer,
            s_5287_0,
            s_5287_1,
            s_5287_2,
            s_5287_3,
            s_5287_4,
            s_5287_5,
            s_5287_6,
        );
        // N s_5287_8: return
        return;
    }
    fn block_5288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5288_0: read-var opc2:u8
        let s_5288_0: u8 = fn_state.opc2;
        // D s_5288_1: cast zx s_5288_0 -> bv
        let s_5288_1: Bits = Bits::new(s_5288_0 as u128, 3u16);
        // C s_5288_2: const #4u : u8
        let s_5288_2: u8 = 4;
        // C s_5288_3: cast zx s_5288_2 -> bv
        let s_5288_3: Bits = Bits::new(s_5288_2 as u128, 3u16);
        // D s_5288_4: cmp-eq s_5288_1 s_5288_3
        let s_5288_4: bool = ((s_5288_1) == (s_5288_3));
        // D s_5288_5: write-var gs#134831 <= s_5288_4
        fn_state.gs_134831 = s_5288_4;
        // N s_5288_6: jump b791
        return block_791(state, tracer, fn_state);
    }
    fn block_5289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5289_0: read-var opc1:u8
        let s_5289_0: u8 = fn_state.opc1;
        // D s_5289_1: cast zx s_5289_0 -> bv
        let s_5289_1: Bits = Bits::new(s_5289_0 as u128, 3u16);
        // C s_5289_2: const #0u : u8
        let s_5289_2: u8 = 0;
        // C s_5289_3: cast zx s_5289_2 -> bv
        let s_5289_3: Bits = Bits::new(s_5289_2 as u128, 3u16);
        // D s_5289_4: cmp-eq s_5289_1 s_5289_3
        let s_5289_4: bool = ((s_5289_1) == (s_5289_3));
        // D s_5289_5: write-var gs#134830 <= s_5289_4
        fn_state.gs_134830 = s_5289_4;
        // N s_5289_6: jump b789
        return block_789(state, tracer, fn_state);
    }
    fn block_5290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5290_0: read-var coproc:u8
        let s_5290_0: u8 = fn_state.coproc;
        // D s_5290_1: cast zx s_5290_0 -> bv
        let s_5290_1: Bits = Bits::new(s_5290_0 as u128, 4u16);
        // C s_5290_2: const #15u : u8
        let s_5290_2: u8 = 15;
        // C s_5290_3: cast zx s_5290_2 -> bv
        let s_5290_3: Bits = Bits::new(s_5290_2 as u128, 4u16);
        // D s_5290_4: cmp-eq s_5290_1 s_5290_3
        let s_5290_4: bool = ((s_5290_1) == (s_5290_3));
        // D s_5290_5: write-var gs#134829 <= s_5290_4
        fn_state.gs_134829 = s_5290_4;
        // N s_5290_6: jump b787
        return block_787(state, tracer, fn_state);
    }
    fn block_5291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5291_0: read-var CRn:u8
        let s_5291_0: u8 = fn_state.CRn;
        // D s_5291_1: cast zx s_5291_0 -> bv
        let s_5291_1: Bits = Bits::new(s_5291_0 as u128, 4u16);
        // C s_5291_2: const #12u : u8
        let s_5291_2: u8 = 12;
        // C s_5291_3: cast zx s_5291_2 -> bv
        let s_5291_3: Bits = Bits::new(s_5291_2 as u128, 4u16);
        // D s_5291_4: cmp-eq s_5291_1 s_5291_3
        let s_5291_4: bool = ((s_5291_1) == (s_5291_3));
        // D s_5291_5: write-var gs#134828 <= s_5291_4
        fn_state.gs_134828 = s_5291_4;
        // N s_5291_6: jump b785
        return block_785(state, tracer, fn_state);
    }
    fn block_5292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5292_0: read-var el:u8
        let s_5292_0: u8 = fn_state.el;
        // D s_5292_1: read-var coproc:u8
        let s_5292_1: u8 = fn_state.coproc;
        // D s_5292_2: read-var opc1:u8
        let s_5292_2: u8 = fn_state.opc1;
        // D s_5292_3: read-var CRn:u8
        let s_5292_3: u8 = fn_state.CRn;
        // D s_5292_4: read-var opc2:u8
        let s_5292_4: u8 = fn_state.opc2;
        // D s_5292_5: read-var CRm:u8
        let s_5292_5: u8 = fn_state.CRm;
        // D s_5292_6: read-var t:i
        let s_5292_6: i128 = fn_state.t;
        // D s_5292_7: call ICV_AP0R_SysRegWrite32_f5921a0effda4992(s_5292_0, s_5292_1, s_5292_2, s_5292_3, s_5292_4, s_5292_5, s_5292_6)
        let s_5292_7: () = ICV_AP0R_SysRegWrite32_f5921a0effda4992(
            state,
            tracer,
            s_5292_0,
            s_5292_1,
            s_5292_2,
            s_5292_3,
            s_5292_4,
            s_5292_5,
            s_5292_6,
        );
        // N s_5292_8: return
        return;
    }
    fn block_5293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5293_0: read-var opc2:u8
        let s_5293_0: u8 = fn_state.opc2;
        // D s_5293_1: cast zx s_5293_0 -> bv
        let s_5293_1: Bits = Bits::new(s_5293_0 as u128, 3u16);
        // C s_5293_2: const #5u : u8
        let s_5293_2: u8 = 5;
        // C s_5293_3: cast zx s_5293_2 -> bv
        let s_5293_3: Bits = Bits::new(s_5293_2 as u128, 3u16);
        // D s_5293_4: cmp-eq s_5293_1 s_5293_3
        let s_5293_4: bool = ((s_5293_1) == (s_5293_3));
        // D s_5293_5: write-var gs#134827 <= s_5293_4
        fn_state.gs_134827 = s_5293_4;
        // N s_5293_6: jump b782
        return block_782(state, tracer, fn_state);
    }
    fn block_5294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5294_0: read-var opc1:u8
        let s_5294_0: u8 = fn_state.opc1;
        // D s_5294_1: cast zx s_5294_0 -> bv
        let s_5294_1: Bits = Bits::new(s_5294_0 as u128, 3u16);
        // C s_5294_2: const #0u : u8
        let s_5294_2: u8 = 0;
        // C s_5294_3: cast zx s_5294_2 -> bv
        let s_5294_3: Bits = Bits::new(s_5294_2 as u128, 3u16);
        // D s_5294_4: cmp-eq s_5294_1 s_5294_3
        let s_5294_4: bool = ((s_5294_1) == (s_5294_3));
        // D s_5294_5: write-var gs#134826 <= s_5294_4
        fn_state.gs_134826 = s_5294_4;
        // N s_5294_6: jump b780
        return block_780(state, tracer, fn_state);
    }
    fn block_5295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5295_0: read-var coproc:u8
        let s_5295_0: u8 = fn_state.coproc;
        // D s_5295_1: cast zx s_5295_0 -> bv
        let s_5295_1: Bits = Bits::new(s_5295_0 as u128, 4u16);
        // C s_5295_2: const #15u : u8
        let s_5295_2: u8 = 15;
        // C s_5295_3: cast zx s_5295_2 -> bv
        let s_5295_3: Bits = Bits::new(s_5295_2 as u128, 4u16);
        // D s_5295_4: cmp-eq s_5295_1 s_5295_3
        let s_5295_4: bool = ((s_5295_1) == (s_5295_3));
        // D s_5295_5: write-var gs#134825 <= s_5295_4
        fn_state.gs_134825 = s_5295_4;
        // N s_5295_6: jump b778
        return block_778(state, tracer, fn_state);
    }
    fn block_5296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5296_0: read-var CRn:u8
        let s_5296_0: u8 = fn_state.CRn;
        // D s_5296_1: cast zx s_5296_0 -> bv
        let s_5296_1: Bits = Bits::new(s_5296_0 as u128, 4u16);
        // C s_5296_2: const #12u : u8
        let s_5296_2: u8 = 12;
        // C s_5296_3: cast zx s_5296_2 -> bv
        let s_5296_3: Bits = Bits::new(s_5296_2 as u128, 4u16);
        // D s_5296_4: cmp-eq s_5296_1 s_5296_3
        let s_5296_4: bool = ((s_5296_1) == (s_5296_3));
        // D s_5296_5: write-var gs#134824 <= s_5296_4
        fn_state.gs_134824 = s_5296_4;
        // N s_5296_6: jump b776
        return block_776(state, tracer, fn_state);
    }
    fn block_5297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5297_0: read-var el:u8
        let s_5297_0: u8 = fn_state.el;
        // D s_5297_1: read-var coproc:u8
        let s_5297_1: u8 = fn_state.coproc;
        // D s_5297_2: read-var opc1:u8
        let s_5297_2: u8 = fn_state.opc1;
        // D s_5297_3: read-var CRn:u8
        let s_5297_3: u8 = fn_state.CRn;
        // D s_5297_4: read-var opc2:u8
        let s_5297_4: u8 = fn_state.opc2;
        // D s_5297_5: read-var CRm:u8
        let s_5297_5: u8 = fn_state.CRm;
        // D s_5297_6: read-var t:i
        let s_5297_6: i128 = fn_state.t;
        // D s_5297_7: call ICV_AP0R_SysRegWrite32_7420f74019631696(s_5297_0, s_5297_1, s_5297_2, s_5297_3, s_5297_4, s_5297_5, s_5297_6)
        let s_5297_7: () = ICV_AP0R_SysRegWrite32_7420f74019631696(
            state,
            tracer,
            s_5297_0,
            s_5297_1,
            s_5297_2,
            s_5297_3,
            s_5297_4,
            s_5297_5,
            s_5297_6,
        );
        // N s_5297_8: return
        return;
    }
    fn block_5298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5298_0: read-var opc2:u8
        let s_5298_0: u8 = fn_state.opc2;
        // D s_5298_1: cast zx s_5298_0 -> bv
        let s_5298_1: Bits = Bits::new(s_5298_0 as u128, 3u16);
        // C s_5298_2: const #6u : u8
        let s_5298_2: u8 = 6;
        // C s_5298_3: cast zx s_5298_2 -> bv
        let s_5298_3: Bits = Bits::new(s_5298_2 as u128, 3u16);
        // D s_5298_4: cmp-eq s_5298_1 s_5298_3
        let s_5298_4: bool = ((s_5298_1) == (s_5298_3));
        // D s_5298_5: write-var gs#134823 <= s_5298_4
        fn_state.gs_134823 = s_5298_4;
        // N s_5298_6: jump b773
        return block_773(state, tracer, fn_state);
    }
    fn block_5299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5299_0: read-var opc1:u8
        let s_5299_0: u8 = fn_state.opc1;
        // D s_5299_1: cast zx s_5299_0 -> bv
        let s_5299_1: Bits = Bits::new(s_5299_0 as u128, 3u16);
        // C s_5299_2: const #0u : u8
        let s_5299_2: u8 = 0;
        // C s_5299_3: cast zx s_5299_2 -> bv
        let s_5299_3: Bits = Bits::new(s_5299_2 as u128, 3u16);
        // D s_5299_4: cmp-eq s_5299_1 s_5299_3
        let s_5299_4: bool = ((s_5299_1) == (s_5299_3));
        // D s_5299_5: write-var gs#134822 <= s_5299_4
        fn_state.gs_134822 = s_5299_4;
        // N s_5299_6: jump b771
        return block_771(state, tracer, fn_state);
    }
    fn block_5300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5300_0: read-var coproc:u8
        let s_5300_0: u8 = fn_state.coproc;
        // D s_5300_1: cast zx s_5300_0 -> bv
        let s_5300_1: Bits = Bits::new(s_5300_0 as u128, 4u16);
        // C s_5300_2: const #15u : u8
        let s_5300_2: u8 = 15;
        // C s_5300_3: cast zx s_5300_2 -> bv
        let s_5300_3: Bits = Bits::new(s_5300_2 as u128, 4u16);
        // D s_5300_4: cmp-eq s_5300_1 s_5300_3
        let s_5300_4: bool = ((s_5300_1) == (s_5300_3));
        // D s_5300_5: write-var gs#134821 <= s_5300_4
        fn_state.gs_134821 = s_5300_4;
        // N s_5300_6: jump b769
        return block_769(state, tracer, fn_state);
    }
    fn block_5301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5301_0: read-var CRn:u8
        let s_5301_0: u8 = fn_state.CRn;
        // D s_5301_1: cast zx s_5301_0 -> bv
        let s_5301_1: Bits = Bits::new(s_5301_0 as u128, 4u16);
        // C s_5301_2: const #12u : u8
        let s_5301_2: u8 = 12;
        // C s_5301_3: cast zx s_5301_2 -> bv
        let s_5301_3: Bits = Bits::new(s_5301_2 as u128, 4u16);
        // D s_5301_4: cmp-eq s_5301_1 s_5301_3
        let s_5301_4: bool = ((s_5301_1) == (s_5301_3));
        // D s_5301_5: write-var gs#134820 <= s_5301_4
        fn_state.gs_134820 = s_5301_4;
        // N s_5301_6: jump b767
        return block_767(state, tracer, fn_state);
    }
    fn block_5302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5302_0: read-var el:u8
        let s_5302_0: u8 = fn_state.el;
        // D s_5302_1: read-var coproc:u8
        let s_5302_1: u8 = fn_state.coproc;
        // D s_5302_2: read-var opc1:u8
        let s_5302_2: u8 = fn_state.opc1;
        // D s_5302_3: read-var CRn:u8
        let s_5302_3: u8 = fn_state.CRn;
        // D s_5302_4: read-var opc2:u8
        let s_5302_4: u8 = fn_state.opc2;
        // D s_5302_5: read-var CRm:u8
        let s_5302_5: u8 = fn_state.CRm;
        // D s_5302_6: read-var t:i
        let s_5302_6: i128 = fn_state.t;
        // D s_5302_7: call ICV_AP0R_SysRegWrite32_c1e479184edb7511(s_5302_0, s_5302_1, s_5302_2, s_5302_3, s_5302_4, s_5302_5, s_5302_6)
        let s_5302_7: () = ICV_AP0R_SysRegWrite32_c1e479184edb7511(
            state,
            tracer,
            s_5302_0,
            s_5302_1,
            s_5302_2,
            s_5302_3,
            s_5302_4,
            s_5302_5,
            s_5302_6,
        );
        // N s_5302_8: return
        return;
    }
    fn block_5303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5303_0: read-var opc2:u8
        let s_5303_0: u8 = fn_state.opc2;
        // D s_5303_1: cast zx s_5303_0 -> bv
        let s_5303_1: Bits = Bits::new(s_5303_0 as u128, 3u16);
        // C s_5303_2: const #7u : u8
        let s_5303_2: u8 = 7;
        // C s_5303_3: cast zx s_5303_2 -> bv
        let s_5303_3: Bits = Bits::new(s_5303_2 as u128, 3u16);
        // D s_5303_4: cmp-eq s_5303_1 s_5303_3
        let s_5303_4: bool = ((s_5303_1) == (s_5303_3));
        // D s_5303_5: write-var gs#134819 <= s_5303_4
        fn_state.gs_134819 = s_5303_4;
        // N s_5303_6: jump b764
        return block_764(state, tracer, fn_state);
    }
    fn block_5304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5304_0: read-var opc1:u8
        let s_5304_0: u8 = fn_state.opc1;
        // D s_5304_1: cast zx s_5304_0 -> bv
        let s_5304_1: Bits = Bits::new(s_5304_0 as u128, 3u16);
        // C s_5304_2: const #0u : u8
        let s_5304_2: u8 = 0;
        // C s_5304_3: cast zx s_5304_2 -> bv
        let s_5304_3: Bits = Bits::new(s_5304_2 as u128, 3u16);
        // D s_5304_4: cmp-eq s_5304_1 s_5304_3
        let s_5304_4: bool = ((s_5304_1) == (s_5304_3));
        // D s_5304_5: write-var gs#134818 <= s_5304_4
        fn_state.gs_134818 = s_5304_4;
        // N s_5304_6: jump b762
        return block_762(state, tracer, fn_state);
    }
    fn block_5305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5305_0: read-var coproc:u8
        let s_5305_0: u8 = fn_state.coproc;
        // D s_5305_1: cast zx s_5305_0 -> bv
        let s_5305_1: Bits = Bits::new(s_5305_0 as u128, 4u16);
        // C s_5305_2: const #15u : u8
        let s_5305_2: u8 = 15;
        // C s_5305_3: cast zx s_5305_2 -> bv
        let s_5305_3: Bits = Bits::new(s_5305_2 as u128, 4u16);
        // D s_5305_4: cmp-eq s_5305_1 s_5305_3
        let s_5305_4: bool = ((s_5305_1) == (s_5305_3));
        // D s_5305_5: write-var gs#134817 <= s_5305_4
        fn_state.gs_134817 = s_5305_4;
        // N s_5305_6: jump b760
        return block_760(state, tracer, fn_state);
    }
    fn block_5306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5306_0: read-var CRn:u8
        let s_5306_0: u8 = fn_state.CRn;
        // D s_5306_1: cast zx s_5306_0 -> bv
        let s_5306_1: Bits = Bits::new(s_5306_0 as u128, 4u16);
        // C s_5306_2: const #12u : u8
        let s_5306_2: u8 = 12;
        // C s_5306_3: cast zx s_5306_2 -> bv
        let s_5306_3: Bits = Bits::new(s_5306_2 as u128, 4u16);
        // D s_5306_4: cmp-eq s_5306_1 s_5306_3
        let s_5306_4: bool = ((s_5306_1) == (s_5306_3));
        // D s_5306_5: write-var gs#134816 <= s_5306_4
        fn_state.gs_134816 = s_5306_4;
        // N s_5306_6: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_5307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5307_0: read-var el:u8
        let s_5307_0: u8 = fn_state.el;
        // D s_5307_1: read-var coproc:u8
        let s_5307_1: u8 = fn_state.coproc;
        // D s_5307_2: read-var opc1:u8
        let s_5307_2: u8 = fn_state.opc1;
        // D s_5307_3: read-var CRn:u8
        let s_5307_3: u8 = fn_state.CRn;
        // D s_5307_4: read-var opc2:u8
        let s_5307_4: u8 = fn_state.opc2;
        // D s_5307_5: read-var CRm:u8
        let s_5307_5: u8 = fn_state.CRm;
        // D s_5307_6: read-var t:i
        let s_5307_6: i128 = fn_state.t;
        // D s_5307_7: call DBGWVR_SysRegWrite32_1db5da1de86cc148(s_5307_0, s_5307_1, s_5307_2, s_5307_3, s_5307_4, s_5307_5, s_5307_6)
        let s_5307_7: () = DBGWVR_SysRegWrite32_1db5da1de86cc148(
            state,
            tracer,
            s_5307_0,
            s_5307_1,
            s_5307_2,
            s_5307_3,
            s_5307_4,
            s_5307_5,
            s_5307_6,
        );
        // N s_5307_8: return
        return;
    }
    fn block_5308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5308_0: read-var opc2:u8
        let s_5308_0: u8 = fn_state.opc2;
        // D s_5308_1: cast zx s_5308_0 -> bv
        let s_5308_1: Bits = Bits::new(s_5308_0 as u128, 3u16);
        // C s_5308_2: const #6u : u8
        let s_5308_2: u8 = 6;
        // C s_5308_3: cast zx s_5308_2 -> bv
        let s_5308_3: Bits = Bits::new(s_5308_2 as u128, 3u16);
        // D s_5308_4: cmp-eq s_5308_1 s_5308_3
        let s_5308_4: bool = ((s_5308_1) == (s_5308_3));
        // D s_5308_5: write-var gs#134815 <= s_5308_4
        fn_state.gs_134815 = s_5308_4;
        // N s_5308_6: jump b755
        return block_755(state, tracer, fn_state);
    }
    fn block_5309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5309_0: read-var opc1:u8
        let s_5309_0: u8 = fn_state.opc1;
        // D s_5309_1: cast zx s_5309_0 -> bv
        let s_5309_1: Bits = Bits::new(s_5309_0 as u128, 3u16);
        // C s_5309_2: const #0u : u8
        let s_5309_2: u8 = 0;
        // C s_5309_3: cast zx s_5309_2 -> bv
        let s_5309_3: Bits = Bits::new(s_5309_2 as u128, 3u16);
        // D s_5309_4: cmp-eq s_5309_1 s_5309_3
        let s_5309_4: bool = ((s_5309_1) == (s_5309_3));
        // D s_5309_5: write-var gs#134814 <= s_5309_4
        fn_state.gs_134814 = s_5309_4;
        // N s_5309_6: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_5310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5310_0: read-var coproc:u8
        let s_5310_0: u8 = fn_state.coproc;
        // D s_5310_1: cast zx s_5310_0 -> bv
        let s_5310_1: Bits = Bits::new(s_5310_0 as u128, 4u16);
        // C s_5310_2: const #14u : u8
        let s_5310_2: u8 = 14;
        // C s_5310_3: cast zx s_5310_2 -> bv
        let s_5310_3: Bits = Bits::new(s_5310_2 as u128, 4u16);
        // D s_5310_4: cmp-eq s_5310_1 s_5310_3
        let s_5310_4: bool = ((s_5310_1) == (s_5310_3));
        // D s_5310_5: write-var gs#134813 <= s_5310_4
        fn_state.gs_134813 = s_5310_4;
        // N s_5310_6: jump b751
        return block_751(state, tracer, fn_state);
    }
    fn block_5311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5311_0: read-var CRn:u8
        let s_5311_0: u8 = fn_state.CRn;
        // D s_5311_1: cast zx s_5311_0 -> bv
        let s_5311_1: Bits = Bits::new(s_5311_0 as u128, 4u16);
        // C s_5311_2: const #0u : u8
        let s_5311_2: u8 = 0;
        // C s_5311_3: cast zx s_5311_2 -> bv
        let s_5311_3: Bits = Bits::new(s_5311_2 as u128, 4u16);
        // D s_5311_4: cmp-eq s_5311_1 s_5311_3
        let s_5311_4: bool = ((s_5311_1) == (s_5311_3));
        // D s_5311_5: write-var gs#134812 <= s_5311_4
        fn_state.gs_134812 = s_5311_4;
        // N s_5311_6: jump b749
        return block_749(state, tracer, fn_state);
    }
    fn block_5312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5312_0: read-var el:u8
        let s_5312_0: u8 = fn_state.el;
        // D s_5312_1: read-var coproc:u8
        let s_5312_1: u8 = fn_state.coproc;
        // D s_5312_2: read-var opc1:u8
        let s_5312_2: u8 = fn_state.opc1;
        // D s_5312_3: read-var CRn:u8
        let s_5312_3: u8 = fn_state.CRn;
        // D s_5312_4: read-var opc2:u8
        let s_5312_4: u8 = fn_state.opc2;
        // D s_5312_5: read-var CRm:u8
        let s_5312_5: u8 = fn_state.CRm;
        // D s_5312_6: read-var t:i
        let s_5312_6: i128 = fn_state.t;
        // D s_5312_7: call DBGWVR_SysRegWrite32_47c683530a163238(s_5312_0, s_5312_1, s_5312_2, s_5312_3, s_5312_4, s_5312_5, s_5312_6)
        let s_5312_7: () = DBGWVR_SysRegWrite32_47c683530a163238(
            state,
            tracer,
            s_5312_0,
            s_5312_1,
            s_5312_2,
            s_5312_3,
            s_5312_4,
            s_5312_5,
            s_5312_6,
        );
        // N s_5312_8: return
        return;
    }
    fn block_5313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5313_0: read-var opc2:u8
        let s_5313_0: u8 = fn_state.opc2;
        // D s_5313_1: cast zx s_5313_0 -> bv
        let s_5313_1: Bits = Bits::new(s_5313_0 as u128, 3u16);
        // C s_5313_2: const #6u : u8
        let s_5313_2: u8 = 6;
        // C s_5313_3: cast zx s_5313_2 -> bv
        let s_5313_3: Bits = Bits::new(s_5313_2 as u128, 3u16);
        // D s_5313_4: cmp-eq s_5313_1 s_5313_3
        let s_5313_4: bool = ((s_5313_1) == (s_5313_3));
        // D s_5313_5: write-var gs#134811 <= s_5313_4
        fn_state.gs_134811 = s_5313_4;
        // N s_5313_6: jump b746
        return block_746(state, tracer, fn_state);
    }
    fn block_5314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5314_0: read-var opc1:u8
        let s_5314_0: u8 = fn_state.opc1;
        // D s_5314_1: cast zx s_5314_0 -> bv
        let s_5314_1: Bits = Bits::new(s_5314_0 as u128, 3u16);
        // C s_5314_2: const #0u : u8
        let s_5314_2: u8 = 0;
        // C s_5314_3: cast zx s_5314_2 -> bv
        let s_5314_3: Bits = Bits::new(s_5314_2 as u128, 3u16);
        // D s_5314_4: cmp-eq s_5314_1 s_5314_3
        let s_5314_4: bool = ((s_5314_1) == (s_5314_3));
        // D s_5314_5: write-var gs#134810 <= s_5314_4
        fn_state.gs_134810 = s_5314_4;
        // N s_5314_6: jump b744
        return block_744(state, tracer, fn_state);
    }
    fn block_5315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5315_0: read-var coproc:u8
        let s_5315_0: u8 = fn_state.coproc;
        // D s_5315_1: cast zx s_5315_0 -> bv
        let s_5315_1: Bits = Bits::new(s_5315_0 as u128, 4u16);
        // C s_5315_2: const #14u : u8
        let s_5315_2: u8 = 14;
        // C s_5315_3: cast zx s_5315_2 -> bv
        let s_5315_3: Bits = Bits::new(s_5315_2 as u128, 4u16);
        // D s_5315_4: cmp-eq s_5315_1 s_5315_3
        let s_5315_4: bool = ((s_5315_1) == (s_5315_3));
        // D s_5315_5: write-var gs#134809 <= s_5315_4
        fn_state.gs_134809 = s_5315_4;
        // N s_5315_6: jump b742
        return block_742(state, tracer, fn_state);
    }
    fn block_5316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5316_0: read-var CRn:u8
        let s_5316_0: u8 = fn_state.CRn;
        // D s_5316_1: cast zx s_5316_0 -> bv
        let s_5316_1: Bits = Bits::new(s_5316_0 as u128, 4u16);
        // C s_5316_2: const #0u : u8
        let s_5316_2: u8 = 0;
        // C s_5316_3: cast zx s_5316_2 -> bv
        let s_5316_3: Bits = Bits::new(s_5316_2 as u128, 4u16);
        // D s_5316_4: cmp-eq s_5316_1 s_5316_3
        let s_5316_4: bool = ((s_5316_1) == (s_5316_3));
        // D s_5316_5: write-var gs#134808 <= s_5316_4
        fn_state.gs_134808 = s_5316_4;
        // N s_5316_6: jump b740
        return block_740(state, tracer, fn_state);
    }
    fn block_5317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5317_0: read-var el:u8
        let s_5317_0: u8 = fn_state.el;
        // D s_5317_1: read-var coproc:u8
        let s_5317_1: u8 = fn_state.coproc;
        // D s_5317_2: read-var opc1:u8
        let s_5317_2: u8 = fn_state.opc1;
        // D s_5317_3: read-var CRn:u8
        let s_5317_3: u8 = fn_state.CRn;
        // D s_5317_4: read-var opc2:u8
        let s_5317_4: u8 = fn_state.opc2;
        // D s_5317_5: read-var CRm:u8
        let s_5317_5: u8 = fn_state.CRm;
        // D s_5317_6: read-var t:i
        let s_5317_6: i128 = fn_state.t;
        // D s_5317_7: call DBGWVR_SysRegWrite32_13f080217ac19392(s_5317_0, s_5317_1, s_5317_2, s_5317_3, s_5317_4, s_5317_5, s_5317_6)
        let s_5317_7: () = DBGWVR_SysRegWrite32_13f080217ac19392(
            state,
            tracer,
            s_5317_0,
            s_5317_1,
            s_5317_2,
            s_5317_3,
            s_5317_4,
            s_5317_5,
            s_5317_6,
        );
        // N s_5317_8: return
        return;
    }
    fn block_5318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5318_0: read-var opc2:u8
        let s_5318_0: u8 = fn_state.opc2;
        // D s_5318_1: cast zx s_5318_0 -> bv
        let s_5318_1: Bits = Bits::new(s_5318_0 as u128, 3u16);
        // C s_5318_2: const #6u : u8
        let s_5318_2: u8 = 6;
        // C s_5318_3: cast zx s_5318_2 -> bv
        let s_5318_3: Bits = Bits::new(s_5318_2 as u128, 3u16);
        // D s_5318_4: cmp-eq s_5318_1 s_5318_3
        let s_5318_4: bool = ((s_5318_1) == (s_5318_3));
        // D s_5318_5: write-var gs#134807 <= s_5318_4
        fn_state.gs_134807 = s_5318_4;
        // N s_5318_6: jump b737
        return block_737(state, tracer, fn_state);
    }
    fn block_5319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5319_0: read-var opc1:u8
        let s_5319_0: u8 = fn_state.opc1;
        // D s_5319_1: cast zx s_5319_0 -> bv
        let s_5319_1: Bits = Bits::new(s_5319_0 as u128, 3u16);
        // C s_5319_2: const #0u : u8
        let s_5319_2: u8 = 0;
        // C s_5319_3: cast zx s_5319_2 -> bv
        let s_5319_3: Bits = Bits::new(s_5319_2 as u128, 3u16);
        // D s_5319_4: cmp-eq s_5319_1 s_5319_3
        let s_5319_4: bool = ((s_5319_1) == (s_5319_3));
        // D s_5319_5: write-var gs#134806 <= s_5319_4
        fn_state.gs_134806 = s_5319_4;
        // N s_5319_6: jump b735
        return block_735(state, tracer, fn_state);
    }
    fn block_5320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5320_0: read-var coproc:u8
        let s_5320_0: u8 = fn_state.coproc;
        // D s_5320_1: cast zx s_5320_0 -> bv
        let s_5320_1: Bits = Bits::new(s_5320_0 as u128, 4u16);
        // C s_5320_2: const #14u : u8
        let s_5320_2: u8 = 14;
        // C s_5320_3: cast zx s_5320_2 -> bv
        let s_5320_3: Bits = Bits::new(s_5320_2 as u128, 4u16);
        // D s_5320_4: cmp-eq s_5320_1 s_5320_3
        let s_5320_4: bool = ((s_5320_1) == (s_5320_3));
        // D s_5320_5: write-var gs#134805 <= s_5320_4
        fn_state.gs_134805 = s_5320_4;
        // N s_5320_6: jump b733
        return block_733(state, tracer, fn_state);
    }
    fn block_5321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5321_0: read-var CRn:u8
        let s_5321_0: u8 = fn_state.CRn;
        // D s_5321_1: cast zx s_5321_0 -> bv
        let s_5321_1: Bits = Bits::new(s_5321_0 as u128, 4u16);
        // C s_5321_2: const #0u : u8
        let s_5321_2: u8 = 0;
        // C s_5321_3: cast zx s_5321_2 -> bv
        let s_5321_3: Bits = Bits::new(s_5321_2 as u128, 4u16);
        // D s_5321_4: cmp-eq s_5321_1 s_5321_3
        let s_5321_4: bool = ((s_5321_1) == (s_5321_3));
        // D s_5321_5: write-var gs#134804 <= s_5321_4
        fn_state.gs_134804 = s_5321_4;
        // N s_5321_6: jump b731
        return block_731(state, tracer, fn_state);
    }
    fn block_5322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5322_0: read-var el:u8
        let s_5322_0: u8 = fn_state.el;
        // D s_5322_1: read-var coproc:u8
        let s_5322_1: u8 = fn_state.coproc;
        // D s_5322_2: read-var opc1:u8
        let s_5322_2: u8 = fn_state.opc1;
        // D s_5322_3: read-var CRn:u8
        let s_5322_3: u8 = fn_state.CRn;
        // D s_5322_4: read-var opc2:u8
        let s_5322_4: u8 = fn_state.opc2;
        // D s_5322_5: read-var CRm:u8
        let s_5322_5: u8 = fn_state.CRm;
        // D s_5322_6: read-var t:i
        let s_5322_6: i128 = fn_state.t;
        // D s_5322_7: call DBGWVR_SysRegWrite32_02f0bae942bffd2c(s_5322_0, s_5322_1, s_5322_2, s_5322_3, s_5322_4, s_5322_5, s_5322_6)
        let s_5322_7: () = DBGWVR_SysRegWrite32_02f0bae942bffd2c(
            state,
            tracer,
            s_5322_0,
            s_5322_1,
            s_5322_2,
            s_5322_3,
            s_5322_4,
            s_5322_5,
            s_5322_6,
        );
        // N s_5322_8: return
        return;
    }
    fn block_5323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5323_0: read-var opc2:u8
        let s_5323_0: u8 = fn_state.opc2;
        // D s_5323_1: cast zx s_5323_0 -> bv
        let s_5323_1: Bits = Bits::new(s_5323_0 as u128, 3u16);
        // C s_5323_2: const #6u : u8
        let s_5323_2: u8 = 6;
        // C s_5323_3: cast zx s_5323_2 -> bv
        let s_5323_3: Bits = Bits::new(s_5323_2 as u128, 3u16);
        // D s_5323_4: cmp-eq s_5323_1 s_5323_3
        let s_5323_4: bool = ((s_5323_1) == (s_5323_3));
        // D s_5323_5: write-var gs#134803 <= s_5323_4
        fn_state.gs_134803 = s_5323_4;
        // N s_5323_6: jump b728
        return block_728(state, tracer, fn_state);
    }
    fn block_5324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5324_0: read-var opc1:u8
        let s_5324_0: u8 = fn_state.opc1;
        // D s_5324_1: cast zx s_5324_0 -> bv
        let s_5324_1: Bits = Bits::new(s_5324_0 as u128, 3u16);
        // C s_5324_2: const #0u : u8
        let s_5324_2: u8 = 0;
        // C s_5324_3: cast zx s_5324_2 -> bv
        let s_5324_3: Bits = Bits::new(s_5324_2 as u128, 3u16);
        // D s_5324_4: cmp-eq s_5324_1 s_5324_3
        let s_5324_4: bool = ((s_5324_1) == (s_5324_3));
        // D s_5324_5: write-var gs#134802 <= s_5324_4
        fn_state.gs_134802 = s_5324_4;
        // N s_5324_6: jump b726
        return block_726(state, tracer, fn_state);
    }
    fn block_5325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5325_0: read-var coproc:u8
        let s_5325_0: u8 = fn_state.coproc;
        // D s_5325_1: cast zx s_5325_0 -> bv
        let s_5325_1: Bits = Bits::new(s_5325_0 as u128, 4u16);
        // C s_5325_2: const #14u : u8
        let s_5325_2: u8 = 14;
        // C s_5325_3: cast zx s_5325_2 -> bv
        let s_5325_3: Bits = Bits::new(s_5325_2 as u128, 4u16);
        // D s_5325_4: cmp-eq s_5325_1 s_5325_3
        let s_5325_4: bool = ((s_5325_1) == (s_5325_3));
        // D s_5325_5: write-var gs#134801 <= s_5325_4
        fn_state.gs_134801 = s_5325_4;
        // N s_5325_6: jump b724
        return block_724(state, tracer, fn_state);
    }
    fn block_5326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5326_0: read-var CRn:u8
        let s_5326_0: u8 = fn_state.CRn;
        // D s_5326_1: cast zx s_5326_0 -> bv
        let s_5326_1: Bits = Bits::new(s_5326_0 as u128, 4u16);
        // C s_5326_2: const #0u : u8
        let s_5326_2: u8 = 0;
        // C s_5326_3: cast zx s_5326_2 -> bv
        let s_5326_3: Bits = Bits::new(s_5326_2 as u128, 4u16);
        // D s_5326_4: cmp-eq s_5326_1 s_5326_3
        let s_5326_4: bool = ((s_5326_1) == (s_5326_3));
        // D s_5326_5: write-var gs#134800 <= s_5326_4
        fn_state.gs_134800 = s_5326_4;
        // N s_5326_6: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_5327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5327_0: read-var el:u8
        let s_5327_0: u8 = fn_state.el;
        // D s_5327_1: read-var coproc:u8
        let s_5327_1: u8 = fn_state.coproc;
        // D s_5327_2: read-var opc1:u8
        let s_5327_2: u8 = fn_state.opc1;
        // D s_5327_3: read-var CRn:u8
        let s_5327_3: u8 = fn_state.CRn;
        // D s_5327_4: read-var opc2:u8
        let s_5327_4: u8 = fn_state.opc2;
        // D s_5327_5: read-var CRm:u8
        let s_5327_5: u8 = fn_state.CRm;
        // D s_5327_6: read-var t:i
        let s_5327_6: i128 = fn_state.t;
        // D s_5327_7: call DBGWVR_SysRegWrite32_4736e16210c07d51(s_5327_0, s_5327_1, s_5327_2, s_5327_3, s_5327_4, s_5327_5, s_5327_6)
        let s_5327_7: () = DBGWVR_SysRegWrite32_4736e16210c07d51(
            state,
            tracer,
            s_5327_0,
            s_5327_1,
            s_5327_2,
            s_5327_3,
            s_5327_4,
            s_5327_5,
            s_5327_6,
        );
        // N s_5327_8: return
        return;
    }
    fn block_5328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5328_0: read-var opc2:u8
        let s_5328_0: u8 = fn_state.opc2;
        // D s_5328_1: cast zx s_5328_0 -> bv
        let s_5328_1: Bits = Bits::new(s_5328_0 as u128, 3u16);
        // C s_5328_2: const #6u : u8
        let s_5328_2: u8 = 6;
        // C s_5328_3: cast zx s_5328_2 -> bv
        let s_5328_3: Bits = Bits::new(s_5328_2 as u128, 3u16);
        // D s_5328_4: cmp-eq s_5328_1 s_5328_3
        let s_5328_4: bool = ((s_5328_1) == (s_5328_3));
        // D s_5328_5: write-var gs#134799 <= s_5328_4
        fn_state.gs_134799 = s_5328_4;
        // N s_5328_6: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_5329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5329_0: read-var opc1:u8
        let s_5329_0: u8 = fn_state.opc1;
        // D s_5329_1: cast zx s_5329_0 -> bv
        let s_5329_1: Bits = Bits::new(s_5329_0 as u128, 3u16);
        // C s_5329_2: const #0u : u8
        let s_5329_2: u8 = 0;
        // C s_5329_3: cast zx s_5329_2 -> bv
        let s_5329_3: Bits = Bits::new(s_5329_2 as u128, 3u16);
        // D s_5329_4: cmp-eq s_5329_1 s_5329_3
        let s_5329_4: bool = ((s_5329_1) == (s_5329_3));
        // D s_5329_5: write-var gs#134798 <= s_5329_4
        fn_state.gs_134798 = s_5329_4;
        // N s_5329_6: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_5330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5330_0: read-var coproc:u8
        let s_5330_0: u8 = fn_state.coproc;
        // D s_5330_1: cast zx s_5330_0 -> bv
        let s_5330_1: Bits = Bits::new(s_5330_0 as u128, 4u16);
        // C s_5330_2: const #14u : u8
        let s_5330_2: u8 = 14;
        // C s_5330_3: cast zx s_5330_2 -> bv
        let s_5330_3: Bits = Bits::new(s_5330_2 as u128, 4u16);
        // D s_5330_4: cmp-eq s_5330_1 s_5330_3
        let s_5330_4: bool = ((s_5330_1) == (s_5330_3));
        // D s_5330_5: write-var gs#134797 <= s_5330_4
        fn_state.gs_134797 = s_5330_4;
        // N s_5330_6: jump b715
        return block_715(state, tracer, fn_state);
    }
    fn block_5331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5331_0: read-var CRn:u8
        let s_5331_0: u8 = fn_state.CRn;
        // D s_5331_1: cast zx s_5331_0 -> bv
        let s_5331_1: Bits = Bits::new(s_5331_0 as u128, 4u16);
        // C s_5331_2: const #0u : u8
        let s_5331_2: u8 = 0;
        // C s_5331_3: cast zx s_5331_2 -> bv
        let s_5331_3: Bits = Bits::new(s_5331_2 as u128, 4u16);
        // D s_5331_4: cmp-eq s_5331_1 s_5331_3
        let s_5331_4: bool = ((s_5331_1) == (s_5331_3));
        // D s_5331_5: write-var gs#134796 <= s_5331_4
        fn_state.gs_134796 = s_5331_4;
        // N s_5331_6: jump b713
        return block_713(state, tracer, fn_state);
    }
    fn block_5332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5332_0: read-var el:u8
        let s_5332_0: u8 = fn_state.el;
        // D s_5332_1: read-var coproc:u8
        let s_5332_1: u8 = fn_state.coproc;
        // D s_5332_2: read-var opc1:u8
        let s_5332_2: u8 = fn_state.opc1;
        // D s_5332_3: read-var CRn:u8
        let s_5332_3: u8 = fn_state.CRn;
        // D s_5332_4: read-var opc2:u8
        let s_5332_4: u8 = fn_state.opc2;
        // D s_5332_5: read-var CRm:u8
        let s_5332_5: u8 = fn_state.CRm;
        // D s_5332_6: read-var t:i
        let s_5332_6: i128 = fn_state.t;
        // D s_5332_7: call DBGWVR_SysRegWrite32_b57dca3091b04393(s_5332_0, s_5332_1, s_5332_2, s_5332_3, s_5332_4, s_5332_5, s_5332_6)
        let s_5332_7: () = DBGWVR_SysRegWrite32_b57dca3091b04393(
            state,
            tracer,
            s_5332_0,
            s_5332_1,
            s_5332_2,
            s_5332_3,
            s_5332_4,
            s_5332_5,
            s_5332_6,
        );
        // N s_5332_8: return
        return;
    }
    fn block_5333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5333_0: read-var opc2:u8
        let s_5333_0: u8 = fn_state.opc2;
        // D s_5333_1: cast zx s_5333_0 -> bv
        let s_5333_1: Bits = Bits::new(s_5333_0 as u128, 3u16);
        // C s_5333_2: const #6u : u8
        let s_5333_2: u8 = 6;
        // C s_5333_3: cast zx s_5333_2 -> bv
        let s_5333_3: Bits = Bits::new(s_5333_2 as u128, 3u16);
        // D s_5333_4: cmp-eq s_5333_1 s_5333_3
        let s_5333_4: bool = ((s_5333_1) == (s_5333_3));
        // D s_5333_5: write-var gs#134795 <= s_5333_4
        fn_state.gs_134795 = s_5333_4;
        // N s_5333_6: jump b710
        return block_710(state, tracer, fn_state);
    }
    fn block_5334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5334_0: read-var opc1:u8
        let s_5334_0: u8 = fn_state.opc1;
        // D s_5334_1: cast zx s_5334_0 -> bv
        let s_5334_1: Bits = Bits::new(s_5334_0 as u128, 3u16);
        // C s_5334_2: const #0u : u8
        let s_5334_2: u8 = 0;
        // C s_5334_3: cast zx s_5334_2 -> bv
        let s_5334_3: Bits = Bits::new(s_5334_2 as u128, 3u16);
        // D s_5334_4: cmp-eq s_5334_1 s_5334_3
        let s_5334_4: bool = ((s_5334_1) == (s_5334_3));
        // D s_5334_5: write-var gs#134794 <= s_5334_4
        fn_state.gs_134794 = s_5334_4;
        // N s_5334_6: jump b708
        return block_708(state, tracer, fn_state);
    }
    fn block_5335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5335_0: read-var coproc:u8
        let s_5335_0: u8 = fn_state.coproc;
        // D s_5335_1: cast zx s_5335_0 -> bv
        let s_5335_1: Bits = Bits::new(s_5335_0 as u128, 4u16);
        // C s_5335_2: const #14u : u8
        let s_5335_2: u8 = 14;
        // C s_5335_3: cast zx s_5335_2 -> bv
        let s_5335_3: Bits = Bits::new(s_5335_2 as u128, 4u16);
        // D s_5335_4: cmp-eq s_5335_1 s_5335_3
        let s_5335_4: bool = ((s_5335_1) == (s_5335_3));
        // D s_5335_5: write-var gs#134793 <= s_5335_4
        fn_state.gs_134793 = s_5335_4;
        // N s_5335_6: jump b706
        return block_706(state, tracer, fn_state);
    }
    fn block_5336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5336_0: read-var CRn:u8
        let s_5336_0: u8 = fn_state.CRn;
        // D s_5336_1: cast zx s_5336_0 -> bv
        let s_5336_1: Bits = Bits::new(s_5336_0 as u128, 4u16);
        // C s_5336_2: const #0u : u8
        let s_5336_2: u8 = 0;
        // C s_5336_3: cast zx s_5336_2 -> bv
        let s_5336_3: Bits = Bits::new(s_5336_2 as u128, 4u16);
        // D s_5336_4: cmp-eq s_5336_1 s_5336_3
        let s_5336_4: bool = ((s_5336_1) == (s_5336_3));
        // D s_5336_5: write-var gs#134792 <= s_5336_4
        fn_state.gs_134792 = s_5336_4;
        // N s_5336_6: jump b704
        return block_704(state, tracer, fn_state);
    }
    fn block_5337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5337_0: read-var el:u8
        let s_5337_0: u8 = fn_state.el;
        // D s_5337_1: read-var coproc:u8
        let s_5337_1: u8 = fn_state.coproc;
        // D s_5337_2: read-var opc1:u8
        let s_5337_2: u8 = fn_state.opc1;
        // D s_5337_3: read-var CRn:u8
        let s_5337_3: u8 = fn_state.CRn;
        // D s_5337_4: read-var opc2:u8
        let s_5337_4: u8 = fn_state.opc2;
        // D s_5337_5: read-var CRm:u8
        let s_5337_5: u8 = fn_state.CRm;
        // D s_5337_6: read-var t:i
        let s_5337_6: i128 = fn_state.t;
        // D s_5337_7: call DBGWVR_SysRegWrite32_594886fdc2160e88(s_5337_0, s_5337_1, s_5337_2, s_5337_3, s_5337_4, s_5337_5, s_5337_6)
        let s_5337_7: () = DBGWVR_SysRegWrite32_594886fdc2160e88(
            state,
            tracer,
            s_5337_0,
            s_5337_1,
            s_5337_2,
            s_5337_3,
            s_5337_4,
            s_5337_5,
            s_5337_6,
        );
        // N s_5337_8: return
        return;
    }
    fn block_5338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5338_0: read-var opc2:u8
        let s_5338_0: u8 = fn_state.opc2;
        // D s_5338_1: cast zx s_5338_0 -> bv
        let s_5338_1: Bits = Bits::new(s_5338_0 as u128, 3u16);
        // C s_5338_2: const #6u : u8
        let s_5338_2: u8 = 6;
        // C s_5338_3: cast zx s_5338_2 -> bv
        let s_5338_3: Bits = Bits::new(s_5338_2 as u128, 3u16);
        // D s_5338_4: cmp-eq s_5338_1 s_5338_3
        let s_5338_4: bool = ((s_5338_1) == (s_5338_3));
        // D s_5338_5: write-var gs#134791 <= s_5338_4
        fn_state.gs_134791 = s_5338_4;
        // N s_5338_6: jump b701
        return block_701(state, tracer, fn_state);
    }
    fn block_5339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5339_0: read-var opc1:u8
        let s_5339_0: u8 = fn_state.opc1;
        // D s_5339_1: cast zx s_5339_0 -> bv
        let s_5339_1: Bits = Bits::new(s_5339_0 as u128, 3u16);
        // C s_5339_2: const #0u : u8
        let s_5339_2: u8 = 0;
        // C s_5339_3: cast zx s_5339_2 -> bv
        let s_5339_3: Bits = Bits::new(s_5339_2 as u128, 3u16);
        // D s_5339_4: cmp-eq s_5339_1 s_5339_3
        let s_5339_4: bool = ((s_5339_1) == (s_5339_3));
        // D s_5339_5: write-var gs#134790 <= s_5339_4
        fn_state.gs_134790 = s_5339_4;
        // N s_5339_6: jump b699
        return block_699(state, tracer, fn_state);
    }
    fn block_5340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5340_0: read-var coproc:u8
        let s_5340_0: u8 = fn_state.coproc;
        // D s_5340_1: cast zx s_5340_0 -> bv
        let s_5340_1: Bits = Bits::new(s_5340_0 as u128, 4u16);
        // C s_5340_2: const #14u : u8
        let s_5340_2: u8 = 14;
        // C s_5340_3: cast zx s_5340_2 -> bv
        let s_5340_3: Bits = Bits::new(s_5340_2 as u128, 4u16);
        // D s_5340_4: cmp-eq s_5340_1 s_5340_3
        let s_5340_4: bool = ((s_5340_1) == (s_5340_3));
        // D s_5340_5: write-var gs#134789 <= s_5340_4
        fn_state.gs_134789 = s_5340_4;
        // N s_5340_6: jump b697
        return block_697(state, tracer, fn_state);
    }
    fn block_5341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5341_0: read-var CRn:u8
        let s_5341_0: u8 = fn_state.CRn;
        // D s_5341_1: cast zx s_5341_0 -> bv
        let s_5341_1: Bits = Bits::new(s_5341_0 as u128, 4u16);
        // C s_5341_2: const #0u : u8
        let s_5341_2: u8 = 0;
        // C s_5341_3: cast zx s_5341_2 -> bv
        let s_5341_3: Bits = Bits::new(s_5341_2 as u128, 4u16);
        // D s_5341_4: cmp-eq s_5341_1 s_5341_3
        let s_5341_4: bool = ((s_5341_1) == (s_5341_3));
        // D s_5341_5: write-var gs#134788 <= s_5341_4
        fn_state.gs_134788 = s_5341_4;
        // N s_5341_6: jump b695
        return block_695(state, tracer, fn_state);
    }
    fn block_5342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5342_0: read-var el:u8
        let s_5342_0: u8 = fn_state.el;
        // D s_5342_1: read-var coproc:u8
        let s_5342_1: u8 = fn_state.coproc;
        // D s_5342_2: read-var opc1:u8
        let s_5342_2: u8 = fn_state.opc1;
        // D s_5342_3: read-var CRn:u8
        let s_5342_3: u8 = fn_state.CRn;
        // D s_5342_4: read-var opc2:u8
        let s_5342_4: u8 = fn_state.opc2;
        // D s_5342_5: read-var CRm:u8
        let s_5342_5: u8 = fn_state.CRm;
        // D s_5342_6: read-var t:i
        let s_5342_6: i128 = fn_state.t;
        // D s_5342_7: call DBGWVR_SysRegWrite32_13a15cb94274721c(s_5342_0, s_5342_1, s_5342_2, s_5342_3, s_5342_4, s_5342_5, s_5342_6)
        let s_5342_7: () = DBGWVR_SysRegWrite32_13a15cb94274721c(
            state,
            tracer,
            s_5342_0,
            s_5342_1,
            s_5342_2,
            s_5342_3,
            s_5342_4,
            s_5342_5,
            s_5342_6,
        );
        // N s_5342_8: return
        return;
    }
    fn block_5343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5343_0: read-var opc2:u8
        let s_5343_0: u8 = fn_state.opc2;
        // D s_5343_1: cast zx s_5343_0 -> bv
        let s_5343_1: Bits = Bits::new(s_5343_0 as u128, 3u16);
        // C s_5343_2: const #6u : u8
        let s_5343_2: u8 = 6;
        // C s_5343_3: cast zx s_5343_2 -> bv
        let s_5343_3: Bits = Bits::new(s_5343_2 as u128, 3u16);
        // D s_5343_4: cmp-eq s_5343_1 s_5343_3
        let s_5343_4: bool = ((s_5343_1) == (s_5343_3));
        // D s_5343_5: write-var gs#134787 <= s_5343_4
        fn_state.gs_134787 = s_5343_4;
        // N s_5343_6: jump b692
        return block_692(state, tracer, fn_state);
    }
    fn block_5344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5344_0: read-var opc1:u8
        let s_5344_0: u8 = fn_state.opc1;
        // D s_5344_1: cast zx s_5344_0 -> bv
        let s_5344_1: Bits = Bits::new(s_5344_0 as u128, 3u16);
        // C s_5344_2: const #0u : u8
        let s_5344_2: u8 = 0;
        // C s_5344_3: cast zx s_5344_2 -> bv
        let s_5344_3: Bits = Bits::new(s_5344_2 as u128, 3u16);
        // D s_5344_4: cmp-eq s_5344_1 s_5344_3
        let s_5344_4: bool = ((s_5344_1) == (s_5344_3));
        // D s_5344_5: write-var gs#134786 <= s_5344_4
        fn_state.gs_134786 = s_5344_4;
        // N s_5344_6: jump b690
        return block_690(state, tracer, fn_state);
    }
    fn block_5345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5345_0: read-var coproc:u8
        let s_5345_0: u8 = fn_state.coproc;
        // D s_5345_1: cast zx s_5345_0 -> bv
        let s_5345_1: Bits = Bits::new(s_5345_0 as u128, 4u16);
        // C s_5345_2: const #14u : u8
        let s_5345_2: u8 = 14;
        // C s_5345_3: cast zx s_5345_2 -> bv
        let s_5345_3: Bits = Bits::new(s_5345_2 as u128, 4u16);
        // D s_5345_4: cmp-eq s_5345_1 s_5345_3
        let s_5345_4: bool = ((s_5345_1) == (s_5345_3));
        // D s_5345_5: write-var gs#134785 <= s_5345_4
        fn_state.gs_134785 = s_5345_4;
        // N s_5345_6: jump b688
        return block_688(state, tracer, fn_state);
    }
    fn block_5346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5346_0: read-var CRn:u8
        let s_5346_0: u8 = fn_state.CRn;
        // D s_5346_1: cast zx s_5346_0 -> bv
        let s_5346_1: Bits = Bits::new(s_5346_0 as u128, 4u16);
        // C s_5346_2: const #0u : u8
        let s_5346_2: u8 = 0;
        // C s_5346_3: cast zx s_5346_2 -> bv
        let s_5346_3: Bits = Bits::new(s_5346_2 as u128, 4u16);
        // D s_5346_4: cmp-eq s_5346_1 s_5346_3
        let s_5346_4: bool = ((s_5346_1) == (s_5346_3));
        // D s_5346_5: write-var gs#134784 <= s_5346_4
        fn_state.gs_134784 = s_5346_4;
        // N s_5346_6: jump b686
        return block_686(state, tracer, fn_state);
    }
    fn block_5347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5347_0: read-var el:u8
        let s_5347_0: u8 = fn_state.el;
        // D s_5347_1: read-var coproc:u8
        let s_5347_1: u8 = fn_state.coproc;
        // D s_5347_2: read-var opc1:u8
        let s_5347_2: u8 = fn_state.opc1;
        // D s_5347_3: read-var CRn:u8
        let s_5347_3: u8 = fn_state.CRn;
        // D s_5347_4: read-var opc2:u8
        let s_5347_4: u8 = fn_state.opc2;
        // D s_5347_5: read-var CRm:u8
        let s_5347_5: u8 = fn_state.CRm;
        // D s_5347_6: read-var t:i
        let s_5347_6: i128 = fn_state.t;
        // D s_5347_7: call DBGWVR_SysRegWrite32_e152ce10f0dfcadb(s_5347_0, s_5347_1, s_5347_2, s_5347_3, s_5347_4, s_5347_5, s_5347_6)
        let s_5347_7: () = DBGWVR_SysRegWrite32_e152ce10f0dfcadb(
            state,
            tracer,
            s_5347_0,
            s_5347_1,
            s_5347_2,
            s_5347_3,
            s_5347_4,
            s_5347_5,
            s_5347_6,
        );
        // N s_5347_8: return
        return;
    }
    fn block_5348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5348_0: read-var opc2:u8
        let s_5348_0: u8 = fn_state.opc2;
        // D s_5348_1: cast zx s_5348_0 -> bv
        let s_5348_1: Bits = Bits::new(s_5348_0 as u128, 3u16);
        // C s_5348_2: const #6u : u8
        let s_5348_2: u8 = 6;
        // C s_5348_3: cast zx s_5348_2 -> bv
        let s_5348_3: Bits = Bits::new(s_5348_2 as u128, 3u16);
        // D s_5348_4: cmp-eq s_5348_1 s_5348_3
        let s_5348_4: bool = ((s_5348_1) == (s_5348_3));
        // D s_5348_5: write-var gs#134783 <= s_5348_4
        fn_state.gs_134783 = s_5348_4;
        // N s_5348_6: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_5349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5349_0: read-var opc1:u8
        let s_5349_0: u8 = fn_state.opc1;
        // D s_5349_1: cast zx s_5349_0 -> bv
        let s_5349_1: Bits = Bits::new(s_5349_0 as u128, 3u16);
        // C s_5349_2: const #0u : u8
        let s_5349_2: u8 = 0;
        // C s_5349_3: cast zx s_5349_2 -> bv
        let s_5349_3: Bits = Bits::new(s_5349_2 as u128, 3u16);
        // D s_5349_4: cmp-eq s_5349_1 s_5349_3
        let s_5349_4: bool = ((s_5349_1) == (s_5349_3));
        // D s_5349_5: write-var gs#134782 <= s_5349_4
        fn_state.gs_134782 = s_5349_4;
        // N s_5349_6: jump b681
        return block_681(state, tracer, fn_state);
    }
    fn block_5350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5350_0: read-var coproc:u8
        let s_5350_0: u8 = fn_state.coproc;
        // D s_5350_1: cast zx s_5350_0 -> bv
        let s_5350_1: Bits = Bits::new(s_5350_0 as u128, 4u16);
        // C s_5350_2: const #14u : u8
        let s_5350_2: u8 = 14;
        // C s_5350_3: cast zx s_5350_2 -> bv
        let s_5350_3: Bits = Bits::new(s_5350_2 as u128, 4u16);
        // D s_5350_4: cmp-eq s_5350_1 s_5350_3
        let s_5350_4: bool = ((s_5350_1) == (s_5350_3));
        // D s_5350_5: write-var gs#134781 <= s_5350_4
        fn_state.gs_134781 = s_5350_4;
        // N s_5350_6: jump b679
        return block_679(state, tracer, fn_state);
    }
    fn block_5351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5351_0: read-var CRn:u8
        let s_5351_0: u8 = fn_state.CRn;
        // D s_5351_1: cast zx s_5351_0 -> bv
        let s_5351_1: Bits = Bits::new(s_5351_0 as u128, 4u16);
        // C s_5351_2: const #0u : u8
        let s_5351_2: u8 = 0;
        // C s_5351_3: cast zx s_5351_2 -> bv
        let s_5351_3: Bits = Bits::new(s_5351_2 as u128, 4u16);
        // D s_5351_4: cmp-eq s_5351_1 s_5351_3
        let s_5351_4: bool = ((s_5351_1) == (s_5351_3));
        // D s_5351_5: write-var gs#134780 <= s_5351_4
        fn_state.gs_134780 = s_5351_4;
        // N s_5351_6: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_5352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5352_0: read-var el:u8
        let s_5352_0: u8 = fn_state.el;
        // D s_5352_1: read-var coproc:u8
        let s_5352_1: u8 = fn_state.coproc;
        // D s_5352_2: read-var opc1:u8
        let s_5352_2: u8 = fn_state.opc1;
        // D s_5352_3: read-var CRn:u8
        let s_5352_3: u8 = fn_state.CRn;
        // D s_5352_4: read-var opc2:u8
        let s_5352_4: u8 = fn_state.opc2;
        // D s_5352_5: read-var CRm:u8
        let s_5352_5: u8 = fn_state.CRm;
        // D s_5352_6: read-var t:i
        let s_5352_6: i128 = fn_state.t;
        // D s_5352_7: call DBGWVR_SysRegWrite32_75d9d09012e8a36d(s_5352_0, s_5352_1, s_5352_2, s_5352_3, s_5352_4, s_5352_5, s_5352_6)
        let s_5352_7: () = DBGWVR_SysRegWrite32_75d9d09012e8a36d(
            state,
            tracer,
            s_5352_0,
            s_5352_1,
            s_5352_2,
            s_5352_3,
            s_5352_4,
            s_5352_5,
            s_5352_6,
        );
        // N s_5352_8: return
        return;
    }
    fn block_5353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5353_0: read-var opc2:u8
        let s_5353_0: u8 = fn_state.opc2;
        // D s_5353_1: cast zx s_5353_0 -> bv
        let s_5353_1: Bits = Bits::new(s_5353_0 as u128, 3u16);
        // C s_5353_2: const #6u : u8
        let s_5353_2: u8 = 6;
        // C s_5353_3: cast zx s_5353_2 -> bv
        let s_5353_3: Bits = Bits::new(s_5353_2 as u128, 3u16);
        // D s_5353_4: cmp-eq s_5353_1 s_5353_3
        let s_5353_4: bool = ((s_5353_1) == (s_5353_3));
        // D s_5353_5: write-var gs#134779 <= s_5353_4
        fn_state.gs_134779 = s_5353_4;
        // N s_5353_6: jump b674
        return block_674(state, tracer, fn_state);
    }
    fn block_5354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5354_0: read-var opc1:u8
        let s_5354_0: u8 = fn_state.opc1;
        // D s_5354_1: cast zx s_5354_0 -> bv
        let s_5354_1: Bits = Bits::new(s_5354_0 as u128, 3u16);
        // C s_5354_2: const #0u : u8
        let s_5354_2: u8 = 0;
        // C s_5354_3: cast zx s_5354_2 -> bv
        let s_5354_3: Bits = Bits::new(s_5354_2 as u128, 3u16);
        // D s_5354_4: cmp-eq s_5354_1 s_5354_3
        let s_5354_4: bool = ((s_5354_1) == (s_5354_3));
        // D s_5354_5: write-var gs#134778 <= s_5354_4
        fn_state.gs_134778 = s_5354_4;
        // N s_5354_6: jump b672
        return block_672(state, tracer, fn_state);
    }
    fn block_5355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5355_0: read-var coproc:u8
        let s_5355_0: u8 = fn_state.coproc;
        // D s_5355_1: cast zx s_5355_0 -> bv
        let s_5355_1: Bits = Bits::new(s_5355_0 as u128, 4u16);
        // C s_5355_2: const #14u : u8
        let s_5355_2: u8 = 14;
        // C s_5355_3: cast zx s_5355_2 -> bv
        let s_5355_3: Bits = Bits::new(s_5355_2 as u128, 4u16);
        // D s_5355_4: cmp-eq s_5355_1 s_5355_3
        let s_5355_4: bool = ((s_5355_1) == (s_5355_3));
        // D s_5355_5: write-var gs#134777 <= s_5355_4
        fn_state.gs_134777 = s_5355_4;
        // N s_5355_6: jump b670
        return block_670(state, tracer, fn_state);
    }
    fn block_5356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5356_0: read-var CRn:u8
        let s_5356_0: u8 = fn_state.CRn;
        // D s_5356_1: cast zx s_5356_0 -> bv
        let s_5356_1: Bits = Bits::new(s_5356_0 as u128, 4u16);
        // C s_5356_2: const #0u : u8
        let s_5356_2: u8 = 0;
        // C s_5356_3: cast zx s_5356_2 -> bv
        let s_5356_3: Bits = Bits::new(s_5356_2 as u128, 4u16);
        // D s_5356_4: cmp-eq s_5356_1 s_5356_3
        let s_5356_4: bool = ((s_5356_1) == (s_5356_3));
        // D s_5356_5: write-var gs#134776 <= s_5356_4
        fn_state.gs_134776 = s_5356_4;
        // N s_5356_6: jump b668
        return block_668(state, tracer, fn_state);
    }
    fn block_5357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5357_0: read-var el:u8
        let s_5357_0: u8 = fn_state.el;
        // D s_5357_1: read-var coproc:u8
        let s_5357_1: u8 = fn_state.coproc;
        // D s_5357_2: read-var opc1:u8
        let s_5357_2: u8 = fn_state.opc1;
        // D s_5357_3: read-var CRn:u8
        let s_5357_3: u8 = fn_state.CRn;
        // D s_5357_4: read-var opc2:u8
        let s_5357_4: u8 = fn_state.opc2;
        // D s_5357_5: read-var CRm:u8
        let s_5357_5: u8 = fn_state.CRm;
        // D s_5357_6: read-var t:i
        let s_5357_6: i128 = fn_state.t;
        // D s_5357_7: call DBGWVR_SysRegWrite32_4a1275b1dbe9af28(s_5357_0, s_5357_1, s_5357_2, s_5357_3, s_5357_4, s_5357_5, s_5357_6)
        let s_5357_7: () = DBGWVR_SysRegWrite32_4a1275b1dbe9af28(
            state,
            tracer,
            s_5357_0,
            s_5357_1,
            s_5357_2,
            s_5357_3,
            s_5357_4,
            s_5357_5,
            s_5357_6,
        );
        // N s_5357_8: return
        return;
    }
    fn block_5358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5358_0: read-var opc2:u8
        let s_5358_0: u8 = fn_state.opc2;
        // D s_5358_1: cast zx s_5358_0 -> bv
        let s_5358_1: Bits = Bits::new(s_5358_0 as u128, 3u16);
        // C s_5358_2: const #6u : u8
        let s_5358_2: u8 = 6;
        // C s_5358_3: cast zx s_5358_2 -> bv
        let s_5358_3: Bits = Bits::new(s_5358_2 as u128, 3u16);
        // D s_5358_4: cmp-eq s_5358_1 s_5358_3
        let s_5358_4: bool = ((s_5358_1) == (s_5358_3));
        // D s_5358_5: write-var gs#134775 <= s_5358_4
        fn_state.gs_134775 = s_5358_4;
        // N s_5358_6: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_5359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5359_0: read-var opc1:u8
        let s_5359_0: u8 = fn_state.opc1;
        // D s_5359_1: cast zx s_5359_0 -> bv
        let s_5359_1: Bits = Bits::new(s_5359_0 as u128, 3u16);
        // C s_5359_2: const #0u : u8
        let s_5359_2: u8 = 0;
        // C s_5359_3: cast zx s_5359_2 -> bv
        let s_5359_3: Bits = Bits::new(s_5359_2 as u128, 3u16);
        // D s_5359_4: cmp-eq s_5359_1 s_5359_3
        let s_5359_4: bool = ((s_5359_1) == (s_5359_3));
        // D s_5359_5: write-var gs#134774 <= s_5359_4
        fn_state.gs_134774 = s_5359_4;
        // N s_5359_6: jump b663
        return block_663(state, tracer, fn_state);
    }
    fn block_5360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5360_0: read-var coproc:u8
        let s_5360_0: u8 = fn_state.coproc;
        // D s_5360_1: cast zx s_5360_0 -> bv
        let s_5360_1: Bits = Bits::new(s_5360_0 as u128, 4u16);
        // C s_5360_2: const #14u : u8
        let s_5360_2: u8 = 14;
        // C s_5360_3: cast zx s_5360_2 -> bv
        let s_5360_3: Bits = Bits::new(s_5360_2 as u128, 4u16);
        // D s_5360_4: cmp-eq s_5360_1 s_5360_3
        let s_5360_4: bool = ((s_5360_1) == (s_5360_3));
        // D s_5360_5: write-var gs#134773 <= s_5360_4
        fn_state.gs_134773 = s_5360_4;
        // N s_5360_6: jump b661
        return block_661(state, tracer, fn_state);
    }
    fn block_5361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5361_0: read-var CRn:u8
        let s_5361_0: u8 = fn_state.CRn;
        // D s_5361_1: cast zx s_5361_0 -> bv
        let s_5361_1: Bits = Bits::new(s_5361_0 as u128, 4u16);
        // C s_5361_2: const #0u : u8
        let s_5361_2: u8 = 0;
        // C s_5361_3: cast zx s_5361_2 -> bv
        let s_5361_3: Bits = Bits::new(s_5361_2 as u128, 4u16);
        // D s_5361_4: cmp-eq s_5361_1 s_5361_3
        let s_5361_4: bool = ((s_5361_1) == (s_5361_3));
        // D s_5361_5: write-var gs#134772 <= s_5361_4
        fn_state.gs_134772 = s_5361_4;
        // N s_5361_6: jump b659
        return block_659(state, tracer, fn_state);
    }
    fn block_5362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5362_0: read-var el:u8
        let s_5362_0: u8 = fn_state.el;
        // D s_5362_1: read-var coproc:u8
        let s_5362_1: u8 = fn_state.coproc;
        // D s_5362_2: read-var opc1:u8
        let s_5362_2: u8 = fn_state.opc1;
        // D s_5362_3: read-var CRn:u8
        let s_5362_3: u8 = fn_state.CRn;
        // D s_5362_4: read-var opc2:u8
        let s_5362_4: u8 = fn_state.opc2;
        // D s_5362_5: read-var CRm:u8
        let s_5362_5: u8 = fn_state.CRm;
        // D s_5362_6: read-var t:i
        let s_5362_6: i128 = fn_state.t;
        // D s_5362_7: call DBGWVR_SysRegWrite32_78026fd71312533d(s_5362_0, s_5362_1, s_5362_2, s_5362_3, s_5362_4, s_5362_5, s_5362_6)
        let s_5362_7: () = DBGWVR_SysRegWrite32_78026fd71312533d(
            state,
            tracer,
            s_5362_0,
            s_5362_1,
            s_5362_2,
            s_5362_3,
            s_5362_4,
            s_5362_5,
            s_5362_6,
        );
        // N s_5362_8: return
        return;
    }
    fn block_5363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5363_0: read-var opc2:u8
        let s_5363_0: u8 = fn_state.opc2;
        // D s_5363_1: cast zx s_5363_0 -> bv
        let s_5363_1: Bits = Bits::new(s_5363_0 as u128, 3u16);
        // C s_5363_2: const #6u : u8
        let s_5363_2: u8 = 6;
        // C s_5363_3: cast zx s_5363_2 -> bv
        let s_5363_3: Bits = Bits::new(s_5363_2 as u128, 3u16);
        // D s_5363_4: cmp-eq s_5363_1 s_5363_3
        let s_5363_4: bool = ((s_5363_1) == (s_5363_3));
        // D s_5363_5: write-var gs#134771 <= s_5363_4
        fn_state.gs_134771 = s_5363_4;
        // N s_5363_6: jump b656
        return block_656(state, tracer, fn_state);
    }
    fn block_5364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5364_0: read-var opc1:u8
        let s_5364_0: u8 = fn_state.opc1;
        // D s_5364_1: cast zx s_5364_0 -> bv
        let s_5364_1: Bits = Bits::new(s_5364_0 as u128, 3u16);
        // C s_5364_2: const #0u : u8
        let s_5364_2: u8 = 0;
        // C s_5364_3: cast zx s_5364_2 -> bv
        let s_5364_3: Bits = Bits::new(s_5364_2 as u128, 3u16);
        // D s_5364_4: cmp-eq s_5364_1 s_5364_3
        let s_5364_4: bool = ((s_5364_1) == (s_5364_3));
        // D s_5364_5: write-var gs#134770 <= s_5364_4
        fn_state.gs_134770 = s_5364_4;
        // N s_5364_6: jump b654
        return block_654(state, tracer, fn_state);
    }
    fn block_5365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5365_0: read-var coproc:u8
        let s_5365_0: u8 = fn_state.coproc;
        // D s_5365_1: cast zx s_5365_0 -> bv
        let s_5365_1: Bits = Bits::new(s_5365_0 as u128, 4u16);
        // C s_5365_2: const #14u : u8
        let s_5365_2: u8 = 14;
        // C s_5365_3: cast zx s_5365_2 -> bv
        let s_5365_3: Bits = Bits::new(s_5365_2 as u128, 4u16);
        // D s_5365_4: cmp-eq s_5365_1 s_5365_3
        let s_5365_4: bool = ((s_5365_1) == (s_5365_3));
        // D s_5365_5: write-var gs#134769 <= s_5365_4
        fn_state.gs_134769 = s_5365_4;
        // N s_5365_6: jump b652
        return block_652(state, tracer, fn_state);
    }
    fn block_5366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5366_0: read-var CRn:u8
        let s_5366_0: u8 = fn_state.CRn;
        // D s_5366_1: cast zx s_5366_0 -> bv
        let s_5366_1: Bits = Bits::new(s_5366_0 as u128, 4u16);
        // C s_5366_2: const #0u : u8
        let s_5366_2: u8 = 0;
        // C s_5366_3: cast zx s_5366_2 -> bv
        let s_5366_3: Bits = Bits::new(s_5366_2 as u128, 4u16);
        // D s_5366_4: cmp-eq s_5366_1 s_5366_3
        let s_5366_4: bool = ((s_5366_1) == (s_5366_3));
        // D s_5366_5: write-var gs#134768 <= s_5366_4
        fn_state.gs_134768 = s_5366_4;
        // N s_5366_6: jump b650
        return block_650(state, tracer, fn_state);
    }
    fn block_5367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5367_0: read-var el:u8
        let s_5367_0: u8 = fn_state.el;
        // D s_5367_1: read-var coproc:u8
        let s_5367_1: u8 = fn_state.coproc;
        // D s_5367_2: read-var opc1:u8
        let s_5367_2: u8 = fn_state.opc1;
        // D s_5367_3: read-var CRn:u8
        let s_5367_3: u8 = fn_state.CRn;
        // D s_5367_4: read-var opc2:u8
        let s_5367_4: u8 = fn_state.opc2;
        // D s_5367_5: read-var CRm:u8
        let s_5367_5: u8 = fn_state.CRm;
        // D s_5367_6: read-var t:i
        let s_5367_6: i128 = fn_state.t;
        // D s_5367_7: call DBGWVR_SysRegWrite32_73839b539e79472c(s_5367_0, s_5367_1, s_5367_2, s_5367_3, s_5367_4, s_5367_5, s_5367_6)
        let s_5367_7: () = DBGWVR_SysRegWrite32_73839b539e79472c(
            state,
            tracer,
            s_5367_0,
            s_5367_1,
            s_5367_2,
            s_5367_3,
            s_5367_4,
            s_5367_5,
            s_5367_6,
        );
        // N s_5367_8: return
        return;
    }
    fn block_5368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5368_0: read-var opc2:u8
        let s_5368_0: u8 = fn_state.opc2;
        // D s_5368_1: cast zx s_5368_0 -> bv
        let s_5368_1: Bits = Bits::new(s_5368_0 as u128, 3u16);
        // C s_5368_2: const #6u : u8
        let s_5368_2: u8 = 6;
        // C s_5368_3: cast zx s_5368_2 -> bv
        let s_5368_3: Bits = Bits::new(s_5368_2 as u128, 3u16);
        // D s_5368_4: cmp-eq s_5368_1 s_5368_3
        let s_5368_4: bool = ((s_5368_1) == (s_5368_3));
        // D s_5368_5: write-var gs#134767 <= s_5368_4
        fn_state.gs_134767 = s_5368_4;
        // N s_5368_6: jump b647
        return block_647(state, tracer, fn_state);
    }
    fn block_5369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5369_0: read-var opc1:u8
        let s_5369_0: u8 = fn_state.opc1;
        // D s_5369_1: cast zx s_5369_0 -> bv
        let s_5369_1: Bits = Bits::new(s_5369_0 as u128, 3u16);
        // C s_5369_2: const #0u : u8
        let s_5369_2: u8 = 0;
        // C s_5369_3: cast zx s_5369_2 -> bv
        let s_5369_3: Bits = Bits::new(s_5369_2 as u128, 3u16);
        // D s_5369_4: cmp-eq s_5369_1 s_5369_3
        let s_5369_4: bool = ((s_5369_1) == (s_5369_3));
        // D s_5369_5: write-var gs#134766 <= s_5369_4
        fn_state.gs_134766 = s_5369_4;
        // N s_5369_6: jump b645
        return block_645(state, tracer, fn_state);
    }
    fn block_5370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5370_0: read-var coproc:u8
        let s_5370_0: u8 = fn_state.coproc;
        // D s_5370_1: cast zx s_5370_0 -> bv
        let s_5370_1: Bits = Bits::new(s_5370_0 as u128, 4u16);
        // C s_5370_2: const #14u : u8
        let s_5370_2: u8 = 14;
        // C s_5370_3: cast zx s_5370_2 -> bv
        let s_5370_3: Bits = Bits::new(s_5370_2 as u128, 4u16);
        // D s_5370_4: cmp-eq s_5370_1 s_5370_3
        let s_5370_4: bool = ((s_5370_1) == (s_5370_3));
        // D s_5370_5: write-var gs#134765 <= s_5370_4
        fn_state.gs_134765 = s_5370_4;
        // N s_5370_6: jump b643
        return block_643(state, tracer, fn_state);
    }
    fn block_5371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5371_0: read-var CRn:u8
        let s_5371_0: u8 = fn_state.CRn;
        // D s_5371_1: cast zx s_5371_0 -> bv
        let s_5371_1: Bits = Bits::new(s_5371_0 as u128, 4u16);
        // C s_5371_2: const #0u : u8
        let s_5371_2: u8 = 0;
        // C s_5371_3: cast zx s_5371_2 -> bv
        let s_5371_3: Bits = Bits::new(s_5371_2 as u128, 4u16);
        // D s_5371_4: cmp-eq s_5371_1 s_5371_3
        let s_5371_4: bool = ((s_5371_1) == (s_5371_3));
        // D s_5371_5: write-var gs#134764 <= s_5371_4
        fn_state.gs_134764 = s_5371_4;
        // N s_5371_6: jump b641
        return block_641(state, tracer, fn_state);
    }
    fn block_5372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5372_0: read-var el:u8
        let s_5372_0: u8 = fn_state.el;
        // D s_5372_1: read-var coproc:u8
        let s_5372_1: u8 = fn_state.coproc;
        // D s_5372_2: read-var opc1:u8
        let s_5372_2: u8 = fn_state.opc1;
        // D s_5372_3: read-var CRn:u8
        let s_5372_3: u8 = fn_state.CRn;
        // D s_5372_4: read-var opc2:u8
        let s_5372_4: u8 = fn_state.opc2;
        // D s_5372_5: read-var CRm:u8
        let s_5372_5: u8 = fn_state.CRm;
        // D s_5372_6: read-var t:i
        let s_5372_6: i128 = fn_state.t;
        // D s_5372_7: call DBGWVR_SysRegWrite32_9c49de3c8c0f3437(s_5372_0, s_5372_1, s_5372_2, s_5372_3, s_5372_4, s_5372_5, s_5372_6)
        let s_5372_7: () = DBGWVR_SysRegWrite32_9c49de3c8c0f3437(
            state,
            tracer,
            s_5372_0,
            s_5372_1,
            s_5372_2,
            s_5372_3,
            s_5372_4,
            s_5372_5,
            s_5372_6,
        );
        // N s_5372_8: return
        return;
    }
    fn block_5373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5373_0: read-var opc2:u8
        let s_5373_0: u8 = fn_state.opc2;
        // D s_5373_1: cast zx s_5373_0 -> bv
        let s_5373_1: Bits = Bits::new(s_5373_0 as u128, 3u16);
        // C s_5373_2: const #6u : u8
        let s_5373_2: u8 = 6;
        // C s_5373_3: cast zx s_5373_2 -> bv
        let s_5373_3: Bits = Bits::new(s_5373_2 as u128, 3u16);
        // D s_5373_4: cmp-eq s_5373_1 s_5373_3
        let s_5373_4: bool = ((s_5373_1) == (s_5373_3));
        // D s_5373_5: write-var gs#134763 <= s_5373_4
        fn_state.gs_134763 = s_5373_4;
        // N s_5373_6: jump b638
        return block_638(state, tracer, fn_state);
    }
    fn block_5374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5374_0: read-var opc1:u8
        let s_5374_0: u8 = fn_state.opc1;
        // D s_5374_1: cast zx s_5374_0 -> bv
        let s_5374_1: Bits = Bits::new(s_5374_0 as u128, 3u16);
        // C s_5374_2: const #0u : u8
        let s_5374_2: u8 = 0;
        // C s_5374_3: cast zx s_5374_2 -> bv
        let s_5374_3: Bits = Bits::new(s_5374_2 as u128, 3u16);
        // D s_5374_4: cmp-eq s_5374_1 s_5374_3
        let s_5374_4: bool = ((s_5374_1) == (s_5374_3));
        // D s_5374_5: write-var gs#134762 <= s_5374_4
        fn_state.gs_134762 = s_5374_4;
        // N s_5374_6: jump b636
        return block_636(state, tracer, fn_state);
    }
    fn block_5375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5375_0: read-var coproc:u8
        let s_5375_0: u8 = fn_state.coproc;
        // D s_5375_1: cast zx s_5375_0 -> bv
        let s_5375_1: Bits = Bits::new(s_5375_0 as u128, 4u16);
        // C s_5375_2: const #14u : u8
        let s_5375_2: u8 = 14;
        // C s_5375_3: cast zx s_5375_2 -> bv
        let s_5375_3: Bits = Bits::new(s_5375_2 as u128, 4u16);
        // D s_5375_4: cmp-eq s_5375_1 s_5375_3
        let s_5375_4: bool = ((s_5375_1) == (s_5375_3));
        // D s_5375_5: write-var gs#134761 <= s_5375_4
        fn_state.gs_134761 = s_5375_4;
        // N s_5375_6: jump b634
        return block_634(state, tracer, fn_state);
    }
    fn block_5376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5376_0: read-var CRn:u8
        let s_5376_0: u8 = fn_state.CRn;
        // D s_5376_1: cast zx s_5376_0 -> bv
        let s_5376_1: Bits = Bits::new(s_5376_0 as u128, 4u16);
        // C s_5376_2: const #0u : u8
        let s_5376_2: u8 = 0;
        // C s_5376_3: cast zx s_5376_2 -> bv
        let s_5376_3: Bits = Bits::new(s_5376_2 as u128, 4u16);
        // D s_5376_4: cmp-eq s_5376_1 s_5376_3
        let s_5376_4: bool = ((s_5376_1) == (s_5376_3));
        // D s_5376_5: write-var gs#134760 <= s_5376_4
        fn_state.gs_134760 = s_5376_4;
        // N s_5376_6: jump b632
        return block_632(state, tracer, fn_state);
    }
    fn block_5377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5377_0: read-var el:u8
        let s_5377_0: u8 = fn_state.el;
        // D s_5377_1: read-var coproc:u8
        let s_5377_1: u8 = fn_state.coproc;
        // D s_5377_2: read-var opc1:u8
        let s_5377_2: u8 = fn_state.opc1;
        // D s_5377_3: read-var CRn:u8
        let s_5377_3: u8 = fn_state.CRn;
        // D s_5377_4: read-var opc2:u8
        let s_5377_4: u8 = fn_state.opc2;
        // D s_5377_5: read-var CRm:u8
        let s_5377_5: u8 = fn_state.CRm;
        // D s_5377_6: read-var t:i
        let s_5377_6: i128 = fn_state.t;
        // D s_5377_7: call DBGWVR_SysRegWrite32_e5618a29e5f06d6d(s_5377_0, s_5377_1, s_5377_2, s_5377_3, s_5377_4, s_5377_5, s_5377_6)
        let s_5377_7: () = DBGWVR_SysRegWrite32_e5618a29e5f06d6d(
            state,
            tracer,
            s_5377_0,
            s_5377_1,
            s_5377_2,
            s_5377_3,
            s_5377_4,
            s_5377_5,
            s_5377_6,
        );
        // N s_5377_8: return
        return;
    }
    fn block_5378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5378_0: read-var opc2:u8
        let s_5378_0: u8 = fn_state.opc2;
        // D s_5378_1: cast zx s_5378_0 -> bv
        let s_5378_1: Bits = Bits::new(s_5378_0 as u128, 3u16);
        // C s_5378_2: const #6u : u8
        let s_5378_2: u8 = 6;
        // C s_5378_3: cast zx s_5378_2 -> bv
        let s_5378_3: Bits = Bits::new(s_5378_2 as u128, 3u16);
        // D s_5378_4: cmp-eq s_5378_1 s_5378_3
        let s_5378_4: bool = ((s_5378_1) == (s_5378_3));
        // D s_5378_5: write-var gs#134759 <= s_5378_4
        fn_state.gs_134759 = s_5378_4;
        // N s_5378_6: jump b629
        return block_629(state, tracer, fn_state);
    }
    fn block_5379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5379_0: read-var opc1:u8
        let s_5379_0: u8 = fn_state.opc1;
        // D s_5379_1: cast zx s_5379_0 -> bv
        let s_5379_1: Bits = Bits::new(s_5379_0 as u128, 3u16);
        // C s_5379_2: const #0u : u8
        let s_5379_2: u8 = 0;
        // C s_5379_3: cast zx s_5379_2 -> bv
        let s_5379_3: Bits = Bits::new(s_5379_2 as u128, 3u16);
        // D s_5379_4: cmp-eq s_5379_1 s_5379_3
        let s_5379_4: bool = ((s_5379_1) == (s_5379_3));
        // D s_5379_5: write-var gs#134758 <= s_5379_4
        fn_state.gs_134758 = s_5379_4;
        // N s_5379_6: jump b627
        return block_627(state, tracer, fn_state);
    }
    fn block_5380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5380_0: read-var coproc:u8
        let s_5380_0: u8 = fn_state.coproc;
        // D s_5380_1: cast zx s_5380_0 -> bv
        let s_5380_1: Bits = Bits::new(s_5380_0 as u128, 4u16);
        // C s_5380_2: const #14u : u8
        let s_5380_2: u8 = 14;
        // C s_5380_3: cast zx s_5380_2 -> bv
        let s_5380_3: Bits = Bits::new(s_5380_2 as u128, 4u16);
        // D s_5380_4: cmp-eq s_5380_1 s_5380_3
        let s_5380_4: bool = ((s_5380_1) == (s_5380_3));
        // D s_5380_5: write-var gs#134757 <= s_5380_4
        fn_state.gs_134757 = s_5380_4;
        // N s_5380_6: jump b625
        return block_625(state, tracer, fn_state);
    }
    fn block_5381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5381_0: read-var CRn:u8
        let s_5381_0: u8 = fn_state.CRn;
        // D s_5381_1: cast zx s_5381_0 -> bv
        let s_5381_1: Bits = Bits::new(s_5381_0 as u128, 4u16);
        // C s_5381_2: const #0u : u8
        let s_5381_2: u8 = 0;
        // C s_5381_3: cast zx s_5381_2 -> bv
        let s_5381_3: Bits = Bits::new(s_5381_2 as u128, 4u16);
        // D s_5381_4: cmp-eq s_5381_1 s_5381_3
        let s_5381_4: bool = ((s_5381_1) == (s_5381_3));
        // D s_5381_5: write-var gs#134756 <= s_5381_4
        fn_state.gs_134756 = s_5381_4;
        // N s_5381_6: jump b623
        return block_623(state, tracer, fn_state);
    }
    fn block_5382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5382_0: read-var el:u8
        let s_5382_0: u8 = fn_state.el;
        // D s_5382_1: read-var coproc:u8
        let s_5382_1: u8 = fn_state.coproc;
        // D s_5382_2: read-var opc1:u8
        let s_5382_2: u8 = fn_state.opc1;
        // D s_5382_3: read-var CRn:u8
        let s_5382_3: u8 = fn_state.CRn;
        // D s_5382_4: read-var opc2:u8
        let s_5382_4: u8 = fn_state.opc2;
        // D s_5382_5: read-var CRm:u8
        let s_5382_5: u8 = fn_state.CRm;
        // D s_5382_6: read-var t:i
        let s_5382_6: i128 = fn_state.t;
        // D s_5382_7: call DBGWVR_SysRegWrite32_605dd081b6345b68(s_5382_0, s_5382_1, s_5382_2, s_5382_3, s_5382_4, s_5382_5, s_5382_6)
        let s_5382_7: () = DBGWVR_SysRegWrite32_605dd081b6345b68(
            state,
            tracer,
            s_5382_0,
            s_5382_1,
            s_5382_2,
            s_5382_3,
            s_5382_4,
            s_5382_5,
            s_5382_6,
        );
        // N s_5382_8: return
        return;
    }
    fn block_5383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5383_0: read-var opc2:u8
        let s_5383_0: u8 = fn_state.opc2;
        // D s_5383_1: cast zx s_5383_0 -> bv
        let s_5383_1: Bits = Bits::new(s_5383_0 as u128, 3u16);
        // C s_5383_2: const #6u : u8
        let s_5383_2: u8 = 6;
        // C s_5383_3: cast zx s_5383_2 -> bv
        let s_5383_3: Bits = Bits::new(s_5383_2 as u128, 3u16);
        // D s_5383_4: cmp-eq s_5383_1 s_5383_3
        let s_5383_4: bool = ((s_5383_1) == (s_5383_3));
        // D s_5383_5: write-var gs#134755 <= s_5383_4
        fn_state.gs_134755 = s_5383_4;
        // N s_5383_6: jump b620
        return block_620(state, tracer, fn_state);
    }
    fn block_5384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5384_0: read-var opc1:u8
        let s_5384_0: u8 = fn_state.opc1;
        // D s_5384_1: cast zx s_5384_0 -> bv
        let s_5384_1: Bits = Bits::new(s_5384_0 as u128, 3u16);
        // C s_5384_2: const #0u : u8
        let s_5384_2: u8 = 0;
        // C s_5384_3: cast zx s_5384_2 -> bv
        let s_5384_3: Bits = Bits::new(s_5384_2 as u128, 3u16);
        // D s_5384_4: cmp-eq s_5384_1 s_5384_3
        let s_5384_4: bool = ((s_5384_1) == (s_5384_3));
        // D s_5384_5: write-var gs#134754 <= s_5384_4
        fn_state.gs_134754 = s_5384_4;
        // N s_5384_6: jump b618
        return block_618(state, tracer, fn_state);
    }
    fn block_5385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5385_0: read-var coproc:u8
        let s_5385_0: u8 = fn_state.coproc;
        // D s_5385_1: cast zx s_5385_0 -> bv
        let s_5385_1: Bits = Bits::new(s_5385_0 as u128, 4u16);
        // C s_5385_2: const #14u : u8
        let s_5385_2: u8 = 14;
        // C s_5385_3: cast zx s_5385_2 -> bv
        let s_5385_3: Bits = Bits::new(s_5385_2 as u128, 4u16);
        // D s_5385_4: cmp-eq s_5385_1 s_5385_3
        let s_5385_4: bool = ((s_5385_1) == (s_5385_3));
        // D s_5385_5: write-var gs#134753 <= s_5385_4
        fn_state.gs_134753 = s_5385_4;
        // N s_5385_6: jump b616
        return block_616(state, tracer, fn_state);
    }
    fn block_5386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5386_0: read-var CRn:u8
        let s_5386_0: u8 = fn_state.CRn;
        // D s_5386_1: cast zx s_5386_0 -> bv
        let s_5386_1: Bits = Bits::new(s_5386_0 as u128, 4u16);
        // C s_5386_2: const #0u : u8
        let s_5386_2: u8 = 0;
        // C s_5386_3: cast zx s_5386_2 -> bv
        let s_5386_3: Bits = Bits::new(s_5386_2 as u128, 4u16);
        // D s_5386_4: cmp-eq s_5386_1 s_5386_3
        let s_5386_4: bool = ((s_5386_1) == (s_5386_3));
        // D s_5386_5: write-var gs#134752 <= s_5386_4
        fn_state.gs_134752 = s_5386_4;
        // N s_5386_6: jump b614
        return block_614(state, tracer, fn_state);
    }
    fn block_5387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5387_0: read-var el:u8
        let s_5387_0: u8 = fn_state.el;
        // D s_5387_1: read-var coproc:u8
        let s_5387_1: u8 = fn_state.coproc;
        // D s_5387_2: read-var opc1:u8
        let s_5387_2: u8 = fn_state.opc1;
        // D s_5387_3: read-var CRn:u8
        let s_5387_3: u8 = fn_state.CRn;
        // D s_5387_4: read-var opc2:u8
        let s_5387_4: u8 = fn_state.opc2;
        // D s_5387_5: read-var CRm:u8
        let s_5387_5: u8 = fn_state.CRm;
        // D s_5387_6: read-var t:i
        let s_5387_6: i128 = fn_state.t;
        // D s_5387_7: call DBGCLAIMCLR_SysRegWrite32_12efe8296d991861(s_5387_0, s_5387_1, s_5387_2, s_5387_3, s_5387_4, s_5387_5, s_5387_6)
        let s_5387_7: () = DBGCLAIMCLR_SysRegWrite32_12efe8296d991861(
            state,
            tracer,
            s_5387_0,
            s_5387_1,
            s_5387_2,
            s_5387_3,
            s_5387_4,
            s_5387_5,
            s_5387_6,
        );
        // N s_5387_8: return
        return;
    }
    fn block_5388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5388_0: read-var opc2:u8
        let s_5388_0: u8 = fn_state.opc2;
        // D s_5388_1: cast zx s_5388_0 -> bv
        let s_5388_1: Bits = Bits::new(s_5388_0 as u128, 3u16);
        // C s_5388_2: const #6u : u8
        let s_5388_2: u8 = 6;
        // C s_5388_3: cast zx s_5388_2 -> bv
        let s_5388_3: Bits = Bits::new(s_5388_2 as u128, 3u16);
        // D s_5388_4: cmp-eq s_5388_1 s_5388_3
        let s_5388_4: bool = ((s_5388_1) == (s_5388_3));
        // D s_5388_5: write-var gs#134751 <= s_5388_4
        fn_state.gs_134751 = s_5388_4;
        // N s_5388_6: jump b611
        return block_611(state, tracer, fn_state);
    }
    fn block_5389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5389_0: read-var opc1:u8
        let s_5389_0: u8 = fn_state.opc1;
        // D s_5389_1: cast zx s_5389_0 -> bv
        let s_5389_1: Bits = Bits::new(s_5389_0 as u128, 3u16);
        // C s_5389_2: const #0u : u8
        let s_5389_2: u8 = 0;
        // C s_5389_3: cast zx s_5389_2 -> bv
        let s_5389_3: Bits = Bits::new(s_5389_2 as u128, 3u16);
        // D s_5389_4: cmp-eq s_5389_1 s_5389_3
        let s_5389_4: bool = ((s_5389_1) == (s_5389_3));
        // D s_5389_5: write-var gs#134750 <= s_5389_4
        fn_state.gs_134750 = s_5389_4;
        // N s_5389_6: jump b609
        return block_609(state, tracer, fn_state);
    }
    fn block_5390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5390_0: read-var coproc:u8
        let s_5390_0: u8 = fn_state.coproc;
        // D s_5390_1: cast zx s_5390_0 -> bv
        let s_5390_1: Bits = Bits::new(s_5390_0 as u128, 4u16);
        // C s_5390_2: const #14u : u8
        let s_5390_2: u8 = 14;
        // C s_5390_3: cast zx s_5390_2 -> bv
        let s_5390_3: Bits = Bits::new(s_5390_2 as u128, 4u16);
        // D s_5390_4: cmp-eq s_5390_1 s_5390_3
        let s_5390_4: bool = ((s_5390_1) == (s_5390_3));
        // D s_5390_5: write-var gs#134749 <= s_5390_4
        fn_state.gs_134749 = s_5390_4;
        // N s_5390_6: jump b607
        return block_607(state, tracer, fn_state);
    }
    fn block_5391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5391_0: read-var CRn:u8
        let s_5391_0: u8 = fn_state.CRn;
        // D s_5391_1: cast zx s_5391_0 -> bv
        let s_5391_1: Bits = Bits::new(s_5391_0 as u128, 4u16);
        // C s_5391_2: const #7u : u8
        let s_5391_2: u8 = 7;
        // C s_5391_3: cast zx s_5391_2 -> bv
        let s_5391_3: Bits = Bits::new(s_5391_2 as u128, 4u16);
        // D s_5391_4: cmp-eq s_5391_1 s_5391_3
        let s_5391_4: bool = ((s_5391_1) == (s_5391_3));
        // D s_5391_5: write-var gs#134748 <= s_5391_4
        fn_state.gs_134748 = s_5391_4;
        // N s_5391_6: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_5392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5392_0: read-var el:u8
        let s_5392_0: u8 = fn_state.el;
        // D s_5392_1: read-var coproc:u8
        let s_5392_1: u8 = fn_state.coproc;
        // D s_5392_2: read-var opc1:u8
        let s_5392_2: u8 = fn_state.opc1;
        // D s_5392_3: read-var CRn:u8
        let s_5392_3: u8 = fn_state.CRn;
        // D s_5392_4: read-var opc2:u8
        let s_5392_4: u8 = fn_state.opc2;
        // D s_5392_5: read-var CRm:u8
        let s_5392_5: u8 = fn_state.CRm;
        // D s_5392_6: read-var t:i
        let s_5392_6: i128 = fn_state.t;
        // D s_5392_7: call CNTV_TVAL_SysRegWrite32_903e727583f63e89(s_5392_0, s_5392_1, s_5392_2, s_5392_3, s_5392_4, s_5392_5, s_5392_6)
        let s_5392_7: () = CNTV_TVAL_SysRegWrite32_903e727583f63e89(
            state,
            tracer,
            s_5392_0,
            s_5392_1,
            s_5392_2,
            s_5392_3,
            s_5392_4,
            s_5392_5,
            s_5392_6,
        );
        // N s_5392_8: return
        return;
    }
    fn block_5393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5393_0: read-var opc2:u8
        let s_5393_0: u8 = fn_state.opc2;
        // D s_5393_1: cast zx s_5393_0 -> bv
        let s_5393_1: Bits = Bits::new(s_5393_0 as u128, 3u16);
        // C s_5393_2: const #0u : u8
        let s_5393_2: u8 = 0;
        // C s_5393_3: cast zx s_5393_2 -> bv
        let s_5393_3: Bits = Bits::new(s_5393_2 as u128, 3u16);
        // D s_5393_4: cmp-eq s_5393_1 s_5393_3
        let s_5393_4: bool = ((s_5393_1) == (s_5393_3));
        // D s_5393_5: write-var gs#134747 <= s_5393_4
        fn_state.gs_134747 = s_5393_4;
        // N s_5393_6: jump b602
        return block_602(state, tracer, fn_state);
    }
    fn block_5394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5394_0: read-var opc1:u8
        let s_5394_0: u8 = fn_state.opc1;
        // D s_5394_1: cast zx s_5394_0 -> bv
        let s_5394_1: Bits = Bits::new(s_5394_0 as u128, 3u16);
        // C s_5394_2: const #0u : u8
        let s_5394_2: u8 = 0;
        // C s_5394_3: cast zx s_5394_2 -> bv
        let s_5394_3: Bits = Bits::new(s_5394_2 as u128, 3u16);
        // D s_5394_4: cmp-eq s_5394_1 s_5394_3
        let s_5394_4: bool = ((s_5394_1) == (s_5394_3));
        // D s_5394_5: write-var gs#134746 <= s_5394_4
        fn_state.gs_134746 = s_5394_4;
        // N s_5394_6: jump b600
        return block_600(state, tracer, fn_state);
    }
    fn block_5395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5395_0: read-var coproc:u8
        let s_5395_0: u8 = fn_state.coproc;
        // D s_5395_1: cast zx s_5395_0 -> bv
        let s_5395_1: Bits = Bits::new(s_5395_0 as u128, 4u16);
        // C s_5395_2: const #15u : u8
        let s_5395_2: u8 = 15;
        // C s_5395_3: cast zx s_5395_2 -> bv
        let s_5395_3: Bits = Bits::new(s_5395_2 as u128, 4u16);
        // D s_5395_4: cmp-eq s_5395_1 s_5395_3
        let s_5395_4: bool = ((s_5395_1) == (s_5395_3));
        // D s_5395_5: write-var gs#134745 <= s_5395_4
        fn_state.gs_134745 = s_5395_4;
        // N s_5395_6: jump b598
        return block_598(state, tracer, fn_state);
    }
    fn block_5396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5396_0: read-var CRn:u8
        let s_5396_0: u8 = fn_state.CRn;
        // D s_5396_1: cast zx s_5396_0 -> bv
        let s_5396_1: Bits = Bits::new(s_5396_0 as u128, 4u16);
        // C s_5396_2: const #14u : u8
        let s_5396_2: u8 = 14;
        // C s_5396_3: cast zx s_5396_2 -> bv
        let s_5396_3: Bits = Bits::new(s_5396_2 as u128, 4u16);
        // D s_5396_4: cmp-eq s_5396_1 s_5396_3
        let s_5396_4: bool = ((s_5396_1) == (s_5396_3));
        // D s_5396_5: write-var gs#134744 <= s_5396_4
        fn_state.gs_134744 = s_5396_4;
        // N s_5396_6: jump b596
        return block_596(state, tracer, fn_state);
    }
    fn block_5397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5397_0: read-var el:u8
        let s_5397_0: u8 = fn_state.el;
        // D s_5397_1: read-var coproc:u8
        let s_5397_1: u8 = fn_state.coproc;
        // D s_5397_2: read-var opc1:u8
        let s_5397_2: u8 = fn_state.opc1;
        // D s_5397_3: read-var CRn:u8
        let s_5397_3: u8 = fn_state.CRn;
        // D s_5397_4: read-var opc2:u8
        let s_5397_4: u8 = fn_state.opc2;
        // D s_5397_5: read-var CRm:u8
        let s_5397_5: u8 = fn_state.CRm;
        // D s_5397_6: read-var t:i
        let s_5397_6: i128 = fn_state.t;
        // D s_5397_7: call HPFAR_SysRegWrite32_8aeb6030fddd52c2(s_5397_0, s_5397_1, s_5397_2, s_5397_3, s_5397_4, s_5397_5, s_5397_6)
        let s_5397_7: () = HPFAR_SysRegWrite32_8aeb6030fddd52c2(
            state,
            tracer,
            s_5397_0,
            s_5397_1,
            s_5397_2,
            s_5397_3,
            s_5397_4,
            s_5397_5,
            s_5397_6,
        );
        // N s_5397_8: return
        return;
    }
    fn block_5398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5398_0: read-var opc2:u8
        let s_5398_0: u8 = fn_state.opc2;
        // D s_5398_1: cast zx s_5398_0 -> bv
        let s_5398_1: Bits = Bits::new(s_5398_0 as u128, 3u16);
        // C s_5398_2: const #4u : u8
        let s_5398_2: u8 = 4;
        // C s_5398_3: cast zx s_5398_2 -> bv
        let s_5398_3: Bits = Bits::new(s_5398_2 as u128, 3u16);
        // D s_5398_4: cmp-eq s_5398_1 s_5398_3
        let s_5398_4: bool = ((s_5398_1) == (s_5398_3));
        // D s_5398_5: write-var gs#134743 <= s_5398_4
        fn_state.gs_134743 = s_5398_4;
        // N s_5398_6: jump b593
        return block_593(state, tracer, fn_state);
    }
    fn block_5399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5399_0: read-var opc1:u8
        let s_5399_0: u8 = fn_state.opc1;
        // D s_5399_1: cast zx s_5399_0 -> bv
        let s_5399_1: Bits = Bits::new(s_5399_0 as u128, 3u16);
        // C s_5399_2: const #4u : u8
        let s_5399_2: u8 = 4;
        // C s_5399_3: cast zx s_5399_2 -> bv
        let s_5399_3: Bits = Bits::new(s_5399_2 as u128, 3u16);
        // D s_5399_4: cmp-eq s_5399_1 s_5399_3
        let s_5399_4: bool = ((s_5399_1) == (s_5399_3));
        // D s_5399_5: write-var gs#134742 <= s_5399_4
        fn_state.gs_134742 = s_5399_4;
        // N s_5399_6: jump b591
        return block_591(state, tracer, fn_state);
    }
    fn block_5400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5400_0: read-var coproc:u8
        let s_5400_0: u8 = fn_state.coproc;
        // D s_5400_1: cast zx s_5400_0 -> bv
        let s_5400_1: Bits = Bits::new(s_5400_0 as u128, 4u16);
        // C s_5400_2: const #15u : u8
        let s_5400_2: u8 = 15;
        // C s_5400_3: cast zx s_5400_2 -> bv
        let s_5400_3: Bits = Bits::new(s_5400_2 as u128, 4u16);
        // D s_5400_4: cmp-eq s_5400_1 s_5400_3
        let s_5400_4: bool = ((s_5400_1) == (s_5400_3));
        // D s_5400_5: write-var gs#134741 <= s_5400_4
        fn_state.gs_134741 = s_5400_4;
        // N s_5400_6: jump b589
        return block_589(state, tracer, fn_state);
    }
    fn block_5401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5401_0: read-var CRn:u8
        let s_5401_0: u8 = fn_state.CRn;
        // D s_5401_1: cast zx s_5401_0 -> bv
        let s_5401_1: Bits = Bits::new(s_5401_0 as u128, 4u16);
        // C s_5401_2: const #6u : u8
        let s_5401_2: u8 = 6;
        // C s_5401_3: cast zx s_5401_2 -> bv
        let s_5401_3: Bits = Bits::new(s_5401_2 as u128, 4u16);
        // D s_5401_4: cmp-eq s_5401_1 s_5401_3
        let s_5401_4: bool = ((s_5401_1) == (s_5401_3));
        // D s_5401_5: write-var gs#134740 <= s_5401_4
        fn_state.gs_134740 = s_5401_4;
        // N s_5401_6: jump b587
        return block_587(state, tracer, fn_state);
    }
    fn block_5402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5402_0: read-var el:u8
        let s_5402_0: u8 = fn_state.el;
        // D s_5402_1: read-var coproc:u8
        let s_5402_1: u8 = fn_state.coproc;
        // D s_5402_2: read-var opc1:u8
        let s_5402_2: u8 = fn_state.opc1;
        // D s_5402_3: read-var CRn:u8
        let s_5402_3: u8 = fn_state.CRn;
        // D s_5402_4: read-var opc2:u8
        let s_5402_4: u8 = fn_state.opc2;
        // D s_5402_5: read-var CRm:u8
        let s_5402_5: u8 = fn_state.CRm;
        // D s_5402_6: read-var t:i
        let s_5402_6: i128 = fn_state.t;
        // D s_5402_7: call TLBIIPAS2L_SysRegWrite32_a0e257684d03ee99(s_5402_0, s_5402_1, s_5402_2, s_5402_3, s_5402_4, s_5402_5, s_5402_6)
        let s_5402_7: () = TLBIIPAS2L_SysRegWrite32_a0e257684d03ee99(
            state,
            tracer,
            s_5402_0,
            s_5402_1,
            s_5402_2,
            s_5402_3,
            s_5402_4,
            s_5402_5,
            s_5402_6,
        );
        // N s_5402_8: return
        return;
    }
    fn block_5403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5403_0: read-var opc2:u8
        let s_5403_0: u8 = fn_state.opc2;
        // D s_5403_1: cast zx s_5403_0 -> bv
        let s_5403_1: Bits = Bits::new(s_5403_0 as u128, 3u16);
        // C s_5403_2: const #5u : u8
        let s_5403_2: u8 = 5;
        // C s_5403_3: cast zx s_5403_2 -> bv
        let s_5403_3: Bits = Bits::new(s_5403_2 as u128, 3u16);
        // D s_5403_4: cmp-eq s_5403_1 s_5403_3
        let s_5403_4: bool = ((s_5403_1) == (s_5403_3));
        // D s_5403_5: write-var gs#134739 <= s_5403_4
        fn_state.gs_134739 = s_5403_4;
        // N s_5403_6: jump b584
        return block_584(state, tracer, fn_state);
    }
    fn block_5404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5404_0: read-var opc1:u8
        let s_5404_0: u8 = fn_state.opc1;
        // D s_5404_1: cast zx s_5404_0 -> bv
        let s_5404_1: Bits = Bits::new(s_5404_0 as u128, 3u16);
        // C s_5404_2: const #4u : u8
        let s_5404_2: u8 = 4;
        // C s_5404_3: cast zx s_5404_2 -> bv
        let s_5404_3: Bits = Bits::new(s_5404_2 as u128, 3u16);
        // D s_5404_4: cmp-eq s_5404_1 s_5404_3
        let s_5404_4: bool = ((s_5404_1) == (s_5404_3));
        // D s_5404_5: write-var gs#134738 <= s_5404_4
        fn_state.gs_134738 = s_5404_4;
        // N s_5404_6: jump b582
        return block_582(state, tracer, fn_state);
    }
    fn block_5405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5405_0: read-var coproc:u8
        let s_5405_0: u8 = fn_state.coproc;
        // D s_5405_1: cast zx s_5405_0 -> bv
        let s_5405_1: Bits = Bits::new(s_5405_0 as u128, 4u16);
        // C s_5405_2: const #15u : u8
        let s_5405_2: u8 = 15;
        // C s_5405_3: cast zx s_5405_2 -> bv
        let s_5405_3: Bits = Bits::new(s_5405_2 as u128, 4u16);
        // D s_5405_4: cmp-eq s_5405_1 s_5405_3
        let s_5405_4: bool = ((s_5405_1) == (s_5405_3));
        // D s_5405_5: write-var gs#134737 <= s_5405_4
        fn_state.gs_134737 = s_5405_4;
        // N s_5405_6: jump b580
        return block_580(state, tracer, fn_state);
    }
    fn block_5406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5406_0: read-var CRn:u8
        let s_5406_0: u8 = fn_state.CRn;
        // D s_5406_1: cast zx s_5406_0 -> bv
        let s_5406_1: Bits = Bits::new(s_5406_0 as u128, 4u16);
        // C s_5406_2: const #8u : u8
        let s_5406_2: u8 = 8;
        // C s_5406_3: cast zx s_5406_2 -> bv
        let s_5406_3: Bits = Bits::new(s_5406_2 as u128, 4u16);
        // D s_5406_4: cmp-eq s_5406_1 s_5406_3
        let s_5406_4: bool = ((s_5406_1) == (s_5406_3));
        // D s_5406_5: write-var gs#134736 <= s_5406_4
        fn_state.gs_134736 = s_5406_4;
        // N s_5406_6: jump b578
        return block_578(state, tracer, fn_state);
    }
    fn block_5407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5407_0: read-var el:u8
        let s_5407_0: u8 = fn_state.el;
        // D s_5407_1: read-var coproc:u8
        let s_5407_1: u8 = fn_state.coproc;
        // D s_5407_2: read-var opc1:u8
        let s_5407_2: u8 = fn_state.opc1;
        // D s_5407_3: read-var CRn:u8
        let s_5407_3: u8 = fn_state.CRn;
        // D s_5407_4: read-var opc2:u8
        let s_5407_4: u8 = fn_state.opc2;
        // D s_5407_5: read-var CRm:u8
        let s_5407_5: u8 = fn_state.CRm;
        // D s_5407_6: read-var t:i
        let s_5407_6: i128 = fn_state.t;
        // D s_5407_7: call TLBIMVALH_SysRegWrite32_e910bf47238cb4c5(s_5407_0, s_5407_1, s_5407_2, s_5407_3, s_5407_4, s_5407_5, s_5407_6)
        let s_5407_7: () = TLBIMVALH_SysRegWrite32_e910bf47238cb4c5(
            state,
            tracer,
            s_5407_0,
            s_5407_1,
            s_5407_2,
            s_5407_3,
            s_5407_4,
            s_5407_5,
            s_5407_6,
        );
        // N s_5407_8: return
        return;
    }
    fn block_5408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5408_0: read-var opc2:u8
        let s_5408_0: u8 = fn_state.opc2;
        // D s_5408_1: cast zx s_5408_0 -> bv
        let s_5408_1: Bits = Bits::new(s_5408_0 as u128, 3u16);
        // C s_5408_2: const #5u : u8
        let s_5408_2: u8 = 5;
        // C s_5408_3: cast zx s_5408_2 -> bv
        let s_5408_3: Bits = Bits::new(s_5408_2 as u128, 3u16);
        // D s_5408_4: cmp-eq s_5408_1 s_5408_3
        let s_5408_4: bool = ((s_5408_1) == (s_5408_3));
        // D s_5408_5: write-var gs#134735 <= s_5408_4
        fn_state.gs_134735 = s_5408_4;
        // N s_5408_6: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_5409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5409_0: read-var opc1:u8
        let s_5409_0: u8 = fn_state.opc1;
        // D s_5409_1: cast zx s_5409_0 -> bv
        let s_5409_1: Bits = Bits::new(s_5409_0 as u128, 3u16);
        // C s_5409_2: const #4u : u8
        let s_5409_2: u8 = 4;
        // C s_5409_3: cast zx s_5409_2 -> bv
        let s_5409_3: Bits = Bits::new(s_5409_2 as u128, 3u16);
        // D s_5409_4: cmp-eq s_5409_1 s_5409_3
        let s_5409_4: bool = ((s_5409_1) == (s_5409_3));
        // D s_5409_5: write-var gs#134734 <= s_5409_4
        fn_state.gs_134734 = s_5409_4;
        // N s_5409_6: jump b573
        return block_573(state, tracer, fn_state);
    }
    fn block_5410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5410_0: read-var coproc:u8
        let s_5410_0: u8 = fn_state.coproc;
        // D s_5410_1: cast zx s_5410_0 -> bv
        let s_5410_1: Bits = Bits::new(s_5410_0 as u128, 4u16);
        // C s_5410_2: const #15u : u8
        let s_5410_2: u8 = 15;
        // C s_5410_3: cast zx s_5410_2 -> bv
        let s_5410_3: Bits = Bits::new(s_5410_2 as u128, 4u16);
        // D s_5410_4: cmp-eq s_5410_1 s_5410_3
        let s_5410_4: bool = ((s_5410_1) == (s_5410_3));
        // D s_5410_5: write-var gs#134733 <= s_5410_4
        fn_state.gs_134733 = s_5410_4;
        // N s_5410_6: jump b571
        return block_571(state, tracer, fn_state);
    }
    fn block_5411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5411_0: read-var CRn:u8
        let s_5411_0: u8 = fn_state.CRn;
        // D s_5411_1: cast zx s_5411_0 -> bv
        let s_5411_1: Bits = Bits::new(s_5411_0 as u128, 4u16);
        // C s_5411_2: const #8u : u8
        let s_5411_2: u8 = 8;
        // C s_5411_3: cast zx s_5411_2 -> bv
        let s_5411_3: Bits = Bits::new(s_5411_2 as u128, 4u16);
        // D s_5411_4: cmp-eq s_5411_1 s_5411_3
        let s_5411_4: bool = ((s_5411_1) == (s_5411_3));
        // D s_5411_5: write-var gs#134732 <= s_5411_4
        fn_state.gs_134732 = s_5411_4;
        // N s_5411_6: jump b569
        return block_569(state, tracer, fn_state);
    }
    fn block_5412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5412_0: read-var el:u8
        let s_5412_0: u8 = fn_state.el;
        // D s_5412_1: read-var coproc:u8
        let s_5412_1: u8 = fn_state.coproc;
        // D s_5412_2: read-var opc1:u8
        let s_5412_2: u8 = fn_state.opc1;
        // D s_5412_3: read-var CRn:u8
        let s_5412_3: u8 = fn_state.CRn;
        // D s_5412_4: read-var opc2:u8
        let s_5412_4: u8 = fn_state.opc2;
        // D s_5412_5: read-var CRm:u8
        let s_5412_5: u8 = fn_state.CRm;
        // D s_5412_6: read-var t:i
        let s_5412_6: i128 = fn_state.t;
        // D s_5412_7: call TLBIMVAALIS_SysRegWrite32_213090c663fe2ea7(s_5412_0, s_5412_1, s_5412_2, s_5412_3, s_5412_4, s_5412_5, s_5412_6)
        let s_5412_7: () = TLBIMVAALIS_SysRegWrite32_213090c663fe2ea7(
            state,
            tracer,
            s_5412_0,
            s_5412_1,
            s_5412_2,
            s_5412_3,
            s_5412_4,
            s_5412_5,
            s_5412_6,
        );
        // N s_5412_8: return
        return;
    }
    fn block_5413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5413_0: read-var opc2:u8
        let s_5413_0: u8 = fn_state.opc2;
        // D s_5413_1: cast zx s_5413_0 -> bv
        let s_5413_1: Bits = Bits::new(s_5413_0 as u128, 3u16);
        // C s_5413_2: const #7u : u8
        let s_5413_2: u8 = 7;
        // C s_5413_3: cast zx s_5413_2 -> bv
        let s_5413_3: Bits = Bits::new(s_5413_2 as u128, 3u16);
        // D s_5413_4: cmp-eq s_5413_1 s_5413_3
        let s_5413_4: bool = ((s_5413_1) == (s_5413_3));
        // D s_5413_5: write-var gs#134731 <= s_5413_4
        fn_state.gs_134731 = s_5413_4;
        // N s_5413_6: jump b566
        return block_566(state, tracer, fn_state);
    }
    fn block_5414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5414_0: read-var opc1:u8
        let s_5414_0: u8 = fn_state.opc1;
        // D s_5414_1: cast zx s_5414_0 -> bv
        let s_5414_1: Bits = Bits::new(s_5414_0 as u128, 3u16);
        // C s_5414_2: const #0u : u8
        let s_5414_2: u8 = 0;
        // C s_5414_3: cast zx s_5414_2 -> bv
        let s_5414_3: Bits = Bits::new(s_5414_2 as u128, 3u16);
        // D s_5414_4: cmp-eq s_5414_1 s_5414_3
        let s_5414_4: bool = ((s_5414_1) == (s_5414_3));
        // D s_5414_5: write-var gs#134730 <= s_5414_4
        fn_state.gs_134730 = s_5414_4;
        // N s_5414_6: jump b564
        return block_564(state, tracer, fn_state);
    }
    fn block_5415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5415_0: read-var coproc:u8
        let s_5415_0: u8 = fn_state.coproc;
        // D s_5415_1: cast zx s_5415_0 -> bv
        let s_5415_1: Bits = Bits::new(s_5415_0 as u128, 4u16);
        // C s_5415_2: const #15u : u8
        let s_5415_2: u8 = 15;
        // C s_5415_3: cast zx s_5415_2 -> bv
        let s_5415_3: Bits = Bits::new(s_5415_2 as u128, 4u16);
        // D s_5415_4: cmp-eq s_5415_1 s_5415_3
        let s_5415_4: bool = ((s_5415_1) == (s_5415_3));
        // D s_5415_5: write-var gs#134729 <= s_5415_4
        fn_state.gs_134729 = s_5415_4;
        // N s_5415_6: jump b562
        return block_562(state, tracer, fn_state);
    }
    fn block_5416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5416_0: read-var CRn:u8
        let s_5416_0: u8 = fn_state.CRn;
        // D s_5416_1: cast zx s_5416_0 -> bv
        let s_5416_1: Bits = Bits::new(s_5416_0 as u128, 4u16);
        // C s_5416_2: const #8u : u8
        let s_5416_2: u8 = 8;
        // C s_5416_3: cast zx s_5416_2 -> bv
        let s_5416_3: Bits = Bits::new(s_5416_2 as u128, 4u16);
        // D s_5416_4: cmp-eq s_5416_1 s_5416_3
        let s_5416_4: bool = ((s_5416_1) == (s_5416_3));
        // D s_5416_5: write-var gs#134728 <= s_5416_4
        fn_state.gs_134728 = s_5416_4;
        // N s_5416_6: jump b560
        return block_560(state, tracer, fn_state);
    }
    fn block_5417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5417_0: read-var el:u8
        let s_5417_0: u8 = fn_state.el;
        // D s_5417_1: read-var coproc:u8
        let s_5417_1: u8 = fn_state.coproc;
        // D s_5417_2: read-var opc1:u8
        let s_5417_2: u8 = fn_state.opc1;
        // D s_5417_3: read-var CRn:u8
        let s_5417_3: u8 = fn_state.CRn;
        // D s_5417_4: read-var opc2:u8
        let s_5417_4: u8 = fn_state.opc2;
        // D s_5417_5: read-var CRm:u8
        let s_5417_5: u8 = fn_state.CRm;
        // D s_5417_6: read-var t:i
        let s_5417_6: i128 = fn_state.t;
        // D s_5417_7: call DTLBIMVA_SysRegWrite32_4d3bdab2ea1d893d(s_5417_0, s_5417_1, s_5417_2, s_5417_3, s_5417_4, s_5417_5, s_5417_6)
        let s_5417_7: () = DTLBIMVA_SysRegWrite32_4d3bdab2ea1d893d(
            state,
            tracer,
            s_5417_0,
            s_5417_1,
            s_5417_2,
            s_5417_3,
            s_5417_4,
            s_5417_5,
            s_5417_6,
        );
        // N s_5417_8: return
        return;
    }
    fn block_5418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5418_0: read-var opc2:u8
        let s_5418_0: u8 = fn_state.opc2;
        // D s_5418_1: cast zx s_5418_0 -> bv
        let s_5418_1: Bits = Bits::new(s_5418_0 as u128, 3u16);
        // C s_5418_2: const #1u : u8
        let s_5418_2: u8 = 1;
        // C s_5418_3: cast zx s_5418_2 -> bv
        let s_5418_3: Bits = Bits::new(s_5418_2 as u128, 3u16);
        // D s_5418_4: cmp-eq s_5418_1 s_5418_3
        let s_5418_4: bool = ((s_5418_1) == (s_5418_3));
        // D s_5418_5: write-var gs#134727 <= s_5418_4
        fn_state.gs_134727 = s_5418_4;
        // N s_5418_6: jump b557
        return block_557(state, tracer, fn_state);
    }
    fn block_5419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5419_0: read-var opc1:u8
        let s_5419_0: u8 = fn_state.opc1;
        // D s_5419_1: cast zx s_5419_0 -> bv
        let s_5419_1: Bits = Bits::new(s_5419_0 as u128, 3u16);
        // C s_5419_2: const #0u : u8
        let s_5419_2: u8 = 0;
        // C s_5419_3: cast zx s_5419_2 -> bv
        let s_5419_3: Bits = Bits::new(s_5419_2 as u128, 3u16);
        // D s_5419_4: cmp-eq s_5419_1 s_5419_3
        let s_5419_4: bool = ((s_5419_1) == (s_5419_3));
        // D s_5419_5: write-var gs#134726 <= s_5419_4
        fn_state.gs_134726 = s_5419_4;
        // N s_5419_6: jump b555
        return block_555(state, tracer, fn_state);
    }
    fn block_5420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5420_0: read-var coproc:u8
        let s_5420_0: u8 = fn_state.coproc;
        // D s_5420_1: cast zx s_5420_0 -> bv
        let s_5420_1: Bits = Bits::new(s_5420_0 as u128, 4u16);
        // C s_5420_2: const #15u : u8
        let s_5420_2: u8 = 15;
        // C s_5420_3: cast zx s_5420_2 -> bv
        let s_5420_3: Bits = Bits::new(s_5420_2 as u128, 4u16);
        // D s_5420_4: cmp-eq s_5420_1 s_5420_3
        let s_5420_4: bool = ((s_5420_1) == (s_5420_3));
        // D s_5420_5: write-var gs#134725 <= s_5420_4
        fn_state.gs_134725 = s_5420_4;
        // N s_5420_6: jump b553
        return block_553(state, tracer, fn_state);
    }
    fn block_5421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5421_0: read-var CRn:u8
        let s_5421_0: u8 = fn_state.CRn;
        // D s_5421_1: cast zx s_5421_0 -> bv
        let s_5421_1: Bits = Bits::new(s_5421_0 as u128, 4u16);
        // C s_5421_2: const #8u : u8
        let s_5421_2: u8 = 8;
        // C s_5421_3: cast zx s_5421_2 -> bv
        let s_5421_3: Bits = Bits::new(s_5421_2 as u128, 4u16);
        // D s_5421_4: cmp-eq s_5421_1 s_5421_3
        let s_5421_4: bool = ((s_5421_1) == (s_5421_3));
        // D s_5421_5: write-var gs#134724 <= s_5421_4
        fn_state.gs_134724 = s_5421_4;
        // N s_5421_6: jump b551
        return block_551(state, tracer, fn_state);
    }
    fn block_5422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5422_0: read-var el:u8
        let s_5422_0: u8 = fn_state.el;
        // D s_5422_1: read-var coproc:u8
        let s_5422_1: u8 = fn_state.coproc;
        // D s_5422_2: read-var opc1:u8
        let s_5422_2: u8 = fn_state.opc1;
        // D s_5422_3: read-var CRn:u8
        let s_5422_3: u8 = fn_state.CRn;
        // D s_5422_4: read-var opc2:u8
        let s_5422_4: u8 = fn_state.opc2;
        // D s_5422_5: read-var CRm:u8
        let s_5422_5: u8 = fn_state.CRm;
        // D s_5422_6: read-var t:i
        let s_5422_6: i128 = fn_state.t;
        // D s_5422_7: call HACTLR_SysRegWrite32_779af4815c28cfff(s_5422_0, s_5422_1, s_5422_2, s_5422_3, s_5422_4, s_5422_5, s_5422_6)
        let s_5422_7: () = HACTLR_SysRegWrite32_779af4815c28cfff(
            state,
            tracer,
            s_5422_0,
            s_5422_1,
            s_5422_2,
            s_5422_3,
            s_5422_4,
            s_5422_5,
            s_5422_6,
        );
        // N s_5422_8: return
        return;
    }
    fn block_5423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5423_0: read-var opc2:u8
        let s_5423_0: u8 = fn_state.opc2;
        // D s_5423_1: cast zx s_5423_0 -> bv
        let s_5423_1: Bits = Bits::new(s_5423_0 as u128, 3u16);
        // C s_5423_2: const #1u : u8
        let s_5423_2: u8 = 1;
        // C s_5423_3: cast zx s_5423_2 -> bv
        let s_5423_3: Bits = Bits::new(s_5423_2 as u128, 3u16);
        // D s_5423_4: cmp-eq s_5423_1 s_5423_3
        let s_5423_4: bool = ((s_5423_1) == (s_5423_3));
        // D s_5423_5: write-var gs#134723 <= s_5423_4
        fn_state.gs_134723 = s_5423_4;
        // N s_5423_6: jump b548
        return block_548(state, tracer, fn_state);
    }
    fn block_5424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5424_0: read-var opc1:u8
        let s_5424_0: u8 = fn_state.opc1;
        // D s_5424_1: cast zx s_5424_0 -> bv
        let s_5424_1: Bits = Bits::new(s_5424_0 as u128, 3u16);
        // C s_5424_2: const #4u : u8
        let s_5424_2: u8 = 4;
        // C s_5424_3: cast zx s_5424_2 -> bv
        let s_5424_3: Bits = Bits::new(s_5424_2 as u128, 3u16);
        // D s_5424_4: cmp-eq s_5424_1 s_5424_3
        let s_5424_4: bool = ((s_5424_1) == (s_5424_3));
        // D s_5424_5: write-var gs#134722 <= s_5424_4
        fn_state.gs_134722 = s_5424_4;
        // N s_5424_6: jump b546
        return block_546(state, tracer, fn_state);
    }
    fn block_5425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5425_0: read-var coproc:u8
        let s_5425_0: u8 = fn_state.coproc;
        // D s_5425_1: cast zx s_5425_0 -> bv
        let s_5425_1: Bits = Bits::new(s_5425_0 as u128, 4u16);
        // C s_5425_2: const #15u : u8
        let s_5425_2: u8 = 15;
        // C s_5425_3: cast zx s_5425_2 -> bv
        let s_5425_3: Bits = Bits::new(s_5425_2 as u128, 4u16);
        // D s_5425_4: cmp-eq s_5425_1 s_5425_3
        let s_5425_4: bool = ((s_5425_1) == (s_5425_3));
        // D s_5425_5: write-var gs#134721 <= s_5425_4
        fn_state.gs_134721 = s_5425_4;
        // N s_5425_6: jump b544
        return block_544(state, tracer, fn_state);
    }
    fn block_5426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5426_0: read-var CRn:u8
        let s_5426_0: u8 = fn_state.CRn;
        // D s_5426_1: cast zx s_5426_0 -> bv
        let s_5426_1: Bits = Bits::new(s_5426_0 as u128, 4u16);
        // C s_5426_2: const #1u : u8
        let s_5426_2: u8 = 1;
        // C s_5426_3: cast zx s_5426_2 -> bv
        let s_5426_3: Bits = Bits::new(s_5426_2 as u128, 4u16);
        // D s_5426_4: cmp-eq s_5426_1 s_5426_3
        let s_5426_4: bool = ((s_5426_1) == (s_5426_3));
        // D s_5426_5: write-var gs#134720 <= s_5426_4
        fn_state.gs_134720 = s_5426_4;
        // N s_5426_6: jump b542
        return block_542(state, tracer, fn_state);
    }
    fn block_5427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5427_0: read-var el:u8
        let s_5427_0: u8 = fn_state.el;
        // D s_5427_1: read-var coproc:u8
        let s_5427_1: u8 = fn_state.coproc;
        // D s_5427_2: read-var opc1:u8
        let s_5427_2: u8 = fn_state.opc1;
        // D s_5427_3: read-var CRn:u8
        let s_5427_3: u8 = fn_state.CRn;
        // D s_5427_4: read-var opc2:u8
        let s_5427_4: u8 = fn_state.opc2;
        // D s_5427_5: read-var CRm:u8
        let s_5427_5: u8 = fn_state.CRm;
        // D s_5427_6: read-var t:i
        let s_5427_6: i128 = fn_state.t;
        // D s_5427_7: call DBGBXVR_SysRegWrite32_3d0f51e1f9bc14d7(s_5427_0, s_5427_1, s_5427_2, s_5427_3, s_5427_4, s_5427_5, s_5427_6)
        let s_5427_7: () = DBGBXVR_SysRegWrite32_3d0f51e1f9bc14d7(
            state,
            tracer,
            s_5427_0,
            s_5427_1,
            s_5427_2,
            s_5427_3,
            s_5427_4,
            s_5427_5,
            s_5427_6,
        );
        // N s_5427_8: return
        return;
    }
    fn block_5428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5428_0: read-var opc2:u8
        let s_5428_0: u8 = fn_state.opc2;
        // D s_5428_1: cast zx s_5428_0 -> bv
        let s_5428_1: Bits = Bits::new(s_5428_0 as u128, 3u16);
        // C s_5428_2: const #1u : u8
        let s_5428_2: u8 = 1;
        // C s_5428_3: cast zx s_5428_2 -> bv
        let s_5428_3: Bits = Bits::new(s_5428_2 as u128, 3u16);
        // D s_5428_4: cmp-eq s_5428_1 s_5428_3
        let s_5428_4: bool = ((s_5428_1) == (s_5428_3));
        // D s_5428_5: write-var gs#134719 <= s_5428_4
        fn_state.gs_134719 = s_5428_4;
        // N s_5428_6: jump b539
        return block_539(state, tracer, fn_state);
    }
    fn block_5429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5429_0: read-var opc1:u8
        let s_5429_0: u8 = fn_state.opc1;
        // D s_5429_1: cast zx s_5429_0 -> bv
        let s_5429_1: Bits = Bits::new(s_5429_0 as u128, 3u16);
        // C s_5429_2: const #0u : u8
        let s_5429_2: u8 = 0;
        // C s_5429_3: cast zx s_5429_2 -> bv
        let s_5429_3: Bits = Bits::new(s_5429_2 as u128, 3u16);
        // D s_5429_4: cmp-eq s_5429_1 s_5429_3
        let s_5429_4: bool = ((s_5429_1) == (s_5429_3));
        // D s_5429_5: write-var gs#134718 <= s_5429_4
        fn_state.gs_134718 = s_5429_4;
        // N s_5429_6: jump b537
        return block_537(state, tracer, fn_state);
    }
    fn block_5430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5430_0: read-var coproc:u8
        let s_5430_0: u8 = fn_state.coproc;
        // D s_5430_1: cast zx s_5430_0 -> bv
        let s_5430_1: Bits = Bits::new(s_5430_0 as u128, 4u16);
        // C s_5430_2: const #14u : u8
        let s_5430_2: u8 = 14;
        // C s_5430_3: cast zx s_5430_2 -> bv
        let s_5430_3: Bits = Bits::new(s_5430_2 as u128, 4u16);
        // D s_5430_4: cmp-eq s_5430_1 s_5430_3
        let s_5430_4: bool = ((s_5430_1) == (s_5430_3));
        // D s_5430_5: write-var gs#134717 <= s_5430_4
        fn_state.gs_134717 = s_5430_4;
        // N s_5430_6: jump b535
        return block_535(state, tracer, fn_state);
    }
    fn block_5431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5431_0: read-var CRn:u8
        let s_5431_0: u8 = fn_state.CRn;
        // D s_5431_1: cast zx s_5431_0 -> bv
        let s_5431_1: Bits = Bits::new(s_5431_0 as u128, 4u16);
        // C s_5431_2: const #1u : u8
        let s_5431_2: u8 = 1;
        // C s_5431_3: cast zx s_5431_2 -> bv
        let s_5431_3: Bits = Bits::new(s_5431_2 as u128, 4u16);
        // D s_5431_4: cmp-eq s_5431_1 s_5431_3
        let s_5431_4: bool = ((s_5431_1) == (s_5431_3));
        // D s_5431_5: write-var gs#134716 <= s_5431_4
        fn_state.gs_134716 = s_5431_4;
        // N s_5431_6: jump b533
        return block_533(state, tracer, fn_state);
    }
    fn block_5432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5432_0: read-var el:u8
        let s_5432_0: u8 = fn_state.el;
        // D s_5432_1: read-var coproc:u8
        let s_5432_1: u8 = fn_state.coproc;
        // D s_5432_2: read-var opc1:u8
        let s_5432_2: u8 = fn_state.opc1;
        // D s_5432_3: read-var CRn:u8
        let s_5432_3: u8 = fn_state.CRn;
        // D s_5432_4: read-var opc2:u8
        let s_5432_4: u8 = fn_state.opc2;
        // D s_5432_5: read-var CRm:u8
        let s_5432_5: u8 = fn_state.CRm;
        // D s_5432_6: read-var t:i
        let s_5432_6: i128 = fn_state.t;
        // D s_5432_7: call DBGBXVR_SysRegWrite32_b16f0d14e4620269(s_5432_0, s_5432_1, s_5432_2, s_5432_3, s_5432_4, s_5432_5, s_5432_6)
        let s_5432_7: () = DBGBXVR_SysRegWrite32_b16f0d14e4620269(
            state,
            tracer,
            s_5432_0,
            s_5432_1,
            s_5432_2,
            s_5432_3,
            s_5432_4,
            s_5432_5,
            s_5432_6,
        );
        // N s_5432_8: return
        return;
    }
    fn block_5433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5433_0: read-var opc2:u8
        let s_5433_0: u8 = fn_state.opc2;
        // D s_5433_1: cast zx s_5433_0 -> bv
        let s_5433_1: Bits = Bits::new(s_5433_0 as u128, 3u16);
        // C s_5433_2: const #1u : u8
        let s_5433_2: u8 = 1;
        // C s_5433_3: cast zx s_5433_2 -> bv
        let s_5433_3: Bits = Bits::new(s_5433_2 as u128, 3u16);
        // D s_5433_4: cmp-eq s_5433_1 s_5433_3
        let s_5433_4: bool = ((s_5433_1) == (s_5433_3));
        // D s_5433_5: write-var gs#134715 <= s_5433_4
        fn_state.gs_134715 = s_5433_4;
        // N s_5433_6: jump b530
        return block_530(state, tracer, fn_state);
    }
    fn block_5434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5434_0: read-var opc1:u8
        let s_5434_0: u8 = fn_state.opc1;
        // D s_5434_1: cast zx s_5434_0 -> bv
        let s_5434_1: Bits = Bits::new(s_5434_0 as u128, 3u16);
        // C s_5434_2: const #0u : u8
        let s_5434_2: u8 = 0;
        // C s_5434_3: cast zx s_5434_2 -> bv
        let s_5434_3: Bits = Bits::new(s_5434_2 as u128, 3u16);
        // D s_5434_4: cmp-eq s_5434_1 s_5434_3
        let s_5434_4: bool = ((s_5434_1) == (s_5434_3));
        // D s_5434_5: write-var gs#134714 <= s_5434_4
        fn_state.gs_134714 = s_5434_4;
        // N s_5434_6: jump b528
        return block_528(state, tracer, fn_state);
    }
    fn block_5435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5435_0: read-var coproc:u8
        let s_5435_0: u8 = fn_state.coproc;
        // D s_5435_1: cast zx s_5435_0 -> bv
        let s_5435_1: Bits = Bits::new(s_5435_0 as u128, 4u16);
        // C s_5435_2: const #14u : u8
        let s_5435_2: u8 = 14;
        // C s_5435_3: cast zx s_5435_2 -> bv
        let s_5435_3: Bits = Bits::new(s_5435_2 as u128, 4u16);
        // D s_5435_4: cmp-eq s_5435_1 s_5435_3
        let s_5435_4: bool = ((s_5435_1) == (s_5435_3));
        // D s_5435_5: write-var gs#134713 <= s_5435_4
        fn_state.gs_134713 = s_5435_4;
        // N s_5435_6: jump b526
        return block_526(state, tracer, fn_state);
    }
    fn block_5436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5436_0: read-var CRn:u8
        let s_5436_0: u8 = fn_state.CRn;
        // D s_5436_1: cast zx s_5436_0 -> bv
        let s_5436_1: Bits = Bits::new(s_5436_0 as u128, 4u16);
        // C s_5436_2: const #1u : u8
        let s_5436_2: u8 = 1;
        // C s_5436_3: cast zx s_5436_2 -> bv
        let s_5436_3: Bits = Bits::new(s_5436_2 as u128, 4u16);
        // D s_5436_4: cmp-eq s_5436_1 s_5436_3
        let s_5436_4: bool = ((s_5436_1) == (s_5436_3));
        // D s_5436_5: write-var gs#134712 <= s_5436_4
        fn_state.gs_134712 = s_5436_4;
        // N s_5436_6: jump b524
        return block_524(state, tracer, fn_state);
    }
    fn block_5437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5437_0: read-var el:u8
        let s_5437_0: u8 = fn_state.el;
        // D s_5437_1: read-var coproc:u8
        let s_5437_1: u8 = fn_state.coproc;
        // D s_5437_2: read-var opc1:u8
        let s_5437_2: u8 = fn_state.opc1;
        // D s_5437_3: read-var CRn:u8
        let s_5437_3: u8 = fn_state.CRn;
        // D s_5437_4: read-var opc2:u8
        let s_5437_4: u8 = fn_state.opc2;
        // D s_5437_5: read-var CRm:u8
        let s_5437_5: u8 = fn_state.CRm;
        // D s_5437_6: read-var t:i
        let s_5437_6: i128 = fn_state.t;
        // D s_5437_7: call DBGBXVR_SysRegWrite32_0917f327cafd0459(s_5437_0, s_5437_1, s_5437_2, s_5437_3, s_5437_4, s_5437_5, s_5437_6)
        let s_5437_7: () = DBGBXVR_SysRegWrite32_0917f327cafd0459(
            state,
            tracer,
            s_5437_0,
            s_5437_1,
            s_5437_2,
            s_5437_3,
            s_5437_4,
            s_5437_5,
            s_5437_6,
        );
        // N s_5437_8: return
        return;
    }
    fn block_5438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5438_0: read-var opc2:u8
        let s_5438_0: u8 = fn_state.opc2;
        // D s_5438_1: cast zx s_5438_0 -> bv
        let s_5438_1: Bits = Bits::new(s_5438_0 as u128, 3u16);
        // C s_5438_2: const #1u : u8
        let s_5438_2: u8 = 1;
        // C s_5438_3: cast zx s_5438_2 -> bv
        let s_5438_3: Bits = Bits::new(s_5438_2 as u128, 3u16);
        // D s_5438_4: cmp-eq s_5438_1 s_5438_3
        let s_5438_4: bool = ((s_5438_1) == (s_5438_3));
        // D s_5438_5: write-var gs#134711 <= s_5438_4
        fn_state.gs_134711 = s_5438_4;
        // N s_5438_6: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_5439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5439_0: read-var opc1:u8
        let s_5439_0: u8 = fn_state.opc1;
        // D s_5439_1: cast zx s_5439_0 -> bv
        let s_5439_1: Bits = Bits::new(s_5439_0 as u128, 3u16);
        // C s_5439_2: const #0u : u8
        let s_5439_2: u8 = 0;
        // C s_5439_3: cast zx s_5439_2 -> bv
        let s_5439_3: Bits = Bits::new(s_5439_2 as u128, 3u16);
        // D s_5439_4: cmp-eq s_5439_1 s_5439_3
        let s_5439_4: bool = ((s_5439_1) == (s_5439_3));
        // D s_5439_5: write-var gs#134710 <= s_5439_4
        fn_state.gs_134710 = s_5439_4;
        // N s_5439_6: jump b519
        return block_519(state, tracer, fn_state);
    }
    fn block_5440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5440_0: read-var coproc:u8
        let s_5440_0: u8 = fn_state.coproc;
        // D s_5440_1: cast zx s_5440_0 -> bv
        let s_5440_1: Bits = Bits::new(s_5440_0 as u128, 4u16);
        // C s_5440_2: const #14u : u8
        let s_5440_2: u8 = 14;
        // C s_5440_3: cast zx s_5440_2 -> bv
        let s_5440_3: Bits = Bits::new(s_5440_2 as u128, 4u16);
        // D s_5440_4: cmp-eq s_5440_1 s_5440_3
        let s_5440_4: bool = ((s_5440_1) == (s_5440_3));
        // D s_5440_5: write-var gs#134709 <= s_5440_4
        fn_state.gs_134709 = s_5440_4;
        // N s_5440_6: jump b517
        return block_517(state, tracer, fn_state);
    }
    fn block_5441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5441_0: read-var CRn:u8
        let s_5441_0: u8 = fn_state.CRn;
        // D s_5441_1: cast zx s_5441_0 -> bv
        let s_5441_1: Bits = Bits::new(s_5441_0 as u128, 4u16);
        // C s_5441_2: const #1u : u8
        let s_5441_2: u8 = 1;
        // C s_5441_3: cast zx s_5441_2 -> bv
        let s_5441_3: Bits = Bits::new(s_5441_2 as u128, 4u16);
        // D s_5441_4: cmp-eq s_5441_1 s_5441_3
        let s_5441_4: bool = ((s_5441_1) == (s_5441_3));
        // D s_5441_5: write-var gs#134708 <= s_5441_4
        fn_state.gs_134708 = s_5441_4;
        // N s_5441_6: jump b515
        return block_515(state, tracer, fn_state);
    }
    fn block_5442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5442_0: read-var el:u8
        let s_5442_0: u8 = fn_state.el;
        // D s_5442_1: read-var coproc:u8
        let s_5442_1: u8 = fn_state.coproc;
        // D s_5442_2: read-var opc1:u8
        let s_5442_2: u8 = fn_state.opc1;
        // D s_5442_3: read-var CRn:u8
        let s_5442_3: u8 = fn_state.CRn;
        // D s_5442_4: read-var opc2:u8
        let s_5442_4: u8 = fn_state.opc2;
        // D s_5442_5: read-var CRm:u8
        let s_5442_5: u8 = fn_state.CRm;
        // D s_5442_6: read-var t:i
        let s_5442_6: i128 = fn_state.t;
        // D s_5442_7: call DBGBXVR_SysRegWrite32_3dce4e0d5dbdee9b(s_5442_0, s_5442_1, s_5442_2, s_5442_3, s_5442_4, s_5442_5, s_5442_6)
        let s_5442_7: () = DBGBXVR_SysRegWrite32_3dce4e0d5dbdee9b(
            state,
            tracer,
            s_5442_0,
            s_5442_1,
            s_5442_2,
            s_5442_3,
            s_5442_4,
            s_5442_5,
            s_5442_6,
        );
        // N s_5442_8: return
        return;
    }
    fn block_5443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5443_0: read-var opc2:u8
        let s_5443_0: u8 = fn_state.opc2;
        // D s_5443_1: cast zx s_5443_0 -> bv
        let s_5443_1: Bits = Bits::new(s_5443_0 as u128, 3u16);
        // C s_5443_2: const #1u : u8
        let s_5443_2: u8 = 1;
        // C s_5443_3: cast zx s_5443_2 -> bv
        let s_5443_3: Bits = Bits::new(s_5443_2 as u128, 3u16);
        // D s_5443_4: cmp-eq s_5443_1 s_5443_3
        let s_5443_4: bool = ((s_5443_1) == (s_5443_3));
        // D s_5443_5: write-var gs#134707 <= s_5443_4
        fn_state.gs_134707 = s_5443_4;
        // N s_5443_6: jump b512
        return block_512(state, tracer, fn_state);
    }
    fn block_5444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5444_0: read-var opc1:u8
        let s_5444_0: u8 = fn_state.opc1;
        // D s_5444_1: cast zx s_5444_0 -> bv
        let s_5444_1: Bits = Bits::new(s_5444_0 as u128, 3u16);
        // C s_5444_2: const #0u : u8
        let s_5444_2: u8 = 0;
        // C s_5444_3: cast zx s_5444_2 -> bv
        let s_5444_3: Bits = Bits::new(s_5444_2 as u128, 3u16);
        // D s_5444_4: cmp-eq s_5444_1 s_5444_3
        let s_5444_4: bool = ((s_5444_1) == (s_5444_3));
        // D s_5444_5: write-var gs#134706 <= s_5444_4
        fn_state.gs_134706 = s_5444_4;
        // N s_5444_6: jump b510
        return block_510(state, tracer, fn_state);
    }
    fn block_5445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5445_0: read-var coproc:u8
        let s_5445_0: u8 = fn_state.coproc;
        // D s_5445_1: cast zx s_5445_0 -> bv
        let s_5445_1: Bits = Bits::new(s_5445_0 as u128, 4u16);
        // C s_5445_2: const #14u : u8
        let s_5445_2: u8 = 14;
        // C s_5445_3: cast zx s_5445_2 -> bv
        let s_5445_3: Bits = Bits::new(s_5445_2 as u128, 4u16);
        // D s_5445_4: cmp-eq s_5445_1 s_5445_3
        let s_5445_4: bool = ((s_5445_1) == (s_5445_3));
        // D s_5445_5: write-var gs#134705 <= s_5445_4
        fn_state.gs_134705 = s_5445_4;
        // N s_5445_6: jump b508
        return block_508(state, tracer, fn_state);
    }
    fn block_5446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5446_0: read-var CRn:u8
        let s_5446_0: u8 = fn_state.CRn;
        // D s_5446_1: cast zx s_5446_0 -> bv
        let s_5446_1: Bits = Bits::new(s_5446_0 as u128, 4u16);
        // C s_5446_2: const #1u : u8
        let s_5446_2: u8 = 1;
        // C s_5446_3: cast zx s_5446_2 -> bv
        let s_5446_3: Bits = Bits::new(s_5446_2 as u128, 4u16);
        // D s_5446_4: cmp-eq s_5446_1 s_5446_3
        let s_5446_4: bool = ((s_5446_1) == (s_5446_3));
        // D s_5446_5: write-var gs#134704 <= s_5446_4
        fn_state.gs_134704 = s_5446_4;
        // N s_5446_6: jump b506
        return block_506(state, tracer, fn_state);
    }
    fn block_5447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5447_0: read-var el:u8
        let s_5447_0: u8 = fn_state.el;
        // D s_5447_1: read-var coproc:u8
        let s_5447_1: u8 = fn_state.coproc;
        // D s_5447_2: read-var opc1:u8
        let s_5447_2: u8 = fn_state.opc1;
        // D s_5447_3: read-var CRn:u8
        let s_5447_3: u8 = fn_state.CRn;
        // D s_5447_4: read-var opc2:u8
        let s_5447_4: u8 = fn_state.opc2;
        // D s_5447_5: read-var CRm:u8
        let s_5447_5: u8 = fn_state.CRm;
        // D s_5447_6: read-var t:i
        let s_5447_6: i128 = fn_state.t;
        // D s_5447_7: call DBGBXVR_SysRegWrite32_ad72222be7819b11(s_5447_0, s_5447_1, s_5447_2, s_5447_3, s_5447_4, s_5447_5, s_5447_6)
        let s_5447_7: () = DBGBXVR_SysRegWrite32_ad72222be7819b11(
            state,
            tracer,
            s_5447_0,
            s_5447_1,
            s_5447_2,
            s_5447_3,
            s_5447_4,
            s_5447_5,
            s_5447_6,
        );
        // N s_5447_8: return
        return;
    }
    fn block_5448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5448_0: read-var opc2:u8
        let s_5448_0: u8 = fn_state.opc2;
        // D s_5448_1: cast zx s_5448_0 -> bv
        let s_5448_1: Bits = Bits::new(s_5448_0 as u128, 3u16);
        // C s_5448_2: const #1u : u8
        let s_5448_2: u8 = 1;
        // C s_5448_3: cast zx s_5448_2 -> bv
        let s_5448_3: Bits = Bits::new(s_5448_2 as u128, 3u16);
        // D s_5448_4: cmp-eq s_5448_1 s_5448_3
        let s_5448_4: bool = ((s_5448_1) == (s_5448_3));
        // D s_5448_5: write-var gs#134703 <= s_5448_4
        fn_state.gs_134703 = s_5448_4;
        // N s_5448_6: jump b503
        return block_503(state, tracer, fn_state);
    }
    fn block_5449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5449_0: read-var opc1:u8
        let s_5449_0: u8 = fn_state.opc1;
        // D s_5449_1: cast zx s_5449_0 -> bv
        let s_5449_1: Bits = Bits::new(s_5449_0 as u128, 3u16);
        // C s_5449_2: const #0u : u8
        let s_5449_2: u8 = 0;
        // C s_5449_3: cast zx s_5449_2 -> bv
        let s_5449_3: Bits = Bits::new(s_5449_2 as u128, 3u16);
        // D s_5449_4: cmp-eq s_5449_1 s_5449_3
        let s_5449_4: bool = ((s_5449_1) == (s_5449_3));
        // D s_5449_5: write-var gs#134702 <= s_5449_4
        fn_state.gs_134702 = s_5449_4;
        // N s_5449_6: jump b501
        return block_501(state, tracer, fn_state);
    }
    fn block_5450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5450_0: read-var coproc:u8
        let s_5450_0: u8 = fn_state.coproc;
        // D s_5450_1: cast zx s_5450_0 -> bv
        let s_5450_1: Bits = Bits::new(s_5450_0 as u128, 4u16);
        // C s_5450_2: const #14u : u8
        let s_5450_2: u8 = 14;
        // C s_5450_3: cast zx s_5450_2 -> bv
        let s_5450_3: Bits = Bits::new(s_5450_2 as u128, 4u16);
        // D s_5450_4: cmp-eq s_5450_1 s_5450_3
        let s_5450_4: bool = ((s_5450_1) == (s_5450_3));
        // D s_5450_5: write-var gs#134701 <= s_5450_4
        fn_state.gs_134701 = s_5450_4;
        // N s_5450_6: jump b499
        return block_499(state, tracer, fn_state);
    }
    fn block_5451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5451_0: read-var CRn:u8
        let s_5451_0: u8 = fn_state.CRn;
        // D s_5451_1: cast zx s_5451_0 -> bv
        let s_5451_1: Bits = Bits::new(s_5451_0 as u128, 4u16);
        // C s_5451_2: const #1u : u8
        let s_5451_2: u8 = 1;
        // C s_5451_3: cast zx s_5451_2 -> bv
        let s_5451_3: Bits = Bits::new(s_5451_2 as u128, 4u16);
        // D s_5451_4: cmp-eq s_5451_1 s_5451_3
        let s_5451_4: bool = ((s_5451_1) == (s_5451_3));
        // D s_5451_5: write-var gs#134700 <= s_5451_4
        fn_state.gs_134700 = s_5451_4;
        // N s_5451_6: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_5452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5452_0: read-var el:u8
        let s_5452_0: u8 = fn_state.el;
        // D s_5452_1: read-var coproc:u8
        let s_5452_1: u8 = fn_state.coproc;
        // D s_5452_2: read-var opc1:u8
        let s_5452_2: u8 = fn_state.opc1;
        // D s_5452_3: read-var CRn:u8
        let s_5452_3: u8 = fn_state.CRn;
        // D s_5452_4: read-var opc2:u8
        let s_5452_4: u8 = fn_state.opc2;
        // D s_5452_5: read-var CRm:u8
        let s_5452_5: u8 = fn_state.CRm;
        // D s_5452_6: read-var t:i
        let s_5452_6: i128 = fn_state.t;
        // D s_5452_7: call DBGBXVR_SysRegWrite32_f06f2fb407b44033(s_5452_0, s_5452_1, s_5452_2, s_5452_3, s_5452_4, s_5452_5, s_5452_6)
        let s_5452_7: () = DBGBXVR_SysRegWrite32_f06f2fb407b44033(
            state,
            tracer,
            s_5452_0,
            s_5452_1,
            s_5452_2,
            s_5452_3,
            s_5452_4,
            s_5452_5,
            s_5452_6,
        );
        // N s_5452_8: return
        return;
    }
    fn block_5453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5453_0: read-var opc2:u8
        let s_5453_0: u8 = fn_state.opc2;
        // D s_5453_1: cast zx s_5453_0 -> bv
        let s_5453_1: Bits = Bits::new(s_5453_0 as u128, 3u16);
        // C s_5453_2: const #1u : u8
        let s_5453_2: u8 = 1;
        // C s_5453_3: cast zx s_5453_2 -> bv
        let s_5453_3: Bits = Bits::new(s_5453_2 as u128, 3u16);
        // D s_5453_4: cmp-eq s_5453_1 s_5453_3
        let s_5453_4: bool = ((s_5453_1) == (s_5453_3));
        // D s_5453_5: write-var gs#134699 <= s_5453_4
        fn_state.gs_134699 = s_5453_4;
        // N s_5453_6: jump b494
        return block_494(state, tracer, fn_state);
    }
    fn block_5454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5454_0: read-var opc1:u8
        let s_5454_0: u8 = fn_state.opc1;
        // D s_5454_1: cast zx s_5454_0 -> bv
        let s_5454_1: Bits = Bits::new(s_5454_0 as u128, 3u16);
        // C s_5454_2: const #0u : u8
        let s_5454_2: u8 = 0;
        // C s_5454_3: cast zx s_5454_2 -> bv
        let s_5454_3: Bits = Bits::new(s_5454_2 as u128, 3u16);
        // D s_5454_4: cmp-eq s_5454_1 s_5454_3
        let s_5454_4: bool = ((s_5454_1) == (s_5454_3));
        // D s_5454_5: write-var gs#134698 <= s_5454_4
        fn_state.gs_134698 = s_5454_4;
        // N s_5454_6: jump b492
        return block_492(state, tracer, fn_state);
    }
    fn block_5455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5455_0: read-var coproc:u8
        let s_5455_0: u8 = fn_state.coproc;
        // D s_5455_1: cast zx s_5455_0 -> bv
        let s_5455_1: Bits = Bits::new(s_5455_0 as u128, 4u16);
        // C s_5455_2: const #14u : u8
        let s_5455_2: u8 = 14;
        // C s_5455_3: cast zx s_5455_2 -> bv
        let s_5455_3: Bits = Bits::new(s_5455_2 as u128, 4u16);
        // D s_5455_4: cmp-eq s_5455_1 s_5455_3
        let s_5455_4: bool = ((s_5455_1) == (s_5455_3));
        // D s_5455_5: write-var gs#134697 <= s_5455_4
        fn_state.gs_134697 = s_5455_4;
        // N s_5455_6: jump b490
        return block_490(state, tracer, fn_state);
    }
    fn block_5456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5456_0: read-var CRn:u8
        let s_5456_0: u8 = fn_state.CRn;
        // D s_5456_1: cast zx s_5456_0 -> bv
        let s_5456_1: Bits = Bits::new(s_5456_0 as u128, 4u16);
        // C s_5456_2: const #1u : u8
        let s_5456_2: u8 = 1;
        // C s_5456_3: cast zx s_5456_2 -> bv
        let s_5456_3: Bits = Bits::new(s_5456_2 as u128, 4u16);
        // D s_5456_4: cmp-eq s_5456_1 s_5456_3
        let s_5456_4: bool = ((s_5456_1) == (s_5456_3));
        // D s_5456_5: write-var gs#134696 <= s_5456_4
        fn_state.gs_134696 = s_5456_4;
        // N s_5456_6: jump b488
        return block_488(state, tracer, fn_state);
    }
    fn block_5457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5457_0: read-var el:u8
        let s_5457_0: u8 = fn_state.el;
        // D s_5457_1: read-var coproc:u8
        let s_5457_1: u8 = fn_state.coproc;
        // D s_5457_2: read-var opc1:u8
        let s_5457_2: u8 = fn_state.opc1;
        // D s_5457_3: read-var CRn:u8
        let s_5457_3: u8 = fn_state.CRn;
        // D s_5457_4: read-var opc2:u8
        let s_5457_4: u8 = fn_state.opc2;
        // D s_5457_5: read-var CRm:u8
        let s_5457_5: u8 = fn_state.CRm;
        // D s_5457_6: read-var t:i
        let s_5457_6: i128 = fn_state.t;
        // D s_5457_7: call DBGBXVR_SysRegWrite32_c8eb4615918df164(s_5457_0, s_5457_1, s_5457_2, s_5457_3, s_5457_4, s_5457_5, s_5457_6)
        let s_5457_7: () = DBGBXVR_SysRegWrite32_c8eb4615918df164(
            state,
            tracer,
            s_5457_0,
            s_5457_1,
            s_5457_2,
            s_5457_3,
            s_5457_4,
            s_5457_5,
            s_5457_6,
        );
        // N s_5457_8: return
        return;
    }
    fn block_5458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5458_0: read-var opc2:u8
        let s_5458_0: u8 = fn_state.opc2;
        // D s_5458_1: cast zx s_5458_0 -> bv
        let s_5458_1: Bits = Bits::new(s_5458_0 as u128, 3u16);
        // C s_5458_2: const #1u : u8
        let s_5458_2: u8 = 1;
        // C s_5458_3: cast zx s_5458_2 -> bv
        let s_5458_3: Bits = Bits::new(s_5458_2 as u128, 3u16);
        // D s_5458_4: cmp-eq s_5458_1 s_5458_3
        let s_5458_4: bool = ((s_5458_1) == (s_5458_3));
        // D s_5458_5: write-var gs#134695 <= s_5458_4
        fn_state.gs_134695 = s_5458_4;
        // N s_5458_6: jump b485
        return block_485(state, tracer, fn_state);
    }
    fn block_5459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5459_0: read-var opc1:u8
        let s_5459_0: u8 = fn_state.opc1;
        // D s_5459_1: cast zx s_5459_0 -> bv
        let s_5459_1: Bits = Bits::new(s_5459_0 as u128, 3u16);
        // C s_5459_2: const #0u : u8
        let s_5459_2: u8 = 0;
        // C s_5459_3: cast zx s_5459_2 -> bv
        let s_5459_3: Bits = Bits::new(s_5459_2 as u128, 3u16);
        // D s_5459_4: cmp-eq s_5459_1 s_5459_3
        let s_5459_4: bool = ((s_5459_1) == (s_5459_3));
        // D s_5459_5: write-var gs#134694 <= s_5459_4
        fn_state.gs_134694 = s_5459_4;
        // N s_5459_6: jump b483
        return block_483(state, tracer, fn_state);
    }
    fn block_5460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5460_0: read-var coproc:u8
        let s_5460_0: u8 = fn_state.coproc;
        // D s_5460_1: cast zx s_5460_0 -> bv
        let s_5460_1: Bits = Bits::new(s_5460_0 as u128, 4u16);
        // C s_5460_2: const #14u : u8
        let s_5460_2: u8 = 14;
        // C s_5460_3: cast zx s_5460_2 -> bv
        let s_5460_3: Bits = Bits::new(s_5460_2 as u128, 4u16);
        // D s_5460_4: cmp-eq s_5460_1 s_5460_3
        let s_5460_4: bool = ((s_5460_1) == (s_5460_3));
        // D s_5460_5: write-var gs#134693 <= s_5460_4
        fn_state.gs_134693 = s_5460_4;
        // N s_5460_6: jump b481
        return block_481(state, tracer, fn_state);
    }
    fn block_5461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5461_0: read-var CRn:u8
        let s_5461_0: u8 = fn_state.CRn;
        // D s_5461_1: cast zx s_5461_0 -> bv
        let s_5461_1: Bits = Bits::new(s_5461_0 as u128, 4u16);
        // C s_5461_2: const #1u : u8
        let s_5461_2: u8 = 1;
        // C s_5461_3: cast zx s_5461_2 -> bv
        let s_5461_3: Bits = Bits::new(s_5461_2 as u128, 4u16);
        // D s_5461_4: cmp-eq s_5461_1 s_5461_3
        let s_5461_4: bool = ((s_5461_1) == (s_5461_3));
        // D s_5461_5: write-var gs#134692 <= s_5461_4
        fn_state.gs_134692 = s_5461_4;
        // N s_5461_6: jump b479
        return block_479(state, tracer, fn_state);
    }
    fn block_5462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5462_0: read-var el:u8
        let s_5462_0: u8 = fn_state.el;
        // D s_5462_1: read-var coproc:u8
        let s_5462_1: u8 = fn_state.coproc;
        // D s_5462_2: read-var opc1:u8
        let s_5462_2: u8 = fn_state.opc1;
        // D s_5462_3: read-var CRn:u8
        let s_5462_3: u8 = fn_state.CRn;
        // D s_5462_4: read-var opc2:u8
        let s_5462_4: u8 = fn_state.opc2;
        // D s_5462_5: read-var CRm:u8
        let s_5462_5: u8 = fn_state.CRm;
        // D s_5462_6: read-var t:i
        let s_5462_6: i128 = fn_state.t;
        // D s_5462_7: call DBGBXVR_SysRegWrite32_ec48b20803401d6a(s_5462_0, s_5462_1, s_5462_2, s_5462_3, s_5462_4, s_5462_5, s_5462_6)
        let s_5462_7: () = DBGBXVR_SysRegWrite32_ec48b20803401d6a(
            state,
            tracer,
            s_5462_0,
            s_5462_1,
            s_5462_2,
            s_5462_3,
            s_5462_4,
            s_5462_5,
            s_5462_6,
        );
        // N s_5462_8: return
        return;
    }
    fn block_5463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5463_0: read-var opc2:u8
        let s_5463_0: u8 = fn_state.opc2;
        // D s_5463_1: cast zx s_5463_0 -> bv
        let s_5463_1: Bits = Bits::new(s_5463_0 as u128, 3u16);
        // C s_5463_2: const #1u : u8
        let s_5463_2: u8 = 1;
        // C s_5463_3: cast zx s_5463_2 -> bv
        let s_5463_3: Bits = Bits::new(s_5463_2 as u128, 3u16);
        // D s_5463_4: cmp-eq s_5463_1 s_5463_3
        let s_5463_4: bool = ((s_5463_1) == (s_5463_3));
        // D s_5463_5: write-var gs#134691 <= s_5463_4
        fn_state.gs_134691 = s_5463_4;
        // N s_5463_6: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_5464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5464_0: read-var opc1:u8
        let s_5464_0: u8 = fn_state.opc1;
        // D s_5464_1: cast zx s_5464_0 -> bv
        let s_5464_1: Bits = Bits::new(s_5464_0 as u128, 3u16);
        // C s_5464_2: const #0u : u8
        let s_5464_2: u8 = 0;
        // C s_5464_3: cast zx s_5464_2 -> bv
        let s_5464_3: Bits = Bits::new(s_5464_2 as u128, 3u16);
        // D s_5464_4: cmp-eq s_5464_1 s_5464_3
        let s_5464_4: bool = ((s_5464_1) == (s_5464_3));
        // D s_5464_5: write-var gs#134690 <= s_5464_4
        fn_state.gs_134690 = s_5464_4;
        // N s_5464_6: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_5465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5465_0: read-var coproc:u8
        let s_5465_0: u8 = fn_state.coproc;
        // D s_5465_1: cast zx s_5465_0 -> bv
        let s_5465_1: Bits = Bits::new(s_5465_0 as u128, 4u16);
        // C s_5465_2: const #14u : u8
        let s_5465_2: u8 = 14;
        // C s_5465_3: cast zx s_5465_2 -> bv
        let s_5465_3: Bits = Bits::new(s_5465_2 as u128, 4u16);
        // D s_5465_4: cmp-eq s_5465_1 s_5465_3
        let s_5465_4: bool = ((s_5465_1) == (s_5465_3));
        // D s_5465_5: write-var gs#134689 <= s_5465_4
        fn_state.gs_134689 = s_5465_4;
        // N s_5465_6: jump b472
        return block_472(state, tracer, fn_state);
    }
    fn block_5466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5466_0: read-var CRn:u8
        let s_5466_0: u8 = fn_state.CRn;
        // D s_5466_1: cast zx s_5466_0 -> bv
        let s_5466_1: Bits = Bits::new(s_5466_0 as u128, 4u16);
        // C s_5466_2: const #1u : u8
        let s_5466_2: u8 = 1;
        // C s_5466_3: cast zx s_5466_2 -> bv
        let s_5466_3: Bits = Bits::new(s_5466_2 as u128, 4u16);
        // D s_5466_4: cmp-eq s_5466_1 s_5466_3
        let s_5466_4: bool = ((s_5466_1) == (s_5466_3));
        // D s_5466_5: write-var gs#134688 <= s_5466_4
        fn_state.gs_134688 = s_5466_4;
        // N s_5466_6: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_5467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5467_0: read-var el:u8
        let s_5467_0: u8 = fn_state.el;
        // D s_5467_1: read-var coproc:u8
        let s_5467_1: u8 = fn_state.coproc;
        // D s_5467_2: read-var opc1:u8
        let s_5467_2: u8 = fn_state.opc1;
        // D s_5467_3: read-var CRn:u8
        let s_5467_3: u8 = fn_state.CRn;
        // D s_5467_4: read-var opc2:u8
        let s_5467_4: u8 = fn_state.opc2;
        // D s_5467_5: read-var CRm:u8
        let s_5467_5: u8 = fn_state.CRm;
        // D s_5467_6: read-var t:i
        let s_5467_6: i128 = fn_state.t;
        // D s_5467_7: call DBGBXVR_SysRegWrite32_4720fe7969390f72(s_5467_0, s_5467_1, s_5467_2, s_5467_3, s_5467_4, s_5467_5, s_5467_6)
        let s_5467_7: () = DBGBXVR_SysRegWrite32_4720fe7969390f72(
            state,
            tracer,
            s_5467_0,
            s_5467_1,
            s_5467_2,
            s_5467_3,
            s_5467_4,
            s_5467_5,
            s_5467_6,
        );
        // N s_5467_8: return
        return;
    }
    fn block_5468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5468_0: read-var opc2:u8
        let s_5468_0: u8 = fn_state.opc2;
        // D s_5468_1: cast zx s_5468_0 -> bv
        let s_5468_1: Bits = Bits::new(s_5468_0 as u128, 3u16);
        // C s_5468_2: const #1u : u8
        let s_5468_2: u8 = 1;
        // C s_5468_3: cast zx s_5468_2 -> bv
        let s_5468_3: Bits = Bits::new(s_5468_2 as u128, 3u16);
        // D s_5468_4: cmp-eq s_5468_1 s_5468_3
        let s_5468_4: bool = ((s_5468_1) == (s_5468_3));
        // D s_5468_5: write-var gs#134687 <= s_5468_4
        fn_state.gs_134687 = s_5468_4;
        // N s_5468_6: jump b467
        return block_467(state, tracer, fn_state);
    }
    fn block_5469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5469_0: read-var opc1:u8
        let s_5469_0: u8 = fn_state.opc1;
        // D s_5469_1: cast zx s_5469_0 -> bv
        let s_5469_1: Bits = Bits::new(s_5469_0 as u128, 3u16);
        // C s_5469_2: const #0u : u8
        let s_5469_2: u8 = 0;
        // C s_5469_3: cast zx s_5469_2 -> bv
        let s_5469_3: Bits = Bits::new(s_5469_2 as u128, 3u16);
        // D s_5469_4: cmp-eq s_5469_1 s_5469_3
        let s_5469_4: bool = ((s_5469_1) == (s_5469_3));
        // D s_5469_5: write-var gs#134686 <= s_5469_4
        fn_state.gs_134686 = s_5469_4;
        // N s_5469_6: jump b465
        return block_465(state, tracer, fn_state);
    }
    fn block_5470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5470_0: read-var coproc:u8
        let s_5470_0: u8 = fn_state.coproc;
        // D s_5470_1: cast zx s_5470_0 -> bv
        let s_5470_1: Bits = Bits::new(s_5470_0 as u128, 4u16);
        // C s_5470_2: const #14u : u8
        let s_5470_2: u8 = 14;
        // C s_5470_3: cast zx s_5470_2 -> bv
        let s_5470_3: Bits = Bits::new(s_5470_2 as u128, 4u16);
        // D s_5470_4: cmp-eq s_5470_1 s_5470_3
        let s_5470_4: bool = ((s_5470_1) == (s_5470_3));
        // D s_5470_5: write-var gs#134685 <= s_5470_4
        fn_state.gs_134685 = s_5470_4;
        // N s_5470_6: jump b463
        return block_463(state, tracer, fn_state);
    }
    fn block_5471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5471_0: read-var CRn:u8
        let s_5471_0: u8 = fn_state.CRn;
        // D s_5471_1: cast zx s_5471_0 -> bv
        let s_5471_1: Bits = Bits::new(s_5471_0 as u128, 4u16);
        // C s_5471_2: const #1u : u8
        let s_5471_2: u8 = 1;
        // C s_5471_3: cast zx s_5471_2 -> bv
        let s_5471_3: Bits = Bits::new(s_5471_2 as u128, 4u16);
        // D s_5471_4: cmp-eq s_5471_1 s_5471_3
        let s_5471_4: bool = ((s_5471_1) == (s_5471_3));
        // D s_5471_5: write-var gs#134684 <= s_5471_4
        fn_state.gs_134684 = s_5471_4;
        // N s_5471_6: jump b461
        return block_461(state, tracer, fn_state);
    }
    fn block_5472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5472_0: read-var el:u8
        let s_5472_0: u8 = fn_state.el;
        // D s_5472_1: read-var coproc:u8
        let s_5472_1: u8 = fn_state.coproc;
        // D s_5472_2: read-var opc1:u8
        let s_5472_2: u8 = fn_state.opc1;
        // D s_5472_3: read-var CRn:u8
        let s_5472_3: u8 = fn_state.CRn;
        // D s_5472_4: read-var opc2:u8
        let s_5472_4: u8 = fn_state.opc2;
        // D s_5472_5: read-var CRm:u8
        let s_5472_5: u8 = fn_state.CRm;
        // D s_5472_6: read-var t:i
        let s_5472_6: i128 = fn_state.t;
        // D s_5472_7: call DBGBXVR_SysRegWrite32_3d25e640561e27b0(s_5472_0, s_5472_1, s_5472_2, s_5472_3, s_5472_4, s_5472_5, s_5472_6)
        let s_5472_7: () = DBGBXVR_SysRegWrite32_3d25e640561e27b0(
            state,
            tracer,
            s_5472_0,
            s_5472_1,
            s_5472_2,
            s_5472_3,
            s_5472_4,
            s_5472_5,
            s_5472_6,
        );
        // N s_5472_8: return
        return;
    }
    fn block_5473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5473_0: read-var opc2:u8
        let s_5473_0: u8 = fn_state.opc2;
        // D s_5473_1: cast zx s_5473_0 -> bv
        let s_5473_1: Bits = Bits::new(s_5473_0 as u128, 3u16);
        // C s_5473_2: const #1u : u8
        let s_5473_2: u8 = 1;
        // C s_5473_3: cast zx s_5473_2 -> bv
        let s_5473_3: Bits = Bits::new(s_5473_2 as u128, 3u16);
        // D s_5473_4: cmp-eq s_5473_1 s_5473_3
        let s_5473_4: bool = ((s_5473_1) == (s_5473_3));
        // D s_5473_5: write-var gs#134683 <= s_5473_4
        fn_state.gs_134683 = s_5473_4;
        // N s_5473_6: jump b458
        return block_458(state, tracer, fn_state);
    }
    fn block_5474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5474_0: read-var opc1:u8
        let s_5474_0: u8 = fn_state.opc1;
        // D s_5474_1: cast zx s_5474_0 -> bv
        let s_5474_1: Bits = Bits::new(s_5474_0 as u128, 3u16);
        // C s_5474_2: const #0u : u8
        let s_5474_2: u8 = 0;
        // C s_5474_3: cast zx s_5474_2 -> bv
        let s_5474_3: Bits = Bits::new(s_5474_2 as u128, 3u16);
        // D s_5474_4: cmp-eq s_5474_1 s_5474_3
        let s_5474_4: bool = ((s_5474_1) == (s_5474_3));
        // D s_5474_5: write-var gs#134682 <= s_5474_4
        fn_state.gs_134682 = s_5474_4;
        // N s_5474_6: jump b456
        return block_456(state, tracer, fn_state);
    }
    fn block_5475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5475_0: read-var coproc:u8
        let s_5475_0: u8 = fn_state.coproc;
        // D s_5475_1: cast zx s_5475_0 -> bv
        let s_5475_1: Bits = Bits::new(s_5475_0 as u128, 4u16);
        // C s_5475_2: const #14u : u8
        let s_5475_2: u8 = 14;
        // C s_5475_3: cast zx s_5475_2 -> bv
        let s_5475_3: Bits = Bits::new(s_5475_2 as u128, 4u16);
        // D s_5475_4: cmp-eq s_5475_1 s_5475_3
        let s_5475_4: bool = ((s_5475_1) == (s_5475_3));
        // D s_5475_5: write-var gs#134681 <= s_5475_4
        fn_state.gs_134681 = s_5475_4;
        // N s_5475_6: jump b454
        return block_454(state, tracer, fn_state);
    }
    fn block_5476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5476_0: read-var CRn:u8
        let s_5476_0: u8 = fn_state.CRn;
        // D s_5476_1: cast zx s_5476_0 -> bv
        let s_5476_1: Bits = Bits::new(s_5476_0 as u128, 4u16);
        // C s_5476_2: const #1u : u8
        let s_5476_2: u8 = 1;
        // C s_5476_3: cast zx s_5476_2 -> bv
        let s_5476_3: Bits = Bits::new(s_5476_2 as u128, 4u16);
        // D s_5476_4: cmp-eq s_5476_1 s_5476_3
        let s_5476_4: bool = ((s_5476_1) == (s_5476_3));
        // D s_5476_5: write-var gs#134680 <= s_5476_4
        fn_state.gs_134680 = s_5476_4;
        // N s_5476_6: jump b452
        return block_452(state, tracer, fn_state);
    }
    fn block_5477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5477_0: read-var el:u8
        let s_5477_0: u8 = fn_state.el;
        // D s_5477_1: read-var coproc:u8
        let s_5477_1: u8 = fn_state.coproc;
        // D s_5477_2: read-var opc1:u8
        let s_5477_2: u8 = fn_state.opc1;
        // D s_5477_3: read-var CRn:u8
        let s_5477_3: u8 = fn_state.CRn;
        // D s_5477_4: read-var opc2:u8
        let s_5477_4: u8 = fn_state.opc2;
        // D s_5477_5: read-var CRm:u8
        let s_5477_5: u8 = fn_state.CRm;
        // D s_5477_6: read-var t:i
        let s_5477_6: i128 = fn_state.t;
        // D s_5477_7: call DBGBXVR_SysRegWrite32_b1bf8c267662673c(s_5477_0, s_5477_1, s_5477_2, s_5477_3, s_5477_4, s_5477_5, s_5477_6)
        let s_5477_7: () = DBGBXVR_SysRegWrite32_b1bf8c267662673c(
            state,
            tracer,
            s_5477_0,
            s_5477_1,
            s_5477_2,
            s_5477_3,
            s_5477_4,
            s_5477_5,
            s_5477_6,
        );
        // N s_5477_8: return
        return;
    }
    fn block_5478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5478_0: read-var opc2:u8
        let s_5478_0: u8 = fn_state.opc2;
        // D s_5478_1: cast zx s_5478_0 -> bv
        let s_5478_1: Bits = Bits::new(s_5478_0 as u128, 3u16);
        // C s_5478_2: const #1u : u8
        let s_5478_2: u8 = 1;
        // C s_5478_3: cast zx s_5478_2 -> bv
        let s_5478_3: Bits = Bits::new(s_5478_2 as u128, 3u16);
        // D s_5478_4: cmp-eq s_5478_1 s_5478_3
        let s_5478_4: bool = ((s_5478_1) == (s_5478_3));
        // D s_5478_5: write-var gs#134679 <= s_5478_4
        fn_state.gs_134679 = s_5478_4;
        // N s_5478_6: jump b449
        return block_449(state, tracer, fn_state);
    }
    fn block_5479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5479_0: read-var opc1:u8
        let s_5479_0: u8 = fn_state.opc1;
        // D s_5479_1: cast zx s_5479_0 -> bv
        let s_5479_1: Bits = Bits::new(s_5479_0 as u128, 3u16);
        // C s_5479_2: const #0u : u8
        let s_5479_2: u8 = 0;
        // C s_5479_3: cast zx s_5479_2 -> bv
        let s_5479_3: Bits = Bits::new(s_5479_2 as u128, 3u16);
        // D s_5479_4: cmp-eq s_5479_1 s_5479_3
        let s_5479_4: bool = ((s_5479_1) == (s_5479_3));
        // D s_5479_5: write-var gs#134678 <= s_5479_4
        fn_state.gs_134678 = s_5479_4;
        // N s_5479_6: jump b447
        return block_447(state, tracer, fn_state);
    }
    fn block_5480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5480_0: read-var coproc:u8
        let s_5480_0: u8 = fn_state.coproc;
        // D s_5480_1: cast zx s_5480_0 -> bv
        let s_5480_1: Bits = Bits::new(s_5480_0 as u128, 4u16);
        // C s_5480_2: const #14u : u8
        let s_5480_2: u8 = 14;
        // C s_5480_3: cast zx s_5480_2 -> bv
        let s_5480_3: Bits = Bits::new(s_5480_2 as u128, 4u16);
        // D s_5480_4: cmp-eq s_5480_1 s_5480_3
        let s_5480_4: bool = ((s_5480_1) == (s_5480_3));
        // D s_5480_5: write-var gs#134677 <= s_5480_4
        fn_state.gs_134677 = s_5480_4;
        // N s_5480_6: jump b445
        return block_445(state, tracer, fn_state);
    }
    fn block_5481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5481_0: read-var CRn:u8
        let s_5481_0: u8 = fn_state.CRn;
        // D s_5481_1: cast zx s_5481_0 -> bv
        let s_5481_1: Bits = Bits::new(s_5481_0 as u128, 4u16);
        // C s_5481_2: const #1u : u8
        let s_5481_2: u8 = 1;
        // C s_5481_3: cast zx s_5481_2 -> bv
        let s_5481_3: Bits = Bits::new(s_5481_2 as u128, 4u16);
        // D s_5481_4: cmp-eq s_5481_1 s_5481_3
        let s_5481_4: bool = ((s_5481_1) == (s_5481_3));
        // D s_5481_5: write-var gs#134676 <= s_5481_4
        fn_state.gs_134676 = s_5481_4;
        // N s_5481_6: jump b443
        return block_443(state, tracer, fn_state);
    }
    fn block_5482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5482_0: read-var el:u8
        let s_5482_0: u8 = fn_state.el;
        // D s_5482_1: read-var coproc:u8
        let s_5482_1: u8 = fn_state.coproc;
        // D s_5482_2: read-var opc1:u8
        let s_5482_2: u8 = fn_state.opc1;
        // D s_5482_3: read-var CRn:u8
        let s_5482_3: u8 = fn_state.CRn;
        // D s_5482_4: read-var opc2:u8
        let s_5482_4: u8 = fn_state.opc2;
        // D s_5482_5: read-var CRm:u8
        let s_5482_5: u8 = fn_state.CRm;
        // D s_5482_6: read-var t:i
        let s_5482_6: i128 = fn_state.t;
        // D s_5482_7: call DBGBXVR_SysRegWrite32_116cb607b4f32fd9(s_5482_0, s_5482_1, s_5482_2, s_5482_3, s_5482_4, s_5482_5, s_5482_6)
        let s_5482_7: () = DBGBXVR_SysRegWrite32_116cb607b4f32fd9(
            state,
            tracer,
            s_5482_0,
            s_5482_1,
            s_5482_2,
            s_5482_3,
            s_5482_4,
            s_5482_5,
            s_5482_6,
        );
        // N s_5482_8: return
        return;
    }
    fn block_5483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5483_0: read-var opc2:u8
        let s_5483_0: u8 = fn_state.opc2;
        // D s_5483_1: cast zx s_5483_0 -> bv
        let s_5483_1: Bits = Bits::new(s_5483_0 as u128, 3u16);
        // C s_5483_2: const #1u : u8
        let s_5483_2: u8 = 1;
        // C s_5483_3: cast zx s_5483_2 -> bv
        let s_5483_3: Bits = Bits::new(s_5483_2 as u128, 3u16);
        // D s_5483_4: cmp-eq s_5483_1 s_5483_3
        let s_5483_4: bool = ((s_5483_1) == (s_5483_3));
        // D s_5483_5: write-var gs#134675 <= s_5483_4
        fn_state.gs_134675 = s_5483_4;
        // N s_5483_6: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_5484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5484_0: read-var opc1:u8
        let s_5484_0: u8 = fn_state.opc1;
        // D s_5484_1: cast zx s_5484_0 -> bv
        let s_5484_1: Bits = Bits::new(s_5484_0 as u128, 3u16);
        // C s_5484_2: const #0u : u8
        let s_5484_2: u8 = 0;
        // C s_5484_3: cast zx s_5484_2 -> bv
        let s_5484_3: Bits = Bits::new(s_5484_2 as u128, 3u16);
        // D s_5484_4: cmp-eq s_5484_1 s_5484_3
        let s_5484_4: bool = ((s_5484_1) == (s_5484_3));
        // D s_5484_5: write-var gs#134674 <= s_5484_4
        fn_state.gs_134674 = s_5484_4;
        // N s_5484_6: jump b438
        return block_438(state, tracer, fn_state);
    }
    fn block_5485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5485_0: read-var coproc:u8
        let s_5485_0: u8 = fn_state.coproc;
        // D s_5485_1: cast zx s_5485_0 -> bv
        let s_5485_1: Bits = Bits::new(s_5485_0 as u128, 4u16);
        // C s_5485_2: const #14u : u8
        let s_5485_2: u8 = 14;
        // C s_5485_3: cast zx s_5485_2 -> bv
        let s_5485_3: Bits = Bits::new(s_5485_2 as u128, 4u16);
        // D s_5485_4: cmp-eq s_5485_1 s_5485_3
        let s_5485_4: bool = ((s_5485_1) == (s_5485_3));
        // D s_5485_5: write-var gs#134673 <= s_5485_4
        fn_state.gs_134673 = s_5485_4;
        // N s_5485_6: jump b436
        return block_436(state, tracer, fn_state);
    }
    fn block_5486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5486_0: read-var CRn:u8
        let s_5486_0: u8 = fn_state.CRn;
        // D s_5486_1: cast zx s_5486_0 -> bv
        let s_5486_1: Bits = Bits::new(s_5486_0 as u128, 4u16);
        // C s_5486_2: const #1u : u8
        let s_5486_2: u8 = 1;
        // C s_5486_3: cast zx s_5486_2 -> bv
        let s_5486_3: Bits = Bits::new(s_5486_2 as u128, 4u16);
        // D s_5486_4: cmp-eq s_5486_1 s_5486_3
        let s_5486_4: bool = ((s_5486_1) == (s_5486_3));
        // D s_5486_5: write-var gs#134672 <= s_5486_4
        fn_state.gs_134672 = s_5486_4;
        // N s_5486_6: jump b434
        return block_434(state, tracer, fn_state);
    }
    fn block_5487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5487_0: read-var el:u8
        let s_5487_0: u8 = fn_state.el;
        // D s_5487_1: read-var coproc:u8
        let s_5487_1: u8 = fn_state.coproc;
        // D s_5487_2: read-var opc1:u8
        let s_5487_2: u8 = fn_state.opc1;
        // D s_5487_3: read-var CRn:u8
        let s_5487_3: u8 = fn_state.CRn;
        // D s_5487_4: read-var opc2:u8
        let s_5487_4: u8 = fn_state.opc2;
        // D s_5487_5: read-var CRm:u8
        let s_5487_5: u8 = fn_state.CRm;
        // D s_5487_6: read-var t:i
        let s_5487_6: i128 = fn_state.t;
        // D s_5487_7: call DBGBXVR_SysRegWrite32_8266ce06319e0f6e(s_5487_0, s_5487_1, s_5487_2, s_5487_3, s_5487_4, s_5487_5, s_5487_6)
        let s_5487_7: () = DBGBXVR_SysRegWrite32_8266ce06319e0f6e(
            state,
            tracer,
            s_5487_0,
            s_5487_1,
            s_5487_2,
            s_5487_3,
            s_5487_4,
            s_5487_5,
            s_5487_6,
        );
        // N s_5487_8: return
        return;
    }
    fn block_5488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5488_0: read-var opc2:u8
        let s_5488_0: u8 = fn_state.opc2;
        // D s_5488_1: cast zx s_5488_0 -> bv
        let s_5488_1: Bits = Bits::new(s_5488_0 as u128, 3u16);
        // C s_5488_2: const #1u : u8
        let s_5488_2: u8 = 1;
        // C s_5488_3: cast zx s_5488_2 -> bv
        let s_5488_3: Bits = Bits::new(s_5488_2 as u128, 3u16);
        // D s_5488_4: cmp-eq s_5488_1 s_5488_3
        let s_5488_4: bool = ((s_5488_1) == (s_5488_3));
        // D s_5488_5: write-var gs#134671 <= s_5488_4
        fn_state.gs_134671 = s_5488_4;
        // N s_5488_6: jump b431
        return block_431(state, tracer, fn_state);
    }
    fn block_5489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5489_0: read-var opc1:u8
        let s_5489_0: u8 = fn_state.opc1;
        // D s_5489_1: cast zx s_5489_0 -> bv
        let s_5489_1: Bits = Bits::new(s_5489_0 as u128, 3u16);
        // C s_5489_2: const #0u : u8
        let s_5489_2: u8 = 0;
        // C s_5489_3: cast zx s_5489_2 -> bv
        let s_5489_3: Bits = Bits::new(s_5489_2 as u128, 3u16);
        // D s_5489_4: cmp-eq s_5489_1 s_5489_3
        let s_5489_4: bool = ((s_5489_1) == (s_5489_3));
        // D s_5489_5: write-var gs#134670 <= s_5489_4
        fn_state.gs_134670 = s_5489_4;
        // N s_5489_6: jump b429
        return block_429(state, tracer, fn_state);
    }
    fn block_5490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5490_0: read-var coproc:u8
        let s_5490_0: u8 = fn_state.coproc;
        // D s_5490_1: cast zx s_5490_0 -> bv
        let s_5490_1: Bits = Bits::new(s_5490_0 as u128, 4u16);
        // C s_5490_2: const #14u : u8
        let s_5490_2: u8 = 14;
        // C s_5490_3: cast zx s_5490_2 -> bv
        let s_5490_3: Bits = Bits::new(s_5490_2 as u128, 4u16);
        // D s_5490_4: cmp-eq s_5490_1 s_5490_3
        let s_5490_4: bool = ((s_5490_1) == (s_5490_3));
        // D s_5490_5: write-var gs#134669 <= s_5490_4
        fn_state.gs_134669 = s_5490_4;
        // N s_5490_6: jump b427
        return block_427(state, tracer, fn_state);
    }
    fn block_5491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5491_0: read-var CRn:u8
        let s_5491_0: u8 = fn_state.CRn;
        // D s_5491_1: cast zx s_5491_0 -> bv
        let s_5491_1: Bits = Bits::new(s_5491_0 as u128, 4u16);
        // C s_5491_2: const #1u : u8
        let s_5491_2: u8 = 1;
        // C s_5491_3: cast zx s_5491_2 -> bv
        let s_5491_3: Bits = Bits::new(s_5491_2 as u128, 4u16);
        // D s_5491_4: cmp-eq s_5491_1 s_5491_3
        let s_5491_4: bool = ((s_5491_1) == (s_5491_3));
        // D s_5491_5: write-var gs#134668 <= s_5491_4
        fn_state.gs_134668 = s_5491_4;
        // N s_5491_6: jump b425
        return block_425(state, tracer, fn_state);
    }
    fn block_5492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5492_0: read-var el:u8
        let s_5492_0: u8 = fn_state.el;
        // D s_5492_1: read-var coproc:u8
        let s_5492_1: u8 = fn_state.coproc;
        // D s_5492_2: read-var opc1:u8
        let s_5492_2: u8 = fn_state.opc1;
        // D s_5492_3: read-var CRn:u8
        let s_5492_3: u8 = fn_state.CRn;
        // D s_5492_4: read-var opc2:u8
        let s_5492_4: u8 = fn_state.opc2;
        // D s_5492_5: read-var CRm:u8
        let s_5492_5: u8 = fn_state.CRm;
        // D s_5492_6: read-var t:i
        let s_5492_6: i128 = fn_state.t;
        // D s_5492_7: call DBGBXVR_SysRegWrite32_9d5393fe9638bbc0(s_5492_0, s_5492_1, s_5492_2, s_5492_3, s_5492_4, s_5492_5, s_5492_6)
        let s_5492_7: () = DBGBXVR_SysRegWrite32_9d5393fe9638bbc0(
            state,
            tracer,
            s_5492_0,
            s_5492_1,
            s_5492_2,
            s_5492_3,
            s_5492_4,
            s_5492_5,
            s_5492_6,
        );
        // N s_5492_8: return
        return;
    }
    fn block_5493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5493_0: read-var opc2:u8
        let s_5493_0: u8 = fn_state.opc2;
        // D s_5493_1: cast zx s_5493_0 -> bv
        let s_5493_1: Bits = Bits::new(s_5493_0 as u128, 3u16);
        // C s_5493_2: const #1u : u8
        let s_5493_2: u8 = 1;
        // C s_5493_3: cast zx s_5493_2 -> bv
        let s_5493_3: Bits = Bits::new(s_5493_2 as u128, 3u16);
        // D s_5493_4: cmp-eq s_5493_1 s_5493_3
        let s_5493_4: bool = ((s_5493_1) == (s_5493_3));
        // D s_5493_5: write-var gs#134667 <= s_5493_4
        fn_state.gs_134667 = s_5493_4;
        // N s_5493_6: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_5494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5494_0: read-var opc1:u8
        let s_5494_0: u8 = fn_state.opc1;
        // D s_5494_1: cast zx s_5494_0 -> bv
        let s_5494_1: Bits = Bits::new(s_5494_0 as u128, 3u16);
        // C s_5494_2: const #0u : u8
        let s_5494_2: u8 = 0;
        // C s_5494_3: cast zx s_5494_2 -> bv
        let s_5494_3: Bits = Bits::new(s_5494_2 as u128, 3u16);
        // D s_5494_4: cmp-eq s_5494_1 s_5494_3
        let s_5494_4: bool = ((s_5494_1) == (s_5494_3));
        // D s_5494_5: write-var gs#134666 <= s_5494_4
        fn_state.gs_134666 = s_5494_4;
        // N s_5494_6: jump b420
        return block_420(state, tracer, fn_state);
    }
    fn block_5495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5495_0: read-var coproc:u8
        let s_5495_0: u8 = fn_state.coproc;
        // D s_5495_1: cast zx s_5495_0 -> bv
        let s_5495_1: Bits = Bits::new(s_5495_0 as u128, 4u16);
        // C s_5495_2: const #14u : u8
        let s_5495_2: u8 = 14;
        // C s_5495_3: cast zx s_5495_2 -> bv
        let s_5495_3: Bits = Bits::new(s_5495_2 as u128, 4u16);
        // D s_5495_4: cmp-eq s_5495_1 s_5495_3
        let s_5495_4: bool = ((s_5495_1) == (s_5495_3));
        // D s_5495_5: write-var gs#134665 <= s_5495_4
        fn_state.gs_134665 = s_5495_4;
        // N s_5495_6: jump b418
        return block_418(state, tracer, fn_state);
    }
    fn block_5496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5496_0: read-var CRn:u8
        let s_5496_0: u8 = fn_state.CRn;
        // D s_5496_1: cast zx s_5496_0 -> bv
        let s_5496_1: Bits = Bits::new(s_5496_0 as u128, 4u16);
        // C s_5496_2: const #1u : u8
        let s_5496_2: u8 = 1;
        // C s_5496_3: cast zx s_5496_2 -> bv
        let s_5496_3: Bits = Bits::new(s_5496_2 as u128, 4u16);
        // D s_5496_4: cmp-eq s_5496_1 s_5496_3
        let s_5496_4: bool = ((s_5496_1) == (s_5496_3));
        // D s_5496_5: write-var gs#134664 <= s_5496_4
        fn_state.gs_134664 = s_5496_4;
        // N s_5496_6: jump b416
        return block_416(state, tracer, fn_state);
    }
    fn block_5497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5497_0: read-var el:u8
        let s_5497_0: u8 = fn_state.el;
        // D s_5497_1: read-var coproc:u8
        let s_5497_1: u8 = fn_state.coproc;
        // D s_5497_2: read-var opc1:u8
        let s_5497_2: u8 = fn_state.opc1;
        // D s_5497_3: read-var CRn:u8
        let s_5497_3: u8 = fn_state.CRn;
        // D s_5497_4: read-var opc2:u8
        let s_5497_4: u8 = fn_state.opc2;
        // D s_5497_5: read-var CRm:u8
        let s_5497_5: u8 = fn_state.CRm;
        // D s_5497_6: read-var t:i
        let s_5497_6: i128 = fn_state.t;
        // D s_5497_7: call DBGBXVR_SysRegWrite32_afc6cb16977bd810(s_5497_0, s_5497_1, s_5497_2, s_5497_3, s_5497_4, s_5497_5, s_5497_6)
        let s_5497_7: () = DBGBXVR_SysRegWrite32_afc6cb16977bd810(
            state,
            tracer,
            s_5497_0,
            s_5497_1,
            s_5497_2,
            s_5497_3,
            s_5497_4,
            s_5497_5,
            s_5497_6,
        );
        // N s_5497_8: return
        return;
    }
    fn block_5498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5498_0: read-var opc2:u8
        let s_5498_0: u8 = fn_state.opc2;
        // D s_5498_1: cast zx s_5498_0 -> bv
        let s_5498_1: Bits = Bits::new(s_5498_0 as u128, 3u16);
        // C s_5498_2: const #1u : u8
        let s_5498_2: u8 = 1;
        // C s_5498_3: cast zx s_5498_2 -> bv
        let s_5498_3: Bits = Bits::new(s_5498_2 as u128, 3u16);
        // D s_5498_4: cmp-eq s_5498_1 s_5498_3
        let s_5498_4: bool = ((s_5498_1) == (s_5498_3));
        // D s_5498_5: write-var gs#134663 <= s_5498_4
        fn_state.gs_134663 = s_5498_4;
        // N s_5498_6: jump b413
        return block_413(state, tracer, fn_state);
    }
    fn block_5499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5499_0: read-var opc1:u8
        let s_5499_0: u8 = fn_state.opc1;
        // D s_5499_1: cast zx s_5499_0 -> bv
        let s_5499_1: Bits = Bits::new(s_5499_0 as u128, 3u16);
        // C s_5499_2: const #0u : u8
        let s_5499_2: u8 = 0;
        // C s_5499_3: cast zx s_5499_2 -> bv
        let s_5499_3: Bits = Bits::new(s_5499_2 as u128, 3u16);
        // D s_5499_4: cmp-eq s_5499_1 s_5499_3
        let s_5499_4: bool = ((s_5499_1) == (s_5499_3));
        // D s_5499_5: write-var gs#134662 <= s_5499_4
        fn_state.gs_134662 = s_5499_4;
        // N s_5499_6: jump b411
        return block_411(state, tracer, fn_state);
    }
    fn block_5500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5500_0: read-var coproc:u8
        let s_5500_0: u8 = fn_state.coproc;
        // D s_5500_1: cast zx s_5500_0 -> bv
        let s_5500_1: Bits = Bits::new(s_5500_0 as u128, 4u16);
        // C s_5500_2: const #14u : u8
        let s_5500_2: u8 = 14;
        // C s_5500_3: cast zx s_5500_2 -> bv
        let s_5500_3: Bits = Bits::new(s_5500_2 as u128, 4u16);
        // D s_5500_4: cmp-eq s_5500_1 s_5500_3
        let s_5500_4: bool = ((s_5500_1) == (s_5500_3));
        // D s_5500_5: write-var gs#134661 <= s_5500_4
        fn_state.gs_134661 = s_5500_4;
        // N s_5500_6: jump b409
        return block_409(state, tracer, fn_state);
    }
    fn block_5501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5501_0: read-var CRn:u8
        let s_5501_0: u8 = fn_state.CRn;
        // D s_5501_1: cast zx s_5501_0 -> bv
        let s_5501_1: Bits = Bits::new(s_5501_0 as u128, 4u16);
        // C s_5501_2: const #1u : u8
        let s_5501_2: u8 = 1;
        // C s_5501_3: cast zx s_5501_2 -> bv
        let s_5501_3: Bits = Bits::new(s_5501_2 as u128, 4u16);
        // D s_5501_4: cmp-eq s_5501_1 s_5501_3
        let s_5501_4: bool = ((s_5501_1) == (s_5501_3));
        // D s_5501_5: write-var gs#134660 <= s_5501_4
        fn_state.gs_134660 = s_5501_4;
        // N s_5501_6: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_5502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5502_0: read-var el:u8
        let s_5502_0: u8 = fn_state.el;
        // D s_5502_1: read-var coproc:u8
        let s_5502_1: u8 = fn_state.coproc;
        // D s_5502_2: read-var opc1:u8
        let s_5502_2: u8 = fn_state.opc1;
        // D s_5502_3: read-var CRn:u8
        let s_5502_3: u8 = fn_state.CRn;
        // D s_5502_4: read-var opc2:u8
        let s_5502_4: u8 = fn_state.opc2;
        // D s_5502_5: read-var CRm:u8
        let s_5502_5: u8 = fn_state.CRm;
        // D s_5502_6: read-var t:i
        let s_5502_6: i128 = fn_state.t;
        // D s_5502_7: call DBGBXVR_SysRegWrite32_24b2754b78ed2b6a(s_5502_0, s_5502_1, s_5502_2, s_5502_3, s_5502_4, s_5502_5, s_5502_6)
        let s_5502_7: () = DBGBXVR_SysRegWrite32_24b2754b78ed2b6a(
            state,
            tracer,
            s_5502_0,
            s_5502_1,
            s_5502_2,
            s_5502_3,
            s_5502_4,
            s_5502_5,
            s_5502_6,
        );
        // N s_5502_8: return
        return;
    }
    fn block_5503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5503_0: read-var opc2:u8
        let s_5503_0: u8 = fn_state.opc2;
        // D s_5503_1: cast zx s_5503_0 -> bv
        let s_5503_1: Bits = Bits::new(s_5503_0 as u128, 3u16);
        // C s_5503_2: const #1u : u8
        let s_5503_2: u8 = 1;
        // C s_5503_3: cast zx s_5503_2 -> bv
        let s_5503_3: Bits = Bits::new(s_5503_2 as u128, 3u16);
        // D s_5503_4: cmp-eq s_5503_1 s_5503_3
        let s_5503_4: bool = ((s_5503_1) == (s_5503_3));
        // D s_5503_5: write-var gs#134659 <= s_5503_4
        fn_state.gs_134659 = s_5503_4;
        // N s_5503_6: jump b404
        return block_404(state, tracer, fn_state);
    }
    fn block_5504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5504_0: read-var opc1:u8
        let s_5504_0: u8 = fn_state.opc1;
        // D s_5504_1: cast zx s_5504_0 -> bv
        let s_5504_1: Bits = Bits::new(s_5504_0 as u128, 3u16);
        // C s_5504_2: const #0u : u8
        let s_5504_2: u8 = 0;
        // C s_5504_3: cast zx s_5504_2 -> bv
        let s_5504_3: Bits = Bits::new(s_5504_2 as u128, 3u16);
        // D s_5504_4: cmp-eq s_5504_1 s_5504_3
        let s_5504_4: bool = ((s_5504_1) == (s_5504_3));
        // D s_5504_5: write-var gs#134658 <= s_5504_4
        fn_state.gs_134658 = s_5504_4;
        // N s_5504_6: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_5505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5505_0: read-var coproc:u8
        let s_5505_0: u8 = fn_state.coproc;
        // D s_5505_1: cast zx s_5505_0 -> bv
        let s_5505_1: Bits = Bits::new(s_5505_0 as u128, 4u16);
        // C s_5505_2: const #14u : u8
        let s_5505_2: u8 = 14;
        // C s_5505_3: cast zx s_5505_2 -> bv
        let s_5505_3: Bits = Bits::new(s_5505_2 as u128, 4u16);
        // D s_5505_4: cmp-eq s_5505_1 s_5505_3
        let s_5505_4: bool = ((s_5505_1) == (s_5505_3));
        // D s_5505_5: write-var gs#134657 <= s_5505_4
        fn_state.gs_134657 = s_5505_4;
        // N s_5505_6: jump b400
        return block_400(state, tracer, fn_state);
    }
    fn block_5506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5506_0: read-var CRn:u8
        let s_5506_0: u8 = fn_state.CRn;
        // D s_5506_1: cast zx s_5506_0 -> bv
        let s_5506_1: Bits = Bits::new(s_5506_0 as u128, 4u16);
        // C s_5506_2: const #1u : u8
        let s_5506_2: u8 = 1;
        // C s_5506_3: cast zx s_5506_2 -> bv
        let s_5506_3: Bits = Bits::new(s_5506_2 as u128, 4u16);
        // D s_5506_4: cmp-eq s_5506_1 s_5506_3
        let s_5506_4: bool = ((s_5506_1) == (s_5506_3));
        // D s_5506_5: write-var gs#134656 <= s_5506_4
        fn_state.gs_134656 = s_5506_4;
        // N s_5506_6: jump b398
        return block_398(state, tracer, fn_state);
    }
    fn block_5507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5507_0: read-var el:u8
        let s_5507_0: u8 = fn_state.el;
        // D s_5507_1: read-var coproc:u8
        let s_5507_1: u8 = fn_state.coproc;
        // D s_5507_2: read-var opc1:u8
        let s_5507_2: u8 = fn_state.opc1;
        // D s_5507_3: read-var CRn:u8
        let s_5507_3: u8 = fn_state.CRn;
        // D s_5507_4: read-var opc2:u8
        let s_5507_4: u8 = fn_state.opc2;
        // D s_5507_5: read-var CRm:u8
        let s_5507_5: u8 = fn_state.CRm;
        // D s_5507_6: read-var t:i
        let s_5507_6: i128 = fn_state.t;
        // D s_5507_7: call CNTHP_TVAL_SysRegWrite32_8e96a3fad1864250(s_5507_0, s_5507_1, s_5507_2, s_5507_3, s_5507_4, s_5507_5, s_5507_6)
        let s_5507_7: () = CNTHP_TVAL_SysRegWrite32_8e96a3fad1864250(
            state,
            tracer,
            s_5507_0,
            s_5507_1,
            s_5507_2,
            s_5507_3,
            s_5507_4,
            s_5507_5,
            s_5507_6,
        );
        // N s_5507_8: return
        return;
    }
    fn block_5508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5508_0: read-var opc2:u8
        let s_5508_0: u8 = fn_state.opc2;
        // D s_5508_1: cast zx s_5508_0 -> bv
        let s_5508_1: Bits = Bits::new(s_5508_0 as u128, 3u16);
        // C s_5508_2: const #0u : u8
        let s_5508_2: u8 = 0;
        // C s_5508_3: cast zx s_5508_2 -> bv
        let s_5508_3: Bits = Bits::new(s_5508_2 as u128, 3u16);
        // D s_5508_4: cmp-eq s_5508_1 s_5508_3
        let s_5508_4: bool = ((s_5508_1) == (s_5508_3));
        // D s_5508_5: write-var gs#134655 <= s_5508_4
        fn_state.gs_134655 = s_5508_4;
        // N s_5508_6: jump b395
        return block_395(state, tracer, fn_state);
    }
    fn block_5509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5509_0: read-var opc1:u8
        let s_5509_0: u8 = fn_state.opc1;
        // D s_5509_1: cast zx s_5509_0 -> bv
        let s_5509_1: Bits = Bits::new(s_5509_0 as u128, 3u16);
        // C s_5509_2: const #0u : u8
        let s_5509_2: u8 = 0;
        // C s_5509_3: cast zx s_5509_2 -> bv
        let s_5509_3: Bits = Bits::new(s_5509_2 as u128, 3u16);
        // D s_5509_4: cmp-eq s_5509_1 s_5509_3
        let s_5509_4: bool = ((s_5509_1) == (s_5509_3));
        // D s_5509_5: write-var gs#134654 <= s_5509_4
        fn_state.gs_134654 = s_5509_4;
        // N s_5509_6: jump b393
        return block_393(state, tracer, fn_state);
    }
    fn block_5510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5510_0: read-var coproc:u8
        let s_5510_0: u8 = fn_state.coproc;
        // D s_5510_1: cast zx s_5510_0 -> bv
        let s_5510_1: Bits = Bits::new(s_5510_0 as u128, 4u16);
        // C s_5510_2: const #15u : u8
        let s_5510_2: u8 = 15;
        // C s_5510_3: cast zx s_5510_2 -> bv
        let s_5510_3: Bits = Bits::new(s_5510_2 as u128, 4u16);
        // D s_5510_4: cmp-eq s_5510_1 s_5510_3
        let s_5510_4: bool = ((s_5510_1) == (s_5510_3));
        // D s_5510_5: write-var gs#134653 <= s_5510_4
        fn_state.gs_134653 = s_5510_4;
        // N s_5510_6: jump b391
        return block_391(state, tracer, fn_state);
    }
    fn block_5511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5511_0: read-var CRn:u8
        let s_5511_0: u8 = fn_state.CRn;
        // D s_5511_1: cast zx s_5511_0 -> bv
        let s_5511_1: Bits = Bits::new(s_5511_0 as u128, 4u16);
        // C s_5511_2: const #14u : u8
        let s_5511_2: u8 = 14;
        // C s_5511_3: cast zx s_5511_2 -> bv
        let s_5511_3: Bits = Bits::new(s_5511_2 as u128, 4u16);
        // D s_5511_4: cmp-eq s_5511_1 s_5511_3
        let s_5511_4: bool = ((s_5511_1) == (s_5511_3));
        // D s_5511_5: write-var gs#134652 <= s_5511_4
        fn_state.gs_134652 = s_5511_4;
        // N s_5511_6: jump b389
        return block_389(state, tracer, fn_state);
    }
    fn block_5512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5512_0: read-var el:u8
        let s_5512_0: u8 = fn_state.el;
        // D s_5512_1: read-var coproc:u8
        let s_5512_1: u8 = fn_state.coproc;
        // D s_5512_2: read-var opc1:u8
        let s_5512_2: u8 = fn_state.opc1;
        // D s_5512_3: read-var CRn:u8
        let s_5512_3: u8 = fn_state.CRn;
        // D s_5512_4: read-var opc2:u8
        let s_5512_4: u8 = fn_state.opc2;
        // D s_5512_5: read-var CRm:u8
        let s_5512_5: u8 = fn_state.CRm;
        // D s_5512_6: read-var t:i
        let s_5512_6: i128 = fn_state.t;
        // D s_5512_7: call CNTHP_TVAL_SysRegWrite32_1a9db618df39c059(s_5512_0, s_5512_1, s_5512_2, s_5512_3, s_5512_4, s_5512_5, s_5512_6)
        let s_5512_7: () = CNTHP_TVAL_SysRegWrite32_1a9db618df39c059(
            state,
            tracer,
            s_5512_0,
            s_5512_1,
            s_5512_2,
            s_5512_3,
            s_5512_4,
            s_5512_5,
            s_5512_6,
        );
        // N s_5512_8: return
        return;
    }
    fn block_5513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5513_0: read-var opc2:u8
        let s_5513_0: u8 = fn_state.opc2;
        // D s_5513_1: cast zx s_5513_0 -> bv
        let s_5513_1: Bits = Bits::new(s_5513_0 as u128, 3u16);
        // C s_5513_2: const #0u : u8
        let s_5513_2: u8 = 0;
        // C s_5513_3: cast zx s_5513_2 -> bv
        let s_5513_3: Bits = Bits::new(s_5513_2 as u128, 3u16);
        // D s_5513_4: cmp-eq s_5513_1 s_5513_3
        let s_5513_4: bool = ((s_5513_1) == (s_5513_3));
        // D s_5513_5: write-var gs#134651 <= s_5513_4
        fn_state.gs_134651 = s_5513_4;
        // N s_5513_6: jump b386
        return block_386(state, tracer, fn_state);
    }
    fn block_5514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5514_0: read-var opc1:u8
        let s_5514_0: u8 = fn_state.opc1;
        // D s_5514_1: cast zx s_5514_0 -> bv
        let s_5514_1: Bits = Bits::new(s_5514_0 as u128, 3u16);
        // C s_5514_2: const #4u : u8
        let s_5514_2: u8 = 4;
        // C s_5514_3: cast zx s_5514_2 -> bv
        let s_5514_3: Bits = Bits::new(s_5514_2 as u128, 3u16);
        // D s_5514_4: cmp-eq s_5514_1 s_5514_3
        let s_5514_4: bool = ((s_5514_1) == (s_5514_3));
        // D s_5514_5: write-var gs#134650 <= s_5514_4
        fn_state.gs_134650 = s_5514_4;
        // N s_5514_6: jump b384
        return block_384(state, tracer, fn_state);
    }
    fn block_5515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5515_0: read-var coproc:u8
        let s_5515_0: u8 = fn_state.coproc;
        // D s_5515_1: cast zx s_5515_0 -> bv
        let s_5515_1: Bits = Bits::new(s_5515_0 as u128, 4u16);
        // C s_5515_2: const #15u : u8
        let s_5515_2: u8 = 15;
        // C s_5515_3: cast zx s_5515_2 -> bv
        let s_5515_3: Bits = Bits::new(s_5515_2 as u128, 4u16);
        // D s_5515_4: cmp-eq s_5515_1 s_5515_3
        let s_5515_4: bool = ((s_5515_1) == (s_5515_3));
        // D s_5515_5: write-var gs#134649 <= s_5515_4
        fn_state.gs_134649 = s_5515_4;
        // N s_5515_6: jump b382
        return block_382(state, tracer, fn_state);
    }
    fn block_5516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5516_0: read-var CRn:u8
        let s_5516_0: u8 = fn_state.CRn;
        // D s_5516_1: cast zx s_5516_0 -> bv
        let s_5516_1: Bits = Bits::new(s_5516_0 as u128, 4u16);
        // C s_5516_2: const #14u : u8
        let s_5516_2: u8 = 14;
        // C s_5516_3: cast zx s_5516_2 -> bv
        let s_5516_3: Bits = Bits::new(s_5516_2 as u128, 4u16);
        // D s_5516_4: cmp-eq s_5516_1 s_5516_3
        let s_5516_4: bool = ((s_5516_1) == (s_5516_3));
        // D s_5516_5: write-var gs#134648 <= s_5516_4
        fn_state.gs_134648 = s_5516_4;
        // N s_5516_6: jump b380
        return block_380(state, tracer, fn_state);
    }
    fn block_5517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5517_0: read-var el:u8
        let s_5517_0: u8 = fn_state.el;
        // D s_5517_1: read-var coproc:u8
        let s_5517_1: u8 = fn_state.coproc;
        // D s_5517_2: read-var opc1:u8
        let s_5517_2: u8 = fn_state.opc1;
        // D s_5517_3: read-var CRn:u8
        let s_5517_3: u8 = fn_state.CRn;
        // D s_5517_4: read-var opc2:u8
        let s_5517_4: u8 = fn_state.opc2;
        // D s_5517_5: read-var CRm:u8
        let s_5517_5: u8 = fn_state.CRm;
        // D s_5517_6: read-var t:i
        let s_5517_6: i128 = fn_state.t;
        // D s_5517_7: call ICV_CTLR_SysRegWrite32_6f9cee422585c5f5(s_5517_0, s_5517_1, s_5517_2, s_5517_3, s_5517_4, s_5517_5, s_5517_6)
        let s_5517_7: () = ICV_CTLR_SysRegWrite32_6f9cee422585c5f5(
            state,
            tracer,
            s_5517_0,
            s_5517_1,
            s_5517_2,
            s_5517_3,
            s_5517_4,
            s_5517_5,
            s_5517_6,
        );
        // N s_5517_8: return
        return;
    }
    fn block_5518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5518_0: read-var opc2:u8
        let s_5518_0: u8 = fn_state.opc2;
        // D s_5518_1: cast zx s_5518_0 -> bv
        let s_5518_1: Bits = Bits::new(s_5518_0 as u128, 3u16);
        // C s_5518_2: const #4u : u8
        let s_5518_2: u8 = 4;
        // C s_5518_3: cast zx s_5518_2 -> bv
        let s_5518_3: Bits = Bits::new(s_5518_2 as u128, 3u16);
        // D s_5518_4: cmp-eq s_5518_1 s_5518_3
        let s_5518_4: bool = ((s_5518_1) == (s_5518_3));
        // D s_5518_5: write-var gs#134647 <= s_5518_4
        fn_state.gs_134647 = s_5518_4;
        // N s_5518_6: jump b377
        return block_377(state, tracer, fn_state);
    }
    fn block_5519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5519_0: read-var opc1:u8
        let s_5519_0: u8 = fn_state.opc1;
        // D s_5519_1: cast zx s_5519_0 -> bv
        let s_5519_1: Bits = Bits::new(s_5519_0 as u128, 3u16);
        // C s_5519_2: const #0u : u8
        let s_5519_2: u8 = 0;
        // C s_5519_3: cast zx s_5519_2 -> bv
        let s_5519_3: Bits = Bits::new(s_5519_2 as u128, 3u16);
        // D s_5519_4: cmp-eq s_5519_1 s_5519_3
        let s_5519_4: bool = ((s_5519_1) == (s_5519_3));
        // D s_5519_5: write-var gs#134646 <= s_5519_4
        fn_state.gs_134646 = s_5519_4;
        // N s_5519_6: jump b375
        return block_375(state, tracer, fn_state);
    }
    fn block_5520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5520_0: read-var coproc:u8
        let s_5520_0: u8 = fn_state.coproc;
        // D s_5520_1: cast zx s_5520_0 -> bv
        let s_5520_1: Bits = Bits::new(s_5520_0 as u128, 4u16);
        // C s_5520_2: const #15u : u8
        let s_5520_2: u8 = 15;
        // C s_5520_3: cast zx s_5520_2 -> bv
        let s_5520_3: Bits = Bits::new(s_5520_2 as u128, 4u16);
        // D s_5520_4: cmp-eq s_5520_1 s_5520_3
        let s_5520_4: bool = ((s_5520_1) == (s_5520_3));
        // D s_5520_5: write-var gs#134645 <= s_5520_4
        fn_state.gs_134645 = s_5520_4;
        // N s_5520_6: jump b373
        return block_373(state, tracer, fn_state);
    }
    fn block_5521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5521_0: read-var CRn:u8
        let s_5521_0: u8 = fn_state.CRn;
        // D s_5521_1: cast zx s_5521_0 -> bv
        let s_5521_1: Bits = Bits::new(s_5521_0 as u128, 4u16);
        // C s_5521_2: const #12u : u8
        let s_5521_2: u8 = 12;
        // C s_5521_3: cast zx s_5521_2 -> bv
        let s_5521_3: Bits = Bits::new(s_5521_2 as u128, 4u16);
        // D s_5521_4: cmp-eq s_5521_1 s_5521_3
        let s_5521_4: bool = ((s_5521_1) == (s_5521_3));
        // D s_5521_5: write-var gs#134644 <= s_5521_4
        fn_state.gs_134644 = s_5521_4;
        // N s_5521_6: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_5522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5522_0: read-var el:u8
        let s_5522_0: u8 = fn_state.el;
        // D s_5522_1: read-var coproc:u8
        let s_5522_1: u8 = fn_state.coproc;
        // D s_5522_2: read-var opc1:u8
        let s_5522_2: u8 = fn_state.opc1;
        // D s_5522_3: read-var CRn:u8
        let s_5522_3: u8 = fn_state.CRn;
        // D s_5522_4: read-var opc2:u8
        let s_5522_4: u8 = fn_state.opc2;
        // D s_5522_5: read-var CRm:u8
        let s_5522_5: u8 = fn_state.CRm;
        // D s_5522_6: read-var t:i
        let s_5522_6: i128 = fn_state.t;
        // D s_5522_7: call TLBIMVAHIS_SysRegWrite32_5da1d1a785b555e8(s_5522_0, s_5522_1, s_5522_2, s_5522_3, s_5522_4, s_5522_5, s_5522_6)
        let s_5522_7: () = TLBIMVAHIS_SysRegWrite32_5da1d1a785b555e8(
            state,
            tracer,
            s_5522_0,
            s_5522_1,
            s_5522_2,
            s_5522_3,
            s_5522_4,
            s_5522_5,
            s_5522_6,
        );
        // N s_5522_8: return
        return;
    }
    fn block_5523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5523_0: read-var opc2:u8
        let s_5523_0: u8 = fn_state.opc2;
        // D s_5523_1: cast zx s_5523_0 -> bv
        let s_5523_1: Bits = Bits::new(s_5523_0 as u128, 3u16);
        // C s_5523_2: const #1u : u8
        let s_5523_2: u8 = 1;
        // C s_5523_3: cast zx s_5523_2 -> bv
        let s_5523_3: Bits = Bits::new(s_5523_2 as u128, 3u16);
        // D s_5523_4: cmp-eq s_5523_1 s_5523_3
        let s_5523_4: bool = ((s_5523_1) == (s_5523_3));
        // D s_5523_5: write-var gs#134643 <= s_5523_4
        fn_state.gs_134643 = s_5523_4;
        // N s_5523_6: jump b368
        return block_368(state, tracer, fn_state);
    }
    fn block_5524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5524_0: read-var opc1:u8
        let s_5524_0: u8 = fn_state.opc1;
        // D s_5524_1: cast zx s_5524_0 -> bv
        let s_5524_1: Bits = Bits::new(s_5524_0 as u128, 3u16);
        // C s_5524_2: const #4u : u8
        let s_5524_2: u8 = 4;
        // C s_5524_3: cast zx s_5524_2 -> bv
        let s_5524_3: Bits = Bits::new(s_5524_2 as u128, 3u16);
        // D s_5524_4: cmp-eq s_5524_1 s_5524_3
        let s_5524_4: bool = ((s_5524_1) == (s_5524_3));
        // D s_5524_5: write-var gs#134642 <= s_5524_4
        fn_state.gs_134642 = s_5524_4;
        // N s_5524_6: jump b366
        return block_366(state, tracer, fn_state);
    }
    fn block_5525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5525_0: read-var coproc:u8
        let s_5525_0: u8 = fn_state.coproc;
        // D s_5525_1: cast zx s_5525_0 -> bv
        let s_5525_1: Bits = Bits::new(s_5525_0 as u128, 4u16);
        // C s_5525_2: const #15u : u8
        let s_5525_2: u8 = 15;
        // C s_5525_3: cast zx s_5525_2 -> bv
        let s_5525_3: Bits = Bits::new(s_5525_2 as u128, 4u16);
        // D s_5525_4: cmp-eq s_5525_1 s_5525_3
        let s_5525_4: bool = ((s_5525_1) == (s_5525_3));
        // D s_5525_5: write-var gs#134641 <= s_5525_4
        fn_state.gs_134641 = s_5525_4;
        // N s_5525_6: jump b364
        return block_364(state, tracer, fn_state);
    }
    fn block_5526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5526_0: read-var CRn:u8
        let s_5526_0: u8 = fn_state.CRn;
        // D s_5526_1: cast zx s_5526_0 -> bv
        let s_5526_1: Bits = Bits::new(s_5526_0 as u128, 4u16);
        // C s_5526_2: const #8u : u8
        let s_5526_2: u8 = 8;
        // C s_5526_3: cast zx s_5526_2 -> bv
        let s_5526_3: Bits = Bits::new(s_5526_2 as u128, 4u16);
        // D s_5526_4: cmp-eq s_5526_1 s_5526_3
        let s_5526_4: bool = ((s_5526_1) == (s_5526_3));
        // D s_5526_5: write-var gs#134640 <= s_5526_4
        fn_state.gs_134640 = s_5526_4;
        // N s_5526_6: jump b362
        return block_362(state, tracer, fn_state);
    }
    fn block_5527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5527_0: read-var el:u8
        let s_5527_0: u8 = fn_state.el;
        // D s_5527_1: read-var coproc:u8
        let s_5527_1: u8 = fn_state.coproc;
        // D s_5527_2: read-var opc1:u8
        let s_5527_2: u8 = fn_state.opc1;
        // D s_5527_3: read-var CRn:u8
        let s_5527_3: u8 = fn_state.CRn;
        // D s_5527_4: read-var opc2:u8
        let s_5527_4: u8 = fn_state.opc2;
        // D s_5527_5: read-var CRm:u8
        let s_5527_5: u8 = fn_state.CRm;
        // D s_5527_6: read-var t:i
        let s_5527_6: i128 = fn_state.t;
        // D s_5527_7: call PRRR_SysRegWrite32_d60dcdae1cc2429d(s_5527_0, s_5527_1, s_5527_2, s_5527_3, s_5527_4, s_5527_5, s_5527_6)
        let s_5527_7: () = PRRR_SysRegWrite32_d60dcdae1cc2429d(
            state,
            tracer,
            s_5527_0,
            s_5527_1,
            s_5527_2,
            s_5527_3,
            s_5527_4,
            s_5527_5,
            s_5527_6,
        );
        // N s_5527_8: return
        return;
    }
    fn block_5528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5528_0: read-var opc2:u8
        let s_5528_0: u8 = fn_state.opc2;
        // D s_5528_1: cast zx s_5528_0 -> bv
        let s_5528_1: Bits = Bits::new(s_5528_0 as u128, 3u16);
        // C s_5528_2: const #0u : u8
        let s_5528_2: u8 = 0;
        // C s_5528_3: cast zx s_5528_2 -> bv
        let s_5528_3: Bits = Bits::new(s_5528_2 as u128, 3u16);
        // D s_5528_4: cmp-eq s_5528_1 s_5528_3
        let s_5528_4: bool = ((s_5528_1) == (s_5528_3));
        // D s_5528_5: write-var gs#134639 <= s_5528_4
        fn_state.gs_134639 = s_5528_4;
        // N s_5528_6: jump b359
        return block_359(state, tracer, fn_state);
    }
    fn block_5529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5529_0: read-var opc1:u8
        let s_5529_0: u8 = fn_state.opc1;
        // D s_5529_1: cast zx s_5529_0 -> bv
        let s_5529_1: Bits = Bits::new(s_5529_0 as u128, 3u16);
        // C s_5529_2: const #0u : u8
        let s_5529_2: u8 = 0;
        // C s_5529_3: cast zx s_5529_2 -> bv
        let s_5529_3: Bits = Bits::new(s_5529_2 as u128, 3u16);
        // D s_5529_4: cmp-eq s_5529_1 s_5529_3
        let s_5529_4: bool = ((s_5529_1) == (s_5529_3));
        // D s_5529_5: write-var gs#134638 <= s_5529_4
        fn_state.gs_134638 = s_5529_4;
        // N s_5529_6: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_5530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5530_0: read-var coproc:u8
        let s_5530_0: u8 = fn_state.coproc;
        // D s_5530_1: cast zx s_5530_0 -> bv
        let s_5530_1: Bits = Bits::new(s_5530_0 as u128, 4u16);
        // C s_5530_2: const #15u : u8
        let s_5530_2: u8 = 15;
        // C s_5530_3: cast zx s_5530_2 -> bv
        let s_5530_3: Bits = Bits::new(s_5530_2 as u128, 4u16);
        // D s_5530_4: cmp-eq s_5530_1 s_5530_3
        let s_5530_4: bool = ((s_5530_1) == (s_5530_3));
        // D s_5530_5: write-var gs#134637 <= s_5530_4
        fn_state.gs_134637 = s_5530_4;
        // N s_5530_6: jump b355
        return block_355(state, tracer, fn_state);
    }
    fn block_5531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5531_0: read-var CRn:u8
        let s_5531_0: u8 = fn_state.CRn;
        // D s_5531_1: cast zx s_5531_0 -> bv
        let s_5531_1: Bits = Bits::new(s_5531_0 as u128, 4u16);
        // C s_5531_2: const #10u : u8
        let s_5531_2: u8 = 10;
        // C s_5531_3: cast zx s_5531_2 -> bv
        let s_5531_3: Bits = Bits::new(s_5531_2 as u128, 4u16);
        // D s_5531_4: cmp-eq s_5531_1 s_5531_3
        let s_5531_4: bool = ((s_5531_1) == (s_5531_3));
        // D s_5531_5: write-var gs#134636 <= s_5531_4
        fn_state.gs_134636 = s_5531_4;
        // N s_5531_6: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_5532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5532_0: read-var el:u8
        let s_5532_0: u8 = fn_state.el;
        // D s_5532_1: read-var coproc:u8
        let s_5532_1: u8 = fn_state.coproc;
        // D s_5532_2: read-var opc1:u8
        let s_5532_2: u8 = fn_state.opc1;
        // D s_5532_3: read-var CRn:u8
        let s_5532_3: u8 = fn_state.CRn;
        // D s_5532_4: read-var opc2:u8
        let s_5532_4: u8 = fn_state.opc2;
        // D s_5532_5: read-var CRm:u8
        let s_5532_5: u8 = fn_state.CRm;
        // D s_5532_6: read-var t:i
        let s_5532_6: i128 = fn_state.t;
        // D s_5532_7: call ITLBIMVA_SysRegWrite32_ff4131cdf091f782(s_5532_0, s_5532_1, s_5532_2, s_5532_3, s_5532_4, s_5532_5, s_5532_6)
        let s_5532_7: () = ITLBIMVA_SysRegWrite32_ff4131cdf091f782(
            state,
            tracer,
            s_5532_0,
            s_5532_1,
            s_5532_2,
            s_5532_3,
            s_5532_4,
            s_5532_5,
            s_5532_6,
        );
        // N s_5532_8: return
        return;
    }
    fn block_5533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5533_0: read-var opc2:u8
        let s_5533_0: u8 = fn_state.opc2;
        // D s_5533_1: cast zx s_5533_0 -> bv
        let s_5533_1: Bits = Bits::new(s_5533_0 as u128, 3u16);
        // C s_5533_2: const #1u : u8
        let s_5533_2: u8 = 1;
        // C s_5533_3: cast zx s_5533_2 -> bv
        let s_5533_3: Bits = Bits::new(s_5533_2 as u128, 3u16);
        // D s_5533_4: cmp-eq s_5533_1 s_5533_3
        let s_5533_4: bool = ((s_5533_1) == (s_5533_3));
        // D s_5533_5: write-var gs#134635 <= s_5533_4
        fn_state.gs_134635 = s_5533_4;
        // N s_5533_6: jump b350
        return block_350(state, tracer, fn_state);
    }
    fn block_5534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5534_0: read-var opc1:u8
        let s_5534_0: u8 = fn_state.opc1;
        // D s_5534_1: cast zx s_5534_0 -> bv
        let s_5534_1: Bits = Bits::new(s_5534_0 as u128, 3u16);
        // C s_5534_2: const #0u : u8
        let s_5534_2: u8 = 0;
        // C s_5534_3: cast zx s_5534_2 -> bv
        let s_5534_3: Bits = Bits::new(s_5534_2 as u128, 3u16);
        // D s_5534_4: cmp-eq s_5534_1 s_5534_3
        let s_5534_4: bool = ((s_5534_1) == (s_5534_3));
        // D s_5534_5: write-var gs#134634 <= s_5534_4
        fn_state.gs_134634 = s_5534_4;
        // N s_5534_6: jump b348
        return block_348(state, tracer, fn_state);
    }
    fn block_5535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5535_0: read-var coproc:u8
        let s_5535_0: u8 = fn_state.coproc;
        // D s_5535_1: cast zx s_5535_0 -> bv
        let s_5535_1: Bits = Bits::new(s_5535_0 as u128, 4u16);
        // C s_5535_2: const #15u : u8
        let s_5535_2: u8 = 15;
        // C s_5535_3: cast zx s_5535_2 -> bv
        let s_5535_3: Bits = Bits::new(s_5535_2 as u128, 4u16);
        // D s_5535_4: cmp-eq s_5535_1 s_5535_3
        let s_5535_4: bool = ((s_5535_1) == (s_5535_3));
        // D s_5535_5: write-var gs#134633 <= s_5535_4
        fn_state.gs_134633 = s_5535_4;
        // N s_5535_6: jump b346
        return block_346(state, tracer, fn_state);
    }
    fn block_5536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5536_0: read-var CRn:u8
        let s_5536_0: u8 = fn_state.CRn;
        // D s_5536_1: cast zx s_5536_0 -> bv
        let s_5536_1: Bits = Bits::new(s_5536_0 as u128, 4u16);
        // C s_5536_2: const #8u : u8
        let s_5536_2: u8 = 8;
        // C s_5536_3: cast zx s_5536_2 -> bv
        let s_5536_3: Bits = Bits::new(s_5536_2 as u128, 4u16);
        // D s_5536_4: cmp-eq s_5536_1 s_5536_3
        let s_5536_4: bool = ((s_5536_1) == (s_5536_3));
        // D s_5536_5: write-var gs#134632 <= s_5536_4
        fn_state.gs_134632 = s_5536_4;
        // N s_5536_6: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_5537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5537_0: read-var el:u8
        let s_5537_0: u8 = fn_state.el;
        // D s_5537_1: read-var coproc:u8
        let s_5537_1: u8 = fn_state.coproc;
        // D s_5537_2: read-var opc1:u8
        let s_5537_2: u8 = fn_state.opc1;
        // D s_5537_3: read-var CRn:u8
        let s_5537_3: u8 = fn_state.CRn;
        // D s_5537_4: read-var opc2:u8
        let s_5537_4: u8 = fn_state.opc2;
        // D s_5537_5: read-var CRm:u8
        let s_5537_5: u8 = fn_state.CRm;
        // D s_5537_6: read-var t:i
        let s_5537_6: i128 = fn_state.t;
        // D s_5537_7: call ICV_IGRPEN0_SysRegWrite32_e641a403de7ed22c(s_5537_0, s_5537_1, s_5537_2, s_5537_3, s_5537_4, s_5537_5, s_5537_6)
        let s_5537_7: () = ICV_IGRPEN0_SysRegWrite32_e641a403de7ed22c(
            state,
            tracer,
            s_5537_0,
            s_5537_1,
            s_5537_2,
            s_5537_3,
            s_5537_4,
            s_5537_5,
            s_5537_6,
        );
        // N s_5537_8: return
        return;
    }
    fn block_5538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5538_0: read-var opc2:u8
        let s_5538_0: u8 = fn_state.opc2;
        // D s_5538_1: cast zx s_5538_0 -> bv
        let s_5538_1: Bits = Bits::new(s_5538_0 as u128, 3u16);
        // C s_5538_2: const #6u : u8
        let s_5538_2: u8 = 6;
        // C s_5538_3: cast zx s_5538_2 -> bv
        let s_5538_3: Bits = Bits::new(s_5538_2 as u128, 3u16);
        // D s_5538_4: cmp-eq s_5538_1 s_5538_3
        let s_5538_4: bool = ((s_5538_1) == (s_5538_3));
        // D s_5538_5: write-var gs#134631 <= s_5538_4
        fn_state.gs_134631 = s_5538_4;
        // N s_5538_6: jump b341
        return block_341(state, tracer, fn_state);
    }
    fn block_5539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5539_0: read-var opc1:u8
        let s_5539_0: u8 = fn_state.opc1;
        // D s_5539_1: cast zx s_5539_0 -> bv
        let s_5539_1: Bits = Bits::new(s_5539_0 as u128, 3u16);
        // C s_5539_2: const #0u : u8
        let s_5539_2: u8 = 0;
        // C s_5539_3: cast zx s_5539_2 -> bv
        let s_5539_3: Bits = Bits::new(s_5539_2 as u128, 3u16);
        // D s_5539_4: cmp-eq s_5539_1 s_5539_3
        let s_5539_4: bool = ((s_5539_1) == (s_5539_3));
        // D s_5539_5: write-var gs#134630 <= s_5539_4
        fn_state.gs_134630 = s_5539_4;
        // N s_5539_6: jump b339
        return block_339(state, tracer, fn_state);
    }
    fn block_5540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5540_0: read-var coproc:u8
        let s_5540_0: u8 = fn_state.coproc;
        // D s_5540_1: cast zx s_5540_0 -> bv
        let s_5540_1: Bits = Bits::new(s_5540_0 as u128, 4u16);
        // C s_5540_2: const #15u : u8
        let s_5540_2: u8 = 15;
        // C s_5540_3: cast zx s_5540_2 -> bv
        let s_5540_3: Bits = Bits::new(s_5540_2 as u128, 4u16);
        // D s_5540_4: cmp-eq s_5540_1 s_5540_3
        let s_5540_4: bool = ((s_5540_1) == (s_5540_3));
        // D s_5540_5: write-var gs#134629 <= s_5540_4
        fn_state.gs_134629 = s_5540_4;
        // N s_5540_6: jump b337
        return block_337(state, tracer, fn_state);
    }
    fn block_5541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5541_0: read-var CRn:u8
        let s_5541_0: u8 = fn_state.CRn;
        // D s_5541_1: cast zx s_5541_0 -> bv
        let s_5541_1: Bits = Bits::new(s_5541_0 as u128, 4u16);
        // C s_5541_2: const #12u : u8
        let s_5541_2: u8 = 12;
        // C s_5541_3: cast zx s_5541_2 -> bv
        let s_5541_3: Bits = Bits::new(s_5541_2 as u128, 4u16);
        // D s_5541_4: cmp-eq s_5541_1 s_5541_3
        let s_5541_4: bool = ((s_5541_1) == (s_5541_3));
        // D s_5541_5: write-var gs#134628 <= s_5541_4
        fn_state.gs_134628 = s_5541_4;
        // N s_5541_6: jump b335
        return block_335(state, tracer, fn_state);
    }
    fn block_5542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5542_0: read-var el:u8
        let s_5542_0: u8 = fn_state.el;
        // D s_5542_1: read-var coproc:u8
        let s_5542_1: u8 = fn_state.coproc;
        // D s_5542_2: read-var opc1:u8
        let s_5542_2: u8 = fn_state.opc1;
        // D s_5542_3: read-var CRn:u8
        let s_5542_3: u8 = fn_state.CRn;
        // D s_5542_4: read-var opc2:u8
        let s_5542_4: u8 = fn_state.opc2;
        // D s_5542_5: read-var CRm:u8
        let s_5542_5: u8 = fn_state.CRm;
        // D s_5542_6: read-var t:i
        let s_5542_6: i128 = fn_state.t;
        // D s_5542_7: call PMCNTENSET_SysRegWrite32_8b1fd246c8987e40(s_5542_0, s_5542_1, s_5542_2, s_5542_3, s_5542_4, s_5542_5, s_5542_6)
        let s_5542_7: () = PMCNTENSET_SysRegWrite32_8b1fd246c8987e40(
            state,
            tracer,
            s_5542_0,
            s_5542_1,
            s_5542_2,
            s_5542_3,
            s_5542_4,
            s_5542_5,
            s_5542_6,
        );
        // N s_5542_8: return
        return;
    }
    fn block_5543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5543_0: read-var opc2:u8
        let s_5543_0: u8 = fn_state.opc2;
        // D s_5543_1: cast zx s_5543_0 -> bv
        let s_5543_1: Bits = Bits::new(s_5543_0 as u128, 3u16);
        // C s_5543_2: const #1u : u8
        let s_5543_2: u8 = 1;
        // C s_5543_3: cast zx s_5543_2 -> bv
        let s_5543_3: Bits = Bits::new(s_5543_2 as u128, 3u16);
        // D s_5543_4: cmp-eq s_5543_1 s_5543_3
        let s_5543_4: bool = ((s_5543_1) == (s_5543_3));
        // D s_5543_5: write-var gs#134627 <= s_5543_4
        fn_state.gs_134627 = s_5543_4;
        // N s_5543_6: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_5544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5544_0: read-var opc1:u8
        let s_5544_0: u8 = fn_state.opc1;
        // D s_5544_1: cast zx s_5544_0 -> bv
        let s_5544_1: Bits = Bits::new(s_5544_0 as u128, 3u16);
        // C s_5544_2: const #0u : u8
        let s_5544_2: u8 = 0;
        // C s_5544_3: cast zx s_5544_2 -> bv
        let s_5544_3: Bits = Bits::new(s_5544_2 as u128, 3u16);
        // D s_5544_4: cmp-eq s_5544_1 s_5544_3
        let s_5544_4: bool = ((s_5544_1) == (s_5544_3));
        // D s_5544_5: write-var gs#134626 <= s_5544_4
        fn_state.gs_134626 = s_5544_4;
        // N s_5544_6: jump b330
        return block_330(state, tracer, fn_state);
    }
    fn block_5545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5545_0: read-var coproc:u8
        let s_5545_0: u8 = fn_state.coproc;
        // D s_5545_1: cast zx s_5545_0 -> bv
        let s_5545_1: Bits = Bits::new(s_5545_0 as u128, 4u16);
        // C s_5545_2: const #15u : u8
        let s_5545_2: u8 = 15;
        // C s_5545_3: cast zx s_5545_2 -> bv
        let s_5545_3: Bits = Bits::new(s_5545_2 as u128, 4u16);
        // D s_5545_4: cmp-eq s_5545_1 s_5545_3
        let s_5545_4: bool = ((s_5545_1) == (s_5545_3));
        // D s_5545_5: write-var gs#134625 <= s_5545_4
        fn_state.gs_134625 = s_5545_4;
        // N s_5545_6: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_5546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5546_0: read-var CRn:u8
        let s_5546_0: u8 = fn_state.CRn;
        // D s_5546_1: cast zx s_5546_0 -> bv
        let s_5546_1: Bits = Bits::new(s_5546_0 as u128, 4u16);
        // C s_5546_2: const #9u : u8
        let s_5546_2: u8 = 9;
        // C s_5546_3: cast zx s_5546_2 -> bv
        let s_5546_3: Bits = Bits::new(s_5546_2 as u128, 4u16);
        // D s_5546_4: cmp-eq s_5546_1 s_5546_3
        let s_5546_4: bool = ((s_5546_1) == (s_5546_3));
        // D s_5546_5: write-var gs#134624 <= s_5546_4
        fn_state.gs_134624 = s_5546_4;
        // N s_5546_6: jump b326
        return block_326(state, tracer, fn_state);
    }
    fn block_5547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5547_0: read-var el:u8
        let s_5547_0: u8 = fn_state.el;
        // D s_5547_1: read-var coproc:u8
        let s_5547_1: u8 = fn_state.coproc;
        // D s_5547_2: read-var opc1:u8
        let s_5547_2: u8 = fn_state.opc1;
        // D s_5547_3: read-var CRn:u8
        let s_5547_3: u8 = fn_state.CRn;
        // D s_5547_4: read-var opc2:u8
        let s_5547_4: u8 = fn_state.opc2;
        // D s_5547_5: read-var CRm:u8
        let s_5547_5: u8 = fn_state.CRm;
        // D s_5547_6: read-var t:i
        let s_5547_6: i128 = fn_state.t;
        // D s_5547_7: call ATS12NSOPR_SysRegWrite32_29b73e1bf71ad72e(s_5547_0, s_5547_1, s_5547_2, s_5547_3, s_5547_4, s_5547_5, s_5547_6)
        let s_5547_7: () = ATS12NSOPR_SysRegWrite32_29b73e1bf71ad72e(
            state,
            tracer,
            s_5547_0,
            s_5547_1,
            s_5547_2,
            s_5547_3,
            s_5547_4,
            s_5547_5,
            s_5547_6,
        );
        // N s_5547_8: return
        return;
    }
    fn block_5548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5548_0: read-var opc2:u8
        let s_5548_0: u8 = fn_state.opc2;
        // D s_5548_1: cast zx s_5548_0 -> bv
        let s_5548_1: Bits = Bits::new(s_5548_0 as u128, 3u16);
        // C s_5548_2: const #4u : u8
        let s_5548_2: u8 = 4;
        // C s_5548_3: cast zx s_5548_2 -> bv
        let s_5548_3: Bits = Bits::new(s_5548_2 as u128, 3u16);
        // D s_5548_4: cmp-eq s_5548_1 s_5548_3
        let s_5548_4: bool = ((s_5548_1) == (s_5548_3));
        // D s_5548_5: write-var gs#134623 <= s_5548_4
        fn_state.gs_134623 = s_5548_4;
        // N s_5548_6: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_5549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5549_0: read-var opc1:u8
        let s_5549_0: u8 = fn_state.opc1;
        // D s_5549_1: cast zx s_5549_0 -> bv
        let s_5549_1: Bits = Bits::new(s_5549_0 as u128, 3u16);
        // C s_5549_2: const #0u : u8
        let s_5549_2: u8 = 0;
        // C s_5549_3: cast zx s_5549_2 -> bv
        let s_5549_3: Bits = Bits::new(s_5549_2 as u128, 3u16);
        // D s_5549_4: cmp-eq s_5549_1 s_5549_3
        let s_5549_4: bool = ((s_5549_1) == (s_5549_3));
        // D s_5549_5: write-var gs#134622 <= s_5549_4
        fn_state.gs_134622 = s_5549_4;
        // N s_5549_6: jump b321
        return block_321(state, tracer, fn_state);
    }
    fn block_5550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5550_0: read-var coproc:u8
        let s_5550_0: u8 = fn_state.coproc;
        // D s_5550_1: cast zx s_5550_0 -> bv
        let s_5550_1: Bits = Bits::new(s_5550_0 as u128, 4u16);
        // C s_5550_2: const #15u : u8
        let s_5550_2: u8 = 15;
        // C s_5550_3: cast zx s_5550_2 -> bv
        let s_5550_3: Bits = Bits::new(s_5550_2 as u128, 4u16);
        // D s_5550_4: cmp-eq s_5550_1 s_5550_3
        let s_5550_4: bool = ((s_5550_1) == (s_5550_3));
        // D s_5550_5: write-var gs#134621 <= s_5550_4
        fn_state.gs_134621 = s_5550_4;
        // N s_5550_6: jump b319
        return block_319(state, tracer, fn_state);
    }
    fn block_5551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5551_0: read-var CRn:u8
        let s_5551_0: u8 = fn_state.CRn;
        // D s_5551_1: cast zx s_5551_0 -> bv
        let s_5551_1: Bits = Bits::new(s_5551_0 as u128, 4u16);
        // C s_5551_2: const #7u : u8
        let s_5551_2: u8 = 7;
        // C s_5551_3: cast zx s_5551_2 -> bv
        let s_5551_3: Bits = Bits::new(s_5551_2 as u128, 4u16);
        // D s_5551_4: cmp-eq s_5551_1 s_5551_3
        let s_5551_4: bool = ((s_5551_1) == (s_5551_3));
        // D s_5551_5: write-var gs#134620 <= s_5551_4
        fn_state.gs_134620 = s_5551_4;
        // N s_5551_6: jump b317
        return block_317(state, tracer, fn_state);
    }
    fn block_5552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5552_0: read-var el:u8
        let s_5552_0: u8 = fn_state.el;
        // D s_5552_1: read-var coproc:u8
        let s_5552_1: u8 = fn_state.coproc;
        // D s_5552_2: read-var opc1:u8
        let s_5552_2: u8 = fn_state.opc1;
        // D s_5552_3: read-var CRn:u8
        let s_5552_3: u8 = fn_state.CRn;
        // D s_5552_4: read-var opc2:u8
        let s_5552_4: u8 = fn_state.opc2;
        // D s_5552_5: read-var CRm:u8
        let s_5552_5: u8 = fn_state.CRm;
        // D s_5552_6: read-var t:i
        let s_5552_6: i128 = fn_state.t;
        // D s_5552_7: call DBGBVR_SysRegWrite32_f6af3de5c6306a23(s_5552_0, s_5552_1, s_5552_2, s_5552_3, s_5552_4, s_5552_5, s_5552_6)
        let s_5552_7: () = DBGBVR_SysRegWrite32_f6af3de5c6306a23(
            state,
            tracer,
            s_5552_0,
            s_5552_1,
            s_5552_2,
            s_5552_3,
            s_5552_4,
            s_5552_5,
            s_5552_6,
        );
        // N s_5552_8: return
        return;
    }
    fn block_5553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5553_0: read-var opc2:u8
        let s_5553_0: u8 = fn_state.opc2;
        // D s_5553_1: cast zx s_5553_0 -> bv
        let s_5553_1: Bits = Bits::new(s_5553_0 as u128, 3u16);
        // C s_5553_2: const #4u : u8
        let s_5553_2: u8 = 4;
        // C s_5553_3: cast zx s_5553_2 -> bv
        let s_5553_3: Bits = Bits::new(s_5553_2 as u128, 3u16);
        // D s_5553_4: cmp-eq s_5553_1 s_5553_3
        let s_5553_4: bool = ((s_5553_1) == (s_5553_3));
        // D s_5553_5: write-var gs#134619 <= s_5553_4
        fn_state.gs_134619 = s_5553_4;
        // N s_5553_6: jump b314
        return block_314(state, tracer, fn_state);
    }
    fn block_5554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5554_0: read-var opc1:u8
        let s_5554_0: u8 = fn_state.opc1;
        // D s_5554_1: cast zx s_5554_0 -> bv
        let s_5554_1: Bits = Bits::new(s_5554_0 as u128, 3u16);
        // C s_5554_2: const #0u : u8
        let s_5554_2: u8 = 0;
        // C s_5554_3: cast zx s_5554_2 -> bv
        let s_5554_3: Bits = Bits::new(s_5554_2 as u128, 3u16);
        // D s_5554_4: cmp-eq s_5554_1 s_5554_3
        let s_5554_4: bool = ((s_5554_1) == (s_5554_3));
        // D s_5554_5: write-var gs#134618 <= s_5554_4
        fn_state.gs_134618 = s_5554_4;
        // N s_5554_6: jump b312
        return block_312(state, tracer, fn_state);
    }
    fn block_5555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5555_0: read-var coproc:u8
        let s_5555_0: u8 = fn_state.coproc;
        // D s_5555_1: cast zx s_5555_0 -> bv
        let s_5555_1: Bits = Bits::new(s_5555_0 as u128, 4u16);
        // C s_5555_2: const #14u : u8
        let s_5555_2: u8 = 14;
        // C s_5555_3: cast zx s_5555_2 -> bv
        let s_5555_3: Bits = Bits::new(s_5555_2 as u128, 4u16);
        // D s_5555_4: cmp-eq s_5555_1 s_5555_3
        let s_5555_4: bool = ((s_5555_1) == (s_5555_3));
        // D s_5555_5: write-var gs#134617 <= s_5555_4
        fn_state.gs_134617 = s_5555_4;
        // N s_5555_6: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_5556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5556_0: read-var CRn:u8
        let s_5556_0: u8 = fn_state.CRn;
        // D s_5556_1: cast zx s_5556_0 -> bv
        let s_5556_1: Bits = Bits::new(s_5556_0 as u128, 4u16);
        // C s_5556_2: const #0u : u8
        let s_5556_2: u8 = 0;
        // C s_5556_3: cast zx s_5556_2 -> bv
        let s_5556_3: Bits = Bits::new(s_5556_2 as u128, 4u16);
        // D s_5556_4: cmp-eq s_5556_1 s_5556_3
        let s_5556_4: bool = ((s_5556_1) == (s_5556_3));
        // D s_5556_5: write-var gs#134616 <= s_5556_4
        fn_state.gs_134616 = s_5556_4;
        // N s_5556_6: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_5557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5557_0: read-var el:u8
        let s_5557_0: u8 = fn_state.el;
        // D s_5557_1: read-var coproc:u8
        let s_5557_1: u8 = fn_state.coproc;
        // D s_5557_2: read-var opc1:u8
        let s_5557_2: u8 = fn_state.opc1;
        // D s_5557_3: read-var CRn:u8
        let s_5557_3: u8 = fn_state.CRn;
        // D s_5557_4: read-var opc2:u8
        let s_5557_4: u8 = fn_state.opc2;
        // D s_5557_5: read-var CRm:u8
        let s_5557_5: u8 = fn_state.CRm;
        // D s_5557_6: read-var t:i
        let s_5557_6: i128 = fn_state.t;
        // D s_5557_7: call DBGBVR_SysRegWrite32_1cb9715dee8f1c1b(s_5557_0, s_5557_1, s_5557_2, s_5557_3, s_5557_4, s_5557_5, s_5557_6)
        let s_5557_7: () = DBGBVR_SysRegWrite32_1cb9715dee8f1c1b(
            state,
            tracer,
            s_5557_0,
            s_5557_1,
            s_5557_2,
            s_5557_3,
            s_5557_4,
            s_5557_5,
            s_5557_6,
        );
        // N s_5557_8: return
        return;
    }
    fn block_5558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5558_0: read-var opc2:u8
        let s_5558_0: u8 = fn_state.opc2;
        // D s_5558_1: cast zx s_5558_0 -> bv
        let s_5558_1: Bits = Bits::new(s_5558_0 as u128, 3u16);
        // C s_5558_2: const #4u : u8
        let s_5558_2: u8 = 4;
        // C s_5558_3: cast zx s_5558_2 -> bv
        let s_5558_3: Bits = Bits::new(s_5558_2 as u128, 3u16);
        // D s_5558_4: cmp-eq s_5558_1 s_5558_3
        let s_5558_4: bool = ((s_5558_1) == (s_5558_3));
        // D s_5558_5: write-var gs#134615 <= s_5558_4
        fn_state.gs_134615 = s_5558_4;
        // N s_5558_6: jump b305
        return block_305(state, tracer, fn_state);
    }
    fn block_5559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5559_0: read-var opc1:u8
        let s_5559_0: u8 = fn_state.opc1;
        // D s_5559_1: cast zx s_5559_0 -> bv
        let s_5559_1: Bits = Bits::new(s_5559_0 as u128, 3u16);
        // C s_5559_2: const #0u : u8
        let s_5559_2: u8 = 0;
        // C s_5559_3: cast zx s_5559_2 -> bv
        let s_5559_3: Bits = Bits::new(s_5559_2 as u128, 3u16);
        // D s_5559_4: cmp-eq s_5559_1 s_5559_3
        let s_5559_4: bool = ((s_5559_1) == (s_5559_3));
        // D s_5559_5: write-var gs#134614 <= s_5559_4
        fn_state.gs_134614 = s_5559_4;
        // N s_5559_6: jump b303
        return block_303(state, tracer, fn_state);
    }
    fn block_5560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5560_0: read-var coproc:u8
        let s_5560_0: u8 = fn_state.coproc;
        // D s_5560_1: cast zx s_5560_0 -> bv
        let s_5560_1: Bits = Bits::new(s_5560_0 as u128, 4u16);
        // C s_5560_2: const #14u : u8
        let s_5560_2: u8 = 14;
        // C s_5560_3: cast zx s_5560_2 -> bv
        let s_5560_3: Bits = Bits::new(s_5560_2 as u128, 4u16);
        // D s_5560_4: cmp-eq s_5560_1 s_5560_3
        let s_5560_4: bool = ((s_5560_1) == (s_5560_3));
        // D s_5560_5: write-var gs#134613 <= s_5560_4
        fn_state.gs_134613 = s_5560_4;
        // N s_5560_6: jump b301
        return block_301(state, tracer, fn_state);
    }
    fn block_5561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5561_0: read-var CRn:u8
        let s_5561_0: u8 = fn_state.CRn;
        // D s_5561_1: cast zx s_5561_0 -> bv
        let s_5561_1: Bits = Bits::new(s_5561_0 as u128, 4u16);
        // C s_5561_2: const #0u : u8
        let s_5561_2: u8 = 0;
        // C s_5561_3: cast zx s_5561_2 -> bv
        let s_5561_3: Bits = Bits::new(s_5561_2 as u128, 4u16);
        // D s_5561_4: cmp-eq s_5561_1 s_5561_3
        let s_5561_4: bool = ((s_5561_1) == (s_5561_3));
        // D s_5561_5: write-var gs#134612 <= s_5561_4
        fn_state.gs_134612 = s_5561_4;
        // N s_5561_6: jump b299
        return block_299(state, tracer, fn_state);
    }
    fn block_5562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5562_0: read-var el:u8
        let s_5562_0: u8 = fn_state.el;
        // D s_5562_1: read-var coproc:u8
        let s_5562_1: u8 = fn_state.coproc;
        // D s_5562_2: read-var opc1:u8
        let s_5562_2: u8 = fn_state.opc1;
        // D s_5562_3: read-var CRn:u8
        let s_5562_3: u8 = fn_state.CRn;
        // D s_5562_4: read-var opc2:u8
        let s_5562_4: u8 = fn_state.opc2;
        // D s_5562_5: read-var CRm:u8
        let s_5562_5: u8 = fn_state.CRm;
        // D s_5562_6: read-var t:i
        let s_5562_6: i128 = fn_state.t;
        // D s_5562_7: call DBGBVR_SysRegWrite32_3fd7a5cc9728d4be(s_5562_0, s_5562_1, s_5562_2, s_5562_3, s_5562_4, s_5562_5, s_5562_6)
        let s_5562_7: () = DBGBVR_SysRegWrite32_3fd7a5cc9728d4be(
            state,
            tracer,
            s_5562_0,
            s_5562_1,
            s_5562_2,
            s_5562_3,
            s_5562_4,
            s_5562_5,
            s_5562_6,
        );
        // N s_5562_8: return
        return;
    }
    fn block_5563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5563_0: read-var opc2:u8
        let s_5563_0: u8 = fn_state.opc2;
        // D s_5563_1: cast zx s_5563_0 -> bv
        let s_5563_1: Bits = Bits::new(s_5563_0 as u128, 3u16);
        // C s_5563_2: const #4u : u8
        let s_5563_2: u8 = 4;
        // C s_5563_3: cast zx s_5563_2 -> bv
        let s_5563_3: Bits = Bits::new(s_5563_2 as u128, 3u16);
        // D s_5563_4: cmp-eq s_5563_1 s_5563_3
        let s_5563_4: bool = ((s_5563_1) == (s_5563_3));
        // D s_5563_5: write-var gs#134611 <= s_5563_4
        fn_state.gs_134611 = s_5563_4;
        // N s_5563_6: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_5564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5564_0: read-var opc1:u8
        let s_5564_0: u8 = fn_state.opc1;
        // D s_5564_1: cast zx s_5564_0 -> bv
        let s_5564_1: Bits = Bits::new(s_5564_0 as u128, 3u16);
        // C s_5564_2: const #0u : u8
        let s_5564_2: u8 = 0;
        // C s_5564_3: cast zx s_5564_2 -> bv
        let s_5564_3: Bits = Bits::new(s_5564_2 as u128, 3u16);
        // D s_5564_4: cmp-eq s_5564_1 s_5564_3
        let s_5564_4: bool = ((s_5564_1) == (s_5564_3));
        // D s_5564_5: write-var gs#134610 <= s_5564_4
        fn_state.gs_134610 = s_5564_4;
        // N s_5564_6: jump b294
        return block_294(state, tracer, fn_state);
    }
    fn block_5565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5565_0: read-var coproc:u8
        let s_5565_0: u8 = fn_state.coproc;
        // D s_5565_1: cast zx s_5565_0 -> bv
        let s_5565_1: Bits = Bits::new(s_5565_0 as u128, 4u16);
        // C s_5565_2: const #14u : u8
        let s_5565_2: u8 = 14;
        // C s_5565_3: cast zx s_5565_2 -> bv
        let s_5565_3: Bits = Bits::new(s_5565_2 as u128, 4u16);
        // D s_5565_4: cmp-eq s_5565_1 s_5565_3
        let s_5565_4: bool = ((s_5565_1) == (s_5565_3));
        // D s_5565_5: write-var gs#134609 <= s_5565_4
        fn_state.gs_134609 = s_5565_4;
        // N s_5565_6: jump b292
        return block_292(state, tracer, fn_state);
    }
    fn block_5566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5566_0: read-var CRn:u8
        let s_5566_0: u8 = fn_state.CRn;
        // D s_5566_1: cast zx s_5566_0 -> bv
        let s_5566_1: Bits = Bits::new(s_5566_0 as u128, 4u16);
        // C s_5566_2: const #0u : u8
        let s_5566_2: u8 = 0;
        // C s_5566_3: cast zx s_5566_2 -> bv
        let s_5566_3: Bits = Bits::new(s_5566_2 as u128, 4u16);
        // D s_5566_4: cmp-eq s_5566_1 s_5566_3
        let s_5566_4: bool = ((s_5566_1) == (s_5566_3));
        // D s_5566_5: write-var gs#134608 <= s_5566_4
        fn_state.gs_134608 = s_5566_4;
        // N s_5566_6: jump b290
        return block_290(state, tracer, fn_state);
    }
    fn block_5567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5567_0: read-var el:u8
        let s_5567_0: u8 = fn_state.el;
        // D s_5567_1: read-var coproc:u8
        let s_5567_1: u8 = fn_state.coproc;
        // D s_5567_2: read-var opc1:u8
        let s_5567_2: u8 = fn_state.opc1;
        // D s_5567_3: read-var CRn:u8
        let s_5567_3: u8 = fn_state.CRn;
        // D s_5567_4: read-var opc2:u8
        let s_5567_4: u8 = fn_state.opc2;
        // D s_5567_5: read-var CRm:u8
        let s_5567_5: u8 = fn_state.CRm;
        // D s_5567_6: read-var t:i
        let s_5567_6: i128 = fn_state.t;
        // D s_5567_7: call DBGBVR_SysRegWrite32_093d01ccd680c913(s_5567_0, s_5567_1, s_5567_2, s_5567_3, s_5567_4, s_5567_5, s_5567_6)
        let s_5567_7: () = DBGBVR_SysRegWrite32_093d01ccd680c913(
            state,
            tracer,
            s_5567_0,
            s_5567_1,
            s_5567_2,
            s_5567_3,
            s_5567_4,
            s_5567_5,
            s_5567_6,
        );
        // N s_5567_8: return
        return;
    }
    fn block_5568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5568_0: read-var opc2:u8
        let s_5568_0: u8 = fn_state.opc2;
        // D s_5568_1: cast zx s_5568_0 -> bv
        let s_5568_1: Bits = Bits::new(s_5568_0 as u128, 3u16);
        // C s_5568_2: const #4u : u8
        let s_5568_2: u8 = 4;
        // C s_5568_3: cast zx s_5568_2 -> bv
        let s_5568_3: Bits = Bits::new(s_5568_2 as u128, 3u16);
        // D s_5568_4: cmp-eq s_5568_1 s_5568_3
        let s_5568_4: bool = ((s_5568_1) == (s_5568_3));
        // D s_5568_5: write-var gs#134607 <= s_5568_4
        fn_state.gs_134607 = s_5568_4;
        // N s_5568_6: jump b287
        return block_287(state, tracer, fn_state);
    }
    fn block_5569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5569_0: read-var opc1:u8
        let s_5569_0: u8 = fn_state.opc1;
        // D s_5569_1: cast zx s_5569_0 -> bv
        let s_5569_1: Bits = Bits::new(s_5569_0 as u128, 3u16);
        // C s_5569_2: const #0u : u8
        let s_5569_2: u8 = 0;
        // C s_5569_3: cast zx s_5569_2 -> bv
        let s_5569_3: Bits = Bits::new(s_5569_2 as u128, 3u16);
        // D s_5569_4: cmp-eq s_5569_1 s_5569_3
        let s_5569_4: bool = ((s_5569_1) == (s_5569_3));
        // D s_5569_5: write-var gs#134606 <= s_5569_4
        fn_state.gs_134606 = s_5569_4;
        // N s_5569_6: jump b285
        return block_285(state, tracer, fn_state);
    }
    fn block_5570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5570_0: read-var coproc:u8
        let s_5570_0: u8 = fn_state.coproc;
        // D s_5570_1: cast zx s_5570_0 -> bv
        let s_5570_1: Bits = Bits::new(s_5570_0 as u128, 4u16);
        // C s_5570_2: const #14u : u8
        let s_5570_2: u8 = 14;
        // C s_5570_3: cast zx s_5570_2 -> bv
        let s_5570_3: Bits = Bits::new(s_5570_2 as u128, 4u16);
        // D s_5570_4: cmp-eq s_5570_1 s_5570_3
        let s_5570_4: bool = ((s_5570_1) == (s_5570_3));
        // D s_5570_5: write-var gs#134605 <= s_5570_4
        fn_state.gs_134605 = s_5570_4;
        // N s_5570_6: jump b283
        return block_283(state, tracer, fn_state);
    }
    fn block_5571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5571_0: read-var CRn:u8
        let s_5571_0: u8 = fn_state.CRn;
        // D s_5571_1: cast zx s_5571_0 -> bv
        let s_5571_1: Bits = Bits::new(s_5571_0 as u128, 4u16);
        // C s_5571_2: const #0u : u8
        let s_5571_2: u8 = 0;
        // C s_5571_3: cast zx s_5571_2 -> bv
        let s_5571_3: Bits = Bits::new(s_5571_2 as u128, 4u16);
        // D s_5571_4: cmp-eq s_5571_1 s_5571_3
        let s_5571_4: bool = ((s_5571_1) == (s_5571_3));
        // D s_5571_5: write-var gs#134604 <= s_5571_4
        fn_state.gs_134604 = s_5571_4;
        // N s_5571_6: jump b281
        return block_281(state, tracer, fn_state);
    }
    fn block_5572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5572_0: read-var el:u8
        let s_5572_0: u8 = fn_state.el;
        // D s_5572_1: read-var coproc:u8
        let s_5572_1: u8 = fn_state.coproc;
        // D s_5572_2: read-var opc1:u8
        let s_5572_2: u8 = fn_state.opc1;
        // D s_5572_3: read-var CRn:u8
        let s_5572_3: u8 = fn_state.CRn;
        // D s_5572_4: read-var opc2:u8
        let s_5572_4: u8 = fn_state.opc2;
        // D s_5572_5: read-var CRm:u8
        let s_5572_5: u8 = fn_state.CRm;
        // D s_5572_6: read-var t:i
        let s_5572_6: i128 = fn_state.t;
        // D s_5572_7: call DBGBVR_SysRegWrite32_eb8ac00541cce6a9(s_5572_0, s_5572_1, s_5572_2, s_5572_3, s_5572_4, s_5572_5, s_5572_6)
        let s_5572_7: () = DBGBVR_SysRegWrite32_eb8ac00541cce6a9(
            state,
            tracer,
            s_5572_0,
            s_5572_1,
            s_5572_2,
            s_5572_3,
            s_5572_4,
            s_5572_5,
            s_5572_6,
        );
        // N s_5572_8: return
        return;
    }
    fn block_5573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5573_0: read-var opc2:u8
        let s_5573_0: u8 = fn_state.opc2;
        // D s_5573_1: cast zx s_5573_0 -> bv
        let s_5573_1: Bits = Bits::new(s_5573_0 as u128, 3u16);
        // C s_5573_2: const #4u : u8
        let s_5573_2: u8 = 4;
        // C s_5573_3: cast zx s_5573_2 -> bv
        let s_5573_3: Bits = Bits::new(s_5573_2 as u128, 3u16);
        // D s_5573_4: cmp-eq s_5573_1 s_5573_3
        let s_5573_4: bool = ((s_5573_1) == (s_5573_3));
        // D s_5573_5: write-var gs#134603 <= s_5573_4
        fn_state.gs_134603 = s_5573_4;
        // N s_5573_6: jump b278
        return block_278(state, tracer, fn_state);
    }
    fn block_5574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5574_0: read-var opc1:u8
        let s_5574_0: u8 = fn_state.opc1;
        // D s_5574_1: cast zx s_5574_0 -> bv
        let s_5574_1: Bits = Bits::new(s_5574_0 as u128, 3u16);
        // C s_5574_2: const #0u : u8
        let s_5574_2: u8 = 0;
        // C s_5574_3: cast zx s_5574_2 -> bv
        let s_5574_3: Bits = Bits::new(s_5574_2 as u128, 3u16);
        // D s_5574_4: cmp-eq s_5574_1 s_5574_3
        let s_5574_4: bool = ((s_5574_1) == (s_5574_3));
        // D s_5574_5: write-var gs#134602 <= s_5574_4
        fn_state.gs_134602 = s_5574_4;
        // N s_5574_6: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_5575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5575_0: read-var coproc:u8
        let s_5575_0: u8 = fn_state.coproc;
        // D s_5575_1: cast zx s_5575_0 -> bv
        let s_5575_1: Bits = Bits::new(s_5575_0 as u128, 4u16);
        // C s_5575_2: const #14u : u8
        let s_5575_2: u8 = 14;
        // C s_5575_3: cast zx s_5575_2 -> bv
        let s_5575_3: Bits = Bits::new(s_5575_2 as u128, 4u16);
        // D s_5575_4: cmp-eq s_5575_1 s_5575_3
        let s_5575_4: bool = ((s_5575_1) == (s_5575_3));
        // D s_5575_5: write-var gs#134601 <= s_5575_4
        fn_state.gs_134601 = s_5575_4;
        // N s_5575_6: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_5576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5576_0: read-var CRn:u8
        let s_5576_0: u8 = fn_state.CRn;
        // D s_5576_1: cast zx s_5576_0 -> bv
        let s_5576_1: Bits = Bits::new(s_5576_0 as u128, 4u16);
        // C s_5576_2: const #0u : u8
        let s_5576_2: u8 = 0;
        // C s_5576_3: cast zx s_5576_2 -> bv
        let s_5576_3: Bits = Bits::new(s_5576_2 as u128, 4u16);
        // D s_5576_4: cmp-eq s_5576_1 s_5576_3
        let s_5576_4: bool = ((s_5576_1) == (s_5576_3));
        // D s_5576_5: write-var gs#134600 <= s_5576_4
        fn_state.gs_134600 = s_5576_4;
        // N s_5576_6: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_5577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5577_0: read-var el:u8
        let s_5577_0: u8 = fn_state.el;
        // D s_5577_1: read-var coproc:u8
        let s_5577_1: u8 = fn_state.coproc;
        // D s_5577_2: read-var opc1:u8
        let s_5577_2: u8 = fn_state.opc1;
        // D s_5577_3: read-var CRn:u8
        let s_5577_3: u8 = fn_state.CRn;
        // D s_5577_4: read-var opc2:u8
        let s_5577_4: u8 = fn_state.opc2;
        // D s_5577_5: read-var CRm:u8
        let s_5577_5: u8 = fn_state.CRm;
        // D s_5577_6: read-var t:i
        let s_5577_6: i128 = fn_state.t;
        // D s_5577_7: call DBGBVR_SysRegWrite32_2e65ad9d6a265c11(s_5577_0, s_5577_1, s_5577_2, s_5577_3, s_5577_4, s_5577_5, s_5577_6)
        let s_5577_7: () = DBGBVR_SysRegWrite32_2e65ad9d6a265c11(
            state,
            tracer,
            s_5577_0,
            s_5577_1,
            s_5577_2,
            s_5577_3,
            s_5577_4,
            s_5577_5,
            s_5577_6,
        );
        // N s_5577_8: return
        return;
    }
    fn block_5578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5578_0: read-var opc2:u8
        let s_5578_0: u8 = fn_state.opc2;
        // D s_5578_1: cast zx s_5578_0 -> bv
        let s_5578_1: Bits = Bits::new(s_5578_0 as u128, 3u16);
        // C s_5578_2: const #4u : u8
        let s_5578_2: u8 = 4;
        // C s_5578_3: cast zx s_5578_2 -> bv
        let s_5578_3: Bits = Bits::new(s_5578_2 as u128, 3u16);
        // D s_5578_4: cmp-eq s_5578_1 s_5578_3
        let s_5578_4: bool = ((s_5578_1) == (s_5578_3));
        // D s_5578_5: write-var gs#134599 <= s_5578_4
        fn_state.gs_134599 = s_5578_4;
        // N s_5578_6: jump b269
        return block_269(state, tracer, fn_state);
    }
    fn block_5579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5579_0: read-var opc1:u8
        let s_5579_0: u8 = fn_state.opc1;
        // D s_5579_1: cast zx s_5579_0 -> bv
        let s_5579_1: Bits = Bits::new(s_5579_0 as u128, 3u16);
        // C s_5579_2: const #0u : u8
        let s_5579_2: u8 = 0;
        // C s_5579_3: cast zx s_5579_2 -> bv
        let s_5579_3: Bits = Bits::new(s_5579_2 as u128, 3u16);
        // D s_5579_4: cmp-eq s_5579_1 s_5579_3
        let s_5579_4: bool = ((s_5579_1) == (s_5579_3));
        // D s_5579_5: write-var gs#134598 <= s_5579_4
        fn_state.gs_134598 = s_5579_4;
        // N s_5579_6: jump b267
        return block_267(state, tracer, fn_state);
    }
    fn block_5580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5580_0: read-var coproc:u8
        let s_5580_0: u8 = fn_state.coproc;
        // D s_5580_1: cast zx s_5580_0 -> bv
        let s_5580_1: Bits = Bits::new(s_5580_0 as u128, 4u16);
        // C s_5580_2: const #14u : u8
        let s_5580_2: u8 = 14;
        // C s_5580_3: cast zx s_5580_2 -> bv
        let s_5580_3: Bits = Bits::new(s_5580_2 as u128, 4u16);
        // D s_5580_4: cmp-eq s_5580_1 s_5580_3
        let s_5580_4: bool = ((s_5580_1) == (s_5580_3));
        // D s_5580_5: write-var gs#134597 <= s_5580_4
        fn_state.gs_134597 = s_5580_4;
        // N s_5580_6: jump b265
        return block_265(state, tracer, fn_state);
    }
    fn block_5581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5581_0: read-var CRn:u8
        let s_5581_0: u8 = fn_state.CRn;
        // D s_5581_1: cast zx s_5581_0 -> bv
        let s_5581_1: Bits = Bits::new(s_5581_0 as u128, 4u16);
        // C s_5581_2: const #0u : u8
        let s_5581_2: u8 = 0;
        // C s_5581_3: cast zx s_5581_2 -> bv
        let s_5581_3: Bits = Bits::new(s_5581_2 as u128, 4u16);
        // D s_5581_4: cmp-eq s_5581_1 s_5581_3
        let s_5581_4: bool = ((s_5581_1) == (s_5581_3));
        // D s_5581_5: write-var gs#134596 <= s_5581_4
        fn_state.gs_134596 = s_5581_4;
        // N s_5581_6: jump b263
        return block_263(state, tracer, fn_state);
    }
    fn block_5582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5582_0: read-var el:u8
        let s_5582_0: u8 = fn_state.el;
        // D s_5582_1: read-var coproc:u8
        let s_5582_1: u8 = fn_state.coproc;
        // D s_5582_2: read-var opc1:u8
        let s_5582_2: u8 = fn_state.opc1;
        // D s_5582_3: read-var CRn:u8
        let s_5582_3: u8 = fn_state.CRn;
        // D s_5582_4: read-var opc2:u8
        let s_5582_4: u8 = fn_state.opc2;
        // D s_5582_5: read-var CRm:u8
        let s_5582_5: u8 = fn_state.CRm;
        // D s_5582_6: read-var t:i
        let s_5582_6: i128 = fn_state.t;
        // D s_5582_7: call DBGBVR_SysRegWrite32_43f4c896c92f0d6b(s_5582_0, s_5582_1, s_5582_2, s_5582_3, s_5582_4, s_5582_5, s_5582_6)
        let s_5582_7: () = DBGBVR_SysRegWrite32_43f4c896c92f0d6b(
            state,
            tracer,
            s_5582_0,
            s_5582_1,
            s_5582_2,
            s_5582_3,
            s_5582_4,
            s_5582_5,
            s_5582_6,
        );
        // N s_5582_8: return
        return;
    }
    fn block_5583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5583_0: read-var opc2:u8
        let s_5583_0: u8 = fn_state.opc2;
        // D s_5583_1: cast zx s_5583_0 -> bv
        let s_5583_1: Bits = Bits::new(s_5583_0 as u128, 3u16);
        // C s_5583_2: const #4u : u8
        let s_5583_2: u8 = 4;
        // C s_5583_3: cast zx s_5583_2 -> bv
        let s_5583_3: Bits = Bits::new(s_5583_2 as u128, 3u16);
        // D s_5583_4: cmp-eq s_5583_1 s_5583_3
        let s_5583_4: bool = ((s_5583_1) == (s_5583_3));
        // D s_5583_5: write-var gs#134595 <= s_5583_4
        fn_state.gs_134595 = s_5583_4;
        // N s_5583_6: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_5584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5584_0: read-var opc1:u8
        let s_5584_0: u8 = fn_state.opc1;
        // D s_5584_1: cast zx s_5584_0 -> bv
        let s_5584_1: Bits = Bits::new(s_5584_0 as u128, 3u16);
        // C s_5584_2: const #0u : u8
        let s_5584_2: u8 = 0;
        // C s_5584_3: cast zx s_5584_2 -> bv
        let s_5584_3: Bits = Bits::new(s_5584_2 as u128, 3u16);
        // D s_5584_4: cmp-eq s_5584_1 s_5584_3
        let s_5584_4: bool = ((s_5584_1) == (s_5584_3));
        // D s_5584_5: write-var gs#134594 <= s_5584_4
        fn_state.gs_134594 = s_5584_4;
        // N s_5584_6: jump b258
        return block_258(state, tracer, fn_state);
    }
    fn block_5585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5585_0: read-var coproc:u8
        let s_5585_0: u8 = fn_state.coproc;
        // D s_5585_1: cast zx s_5585_0 -> bv
        let s_5585_1: Bits = Bits::new(s_5585_0 as u128, 4u16);
        // C s_5585_2: const #14u : u8
        let s_5585_2: u8 = 14;
        // C s_5585_3: cast zx s_5585_2 -> bv
        let s_5585_3: Bits = Bits::new(s_5585_2 as u128, 4u16);
        // D s_5585_4: cmp-eq s_5585_1 s_5585_3
        let s_5585_4: bool = ((s_5585_1) == (s_5585_3));
        // D s_5585_5: write-var gs#134593 <= s_5585_4
        fn_state.gs_134593 = s_5585_4;
        // N s_5585_6: jump b256
        return block_256(state, tracer, fn_state);
    }
    fn block_5586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5586_0: read-var CRn:u8
        let s_5586_0: u8 = fn_state.CRn;
        // D s_5586_1: cast zx s_5586_0 -> bv
        let s_5586_1: Bits = Bits::new(s_5586_0 as u128, 4u16);
        // C s_5586_2: const #0u : u8
        let s_5586_2: u8 = 0;
        // C s_5586_3: cast zx s_5586_2 -> bv
        let s_5586_3: Bits = Bits::new(s_5586_2 as u128, 4u16);
        // D s_5586_4: cmp-eq s_5586_1 s_5586_3
        let s_5586_4: bool = ((s_5586_1) == (s_5586_3));
        // D s_5586_5: write-var gs#134592 <= s_5586_4
        fn_state.gs_134592 = s_5586_4;
        // N s_5586_6: jump b254
        return block_254(state, tracer, fn_state);
    }
    fn block_5587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5587_0: read-var el:u8
        let s_5587_0: u8 = fn_state.el;
        // D s_5587_1: read-var coproc:u8
        let s_5587_1: u8 = fn_state.coproc;
        // D s_5587_2: read-var opc1:u8
        let s_5587_2: u8 = fn_state.opc1;
        // D s_5587_3: read-var CRn:u8
        let s_5587_3: u8 = fn_state.CRn;
        // D s_5587_4: read-var opc2:u8
        let s_5587_4: u8 = fn_state.opc2;
        // D s_5587_5: read-var CRm:u8
        let s_5587_5: u8 = fn_state.CRm;
        // D s_5587_6: read-var t:i
        let s_5587_6: i128 = fn_state.t;
        // D s_5587_7: call DBGBVR_SysRegWrite32_09f07ef9f7a6387c(s_5587_0, s_5587_1, s_5587_2, s_5587_3, s_5587_4, s_5587_5, s_5587_6)
        let s_5587_7: () = DBGBVR_SysRegWrite32_09f07ef9f7a6387c(
            state,
            tracer,
            s_5587_0,
            s_5587_1,
            s_5587_2,
            s_5587_3,
            s_5587_4,
            s_5587_5,
            s_5587_6,
        );
        // N s_5587_8: return
        return;
    }
    fn block_5588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5588_0: read-var opc2:u8
        let s_5588_0: u8 = fn_state.opc2;
        // D s_5588_1: cast zx s_5588_0 -> bv
        let s_5588_1: Bits = Bits::new(s_5588_0 as u128, 3u16);
        // C s_5588_2: const #4u : u8
        let s_5588_2: u8 = 4;
        // C s_5588_3: cast zx s_5588_2 -> bv
        let s_5588_3: Bits = Bits::new(s_5588_2 as u128, 3u16);
        // D s_5588_4: cmp-eq s_5588_1 s_5588_3
        let s_5588_4: bool = ((s_5588_1) == (s_5588_3));
        // D s_5588_5: write-var gs#134591 <= s_5588_4
        fn_state.gs_134591 = s_5588_4;
        // N s_5588_6: jump b251
        return block_251(state, tracer, fn_state);
    }
    fn block_5589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5589_0: read-var opc1:u8
        let s_5589_0: u8 = fn_state.opc1;
        // D s_5589_1: cast zx s_5589_0 -> bv
        let s_5589_1: Bits = Bits::new(s_5589_0 as u128, 3u16);
        // C s_5589_2: const #0u : u8
        let s_5589_2: u8 = 0;
        // C s_5589_3: cast zx s_5589_2 -> bv
        let s_5589_3: Bits = Bits::new(s_5589_2 as u128, 3u16);
        // D s_5589_4: cmp-eq s_5589_1 s_5589_3
        let s_5589_4: bool = ((s_5589_1) == (s_5589_3));
        // D s_5589_5: write-var gs#134590 <= s_5589_4
        fn_state.gs_134590 = s_5589_4;
        // N s_5589_6: jump b249
        return block_249(state, tracer, fn_state);
    }
    fn block_5590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5590_0: read-var coproc:u8
        let s_5590_0: u8 = fn_state.coproc;
        // D s_5590_1: cast zx s_5590_0 -> bv
        let s_5590_1: Bits = Bits::new(s_5590_0 as u128, 4u16);
        // C s_5590_2: const #14u : u8
        let s_5590_2: u8 = 14;
        // C s_5590_3: cast zx s_5590_2 -> bv
        let s_5590_3: Bits = Bits::new(s_5590_2 as u128, 4u16);
        // D s_5590_4: cmp-eq s_5590_1 s_5590_3
        let s_5590_4: bool = ((s_5590_1) == (s_5590_3));
        // D s_5590_5: write-var gs#134589 <= s_5590_4
        fn_state.gs_134589 = s_5590_4;
        // N s_5590_6: jump b247
        return block_247(state, tracer, fn_state);
    }
    fn block_5591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5591_0: read-var CRn:u8
        let s_5591_0: u8 = fn_state.CRn;
        // D s_5591_1: cast zx s_5591_0 -> bv
        let s_5591_1: Bits = Bits::new(s_5591_0 as u128, 4u16);
        // C s_5591_2: const #0u : u8
        let s_5591_2: u8 = 0;
        // C s_5591_3: cast zx s_5591_2 -> bv
        let s_5591_3: Bits = Bits::new(s_5591_2 as u128, 4u16);
        // D s_5591_4: cmp-eq s_5591_1 s_5591_3
        let s_5591_4: bool = ((s_5591_1) == (s_5591_3));
        // D s_5591_5: write-var gs#134588 <= s_5591_4
        fn_state.gs_134588 = s_5591_4;
        // N s_5591_6: jump b245
        return block_245(state, tracer, fn_state);
    }
    fn block_5592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5592_0: read-var el:u8
        let s_5592_0: u8 = fn_state.el;
        // D s_5592_1: read-var coproc:u8
        let s_5592_1: u8 = fn_state.coproc;
        // D s_5592_2: read-var opc1:u8
        let s_5592_2: u8 = fn_state.opc1;
        // D s_5592_3: read-var CRn:u8
        let s_5592_3: u8 = fn_state.CRn;
        // D s_5592_4: read-var opc2:u8
        let s_5592_4: u8 = fn_state.opc2;
        // D s_5592_5: read-var CRm:u8
        let s_5592_5: u8 = fn_state.CRm;
        // D s_5592_6: read-var t:i
        let s_5592_6: i128 = fn_state.t;
        // D s_5592_7: call DBGBVR_SysRegWrite32_7386f767486da9e4(s_5592_0, s_5592_1, s_5592_2, s_5592_3, s_5592_4, s_5592_5, s_5592_6)
        let s_5592_7: () = DBGBVR_SysRegWrite32_7386f767486da9e4(
            state,
            tracer,
            s_5592_0,
            s_5592_1,
            s_5592_2,
            s_5592_3,
            s_5592_4,
            s_5592_5,
            s_5592_6,
        );
        // N s_5592_8: return
        return;
    }
    fn block_5593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5593_0: read-var opc2:u8
        let s_5593_0: u8 = fn_state.opc2;
        // D s_5593_1: cast zx s_5593_0 -> bv
        let s_5593_1: Bits = Bits::new(s_5593_0 as u128, 3u16);
        // C s_5593_2: const #4u : u8
        let s_5593_2: u8 = 4;
        // C s_5593_3: cast zx s_5593_2 -> bv
        let s_5593_3: Bits = Bits::new(s_5593_2 as u128, 3u16);
        // D s_5593_4: cmp-eq s_5593_1 s_5593_3
        let s_5593_4: bool = ((s_5593_1) == (s_5593_3));
        // D s_5593_5: write-var gs#134587 <= s_5593_4
        fn_state.gs_134587 = s_5593_4;
        // N s_5593_6: jump b242
        return block_242(state, tracer, fn_state);
    }
    fn block_5594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5594_0: read-var opc1:u8
        let s_5594_0: u8 = fn_state.opc1;
        // D s_5594_1: cast zx s_5594_0 -> bv
        let s_5594_1: Bits = Bits::new(s_5594_0 as u128, 3u16);
        // C s_5594_2: const #0u : u8
        let s_5594_2: u8 = 0;
        // C s_5594_3: cast zx s_5594_2 -> bv
        let s_5594_3: Bits = Bits::new(s_5594_2 as u128, 3u16);
        // D s_5594_4: cmp-eq s_5594_1 s_5594_3
        let s_5594_4: bool = ((s_5594_1) == (s_5594_3));
        // D s_5594_5: write-var gs#134586 <= s_5594_4
        fn_state.gs_134586 = s_5594_4;
        // N s_5594_6: jump b240
        return block_240(state, tracer, fn_state);
    }
    fn block_5595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5595_0: read-var coproc:u8
        let s_5595_0: u8 = fn_state.coproc;
        // D s_5595_1: cast zx s_5595_0 -> bv
        let s_5595_1: Bits = Bits::new(s_5595_0 as u128, 4u16);
        // C s_5595_2: const #14u : u8
        let s_5595_2: u8 = 14;
        // C s_5595_3: cast zx s_5595_2 -> bv
        let s_5595_3: Bits = Bits::new(s_5595_2 as u128, 4u16);
        // D s_5595_4: cmp-eq s_5595_1 s_5595_3
        let s_5595_4: bool = ((s_5595_1) == (s_5595_3));
        // D s_5595_5: write-var gs#134585 <= s_5595_4
        fn_state.gs_134585 = s_5595_4;
        // N s_5595_6: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_5596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5596_0: read-var CRn:u8
        let s_5596_0: u8 = fn_state.CRn;
        // D s_5596_1: cast zx s_5596_0 -> bv
        let s_5596_1: Bits = Bits::new(s_5596_0 as u128, 4u16);
        // C s_5596_2: const #0u : u8
        let s_5596_2: u8 = 0;
        // C s_5596_3: cast zx s_5596_2 -> bv
        let s_5596_3: Bits = Bits::new(s_5596_2 as u128, 4u16);
        // D s_5596_4: cmp-eq s_5596_1 s_5596_3
        let s_5596_4: bool = ((s_5596_1) == (s_5596_3));
        // D s_5596_5: write-var gs#134584 <= s_5596_4
        fn_state.gs_134584 = s_5596_4;
        // N s_5596_6: jump b236
        return block_236(state, tracer, fn_state);
    }
    fn block_5597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5597_0: read-var el:u8
        let s_5597_0: u8 = fn_state.el;
        // D s_5597_1: read-var coproc:u8
        let s_5597_1: u8 = fn_state.coproc;
        // D s_5597_2: read-var opc1:u8
        let s_5597_2: u8 = fn_state.opc1;
        // D s_5597_3: read-var CRn:u8
        let s_5597_3: u8 = fn_state.CRn;
        // D s_5597_4: read-var opc2:u8
        let s_5597_4: u8 = fn_state.opc2;
        // D s_5597_5: read-var CRm:u8
        let s_5597_5: u8 = fn_state.CRm;
        // D s_5597_6: read-var t:i
        let s_5597_6: i128 = fn_state.t;
        // D s_5597_7: call DBGBVR_SysRegWrite32_582b75e31913750c(s_5597_0, s_5597_1, s_5597_2, s_5597_3, s_5597_4, s_5597_5, s_5597_6)
        let s_5597_7: () = DBGBVR_SysRegWrite32_582b75e31913750c(
            state,
            tracer,
            s_5597_0,
            s_5597_1,
            s_5597_2,
            s_5597_3,
            s_5597_4,
            s_5597_5,
            s_5597_6,
        );
        // N s_5597_8: return
        return;
    }
    fn block_5598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5598_0: read-var opc2:u8
        let s_5598_0: u8 = fn_state.opc2;
        // D s_5598_1: cast zx s_5598_0 -> bv
        let s_5598_1: Bits = Bits::new(s_5598_0 as u128, 3u16);
        // C s_5598_2: const #4u : u8
        let s_5598_2: u8 = 4;
        // C s_5598_3: cast zx s_5598_2 -> bv
        let s_5598_3: Bits = Bits::new(s_5598_2 as u128, 3u16);
        // D s_5598_4: cmp-eq s_5598_1 s_5598_3
        let s_5598_4: bool = ((s_5598_1) == (s_5598_3));
        // D s_5598_5: write-var gs#134583 <= s_5598_4
        fn_state.gs_134583 = s_5598_4;
        // N s_5598_6: jump b233
        return block_233(state, tracer, fn_state);
    }
    fn block_5599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5599_0: read-var opc1:u8
        let s_5599_0: u8 = fn_state.opc1;
        // D s_5599_1: cast zx s_5599_0 -> bv
        let s_5599_1: Bits = Bits::new(s_5599_0 as u128, 3u16);
        // C s_5599_2: const #0u : u8
        let s_5599_2: u8 = 0;
        // C s_5599_3: cast zx s_5599_2 -> bv
        let s_5599_3: Bits = Bits::new(s_5599_2 as u128, 3u16);
        // D s_5599_4: cmp-eq s_5599_1 s_5599_3
        let s_5599_4: bool = ((s_5599_1) == (s_5599_3));
        // D s_5599_5: write-var gs#134582 <= s_5599_4
        fn_state.gs_134582 = s_5599_4;
        // N s_5599_6: jump b231
        return block_231(state, tracer, fn_state);
    }
    fn block_5600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5600_0: read-var coproc:u8
        let s_5600_0: u8 = fn_state.coproc;
        // D s_5600_1: cast zx s_5600_0 -> bv
        let s_5600_1: Bits = Bits::new(s_5600_0 as u128, 4u16);
        // C s_5600_2: const #14u : u8
        let s_5600_2: u8 = 14;
        // C s_5600_3: cast zx s_5600_2 -> bv
        let s_5600_3: Bits = Bits::new(s_5600_2 as u128, 4u16);
        // D s_5600_4: cmp-eq s_5600_1 s_5600_3
        let s_5600_4: bool = ((s_5600_1) == (s_5600_3));
        // D s_5600_5: write-var gs#134581 <= s_5600_4
        fn_state.gs_134581 = s_5600_4;
        // N s_5600_6: jump b229
        return block_229(state, tracer, fn_state);
    }
    fn block_5601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5601_0: read-var CRn:u8
        let s_5601_0: u8 = fn_state.CRn;
        // D s_5601_1: cast zx s_5601_0 -> bv
        let s_5601_1: Bits = Bits::new(s_5601_0 as u128, 4u16);
        // C s_5601_2: const #0u : u8
        let s_5601_2: u8 = 0;
        // C s_5601_3: cast zx s_5601_2 -> bv
        let s_5601_3: Bits = Bits::new(s_5601_2 as u128, 4u16);
        // D s_5601_4: cmp-eq s_5601_1 s_5601_3
        let s_5601_4: bool = ((s_5601_1) == (s_5601_3));
        // D s_5601_5: write-var gs#134580 <= s_5601_4
        fn_state.gs_134580 = s_5601_4;
        // N s_5601_6: jump b227
        return block_227(state, tracer, fn_state);
    }
    fn block_5602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5602_0: read-var el:u8
        let s_5602_0: u8 = fn_state.el;
        // D s_5602_1: read-var coproc:u8
        let s_5602_1: u8 = fn_state.coproc;
        // D s_5602_2: read-var opc1:u8
        let s_5602_2: u8 = fn_state.opc1;
        // D s_5602_3: read-var CRn:u8
        let s_5602_3: u8 = fn_state.CRn;
        // D s_5602_4: read-var opc2:u8
        let s_5602_4: u8 = fn_state.opc2;
        // D s_5602_5: read-var CRm:u8
        let s_5602_5: u8 = fn_state.CRm;
        // D s_5602_6: read-var t:i
        let s_5602_6: i128 = fn_state.t;
        // D s_5602_7: call DBGBVR_SysRegWrite32_d3b70c896b17af64(s_5602_0, s_5602_1, s_5602_2, s_5602_3, s_5602_4, s_5602_5, s_5602_6)
        let s_5602_7: () = DBGBVR_SysRegWrite32_d3b70c896b17af64(
            state,
            tracer,
            s_5602_0,
            s_5602_1,
            s_5602_2,
            s_5602_3,
            s_5602_4,
            s_5602_5,
            s_5602_6,
        );
        // N s_5602_8: return
        return;
    }
    fn block_5603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5603_0: read-var opc2:u8
        let s_5603_0: u8 = fn_state.opc2;
        // D s_5603_1: cast zx s_5603_0 -> bv
        let s_5603_1: Bits = Bits::new(s_5603_0 as u128, 3u16);
        // C s_5603_2: const #4u : u8
        let s_5603_2: u8 = 4;
        // C s_5603_3: cast zx s_5603_2 -> bv
        let s_5603_3: Bits = Bits::new(s_5603_2 as u128, 3u16);
        // D s_5603_4: cmp-eq s_5603_1 s_5603_3
        let s_5603_4: bool = ((s_5603_1) == (s_5603_3));
        // D s_5603_5: write-var gs#134579 <= s_5603_4
        fn_state.gs_134579 = s_5603_4;
        // N s_5603_6: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_5604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5604_0: read-var opc1:u8
        let s_5604_0: u8 = fn_state.opc1;
        // D s_5604_1: cast zx s_5604_0 -> bv
        let s_5604_1: Bits = Bits::new(s_5604_0 as u128, 3u16);
        // C s_5604_2: const #0u : u8
        let s_5604_2: u8 = 0;
        // C s_5604_3: cast zx s_5604_2 -> bv
        let s_5604_3: Bits = Bits::new(s_5604_2 as u128, 3u16);
        // D s_5604_4: cmp-eq s_5604_1 s_5604_3
        let s_5604_4: bool = ((s_5604_1) == (s_5604_3));
        // D s_5604_5: write-var gs#134578 <= s_5604_4
        fn_state.gs_134578 = s_5604_4;
        // N s_5604_6: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_5605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5605_0: read-var coproc:u8
        let s_5605_0: u8 = fn_state.coproc;
        // D s_5605_1: cast zx s_5605_0 -> bv
        let s_5605_1: Bits = Bits::new(s_5605_0 as u128, 4u16);
        // C s_5605_2: const #14u : u8
        let s_5605_2: u8 = 14;
        // C s_5605_3: cast zx s_5605_2 -> bv
        let s_5605_3: Bits = Bits::new(s_5605_2 as u128, 4u16);
        // D s_5605_4: cmp-eq s_5605_1 s_5605_3
        let s_5605_4: bool = ((s_5605_1) == (s_5605_3));
        // D s_5605_5: write-var gs#134577 <= s_5605_4
        fn_state.gs_134577 = s_5605_4;
        // N s_5605_6: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_5606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5606_0: read-var CRn:u8
        let s_5606_0: u8 = fn_state.CRn;
        // D s_5606_1: cast zx s_5606_0 -> bv
        let s_5606_1: Bits = Bits::new(s_5606_0 as u128, 4u16);
        // C s_5606_2: const #0u : u8
        let s_5606_2: u8 = 0;
        // C s_5606_3: cast zx s_5606_2 -> bv
        let s_5606_3: Bits = Bits::new(s_5606_2 as u128, 4u16);
        // D s_5606_4: cmp-eq s_5606_1 s_5606_3
        let s_5606_4: bool = ((s_5606_1) == (s_5606_3));
        // D s_5606_5: write-var gs#134576 <= s_5606_4
        fn_state.gs_134576 = s_5606_4;
        // N s_5606_6: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_5607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5607_0: read-var el:u8
        let s_5607_0: u8 = fn_state.el;
        // D s_5607_1: read-var coproc:u8
        let s_5607_1: u8 = fn_state.coproc;
        // D s_5607_2: read-var opc1:u8
        let s_5607_2: u8 = fn_state.opc1;
        // D s_5607_3: read-var CRn:u8
        let s_5607_3: u8 = fn_state.CRn;
        // D s_5607_4: read-var opc2:u8
        let s_5607_4: u8 = fn_state.opc2;
        // D s_5607_5: read-var CRm:u8
        let s_5607_5: u8 = fn_state.CRm;
        // D s_5607_6: read-var t:i
        let s_5607_6: i128 = fn_state.t;
        // D s_5607_7: call DBGBVR_SysRegWrite32_6325f50ba95b0b24(s_5607_0, s_5607_1, s_5607_2, s_5607_3, s_5607_4, s_5607_5, s_5607_6)
        let s_5607_7: () = DBGBVR_SysRegWrite32_6325f50ba95b0b24(
            state,
            tracer,
            s_5607_0,
            s_5607_1,
            s_5607_2,
            s_5607_3,
            s_5607_4,
            s_5607_5,
            s_5607_6,
        );
        // N s_5607_8: return
        return;
    }
    fn block_5608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5608_0: read-var opc2:u8
        let s_5608_0: u8 = fn_state.opc2;
        // D s_5608_1: cast zx s_5608_0 -> bv
        let s_5608_1: Bits = Bits::new(s_5608_0 as u128, 3u16);
        // C s_5608_2: const #4u : u8
        let s_5608_2: u8 = 4;
        // C s_5608_3: cast zx s_5608_2 -> bv
        let s_5608_3: Bits = Bits::new(s_5608_2 as u128, 3u16);
        // D s_5608_4: cmp-eq s_5608_1 s_5608_3
        let s_5608_4: bool = ((s_5608_1) == (s_5608_3));
        // D s_5608_5: write-var gs#134575 <= s_5608_4
        fn_state.gs_134575 = s_5608_4;
        // N s_5608_6: jump b215
        return block_215(state, tracer, fn_state);
    }
    fn block_5609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5609_0: read-var opc1:u8
        let s_5609_0: u8 = fn_state.opc1;
        // D s_5609_1: cast zx s_5609_0 -> bv
        let s_5609_1: Bits = Bits::new(s_5609_0 as u128, 3u16);
        // C s_5609_2: const #0u : u8
        let s_5609_2: u8 = 0;
        // C s_5609_3: cast zx s_5609_2 -> bv
        let s_5609_3: Bits = Bits::new(s_5609_2 as u128, 3u16);
        // D s_5609_4: cmp-eq s_5609_1 s_5609_3
        let s_5609_4: bool = ((s_5609_1) == (s_5609_3));
        // D s_5609_5: write-var gs#134574 <= s_5609_4
        fn_state.gs_134574 = s_5609_4;
        // N s_5609_6: jump b213
        return block_213(state, tracer, fn_state);
    }
    fn block_5610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5610_0: read-var coproc:u8
        let s_5610_0: u8 = fn_state.coproc;
        // D s_5610_1: cast zx s_5610_0 -> bv
        let s_5610_1: Bits = Bits::new(s_5610_0 as u128, 4u16);
        // C s_5610_2: const #14u : u8
        let s_5610_2: u8 = 14;
        // C s_5610_3: cast zx s_5610_2 -> bv
        let s_5610_3: Bits = Bits::new(s_5610_2 as u128, 4u16);
        // D s_5610_4: cmp-eq s_5610_1 s_5610_3
        let s_5610_4: bool = ((s_5610_1) == (s_5610_3));
        // D s_5610_5: write-var gs#134573 <= s_5610_4
        fn_state.gs_134573 = s_5610_4;
        // N s_5610_6: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_5611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5611_0: read-var CRn:u8
        let s_5611_0: u8 = fn_state.CRn;
        // D s_5611_1: cast zx s_5611_0 -> bv
        let s_5611_1: Bits = Bits::new(s_5611_0 as u128, 4u16);
        // C s_5611_2: const #0u : u8
        let s_5611_2: u8 = 0;
        // C s_5611_3: cast zx s_5611_2 -> bv
        let s_5611_3: Bits = Bits::new(s_5611_2 as u128, 4u16);
        // D s_5611_4: cmp-eq s_5611_1 s_5611_3
        let s_5611_4: bool = ((s_5611_1) == (s_5611_3));
        // D s_5611_5: write-var gs#134572 <= s_5611_4
        fn_state.gs_134572 = s_5611_4;
        // N s_5611_6: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_5612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5612_0: read-var el:u8
        let s_5612_0: u8 = fn_state.el;
        // D s_5612_1: read-var coproc:u8
        let s_5612_1: u8 = fn_state.coproc;
        // D s_5612_2: read-var opc1:u8
        let s_5612_2: u8 = fn_state.opc1;
        // D s_5612_3: read-var CRn:u8
        let s_5612_3: u8 = fn_state.CRn;
        // D s_5612_4: read-var opc2:u8
        let s_5612_4: u8 = fn_state.opc2;
        // D s_5612_5: read-var CRm:u8
        let s_5612_5: u8 = fn_state.CRm;
        // D s_5612_6: read-var t:i
        let s_5612_6: i128 = fn_state.t;
        // D s_5612_7: call DBGBVR_SysRegWrite32_00f20f6c3bc04edd(s_5612_0, s_5612_1, s_5612_2, s_5612_3, s_5612_4, s_5612_5, s_5612_6)
        let s_5612_7: () = DBGBVR_SysRegWrite32_00f20f6c3bc04edd(
            state,
            tracer,
            s_5612_0,
            s_5612_1,
            s_5612_2,
            s_5612_3,
            s_5612_4,
            s_5612_5,
            s_5612_6,
        );
        // N s_5612_8: return
        return;
    }
    fn block_5613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5613_0: read-var opc2:u8
        let s_5613_0: u8 = fn_state.opc2;
        // D s_5613_1: cast zx s_5613_0 -> bv
        let s_5613_1: Bits = Bits::new(s_5613_0 as u128, 3u16);
        // C s_5613_2: const #4u : u8
        let s_5613_2: u8 = 4;
        // C s_5613_3: cast zx s_5613_2 -> bv
        let s_5613_3: Bits = Bits::new(s_5613_2 as u128, 3u16);
        // D s_5613_4: cmp-eq s_5613_1 s_5613_3
        let s_5613_4: bool = ((s_5613_1) == (s_5613_3));
        // D s_5613_5: write-var gs#134571 <= s_5613_4
        fn_state.gs_134571 = s_5613_4;
        // N s_5613_6: jump b206
        return block_206(state, tracer, fn_state);
    }
    fn block_5614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5614_0: read-var opc1:u8
        let s_5614_0: u8 = fn_state.opc1;
        // D s_5614_1: cast zx s_5614_0 -> bv
        let s_5614_1: Bits = Bits::new(s_5614_0 as u128, 3u16);
        // C s_5614_2: const #0u : u8
        let s_5614_2: u8 = 0;
        // C s_5614_3: cast zx s_5614_2 -> bv
        let s_5614_3: Bits = Bits::new(s_5614_2 as u128, 3u16);
        // D s_5614_4: cmp-eq s_5614_1 s_5614_3
        let s_5614_4: bool = ((s_5614_1) == (s_5614_3));
        // D s_5614_5: write-var gs#134570 <= s_5614_4
        fn_state.gs_134570 = s_5614_4;
        // N s_5614_6: jump b204
        return block_204(state, tracer, fn_state);
    }
    fn block_5615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5615_0: read-var coproc:u8
        let s_5615_0: u8 = fn_state.coproc;
        // D s_5615_1: cast zx s_5615_0 -> bv
        let s_5615_1: Bits = Bits::new(s_5615_0 as u128, 4u16);
        // C s_5615_2: const #14u : u8
        let s_5615_2: u8 = 14;
        // C s_5615_3: cast zx s_5615_2 -> bv
        let s_5615_3: Bits = Bits::new(s_5615_2 as u128, 4u16);
        // D s_5615_4: cmp-eq s_5615_1 s_5615_3
        let s_5615_4: bool = ((s_5615_1) == (s_5615_3));
        // D s_5615_5: write-var gs#134569 <= s_5615_4
        fn_state.gs_134569 = s_5615_4;
        // N s_5615_6: jump b202
        return block_202(state, tracer, fn_state);
    }
    fn block_5616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5616_0: read-var CRn:u8
        let s_5616_0: u8 = fn_state.CRn;
        // D s_5616_1: cast zx s_5616_0 -> bv
        let s_5616_1: Bits = Bits::new(s_5616_0 as u128, 4u16);
        // C s_5616_2: const #0u : u8
        let s_5616_2: u8 = 0;
        // C s_5616_3: cast zx s_5616_2 -> bv
        let s_5616_3: Bits = Bits::new(s_5616_2 as u128, 4u16);
        // D s_5616_4: cmp-eq s_5616_1 s_5616_3
        let s_5616_4: bool = ((s_5616_1) == (s_5616_3));
        // D s_5616_5: write-var gs#134568 <= s_5616_4
        fn_state.gs_134568 = s_5616_4;
        // N s_5616_6: jump b200
        return block_200(state, tracer, fn_state);
    }
    fn block_5617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5617_0: read-var el:u8
        let s_5617_0: u8 = fn_state.el;
        // D s_5617_1: read-var coproc:u8
        let s_5617_1: u8 = fn_state.coproc;
        // D s_5617_2: read-var opc1:u8
        let s_5617_2: u8 = fn_state.opc1;
        // D s_5617_3: read-var CRn:u8
        let s_5617_3: u8 = fn_state.CRn;
        // D s_5617_4: read-var opc2:u8
        let s_5617_4: u8 = fn_state.opc2;
        // D s_5617_5: read-var CRm:u8
        let s_5617_5: u8 = fn_state.CRm;
        // D s_5617_6: read-var t:i
        let s_5617_6: i128 = fn_state.t;
        // D s_5617_7: call DBGBVR_SysRegWrite32_bf3ed59977f70f6c(s_5617_0, s_5617_1, s_5617_2, s_5617_3, s_5617_4, s_5617_5, s_5617_6)
        let s_5617_7: () = DBGBVR_SysRegWrite32_bf3ed59977f70f6c(
            state,
            tracer,
            s_5617_0,
            s_5617_1,
            s_5617_2,
            s_5617_3,
            s_5617_4,
            s_5617_5,
            s_5617_6,
        );
        // N s_5617_8: return
        return;
    }
    fn block_5618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5618_0: read-var opc2:u8
        let s_5618_0: u8 = fn_state.opc2;
        // D s_5618_1: cast zx s_5618_0 -> bv
        let s_5618_1: Bits = Bits::new(s_5618_0 as u128, 3u16);
        // C s_5618_2: const #4u : u8
        let s_5618_2: u8 = 4;
        // C s_5618_3: cast zx s_5618_2 -> bv
        let s_5618_3: Bits = Bits::new(s_5618_2 as u128, 3u16);
        // D s_5618_4: cmp-eq s_5618_1 s_5618_3
        let s_5618_4: bool = ((s_5618_1) == (s_5618_3));
        // D s_5618_5: write-var gs#134567 <= s_5618_4
        fn_state.gs_134567 = s_5618_4;
        // N s_5618_6: jump b197
        return block_197(state, tracer, fn_state);
    }
    fn block_5619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5619_0: read-var opc1:u8
        let s_5619_0: u8 = fn_state.opc1;
        // D s_5619_1: cast zx s_5619_0 -> bv
        let s_5619_1: Bits = Bits::new(s_5619_0 as u128, 3u16);
        // C s_5619_2: const #0u : u8
        let s_5619_2: u8 = 0;
        // C s_5619_3: cast zx s_5619_2 -> bv
        let s_5619_3: Bits = Bits::new(s_5619_2 as u128, 3u16);
        // D s_5619_4: cmp-eq s_5619_1 s_5619_3
        let s_5619_4: bool = ((s_5619_1) == (s_5619_3));
        // D s_5619_5: write-var gs#134566 <= s_5619_4
        fn_state.gs_134566 = s_5619_4;
        // N s_5619_6: jump b195
        return block_195(state, tracer, fn_state);
    }
    fn block_5620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5620_0: read-var coproc:u8
        let s_5620_0: u8 = fn_state.coproc;
        // D s_5620_1: cast zx s_5620_0 -> bv
        let s_5620_1: Bits = Bits::new(s_5620_0 as u128, 4u16);
        // C s_5620_2: const #14u : u8
        let s_5620_2: u8 = 14;
        // C s_5620_3: cast zx s_5620_2 -> bv
        let s_5620_3: Bits = Bits::new(s_5620_2 as u128, 4u16);
        // D s_5620_4: cmp-eq s_5620_1 s_5620_3
        let s_5620_4: bool = ((s_5620_1) == (s_5620_3));
        // D s_5620_5: write-var gs#134565 <= s_5620_4
        fn_state.gs_134565 = s_5620_4;
        // N s_5620_6: jump b193
        return block_193(state, tracer, fn_state);
    }
    fn block_5621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5621_0: read-var CRn:u8
        let s_5621_0: u8 = fn_state.CRn;
        // D s_5621_1: cast zx s_5621_0 -> bv
        let s_5621_1: Bits = Bits::new(s_5621_0 as u128, 4u16);
        // C s_5621_2: const #0u : u8
        let s_5621_2: u8 = 0;
        // C s_5621_3: cast zx s_5621_2 -> bv
        let s_5621_3: Bits = Bits::new(s_5621_2 as u128, 4u16);
        // D s_5621_4: cmp-eq s_5621_1 s_5621_3
        let s_5621_4: bool = ((s_5621_1) == (s_5621_3));
        // D s_5621_5: write-var gs#134564 <= s_5621_4
        fn_state.gs_134564 = s_5621_4;
        // N s_5621_6: jump b191
        return block_191(state, tracer, fn_state);
    }
    fn block_5622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5622_0: read-var el:u8
        let s_5622_0: u8 = fn_state.el;
        // D s_5622_1: read-var coproc:u8
        let s_5622_1: u8 = fn_state.coproc;
        // D s_5622_2: read-var opc1:u8
        let s_5622_2: u8 = fn_state.opc1;
        // D s_5622_3: read-var CRn:u8
        let s_5622_3: u8 = fn_state.CRn;
        // D s_5622_4: read-var opc2:u8
        let s_5622_4: u8 = fn_state.opc2;
        // D s_5622_5: read-var CRm:u8
        let s_5622_5: u8 = fn_state.CRm;
        // D s_5622_6: read-var t:i
        let s_5622_6: i128 = fn_state.t;
        // D s_5622_7: call DBGBVR_SysRegWrite32_08e35fe5ecd207ba(s_5622_0, s_5622_1, s_5622_2, s_5622_3, s_5622_4, s_5622_5, s_5622_6)
        let s_5622_7: () = DBGBVR_SysRegWrite32_08e35fe5ecd207ba(
            state,
            tracer,
            s_5622_0,
            s_5622_1,
            s_5622_2,
            s_5622_3,
            s_5622_4,
            s_5622_5,
            s_5622_6,
        );
        // N s_5622_8: return
        return;
    }
    fn block_5623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5623_0: read-var opc2:u8
        let s_5623_0: u8 = fn_state.opc2;
        // D s_5623_1: cast zx s_5623_0 -> bv
        let s_5623_1: Bits = Bits::new(s_5623_0 as u128, 3u16);
        // C s_5623_2: const #4u : u8
        let s_5623_2: u8 = 4;
        // C s_5623_3: cast zx s_5623_2 -> bv
        let s_5623_3: Bits = Bits::new(s_5623_2 as u128, 3u16);
        // D s_5623_4: cmp-eq s_5623_1 s_5623_3
        let s_5623_4: bool = ((s_5623_1) == (s_5623_3));
        // D s_5623_5: write-var gs#134563 <= s_5623_4
        fn_state.gs_134563 = s_5623_4;
        // N s_5623_6: jump b188
        return block_188(state, tracer, fn_state);
    }
    fn block_5624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5624_0: read-var opc1:u8
        let s_5624_0: u8 = fn_state.opc1;
        // D s_5624_1: cast zx s_5624_0 -> bv
        let s_5624_1: Bits = Bits::new(s_5624_0 as u128, 3u16);
        // C s_5624_2: const #0u : u8
        let s_5624_2: u8 = 0;
        // C s_5624_3: cast zx s_5624_2 -> bv
        let s_5624_3: Bits = Bits::new(s_5624_2 as u128, 3u16);
        // D s_5624_4: cmp-eq s_5624_1 s_5624_3
        let s_5624_4: bool = ((s_5624_1) == (s_5624_3));
        // D s_5624_5: write-var gs#134562 <= s_5624_4
        fn_state.gs_134562 = s_5624_4;
        // N s_5624_6: jump b186
        return block_186(state, tracer, fn_state);
    }
    fn block_5625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5625_0: read-var coproc:u8
        let s_5625_0: u8 = fn_state.coproc;
        // D s_5625_1: cast zx s_5625_0 -> bv
        let s_5625_1: Bits = Bits::new(s_5625_0 as u128, 4u16);
        // C s_5625_2: const #14u : u8
        let s_5625_2: u8 = 14;
        // C s_5625_3: cast zx s_5625_2 -> bv
        let s_5625_3: Bits = Bits::new(s_5625_2 as u128, 4u16);
        // D s_5625_4: cmp-eq s_5625_1 s_5625_3
        let s_5625_4: bool = ((s_5625_1) == (s_5625_3));
        // D s_5625_5: write-var gs#134561 <= s_5625_4
        fn_state.gs_134561 = s_5625_4;
        // N s_5625_6: jump b184
        return block_184(state, tracer, fn_state);
    }
    fn block_5626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5626_0: read-var CRn:u8
        let s_5626_0: u8 = fn_state.CRn;
        // D s_5626_1: cast zx s_5626_0 -> bv
        let s_5626_1: Bits = Bits::new(s_5626_0 as u128, 4u16);
        // C s_5626_2: const #0u : u8
        let s_5626_2: u8 = 0;
        // C s_5626_3: cast zx s_5626_2 -> bv
        let s_5626_3: Bits = Bits::new(s_5626_2 as u128, 4u16);
        // D s_5626_4: cmp-eq s_5626_1 s_5626_3
        let s_5626_4: bool = ((s_5626_1) == (s_5626_3));
        // D s_5626_5: write-var gs#134560 <= s_5626_4
        fn_state.gs_134560 = s_5626_4;
        // N s_5626_6: jump b182
        return block_182(state, tracer, fn_state);
    }
    fn block_5627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5627_0: read-var el:u8
        let s_5627_0: u8 = fn_state.el;
        // D s_5627_1: read-var coproc:u8
        let s_5627_1: u8 = fn_state.coproc;
        // D s_5627_2: read-var opc1:u8
        let s_5627_2: u8 = fn_state.opc1;
        // D s_5627_3: read-var CRn:u8
        let s_5627_3: u8 = fn_state.CRn;
        // D s_5627_4: read-var opc2:u8
        let s_5627_4: u8 = fn_state.opc2;
        // D s_5627_5: read-var CRm:u8
        let s_5627_5: u8 = fn_state.CRm;
        // D s_5627_6: read-var t:i
        let s_5627_6: i128 = fn_state.t;
        // D s_5627_7: call DBGBVR_SysRegWrite32_bd28a7bc76c62bdd(s_5627_0, s_5627_1, s_5627_2, s_5627_3, s_5627_4, s_5627_5, s_5627_6)
        let s_5627_7: () = DBGBVR_SysRegWrite32_bd28a7bc76c62bdd(
            state,
            tracer,
            s_5627_0,
            s_5627_1,
            s_5627_2,
            s_5627_3,
            s_5627_4,
            s_5627_5,
            s_5627_6,
        );
        // N s_5627_8: return
        return;
    }
    fn block_5628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5628_0: read-var opc2:u8
        let s_5628_0: u8 = fn_state.opc2;
        // D s_5628_1: cast zx s_5628_0 -> bv
        let s_5628_1: Bits = Bits::new(s_5628_0 as u128, 3u16);
        // C s_5628_2: const #4u : u8
        let s_5628_2: u8 = 4;
        // C s_5628_3: cast zx s_5628_2 -> bv
        let s_5628_3: Bits = Bits::new(s_5628_2 as u128, 3u16);
        // D s_5628_4: cmp-eq s_5628_1 s_5628_3
        let s_5628_4: bool = ((s_5628_1) == (s_5628_3));
        // D s_5628_5: write-var gs#134559 <= s_5628_4
        fn_state.gs_134559 = s_5628_4;
        // N s_5628_6: jump b179
        return block_179(state, tracer, fn_state);
    }
    fn block_5629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5629_0: read-var opc1:u8
        let s_5629_0: u8 = fn_state.opc1;
        // D s_5629_1: cast zx s_5629_0 -> bv
        let s_5629_1: Bits = Bits::new(s_5629_0 as u128, 3u16);
        // C s_5629_2: const #0u : u8
        let s_5629_2: u8 = 0;
        // C s_5629_3: cast zx s_5629_2 -> bv
        let s_5629_3: Bits = Bits::new(s_5629_2 as u128, 3u16);
        // D s_5629_4: cmp-eq s_5629_1 s_5629_3
        let s_5629_4: bool = ((s_5629_1) == (s_5629_3));
        // D s_5629_5: write-var gs#134558 <= s_5629_4
        fn_state.gs_134558 = s_5629_4;
        // N s_5629_6: jump b177
        return block_177(state, tracer, fn_state);
    }
    fn block_5630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5630_0: read-var coproc:u8
        let s_5630_0: u8 = fn_state.coproc;
        // D s_5630_1: cast zx s_5630_0 -> bv
        let s_5630_1: Bits = Bits::new(s_5630_0 as u128, 4u16);
        // C s_5630_2: const #14u : u8
        let s_5630_2: u8 = 14;
        // C s_5630_3: cast zx s_5630_2 -> bv
        let s_5630_3: Bits = Bits::new(s_5630_2 as u128, 4u16);
        // D s_5630_4: cmp-eq s_5630_1 s_5630_3
        let s_5630_4: bool = ((s_5630_1) == (s_5630_3));
        // D s_5630_5: write-var gs#134557 <= s_5630_4
        fn_state.gs_134557 = s_5630_4;
        // N s_5630_6: jump b175
        return block_175(state, tracer, fn_state);
    }
    fn block_5631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5631_0: read-var CRn:u8
        let s_5631_0: u8 = fn_state.CRn;
        // D s_5631_1: cast zx s_5631_0 -> bv
        let s_5631_1: Bits = Bits::new(s_5631_0 as u128, 4u16);
        // C s_5631_2: const #0u : u8
        let s_5631_2: u8 = 0;
        // C s_5631_3: cast zx s_5631_2 -> bv
        let s_5631_3: Bits = Bits::new(s_5631_2 as u128, 4u16);
        // D s_5631_4: cmp-eq s_5631_1 s_5631_3
        let s_5631_4: bool = ((s_5631_1) == (s_5631_3));
        // D s_5631_5: write-var gs#134556 <= s_5631_4
        fn_state.gs_134556 = s_5631_4;
        // N s_5631_6: jump b173
        return block_173(state, tracer, fn_state);
    }
    fn block_5632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5632_0: read-var el:u8
        let s_5632_0: u8 = fn_state.el;
        // D s_5632_1: read-var coproc:u8
        let s_5632_1: u8 = fn_state.coproc;
        // D s_5632_2: read-var opc1:u8
        let s_5632_2: u8 = fn_state.opc1;
        // D s_5632_3: read-var CRn:u8
        let s_5632_3: u8 = fn_state.CRn;
        // D s_5632_4: read-var opc2:u8
        let s_5632_4: u8 = fn_state.opc2;
        // D s_5632_5: read-var CRm:u8
        let s_5632_5: u8 = fn_state.CRm;
        // D s_5632_6: read-var t:i
        let s_5632_6: i128 = fn_state.t;
        // D s_5632_7: call CNTHPS_CTL_SysRegWrite32_420a204f985af014(s_5632_0, s_5632_1, s_5632_2, s_5632_3, s_5632_4, s_5632_5, s_5632_6)
        let s_5632_7: () = CNTHPS_CTL_SysRegWrite32_420a204f985af014(
            state,
            tracer,
            s_5632_0,
            s_5632_1,
            s_5632_2,
            s_5632_3,
            s_5632_4,
            s_5632_5,
            s_5632_6,
        );
        // N s_5632_8: return
        return;
    }
    fn block_5633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5633_0: read-var opc2:u8
        let s_5633_0: u8 = fn_state.opc2;
        // D s_5633_1: cast zx s_5633_0 -> bv
        let s_5633_1: Bits = Bits::new(s_5633_0 as u128, 3u16);
        // C s_5633_2: const #1u : u8
        let s_5633_2: u8 = 1;
        // C s_5633_3: cast zx s_5633_2 -> bv
        let s_5633_3: Bits = Bits::new(s_5633_2 as u128, 3u16);
        // D s_5633_4: cmp-eq s_5633_1 s_5633_3
        let s_5633_4: bool = ((s_5633_1) == (s_5633_3));
        // D s_5633_5: write-var gs#134555 <= s_5633_4
        fn_state.gs_134555 = s_5633_4;
        // N s_5633_6: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_5634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5634_0: read-var opc1:u8
        let s_5634_0: u8 = fn_state.opc1;
        // D s_5634_1: cast zx s_5634_0 -> bv
        let s_5634_1: Bits = Bits::new(s_5634_0 as u128, 3u16);
        // C s_5634_2: const #0u : u8
        let s_5634_2: u8 = 0;
        // C s_5634_3: cast zx s_5634_2 -> bv
        let s_5634_3: Bits = Bits::new(s_5634_2 as u128, 3u16);
        // D s_5634_4: cmp-eq s_5634_1 s_5634_3
        let s_5634_4: bool = ((s_5634_1) == (s_5634_3));
        // D s_5634_5: write-var gs#134554 <= s_5634_4
        fn_state.gs_134554 = s_5634_4;
        // N s_5634_6: jump b168
        return block_168(state, tracer, fn_state);
    }
    fn block_5635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5635_0: read-var coproc:u8
        let s_5635_0: u8 = fn_state.coproc;
        // D s_5635_1: cast zx s_5635_0 -> bv
        let s_5635_1: Bits = Bits::new(s_5635_0 as u128, 4u16);
        // C s_5635_2: const #15u : u8
        let s_5635_2: u8 = 15;
        // C s_5635_3: cast zx s_5635_2 -> bv
        let s_5635_3: Bits = Bits::new(s_5635_2 as u128, 4u16);
        // D s_5635_4: cmp-eq s_5635_1 s_5635_3
        let s_5635_4: bool = ((s_5635_1) == (s_5635_3));
        // D s_5635_5: write-var gs#134553 <= s_5635_4
        fn_state.gs_134553 = s_5635_4;
        // N s_5635_6: jump b166
        return block_166(state, tracer, fn_state);
    }
    fn block_5636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5636_0: read-var CRn:u8
        let s_5636_0: u8 = fn_state.CRn;
        // D s_5636_1: cast zx s_5636_0 -> bv
        let s_5636_1: Bits = Bits::new(s_5636_0 as u128, 4u16);
        // C s_5636_2: const #14u : u8
        let s_5636_2: u8 = 14;
        // C s_5636_3: cast zx s_5636_2 -> bv
        let s_5636_3: Bits = Bits::new(s_5636_2 as u128, 4u16);
        // D s_5636_4: cmp-eq s_5636_1 s_5636_3
        let s_5636_4: bool = ((s_5636_1) == (s_5636_3));
        // D s_5636_5: write-var gs#134552 <= s_5636_4
        fn_state.gs_134552 = s_5636_4;
        // N s_5636_6: jump b164
        return block_164(state, tracer, fn_state);
    }
    fn block_5637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5637_0: read-var el:u8
        let s_5637_0: u8 = fn_state.el;
        // D s_5637_1: read-var coproc:u8
        let s_5637_1: u8 = fn_state.coproc;
        // D s_5637_2: read-var opc1:u8
        let s_5637_2: u8 = fn_state.opc1;
        // D s_5637_3: read-var CRn:u8
        let s_5637_3: u8 = fn_state.CRn;
        // D s_5637_4: read-var opc2:u8
        let s_5637_4: u8 = fn_state.opc2;
        // D s_5637_5: read-var CRm:u8
        let s_5637_5: u8 = fn_state.CRm;
        // D s_5637_6: read-var t:i
        let s_5637_6: i128 = fn_state.t;
        // D s_5637_7: call PMUSERENR_SysRegWrite32_5b91165bfc334c29(s_5637_0, s_5637_1, s_5637_2, s_5637_3, s_5637_4, s_5637_5, s_5637_6)
        let s_5637_7: () = PMUSERENR_SysRegWrite32_5b91165bfc334c29(
            state,
            tracer,
            s_5637_0,
            s_5637_1,
            s_5637_2,
            s_5637_3,
            s_5637_4,
            s_5637_5,
            s_5637_6,
        );
        // N s_5637_8: return
        return;
    }
    fn block_5638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5638_0: read-var opc2:u8
        let s_5638_0: u8 = fn_state.opc2;
        // D s_5638_1: cast zx s_5638_0 -> bv
        let s_5638_1: Bits = Bits::new(s_5638_0 as u128, 3u16);
        // C s_5638_2: const #0u : u8
        let s_5638_2: u8 = 0;
        // C s_5638_3: cast zx s_5638_2 -> bv
        let s_5638_3: Bits = Bits::new(s_5638_2 as u128, 3u16);
        // D s_5638_4: cmp-eq s_5638_1 s_5638_3
        let s_5638_4: bool = ((s_5638_1) == (s_5638_3));
        // D s_5638_5: write-var gs#134551 <= s_5638_4
        fn_state.gs_134551 = s_5638_4;
        // N s_5638_6: jump b161
        return block_161(state, tracer, fn_state);
    }
    fn block_5639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5639_0: read-var opc1:u8
        let s_5639_0: u8 = fn_state.opc1;
        // D s_5639_1: cast zx s_5639_0 -> bv
        let s_5639_1: Bits = Bits::new(s_5639_0 as u128, 3u16);
        // C s_5639_2: const #0u : u8
        let s_5639_2: u8 = 0;
        // C s_5639_3: cast zx s_5639_2 -> bv
        let s_5639_3: Bits = Bits::new(s_5639_2 as u128, 3u16);
        // D s_5639_4: cmp-eq s_5639_1 s_5639_3
        let s_5639_4: bool = ((s_5639_1) == (s_5639_3));
        // D s_5639_5: write-var gs#134550 <= s_5639_4
        fn_state.gs_134550 = s_5639_4;
        // N s_5639_6: jump b159
        return block_159(state, tracer, fn_state);
    }
    fn block_5640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5640_0: read-var coproc:u8
        let s_5640_0: u8 = fn_state.coproc;
        // D s_5640_1: cast zx s_5640_0 -> bv
        let s_5640_1: Bits = Bits::new(s_5640_0 as u128, 4u16);
        // C s_5640_2: const #15u : u8
        let s_5640_2: u8 = 15;
        // C s_5640_3: cast zx s_5640_2 -> bv
        let s_5640_3: Bits = Bits::new(s_5640_2 as u128, 4u16);
        // D s_5640_4: cmp-eq s_5640_1 s_5640_3
        let s_5640_4: bool = ((s_5640_1) == (s_5640_3));
        // D s_5640_5: write-var gs#134549 <= s_5640_4
        fn_state.gs_134549 = s_5640_4;
        // N s_5640_6: jump b157
        return block_157(state, tracer, fn_state);
    }
    fn block_5641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5641_0: read-var CRn:u8
        let s_5641_0: u8 = fn_state.CRn;
        // D s_5641_1: cast zx s_5641_0 -> bv
        let s_5641_1: Bits = Bits::new(s_5641_0 as u128, 4u16);
        // C s_5641_2: const #9u : u8
        let s_5641_2: u8 = 9;
        // C s_5641_3: cast zx s_5641_2 -> bv
        let s_5641_3: Bits = Bits::new(s_5641_2 as u128, 4u16);
        // D s_5641_4: cmp-eq s_5641_1 s_5641_3
        let s_5641_4: bool = ((s_5641_1) == (s_5641_3));
        // D s_5641_5: write-var gs#134548 <= s_5641_4
        fn_state.gs_134548 = s_5641_4;
        // N s_5641_6: jump b155
        return block_155(state, tracer, fn_state);
    }
    fn block_5642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5642_0: read-var el:u8
        let s_5642_0: u8 = fn_state.el;
        // D s_5642_1: read-var coproc:u8
        let s_5642_1: u8 = fn_state.coproc;
        // D s_5642_2: read-var opc1:u8
        let s_5642_2: u8 = fn_state.opc1;
        // D s_5642_3: read-var CRn:u8
        let s_5642_3: u8 = fn_state.CRn;
        // D s_5642_4: read-var opc2:u8
        let s_5642_4: u8 = fn_state.opc2;
        // D s_5642_5: read-var CRm:u8
        let s_5642_5: u8 = fn_state.CRm;
        // D s_5642_6: read-var t:i
        let s_5642_6: i128 = fn_state.t;
        // D s_5642_7: call PMOVSR_SysRegWrite32_afe1ff69a9fde1bd(s_5642_0, s_5642_1, s_5642_2, s_5642_3, s_5642_4, s_5642_5, s_5642_6)
        let s_5642_7: () = PMOVSR_SysRegWrite32_afe1ff69a9fde1bd(
            state,
            tracer,
            s_5642_0,
            s_5642_1,
            s_5642_2,
            s_5642_3,
            s_5642_4,
            s_5642_5,
            s_5642_6,
        );
        // N s_5642_8: return
        return;
    }
    fn block_5643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5643_0: read-var opc2:u8
        let s_5643_0: u8 = fn_state.opc2;
        // D s_5643_1: cast zx s_5643_0 -> bv
        let s_5643_1: Bits = Bits::new(s_5643_0 as u128, 3u16);
        // C s_5643_2: const #3u : u8
        let s_5643_2: u8 = 3;
        // C s_5643_3: cast zx s_5643_2 -> bv
        let s_5643_3: Bits = Bits::new(s_5643_2 as u128, 3u16);
        // D s_5643_4: cmp-eq s_5643_1 s_5643_3
        let s_5643_4: bool = ((s_5643_1) == (s_5643_3));
        // D s_5643_5: write-var gs#134547 <= s_5643_4
        fn_state.gs_134547 = s_5643_4;
        // N s_5643_6: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_5644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5644_0: read-var opc1:u8
        let s_5644_0: u8 = fn_state.opc1;
        // D s_5644_1: cast zx s_5644_0 -> bv
        let s_5644_1: Bits = Bits::new(s_5644_0 as u128, 3u16);
        // C s_5644_2: const #0u : u8
        let s_5644_2: u8 = 0;
        // C s_5644_3: cast zx s_5644_2 -> bv
        let s_5644_3: Bits = Bits::new(s_5644_2 as u128, 3u16);
        // D s_5644_4: cmp-eq s_5644_1 s_5644_3
        let s_5644_4: bool = ((s_5644_1) == (s_5644_3));
        // D s_5644_5: write-var gs#134546 <= s_5644_4
        fn_state.gs_134546 = s_5644_4;
        // N s_5644_6: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_5645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5645_0: read-var coproc:u8
        let s_5645_0: u8 = fn_state.coproc;
        // D s_5645_1: cast zx s_5645_0 -> bv
        let s_5645_1: Bits = Bits::new(s_5645_0 as u128, 4u16);
        // C s_5645_2: const #15u : u8
        let s_5645_2: u8 = 15;
        // C s_5645_3: cast zx s_5645_2 -> bv
        let s_5645_3: Bits = Bits::new(s_5645_2 as u128, 4u16);
        // D s_5645_4: cmp-eq s_5645_1 s_5645_3
        let s_5645_4: bool = ((s_5645_1) == (s_5645_3));
        // D s_5645_5: write-var gs#134545 <= s_5645_4
        fn_state.gs_134545 = s_5645_4;
        // N s_5645_6: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_5646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5646_0: read-var CRn:u8
        let s_5646_0: u8 = fn_state.CRn;
        // D s_5646_1: cast zx s_5646_0 -> bv
        let s_5646_1: Bits = Bits::new(s_5646_0 as u128, 4u16);
        // C s_5646_2: const #9u : u8
        let s_5646_2: u8 = 9;
        // C s_5646_3: cast zx s_5646_2 -> bv
        let s_5646_3: Bits = Bits::new(s_5646_2 as u128, 4u16);
        // D s_5646_4: cmp-eq s_5646_1 s_5646_3
        let s_5646_4: bool = ((s_5646_1) == (s_5646_3));
        // D s_5646_5: write-var gs#134544 <= s_5646_4
        fn_state.gs_134544 = s_5646_4;
        // N s_5646_6: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_5647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5647_0: read-var el:u8
        let s_5647_0: u8 = fn_state.el;
        // D s_5647_1: read-var coproc:u8
        let s_5647_1: u8 = fn_state.coproc;
        // D s_5647_2: read-var opc1:u8
        let s_5647_2: u8 = fn_state.opc1;
        // D s_5647_3: read-var CRn:u8
        let s_5647_3: u8 = fn_state.CRn;
        // D s_5647_4: read-var opc2:u8
        let s_5647_4: u8 = fn_state.opc2;
        // D s_5647_5: read-var CRm:u8
        let s_5647_5: u8 = fn_state.CRm;
        // D s_5647_6: read-var t:i
        let s_5647_6: i128 = fn_state.t;
        // D s_5647_7: call ICV_IGRPEN1_SysRegWrite32_224f633a4805f3d5(s_5647_0, s_5647_1, s_5647_2, s_5647_3, s_5647_4, s_5647_5, s_5647_6)
        let s_5647_7: () = ICV_IGRPEN1_SysRegWrite32_224f633a4805f3d5(
            state,
            tracer,
            s_5647_0,
            s_5647_1,
            s_5647_2,
            s_5647_3,
            s_5647_4,
            s_5647_5,
            s_5647_6,
        );
        // N s_5647_8: return
        return;
    }
    fn block_5648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5648_0: read-var opc2:u8
        let s_5648_0: u8 = fn_state.opc2;
        // D s_5648_1: cast zx s_5648_0 -> bv
        let s_5648_1: Bits = Bits::new(s_5648_0 as u128, 3u16);
        // C s_5648_2: const #7u : u8
        let s_5648_2: u8 = 7;
        // C s_5648_3: cast zx s_5648_2 -> bv
        let s_5648_3: Bits = Bits::new(s_5648_2 as u128, 3u16);
        // D s_5648_4: cmp-eq s_5648_1 s_5648_3
        let s_5648_4: bool = ((s_5648_1) == (s_5648_3));
        // D s_5648_5: write-var gs#134543 <= s_5648_4
        fn_state.gs_134543 = s_5648_4;
        // N s_5648_6: jump b143
        return block_143(state, tracer, fn_state);
    }
    fn block_5649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5649_0: read-var opc1:u8
        let s_5649_0: u8 = fn_state.opc1;
        // D s_5649_1: cast zx s_5649_0 -> bv
        let s_5649_1: Bits = Bits::new(s_5649_0 as u128, 3u16);
        // C s_5649_2: const #0u : u8
        let s_5649_2: u8 = 0;
        // C s_5649_3: cast zx s_5649_2 -> bv
        let s_5649_3: Bits = Bits::new(s_5649_2 as u128, 3u16);
        // D s_5649_4: cmp-eq s_5649_1 s_5649_3
        let s_5649_4: bool = ((s_5649_1) == (s_5649_3));
        // D s_5649_5: write-var gs#134542 <= s_5649_4
        fn_state.gs_134542 = s_5649_4;
        // N s_5649_6: jump b141
        return block_141(state, tracer, fn_state);
    }
    fn block_5650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5650_0: read-var coproc:u8
        let s_5650_0: u8 = fn_state.coproc;
        // D s_5650_1: cast zx s_5650_0 -> bv
        let s_5650_1: Bits = Bits::new(s_5650_0 as u128, 4u16);
        // C s_5650_2: const #15u : u8
        let s_5650_2: u8 = 15;
        // C s_5650_3: cast zx s_5650_2 -> bv
        let s_5650_3: Bits = Bits::new(s_5650_2 as u128, 4u16);
        // D s_5650_4: cmp-eq s_5650_1 s_5650_3
        let s_5650_4: bool = ((s_5650_1) == (s_5650_3));
        // D s_5650_5: write-var gs#134541 <= s_5650_4
        fn_state.gs_134541 = s_5650_4;
        // N s_5650_6: jump b139
        return block_139(state, tracer, fn_state);
    }
    fn block_5651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5651_0: read-var CRn:u8
        let s_5651_0: u8 = fn_state.CRn;
        // D s_5651_1: cast zx s_5651_0 -> bv
        let s_5651_1: Bits = Bits::new(s_5651_0 as u128, 4u16);
        // C s_5651_2: const #12u : u8
        let s_5651_2: u8 = 12;
        // C s_5651_3: cast zx s_5651_2 -> bv
        let s_5651_3: Bits = Bits::new(s_5651_2 as u128, 4u16);
        // D s_5651_4: cmp-eq s_5651_1 s_5651_3
        let s_5651_4: bool = ((s_5651_1) == (s_5651_3));
        // D s_5651_5: write-var gs#134540 <= s_5651_4
        fn_state.gs_134540 = s_5651_4;
        // N s_5651_6: jump b137
        return block_137(state, tracer, fn_state);
    }
    fn block_5652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5652_0: read-var el:u8
        let s_5652_0: u8 = fn_state.el;
        // D s_5652_1: read-var coproc:u8
        let s_5652_1: u8 = fn_state.coproc;
        // D s_5652_2: read-var opc1:u8
        let s_5652_2: u8 = fn_state.opc1;
        // D s_5652_3: read-var CRn:u8
        let s_5652_3: u8 = fn_state.CRn;
        // D s_5652_4: read-var opc2:u8
        let s_5652_4: u8 = fn_state.opc2;
        // D s_5652_5: read-var CRm:u8
        let s_5652_5: u8 = fn_state.CRm;
        // D s_5652_6: read-var t:i
        let s_5652_6: i128 = fn_state.t;
        // D s_5652_7: call HCPTR_SysRegWrite32_793a7f8578c5645f(s_5652_0, s_5652_1, s_5652_2, s_5652_3, s_5652_4, s_5652_5, s_5652_6)
        let s_5652_7: () = HCPTR_SysRegWrite32_793a7f8578c5645f(
            state,
            tracer,
            s_5652_0,
            s_5652_1,
            s_5652_2,
            s_5652_3,
            s_5652_4,
            s_5652_5,
            s_5652_6,
        );
        // N s_5652_8: return
        return;
    }
    fn block_5653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5653_0: read-var opc2:u8
        let s_5653_0: u8 = fn_state.opc2;
        // D s_5653_1: cast zx s_5653_0 -> bv
        let s_5653_1: Bits = Bits::new(s_5653_0 as u128, 3u16);
        // C s_5653_2: const #2u : u8
        let s_5653_2: u8 = 2;
        // C s_5653_3: cast zx s_5653_2 -> bv
        let s_5653_3: Bits = Bits::new(s_5653_2 as u128, 3u16);
        // D s_5653_4: cmp-eq s_5653_1 s_5653_3
        let s_5653_4: bool = ((s_5653_1) == (s_5653_3));
        // D s_5653_5: write-var gs#134539 <= s_5653_4
        fn_state.gs_134539 = s_5653_4;
        // N s_5653_6: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_5654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5654_0: read-var opc1:u8
        let s_5654_0: u8 = fn_state.opc1;
        // D s_5654_1: cast zx s_5654_0 -> bv
        let s_5654_1: Bits = Bits::new(s_5654_0 as u128, 3u16);
        // C s_5654_2: const #4u : u8
        let s_5654_2: u8 = 4;
        // C s_5654_3: cast zx s_5654_2 -> bv
        let s_5654_3: Bits = Bits::new(s_5654_2 as u128, 3u16);
        // D s_5654_4: cmp-eq s_5654_1 s_5654_3
        let s_5654_4: bool = ((s_5654_1) == (s_5654_3));
        // D s_5654_5: write-var gs#134538 <= s_5654_4
        fn_state.gs_134538 = s_5654_4;
        // N s_5654_6: jump b132
        return block_132(state, tracer, fn_state);
    }
    fn block_5655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5655_0: read-var coproc:u8
        let s_5655_0: u8 = fn_state.coproc;
        // D s_5655_1: cast zx s_5655_0 -> bv
        let s_5655_1: Bits = Bits::new(s_5655_0 as u128, 4u16);
        // C s_5655_2: const #15u : u8
        let s_5655_2: u8 = 15;
        // C s_5655_3: cast zx s_5655_2 -> bv
        let s_5655_3: Bits = Bits::new(s_5655_2 as u128, 4u16);
        // D s_5655_4: cmp-eq s_5655_1 s_5655_3
        let s_5655_4: bool = ((s_5655_1) == (s_5655_3));
        // D s_5655_5: write-var gs#134537 <= s_5655_4
        fn_state.gs_134537 = s_5655_4;
        // N s_5655_6: jump b130
        return block_130(state, tracer, fn_state);
    }
    fn block_5656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5656_0: read-var CRn:u8
        let s_5656_0: u8 = fn_state.CRn;
        // D s_5656_1: cast zx s_5656_0 -> bv
        let s_5656_1: Bits = Bits::new(s_5656_0 as u128, 4u16);
        // C s_5656_2: const #1u : u8
        let s_5656_2: u8 = 1;
        // C s_5656_3: cast zx s_5656_2 -> bv
        let s_5656_3: Bits = Bits::new(s_5656_2 as u128, 4u16);
        // D s_5656_4: cmp-eq s_5656_1 s_5656_3
        let s_5656_4: bool = ((s_5656_1) == (s_5656_3));
        // D s_5656_5: write-var gs#134536 <= s_5656_4
        fn_state.gs_134536 = s_5656_4;
        // N s_5656_6: jump b128
        return block_128(state, tracer, fn_state);
    }
    fn block_5657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5657_0: read-var el:u8
        let s_5657_0: u8 = fn_state.el;
        // D s_5657_1: read-var coproc:u8
        let s_5657_1: u8 = fn_state.coproc;
        // D s_5657_2: read-var opc1:u8
        let s_5657_2: u8 = fn_state.opc1;
        // D s_5657_3: read-var CRn:u8
        let s_5657_3: u8 = fn_state.CRn;
        // D s_5657_4: read-var opc2:u8
        let s_5657_4: u8 = fn_state.opc2;
        // D s_5657_5: read-var CRm:u8
        let s_5657_5: u8 = fn_state.CRm;
        // D s_5657_6: read-var t:i
        let s_5657_6: i128 = fn_state.t;
        // D s_5657_7: call JOSCR_SysRegWrite32_88e20b8662c98b9c(s_5657_0, s_5657_1, s_5657_2, s_5657_3, s_5657_4, s_5657_5, s_5657_6)
        let s_5657_7: () = JOSCR_SysRegWrite32_88e20b8662c98b9c(
            state,
            tracer,
            s_5657_0,
            s_5657_1,
            s_5657_2,
            s_5657_3,
            s_5657_4,
            s_5657_5,
            s_5657_6,
        );
        // N s_5657_8: return
        return;
    }
    fn block_5658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5658_0: read-var opc2:u8
        let s_5658_0: u8 = fn_state.opc2;
        // D s_5658_1: cast zx s_5658_0 -> bv
        let s_5658_1: Bits = Bits::new(s_5658_0 as u128, 3u16);
        // C s_5658_2: const #0u : u8
        let s_5658_2: u8 = 0;
        // C s_5658_3: cast zx s_5658_2 -> bv
        let s_5658_3: Bits = Bits::new(s_5658_2 as u128, 3u16);
        // D s_5658_4: cmp-eq s_5658_1 s_5658_3
        let s_5658_4: bool = ((s_5658_1) == (s_5658_3));
        // D s_5658_5: write-var gs#134535 <= s_5658_4
        fn_state.gs_134535 = s_5658_4;
        // N s_5658_6: jump b125
        return block_125(state, tracer, fn_state);
    }
    fn block_5659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5659_0: read-var opc1:u8
        let s_5659_0: u8 = fn_state.opc1;
        // D s_5659_1: cast zx s_5659_0 -> bv
        let s_5659_1: Bits = Bits::new(s_5659_0 as u128, 3u16);
        // C s_5659_2: const #7u : u8
        let s_5659_2: u8 = 7;
        // C s_5659_3: cast zx s_5659_2 -> bv
        let s_5659_3: Bits = Bits::new(s_5659_2 as u128, 3u16);
        // D s_5659_4: cmp-eq s_5659_1 s_5659_3
        let s_5659_4: bool = ((s_5659_1) == (s_5659_3));
        // D s_5659_5: write-var gs#134534 <= s_5659_4
        fn_state.gs_134534 = s_5659_4;
        // N s_5659_6: jump b123
        return block_123(state, tracer, fn_state);
    }
    fn block_5660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5660_0: read-var coproc:u8
        let s_5660_0: u8 = fn_state.coproc;
        // D s_5660_1: cast zx s_5660_0 -> bv
        let s_5660_1: Bits = Bits::new(s_5660_0 as u128, 4u16);
        // C s_5660_2: const #14u : u8
        let s_5660_2: u8 = 14;
        // C s_5660_3: cast zx s_5660_2 -> bv
        let s_5660_3: Bits = Bits::new(s_5660_2 as u128, 4u16);
        // D s_5660_4: cmp-eq s_5660_1 s_5660_3
        let s_5660_4: bool = ((s_5660_1) == (s_5660_3));
        // D s_5660_5: write-var gs#134533 <= s_5660_4
        fn_state.gs_134533 = s_5660_4;
        // N s_5660_6: jump b121
        return block_121(state, tracer, fn_state);
    }
    fn block_5661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5661_0: read-var CRn:u8
        let s_5661_0: u8 = fn_state.CRn;
        // D s_5661_1: cast zx s_5661_0 -> bv
        let s_5661_1: Bits = Bits::new(s_5661_0 as u128, 4u16);
        // C s_5661_2: const #1u : u8
        let s_5661_2: u8 = 1;
        // C s_5661_3: cast zx s_5661_2 -> bv
        let s_5661_3: Bits = Bits::new(s_5661_2 as u128, 4u16);
        // D s_5661_4: cmp-eq s_5661_1 s_5661_3
        let s_5661_4: bool = ((s_5661_1) == (s_5661_3));
        // D s_5661_5: write-var gs#134532 <= s_5661_4
        fn_state.gs_134532 = s_5661_4;
        // N s_5661_6: jump b119
        return block_119(state, tracer, fn_state);
    }
    fn block_5662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5662_0: read-var el:u8
        let s_5662_0: u8 = fn_state.el;
        // D s_5662_1: read-var coproc:u8
        let s_5662_1: u8 = fn_state.coproc;
        // D s_5662_2: read-var opc1:u8
        let s_5662_2: u8 = fn_state.opc1;
        // D s_5662_3: read-var CRn:u8
        let s_5662_3: u8 = fn_state.CRn;
        // D s_5662_4: read-var opc2:u8
        let s_5662_4: u8 = fn_state.opc2;
        // D s_5662_5: read-var CRm:u8
        let s_5662_5: u8 = fn_state.CRm;
        // D s_5662_6: read-var t:i
        let s_5662_6: i128 = fn_state.t;
        // D s_5662_7: call HACR_SysRegWrite32_5e68b66302bfb64c(s_5662_0, s_5662_1, s_5662_2, s_5662_3, s_5662_4, s_5662_5, s_5662_6)
        let s_5662_7: () = HACR_SysRegWrite32_5e68b66302bfb64c(
            state,
            tracer,
            s_5662_0,
            s_5662_1,
            s_5662_2,
            s_5662_3,
            s_5662_4,
            s_5662_5,
            s_5662_6,
        );
        // N s_5662_8: return
        return;
    }
    fn block_5663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5663_0: read-var opc2:u8
        let s_5663_0: u8 = fn_state.opc2;
        // D s_5663_1: cast zx s_5663_0 -> bv
        let s_5663_1: Bits = Bits::new(s_5663_0 as u128, 3u16);
        // C s_5663_2: const #7u : u8
        let s_5663_2: u8 = 7;
        // C s_5663_3: cast zx s_5663_2 -> bv
        let s_5663_3: Bits = Bits::new(s_5663_2 as u128, 3u16);
        // D s_5663_4: cmp-eq s_5663_1 s_5663_3
        let s_5663_4: bool = ((s_5663_1) == (s_5663_3));
        // D s_5663_5: write-var gs#134531 <= s_5663_4
        fn_state.gs_134531 = s_5663_4;
        // N s_5663_6: jump b116
        return block_116(state, tracer, fn_state);
    }
    fn block_5664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5664_0: read-var opc1:u8
        let s_5664_0: u8 = fn_state.opc1;
        // D s_5664_1: cast zx s_5664_0 -> bv
        let s_5664_1: Bits = Bits::new(s_5664_0 as u128, 3u16);
        // C s_5664_2: const #4u : u8
        let s_5664_2: u8 = 4;
        // C s_5664_3: cast zx s_5664_2 -> bv
        let s_5664_3: Bits = Bits::new(s_5664_2 as u128, 3u16);
        // D s_5664_4: cmp-eq s_5664_1 s_5664_3
        let s_5664_4: bool = ((s_5664_1) == (s_5664_3));
        // D s_5664_5: write-var gs#134530 <= s_5664_4
        fn_state.gs_134530 = s_5664_4;
        // N s_5664_6: jump b114
        return block_114(state, tracer, fn_state);
    }
    fn block_5665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5665_0: read-var coproc:u8
        let s_5665_0: u8 = fn_state.coproc;
        // D s_5665_1: cast zx s_5665_0 -> bv
        let s_5665_1: Bits = Bits::new(s_5665_0 as u128, 4u16);
        // C s_5665_2: const #15u : u8
        let s_5665_2: u8 = 15;
        // C s_5665_3: cast zx s_5665_2 -> bv
        let s_5665_3: Bits = Bits::new(s_5665_2 as u128, 4u16);
        // D s_5665_4: cmp-eq s_5665_1 s_5665_3
        let s_5665_4: bool = ((s_5665_1) == (s_5665_3));
        // D s_5665_5: write-var gs#134529 <= s_5665_4
        fn_state.gs_134529 = s_5665_4;
        // N s_5665_6: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_5666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5666_0: read-var CRn:u8
        let s_5666_0: u8 = fn_state.CRn;
        // D s_5666_1: cast zx s_5666_0 -> bv
        let s_5666_1: Bits = Bits::new(s_5666_0 as u128, 4u16);
        // C s_5666_2: const #1u : u8
        let s_5666_2: u8 = 1;
        // C s_5666_3: cast zx s_5666_2 -> bv
        let s_5666_3: Bits = Bits::new(s_5666_2 as u128, 4u16);
        // D s_5666_4: cmp-eq s_5666_1 s_5666_3
        let s_5666_4: bool = ((s_5666_1) == (s_5666_3));
        // D s_5666_5: write-var gs#134528 <= s_5666_4
        fn_state.gs_134528 = s_5666_4;
        // N s_5666_6: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_5667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5667_0: read-var el:u8
        let s_5667_0: u8 = fn_state.el;
        // D s_5667_1: read-var coproc:u8
        let s_5667_1: u8 = fn_state.coproc;
        // D s_5667_2: read-var opc1:u8
        let s_5667_2: u8 = fn_state.opc1;
        // D s_5667_3: read-var CRn:u8
        let s_5667_3: u8 = fn_state.CRn;
        // D s_5667_4: read-var opc2:u8
        let s_5667_4: u8 = fn_state.opc2;
        // D s_5667_5: read-var CRm:u8
        let s_5667_5: u8 = fn_state.CRm;
        // D s_5667_6: read-var t:i
        let s_5667_6: i128 = fn_state.t;
        // D s_5667_7: call HIFAR_SysRegWrite32_d0cdc9f9cdd54922(s_5667_0, s_5667_1, s_5667_2, s_5667_3, s_5667_4, s_5667_5, s_5667_6)
        let s_5667_7: () = HIFAR_SysRegWrite32_d0cdc9f9cdd54922(
            state,
            tracer,
            s_5667_0,
            s_5667_1,
            s_5667_2,
            s_5667_3,
            s_5667_4,
            s_5667_5,
            s_5667_6,
        );
        // N s_5667_8: return
        return;
    }
    fn block_5668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5668_0: read-var opc2:u8
        let s_5668_0: u8 = fn_state.opc2;
        // D s_5668_1: cast zx s_5668_0 -> bv
        let s_5668_1: Bits = Bits::new(s_5668_0 as u128, 3u16);
        // C s_5668_2: const #2u : u8
        let s_5668_2: u8 = 2;
        // C s_5668_3: cast zx s_5668_2 -> bv
        let s_5668_3: Bits = Bits::new(s_5668_2 as u128, 3u16);
        // D s_5668_4: cmp-eq s_5668_1 s_5668_3
        let s_5668_4: bool = ((s_5668_1) == (s_5668_3));
        // D s_5668_5: write-var gs#134527 <= s_5668_4
        fn_state.gs_134527 = s_5668_4;
        // N s_5668_6: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_5669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5669_0: read-var opc1:u8
        let s_5669_0: u8 = fn_state.opc1;
        // D s_5669_1: cast zx s_5669_0 -> bv
        let s_5669_1: Bits = Bits::new(s_5669_0 as u128, 3u16);
        // C s_5669_2: const #4u : u8
        let s_5669_2: u8 = 4;
        // C s_5669_3: cast zx s_5669_2 -> bv
        let s_5669_3: Bits = Bits::new(s_5669_2 as u128, 3u16);
        // D s_5669_4: cmp-eq s_5669_1 s_5669_3
        let s_5669_4: bool = ((s_5669_1) == (s_5669_3));
        // D s_5669_5: write-var gs#134526 <= s_5669_4
        fn_state.gs_134526 = s_5669_4;
        // N s_5669_6: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_5670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5670_0: read-var coproc:u8
        let s_5670_0: u8 = fn_state.coproc;
        // D s_5670_1: cast zx s_5670_0 -> bv
        let s_5670_1: Bits = Bits::new(s_5670_0 as u128, 4u16);
        // C s_5670_2: const #15u : u8
        let s_5670_2: u8 = 15;
        // C s_5670_3: cast zx s_5670_2 -> bv
        let s_5670_3: Bits = Bits::new(s_5670_2 as u128, 4u16);
        // D s_5670_4: cmp-eq s_5670_1 s_5670_3
        let s_5670_4: bool = ((s_5670_1) == (s_5670_3));
        // D s_5670_5: write-var gs#134525 <= s_5670_4
        fn_state.gs_134525 = s_5670_4;
        // N s_5670_6: jump b103
        return block_103(state, tracer, fn_state);
    }
    fn block_5671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5671_0: read-var CRn:u8
        let s_5671_0: u8 = fn_state.CRn;
        // D s_5671_1: cast zx s_5671_0 -> bv
        let s_5671_1: Bits = Bits::new(s_5671_0 as u128, 4u16);
        // C s_5671_2: const #6u : u8
        let s_5671_2: u8 = 6;
        // C s_5671_3: cast zx s_5671_2 -> bv
        let s_5671_3: Bits = Bits::new(s_5671_2 as u128, 4u16);
        // D s_5671_4: cmp-eq s_5671_1 s_5671_3
        let s_5671_4: bool = ((s_5671_1) == (s_5671_3));
        // D s_5671_5: write-var gs#134524 <= s_5671_4
        fn_state.gs_134524 = s_5671_4;
        // N s_5671_6: jump b101
        return block_101(state, tracer, fn_state);
    }
    fn block_5672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5672_0: read-var el:u8
        let s_5672_0: u8 = fn_state.el;
        // D s_5672_1: read-var coproc:u8
        let s_5672_1: u8 = fn_state.coproc;
        // D s_5672_2: read-var opc1:u8
        let s_5672_2: u8 = fn_state.opc1;
        // D s_5672_3: read-var CRn:u8
        let s_5672_3: u8 = fn_state.CRn;
        // D s_5672_4: read-var opc2:u8
        let s_5672_4: u8 = fn_state.opc2;
        // D s_5672_5: read-var CRm:u8
        let s_5672_5: u8 = fn_state.CRm;
        // D s_5672_6: read-var t:i
        let s_5672_6: i128 = fn_state.t;
        // D s_5672_7: call AIFSR_SysRegWrite32_0ca6e826bb64fe73(s_5672_0, s_5672_1, s_5672_2, s_5672_3, s_5672_4, s_5672_5, s_5672_6)
        let s_5672_7: () = AIFSR_SysRegWrite32_0ca6e826bb64fe73(
            state,
            tracer,
            s_5672_0,
            s_5672_1,
            s_5672_2,
            s_5672_3,
            s_5672_4,
            s_5672_5,
            s_5672_6,
        );
        // N s_5672_8: return
        return;
    }
    fn block_5673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5673_0: read-var opc2:u8
        let s_5673_0: u8 = fn_state.opc2;
        // D s_5673_1: cast zx s_5673_0 -> bv
        let s_5673_1: Bits = Bits::new(s_5673_0 as u128, 3u16);
        // C s_5673_2: const #1u : u8
        let s_5673_2: u8 = 1;
        // C s_5673_3: cast zx s_5673_2 -> bv
        let s_5673_3: Bits = Bits::new(s_5673_2 as u128, 3u16);
        // D s_5673_4: cmp-eq s_5673_1 s_5673_3
        let s_5673_4: bool = ((s_5673_1) == (s_5673_3));
        // D s_5673_5: write-var gs#134523 <= s_5673_4
        fn_state.gs_134523 = s_5673_4;
        // N s_5673_6: jump b98
        return block_98(state, tracer, fn_state);
    }
    fn block_5674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5674_0: read-var opc1:u8
        let s_5674_0: u8 = fn_state.opc1;
        // D s_5674_1: cast zx s_5674_0 -> bv
        let s_5674_1: Bits = Bits::new(s_5674_0 as u128, 3u16);
        // C s_5674_2: const #0u : u8
        let s_5674_2: u8 = 0;
        // C s_5674_3: cast zx s_5674_2 -> bv
        let s_5674_3: Bits = Bits::new(s_5674_2 as u128, 3u16);
        // D s_5674_4: cmp-eq s_5674_1 s_5674_3
        let s_5674_4: bool = ((s_5674_1) == (s_5674_3));
        // D s_5674_5: write-var gs#134522 <= s_5674_4
        fn_state.gs_134522 = s_5674_4;
        // N s_5674_6: jump b96
        return block_96(state, tracer, fn_state);
    }
    fn block_5675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5675_0: read-var coproc:u8
        let s_5675_0: u8 = fn_state.coproc;
        // D s_5675_1: cast zx s_5675_0 -> bv
        let s_5675_1: Bits = Bits::new(s_5675_0 as u128, 4u16);
        // C s_5675_2: const #15u : u8
        let s_5675_2: u8 = 15;
        // C s_5675_3: cast zx s_5675_2 -> bv
        let s_5675_3: Bits = Bits::new(s_5675_2 as u128, 4u16);
        // D s_5675_4: cmp-eq s_5675_1 s_5675_3
        let s_5675_4: bool = ((s_5675_1) == (s_5675_3));
        // D s_5675_5: write-var gs#134521 <= s_5675_4
        fn_state.gs_134521 = s_5675_4;
        // N s_5675_6: jump b94
        return block_94(state, tracer, fn_state);
    }
    fn block_5676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5676_0: read-var CRn:u8
        let s_5676_0: u8 = fn_state.CRn;
        // D s_5676_1: cast zx s_5676_0 -> bv
        let s_5676_1: Bits = Bits::new(s_5676_0 as u128, 4u16);
        // C s_5676_2: const #5u : u8
        let s_5676_2: u8 = 5;
        // C s_5676_3: cast zx s_5676_2 -> bv
        let s_5676_3: Bits = Bits::new(s_5676_2 as u128, 4u16);
        // D s_5676_4: cmp-eq s_5676_1 s_5676_3
        let s_5676_4: bool = ((s_5676_1) == (s_5676_3));
        // D s_5676_5: write-var gs#134520 <= s_5676_4
        fn_state.gs_134520 = s_5676_4;
        // N s_5676_6: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_5677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5677_0: read-var el:u8
        let s_5677_0: u8 = fn_state.el;
        // D s_5677_1: read-var coproc:u8
        let s_5677_1: u8 = fn_state.coproc;
        // D s_5677_2: read-var opc1:u8
        let s_5677_2: u8 = fn_state.opc1;
        // D s_5677_3: read-var CRn:u8
        let s_5677_3: u8 = fn_state.CRn;
        // D s_5677_4: read-var opc2:u8
        let s_5677_4: u8 = fn_state.opc2;
        // D s_5677_5: read-var CRm:u8
        let s_5677_5: u8 = fn_state.CRm;
        // D s_5677_6: read-var t:i
        let s_5677_6: i128 = fn_state.t;
        // D s_5677_7: call ATS12NSOUR_SysRegWrite32_c89f9455fa8ec3dc(s_5677_0, s_5677_1, s_5677_2, s_5677_3, s_5677_4, s_5677_5, s_5677_6)
        let s_5677_7: () = ATS12NSOUR_SysRegWrite32_c89f9455fa8ec3dc(
            state,
            tracer,
            s_5677_0,
            s_5677_1,
            s_5677_2,
            s_5677_3,
            s_5677_4,
            s_5677_5,
            s_5677_6,
        );
        // N s_5677_8: return
        return;
    }
    fn block_5678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5678_0: read-var opc2:u8
        let s_5678_0: u8 = fn_state.opc2;
        // D s_5678_1: cast zx s_5678_0 -> bv
        let s_5678_1: Bits = Bits::new(s_5678_0 as u128, 3u16);
        // C s_5678_2: const #6u : u8
        let s_5678_2: u8 = 6;
        // C s_5678_3: cast zx s_5678_2 -> bv
        let s_5678_3: Bits = Bits::new(s_5678_2 as u128, 3u16);
        // D s_5678_4: cmp-eq s_5678_1 s_5678_3
        let s_5678_4: bool = ((s_5678_1) == (s_5678_3));
        // D s_5678_5: write-var gs#134519 <= s_5678_4
        fn_state.gs_134519 = s_5678_4;
        // N s_5678_6: jump b89
        return block_89(state, tracer, fn_state);
    }
    fn block_5679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5679_0: read-var opc1:u8
        let s_5679_0: u8 = fn_state.opc1;
        // D s_5679_1: cast zx s_5679_0 -> bv
        let s_5679_1: Bits = Bits::new(s_5679_0 as u128, 3u16);
        // C s_5679_2: const #0u : u8
        let s_5679_2: u8 = 0;
        // C s_5679_3: cast zx s_5679_2 -> bv
        let s_5679_3: Bits = Bits::new(s_5679_2 as u128, 3u16);
        // D s_5679_4: cmp-eq s_5679_1 s_5679_3
        let s_5679_4: bool = ((s_5679_1) == (s_5679_3));
        // D s_5679_5: write-var gs#134518 <= s_5679_4
        fn_state.gs_134518 = s_5679_4;
        // N s_5679_6: jump b87
        return block_87(state, tracer, fn_state);
    }
    fn block_5680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5680_0: read-var coproc:u8
        let s_5680_0: u8 = fn_state.coproc;
        // D s_5680_1: cast zx s_5680_0 -> bv
        let s_5680_1: Bits = Bits::new(s_5680_0 as u128, 4u16);
        // C s_5680_2: const #15u : u8
        let s_5680_2: u8 = 15;
        // C s_5680_3: cast zx s_5680_2 -> bv
        let s_5680_3: Bits = Bits::new(s_5680_2 as u128, 4u16);
        // D s_5680_4: cmp-eq s_5680_1 s_5680_3
        let s_5680_4: bool = ((s_5680_1) == (s_5680_3));
        // D s_5680_5: write-var gs#134517 <= s_5680_4
        fn_state.gs_134517 = s_5680_4;
        // N s_5680_6: jump b85
        return block_85(state, tracer, fn_state);
    }
    fn block_5681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5681_0: read-var CRn:u8
        let s_5681_0: u8 = fn_state.CRn;
        // D s_5681_1: cast zx s_5681_0 -> bv
        let s_5681_1: Bits = Bits::new(s_5681_0 as u128, 4u16);
        // C s_5681_2: const #7u : u8
        let s_5681_2: u8 = 7;
        // C s_5681_3: cast zx s_5681_2 -> bv
        let s_5681_3: Bits = Bits::new(s_5681_2 as u128, 4u16);
        // D s_5681_4: cmp-eq s_5681_1 s_5681_3
        let s_5681_4: bool = ((s_5681_1) == (s_5681_3));
        // D s_5681_5: write-var gs#134516 <= s_5681_4
        fn_state.gs_134516 = s_5681_4;
        // N s_5681_6: jump b83
        return block_83(state, tracer, fn_state);
    }
    fn block_5682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5682_0: read-var el:u8
        let s_5682_0: u8 = fn_state.el;
        // D s_5682_1: read-var coproc:u8
        let s_5682_1: u8 = fn_state.coproc;
        // D s_5682_2: read-var opc1:u8
        let s_5682_2: u8 = fn_state.opc1;
        // D s_5682_3: read-var CRn:u8
        let s_5682_3: u8 = fn_state.CRn;
        // D s_5682_4: read-var opc2:u8
        let s_5682_4: u8 = fn_state.opc2;
        // D s_5682_5: read-var CRm:u8
        let s_5682_5: u8 = fn_state.CRm;
        // D s_5682_6: read-var t:i
        let s_5682_6: i128 = fn_state.t;
        // D s_5682_7: call DBGOSDLR_SysRegWrite32_d7c248a695fd43a4(s_5682_0, s_5682_1, s_5682_2, s_5682_3, s_5682_4, s_5682_5, s_5682_6)
        let s_5682_7: () = DBGOSDLR_SysRegWrite32_d7c248a695fd43a4(
            state,
            tracer,
            s_5682_0,
            s_5682_1,
            s_5682_2,
            s_5682_3,
            s_5682_4,
            s_5682_5,
            s_5682_6,
        );
        // N s_5682_8: return
        return;
    }
    fn block_5683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5683_0: read-var opc2:u8
        let s_5683_0: u8 = fn_state.opc2;
        // D s_5683_1: cast zx s_5683_0 -> bv
        let s_5683_1: Bits = Bits::new(s_5683_0 as u128, 3u16);
        // C s_5683_2: const #4u : u8
        let s_5683_2: u8 = 4;
        // C s_5683_3: cast zx s_5683_2 -> bv
        let s_5683_3: Bits = Bits::new(s_5683_2 as u128, 3u16);
        // D s_5683_4: cmp-eq s_5683_1 s_5683_3
        let s_5683_4: bool = ((s_5683_1) == (s_5683_3));
        // D s_5683_5: write-var gs#134515 <= s_5683_4
        fn_state.gs_134515 = s_5683_4;
        // N s_5683_6: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_5684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5684_0: read-var opc1:u8
        let s_5684_0: u8 = fn_state.opc1;
        // D s_5684_1: cast zx s_5684_0 -> bv
        let s_5684_1: Bits = Bits::new(s_5684_0 as u128, 3u16);
        // C s_5684_2: const #0u : u8
        let s_5684_2: u8 = 0;
        // C s_5684_3: cast zx s_5684_2 -> bv
        let s_5684_3: Bits = Bits::new(s_5684_2 as u128, 3u16);
        // D s_5684_4: cmp-eq s_5684_1 s_5684_3
        let s_5684_4: bool = ((s_5684_1) == (s_5684_3));
        // D s_5684_5: write-var gs#134514 <= s_5684_4
        fn_state.gs_134514 = s_5684_4;
        // N s_5684_6: jump b78
        return block_78(state, tracer, fn_state);
    }
    fn block_5685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5685_0: read-var coproc:u8
        let s_5685_0: u8 = fn_state.coproc;
        // D s_5685_1: cast zx s_5685_0 -> bv
        let s_5685_1: Bits = Bits::new(s_5685_0 as u128, 4u16);
        // C s_5685_2: const #14u : u8
        let s_5685_2: u8 = 14;
        // C s_5685_3: cast zx s_5685_2 -> bv
        let s_5685_3: Bits = Bits::new(s_5685_2 as u128, 4u16);
        // D s_5685_4: cmp-eq s_5685_1 s_5685_3
        let s_5685_4: bool = ((s_5685_1) == (s_5685_3));
        // D s_5685_5: write-var gs#134513 <= s_5685_4
        fn_state.gs_134513 = s_5685_4;
        // N s_5685_6: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_5686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5686_0: read-var CRn:u8
        let s_5686_0: u8 = fn_state.CRn;
        // D s_5686_1: cast zx s_5686_0 -> bv
        let s_5686_1: Bits = Bits::new(s_5686_0 as u128, 4u16);
        // C s_5686_2: const #1u : u8
        let s_5686_2: u8 = 1;
        // C s_5686_3: cast zx s_5686_2 -> bv
        let s_5686_3: Bits = Bits::new(s_5686_2 as u128, 4u16);
        // D s_5686_4: cmp-eq s_5686_1 s_5686_3
        let s_5686_4: bool = ((s_5686_1) == (s_5686_3));
        // D s_5686_5: write-var gs#134512 <= s_5686_4
        fn_state.gs_134512 = s_5686_4;
        // N s_5686_6: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_5687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5687_0: read-var el:u8
        let s_5687_0: u8 = fn_state.el;
        // D s_5687_1: read-var coproc:u8
        let s_5687_1: u8 = fn_state.coproc;
        // D s_5687_2: read-var opc1:u8
        let s_5687_2: u8 = fn_state.opc1;
        // D s_5687_3: read-var CRn:u8
        let s_5687_3: u8 = fn_state.CRn;
        // D s_5687_4: read-var opc2:u8
        let s_5687_4: u8 = fn_state.opc2;
        // D s_5687_5: read-var CRm:u8
        let s_5687_5: u8 = fn_state.CRm;
        // D s_5687_6: read-var t:i
        let s_5687_6: i128 = fn_state.t;
        // D s_5687_7: call CPPRCTX_SysRegWrite32_07d924e6f4753edc(s_5687_0, s_5687_1, s_5687_2, s_5687_3, s_5687_4, s_5687_5, s_5687_6)
        let s_5687_7: () = CPPRCTX_SysRegWrite32_07d924e6f4753edc(
            state,
            tracer,
            s_5687_0,
            s_5687_1,
            s_5687_2,
            s_5687_3,
            s_5687_4,
            s_5687_5,
            s_5687_6,
        );
        // N s_5687_8: return
        return;
    }
    fn block_5688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5688_0: read-var opc2:u8
        let s_5688_0: u8 = fn_state.opc2;
        // D s_5688_1: cast zx s_5688_0 -> bv
        let s_5688_1: Bits = Bits::new(s_5688_0 as u128, 3u16);
        // C s_5688_2: const #7u : u8
        let s_5688_2: u8 = 7;
        // C s_5688_3: cast zx s_5688_2 -> bv
        let s_5688_3: Bits = Bits::new(s_5688_2 as u128, 3u16);
        // D s_5688_4: cmp-eq s_5688_1 s_5688_3
        let s_5688_4: bool = ((s_5688_1) == (s_5688_3));
        // D s_5688_5: write-var gs#134511 <= s_5688_4
        fn_state.gs_134511 = s_5688_4;
        // N s_5688_6: jump b71
        return block_71(state, tracer, fn_state);
    }
    fn block_5689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5689_0: read-var opc1:u8
        let s_5689_0: u8 = fn_state.opc1;
        // D s_5689_1: cast zx s_5689_0 -> bv
        let s_5689_1: Bits = Bits::new(s_5689_0 as u128, 3u16);
        // C s_5689_2: const #0u : u8
        let s_5689_2: u8 = 0;
        // C s_5689_3: cast zx s_5689_2 -> bv
        let s_5689_3: Bits = Bits::new(s_5689_2 as u128, 3u16);
        // D s_5689_4: cmp-eq s_5689_1 s_5689_3
        let s_5689_4: bool = ((s_5689_1) == (s_5689_3));
        // D s_5689_5: write-var gs#134510 <= s_5689_4
        fn_state.gs_134510 = s_5689_4;
        // N s_5689_6: jump b69
        return block_69(state, tracer, fn_state);
    }
    fn block_5690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5690_0: read-var coproc:u8
        let s_5690_0: u8 = fn_state.coproc;
        // D s_5690_1: cast zx s_5690_0 -> bv
        let s_5690_1: Bits = Bits::new(s_5690_0 as u128, 4u16);
        // C s_5690_2: const #15u : u8
        let s_5690_2: u8 = 15;
        // C s_5690_3: cast zx s_5690_2 -> bv
        let s_5690_3: Bits = Bits::new(s_5690_2 as u128, 4u16);
        // D s_5690_4: cmp-eq s_5690_1 s_5690_3
        let s_5690_4: bool = ((s_5690_1) == (s_5690_3));
        // D s_5690_5: write-var gs#134509 <= s_5690_4
        fn_state.gs_134509 = s_5690_4;
        // N s_5690_6: jump b67
        return block_67(state, tracer, fn_state);
    }
    fn block_5691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5691_0: read-var CRn:u8
        let s_5691_0: u8 = fn_state.CRn;
        // D s_5691_1: cast zx s_5691_0 -> bv
        let s_5691_1: Bits = Bits::new(s_5691_0 as u128, 4u16);
        // C s_5691_2: const #7u : u8
        let s_5691_2: u8 = 7;
        // C s_5691_3: cast zx s_5691_2 -> bv
        let s_5691_3: Bits = Bits::new(s_5691_2 as u128, 4u16);
        // D s_5691_4: cmp-eq s_5691_1 s_5691_3
        let s_5691_4: bool = ((s_5691_1) == (s_5691_3));
        // D s_5691_5: write-var gs#134508 <= s_5691_4
        fn_state.gs_134508 = s_5691_4;
        // N s_5691_6: jump b65
        return block_65(state, tracer, fn_state);
    }
    fn block_5692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5692_0: read-var el:u8
        let s_5692_0: u8 = fn_state.el;
        // D s_5692_1: read-var coproc:u8
        let s_5692_1: u8 = fn_state.coproc;
        // D s_5692_2: read-var opc1:u8
        let s_5692_2: u8 = fn_state.opc1;
        // D s_5692_3: read-var CRn:u8
        let s_5692_3: u8 = fn_state.CRn;
        // D s_5692_4: read-var opc2:u8
        let s_5692_4: u8 = fn_state.opc2;
        // D s_5692_5: read-var CRm:u8
        let s_5692_5: u8 = fn_state.CRm;
        // D s_5692_6: read-var t:i
        let s_5692_6: i128 = fn_state.t;
        // D s_5692_7: call HCR_SysRegWrite32_968f9ec8dcacddcc(s_5692_0, s_5692_1, s_5692_2, s_5692_3, s_5692_4, s_5692_5, s_5692_6)
        let s_5692_7: () = HCR_SysRegWrite32_968f9ec8dcacddcc(
            state,
            tracer,
            s_5692_0,
            s_5692_1,
            s_5692_2,
            s_5692_3,
            s_5692_4,
            s_5692_5,
            s_5692_6,
        );
        // N s_5692_8: return
        return;
    }
    fn block_5693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5693_0: read-var opc2:u8
        let s_5693_0: u8 = fn_state.opc2;
        // D s_5693_1: cast zx s_5693_0 -> bv
        let s_5693_1: Bits = Bits::new(s_5693_0 as u128, 3u16);
        // C s_5693_2: const #0u : u8
        let s_5693_2: u8 = 0;
        // C s_5693_3: cast zx s_5693_2 -> bv
        let s_5693_3: Bits = Bits::new(s_5693_2 as u128, 3u16);
        // D s_5693_4: cmp-eq s_5693_1 s_5693_3
        let s_5693_4: bool = ((s_5693_1) == (s_5693_3));
        // D s_5693_5: write-var gs#134507 <= s_5693_4
        fn_state.gs_134507 = s_5693_4;
        // N s_5693_6: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_5694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5694_0: read-var opc1:u8
        let s_5694_0: u8 = fn_state.opc1;
        // D s_5694_1: cast zx s_5694_0 -> bv
        let s_5694_1: Bits = Bits::new(s_5694_0 as u128, 3u16);
        // C s_5694_2: const #4u : u8
        let s_5694_2: u8 = 4;
        // C s_5694_3: cast zx s_5694_2 -> bv
        let s_5694_3: Bits = Bits::new(s_5694_2 as u128, 3u16);
        // D s_5694_4: cmp-eq s_5694_1 s_5694_3
        let s_5694_4: bool = ((s_5694_1) == (s_5694_3));
        // D s_5694_5: write-var gs#134506 <= s_5694_4
        fn_state.gs_134506 = s_5694_4;
        // N s_5694_6: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_5695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5695_0: read-var coproc:u8
        let s_5695_0: u8 = fn_state.coproc;
        // D s_5695_1: cast zx s_5695_0 -> bv
        let s_5695_1: Bits = Bits::new(s_5695_0 as u128, 4u16);
        // C s_5695_2: const #15u : u8
        let s_5695_2: u8 = 15;
        // C s_5695_3: cast zx s_5695_2 -> bv
        let s_5695_3: Bits = Bits::new(s_5695_2 as u128, 4u16);
        // D s_5695_4: cmp-eq s_5695_1 s_5695_3
        let s_5695_4: bool = ((s_5695_1) == (s_5695_3));
        // D s_5695_5: write-var gs#134505 <= s_5695_4
        fn_state.gs_134505 = s_5695_4;
        // N s_5695_6: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_5696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5696_0: read-var CRn:u8
        let s_5696_0: u8 = fn_state.CRn;
        // D s_5696_1: cast zx s_5696_0 -> bv
        let s_5696_1: Bits = Bits::new(s_5696_0 as u128, 4u16);
        // C s_5696_2: const #1u : u8
        let s_5696_2: u8 = 1;
        // C s_5696_3: cast zx s_5696_2 -> bv
        let s_5696_3: Bits = Bits::new(s_5696_2 as u128, 4u16);
        // D s_5696_4: cmp-eq s_5696_1 s_5696_3
        let s_5696_4: bool = ((s_5696_1) == (s_5696_3));
        // D s_5696_5: write-var gs#134504 <= s_5696_4
        fn_state.gs_134504 = s_5696_4;
        // N s_5696_6: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_5697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5697_0: read-var el:u8
        let s_5697_0: u8 = fn_state.el;
        // D s_5697_1: read-var coproc:u8
        let s_5697_1: u8 = fn_state.coproc;
        // D s_5697_2: read-var opc1:u8
        let s_5697_2: u8 = fn_state.opc1;
        // D s_5697_3: read-var CRn:u8
        let s_5697_3: u8 = fn_state.CRn;
        // D s_5697_4: read-var opc2:u8
        let s_5697_4: u8 = fn_state.opc2;
        // D s_5697_5: read-var CRm:u8
        let s_5697_5: u8 = fn_state.CRm;
        // D s_5697_6: read-var t:i
        let s_5697_6: i128 = fn_state.t;
        // D s_5697_7: call PMXEVCNTR_SysRegWrite32_4f0aa881614b1f11(s_5697_0, s_5697_1, s_5697_2, s_5697_3, s_5697_4, s_5697_5, s_5697_6)
        let s_5697_7: () = PMXEVCNTR_SysRegWrite32_4f0aa881614b1f11(
            state,
            tracer,
            s_5697_0,
            s_5697_1,
            s_5697_2,
            s_5697_3,
            s_5697_4,
            s_5697_5,
            s_5697_6,
        );
        // N s_5697_8: return
        return;
    }
    fn block_5698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5698_0: read-var opc2:u8
        let s_5698_0: u8 = fn_state.opc2;
        // D s_5698_1: cast zx s_5698_0 -> bv
        let s_5698_1: Bits = Bits::new(s_5698_0 as u128, 3u16);
        // C s_5698_2: const #2u : u8
        let s_5698_2: u8 = 2;
        // C s_5698_3: cast zx s_5698_2 -> bv
        let s_5698_3: Bits = Bits::new(s_5698_2 as u128, 3u16);
        // D s_5698_4: cmp-eq s_5698_1 s_5698_3
        let s_5698_4: bool = ((s_5698_1) == (s_5698_3));
        // D s_5698_5: write-var gs#134503 <= s_5698_4
        fn_state.gs_134503 = s_5698_4;
        // N s_5698_6: jump b53
        return block_53(state, tracer, fn_state);
    }
    fn block_5699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5699_0: read-var opc1:u8
        let s_5699_0: u8 = fn_state.opc1;
        // D s_5699_1: cast zx s_5699_0 -> bv
        let s_5699_1: Bits = Bits::new(s_5699_0 as u128, 3u16);
        // C s_5699_2: const #0u : u8
        let s_5699_2: u8 = 0;
        // C s_5699_3: cast zx s_5699_2 -> bv
        let s_5699_3: Bits = Bits::new(s_5699_2 as u128, 3u16);
        // D s_5699_4: cmp-eq s_5699_1 s_5699_3
        let s_5699_4: bool = ((s_5699_1) == (s_5699_3));
        // D s_5699_5: write-var gs#134502 <= s_5699_4
        fn_state.gs_134502 = s_5699_4;
        // N s_5699_6: jump b51
        return block_51(state, tracer, fn_state);
    }
    fn block_5700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5700_0: read-var coproc:u8
        let s_5700_0: u8 = fn_state.coproc;
        // D s_5700_1: cast zx s_5700_0 -> bv
        let s_5700_1: Bits = Bits::new(s_5700_0 as u128, 4u16);
        // C s_5700_2: const #15u : u8
        let s_5700_2: u8 = 15;
        // C s_5700_3: cast zx s_5700_2 -> bv
        let s_5700_3: Bits = Bits::new(s_5700_2 as u128, 4u16);
        // D s_5700_4: cmp-eq s_5700_1 s_5700_3
        let s_5700_4: bool = ((s_5700_1) == (s_5700_3));
        // D s_5700_5: write-var gs#134501 <= s_5700_4
        fn_state.gs_134501 = s_5700_4;
        // N s_5700_6: jump b49
        return block_49(state, tracer, fn_state);
    }
    fn block_5701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5701_0: read-var CRn:u8
        let s_5701_0: u8 = fn_state.CRn;
        // D s_5701_1: cast zx s_5701_0 -> bv
        let s_5701_1: Bits = Bits::new(s_5701_0 as u128, 4u16);
        // C s_5701_2: const #9u : u8
        let s_5701_2: u8 = 9;
        // C s_5701_3: cast zx s_5701_2 -> bv
        let s_5701_3: Bits = Bits::new(s_5701_2 as u128, 4u16);
        // D s_5701_4: cmp-eq s_5701_1 s_5701_3
        let s_5701_4: bool = ((s_5701_1) == (s_5701_3));
        // D s_5701_5: write-var gs#134500 <= s_5701_4
        fn_state.gs_134500 = s_5701_4;
        // N s_5701_6: jump b47
        return block_47(state, tracer, fn_state);
    }
    fn block_5702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5702_0: read-var el:u8
        let s_5702_0: u8 = fn_state.el;
        // D s_5702_1: read-var coproc:u8
        let s_5702_1: u8 = fn_state.coproc;
        // D s_5702_2: read-var opc1:u8
        let s_5702_2: u8 = fn_state.opc1;
        // D s_5702_3: read-var CRn:u8
        let s_5702_3: u8 = fn_state.CRn;
        // D s_5702_4: read-var opc2:u8
        let s_5702_4: u8 = fn_state.opc2;
        // D s_5702_5: read-var CRm:u8
        let s_5702_5: u8 = fn_state.CRm;
        // D s_5702_6: read-var t:i
        let s_5702_6: i128 = fn_state.t;
        // D s_5702_7: call TTBCR_SysRegWrite32_4607ff14cabf6694(s_5702_0, s_5702_1, s_5702_2, s_5702_3, s_5702_4, s_5702_5, s_5702_6)
        let s_5702_7: () = TTBCR_SysRegWrite32_4607ff14cabf6694(
            state,
            tracer,
            s_5702_0,
            s_5702_1,
            s_5702_2,
            s_5702_3,
            s_5702_4,
            s_5702_5,
            s_5702_6,
        );
        // N s_5702_8: return
        return;
    }
    fn block_5703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5703_0: read-var opc2:u8
        let s_5703_0: u8 = fn_state.opc2;
        // D s_5703_1: cast zx s_5703_0 -> bv
        let s_5703_1: Bits = Bits::new(s_5703_0 as u128, 3u16);
        // C s_5703_2: const #2u : u8
        let s_5703_2: u8 = 2;
        // C s_5703_3: cast zx s_5703_2 -> bv
        let s_5703_3: Bits = Bits::new(s_5703_2 as u128, 3u16);
        // D s_5703_4: cmp-eq s_5703_1 s_5703_3
        let s_5703_4: bool = ((s_5703_1) == (s_5703_3));
        // D s_5703_5: write-var gs#134499 <= s_5703_4
        fn_state.gs_134499 = s_5703_4;
        // N s_5703_6: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_5704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5704_0: read-var opc1:u8
        let s_5704_0: u8 = fn_state.opc1;
        // D s_5704_1: cast zx s_5704_0 -> bv
        let s_5704_1: Bits = Bits::new(s_5704_0 as u128, 3u16);
        // C s_5704_2: const #0u : u8
        let s_5704_2: u8 = 0;
        // C s_5704_3: cast zx s_5704_2 -> bv
        let s_5704_3: Bits = Bits::new(s_5704_2 as u128, 3u16);
        // D s_5704_4: cmp-eq s_5704_1 s_5704_3
        let s_5704_4: bool = ((s_5704_1) == (s_5704_3));
        // D s_5704_5: write-var gs#134498 <= s_5704_4
        fn_state.gs_134498 = s_5704_4;
        // N s_5704_6: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_5705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5705_0: read-var coproc:u8
        let s_5705_0: u8 = fn_state.coproc;
        // D s_5705_1: cast zx s_5705_0 -> bv
        let s_5705_1: Bits = Bits::new(s_5705_0 as u128, 4u16);
        // C s_5705_2: const #15u : u8
        let s_5705_2: u8 = 15;
        // C s_5705_3: cast zx s_5705_2 -> bv
        let s_5705_3: Bits = Bits::new(s_5705_2 as u128, 4u16);
        // D s_5705_4: cmp-eq s_5705_1 s_5705_3
        let s_5705_4: bool = ((s_5705_1) == (s_5705_3));
        // D s_5705_5: write-var gs#134497 <= s_5705_4
        fn_state.gs_134497 = s_5705_4;
        // N s_5705_6: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_5706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5706_0: read-var CRn:u8
        let s_5706_0: u8 = fn_state.CRn;
        // D s_5706_1: cast zx s_5706_0 -> bv
        let s_5706_1: Bits = Bits::new(s_5706_0 as u128, 4u16);
        // C s_5706_2: const #2u : u8
        let s_5706_2: u8 = 2;
        // C s_5706_3: cast zx s_5706_2 -> bv
        let s_5706_3: Bits = Bits::new(s_5706_2 as u128, 4u16);
        // D s_5706_4: cmp-eq s_5706_1 s_5706_3
        let s_5706_4: bool = ((s_5706_1) == (s_5706_3));
        // D s_5706_5: write-var gs#134496 <= s_5706_4
        fn_state.gs_134496 = s_5706_4;
        // N s_5706_6: jump b38
        return block_38(state, tracer, fn_state);
    }
    fn block_5707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5707_0: read-var el:u8
        let s_5707_0: u8 = fn_state.el;
        // D s_5707_1: read-var coproc:u8
        let s_5707_1: u8 = fn_state.coproc;
        // D s_5707_2: read-var opc1:u8
        let s_5707_2: u8 = fn_state.opc1;
        // D s_5707_3: read-var CRn:u8
        let s_5707_3: u8 = fn_state.CRn;
        // D s_5707_4: read-var opc2:u8
        let s_5707_4: u8 = fn_state.opc2;
        // D s_5707_5: read-var CRm:u8
        let s_5707_5: u8 = fn_state.CRm;
        // D s_5707_6: read-var t:i
        let s_5707_6: i128 = fn_state.t;
        // D s_5707_7: call TTBR0_SysRegWrite32_455c3a8e0a51a871(s_5707_0, s_5707_1, s_5707_2, s_5707_3, s_5707_4, s_5707_5, s_5707_6)
        let s_5707_7: () = TTBR0_SysRegWrite32_455c3a8e0a51a871(
            state,
            tracer,
            s_5707_0,
            s_5707_1,
            s_5707_2,
            s_5707_3,
            s_5707_4,
            s_5707_5,
            s_5707_6,
        );
        // N s_5707_8: return
        return;
    }
    fn block_5708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5708_0: read-var opc2:u8
        let s_5708_0: u8 = fn_state.opc2;
        // D s_5708_1: cast zx s_5708_0 -> bv
        let s_5708_1: Bits = Bits::new(s_5708_0 as u128, 3u16);
        // C s_5708_2: const #0u : u8
        let s_5708_2: u8 = 0;
        // C s_5708_3: cast zx s_5708_2 -> bv
        let s_5708_3: Bits = Bits::new(s_5708_2 as u128, 3u16);
        // D s_5708_4: cmp-eq s_5708_1 s_5708_3
        let s_5708_4: bool = ((s_5708_1) == (s_5708_3));
        // D s_5708_5: write-var gs#134495 <= s_5708_4
        fn_state.gs_134495 = s_5708_4;
        // N s_5708_6: jump b35
        return block_35(state, tracer, fn_state);
    }
    fn block_5709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5709_0: read-var opc1:u8
        let s_5709_0: u8 = fn_state.opc1;
        // D s_5709_1: cast zx s_5709_0 -> bv
        let s_5709_1: Bits = Bits::new(s_5709_0 as u128, 3u16);
        // C s_5709_2: const #0u : u8
        let s_5709_2: u8 = 0;
        // C s_5709_3: cast zx s_5709_2 -> bv
        let s_5709_3: Bits = Bits::new(s_5709_2 as u128, 3u16);
        // D s_5709_4: cmp-eq s_5709_1 s_5709_3
        let s_5709_4: bool = ((s_5709_1) == (s_5709_3));
        // D s_5709_5: write-var gs#134494 <= s_5709_4
        fn_state.gs_134494 = s_5709_4;
        // N s_5709_6: jump b33
        return block_33(state, tracer, fn_state);
    }
    fn block_5710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5710_0: read-var coproc:u8
        let s_5710_0: u8 = fn_state.coproc;
        // D s_5710_1: cast zx s_5710_0 -> bv
        let s_5710_1: Bits = Bits::new(s_5710_0 as u128, 4u16);
        // C s_5710_2: const #15u : u8
        let s_5710_2: u8 = 15;
        // C s_5710_3: cast zx s_5710_2 -> bv
        let s_5710_3: Bits = Bits::new(s_5710_2 as u128, 4u16);
        // D s_5710_4: cmp-eq s_5710_1 s_5710_3
        let s_5710_4: bool = ((s_5710_1) == (s_5710_3));
        // D s_5710_5: write-var gs#134493 <= s_5710_4
        fn_state.gs_134493 = s_5710_4;
        // N s_5710_6: jump b31
        return block_31(state, tracer, fn_state);
    }
    fn block_5711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5711_0: read-var CRn:u8
        let s_5711_0: u8 = fn_state.CRn;
        // D s_5711_1: cast zx s_5711_0 -> bv
        let s_5711_1: Bits = Bits::new(s_5711_0 as u128, 4u16);
        // C s_5711_2: const #2u : u8
        let s_5711_2: u8 = 2;
        // C s_5711_3: cast zx s_5711_2 -> bv
        let s_5711_3: Bits = Bits::new(s_5711_2 as u128, 4u16);
        // D s_5711_4: cmp-eq s_5711_1 s_5711_3
        let s_5711_4: bool = ((s_5711_1) == (s_5711_3));
        // D s_5711_5: write-var gs#134492 <= s_5711_4
        fn_state.gs_134492 = s_5711_4;
        // N s_5711_6: jump b29
        return block_29(state, tracer, fn_state);
    }
    fn block_5712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5712_0: read-var el:u8
        let s_5712_0: u8 = fn_state.el;
        // D s_5712_1: read-var coproc:u8
        let s_5712_1: u8 = fn_state.coproc;
        // D s_5712_2: read-var opc1:u8
        let s_5712_2: u8 = fn_state.opc1;
        // D s_5712_3: read-var CRn:u8
        let s_5712_3: u8 = fn_state.CRn;
        // D s_5712_4: read-var opc2:u8
        let s_5712_4: u8 = fn_state.opc2;
        // D s_5712_5: read-var CRm:u8
        let s_5712_5: u8 = fn_state.CRm;
        // D s_5712_6: read-var t:i
        let s_5712_6: i128 = fn_state.t;
        // D s_5712_7: call TTBR1_SysRegWrite32_388bd96b6dea14cc(s_5712_0, s_5712_1, s_5712_2, s_5712_3, s_5712_4, s_5712_5, s_5712_6)
        let s_5712_7: () = TTBR1_SysRegWrite32_388bd96b6dea14cc(
            state,
            tracer,
            s_5712_0,
            s_5712_1,
            s_5712_2,
            s_5712_3,
            s_5712_4,
            s_5712_5,
            s_5712_6,
        );
        // N s_5712_8: return
        return;
    }
    fn block_5713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5713_0: read-var opc2:u8
        let s_5713_0: u8 = fn_state.opc2;
        // D s_5713_1: cast zx s_5713_0 -> bv
        let s_5713_1: Bits = Bits::new(s_5713_0 as u128, 3u16);
        // C s_5713_2: const #1u : u8
        let s_5713_2: u8 = 1;
        // C s_5713_3: cast zx s_5713_2 -> bv
        let s_5713_3: Bits = Bits::new(s_5713_2 as u128, 3u16);
        // D s_5713_4: cmp-eq s_5713_1 s_5713_3
        let s_5713_4: bool = ((s_5713_1) == (s_5713_3));
        // D s_5713_5: write-var gs#134491 <= s_5713_4
        fn_state.gs_134491 = s_5713_4;
        // N s_5713_6: jump b26
        return block_26(state, tracer, fn_state);
    }
    fn block_5714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5714_0: read-var opc1:u8
        let s_5714_0: u8 = fn_state.opc1;
        // D s_5714_1: cast zx s_5714_0 -> bv
        let s_5714_1: Bits = Bits::new(s_5714_0 as u128, 3u16);
        // C s_5714_2: const #0u : u8
        let s_5714_2: u8 = 0;
        // C s_5714_3: cast zx s_5714_2 -> bv
        let s_5714_3: Bits = Bits::new(s_5714_2 as u128, 3u16);
        // D s_5714_4: cmp-eq s_5714_1 s_5714_3
        let s_5714_4: bool = ((s_5714_1) == (s_5714_3));
        // D s_5714_5: write-var gs#134490 <= s_5714_4
        fn_state.gs_134490 = s_5714_4;
        // N s_5714_6: jump b24
        return block_24(state, tracer, fn_state);
    }
    fn block_5715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5715_0: read-var coproc:u8
        let s_5715_0: u8 = fn_state.coproc;
        // D s_5715_1: cast zx s_5715_0 -> bv
        let s_5715_1: Bits = Bits::new(s_5715_0 as u128, 4u16);
        // C s_5715_2: const #15u : u8
        let s_5715_2: u8 = 15;
        // C s_5715_3: cast zx s_5715_2 -> bv
        let s_5715_3: Bits = Bits::new(s_5715_2 as u128, 4u16);
        // D s_5715_4: cmp-eq s_5715_1 s_5715_3
        let s_5715_4: bool = ((s_5715_1) == (s_5715_3));
        // D s_5715_5: write-var gs#134489 <= s_5715_4
        fn_state.gs_134489 = s_5715_4;
        // N s_5715_6: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_5716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5716_0: read-var CRn:u8
        let s_5716_0: u8 = fn_state.CRn;
        // D s_5716_1: cast zx s_5716_0 -> bv
        let s_5716_1: Bits = Bits::new(s_5716_0 as u128, 4u16);
        // C s_5716_2: const #2u : u8
        let s_5716_2: u8 = 2;
        // C s_5716_3: cast zx s_5716_2 -> bv
        let s_5716_3: Bits = Bits::new(s_5716_2 as u128, 4u16);
        // D s_5716_4: cmp-eq s_5716_1 s_5716_3
        let s_5716_4: bool = ((s_5716_1) == (s_5716_3));
        // D s_5716_5: write-var gs#134488 <= s_5716_4
        fn_state.gs_134488 = s_5716_4;
        // N s_5716_6: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_5717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5717_0: read-var el:u8
        let s_5717_0: u8 = fn_state.el;
        // D s_5717_1: read-var coproc:u8
        let s_5717_1: u8 = fn_state.coproc;
        // D s_5717_2: read-var opc1:u8
        let s_5717_2: u8 = fn_state.opc1;
        // D s_5717_3: read-var CRn:u8
        let s_5717_3: u8 = fn_state.CRn;
        // D s_5717_4: read-var opc2:u8
        let s_5717_4: u8 = fn_state.opc2;
        // D s_5717_5: read-var CRm:u8
        let s_5717_5: u8 = fn_state.CRm;
        // D s_5717_6: read-var t:i
        let s_5717_6: i128 = fn_state.t;
        // D s_5717_7: call PMCCNTR_SysRegWrite32_2765928b3dd6404e(s_5717_0, s_5717_1, s_5717_2, s_5717_3, s_5717_4, s_5717_5, s_5717_6)
        let s_5717_7: () = PMCCNTR_SysRegWrite32_2765928b3dd6404e(
            state,
            tracer,
            s_5717_0,
            s_5717_1,
            s_5717_2,
            s_5717_3,
            s_5717_4,
            s_5717_5,
            s_5717_6,
        );
        // N s_5717_8: return
        return;
    }
    fn block_5718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5718_0: read-var opc2:u8
        let s_5718_0: u8 = fn_state.opc2;
        // D s_5718_1: cast zx s_5718_0 -> bv
        let s_5718_1: Bits = Bits::new(s_5718_0 as u128, 3u16);
        // C s_5718_2: const #0u : u8
        let s_5718_2: u8 = 0;
        // C s_5718_3: cast zx s_5718_2 -> bv
        let s_5718_3: Bits = Bits::new(s_5718_2 as u128, 3u16);
        // D s_5718_4: cmp-eq s_5718_1 s_5718_3
        let s_5718_4: bool = ((s_5718_1) == (s_5718_3));
        // D s_5718_5: write-var gs#134487 <= s_5718_4
        fn_state.gs_134487 = s_5718_4;
        // N s_5718_6: jump b17
        return block_17(state, tracer, fn_state);
    }
    fn block_5719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5719_0: read-var opc1:u8
        let s_5719_0: u8 = fn_state.opc1;
        // D s_5719_1: cast zx s_5719_0 -> bv
        let s_5719_1: Bits = Bits::new(s_5719_0 as u128, 3u16);
        // C s_5719_2: const #0u : u8
        let s_5719_2: u8 = 0;
        // C s_5719_3: cast zx s_5719_2 -> bv
        let s_5719_3: Bits = Bits::new(s_5719_2 as u128, 3u16);
        // D s_5719_4: cmp-eq s_5719_1 s_5719_3
        let s_5719_4: bool = ((s_5719_1) == (s_5719_3));
        // D s_5719_5: write-var gs#134486 <= s_5719_4
        fn_state.gs_134486 = s_5719_4;
        // N s_5719_6: jump b15
        return block_15(state, tracer, fn_state);
    }
    fn block_5720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5720_0: read-var coproc:u8
        let s_5720_0: u8 = fn_state.coproc;
        // D s_5720_1: cast zx s_5720_0 -> bv
        let s_5720_1: Bits = Bits::new(s_5720_0 as u128, 4u16);
        // C s_5720_2: const #15u : u8
        let s_5720_2: u8 = 15;
        // C s_5720_3: cast zx s_5720_2 -> bv
        let s_5720_3: Bits = Bits::new(s_5720_2 as u128, 4u16);
        // D s_5720_4: cmp-eq s_5720_1 s_5720_3
        let s_5720_4: bool = ((s_5720_1) == (s_5720_3));
        // D s_5720_5: write-var gs#134485 <= s_5720_4
        fn_state.gs_134485 = s_5720_4;
        // N s_5720_6: jump b13
        return block_13(state, tracer, fn_state);
    }
    fn block_5721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5721_0: read-var CRn:u8
        let s_5721_0: u8 = fn_state.CRn;
        // D s_5721_1: cast zx s_5721_0 -> bv
        let s_5721_1: Bits = Bits::new(s_5721_0 as u128, 4u16);
        // C s_5721_2: const #9u : u8
        let s_5721_2: u8 = 9;
        // C s_5721_3: cast zx s_5721_2 -> bv
        let s_5721_3: Bits = Bits::new(s_5721_2 as u128, 4u16);
        // D s_5721_4: cmp-eq s_5721_1 s_5721_3
        let s_5721_4: bool = ((s_5721_1) == (s_5721_3));
        // D s_5721_5: write-var gs#134484 <= s_5721_4
        fn_state.gs_134484 = s_5721_4;
        // N s_5721_6: jump b11
        return block_11(state, tracer, fn_state);
    }
    fn block_5722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5722_0: read-var el:u8
        let s_5722_0: u8 = fn_state.el;
        // D s_5722_1: read-var coproc:u8
        let s_5722_1: u8 = fn_state.coproc;
        // D s_5722_2: read-var opc1:u8
        let s_5722_2: u8 = fn_state.opc1;
        // D s_5722_3: read-var CRn:u8
        let s_5722_3: u8 = fn_state.CRn;
        // D s_5722_4: read-var opc2:u8
        let s_5722_4: u8 = fn_state.opc2;
        // D s_5722_5: read-var CRm:u8
        let s_5722_5: u8 = fn_state.CRm;
        // D s_5722_6: read-var t:i
        let s_5722_6: i128 = fn_state.t;
        // D s_5722_7: call PAR_SysRegWrite32_b3494b8d6e542bfa(s_5722_0, s_5722_1, s_5722_2, s_5722_3, s_5722_4, s_5722_5, s_5722_6)
        let s_5722_7: () = PAR_SysRegWrite32_b3494b8d6e542bfa(
            state,
            tracer,
            s_5722_0,
            s_5722_1,
            s_5722_2,
            s_5722_3,
            s_5722_4,
            s_5722_5,
            s_5722_6,
        );
        // N s_5722_8: return
        return;
    }
    fn block_5723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5723_0: read-var opc2:u8
        let s_5723_0: u8 = fn_state.opc2;
        // D s_5723_1: cast zx s_5723_0 -> bv
        let s_5723_1: Bits = Bits::new(s_5723_0 as u128, 3u16);
        // C s_5723_2: const #0u : u8
        let s_5723_2: u8 = 0;
        // C s_5723_3: cast zx s_5723_2 -> bv
        let s_5723_3: Bits = Bits::new(s_5723_2 as u128, 3u16);
        // D s_5723_4: cmp-eq s_5723_1 s_5723_3
        let s_5723_4: bool = ((s_5723_1) == (s_5723_3));
        // D s_5723_5: write-var gs#134483 <= s_5723_4
        fn_state.gs_134483 = s_5723_4;
        // N s_5723_6: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_5724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5724_0: read-var opc1:u8
        let s_5724_0: u8 = fn_state.opc1;
        // D s_5724_1: cast zx s_5724_0 -> bv
        let s_5724_1: Bits = Bits::new(s_5724_0 as u128, 3u16);
        // C s_5724_2: const #0u : u8
        let s_5724_2: u8 = 0;
        // C s_5724_3: cast zx s_5724_2 -> bv
        let s_5724_3: Bits = Bits::new(s_5724_2 as u128, 3u16);
        // D s_5724_4: cmp-eq s_5724_1 s_5724_3
        let s_5724_4: bool = ((s_5724_1) == (s_5724_3));
        // D s_5724_5: write-var gs#134482 <= s_5724_4
        fn_state.gs_134482 = s_5724_4;
        // N s_5724_6: jump b6
        return block_6(state, tracer, fn_state);
    }
    fn block_5725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5725_0: read-var coproc:u8
        let s_5725_0: u8 = fn_state.coproc;
        // D s_5725_1: cast zx s_5725_0 -> bv
        let s_5725_1: Bits = Bits::new(s_5725_0 as u128, 4u16);
        // C s_5725_2: const #15u : u8
        let s_5725_2: u8 = 15;
        // C s_5725_3: cast zx s_5725_2 -> bv
        let s_5725_3: Bits = Bits::new(s_5725_2 as u128, 4u16);
        // D s_5725_4: cmp-eq s_5725_1 s_5725_3
        let s_5725_4: bool = ((s_5725_1) == (s_5725_3));
        // D s_5725_5: write-var gs#134481 <= s_5725_4
        fn_state.gs_134481 = s_5725_4;
        // N s_5725_6: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_5726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5726_0: read-var CRn:u8
        let s_5726_0: u8 = fn_state.CRn;
        // D s_5726_1: cast zx s_5726_0 -> bv
        let s_5726_1: Bits = Bits::new(s_5726_0 as u128, 4u16);
        // C s_5726_2: const #7u : u8
        let s_5726_2: u8 = 7;
        // C s_5726_3: cast zx s_5726_2 -> bv
        let s_5726_3: Bits = Bits::new(s_5726_2 as u128, 4u16);
        // D s_5726_4: cmp-eq s_5726_1 s_5726_3
        let s_5726_4: bool = ((s_5726_1) == (s_5726_3));
        // D s_5726_5: write-var gs#134480 <= s_5726_4
        fn_state.gs_134480 = s_5726_4;
        // N s_5726_6: jump b2
        return block_2(state, tracer, fn_state);
    }
}
