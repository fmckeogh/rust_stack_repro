#![no_std]
#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_doc_comments)]
#![allow(non_upper_case_globals)]
//! BOREALIS GENERATED FILE
extern crate alloc;
use decode_aarch32_instrs_VMOV_i_A3enc_A_txt::*;
use decode_aarch32_instrs_SETPAN_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOV_i_A5enc_A_txt::*;
use decode_aarch32_instrs_VLD2_m_A2enc_A_txt::*;
use decode_aarch32_instrs_VORN_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VRADDHN_A1enc_A_txt::*;
use decode_aarch32_instrs_VQRDMULH_A2enc_A_txt::*;
use decode_aarch32_instrs_VQSHRN_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD4_1_A1enc_A_txt::*;
use decode_aarch32_instrs_SHA256SU1_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD3_m_A1enc_A_txt::*;
use decode_aarch32_instrs_VST3_1_A3enc_A_txt::*;
use decode_aarch32_instrs_VRSUBHN_A1enc_A_txt::*;
use decode_aarch32_instrs_VCGT_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VABA_A2enc_A_txt::*;
use decode_aarch32_instrs_VCLT_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VMAX_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VQRDMLAH_A1enc_A_txt::*;
use decode_aarch32_instrs_AESMC_A1enc_A_txt::*;
use decode_aarch32_instrs_VBIC_i_A2enc_A_txt::*;
use decode_aarch32_instrs_VMVN_i_A3enc_A_txt::*;
use decode_aarch32_instrs_VCLZ_A1enc_A_txt::*;
use decode_aarch32_instrs_VSHRN_A1enc_A_txt::*;
use decode_aarch32_instrs_VQDMLSL_A2enc_A_txt::*;
use decode_aarch32_instrs_SHA1SU1_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD1_a_A1enc_A_txt::*;
use decode_aarch32_instrs_VADD_f_A1enc_A_txt::*;
use decode_aarch32_instrs_VQDMULL_A2enc_A_txt::*;
use decode_aarch32_instrs_SHA256SU0_A1enc_A_txt::*;
use decode_aarch32_instrs_VRINTX_asimd_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD4_m_A1enc_A_txt::*;
use decode_aarch32_instrs_DSB_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD3_1_A3enc_A_txt::*;
use decode_aarch32_instrs_VABD_f_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOVN_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD1_m_A2enc_A_txt::*;
use decode_aarch32_instrs_PLD_l_A1enc_A_txt::*;
use decode_aarch32_instrs_CLREX_A1enc_A_txt::*;
use decode_aarch32_instrs_VABD_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VMUL_f_A1enc_A_txt::*;
use decode_aarch32_instrs_VNEG_A1enc_A_txt::*;
use decode_aarch32_instrs_VORR_i_A2enc_A_txt::*;
use decode_aarch32_instrs_VPMAX_f_A1enc_A_txt::*;
use decode_aarch32_instrs_VPMAX_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VQDMLAL_A2enc_A_txt::*;
use decode_aarch32_instrs_VPADD_f_A1enc_A_txt::*;
use decode_aarch32_instrs_VQDMLAL_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD1_1_A3enc_A_txt::*;
use decode_aarch32_instrs_VEOR_A1enc_A_txt::*;
use decode_aarch32_instrs_VEXT_A1enc_A_txt::*;
use decode_aarch32_instrs_VCEQ_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD2_m_A1enc_A_txt::*;
use decode_aarch32_instrs_VMUL_s_A2enc_A_txt::*;
use decode_aarch32_instrs_VRSQRTE_A1enc_A_txt::*;
use decode_aarch32_instrs_VST1_1_A2enc_A_txt::*;
use decode_aarch32_instrs_VMLA_i_A2enc_A_txt::*;
use decode_aarch32_instrs_VST1_1_A3enc_A_txt::*;
use decode_aarch32_instrs_VST1_m_A1enc_A_txt::*;
use decode_aarch32_instrs_SETEND_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD1_m_A4enc_A_txt::*;
use decode_aarch32_instrs_VLD3_1_A2enc_A_txt::*;
use decode_aarch32_instrs_VAND_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD1_m_A1enc_A_txt::*;
use decode_aarch32_instrs_VUZP_A1enc_A_txt::*;
use decode_aarch32_instrs_AESD_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOVL_A1enc_A_txt::*;
use decode_aarch32_instrs_VRSQRTS_A1enc_A_txt::*;
use decode_aarch32_instrs_VMLA_f_A1enc_A_txt::*;
use decode_aarch32_instrs_VRECPE_A1enc_A_txt::*;
use decode_aarch32_instrs_VHADD_A1enc_A_txt::*;
use decode_aarch32_instrs_VREV16_A1enc_A_txt::*;
use decode_aarch32_instrs_VQRDMLSH_A1enc_A_txt::*;
use decode_aarch32_instrs_VRSRA_A1enc_A_txt::*;
use decode_aarch32_instrs_VST2_1_A2enc_A_txt::*;
use decode_aarch32_instrs_VADD_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VORR_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VQRSHL_A1enc_A_txt::*;
use decode_aarch32_instrs_VST2_m_A2enc_A_txt::*;
use decode_aarch32_instrs_SHA1P_A1enc_A_txt::*;
use decode_aarch32_instrs_VQDMULL_A1enc_A_txt::*;
use decode_aarch32_instrs_VPADD_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VST1_m_A3enc_A_txt::*;
use decode_aarch32_instrs_VRINTZ_asimd_A1enc_A_txt::*;
use decode_aarch32_instrs_VSWP_A1enc_A_txt::*;
use decode_aarch32_instrs_VTRN_A1enc_A_txt::*;
use decode_aarch32_instrs_PSSBB_A1enc_A_txt::*;
use decode_aarch32_instrs_VQMOVN_A1enc_A_txt::*;
use decode_aarch32_instrs_VSUBL_A1enc_A_txt::*;
use decode_aarch32_instrs_VSHLL_A2enc_A_txt::*;
use decode_aarch32_instrs_VSLI_A1enc_A_txt::*;
use decode_aarch32_instrs_VSHR_A1enc_A_txt::*;
use decode_aarch32_instrs_VST2_m_A1enc_A_txt::*;
use decode_aarch32_instrs_VMLA_i_A1enc_A_txt::*;
use decode_aarch32_instrs_SHA256H_A1enc_A_txt::*;
use decode_aarch32_instrs_VSUB_f_A1enc_A_txt::*;
use decode_aarch32_instrs_VZIP_A1enc_A_txt::*;
use decode_aarch32_instrs_VBIC_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VMUL_s_A1enc_A_txt::*;
use decode_aarch32_instrs_VCGT_r_A2enc_A_txt::*;
use decode_aarch32_instrs_VBIF_A1enc_A_txt::*;
use decode_aarch32_instrs_DMB_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD4_1_A3enc_A_txt::*;
use decode_aarch32_instrs_VLD2_1_A1enc_A_txt::*;
use decode_aarch32_instrs_VQSHL_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VCVT_is_A1enc_A_txt::*;
use decode_aarch32_instrs_VACGE_A1enc_A_txt::*;
use decode_aarch32_instrs_VCNT_A1enc_A_txt::*;
use decode_aarch32_instrs_VQSUB_A1enc_A_txt::*;
use decode_aarch32_instrs_VPADDL_A1enc_A_txt::*;
use decode_aarch32_instrs_VMUL_i_A2enc_A_txt::*;
use decode_aarch32_instrs_VRSHR_A1enc_A_txt::*;
use decode_aarch32_instrs_VQRDMLAH_A2enc_A_txt::*;
use decode_aarch32_instrs_VST1_m_A4enc_A_txt::*;
use decode_aarch32_instrs_VLD3_a_A1enc_A_txt::*;
use decode_aarch32_instrs_VST4_m_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD1_1_A2enc_A_txt::*;
use decode_aarch32_instrs_VST3_m_A1enc_A_txt::*;
use decode_aarch32_instrs_VQADD_A1enc_A_txt::*;
use decode_aarch32_instrs_PLI_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VQDMULH_A1enc_A_txt::*;
use decode_aarch32_instrs_VST4_1_A3enc_A_txt::*;
use decode_aarch32_instrs_SHA1C_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD2_1_A3enc_A_txt::*;
use decode_aarch32_instrs_VMVN_i_A2enc_A_txt::*;
use decode_aarch32_instrs_VST2_1_A3enc_A_txt::*;
use decode_aarch32_instrs_SHA1SU0_A1enc_A_txt::*;
use decode_aarch32_instrs_VPADAL_A1enc_A_txt::*;
use decode_aarch32_instrs_VQRSHRN_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOV_i_A4enc_A_txt::*;
use decode_aarch32_instrs_VSHL_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VST1_m_A2enc_A_txt::*;
use decode_aarch32_instrs_VQSHL_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VST4_1_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD1_1_A1enc_A_txt::*;
use decode_aarch32_instrs_VQNEG_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD4_a_A1enc_A_txt::*;
use decode_aarch32_instrs_VRSHL_A1enc_A_txt::*;
use decode_aarch32_instrs_AESIMC_A1enc_A_txt::*;
use decode_aarch32_instrs_VST3_1_A1enc_A_txt::*;
use decode_aarch32_instrs_VBIC_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VST4_1_A2enc_A_txt::*;
use decode_aarch32_instrs_VSUBHN_A1enc_A_txt::*;
use decode_aarch32_instrs_VSRI_A1enc_A_txt::*;
use decode_aarch32_instrs_SHA256H2_A1enc_A_txt::*;
use decode_aarch32_instrs_VMLA_s_A1enc_A_txt::*;
use decode_aarch32_instrs_VFMA_A1enc_A_txt::*;
use decode_aarch32_instrs_VDUP_s_A1enc_A_txt::*;
use decode_aarch32_instrs_ISB_A1enc_A_txt::*;
use decode_aarch32_instrs_VADDL_A1enc_A_txt::*;
use decode_aarch32_instrs_VCEQ_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VRHADD_A1enc_A_txt::*;
use decode_aarch32_instrs_VCGE_r_A2enc_A_txt::*;
use decode_aarch32_instrs_VST3_1_A2enc_A_txt::*;
use decode_aarch32_instrs_VTST_A1enc_A_txt::*;
use decode_aarch32_instrs_AESE_A1enc_A_txt::*;
use decode_aarch32_instrs_VSUB_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VRINTA_asimd_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD3_1_A1enc_A_txt::*;
use decode_aarch32_instrs_VMUL_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD2_a_A1enc_A_txt::*;
use decode_aarch32_instrs_VADDHN_A1enc_A_txt::*;
use decode_aarch32_instrs_VMLA_s_A2enc_A_txt::*;
use decode_aarch32_instrs_VMOV_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VORR_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VQABS_A1enc_A_txt::*;
use decode_aarch32_instrs_VQRDMLSH_A2enc_A_txt::*;
use decode_aarch32_instrs_PLD_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VCVT_xs_A1enc_A_txt::*;
use decode_aarch32_instrs_VMVN_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VSHL_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VTBL_A1enc_A_txt::*;
use decode_aarch32_instrs_SHA1H_A1enc_A_txt::*;
use decode_aarch32_instrs_VQDMULH_A2enc_A_txt::*;
use decode_aarch32_instrs_VMAXNM_A1enc_A_txt::*;
use decode_aarch32_instrs_VCVT_A1enc_A_txt::*;
use decode_aarch32_instrs_PLI_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VSRA_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD4_1_A2enc_A_txt::*;
use decode_aarch32_instrs_VCGE_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VRECPS_A1enc_A_txt::*;
use decode_aarch32_instrs_VCLS_A1enc_A_txt::*;
use decode_aarch32_instrs_PLD_i_A1enc_A_txt::*;
use decode_aarch32_instrs_CPS_A1enc_AS_txt::*;
use decode_aarch32_instrs_VCGT_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VST2_1_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD1_m_A3enc_A_txt::*;
use decode_aarch32_instrs_SHA1M_A1enc_A_txt::*;
use decode_aarch32_instrs_VCVTA_asimd_A1enc_A_txt::*;
use decode_aarch32_instrs_VMAX_f_A1enc_A_txt::*;
use decode_aarch32_instrs_VCEQ_r_A2enc_A_txt::*;
use decode_aarch32_instrs_SB_A1enc_A_txt::*;
use decode_aarch32_instrs_VCVT_hs_A1enc_A_txt::*;
use decode_aarch32_instrs_VABD_i_A2enc_A_txt::*;
use decode_aarch32_instrs_VCGE_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VLD2_1_A2enc_A_txt::*;
use decode_aarch32_instrs_VRSHRN_A1enc_A_txt::*;
use decode_aarch32_instrs_VSHLL_A1enc_A_txt::*;
use decode_aarch32_instrs_VST1_1_A1enc_A_txt::*;
use decode_aarch32_instrs_SSBB_A1enc_A_txt::*;
use decode_aarch32_instrs_VMVN_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VQRDMULH_A1enc_A_txt::*;
use decode_aarch32_instrs_VABS_A1enc_A_txt::*;
use decode_aarch32_instrs_VABA_A1enc_A_txt::*;
use decode_aarch32_instrs_VQDMLSL_A1enc_A_txt::*;
use decode_aarch32_instrs_VCLE_i_A1enc_A_txt::*;
use common::*;
pub fn u__DecodeA32_Unconditional<T: Tracer>(
    state: &mut State,
    tracer: &T,
    gs_397433: i128,
    gs_397434: u32,
) -> () {
    #[derive(Default)]
    struct FunctionState {
        gs_403121: bool,
        gs_397588: bool,
        gs_403405: bool,
        gs_397562: bool,
        gs_398563: bool,
        gs_399475: bool,
        gs_398800: bool,
        gs_402975: bool,
        gs_401012: bool,
        u_31122: u32,
        gs_400880: bool,
        gs_403583: bool,
        gs_400173: bool,
        u_30562: u8,
        gs_401656: bool,
        gs_398958: bool,
        gs_400424: bool,
        gs_400562: bool,
        gs_400977: bool,
        gs_399269: bool,
        gs_403724: bool,
        u_32193: u32,
        u_32170: u32,
        gs_403199: bool,
        gs_402417: bool,
        gs_402314: bool,
        u_30832: u32,
        gs_403312: bool,
        gs_401419: bool,
        gs_397834: bool,
        gs_400493: bool,
        u_30558: u32,
        gs_400425: bool,
        gs_402366: bool,
        gs_403064: bool,
        gs_403721: bool,
        gs_397509: bool,
        gs_402911: bool,
        gs_400041: bool,
        gs_398671: bool,
        gs_402598: bool,
        gs_400243: bool,
        u_30652: u32,
        gs_402153: bool,
        gs_402124: bool,
        gs_398132: bool,
        gs_401485: bool,
        gs_401789: bool,
        gs_399321: bool,
        gs_398665: bool,
        gs_399966: bool,
        gs_397483: bool,
        u_32144: u32,
        gs_400720: bool,
        gs_398465: bool,
        gs_397972: bool,
        gs_399525: bool,
        gs_402363: bool,
        gs_397591: bool,
        gs_403770: bool,
        gs_398467: bool,
        gs_397486: bool,
        gs_401787: bool,
        gs_398233: bool,
        gs_398134: bool,
        gs_400427: bool,
        gs_403112: bool,
        gs_399848: bool,
        gs_397716: bool,
        gs_397667: bool,
        gs_400170: bool,
        gs_397821: bool,
        gs_398103: bool,
        gs_397521: bool,
        gs_400593: bool,
        gs_399579: bool,
        u_30567: bool,
        gs_400878: bool,
        gs_403197: bool,
        u_32218: u32,
        u_31208: u32,
        gs_397712: bool,
        gs_398269: bool,
        u_31425: u32,
        gs_403851: bool,
        gs_402497: bool,
        gs_400278: bool,
        gs_403063: bool,
        gs_399500: bool,
        gs_401590: bool,
        gs_397553: bool,
        gs_402495: bool,
        gs_402781: bool,
        gs_401786: bool,
        gs_397907: bool,
        gs_401879: bool,
        gs_401387: bool,
        u_31608: u32,
        u_31986: u32,
        gs_400319: bool,
        u_30570: u32,
        gs_400003: bool,
        gs_402264: bool,
        gs_403495: bool,
        mode: u8,
        gs_400282: bool,
        gs_401390: bool,
        u_32319: u32,
        gs_402261: bool,
        gs_402726: bool,
        gs_398302: bool,
        u_32234: u32,
        u_31893: u32,
        u_31353: u32,
        gs_397559: bool,
        u_31679: u32,
        u_30662: u32,
        gs_399423: bool,
        gs_403432: bool,
        u_30813: u32,
        u_31909: u32,
        gs_399053: bool,
        u_31901: u32,
        gs_400854: bool,
        gs_398528: bool,
        gs_398834: bool,
        gs_402364: bool,
        gs_403035: bool,
        gs_402472: bool,
        gs_398900: bool,
        gs_401420: bool,
        gs_403620: bool,
        gs_398929: bool,
        gs_400046: bool,
        u_31668: u32,
        gs_397462: bool,
        u__opcode: u32,
        gs_402703: bool,
        u_31917: u32,
        gs_399083: bool,
        gs_397744: bool,
        u_31114: u32,
        gs_400277: bool,
        gs_403524: bool,
        gs_402494: bool,
        gs_400112: bool,
        gs_401200: bool,
        gs_400426: bool,
        gs_402176: bool,
        gs_402725: bool,
        gs_398167: bool,
        u_30594: u32,
        gs_397875: bool,
        gs_403346: bool,
        u_31534: u32,
        gs_399016: bool,
        gs_400594: bool,
        gs_397627: bool,
        gs_400624: bool,
        gs_401071: bool,
        gs_397714: bool,
        gs_403707: bool,
        gs_399710: bool,
        gs_401785: bool,
        gs_400245: bool,
        gs_402676: bool,
        gs_399842: bool,
        gs_401819: bool,
        gs_403736: bool,
        gs_403619: bool,
        gs_399965: bool,
        u_30793: u32,
        gs_398273: bool,
        gs_403773: bool,
        u_31140: u32,
        gs_398668: bool,
        gs_403767: bool,
        gs_397692: bool,
        gs_397565: bool,
        gs_398199: bool,
        gs_403374: bool,
        gs_400813: bool,
        gs_400491: bool,
        gs_399603: bool,
        gs_397609: bool,
        gs_399050: bool,
        gs_397771: bool,
        u_32126: u32,
        gs_402289: bool,
        gs_401197: bool,
        gs_399213: bool,
        u_30978: u32,
        gs_403124: bool,
        gs_400388: bool,
        u_31588: u32,
        gs_403800: bool,
        gs_400944: bool,
        gs_399502: bool,
        u_32003: u32,
        gs_398365: bool,
        gs_400976: bool,
        gs_403253: bool,
        gs_401558: bool,
        gs_403584: bool,
        gs_398735: bool,
        gs_400171: bool,
        gs_401976: bool,
        u_31813: u32,
        gs_397645: bool,
        gs_403685: bool,
        gs_397747: bool,
        gs_399683: bool,
        gs_402547: bool,
        gs_401289: bool,
        u_32044: u32,
        gs_401108: bool,
        gs_400462: bool,
        u_31995: u32,
        gs_398833: bool,
        gs_403552: bool,
        gs_399369: bool,
        gs_403828: bool,
        gs_400752: bool,
        u_32317: u32,
        gs_397515: bool,
        gs_402063: bool,
        gs_401454: bool,
        u_31249: u32,
        gs_400147: bool,
        u_32118: u32,
        gs_400114: bool,
        gs_397600: bool,
        gs_397750: bool,
        gs_399930: bool,
        gs_403200: bool,
        gs_401688: bool,
        u_31514: u32,
        gs_403779: bool,
        gs_398010: bool,
        gs_401521: bool,
        gs_397547: bool,
        gs_402974: bool,
        gs_403066: bool,
        u_30681: u32,
        gs_401072: bool,
        u_32152: u32,
        gs_401385: bool,
        gs_403498: bool,
        gs_397491: bool,
        u_31397: u32,
        gs_403000: bool,
        u_31388: u32,
        gs_400169: bool,
        imm1: bool,
        gs_403431: bool,
        gs_400496: bool,
        gs_400460: bool,
        gs_402032: bool,
        gs_398131: bool,
        gs_403751: bool,
        gs_397974: bool,
        u_30971: u32,
        u_30734: u32,
        u_32313: u32,
        gs_401171: bool,
        gs_400144: bool,
        gs_402520: bool,
        gs_403288: bool,
        u_31848: u32,
        gs_398566: bool,
        u_31768: u32,
        gs_401556: bool,
        gs_402678: bool,
        gs_398799: bool,
        gs_400598: bool,
        gs_402031: bool,
        gs_397465: bool,
        gs_400557: bool,
        u_30634: u32,
        gs_398493: bool,
        u_31473: u32,
        gs_398564: bool,
        u_32277: u32,
        gs_400429: bool,
        gs_403139: bool,
        gs_398527: bool,
        gs_402912: bool,
        u_31562: u32,
        gs_403314: bool,
        gs_399883: bool,
        gs_401166: bool,
        gs_401168: bool,
        gs_402033: bool,
        gs_401878: bool,
        u_31021: u32,
        gs_397512: bool,
        gs_401135: bool,
        u_32227: u32,
        gs_403748: bool,
        gs_397741: bool,
        gs_398461: bool,
        u_32259: u32,
        gs_403115: bool,
        gs_401202: bool,
        gs_397447: bool,
        u_30575: u32,
        gs_400916: bool,
        u_31294: u32,
        gs_403202: bool,
        gs_398075: bool,
        gs_397971: bool,
        gs_398463: bool,
        gs_399159: bool,
        gs_402447: bool,
        gs_401456: bool,
        gs_399422: bool,
        gs_397872: bool,
        u_30701: u32,
        gs_401560: bool,
        gs_402675: bool,
        gs_399845: bool,
        gs_400718: bool,
        gs_403465: bool,
        gs_400389: bool,
        gs_399708: bool,
        gs_400783: bool,
        gs_401257: bool,
        gs_398272: bool,
        gs_400751: bool,
        u_31758: u32,
        gs_401823: bool,
        u_30865: u32,
        gs_402205: bool,
        gs_402066: bool,
        gs_397768: bool,
        gs_399242: bool,
        gs_397904: bool,
        gs_400201: bool,
        gs_398738: bool,
        u_31131: u32,
        gs_403090: bool,
        gs_398494: bool,
        gs_401489: bool,
        u_30929: u32,
        gs_402311: bool,
        u_30564: u32,
        u_31370: u32,
        gs_399318: bool,
        u_31953: u32,
        gs_398425: bool,
        gs_400945: bool,
        gs_400390: bool,
        u_31196: u32,
        gs_398836: bool,
        gs_403171: bool,
        gs_402840: bool,
        gs_400850: bool,
        gs_400625: bool,
        gs_399343: bool,
        gs_398366: bool,
        gs_403290: bool,
        gs_398367: bool,
        u_30556: u32,
        gs_401352: bool,
        gs_402089: bool,
        gs_401169: bool,
        u_31305: u32,
        gs_402780: bool,
        gs_401586: bool,
        imod: u8,
        gs_400595: bool,
        gs_402002: bool,
        gs_403404: bool,
        gs_401555: bool,
        gs_403228: bool,
        gs_403286: bool,
        gs_397480: bool,
        gs_400076: bool,
        gs_398271: bool,
        gs_398237: bool,
        gs_402155: bool,
        u_30908: u32,
        gs_403140: bool,
        gs_398704: bool,
        gs_397797: bool,
        E: bool,
        gs_400879: bool,
        gs_401288: bool,
        u_31969: u32,
        u_31874: u32,
        gs_400387: bool,
        gs_399108: bool,
        u_31444: u32,
        gs_400492: bool,
        gs_398565: bool,
        gs_397835: bool,
        gs_400006: bool,
        gs_401386: bool,
        u_32019: u32,
        gs_400526: bool,
        gs_399808: bool,
        u_31638: u32,
        gs_397905: bool,
        gs_397818: bool,
        gs_399741: bool,
        gs_400353: bool,
        gs_400314: bool,
        gs_402573: bool,
        gs_403091: bool,
        gs_399631: bool,
        u_31884: u32,
        gs_403142: bool,
        u_30566: u32,
        gs_398599: bool,
        gs_403730: bool,
        gs_403342: bool,
        gs_403461: bool,
        gs_402649: bool,
        gs_403316: bool,
        gs_401009: bool,
        u_31106: u32,
        u_30753: u32,
        gs_398767: bool,
        gs_400352: bool,
        gs_400689: bool,
        u_32315: u32,
        gs_403493: bool,
        gs_403618: bool,
        gs_398107: bool,
        gs_399267: bool,
        gs_400691: bool,
        gs_400240: bool,
        gs_400978: bool,
        u_30763: u32,
        merge_var: ProductType7b8639ca40b2f578,
        gs_398956: bool,
        gs_398734: bool,
        gs_398368: bool,
        gs_398766: bool,
        gs_397871: bool,
        gs_401487: bool,
        gs_397762: bool,
        gs_399552: bool,
        gs_400317: bool,
        gs_400079: bool,
        gs_398303: bool,
        gs_403002: bool,
        gs_403684: bool,
        gs_403848: bool,
        u_32036: u32,
        gs_402391: bool,
        u_31804: u32,
        gs_397780: bool,
        gs_401321: bool,
        gs_403287: bool,
        gs_401167: bool,
        gs_398897: bool,
        gs_403654: bool,
        u_30613: u32,
        u_31056: u32,
        gs_401820: bool,
        gs_401882: bool,
        gs_399450: bool,
        gs_402420: bool,
        gs_398164: bool,
        gs_398984: bool,
        gs_401852: bool,
        u_31316: u32,
        gs_403656: bool,
        u_31688: u32,
        gs_401751: bool,
        gs_401557: bool,
        u_31326: u32,
        gs_402574: bool,
        u_31151: u32,
        gs_397456: bool,
        gs_402623: bool,
        gs_403683: bool,
        u_30604: u32,
        gs_403344: bool,
        gs_399524: bool,
        gs_397838: bool,
        gs_401262: bool,
        gs_398768: bool,
        u_31361: u32,
        gs_400077: bool,
        gs_398041: bool,
        u_30743: u32,
        u_30591: u32,
        u_31335: u32,
        gs_397756: bool,
        gs_398529: bool,
        gs_399186: bool,
        gs_400559: bool,
        gs_399398: bool,
        gs_397694: bool,
        gs_397753: bool,
        gs_398771: bool,
        gs_398567: bool,
        gs_402626: bool,
        gs_402914: bool,
        gs_398667: bool,
        gs_401224: bool,
        gs_399111: bool,
        gs_397453: bool,
        u_32061: u32,
        gs_402999: bool,
        gs_397786: bool,
        u_31944: u32,
        gs_400004: bool,
        u_32252: u32,
        gs_401621: bool,
        u_31029: u32,
        u_31837: u32,
        gs_397530: bool,
        gs_403496: bool,
        u_31072: u32,
        gs_398464: bool,
        gs_398769: bool,
        gs_397594: bool,
        gs_398930: bool,
        u_30849: u32,
        u_31926: u32,
        gs_398830: bool,
        gs_402651: bool,
        gs_402753: bool,
        gs_398073: bool,
        gs_398394: bool,
        gs_398595: bool,
        gs_399968: bool,
        gs_398864: bool,
        u_30882: u32,
        gs_401355: bool,
        gs_403776: bool,
        gs_398200: bool,
        gs_401008: bool,
        gs_398072: bool,
        u_32288: u32,
        gs_402035: bool,
        gs_399882: bool,
        gs_402873: bool,
        u_31239: u32,
        gs_397806: bool,
        gs_401944: bool,
        gs_402126: bool,
        gs_403144: bool,
        gs_399395: bool,
        gs_400523: bool,
        gs_397777: bool,
        u_30823: u32,
        gs_403822: bool,
        gs_397939: bool,
        gs_399774: bool,
        gs_402750: bool,
        gs_398008: bool,
        gs_403718: bool,
        gs_398633: bool,
        gs_397626: bool,
        u_31830: u32,
        u_31174: u32,
        gs_401881: bool,
        gs_398985: bool,
        gs_402234: bool,
        gs_398332: bool,
        gs_400459: bool,
        gs_397691: bool,
        u_31977: u32,
        gs_400659: bool,
        gs_401725: bool,
        gs_403033: bool,
        gs_397812: bool,
        gs_403553: bool,
        gs_399051: bool,
        u_31219: u32,
        gs_402815: bool,
        gs_403343: bool,
        u_32136: u32,
        gs_403834: bool,
        u_30587: u32,
        gs_399185: bool,
        gs_397503: bool,
        u_31935: u32,
        u_31229: u32,
        gs_401198: bool,
        u_31708: u32,
        gs_402576: bool,
        gs_399924: bool,
        u_31717: u32,
        gs_398370: bool,
        gs_403521: bool,
        gs_400316: bool,
        gs_403407: bool,
        gs_402152: bool,
        gs_403586: bool,
        gs_402175: bool,
        gs_402977: bool,
        gs_403409: bool,
        gs_399967: bool,
        u_30783: u32,
        gs_398234: bool,
        u_31344: u32,
        u_32090: u32,
        gs_403745: bool,
        gs_401914: bool,
        gs_400592: bool,
        gs_399805: bool,
        gs_401624: bool,
        gs_399133: bool,
        gs_401138: bool,
        gs_397973: bool,
        gs_402470: bool,
        gs_403231: bool,
        gs_399449: bool,
        u_30559: u8,
        gs_400782: bool,
        gs_399013: bool,
        gs_402003: bool,
        u_30956: u32,
        gs_399319: bool,
        gs_399771: bool,
        gs_400628: bool,
        gs_397873: bool,
        gs_400457: bool,
        gs_399654: bool,
        A: bool,
        gs_398531: bool,
        gs_400852: bool,
        u_30840: u32,
        u_32209: u32,
        gs_403520: bool,
        gs_403068: bool,
        u_31794: u32,
        gs_403037: bool,
        u_30857: u32,
        gs_400661: bool,
        gs_400596: bool,
        u_31618: u32,
        gs_398012: bool,
        gs_400913: bool,
        gs_401457: bool,
        gs_403651: bool,
        gs_400203: bool,
        gs_401323: bool,
        gs_400815: bool,
        gs_402286: bool,
        u_32156: u32,
        gs_398169: bool,
        gs_403733: bool,
        gs_403739: bool,
        gs_402522: bool,
        gs_398798: bool,
        u_32297: u32,
        gs_402062: bool,
        gs_402237: bool,
        gs_399161: bool,
        gs_399474: bool,
        gs_400081: bool,
        u_32052: u32,
        gs_403847: bool,
        gs_403433: bool,
        gs_401076: bool,
        u_31163: u32,
        gs_399964: bool,
        gs_400239: bool,
        gs_400753: bool,
        u_30568: u16,
        gs_401225: bool,
        gs_397568: bool,
        gs_398497: bool,
        gs_398235: bool,
        gs_400005: bool,
        u_31628: u32,
        gs_398736: bool,
        gs_400202: bool,
        gs_402812: bool,
        gs_403255: bool,
        gs_399239: bool,
        u_31544: u32,
        gs_400626: bool,
        u_31266: u32,
        gs_401136: bool,
        gs_403849: bool,
        gs_401912: bool,
        gs_397471: bool,
        gs_403463: bool,
        u_31283: u32,
        gs_401975: bool,
        u_32154: bool,
        u_32305: u32,
        gs_401588: bool,
        u_30692: u32,
        gs_398862: bool,
        u_31822: u32,
        gs_401686: bool,
        gs_403709: bool,
        gs_398701: bool,
        gs_401259: bool,
        u_31064: u32,
        gs_400560: bool,
        u_30873: u32,
        gs_401657: bool,
        gs_402942: bool,
        gs_398495: bool,
        u_32184: u32,
        gs_397809: bool,
        gs_398733: bool,
        gs_397579: bool,
        gs_401074: bool,
        option_name: u8,
        gs_398631: bool,
        gs_398165: bool,
        gs_403406: bool,
        gs_402336: bool,
        u_32243: u32,
        u_30891: u32,
        gs_399346: bool,
        gs_399551: bool,
        u_30589: u32,
        gs_398462: bool,
        gs_397870: bool,
        u_31784: u32,
        gs_400755: bool,
        gs_402418: bool,
        gs_400280: bool,
        gs_403807: bool,
        gs_399136: bool,
        gs_400205: bool,
        gs_401884: bool,
        gs_401258: bool,
        gs_401620: bool,
        gs_399049: bool,
        gs_400458: bool,
        gs_402839: bool,
        gs_401722: bool,
        u_30899: u32,
        gs_397477: bool,
        gs_401523: bool,
        gs_398429: bool,
        gs_402064: bool,
        gs_401655: bool,
        u_31484: u32,
        gs_403257: bool,
        u_31080: u32,
        gs_398329: bool,
        u_31858: u32,
        gs_399806: bool,
        gs_402842: bool,
        gs_403034: bool,
        gs_401422: bool,
        u_31570: u32,
        gs_402287: bool,
        gs_403831: bool,
        gs_402624: bool,
        gs_397612: bool,
        gs_398427: bool,
        gs_397800: bool,
        gs_403810: bool,
        gs_400522: bool,
        gs_401910: bool,
        gs_401974: bool,
        u_32080: u32,
        u_31098: u32,
        gs_398275: bool,
        gs_398330: bool,
        gs_398700: bool,
        gs_399606: bool,
        gs_398865: bool,
        gs_398569: bool,
        gs_399371: bool,
        gs_400980: bool,
        gs_398203: bool,
        gs_403727: bool,
        gs_400315: bool,
        gs_403373: bool,
        u_30724: u32,
        gs_403687: bool,
        gs_398987: bool,
        gs_403494: bool,
        gs_399086: bool,
        gs_398669: bool,
        gs_399578: bool,
        gs_402519: bool,
        gs_403065: bool,
        gs_402728: bool,
        gs_398597: bool,
        gs_400688: bool,
        gs_398270: bool,
        gs_403623: bool,
        gs_399844: bool,
        u_31273: u32,
        gs_398802: bool,
        u_30772: u32,
        gs_398395: bool,
        gs_403169: bool,
        gs_400142: bool,
        gs_402122: bool,
        gs_399739: bool,
        gs_397976: bool,
        gs_397936: bool,
        gs_401326: bool,
        gs_398038: bool,
        gs_399134: bool,
        gs_401388: bool,
        u_31598: u32,
        gs_397935: bool,
        gs_403227: bool,
        gs_399527: bool,
        gs_401622: bool,
        gs_401943: bool,
        u_31435: u32,
        u_30671: u32,
        gs_400393: bool,
        gs_398009: bool,
        gs_400851: bool,
        gs_397765: bool,
        gs_403198: bool,
        gs_398166: bool,
        gs_402090: bool,
        gs_397903: bool,
        gs_403785: bool,
        gs_402813: bool,
        gs_403757: bool,
        u_31865: u32,
        u_31379: u32,
        gs_399885: bool,
        gs_397535: bool,
        gs_399927: bool,
        u_30580: u32,
        gs_403226: bool,
        gs_399888: bool,
        I: bool,
        gs_401942: bool,
        gs_399886: bool,
        gs_401911: bool,
        gs_397597: bool,
        gs_403555: bool,
        gs_400241: bool,
        gs_399048: bool,
        gs_397937: bool,
        gs_401723: bool,
        gs_403652: bool,
        gs_402700: bool,
        gs_399266: bool,
        gs_400279: bool,
        gs_399477: bool,
        gs_398039: bool,
        gs_403118: bool,
        gs_403760: bool,
        gs_402783: bool,
        gs_402444: bool,
        gs_398699: bool,
        u_31259: u32,
        u_31089: u32,
        u_30624: u32,
        gs_402648: bool,
        gs_399604: bool,
        gs_403782: bool,
        gs_403825: bool,
        gs_397574: bool,
        gs_397544: bool,
        u_32268: u32,
        u_31699: u32,
        u_31524: u32,
        gs_397459: bool,
        gs_399970: bool,
        gs_397824: bool,
        gs_399884: bool,
        gs_400948: bool,
        gs_402811: bool,
        u_32200: u32,
        gs_400357: bool,
        gs_398895: bool,
        gs_401978: bool,
        gs_403797: bool,
        gs_401227: bool,
        gs_397669: bool,
        gs_398957: bool,
        gs_400687: bool,
        gs_401353: bool,
        gs_399084: bool,
        u_31005: u32,
        gs_401106: bool,
        gs_403788: bool,
        gs_399707: bool,
        gs_399296: bool,
        gs_398896: bool,
        u_31578: u32,
        gs_400556: bool,
        u_31454: u32,
        u_31504: u32,
        gs_400558: bool,
        gs_400849: bool,
        gs_401880: bool,
        gs_401134: bool,
        gs_397731: bool,
        gs_402872: bool,
        gs_400242: bool,
        gs_400044: bool,
        gs_399499: bool,
        gs_402339: bool,
        u_30918: u32,
        gs_399804: bool,
        gs_402088: bool,
        gs_398426: bool,
        u_30987: u32,
        gs_400912: bool,
        gs_400657: bool,
        gs_402939: bool,
        gs_401459: bool,
        gs_397803: bool,
        u_32101: u32,
        u_32163: u32,
        gs_403376: bool,
        gs_402549: bool,
        gs_401720: bool,
        gs_399772: bool,
        gs_403554: bool,
        gs_402005: bool,
        gs_399928: bool,
        gs_402909: bool,
        gs_399293: bool,
        gs_401520: bool,
        u_31465: u32,
        u_30996: u32,
        gs_401199: bool,
        gs_402445: bool,
        gs_397615: bool,
        gs_402206: bool,
        gs_403816: bool,
        gs_401658: bool,
        gs_402938: bool,
        u_31775: u32,
        gs_397437: bool,
        gs_397666: bool,
        gs_403791: bool,
        gs_400817: bool,
        gs_400882: bool,
        u_30706: u32,
        gs_403141: bool,
        u_32011: u32,
        gs_398239: bool,
        gs_403168: bool,
        gs_400113: bool,
        gs_399629: bool,
        gs_398305: bool,
        gs_398301: bool,
        gs_398702: bool,
        gs_400355: bool,
        u_32109: u32,
        u_31185: u32,
        u_31038: u32,
        gs_401038: bool,
        gs_401850: bool,
        gs_403754: bool,
        gs_403621: bool,
        gs_397647: bool,
        gs_398596: bool,
        gs_402123: bool,
        gs_402208: bool,
        gs_402874: bool,
        gs_397527: bool,
        gs_403173: bool,
        gs_397500: bool,
        gs_400781: bool,
        gs_397629: bool,
        gs_400785: bool,
        gs_401752: bool,
        gs_399738: bool,
        gs_403794: bool,
        gs_401322: bool,
        gs_398867: bool,
        gs_403093: bool,
        gs_403653: bool,
        u_30941: u32,
        gs_397550: bool,
        gs_403229: bool,
        gs_400078: bool,
        gs_403682: bool,
        gs_399926: bool,
        u_31658: u32,
        gs_397603: bool,
        gs_402235: bool,
        u_30948: u32,
        gs_403313: bool,
        u_31047: u32,
        gs_401418: bool,
        gs_403742: bool,
        gs_401260: bool,
        gs_401039: bool,
        gs_402178: bool,
        u_31961: u32,
        gs_402204: bool,
        gs_397444: bool,
        gs_398629: bool,
        gs_399240: bool,
        gs_402751: bool,
        gs_403522: bool,
        gs_401291: bool,
        gs_399843: bool,
        gs_398832: bool,
        gs_401073: bool,
        gs_402390: bool,
        gs_402599: bool,
        gs_400914: bool,
        gs_398011: bool,
        gs_402875: bool,
        gs_397518: bool,
        gs_400490: bool,
        gs_397556: bool,
        gs_399215: bool,
        gs_400656: bool,
        gs_399653: bool,
        u_30715: u32,
        gs_399294: bool,
        gs_401753: bool,
        gs_398236: bool,
        gs_400008: bool,
        gs_400143: bool,
        gs_397524: bool,
        u_32028: u32,
        gs_403557: bool,
        gs_402262: bool,
        u_31747: u32,
        u_31727: u32,
        gs_400750: bool,
        gs_398397: bool,
        gs_399368: bool,
        gs_403285: bool,
        gs_402337: bool,
        gs_401041: bool,
        gs_401010: bool,
        gs_402061: bool,
        gs_403435: bool,
        u_30964: u32,
        gs_398201: bool,
        gs_401721: bool,
        gs_400354: bool,
        gs_400116: bool,
        gs_402393: bool,
        gs_401104: bool,
        gs_399628: bool,
        gs_397665: bool,
        gs_400042: bool,
        gs_399680: bool,
        gs_401687: bool,
        gs_401486: bool,
        gs_397774: bool,
        gs_402701: bool,
        gs_400040: bool,
        gs_397713: bool,
        gs_400658: bool,
        gs_400423: bool,
        gs_398960: bool,
        gs_399396: bool,
        gs_402910: bool,
        gs_398071: bool,
        gs_398863: bool,
        gs_400391: bool,
        gs_399344: bool,
        gs_403254: bool,
        gs_399425: bool,
        gs_403032: bool,
        u_31013: u32,
        u_30642: u32,
        gs_401660: bool,
        gs_400043: bool,
        gs_398104: bool,
        gs_397468: bool,
        u_30561: u32,
        gs_403372: bool,
        gs_401755: bool,
        gs_401821: bool,
        gs_403813: bool,
        u_32153: bool,
        gs_397788: bool,
        gs_401849: bool,
        gs_397738: bool,
        u_31553: u32,
        gs_401519: bool,
        gs_400717: bool,
        gs_398898: bool,
        u_31494: u32,
        gs_397618: bool,
        gs_402312: bool,
        gs_400946: bool,
        gs_402877: bool,
        gs_403170: bool,
        gs_397815: bool,
        gs_400814: bool,
        gs_398797: bool,
        gs_399212: bool,
        gs_399158: bool,
        gs_400494: bool,
        gs_402973: bool,
        u_32177: u32,
        u_31406: u32,
        gs_403462: bool,
        gs_397759: bool,
        gs_400524: bool,
        gs_401324: bool,
        gs_397450: bool,
        gs_399656: bool,
        u_30802: u32,
        gs_398732: bool,
        gs_399014: bool,
        gs_399846: bool,
        gs_402546: bool,
        gs_398932: bool,
        gs_402779: bool,
        gs_402972: bool,
        gs_398831: bool,
        gs_402601: bool,
        gs_399554: bool,
        gs_401654: bool,
        gs_403819: bool,
        gs_402940: bool,
        gs_401690: bool,
        gs_397836: bool,
        gs_399109: bool,
        gs_397474: bool,
        gs_398666: bool,
        gs_397571: bool,
        gs_399452: bool,
        gs_399681: bool,
        gs_398105: bool,
        u_31415: u32,
        gs_400351: bool,
        gs_402092: bool,
        gs_400145: bool,
        gs_401946: bool,
        gs_399188: bool,
        gs_399925: bool,
        gs_401587: bool,
        gs_400002: bool,
        gs_403837: bool,
        gs_397606: bool,
        gs_398014: bool,
        gs_398928: bool,
        gs_398630: bool,
        gs_401105: bool,
        u_32071: u32,
        gs_403127: bool,
        u_31736: u32,
        gs_398364: bool,
        u_31649: u32,
        gs_399581: bool,
        gs_400111: bool,
        gs_397506: bool,
        gs_401455: bool,
        gs_402469: bool,
        gs_397433: i128,
        gs_397434: u32,
    }
    let fn_state = FunctionState {
        gs_397433,
        gs_397434,
        ..Default::default()
    };
    return block_0(state, tracer, fn_state);
    fn block_0<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_0_0: read-var gs#397433:i
        let s_0_0: i128 = fn_state.gs_397433;
        // D s_0_1: write-var merge#var.0 <= s_0_0
        fn_state.merge_var._0 = s_0_0;
        // D s_0_2: read-var gs#397434:u32
        let s_0_2: u32 = fn_state.gs_397434;
        // D s_0_3: write-var merge#var.1 <= s_0_2
        fn_state.merge_var._1 = s_0_2;
        // D s_0_4: read-var merge#var.1:struct
        let s_0_4: u32 = fn_state.merge_var._1;
        // D s_0_5: write-var __opcode <= s_0_4
        fn_state.u__opcode = s_0_4;
        // D s_0_6: read-var __opcode:u32
        let s_0_6: u32 = fn_state.u__opcode;
        // D s_0_7: cast zx s_0_6 -> bv
        let s_0_7: Bits = Bits::new(s_0_6 as u128, 32u16);
        // C s_0_8: const #4118802463u : u32
        let s_0_8: u32 = 4118802463;
        // C s_0_9: cast zx s_0_8 -> bv
        let s_0_9: Bits = Bits::new(s_0_8 as u128, 32u16);
        // D s_0_10: cmp-eq s_0_7 s_0_9
        let s_0_10: bool = ((s_0_7) == (s_0_9));
        // N s_0_11: branch s_0_10 b3225 b1
        if s_0_10 {
            return block_3225(state, tracer, fn_state);
        } else {
            return block_1(state, tracer, fn_state);
        };
    }
    fn block_1<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1_0: const #0u : u8
        let s_1_0: bool = false;
        // D s_1_1: write-var gs#397437 <= s_1_0
        fn_state.gs_397437 = s_1_0;
        // N s_1_2: jump b2
        return block_2(state, tracer, fn_state);
    }
    fn block_2<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2_0: read-var gs#397437:u8
        let s_2_0: bool = fn_state.gs_397437;
        // D s_2_1: not s_2_0
        let s_2_1: bool = !s_2_0;
        // N s_2_2: branch s_2_1 b51 b3
        if s_2_1 {
            return block_51(state, tracer, fn_state);
        } else {
            return block_3(state, tracer, fn_state);
        };
    }
    fn block_3<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3_0: const #2879s : i
        let s_3_0: i128 = 2879;
        // C s_3_1: const #14696u : u32
        let s_3_1: u32 = 14696;
        // N s_3_2: write-reg s_3_1 <= s_3_0
        let s_3_2: () = {
            state.write_register::<i128>(s_3_1 as isize, s_3_0);
            tracer.write_register(s_3_1 as isize, s_3_0);
        };
        // C s_3_3: const #16s : i
        let s_3_3: i128 = 16;
        // D s_3_4: read-var __opcode:u32
        let s_3_4: u32 = fn_state.u__opcode;
        // D s_3_5: cast zx s_3_4 -> bv
        let s_3_5: Bits = Bits::new(s_3_4 as u128, 32u16);
        // C s_3_6: const #1u : u64
        let s_3_6: u64 = 1;
        // D s_3_7: bit-extract s_3_5 s_3_3 s_3_6
        let s_3_7: Bits = (Bits::new(
            ((s_3_5) >> (s_3_3)).value(),
            u16::try_from(s_3_6).unwrap(),
        ));
        // D s_3_8: cast reint s_3_7 -> u8
        let s_3_8: bool = ((s_3_7.value()) != 0);
        // C s_3_9: const #0s : i
        let s_3_9: i128 = 0;
        // C s_3_10: const #0u : u64
        let s_3_10: u64 = 0;
        // D s_3_11: cast zx s_3_8 -> u64
        let s_3_11: u64 = (s_3_8 as u64);
        // C s_3_12: const #1u : u64
        let s_3_12: u64 = 1;
        // D s_3_13: and s_3_11 s_3_12
        let s_3_13: u64 = ((s_3_11) & (s_3_12));
        // D s_3_14: cmp-eq s_3_13 s_3_12
        let s_3_14: bool = ((s_3_13) == (s_3_12));
        // D s_3_15: lsl s_3_11 s_3_9
        let s_3_15: u64 = s_3_11 << s_3_9;
        // D s_3_16: or s_3_10 s_3_15
        let s_3_16: u64 = ((s_3_10) | (s_3_15));
        // D s_3_17: cmpl s_3_15
        let s_3_17: u64 = !s_3_15;
        // D s_3_18: and s_3_10 s_3_17
        let s_3_18: u64 = ((s_3_10) & (s_3_17));
        // D s_3_19: select s_3_14 s_3_16 s_3_18
        let s_3_19: u64 = if s_3_14 { s_3_16 } else { s_3_18 };
        // D s_3_20: cast trunc s_3_19 -> u8
        let s_3_20: bool = ((s_3_19) != 0);
        // D s_3_21: cast zx s_3_20 -> bv
        let s_3_21: Bits = Bits::new(s_3_20 as u128, 1u16);
        // C s_3_22: const #1u : u8
        let s_3_22: bool = true;
        // C s_3_23: cast zx s_3_22 -> bv
        let s_3_23: Bits = Bits::new(s_3_22 as u128, 1u16);
        // D s_3_24: cmp-ne s_3_21 s_3_23
        let s_3_24: bool = ((s_3_21) != (s_3_23));
        // N s_3_25: branch s_3_24 b50 b4
        if s_3_24 {
            return block_50(state, tracer, fn_state);
        } else {
            return block_4(state, tracer, fn_state);
        };
    }
    fn block_4<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_4_0: const #17s : i
        let s_4_0: i128 = 17;
        // D s_4_1: read-var __opcode:u32
        let s_4_1: u32 = fn_state.u__opcode;
        // D s_4_2: cast zx s_4_1 -> bv
        let s_4_2: Bits = Bits::new(s_4_1 as u128, 32u16);
        // C s_4_3: const #1u : u64
        let s_4_3: u64 = 1;
        // D s_4_4: bit-extract s_4_2 s_4_0 s_4_3
        let s_4_4: Bits = (Bits::new(
            ((s_4_2) >> (s_4_0)).value(),
            u16::try_from(s_4_3).unwrap(),
        ));
        // D s_4_5: cast reint s_4_4 -> u8
        let s_4_5: bool = ((s_4_4.value()) != 0);
        // C s_4_6: const #0s : i
        let s_4_6: i128 = 0;
        // C s_4_7: const #0u : u64
        let s_4_7: u64 = 0;
        // D s_4_8: cast zx s_4_5 -> u64
        let s_4_8: u64 = (s_4_5 as u64);
        // C s_4_9: const #1u : u64
        let s_4_9: u64 = 1;
        // D s_4_10: and s_4_8 s_4_9
        let s_4_10: u64 = ((s_4_8) & (s_4_9));
        // D s_4_11: cmp-eq s_4_10 s_4_9
        let s_4_11: bool = ((s_4_10) == (s_4_9));
        // D s_4_12: lsl s_4_8 s_4_6
        let s_4_12: u64 = s_4_8 << s_4_6;
        // D s_4_13: or s_4_7 s_4_12
        let s_4_13: u64 = ((s_4_7) | (s_4_12));
        // D s_4_14: cmpl s_4_12
        let s_4_14: u64 = !s_4_12;
        // D s_4_15: and s_4_7 s_4_14
        let s_4_15: u64 = ((s_4_7) & (s_4_14));
        // D s_4_16: select s_4_11 s_4_13 s_4_15
        let s_4_16: u64 = if s_4_11 { s_4_13 } else { s_4_15 };
        // D s_4_17: cast trunc s_4_16 -> u8
        let s_4_17: bool = ((s_4_16) != 0);
        // D s_4_18: cast zx s_4_17 -> bv
        let s_4_18: Bits = Bits::new(s_4_17 as u128, 1u16);
        // C s_4_19: const #1u : u8
        let s_4_19: bool = true;
        // C s_4_20: cast zx s_4_19 -> bv
        let s_4_20: Bits = Bits::new(s_4_19 as u128, 1u16);
        // D s_4_21: cmp-ne s_4_18 s_4_20
        let s_4_21: bool = ((s_4_18) != (s_4_20));
        // D s_4_22: write-var gs#397444 <= s_4_21
        fn_state.gs_397444 = s_4_21;
        // N s_4_23: jump b5
        return block_5(state, tracer, fn_state);
    }
    fn block_5<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5_0: read-var gs#397444:u8
        let s_5_0: bool = fn_state.gs_397444;
        // N s_5_1: branch s_5_0 b49 b6
        if s_5_0 {
            return block_49(state, tracer, fn_state);
        } else {
            return block_6(state, tracer, fn_state);
        };
    }
    fn block_6<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_6_0: const #18s : i
        let s_6_0: i128 = 18;
        // D s_6_1: read-var __opcode:u32
        let s_6_1: u32 = fn_state.u__opcode;
        // D s_6_2: cast zx s_6_1 -> bv
        let s_6_2: Bits = Bits::new(s_6_1 as u128, 32u16);
        // C s_6_3: const #1u : u64
        let s_6_3: u64 = 1;
        // D s_6_4: bit-extract s_6_2 s_6_0 s_6_3
        let s_6_4: Bits = (Bits::new(
            ((s_6_2) >> (s_6_0)).value(),
            u16::try_from(s_6_3).unwrap(),
        ));
        // D s_6_5: cast reint s_6_4 -> u8
        let s_6_5: bool = ((s_6_4.value()) != 0);
        // C s_6_6: const #0s : i
        let s_6_6: i128 = 0;
        // C s_6_7: const #0u : u64
        let s_6_7: u64 = 0;
        // D s_6_8: cast zx s_6_5 -> u64
        let s_6_8: u64 = (s_6_5 as u64);
        // C s_6_9: const #1u : u64
        let s_6_9: u64 = 1;
        // D s_6_10: and s_6_8 s_6_9
        let s_6_10: u64 = ((s_6_8) & (s_6_9));
        // D s_6_11: cmp-eq s_6_10 s_6_9
        let s_6_11: bool = ((s_6_10) == (s_6_9));
        // D s_6_12: lsl s_6_8 s_6_6
        let s_6_12: u64 = s_6_8 << s_6_6;
        // D s_6_13: or s_6_7 s_6_12
        let s_6_13: u64 = ((s_6_7) | (s_6_12));
        // D s_6_14: cmpl s_6_12
        let s_6_14: u64 = !s_6_12;
        // D s_6_15: and s_6_7 s_6_14
        let s_6_15: u64 = ((s_6_7) & (s_6_14));
        // D s_6_16: select s_6_11 s_6_13 s_6_15
        let s_6_16: u64 = if s_6_11 { s_6_13 } else { s_6_15 };
        // D s_6_17: cast trunc s_6_16 -> u8
        let s_6_17: bool = ((s_6_16) != 0);
        // D s_6_18: cast zx s_6_17 -> bv
        let s_6_18: Bits = Bits::new(s_6_17 as u128, 1u16);
        // C s_6_19: const #1u : u8
        let s_6_19: bool = true;
        // C s_6_20: cast zx s_6_19 -> bv
        let s_6_20: Bits = Bits::new(s_6_19 as u128, 1u16);
        // D s_6_21: cmp-ne s_6_18 s_6_20
        let s_6_21: bool = ((s_6_18) != (s_6_20));
        // D s_6_22: write-var gs#397447 <= s_6_21
        fn_state.gs_397447 = s_6_21;
        // N s_6_23: jump b7
        return block_7(state, tracer, fn_state);
    }
    fn block_7<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_7_0: read-var gs#397447:u8
        let s_7_0: bool = fn_state.gs_397447;
        // N s_7_1: branch s_7_0 b48 b8
        if s_7_0 {
            return block_48(state, tracer, fn_state);
        } else {
            return block_8(state, tracer, fn_state);
        };
    }
    fn block_8<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_8_0: const #19s : i
        let s_8_0: i128 = 19;
        // D s_8_1: read-var __opcode:u32
        let s_8_1: u32 = fn_state.u__opcode;
        // D s_8_2: cast zx s_8_1 -> bv
        let s_8_2: Bits = Bits::new(s_8_1 as u128, 32u16);
        // C s_8_3: const #1u : u64
        let s_8_3: u64 = 1;
        // D s_8_4: bit-extract s_8_2 s_8_0 s_8_3
        let s_8_4: Bits = (Bits::new(
            ((s_8_2) >> (s_8_0)).value(),
            u16::try_from(s_8_3).unwrap(),
        ));
        // D s_8_5: cast reint s_8_4 -> u8
        let s_8_5: bool = ((s_8_4.value()) != 0);
        // C s_8_6: const #0s : i
        let s_8_6: i128 = 0;
        // C s_8_7: const #0u : u64
        let s_8_7: u64 = 0;
        // D s_8_8: cast zx s_8_5 -> u64
        let s_8_8: u64 = (s_8_5 as u64);
        // C s_8_9: const #1u : u64
        let s_8_9: u64 = 1;
        // D s_8_10: and s_8_8 s_8_9
        let s_8_10: u64 = ((s_8_8) & (s_8_9));
        // D s_8_11: cmp-eq s_8_10 s_8_9
        let s_8_11: bool = ((s_8_10) == (s_8_9));
        // D s_8_12: lsl s_8_8 s_8_6
        let s_8_12: u64 = s_8_8 << s_8_6;
        // D s_8_13: or s_8_7 s_8_12
        let s_8_13: u64 = ((s_8_7) | (s_8_12));
        // D s_8_14: cmpl s_8_12
        let s_8_14: u64 = !s_8_12;
        // D s_8_15: and s_8_7 s_8_14
        let s_8_15: u64 = ((s_8_7) & (s_8_14));
        // D s_8_16: select s_8_11 s_8_13 s_8_15
        let s_8_16: u64 = if s_8_11 { s_8_13 } else { s_8_15 };
        // D s_8_17: cast trunc s_8_16 -> u8
        let s_8_17: bool = ((s_8_16) != 0);
        // D s_8_18: cast zx s_8_17 -> bv
        let s_8_18: Bits = Bits::new(s_8_17 as u128, 1u16);
        // C s_8_19: const #1u : u8
        let s_8_19: bool = true;
        // C s_8_20: cast zx s_8_19 -> bv
        let s_8_20: Bits = Bits::new(s_8_19 as u128, 1u16);
        // D s_8_21: cmp-ne s_8_18 s_8_20
        let s_8_21: bool = ((s_8_18) != (s_8_20));
        // D s_8_22: write-var gs#397450 <= s_8_21
        fn_state.gs_397450 = s_8_21;
        // N s_8_23: jump b9
        return block_9(state, tracer, fn_state);
    }
    fn block_9<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_9_0: read-var gs#397450:u8
        let s_9_0: bool = fn_state.gs_397450;
        // N s_9_1: branch s_9_0 b47 b10
        if s_9_0 {
            return block_47(state, tracer, fn_state);
        } else {
            return block_10(state, tracer, fn_state);
        };
    }
    fn block_10<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_10_0: const #12s : i
        let s_10_0: i128 = 12;
        // D s_10_1: read-var __opcode:u32
        let s_10_1: u32 = fn_state.u__opcode;
        // D s_10_2: cast zx s_10_1 -> bv
        let s_10_2: Bits = Bits::new(s_10_1 as u128, 32u16);
        // C s_10_3: const #1u : u64
        let s_10_3: u64 = 1;
        // D s_10_4: bit-extract s_10_2 s_10_0 s_10_3
        let s_10_4: Bits = (Bits::new(
            ((s_10_2) >> (s_10_0)).value(),
            u16::try_from(s_10_3).unwrap(),
        ));
        // D s_10_5: cast reint s_10_4 -> u8
        let s_10_5: bool = ((s_10_4.value()) != 0);
        // C s_10_6: const #0s : i
        let s_10_6: i128 = 0;
        // C s_10_7: const #0u : u64
        let s_10_7: u64 = 0;
        // D s_10_8: cast zx s_10_5 -> u64
        let s_10_8: u64 = (s_10_5 as u64);
        // C s_10_9: const #1u : u64
        let s_10_9: u64 = 1;
        // D s_10_10: and s_10_8 s_10_9
        let s_10_10: u64 = ((s_10_8) & (s_10_9));
        // D s_10_11: cmp-eq s_10_10 s_10_9
        let s_10_11: bool = ((s_10_10) == (s_10_9));
        // D s_10_12: lsl s_10_8 s_10_6
        let s_10_12: u64 = s_10_8 << s_10_6;
        // D s_10_13: or s_10_7 s_10_12
        let s_10_13: u64 = ((s_10_7) | (s_10_12));
        // D s_10_14: cmpl s_10_12
        let s_10_14: u64 = !s_10_12;
        // D s_10_15: and s_10_7 s_10_14
        let s_10_15: u64 = ((s_10_7) & (s_10_14));
        // D s_10_16: select s_10_11 s_10_13 s_10_15
        let s_10_16: u64 = if s_10_11 { s_10_13 } else { s_10_15 };
        // D s_10_17: cast trunc s_10_16 -> u8
        let s_10_17: bool = ((s_10_16) != 0);
        // D s_10_18: cast zx s_10_17 -> bv
        let s_10_18: Bits = Bits::new(s_10_17 as u128, 1u16);
        // C s_10_19: const #1u : u8
        let s_10_19: bool = true;
        // C s_10_20: cast zx s_10_19 -> bv
        let s_10_20: Bits = Bits::new(s_10_19 as u128, 1u16);
        // D s_10_21: cmp-ne s_10_18 s_10_20
        let s_10_21: bool = ((s_10_18) != (s_10_20));
        // D s_10_22: write-var gs#397453 <= s_10_21
        fn_state.gs_397453 = s_10_21;
        // N s_10_23: jump b11
        return block_11(state, tracer, fn_state);
    }
    fn block_11<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_11_0: read-var gs#397453:u8
        let s_11_0: bool = fn_state.gs_397453;
        // N s_11_1: branch s_11_0 b46 b12
        if s_11_0 {
            return block_46(state, tracer, fn_state);
        } else {
            return block_12(state, tracer, fn_state);
        };
    }
    fn block_12<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_12_0: const #13s : i
        let s_12_0: i128 = 13;
        // D s_12_1: read-var __opcode:u32
        let s_12_1: u32 = fn_state.u__opcode;
        // D s_12_2: cast zx s_12_1 -> bv
        let s_12_2: Bits = Bits::new(s_12_1 as u128, 32u16);
        // C s_12_3: const #1u : u64
        let s_12_3: u64 = 1;
        // D s_12_4: bit-extract s_12_2 s_12_0 s_12_3
        let s_12_4: Bits = (Bits::new(
            ((s_12_2) >> (s_12_0)).value(),
            u16::try_from(s_12_3).unwrap(),
        ));
        // D s_12_5: cast reint s_12_4 -> u8
        let s_12_5: bool = ((s_12_4.value()) != 0);
        // C s_12_6: const #0s : i
        let s_12_6: i128 = 0;
        // C s_12_7: const #0u : u64
        let s_12_7: u64 = 0;
        // D s_12_8: cast zx s_12_5 -> u64
        let s_12_8: u64 = (s_12_5 as u64);
        // C s_12_9: const #1u : u64
        let s_12_9: u64 = 1;
        // D s_12_10: and s_12_8 s_12_9
        let s_12_10: u64 = ((s_12_8) & (s_12_9));
        // D s_12_11: cmp-eq s_12_10 s_12_9
        let s_12_11: bool = ((s_12_10) == (s_12_9));
        // D s_12_12: lsl s_12_8 s_12_6
        let s_12_12: u64 = s_12_8 << s_12_6;
        // D s_12_13: or s_12_7 s_12_12
        let s_12_13: u64 = ((s_12_7) | (s_12_12));
        // D s_12_14: cmpl s_12_12
        let s_12_14: u64 = !s_12_12;
        // D s_12_15: and s_12_7 s_12_14
        let s_12_15: u64 = ((s_12_7) & (s_12_14));
        // D s_12_16: select s_12_11 s_12_13 s_12_15
        let s_12_16: u64 = if s_12_11 { s_12_13 } else { s_12_15 };
        // D s_12_17: cast trunc s_12_16 -> u8
        let s_12_17: bool = ((s_12_16) != 0);
        // D s_12_18: cast zx s_12_17 -> bv
        let s_12_18: Bits = Bits::new(s_12_17 as u128, 1u16);
        // C s_12_19: const #1u : u8
        let s_12_19: bool = true;
        // C s_12_20: cast zx s_12_19 -> bv
        let s_12_20: Bits = Bits::new(s_12_19 as u128, 1u16);
        // D s_12_21: cmp-ne s_12_18 s_12_20
        let s_12_21: bool = ((s_12_18) != (s_12_20));
        // D s_12_22: write-var gs#397456 <= s_12_21
        fn_state.gs_397456 = s_12_21;
        // N s_12_23: jump b13
        return block_13(state, tracer, fn_state);
    }
    fn block_13<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_13_0: read-var gs#397456:u8
        let s_13_0: bool = fn_state.gs_397456;
        // N s_13_1: branch s_13_0 b45 b14
        if s_13_0 {
            return block_45(state, tracer, fn_state);
        } else {
            return block_14(state, tracer, fn_state);
        };
    }
    fn block_14<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_14_0: const #14s : i
        let s_14_0: i128 = 14;
        // D s_14_1: read-var __opcode:u32
        let s_14_1: u32 = fn_state.u__opcode;
        // D s_14_2: cast zx s_14_1 -> bv
        let s_14_2: Bits = Bits::new(s_14_1 as u128, 32u16);
        // C s_14_3: const #1u : u64
        let s_14_3: u64 = 1;
        // D s_14_4: bit-extract s_14_2 s_14_0 s_14_3
        let s_14_4: Bits = (Bits::new(
            ((s_14_2) >> (s_14_0)).value(),
            u16::try_from(s_14_3).unwrap(),
        ));
        // D s_14_5: cast reint s_14_4 -> u8
        let s_14_5: bool = ((s_14_4.value()) != 0);
        // C s_14_6: const #0s : i
        let s_14_6: i128 = 0;
        // C s_14_7: const #0u : u64
        let s_14_7: u64 = 0;
        // D s_14_8: cast zx s_14_5 -> u64
        let s_14_8: u64 = (s_14_5 as u64);
        // C s_14_9: const #1u : u64
        let s_14_9: u64 = 1;
        // D s_14_10: and s_14_8 s_14_9
        let s_14_10: u64 = ((s_14_8) & (s_14_9));
        // D s_14_11: cmp-eq s_14_10 s_14_9
        let s_14_11: bool = ((s_14_10) == (s_14_9));
        // D s_14_12: lsl s_14_8 s_14_6
        let s_14_12: u64 = s_14_8 << s_14_6;
        // D s_14_13: or s_14_7 s_14_12
        let s_14_13: u64 = ((s_14_7) | (s_14_12));
        // D s_14_14: cmpl s_14_12
        let s_14_14: u64 = !s_14_12;
        // D s_14_15: and s_14_7 s_14_14
        let s_14_15: u64 = ((s_14_7) & (s_14_14));
        // D s_14_16: select s_14_11 s_14_13 s_14_15
        let s_14_16: u64 = if s_14_11 { s_14_13 } else { s_14_15 };
        // D s_14_17: cast trunc s_14_16 -> u8
        let s_14_17: bool = ((s_14_16) != 0);
        // D s_14_18: cast zx s_14_17 -> bv
        let s_14_18: Bits = Bits::new(s_14_17 as u128, 1u16);
        // C s_14_19: const #1u : u8
        let s_14_19: bool = true;
        // C s_14_20: cast zx s_14_19 -> bv
        let s_14_20: Bits = Bits::new(s_14_19 as u128, 1u16);
        // D s_14_21: cmp-ne s_14_18 s_14_20
        let s_14_21: bool = ((s_14_18) != (s_14_20));
        // D s_14_22: write-var gs#397459 <= s_14_21
        fn_state.gs_397459 = s_14_21;
        // N s_14_23: jump b15
        return block_15(state, tracer, fn_state);
    }
    fn block_15<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_15_0: read-var gs#397459:u8
        let s_15_0: bool = fn_state.gs_397459;
        // N s_15_1: branch s_15_0 b44 b16
        if s_15_0 {
            return block_44(state, tracer, fn_state);
        } else {
            return block_16(state, tracer, fn_state);
        };
    }
    fn block_16<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_16_0: const #15s : i
        let s_16_0: i128 = 15;
        // D s_16_1: read-var __opcode:u32
        let s_16_1: u32 = fn_state.u__opcode;
        // D s_16_2: cast zx s_16_1 -> bv
        let s_16_2: Bits = Bits::new(s_16_1 as u128, 32u16);
        // C s_16_3: const #1u : u64
        let s_16_3: u64 = 1;
        // D s_16_4: bit-extract s_16_2 s_16_0 s_16_3
        let s_16_4: Bits = (Bits::new(
            ((s_16_2) >> (s_16_0)).value(),
            u16::try_from(s_16_3).unwrap(),
        ));
        // D s_16_5: cast reint s_16_4 -> u8
        let s_16_5: bool = ((s_16_4.value()) != 0);
        // C s_16_6: const #0s : i
        let s_16_6: i128 = 0;
        // C s_16_7: const #0u : u64
        let s_16_7: u64 = 0;
        // D s_16_8: cast zx s_16_5 -> u64
        let s_16_8: u64 = (s_16_5 as u64);
        // C s_16_9: const #1u : u64
        let s_16_9: u64 = 1;
        // D s_16_10: and s_16_8 s_16_9
        let s_16_10: u64 = ((s_16_8) & (s_16_9));
        // D s_16_11: cmp-eq s_16_10 s_16_9
        let s_16_11: bool = ((s_16_10) == (s_16_9));
        // D s_16_12: lsl s_16_8 s_16_6
        let s_16_12: u64 = s_16_8 << s_16_6;
        // D s_16_13: or s_16_7 s_16_12
        let s_16_13: u64 = ((s_16_7) | (s_16_12));
        // D s_16_14: cmpl s_16_12
        let s_16_14: u64 = !s_16_12;
        // D s_16_15: and s_16_7 s_16_14
        let s_16_15: u64 = ((s_16_7) & (s_16_14));
        // D s_16_16: select s_16_11 s_16_13 s_16_15
        let s_16_16: u64 = if s_16_11 { s_16_13 } else { s_16_15 };
        // D s_16_17: cast trunc s_16_16 -> u8
        let s_16_17: bool = ((s_16_16) != 0);
        // D s_16_18: cast zx s_16_17 -> bv
        let s_16_18: Bits = Bits::new(s_16_17 as u128, 1u16);
        // C s_16_19: const #1u : u8
        let s_16_19: bool = true;
        // C s_16_20: cast zx s_16_19 -> bv
        let s_16_20: Bits = Bits::new(s_16_19 as u128, 1u16);
        // D s_16_21: cmp-ne s_16_18 s_16_20
        let s_16_21: bool = ((s_16_18) != (s_16_20));
        // D s_16_22: write-var gs#397462 <= s_16_21
        fn_state.gs_397462 = s_16_21;
        // N s_16_23: jump b17
        return block_17(state, tracer, fn_state);
    }
    fn block_17<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_17_0: read-var gs#397462:u8
        let s_17_0: bool = fn_state.gs_397462;
        // N s_17_1: branch s_17_0 b43 b18
        if s_17_0 {
            return block_43(state, tracer, fn_state);
        } else {
            return block_18(state, tracer, fn_state);
        };
    }
    fn block_18<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_18_0: const #8s : i
        let s_18_0: i128 = 8;
        // D s_18_1: read-var __opcode:u32
        let s_18_1: u32 = fn_state.u__opcode;
        // D s_18_2: cast zx s_18_1 -> bv
        let s_18_2: Bits = Bits::new(s_18_1 as u128, 32u16);
        // C s_18_3: const #1u : u64
        let s_18_3: u64 = 1;
        // D s_18_4: bit-extract s_18_2 s_18_0 s_18_3
        let s_18_4: Bits = (Bits::new(
            ((s_18_2) >> (s_18_0)).value(),
            u16::try_from(s_18_3).unwrap(),
        ));
        // D s_18_5: cast reint s_18_4 -> u8
        let s_18_5: bool = ((s_18_4.value()) != 0);
        // C s_18_6: const #0s : i
        let s_18_6: i128 = 0;
        // C s_18_7: const #0u : u64
        let s_18_7: u64 = 0;
        // D s_18_8: cast zx s_18_5 -> u64
        let s_18_8: u64 = (s_18_5 as u64);
        // C s_18_9: const #1u : u64
        let s_18_9: u64 = 1;
        // D s_18_10: and s_18_8 s_18_9
        let s_18_10: u64 = ((s_18_8) & (s_18_9));
        // D s_18_11: cmp-eq s_18_10 s_18_9
        let s_18_11: bool = ((s_18_10) == (s_18_9));
        // D s_18_12: lsl s_18_8 s_18_6
        let s_18_12: u64 = s_18_8 << s_18_6;
        // D s_18_13: or s_18_7 s_18_12
        let s_18_13: u64 = ((s_18_7) | (s_18_12));
        // D s_18_14: cmpl s_18_12
        let s_18_14: u64 = !s_18_12;
        // D s_18_15: and s_18_7 s_18_14
        let s_18_15: u64 = ((s_18_7) & (s_18_14));
        // D s_18_16: select s_18_11 s_18_13 s_18_15
        let s_18_16: u64 = if s_18_11 { s_18_13 } else { s_18_15 };
        // D s_18_17: cast trunc s_18_16 -> u8
        let s_18_17: bool = ((s_18_16) != 0);
        // D s_18_18: cast zx s_18_17 -> bv
        let s_18_18: Bits = Bits::new(s_18_17 as u128, 1u16);
        // C s_18_19: const #0u : u8
        let s_18_19: bool = false;
        // C s_18_20: cast zx s_18_19 -> bv
        let s_18_20: Bits = Bits::new(s_18_19 as u128, 1u16);
        // D s_18_21: cmp-ne s_18_18 s_18_20
        let s_18_21: bool = ((s_18_18) != (s_18_20));
        // D s_18_22: write-var gs#397465 <= s_18_21
        fn_state.gs_397465 = s_18_21;
        // N s_18_23: jump b19
        return block_19(state, tracer, fn_state);
    }
    fn block_19<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_19_0: read-var gs#397465:u8
        let s_19_0: bool = fn_state.gs_397465;
        // N s_19_1: branch s_19_0 b42 b20
        if s_19_0 {
            return block_42(state, tracer, fn_state);
        } else {
            return block_20(state, tracer, fn_state);
        };
    }
    fn block_20<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_20_0: const #9s : i
        let s_20_0: i128 = 9;
        // D s_20_1: read-var __opcode:u32
        let s_20_1: u32 = fn_state.u__opcode;
        // D s_20_2: cast zx s_20_1 -> bv
        let s_20_2: Bits = Bits::new(s_20_1 as u128, 32u16);
        // C s_20_3: const #1u : u64
        let s_20_3: u64 = 1;
        // D s_20_4: bit-extract s_20_2 s_20_0 s_20_3
        let s_20_4: Bits = (Bits::new(
            ((s_20_2) >> (s_20_0)).value(),
            u16::try_from(s_20_3).unwrap(),
        ));
        // D s_20_5: cast reint s_20_4 -> u8
        let s_20_5: bool = ((s_20_4.value()) != 0);
        // C s_20_6: const #0s : i
        let s_20_6: i128 = 0;
        // C s_20_7: const #0u : u64
        let s_20_7: u64 = 0;
        // D s_20_8: cast zx s_20_5 -> u64
        let s_20_8: u64 = (s_20_5 as u64);
        // C s_20_9: const #1u : u64
        let s_20_9: u64 = 1;
        // D s_20_10: and s_20_8 s_20_9
        let s_20_10: u64 = ((s_20_8) & (s_20_9));
        // D s_20_11: cmp-eq s_20_10 s_20_9
        let s_20_11: bool = ((s_20_10) == (s_20_9));
        // D s_20_12: lsl s_20_8 s_20_6
        let s_20_12: u64 = s_20_8 << s_20_6;
        // D s_20_13: or s_20_7 s_20_12
        let s_20_13: u64 = ((s_20_7) | (s_20_12));
        // D s_20_14: cmpl s_20_12
        let s_20_14: u64 = !s_20_12;
        // D s_20_15: and s_20_7 s_20_14
        let s_20_15: u64 = ((s_20_7) & (s_20_14));
        // D s_20_16: select s_20_11 s_20_13 s_20_15
        let s_20_16: u64 = if s_20_11 { s_20_13 } else { s_20_15 };
        // D s_20_17: cast trunc s_20_16 -> u8
        let s_20_17: bool = ((s_20_16) != 0);
        // D s_20_18: cast zx s_20_17 -> bv
        let s_20_18: Bits = Bits::new(s_20_17 as u128, 1u16);
        // C s_20_19: const #0u : u8
        let s_20_19: bool = false;
        // C s_20_20: cast zx s_20_19 -> bv
        let s_20_20: Bits = Bits::new(s_20_19 as u128, 1u16);
        // D s_20_21: cmp-ne s_20_18 s_20_20
        let s_20_21: bool = ((s_20_18) != (s_20_20));
        // D s_20_22: write-var gs#397468 <= s_20_21
        fn_state.gs_397468 = s_20_21;
        // N s_20_23: jump b21
        return block_21(state, tracer, fn_state);
    }
    fn block_21<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_21_0: read-var gs#397468:u8
        let s_21_0: bool = fn_state.gs_397468;
        // N s_21_1: branch s_21_0 b41 b22
        if s_21_0 {
            return block_41(state, tracer, fn_state);
        } else {
            return block_22(state, tracer, fn_state);
        };
    }
    fn block_22<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_22_0: const #10s : i
        let s_22_0: i128 = 10;
        // D s_22_1: read-var __opcode:u32
        let s_22_1: u32 = fn_state.u__opcode;
        // D s_22_2: cast zx s_22_1 -> bv
        let s_22_2: Bits = Bits::new(s_22_1 as u128, 32u16);
        // C s_22_3: const #1u : u64
        let s_22_3: u64 = 1;
        // D s_22_4: bit-extract s_22_2 s_22_0 s_22_3
        let s_22_4: Bits = (Bits::new(
            ((s_22_2) >> (s_22_0)).value(),
            u16::try_from(s_22_3).unwrap(),
        ));
        // D s_22_5: cast reint s_22_4 -> u8
        let s_22_5: bool = ((s_22_4.value()) != 0);
        // C s_22_6: const #0s : i
        let s_22_6: i128 = 0;
        // C s_22_7: const #0u : u64
        let s_22_7: u64 = 0;
        // D s_22_8: cast zx s_22_5 -> u64
        let s_22_8: u64 = (s_22_5 as u64);
        // C s_22_9: const #1u : u64
        let s_22_9: u64 = 1;
        // D s_22_10: and s_22_8 s_22_9
        let s_22_10: u64 = ((s_22_8) & (s_22_9));
        // D s_22_11: cmp-eq s_22_10 s_22_9
        let s_22_11: bool = ((s_22_10) == (s_22_9));
        // D s_22_12: lsl s_22_8 s_22_6
        let s_22_12: u64 = s_22_8 << s_22_6;
        // D s_22_13: or s_22_7 s_22_12
        let s_22_13: u64 = ((s_22_7) | (s_22_12));
        // D s_22_14: cmpl s_22_12
        let s_22_14: u64 = !s_22_12;
        // D s_22_15: and s_22_7 s_22_14
        let s_22_15: u64 = ((s_22_7) & (s_22_14));
        // D s_22_16: select s_22_11 s_22_13 s_22_15
        let s_22_16: u64 = if s_22_11 { s_22_13 } else { s_22_15 };
        // D s_22_17: cast trunc s_22_16 -> u8
        let s_22_17: bool = ((s_22_16) != 0);
        // D s_22_18: cast zx s_22_17 -> bv
        let s_22_18: Bits = Bits::new(s_22_17 as u128, 1u16);
        // C s_22_19: const #0u : u8
        let s_22_19: bool = false;
        // C s_22_20: cast zx s_22_19 -> bv
        let s_22_20: Bits = Bits::new(s_22_19 as u128, 1u16);
        // D s_22_21: cmp-ne s_22_18 s_22_20
        let s_22_21: bool = ((s_22_18) != (s_22_20));
        // D s_22_22: write-var gs#397471 <= s_22_21
        fn_state.gs_397471 = s_22_21;
        // N s_22_23: jump b23
        return block_23(state, tracer, fn_state);
    }
    fn block_23<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_23_0: read-var gs#397471:u8
        let s_23_0: bool = fn_state.gs_397471;
        // N s_23_1: branch s_23_0 b40 b24
        if s_23_0 {
            return block_40(state, tracer, fn_state);
        } else {
            return block_24(state, tracer, fn_state);
        };
    }
    fn block_24<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_24_0: const #11s : i
        let s_24_0: i128 = 11;
        // D s_24_1: read-var __opcode:u32
        let s_24_1: u32 = fn_state.u__opcode;
        // D s_24_2: cast zx s_24_1 -> bv
        let s_24_2: Bits = Bits::new(s_24_1 as u128, 32u16);
        // C s_24_3: const #1u : u64
        let s_24_3: u64 = 1;
        // D s_24_4: bit-extract s_24_2 s_24_0 s_24_3
        let s_24_4: Bits = (Bits::new(
            ((s_24_2) >> (s_24_0)).value(),
            u16::try_from(s_24_3).unwrap(),
        ));
        // D s_24_5: cast reint s_24_4 -> u8
        let s_24_5: bool = ((s_24_4.value()) != 0);
        // C s_24_6: const #0s : i
        let s_24_6: i128 = 0;
        // C s_24_7: const #0u : u64
        let s_24_7: u64 = 0;
        // D s_24_8: cast zx s_24_5 -> u64
        let s_24_8: u64 = (s_24_5 as u64);
        // C s_24_9: const #1u : u64
        let s_24_9: u64 = 1;
        // D s_24_10: and s_24_8 s_24_9
        let s_24_10: u64 = ((s_24_8) & (s_24_9));
        // D s_24_11: cmp-eq s_24_10 s_24_9
        let s_24_11: bool = ((s_24_10) == (s_24_9));
        // D s_24_12: lsl s_24_8 s_24_6
        let s_24_12: u64 = s_24_8 << s_24_6;
        // D s_24_13: or s_24_7 s_24_12
        let s_24_13: u64 = ((s_24_7) | (s_24_12));
        // D s_24_14: cmpl s_24_12
        let s_24_14: u64 = !s_24_12;
        // D s_24_15: and s_24_7 s_24_14
        let s_24_15: u64 = ((s_24_7) & (s_24_14));
        // D s_24_16: select s_24_11 s_24_13 s_24_15
        let s_24_16: u64 = if s_24_11 { s_24_13 } else { s_24_15 };
        // D s_24_17: cast trunc s_24_16 -> u8
        let s_24_17: bool = ((s_24_16) != 0);
        // D s_24_18: cast zx s_24_17 -> bv
        let s_24_18: Bits = Bits::new(s_24_17 as u128, 1u16);
        // C s_24_19: const #0u : u8
        let s_24_19: bool = false;
        // C s_24_20: cast zx s_24_19 -> bv
        let s_24_20: Bits = Bits::new(s_24_19 as u128, 1u16);
        // D s_24_21: cmp-ne s_24_18 s_24_20
        let s_24_21: bool = ((s_24_18) != (s_24_20));
        // D s_24_22: write-var gs#397474 <= s_24_21
        fn_state.gs_397474 = s_24_21;
        // N s_24_23: jump b25
        return block_25(state, tracer, fn_state);
    }
    fn block_25<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_25_0: read-var gs#397474:u8
        let s_25_0: bool = fn_state.gs_397474;
        // N s_25_1: branch s_25_0 b39 b26
        if s_25_0 {
            return block_39(state, tracer, fn_state);
        } else {
            return block_26(state, tracer, fn_state);
        };
    }
    fn block_26<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_26_0: const #0s : i
        let s_26_0: i128 = 0;
        // D s_26_1: read-var __opcode:u32
        let s_26_1: u32 = fn_state.u__opcode;
        // D s_26_2: cast zx s_26_1 -> bv
        let s_26_2: Bits = Bits::new(s_26_1 as u128, 32u16);
        // C s_26_3: const #1u : u64
        let s_26_3: u64 = 1;
        // D s_26_4: bit-extract s_26_2 s_26_0 s_26_3
        let s_26_4: Bits = (Bits::new(
            ((s_26_2) >> (s_26_0)).value(),
            u16::try_from(s_26_3).unwrap(),
        ));
        // D s_26_5: cast reint s_26_4 -> u8
        let s_26_5: bool = ((s_26_4.value()) != 0);
        // C s_26_6: const #0s : i
        let s_26_6: i128 = 0;
        // C s_26_7: const #0u : u64
        let s_26_7: u64 = 0;
        // D s_26_8: cast zx s_26_5 -> u64
        let s_26_8: u64 = (s_26_5 as u64);
        // C s_26_9: const #1u : u64
        let s_26_9: u64 = 1;
        // D s_26_10: and s_26_8 s_26_9
        let s_26_10: u64 = ((s_26_8) & (s_26_9));
        // D s_26_11: cmp-eq s_26_10 s_26_9
        let s_26_11: bool = ((s_26_10) == (s_26_9));
        // D s_26_12: lsl s_26_8 s_26_6
        let s_26_12: u64 = s_26_8 << s_26_6;
        // D s_26_13: or s_26_7 s_26_12
        let s_26_13: u64 = ((s_26_7) | (s_26_12));
        // D s_26_14: cmpl s_26_12
        let s_26_14: u64 = !s_26_12;
        // D s_26_15: and s_26_7 s_26_14
        let s_26_15: u64 = ((s_26_7) & (s_26_14));
        // D s_26_16: select s_26_11 s_26_13 s_26_15
        let s_26_16: u64 = if s_26_11 { s_26_13 } else { s_26_15 };
        // D s_26_17: cast trunc s_26_16 -> u8
        let s_26_17: bool = ((s_26_16) != 0);
        // D s_26_18: cast zx s_26_17 -> bv
        let s_26_18: Bits = Bits::new(s_26_17 as u128, 1u16);
        // C s_26_19: const #1u : u8
        let s_26_19: bool = true;
        // C s_26_20: cast zx s_26_19 -> bv
        let s_26_20: Bits = Bits::new(s_26_19 as u128, 1u16);
        // D s_26_21: cmp-ne s_26_18 s_26_20
        let s_26_21: bool = ((s_26_18) != (s_26_20));
        // D s_26_22: write-var gs#397477 <= s_26_21
        fn_state.gs_397477 = s_26_21;
        // N s_26_23: jump b27
        return block_27(state, tracer, fn_state);
    }
    fn block_27<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_27_0: read-var gs#397477:u8
        let s_27_0: bool = fn_state.gs_397477;
        // N s_27_1: branch s_27_0 b38 b28
        if s_27_0 {
            return block_38(state, tracer, fn_state);
        } else {
            return block_28(state, tracer, fn_state);
        };
    }
    fn block_28<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_28_0: const #1s : i
        let s_28_0: i128 = 1;
        // D s_28_1: read-var __opcode:u32
        let s_28_1: u32 = fn_state.u__opcode;
        // D s_28_2: cast zx s_28_1 -> bv
        let s_28_2: Bits = Bits::new(s_28_1 as u128, 32u16);
        // C s_28_3: const #1u : u64
        let s_28_3: u64 = 1;
        // D s_28_4: bit-extract s_28_2 s_28_0 s_28_3
        let s_28_4: Bits = (Bits::new(
            ((s_28_2) >> (s_28_0)).value(),
            u16::try_from(s_28_3).unwrap(),
        ));
        // D s_28_5: cast reint s_28_4 -> u8
        let s_28_5: bool = ((s_28_4.value()) != 0);
        // C s_28_6: const #0s : i
        let s_28_6: i128 = 0;
        // C s_28_7: const #0u : u64
        let s_28_7: u64 = 0;
        // D s_28_8: cast zx s_28_5 -> u64
        let s_28_8: u64 = (s_28_5 as u64);
        // C s_28_9: const #1u : u64
        let s_28_9: u64 = 1;
        // D s_28_10: and s_28_8 s_28_9
        let s_28_10: u64 = ((s_28_8) & (s_28_9));
        // D s_28_11: cmp-eq s_28_10 s_28_9
        let s_28_11: bool = ((s_28_10) == (s_28_9));
        // D s_28_12: lsl s_28_8 s_28_6
        let s_28_12: u64 = s_28_8 << s_28_6;
        // D s_28_13: or s_28_7 s_28_12
        let s_28_13: u64 = ((s_28_7) | (s_28_12));
        // D s_28_14: cmpl s_28_12
        let s_28_14: u64 = !s_28_12;
        // D s_28_15: and s_28_7 s_28_14
        let s_28_15: u64 = ((s_28_7) & (s_28_14));
        // D s_28_16: select s_28_11 s_28_13 s_28_15
        let s_28_16: u64 = if s_28_11 { s_28_13 } else { s_28_15 };
        // D s_28_17: cast trunc s_28_16 -> u8
        let s_28_17: bool = ((s_28_16) != 0);
        // D s_28_18: cast zx s_28_17 -> bv
        let s_28_18: Bits = Bits::new(s_28_17 as u128, 1u16);
        // C s_28_19: const #1u : u8
        let s_28_19: bool = true;
        // C s_28_20: cast zx s_28_19 -> bv
        let s_28_20: Bits = Bits::new(s_28_19 as u128, 1u16);
        // D s_28_21: cmp-ne s_28_18 s_28_20
        let s_28_21: bool = ((s_28_18) != (s_28_20));
        // D s_28_22: write-var gs#397480 <= s_28_21
        fn_state.gs_397480 = s_28_21;
        // N s_28_23: jump b29
        return block_29(state, tracer, fn_state);
    }
    fn block_29<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_29_0: read-var gs#397480:u8
        let s_29_0: bool = fn_state.gs_397480;
        // N s_29_1: branch s_29_0 b37 b30
        if s_29_0 {
            return block_37(state, tracer, fn_state);
        } else {
            return block_30(state, tracer, fn_state);
        };
    }
    fn block_30<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_30_0: const #2s : i
        let s_30_0: i128 = 2;
        // D s_30_1: read-var __opcode:u32
        let s_30_1: u32 = fn_state.u__opcode;
        // D s_30_2: cast zx s_30_1 -> bv
        let s_30_2: Bits = Bits::new(s_30_1 as u128, 32u16);
        // C s_30_3: const #1u : u64
        let s_30_3: u64 = 1;
        // D s_30_4: bit-extract s_30_2 s_30_0 s_30_3
        let s_30_4: Bits = (Bits::new(
            ((s_30_2) >> (s_30_0)).value(),
            u16::try_from(s_30_3).unwrap(),
        ));
        // D s_30_5: cast reint s_30_4 -> u8
        let s_30_5: bool = ((s_30_4.value()) != 0);
        // C s_30_6: const #0s : i
        let s_30_6: i128 = 0;
        // C s_30_7: const #0u : u64
        let s_30_7: u64 = 0;
        // D s_30_8: cast zx s_30_5 -> u64
        let s_30_8: u64 = (s_30_5 as u64);
        // C s_30_9: const #1u : u64
        let s_30_9: u64 = 1;
        // D s_30_10: and s_30_8 s_30_9
        let s_30_10: u64 = ((s_30_8) & (s_30_9));
        // D s_30_11: cmp-eq s_30_10 s_30_9
        let s_30_11: bool = ((s_30_10) == (s_30_9));
        // D s_30_12: lsl s_30_8 s_30_6
        let s_30_12: u64 = s_30_8 << s_30_6;
        // D s_30_13: or s_30_7 s_30_12
        let s_30_13: u64 = ((s_30_7) | (s_30_12));
        // D s_30_14: cmpl s_30_12
        let s_30_14: u64 = !s_30_12;
        // D s_30_15: and s_30_7 s_30_14
        let s_30_15: u64 = ((s_30_7) & (s_30_14));
        // D s_30_16: select s_30_11 s_30_13 s_30_15
        let s_30_16: u64 = if s_30_11 { s_30_13 } else { s_30_15 };
        // D s_30_17: cast trunc s_30_16 -> u8
        let s_30_17: bool = ((s_30_16) != 0);
        // D s_30_18: cast zx s_30_17 -> bv
        let s_30_18: Bits = Bits::new(s_30_17 as u128, 1u16);
        // C s_30_19: const #1u : u8
        let s_30_19: bool = true;
        // C s_30_20: cast zx s_30_19 -> bv
        let s_30_20: Bits = Bits::new(s_30_19 as u128, 1u16);
        // D s_30_21: cmp-ne s_30_18 s_30_20
        let s_30_21: bool = ((s_30_18) != (s_30_20));
        // D s_30_22: write-var gs#397483 <= s_30_21
        fn_state.gs_397483 = s_30_21;
        // N s_30_23: jump b31
        return block_31(state, tracer, fn_state);
    }
    fn block_31<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_31_0: read-var gs#397483:u8
        let s_31_0: bool = fn_state.gs_397483;
        // N s_31_1: branch s_31_0 b36 b32
        if s_31_0 {
            return block_36(state, tracer, fn_state);
        } else {
            return block_32(state, tracer, fn_state);
        };
    }
    fn block_32<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_32_0: const #3s : i
        let s_32_0: i128 = 3;
        // D s_32_1: read-var __opcode:u32
        let s_32_1: u32 = fn_state.u__opcode;
        // D s_32_2: cast zx s_32_1 -> bv
        let s_32_2: Bits = Bits::new(s_32_1 as u128, 32u16);
        // C s_32_3: const #1u : u64
        let s_32_3: u64 = 1;
        // D s_32_4: bit-extract s_32_2 s_32_0 s_32_3
        let s_32_4: Bits = (Bits::new(
            ((s_32_2) >> (s_32_0)).value(),
            u16::try_from(s_32_3).unwrap(),
        ));
        // D s_32_5: cast reint s_32_4 -> u8
        let s_32_5: bool = ((s_32_4.value()) != 0);
        // C s_32_6: const #0s : i
        let s_32_6: i128 = 0;
        // C s_32_7: const #0u : u64
        let s_32_7: u64 = 0;
        // D s_32_8: cast zx s_32_5 -> u64
        let s_32_8: u64 = (s_32_5 as u64);
        // C s_32_9: const #1u : u64
        let s_32_9: u64 = 1;
        // D s_32_10: and s_32_8 s_32_9
        let s_32_10: u64 = ((s_32_8) & (s_32_9));
        // D s_32_11: cmp-eq s_32_10 s_32_9
        let s_32_11: bool = ((s_32_10) == (s_32_9));
        // D s_32_12: lsl s_32_8 s_32_6
        let s_32_12: u64 = s_32_8 << s_32_6;
        // D s_32_13: or s_32_7 s_32_12
        let s_32_13: u64 = ((s_32_7) | (s_32_12));
        // D s_32_14: cmpl s_32_12
        let s_32_14: u64 = !s_32_12;
        // D s_32_15: and s_32_7 s_32_14
        let s_32_15: u64 = ((s_32_7) & (s_32_14));
        // D s_32_16: select s_32_11 s_32_13 s_32_15
        let s_32_16: u64 = if s_32_11 { s_32_13 } else { s_32_15 };
        // D s_32_17: cast trunc s_32_16 -> u8
        let s_32_17: bool = ((s_32_16) != 0);
        // D s_32_18: cast zx s_32_17 -> bv
        let s_32_18: Bits = Bits::new(s_32_17 as u128, 1u16);
        // C s_32_19: const #1u : u8
        let s_32_19: bool = true;
        // C s_32_20: cast zx s_32_19 -> bv
        let s_32_20: Bits = Bits::new(s_32_19 as u128, 1u16);
        // D s_32_21: cmp-ne s_32_18 s_32_20
        let s_32_21: bool = ((s_32_18) != (s_32_20));
        // D s_32_22: write-var gs#397486 <= s_32_21
        fn_state.gs_397486 = s_32_21;
        // N s_32_23: jump b33
        return block_33(state, tracer, fn_state);
    }
    fn block_33<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_33_0: read-var gs#397486:u8
        let s_33_0: bool = fn_state.gs_397486;
        // N s_33_1: branch s_33_0 b35 b34
        if s_33_0 {
            return block_35(state, tracer, fn_state);
        } else {
            return block_34(state, tracer, fn_state);
        };
    }
    fn block_34<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_34_0: const #() : ()
        let s_34_0: () = ();
        // S s_34_1: call decode_aarch32_instrs_CLREX_A1enc_A_txt(s_34_0)
        let s_34_1: () = decode_aarch32_instrs_CLREX_A1enc_A_txt(state, tracer, s_34_0);
        // N s_34_2: return
        return;
    }
    fn block_35<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_35_0: panic
        panic!("{:?}", ());
        // N s_35_1: return
        return;
    }
    fn block_36<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_36_0: const #1u : u8
        let s_36_0: bool = true;
        // D s_36_1: write-var gs#397486 <= s_36_0
        fn_state.gs_397486 = s_36_0;
        // N s_36_2: jump b33
        return block_33(state, tracer, fn_state);
    }
    fn block_37<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_37_0: const #1u : u8
        let s_37_0: bool = true;
        // D s_37_1: write-var gs#397483 <= s_37_0
        fn_state.gs_397483 = s_37_0;
        // N s_37_2: jump b31
        return block_31(state, tracer, fn_state);
    }
    fn block_38<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_38_0: const #1u : u8
        let s_38_0: bool = true;
        // D s_38_1: write-var gs#397480 <= s_38_0
        fn_state.gs_397480 = s_38_0;
        // N s_38_2: jump b29
        return block_29(state, tracer, fn_state);
    }
    fn block_39<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_39_0: const #1u : u8
        let s_39_0: bool = true;
        // D s_39_1: write-var gs#397477 <= s_39_0
        fn_state.gs_397477 = s_39_0;
        // N s_39_2: jump b27
        return block_27(state, tracer, fn_state);
    }
    fn block_40<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_40_0: const #1u : u8
        let s_40_0: bool = true;
        // D s_40_1: write-var gs#397474 <= s_40_0
        fn_state.gs_397474 = s_40_0;
        // N s_40_2: jump b25
        return block_25(state, tracer, fn_state);
    }
    fn block_41<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_41_0: const #1u : u8
        let s_41_0: bool = true;
        // D s_41_1: write-var gs#397471 <= s_41_0
        fn_state.gs_397471 = s_41_0;
        // N s_41_2: jump b23
        return block_23(state, tracer, fn_state);
    }
    fn block_42<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_42_0: const #1u : u8
        let s_42_0: bool = true;
        // D s_42_1: write-var gs#397468 <= s_42_0
        fn_state.gs_397468 = s_42_0;
        // N s_42_2: jump b21
        return block_21(state, tracer, fn_state);
    }
    fn block_43<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_43_0: const #1u : u8
        let s_43_0: bool = true;
        // D s_43_1: write-var gs#397465 <= s_43_0
        fn_state.gs_397465 = s_43_0;
        // N s_43_2: jump b19
        return block_19(state, tracer, fn_state);
    }
    fn block_44<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_44_0: const #1u : u8
        let s_44_0: bool = true;
        // D s_44_1: write-var gs#397462 <= s_44_0
        fn_state.gs_397462 = s_44_0;
        // N s_44_2: jump b17
        return block_17(state, tracer, fn_state);
    }
    fn block_45<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_45_0: const #1u : u8
        let s_45_0: bool = true;
        // D s_45_1: write-var gs#397459 <= s_45_0
        fn_state.gs_397459 = s_45_0;
        // N s_45_2: jump b15
        return block_15(state, tracer, fn_state);
    }
    fn block_46<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_46_0: const #1u : u8
        let s_46_0: bool = true;
        // D s_46_1: write-var gs#397456 <= s_46_0
        fn_state.gs_397456 = s_46_0;
        // N s_46_2: jump b13
        return block_13(state, tracer, fn_state);
    }
    fn block_47<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_47_0: const #1u : u8
        let s_47_0: bool = true;
        // D s_47_1: write-var gs#397453 <= s_47_0
        fn_state.gs_397453 = s_47_0;
        // N s_47_2: jump b11
        return block_11(state, tracer, fn_state);
    }
    fn block_48<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_48_0: const #1u : u8
        let s_48_0: bool = true;
        // D s_48_1: write-var gs#397450 <= s_48_0
        fn_state.gs_397450 = s_48_0;
        // N s_48_2: jump b9
        return block_9(state, tracer, fn_state);
    }
    fn block_49<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_49_0: const #1u : u8
        let s_49_0: bool = true;
        // D s_49_1: write-var gs#397447 <= s_49_0
        fn_state.gs_397447 = s_49_0;
        // N s_49_2: jump b7
        return block_7(state, tracer, fn_state);
    }
    fn block_50<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_50_0: const #1u : u8
        let s_50_0: bool = true;
        // D s_50_1: write-var gs#397444 <= s_50_0
        fn_state.gs_397444 = s_50_0;
        // N s_50_2: jump b5
        return block_5(state, tracer, fn_state);
    }
    fn block_51<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_51_0: read-var merge#var.1:struct
        let s_51_0: u32 = fn_state.merge_var._1;
        // D s_51_1: write-var u#30556 <= s_51_0
        fn_state.u_30556 = s_51_0;
        // C s_51_2: const #4s : i
        let s_51_2: i128 = 4;
        // D s_51_3: read-var u#30556:u32
        let s_51_3: u32 = fn_state.u_30556;
        // D s_51_4: cast zx s_51_3 -> bv
        let s_51_4: Bits = Bits::new(s_51_3 as u128, 32u16);
        // C s_51_5: const #1s : i64
        let s_51_5: i64 = 1;
        // C s_51_6: cast zx s_51_5 -> i
        let s_51_6: i128 = (i128::try_from(s_51_5).unwrap());
        // C s_51_7: const #27s : i
        let s_51_7: i128 = 27;
        // C s_51_8: add s_51_7 s_51_6
        let s_51_8: i128 = (s_51_7 + s_51_6);
        // D s_51_9: bit-extract s_51_4 s_51_2 s_51_8
        let s_51_9: Bits = (Bits::new(
            ((s_51_4) >> (s_51_2)).value(),
            u16::try_from(s_51_8).unwrap(),
        ));
        // D s_51_10: cast reint s_51_9 -> u28
        let s_51_10: u32 = (s_51_9.value() as u32);
        // D s_51_11: cast zx s_51_10 -> bv
        let s_51_11: Bits = Bits::new(s_51_10 as u128, 28u16);
        // C s_51_12: const #257425157u : u28
        let s_51_12: u32 = 257425157;
        // C s_51_13: cast zx s_51_12 -> bv
        let s_51_13: Bits = Bits::new(s_51_12 as u128, 28u16);
        // D s_51_14: cmp-eq s_51_11 s_51_13
        let s_51_14: bool = ((s_51_11) == (s_51_13));
        // N s_51_15: branch s_51_14 b3224 b52
        if s_51_14 {
            return block_3224(state, tracer, fn_state);
        } else {
            return block_52(state, tracer, fn_state);
        };
    }
    fn block_52<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_52_0: const #0u : u8
        let s_52_0: bool = false;
        // D s_52_1: write-var gs#397491 <= s_52_0
        fn_state.gs_397491 = s_52_0;
        // N s_52_2: jump b53
        return block_53(state, tracer, fn_state);
    }
    fn block_53<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_53_0: read-var gs#397491:u8
        let s_53_0: bool = fn_state.gs_397491;
        // D s_53_1: not s_53_0
        let s_53_1: bool = !s_53_0;
        // N s_53_2: branch s_53_1 b90 b54
        if s_53_1 {
            return block_90(state, tracer, fn_state);
        } else {
            return block_54(state, tracer, fn_state);
        };
    }
    fn block_54<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_54_0: const #2899s : i
        let s_54_0: i128 = 2899;
        // C s_54_1: const #14696u : u32
        let s_54_1: u32 = 14696;
        // N s_54_2: write-reg s_54_1 <= s_54_0
        let s_54_2: () = {
            state.write_register::<i128>(s_54_1 as isize, s_54_0);
            tracer.write_register(s_54_1 as isize, s_54_0);
        };
        // C s_54_3: const #0s : i
        let s_54_3: i128 = 0;
        // C s_54_4: const #4s : i
        let s_54_4: i128 = 4;
        // D s_54_5: read-var u#30556:u32
        let s_54_5: u32 = fn_state.u_30556;
        // D s_54_6: cast zx s_54_5 -> bv
        let s_54_6: Bits = Bits::new(s_54_5 as u128, 32u16);
        // D s_54_7: bit-extract s_54_6 s_54_3 s_54_4
        let s_54_7: Bits = (Bits::new(
            ((s_54_6) >> (s_54_3)).value(),
            u16::try_from(s_54_4).unwrap(),
        ));
        // D s_54_8: cast reint s_54_7 -> u8
        let s_54_8: u8 = (s_54_7.value() as u8);
        // D s_54_9: write-var option_name <= s_54_8
        fn_state.option_name = s_54_8;
        // C s_54_10: const #16s : i
        let s_54_10: i128 = 16;
        // D s_54_11: read-var u#30556:u32
        let s_54_11: u32 = fn_state.u_30556;
        // D s_54_12: cast zx s_54_11 -> bv
        let s_54_12: Bits = Bits::new(s_54_11 as u128, 32u16);
        // C s_54_13: const #1u : u64
        let s_54_13: u64 = 1;
        // D s_54_14: bit-extract s_54_12 s_54_10 s_54_13
        let s_54_14: Bits = (Bits::new(
            ((s_54_12) >> (s_54_10)).value(),
            u16::try_from(s_54_13).unwrap(),
        ));
        // D s_54_15: cast reint s_54_14 -> u8
        let s_54_15: bool = ((s_54_14.value()) != 0);
        // C s_54_16: const #0s : i
        let s_54_16: i128 = 0;
        // C s_54_17: const #0u : u64
        let s_54_17: u64 = 0;
        // D s_54_18: cast zx s_54_15 -> u64
        let s_54_18: u64 = (s_54_15 as u64);
        // C s_54_19: const #1u : u64
        let s_54_19: u64 = 1;
        // D s_54_20: and s_54_18 s_54_19
        let s_54_20: u64 = ((s_54_18) & (s_54_19));
        // D s_54_21: cmp-eq s_54_20 s_54_19
        let s_54_21: bool = ((s_54_20) == (s_54_19));
        // D s_54_22: lsl s_54_18 s_54_16
        let s_54_22: u64 = s_54_18 << s_54_16;
        // D s_54_23: or s_54_17 s_54_22
        let s_54_23: u64 = ((s_54_17) | (s_54_22));
        // D s_54_24: cmpl s_54_22
        let s_54_24: u64 = !s_54_22;
        // D s_54_25: and s_54_17 s_54_24
        let s_54_25: u64 = ((s_54_17) & (s_54_24));
        // D s_54_26: select s_54_21 s_54_23 s_54_25
        let s_54_26: u64 = if s_54_21 { s_54_23 } else { s_54_25 };
        // D s_54_27: cast trunc s_54_26 -> u8
        let s_54_27: bool = ((s_54_26) != 0);
        // D s_54_28: cast zx s_54_27 -> bv
        let s_54_28: Bits = Bits::new(s_54_27 as u128, 1u16);
        // C s_54_29: const #1u : u8
        let s_54_29: bool = true;
        // C s_54_30: cast zx s_54_29 -> bv
        let s_54_30: Bits = Bits::new(s_54_29 as u128, 1u16);
        // D s_54_31: cmp-ne s_54_28 s_54_30
        let s_54_31: bool = ((s_54_28) != (s_54_30));
        // N s_54_32: branch s_54_31 b89 b55
        if s_54_31 {
            return block_89(state, tracer, fn_state);
        } else {
            return block_55(state, tracer, fn_state);
        };
    }
    fn block_55<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_55_0: const #17s : i
        let s_55_0: i128 = 17;
        // D s_55_1: read-var u#30556:u32
        let s_55_1: u32 = fn_state.u_30556;
        // D s_55_2: cast zx s_55_1 -> bv
        let s_55_2: Bits = Bits::new(s_55_1 as u128, 32u16);
        // C s_55_3: const #1u : u64
        let s_55_3: u64 = 1;
        // D s_55_4: bit-extract s_55_2 s_55_0 s_55_3
        let s_55_4: Bits = (Bits::new(
            ((s_55_2) >> (s_55_0)).value(),
            u16::try_from(s_55_3).unwrap(),
        ));
        // D s_55_5: cast reint s_55_4 -> u8
        let s_55_5: bool = ((s_55_4.value()) != 0);
        // C s_55_6: const #0s : i
        let s_55_6: i128 = 0;
        // C s_55_7: const #0u : u64
        let s_55_7: u64 = 0;
        // D s_55_8: cast zx s_55_5 -> u64
        let s_55_8: u64 = (s_55_5 as u64);
        // C s_55_9: const #1u : u64
        let s_55_9: u64 = 1;
        // D s_55_10: and s_55_8 s_55_9
        let s_55_10: u64 = ((s_55_8) & (s_55_9));
        // D s_55_11: cmp-eq s_55_10 s_55_9
        let s_55_11: bool = ((s_55_10) == (s_55_9));
        // D s_55_12: lsl s_55_8 s_55_6
        let s_55_12: u64 = s_55_8 << s_55_6;
        // D s_55_13: or s_55_7 s_55_12
        let s_55_13: u64 = ((s_55_7) | (s_55_12));
        // D s_55_14: cmpl s_55_12
        let s_55_14: u64 = !s_55_12;
        // D s_55_15: and s_55_7 s_55_14
        let s_55_15: u64 = ((s_55_7) & (s_55_14));
        // D s_55_16: select s_55_11 s_55_13 s_55_15
        let s_55_16: u64 = if s_55_11 { s_55_13 } else { s_55_15 };
        // D s_55_17: cast trunc s_55_16 -> u8
        let s_55_17: bool = ((s_55_16) != 0);
        // D s_55_18: cast zx s_55_17 -> bv
        let s_55_18: Bits = Bits::new(s_55_17 as u128, 1u16);
        // C s_55_19: const #1u : u8
        let s_55_19: bool = true;
        // C s_55_20: cast zx s_55_19 -> bv
        let s_55_20: Bits = Bits::new(s_55_19 as u128, 1u16);
        // D s_55_21: cmp-ne s_55_18 s_55_20
        let s_55_21: bool = ((s_55_18) != (s_55_20));
        // D s_55_22: write-var gs#397500 <= s_55_21
        fn_state.gs_397500 = s_55_21;
        // N s_55_23: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_56<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_56_0: read-var gs#397500:u8
        let s_56_0: bool = fn_state.gs_397500;
        // N s_56_1: branch s_56_0 b88 b57
        if s_56_0 {
            return block_88(state, tracer, fn_state);
        } else {
            return block_57(state, tracer, fn_state);
        };
    }
    fn block_57<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_57_0: const #18s : i
        let s_57_0: i128 = 18;
        // D s_57_1: read-var u#30556:u32
        let s_57_1: u32 = fn_state.u_30556;
        // D s_57_2: cast zx s_57_1 -> bv
        let s_57_2: Bits = Bits::new(s_57_1 as u128, 32u16);
        // C s_57_3: const #1u : u64
        let s_57_3: u64 = 1;
        // D s_57_4: bit-extract s_57_2 s_57_0 s_57_3
        let s_57_4: Bits = (Bits::new(
            ((s_57_2) >> (s_57_0)).value(),
            u16::try_from(s_57_3).unwrap(),
        ));
        // D s_57_5: cast reint s_57_4 -> u8
        let s_57_5: bool = ((s_57_4.value()) != 0);
        // C s_57_6: const #0s : i
        let s_57_6: i128 = 0;
        // C s_57_7: const #0u : u64
        let s_57_7: u64 = 0;
        // D s_57_8: cast zx s_57_5 -> u64
        let s_57_8: u64 = (s_57_5 as u64);
        // C s_57_9: const #1u : u64
        let s_57_9: u64 = 1;
        // D s_57_10: and s_57_8 s_57_9
        let s_57_10: u64 = ((s_57_8) & (s_57_9));
        // D s_57_11: cmp-eq s_57_10 s_57_9
        let s_57_11: bool = ((s_57_10) == (s_57_9));
        // D s_57_12: lsl s_57_8 s_57_6
        let s_57_12: u64 = s_57_8 << s_57_6;
        // D s_57_13: or s_57_7 s_57_12
        let s_57_13: u64 = ((s_57_7) | (s_57_12));
        // D s_57_14: cmpl s_57_12
        let s_57_14: u64 = !s_57_12;
        // D s_57_15: and s_57_7 s_57_14
        let s_57_15: u64 = ((s_57_7) & (s_57_14));
        // D s_57_16: select s_57_11 s_57_13 s_57_15
        let s_57_16: u64 = if s_57_11 { s_57_13 } else { s_57_15 };
        // D s_57_17: cast trunc s_57_16 -> u8
        let s_57_17: bool = ((s_57_16) != 0);
        // D s_57_18: cast zx s_57_17 -> bv
        let s_57_18: Bits = Bits::new(s_57_17 as u128, 1u16);
        // C s_57_19: const #1u : u8
        let s_57_19: bool = true;
        // C s_57_20: cast zx s_57_19 -> bv
        let s_57_20: Bits = Bits::new(s_57_19 as u128, 1u16);
        // D s_57_21: cmp-ne s_57_18 s_57_20
        let s_57_21: bool = ((s_57_18) != (s_57_20));
        // D s_57_22: write-var gs#397503 <= s_57_21
        fn_state.gs_397503 = s_57_21;
        // N s_57_23: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_58<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_58_0: read-var gs#397503:u8
        let s_58_0: bool = fn_state.gs_397503;
        // N s_58_1: branch s_58_0 b87 b59
        if s_58_0 {
            return block_87(state, tracer, fn_state);
        } else {
            return block_59(state, tracer, fn_state);
        };
    }
    fn block_59<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_59_0: const #19s : i
        let s_59_0: i128 = 19;
        // D s_59_1: read-var u#30556:u32
        let s_59_1: u32 = fn_state.u_30556;
        // D s_59_2: cast zx s_59_1 -> bv
        let s_59_2: Bits = Bits::new(s_59_1 as u128, 32u16);
        // C s_59_3: const #1u : u64
        let s_59_3: u64 = 1;
        // D s_59_4: bit-extract s_59_2 s_59_0 s_59_3
        let s_59_4: Bits = (Bits::new(
            ((s_59_2) >> (s_59_0)).value(),
            u16::try_from(s_59_3).unwrap(),
        ));
        // D s_59_5: cast reint s_59_4 -> u8
        let s_59_5: bool = ((s_59_4.value()) != 0);
        // C s_59_6: const #0s : i
        let s_59_6: i128 = 0;
        // C s_59_7: const #0u : u64
        let s_59_7: u64 = 0;
        // D s_59_8: cast zx s_59_5 -> u64
        let s_59_8: u64 = (s_59_5 as u64);
        // C s_59_9: const #1u : u64
        let s_59_9: u64 = 1;
        // D s_59_10: and s_59_8 s_59_9
        let s_59_10: u64 = ((s_59_8) & (s_59_9));
        // D s_59_11: cmp-eq s_59_10 s_59_9
        let s_59_11: bool = ((s_59_10) == (s_59_9));
        // D s_59_12: lsl s_59_8 s_59_6
        let s_59_12: u64 = s_59_8 << s_59_6;
        // D s_59_13: or s_59_7 s_59_12
        let s_59_13: u64 = ((s_59_7) | (s_59_12));
        // D s_59_14: cmpl s_59_12
        let s_59_14: u64 = !s_59_12;
        // D s_59_15: and s_59_7 s_59_14
        let s_59_15: u64 = ((s_59_7) & (s_59_14));
        // D s_59_16: select s_59_11 s_59_13 s_59_15
        let s_59_16: u64 = if s_59_11 { s_59_13 } else { s_59_15 };
        // D s_59_17: cast trunc s_59_16 -> u8
        let s_59_17: bool = ((s_59_16) != 0);
        // D s_59_18: cast zx s_59_17 -> bv
        let s_59_18: Bits = Bits::new(s_59_17 as u128, 1u16);
        // C s_59_19: const #1u : u8
        let s_59_19: bool = true;
        // C s_59_20: cast zx s_59_19 -> bv
        let s_59_20: Bits = Bits::new(s_59_19 as u128, 1u16);
        // D s_59_21: cmp-ne s_59_18 s_59_20
        let s_59_21: bool = ((s_59_18) != (s_59_20));
        // D s_59_22: write-var gs#397506 <= s_59_21
        fn_state.gs_397506 = s_59_21;
        // N s_59_23: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_60<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_60_0: read-var gs#397506:u8
        let s_60_0: bool = fn_state.gs_397506;
        // N s_60_1: branch s_60_0 b86 b61
        if s_60_0 {
            return block_86(state, tracer, fn_state);
        } else {
            return block_61(state, tracer, fn_state);
        };
    }
    fn block_61<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_61_0: const #12s : i
        let s_61_0: i128 = 12;
        // D s_61_1: read-var u#30556:u32
        let s_61_1: u32 = fn_state.u_30556;
        // D s_61_2: cast zx s_61_1 -> bv
        let s_61_2: Bits = Bits::new(s_61_1 as u128, 32u16);
        // C s_61_3: const #1u : u64
        let s_61_3: u64 = 1;
        // D s_61_4: bit-extract s_61_2 s_61_0 s_61_3
        let s_61_4: Bits = (Bits::new(
            ((s_61_2) >> (s_61_0)).value(),
            u16::try_from(s_61_3).unwrap(),
        ));
        // D s_61_5: cast reint s_61_4 -> u8
        let s_61_5: bool = ((s_61_4.value()) != 0);
        // C s_61_6: const #0s : i
        let s_61_6: i128 = 0;
        // C s_61_7: const #0u : u64
        let s_61_7: u64 = 0;
        // D s_61_8: cast zx s_61_5 -> u64
        let s_61_8: u64 = (s_61_5 as u64);
        // C s_61_9: const #1u : u64
        let s_61_9: u64 = 1;
        // D s_61_10: and s_61_8 s_61_9
        let s_61_10: u64 = ((s_61_8) & (s_61_9));
        // D s_61_11: cmp-eq s_61_10 s_61_9
        let s_61_11: bool = ((s_61_10) == (s_61_9));
        // D s_61_12: lsl s_61_8 s_61_6
        let s_61_12: u64 = s_61_8 << s_61_6;
        // D s_61_13: or s_61_7 s_61_12
        let s_61_13: u64 = ((s_61_7) | (s_61_12));
        // D s_61_14: cmpl s_61_12
        let s_61_14: u64 = !s_61_12;
        // D s_61_15: and s_61_7 s_61_14
        let s_61_15: u64 = ((s_61_7) & (s_61_14));
        // D s_61_16: select s_61_11 s_61_13 s_61_15
        let s_61_16: u64 = if s_61_11 { s_61_13 } else { s_61_15 };
        // D s_61_17: cast trunc s_61_16 -> u8
        let s_61_17: bool = ((s_61_16) != 0);
        // D s_61_18: cast zx s_61_17 -> bv
        let s_61_18: Bits = Bits::new(s_61_17 as u128, 1u16);
        // C s_61_19: const #1u : u8
        let s_61_19: bool = true;
        // C s_61_20: cast zx s_61_19 -> bv
        let s_61_20: Bits = Bits::new(s_61_19 as u128, 1u16);
        // D s_61_21: cmp-ne s_61_18 s_61_20
        let s_61_21: bool = ((s_61_18) != (s_61_20));
        // D s_61_22: write-var gs#397509 <= s_61_21
        fn_state.gs_397509 = s_61_21;
        // N s_61_23: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_62<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_62_0: read-var gs#397509:u8
        let s_62_0: bool = fn_state.gs_397509;
        // N s_62_1: branch s_62_0 b85 b63
        if s_62_0 {
            return block_85(state, tracer, fn_state);
        } else {
            return block_63(state, tracer, fn_state);
        };
    }
    fn block_63<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_63_0: const #13s : i
        let s_63_0: i128 = 13;
        // D s_63_1: read-var u#30556:u32
        let s_63_1: u32 = fn_state.u_30556;
        // D s_63_2: cast zx s_63_1 -> bv
        let s_63_2: Bits = Bits::new(s_63_1 as u128, 32u16);
        // C s_63_3: const #1u : u64
        let s_63_3: u64 = 1;
        // D s_63_4: bit-extract s_63_2 s_63_0 s_63_3
        let s_63_4: Bits = (Bits::new(
            ((s_63_2) >> (s_63_0)).value(),
            u16::try_from(s_63_3).unwrap(),
        ));
        // D s_63_5: cast reint s_63_4 -> u8
        let s_63_5: bool = ((s_63_4.value()) != 0);
        // C s_63_6: const #0s : i
        let s_63_6: i128 = 0;
        // C s_63_7: const #0u : u64
        let s_63_7: u64 = 0;
        // D s_63_8: cast zx s_63_5 -> u64
        let s_63_8: u64 = (s_63_5 as u64);
        // C s_63_9: const #1u : u64
        let s_63_9: u64 = 1;
        // D s_63_10: and s_63_8 s_63_9
        let s_63_10: u64 = ((s_63_8) & (s_63_9));
        // D s_63_11: cmp-eq s_63_10 s_63_9
        let s_63_11: bool = ((s_63_10) == (s_63_9));
        // D s_63_12: lsl s_63_8 s_63_6
        let s_63_12: u64 = s_63_8 << s_63_6;
        // D s_63_13: or s_63_7 s_63_12
        let s_63_13: u64 = ((s_63_7) | (s_63_12));
        // D s_63_14: cmpl s_63_12
        let s_63_14: u64 = !s_63_12;
        // D s_63_15: and s_63_7 s_63_14
        let s_63_15: u64 = ((s_63_7) & (s_63_14));
        // D s_63_16: select s_63_11 s_63_13 s_63_15
        let s_63_16: u64 = if s_63_11 { s_63_13 } else { s_63_15 };
        // D s_63_17: cast trunc s_63_16 -> u8
        let s_63_17: bool = ((s_63_16) != 0);
        // D s_63_18: cast zx s_63_17 -> bv
        let s_63_18: Bits = Bits::new(s_63_17 as u128, 1u16);
        // C s_63_19: const #1u : u8
        let s_63_19: bool = true;
        // C s_63_20: cast zx s_63_19 -> bv
        let s_63_20: Bits = Bits::new(s_63_19 as u128, 1u16);
        // D s_63_21: cmp-ne s_63_18 s_63_20
        let s_63_21: bool = ((s_63_18) != (s_63_20));
        // D s_63_22: write-var gs#397512 <= s_63_21
        fn_state.gs_397512 = s_63_21;
        // N s_63_23: jump b64
        return block_64(state, tracer, fn_state);
    }
    fn block_64<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_64_0: read-var gs#397512:u8
        let s_64_0: bool = fn_state.gs_397512;
        // N s_64_1: branch s_64_0 b84 b65
        if s_64_0 {
            return block_84(state, tracer, fn_state);
        } else {
            return block_65(state, tracer, fn_state);
        };
    }
    fn block_65<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_65_0: const #14s : i
        let s_65_0: i128 = 14;
        // D s_65_1: read-var u#30556:u32
        let s_65_1: u32 = fn_state.u_30556;
        // D s_65_2: cast zx s_65_1 -> bv
        let s_65_2: Bits = Bits::new(s_65_1 as u128, 32u16);
        // C s_65_3: const #1u : u64
        let s_65_3: u64 = 1;
        // D s_65_4: bit-extract s_65_2 s_65_0 s_65_3
        let s_65_4: Bits = (Bits::new(
            ((s_65_2) >> (s_65_0)).value(),
            u16::try_from(s_65_3).unwrap(),
        ));
        // D s_65_5: cast reint s_65_4 -> u8
        let s_65_5: bool = ((s_65_4.value()) != 0);
        // C s_65_6: const #0s : i
        let s_65_6: i128 = 0;
        // C s_65_7: const #0u : u64
        let s_65_7: u64 = 0;
        // D s_65_8: cast zx s_65_5 -> u64
        let s_65_8: u64 = (s_65_5 as u64);
        // C s_65_9: const #1u : u64
        let s_65_9: u64 = 1;
        // D s_65_10: and s_65_8 s_65_9
        let s_65_10: u64 = ((s_65_8) & (s_65_9));
        // D s_65_11: cmp-eq s_65_10 s_65_9
        let s_65_11: bool = ((s_65_10) == (s_65_9));
        // D s_65_12: lsl s_65_8 s_65_6
        let s_65_12: u64 = s_65_8 << s_65_6;
        // D s_65_13: or s_65_7 s_65_12
        let s_65_13: u64 = ((s_65_7) | (s_65_12));
        // D s_65_14: cmpl s_65_12
        let s_65_14: u64 = !s_65_12;
        // D s_65_15: and s_65_7 s_65_14
        let s_65_15: u64 = ((s_65_7) & (s_65_14));
        // D s_65_16: select s_65_11 s_65_13 s_65_15
        let s_65_16: u64 = if s_65_11 { s_65_13 } else { s_65_15 };
        // D s_65_17: cast trunc s_65_16 -> u8
        let s_65_17: bool = ((s_65_16) != 0);
        // D s_65_18: cast zx s_65_17 -> bv
        let s_65_18: Bits = Bits::new(s_65_17 as u128, 1u16);
        // C s_65_19: const #1u : u8
        let s_65_19: bool = true;
        // C s_65_20: cast zx s_65_19 -> bv
        let s_65_20: Bits = Bits::new(s_65_19 as u128, 1u16);
        // D s_65_21: cmp-ne s_65_18 s_65_20
        let s_65_21: bool = ((s_65_18) != (s_65_20));
        // D s_65_22: write-var gs#397515 <= s_65_21
        fn_state.gs_397515 = s_65_21;
        // N s_65_23: jump b66
        return block_66(state, tracer, fn_state);
    }
    fn block_66<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_66_0: read-var gs#397515:u8
        let s_66_0: bool = fn_state.gs_397515;
        // N s_66_1: branch s_66_0 b83 b67
        if s_66_0 {
            return block_83(state, tracer, fn_state);
        } else {
            return block_67(state, tracer, fn_state);
        };
    }
    fn block_67<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_67_0: const #15s : i
        let s_67_0: i128 = 15;
        // D s_67_1: read-var u#30556:u32
        let s_67_1: u32 = fn_state.u_30556;
        // D s_67_2: cast zx s_67_1 -> bv
        let s_67_2: Bits = Bits::new(s_67_1 as u128, 32u16);
        // C s_67_3: const #1u : u64
        let s_67_3: u64 = 1;
        // D s_67_4: bit-extract s_67_2 s_67_0 s_67_3
        let s_67_4: Bits = (Bits::new(
            ((s_67_2) >> (s_67_0)).value(),
            u16::try_from(s_67_3).unwrap(),
        ));
        // D s_67_5: cast reint s_67_4 -> u8
        let s_67_5: bool = ((s_67_4.value()) != 0);
        // C s_67_6: const #0s : i
        let s_67_6: i128 = 0;
        // C s_67_7: const #0u : u64
        let s_67_7: u64 = 0;
        // D s_67_8: cast zx s_67_5 -> u64
        let s_67_8: u64 = (s_67_5 as u64);
        // C s_67_9: const #1u : u64
        let s_67_9: u64 = 1;
        // D s_67_10: and s_67_8 s_67_9
        let s_67_10: u64 = ((s_67_8) & (s_67_9));
        // D s_67_11: cmp-eq s_67_10 s_67_9
        let s_67_11: bool = ((s_67_10) == (s_67_9));
        // D s_67_12: lsl s_67_8 s_67_6
        let s_67_12: u64 = s_67_8 << s_67_6;
        // D s_67_13: or s_67_7 s_67_12
        let s_67_13: u64 = ((s_67_7) | (s_67_12));
        // D s_67_14: cmpl s_67_12
        let s_67_14: u64 = !s_67_12;
        // D s_67_15: and s_67_7 s_67_14
        let s_67_15: u64 = ((s_67_7) & (s_67_14));
        // D s_67_16: select s_67_11 s_67_13 s_67_15
        let s_67_16: u64 = if s_67_11 { s_67_13 } else { s_67_15 };
        // D s_67_17: cast trunc s_67_16 -> u8
        let s_67_17: bool = ((s_67_16) != 0);
        // D s_67_18: cast zx s_67_17 -> bv
        let s_67_18: Bits = Bits::new(s_67_17 as u128, 1u16);
        // C s_67_19: const #1u : u8
        let s_67_19: bool = true;
        // C s_67_20: cast zx s_67_19 -> bv
        let s_67_20: Bits = Bits::new(s_67_19 as u128, 1u16);
        // D s_67_21: cmp-ne s_67_18 s_67_20
        let s_67_21: bool = ((s_67_18) != (s_67_20));
        // D s_67_22: write-var gs#397518 <= s_67_21
        fn_state.gs_397518 = s_67_21;
        // N s_67_23: jump b68
        return block_68(state, tracer, fn_state);
    }
    fn block_68<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_68_0: read-var gs#397518:u8
        let s_68_0: bool = fn_state.gs_397518;
        // N s_68_1: branch s_68_0 b82 b69
        if s_68_0 {
            return block_82(state, tracer, fn_state);
        } else {
            return block_69(state, tracer, fn_state);
        };
    }
    fn block_69<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_69_0: const #8s : i
        let s_69_0: i128 = 8;
        // D s_69_1: read-var u#30556:u32
        let s_69_1: u32 = fn_state.u_30556;
        // D s_69_2: cast zx s_69_1 -> bv
        let s_69_2: Bits = Bits::new(s_69_1 as u128, 32u16);
        // C s_69_3: const #1u : u64
        let s_69_3: u64 = 1;
        // D s_69_4: bit-extract s_69_2 s_69_0 s_69_3
        let s_69_4: Bits = (Bits::new(
            ((s_69_2) >> (s_69_0)).value(),
            u16::try_from(s_69_3).unwrap(),
        ));
        // D s_69_5: cast reint s_69_4 -> u8
        let s_69_5: bool = ((s_69_4.value()) != 0);
        // C s_69_6: const #0s : i
        let s_69_6: i128 = 0;
        // C s_69_7: const #0u : u64
        let s_69_7: u64 = 0;
        // D s_69_8: cast zx s_69_5 -> u64
        let s_69_8: u64 = (s_69_5 as u64);
        // C s_69_9: const #1u : u64
        let s_69_9: u64 = 1;
        // D s_69_10: and s_69_8 s_69_9
        let s_69_10: u64 = ((s_69_8) & (s_69_9));
        // D s_69_11: cmp-eq s_69_10 s_69_9
        let s_69_11: bool = ((s_69_10) == (s_69_9));
        // D s_69_12: lsl s_69_8 s_69_6
        let s_69_12: u64 = s_69_8 << s_69_6;
        // D s_69_13: or s_69_7 s_69_12
        let s_69_13: u64 = ((s_69_7) | (s_69_12));
        // D s_69_14: cmpl s_69_12
        let s_69_14: u64 = !s_69_12;
        // D s_69_15: and s_69_7 s_69_14
        let s_69_15: u64 = ((s_69_7) & (s_69_14));
        // D s_69_16: select s_69_11 s_69_13 s_69_15
        let s_69_16: u64 = if s_69_11 { s_69_13 } else { s_69_15 };
        // D s_69_17: cast trunc s_69_16 -> u8
        let s_69_17: bool = ((s_69_16) != 0);
        // D s_69_18: cast zx s_69_17 -> bv
        let s_69_18: Bits = Bits::new(s_69_17 as u128, 1u16);
        // C s_69_19: const #0u : u8
        let s_69_19: bool = false;
        // C s_69_20: cast zx s_69_19 -> bv
        let s_69_20: Bits = Bits::new(s_69_19 as u128, 1u16);
        // D s_69_21: cmp-ne s_69_18 s_69_20
        let s_69_21: bool = ((s_69_18) != (s_69_20));
        // D s_69_22: write-var gs#397521 <= s_69_21
        fn_state.gs_397521 = s_69_21;
        // N s_69_23: jump b70
        return block_70(state, tracer, fn_state);
    }
    fn block_70<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_70_0: read-var gs#397521:u8
        let s_70_0: bool = fn_state.gs_397521;
        // N s_70_1: branch s_70_0 b81 b71
        if s_70_0 {
            return block_81(state, tracer, fn_state);
        } else {
            return block_71(state, tracer, fn_state);
        };
    }
    fn block_71<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_71_0: const #9s : i
        let s_71_0: i128 = 9;
        // D s_71_1: read-var u#30556:u32
        let s_71_1: u32 = fn_state.u_30556;
        // D s_71_2: cast zx s_71_1 -> bv
        let s_71_2: Bits = Bits::new(s_71_1 as u128, 32u16);
        // C s_71_3: const #1u : u64
        let s_71_3: u64 = 1;
        // D s_71_4: bit-extract s_71_2 s_71_0 s_71_3
        let s_71_4: Bits = (Bits::new(
            ((s_71_2) >> (s_71_0)).value(),
            u16::try_from(s_71_3).unwrap(),
        ));
        // D s_71_5: cast reint s_71_4 -> u8
        let s_71_5: bool = ((s_71_4.value()) != 0);
        // C s_71_6: const #0s : i
        let s_71_6: i128 = 0;
        // C s_71_7: const #0u : u64
        let s_71_7: u64 = 0;
        // D s_71_8: cast zx s_71_5 -> u64
        let s_71_8: u64 = (s_71_5 as u64);
        // C s_71_9: const #1u : u64
        let s_71_9: u64 = 1;
        // D s_71_10: and s_71_8 s_71_9
        let s_71_10: u64 = ((s_71_8) & (s_71_9));
        // D s_71_11: cmp-eq s_71_10 s_71_9
        let s_71_11: bool = ((s_71_10) == (s_71_9));
        // D s_71_12: lsl s_71_8 s_71_6
        let s_71_12: u64 = s_71_8 << s_71_6;
        // D s_71_13: or s_71_7 s_71_12
        let s_71_13: u64 = ((s_71_7) | (s_71_12));
        // D s_71_14: cmpl s_71_12
        let s_71_14: u64 = !s_71_12;
        // D s_71_15: and s_71_7 s_71_14
        let s_71_15: u64 = ((s_71_7) & (s_71_14));
        // D s_71_16: select s_71_11 s_71_13 s_71_15
        let s_71_16: u64 = if s_71_11 { s_71_13 } else { s_71_15 };
        // D s_71_17: cast trunc s_71_16 -> u8
        let s_71_17: bool = ((s_71_16) != 0);
        // D s_71_18: cast zx s_71_17 -> bv
        let s_71_18: Bits = Bits::new(s_71_17 as u128, 1u16);
        // C s_71_19: const #0u : u8
        let s_71_19: bool = false;
        // C s_71_20: cast zx s_71_19 -> bv
        let s_71_20: Bits = Bits::new(s_71_19 as u128, 1u16);
        // D s_71_21: cmp-ne s_71_18 s_71_20
        let s_71_21: bool = ((s_71_18) != (s_71_20));
        // D s_71_22: write-var gs#397524 <= s_71_21
        fn_state.gs_397524 = s_71_21;
        // N s_71_23: jump b72
        return block_72(state, tracer, fn_state);
    }
    fn block_72<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_72_0: read-var gs#397524:u8
        let s_72_0: bool = fn_state.gs_397524;
        // N s_72_1: branch s_72_0 b80 b73
        if s_72_0 {
            return block_80(state, tracer, fn_state);
        } else {
            return block_73(state, tracer, fn_state);
        };
    }
    fn block_73<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_73_0: const #10s : i
        let s_73_0: i128 = 10;
        // D s_73_1: read-var u#30556:u32
        let s_73_1: u32 = fn_state.u_30556;
        // D s_73_2: cast zx s_73_1 -> bv
        let s_73_2: Bits = Bits::new(s_73_1 as u128, 32u16);
        // C s_73_3: const #1u : u64
        let s_73_3: u64 = 1;
        // D s_73_4: bit-extract s_73_2 s_73_0 s_73_3
        let s_73_4: Bits = (Bits::new(
            ((s_73_2) >> (s_73_0)).value(),
            u16::try_from(s_73_3).unwrap(),
        ));
        // D s_73_5: cast reint s_73_4 -> u8
        let s_73_5: bool = ((s_73_4.value()) != 0);
        // C s_73_6: const #0s : i
        let s_73_6: i128 = 0;
        // C s_73_7: const #0u : u64
        let s_73_7: u64 = 0;
        // D s_73_8: cast zx s_73_5 -> u64
        let s_73_8: u64 = (s_73_5 as u64);
        // C s_73_9: const #1u : u64
        let s_73_9: u64 = 1;
        // D s_73_10: and s_73_8 s_73_9
        let s_73_10: u64 = ((s_73_8) & (s_73_9));
        // D s_73_11: cmp-eq s_73_10 s_73_9
        let s_73_11: bool = ((s_73_10) == (s_73_9));
        // D s_73_12: lsl s_73_8 s_73_6
        let s_73_12: u64 = s_73_8 << s_73_6;
        // D s_73_13: or s_73_7 s_73_12
        let s_73_13: u64 = ((s_73_7) | (s_73_12));
        // D s_73_14: cmpl s_73_12
        let s_73_14: u64 = !s_73_12;
        // D s_73_15: and s_73_7 s_73_14
        let s_73_15: u64 = ((s_73_7) & (s_73_14));
        // D s_73_16: select s_73_11 s_73_13 s_73_15
        let s_73_16: u64 = if s_73_11 { s_73_13 } else { s_73_15 };
        // D s_73_17: cast trunc s_73_16 -> u8
        let s_73_17: bool = ((s_73_16) != 0);
        // D s_73_18: cast zx s_73_17 -> bv
        let s_73_18: Bits = Bits::new(s_73_17 as u128, 1u16);
        // C s_73_19: const #0u : u8
        let s_73_19: bool = false;
        // C s_73_20: cast zx s_73_19 -> bv
        let s_73_20: Bits = Bits::new(s_73_19 as u128, 1u16);
        // D s_73_21: cmp-ne s_73_18 s_73_20
        let s_73_21: bool = ((s_73_18) != (s_73_20));
        // D s_73_22: write-var gs#397527 <= s_73_21
        fn_state.gs_397527 = s_73_21;
        // N s_73_23: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_74<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_74_0: read-var gs#397527:u8
        let s_74_0: bool = fn_state.gs_397527;
        // N s_74_1: branch s_74_0 b79 b75
        if s_74_0 {
            return block_79(state, tracer, fn_state);
        } else {
            return block_75(state, tracer, fn_state);
        };
    }
    fn block_75<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_75_0: const #11s : i
        let s_75_0: i128 = 11;
        // D s_75_1: read-var u#30556:u32
        let s_75_1: u32 = fn_state.u_30556;
        // D s_75_2: cast zx s_75_1 -> bv
        let s_75_2: Bits = Bits::new(s_75_1 as u128, 32u16);
        // C s_75_3: const #1u : u64
        let s_75_3: u64 = 1;
        // D s_75_4: bit-extract s_75_2 s_75_0 s_75_3
        let s_75_4: Bits = (Bits::new(
            ((s_75_2) >> (s_75_0)).value(),
            u16::try_from(s_75_3).unwrap(),
        ));
        // D s_75_5: cast reint s_75_4 -> u8
        let s_75_5: bool = ((s_75_4.value()) != 0);
        // C s_75_6: const #0s : i
        let s_75_6: i128 = 0;
        // C s_75_7: const #0u : u64
        let s_75_7: u64 = 0;
        // D s_75_8: cast zx s_75_5 -> u64
        let s_75_8: u64 = (s_75_5 as u64);
        // C s_75_9: const #1u : u64
        let s_75_9: u64 = 1;
        // D s_75_10: and s_75_8 s_75_9
        let s_75_10: u64 = ((s_75_8) & (s_75_9));
        // D s_75_11: cmp-eq s_75_10 s_75_9
        let s_75_11: bool = ((s_75_10) == (s_75_9));
        // D s_75_12: lsl s_75_8 s_75_6
        let s_75_12: u64 = s_75_8 << s_75_6;
        // D s_75_13: or s_75_7 s_75_12
        let s_75_13: u64 = ((s_75_7) | (s_75_12));
        // D s_75_14: cmpl s_75_12
        let s_75_14: u64 = !s_75_12;
        // D s_75_15: and s_75_7 s_75_14
        let s_75_15: u64 = ((s_75_7) & (s_75_14));
        // D s_75_16: select s_75_11 s_75_13 s_75_15
        let s_75_16: u64 = if s_75_11 { s_75_13 } else { s_75_15 };
        // D s_75_17: cast trunc s_75_16 -> u8
        let s_75_17: bool = ((s_75_16) != 0);
        // D s_75_18: cast zx s_75_17 -> bv
        let s_75_18: Bits = Bits::new(s_75_17 as u128, 1u16);
        // C s_75_19: const #0u : u8
        let s_75_19: bool = false;
        // C s_75_20: cast zx s_75_19 -> bv
        let s_75_20: Bits = Bits::new(s_75_19 as u128, 1u16);
        // D s_75_21: cmp-ne s_75_18 s_75_20
        let s_75_21: bool = ((s_75_18) != (s_75_20));
        // D s_75_22: write-var gs#397530 <= s_75_21
        fn_state.gs_397530 = s_75_21;
        // N s_75_23: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_76<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_76_0: read-var gs#397530:u8
        let s_76_0: bool = fn_state.gs_397530;
        // N s_76_1: branch s_76_0 b78 b77
        if s_76_0 {
            return block_78(state, tracer, fn_state);
        } else {
            return block_77(state, tracer, fn_state);
        };
    }
    fn block_77<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_77_0: read-var option_name:u8
        let s_77_0: u8 = fn_state.option_name;
        // D s_77_1: call decode_aarch32_instrs_DMB_A1enc_A_txt(s_77_0)
        let s_77_1: () = decode_aarch32_instrs_DMB_A1enc_A_txt(state, tracer, s_77_0);
        // N s_77_2: return
        return;
    }
    fn block_78<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_78_0: panic
        panic!("{:?}", ());
        // N s_78_1: return
        return;
    }
    fn block_79<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_79_0: const #1u : u8
        let s_79_0: bool = true;
        // D s_79_1: write-var gs#397530 <= s_79_0
        fn_state.gs_397530 = s_79_0;
        // N s_79_2: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_80<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_80_0: const #1u : u8
        let s_80_0: bool = true;
        // D s_80_1: write-var gs#397527 <= s_80_0
        fn_state.gs_397527 = s_80_0;
        // N s_80_2: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_81<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_81_0: const #1u : u8
        let s_81_0: bool = true;
        // D s_81_1: write-var gs#397524 <= s_81_0
        fn_state.gs_397524 = s_81_0;
        // N s_81_2: jump b72
        return block_72(state, tracer, fn_state);
    }
    fn block_82<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_82_0: const #1u : u8
        let s_82_0: bool = true;
        // D s_82_1: write-var gs#397521 <= s_82_0
        fn_state.gs_397521 = s_82_0;
        // N s_82_2: jump b70
        return block_70(state, tracer, fn_state);
    }
    fn block_83<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_83_0: const #1u : u8
        let s_83_0: bool = true;
        // D s_83_1: write-var gs#397518 <= s_83_0
        fn_state.gs_397518 = s_83_0;
        // N s_83_2: jump b68
        return block_68(state, tracer, fn_state);
    }
    fn block_84<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_84_0: const #1u : u8
        let s_84_0: bool = true;
        // D s_84_1: write-var gs#397515 <= s_84_0
        fn_state.gs_397515 = s_84_0;
        // N s_84_2: jump b66
        return block_66(state, tracer, fn_state);
    }
    fn block_85<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_85_0: const #1u : u8
        let s_85_0: bool = true;
        // D s_85_1: write-var gs#397512 <= s_85_0
        fn_state.gs_397512 = s_85_0;
        // N s_85_2: jump b64
        return block_64(state, tracer, fn_state);
    }
    fn block_86<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_86_0: const #1u : u8
        let s_86_0: bool = true;
        // D s_86_1: write-var gs#397509 <= s_86_0
        fn_state.gs_397509 = s_86_0;
        // N s_86_2: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_87<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_87_0: const #1u : u8
        let s_87_0: bool = true;
        // D s_87_1: write-var gs#397506 <= s_87_0
        fn_state.gs_397506 = s_87_0;
        // N s_87_2: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_88<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_88_0: const #1u : u8
        let s_88_0: bool = true;
        // D s_88_1: write-var gs#397503 <= s_88_0
        fn_state.gs_397503 = s_88_0;
        // N s_88_2: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_89<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_89_0: const #1u : u8
        let s_89_0: bool = true;
        // D s_89_1: write-var gs#397500 <= s_89_0
        fn_state.gs_397500 = s_89_0;
        // N s_89_2: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_90<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_90_0: read-var merge#var.1:struct
        let s_90_0: u32 = fn_state.merge_var._1;
        // D s_90_1: write-var u#30558 <= s_90_0
        fn_state.u_30558 = s_90_0;
        // C s_90_2: const #4s : i
        let s_90_2: i128 = 4;
        // D s_90_3: read-var u#30558:u32
        let s_90_3: u32 = fn_state.u_30558;
        // D s_90_4: cast zx s_90_3 -> bv
        let s_90_4: Bits = Bits::new(s_90_3 as u128, 32u16);
        // C s_90_5: const #1s : i64
        let s_90_5: i64 = 1;
        // C s_90_6: cast zx s_90_5 -> i
        let s_90_6: i128 = (i128::try_from(s_90_5).unwrap());
        // C s_90_7: const #27s : i
        let s_90_7: i128 = 27;
        // C s_90_8: add s_90_7 s_90_6
        let s_90_8: i128 = (s_90_7 + s_90_6);
        // D s_90_9: bit-extract s_90_4 s_90_2 s_90_8
        let s_90_9: Bits = (Bits::new(
            ((s_90_4) >> (s_90_2)).value(),
            u16::try_from(s_90_8).unwrap(),
        ));
        // D s_90_10: cast reint s_90_9 -> u28
        let s_90_10: u32 = (s_90_9.value() as u32);
        // D s_90_11: cast zx s_90_10 -> bv
        let s_90_11: Bits = Bits::new(s_90_10 as u128, 28u16);
        // C s_90_12: const #257425156u : u28
        let s_90_12: u32 = 257425156;
        // C s_90_13: cast zx s_90_12 -> bv
        let s_90_13: Bits = Bits::new(s_90_12 as u128, 28u16);
        // D s_90_14: cmp-eq s_90_11 s_90_13
        let s_90_14: bool = ((s_90_11) == (s_90_13));
        // N s_90_15: branch s_90_14 b3223 b91
        if s_90_14 {
            return block_3223(state, tracer, fn_state);
        } else {
            return block_91(state, tracer, fn_state);
        };
    }
    fn block_91<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_91_0: const #0u : u8
        let s_91_0: bool = false;
        // D s_91_1: write-var gs#397535 <= s_91_0
        fn_state.gs_397535 = s_91_0;
        // N s_91_2: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_92<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_92_0: read-var gs#397535:u8
        let s_92_0: bool = fn_state.gs_397535;
        // D s_92_1: not s_92_0
        let s_92_1: bool = !s_92_0;
        // N s_92_2: branch s_92_1 b129 b93
        if s_92_1 {
            return block_129(state, tracer, fn_state);
        } else {
            return block_93(state, tracer, fn_state);
        };
    }
    fn block_93<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_93_0: const #2901s : i
        let s_93_0: i128 = 2901;
        // C s_93_1: const #14696u : u32
        let s_93_1: u32 = 14696;
        // N s_93_2: write-reg s_93_1 <= s_93_0
        let s_93_2: () = {
            state.write_register::<i128>(s_93_1 as isize, s_93_0);
            tracer.write_register(s_93_1 as isize, s_93_0);
        };
        // C s_93_3: const #0s : i
        let s_93_3: i128 = 0;
        // C s_93_4: const #4s : i
        let s_93_4: i128 = 4;
        // D s_93_5: read-var u#30558:u32
        let s_93_5: u32 = fn_state.u_30558;
        // D s_93_6: cast zx s_93_5 -> bv
        let s_93_6: Bits = Bits::new(s_93_5 as u128, 32u16);
        // D s_93_7: bit-extract s_93_6 s_93_3 s_93_4
        let s_93_7: Bits = (Bits::new(
            ((s_93_6) >> (s_93_3)).value(),
            u16::try_from(s_93_4).unwrap(),
        ));
        // D s_93_8: cast reint s_93_7 -> u8
        let s_93_8: u8 = (s_93_7.value() as u8);
        // D s_93_9: write-var u#30559 <= s_93_8
        fn_state.u_30559 = s_93_8;
        // C s_93_10: const #16s : i
        let s_93_10: i128 = 16;
        // D s_93_11: read-var u#30558:u32
        let s_93_11: u32 = fn_state.u_30558;
        // D s_93_12: cast zx s_93_11 -> bv
        let s_93_12: Bits = Bits::new(s_93_11 as u128, 32u16);
        // C s_93_13: const #1u : u64
        let s_93_13: u64 = 1;
        // D s_93_14: bit-extract s_93_12 s_93_10 s_93_13
        let s_93_14: Bits = (Bits::new(
            ((s_93_12) >> (s_93_10)).value(),
            u16::try_from(s_93_13).unwrap(),
        ));
        // D s_93_15: cast reint s_93_14 -> u8
        let s_93_15: bool = ((s_93_14.value()) != 0);
        // C s_93_16: const #0s : i
        let s_93_16: i128 = 0;
        // C s_93_17: const #0u : u64
        let s_93_17: u64 = 0;
        // D s_93_18: cast zx s_93_15 -> u64
        let s_93_18: u64 = (s_93_15 as u64);
        // C s_93_19: const #1u : u64
        let s_93_19: u64 = 1;
        // D s_93_20: and s_93_18 s_93_19
        let s_93_20: u64 = ((s_93_18) & (s_93_19));
        // D s_93_21: cmp-eq s_93_20 s_93_19
        let s_93_21: bool = ((s_93_20) == (s_93_19));
        // D s_93_22: lsl s_93_18 s_93_16
        let s_93_22: u64 = s_93_18 << s_93_16;
        // D s_93_23: or s_93_17 s_93_22
        let s_93_23: u64 = ((s_93_17) | (s_93_22));
        // D s_93_24: cmpl s_93_22
        let s_93_24: u64 = !s_93_22;
        // D s_93_25: and s_93_17 s_93_24
        let s_93_25: u64 = ((s_93_17) & (s_93_24));
        // D s_93_26: select s_93_21 s_93_23 s_93_25
        let s_93_26: u64 = if s_93_21 { s_93_23 } else { s_93_25 };
        // D s_93_27: cast trunc s_93_26 -> u8
        let s_93_27: bool = ((s_93_26) != 0);
        // D s_93_28: cast zx s_93_27 -> bv
        let s_93_28: Bits = Bits::new(s_93_27 as u128, 1u16);
        // C s_93_29: const #1u : u8
        let s_93_29: bool = true;
        // C s_93_30: cast zx s_93_29 -> bv
        let s_93_30: Bits = Bits::new(s_93_29 as u128, 1u16);
        // D s_93_31: cmp-ne s_93_28 s_93_30
        let s_93_31: bool = ((s_93_28) != (s_93_30));
        // N s_93_32: branch s_93_31 b128 b94
        if s_93_31 {
            return block_128(state, tracer, fn_state);
        } else {
            return block_94(state, tracer, fn_state);
        };
    }
    fn block_94<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_94_0: const #17s : i
        let s_94_0: i128 = 17;
        // D s_94_1: read-var u#30558:u32
        let s_94_1: u32 = fn_state.u_30558;
        // D s_94_2: cast zx s_94_1 -> bv
        let s_94_2: Bits = Bits::new(s_94_1 as u128, 32u16);
        // C s_94_3: const #1u : u64
        let s_94_3: u64 = 1;
        // D s_94_4: bit-extract s_94_2 s_94_0 s_94_3
        let s_94_4: Bits = (Bits::new(
            ((s_94_2) >> (s_94_0)).value(),
            u16::try_from(s_94_3).unwrap(),
        ));
        // D s_94_5: cast reint s_94_4 -> u8
        let s_94_5: bool = ((s_94_4.value()) != 0);
        // C s_94_6: const #0s : i
        let s_94_6: i128 = 0;
        // C s_94_7: const #0u : u64
        let s_94_7: u64 = 0;
        // D s_94_8: cast zx s_94_5 -> u64
        let s_94_8: u64 = (s_94_5 as u64);
        // C s_94_9: const #1u : u64
        let s_94_9: u64 = 1;
        // D s_94_10: and s_94_8 s_94_9
        let s_94_10: u64 = ((s_94_8) & (s_94_9));
        // D s_94_11: cmp-eq s_94_10 s_94_9
        let s_94_11: bool = ((s_94_10) == (s_94_9));
        // D s_94_12: lsl s_94_8 s_94_6
        let s_94_12: u64 = s_94_8 << s_94_6;
        // D s_94_13: or s_94_7 s_94_12
        let s_94_13: u64 = ((s_94_7) | (s_94_12));
        // D s_94_14: cmpl s_94_12
        let s_94_14: u64 = !s_94_12;
        // D s_94_15: and s_94_7 s_94_14
        let s_94_15: u64 = ((s_94_7) & (s_94_14));
        // D s_94_16: select s_94_11 s_94_13 s_94_15
        let s_94_16: u64 = if s_94_11 { s_94_13 } else { s_94_15 };
        // D s_94_17: cast trunc s_94_16 -> u8
        let s_94_17: bool = ((s_94_16) != 0);
        // D s_94_18: cast zx s_94_17 -> bv
        let s_94_18: Bits = Bits::new(s_94_17 as u128, 1u16);
        // C s_94_19: const #1u : u8
        let s_94_19: bool = true;
        // C s_94_20: cast zx s_94_19 -> bv
        let s_94_20: Bits = Bits::new(s_94_19 as u128, 1u16);
        // D s_94_21: cmp-ne s_94_18 s_94_20
        let s_94_21: bool = ((s_94_18) != (s_94_20));
        // D s_94_22: write-var gs#397544 <= s_94_21
        fn_state.gs_397544 = s_94_21;
        // N s_94_23: jump b95
        return block_95(state, tracer, fn_state);
    }
    fn block_95<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_95_0: read-var gs#397544:u8
        let s_95_0: bool = fn_state.gs_397544;
        // N s_95_1: branch s_95_0 b127 b96
        if s_95_0 {
            return block_127(state, tracer, fn_state);
        } else {
            return block_96(state, tracer, fn_state);
        };
    }
    fn block_96<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_96_0: const #18s : i
        let s_96_0: i128 = 18;
        // D s_96_1: read-var u#30558:u32
        let s_96_1: u32 = fn_state.u_30558;
        // D s_96_2: cast zx s_96_1 -> bv
        let s_96_2: Bits = Bits::new(s_96_1 as u128, 32u16);
        // C s_96_3: const #1u : u64
        let s_96_3: u64 = 1;
        // D s_96_4: bit-extract s_96_2 s_96_0 s_96_3
        let s_96_4: Bits = (Bits::new(
            ((s_96_2) >> (s_96_0)).value(),
            u16::try_from(s_96_3).unwrap(),
        ));
        // D s_96_5: cast reint s_96_4 -> u8
        let s_96_5: bool = ((s_96_4.value()) != 0);
        // C s_96_6: const #0s : i
        let s_96_6: i128 = 0;
        // C s_96_7: const #0u : u64
        let s_96_7: u64 = 0;
        // D s_96_8: cast zx s_96_5 -> u64
        let s_96_8: u64 = (s_96_5 as u64);
        // C s_96_9: const #1u : u64
        let s_96_9: u64 = 1;
        // D s_96_10: and s_96_8 s_96_9
        let s_96_10: u64 = ((s_96_8) & (s_96_9));
        // D s_96_11: cmp-eq s_96_10 s_96_9
        let s_96_11: bool = ((s_96_10) == (s_96_9));
        // D s_96_12: lsl s_96_8 s_96_6
        let s_96_12: u64 = s_96_8 << s_96_6;
        // D s_96_13: or s_96_7 s_96_12
        let s_96_13: u64 = ((s_96_7) | (s_96_12));
        // D s_96_14: cmpl s_96_12
        let s_96_14: u64 = !s_96_12;
        // D s_96_15: and s_96_7 s_96_14
        let s_96_15: u64 = ((s_96_7) & (s_96_14));
        // D s_96_16: select s_96_11 s_96_13 s_96_15
        let s_96_16: u64 = if s_96_11 { s_96_13 } else { s_96_15 };
        // D s_96_17: cast trunc s_96_16 -> u8
        let s_96_17: bool = ((s_96_16) != 0);
        // D s_96_18: cast zx s_96_17 -> bv
        let s_96_18: Bits = Bits::new(s_96_17 as u128, 1u16);
        // C s_96_19: const #1u : u8
        let s_96_19: bool = true;
        // C s_96_20: cast zx s_96_19 -> bv
        let s_96_20: Bits = Bits::new(s_96_19 as u128, 1u16);
        // D s_96_21: cmp-ne s_96_18 s_96_20
        let s_96_21: bool = ((s_96_18) != (s_96_20));
        // D s_96_22: write-var gs#397547 <= s_96_21
        fn_state.gs_397547 = s_96_21;
        // N s_96_23: jump b97
        return block_97(state, tracer, fn_state);
    }
    fn block_97<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_97_0: read-var gs#397547:u8
        let s_97_0: bool = fn_state.gs_397547;
        // N s_97_1: branch s_97_0 b126 b98
        if s_97_0 {
            return block_126(state, tracer, fn_state);
        } else {
            return block_98(state, tracer, fn_state);
        };
    }
    fn block_98<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_98_0: const #19s : i
        let s_98_0: i128 = 19;
        // D s_98_1: read-var u#30558:u32
        let s_98_1: u32 = fn_state.u_30558;
        // D s_98_2: cast zx s_98_1 -> bv
        let s_98_2: Bits = Bits::new(s_98_1 as u128, 32u16);
        // C s_98_3: const #1u : u64
        let s_98_3: u64 = 1;
        // D s_98_4: bit-extract s_98_2 s_98_0 s_98_3
        let s_98_4: Bits = (Bits::new(
            ((s_98_2) >> (s_98_0)).value(),
            u16::try_from(s_98_3).unwrap(),
        ));
        // D s_98_5: cast reint s_98_4 -> u8
        let s_98_5: bool = ((s_98_4.value()) != 0);
        // C s_98_6: const #0s : i
        let s_98_6: i128 = 0;
        // C s_98_7: const #0u : u64
        let s_98_7: u64 = 0;
        // D s_98_8: cast zx s_98_5 -> u64
        let s_98_8: u64 = (s_98_5 as u64);
        // C s_98_9: const #1u : u64
        let s_98_9: u64 = 1;
        // D s_98_10: and s_98_8 s_98_9
        let s_98_10: u64 = ((s_98_8) & (s_98_9));
        // D s_98_11: cmp-eq s_98_10 s_98_9
        let s_98_11: bool = ((s_98_10) == (s_98_9));
        // D s_98_12: lsl s_98_8 s_98_6
        let s_98_12: u64 = s_98_8 << s_98_6;
        // D s_98_13: or s_98_7 s_98_12
        let s_98_13: u64 = ((s_98_7) | (s_98_12));
        // D s_98_14: cmpl s_98_12
        let s_98_14: u64 = !s_98_12;
        // D s_98_15: and s_98_7 s_98_14
        let s_98_15: u64 = ((s_98_7) & (s_98_14));
        // D s_98_16: select s_98_11 s_98_13 s_98_15
        let s_98_16: u64 = if s_98_11 { s_98_13 } else { s_98_15 };
        // D s_98_17: cast trunc s_98_16 -> u8
        let s_98_17: bool = ((s_98_16) != 0);
        // D s_98_18: cast zx s_98_17 -> bv
        let s_98_18: Bits = Bits::new(s_98_17 as u128, 1u16);
        // C s_98_19: const #1u : u8
        let s_98_19: bool = true;
        // C s_98_20: cast zx s_98_19 -> bv
        let s_98_20: Bits = Bits::new(s_98_19 as u128, 1u16);
        // D s_98_21: cmp-ne s_98_18 s_98_20
        let s_98_21: bool = ((s_98_18) != (s_98_20));
        // D s_98_22: write-var gs#397550 <= s_98_21
        fn_state.gs_397550 = s_98_21;
        // N s_98_23: jump b99
        return block_99(state, tracer, fn_state);
    }
    fn block_99<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_99_0: read-var gs#397550:u8
        let s_99_0: bool = fn_state.gs_397550;
        // N s_99_1: branch s_99_0 b125 b100
        if s_99_0 {
            return block_125(state, tracer, fn_state);
        } else {
            return block_100(state, tracer, fn_state);
        };
    }
    fn block_100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_100_0: const #12s : i
        let s_100_0: i128 = 12;
        // D s_100_1: read-var u#30558:u32
        let s_100_1: u32 = fn_state.u_30558;
        // D s_100_2: cast zx s_100_1 -> bv
        let s_100_2: Bits = Bits::new(s_100_1 as u128, 32u16);
        // C s_100_3: const #1u : u64
        let s_100_3: u64 = 1;
        // D s_100_4: bit-extract s_100_2 s_100_0 s_100_3
        let s_100_4: Bits = (Bits::new(
            ((s_100_2) >> (s_100_0)).value(),
            u16::try_from(s_100_3).unwrap(),
        ));
        // D s_100_5: cast reint s_100_4 -> u8
        let s_100_5: bool = ((s_100_4.value()) != 0);
        // C s_100_6: const #0s : i
        let s_100_6: i128 = 0;
        // C s_100_7: const #0u : u64
        let s_100_7: u64 = 0;
        // D s_100_8: cast zx s_100_5 -> u64
        let s_100_8: u64 = (s_100_5 as u64);
        // C s_100_9: const #1u : u64
        let s_100_9: u64 = 1;
        // D s_100_10: and s_100_8 s_100_9
        let s_100_10: u64 = ((s_100_8) & (s_100_9));
        // D s_100_11: cmp-eq s_100_10 s_100_9
        let s_100_11: bool = ((s_100_10) == (s_100_9));
        // D s_100_12: lsl s_100_8 s_100_6
        let s_100_12: u64 = s_100_8 << s_100_6;
        // D s_100_13: or s_100_7 s_100_12
        let s_100_13: u64 = ((s_100_7) | (s_100_12));
        // D s_100_14: cmpl s_100_12
        let s_100_14: u64 = !s_100_12;
        // D s_100_15: and s_100_7 s_100_14
        let s_100_15: u64 = ((s_100_7) & (s_100_14));
        // D s_100_16: select s_100_11 s_100_13 s_100_15
        let s_100_16: u64 = if s_100_11 { s_100_13 } else { s_100_15 };
        // D s_100_17: cast trunc s_100_16 -> u8
        let s_100_17: bool = ((s_100_16) != 0);
        // D s_100_18: cast zx s_100_17 -> bv
        let s_100_18: Bits = Bits::new(s_100_17 as u128, 1u16);
        // C s_100_19: const #1u : u8
        let s_100_19: bool = true;
        // C s_100_20: cast zx s_100_19 -> bv
        let s_100_20: Bits = Bits::new(s_100_19 as u128, 1u16);
        // D s_100_21: cmp-ne s_100_18 s_100_20
        let s_100_21: bool = ((s_100_18) != (s_100_20));
        // D s_100_22: write-var gs#397553 <= s_100_21
        fn_state.gs_397553 = s_100_21;
        // N s_100_23: jump b101
        return block_101(state, tracer, fn_state);
    }
    fn block_101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_101_0: read-var gs#397553:u8
        let s_101_0: bool = fn_state.gs_397553;
        // N s_101_1: branch s_101_0 b124 b102
        if s_101_0 {
            return block_124(state, tracer, fn_state);
        } else {
            return block_102(state, tracer, fn_state);
        };
    }
    fn block_102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_102_0: const #13s : i
        let s_102_0: i128 = 13;
        // D s_102_1: read-var u#30558:u32
        let s_102_1: u32 = fn_state.u_30558;
        // D s_102_2: cast zx s_102_1 -> bv
        let s_102_2: Bits = Bits::new(s_102_1 as u128, 32u16);
        // C s_102_3: const #1u : u64
        let s_102_3: u64 = 1;
        // D s_102_4: bit-extract s_102_2 s_102_0 s_102_3
        let s_102_4: Bits = (Bits::new(
            ((s_102_2) >> (s_102_0)).value(),
            u16::try_from(s_102_3).unwrap(),
        ));
        // D s_102_5: cast reint s_102_4 -> u8
        let s_102_5: bool = ((s_102_4.value()) != 0);
        // C s_102_6: const #0s : i
        let s_102_6: i128 = 0;
        // C s_102_7: const #0u : u64
        let s_102_7: u64 = 0;
        // D s_102_8: cast zx s_102_5 -> u64
        let s_102_8: u64 = (s_102_5 as u64);
        // C s_102_9: const #1u : u64
        let s_102_9: u64 = 1;
        // D s_102_10: and s_102_8 s_102_9
        let s_102_10: u64 = ((s_102_8) & (s_102_9));
        // D s_102_11: cmp-eq s_102_10 s_102_9
        let s_102_11: bool = ((s_102_10) == (s_102_9));
        // D s_102_12: lsl s_102_8 s_102_6
        let s_102_12: u64 = s_102_8 << s_102_6;
        // D s_102_13: or s_102_7 s_102_12
        let s_102_13: u64 = ((s_102_7) | (s_102_12));
        // D s_102_14: cmpl s_102_12
        let s_102_14: u64 = !s_102_12;
        // D s_102_15: and s_102_7 s_102_14
        let s_102_15: u64 = ((s_102_7) & (s_102_14));
        // D s_102_16: select s_102_11 s_102_13 s_102_15
        let s_102_16: u64 = if s_102_11 { s_102_13 } else { s_102_15 };
        // D s_102_17: cast trunc s_102_16 -> u8
        let s_102_17: bool = ((s_102_16) != 0);
        // D s_102_18: cast zx s_102_17 -> bv
        let s_102_18: Bits = Bits::new(s_102_17 as u128, 1u16);
        // C s_102_19: const #1u : u8
        let s_102_19: bool = true;
        // C s_102_20: cast zx s_102_19 -> bv
        let s_102_20: Bits = Bits::new(s_102_19 as u128, 1u16);
        // D s_102_21: cmp-ne s_102_18 s_102_20
        let s_102_21: bool = ((s_102_18) != (s_102_20));
        // D s_102_22: write-var gs#397556 <= s_102_21
        fn_state.gs_397556 = s_102_21;
        // N s_102_23: jump b103
        return block_103(state, tracer, fn_state);
    }
    fn block_103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_103_0: read-var gs#397556:u8
        let s_103_0: bool = fn_state.gs_397556;
        // N s_103_1: branch s_103_0 b123 b104
        if s_103_0 {
            return block_123(state, tracer, fn_state);
        } else {
            return block_104(state, tracer, fn_state);
        };
    }
    fn block_104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_104_0: const #14s : i
        let s_104_0: i128 = 14;
        // D s_104_1: read-var u#30558:u32
        let s_104_1: u32 = fn_state.u_30558;
        // D s_104_2: cast zx s_104_1 -> bv
        let s_104_2: Bits = Bits::new(s_104_1 as u128, 32u16);
        // C s_104_3: const #1u : u64
        let s_104_3: u64 = 1;
        // D s_104_4: bit-extract s_104_2 s_104_0 s_104_3
        let s_104_4: Bits = (Bits::new(
            ((s_104_2) >> (s_104_0)).value(),
            u16::try_from(s_104_3).unwrap(),
        ));
        // D s_104_5: cast reint s_104_4 -> u8
        let s_104_5: bool = ((s_104_4.value()) != 0);
        // C s_104_6: const #0s : i
        let s_104_6: i128 = 0;
        // C s_104_7: const #0u : u64
        let s_104_7: u64 = 0;
        // D s_104_8: cast zx s_104_5 -> u64
        let s_104_8: u64 = (s_104_5 as u64);
        // C s_104_9: const #1u : u64
        let s_104_9: u64 = 1;
        // D s_104_10: and s_104_8 s_104_9
        let s_104_10: u64 = ((s_104_8) & (s_104_9));
        // D s_104_11: cmp-eq s_104_10 s_104_9
        let s_104_11: bool = ((s_104_10) == (s_104_9));
        // D s_104_12: lsl s_104_8 s_104_6
        let s_104_12: u64 = s_104_8 << s_104_6;
        // D s_104_13: or s_104_7 s_104_12
        let s_104_13: u64 = ((s_104_7) | (s_104_12));
        // D s_104_14: cmpl s_104_12
        let s_104_14: u64 = !s_104_12;
        // D s_104_15: and s_104_7 s_104_14
        let s_104_15: u64 = ((s_104_7) & (s_104_14));
        // D s_104_16: select s_104_11 s_104_13 s_104_15
        let s_104_16: u64 = if s_104_11 { s_104_13 } else { s_104_15 };
        // D s_104_17: cast trunc s_104_16 -> u8
        let s_104_17: bool = ((s_104_16) != 0);
        // D s_104_18: cast zx s_104_17 -> bv
        let s_104_18: Bits = Bits::new(s_104_17 as u128, 1u16);
        // C s_104_19: const #1u : u8
        let s_104_19: bool = true;
        // C s_104_20: cast zx s_104_19 -> bv
        let s_104_20: Bits = Bits::new(s_104_19 as u128, 1u16);
        // D s_104_21: cmp-ne s_104_18 s_104_20
        let s_104_21: bool = ((s_104_18) != (s_104_20));
        // D s_104_22: write-var gs#397559 <= s_104_21
        fn_state.gs_397559 = s_104_21;
        // N s_104_23: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_105_0: read-var gs#397559:u8
        let s_105_0: bool = fn_state.gs_397559;
        // N s_105_1: branch s_105_0 b122 b106
        if s_105_0 {
            return block_122(state, tracer, fn_state);
        } else {
            return block_106(state, tracer, fn_state);
        };
    }
    fn block_106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_106_0: const #15s : i
        let s_106_0: i128 = 15;
        // D s_106_1: read-var u#30558:u32
        let s_106_1: u32 = fn_state.u_30558;
        // D s_106_2: cast zx s_106_1 -> bv
        let s_106_2: Bits = Bits::new(s_106_1 as u128, 32u16);
        // C s_106_3: const #1u : u64
        let s_106_3: u64 = 1;
        // D s_106_4: bit-extract s_106_2 s_106_0 s_106_3
        let s_106_4: Bits = (Bits::new(
            ((s_106_2) >> (s_106_0)).value(),
            u16::try_from(s_106_3).unwrap(),
        ));
        // D s_106_5: cast reint s_106_4 -> u8
        let s_106_5: bool = ((s_106_4.value()) != 0);
        // C s_106_6: const #0s : i
        let s_106_6: i128 = 0;
        // C s_106_7: const #0u : u64
        let s_106_7: u64 = 0;
        // D s_106_8: cast zx s_106_5 -> u64
        let s_106_8: u64 = (s_106_5 as u64);
        // C s_106_9: const #1u : u64
        let s_106_9: u64 = 1;
        // D s_106_10: and s_106_8 s_106_9
        let s_106_10: u64 = ((s_106_8) & (s_106_9));
        // D s_106_11: cmp-eq s_106_10 s_106_9
        let s_106_11: bool = ((s_106_10) == (s_106_9));
        // D s_106_12: lsl s_106_8 s_106_6
        let s_106_12: u64 = s_106_8 << s_106_6;
        // D s_106_13: or s_106_7 s_106_12
        let s_106_13: u64 = ((s_106_7) | (s_106_12));
        // D s_106_14: cmpl s_106_12
        let s_106_14: u64 = !s_106_12;
        // D s_106_15: and s_106_7 s_106_14
        let s_106_15: u64 = ((s_106_7) & (s_106_14));
        // D s_106_16: select s_106_11 s_106_13 s_106_15
        let s_106_16: u64 = if s_106_11 { s_106_13 } else { s_106_15 };
        // D s_106_17: cast trunc s_106_16 -> u8
        let s_106_17: bool = ((s_106_16) != 0);
        // D s_106_18: cast zx s_106_17 -> bv
        let s_106_18: Bits = Bits::new(s_106_17 as u128, 1u16);
        // C s_106_19: const #1u : u8
        let s_106_19: bool = true;
        // C s_106_20: cast zx s_106_19 -> bv
        let s_106_20: Bits = Bits::new(s_106_19 as u128, 1u16);
        // D s_106_21: cmp-ne s_106_18 s_106_20
        let s_106_21: bool = ((s_106_18) != (s_106_20));
        // D s_106_22: write-var gs#397562 <= s_106_21
        fn_state.gs_397562 = s_106_21;
        // N s_106_23: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_107_0: read-var gs#397562:u8
        let s_107_0: bool = fn_state.gs_397562;
        // N s_107_1: branch s_107_0 b121 b108
        if s_107_0 {
            return block_121(state, tracer, fn_state);
        } else {
            return block_108(state, tracer, fn_state);
        };
    }
    fn block_108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_108_0: const #8s : i
        let s_108_0: i128 = 8;
        // D s_108_1: read-var u#30558:u32
        let s_108_1: u32 = fn_state.u_30558;
        // D s_108_2: cast zx s_108_1 -> bv
        let s_108_2: Bits = Bits::new(s_108_1 as u128, 32u16);
        // C s_108_3: const #1u : u64
        let s_108_3: u64 = 1;
        // D s_108_4: bit-extract s_108_2 s_108_0 s_108_3
        let s_108_4: Bits = (Bits::new(
            ((s_108_2) >> (s_108_0)).value(),
            u16::try_from(s_108_3).unwrap(),
        ));
        // D s_108_5: cast reint s_108_4 -> u8
        let s_108_5: bool = ((s_108_4.value()) != 0);
        // C s_108_6: const #0s : i
        let s_108_6: i128 = 0;
        // C s_108_7: const #0u : u64
        let s_108_7: u64 = 0;
        // D s_108_8: cast zx s_108_5 -> u64
        let s_108_8: u64 = (s_108_5 as u64);
        // C s_108_9: const #1u : u64
        let s_108_9: u64 = 1;
        // D s_108_10: and s_108_8 s_108_9
        let s_108_10: u64 = ((s_108_8) & (s_108_9));
        // D s_108_11: cmp-eq s_108_10 s_108_9
        let s_108_11: bool = ((s_108_10) == (s_108_9));
        // D s_108_12: lsl s_108_8 s_108_6
        let s_108_12: u64 = s_108_8 << s_108_6;
        // D s_108_13: or s_108_7 s_108_12
        let s_108_13: u64 = ((s_108_7) | (s_108_12));
        // D s_108_14: cmpl s_108_12
        let s_108_14: u64 = !s_108_12;
        // D s_108_15: and s_108_7 s_108_14
        let s_108_15: u64 = ((s_108_7) & (s_108_14));
        // D s_108_16: select s_108_11 s_108_13 s_108_15
        let s_108_16: u64 = if s_108_11 { s_108_13 } else { s_108_15 };
        // D s_108_17: cast trunc s_108_16 -> u8
        let s_108_17: bool = ((s_108_16) != 0);
        // D s_108_18: cast zx s_108_17 -> bv
        let s_108_18: Bits = Bits::new(s_108_17 as u128, 1u16);
        // C s_108_19: const #0u : u8
        let s_108_19: bool = false;
        // C s_108_20: cast zx s_108_19 -> bv
        let s_108_20: Bits = Bits::new(s_108_19 as u128, 1u16);
        // D s_108_21: cmp-ne s_108_18 s_108_20
        let s_108_21: bool = ((s_108_18) != (s_108_20));
        // D s_108_22: write-var gs#397565 <= s_108_21
        fn_state.gs_397565 = s_108_21;
        // N s_108_23: jump b109
        return block_109(state, tracer, fn_state);
    }
    fn block_109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_109_0: read-var gs#397565:u8
        let s_109_0: bool = fn_state.gs_397565;
        // N s_109_1: branch s_109_0 b120 b110
        if s_109_0 {
            return block_120(state, tracer, fn_state);
        } else {
            return block_110(state, tracer, fn_state);
        };
    }
    fn block_110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_110_0: const #9s : i
        let s_110_0: i128 = 9;
        // D s_110_1: read-var u#30558:u32
        let s_110_1: u32 = fn_state.u_30558;
        // D s_110_2: cast zx s_110_1 -> bv
        let s_110_2: Bits = Bits::new(s_110_1 as u128, 32u16);
        // C s_110_3: const #1u : u64
        let s_110_3: u64 = 1;
        // D s_110_4: bit-extract s_110_2 s_110_0 s_110_3
        let s_110_4: Bits = (Bits::new(
            ((s_110_2) >> (s_110_0)).value(),
            u16::try_from(s_110_3).unwrap(),
        ));
        // D s_110_5: cast reint s_110_4 -> u8
        let s_110_5: bool = ((s_110_4.value()) != 0);
        // C s_110_6: const #0s : i
        let s_110_6: i128 = 0;
        // C s_110_7: const #0u : u64
        let s_110_7: u64 = 0;
        // D s_110_8: cast zx s_110_5 -> u64
        let s_110_8: u64 = (s_110_5 as u64);
        // C s_110_9: const #1u : u64
        let s_110_9: u64 = 1;
        // D s_110_10: and s_110_8 s_110_9
        let s_110_10: u64 = ((s_110_8) & (s_110_9));
        // D s_110_11: cmp-eq s_110_10 s_110_9
        let s_110_11: bool = ((s_110_10) == (s_110_9));
        // D s_110_12: lsl s_110_8 s_110_6
        let s_110_12: u64 = s_110_8 << s_110_6;
        // D s_110_13: or s_110_7 s_110_12
        let s_110_13: u64 = ((s_110_7) | (s_110_12));
        // D s_110_14: cmpl s_110_12
        let s_110_14: u64 = !s_110_12;
        // D s_110_15: and s_110_7 s_110_14
        let s_110_15: u64 = ((s_110_7) & (s_110_14));
        // D s_110_16: select s_110_11 s_110_13 s_110_15
        let s_110_16: u64 = if s_110_11 { s_110_13 } else { s_110_15 };
        // D s_110_17: cast trunc s_110_16 -> u8
        let s_110_17: bool = ((s_110_16) != 0);
        // D s_110_18: cast zx s_110_17 -> bv
        let s_110_18: Bits = Bits::new(s_110_17 as u128, 1u16);
        // C s_110_19: const #0u : u8
        let s_110_19: bool = false;
        // C s_110_20: cast zx s_110_19 -> bv
        let s_110_20: Bits = Bits::new(s_110_19 as u128, 1u16);
        // D s_110_21: cmp-ne s_110_18 s_110_20
        let s_110_21: bool = ((s_110_18) != (s_110_20));
        // D s_110_22: write-var gs#397568 <= s_110_21
        fn_state.gs_397568 = s_110_21;
        // N s_110_23: jump b111
        return block_111(state, tracer, fn_state);
    }
    fn block_111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_111_0: read-var gs#397568:u8
        let s_111_0: bool = fn_state.gs_397568;
        // N s_111_1: branch s_111_0 b119 b112
        if s_111_0 {
            return block_119(state, tracer, fn_state);
        } else {
            return block_112(state, tracer, fn_state);
        };
    }
    fn block_112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_112_0: const #10s : i
        let s_112_0: i128 = 10;
        // D s_112_1: read-var u#30558:u32
        let s_112_1: u32 = fn_state.u_30558;
        // D s_112_2: cast zx s_112_1 -> bv
        let s_112_2: Bits = Bits::new(s_112_1 as u128, 32u16);
        // C s_112_3: const #1u : u64
        let s_112_3: u64 = 1;
        // D s_112_4: bit-extract s_112_2 s_112_0 s_112_3
        let s_112_4: Bits = (Bits::new(
            ((s_112_2) >> (s_112_0)).value(),
            u16::try_from(s_112_3).unwrap(),
        ));
        // D s_112_5: cast reint s_112_4 -> u8
        let s_112_5: bool = ((s_112_4.value()) != 0);
        // C s_112_6: const #0s : i
        let s_112_6: i128 = 0;
        // C s_112_7: const #0u : u64
        let s_112_7: u64 = 0;
        // D s_112_8: cast zx s_112_5 -> u64
        let s_112_8: u64 = (s_112_5 as u64);
        // C s_112_9: const #1u : u64
        let s_112_9: u64 = 1;
        // D s_112_10: and s_112_8 s_112_9
        let s_112_10: u64 = ((s_112_8) & (s_112_9));
        // D s_112_11: cmp-eq s_112_10 s_112_9
        let s_112_11: bool = ((s_112_10) == (s_112_9));
        // D s_112_12: lsl s_112_8 s_112_6
        let s_112_12: u64 = s_112_8 << s_112_6;
        // D s_112_13: or s_112_7 s_112_12
        let s_112_13: u64 = ((s_112_7) | (s_112_12));
        // D s_112_14: cmpl s_112_12
        let s_112_14: u64 = !s_112_12;
        // D s_112_15: and s_112_7 s_112_14
        let s_112_15: u64 = ((s_112_7) & (s_112_14));
        // D s_112_16: select s_112_11 s_112_13 s_112_15
        let s_112_16: u64 = if s_112_11 { s_112_13 } else { s_112_15 };
        // D s_112_17: cast trunc s_112_16 -> u8
        let s_112_17: bool = ((s_112_16) != 0);
        // D s_112_18: cast zx s_112_17 -> bv
        let s_112_18: Bits = Bits::new(s_112_17 as u128, 1u16);
        // C s_112_19: const #0u : u8
        let s_112_19: bool = false;
        // C s_112_20: cast zx s_112_19 -> bv
        let s_112_20: Bits = Bits::new(s_112_19 as u128, 1u16);
        // D s_112_21: cmp-ne s_112_18 s_112_20
        let s_112_21: bool = ((s_112_18) != (s_112_20));
        // D s_112_22: write-var gs#397571 <= s_112_21
        fn_state.gs_397571 = s_112_21;
        // N s_112_23: jump b113
        return block_113(state, tracer, fn_state);
    }
    fn block_113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_113_0: read-var gs#397571:u8
        let s_113_0: bool = fn_state.gs_397571;
        // N s_113_1: branch s_113_0 b118 b114
        if s_113_0 {
            return block_118(state, tracer, fn_state);
        } else {
            return block_114(state, tracer, fn_state);
        };
    }
    fn block_114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_114_0: const #11s : i
        let s_114_0: i128 = 11;
        // D s_114_1: read-var u#30558:u32
        let s_114_1: u32 = fn_state.u_30558;
        // D s_114_2: cast zx s_114_1 -> bv
        let s_114_2: Bits = Bits::new(s_114_1 as u128, 32u16);
        // C s_114_3: const #1u : u64
        let s_114_3: u64 = 1;
        // D s_114_4: bit-extract s_114_2 s_114_0 s_114_3
        let s_114_4: Bits = (Bits::new(
            ((s_114_2) >> (s_114_0)).value(),
            u16::try_from(s_114_3).unwrap(),
        ));
        // D s_114_5: cast reint s_114_4 -> u8
        let s_114_5: bool = ((s_114_4.value()) != 0);
        // C s_114_6: const #0s : i
        let s_114_6: i128 = 0;
        // C s_114_7: const #0u : u64
        let s_114_7: u64 = 0;
        // D s_114_8: cast zx s_114_5 -> u64
        let s_114_8: u64 = (s_114_5 as u64);
        // C s_114_9: const #1u : u64
        let s_114_9: u64 = 1;
        // D s_114_10: and s_114_8 s_114_9
        let s_114_10: u64 = ((s_114_8) & (s_114_9));
        // D s_114_11: cmp-eq s_114_10 s_114_9
        let s_114_11: bool = ((s_114_10) == (s_114_9));
        // D s_114_12: lsl s_114_8 s_114_6
        let s_114_12: u64 = s_114_8 << s_114_6;
        // D s_114_13: or s_114_7 s_114_12
        let s_114_13: u64 = ((s_114_7) | (s_114_12));
        // D s_114_14: cmpl s_114_12
        let s_114_14: u64 = !s_114_12;
        // D s_114_15: and s_114_7 s_114_14
        let s_114_15: u64 = ((s_114_7) & (s_114_14));
        // D s_114_16: select s_114_11 s_114_13 s_114_15
        let s_114_16: u64 = if s_114_11 { s_114_13 } else { s_114_15 };
        // D s_114_17: cast trunc s_114_16 -> u8
        let s_114_17: bool = ((s_114_16) != 0);
        // D s_114_18: cast zx s_114_17 -> bv
        let s_114_18: Bits = Bits::new(s_114_17 as u128, 1u16);
        // C s_114_19: const #0u : u8
        let s_114_19: bool = false;
        // C s_114_20: cast zx s_114_19 -> bv
        let s_114_20: Bits = Bits::new(s_114_19 as u128, 1u16);
        // D s_114_21: cmp-ne s_114_18 s_114_20
        let s_114_21: bool = ((s_114_18) != (s_114_20));
        // D s_114_22: write-var gs#397574 <= s_114_21
        fn_state.gs_397574 = s_114_21;
        // N s_114_23: jump b115
        return block_115(state, tracer, fn_state);
    }
    fn block_115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_115_0: read-var gs#397574:u8
        let s_115_0: bool = fn_state.gs_397574;
        // N s_115_1: branch s_115_0 b117 b116
        if s_115_0 {
            return block_117(state, tracer, fn_state);
        } else {
            return block_116(state, tracer, fn_state);
        };
    }
    fn block_116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_116_0: read-var u#30559:u8
        let s_116_0: u8 = fn_state.u_30559;
        // D s_116_1: call decode_aarch32_instrs_DSB_A1enc_A_txt(s_116_0)
        let s_116_1: () = decode_aarch32_instrs_DSB_A1enc_A_txt(state, tracer, s_116_0);
        // N s_116_2: return
        return;
    }
    fn block_117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_117_0: panic
        panic!("{:?}", ());
        // N s_117_1: return
        return;
    }
    fn block_118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_118_0: const #1u : u8
        let s_118_0: bool = true;
        // D s_118_1: write-var gs#397574 <= s_118_0
        fn_state.gs_397574 = s_118_0;
        // N s_118_2: jump b115
        return block_115(state, tracer, fn_state);
    }
    fn block_119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_119_0: const #1u : u8
        let s_119_0: bool = true;
        // D s_119_1: write-var gs#397571 <= s_119_0
        fn_state.gs_397571 = s_119_0;
        // N s_119_2: jump b113
        return block_113(state, tracer, fn_state);
    }
    fn block_120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_120_0: const #1u : u8
        let s_120_0: bool = true;
        // D s_120_1: write-var gs#397568 <= s_120_0
        fn_state.gs_397568 = s_120_0;
        // N s_120_2: jump b111
        return block_111(state, tracer, fn_state);
    }
    fn block_121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_121_0: const #1u : u8
        let s_121_0: bool = true;
        // D s_121_1: write-var gs#397565 <= s_121_0
        fn_state.gs_397565 = s_121_0;
        // N s_121_2: jump b109
        return block_109(state, tracer, fn_state);
    }
    fn block_122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_122_0: const #1u : u8
        let s_122_0: bool = true;
        // D s_122_1: write-var gs#397562 <= s_122_0
        fn_state.gs_397562 = s_122_0;
        // N s_122_2: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_123_0: const #1u : u8
        let s_123_0: bool = true;
        // D s_123_1: write-var gs#397559 <= s_123_0
        fn_state.gs_397559 = s_123_0;
        // N s_123_2: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_124_0: const #1u : u8
        let s_124_0: bool = true;
        // D s_124_1: write-var gs#397556 <= s_124_0
        fn_state.gs_397556 = s_124_0;
        // N s_124_2: jump b103
        return block_103(state, tracer, fn_state);
    }
    fn block_125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_125_0: const #1u : u8
        let s_125_0: bool = true;
        // D s_125_1: write-var gs#397553 <= s_125_0
        fn_state.gs_397553 = s_125_0;
        // N s_125_2: jump b101
        return block_101(state, tracer, fn_state);
    }
    fn block_126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_126_0: const #1u : u8
        let s_126_0: bool = true;
        // D s_126_1: write-var gs#397550 <= s_126_0
        fn_state.gs_397550 = s_126_0;
        // N s_126_2: jump b99
        return block_99(state, tracer, fn_state);
    }
    fn block_127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_127_0: const #1u : u8
        let s_127_0: bool = true;
        // D s_127_1: write-var gs#397547 <= s_127_0
        fn_state.gs_397547 = s_127_0;
        // N s_127_2: jump b97
        return block_97(state, tracer, fn_state);
    }
    fn block_128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_128_0: const #1u : u8
        let s_128_0: bool = true;
        // D s_128_1: write-var gs#397544 <= s_128_0
        fn_state.gs_397544 = s_128_0;
        // N s_128_2: jump b95
        return block_95(state, tracer, fn_state);
    }
    fn block_129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_129_0: read-var merge#var.1:struct
        let s_129_0: u32 = fn_state.merge_var._1;
        // D s_129_1: write-var u#30561 <= s_129_0
        fn_state.u_30561 = s_129_0;
        // C s_129_2: const #4s : i
        let s_129_2: i128 = 4;
        // D s_129_3: read-var u#30561:u32
        let s_129_3: u32 = fn_state.u_30561;
        // D s_129_4: cast zx s_129_3 -> bv
        let s_129_4: Bits = Bits::new(s_129_3 as u128, 32u16);
        // C s_129_5: const #1s : i64
        let s_129_5: i64 = 1;
        // C s_129_6: cast zx s_129_5 -> i
        let s_129_6: i128 = (i128::try_from(s_129_5).unwrap());
        // C s_129_7: const #27s : i
        let s_129_7: i128 = 27;
        // C s_129_8: add s_129_7 s_129_6
        let s_129_8: i128 = (s_129_7 + s_129_6);
        // D s_129_9: bit-extract s_129_4 s_129_2 s_129_8
        let s_129_9: Bits = (Bits::new(
            ((s_129_4) >> (s_129_2)).value(),
            u16::try_from(s_129_8).unwrap(),
        ));
        // D s_129_10: cast reint s_129_9 -> u28
        let s_129_10: u32 = (s_129_9.value() as u32);
        // D s_129_11: cast zx s_129_10 -> bv
        let s_129_11: Bits = Bits::new(s_129_10 as u128, 28u16);
        // C s_129_12: const #257425158u : u28
        let s_129_12: u32 = 257425158;
        // C s_129_13: cast zx s_129_12 -> bv
        let s_129_13: Bits = Bits::new(s_129_12 as u128, 28u16);
        // D s_129_14: cmp-eq s_129_11 s_129_13
        let s_129_14: bool = ((s_129_11) == (s_129_13));
        // N s_129_15: branch s_129_14 b3222 b130
        if s_129_14 {
            return block_3222(state, tracer, fn_state);
        } else {
            return block_130(state, tracer, fn_state);
        };
    }
    fn block_130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_130_0: const #0u : u8
        let s_130_0: bool = false;
        // D s_130_1: write-var gs#397579 <= s_130_0
        fn_state.gs_397579 = s_130_0;
        // N s_130_2: jump b131
        return block_131(state, tracer, fn_state);
    }
    fn block_131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_131_0: read-var gs#397579:u8
        let s_131_0: bool = fn_state.gs_397579;
        // D s_131_1: not s_131_0
        let s_131_1: bool = !s_131_0;
        // N s_131_2: branch s_131_1 b168 b132
        if s_131_1 {
            return block_168(state, tracer, fn_state);
        } else {
            return block_132(state, tracer, fn_state);
        };
    }
    fn block_132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_132_0: const #2909s : i
        let s_132_0: i128 = 2909;
        // C s_132_1: const #14696u : u32
        let s_132_1: u32 = 14696;
        // N s_132_2: write-reg s_132_1 <= s_132_0
        let s_132_2: () = {
            state.write_register::<i128>(s_132_1 as isize, s_132_0);
            tracer.write_register(s_132_1 as isize, s_132_0);
        };
        // C s_132_3: const #0s : i
        let s_132_3: i128 = 0;
        // C s_132_4: const #4s : i
        let s_132_4: i128 = 4;
        // D s_132_5: read-var u#30561:u32
        let s_132_5: u32 = fn_state.u_30561;
        // D s_132_6: cast zx s_132_5 -> bv
        let s_132_6: Bits = Bits::new(s_132_5 as u128, 32u16);
        // D s_132_7: bit-extract s_132_6 s_132_3 s_132_4
        let s_132_7: Bits = (Bits::new(
            ((s_132_6) >> (s_132_3)).value(),
            u16::try_from(s_132_4).unwrap(),
        ));
        // D s_132_8: cast reint s_132_7 -> u8
        let s_132_8: u8 = (s_132_7.value() as u8);
        // D s_132_9: write-var u#30562 <= s_132_8
        fn_state.u_30562 = s_132_8;
        // C s_132_10: const #16s : i
        let s_132_10: i128 = 16;
        // D s_132_11: read-var u#30561:u32
        let s_132_11: u32 = fn_state.u_30561;
        // D s_132_12: cast zx s_132_11 -> bv
        let s_132_12: Bits = Bits::new(s_132_11 as u128, 32u16);
        // C s_132_13: const #1u : u64
        let s_132_13: u64 = 1;
        // D s_132_14: bit-extract s_132_12 s_132_10 s_132_13
        let s_132_14: Bits = (Bits::new(
            ((s_132_12) >> (s_132_10)).value(),
            u16::try_from(s_132_13).unwrap(),
        ));
        // D s_132_15: cast reint s_132_14 -> u8
        let s_132_15: bool = ((s_132_14.value()) != 0);
        // C s_132_16: const #0s : i
        let s_132_16: i128 = 0;
        // C s_132_17: const #0u : u64
        let s_132_17: u64 = 0;
        // D s_132_18: cast zx s_132_15 -> u64
        let s_132_18: u64 = (s_132_15 as u64);
        // C s_132_19: const #1u : u64
        let s_132_19: u64 = 1;
        // D s_132_20: and s_132_18 s_132_19
        let s_132_20: u64 = ((s_132_18) & (s_132_19));
        // D s_132_21: cmp-eq s_132_20 s_132_19
        let s_132_21: bool = ((s_132_20) == (s_132_19));
        // D s_132_22: lsl s_132_18 s_132_16
        let s_132_22: u64 = s_132_18 << s_132_16;
        // D s_132_23: or s_132_17 s_132_22
        let s_132_23: u64 = ((s_132_17) | (s_132_22));
        // D s_132_24: cmpl s_132_22
        let s_132_24: u64 = !s_132_22;
        // D s_132_25: and s_132_17 s_132_24
        let s_132_25: u64 = ((s_132_17) & (s_132_24));
        // D s_132_26: select s_132_21 s_132_23 s_132_25
        let s_132_26: u64 = if s_132_21 { s_132_23 } else { s_132_25 };
        // D s_132_27: cast trunc s_132_26 -> u8
        let s_132_27: bool = ((s_132_26) != 0);
        // D s_132_28: cast zx s_132_27 -> bv
        let s_132_28: Bits = Bits::new(s_132_27 as u128, 1u16);
        // C s_132_29: const #1u : u8
        let s_132_29: bool = true;
        // C s_132_30: cast zx s_132_29 -> bv
        let s_132_30: Bits = Bits::new(s_132_29 as u128, 1u16);
        // D s_132_31: cmp-ne s_132_28 s_132_30
        let s_132_31: bool = ((s_132_28) != (s_132_30));
        // N s_132_32: branch s_132_31 b167 b133
        if s_132_31 {
            return block_167(state, tracer, fn_state);
        } else {
            return block_133(state, tracer, fn_state);
        };
    }
    fn block_133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_133_0: const #17s : i
        let s_133_0: i128 = 17;
        // D s_133_1: read-var u#30561:u32
        let s_133_1: u32 = fn_state.u_30561;
        // D s_133_2: cast zx s_133_1 -> bv
        let s_133_2: Bits = Bits::new(s_133_1 as u128, 32u16);
        // C s_133_3: const #1u : u64
        let s_133_3: u64 = 1;
        // D s_133_4: bit-extract s_133_2 s_133_0 s_133_3
        let s_133_4: Bits = (Bits::new(
            ((s_133_2) >> (s_133_0)).value(),
            u16::try_from(s_133_3).unwrap(),
        ));
        // D s_133_5: cast reint s_133_4 -> u8
        let s_133_5: bool = ((s_133_4.value()) != 0);
        // C s_133_6: const #0s : i
        let s_133_6: i128 = 0;
        // C s_133_7: const #0u : u64
        let s_133_7: u64 = 0;
        // D s_133_8: cast zx s_133_5 -> u64
        let s_133_8: u64 = (s_133_5 as u64);
        // C s_133_9: const #1u : u64
        let s_133_9: u64 = 1;
        // D s_133_10: and s_133_8 s_133_9
        let s_133_10: u64 = ((s_133_8) & (s_133_9));
        // D s_133_11: cmp-eq s_133_10 s_133_9
        let s_133_11: bool = ((s_133_10) == (s_133_9));
        // D s_133_12: lsl s_133_8 s_133_6
        let s_133_12: u64 = s_133_8 << s_133_6;
        // D s_133_13: or s_133_7 s_133_12
        let s_133_13: u64 = ((s_133_7) | (s_133_12));
        // D s_133_14: cmpl s_133_12
        let s_133_14: u64 = !s_133_12;
        // D s_133_15: and s_133_7 s_133_14
        let s_133_15: u64 = ((s_133_7) & (s_133_14));
        // D s_133_16: select s_133_11 s_133_13 s_133_15
        let s_133_16: u64 = if s_133_11 { s_133_13 } else { s_133_15 };
        // D s_133_17: cast trunc s_133_16 -> u8
        let s_133_17: bool = ((s_133_16) != 0);
        // D s_133_18: cast zx s_133_17 -> bv
        let s_133_18: Bits = Bits::new(s_133_17 as u128, 1u16);
        // C s_133_19: const #1u : u8
        let s_133_19: bool = true;
        // C s_133_20: cast zx s_133_19 -> bv
        let s_133_20: Bits = Bits::new(s_133_19 as u128, 1u16);
        // D s_133_21: cmp-ne s_133_18 s_133_20
        let s_133_21: bool = ((s_133_18) != (s_133_20));
        // D s_133_22: write-var gs#397588 <= s_133_21
        fn_state.gs_397588 = s_133_21;
        // N s_133_23: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_134_0: read-var gs#397588:u8
        let s_134_0: bool = fn_state.gs_397588;
        // N s_134_1: branch s_134_0 b166 b135
        if s_134_0 {
            return block_166(state, tracer, fn_state);
        } else {
            return block_135(state, tracer, fn_state);
        };
    }
    fn block_135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_135_0: const #18s : i
        let s_135_0: i128 = 18;
        // D s_135_1: read-var u#30561:u32
        let s_135_1: u32 = fn_state.u_30561;
        // D s_135_2: cast zx s_135_1 -> bv
        let s_135_2: Bits = Bits::new(s_135_1 as u128, 32u16);
        // C s_135_3: const #1u : u64
        let s_135_3: u64 = 1;
        // D s_135_4: bit-extract s_135_2 s_135_0 s_135_3
        let s_135_4: Bits = (Bits::new(
            ((s_135_2) >> (s_135_0)).value(),
            u16::try_from(s_135_3).unwrap(),
        ));
        // D s_135_5: cast reint s_135_4 -> u8
        let s_135_5: bool = ((s_135_4.value()) != 0);
        // C s_135_6: const #0s : i
        let s_135_6: i128 = 0;
        // C s_135_7: const #0u : u64
        let s_135_7: u64 = 0;
        // D s_135_8: cast zx s_135_5 -> u64
        let s_135_8: u64 = (s_135_5 as u64);
        // C s_135_9: const #1u : u64
        let s_135_9: u64 = 1;
        // D s_135_10: and s_135_8 s_135_9
        let s_135_10: u64 = ((s_135_8) & (s_135_9));
        // D s_135_11: cmp-eq s_135_10 s_135_9
        let s_135_11: bool = ((s_135_10) == (s_135_9));
        // D s_135_12: lsl s_135_8 s_135_6
        let s_135_12: u64 = s_135_8 << s_135_6;
        // D s_135_13: or s_135_7 s_135_12
        let s_135_13: u64 = ((s_135_7) | (s_135_12));
        // D s_135_14: cmpl s_135_12
        let s_135_14: u64 = !s_135_12;
        // D s_135_15: and s_135_7 s_135_14
        let s_135_15: u64 = ((s_135_7) & (s_135_14));
        // D s_135_16: select s_135_11 s_135_13 s_135_15
        let s_135_16: u64 = if s_135_11 { s_135_13 } else { s_135_15 };
        // D s_135_17: cast trunc s_135_16 -> u8
        let s_135_17: bool = ((s_135_16) != 0);
        // D s_135_18: cast zx s_135_17 -> bv
        let s_135_18: Bits = Bits::new(s_135_17 as u128, 1u16);
        // C s_135_19: const #1u : u8
        let s_135_19: bool = true;
        // C s_135_20: cast zx s_135_19 -> bv
        let s_135_20: Bits = Bits::new(s_135_19 as u128, 1u16);
        // D s_135_21: cmp-ne s_135_18 s_135_20
        let s_135_21: bool = ((s_135_18) != (s_135_20));
        // D s_135_22: write-var gs#397591 <= s_135_21
        fn_state.gs_397591 = s_135_21;
        // N s_135_23: jump b136
        return block_136(state, tracer, fn_state);
    }
    fn block_136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_136_0: read-var gs#397591:u8
        let s_136_0: bool = fn_state.gs_397591;
        // N s_136_1: branch s_136_0 b165 b137
        if s_136_0 {
            return block_165(state, tracer, fn_state);
        } else {
            return block_137(state, tracer, fn_state);
        };
    }
    fn block_137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_137_0: const #19s : i
        let s_137_0: i128 = 19;
        // D s_137_1: read-var u#30561:u32
        let s_137_1: u32 = fn_state.u_30561;
        // D s_137_2: cast zx s_137_1 -> bv
        let s_137_2: Bits = Bits::new(s_137_1 as u128, 32u16);
        // C s_137_3: const #1u : u64
        let s_137_3: u64 = 1;
        // D s_137_4: bit-extract s_137_2 s_137_0 s_137_3
        let s_137_4: Bits = (Bits::new(
            ((s_137_2) >> (s_137_0)).value(),
            u16::try_from(s_137_3).unwrap(),
        ));
        // D s_137_5: cast reint s_137_4 -> u8
        let s_137_5: bool = ((s_137_4.value()) != 0);
        // C s_137_6: const #0s : i
        let s_137_6: i128 = 0;
        // C s_137_7: const #0u : u64
        let s_137_7: u64 = 0;
        // D s_137_8: cast zx s_137_5 -> u64
        let s_137_8: u64 = (s_137_5 as u64);
        // C s_137_9: const #1u : u64
        let s_137_9: u64 = 1;
        // D s_137_10: and s_137_8 s_137_9
        let s_137_10: u64 = ((s_137_8) & (s_137_9));
        // D s_137_11: cmp-eq s_137_10 s_137_9
        let s_137_11: bool = ((s_137_10) == (s_137_9));
        // D s_137_12: lsl s_137_8 s_137_6
        let s_137_12: u64 = s_137_8 << s_137_6;
        // D s_137_13: or s_137_7 s_137_12
        let s_137_13: u64 = ((s_137_7) | (s_137_12));
        // D s_137_14: cmpl s_137_12
        let s_137_14: u64 = !s_137_12;
        // D s_137_15: and s_137_7 s_137_14
        let s_137_15: u64 = ((s_137_7) & (s_137_14));
        // D s_137_16: select s_137_11 s_137_13 s_137_15
        let s_137_16: u64 = if s_137_11 { s_137_13 } else { s_137_15 };
        // D s_137_17: cast trunc s_137_16 -> u8
        let s_137_17: bool = ((s_137_16) != 0);
        // D s_137_18: cast zx s_137_17 -> bv
        let s_137_18: Bits = Bits::new(s_137_17 as u128, 1u16);
        // C s_137_19: const #1u : u8
        let s_137_19: bool = true;
        // C s_137_20: cast zx s_137_19 -> bv
        let s_137_20: Bits = Bits::new(s_137_19 as u128, 1u16);
        // D s_137_21: cmp-ne s_137_18 s_137_20
        let s_137_21: bool = ((s_137_18) != (s_137_20));
        // D s_137_22: write-var gs#397594 <= s_137_21
        fn_state.gs_397594 = s_137_21;
        // N s_137_23: jump b138
        return block_138(state, tracer, fn_state);
    }
    fn block_138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_138_0: read-var gs#397594:u8
        let s_138_0: bool = fn_state.gs_397594;
        // N s_138_1: branch s_138_0 b164 b139
        if s_138_0 {
            return block_164(state, tracer, fn_state);
        } else {
            return block_139(state, tracer, fn_state);
        };
    }
    fn block_139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_139_0: const #12s : i
        let s_139_0: i128 = 12;
        // D s_139_1: read-var u#30561:u32
        let s_139_1: u32 = fn_state.u_30561;
        // D s_139_2: cast zx s_139_1 -> bv
        let s_139_2: Bits = Bits::new(s_139_1 as u128, 32u16);
        // C s_139_3: const #1u : u64
        let s_139_3: u64 = 1;
        // D s_139_4: bit-extract s_139_2 s_139_0 s_139_3
        let s_139_4: Bits = (Bits::new(
            ((s_139_2) >> (s_139_0)).value(),
            u16::try_from(s_139_3).unwrap(),
        ));
        // D s_139_5: cast reint s_139_4 -> u8
        let s_139_5: bool = ((s_139_4.value()) != 0);
        // C s_139_6: const #0s : i
        let s_139_6: i128 = 0;
        // C s_139_7: const #0u : u64
        let s_139_7: u64 = 0;
        // D s_139_8: cast zx s_139_5 -> u64
        let s_139_8: u64 = (s_139_5 as u64);
        // C s_139_9: const #1u : u64
        let s_139_9: u64 = 1;
        // D s_139_10: and s_139_8 s_139_9
        let s_139_10: u64 = ((s_139_8) & (s_139_9));
        // D s_139_11: cmp-eq s_139_10 s_139_9
        let s_139_11: bool = ((s_139_10) == (s_139_9));
        // D s_139_12: lsl s_139_8 s_139_6
        let s_139_12: u64 = s_139_8 << s_139_6;
        // D s_139_13: or s_139_7 s_139_12
        let s_139_13: u64 = ((s_139_7) | (s_139_12));
        // D s_139_14: cmpl s_139_12
        let s_139_14: u64 = !s_139_12;
        // D s_139_15: and s_139_7 s_139_14
        let s_139_15: u64 = ((s_139_7) & (s_139_14));
        // D s_139_16: select s_139_11 s_139_13 s_139_15
        let s_139_16: u64 = if s_139_11 { s_139_13 } else { s_139_15 };
        // D s_139_17: cast trunc s_139_16 -> u8
        let s_139_17: bool = ((s_139_16) != 0);
        // D s_139_18: cast zx s_139_17 -> bv
        let s_139_18: Bits = Bits::new(s_139_17 as u128, 1u16);
        // C s_139_19: const #1u : u8
        let s_139_19: bool = true;
        // C s_139_20: cast zx s_139_19 -> bv
        let s_139_20: Bits = Bits::new(s_139_19 as u128, 1u16);
        // D s_139_21: cmp-ne s_139_18 s_139_20
        let s_139_21: bool = ((s_139_18) != (s_139_20));
        // D s_139_22: write-var gs#397597 <= s_139_21
        fn_state.gs_397597 = s_139_21;
        // N s_139_23: jump b140
        return block_140(state, tracer, fn_state);
    }
    fn block_140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_140_0: read-var gs#397597:u8
        let s_140_0: bool = fn_state.gs_397597;
        // N s_140_1: branch s_140_0 b163 b141
        if s_140_0 {
            return block_163(state, tracer, fn_state);
        } else {
            return block_141(state, tracer, fn_state);
        };
    }
    fn block_141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_141_0: const #13s : i
        let s_141_0: i128 = 13;
        // D s_141_1: read-var u#30561:u32
        let s_141_1: u32 = fn_state.u_30561;
        // D s_141_2: cast zx s_141_1 -> bv
        let s_141_2: Bits = Bits::new(s_141_1 as u128, 32u16);
        // C s_141_3: const #1u : u64
        let s_141_3: u64 = 1;
        // D s_141_4: bit-extract s_141_2 s_141_0 s_141_3
        let s_141_4: Bits = (Bits::new(
            ((s_141_2) >> (s_141_0)).value(),
            u16::try_from(s_141_3).unwrap(),
        ));
        // D s_141_5: cast reint s_141_4 -> u8
        let s_141_5: bool = ((s_141_4.value()) != 0);
        // C s_141_6: const #0s : i
        let s_141_6: i128 = 0;
        // C s_141_7: const #0u : u64
        let s_141_7: u64 = 0;
        // D s_141_8: cast zx s_141_5 -> u64
        let s_141_8: u64 = (s_141_5 as u64);
        // C s_141_9: const #1u : u64
        let s_141_9: u64 = 1;
        // D s_141_10: and s_141_8 s_141_9
        let s_141_10: u64 = ((s_141_8) & (s_141_9));
        // D s_141_11: cmp-eq s_141_10 s_141_9
        let s_141_11: bool = ((s_141_10) == (s_141_9));
        // D s_141_12: lsl s_141_8 s_141_6
        let s_141_12: u64 = s_141_8 << s_141_6;
        // D s_141_13: or s_141_7 s_141_12
        let s_141_13: u64 = ((s_141_7) | (s_141_12));
        // D s_141_14: cmpl s_141_12
        let s_141_14: u64 = !s_141_12;
        // D s_141_15: and s_141_7 s_141_14
        let s_141_15: u64 = ((s_141_7) & (s_141_14));
        // D s_141_16: select s_141_11 s_141_13 s_141_15
        let s_141_16: u64 = if s_141_11 { s_141_13 } else { s_141_15 };
        // D s_141_17: cast trunc s_141_16 -> u8
        let s_141_17: bool = ((s_141_16) != 0);
        // D s_141_18: cast zx s_141_17 -> bv
        let s_141_18: Bits = Bits::new(s_141_17 as u128, 1u16);
        // C s_141_19: const #1u : u8
        let s_141_19: bool = true;
        // C s_141_20: cast zx s_141_19 -> bv
        let s_141_20: Bits = Bits::new(s_141_19 as u128, 1u16);
        // D s_141_21: cmp-ne s_141_18 s_141_20
        let s_141_21: bool = ((s_141_18) != (s_141_20));
        // D s_141_22: write-var gs#397600 <= s_141_21
        fn_state.gs_397600 = s_141_21;
        // N s_141_23: jump b142
        return block_142(state, tracer, fn_state);
    }
    fn block_142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_142_0: read-var gs#397600:u8
        let s_142_0: bool = fn_state.gs_397600;
        // N s_142_1: branch s_142_0 b162 b143
        if s_142_0 {
            return block_162(state, tracer, fn_state);
        } else {
            return block_143(state, tracer, fn_state);
        };
    }
    fn block_143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_143_0: const #14s : i
        let s_143_0: i128 = 14;
        // D s_143_1: read-var u#30561:u32
        let s_143_1: u32 = fn_state.u_30561;
        // D s_143_2: cast zx s_143_1 -> bv
        let s_143_2: Bits = Bits::new(s_143_1 as u128, 32u16);
        // C s_143_3: const #1u : u64
        let s_143_3: u64 = 1;
        // D s_143_4: bit-extract s_143_2 s_143_0 s_143_3
        let s_143_4: Bits = (Bits::new(
            ((s_143_2) >> (s_143_0)).value(),
            u16::try_from(s_143_3).unwrap(),
        ));
        // D s_143_5: cast reint s_143_4 -> u8
        let s_143_5: bool = ((s_143_4.value()) != 0);
        // C s_143_6: const #0s : i
        let s_143_6: i128 = 0;
        // C s_143_7: const #0u : u64
        let s_143_7: u64 = 0;
        // D s_143_8: cast zx s_143_5 -> u64
        let s_143_8: u64 = (s_143_5 as u64);
        // C s_143_9: const #1u : u64
        let s_143_9: u64 = 1;
        // D s_143_10: and s_143_8 s_143_9
        let s_143_10: u64 = ((s_143_8) & (s_143_9));
        // D s_143_11: cmp-eq s_143_10 s_143_9
        let s_143_11: bool = ((s_143_10) == (s_143_9));
        // D s_143_12: lsl s_143_8 s_143_6
        let s_143_12: u64 = s_143_8 << s_143_6;
        // D s_143_13: or s_143_7 s_143_12
        let s_143_13: u64 = ((s_143_7) | (s_143_12));
        // D s_143_14: cmpl s_143_12
        let s_143_14: u64 = !s_143_12;
        // D s_143_15: and s_143_7 s_143_14
        let s_143_15: u64 = ((s_143_7) & (s_143_14));
        // D s_143_16: select s_143_11 s_143_13 s_143_15
        let s_143_16: u64 = if s_143_11 { s_143_13 } else { s_143_15 };
        // D s_143_17: cast trunc s_143_16 -> u8
        let s_143_17: bool = ((s_143_16) != 0);
        // D s_143_18: cast zx s_143_17 -> bv
        let s_143_18: Bits = Bits::new(s_143_17 as u128, 1u16);
        // C s_143_19: const #1u : u8
        let s_143_19: bool = true;
        // C s_143_20: cast zx s_143_19 -> bv
        let s_143_20: Bits = Bits::new(s_143_19 as u128, 1u16);
        // D s_143_21: cmp-ne s_143_18 s_143_20
        let s_143_21: bool = ((s_143_18) != (s_143_20));
        // D s_143_22: write-var gs#397603 <= s_143_21
        fn_state.gs_397603 = s_143_21;
        // N s_143_23: jump b144
        return block_144(state, tracer, fn_state);
    }
    fn block_144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_144_0: read-var gs#397603:u8
        let s_144_0: bool = fn_state.gs_397603;
        // N s_144_1: branch s_144_0 b161 b145
        if s_144_0 {
            return block_161(state, tracer, fn_state);
        } else {
            return block_145(state, tracer, fn_state);
        };
    }
    fn block_145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_145_0: const #15s : i
        let s_145_0: i128 = 15;
        // D s_145_1: read-var u#30561:u32
        let s_145_1: u32 = fn_state.u_30561;
        // D s_145_2: cast zx s_145_1 -> bv
        let s_145_2: Bits = Bits::new(s_145_1 as u128, 32u16);
        // C s_145_3: const #1u : u64
        let s_145_3: u64 = 1;
        // D s_145_4: bit-extract s_145_2 s_145_0 s_145_3
        let s_145_4: Bits = (Bits::new(
            ((s_145_2) >> (s_145_0)).value(),
            u16::try_from(s_145_3).unwrap(),
        ));
        // D s_145_5: cast reint s_145_4 -> u8
        let s_145_5: bool = ((s_145_4.value()) != 0);
        // C s_145_6: const #0s : i
        let s_145_6: i128 = 0;
        // C s_145_7: const #0u : u64
        let s_145_7: u64 = 0;
        // D s_145_8: cast zx s_145_5 -> u64
        let s_145_8: u64 = (s_145_5 as u64);
        // C s_145_9: const #1u : u64
        let s_145_9: u64 = 1;
        // D s_145_10: and s_145_8 s_145_9
        let s_145_10: u64 = ((s_145_8) & (s_145_9));
        // D s_145_11: cmp-eq s_145_10 s_145_9
        let s_145_11: bool = ((s_145_10) == (s_145_9));
        // D s_145_12: lsl s_145_8 s_145_6
        let s_145_12: u64 = s_145_8 << s_145_6;
        // D s_145_13: or s_145_7 s_145_12
        let s_145_13: u64 = ((s_145_7) | (s_145_12));
        // D s_145_14: cmpl s_145_12
        let s_145_14: u64 = !s_145_12;
        // D s_145_15: and s_145_7 s_145_14
        let s_145_15: u64 = ((s_145_7) & (s_145_14));
        // D s_145_16: select s_145_11 s_145_13 s_145_15
        let s_145_16: u64 = if s_145_11 { s_145_13 } else { s_145_15 };
        // D s_145_17: cast trunc s_145_16 -> u8
        let s_145_17: bool = ((s_145_16) != 0);
        // D s_145_18: cast zx s_145_17 -> bv
        let s_145_18: Bits = Bits::new(s_145_17 as u128, 1u16);
        // C s_145_19: const #1u : u8
        let s_145_19: bool = true;
        // C s_145_20: cast zx s_145_19 -> bv
        let s_145_20: Bits = Bits::new(s_145_19 as u128, 1u16);
        // D s_145_21: cmp-ne s_145_18 s_145_20
        let s_145_21: bool = ((s_145_18) != (s_145_20));
        // D s_145_22: write-var gs#397606 <= s_145_21
        fn_state.gs_397606 = s_145_21;
        // N s_145_23: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_146_0: read-var gs#397606:u8
        let s_146_0: bool = fn_state.gs_397606;
        // N s_146_1: branch s_146_0 b160 b147
        if s_146_0 {
            return block_160(state, tracer, fn_state);
        } else {
            return block_147(state, tracer, fn_state);
        };
    }
    fn block_147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_147_0: const #8s : i
        let s_147_0: i128 = 8;
        // D s_147_1: read-var u#30561:u32
        let s_147_1: u32 = fn_state.u_30561;
        // D s_147_2: cast zx s_147_1 -> bv
        let s_147_2: Bits = Bits::new(s_147_1 as u128, 32u16);
        // C s_147_3: const #1u : u64
        let s_147_3: u64 = 1;
        // D s_147_4: bit-extract s_147_2 s_147_0 s_147_3
        let s_147_4: Bits = (Bits::new(
            ((s_147_2) >> (s_147_0)).value(),
            u16::try_from(s_147_3).unwrap(),
        ));
        // D s_147_5: cast reint s_147_4 -> u8
        let s_147_5: bool = ((s_147_4.value()) != 0);
        // C s_147_6: const #0s : i
        let s_147_6: i128 = 0;
        // C s_147_7: const #0u : u64
        let s_147_7: u64 = 0;
        // D s_147_8: cast zx s_147_5 -> u64
        let s_147_8: u64 = (s_147_5 as u64);
        // C s_147_9: const #1u : u64
        let s_147_9: u64 = 1;
        // D s_147_10: and s_147_8 s_147_9
        let s_147_10: u64 = ((s_147_8) & (s_147_9));
        // D s_147_11: cmp-eq s_147_10 s_147_9
        let s_147_11: bool = ((s_147_10) == (s_147_9));
        // D s_147_12: lsl s_147_8 s_147_6
        let s_147_12: u64 = s_147_8 << s_147_6;
        // D s_147_13: or s_147_7 s_147_12
        let s_147_13: u64 = ((s_147_7) | (s_147_12));
        // D s_147_14: cmpl s_147_12
        let s_147_14: u64 = !s_147_12;
        // D s_147_15: and s_147_7 s_147_14
        let s_147_15: u64 = ((s_147_7) & (s_147_14));
        // D s_147_16: select s_147_11 s_147_13 s_147_15
        let s_147_16: u64 = if s_147_11 { s_147_13 } else { s_147_15 };
        // D s_147_17: cast trunc s_147_16 -> u8
        let s_147_17: bool = ((s_147_16) != 0);
        // D s_147_18: cast zx s_147_17 -> bv
        let s_147_18: Bits = Bits::new(s_147_17 as u128, 1u16);
        // C s_147_19: const #0u : u8
        let s_147_19: bool = false;
        // C s_147_20: cast zx s_147_19 -> bv
        let s_147_20: Bits = Bits::new(s_147_19 as u128, 1u16);
        // D s_147_21: cmp-ne s_147_18 s_147_20
        let s_147_21: bool = ((s_147_18) != (s_147_20));
        // D s_147_22: write-var gs#397609 <= s_147_21
        fn_state.gs_397609 = s_147_21;
        // N s_147_23: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_148_0: read-var gs#397609:u8
        let s_148_0: bool = fn_state.gs_397609;
        // N s_148_1: branch s_148_0 b159 b149
        if s_148_0 {
            return block_159(state, tracer, fn_state);
        } else {
            return block_149(state, tracer, fn_state);
        };
    }
    fn block_149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_149_0: const #9s : i
        let s_149_0: i128 = 9;
        // D s_149_1: read-var u#30561:u32
        let s_149_1: u32 = fn_state.u_30561;
        // D s_149_2: cast zx s_149_1 -> bv
        let s_149_2: Bits = Bits::new(s_149_1 as u128, 32u16);
        // C s_149_3: const #1u : u64
        let s_149_3: u64 = 1;
        // D s_149_4: bit-extract s_149_2 s_149_0 s_149_3
        let s_149_4: Bits = (Bits::new(
            ((s_149_2) >> (s_149_0)).value(),
            u16::try_from(s_149_3).unwrap(),
        ));
        // D s_149_5: cast reint s_149_4 -> u8
        let s_149_5: bool = ((s_149_4.value()) != 0);
        // C s_149_6: const #0s : i
        let s_149_6: i128 = 0;
        // C s_149_7: const #0u : u64
        let s_149_7: u64 = 0;
        // D s_149_8: cast zx s_149_5 -> u64
        let s_149_8: u64 = (s_149_5 as u64);
        // C s_149_9: const #1u : u64
        let s_149_9: u64 = 1;
        // D s_149_10: and s_149_8 s_149_9
        let s_149_10: u64 = ((s_149_8) & (s_149_9));
        // D s_149_11: cmp-eq s_149_10 s_149_9
        let s_149_11: bool = ((s_149_10) == (s_149_9));
        // D s_149_12: lsl s_149_8 s_149_6
        let s_149_12: u64 = s_149_8 << s_149_6;
        // D s_149_13: or s_149_7 s_149_12
        let s_149_13: u64 = ((s_149_7) | (s_149_12));
        // D s_149_14: cmpl s_149_12
        let s_149_14: u64 = !s_149_12;
        // D s_149_15: and s_149_7 s_149_14
        let s_149_15: u64 = ((s_149_7) & (s_149_14));
        // D s_149_16: select s_149_11 s_149_13 s_149_15
        let s_149_16: u64 = if s_149_11 { s_149_13 } else { s_149_15 };
        // D s_149_17: cast trunc s_149_16 -> u8
        let s_149_17: bool = ((s_149_16) != 0);
        // D s_149_18: cast zx s_149_17 -> bv
        let s_149_18: Bits = Bits::new(s_149_17 as u128, 1u16);
        // C s_149_19: const #0u : u8
        let s_149_19: bool = false;
        // C s_149_20: cast zx s_149_19 -> bv
        let s_149_20: Bits = Bits::new(s_149_19 as u128, 1u16);
        // D s_149_21: cmp-ne s_149_18 s_149_20
        let s_149_21: bool = ((s_149_18) != (s_149_20));
        // D s_149_22: write-var gs#397612 <= s_149_21
        fn_state.gs_397612 = s_149_21;
        // N s_149_23: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_150_0: read-var gs#397612:u8
        let s_150_0: bool = fn_state.gs_397612;
        // N s_150_1: branch s_150_0 b158 b151
        if s_150_0 {
            return block_158(state, tracer, fn_state);
        } else {
            return block_151(state, tracer, fn_state);
        };
    }
    fn block_151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_151_0: const #10s : i
        let s_151_0: i128 = 10;
        // D s_151_1: read-var u#30561:u32
        let s_151_1: u32 = fn_state.u_30561;
        // D s_151_2: cast zx s_151_1 -> bv
        let s_151_2: Bits = Bits::new(s_151_1 as u128, 32u16);
        // C s_151_3: const #1u : u64
        let s_151_3: u64 = 1;
        // D s_151_4: bit-extract s_151_2 s_151_0 s_151_3
        let s_151_4: Bits = (Bits::new(
            ((s_151_2) >> (s_151_0)).value(),
            u16::try_from(s_151_3).unwrap(),
        ));
        // D s_151_5: cast reint s_151_4 -> u8
        let s_151_5: bool = ((s_151_4.value()) != 0);
        // C s_151_6: const #0s : i
        let s_151_6: i128 = 0;
        // C s_151_7: const #0u : u64
        let s_151_7: u64 = 0;
        // D s_151_8: cast zx s_151_5 -> u64
        let s_151_8: u64 = (s_151_5 as u64);
        // C s_151_9: const #1u : u64
        let s_151_9: u64 = 1;
        // D s_151_10: and s_151_8 s_151_9
        let s_151_10: u64 = ((s_151_8) & (s_151_9));
        // D s_151_11: cmp-eq s_151_10 s_151_9
        let s_151_11: bool = ((s_151_10) == (s_151_9));
        // D s_151_12: lsl s_151_8 s_151_6
        let s_151_12: u64 = s_151_8 << s_151_6;
        // D s_151_13: or s_151_7 s_151_12
        let s_151_13: u64 = ((s_151_7) | (s_151_12));
        // D s_151_14: cmpl s_151_12
        let s_151_14: u64 = !s_151_12;
        // D s_151_15: and s_151_7 s_151_14
        let s_151_15: u64 = ((s_151_7) & (s_151_14));
        // D s_151_16: select s_151_11 s_151_13 s_151_15
        let s_151_16: u64 = if s_151_11 { s_151_13 } else { s_151_15 };
        // D s_151_17: cast trunc s_151_16 -> u8
        let s_151_17: bool = ((s_151_16) != 0);
        // D s_151_18: cast zx s_151_17 -> bv
        let s_151_18: Bits = Bits::new(s_151_17 as u128, 1u16);
        // C s_151_19: const #0u : u8
        let s_151_19: bool = false;
        // C s_151_20: cast zx s_151_19 -> bv
        let s_151_20: Bits = Bits::new(s_151_19 as u128, 1u16);
        // D s_151_21: cmp-ne s_151_18 s_151_20
        let s_151_21: bool = ((s_151_18) != (s_151_20));
        // D s_151_22: write-var gs#397615 <= s_151_21
        fn_state.gs_397615 = s_151_21;
        // N s_151_23: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_152_0: read-var gs#397615:u8
        let s_152_0: bool = fn_state.gs_397615;
        // N s_152_1: branch s_152_0 b157 b153
        if s_152_0 {
            return block_157(state, tracer, fn_state);
        } else {
            return block_153(state, tracer, fn_state);
        };
    }
    fn block_153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_153_0: const #11s : i
        let s_153_0: i128 = 11;
        // D s_153_1: read-var u#30561:u32
        let s_153_1: u32 = fn_state.u_30561;
        // D s_153_2: cast zx s_153_1 -> bv
        let s_153_2: Bits = Bits::new(s_153_1 as u128, 32u16);
        // C s_153_3: const #1u : u64
        let s_153_3: u64 = 1;
        // D s_153_4: bit-extract s_153_2 s_153_0 s_153_3
        let s_153_4: Bits = (Bits::new(
            ((s_153_2) >> (s_153_0)).value(),
            u16::try_from(s_153_3).unwrap(),
        ));
        // D s_153_5: cast reint s_153_4 -> u8
        let s_153_5: bool = ((s_153_4.value()) != 0);
        // C s_153_6: const #0s : i
        let s_153_6: i128 = 0;
        // C s_153_7: const #0u : u64
        let s_153_7: u64 = 0;
        // D s_153_8: cast zx s_153_5 -> u64
        let s_153_8: u64 = (s_153_5 as u64);
        // C s_153_9: const #1u : u64
        let s_153_9: u64 = 1;
        // D s_153_10: and s_153_8 s_153_9
        let s_153_10: u64 = ((s_153_8) & (s_153_9));
        // D s_153_11: cmp-eq s_153_10 s_153_9
        let s_153_11: bool = ((s_153_10) == (s_153_9));
        // D s_153_12: lsl s_153_8 s_153_6
        let s_153_12: u64 = s_153_8 << s_153_6;
        // D s_153_13: or s_153_7 s_153_12
        let s_153_13: u64 = ((s_153_7) | (s_153_12));
        // D s_153_14: cmpl s_153_12
        let s_153_14: u64 = !s_153_12;
        // D s_153_15: and s_153_7 s_153_14
        let s_153_15: u64 = ((s_153_7) & (s_153_14));
        // D s_153_16: select s_153_11 s_153_13 s_153_15
        let s_153_16: u64 = if s_153_11 { s_153_13 } else { s_153_15 };
        // D s_153_17: cast trunc s_153_16 -> u8
        let s_153_17: bool = ((s_153_16) != 0);
        // D s_153_18: cast zx s_153_17 -> bv
        let s_153_18: Bits = Bits::new(s_153_17 as u128, 1u16);
        // C s_153_19: const #0u : u8
        let s_153_19: bool = false;
        // C s_153_20: cast zx s_153_19 -> bv
        let s_153_20: Bits = Bits::new(s_153_19 as u128, 1u16);
        // D s_153_21: cmp-ne s_153_18 s_153_20
        let s_153_21: bool = ((s_153_18) != (s_153_20));
        // D s_153_22: write-var gs#397618 <= s_153_21
        fn_state.gs_397618 = s_153_21;
        // N s_153_23: jump b154
        return block_154(state, tracer, fn_state);
    }
    fn block_154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_154_0: read-var gs#397618:u8
        let s_154_0: bool = fn_state.gs_397618;
        // N s_154_1: branch s_154_0 b156 b155
        if s_154_0 {
            return block_156(state, tracer, fn_state);
        } else {
            return block_155(state, tracer, fn_state);
        };
    }
    fn block_155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_155_0: read-var u#30562:u8
        let s_155_0: u8 = fn_state.u_30562;
        // D s_155_1: call decode_aarch32_instrs_ISB_A1enc_A_txt(s_155_0)
        let s_155_1: () = decode_aarch32_instrs_ISB_A1enc_A_txt(state, tracer, s_155_0);
        // N s_155_2: return
        return;
    }
    fn block_156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_156_0: panic
        panic!("{:?}", ());
        // N s_156_1: return
        return;
    }
    fn block_157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_157_0: const #1u : u8
        let s_157_0: bool = true;
        // D s_157_1: write-var gs#397618 <= s_157_0
        fn_state.gs_397618 = s_157_0;
        // N s_157_2: jump b154
        return block_154(state, tracer, fn_state);
    }
    fn block_158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_158_0: const #1u : u8
        let s_158_0: bool = true;
        // D s_158_1: write-var gs#397615 <= s_158_0
        fn_state.gs_397615 = s_158_0;
        // N s_158_2: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_159_0: const #1u : u8
        let s_159_0: bool = true;
        // D s_159_1: write-var gs#397612 <= s_159_0
        fn_state.gs_397612 = s_159_0;
        // N s_159_2: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_160_0: const #1u : u8
        let s_160_0: bool = true;
        // D s_160_1: write-var gs#397609 <= s_160_0
        fn_state.gs_397609 = s_160_0;
        // N s_160_2: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_161_0: const #1u : u8
        let s_161_0: bool = true;
        // D s_161_1: write-var gs#397606 <= s_161_0
        fn_state.gs_397606 = s_161_0;
        // N s_161_2: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_162_0: const #1u : u8
        let s_162_0: bool = true;
        // D s_162_1: write-var gs#397603 <= s_162_0
        fn_state.gs_397603 = s_162_0;
        // N s_162_2: jump b144
        return block_144(state, tracer, fn_state);
    }
    fn block_163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_163_0: const #1u : u8
        let s_163_0: bool = true;
        // D s_163_1: write-var gs#397600 <= s_163_0
        fn_state.gs_397600 = s_163_0;
        // N s_163_2: jump b142
        return block_142(state, tracer, fn_state);
    }
    fn block_164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_164_0: const #1u : u8
        let s_164_0: bool = true;
        // D s_164_1: write-var gs#397597 <= s_164_0
        fn_state.gs_397597 = s_164_0;
        // N s_164_2: jump b140
        return block_140(state, tracer, fn_state);
    }
    fn block_165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_165_0: const #1u : u8
        let s_165_0: bool = true;
        // D s_165_1: write-var gs#397594 <= s_165_0
        fn_state.gs_397594 = s_165_0;
        // N s_165_2: jump b138
        return block_138(state, tracer, fn_state);
    }
    fn block_166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_166_0: const #1u : u8
        let s_166_0: bool = true;
        // D s_166_1: write-var gs#397591 <= s_166_0
        fn_state.gs_397591 = s_166_0;
        // N s_166_2: jump b136
        return block_136(state, tracer, fn_state);
    }
    fn block_167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_167_0: const #1u : u8
        let s_167_0: bool = true;
        // D s_167_1: write-var gs#397588 <= s_167_0
        fn_state.gs_397588 = s_167_0;
        // N s_167_2: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_168_0: read-var merge#var.1:struct
        let s_168_0: u32 = fn_state.merge_var._1;
        // D s_168_1: write-var u#30564 <= s_168_0
        fn_state.u_30564 = s_168_0;
        // C s_168_2: const #24s : i
        let s_168_2: i128 = 24;
        // D s_168_3: read-var u#30564:u32
        let s_168_3: u32 = fn_state.u_30564;
        // D s_168_4: cast zx s_168_3 -> bv
        let s_168_4: Bits = Bits::new(s_168_3 as u128, 32u16);
        // C s_168_5: const #1s : i64
        let s_168_5: i64 = 1;
        // C s_168_6: cast zx s_168_5 -> i
        let s_168_6: i128 = (i128::try_from(s_168_5).unwrap());
        // C s_168_7: const #7s : i
        let s_168_7: i128 = 7;
        // C s_168_8: add s_168_7 s_168_6
        let s_168_8: i128 = (s_168_7 + s_168_6);
        // D s_168_9: bit-extract s_168_4 s_168_2 s_168_8
        let s_168_9: Bits = (Bits::new(
            ((s_168_4) >> (s_168_2)).value(),
            u16::try_from(s_168_8).unwrap(),
        ));
        // D s_168_10: cast reint s_168_9 -> u8
        let s_168_10: u8 = (s_168_9.value() as u8);
        // D s_168_11: cast zx s_168_10 -> bv
        let s_168_11: Bits = Bits::new(s_168_10 as u128, 8u16);
        // C s_168_12: const #245u : u8
        let s_168_12: u8 = 245;
        // C s_168_13: cast zx s_168_12 -> bv
        let s_168_13: Bits = Bits::new(s_168_12 as u128, 8u16);
        // D s_168_14: cmp-eq s_168_11 s_168_13
        let s_168_14: bool = ((s_168_11) == (s_168_13));
        // N s_168_15: branch s_168_14 b3218 b169
        if s_168_14 {
            return block_3218(state, tracer, fn_state);
        } else {
            return block_169(state, tracer, fn_state);
        };
    }
    fn block_169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_169_0: const #0u : u8
        let s_169_0: bool = false;
        // D s_169_1: write-var gs#397627 <= s_169_0
        fn_state.gs_397627 = s_169_0;
        // N s_169_2: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_170_0: read-var gs#397627:u8
        let s_170_0: bool = fn_state.gs_397627;
        // N s_170_1: branch s_170_0 b3217 b171
        if s_170_0 {
            return block_3217(state, tracer, fn_state);
        } else {
            return block_171(state, tracer, fn_state);
        };
    }
    fn block_171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_171_0: const #0u : u8
        let s_171_0: bool = false;
        // D s_171_1: write-var gs#397629 <= s_171_0
        fn_state.gs_397629 = s_171_0;
        // N s_171_2: jump b172
        return block_172(state, tracer, fn_state);
    }
    fn block_172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_172_0: read-var gs#397629:u8
        let s_172_0: bool = fn_state.gs_397629;
        // D s_172_1: not s_172_0
        let s_172_1: bool = !s_172_0;
        // N s_172_2: branch s_172_1 b174 b173
        if s_172_1 {
            return block_174(state, tracer, fn_state);
        } else {
            return block_173(state, tracer, fn_state);
        };
    }
    fn block_173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_173_0: const #3049s : i
        let s_173_0: i128 = 3049;
        // C s_173_1: const #14696u : u32
        let s_173_1: u32 = 14696;
        // N s_173_2: write-reg s_173_1 <= s_173_0
        let s_173_2: () = {
            state.write_register::<i128>(s_173_1 as isize, s_173_0);
            tracer.write_register(s_173_1 as isize, s_173_0);
        };
        // C s_173_3: const #23s : i
        let s_173_3: i128 = 23;
        // C s_173_4: const #1s : i
        let s_173_4: i128 = 1;
        // D s_173_5: read-var u#30564:u32
        let s_173_5: u32 = fn_state.u_30564;
        // D s_173_6: cast zx s_173_5 -> bv
        let s_173_6: Bits = Bits::new(s_173_5 as u128, 32u16);
        // D s_173_7: bit-extract s_173_6 s_173_3 s_173_4
        let s_173_7: Bits = (Bits::new(
            ((s_173_6) >> (s_173_3)).value(),
            u16::try_from(s_173_4).unwrap(),
        ));
        // D s_173_8: cast reint s_173_7 -> u8
        let s_173_8: bool = ((s_173_7.value()) != 0);
        // C s_173_9: const #22s : i
        let s_173_9: i128 = 22;
        // C s_173_10: const #1s : i
        let s_173_10: i128 = 1;
        // D s_173_11: read-var u#30564:u32
        let s_173_11: u32 = fn_state.u_30564;
        // D s_173_12: cast zx s_173_11 -> bv
        let s_173_12: Bits = Bits::new(s_173_11 as u128, 32u16);
        // D s_173_13: bit-extract s_173_12 s_173_9 s_173_10
        let s_173_13: Bits = (Bits::new(
            ((s_173_12) >> (s_173_9)).value(),
            u16::try_from(s_173_10).unwrap(),
        ));
        // D s_173_14: cast reint s_173_13 -> u8
        let s_173_14: bool = ((s_173_13.value()) != 0);
        // C s_173_15: const #16s : i
        let s_173_15: i128 = 16;
        // C s_173_16: const #4s : i
        let s_173_16: i128 = 4;
        // D s_173_17: read-var u#30564:u32
        let s_173_17: u32 = fn_state.u_30564;
        // D s_173_18: cast zx s_173_17 -> bv
        let s_173_18: Bits = Bits::new(s_173_17 as u128, 32u16);
        // D s_173_19: bit-extract s_173_18 s_173_15 s_173_16
        let s_173_19: Bits = (Bits::new(
            ((s_173_18) >> (s_173_15)).value(),
            u16::try_from(s_173_16).unwrap(),
        ));
        // D s_173_20: cast reint s_173_19 -> u8
        let s_173_20: u8 = (s_173_19.value() as u8);
        // C s_173_21: const #0s : i
        let s_173_21: i128 = 0;
        // C s_173_22: const #12s : i
        let s_173_22: i128 = 12;
        // D s_173_23: read-var u#30564:u32
        let s_173_23: u32 = fn_state.u_30564;
        // D s_173_24: cast zx s_173_23 -> bv
        let s_173_24: Bits = Bits::new(s_173_23 as u128, 32u16);
        // D s_173_25: bit-extract s_173_24 s_173_21 s_173_22
        let s_173_25: Bits = (Bits::new(
            ((s_173_24) >> (s_173_21)).value(),
            u16::try_from(s_173_22).unwrap(),
        ));
        // D s_173_26: cast reint s_173_25 -> u12
        let s_173_26: u16 = (s_173_25.value() as u16);
        // D s_173_27: call decode_aarch32_instrs_PLD_i_A1enc_A_txt(s_173_8, s_173_14, s_173_20, s_173_26)
        let s_173_27: () = decode_aarch32_instrs_PLD_i_A1enc_A_txt(
            state,
            tracer,
            s_173_8,
            s_173_14,
            s_173_20,
            s_173_26,
        );
        // N s_173_28: return
        return;
    }
    fn block_174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_174_0: read-var merge#var.1:struct
        let s_174_0: u32 = fn_state.merge_var._1;
        // D s_174_1: write-var u#30566 <= s_174_0
        fn_state.u_30566 = s_174_0;
        // C s_174_2: const #24s : i
        let s_174_2: i128 = 24;
        // D s_174_3: read-var u#30566:u32
        let s_174_3: u32 = fn_state.u_30566;
        // D s_174_4: cast zx s_174_3 -> bv
        let s_174_4: Bits = Bits::new(s_174_3 as u128, 32u16);
        // C s_174_5: const #1s : i64
        let s_174_5: i64 = 1;
        // C s_174_6: cast zx s_174_5 -> i
        let s_174_6: i128 = (i128::try_from(s_174_5).unwrap());
        // C s_174_7: const #7s : i
        let s_174_7: i128 = 7;
        // C s_174_8: add s_174_7 s_174_6
        let s_174_8: i128 = (s_174_7 + s_174_6);
        // D s_174_9: bit-extract s_174_4 s_174_2 s_174_8
        let s_174_9: Bits = (Bits::new(
            ((s_174_4) >> (s_174_2)).value(),
            u16::try_from(s_174_8).unwrap(),
        ));
        // D s_174_10: cast reint s_174_9 -> u8
        let s_174_10: u8 = (s_174_9.value() as u8);
        // D s_174_11: cast zx s_174_10 -> bv
        let s_174_11: Bits = Bits::new(s_174_10 as u128, 8u16);
        // C s_174_12: const #245u : u8
        let s_174_12: u8 = 245;
        // C s_174_13: cast zx s_174_12 -> bv
        let s_174_13: Bits = Bits::new(s_174_12 as u128, 8u16);
        // D s_174_14: cmp-eq s_174_11 s_174_13
        let s_174_14: bool = ((s_174_11) == (s_174_13));
        // N s_174_15: branch s_174_14 b3216 b175
        if s_174_14 {
            return block_3216(state, tracer, fn_state);
        } else {
            return block_175(state, tracer, fn_state);
        };
    }
    fn block_175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_175_0: const #0u : u8
        let s_175_0: bool = false;
        // D s_175_1: write-var gs#397645 <= s_175_0
        fn_state.gs_397645 = s_175_0;
        // N s_175_2: jump b176
        return block_176(state, tracer, fn_state);
    }
    fn block_176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_176_0: read-var gs#397645:u8
        let s_176_0: bool = fn_state.gs_397645;
        // N s_176_1: branch s_176_0 b3215 b177
        if s_176_0 {
            return block_3215(state, tracer, fn_state);
        } else {
            return block_177(state, tracer, fn_state);
        };
    }
    fn block_177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_177_0: const #0u : u8
        let s_177_0: bool = false;
        // D s_177_1: write-var gs#397647 <= s_177_0
        fn_state.gs_397647 = s_177_0;
        // N s_177_2: jump b178
        return block_178(state, tracer, fn_state);
    }
    fn block_178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_178_0: read-var gs#397647:u8
        let s_178_0: bool = fn_state.gs_397647;
        // D s_178_1: not s_178_0
        let s_178_1: bool = !s_178_0;
        // N s_178_2: branch s_178_1 b182 b179
        if s_178_1 {
            return block_182(state, tracer, fn_state);
        } else {
            return block_179(state, tracer, fn_state);
        };
    }
    fn block_179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_179_0: const #3052s : i
        let s_179_0: i128 = 3052;
        // C s_179_1: const #14696u : u32
        let s_179_1: u32 = 14696;
        // N s_179_2: write-reg s_179_1 <= s_179_0
        let s_179_2: () = {
            state.write_register::<i128>(s_179_1 as isize, s_179_0);
            tracer.write_register(s_179_1 as isize, s_179_0);
        };
        // C s_179_3: const #23s : i
        let s_179_3: i128 = 23;
        // C s_179_4: const #1s : i
        let s_179_4: i128 = 1;
        // D s_179_5: read-var u#30566:u32
        let s_179_5: u32 = fn_state.u_30566;
        // D s_179_6: cast zx s_179_5 -> bv
        let s_179_6: Bits = Bits::new(s_179_5 as u128, 32u16);
        // D s_179_7: bit-extract s_179_6 s_179_3 s_179_4
        let s_179_7: Bits = (Bits::new(
            ((s_179_6) >> (s_179_3)).value(),
            u16::try_from(s_179_4).unwrap(),
        ));
        // D s_179_8: cast reint s_179_7 -> u8
        let s_179_8: bool = ((s_179_7.value()) != 0);
        // D s_179_9: write-var u#30567 <= s_179_8
        fn_state.u_30567 = s_179_8;
        // C s_179_10: const #0s : i
        let s_179_10: i128 = 0;
        // C s_179_11: const #12s : i
        let s_179_11: i128 = 12;
        // D s_179_12: read-var u#30566:u32
        let s_179_12: u32 = fn_state.u_30566;
        // D s_179_13: cast zx s_179_12 -> bv
        let s_179_13: Bits = Bits::new(s_179_12 as u128, 32u16);
        // D s_179_14: bit-extract s_179_13 s_179_10 s_179_11
        let s_179_14: Bits = (Bits::new(
            ((s_179_13) >> (s_179_10)).value(),
            u16::try_from(s_179_11).unwrap(),
        ));
        // D s_179_15: cast reint s_179_14 -> u12
        let s_179_15: u16 = (s_179_14.value() as u16);
        // D s_179_16: write-var u#30568 <= s_179_15
        fn_state.u_30568 = s_179_15;
        // C s_179_17: const #22s : i
        let s_179_17: i128 = 22;
        // D s_179_18: read-var u#30566:u32
        let s_179_18: u32 = fn_state.u_30566;
        // D s_179_19: cast zx s_179_18 -> bv
        let s_179_19: Bits = Bits::new(s_179_18 as u128, 32u16);
        // C s_179_20: const #1u : u64
        let s_179_20: u64 = 1;
        // D s_179_21: bit-extract s_179_19 s_179_17 s_179_20
        let s_179_21: Bits = (Bits::new(
            ((s_179_19) >> (s_179_17)).value(),
            u16::try_from(s_179_20).unwrap(),
        ));
        // D s_179_22: cast reint s_179_21 -> u8
        let s_179_22: bool = ((s_179_21.value()) != 0);
        // C s_179_23: const #0s : i
        let s_179_23: i128 = 0;
        // C s_179_24: const #0u : u64
        let s_179_24: u64 = 0;
        // D s_179_25: cast zx s_179_22 -> u64
        let s_179_25: u64 = (s_179_22 as u64);
        // C s_179_26: const #1u : u64
        let s_179_26: u64 = 1;
        // D s_179_27: and s_179_25 s_179_26
        let s_179_27: u64 = ((s_179_25) & (s_179_26));
        // D s_179_28: cmp-eq s_179_27 s_179_26
        let s_179_28: bool = ((s_179_27) == (s_179_26));
        // D s_179_29: lsl s_179_25 s_179_23
        let s_179_29: u64 = s_179_25 << s_179_23;
        // D s_179_30: or s_179_24 s_179_29
        let s_179_30: u64 = ((s_179_24) | (s_179_29));
        // D s_179_31: cmpl s_179_29
        let s_179_31: u64 = !s_179_29;
        // D s_179_32: and s_179_24 s_179_31
        let s_179_32: u64 = ((s_179_24) & (s_179_31));
        // D s_179_33: select s_179_28 s_179_30 s_179_32
        let s_179_33: u64 = if s_179_28 { s_179_30 } else { s_179_32 };
        // D s_179_34: cast trunc s_179_33 -> u8
        let s_179_34: bool = ((s_179_33) != 0);
        // D s_179_35: cast zx s_179_34 -> bv
        let s_179_35: Bits = Bits::new(s_179_34 as u128, 1u16);
        // C s_179_36: const #1u : u8
        let s_179_36: bool = true;
        // C s_179_37: cast zx s_179_36 -> bv
        let s_179_37: Bits = Bits::new(s_179_36 as u128, 1u16);
        // D s_179_38: cmp-ne s_179_35 s_179_37
        let s_179_38: bool = ((s_179_35) != (s_179_37));
        // N s_179_39: branch s_179_38 b181 b180
        if s_179_38 {
            return block_181(state, tracer, fn_state);
        } else {
            return block_180(state, tracer, fn_state);
        };
    }
    fn block_180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_180_0: read-var u#30567:u8
        let s_180_0: bool = fn_state.u_30567;
        // D s_180_1: read-var u#30568:u12
        let s_180_1: u16 = fn_state.u_30568;
        // D s_180_2: call decode_aarch32_instrs_PLD_l_A1enc_A_txt(s_180_0, s_180_1)
        let s_180_2: () = decode_aarch32_instrs_PLD_l_A1enc_A_txt(
            state,
            tracer,
            s_180_0,
            s_180_1,
        );
        // N s_180_3: return
        return;
    }
    fn block_181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_181_0: panic
        panic!("{:?}", ());
        // N s_181_1: return
        return;
    }
    fn block_182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_182_0: read-var merge#var.1:struct
        let s_182_0: u32 = fn_state.merge_var._1;
        // D s_182_1: write-var u#30570 <= s_182_0
        fn_state.u_30570 = s_182_0;
        // C s_182_2: const #24s : i
        let s_182_2: i128 = 24;
        // D s_182_3: read-var u#30570:u32
        let s_182_3: u32 = fn_state.u_30570;
        // D s_182_4: cast zx s_182_3 -> bv
        let s_182_4: Bits = Bits::new(s_182_3 as u128, 32u16);
        // C s_182_5: const #1s : i64
        let s_182_5: i64 = 1;
        // C s_182_6: cast zx s_182_5 -> i
        let s_182_6: i128 = (i128::try_from(s_182_5).unwrap());
        // C s_182_7: const #7s : i
        let s_182_7: i128 = 7;
        // C s_182_8: add s_182_7 s_182_6
        let s_182_8: i128 = (s_182_7 + s_182_6);
        // D s_182_9: bit-extract s_182_4 s_182_2 s_182_8
        let s_182_9: Bits = (Bits::new(
            ((s_182_4) >> (s_182_2)).value(),
            u16::try_from(s_182_8).unwrap(),
        ));
        // D s_182_10: cast reint s_182_9 -> u8
        let s_182_10: u8 = (s_182_9.value() as u8);
        // D s_182_11: cast zx s_182_10 -> bv
        let s_182_11: Bits = Bits::new(s_182_10 as u128, 8u16);
        // C s_182_12: const #247u : u8
        let s_182_12: u8 = 247;
        // C s_182_13: cast zx s_182_12 -> bv
        let s_182_13: Bits = Bits::new(s_182_12 as u128, 8u16);
        // D s_182_14: cmp-eq s_182_11 s_182_13
        let s_182_14: bool = ((s_182_11) == (s_182_13));
        // N s_182_15: branch s_182_14 b3208 b183
        if s_182_14 {
            return block_3208(state, tracer, fn_state);
        } else {
            return block_183(state, tracer, fn_state);
        };
    }
    fn block_183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_183_0: const #0u : u8
        let s_183_0: bool = false;
        // D s_183_1: write-var gs#397667 <= s_183_0
        fn_state.gs_397667 = s_183_0;
        // N s_183_2: jump b184
        return block_184(state, tracer, fn_state);
    }
    fn block_184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_184_0: read-var gs#397667:u8
        let s_184_0: bool = fn_state.gs_397667;
        // N s_184_1: branch s_184_0 b3207 b185
        if s_184_0 {
            return block_3207(state, tracer, fn_state);
        } else {
            return block_185(state, tracer, fn_state);
        };
    }
    fn block_185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_185_0: const #0u : u8
        let s_185_0: bool = false;
        // D s_185_1: write-var gs#397669 <= s_185_0
        fn_state.gs_397669 = s_185_0;
        // N s_185_2: jump b186
        return block_186(state, tracer, fn_state);
    }
    fn block_186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_186_0: read-var gs#397669:u8
        let s_186_0: bool = fn_state.gs_397669;
        // D s_186_1: not s_186_0
        let s_186_1: bool = !s_186_0;
        // N s_186_2: branch s_186_1 b188 b187
        if s_186_1 {
            return block_188(state, tracer, fn_state);
        } else {
            return block_187(state, tracer, fn_state);
        };
    }
    fn block_187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_187_0: const #3054s : i
        let s_187_0: i128 = 3054;
        // C s_187_1: const #14696u : u32
        let s_187_1: u32 = 14696;
        // N s_187_2: write-reg s_187_1 <= s_187_0
        let s_187_2: () = {
            state.write_register::<i128>(s_187_1 as isize, s_187_0);
            tracer.write_register(s_187_1 as isize, s_187_0);
        };
        // C s_187_3: const #23s : i
        let s_187_3: i128 = 23;
        // C s_187_4: const #1s : i
        let s_187_4: i128 = 1;
        // D s_187_5: read-var u#30570:u32
        let s_187_5: u32 = fn_state.u_30570;
        // D s_187_6: cast zx s_187_5 -> bv
        let s_187_6: Bits = Bits::new(s_187_5 as u128, 32u16);
        // D s_187_7: bit-extract s_187_6 s_187_3 s_187_4
        let s_187_7: Bits = (Bits::new(
            ((s_187_6) >> (s_187_3)).value(),
            u16::try_from(s_187_4).unwrap(),
        ));
        // D s_187_8: cast reint s_187_7 -> u8
        let s_187_8: bool = ((s_187_7.value()) != 0);
        // C s_187_9: const #22s : i
        let s_187_9: i128 = 22;
        // C s_187_10: const #1s : i
        let s_187_10: i128 = 1;
        // D s_187_11: read-var u#30570:u32
        let s_187_11: u32 = fn_state.u_30570;
        // D s_187_12: cast zx s_187_11 -> bv
        let s_187_12: Bits = Bits::new(s_187_11 as u128, 32u16);
        // D s_187_13: bit-extract s_187_12 s_187_9 s_187_10
        let s_187_13: Bits = (Bits::new(
            ((s_187_12) >> (s_187_9)).value(),
            u16::try_from(s_187_10).unwrap(),
        ));
        // D s_187_14: cast reint s_187_13 -> u8
        let s_187_14: bool = ((s_187_13.value()) != 0);
        // C s_187_15: const #16s : i
        let s_187_15: i128 = 16;
        // C s_187_16: const #4s : i
        let s_187_16: i128 = 4;
        // D s_187_17: read-var u#30570:u32
        let s_187_17: u32 = fn_state.u_30570;
        // D s_187_18: cast zx s_187_17 -> bv
        let s_187_18: Bits = Bits::new(s_187_17 as u128, 32u16);
        // D s_187_19: bit-extract s_187_18 s_187_15 s_187_16
        let s_187_19: Bits = (Bits::new(
            ((s_187_18) >> (s_187_15)).value(),
            u16::try_from(s_187_16).unwrap(),
        ));
        // D s_187_20: cast reint s_187_19 -> u8
        let s_187_20: u8 = (s_187_19.value() as u8);
        // C s_187_21: const #7s : i
        let s_187_21: i128 = 7;
        // C s_187_22: const #5s : i
        let s_187_22: i128 = 5;
        // D s_187_23: read-var u#30570:u32
        let s_187_23: u32 = fn_state.u_30570;
        // D s_187_24: cast zx s_187_23 -> bv
        let s_187_24: Bits = Bits::new(s_187_23 as u128, 32u16);
        // D s_187_25: bit-extract s_187_24 s_187_21 s_187_22
        let s_187_25: Bits = (Bits::new(
            ((s_187_24) >> (s_187_21)).value(),
            u16::try_from(s_187_22).unwrap(),
        ));
        // D s_187_26: cast reint s_187_25 -> u8
        let s_187_26: u8 = (s_187_25.value() as u8);
        // C s_187_27: const #5s : i
        let s_187_27: i128 = 5;
        // C s_187_28: const #2s : i
        let s_187_28: i128 = 2;
        // D s_187_29: read-var u#30570:u32
        let s_187_29: u32 = fn_state.u_30570;
        // D s_187_30: cast zx s_187_29 -> bv
        let s_187_30: Bits = Bits::new(s_187_29 as u128, 32u16);
        // D s_187_31: bit-extract s_187_30 s_187_27 s_187_28
        let s_187_31: Bits = (Bits::new(
            ((s_187_30) >> (s_187_27)).value(),
            u16::try_from(s_187_28).unwrap(),
        ));
        // D s_187_32: cast reint s_187_31 -> u8
        let s_187_32: u8 = (s_187_31.value() as u8);
        // C s_187_33: const #0s : i
        let s_187_33: i128 = 0;
        // C s_187_34: const #4s : i
        let s_187_34: i128 = 4;
        // D s_187_35: read-var u#30570:u32
        let s_187_35: u32 = fn_state.u_30570;
        // D s_187_36: cast zx s_187_35 -> bv
        let s_187_36: Bits = Bits::new(s_187_35 as u128, 32u16);
        // D s_187_37: bit-extract s_187_36 s_187_33 s_187_34
        let s_187_37: Bits = (Bits::new(
            ((s_187_36) >> (s_187_33)).value(),
            u16::try_from(s_187_34).unwrap(),
        ));
        // D s_187_38: cast reint s_187_37 -> u8
        let s_187_38: u8 = (s_187_37.value() as u8);
        // D s_187_39: call decode_aarch32_instrs_PLD_r_A1enc_A_txt(s_187_8, s_187_14, s_187_20, s_187_26, s_187_32, s_187_38)
        let s_187_39: () = decode_aarch32_instrs_PLD_r_A1enc_A_txt(
            state,
            tracer,
            s_187_8,
            s_187_14,
            s_187_20,
            s_187_26,
            s_187_32,
            s_187_38,
        );
        // N s_187_40: return
        return;
    }
    fn block_188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_188_0: read-var merge#var.1:struct
        let s_188_0: u32 = fn_state.merge_var._1;
        // D s_188_1: write-var u#30575 <= s_188_0
        fn_state.u_30575 = s_188_0;
        // C s_188_2: const #24s : i
        let s_188_2: i128 = 24;
        // D s_188_3: read-var u#30575:u32
        let s_188_3: u32 = fn_state.u_30575;
        // D s_188_4: cast zx s_188_3 -> bv
        let s_188_4: Bits = Bits::new(s_188_3 as u128, 32u16);
        // C s_188_5: const #1s : i64
        let s_188_5: i64 = 1;
        // C s_188_6: cast zx s_188_5 -> i
        let s_188_6: i128 = (i128::try_from(s_188_5).unwrap());
        // C s_188_7: const #7s : i
        let s_188_7: i128 = 7;
        // C s_188_8: add s_188_7 s_188_6
        let s_188_8: i128 = (s_188_7 + s_188_6);
        // D s_188_9: bit-extract s_188_4 s_188_2 s_188_8
        let s_188_9: Bits = (Bits::new(
            ((s_188_4) >> (s_188_2)).value(),
            u16::try_from(s_188_8).unwrap(),
        ));
        // D s_188_10: cast reint s_188_9 -> u8
        let s_188_10: u8 = (s_188_9.value() as u8);
        // D s_188_11: cast zx s_188_10 -> bv
        let s_188_11: Bits = Bits::new(s_188_10 as u128, 8u16);
        // C s_188_12: const #244u : u8
        let s_188_12: u8 = 244;
        // C s_188_13: cast zx s_188_12 -> bv
        let s_188_13: Bits = Bits::new(s_188_12 as u128, 8u16);
        // D s_188_14: cmp-eq s_188_11 s_188_13
        let s_188_14: bool = ((s_188_11) == (s_188_13));
        // N s_188_15: branch s_188_14 b3203 b189
        if s_188_14 {
            return block_3203(state, tracer, fn_state);
        } else {
            return block_189(state, tracer, fn_state);
        };
    }
    fn block_189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_189_0: const #0u : u8
        let s_189_0: bool = false;
        // D s_189_1: write-var gs#397692 <= s_189_0
        fn_state.gs_397692 = s_189_0;
        // N s_189_2: jump b190
        return block_190(state, tracer, fn_state);
    }
    fn block_190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_190_0: read-var gs#397692:u8
        let s_190_0: bool = fn_state.gs_397692;
        // N s_190_1: branch s_190_0 b3202 b191
        if s_190_0 {
            return block_3202(state, tracer, fn_state);
        } else {
            return block_191(state, tracer, fn_state);
        };
    }
    fn block_191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_191_0: const #0u : u8
        let s_191_0: bool = false;
        // D s_191_1: write-var gs#397694 <= s_191_0
        fn_state.gs_397694 = s_191_0;
        // N s_191_2: jump b192
        return block_192(state, tracer, fn_state);
    }
    fn block_192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_192_0: read-var gs#397694:u8
        let s_192_0: bool = fn_state.gs_397694;
        // D s_192_1: not s_192_0
        let s_192_1: bool = !s_192_0;
        // N s_192_2: branch s_192_1 b194 b193
        if s_192_1 {
            return block_194(state, tracer, fn_state);
        } else {
            return block_193(state, tracer, fn_state);
        };
    }
    fn block_193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_193_0: const #3056s : i
        let s_193_0: i128 = 3056;
        // C s_193_1: const #14696u : u32
        let s_193_1: u32 = 14696;
        // N s_193_2: write-reg s_193_1 <= s_193_0
        let s_193_2: () = {
            state.write_register::<i128>(s_193_1 as isize, s_193_0);
            tracer.write_register(s_193_1 as isize, s_193_0);
        };
        // C s_193_3: const #23s : i
        let s_193_3: i128 = 23;
        // C s_193_4: const #1s : i
        let s_193_4: i128 = 1;
        // D s_193_5: read-var u#30575:u32
        let s_193_5: u32 = fn_state.u_30575;
        // D s_193_6: cast zx s_193_5 -> bv
        let s_193_6: Bits = Bits::new(s_193_5 as u128, 32u16);
        // D s_193_7: bit-extract s_193_6 s_193_3 s_193_4
        let s_193_7: Bits = (Bits::new(
            ((s_193_6) >> (s_193_3)).value(),
            u16::try_from(s_193_4).unwrap(),
        ));
        // D s_193_8: cast reint s_193_7 -> u8
        let s_193_8: bool = ((s_193_7.value()) != 0);
        // C s_193_9: const #16s : i
        let s_193_9: i128 = 16;
        // C s_193_10: const #4s : i
        let s_193_10: i128 = 4;
        // D s_193_11: read-var u#30575:u32
        let s_193_11: u32 = fn_state.u_30575;
        // D s_193_12: cast zx s_193_11 -> bv
        let s_193_12: Bits = Bits::new(s_193_11 as u128, 32u16);
        // D s_193_13: bit-extract s_193_12 s_193_9 s_193_10
        let s_193_13: Bits = (Bits::new(
            ((s_193_12) >> (s_193_9)).value(),
            u16::try_from(s_193_10).unwrap(),
        ));
        // D s_193_14: cast reint s_193_13 -> u8
        let s_193_14: u8 = (s_193_13.value() as u8);
        // C s_193_15: const #0s : i
        let s_193_15: i128 = 0;
        // C s_193_16: const #12s : i
        let s_193_16: i128 = 12;
        // D s_193_17: read-var u#30575:u32
        let s_193_17: u32 = fn_state.u_30575;
        // D s_193_18: cast zx s_193_17 -> bv
        let s_193_18: Bits = Bits::new(s_193_17 as u128, 32u16);
        // D s_193_19: bit-extract s_193_18 s_193_15 s_193_16
        let s_193_19: Bits = (Bits::new(
            ((s_193_18) >> (s_193_15)).value(),
            u16::try_from(s_193_16).unwrap(),
        ));
        // D s_193_20: cast reint s_193_19 -> u12
        let s_193_20: u16 = (s_193_19.value() as u16);
        // D s_193_21: call decode_aarch32_instrs_PLI_i_A1enc_A_txt(s_193_8, s_193_14, s_193_20)
        let s_193_21: () = decode_aarch32_instrs_PLI_i_A1enc_A_txt(
            state,
            tracer,
            s_193_8,
            s_193_14,
            s_193_20,
        );
        // N s_193_22: return
        return;
    }
    fn block_194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_194_0: read-var merge#var.1:struct
        let s_194_0: u32 = fn_state.merge_var._1;
        // D s_194_1: write-var u#30580 <= s_194_0
        fn_state.u_30580 = s_194_0;
        // C s_194_2: const #24s : i
        let s_194_2: i128 = 24;
        // D s_194_3: read-var u#30580:u32
        let s_194_3: u32 = fn_state.u_30580;
        // D s_194_4: cast zx s_194_3 -> bv
        let s_194_4: Bits = Bits::new(s_194_3 as u128, 32u16);
        // C s_194_5: const #1s : i64
        let s_194_5: i64 = 1;
        // C s_194_6: cast zx s_194_5 -> i
        let s_194_6: i128 = (i128::try_from(s_194_5).unwrap());
        // C s_194_7: const #7s : i
        let s_194_7: i128 = 7;
        // C s_194_8: add s_194_7 s_194_6
        let s_194_8: i128 = (s_194_7 + s_194_6);
        // D s_194_9: bit-extract s_194_4 s_194_2 s_194_8
        let s_194_9: Bits = (Bits::new(
            ((s_194_4) >> (s_194_2)).value(),
            u16::try_from(s_194_8).unwrap(),
        ));
        // D s_194_10: cast reint s_194_9 -> u8
        let s_194_10: u8 = (s_194_9.value() as u8);
        // D s_194_11: cast zx s_194_10 -> bv
        let s_194_11: Bits = Bits::new(s_194_10 as u128, 8u16);
        // C s_194_12: const #246u : u8
        let s_194_12: u8 = 246;
        // C s_194_13: cast zx s_194_12 -> bv
        let s_194_13: Bits = Bits::new(s_194_12 as u128, 8u16);
        // D s_194_14: cmp-eq s_194_11 s_194_13
        let s_194_14: bool = ((s_194_11) == (s_194_13));
        // N s_194_15: branch s_194_14 b3195 b195
        if s_194_14 {
            return block_3195(state, tracer, fn_state);
        } else {
            return block_195(state, tracer, fn_state);
        };
    }
    fn block_195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_195_0: const #0u : u8
        let s_195_0: bool = false;
        // D s_195_1: write-var gs#397714 <= s_195_0
        fn_state.gs_397714 = s_195_0;
        // N s_195_2: jump b196
        return block_196(state, tracer, fn_state);
    }
    fn block_196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_196_0: read-var gs#397714:u8
        let s_196_0: bool = fn_state.gs_397714;
        // N s_196_1: branch s_196_0 b3194 b197
        if s_196_0 {
            return block_3194(state, tracer, fn_state);
        } else {
            return block_197(state, tracer, fn_state);
        };
    }
    fn block_197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_197_0: const #0u : u8
        let s_197_0: bool = false;
        // D s_197_1: write-var gs#397716 <= s_197_0
        fn_state.gs_397716 = s_197_0;
        // N s_197_2: jump b198
        return block_198(state, tracer, fn_state);
    }
    fn block_198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_198_0: read-var gs#397716:u8
        let s_198_0: bool = fn_state.gs_397716;
        // D s_198_1: not s_198_0
        let s_198_1: bool = !s_198_0;
        // N s_198_2: branch s_198_1 b200 b199
        if s_198_1 {
            return block_200(state, tracer, fn_state);
        } else {
            return block_199(state, tracer, fn_state);
        };
    }
    fn block_199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_199_0: const #3060s : i
        let s_199_0: i128 = 3060;
        // C s_199_1: const #14696u : u32
        let s_199_1: u32 = 14696;
        // N s_199_2: write-reg s_199_1 <= s_199_0
        let s_199_2: () = {
            state.write_register::<i128>(s_199_1 as isize, s_199_0);
            tracer.write_register(s_199_1 as isize, s_199_0);
        };
        // C s_199_3: const #23s : i
        let s_199_3: i128 = 23;
        // C s_199_4: const #1s : i
        let s_199_4: i128 = 1;
        // D s_199_5: read-var u#30580:u32
        let s_199_5: u32 = fn_state.u_30580;
        // D s_199_6: cast zx s_199_5 -> bv
        let s_199_6: Bits = Bits::new(s_199_5 as u128, 32u16);
        // D s_199_7: bit-extract s_199_6 s_199_3 s_199_4
        let s_199_7: Bits = (Bits::new(
            ((s_199_6) >> (s_199_3)).value(),
            u16::try_from(s_199_4).unwrap(),
        ));
        // D s_199_8: cast reint s_199_7 -> u8
        let s_199_8: bool = ((s_199_7.value()) != 0);
        // C s_199_9: const #16s : i
        let s_199_9: i128 = 16;
        // C s_199_10: const #4s : i
        let s_199_10: i128 = 4;
        // D s_199_11: read-var u#30580:u32
        let s_199_11: u32 = fn_state.u_30580;
        // D s_199_12: cast zx s_199_11 -> bv
        let s_199_12: Bits = Bits::new(s_199_11 as u128, 32u16);
        // D s_199_13: bit-extract s_199_12 s_199_9 s_199_10
        let s_199_13: Bits = (Bits::new(
            ((s_199_12) >> (s_199_9)).value(),
            u16::try_from(s_199_10).unwrap(),
        ));
        // D s_199_14: cast reint s_199_13 -> u8
        let s_199_14: u8 = (s_199_13.value() as u8);
        // C s_199_15: const #7s : i
        let s_199_15: i128 = 7;
        // C s_199_16: const #5s : i
        let s_199_16: i128 = 5;
        // D s_199_17: read-var u#30580:u32
        let s_199_17: u32 = fn_state.u_30580;
        // D s_199_18: cast zx s_199_17 -> bv
        let s_199_18: Bits = Bits::new(s_199_17 as u128, 32u16);
        // D s_199_19: bit-extract s_199_18 s_199_15 s_199_16
        let s_199_19: Bits = (Bits::new(
            ((s_199_18) >> (s_199_15)).value(),
            u16::try_from(s_199_16).unwrap(),
        ));
        // D s_199_20: cast reint s_199_19 -> u8
        let s_199_20: u8 = (s_199_19.value() as u8);
        // C s_199_21: const #5s : i
        let s_199_21: i128 = 5;
        // C s_199_22: const #2s : i
        let s_199_22: i128 = 2;
        // D s_199_23: read-var u#30580:u32
        let s_199_23: u32 = fn_state.u_30580;
        // D s_199_24: cast zx s_199_23 -> bv
        let s_199_24: Bits = Bits::new(s_199_23 as u128, 32u16);
        // D s_199_25: bit-extract s_199_24 s_199_21 s_199_22
        let s_199_25: Bits = (Bits::new(
            ((s_199_24) >> (s_199_21)).value(),
            u16::try_from(s_199_22).unwrap(),
        ));
        // D s_199_26: cast reint s_199_25 -> u8
        let s_199_26: u8 = (s_199_25.value() as u8);
        // C s_199_27: const #0s : i
        let s_199_27: i128 = 0;
        // C s_199_28: const #4s : i
        let s_199_28: i128 = 4;
        // D s_199_29: read-var u#30580:u32
        let s_199_29: u32 = fn_state.u_30580;
        // D s_199_30: cast zx s_199_29 -> bv
        let s_199_30: Bits = Bits::new(s_199_29 as u128, 32u16);
        // D s_199_31: bit-extract s_199_30 s_199_27 s_199_28
        let s_199_31: Bits = (Bits::new(
            ((s_199_30) >> (s_199_27)).value(),
            u16::try_from(s_199_28).unwrap(),
        ));
        // D s_199_32: cast reint s_199_31 -> u8
        let s_199_32: u8 = (s_199_31.value() as u8);
        // D s_199_33: call decode_aarch32_instrs_PLI_r_A1enc_A_txt(s_199_8, s_199_14, s_199_20, s_199_26, s_199_32)
        let s_199_33: () = decode_aarch32_instrs_PLI_r_A1enc_A_txt(
            state,
            tracer,
            s_199_8,
            s_199_14,
            s_199_20,
            s_199_26,
            s_199_32,
        );
        // N s_199_34: return
        return;
    }
    fn block_200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_200_0: read-var merge#var.1:struct
        let s_200_0: u32 = fn_state.merge_var._1;
        // D s_200_1: write-var u#30587 <= s_200_0
        fn_state.u_30587 = s_200_0;
        // D s_200_2: read-var u#30587:u32
        let s_200_2: u32 = fn_state.u_30587;
        // D s_200_3: cast zx s_200_2 -> bv
        let s_200_3: Bits = Bits::new(s_200_2 as u128, 32u16);
        // C s_200_4: const #4118802544u : u32
        let s_200_4: u32 = 4118802544;
        // C s_200_5: cast zx s_200_4 -> bv
        let s_200_5: Bits = Bits::new(s_200_4 as u128, 32u16);
        // D s_200_6: cmp-eq s_200_3 s_200_5
        let s_200_6: bool = ((s_200_3) == (s_200_5));
        // N s_200_7: branch s_200_6 b3193 b201
        if s_200_6 {
            return block_3193(state, tracer, fn_state);
        } else {
            return block_201(state, tracer, fn_state);
        };
    }
    fn block_201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_201_0: const #0u : u8
        let s_201_0: bool = false;
        // D s_201_1: write-var gs#397731 <= s_201_0
        fn_state.gs_397731 = s_201_0;
        // N s_201_2: jump b202
        return block_202(state, tracer, fn_state);
    }
    fn block_202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_202_0: read-var gs#397731:u8
        let s_202_0: bool = fn_state.gs_397731;
        // D s_202_1: not s_202_0
        let s_202_1: bool = !s_202_0;
        // N s_202_2: branch s_202_1 b251 b203
        if s_202_1 {
            return block_251(state, tracer, fn_state);
        } else {
            return block_203(state, tracer, fn_state);
        };
    }
    fn block_203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_203_0: const #3111s : i
        let s_203_0: i128 = 3111;
        // C s_203_1: const #14696u : u32
        let s_203_1: u32 = 14696;
        // N s_203_2: write-reg s_203_1 <= s_203_0
        let s_203_2: () = {
            state.write_register::<i128>(s_203_1 as isize, s_203_0);
            tracer.write_register(s_203_1 as isize, s_203_0);
        };
        // C s_203_3: const #16s : i
        let s_203_3: i128 = 16;
        // D s_203_4: read-var u#30587:u32
        let s_203_4: u32 = fn_state.u_30587;
        // D s_203_5: cast zx s_203_4 -> bv
        let s_203_5: Bits = Bits::new(s_203_4 as u128, 32u16);
        // C s_203_6: const #1u : u64
        let s_203_6: u64 = 1;
        // D s_203_7: bit-extract s_203_5 s_203_3 s_203_6
        let s_203_7: Bits = (Bits::new(
            ((s_203_5) >> (s_203_3)).value(),
            u16::try_from(s_203_6).unwrap(),
        ));
        // D s_203_8: cast reint s_203_7 -> u8
        let s_203_8: bool = ((s_203_7.value()) != 0);
        // C s_203_9: const #0s : i
        let s_203_9: i128 = 0;
        // C s_203_10: const #0u : u64
        let s_203_10: u64 = 0;
        // D s_203_11: cast zx s_203_8 -> u64
        let s_203_11: u64 = (s_203_8 as u64);
        // C s_203_12: const #1u : u64
        let s_203_12: u64 = 1;
        // D s_203_13: and s_203_11 s_203_12
        let s_203_13: u64 = ((s_203_11) & (s_203_12));
        // D s_203_14: cmp-eq s_203_13 s_203_12
        let s_203_14: bool = ((s_203_13) == (s_203_12));
        // D s_203_15: lsl s_203_11 s_203_9
        let s_203_15: u64 = s_203_11 << s_203_9;
        // D s_203_16: or s_203_10 s_203_15
        let s_203_16: u64 = ((s_203_10) | (s_203_15));
        // D s_203_17: cmpl s_203_15
        let s_203_17: u64 = !s_203_15;
        // D s_203_18: and s_203_10 s_203_17
        let s_203_18: u64 = ((s_203_10) & (s_203_17));
        // D s_203_19: select s_203_14 s_203_16 s_203_18
        let s_203_19: u64 = if s_203_14 { s_203_16 } else { s_203_18 };
        // D s_203_20: cast trunc s_203_19 -> u8
        let s_203_20: bool = ((s_203_19) != 0);
        // D s_203_21: cast zx s_203_20 -> bv
        let s_203_21: Bits = Bits::new(s_203_20 as u128, 1u16);
        // C s_203_22: const #1u : u8
        let s_203_22: bool = true;
        // C s_203_23: cast zx s_203_22 -> bv
        let s_203_23: Bits = Bits::new(s_203_22 as u128, 1u16);
        // D s_203_24: cmp-ne s_203_21 s_203_23
        let s_203_24: bool = ((s_203_21) != (s_203_23));
        // N s_203_25: branch s_203_24 b250 b204
        if s_203_24 {
            return block_250(state, tracer, fn_state);
        } else {
            return block_204(state, tracer, fn_state);
        };
    }
    fn block_204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_204_0: const #17s : i
        let s_204_0: i128 = 17;
        // D s_204_1: read-var u#30587:u32
        let s_204_1: u32 = fn_state.u_30587;
        // D s_204_2: cast zx s_204_1 -> bv
        let s_204_2: Bits = Bits::new(s_204_1 as u128, 32u16);
        // C s_204_3: const #1u : u64
        let s_204_3: u64 = 1;
        // D s_204_4: bit-extract s_204_2 s_204_0 s_204_3
        let s_204_4: Bits = (Bits::new(
            ((s_204_2) >> (s_204_0)).value(),
            u16::try_from(s_204_3).unwrap(),
        ));
        // D s_204_5: cast reint s_204_4 -> u8
        let s_204_5: bool = ((s_204_4.value()) != 0);
        // C s_204_6: const #0s : i
        let s_204_6: i128 = 0;
        // C s_204_7: const #0u : u64
        let s_204_7: u64 = 0;
        // D s_204_8: cast zx s_204_5 -> u64
        let s_204_8: u64 = (s_204_5 as u64);
        // C s_204_9: const #1u : u64
        let s_204_9: u64 = 1;
        // D s_204_10: and s_204_8 s_204_9
        let s_204_10: u64 = ((s_204_8) & (s_204_9));
        // D s_204_11: cmp-eq s_204_10 s_204_9
        let s_204_11: bool = ((s_204_10) == (s_204_9));
        // D s_204_12: lsl s_204_8 s_204_6
        let s_204_12: u64 = s_204_8 << s_204_6;
        // D s_204_13: or s_204_7 s_204_12
        let s_204_13: u64 = ((s_204_7) | (s_204_12));
        // D s_204_14: cmpl s_204_12
        let s_204_14: u64 = !s_204_12;
        // D s_204_15: and s_204_7 s_204_14
        let s_204_15: u64 = ((s_204_7) & (s_204_14));
        // D s_204_16: select s_204_11 s_204_13 s_204_15
        let s_204_16: u64 = if s_204_11 { s_204_13 } else { s_204_15 };
        // D s_204_17: cast trunc s_204_16 -> u8
        let s_204_17: bool = ((s_204_16) != 0);
        // D s_204_18: cast zx s_204_17 -> bv
        let s_204_18: Bits = Bits::new(s_204_17 as u128, 1u16);
        // C s_204_19: const #1u : u8
        let s_204_19: bool = true;
        // C s_204_20: cast zx s_204_19 -> bv
        let s_204_20: Bits = Bits::new(s_204_19 as u128, 1u16);
        // D s_204_21: cmp-ne s_204_18 s_204_20
        let s_204_21: bool = ((s_204_18) != (s_204_20));
        // D s_204_22: write-var gs#397738 <= s_204_21
        fn_state.gs_397738 = s_204_21;
        // N s_204_23: jump b205
        return block_205(state, tracer, fn_state);
    }
    fn block_205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_205_0: read-var gs#397738:u8
        let s_205_0: bool = fn_state.gs_397738;
        // N s_205_1: branch s_205_0 b249 b206
        if s_205_0 {
            return block_249(state, tracer, fn_state);
        } else {
            return block_206(state, tracer, fn_state);
        };
    }
    fn block_206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_206_0: const #18s : i
        let s_206_0: i128 = 18;
        // D s_206_1: read-var u#30587:u32
        let s_206_1: u32 = fn_state.u_30587;
        // D s_206_2: cast zx s_206_1 -> bv
        let s_206_2: Bits = Bits::new(s_206_1 as u128, 32u16);
        // C s_206_3: const #1u : u64
        let s_206_3: u64 = 1;
        // D s_206_4: bit-extract s_206_2 s_206_0 s_206_3
        let s_206_4: Bits = (Bits::new(
            ((s_206_2) >> (s_206_0)).value(),
            u16::try_from(s_206_3).unwrap(),
        ));
        // D s_206_5: cast reint s_206_4 -> u8
        let s_206_5: bool = ((s_206_4.value()) != 0);
        // C s_206_6: const #0s : i
        let s_206_6: i128 = 0;
        // C s_206_7: const #0u : u64
        let s_206_7: u64 = 0;
        // D s_206_8: cast zx s_206_5 -> u64
        let s_206_8: u64 = (s_206_5 as u64);
        // C s_206_9: const #1u : u64
        let s_206_9: u64 = 1;
        // D s_206_10: and s_206_8 s_206_9
        let s_206_10: u64 = ((s_206_8) & (s_206_9));
        // D s_206_11: cmp-eq s_206_10 s_206_9
        let s_206_11: bool = ((s_206_10) == (s_206_9));
        // D s_206_12: lsl s_206_8 s_206_6
        let s_206_12: u64 = s_206_8 << s_206_6;
        // D s_206_13: or s_206_7 s_206_12
        let s_206_13: u64 = ((s_206_7) | (s_206_12));
        // D s_206_14: cmpl s_206_12
        let s_206_14: u64 = !s_206_12;
        // D s_206_15: and s_206_7 s_206_14
        let s_206_15: u64 = ((s_206_7) & (s_206_14));
        // D s_206_16: select s_206_11 s_206_13 s_206_15
        let s_206_16: u64 = if s_206_11 { s_206_13 } else { s_206_15 };
        // D s_206_17: cast trunc s_206_16 -> u8
        let s_206_17: bool = ((s_206_16) != 0);
        // D s_206_18: cast zx s_206_17 -> bv
        let s_206_18: Bits = Bits::new(s_206_17 as u128, 1u16);
        // C s_206_19: const #1u : u8
        let s_206_19: bool = true;
        // C s_206_20: cast zx s_206_19 -> bv
        let s_206_20: Bits = Bits::new(s_206_19 as u128, 1u16);
        // D s_206_21: cmp-ne s_206_18 s_206_20
        let s_206_21: bool = ((s_206_18) != (s_206_20));
        // D s_206_22: write-var gs#397741 <= s_206_21
        fn_state.gs_397741 = s_206_21;
        // N s_206_23: jump b207
        return block_207(state, tracer, fn_state);
    }
    fn block_207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_207_0: read-var gs#397741:u8
        let s_207_0: bool = fn_state.gs_397741;
        // N s_207_1: branch s_207_0 b248 b208
        if s_207_0 {
            return block_248(state, tracer, fn_state);
        } else {
            return block_208(state, tracer, fn_state);
        };
    }
    fn block_208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_208_0: const #19s : i
        let s_208_0: i128 = 19;
        // D s_208_1: read-var u#30587:u32
        let s_208_1: u32 = fn_state.u_30587;
        // D s_208_2: cast zx s_208_1 -> bv
        let s_208_2: Bits = Bits::new(s_208_1 as u128, 32u16);
        // C s_208_3: const #1u : u64
        let s_208_3: u64 = 1;
        // D s_208_4: bit-extract s_208_2 s_208_0 s_208_3
        let s_208_4: Bits = (Bits::new(
            ((s_208_2) >> (s_208_0)).value(),
            u16::try_from(s_208_3).unwrap(),
        ));
        // D s_208_5: cast reint s_208_4 -> u8
        let s_208_5: bool = ((s_208_4.value()) != 0);
        // C s_208_6: const #0s : i
        let s_208_6: i128 = 0;
        // C s_208_7: const #0u : u64
        let s_208_7: u64 = 0;
        // D s_208_8: cast zx s_208_5 -> u64
        let s_208_8: u64 = (s_208_5 as u64);
        // C s_208_9: const #1u : u64
        let s_208_9: u64 = 1;
        // D s_208_10: and s_208_8 s_208_9
        let s_208_10: u64 = ((s_208_8) & (s_208_9));
        // D s_208_11: cmp-eq s_208_10 s_208_9
        let s_208_11: bool = ((s_208_10) == (s_208_9));
        // D s_208_12: lsl s_208_8 s_208_6
        let s_208_12: u64 = s_208_8 << s_208_6;
        // D s_208_13: or s_208_7 s_208_12
        let s_208_13: u64 = ((s_208_7) | (s_208_12));
        // D s_208_14: cmpl s_208_12
        let s_208_14: u64 = !s_208_12;
        // D s_208_15: and s_208_7 s_208_14
        let s_208_15: u64 = ((s_208_7) & (s_208_14));
        // D s_208_16: select s_208_11 s_208_13 s_208_15
        let s_208_16: u64 = if s_208_11 { s_208_13 } else { s_208_15 };
        // D s_208_17: cast trunc s_208_16 -> u8
        let s_208_17: bool = ((s_208_16) != 0);
        // D s_208_18: cast zx s_208_17 -> bv
        let s_208_18: Bits = Bits::new(s_208_17 as u128, 1u16);
        // C s_208_19: const #1u : u8
        let s_208_19: bool = true;
        // C s_208_20: cast zx s_208_19 -> bv
        let s_208_20: Bits = Bits::new(s_208_19 as u128, 1u16);
        // D s_208_21: cmp-ne s_208_18 s_208_20
        let s_208_21: bool = ((s_208_18) != (s_208_20));
        // D s_208_22: write-var gs#397744 <= s_208_21
        fn_state.gs_397744 = s_208_21;
        // N s_208_23: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_209_0: read-var gs#397744:u8
        let s_209_0: bool = fn_state.gs_397744;
        // N s_209_1: branch s_209_0 b247 b210
        if s_209_0 {
            return block_247(state, tracer, fn_state);
        } else {
            return block_210(state, tracer, fn_state);
        };
    }
    fn block_210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_210_0: const #12s : i
        let s_210_0: i128 = 12;
        // D s_210_1: read-var u#30587:u32
        let s_210_1: u32 = fn_state.u_30587;
        // D s_210_2: cast zx s_210_1 -> bv
        let s_210_2: Bits = Bits::new(s_210_1 as u128, 32u16);
        // C s_210_3: const #1u : u64
        let s_210_3: u64 = 1;
        // D s_210_4: bit-extract s_210_2 s_210_0 s_210_3
        let s_210_4: Bits = (Bits::new(
            ((s_210_2) >> (s_210_0)).value(),
            u16::try_from(s_210_3).unwrap(),
        ));
        // D s_210_5: cast reint s_210_4 -> u8
        let s_210_5: bool = ((s_210_4.value()) != 0);
        // C s_210_6: const #0s : i
        let s_210_6: i128 = 0;
        // C s_210_7: const #0u : u64
        let s_210_7: u64 = 0;
        // D s_210_8: cast zx s_210_5 -> u64
        let s_210_8: u64 = (s_210_5 as u64);
        // C s_210_9: const #1u : u64
        let s_210_9: u64 = 1;
        // D s_210_10: and s_210_8 s_210_9
        let s_210_10: u64 = ((s_210_8) & (s_210_9));
        // D s_210_11: cmp-eq s_210_10 s_210_9
        let s_210_11: bool = ((s_210_10) == (s_210_9));
        // D s_210_12: lsl s_210_8 s_210_6
        let s_210_12: u64 = s_210_8 << s_210_6;
        // D s_210_13: or s_210_7 s_210_12
        let s_210_13: u64 = ((s_210_7) | (s_210_12));
        // D s_210_14: cmpl s_210_12
        let s_210_14: u64 = !s_210_12;
        // D s_210_15: and s_210_7 s_210_14
        let s_210_15: u64 = ((s_210_7) & (s_210_14));
        // D s_210_16: select s_210_11 s_210_13 s_210_15
        let s_210_16: u64 = if s_210_11 { s_210_13 } else { s_210_15 };
        // D s_210_17: cast trunc s_210_16 -> u8
        let s_210_17: bool = ((s_210_16) != 0);
        // D s_210_18: cast zx s_210_17 -> bv
        let s_210_18: Bits = Bits::new(s_210_17 as u128, 1u16);
        // C s_210_19: const #1u : u8
        let s_210_19: bool = true;
        // C s_210_20: cast zx s_210_19 -> bv
        let s_210_20: Bits = Bits::new(s_210_19 as u128, 1u16);
        // D s_210_21: cmp-ne s_210_18 s_210_20
        let s_210_21: bool = ((s_210_18) != (s_210_20));
        // D s_210_22: write-var gs#397747 <= s_210_21
        fn_state.gs_397747 = s_210_21;
        // N s_210_23: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_211_0: read-var gs#397747:u8
        let s_211_0: bool = fn_state.gs_397747;
        // N s_211_1: branch s_211_0 b246 b212
        if s_211_0 {
            return block_246(state, tracer, fn_state);
        } else {
            return block_212(state, tracer, fn_state);
        };
    }
    fn block_212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_212_0: const #13s : i
        let s_212_0: i128 = 13;
        // D s_212_1: read-var u#30587:u32
        let s_212_1: u32 = fn_state.u_30587;
        // D s_212_2: cast zx s_212_1 -> bv
        let s_212_2: Bits = Bits::new(s_212_1 as u128, 32u16);
        // C s_212_3: const #1u : u64
        let s_212_3: u64 = 1;
        // D s_212_4: bit-extract s_212_2 s_212_0 s_212_3
        let s_212_4: Bits = (Bits::new(
            ((s_212_2) >> (s_212_0)).value(),
            u16::try_from(s_212_3).unwrap(),
        ));
        // D s_212_5: cast reint s_212_4 -> u8
        let s_212_5: bool = ((s_212_4.value()) != 0);
        // C s_212_6: const #0s : i
        let s_212_6: i128 = 0;
        // C s_212_7: const #0u : u64
        let s_212_7: u64 = 0;
        // D s_212_8: cast zx s_212_5 -> u64
        let s_212_8: u64 = (s_212_5 as u64);
        // C s_212_9: const #1u : u64
        let s_212_9: u64 = 1;
        // D s_212_10: and s_212_8 s_212_9
        let s_212_10: u64 = ((s_212_8) & (s_212_9));
        // D s_212_11: cmp-eq s_212_10 s_212_9
        let s_212_11: bool = ((s_212_10) == (s_212_9));
        // D s_212_12: lsl s_212_8 s_212_6
        let s_212_12: u64 = s_212_8 << s_212_6;
        // D s_212_13: or s_212_7 s_212_12
        let s_212_13: u64 = ((s_212_7) | (s_212_12));
        // D s_212_14: cmpl s_212_12
        let s_212_14: u64 = !s_212_12;
        // D s_212_15: and s_212_7 s_212_14
        let s_212_15: u64 = ((s_212_7) & (s_212_14));
        // D s_212_16: select s_212_11 s_212_13 s_212_15
        let s_212_16: u64 = if s_212_11 { s_212_13 } else { s_212_15 };
        // D s_212_17: cast trunc s_212_16 -> u8
        let s_212_17: bool = ((s_212_16) != 0);
        // D s_212_18: cast zx s_212_17 -> bv
        let s_212_18: Bits = Bits::new(s_212_17 as u128, 1u16);
        // C s_212_19: const #1u : u8
        let s_212_19: bool = true;
        // C s_212_20: cast zx s_212_19 -> bv
        let s_212_20: Bits = Bits::new(s_212_19 as u128, 1u16);
        // D s_212_21: cmp-ne s_212_18 s_212_20
        let s_212_21: bool = ((s_212_18) != (s_212_20));
        // D s_212_22: write-var gs#397750 <= s_212_21
        fn_state.gs_397750 = s_212_21;
        // N s_212_23: jump b213
        return block_213(state, tracer, fn_state);
    }
    fn block_213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_213_0: read-var gs#397750:u8
        let s_213_0: bool = fn_state.gs_397750;
        // N s_213_1: branch s_213_0 b245 b214
        if s_213_0 {
            return block_245(state, tracer, fn_state);
        } else {
            return block_214(state, tracer, fn_state);
        };
    }
    fn block_214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_214_0: const #14s : i
        let s_214_0: i128 = 14;
        // D s_214_1: read-var u#30587:u32
        let s_214_1: u32 = fn_state.u_30587;
        // D s_214_2: cast zx s_214_1 -> bv
        let s_214_2: Bits = Bits::new(s_214_1 as u128, 32u16);
        // C s_214_3: const #1u : u64
        let s_214_3: u64 = 1;
        // D s_214_4: bit-extract s_214_2 s_214_0 s_214_3
        let s_214_4: Bits = (Bits::new(
            ((s_214_2) >> (s_214_0)).value(),
            u16::try_from(s_214_3).unwrap(),
        ));
        // D s_214_5: cast reint s_214_4 -> u8
        let s_214_5: bool = ((s_214_4.value()) != 0);
        // C s_214_6: const #0s : i
        let s_214_6: i128 = 0;
        // C s_214_7: const #0u : u64
        let s_214_7: u64 = 0;
        // D s_214_8: cast zx s_214_5 -> u64
        let s_214_8: u64 = (s_214_5 as u64);
        // C s_214_9: const #1u : u64
        let s_214_9: u64 = 1;
        // D s_214_10: and s_214_8 s_214_9
        let s_214_10: u64 = ((s_214_8) & (s_214_9));
        // D s_214_11: cmp-eq s_214_10 s_214_9
        let s_214_11: bool = ((s_214_10) == (s_214_9));
        // D s_214_12: lsl s_214_8 s_214_6
        let s_214_12: u64 = s_214_8 << s_214_6;
        // D s_214_13: or s_214_7 s_214_12
        let s_214_13: u64 = ((s_214_7) | (s_214_12));
        // D s_214_14: cmpl s_214_12
        let s_214_14: u64 = !s_214_12;
        // D s_214_15: and s_214_7 s_214_14
        let s_214_15: u64 = ((s_214_7) & (s_214_14));
        // D s_214_16: select s_214_11 s_214_13 s_214_15
        let s_214_16: u64 = if s_214_11 { s_214_13 } else { s_214_15 };
        // D s_214_17: cast trunc s_214_16 -> u8
        let s_214_17: bool = ((s_214_16) != 0);
        // D s_214_18: cast zx s_214_17 -> bv
        let s_214_18: Bits = Bits::new(s_214_17 as u128, 1u16);
        // C s_214_19: const #1u : u8
        let s_214_19: bool = true;
        // C s_214_20: cast zx s_214_19 -> bv
        let s_214_20: Bits = Bits::new(s_214_19 as u128, 1u16);
        // D s_214_21: cmp-ne s_214_18 s_214_20
        let s_214_21: bool = ((s_214_18) != (s_214_20));
        // D s_214_22: write-var gs#397753 <= s_214_21
        fn_state.gs_397753 = s_214_21;
        // N s_214_23: jump b215
        return block_215(state, tracer, fn_state);
    }
    fn block_215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_215_0: read-var gs#397753:u8
        let s_215_0: bool = fn_state.gs_397753;
        // N s_215_1: branch s_215_0 b244 b216
        if s_215_0 {
            return block_244(state, tracer, fn_state);
        } else {
            return block_216(state, tracer, fn_state);
        };
    }
    fn block_216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_216_0: const #15s : i
        let s_216_0: i128 = 15;
        // D s_216_1: read-var u#30587:u32
        let s_216_1: u32 = fn_state.u_30587;
        // D s_216_2: cast zx s_216_1 -> bv
        let s_216_2: Bits = Bits::new(s_216_1 as u128, 32u16);
        // C s_216_3: const #1u : u64
        let s_216_3: u64 = 1;
        // D s_216_4: bit-extract s_216_2 s_216_0 s_216_3
        let s_216_4: Bits = (Bits::new(
            ((s_216_2) >> (s_216_0)).value(),
            u16::try_from(s_216_3).unwrap(),
        ));
        // D s_216_5: cast reint s_216_4 -> u8
        let s_216_5: bool = ((s_216_4.value()) != 0);
        // C s_216_6: const #0s : i
        let s_216_6: i128 = 0;
        // C s_216_7: const #0u : u64
        let s_216_7: u64 = 0;
        // D s_216_8: cast zx s_216_5 -> u64
        let s_216_8: u64 = (s_216_5 as u64);
        // C s_216_9: const #1u : u64
        let s_216_9: u64 = 1;
        // D s_216_10: and s_216_8 s_216_9
        let s_216_10: u64 = ((s_216_8) & (s_216_9));
        // D s_216_11: cmp-eq s_216_10 s_216_9
        let s_216_11: bool = ((s_216_10) == (s_216_9));
        // D s_216_12: lsl s_216_8 s_216_6
        let s_216_12: u64 = s_216_8 << s_216_6;
        // D s_216_13: or s_216_7 s_216_12
        let s_216_13: u64 = ((s_216_7) | (s_216_12));
        // D s_216_14: cmpl s_216_12
        let s_216_14: u64 = !s_216_12;
        // D s_216_15: and s_216_7 s_216_14
        let s_216_15: u64 = ((s_216_7) & (s_216_14));
        // D s_216_16: select s_216_11 s_216_13 s_216_15
        let s_216_16: u64 = if s_216_11 { s_216_13 } else { s_216_15 };
        // D s_216_17: cast trunc s_216_16 -> u8
        let s_216_17: bool = ((s_216_16) != 0);
        // D s_216_18: cast zx s_216_17 -> bv
        let s_216_18: Bits = Bits::new(s_216_17 as u128, 1u16);
        // C s_216_19: const #1u : u8
        let s_216_19: bool = true;
        // C s_216_20: cast zx s_216_19 -> bv
        let s_216_20: Bits = Bits::new(s_216_19 as u128, 1u16);
        // D s_216_21: cmp-ne s_216_18 s_216_20
        let s_216_21: bool = ((s_216_18) != (s_216_20));
        // D s_216_22: write-var gs#397756 <= s_216_21
        fn_state.gs_397756 = s_216_21;
        // N s_216_23: jump b217
        return block_217(state, tracer, fn_state);
    }
    fn block_217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_217_0: read-var gs#397756:u8
        let s_217_0: bool = fn_state.gs_397756;
        // N s_217_1: branch s_217_0 b243 b218
        if s_217_0 {
            return block_243(state, tracer, fn_state);
        } else {
            return block_218(state, tracer, fn_state);
        };
    }
    fn block_218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_218_0: const #8s : i
        let s_218_0: i128 = 8;
        // D s_218_1: read-var u#30587:u32
        let s_218_1: u32 = fn_state.u_30587;
        // D s_218_2: cast zx s_218_1 -> bv
        let s_218_2: Bits = Bits::new(s_218_1 as u128, 32u16);
        // C s_218_3: const #1u : u64
        let s_218_3: u64 = 1;
        // D s_218_4: bit-extract s_218_2 s_218_0 s_218_3
        let s_218_4: Bits = (Bits::new(
            ((s_218_2) >> (s_218_0)).value(),
            u16::try_from(s_218_3).unwrap(),
        ));
        // D s_218_5: cast reint s_218_4 -> u8
        let s_218_5: bool = ((s_218_4.value()) != 0);
        // C s_218_6: const #0s : i
        let s_218_6: i128 = 0;
        // C s_218_7: const #0u : u64
        let s_218_7: u64 = 0;
        // D s_218_8: cast zx s_218_5 -> u64
        let s_218_8: u64 = (s_218_5 as u64);
        // C s_218_9: const #1u : u64
        let s_218_9: u64 = 1;
        // D s_218_10: and s_218_8 s_218_9
        let s_218_10: u64 = ((s_218_8) & (s_218_9));
        // D s_218_11: cmp-eq s_218_10 s_218_9
        let s_218_11: bool = ((s_218_10) == (s_218_9));
        // D s_218_12: lsl s_218_8 s_218_6
        let s_218_12: u64 = s_218_8 << s_218_6;
        // D s_218_13: or s_218_7 s_218_12
        let s_218_13: u64 = ((s_218_7) | (s_218_12));
        // D s_218_14: cmpl s_218_12
        let s_218_14: u64 = !s_218_12;
        // D s_218_15: and s_218_7 s_218_14
        let s_218_15: u64 = ((s_218_7) & (s_218_14));
        // D s_218_16: select s_218_11 s_218_13 s_218_15
        let s_218_16: u64 = if s_218_11 { s_218_13 } else { s_218_15 };
        // D s_218_17: cast trunc s_218_16 -> u8
        let s_218_17: bool = ((s_218_16) != 0);
        // D s_218_18: cast zx s_218_17 -> bv
        let s_218_18: Bits = Bits::new(s_218_17 as u128, 1u16);
        // C s_218_19: const #0u : u8
        let s_218_19: bool = false;
        // C s_218_20: cast zx s_218_19 -> bv
        let s_218_20: Bits = Bits::new(s_218_19 as u128, 1u16);
        // D s_218_21: cmp-ne s_218_18 s_218_20
        let s_218_21: bool = ((s_218_18) != (s_218_20));
        // D s_218_22: write-var gs#397759 <= s_218_21
        fn_state.gs_397759 = s_218_21;
        // N s_218_23: jump b219
        return block_219(state, tracer, fn_state);
    }
    fn block_219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_219_0: read-var gs#397759:u8
        let s_219_0: bool = fn_state.gs_397759;
        // N s_219_1: branch s_219_0 b242 b220
        if s_219_0 {
            return block_242(state, tracer, fn_state);
        } else {
            return block_220(state, tracer, fn_state);
        };
    }
    fn block_220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_220_0: const #9s : i
        let s_220_0: i128 = 9;
        // D s_220_1: read-var u#30587:u32
        let s_220_1: u32 = fn_state.u_30587;
        // D s_220_2: cast zx s_220_1 -> bv
        let s_220_2: Bits = Bits::new(s_220_1 as u128, 32u16);
        // C s_220_3: const #1u : u64
        let s_220_3: u64 = 1;
        // D s_220_4: bit-extract s_220_2 s_220_0 s_220_3
        let s_220_4: Bits = (Bits::new(
            ((s_220_2) >> (s_220_0)).value(),
            u16::try_from(s_220_3).unwrap(),
        ));
        // D s_220_5: cast reint s_220_4 -> u8
        let s_220_5: bool = ((s_220_4.value()) != 0);
        // C s_220_6: const #0s : i
        let s_220_6: i128 = 0;
        // C s_220_7: const #0u : u64
        let s_220_7: u64 = 0;
        // D s_220_8: cast zx s_220_5 -> u64
        let s_220_8: u64 = (s_220_5 as u64);
        // C s_220_9: const #1u : u64
        let s_220_9: u64 = 1;
        // D s_220_10: and s_220_8 s_220_9
        let s_220_10: u64 = ((s_220_8) & (s_220_9));
        // D s_220_11: cmp-eq s_220_10 s_220_9
        let s_220_11: bool = ((s_220_10) == (s_220_9));
        // D s_220_12: lsl s_220_8 s_220_6
        let s_220_12: u64 = s_220_8 << s_220_6;
        // D s_220_13: or s_220_7 s_220_12
        let s_220_13: u64 = ((s_220_7) | (s_220_12));
        // D s_220_14: cmpl s_220_12
        let s_220_14: u64 = !s_220_12;
        // D s_220_15: and s_220_7 s_220_14
        let s_220_15: u64 = ((s_220_7) & (s_220_14));
        // D s_220_16: select s_220_11 s_220_13 s_220_15
        let s_220_16: u64 = if s_220_11 { s_220_13 } else { s_220_15 };
        // D s_220_17: cast trunc s_220_16 -> u8
        let s_220_17: bool = ((s_220_16) != 0);
        // D s_220_18: cast zx s_220_17 -> bv
        let s_220_18: Bits = Bits::new(s_220_17 as u128, 1u16);
        // C s_220_19: const #0u : u8
        let s_220_19: bool = false;
        // C s_220_20: cast zx s_220_19 -> bv
        let s_220_20: Bits = Bits::new(s_220_19 as u128, 1u16);
        // D s_220_21: cmp-ne s_220_18 s_220_20
        let s_220_21: bool = ((s_220_18) != (s_220_20));
        // D s_220_22: write-var gs#397762 <= s_220_21
        fn_state.gs_397762 = s_220_21;
        // N s_220_23: jump b221
        return block_221(state, tracer, fn_state);
    }
    fn block_221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_221_0: read-var gs#397762:u8
        let s_221_0: bool = fn_state.gs_397762;
        // N s_221_1: branch s_221_0 b241 b222
        if s_221_0 {
            return block_241(state, tracer, fn_state);
        } else {
            return block_222(state, tracer, fn_state);
        };
    }
    fn block_222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_222_0: const #10s : i
        let s_222_0: i128 = 10;
        // D s_222_1: read-var u#30587:u32
        let s_222_1: u32 = fn_state.u_30587;
        // D s_222_2: cast zx s_222_1 -> bv
        let s_222_2: Bits = Bits::new(s_222_1 as u128, 32u16);
        // C s_222_3: const #1u : u64
        let s_222_3: u64 = 1;
        // D s_222_4: bit-extract s_222_2 s_222_0 s_222_3
        let s_222_4: Bits = (Bits::new(
            ((s_222_2) >> (s_222_0)).value(),
            u16::try_from(s_222_3).unwrap(),
        ));
        // D s_222_5: cast reint s_222_4 -> u8
        let s_222_5: bool = ((s_222_4.value()) != 0);
        // C s_222_6: const #0s : i
        let s_222_6: i128 = 0;
        // C s_222_7: const #0u : u64
        let s_222_7: u64 = 0;
        // D s_222_8: cast zx s_222_5 -> u64
        let s_222_8: u64 = (s_222_5 as u64);
        // C s_222_9: const #1u : u64
        let s_222_9: u64 = 1;
        // D s_222_10: and s_222_8 s_222_9
        let s_222_10: u64 = ((s_222_8) & (s_222_9));
        // D s_222_11: cmp-eq s_222_10 s_222_9
        let s_222_11: bool = ((s_222_10) == (s_222_9));
        // D s_222_12: lsl s_222_8 s_222_6
        let s_222_12: u64 = s_222_8 << s_222_6;
        // D s_222_13: or s_222_7 s_222_12
        let s_222_13: u64 = ((s_222_7) | (s_222_12));
        // D s_222_14: cmpl s_222_12
        let s_222_14: u64 = !s_222_12;
        // D s_222_15: and s_222_7 s_222_14
        let s_222_15: u64 = ((s_222_7) & (s_222_14));
        // D s_222_16: select s_222_11 s_222_13 s_222_15
        let s_222_16: u64 = if s_222_11 { s_222_13 } else { s_222_15 };
        // D s_222_17: cast trunc s_222_16 -> u8
        let s_222_17: bool = ((s_222_16) != 0);
        // D s_222_18: cast zx s_222_17 -> bv
        let s_222_18: Bits = Bits::new(s_222_17 as u128, 1u16);
        // C s_222_19: const #0u : u8
        let s_222_19: bool = false;
        // C s_222_20: cast zx s_222_19 -> bv
        let s_222_20: Bits = Bits::new(s_222_19 as u128, 1u16);
        // D s_222_21: cmp-ne s_222_18 s_222_20
        let s_222_21: bool = ((s_222_18) != (s_222_20));
        // D s_222_22: write-var gs#397765 <= s_222_21
        fn_state.gs_397765 = s_222_21;
        // N s_222_23: jump b223
        return block_223(state, tracer, fn_state);
    }
    fn block_223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_223_0: read-var gs#397765:u8
        let s_223_0: bool = fn_state.gs_397765;
        // N s_223_1: branch s_223_0 b240 b224
        if s_223_0 {
            return block_240(state, tracer, fn_state);
        } else {
            return block_224(state, tracer, fn_state);
        };
    }
    fn block_224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_224_0: const #11s : i
        let s_224_0: i128 = 11;
        // D s_224_1: read-var u#30587:u32
        let s_224_1: u32 = fn_state.u_30587;
        // D s_224_2: cast zx s_224_1 -> bv
        let s_224_2: Bits = Bits::new(s_224_1 as u128, 32u16);
        // C s_224_3: const #1u : u64
        let s_224_3: u64 = 1;
        // D s_224_4: bit-extract s_224_2 s_224_0 s_224_3
        let s_224_4: Bits = (Bits::new(
            ((s_224_2) >> (s_224_0)).value(),
            u16::try_from(s_224_3).unwrap(),
        ));
        // D s_224_5: cast reint s_224_4 -> u8
        let s_224_5: bool = ((s_224_4.value()) != 0);
        // C s_224_6: const #0s : i
        let s_224_6: i128 = 0;
        // C s_224_7: const #0u : u64
        let s_224_7: u64 = 0;
        // D s_224_8: cast zx s_224_5 -> u64
        let s_224_8: u64 = (s_224_5 as u64);
        // C s_224_9: const #1u : u64
        let s_224_9: u64 = 1;
        // D s_224_10: and s_224_8 s_224_9
        let s_224_10: u64 = ((s_224_8) & (s_224_9));
        // D s_224_11: cmp-eq s_224_10 s_224_9
        let s_224_11: bool = ((s_224_10) == (s_224_9));
        // D s_224_12: lsl s_224_8 s_224_6
        let s_224_12: u64 = s_224_8 << s_224_6;
        // D s_224_13: or s_224_7 s_224_12
        let s_224_13: u64 = ((s_224_7) | (s_224_12));
        // D s_224_14: cmpl s_224_12
        let s_224_14: u64 = !s_224_12;
        // D s_224_15: and s_224_7 s_224_14
        let s_224_15: u64 = ((s_224_7) & (s_224_14));
        // D s_224_16: select s_224_11 s_224_13 s_224_15
        let s_224_16: u64 = if s_224_11 { s_224_13 } else { s_224_15 };
        // D s_224_17: cast trunc s_224_16 -> u8
        let s_224_17: bool = ((s_224_16) != 0);
        // D s_224_18: cast zx s_224_17 -> bv
        let s_224_18: Bits = Bits::new(s_224_17 as u128, 1u16);
        // C s_224_19: const #0u : u8
        let s_224_19: bool = false;
        // C s_224_20: cast zx s_224_19 -> bv
        let s_224_20: Bits = Bits::new(s_224_19 as u128, 1u16);
        // D s_224_21: cmp-ne s_224_18 s_224_20
        let s_224_21: bool = ((s_224_18) != (s_224_20));
        // D s_224_22: write-var gs#397768 <= s_224_21
        fn_state.gs_397768 = s_224_21;
        // N s_224_23: jump b225
        return block_225(state, tracer, fn_state);
    }
    fn block_225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_225_0: read-var gs#397768:u8
        let s_225_0: bool = fn_state.gs_397768;
        // N s_225_1: branch s_225_0 b239 b226
        if s_225_0 {
            return block_239(state, tracer, fn_state);
        } else {
            return block_226(state, tracer, fn_state);
        };
    }
    fn block_226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_226_0: const #0s : i
        let s_226_0: i128 = 0;
        // D s_226_1: read-var u#30587:u32
        let s_226_1: u32 = fn_state.u_30587;
        // D s_226_2: cast zx s_226_1 -> bv
        let s_226_2: Bits = Bits::new(s_226_1 as u128, 32u16);
        // C s_226_3: const #1u : u64
        let s_226_3: u64 = 1;
        // D s_226_4: bit-extract s_226_2 s_226_0 s_226_3
        let s_226_4: Bits = (Bits::new(
            ((s_226_2) >> (s_226_0)).value(),
            u16::try_from(s_226_3).unwrap(),
        ));
        // D s_226_5: cast reint s_226_4 -> u8
        let s_226_5: bool = ((s_226_4.value()) != 0);
        // C s_226_6: const #0s : i
        let s_226_6: i128 = 0;
        // C s_226_7: const #0u : u64
        let s_226_7: u64 = 0;
        // D s_226_8: cast zx s_226_5 -> u64
        let s_226_8: u64 = (s_226_5 as u64);
        // C s_226_9: const #1u : u64
        let s_226_9: u64 = 1;
        // D s_226_10: and s_226_8 s_226_9
        let s_226_10: u64 = ((s_226_8) & (s_226_9));
        // D s_226_11: cmp-eq s_226_10 s_226_9
        let s_226_11: bool = ((s_226_10) == (s_226_9));
        // D s_226_12: lsl s_226_8 s_226_6
        let s_226_12: u64 = s_226_8 << s_226_6;
        // D s_226_13: or s_226_7 s_226_12
        let s_226_13: u64 = ((s_226_7) | (s_226_12));
        // D s_226_14: cmpl s_226_12
        let s_226_14: u64 = !s_226_12;
        // D s_226_15: and s_226_7 s_226_14
        let s_226_15: u64 = ((s_226_7) & (s_226_14));
        // D s_226_16: select s_226_11 s_226_13 s_226_15
        let s_226_16: u64 = if s_226_11 { s_226_13 } else { s_226_15 };
        // D s_226_17: cast trunc s_226_16 -> u8
        let s_226_17: bool = ((s_226_16) != 0);
        // D s_226_18: cast zx s_226_17 -> bv
        let s_226_18: Bits = Bits::new(s_226_17 as u128, 1u16);
        // C s_226_19: const #0u : u8
        let s_226_19: bool = false;
        // C s_226_20: cast zx s_226_19 -> bv
        let s_226_20: Bits = Bits::new(s_226_19 as u128, 1u16);
        // D s_226_21: cmp-ne s_226_18 s_226_20
        let s_226_21: bool = ((s_226_18) != (s_226_20));
        // D s_226_22: write-var gs#397771 <= s_226_21
        fn_state.gs_397771 = s_226_21;
        // N s_226_23: jump b227
        return block_227(state, tracer, fn_state);
    }
    fn block_227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_227_0: read-var gs#397771:u8
        let s_227_0: bool = fn_state.gs_397771;
        // N s_227_1: branch s_227_0 b238 b228
        if s_227_0 {
            return block_238(state, tracer, fn_state);
        } else {
            return block_228(state, tracer, fn_state);
        };
    }
    fn block_228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_228_0: const #1s : i
        let s_228_0: i128 = 1;
        // D s_228_1: read-var u#30587:u32
        let s_228_1: u32 = fn_state.u_30587;
        // D s_228_2: cast zx s_228_1 -> bv
        let s_228_2: Bits = Bits::new(s_228_1 as u128, 32u16);
        // C s_228_3: const #1u : u64
        let s_228_3: u64 = 1;
        // D s_228_4: bit-extract s_228_2 s_228_0 s_228_3
        let s_228_4: Bits = (Bits::new(
            ((s_228_2) >> (s_228_0)).value(),
            u16::try_from(s_228_3).unwrap(),
        ));
        // D s_228_5: cast reint s_228_4 -> u8
        let s_228_5: bool = ((s_228_4.value()) != 0);
        // C s_228_6: const #0s : i
        let s_228_6: i128 = 0;
        // C s_228_7: const #0u : u64
        let s_228_7: u64 = 0;
        // D s_228_8: cast zx s_228_5 -> u64
        let s_228_8: u64 = (s_228_5 as u64);
        // C s_228_9: const #1u : u64
        let s_228_9: u64 = 1;
        // D s_228_10: and s_228_8 s_228_9
        let s_228_10: u64 = ((s_228_8) & (s_228_9));
        // D s_228_11: cmp-eq s_228_10 s_228_9
        let s_228_11: bool = ((s_228_10) == (s_228_9));
        // D s_228_12: lsl s_228_8 s_228_6
        let s_228_12: u64 = s_228_8 << s_228_6;
        // D s_228_13: or s_228_7 s_228_12
        let s_228_13: u64 = ((s_228_7) | (s_228_12));
        // D s_228_14: cmpl s_228_12
        let s_228_14: u64 = !s_228_12;
        // D s_228_15: and s_228_7 s_228_14
        let s_228_15: u64 = ((s_228_7) & (s_228_14));
        // D s_228_16: select s_228_11 s_228_13 s_228_15
        let s_228_16: u64 = if s_228_11 { s_228_13 } else { s_228_15 };
        // D s_228_17: cast trunc s_228_16 -> u8
        let s_228_17: bool = ((s_228_16) != 0);
        // D s_228_18: cast zx s_228_17 -> bv
        let s_228_18: Bits = Bits::new(s_228_17 as u128, 1u16);
        // C s_228_19: const #0u : u8
        let s_228_19: bool = false;
        // C s_228_20: cast zx s_228_19 -> bv
        let s_228_20: Bits = Bits::new(s_228_19 as u128, 1u16);
        // D s_228_21: cmp-ne s_228_18 s_228_20
        let s_228_21: bool = ((s_228_18) != (s_228_20));
        // D s_228_22: write-var gs#397774 <= s_228_21
        fn_state.gs_397774 = s_228_21;
        // N s_228_23: jump b229
        return block_229(state, tracer, fn_state);
    }
    fn block_229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_229_0: read-var gs#397774:u8
        let s_229_0: bool = fn_state.gs_397774;
        // N s_229_1: branch s_229_0 b237 b230
        if s_229_0 {
            return block_237(state, tracer, fn_state);
        } else {
            return block_230(state, tracer, fn_state);
        };
    }
    fn block_230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_230_0: const #2s : i
        let s_230_0: i128 = 2;
        // D s_230_1: read-var u#30587:u32
        let s_230_1: u32 = fn_state.u_30587;
        // D s_230_2: cast zx s_230_1 -> bv
        let s_230_2: Bits = Bits::new(s_230_1 as u128, 32u16);
        // C s_230_3: const #1u : u64
        let s_230_3: u64 = 1;
        // D s_230_4: bit-extract s_230_2 s_230_0 s_230_3
        let s_230_4: Bits = (Bits::new(
            ((s_230_2) >> (s_230_0)).value(),
            u16::try_from(s_230_3).unwrap(),
        ));
        // D s_230_5: cast reint s_230_4 -> u8
        let s_230_5: bool = ((s_230_4.value()) != 0);
        // C s_230_6: const #0s : i
        let s_230_6: i128 = 0;
        // C s_230_7: const #0u : u64
        let s_230_7: u64 = 0;
        // D s_230_8: cast zx s_230_5 -> u64
        let s_230_8: u64 = (s_230_5 as u64);
        // C s_230_9: const #1u : u64
        let s_230_9: u64 = 1;
        // D s_230_10: and s_230_8 s_230_9
        let s_230_10: u64 = ((s_230_8) & (s_230_9));
        // D s_230_11: cmp-eq s_230_10 s_230_9
        let s_230_11: bool = ((s_230_10) == (s_230_9));
        // D s_230_12: lsl s_230_8 s_230_6
        let s_230_12: u64 = s_230_8 << s_230_6;
        // D s_230_13: or s_230_7 s_230_12
        let s_230_13: u64 = ((s_230_7) | (s_230_12));
        // D s_230_14: cmpl s_230_12
        let s_230_14: u64 = !s_230_12;
        // D s_230_15: and s_230_7 s_230_14
        let s_230_15: u64 = ((s_230_7) & (s_230_14));
        // D s_230_16: select s_230_11 s_230_13 s_230_15
        let s_230_16: u64 = if s_230_11 { s_230_13 } else { s_230_15 };
        // D s_230_17: cast trunc s_230_16 -> u8
        let s_230_17: bool = ((s_230_16) != 0);
        // D s_230_18: cast zx s_230_17 -> bv
        let s_230_18: Bits = Bits::new(s_230_17 as u128, 1u16);
        // C s_230_19: const #0u : u8
        let s_230_19: bool = false;
        // C s_230_20: cast zx s_230_19 -> bv
        let s_230_20: Bits = Bits::new(s_230_19 as u128, 1u16);
        // D s_230_21: cmp-ne s_230_18 s_230_20
        let s_230_21: bool = ((s_230_18) != (s_230_20));
        // D s_230_22: write-var gs#397777 <= s_230_21
        fn_state.gs_397777 = s_230_21;
        // N s_230_23: jump b231
        return block_231(state, tracer, fn_state);
    }
    fn block_231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_231_0: read-var gs#397777:u8
        let s_231_0: bool = fn_state.gs_397777;
        // N s_231_1: branch s_231_0 b236 b232
        if s_231_0 {
            return block_236(state, tracer, fn_state);
        } else {
            return block_232(state, tracer, fn_state);
        };
    }
    fn block_232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_232_0: const #3s : i
        let s_232_0: i128 = 3;
        // D s_232_1: read-var u#30587:u32
        let s_232_1: u32 = fn_state.u_30587;
        // D s_232_2: cast zx s_232_1 -> bv
        let s_232_2: Bits = Bits::new(s_232_1 as u128, 32u16);
        // C s_232_3: const #1u : u64
        let s_232_3: u64 = 1;
        // D s_232_4: bit-extract s_232_2 s_232_0 s_232_3
        let s_232_4: Bits = (Bits::new(
            ((s_232_2) >> (s_232_0)).value(),
            u16::try_from(s_232_3).unwrap(),
        ));
        // D s_232_5: cast reint s_232_4 -> u8
        let s_232_5: bool = ((s_232_4.value()) != 0);
        // C s_232_6: const #0s : i
        let s_232_6: i128 = 0;
        // C s_232_7: const #0u : u64
        let s_232_7: u64 = 0;
        // D s_232_8: cast zx s_232_5 -> u64
        let s_232_8: u64 = (s_232_5 as u64);
        // C s_232_9: const #1u : u64
        let s_232_9: u64 = 1;
        // D s_232_10: and s_232_8 s_232_9
        let s_232_10: u64 = ((s_232_8) & (s_232_9));
        // D s_232_11: cmp-eq s_232_10 s_232_9
        let s_232_11: bool = ((s_232_10) == (s_232_9));
        // D s_232_12: lsl s_232_8 s_232_6
        let s_232_12: u64 = s_232_8 << s_232_6;
        // D s_232_13: or s_232_7 s_232_12
        let s_232_13: u64 = ((s_232_7) | (s_232_12));
        // D s_232_14: cmpl s_232_12
        let s_232_14: u64 = !s_232_12;
        // D s_232_15: and s_232_7 s_232_14
        let s_232_15: u64 = ((s_232_7) & (s_232_14));
        // D s_232_16: select s_232_11 s_232_13 s_232_15
        let s_232_16: u64 = if s_232_11 { s_232_13 } else { s_232_15 };
        // D s_232_17: cast trunc s_232_16 -> u8
        let s_232_17: bool = ((s_232_16) != 0);
        // D s_232_18: cast zx s_232_17 -> bv
        let s_232_18: Bits = Bits::new(s_232_17 as u128, 1u16);
        // C s_232_19: const #0u : u8
        let s_232_19: bool = false;
        // C s_232_20: cast zx s_232_19 -> bv
        let s_232_20: Bits = Bits::new(s_232_19 as u128, 1u16);
        // D s_232_21: cmp-ne s_232_18 s_232_20
        let s_232_21: bool = ((s_232_18) != (s_232_20));
        // D s_232_22: write-var gs#397780 <= s_232_21
        fn_state.gs_397780 = s_232_21;
        // N s_232_23: jump b233
        return block_233(state, tracer, fn_state);
    }
    fn block_233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_233_0: read-var gs#397780:u8
        let s_233_0: bool = fn_state.gs_397780;
        // N s_233_1: branch s_233_0 b235 b234
        if s_233_0 {
            return block_235(state, tracer, fn_state);
        } else {
            return block_234(state, tracer, fn_state);
        };
    }
    fn block_234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_234_0: const #() : ()
        let s_234_0: () = ();
        // S s_234_1: call decode_aarch32_instrs_SB_A1enc_A_txt(s_234_0)
        let s_234_1: () = decode_aarch32_instrs_SB_A1enc_A_txt(state, tracer, s_234_0);
        // N s_234_2: return
        return;
    }
    fn block_235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_235_0: panic
        panic!("{:?}", ());
        // N s_235_1: return
        return;
    }
    fn block_236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_236_0: const #1u : u8
        let s_236_0: bool = true;
        // D s_236_1: write-var gs#397780 <= s_236_0
        fn_state.gs_397780 = s_236_0;
        // N s_236_2: jump b233
        return block_233(state, tracer, fn_state);
    }
    fn block_237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_237_0: const #1u : u8
        let s_237_0: bool = true;
        // D s_237_1: write-var gs#397777 <= s_237_0
        fn_state.gs_397777 = s_237_0;
        // N s_237_2: jump b231
        return block_231(state, tracer, fn_state);
    }
    fn block_238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_238_0: const #1u : u8
        let s_238_0: bool = true;
        // D s_238_1: write-var gs#397774 <= s_238_0
        fn_state.gs_397774 = s_238_0;
        // N s_238_2: jump b229
        return block_229(state, tracer, fn_state);
    }
    fn block_239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_239_0: const #1u : u8
        let s_239_0: bool = true;
        // D s_239_1: write-var gs#397771 <= s_239_0
        fn_state.gs_397771 = s_239_0;
        // N s_239_2: jump b227
        return block_227(state, tracer, fn_state);
    }
    fn block_240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_240_0: const #1u : u8
        let s_240_0: bool = true;
        // D s_240_1: write-var gs#397768 <= s_240_0
        fn_state.gs_397768 = s_240_0;
        // N s_240_2: jump b225
        return block_225(state, tracer, fn_state);
    }
    fn block_241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_241_0: const #1u : u8
        let s_241_0: bool = true;
        // D s_241_1: write-var gs#397765 <= s_241_0
        fn_state.gs_397765 = s_241_0;
        // N s_241_2: jump b223
        return block_223(state, tracer, fn_state);
    }
    fn block_242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_242_0: const #1u : u8
        let s_242_0: bool = true;
        // D s_242_1: write-var gs#397762 <= s_242_0
        fn_state.gs_397762 = s_242_0;
        // N s_242_2: jump b221
        return block_221(state, tracer, fn_state);
    }
    fn block_243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_243_0: const #1u : u8
        let s_243_0: bool = true;
        // D s_243_1: write-var gs#397759 <= s_243_0
        fn_state.gs_397759 = s_243_0;
        // N s_243_2: jump b219
        return block_219(state, tracer, fn_state);
    }
    fn block_244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_244_0: const #1u : u8
        let s_244_0: bool = true;
        // D s_244_1: write-var gs#397756 <= s_244_0
        fn_state.gs_397756 = s_244_0;
        // N s_244_2: jump b217
        return block_217(state, tracer, fn_state);
    }
    fn block_245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_245_0: const #1u : u8
        let s_245_0: bool = true;
        // D s_245_1: write-var gs#397753 <= s_245_0
        fn_state.gs_397753 = s_245_0;
        // N s_245_2: jump b215
        return block_215(state, tracer, fn_state);
    }
    fn block_246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_246_0: const #1u : u8
        let s_246_0: bool = true;
        // D s_246_1: write-var gs#397750 <= s_246_0
        fn_state.gs_397750 = s_246_0;
        // N s_246_2: jump b213
        return block_213(state, tracer, fn_state);
    }
    fn block_247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_247_0: const #1u : u8
        let s_247_0: bool = true;
        // D s_247_1: write-var gs#397747 <= s_247_0
        fn_state.gs_397747 = s_247_0;
        // N s_247_2: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_248_0: const #1u : u8
        let s_248_0: bool = true;
        // D s_248_1: write-var gs#397744 <= s_248_0
        fn_state.gs_397744 = s_248_0;
        // N s_248_2: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_249_0: const #1u : u8
        let s_249_0: bool = true;
        // D s_249_1: write-var gs#397741 <= s_249_0
        fn_state.gs_397741 = s_249_0;
        // N s_249_2: jump b207
        return block_207(state, tracer, fn_state);
    }
    fn block_250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_250_0: const #1u : u8
        let s_250_0: bool = true;
        // D s_250_1: write-var gs#397738 <= s_250_0
        fn_state.gs_397738 = s_250_0;
        // N s_250_2: jump b205
        return block_205(state, tracer, fn_state);
    }
    fn block_251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_251_0: read-var merge#var.1:struct
        let s_251_0: u32 = fn_state.merge_var._1;
        // D s_251_1: write-var u#30589 <= s_251_0
        fn_state.u_30589 = s_251_0;
        // C s_251_2: const #10s : i
        let s_251_2: i128 = 10;
        // D s_251_3: read-var u#30589:u32
        let s_251_3: u32 = fn_state.u_30589;
        // D s_251_4: cast zx s_251_3 -> bv
        let s_251_4: Bits = Bits::new(s_251_3 as u128, 32u16);
        // C s_251_5: const #1s : i64
        let s_251_5: i64 = 1;
        // C s_251_6: cast zx s_251_5 -> i
        let s_251_6: i128 = (i128::try_from(s_251_5).unwrap());
        // C s_251_7: const #21s : i
        let s_251_7: i128 = 21;
        // C s_251_8: add s_251_7 s_251_6
        let s_251_8: i128 = (s_251_7 + s_251_6);
        // D s_251_9: bit-extract s_251_4 s_251_2 s_251_8
        let s_251_9: Bits = (Bits::new(
            ((s_251_4) >> (s_251_2)).value(),
            u16::try_from(s_251_8).unwrap(),
        ));
        // D s_251_10: cast reint s_251_9 -> u22
        let s_251_10: u32 = (s_251_9.value() as u32);
        // D s_251_11: cast zx s_251_10 -> bv
        let s_251_11: Bits = Bits::new(s_251_10 as u128, 22u16);
        // C s_251_12: const #3948608u : u22
        let s_251_12: u32 = 3948608;
        // C s_251_13: cast zx s_251_12 -> bv
        let s_251_13: Bits = Bits::new(s_251_12 as u128, 22u16);
        // D s_251_14: cmp-eq s_251_11 s_251_13
        let s_251_14: bool = ((s_251_11) == (s_251_13));
        // N s_251_15: branch s_251_14 b3192 b252
        if s_251_14 {
            return block_3192(state, tracer, fn_state);
        } else {
            return block_252(state, tracer, fn_state);
        };
    }
    fn block_252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_252_0: const #0u : u8
        let s_252_0: bool = false;
        // D s_252_1: write-var gs#397786 <= s_252_0
        fn_state.gs_397786 = s_252_0;
        // N s_252_2: jump b253
        return block_253(state, tracer, fn_state);
    }
    fn block_253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_253_0: read-var gs#397786:u8
        let s_253_0: bool = fn_state.gs_397786;
        // N s_253_1: branch s_253_0 b3191 b254
        if s_253_0 {
            return block_3191(state, tracer, fn_state);
        } else {
            return block_254(state, tracer, fn_state);
        };
    }
    fn block_254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_254_0: const #0u : u8
        let s_254_0: bool = false;
        // D s_254_1: write-var gs#397788 <= s_254_0
        fn_state.gs_397788 = s_254_0;
        // N s_254_2: jump b255
        return block_255(state, tracer, fn_state);
    }
    fn block_255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_255_0: read-var gs#397788:u8
        let s_255_0: bool = fn_state.gs_397788;
        // D s_255_1: not s_255_0
        let s_255_1: bool = !s_255_0;
        // N s_255_2: branch s_255_1 b289 b256
        if s_255_1 {
            return block_289(state, tracer, fn_state);
        } else {
            return block_256(state, tracer, fn_state);
        };
    }
    fn block_256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_256_0: const #3125s : i
        let s_256_0: i128 = 3125;
        // C s_256_1: const #14696u : u32
        let s_256_1: u32 = 14696;
        // N s_256_2: write-reg s_256_1 <= s_256_0
        let s_256_2: () = {
            state.write_register::<i128>(s_256_1 as isize, s_256_0);
            tracer.write_register(s_256_1 as isize, s_256_0);
        };
        // C s_256_3: const #9s : i
        let s_256_3: i128 = 9;
        // C s_256_4: const #1s : i
        let s_256_4: i128 = 1;
        // D s_256_5: read-var u#30589:u32
        let s_256_5: u32 = fn_state.u_30589;
        // D s_256_6: cast zx s_256_5 -> bv
        let s_256_6: Bits = Bits::new(s_256_5 as u128, 32u16);
        // D s_256_7: bit-extract s_256_6 s_256_3 s_256_4
        let s_256_7: Bits = (Bits::new(
            ((s_256_6) >> (s_256_3)).value(),
            u16::try_from(s_256_4).unwrap(),
        ));
        // D s_256_8: cast reint s_256_7 -> u8
        let s_256_8: bool = ((s_256_7.value()) != 0);
        // D s_256_9: write-var E <= s_256_8
        fn_state.E = s_256_8;
        // C s_256_10: const #10s : i
        let s_256_10: i128 = 10;
        // D s_256_11: read-var u#30589:u32
        let s_256_11: u32 = fn_state.u_30589;
        // D s_256_12: cast zx s_256_11 -> bv
        let s_256_12: Bits = Bits::new(s_256_11 as u128, 32u16);
        // C s_256_13: const #1u : u64
        let s_256_13: u64 = 1;
        // D s_256_14: bit-extract s_256_12 s_256_10 s_256_13
        let s_256_14: Bits = (Bits::new(
            ((s_256_12) >> (s_256_10)).value(),
            u16::try_from(s_256_13).unwrap(),
        ));
        // D s_256_15: cast reint s_256_14 -> u8
        let s_256_15: bool = ((s_256_14.value()) != 0);
        // C s_256_16: const #0s : i
        let s_256_16: i128 = 0;
        // C s_256_17: const #0u : u64
        let s_256_17: u64 = 0;
        // D s_256_18: cast zx s_256_15 -> u64
        let s_256_18: u64 = (s_256_15 as u64);
        // C s_256_19: const #1u : u64
        let s_256_19: u64 = 1;
        // D s_256_20: and s_256_18 s_256_19
        let s_256_20: u64 = ((s_256_18) & (s_256_19));
        // D s_256_21: cmp-eq s_256_20 s_256_19
        let s_256_21: bool = ((s_256_20) == (s_256_19));
        // D s_256_22: lsl s_256_18 s_256_16
        let s_256_22: u64 = s_256_18 << s_256_16;
        // D s_256_23: or s_256_17 s_256_22
        let s_256_23: u64 = ((s_256_17) | (s_256_22));
        // D s_256_24: cmpl s_256_22
        let s_256_24: u64 = !s_256_22;
        // D s_256_25: and s_256_17 s_256_24
        let s_256_25: u64 = ((s_256_17) & (s_256_24));
        // D s_256_26: select s_256_21 s_256_23 s_256_25
        let s_256_26: u64 = if s_256_21 { s_256_23 } else { s_256_25 };
        // D s_256_27: cast trunc s_256_26 -> u8
        let s_256_27: bool = ((s_256_26) != 0);
        // D s_256_28: cast zx s_256_27 -> bv
        let s_256_28: Bits = Bits::new(s_256_27 as u128, 1u16);
        // C s_256_29: const #0u : u8
        let s_256_29: bool = false;
        // C s_256_30: cast zx s_256_29 -> bv
        let s_256_30: Bits = Bits::new(s_256_29 as u128, 1u16);
        // D s_256_31: cmp-ne s_256_28 s_256_30
        let s_256_31: bool = ((s_256_28) != (s_256_30));
        // N s_256_32: branch s_256_31 b288 b257
        if s_256_31 {
            return block_288(state, tracer, fn_state);
        } else {
            return block_257(state, tracer, fn_state);
        };
    }
    fn block_257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_257_0: const #11s : i
        let s_257_0: i128 = 11;
        // D s_257_1: read-var u#30589:u32
        let s_257_1: u32 = fn_state.u_30589;
        // D s_257_2: cast zx s_257_1 -> bv
        let s_257_2: Bits = Bits::new(s_257_1 as u128, 32u16);
        // C s_257_3: const #1u : u64
        let s_257_3: u64 = 1;
        // D s_257_4: bit-extract s_257_2 s_257_0 s_257_3
        let s_257_4: Bits = (Bits::new(
            ((s_257_2) >> (s_257_0)).value(),
            u16::try_from(s_257_3).unwrap(),
        ));
        // D s_257_5: cast reint s_257_4 -> u8
        let s_257_5: bool = ((s_257_4.value()) != 0);
        // C s_257_6: const #0s : i
        let s_257_6: i128 = 0;
        // C s_257_7: const #0u : u64
        let s_257_7: u64 = 0;
        // D s_257_8: cast zx s_257_5 -> u64
        let s_257_8: u64 = (s_257_5 as u64);
        // C s_257_9: const #1u : u64
        let s_257_9: u64 = 1;
        // D s_257_10: and s_257_8 s_257_9
        let s_257_10: u64 = ((s_257_8) & (s_257_9));
        // D s_257_11: cmp-eq s_257_10 s_257_9
        let s_257_11: bool = ((s_257_10) == (s_257_9));
        // D s_257_12: lsl s_257_8 s_257_6
        let s_257_12: u64 = s_257_8 << s_257_6;
        // D s_257_13: or s_257_7 s_257_12
        let s_257_13: u64 = ((s_257_7) | (s_257_12));
        // D s_257_14: cmpl s_257_12
        let s_257_14: u64 = !s_257_12;
        // D s_257_15: and s_257_7 s_257_14
        let s_257_15: u64 = ((s_257_7) & (s_257_14));
        // D s_257_16: select s_257_11 s_257_13 s_257_15
        let s_257_16: u64 = if s_257_11 { s_257_13 } else { s_257_15 };
        // D s_257_17: cast trunc s_257_16 -> u8
        let s_257_17: bool = ((s_257_16) != 0);
        // D s_257_18: cast zx s_257_17 -> bv
        let s_257_18: Bits = Bits::new(s_257_17 as u128, 1u16);
        // C s_257_19: const #0u : u8
        let s_257_19: bool = false;
        // C s_257_20: cast zx s_257_19 -> bv
        let s_257_20: Bits = Bits::new(s_257_19 as u128, 1u16);
        // D s_257_21: cmp-ne s_257_18 s_257_20
        let s_257_21: bool = ((s_257_18) != (s_257_20));
        // D s_257_22: write-var gs#397797 <= s_257_21
        fn_state.gs_397797 = s_257_21;
        // N s_257_23: jump b258
        return block_258(state, tracer, fn_state);
    }
    fn block_258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_258_0: read-var gs#397797:u8
        let s_258_0: bool = fn_state.gs_397797;
        // N s_258_1: branch s_258_0 b287 b259
        if s_258_0 {
            return block_287(state, tracer, fn_state);
        } else {
            return block_259(state, tracer, fn_state);
        };
    }
    fn block_259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_259_0: const #12s : i
        let s_259_0: i128 = 12;
        // D s_259_1: read-var u#30589:u32
        let s_259_1: u32 = fn_state.u_30589;
        // D s_259_2: cast zx s_259_1 -> bv
        let s_259_2: Bits = Bits::new(s_259_1 as u128, 32u16);
        // C s_259_3: const #1u : u64
        let s_259_3: u64 = 1;
        // D s_259_4: bit-extract s_259_2 s_259_0 s_259_3
        let s_259_4: Bits = (Bits::new(
            ((s_259_2) >> (s_259_0)).value(),
            u16::try_from(s_259_3).unwrap(),
        ));
        // D s_259_5: cast reint s_259_4 -> u8
        let s_259_5: bool = ((s_259_4.value()) != 0);
        // C s_259_6: const #0s : i
        let s_259_6: i128 = 0;
        // C s_259_7: const #0u : u64
        let s_259_7: u64 = 0;
        // D s_259_8: cast zx s_259_5 -> u64
        let s_259_8: u64 = (s_259_5 as u64);
        // C s_259_9: const #1u : u64
        let s_259_9: u64 = 1;
        // D s_259_10: and s_259_8 s_259_9
        let s_259_10: u64 = ((s_259_8) & (s_259_9));
        // D s_259_11: cmp-eq s_259_10 s_259_9
        let s_259_11: bool = ((s_259_10) == (s_259_9));
        // D s_259_12: lsl s_259_8 s_259_6
        let s_259_12: u64 = s_259_8 << s_259_6;
        // D s_259_13: or s_259_7 s_259_12
        let s_259_13: u64 = ((s_259_7) | (s_259_12));
        // D s_259_14: cmpl s_259_12
        let s_259_14: u64 = !s_259_12;
        // D s_259_15: and s_259_7 s_259_14
        let s_259_15: u64 = ((s_259_7) & (s_259_14));
        // D s_259_16: select s_259_11 s_259_13 s_259_15
        let s_259_16: u64 = if s_259_11 { s_259_13 } else { s_259_15 };
        // D s_259_17: cast trunc s_259_16 -> u8
        let s_259_17: bool = ((s_259_16) != 0);
        // D s_259_18: cast zx s_259_17 -> bv
        let s_259_18: Bits = Bits::new(s_259_17 as u128, 1u16);
        // C s_259_19: const #0u : u8
        let s_259_19: bool = false;
        // C s_259_20: cast zx s_259_19 -> bv
        let s_259_20: Bits = Bits::new(s_259_19 as u128, 1u16);
        // D s_259_21: cmp-ne s_259_18 s_259_20
        let s_259_21: bool = ((s_259_18) != (s_259_20));
        // D s_259_22: write-var gs#397800 <= s_259_21
        fn_state.gs_397800 = s_259_21;
        // N s_259_23: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_260_0: read-var gs#397800:u8
        let s_260_0: bool = fn_state.gs_397800;
        // N s_260_1: branch s_260_0 b286 b261
        if s_260_0 {
            return block_286(state, tracer, fn_state);
        } else {
            return block_261(state, tracer, fn_state);
        };
    }
    fn block_261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_261_0: const #13s : i
        let s_261_0: i128 = 13;
        // D s_261_1: read-var u#30589:u32
        let s_261_1: u32 = fn_state.u_30589;
        // D s_261_2: cast zx s_261_1 -> bv
        let s_261_2: Bits = Bits::new(s_261_1 as u128, 32u16);
        // C s_261_3: const #1u : u64
        let s_261_3: u64 = 1;
        // D s_261_4: bit-extract s_261_2 s_261_0 s_261_3
        let s_261_4: Bits = (Bits::new(
            ((s_261_2) >> (s_261_0)).value(),
            u16::try_from(s_261_3).unwrap(),
        ));
        // D s_261_5: cast reint s_261_4 -> u8
        let s_261_5: bool = ((s_261_4.value()) != 0);
        // C s_261_6: const #0s : i
        let s_261_6: i128 = 0;
        // C s_261_7: const #0u : u64
        let s_261_7: u64 = 0;
        // D s_261_8: cast zx s_261_5 -> u64
        let s_261_8: u64 = (s_261_5 as u64);
        // C s_261_9: const #1u : u64
        let s_261_9: u64 = 1;
        // D s_261_10: and s_261_8 s_261_9
        let s_261_10: u64 = ((s_261_8) & (s_261_9));
        // D s_261_11: cmp-eq s_261_10 s_261_9
        let s_261_11: bool = ((s_261_10) == (s_261_9));
        // D s_261_12: lsl s_261_8 s_261_6
        let s_261_12: u64 = s_261_8 << s_261_6;
        // D s_261_13: or s_261_7 s_261_12
        let s_261_13: u64 = ((s_261_7) | (s_261_12));
        // D s_261_14: cmpl s_261_12
        let s_261_14: u64 = !s_261_12;
        // D s_261_15: and s_261_7 s_261_14
        let s_261_15: u64 = ((s_261_7) & (s_261_14));
        // D s_261_16: select s_261_11 s_261_13 s_261_15
        let s_261_16: u64 = if s_261_11 { s_261_13 } else { s_261_15 };
        // D s_261_17: cast trunc s_261_16 -> u8
        let s_261_17: bool = ((s_261_16) != 0);
        // D s_261_18: cast zx s_261_17 -> bv
        let s_261_18: Bits = Bits::new(s_261_17 as u128, 1u16);
        // C s_261_19: const #0u : u8
        let s_261_19: bool = false;
        // C s_261_20: cast zx s_261_19 -> bv
        let s_261_20: Bits = Bits::new(s_261_19 as u128, 1u16);
        // D s_261_21: cmp-ne s_261_18 s_261_20
        let s_261_21: bool = ((s_261_18) != (s_261_20));
        // D s_261_22: write-var gs#397803 <= s_261_21
        fn_state.gs_397803 = s_261_21;
        // N s_261_23: jump b262
        return block_262(state, tracer, fn_state);
    }
    fn block_262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_262_0: read-var gs#397803:u8
        let s_262_0: bool = fn_state.gs_397803;
        // N s_262_1: branch s_262_0 b285 b263
        if s_262_0 {
            return block_285(state, tracer, fn_state);
        } else {
            return block_263(state, tracer, fn_state);
        };
    }
    fn block_263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_263_0: const #14s : i
        let s_263_0: i128 = 14;
        // D s_263_1: read-var u#30589:u32
        let s_263_1: u32 = fn_state.u_30589;
        // D s_263_2: cast zx s_263_1 -> bv
        let s_263_2: Bits = Bits::new(s_263_1 as u128, 32u16);
        // C s_263_3: const #1u : u64
        let s_263_3: u64 = 1;
        // D s_263_4: bit-extract s_263_2 s_263_0 s_263_3
        let s_263_4: Bits = (Bits::new(
            ((s_263_2) >> (s_263_0)).value(),
            u16::try_from(s_263_3).unwrap(),
        ));
        // D s_263_5: cast reint s_263_4 -> u8
        let s_263_5: bool = ((s_263_4.value()) != 0);
        // C s_263_6: const #0s : i
        let s_263_6: i128 = 0;
        // C s_263_7: const #0u : u64
        let s_263_7: u64 = 0;
        // D s_263_8: cast zx s_263_5 -> u64
        let s_263_8: u64 = (s_263_5 as u64);
        // C s_263_9: const #1u : u64
        let s_263_9: u64 = 1;
        // D s_263_10: and s_263_8 s_263_9
        let s_263_10: u64 = ((s_263_8) & (s_263_9));
        // D s_263_11: cmp-eq s_263_10 s_263_9
        let s_263_11: bool = ((s_263_10) == (s_263_9));
        // D s_263_12: lsl s_263_8 s_263_6
        let s_263_12: u64 = s_263_8 << s_263_6;
        // D s_263_13: or s_263_7 s_263_12
        let s_263_13: u64 = ((s_263_7) | (s_263_12));
        // D s_263_14: cmpl s_263_12
        let s_263_14: u64 = !s_263_12;
        // D s_263_15: and s_263_7 s_263_14
        let s_263_15: u64 = ((s_263_7) & (s_263_14));
        // D s_263_16: select s_263_11 s_263_13 s_263_15
        let s_263_16: u64 = if s_263_11 { s_263_13 } else { s_263_15 };
        // D s_263_17: cast trunc s_263_16 -> u8
        let s_263_17: bool = ((s_263_16) != 0);
        // D s_263_18: cast zx s_263_17 -> bv
        let s_263_18: Bits = Bits::new(s_263_17 as u128, 1u16);
        // C s_263_19: const #0u : u8
        let s_263_19: bool = false;
        // C s_263_20: cast zx s_263_19 -> bv
        let s_263_20: Bits = Bits::new(s_263_19 as u128, 1u16);
        // D s_263_21: cmp-ne s_263_18 s_263_20
        let s_263_21: bool = ((s_263_18) != (s_263_20));
        // D s_263_22: write-var gs#397806 <= s_263_21
        fn_state.gs_397806 = s_263_21;
        // N s_263_23: jump b264
        return block_264(state, tracer, fn_state);
    }
    fn block_264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_264_0: read-var gs#397806:u8
        let s_264_0: bool = fn_state.gs_397806;
        // N s_264_1: branch s_264_0 b284 b265
        if s_264_0 {
            return block_284(state, tracer, fn_state);
        } else {
            return block_265(state, tracer, fn_state);
        };
    }
    fn block_265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_265_0: const #15s : i
        let s_265_0: i128 = 15;
        // D s_265_1: read-var u#30589:u32
        let s_265_1: u32 = fn_state.u_30589;
        // D s_265_2: cast zx s_265_1 -> bv
        let s_265_2: Bits = Bits::new(s_265_1 as u128, 32u16);
        // C s_265_3: const #1u : u64
        let s_265_3: u64 = 1;
        // D s_265_4: bit-extract s_265_2 s_265_0 s_265_3
        let s_265_4: Bits = (Bits::new(
            ((s_265_2) >> (s_265_0)).value(),
            u16::try_from(s_265_3).unwrap(),
        ));
        // D s_265_5: cast reint s_265_4 -> u8
        let s_265_5: bool = ((s_265_4.value()) != 0);
        // C s_265_6: const #0s : i
        let s_265_6: i128 = 0;
        // C s_265_7: const #0u : u64
        let s_265_7: u64 = 0;
        // D s_265_8: cast zx s_265_5 -> u64
        let s_265_8: u64 = (s_265_5 as u64);
        // C s_265_9: const #1u : u64
        let s_265_9: u64 = 1;
        // D s_265_10: and s_265_8 s_265_9
        let s_265_10: u64 = ((s_265_8) & (s_265_9));
        // D s_265_11: cmp-eq s_265_10 s_265_9
        let s_265_11: bool = ((s_265_10) == (s_265_9));
        // D s_265_12: lsl s_265_8 s_265_6
        let s_265_12: u64 = s_265_8 << s_265_6;
        // D s_265_13: or s_265_7 s_265_12
        let s_265_13: u64 = ((s_265_7) | (s_265_12));
        // D s_265_14: cmpl s_265_12
        let s_265_14: u64 = !s_265_12;
        // D s_265_15: and s_265_7 s_265_14
        let s_265_15: u64 = ((s_265_7) & (s_265_14));
        // D s_265_16: select s_265_11 s_265_13 s_265_15
        let s_265_16: u64 = if s_265_11 { s_265_13 } else { s_265_15 };
        // D s_265_17: cast trunc s_265_16 -> u8
        let s_265_17: bool = ((s_265_16) != 0);
        // D s_265_18: cast zx s_265_17 -> bv
        let s_265_18: Bits = Bits::new(s_265_17 as u128, 1u16);
        // C s_265_19: const #0u : u8
        let s_265_19: bool = false;
        // C s_265_20: cast zx s_265_19 -> bv
        let s_265_20: Bits = Bits::new(s_265_19 as u128, 1u16);
        // D s_265_21: cmp-ne s_265_18 s_265_20
        let s_265_21: bool = ((s_265_18) != (s_265_20));
        // D s_265_22: write-var gs#397809 <= s_265_21
        fn_state.gs_397809 = s_265_21;
        // N s_265_23: jump b266
        return block_266(state, tracer, fn_state);
    }
    fn block_266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_266_0: read-var gs#397809:u8
        let s_266_0: bool = fn_state.gs_397809;
        // N s_266_1: branch s_266_0 b283 b267
        if s_266_0 {
            return block_283(state, tracer, fn_state);
        } else {
            return block_267(state, tracer, fn_state);
        };
    }
    fn block_267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_267_0: const #8s : i
        let s_267_0: i128 = 8;
        // D s_267_1: read-var u#30589:u32
        let s_267_1: u32 = fn_state.u_30589;
        // D s_267_2: cast zx s_267_1 -> bv
        let s_267_2: Bits = Bits::new(s_267_1 as u128, 32u16);
        // C s_267_3: const #1u : u64
        let s_267_3: u64 = 1;
        // D s_267_4: bit-extract s_267_2 s_267_0 s_267_3
        let s_267_4: Bits = (Bits::new(
            ((s_267_2) >> (s_267_0)).value(),
            u16::try_from(s_267_3).unwrap(),
        ));
        // D s_267_5: cast reint s_267_4 -> u8
        let s_267_5: bool = ((s_267_4.value()) != 0);
        // C s_267_6: const #0s : i
        let s_267_6: i128 = 0;
        // C s_267_7: const #0u : u64
        let s_267_7: u64 = 0;
        // D s_267_8: cast zx s_267_5 -> u64
        let s_267_8: u64 = (s_267_5 as u64);
        // C s_267_9: const #1u : u64
        let s_267_9: u64 = 1;
        // D s_267_10: and s_267_8 s_267_9
        let s_267_10: u64 = ((s_267_8) & (s_267_9));
        // D s_267_11: cmp-eq s_267_10 s_267_9
        let s_267_11: bool = ((s_267_10) == (s_267_9));
        // D s_267_12: lsl s_267_8 s_267_6
        let s_267_12: u64 = s_267_8 << s_267_6;
        // D s_267_13: or s_267_7 s_267_12
        let s_267_13: u64 = ((s_267_7) | (s_267_12));
        // D s_267_14: cmpl s_267_12
        let s_267_14: u64 = !s_267_12;
        // D s_267_15: and s_267_7 s_267_14
        let s_267_15: u64 = ((s_267_7) & (s_267_14));
        // D s_267_16: select s_267_11 s_267_13 s_267_15
        let s_267_16: u64 = if s_267_11 { s_267_13 } else { s_267_15 };
        // D s_267_17: cast trunc s_267_16 -> u8
        let s_267_17: bool = ((s_267_16) != 0);
        // D s_267_18: cast zx s_267_17 -> bv
        let s_267_18: Bits = Bits::new(s_267_17 as u128, 1u16);
        // C s_267_19: const #0u : u8
        let s_267_19: bool = false;
        // C s_267_20: cast zx s_267_19 -> bv
        let s_267_20: Bits = Bits::new(s_267_19 as u128, 1u16);
        // D s_267_21: cmp-ne s_267_18 s_267_20
        let s_267_21: bool = ((s_267_18) != (s_267_20));
        // D s_267_22: write-var gs#397812 <= s_267_21
        fn_state.gs_397812 = s_267_21;
        // N s_267_23: jump b268
        return block_268(state, tracer, fn_state);
    }
    fn block_268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_268_0: read-var gs#397812:u8
        let s_268_0: bool = fn_state.gs_397812;
        // N s_268_1: branch s_268_0 b282 b269
        if s_268_0 {
            return block_282(state, tracer, fn_state);
        } else {
            return block_269(state, tracer, fn_state);
        };
    }
    fn block_269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_269_0: const #0s : i
        let s_269_0: i128 = 0;
        // D s_269_1: read-var u#30589:u32
        let s_269_1: u32 = fn_state.u_30589;
        // D s_269_2: cast zx s_269_1 -> bv
        let s_269_2: Bits = Bits::new(s_269_1 as u128, 32u16);
        // C s_269_3: const #1u : u64
        let s_269_3: u64 = 1;
        // D s_269_4: bit-extract s_269_2 s_269_0 s_269_3
        let s_269_4: Bits = (Bits::new(
            ((s_269_2) >> (s_269_0)).value(),
            u16::try_from(s_269_3).unwrap(),
        ));
        // D s_269_5: cast reint s_269_4 -> u8
        let s_269_5: bool = ((s_269_4.value()) != 0);
        // C s_269_6: const #0s : i
        let s_269_6: i128 = 0;
        // C s_269_7: const #0u : u64
        let s_269_7: u64 = 0;
        // D s_269_8: cast zx s_269_5 -> u64
        let s_269_8: u64 = (s_269_5 as u64);
        // C s_269_9: const #1u : u64
        let s_269_9: u64 = 1;
        // D s_269_10: and s_269_8 s_269_9
        let s_269_10: u64 = ((s_269_8) & (s_269_9));
        // D s_269_11: cmp-eq s_269_10 s_269_9
        let s_269_11: bool = ((s_269_10) == (s_269_9));
        // D s_269_12: lsl s_269_8 s_269_6
        let s_269_12: u64 = s_269_8 << s_269_6;
        // D s_269_13: or s_269_7 s_269_12
        let s_269_13: u64 = ((s_269_7) | (s_269_12));
        // D s_269_14: cmpl s_269_12
        let s_269_14: u64 = !s_269_12;
        // D s_269_15: and s_269_7 s_269_14
        let s_269_15: u64 = ((s_269_7) & (s_269_14));
        // D s_269_16: select s_269_11 s_269_13 s_269_15
        let s_269_16: u64 = if s_269_11 { s_269_13 } else { s_269_15 };
        // D s_269_17: cast trunc s_269_16 -> u8
        let s_269_17: bool = ((s_269_16) != 0);
        // D s_269_18: cast zx s_269_17 -> bv
        let s_269_18: Bits = Bits::new(s_269_17 as u128, 1u16);
        // C s_269_19: const #0u : u8
        let s_269_19: bool = false;
        // C s_269_20: cast zx s_269_19 -> bv
        let s_269_20: Bits = Bits::new(s_269_19 as u128, 1u16);
        // D s_269_21: cmp-ne s_269_18 s_269_20
        let s_269_21: bool = ((s_269_18) != (s_269_20));
        // D s_269_22: write-var gs#397815 <= s_269_21
        fn_state.gs_397815 = s_269_21;
        // N s_269_23: jump b270
        return block_270(state, tracer, fn_state);
    }
    fn block_270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_270_0: read-var gs#397815:u8
        let s_270_0: bool = fn_state.gs_397815;
        // N s_270_1: branch s_270_0 b281 b271
        if s_270_0 {
            return block_281(state, tracer, fn_state);
        } else {
            return block_271(state, tracer, fn_state);
        };
    }
    fn block_271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_271_0: const #1s : i
        let s_271_0: i128 = 1;
        // D s_271_1: read-var u#30589:u32
        let s_271_1: u32 = fn_state.u_30589;
        // D s_271_2: cast zx s_271_1 -> bv
        let s_271_2: Bits = Bits::new(s_271_1 as u128, 32u16);
        // C s_271_3: const #1u : u64
        let s_271_3: u64 = 1;
        // D s_271_4: bit-extract s_271_2 s_271_0 s_271_3
        let s_271_4: Bits = (Bits::new(
            ((s_271_2) >> (s_271_0)).value(),
            u16::try_from(s_271_3).unwrap(),
        ));
        // D s_271_5: cast reint s_271_4 -> u8
        let s_271_5: bool = ((s_271_4.value()) != 0);
        // C s_271_6: const #0s : i
        let s_271_6: i128 = 0;
        // C s_271_7: const #0u : u64
        let s_271_7: u64 = 0;
        // D s_271_8: cast zx s_271_5 -> u64
        let s_271_8: u64 = (s_271_5 as u64);
        // C s_271_9: const #1u : u64
        let s_271_9: u64 = 1;
        // D s_271_10: and s_271_8 s_271_9
        let s_271_10: u64 = ((s_271_8) & (s_271_9));
        // D s_271_11: cmp-eq s_271_10 s_271_9
        let s_271_11: bool = ((s_271_10) == (s_271_9));
        // D s_271_12: lsl s_271_8 s_271_6
        let s_271_12: u64 = s_271_8 << s_271_6;
        // D s_271_13: or s_271_7 s_271_12
        let s_271_13: u64 = ((s_271_7) | (s_271_12));
        // D s_271_14: cmpl s_271_12
        let s_271_14: u64 = !s_271_12;
        // D s_271_15: and s_271_7 s_271_14
        let s_271_15: u64 = ((s_271_7) & (s_271_14));
        // D s_271_16: select s_271_11 s_271_13 s_271_15
        let s_271_16: u64 = if s_271_11 { s_271_13 } else { s_271_15 };
        // D s_271_17: cast trunc s_271_16 -> u8
        let s_271_17: bool = ((s_271_16) != 0);
        // D s_271_18: cast zx s_271_17 -> bv
        let s_271_18: Bits = Bits::new(s_271_17 as u128, 1u16);
        // C s_271_19: const #0u : u8
        let s_271_19: bool = false;
        // C s_271_20: cast zx s_271_19 -> bv
        let s_271_20: Bits = Bits::new(s_271_19 as u128, 1u16);
        // D s_271_21: cmp-ne s_271_18 s_271_20
        let s_271_21: bool = ((s_271_18) != (s_271_20));
        // D s_271_22: write-var gs#397818 <= s_271_21
        fn_state.gs_397818 = s_271_21;
        // N s_271_23: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_272_0: read-var gs#397818:u8
        let s_272_0: bool = fn_state.gs_397818;
        // N s_272_1: branch s_272_0 b280 b273
        if s_272_0 {
            return block_280(state, tracer, fn_state);
        } else {
            return block_273(state, tracer, fn_state);
        };
    }
    fn block_273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_273_0: const #2s : i
        let s_273_0: i128 = 2;
        // D s_273_1: read-var u#30589:u32
        let s_273_1: u32 = fn_state.u_30589;
        // D s_273_2: cast zx s_273_1 -> bv
        let s_273_2: Bits = Bits::new(s_273_1 as u128, 32u16);
        // C s_273_3: const #1u : u64
        let s_273_3: u64 = 1;
        // D s_273_4: bit-extract s_273_2 s_273_0 s_273_3
        let s_273_4: Bits = (Bits::new(
            ((s_273_2) >> (s_273_0)).value(),
            u16::try_from(s_273_3).unwrap(),
        ));
        // D s_273_5: cast reint s_273_4 -> u8
        let s_273_5: bool = ((s_273_4.value()) != 0);
        // C s_273_6: const #0s : i
        let s_273_6: i128 = 0;
        // C s_273_7: const #0u : u64
        let s_273_7: u64 = 0;
        // D s_273_8: cast zx s_273_5 -> u64
        let s_273_8: u64 = (s_273_5 as u64);
        // C s_273_9: const #1u : u64
        let s_273_9: u64 = 1;
        // D s_273_10: and s_273_8 s_273_9
        let s_273_10: u64 = ((s_273_8) & (s_273_9));
        // D s_273_11: cmp-eq s_273_10 s_273_9
        let s_273_11: bool = ((s_273_10) == (s_273_9));
        // D s_273_12: lsl s_273_8 s_273_6
        let s_273_12: u64 = s_273_8 << s_273_6;
        // D s_273_13: or s_273_7 s_273_12
        let s_273_13: u64 = ((s_273_7) | (s_273_12));
        // D s_273_14: cmpl s_273_12
        let s_273_14: u64 = !s_273_12;
        // D s_273_15: and s_273_7 s_273_14
        let s_273_15: u64 = ((s_273_7) & (s_273_14));
        // D s_273_16: select s_273_11 s_273_13 s_273_15
        let s_273_16: u64 = if s_273_11 { s_273_13 } else { s_273_15 };
        // D s_273_17: cast trunc s_273_16 -> u8
        let s_273_17: bool = ((s_273_16) != 0);
        // D s_273_18: cast zx s_273_17 -> bv
        let s_273_18: Bits = Bits::new(s_273_17 as u128, 1u16);
        // C s_273_19: const #0u : u8
        let s_273_19: bool = false;
        // C s_273_20: cast zx s_273_19 -> bv
        let s_273_20: Bits = Bits::new(s_273_19 as u128, 1u16);
        // D s_273_21: cmp-ne s_273_18 s_273_20
        let s_273_21: bool = ((s_273_18) != (s_273_20));
        // D s_273_22: write-var gs#397821 <= s_273_21
        fn_state.gs_397821 = s_273_21;
        // N s_273_23: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_274_0: read-var gs#397821:u8
        let s_274_0: bool = fn_state.gs_397821;
        // N s_274_1: branch s_274_0 b279 b275
        if s_274_0 {
            return block_279(state, tracer, fn_state);
        } else {
            return block_275(state, tracer, fn_state);
        };
    }
    fn block_275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_275_0: const #3s : i
        let s_275_0: i128 = 3;
        // D s_275_1: read-var u#30589:u32
        let s_275_1: u32 = fn_state.u_30589;
        // D s_275_2: cast zx s_275_1 -> bv
        let s_275_2: Bits = Bits::new(s_275_1 as u128, 32u16);
        // C s_275_3: const #1u : u64
        let s_275_3: u64 = 1;
        // D s_275_4: bit-extract s_275_2 s_275_0 s_275_3
        let s_275_4: Bits = (Bits::new(
            ((s_275_2) >> (s_275_0)).value(),
            u16::try_from(s_275_3).unwrap(),
        ));
        // D s_275_5: cast reint s_275_4 -> u8
        let s_275_5: bool = ((s_275_4.value()) != 0);
        // C s_275_6: const #0s : i
        let s_275_6: i128 = 0;
        // C s_275_7: const #0u : u64
        let s_275_7: u64 = 0;
        // D s_275_8: cast zx s_275_5 -> u64
        let s_275_8: u64 = (s_275_5 as u64);
        // C s_275_9: const #1u : u64
        let s_275_9: u64 = 1;
        // D s_275_10: and s_275_8 s_275_9
        let s_275_10: u64 = ((s_275_8) & (s_275_9));
        // D s_275_11: cmp-eq s_275_10 s_275_9
        let s_275_11: bool = ((s_275_10) == (s_275_9));
        // D s_275_12: lsl s_275_8 s_275_6
        let s_275_12: u64 = s_275_8 << s_275_6;
        // D s_275_13: or s_275_7 s_275_12
        let s_275_13: u64 = ((s_275_7) | (s_275_12));
        // D s_275_14: cmpl s_275_12
        let s_275_14: u64 = !s_275_12;
        // D s_275_15: and s_275_7 s_275_14
        let s_275_15: u64 = ((s_275_7) & (s_275_14));
        // D s_275_16: select s_275_11 s_275_13 s_275_15
        let s_275_16: u64 = if s_275_11 { s_275_13 } else { s_275_15 };
        // D s_275_17: cast trunc s_275_16 -> u8
        let s_275_17: bool = ((s_275_16) != 0);
        // D s_275_18: cast zx s_275_17 -> bv
        let s_275_18: Bits = Bits::new(s_275_17 as u128, 1u16);
        // C s_275_19: const #0u : u8
        let s_275_19: bool = false;
        // C s_275_20: cast zx s_275_19 -> bv
        let s_275_20: Bits = Bits::new(s_275_19 as u128, 1u16);
        // D s_275_21: cmp-ne s_275_18 s_275_20
        let s_275_21: bool = ((s_275_18) != (s_275_20));
        // D s_275_22: write-var gs#397824 <= s_275_21
        fn_state.gs_397824 = s_275_21;
        // N s_275_23: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_276_0: read-var gs#397824:u8
        let s_276_0: bool = fn_state.gs_397824;
        // N s_276_1: branch s_276_0 b278 b277
        if s_276_0 {
            return block_278(state, tracer, fn_state);
        } else {
            return block_277(state, tracer, fn_state);
        };
    }
    fn block_277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_277_0: read-var E:u8
        let s_277_0: bool = fn_state.E;
        // D s_277_1: call decode_aarch32_instrs_SETEND_A1enc_A_txt(s_277_0)
        let s_277_1: () = decode_aarch32_instrs_SETEND_A1enc_A_txt(
            state,
            tracer,
            s_277_0,
        );
        // N s_277_2: return
        return;
    }
    fn block_278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_278_0: panic
        panic!("{:?}", ());
        // N s_278_1: return
        return;
    }
    fn block_279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_279_0: const #1u : u8
        let s_279_0: bool = true;
        // D s_279_1: write-var gs#397824 <= s_279_0
        fn_state.gs_397824 = s_279_0;
        // N s_279_2: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_280_0: const #1u : u8
        let s_280_0: bool = true;
        // D s_280_1: write-var gs#397821 <= s_280_0
        fn_state.gs_397821 = s_280_0;
        // N s_280_2: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_281_0: const #1u : u8
        let s_281_0: bool = true;
        // D s_281_1: write-var gs#397818 <= s_281_0
        fn_state.gs_397818 = s_281_0;
        // N s_281_2: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_282_0: const #1u : u8
        let s_282_0: bool = true;
        // D s_282_1: write-var gs#397815 <= s_282_0
        fn_state.gs_397815 = s_282_0;
        // N s_282_2: jump b270
        return block_270(state, tracer, fn_state);
    }
    fn block_283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_283_0: const #1u : u8
        let s_283_0: bool = true;
        // D s_283_1: write-var gs#397812 <= s_283_0
        fn_state.gs_397812 = s_283_0;
        // N s_283_2: jump b268
        return block_268(state, tracer, fn_state);
    }
    fn block_284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_284_0: const #1u : u8
        let s_284_0: bool = true;
        // D s_284_1: write-var gs#397809 <= s_284_0
        fn_state.gs_397809 = s_284_0;
        // N s_284_2: jump b266
        return block_266(state, tracer, fn_state);
    }
    fn block_285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_285_0: const #1u : u8
        let s_285_0: bool = true;
        // D s_285_1: write-var gs#397806 <= s_285_0
        fn_state.gs_397806 = s_285_0;
        // N s_285_2: jump b264
        return block_264(state, tracer, fn_state);
    }
    fn block_286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_286_0: const #1u : u8
        let s_286_0: bool = true;
        // D s_286_1: write-var gs#397803 <= s_286_0
        fn_state.gs_397803 = s_286_0;
        // N s_286_2: jump b262
        return block_262(state, tracer, fn_state);
    }
    fn block_287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_287_0: const #1u : u8
        let s_287_0: bool = true;
        // D s_287_1: write-var gs#397800 <= s_287_0
        fn_state.gs_397800 = s_287_0;
        // N s_287_2: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_288_0: const #1u : u8
        let s_288_0: bool = true;
        // D s_288_1: write-var gs#397797 <= s_288_0
        fn_state.gs_397797 = s_288_0;
        // N s_288_2: jump b258
        return block_258(state, tracer, fn_state);
    }
    fn block_289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_289_0: read-var merge#var.1:struct
        let s_289_0: u32 = fn_state.merge_var._1;
        // D s_289_1: write-var u#30591 <= s_289_0
        fn_state.u_30591 = s_289_0;
        // C s_289_2: const #25s : i
        let s_289_2: i128 = 25;
        // D s_289_3: read-var u#30591:u32
        let s_289_3: u32 = fn_state.u_30591;
        // D s_289_4: cast zx s_289_3 -> bv
        let s_289_4: Bits = Bits::new(s_289_3 as u128, 32u16);
        // C s_289_5: const #1s : i64
        let s_289_5: i64 = 1;
        // C s_289_6: cast zx s_289_5 -> i
        let s_289_6: i128 = (i128::try_from(s_289_5).unwrap());
        // C s_289_7: const #6s : i
        let s_289_7: i128 = 6;
        // C s_289_8: add s_289_7 s_289_6
        let s_289_8: i128 = (s_289_7 + s_289_6);
        // D s_289_9: bit-extract s_289_4 s_289_2 s_289_8
        let s_289_9: Bits = (Bits::new(
            ((s_289_4) >> (s_289_2)).value(),
            u16::try_from(s_289_8).unwrap(),
        ));
        // D s_289_10: cast reint s_289_9 -> u8
        let s_289_10: u8 = (s_289_9.value() as u8);
        // D s_289_11: cast zx s_289_10 -> bv
        let s_289_11: Bits = Bits::new(s_289_10 as u128, 7u16);
        // C s_289_12: const #121u : u8
        let s_289_12: u8 = 121;
        // C s_289_13: cast zx s_289_12 -> bv
        let s_289_13: Bits = Bits::new(s_289_12 as u128, 7u16);
        // D s_289_14: cmp-eq s_289_11 s_289_13
        let s_289_14: bool = ((s_289_11) == (s_289_13));
        // N s_289_15: branch s_289_14 b3184 b290
        if s_289_14 {
            return block_3184(state, tracer, fn_state);
        } else {
            return block_290(state, tracer, fn_state);
        };
    }
    fn block_290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_290_0: const #0u : u8
        let s_290_0: bool = false;
        // D s_290_1: write-var gs#397836 <= s_290_0
        fn_state.gs_397836 = s_290_0;
        // N s_290_2: jump b291
        return block_291(state, tracer, fn_state);
    }
    fn block_291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_291_0: read-var gs#397836:u8
        let s_291_0: bool = fn_state.gs_397836;
        // N s_291_1: branch s_291_0 b3183 b292
        if s_291_0 {
            return block_3183(state, tracer, fn_state);
        } else {
            return block_292(state, tracer, fn_state);
        };
    }
    fn block_292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_292_0: const #0u : u8
        let s_292_0: bool = false;
        // D s_292_1: write-var gs#397838 <= s_292_0
        fn_state.gs_397838 = s_292_0;
        // N s_292_2: jump b293
        return block_293(state, tracer, fn_state);
    }
    fn block_293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_293_0: read-var gs#397838:u8
        let s_293_0: bool = fn_state.gs_397838;
        // D s_293_1: not s_293_0
        let s_293_1: bool = !s_293_0;
        // N s_293_2: branch s_293_1 b295 b294
        if s_293_1 {
            return block_295(state, tracer, fn_state);
        } else {
            return block_294(state, tracer, fn_state);
        };
    }
    fn block_294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_294_0: const #3350s : i
        let s_294_0: i128 = 3350;
        // C s_294_1: const #14696u : u32
        let s_294_1: u32 = 14696;
        // N s_294_2: write-reg s_294_1 <= s_294_0
        let s_294_2: () = {
            state.write_register::<i128>(s_294_1 as isize, s_294_0);
            tracer.write_register(s_294_1 as isize, s_294_0);
        };
        // C s_294_3: const #24s : i
        let s_294_3: i128 = 24;
        // C s_294_4: const #1s : i
        let s_294_4: i128 = 1;
        // D s_294_5: read-var u#30591:u32
        let s_294_5: u32 = fn_state.u_30591;
        // D s_294_6: cast zx s_294_5 -> bv
        let s_294_6: Bits = Bits::new(s_294_5 as u128, 32u16);
        // D s_294_7: bit-extract s_294_6 s_294_3 s_294_4
        let s_294_7: Bits = (Bits::new(
            ((s_294_6) >> (s_294_3)).value(),
            u16::try_from(s_294_4).unwrap(),
        ));
        // D s_294_8: cast reint s_294_7 -> u8
        let s_294_8: bool = ((s_294_7.value()) != 0);
        // C s_294_9: const #22s : i
        let s_294_9: i128 = 22;
        // C s_294_10: const #1s : i
        let s_294_10: i128 = 1;
        // D s_294_11: read-var u#30591:u32
        let s_294_11: u32 = fn_state.u_30591;
        // D s_294_12: cast zx s_294_11 -> bv
        let s_294_12: Bits = Bits::new(s_294_11 as u128, 32u16);
        // D s_294_13: bit-extract s_294_12 s_294_9 s_294_10
        let s_294_13: Bits = (Bits::new(
            ((s_294_12) >> (s_294_9)).value(),
            u16::try_from(s_294_10).unwrap(),
        ));
        // D s_294_14: cast reint s_294_13 -> u8
        let s_294_14: bool = ((s_294_13.value()) != 0);
        // C s_294_15: const #20s : i
        let s_294_15: i128 = 20;
        // C s_294_16: const #2s : i
        let s_294_16: i128 = 2;
        // D s_294_17: read-var u#30591:u32
        let s_294_17: u32 = fn_state.u_30591;
        // D s_294_18: cast zx s_294_17 -> bv
        let s_294_18: Bits = Bits::new(s_294_17 as u128, 32u16);
        // D s_294_19: bit-extract s_294_18 s_294_15 s_294_16
        let s_294_19: Bits = (Bits::new(
            ((s_294_18) >> (s_294_15)).value(),
            u16::try_from(s_294_16).unwrap(),
        ));
        // D s_294_20: cast reint s_294_19 -> u8
        let s_294_20: u8 = (s_294_19.value() as u8);
        // C s_294_21: const #16s : i
        let s_294_21: i128 = 16;
        // C s_294_22: const #4s : i
        let s_294_22: i128 = 4;
        // D s_294_23: read-var u#30591:u32
        let s_294_23: u32 = fn_state.u_30591;
        // D s_294_24: cast zx s_294_23 -> bv
        let s_294_24: Bits = Bits::new(s_294_23 as u128, 32u16);
        // D s_294_25: bit-extract s_294_24 s_294_21 s_294_22
        let s_294_25: Bits = (Bits::new(
            ((s_294_24) >> (s_294_21)).value(),
            u16::try_from(s_294_22).unwrap(),
        ));
        // D s_294_26: cast reint s_294_25 -> u8
        let s_294_26: u8 = (s_294_25.value() as u8);
        // C s_294_27: const #12s : i
        let s_294_27: i128 = 12;
        // C s_294_28: const #4s : i
        let s_294_28: i128 = 4;
        // D s_294_29: read-var u#30591:u32
        let s_294_29: u32 = fn_state.u_30591;
        // D s_294_30: cast zx s_294_29 -> bv
        let s_294_30: Bits = Bits::new(s_294_29 as u128, 32u16);
        // D s_294_31: bit-extract s_294_30 s_294_27 s_294_28
        let s_294_31: Bits = (Bits::new(
            ((s_294_30) >> (s_294_27)).value(),
            u16::try_from(s_294_28).unwrap(),
        ));
        // D s_294_32: cast reint s_294_31 -> u8
        let s_294_32: u8 = (s_294_31.value() as u8);
        // C s_294_33: const #7s : i
        let s_294_33: i128 = 7;
        // C s_294_34: const #1s : i
        let s_294_34: i128 = 1;
        // D s_294_35: read-var u#30591:u32
        let s_294_35: u32 = fn_state.u_30591;
        // D s_294_36: cast zx s_294_35 -> bv
        let s_294_36: Bits = Bits::new(s_294_35 as u128, 32u16);
        // D s_294_37: bit-extract s_294_36 s_294_33 s_294_34
        let s_294_37: Bits = (Bits::new(
            ((s_294_36) >> (s_294_33)).value(),
            u16::try_from(s_294_34).unwrap(),
        ));
        // D s_294_38: cast reint s_294_37 -> u8
        let s_294_38: bool = ((s_294_37.value()) != 0);
        // C s_294_39: const #6s : i
        let s_294_39: i128 = 6;
        // C s_294_40: const #1s : i
        let s_294_40: i128 = 1;
        // D s_294_41: read-var u#30591:u32
        let s_294_41: u32 = fn_state.u_30591;
        // D s_294_42: cast zx s_294_41 -> bv
        let s_294_42: Bits = Bits::new(s_294_41 as u128, 32u16);
        // D s_294_43: bit-extract s_294_42 s_294_39 s_294_40
        let s_294_43: Bits = (Bits::new(
            ((s_294_42) >> (s_294_39)).value(),
            u16::try_from(s_294_40).unwrap(),
        ));
        // D s_294_44: cast reint s_294_43 -> u8
        let s_294_44: bool = ((s_294_43.value()) != 0);
        // C s_294_45: const #5s : i
        let s_294_45: i128 = 5;
        // C s_294_46: const #1s : i
        let s_294_46: i128 = 1;
        // D s_294_47: read-var u#30591:u32
        let s_294_47: u32 = fn_state.u_30591;
        // D s_294_48: cast zx s_294_47 -> bv
        let s_294_48: Bits = Bits::new(s_294_47 as u128, 32u16);
        // D s_294_49: bit-extract s_294_48 s_294_45 s_294_46
        let s_294_49: Bits = (Bits::new(
            ((s_294_48) >> (s_294_45)).value(),
            u16::try_from(s_294_46).unwrap(),
        ));
        // D s_294_50: cast reint s_294_49 -> u8
        let s_294_50: bool = ((s_294_49.value()) != 0);
        // C s_294_51: const #0s : i
        let s_294_51: i128 = 0;
        // C s_294_52: const #4s : i
        let s_294_52: i128 = 4;
        // D s_294_53: read-var u#30591:u32
        let s_294_53: u32 = fn_state.u_30591;
        // D s_294_54: cast zx s_294_53 -> bv
        let s_294_54: Bits = Bits::new(s_294_53 as u128, 32u16);
        // D s_294_55: bit-extract s_294_54 s_294_51 s_294_52
        let s_294_55: Bits = (Bits::new(
            ((s_294_54) >> (s_294_51)).value(),
            u16::try_from(s_294_52).unwrap(),
        ));
        // D s_294_56: cast reint s_294_55 -> u8
        let s_294_56: u8 = (s_294_55.value() as u8);
        // D s_294_57: call decode_aarch32_instrs_VABA_A1enc_A_txt(s_294_8, s_294_14, s_294_20, s_294_26, s_294_32, s_294_38, s_294_44, s_294_50, s_294_56)
        let s_294_57: () = decode_aarch32_instrs_VABA_A1enc_A_txt(
            state,
            tracer,
            s_294_8,
            s_294_14,
            s_294_20,
            s_294_26,
            s_294_32,
            s_294_38,
            s_294_44,
            s_294_50,
            s_294_56,
        );
        // N s_294_58: return
        return;
    }
    fn block_295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_295_0: read-var merge#var.1:struct
        let s_295_0: u32 = fn_state.merge_var._1;
        // D s_295_1: write-var u#30594 <= s_295_0
        fn_state.u_30594 = s_295_0;
        // C s_295_2: const #25s : i
        let s_295_2: i128 = 25;
        // D s_295_3: read-var u#30594:u32
        let s_295_3: u32 = fn_state.u_30594;
        // D s_295_4: cast zx s_295_3 -> bv
        let s_295_4: Bits = Bits::new(s_295_3 as u128, 32u16);
        // C s_295_5: const #1s : i64
        let s_295_5: i64 = 1;
        // C s_295_6: cast zx s_295_5 -> i
        let s_295_6: i128 = (i128::try_from(s_295_5).unwrap());
        // C s_295_7: const #6s : i
        let s_295_7: i128 = 6;
        // C s_295_8: add s_295_7 s_295_6
        let s_295_8: i128 = (s_295_7 + s_295_6);
        // D s_295_9: bit-extract s_295_4 s_295_2 s_295_8
        let s_295_9: Bits = (Bits::new(
            ((s_295_4) >> (s_295_2)).value(),
            u16::try_from(s_295_8).unwrap(),
        ));
        // D s_295_10: cast reint s_295_9 -> u8
        let s_295_10: u8 = (s_295_9.value() as u8);
        // D s_295_11: cast zx s_295_10 -> bv
        let s_295_11: Bits = Bits::new(s_295_10 as u128, 7u16);
        // C s_295_12: const #121u : u8
        let s_295_12: u8 = 121;
        // C s_295_13: cast zx s_295_12 -> bv
        let s_295_13: Bits = Bits::new(s_295_12 as u128, 7u16);
        // D s_295_14: cmp-eq s_295_11 s_295_13
        let s_295_14: bool = ((s_295_11) == (s_295_13));
        // N s_295_15: branch s_295_14 b3173 b296
        if s_295_14 {
            return block_3173(state, tracer, fn_state);
        } else {
            return block_296(state, tracer, fn_state);
        };
    }
    fn block_296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_296_0: const #0u : u8
        let s_296_0: bool = false;
        // D s_296_1: write-var gs#397873 <= s_296_0
        fn_state.gs_397873 = s_296_0;
        // N s_296_2: jump b297
        return block_297(state, tracer, fn_state);
    }
    fn block_297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_297_0: read-var gs#397873:u8
        let s_297_0: bool = fn_state.gs_397873;
        // N s_297_1: branch s_297_0 b3172 b298
        if s_297_0 {
            return block_3172(state, tracer, fn_state);
        } else {
            return block_298(state, tracer, fn_state);
        };
    }
    fn block_298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_298_0: const #0u : u8
        let s_298_0: bool = false;
        // D s_298_1: write-var gs#397875 <= s_298_0
        fn_state.gs_397875 = s_298_0;
        // N s_298_2: jump b299
        return block_299(state, tracer, fn_state);
    }
    fn block_299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_299_0: read-var gs#397875:u8
        let s_299_0: bool = fn_state.gs_397875;
        // D s_299_1: not s_299_0
        let s_299_1: bool = !s_299_0;
        // N s_299_2: branch s_299_1 b301 b300
        if s_299_1 {
            return block_301(state, tracer, fn_state);
        } else {
            return block_300(state, tracer, fn_state);
        };
    }
    fn block_300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_300_0: const #3351s : i
        let s_300_0: i128 = 3351;
        // C s_300_1: const #14696u : u32
        let s_300_1: u32 = 14696;
        // N s_300_2: write-reg s_300_1 <= s_300_0
        let s_300_2: () = {
            state.write_register::<i128>(s_300_1 as isize, s_300_0);
            tracer.write_register(s_300_1 as isize, s_300_0);
        };
        // C s_300_3: const #24s : i
        let s_300_3: i128 = 24;
        // C s_300_4: const #1s : i
        let s_300_4: i128 = 1;
        // D s_300_5: read-var u#30594:u32
        let s_300_5: u32 = fn_state.u_30594;
        // D s_300_6: cast zx s_300_5 -> bv
        let s_300_6: Bits = Bits::new(s_300_5 as u128, 32u16);
        // D s_300_7: bit-extract s_300_6 s_300_3 s_300_4
        let s_300_7: Bits = (Bits::new(
            ((s_300_6) >> (s_300_3)).value(),
            u16::try_from(s_300_4).unwrap(),
        ));
        // D s_300_8: cast reint s_300_7 -> u8
        let s_300_8: bool = ((s_300_7.value()) != 0);
        // C s_300_9: const #22s : i
        let s_300_9: i128 = 22;
        // C s_300_10: const #1s : i
        let s_300_10: i128 = 1;
        // D s_300_11: read-var u#30594:u32
        let s_300_11: u32 = fn_state.u_30594;
        // D s_300_12: cast zx s_300_11 -> bv
        let s_300_12: Bits = Bits::new(s_300_11 as u128, 32u16);
        // D s_300_13: bit-extract s_300_12 s_300_9 s_300_10
        let s_300_13: Bits = (Bits::new(
            ((s_300_12) >> (s_300_9)).value(),
            u16::try_from(s_300_10).unwrap(),
        ));
        // D s_300_14: cast reint s_300_13 -> u8
        let s_300_14: bool = ((s_300_13.value()) != 0);
        // C s_300_15: const #20s : i
        let s_300_15: i128 = 20;
        // C s_300_16: const #2s : i
        let s_300_16: i128 = 2;
        // D s_300_17: read-var u#30594:u32
        let s_300_17: u32 = fn_state.u_30594;
        // D s_300_18: cast zx s_300_17 -> bv
        let s_300_18: Bits = Bits::new(s_300_17 as u128, 32u16);
        // D s_300_19: bit-extract s_300_18 s_300_15 s_300_16
        let s_300_19: Bits = (Bits::new(
            ((s_300_18) >> (s_300_15)).value(),
            u16::try_from(s_300_16).unwrap(),
        ));
        // D s_300_20: cast reint s_300_19 -> u8
        let s_300_20: u8 = (s_300_19.value() as u8);
        // C s_300_21: const #16s : i
        let s_300_21: i128 = 16;
        // C s_300_22: const #4s : i
        let s_300_22: i128 = 4;
        // D s_300_23: read-var u#30594:u32
        let s_300_23: u32 = fn_state.u_30594;
        // D s_300_24: cast zx s_300_23 -> bv
        let s_300_24: Bits = Bits::new(s_300_23 as u128, 32u16);
        // D s_300_25: bit-extract s_300_24 s_300_21 s_300_22
        let s_300_25: Bits = (Bits::new(
            ((s_300_24) >> (s_300_21)).value(),
            u16::try_from(s_300_22).unwrap(),
        ));
        // D s_300_26: cast reint s_300_25 -> u8
        let s_300_26: u8 = (s_300_25.value() as u8);
        // C s_300_27: const #12s : i
        let s_300_27: i128 = 12;
        // C s_300_28: const #4s : i
        let s_300_28: i128 = 4;
        // D s_300_29: read-var u#30594:u32
        let s_300_29: u32 = fn_state.u_30594;
        // D s_300_30: cast zx s_300_29 -> bv
        let s_300_30: Bits = Bits::new(s_300_29 as u128, 32u16);
        // D s_300_31: bit-extract s_300_30 s_300_27 s_300_28
        let s_300_31: Bits = (Bits::new(
            ((s_300_30) >> (s_300_27)).value(),
            u16::try_from(s_300_28).unwrap(),
        ));
        // D s_300_32: cast reint s_300_31 -> u8
        let s_300_32: u8 = (s_300_31.value() as u8);
        // C s_300_33: const #7s : i
        let s_300_33: i128 = 7;
        // C s_300_34: const #1s : i
        let s_300_34: i128 = 1;
        // D s_300_35: read-var u#30594:u32
        let s_300_35: u32 = fn_state.u_30594;
        // D s_300_36: cast zx s_300_35 -> bv
        let s_300_36: Bits = Bits::new(s_300_35 as u128, 32u16);
        // D s_300_37: bit-extract s_300_36 s_300_33 s_300_34
        let s_300_37: Bits = (Bits::new(
            ((s_300_36) >> (s_300_33)).value(),
            u16::try_from(s_300_34).unwrap(),
        ));
        // D s_300_38: cast reint s_300_37 -> u8
        let s_300_38: bool = ((s_300_37.value()) != 0);
        // C s_300_39: const #5s : i
        let s_300_39: i128 = 5;
        // C s_300_40: const #1s : i
        let s_300_40: i128 = 1;
        // D s_300_41: read-var u#30594:u32
        let s_300_41: u32 = fn_state.u_30594;
        // D s_300_42: cast zx s_300_41 -> bv
        let s_300_42: Bits = Bits::new(s_300_41 as u128, 32u16);
        // D s_300_43: bit-extract s_300_42 s_300_39 s_300_40
        let s_300_43: Bits = (Bits::new(
            ((s_300_42) >> (s_300_39)).value(),
            u16::try_from(s_300_40).unwrap(),
        ));
        // D s_300_44: cast reint s_300_43 -> u8
        let s_300_44: bool = ((s_300_43.value()) != 0);
        // C s_300_45: const #0s : i
        let s_300_45: i128 = 0;
        // C s_300_46: const #4s : i
        let s_300_46: i128 = 4;
        // D s_300_47: read-var u#30594:u32
        let s_300_47: u32 = fn_state.u_30594;
        // D s_300_48: cast zx s_300_47 -> bv
        let s_300_48: Bits = Bits::new(s_300_47 as u128, 32u16);
        // D s_300_49: bit-extract s_300_48 s_300_45 s_300_46
        let s_300_49: Bits = (Bits::new(
            ((s_300_48) >> (s_300_45)).value(),
            u16::try_from(s_300_46).unwrap(),
        ));
        // D s_300_50: cast reint s_300_49 -> u8
        let s_300_50: u8 = (s_300_49.value() as u8);
        // D s_300_51: call decode_aarch32_instrs_VABA_A2enc_A_txt(s_300_8, s_300_14, s_300_20, s_300_26, s_300_32, s_300_38, s_300_44, s_300_50)
        let s_300_51: () = decode_aarch32_instrs_VABA_A2enc_A_txt(
            state,
            tracer,
            s_300_8,
            s_300_14,
            s_300_20,
            s_300_26,
            s_300_32,
            s_300_38,
            s_300_44,
            s_300_50,
        );
        // N s_300_52: return
        return;
    }
    fn block_301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_301_0: read-var merge#var.1:struct
        let s_301_0: u32 = fn_state.merge_var._1;
        // D s_301_1: write-var u#30604 <= s_301_0
        fn_state.u_30604 = s_301_0;
        // C s_301_2: const #23s : i
        let s_301_2: i128 = 23;
        // D s_301_3: read-var u#30604:u32
        let s_301_3: u32 = fn_state.u_30604;
        // D s_301_4: cast zx s_301_3 -> bv
        let s_301_4: Bits = Bits::new(s_301_3 as u128, 32u16);
        // C s_301_5: const #1s : i64
        let s_301_5: i64 = 1;
        // C s_301_6: cast zx s_301_5 -> i
        let s_301_6: i128 = (i128::try_from(s_301_5).unwrap());
        // C s_301_7: const #8s : i
        let s_301_7: i128 = 8;
        // C s_301_8: add s_301_7 s_301_6
        let s_301_8: i128 = (s_301_7 + s_301_6);
        // D s_301_9: bit-extract s_301_4 s_301_2 s_301_8
        let s_301_9: Bits = (Bits::new(
            ((s_301_4) >> (s_301_2)).value(),
            u16::try_from(s_301_8).unwrap(),
        ));
        // D s_301_10: cast reint s_301_9 -> u9
        let s_301_10: u16 = (s_301_9.value() as u16);
        // D s_301_11: cast zx s_301_10 -> bv
        let s_301_11: Bits = Bits::new(s_301_10 as u128, 9u16);
        // C s_301_12: const #486u : u9
        let s_301_12: u16 = 486;
        // C s_301_13: cast zx s_301_12 -> bv
        let s_301_13: Bits = Bits::new(s_301_12 as u128, 9u16);
        // D s_301_14: cmp-eq s_301_11 s_301_13
        let s_301_14: bool = ((s_301_11) == (s_301_13));
        // N s_301_15: branch s_301_14 b3165 b302
        if s_301_14 {
            return block_3165(state, tracer, fn_state);
        } else {
            return block_302(state, tracer, fn_state);
        };
    }
    fn block_302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_302_0: const #0u : u8
        let s_302_0: bool = false;
        // D s_302_1: write-var gs#397905 <= s_302_0
        fn_state.gs_397905 = s_302_0;
        // N s_302_2: jump b303
        return block_303(state, tracer, fn_state);
    }
    fn block_303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_303_0: read-var gs#397905:u8
        let s_303_0: bool = fn_state.gs_397905;
        // N s_303_1: branch s_303_0 b3164 b304
        if s_303_0 {
            return block_3164(state, tracer, fn_state);
        } else {
            return block_304(state, tracer, fn_state);
        };
    }
    fn block_304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_304_0: const #0u : u8
        let s_304_0: bool = false;
        // D s_304_1: write-var gs#397907 <= s_304_0
        fn_state.gs_397907 = s_304_0;
        // N s_304_2: jump b305
        return block_305(state, tracer, fn_state);
    }
    fn block_305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_305_0: read-var gs#397907:u8
        let s_305_0: bool = fn_state.gs_397907;
        // D s_305_1: not s_305_0
        let s_305_1: bool = !s_305_0;
        // N s_305_2: branch s_305_1 b307 b306
        if s_305_1 {
            return block_307(state, tracer, fn_state);
        } else {
            return block_306(state, tracer, fn_state);
        };
    }
    fn block_306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_306_0: const #3354s : i
        let s_306_0: i128 = 3354;
        // C s_306_1: const #14696u : u32
        let s_306_1: u32 = 14696;
        // N s_306_2: write-reg s_306_1 <= s_306_0
        let s_306_2: () = {
            state.write_register::<i128>(s_306_1 as isize, s_306_0);
            tracer.write_register(s_306_1 as isize, s_306_0);
        };
        // C s_306_3: const #22s : i
        let s_306_3: i128 = 22;
        // C s_306_4: const #1s : i
        let s_306_4: i128 = 1;
        // D s_306_5: read-var u#30604:u32
        let s_306_5: u32 = fn_state.u_30604;
        // D s_306_6: cast zx s_306_5 -> bv
        let s_306_6: Bits = Bits::new(s_306_5 as u128, 32u16);
        // D s_306_7: bit-extract s_306_6 s_306_3 s_306_4
        let s_306_7: Bits = (Bits::new(
            ((s_306_6) >> (s_306_3)).value(),
            u16::try_from(s_306_4).unwrap(),
        ));
        // D s_306_8: cast reint s_306_7 -> u8
        let s_306_8: bool = ((s_306_7.value()) != 0);
        // C s_306_9: const #20s : i
        let s_306_9: i128 = 20;
        // C s_306_10: const #1s : i
        let s_306_10: i128 = 1;
        // D s_306_11: read-var u#30604:u32
        let s_306_11: u32 = fn_state.u_30604;
        // D s_306_12: cast zx s_306_11 -> bv
        let s_306_12: Bits = Bits::new(s_306_11 as u128, 32u16);
        // D s_306_13: bit-extract s_306_12 s_306_9 s_306_10
        let s_306_13: Bits = (Bits::new(
            ((s_306_12) >> (s_306_9)).value(),
            u16::try_from(s_306_10).unwrap(),
        ));
        // D s_306_14: cast reint s_306_13 -> u8
        let s_306_14: bool = ((s_306_13.value()) != 0);
        // C s_306_15: const #16s : i
        let s_306_15: i128 = 16;
        // C s_306_16: const #4s : i
        let s_306_16: i128 = 4;
        // D s_306_17: read-var u#30604:u32
        let s_306_17: u32 = fn_state.u_30604;
        // D s_306_18: cast zx s_306_17 -> bv
        let s_306_18: Bits = Bits::new(s_306_17 as u128, 32u16);
        // D s_306_19: bit-extract s_306_18 s_306_15 s_306_16
        let s_306_19: Bits = (Bits::new(
            ((s_306_18) >> (s_306_15)).value(),
            u16::try_from(s_306_16).unwrap(),
        ));
        // D s_306_20: cast reint s_306_19 -> u8
        let s_306_20: u8 = (s_306_19.value() as u8);
        // C s_306_21: const #12s : i
        let s_306_21: i128 = 12;
        // C s_306_22: const #4s : i
        let s_306_22: i128 = 4;
        // D s_306_23: read-var u#30604:u32
        let s_306_23: u32 = fn_state.u_30604;
        // D s_306_24: cast zx s_306_23 -> bv
        let s_306_24: Bits = Bits::new(s_306_23 as u128, 32u16);
        // D s_306_25: bit-extract s_306_24 s_306_21 s_306_22
        let s_306_25: Bits = (Bits::new(
            ((s_306_24) >> (s_306_21)).value(),
            u16::try_from(s_306_22).unwrap(),
        ));
        // D s_306_26: cast reint s_306_25 -> u8
        let s_306_26: u8 = (s_306_25.value() as u8);
        // C s_306_27: const #7s : i
        let s_306_27: i128 = 7;
        // C s_306_28: const #1s : i
        let s_306_28: i128 = 1;
        // D s_306_29: read-var u#30604:u32
        let s_306_29: u32 = fn_state.u_30604;
        // D s_306_30: cast zx s_306_29 -> bv
        let s_306_30: Bits = Bits::new(s_306_29 as u128, 32u16);
        // D s_306_31: bit-extract s_306_30 s_306_27 s_306_28
        let s_306_31: Bits = (Bits::new(
            ((s_306_30) >> (s_306_27)).value(),
            u16::try_from(s_306_28).unwrap(),
        ));
        // D s_306_32: cast reint s_306_31 -> u8
        let s_306_32: bool = ((s_306_31.value()) != 0);
        // C s_306_33: const #6s : i
        let s_306_33: i128 = 6;
        // C s_306_34: const #1s : i
        let s_306_34: i128 = 1;
        // D s_306_35: read-var u#30604:u32
        let s_306_35: u32 = fn_state.u_30604;
        // D s_306_36: cast zx s_306_35 -> bv
        let s_306_36: Bits = Bits::new(s_306_35 as u128, 32u16);
        // D s_306_37: bit-extract s_306_36 s_306_33 s_306_34
        let s_306_37: Bits = (Bits::new(
            ((s_306_36) >> (s_306_33)).value(),
            u16::try_from(s_306_34).unwrap(),
        ));
        // D s_306_38: cast reint s_306_37 -> u8
        let s_306_38: bool = ((s_306_37.value()) != 0);
        // C s_306_39: const #5s : i
        let s_306_39: i128 = 5;
        // C s_306_40: const #1s : i
        let s_306_40: i128 = 1;
        // D s_306_41: read-var u#30604:u32
        let s_306_41: u32 = fn_state.u_30604;
        // D s_306_42: cast zx s_306_41 -> bv
        let s_306_42: Bits = Bits::new(s_306_41 as u128, 32u16);
        // D s_306_43: bit-extract s_306_42 s_306_39 s_306_40
        let s_306_43: Bits = (Bits::new(
            ((s_306_42) >> (s_306_39)).value(),
            u16::try_from(s_306_40).unwrap(),
        ));
        // D s_306_44: cast reint s_306_43 -> u8
        let s_306_44: bool = ((s_306_43.value()) != 0);
        // C s_306_45: const #0s : i
        let s_306_45: i128 = 0;
        // C s_306_46: const #4s : i
        let s_306_46: i128 = 4;
        // D s_306_47: read-var u#30604:u32
        let s_306_47: u32 = fn_state.u_30604;
        // D s_306_48: cast zx s_306_47 -> bv
        let s_306_48: Bits = Bits::new(s_306_47 as u128, 32u16);
        // D s_306_49: bit-extract s_306_48 s_306_45 s_306_46
        let s_306_49: Bits = (Bits::new(
            ((s_306_48) >> (s_306_45)).value(),
            u16::try_from(s_306_46).unwrap(),
        ));
        // D s_306_50: cast reint s_306_49 -> u8
        let s_306_50: u8 = (s_306_49.value() as u8);
        // D s_306_51: call decode_aarch32_instrs_VABD_f_A1enc_A_txt(s_306_8, s_306_14, s_306_20, s_306_26, s_306_32, s_306_38, s_306_44, s_306_50)
        let s_306_51: () = decode_aarch32_instrs_VABD_f_A1enc_A_txt(
            state,
            tracer,
            s_306_8,
            s_306_14,
            s_306_20,
            s_306_26,
            s_306_32,
            s_306_38,
            s_306_44,
            s_306_50,
        );
        // N s_306_52: return
        return;
    }
    fn block_307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_307_0: read-var merge#var.1:struct
        let s_307_0: u32 = fn_state.merge_var._1;
        // D s_307_1: write-var u#30613 <= s_307_0
        fn_state.u_30613 = s_307_0;
        // C s_307_2: const #25s : i
        let s_307_2: i128 = 25;
        // D s_307_3: read-var u#30613:u32
        let s_307_3: u32 = fn_state.u_30613;
        // D s_307_4: cast zx s_307_3 -> bv
        let s_307_4: Bits = Bits::new(s_307_3 as u128, 32u16);
        // C s_307_5: const #1s : i64
        let s_307_5: i64 = 1;
        // C s_307_6: cast zx s_307_5 -> i
        let s_307_6: i128 = (i128::try_from(s_307_5).unwrap());
        // C s_307_7: const #6s : i
        let s_307_7: i128 = 6;
        // C s_307_8: add s_307_7 s_307_6
        let s_307_8: i128 = (s_307_7 + s_307_6);
        // D s_307_9: bit-extract s_307_4 s_307_2 s_307_8
        let s_307_9: Bits = (Bits::new(
            ((s_307_4) >> (s_307_2)).value(),
            u16::try_from(s_307_8).unwrap(),
        ));
        // D s_307_10: cast reint s_307_9 -> u8
        let s_307_10: u8 = (s_307_9.value() as u8);
        // D s_307_11: cast zx s_307_10 -> bv
        let s_307_11: Bits = Bits::new(s_307_10 as u128, 7u16);
        // C s_307_12: const #121u : u8
        let s_307_12: u8 = 121;
        // C s_307_13: cast zx s_307_12 -> bv
        let s_307_13: Bits = Bits::new(s_307_12 as u128, 7u16);
        // D s_307_14: cmp-eq s_307_11 s_307_13
        let s_307_14: bool = ((s_307_11) == (s_307_13));
        // N s_307_15: branch s_307_14 b3157 b308
        if s_307_14 {
            return block_3157(state, tracer, fn_state);
        } else {
            return block_308(state, tracer, fn_state);
        };
    }
    fn block_308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_308_0: const #0u : u8
        let s_308_0: bool = false;
        // D s_308_1: write-var gs#397937 <= s_308_0
        fn_state.gs_397937 = s_308_0;
        // N s_308_2: jump b309
        return block_309(state, tracer, fn_state);
    }
    fn block_309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_309_0: read-var gs#397937:u8
        let s_309_0: bool = fn_state.gs_397937;
        // N s_309_1: branch s_309_0 b3156 b310
        if s_309_0 {
            return block_3156(state, tracer, fn_state);
        } else {
            return block_310(state, tracer, fn_state);
        };
    }
    fn block_310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_310_0: const #0u : u8
        let s_310_0: bool = false;
        // D s_310_1: write-var gs#397939 <= s_310_0
        fn_state.gs_397939 = s_310_0;
        // N s_310_2: jump b311
        return block_311(state, tracer, fn_state);
    }
    fn block_311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_311_0: read-var gs#397939:u8
        let s_311_0: bool = fn_state.gs_397939;
        // D s_311_1: not s_311_0
        let s_311_1: bool = !s_311_0;
        // N s_311_2: branch s_311_1 b313 b312
        if s_311_1 {
            return block_313(state, tracer, fn_state);
        } else {
            return block_312(state, tracer, fn_state);
        };
    }
    fn block_312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_312_0: const #3356s : i
        let s_312_0: i128 = 3356;
        // C s_312_1: const #14696u : u32
        let s_312_1: u32 = 14696;
        // N s_312_2: write-reg s_312_1 <= s_312_0
        let s_312_2: () = {
            state.write_register::<i128>(s_312_1 as isize, s_312_0);
            tracer.write_register(s_312_1 as isize, s_312_0);
        };
        // C s_312_3: const #24s : i
        let s_312_3: i128 = 24;
        // C s_312_4: const #1s : i
        let s_312_4: i128 = 1;
        // D s_312_5: read-var u#30613:u32
        let s_312_5: u32 = fn_state.u_30613;
        // D s_312_6: cast zx s_312_5 -> bv
        let s_312_6: Bits = Bits::new(s_312_5 as u128, 32u16);
        // D s_312_7: bit-extract s_312_6 s_312_3 s_312_4
        let s_312_7: Bits = (Bits::new(
            ((s_312_6) >> (s_312_3)).value(),
            u16::try_from(s_312_4).unwrap(),
        ));
        // D s_312_8: cast reint s_312_7 -> u8
        let s_312_8: bool = ((s_312_7.value()) != 0);
        // C s_312_9: const #22s : i
        let s_312_9: i128 = 22;
        // C s_312_10: const #1s : i
        let s_312_10: i128 = 1;
        // D s_312_11: read-var u#30613:u32
        let s_312_11: u32 = fn_state.u_30613;
        // D s_312_12: cast zx s_312_11 -> bv
        let s_312_12: Bits = Bits::new(s_312_11 as u128, 32u16);
        // D s_312_13: bit-extract s_312_12 s_312_9 s_312_10
        let s_312_13: Bits = (Bits::new(
            ((s_312_12) >> (s_312_9)).value(),
            u16::try_from(s_312_10).unwrap(),
        ));
        // D s_312_14: cast reint s_312_13 -> u8
        let s_312_14: bool = ((s_312_13.value()) != 0);
        // C s_312_15: const #20s : i
        let s_312_15: i128 = 20;
        // C s_312_16: const #2s : i
        let s_312_16: i128 = 2;
        // D s_312_17: read-var u#30613:u32
        let s_312_17: u32 = fn_state.u_30613;
        // D s_312_18: cast zx s_312_17 -> bv
        let s_312_18: Bits = Bits::new(s_312_17 as u128, 32u16);
        // D s_312_19: bit-extract s_312_18 s_312_15 s_312_16
        let s_312_19: Bits = (Bits::new(
            ((s_312_18) >> (s_312_15)).value(),
            u16::try_from(s_312_16).unwrap(),
        ));
        // D s_312_20: cast reint s_312_19 -> u8
        let s_312_20: u8 = (s_312_19.value() as u8);
        // C s_312_21: const #16s : i
        let s_312_21: i128 = 16;
        // C s_312_22: const #4s : i
        let s_312_22: i128 = 4;
        // D s_312_23: read-var u#30613:u32
        let s_312_23: u32 = fn_state.u_30613;
        // D s_312_24: cast zx s_312_23 -> bv
        let s_312_24: Bits = Bits::new(s_312_23 as u128, 32u16);
        // D s_312_25: bit-extract s_312_24 s_312_21 s_312_22
        let s_312_25: Bits = (Bits::new(
            ((s_312_24) >> (s_312_21)).value(),
            u16::try_from(s_312_22).unwrap(),
        ));
        // D s_312_26: cast reint s_312_25 -> u8
        let s_312_26: u8 = (s_312_25.value() as u8);
        // C s_312_27: const #12s : i
        let s_312_27: i128 = 12;
        // C s_312_28: const #4s : i
        let s_312_28: i128 = 4;
        // D s_312_29: read-var u#30613:u32
        let s_312_29: u32 = fn_state.u_30613;
        // D s_312_30: cast zx s_312_29 -> bv
        let s_312_30: Bits = Bits::new(s_312_29 as u128, 32u16);
        // D s_312_31: bit-extract s_312_30 s_312_27 s_312_28
        let s_312_31: Bits = (Bits::new(
            ((s_312_30) >> (s_312_27)).value(),
            u16::try_from(s_312_28).unwrap(),
        ));
        // D s_312_32: cast reint s_312_31 -> u8
        let s_312_32: u8 = (s_312_31.value() as u8);
        // C s_312_33: const #7s : i
        let s_312_33: i128 = 7;
        // C s_312_34: const #1s : i
        let s_312_34: i128 = 1;
        // D s_312_35: read-var u#30613:u32
        let s_312_35: u32 = fn_state.u_30613;
        // D s_312_36: cast zx s_312_35 -> bv
        let s_312_36: Bits = Bits::new(s_312_35 as u128, 32u16);
        // D s_312_37: bit-extract s_312_36 s_312_33 s_312_34
        let s_312_37: Bits = (Bits::new(
            ((s_312_36) >> (s_312_33)).value(),
            u16::try_from(s_312_34).unwrap(),
        ));
        // D s_312_38: cast reint s_312_37 -> u8
        let s_312_38: bool = ((s_312_37.value()) != 0);
        // C s_312_39: const #6s : i
        let s_312_39: i128 = 6;
        // C s_312_40: const #1s : i
        let s_312_40: i128 = 1;
        // D s_312_41: read-var u#30613:u32
        let s_312_41: u32 = fn_state.u_30613;
        // D s_312_42: cast zx s_312_41 -> bv
        let s_312_42: Bits = Bits::new(s_312_41 as u128, 32u16);
        // D s_312_43: bit-extract s_312_42 s_312_39 s_312_40
        let s_312_43: Bits = (Bits::new(
            ((s_312_42) >> (s_312_39)).value(),
            u16::try_from(s_312_40).unwrap(),
        ));
        // D s_312_44: cast reint s_312_43 -> u8
        let s_312_44: bool = ((s_312_43.value()) != 0);
        // C s_312_45: const #5s : i
        let s_312_45: i128 = 5;
        // C s_312_46: const #1s : i
        let s_312_46: i128 = 1;
        // D s_312_47: read-var u#30613:u32
        let s_312_47: u32 = fn_state.u_30613;
        // D s_312_48: cast zx s_312_47 -> bv
        let s_312_48: Bits = Bits::new(s_312_47 as u128, 32u16);
        // D s_312_49: bit-extract s_312_48 s_312_45 s_312_46
        let s_312_49: Bits = (Bits::new(
            ((s_312_48) >> (s_312_45)).value(),
            u16::try_from(s_312_46).unwrap(),
        ));
        // D s_312_50: cast reint s_312_49 -> u8
        let s_312_50: bool = ((s_312_49.value()) != 0);
        // C s_312_51: const #0s : i
        let s_312_51: i128 = 0;
        // C s_312_52: const #4s : i
        let s_312_52: i128 = 4;
        // D s_312_53: read-var u#30613:u32
        let s_312_53: u32 = fn_state.u_30613;
        // D s_312_54: cast zx s_312_53 -> bv
        let s_312_54: Bits = Bits::new(s_312_53 as u128, 32u16);
        // D s_312_55: bit-extract s_312_54 s_312_51 s_312_52
        let s_312_55: Bits = (Bits::new(
            ((s_312_54) >> (s_312_51)).value(),
            u16::try_from(s_312_52).unwrap(),
        ));
        // D s_312_56: cast reint s_312_55 -> u8
        let s_312_56: u8 = (s_312_55.value() as u8);
        // D s_312_57: call decode_aarch32_instrs_VABD_i_A1enc_A_txt(s_312_8, s_312_14, s_312_20, s_312_26, s_312_32, s_312_38, s_312_44, s_312_50, s_312_56)
        let s_312_57: () = decode_aarch32_instrs_VABD_i_A1enc_A_txt(
            state,
            tracer,
            s_312_8,
            s_312_14,
            s_312_20,
            s_312_26,
            s_312_32,
            s_312_38,
            s_312_44,
            s_312_50,
            s_312_56,
        );
        // N s_312_58: return
        return;
    }
    fn block_313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_313_0: read-var merge#var.1:struct
        let s_313_0: u32 = fn_state.merge_var._1;
        // D s_313_1: write-var u#30624 <= s_313_0
        fn_state.u_30624 = s_313_0;
        // C s_313_2: const #25s : i
        let s_313_2: i128 = 25;
        // D s_313_3: read-var u#30624:u32
        let s_313_3: u32 = fn_state.u_30624;
        // D s_313_4: cast zx s_313_3 -> bv
        let s_313_4: Bits = Bits::new(s_313_3 as u128, 32u16);
        // C s_313_5: const #1s : i64
        let s_313_5: i64 = 1;
        // C s_313_6: cast zx s_313_5 -> i
        let s_313_6: i128 = (i128::try_from(s_313_5).unwrap());
        // C s_313_7: const #6s : i
        let s_313_7: i128 = 6;
        // C s_313_8: add s_313_7 s_313_6
        let s_313_8: i128 = (s_313_7 + s_313_6);
        // D s_313_9: bit-extract s_313_4 s_313_2 s_313_8
        let s_313_9: Bits = (Bits::new(
            ((s_313_4) >> (s_313_2)).value(),
            u16::try_from(s_313_8).unwrap(),
        ));
        // D s_313_10: cast reint s_313_9 -> u8
        let s_313_10: u8 = (s_313_9.value() as u8);
        // D s_313_11: cast zx s_313_10 -> bv
        let s_313_11: Bits = Bits::new(s_313_10 as u128, 7u16);
        // C s_313_12: const #121u : u8
        let s_313_12: u8 = 121;
        // C s_313_13: cast zx s_313_12 -> bv
        let s_313_13: Bits = Bits::new(s_313_12 as u128, 7u16);
        // D s_313_14: cmp-eq s_313_11 s_313_13
        let s_313_14: bool = ((s_313_11) == (s_313_13));
        // N s_313_15: branch s_313_14 b3146 b314
        if s_313_14 {
            return block_3146(state, tracer, fn_state);
        } else {
            return block_314(state, tracer, fn_state);
        };
    }
    fn block_314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_314_0: const #0u : u8
        let s_314_0: bool = false;
        // D s_314_1: write-var gs#397974 <= s_314_0
        fn_state.gs_397974 = s_314_0;
        // N s_314_2: jump b315
        return block_315(state, tracer, fn_state);
    }
    fn block_315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_315_0: read-var gs#397974:u8
        let s_315_0: bool = fn_state.gs_397974;
        // N s_315_1: branch s_315_0 b3145 b316
        if s_315_0 {
            return block_3145(state, tracer, fn_state);
        } else {
            return block_316(state, tracer, fn_state);
        };
    }
    fn block_316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_316_0: const #0u : u8
        let s_316_0: bool = false;
        // D s_316_1: write-var gs#397976 <= s_316_0
        fn_state.gs_397976 = s_316_0;
        // N s_316_2: jump b317
        return block_317(state, tracer, fn_state);
    }
    fn block_317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_317_0: read-var gs#397976:u8
        let s_317_0: bool = fn_state.gs_397976;
        // D s_317_1: not s_317_0
        let s_317_1: bool = !s_317_0;
        // N s_317_2: branch s_317_1 b319 b318
        if s_317_1 {
            return block_319(state, tracer, fn_state);
        } else {
            return block_318(state, tracer, fn_state);
        };
    }
    fn block_318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_318_0: const #3357s : i
        let s_318_0: i128 = 3357;
        // C s_318_1: const #14696u : u32
        let s_318_1: u32 = 14696;
        // N s_318_2: write-reg s_318_1 <= s_318_0
        let s_318_2: () = {
            state.write_register::<i128>(s_318_1 as isize, s_318_0);
            tracer.write_register(s_318_1 as isize, s_318_0);
        };
        // C s_318_3: const #24s : i
        let s_318_3: i128 = 24;
        // C s_318_4: const #1s : i
        let s_318_4: i128 = 1;
        // D s_318_5: read-var u#30624:u32
        let s_318_5: u32 = fn_state.u_30624;
        // D s_318_6: cast zx s_318_5 -> bv
        let s_318_6: Bits = Bits::new(s_318_5 as u128, 32u16);
        // D s_318_7: bit-extract s_318_6 s_318_3 s_318_4
        let s_318_7: Bits = (Bits::new(
            ((s_318_6) >> (s_318_3)).value(),
            u16::try_from(s_318_4).unwrap(),
        ));
        // D s_318_8: cast reint s_318_7 -> u8
        let s_318_8: bool = ((s_318_7.value()) != 0);
        // C s_318_9: const #22s : i
        let s_318_9: i128 = 22;
        // C s_318_10: const #1s : i
        let s_318_10: i128 = 1;
        // D s_318_11: read-var u#30624:u32
        let s_318_11: u32 = fn_state.u_30624;
        // D s_318_12: cast zx s_318_11 -> bv
        let s_318_12: Bits = Bits::new(s_318_11 as u128, 32u16);
        // D s_318_13: bit-extract s_318_12 s_318_9 s_318_10
        let s_318_13: Bits = (Bits::new(
            ((s_318_12) >> (s_318_9)).value(),
            u16::try_from(s_318_10).unwrap(),
        ));
        // D s_318_14: cast reint s_318_13 -> u8
        let s_318_14: bool = ((s_318_13.value()) != 0);
        // C s_318_15: const #20s : i
        let s_318_15: i128 = 20;
        // C s_318_16: const #2s : i
        let s_318_16: i128 = 2;
        // D s_318_17: read-var u#30624:u32
        let s_318_17: u32 = fn_state.u_30624;
        // D s_318_18: cast zx s_318_17 -> bv
        let s_318_18: Bits = Bits::new(s_318_17 as u128, 32u16);
        // D s_318_19: bit-extract s_318_18 s_318_15 s_318_16
        let s_318_19: Bits = (Bits::new(
            ((s_318_18) >> (s_318_15)).value(),
            u16::try_from(s_318_16).unwrap(),
        ));
        // D s_318_20: cast reint s_318_19 -> u8
        let s_318_20: u8 = (s_318_19.value() as u8);
        // C s_318_21: const #16s : i
        let s_318_21: i128 = 16;
        // C s_318_22: const #4s : i
        let s_318_22: i128 = 4;
        // D s_318_23: read-var u#30624:u32
        let s_318_23: u32 = fn_state.u_30624;
        // D s_318_24: cast zx s_318_23 -> bv
        let s_318_24: Bits = Bits::new(s_318_23 as u128, 32u16);
        // D s_318_25: bit-extract s_318_24 s_318_21 s_318_22
        let s_318_25: Bits = (Bits::new(
            ((s_318_24) >> (s_318_21)).value(),
            u16::try_from(s_318_22).unwrap(),
        ));
        // D s_318_26: cast reint s_318_25 -> u8
        let s_318_26: u8 = (s_318_25.value() as u8);
        // C s_318_27: const #12s : i
        let s_318_27: i128 = 12;
        // C s_318_28: const #4s : i
        let s_318_28: i128 = 4;
        // D s_318_29: read-var u#30624:u32
        let s_318_29: u32 = fn_state.u_30624;
        // D s_318_30: cast zx s_318_29 -> bv
        let s_318_30: Bits = Bits::new(s_318_29 as u128, 32u16);
        // D s_318_31: bit-extract s_318_30 s_318_27 s_318_28
        let s_318_31: Bits = (Bits::new(
            ((s_318_30) >> (s_318_27)).value(),
            u16::try_from(s_318_28).unwrap(),
        ));
        // D s_318_32: cast reint s_318_31 -> u8
        let s_318_32: u8 = (s_318_31.value() as u8);
        // C s_318_33: const #7s : i
        let s_318_33: i128 = 7;
        // C s_318_34: const #1s : i
        let s_318_34: i128 = 1;
        // D s_318_35: read-var u#30624:u32
        let s_318_35: u32 = fn_state.u_30624;
        // D s_318_36: cast zx s_318_35 -> bv
        let s_318_36: Bits = Bits::new(s_318_35 as u128, 32u16);
        // D s_318_37: bit-extract s_318_36 s_318_33 s_318_34
        let s_318_37: Bits = (Bits::new(
            ((s_318_36) >> (s_318_33)).value(),
            u16::try_from(s_318_34).unwrap(),
        ));
        // D s_318_38: cast reint s_318_37 -> u8
        let s_318_38: bool = ((s_318_37.value()) != 0);
        // C s_318_39: const #5s : i
        let s_318_39: i128 = 5;
        // C s_318_40: const #1s : i
        let s_318_40: i128 = 1;
        // D s_318_41: read-var u#30624:u32
        let s_318_41: u32 = fn_state.u_30624;
        // D s_318_42: cast zx s_318_41 -> bv
        let s_318_42: Bits = Bits::new(s_318_41 as u128, 32u16);
        // D s_318_43: bit-extract s_318_42 s_318_39 s_318_40
        let s_318_43: Bits = (Bits::new(
            ((s_318_42) >> (s_318_39)).value(),
            u16::try_from(s_318_40).unwrap(),
        ));
        // D s_318_44: cast reint s_318_43 -> u8
        let s_318_44: bool = ((s_318_43.value()) != 0);
        // C s_318_45: const #0s : i
        let s_318_45: i128 = 0;
        // C s_318_46: const #4s : i
        let s_318_46: i128 = 4;
        // D s_318_47: read-var u#30624:u32
        let s_318_47: u32 = fn_state.u_30624;
        // D s_318_48: cast zx s_318_47 -> bv
        let s_318_48: Bits = Bits::new(s_318_47 as u128, 32u16);
        // D s_318_49: bit-extract s_318_48 s_318_45 s_318_46
        let s_318_49: Bits = (Bits::new(
            ((s_318_48) >> (s_318_45)).value(),
            u16::try_from(s_318_46).unwrap(),
        ));
        // D s_318_50: cast reint s_318_49 -> u8
        let s_318_50: u8 = (s_318_49.value() as u8);
        // D s_318_51: call decode_aarch32_instrs_VABD_i_A2enc_A_txt(s_318_8, s_318_14, s_318_20, s_318_26, s_318_32, s_318_38, s_318_44, s_318_50)
        let s_318_51: () = decode_aarch32_instrs_VABD_i_A2enc_A_txt(
            state,
            tracer,
            s_318_8,
            s_318_14,
            s_318_20,
            s_318_26,
            s_318_32,
            s_318_38,
            s_318_44,
            s_318_50,
        );
        // N s_318_52: return
        return;
    }
    fn block_319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_319_0: read-var merge#var.1:struct
        let s_319_0: u32 = fn_state.merge_var._1;
        // D s_319_1: write-var u#30634 <= s_319_0
        fn_state.u_30634 = s_319_0;
        // C s_319_2: const #23s : i
        let s_319_2: i128 = 23;
        // D s_319_3: read-var u#30634:u32
        let s_319_3: u32 = fn_state.u_30634;
        // D s_319_4: cast zx s_319_3 -> bv
        let s_319_4: Bits = Bits::new(s_319_3 as u128, 32u16);
        // C s_319_5: const #1s : i64
        let s_319_5: i64 = 1;
        // C s_319_6: cast zx s_319_5 -> i
        let s_319_6: i128 = (i128::try_from(s_319_5).unwrap());
        // C s_319_7: const #8s : i
        let s_319_7: i128 = 8;
        // C s_319_8: add s_319_7 s_319_6
        let s_319_8: i128 = (s_319_7 + s_319_6);
        // D s_319_9: bit-extract s_319_4 s_319_2 s_319_8
        let s_319_9: Bits = (Bits::new(
            ((s_319_4) >> (s_319_2)).value(),
            u16::try_from(s_319_8).unwrap(),
        ));
        // D s_319_10: cast reint s_319_9 -> u9
        let s_319_10: u16 = (s_319_9.value() as u16);
        // D s_319_11: cast zx s_319_10 -> bv
        let s_319_11: Bits = Bits::new(s_319_10 as u128, 9u16);
        // C s_319_12: const #487u : u9
        let s_319_12: u16 = 487;
        // C s_319_13: cast zx s_319_12 -> bv
        let s_319_13: Bits = Bits::new(s_319_12 as u128, 9u16);
        // D s_319_14: cmp-eq s_319_11 s_319_13
        let s_319_14: bool = ((s_319_11) == (s_319_13));
        // N s_319_15: branch s_319_14 b3132 b320
        if s_319_14 {
            return block_3132(state, tracer, fn_state);
        } else {
            return block_320(state, tracer, fn_state);
        };
    }
    fn block_320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_320_0: const #0u : u8
        let s_320_0: bool = false;
        // D s_320_1: write-var gs#398012 <= s_320_0
        fn_state.gs_398012 = s_320_0;
        // N s_320_2: jump b321
        return block_321(state, tracer, fn_state);
    }
    fn block_321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_321_0: read-var gs#398012:u8
        let s_321_0: bool = fn_state.gs_398012;
        // N s_321_1: branch s_321_0 b3131 b322
        if s_321_0 {
            return block_3131(state, tracer, fn_state);
        } else {
            return block_322(state, tracer, fn_state);
        };
    }
    fn block_322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_322_0: const #0u : u8
        let s_322_0: bool = false;
        // D s_322_1: write-var gs#398014 <= s_322_0
        fn_state.gs_398014 = s_322_0;
        // N s_322_2: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_323_0: read-var gs#398014:u8
        let s_323_0: bool = fn_state.gs_398014;
        // D s_323_1: not s_323_0
        let s_323_1: bool = !s_323_0;
        // N s_323_2: branch s_323_1 b325 b324
        if s_323_1 {
            return block_325(state, tracer, fn_state);
        } else {
            return block_324(state, tracer, fn_state);
        };
    }
    fn block_324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_324_0: const #3360s : i
        let s_324_0: i128 = 3360;
        // C s_324_1: const #14696u : u32
        let s_324_1: u32 = 14696;
        // N s_324_2: write-reg s_324_1 <= s_324_0
        let s_324_2: () = {
            state.write_register::<i128>(s_324_1 as isize, s_324_0);
            tracer.write_register(s_324_1 as isize, s_324_0);
        };
        // C s_324_3: const #22s : i
        let s_324_3: i128 = 22;
        // C s_324_4: const #1s : i
        let s_324_4: i128 = 1;
        // D s_324_5: read-var u#30634:u32
        let s_324_5: u32 = fn_state.u_30634;
        // D s_324_6: cast zx s_324_5 -> bv
        let s_324_6: Bits = Bits::new(s_324_5 as u128, 32u16);
        // D s_324_7: bit-extract s_324_6 s_324_3 s_324_4
        let s_324_7: Bits = (Bits::new(
            ((s_324_6) >> (s_324_3)).value(),
            u16::try_from(s_324_4).unwrap(),
        ));
        // D s_324_8: cast reint s_324_7 -> u8
        let s_324_8: bool = ((s_324_7.value()) != 0);
        // C s_324_9: const #18s : i
        let s_324_9: i128 = 18;
        // C s_324_10: const #2s : i
        let s_324_10: i128 = 2;
        // D s_324_11: read-var u#30634:u32
        let s_324_11: u32 = fn_state.u_30634;
        // D s_324_12: cast zx s_324_11 -> bv
        let s_324_12: Bits = Bits::new(s_324_11 as u128, 32u16);
        // D s_324_13: bit-extract s_324_12 s_324_9 s_324_10
        let s_324_13: Bits = (Bits::new(
            ((s_324_12) >> (s_324_9)).value(),
            u16::try_from(s_324_10).unwrap(),
        ));
        // D s_324_14: cast reint s_324_13 -> u8
        let s_324_14: u8 = (s_324_13.value() as u8);
        // C s_324_15: const #12s : i
        let s_324_15: i128 = 12;
        // C s_324_16: const #4s : i
        let s_324_16: i128 = 4;
        // D s_324_17: read-var u#30634:u32
        let s_324_17: u32 = fn_state.u_30634;
        // D s_324_18: cast zx s_324_17 -> bv
        let s_324_18: Bits = Bits::new(s_324_17 as u128, 32u16);
        // D s_324_19: bit-extract s_324_18 s_324_15 s_324_16
        let s_324_19: Bits = (Bits::new(
            ((s_324_18) >> (s_324_15)).value(),
            u16::try_from(s_324_16).unwrap(),
        ));
        // D s_324_20: cast reint s_324_19 -> u8
        let s_324_20: u8 = (s_324_19.value() as u8);
        // C s_324_21: const #10s : i
        let s_324_21: i128 = 10;
        // C s_324_22: const #1s : i
        let s_324_22: i128 = 1;
        // D s_324_23: read-var u#30634:u32
        let s_324_23: u32 = fn_state.u_30634;
        // D s_324_24: cast zx s_324_23 -> bv
        let s_324_24: Bits = Bits::new(s_324_23 as u128, 32u16);
        // D s_324_25: bit-extract s_324_24 s_324_21 s_324_22
        let s_324_25: Bits = (Bits::new(
            ((s_324_24) >> (s_324_21)).value(),
            u16::try_from(s_324_22).unwrap(),
        ));
        // D s_324_26: cast reint s_324_25 -> u8
        let s_324_26: bool = ((s_324_25.value()) != 0);
        // C s_324_27: const #6s : i
        let s_324_27: i128 = 6;
        // C s_324_28: const #1s : i
        let s_324_28: i128 = 1;
        // D s_324_29: read-var u#30634:u32
        let s_324_29: u32 = fn_state.u_30634;
        // D s_324_30: cast zx s_324_29 -> bv
        let s_324_30: Bits = Bits::new(s_324_29 as u128, 32u16);
        // D s_324_31: bit-extract s_324_30 s_324_27 s_324_28
        let s_324_31: Bits = (Bits::new(
            ((s_324_30) >> (s_324_27)).value(),
            u16::try_from(s_324_28).unwrap(),
        ));
        // D s_324_32: cast reint s_324_31 -> u8
        let s_324_32: bool = ((s_324_31.value()) != 0);
        // C s_324_33: const #5s : i
        let s_324_33: i128 = 5;
        // C s_324_34: const #1s : i
        let s_324_34: i128 = 1;
        // D s_324_35: read-var u#30634:u32
        let s_324_35: u32 = fn_state.u_30634;
        // D s_324_36: cast zx s_324_35 -> bv
        let s_324_36: Bits = Bits::new(s_324_35 as u128, 32u16);
        // D s_324_37: bit-extract s_324_36 s_324_33 s_324_34
        let s_324_37: Bits = (Bits::new(
            ((s_324_36) >> (s_324_33)).value(),
            u16::try_from(s_324_34).unwrap(),
        ));
        // D s_324_38: cast reint s_324_37 -> u8
        let s_324_38: bool = ((s_324_37.value()) != 0);
        // C s_324_39: const #0s : i
        let s_324_39: i128 = 0;
        // C s_324_40: const #4s : i
        let s_324_40: i128 = 4;
        // D s_324_41: read-var u#30634:u32
        let s_324_41: u32 = fn_state.u_30634;
        // D s_324_42: cast zx s_324_41 -> bv
        let s_324_42: Bits = Bits::new(s_324_41 as u128, 32u16);
        // D s_324_43: bit-extract s_324_42 s_324_39 s_324_40
        let s_324_43: Bits = (Bits::new(
            ((s_324_42) >> (s_324_39)).value(),
            u16::try_from(s_324_40).unwrap(),
        ));
        // D s_324_44: cast reint s_324_43 -> u8
        let s_324_44: u8 = (s_324_43.value() as u8);
        // D s_324_45: call decode_aarch32_instrs_VABS_A1enc_A_txt(s_324_8, s_324_14, s_324_20, s_324_26, s_324_32, s_324_38, s_324_44)
        let s_324_45: () = decode_aarch32_instrs_VABS_A1enc_A_txt(
            state,
            tracer,
            s_324_8,
            s_324_14,
            s_324_20,
            s_324_26,
            s_324_32,
            s_324_38,
            s_324_44,
        );
        // N s_324_46: return
        return;
    }
    fn block_325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_325_0: read-var merge#var.1:struct
        let s_325_0: u32 = fn_state.merge_var._1;
        // D s_325_1: write-var u#30642 <= s_325_0
        fn_state.u_30642 = s_325_0;
        // C s_325_2: const #23s : i
        let s_325_2: i128 = 23;
        // D s_325_3: read-var u#30642:u32
        let s_325_3: u32 = fn_state.u_30642;
        // D s_325_4: cast zx s_325_3 -> bv
        let s_325_4: Bits = Bits::new(s_325_3 as u128, 32u16);
        // C s_325_5: const #1s : i64
        let s_325_5: i64 = 1;
        // C s_325_6: cast zx s_325_5 -> i
        let s_325_6: i128 = (i128::try_from(s_325_5).unwrap());
        // C s_325_7: const #8s : i
        let s_325_7: i128 = 8;
        // C s_325_8: add s_325_7 s_325_6
        let s_325_8: i128 = (s_325_7 + s_325_6);
        // D s_325_9: bit-extract s_325_4 s_325_2 s_325_8
        let s_325_9: Bits = (Bits::new(
            ((s_325_4) >> (s_325_2)).value(),
            u16::try_from(s_325_8).unwrap(),
        ));
        // D s_325_10: cast reint s_325_9 -> u9
        let s_325_10: u16 = (s_325_9.value() as u16);
        // D s_325_11: cast zx s_325_10 -> bv
        let s_325_11: Bits = Bits::new(s_325_10 as u128, 9u16);
        // C s_325_12: const #486u : u9
        let s_325_12: u16 = 486;
        // C s_325_13: cast zx s_325_12 -> bv
        let s_325_13: Bits = Bits::new(s_325_12 as u128, 9u16);
        // D s_325_14: cmp-eq s_325_11 s_325_13
        let s_325_14: bool = ((s_325_11) == (s_325_13));
        // N s_325_15: branch s_325_14 b3127 b326
        if s_325_14 {
            return block_3127(state, tracer, fn_state);
        } else {
            return block_326(state, tracer, fn_state);
        };
    }
    fn block_326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_326_0: const #0u : u8
        let s_326_0: bool = false;
        // D s_326_1: write-var gs#398039 <= s_326_0
        fn_state.gs_398039 = s_326_0;
        // N s_326_2: jump b327
        return block_327(state, tracer, fn_state);
    }
    fn block_327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_327_0: read-var gs#398039:u8
        let s_327_0: bool = fn_state.gs_398039;
        // N s_327_1: branch s_327_0 b3126 b328
        if s_327_0 {
            return block_3126(state, tracer, fn_state);
        } else {
            return block_328(state, tracer, fn_state);
        };
    }
    fn block_328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_328_0: const #0u : u8
        let s_328_0: bool = false;
        // D s_328_1: write-var gs#398041 <= s_328_0
        fn_state.gs_398041 = s_328_0;
        // N s_328_2: jump b329
        return block_329(state, tracer, fn_state);
    }
    fn block_329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_329_0: read-var gs#398041:u8
        let s_329_0: bool = fn_state.gs_398041;
        // D s_329_1: not s_329_0
        let s_329_1: bool = !s_329_0;
        // N s_329_2: branch s_329_1 b331 b330
        if s_329_1 {
            return block_331(state, tracer, fn_state);
        } else {
            return block_330(state, tracer, fn_state);
        };
    }
    fn block_330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_330_0: const #3364s : i
        let s_330_0: i128 = 3364;
        // C s_330_1: const #14696u : u32
        let s_330_1: u32 = 14696;
        // N s_330_2: write-reg s_330_1 <= s_330_0
        let s_330_2: () = {
            state.write_register::<i128>(s_330_1 as isize, s_330_0);
            tracer.write_register(s_330_1 as isize, s_330_0);
        };
        // C s_330_3: const #22s : i
        let s_330_3: i128 = 22;
        // C s_330_4: const #1s : i
        let s_330_4: i128 = 1;
        // D s_330_5: read-var u#30642:u32
        let s_330_5: u32 = fn_state.u_30642;
        // D s_330_6: cast zx s_330_5 -> bv
        let s_330_6: Bits = Bits::new(s_330_5 as u128, 32u16);
        // D s_330_7: bit-extract s_330_6 s_330_3 s_330_4
        let s_330_7: Bits = (Bits::new(
            ((s_330_6) >> (s_330_3)).value(),
            u16::try_from(s_330_4).unwrap(),
        ));
        // D s_330_8: cast reint s_330_7 -> u8
        let s_330_8: bool = ((s_330_7.value()) != 0);
        // C s_330_9: const #21s : i
        let s_330_9: i128 = 21;
        // C s_330_10: const #1s : i
        let s_330_10: i128 = 1;
        // D s_330_11: read-var u#30642:u32
        let s_330_11: u32 = fn_state.u_30642;
        // D s_330_12: cast zx s_330_11 -> bv
        let s_330_12: Bits = Bits::new(s_330_11 as u128, 32u16);
        // D s_330_13: bit-extract s_330_12 s_330_9 s_330_10
        let s_330_13: Bits = (Bits::new(
            ((s_330_12) >> (s_330_9)).value(),
            u16::try_from(s_330_10).unwrap(),
        ));
        // D s_330_14: cast reint s_330_13 -> u8
        let s_330_14: bool = ((s_330_13.value()) != 0);
        // C s_330_15: const #20s : i
        let s_330_15: i128 = 20;
        // C s_330_16: const #1s : i
        let s_330_16: i128 = 1;
        // D s_330_17: read-var u#30642:u32
        let s_330_17: u32 = fn_state.u_30642;
        // D s_330_18: cast zx s_330_17 -> bv
        let s_330_18: Bits = Bits::new(s_330_17 as u128, 32u16);
        // D s_330_19: bit-extract s_330_18 s_330_15 s_330_16
        let s_330_19: Bits = (Bits::new(
            ((s_330_18) >> (s_330_15)).value(),
            u16::try_from(s_330_16).unwrap(),
        ));
        // D s_330_20: cast reint s_330_19 -> u8
        let s_330_20: bool = ((s_330_19.value()) != 0);
        // C s_330_21: const #16s : i
        let s_330_21: i128 = 16;
        // C s_330_22: const #4s : i
        let s_330_22: i128 = 4;
        // D s_330_23: read-var u#30642:u32
        let s_330_23: u32 = fn_state.u_30642;
        // D s_330_24: cast zx s_330_23 -> bv
        let s_330_24: Bits = Bits::new(s_330_23 as u128, 32u16);
        // D s_330_25: bit-extract s_330_24 s_330_21 s_330_22
        let s_330_25: Bits = (Bits::new(
            ((s_330_24) >> (s_330_21)).value(),
            u16::try_from(s_330_22).unwrap(),
        ));
        // D s_330_26: cast reint s_330_25 -> u8
        let s_330_26: u8 = (s_330_25.value() as u8);
        // C s_330_27: const #12s : i
        let s_330_27: i128 = 12;
        // C s_330_28: const #4s : i
        let s_330_28: i128 = 4;
        // D s_330_29: read-var u#30642:u32
        let s_330_29: u32 = fn_state.u_30642;
        // D s_330_30: cast zx s_330_29 -> bv
        let s_330_30: Bits = Bits::new(s_330_29 as u128, 32u16);
        // D s_330_31: bit-extract s_330_30 s_330_27 s_330_28
        let s_330_31: Bits = (Bits::new(
            ((s_330_30) >> (s_330_27)).value(),
            u16::try_from(s_330_28).unwrap(),
        ));
        // D s_330_32: cast reint s_330_31 -> u8
        let s_330_32: u8 = (s_330_31.value() as u8);
        // C s_330_33: const #7s : i
        let s_330_33: i128 = 7;
        // C s_330_34: const #1s : i
        let s_330_34: i128 = 1;
        // D s_330_35: read-var u#30642:u32
        let s_330_35: u32 = fn_state.u_30642;
        // D s_330_36: cast zx s_330_35 -> bv
        let s_330_36: Bits = Bits::new(s_330_35 as u128, 32u16);
        // D s_330_37: bit-extract s_330_36 s_330_33 s_330_34
        let s_330_37: Bits = (Bits::new(
            ((s_330_36) >> (s_330_33)).value(),
            u16::try_from(s_330_34).unwrap(),
        ));
        // D s_330_38: cast reint s_330_37 -> u8
        let s_330_38: bool = ((s_330_37.value()) != 0);
        // C s_330_39: const #6s : i
        let s_330_39: i128 = 6;
        // C s_330_40: const #1s : i
        let s_330_40: i128 = 1;
        // D s_330_41: read-var u#30642:u32
        let s_330_41: u32 = fn_state.u_30642;
        // D s_330_42: cast zx s_330_41 -> bv
        let s_330_42: Bits = Bits::new(s_330_41 as u128, 32u16);
        // D s_330_43: bit-extract s_330_42 s_330_39 s_330_40
        let s_330_43: Bits = (Bits::new(
            ((s_330_42) >> (s_330_39)).value(),
            u16::try_from(s_330_40).unwrap(),
        ));
        // D s_330_44: cast reint s_330_43 -> u8
        let s_330_44: bool = ((s_330_43.value()) != 0);
        // C s_330_45: const #5s : i
        let s_330_45: i128 = 5;
        // C s_330_46: const #1s : i
        let s_330_46: i128 = 1;
        // D s_330_47: read-var u#30642:u32
        let s_330_47: u32 = fn_state.u_30642;
        // D s_330_48: cast zx s_330_47 -> bv
        let s_330_48: Bits = Bits::new(s_330_47 as u128, 32u16);
        // D s_330_49: bit-extract s_330_48 s_330_45 s_330_46
        let s_330_49: Bits = (Bits::new(
            ((s_330_48) >> (s_330_45)).value(),
            u16::try_from(s_330_46).unwrap(),
        ));
        // D s_330_50: cast reint s_330_49 -> u8
        let s_330_50: bool = ((s_330_49.value()) != 0);
        // C s_330_51: const #0s : i
        let s_330_51: i128 = 0;
        // C s_330_52: const #4s : i
        let s_330_52: i128 = 4;
        // D s_330_53: read-var u#30642:u32
        let s_330_53: u32 = fn_state.u_30642;
        // D s_330_54: cast zx s_330_53 -> bv
        let s_330_54: Bits = Bits::new(s_330_53 as u128, 32u16);
        // D s_330_55: bit-extract s_330_54 s_330_51 s_330_52
        let s_330_55: Bits = (Bits::new(
            ((s_330_54) >> (s_330_51)).value(),
            u16::try_from(s_330_52).unwrap(),
        ));
        // D s_330_56: cast reint s_330_55 -> u8
        let s_330_56: u8 = (s_330_55.value() as u8);
        // D s_330_57: call decode_aarch32_instrs_VACGE_A1enc_A_txt(s_330_8, s_330_14, s_330_20, s_330_26, s_330_32, s_330_38, s_330_44, s_330_50, s_330_56)
        let s_330_57: () = decode_aarch32_instrs_VACGE_A1enc_A_txt(
            state,
            tracer,
            s_330_8,
            s_330_14,
            s_330_20,
            s_330_26,
            s_330_32,
            s_330_38,
            s_330_44,
            s_330_50,
            s_330_56,
        );
        // N s_330_58: return
        return;
    }
    fn block_331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_331_0: read-var merge#var.1:struct
        let s_331_0: u32 = fn_state.merge_var._1;
        // D s_331_1: write-var u#30652 <= s_331_0
        fn_state.u_30652 = s_331_0;
        // C s_331_2: const #23s : i
        let s_331_2: i128 = 23;
        // D s_331_3: read-var u#30652:u32
        let s_331_3: u32 = fn_state.u_30652;
        // D s_331_4: cast zx s_331_3 -> bv
        let s_331_4: Bits = Bits::new(s_331_3 as u128, 32u16);
        // C s_331_5: const #1s : i64
        let s_331_5: i64 = 1;
        // C s_331_6: cast zx s_331_5 -> i
        let s_331_6: i128 = (i128::try_from(s_331_5).unwrap());
        // C s_331_7: const #8s : i
        let s_331_7: i128 = 8;
        // C s_331_8: add s_331_7 s_331_6
        let s_331_8: i128 = (s_331_7 + s_331_6);
        // D s_331_9: bit-extract s_331_4 s_331_2 s_331_8
        let s_331_9: Bits = (Bits::new(
            ((s_331_4) >> (s_331_2)).value(),
            u16::try_from(s_331_8).unwrap(),
        ));
        // D s_331_10: cast reint s_331_9 -> u9
        let s_331_10: u16 = (s_331_9.value() as u16);
        // D s_331_11: cast zx s_331_10 -> bv
        let s_331_11: Bits = Bits::new(s_331_10 as u128, 9u16);
        // C s_331_12: const #484u : u9
        let s_331_12: u16 = 484;
        // C s_331_13: cast zx s_331_12 -> bv
        let s_331_13: Bits = Bits::new(s_331_12 as u128, 9u16);
        // D s_331_14: cmp-eq s_331_11 s_331_13
        let s_331_14: bool = ((s_331_11) == (s_331_13));
        // N s_331_15: branch s_331_14 b3119 b332
        if s_331_14 {
            return block_3119(state, tracer, fn_state);
        } else {
            return block_332(state, tracer, fn_state);
        };
    }
    fn block_332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_332_0: const #0u : u8
        let s_332_0: bool = false;
        // D s_332_1: write-var gs#398073 <= s_332_0
        fn_state.gs_398073 = s_332_0;
        // N s_332_2: jump b333
        return block_333(state, tracer, fn_state);
    }
    fn block_333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_333_0: read-var gs#398073:u8
        let s_333_0: bool = fn_state.gs_398073;
        // N s_333_1: branch s_333_0 b3118 b334
        if s_333_0 {
            return block_3118(state, tracer, fn_state);
        } else {
            return block_334(state, tracer, fn_state);
        };
    }
    fn block_334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_334_0: const #0u : u8
        let s_334_0: bool = false;
        // D s_334_1: write-var gs#398075 <= s_334_0
        fn_state.gs_398075 = s_334_0;
        // N s_334_2: jump b335
        return block_335(state, tracer, fn_state);
    }
    fn block_335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_335_0: read-var gs#398075:u8
        let s_335_0: bool = fn_state.gs_398075;
        // D s_335_1: not s_335_0
        let s_335_1: bool = !s_335_0;
        // N s_335_2: branch s_335_1 b337 b336
        if s_335_1 {
            return block_337(state, tracer, fn_state);
        } else {
            return block_336(state, tracer, fn_state);
        };
    }
    fn block_336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_336_0: const #3366s : i
        let s_336_0: i128 = 3366;
        // C s_336_1: const #14696u : u32
        let s_336_1: u32 = 14696;
        // N s_336_2: write-reg s_336_1 <= s_336_0
        let s_336_2: () = {
            state.write_register::<i128>(s_336_1 as isize, s_336_0);
            tracer.write_register(s_336_1 as isize, s_336_0);
        };
        // C s_336_3: const #22s : i
        let s_336_3: i128 = 22;
        // C s_336_4: const #1s : i
        let s_336_4: i128 = 1;
        // D s_336_5: read-var u#30652:u32
        let s_336_5: u32 = fn_state.u_30652;
        // D s_336_6: cast zx s_336_5 -> bv
        let s_336_6: Bits = Bits::new(s_336_5 as u128, 32u16);
        // D s_336_7: bit-extract s_336_6 s_336_3 s_336_4
        let s_336_7: Bits = (Bits::new(
            ((s_336_6) >> (s_336_3)).value(),
            u16::try_from(s_336_4).unwrap(),
        ));
        // D s_336_8: cast reint s_336_7 -> u8
        let s_336_8: bool = ((s_336_7.value()) != 0);
        // C s_336_9: const #20s : i
        let s_336_9: i128 = 20;
        // C s_336_10: const #1s : i
        let s_336_10: i128 = 1;
        // D s_336_11: read-var u#30652:u32
        let s_336_11: u32 = fn_state.u_30652;
        // D s_336_12: cast zx s_336_11 -> bv
        let s_336_12: Bits = Bits::new(s_336_11 as u128, 32u16);
        // D s_336_13: bit-extract s_336_12 s_336_9 s_336_10
        let s_336_13: Bits = (Bits::new(
            ((s_336_12) >> (s_336_9)).value(),
            u16::try_from(s_336_10).unwrap(),
        ));
        // D s_336_14: cast reint s_336_13 -> u8
        let s_336_14: bool = ((s_336_13.value()) != 0);
        // C s_336_15: const #16s : i
        let s_336_15: i128 = 16;
        // C s_336_16: const #4s : i
        let s_336_16: i128 = 4;
        // D s_336_17: read-var u#30652:u32
        let s_336_17: u32 = fn_state.u_30652;
        // D s_336_18: cast zx s_336_17 -> bv
        let s_336_18: Bits = Bits::new(s_336_17 as u128, 32u16);
        // D s_336_19: bit-extract s_336_18 s_336_15 s_336_16
        let s_336_19: Bits = (Bits::new(
            ((s_336_18) >> (s_336_15)).value(),
            u16::try_from(s_336_16).unwrap(),
        ));
        // D s_336_20: cast reint s_336_19 -> u8
        let s_336_20: u8 = (s_336_19.value() as u8);
        // C s_336_21: const #12s : i
        let s_336_21: i128 = 12;
        // C s_336_22: const #4s : i
        let s_336_22: i128 = 4;
        // D s_336_23: read-var u#30652:u32
        let s_336_23: u32 = fn_state.u_30652;
        // D s_336_24: cast zx s_336_23 -> bv
        let s_336_24: Bits = Bits::new(s_336_23 as u128, 32u16);
        // D s_336_25: bit-extract s_336_24 s_336_21 s_336_22
        let s_336_25: Bits = (Bits::new(
            ((s_336_24) >> (s_336_21)).value(),
            u16::try_from(s_336_22).unwrap(),
        ));
        // D s_336_26: cast reint s_336_25 -> u8
        let s_336_26: u8 = (s_336_25.value() as u8);
        // C s_336_27: const #7s : i
        let s_336_27: i128 = 7;
        // C s_336_28: const #1s : i
        let s_336_28: i128 = 1;
        // D s_336_29: read-var u#30652:u32
        let s_336_29: u32 = fn_state.u_30652;
        // D s_336_30: cast zx s_336_29 -> bv
        let s_336_30: Bits = Bits::new(s_336_29 as u128, 32u16);
        // D s_336_31: bit-extract s_336_30 s_336_27 s_336_28
        let s_336_31: Bits = (Bits::new(
            ((s_336_30) >> (s_336_27)).value(),
            u16::try_from(s_336_28).unwrap(),
        ));
        // D s_336_32: cast reint s_336_31 -> u8
        let s_336_32: bool = ((s_336_31.value()) != 0);
        // C s_336_33: const #6s : i
        let s_336_33: i128 = 6;
        // C s_336_34: const #1s : i
        let s_336_34: i128 = 1;
        // D s_336_35: read-var u#30652:u32
        let s_336_35: u32 = fn_state.u_30652;
        // D s_336_36: cast zx s_336_35 -> bv
        let s_336_36: Bits = Bits::new(s_336_35 as u128, 32u16);
        // D s_336_37: bit-extract s_336_36 s_336_33 s_336_34
        let s_336_37: Bits = (Bits::new(
            ((s_336_36) >> (s_336_33)).value(),
            u16::try_from(s_336_34).unwrap(),
        ));
        // D s_336_38: cast reint s_336_37 -> u8
        let s_336_38: bool = ((s_336_37.value()) != 0);
        // C s_336_39: const #5s : i
        let s_336_39: i128 = 5;
        // C s_336_40: const #1s : i
        let s_336_40: i128 = 1;
        // D s_336_41: read-var u#30652:u32
        let s_336_41: u32 = fn_state.u_30652;
        // D s_336_42: cast zx s_336_41 -> bv
        let s_336_42: Bits = Bits::new(s_336_41 as u128, 32u16);
        // D s_336_43: bit-extract s_336_42 s_336_39 s_336_40
        let s_336_43: Bits = (Bits::new(
            ((s_336_42) >> (s_336_39)).value(),
            u16::try_from(s_336_40).unwrap(),
        ));
        // D s_336_44: cast reint s_336_43 -> u8
        let s_336_44: bool = ((s_336_43.value()) != 0);
        // C s_336_45: const #0s : i
        let s_336_45: i128 = 0;
        // C s_336_46: const #4s : i
        let s_336_46: i128 = 4;
        // D s_336_47: read-var u#30652:u32
        let s_336_47: u32 = fn_state.u_30652;
        // D s_336_48: cast zx s_336_47 -> bv
        let s_336_48: Bits = Bits::new(s_336_47 as u128, 32u16);
        // D s_336_49: bit-extract s_336_48 s_336_45 s_336_46
        let s_336_49: Bits = (Bits::new(
            ((s_336_48) >> (s_336_45)).value(),
            u16::try_from(s_336_46).unwrap(),
        ));
        // D s_336_50: cast reint s_336_49 -> u8
        let s_336_50: u8 = (s_336_49.value() as u8);
        // D s_336_51: call decode_aarch32_instrs_VADD_f_A1enc_A_txt(s_336_8, s_336_14, s_336_20, s_336_26, s_336_32, s_336_38, s_336_44, s_336_50)
        let s_336_51: () = decode_aarch32_instrs_VADD_f_A1enc_A_txt(
            state,
            tracer,
            s_336_8,
            s_336_14,
            s_336_20,
            s_336_26,
            s_336_32,
            s_336_38,
            s_336_44,
            s_336_50,
        );
        // N s_336_52: return
        return;
    }
    fn block_337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_337_0: read-var merge#var.1:struct
        let s_337_0: u32 = fn_state.merge_var._1;
        // D s_337_1: write-var u#30662 <= s_337_0
        fn_state.u_30662 = s_337_0;
        // C s_337_2: const #23s : i
        let s_337_2: i128 = 23;
        // D s_337_3: read-var u#30662:u32
        let s_337_3: u32 = fn_state.u_30662;
        // D s_337_4: cast zx s_337_3 -> bv
        let s_337_4: Bits = Bits::new(s_337_3 as u128, 32u16);
        // C s_337_5: const #1s : i64
        let s_337_5: i64 = 1;
        // C s_337_6: cast zx s_337_5 -> i
        let s_337_6: i128 = (i128::try_from(s_337_5).unwrap());
        // C s_337_7: const #8s : i
        let s_337_7: i128 = 8;
        // C s_337_8: add s_337_7 s_337_6
        let s_337_8: i128 = (s_337_7 + s_337_6);
        // D s_337_9: bit-extract s_337_4 s_337_2 s_337_8
        let s_337_9: Bits = (Bits::new(
            ((s_337_4) >> (s_337_2)).value(),
            u16::try_from(s_337_8).unwrap(),
        ));
        // D s_337_10: cast reint s_337_9 -> u9
        let s_337_10: u16 = (s_337_9.value() as u16);
        // D s_337_11: cast zx s_337_10 -> bv
        let s_337_11: Bits = Bits::new(s_337_10 as u128, 9u16);
        // C s_337_12: const #485u : u9
        let s_337_12: u16 = 485;
        // C s_337_13: cast zx s_337_12 -> bv
        let s_337_13: Bits = Bits::new(s_337_12 as u128, 9u16);
        // D s_337_14: cmp-eq s_337_11 s_337_13
        let s_337_14: bool = ((s_337_11) == (s_337_13));
        // N s_337_15: branch s_337_14 b3111 b338
        if s_337_14 {
            return block_3111(state, tracer, fn_state);
        } else {
            return block_338(state, tracer, fn_state);
        };
    }
    fn block_338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_338_0: const #0u : u8
        let s_338_0: bool = false;
        // D s_338_1: write-var gs#398105 <= s_338_0
        fn_state.gs_398105 = s_338_0;
        // N s_338_2: jump b339
        return block_339(state, tracer, fn_state);
    }
    fn block_339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_339_0: read-var gs#398105:u8
        let s_339_0: bool = fn_state.gs_398105;
        // N s_339_1: branch s_339_0 b3110 b340
        if s_339_0 {
            return block_3110(state, tracer, fn_state);
        } else {
            return block_340(state, tracer, fn_state);
        };
    }
    fn block_340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_340_0: const #0u : u8
        let s_340_0: bool = false;
        // D s_340_1: write-var gs#398107 <= s_340_0
        fn_state.gs_398107 = s_340_0;
        // N s_340_2: jump b341
        return block_341(state, tracer, fn_state);
    }
    fn block_341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_341_0: read-var gs#398107:u8
        let s_341_0: bool = fn_state.gs_398107;
        // D s_341_1: not s_341_0
        let s_341_1: bool = !s_341_0;
        // N s_341_2: branch s_341_1 b343 b342
        if s_341_1 {
            return block_343(state, tracer, fn_state);
        } else {
            return block_342(state, tracer, fn_state);
        };
    }
    fn block_342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_342_0: const #3370s : i
        let s_342_0: i128 = 3370;
        // C s_342_1: const #14696u : u32
        let s_342_1: u32 = 14696;
        // N s_342_2: write-reg s_342_1 <= s_342_0
        let s_342_2: () = {
            state.write_register::<i128>(s_342_1 as isize, s_342_0);
            tracer.write_register(s_342_1 as isize, s_342_0);
        };
        // C s_342_3: const #22s : i
        let s_342_3: i128 = 22;
        // C s_342_4: const #1s : i
        let s_342_4: i128 = 1;
        // D s_342_5: read-var u#30662:u32
        let s_342_5: u32 = fn_state.u_30662;
        // D s_342_6: cast zx s_342_5 -> bv
        let s_342_6: Bits = Bits::new(s_342_5 as u128, 32u16);
        // D s_342_7: bit-extract s_342_6 s_342_3 s_342_4
        let s_342_7: Bits = (Bits::new(
            ((s_342_6) >> (s_342_3)).value(),
            u16::try_from(s_342_4).unwrap(),
        ));
        // D s_342_8: cast reint s_342_7 -> u8
        let s_342_8: bool = ((s_342_7.value()) != 0);
        // C s_342_9: const #20s : i
        let s_342_9: i128 = 20;
        // C s_342_10: const #2s : i
        let s_342_10: i128 = 2;
        // D s_342_11: read-var u#30662:u32
        let s_342_11: u32 = fn_state.u_30662;
        // D s_342_12: cast zx s_342_11 -> bv
        let s_342_12: Bits = Bits::new(s_342_11 as u128, 32u16);
        // D s_342_13: bit-extract s_342_12 s_342_9 s_342_10
        let s_342_13: Bits = (Bits::new(
            ((s_342_12) >> (s_342_9)).value(),
            u16::try_from(s_342_10).unwrap(),
        ));
        // D s_342_14: cast reint s_342_13 -> u8
        let s_342_14: u8 = (s_342_13.value() as u8);
        // C s_342_15: const #16s : i
        let s_342_15: i128 = 16;
        // C s_342_16: const #4s : i
        let s_342_16: i128 = 4;
        // D s_342_17: read-var u#30662:u32
        let s_342_17: u32 = fn_state.u_30662;
        // D s_342_18: cast zx s_342_17 -> bv
        let s_342_18: Bits = Bits::new(s_342_17 as u128, 32u16);
        // D s_342_19: bit-extract s_342_18 s_342_15 s_342_16
        let s_342_19: Bits = (Bits::new(
            ((s_342_18) >> (s_342_15)).value(),
            u16::try_from(s_342_16).unwrap(),
        ));
        // D s_342_20: cast reint s_342_19 -> u8
        let s_342_20: u8 = (s_342_19.value() as u8);
        // C s_342_21: const #12s : i
        let s_342_21: i128 = 12;
        // C s_342_22: const #4s : i
        let s_342_22: i128 = 4;
        // D s_342_23: read-var u#30662:u32
        let s_342_23: u32 = fn_state.u_30662;
        // D s_342_24: cast zx s_342_23 -> bv
        let s_342_24: Bits = Bits::new(s_342_23 as u128, 32u16);
        // D s_342_25: bit-extract s_342_24 s_342_21 s_342_22
        let s_342_25: Bits = (Bits::new(
            ((s_342_24) >> (s_342_21)).value(),
            u16::try_from(s_342_22).unwrap(),
        ));
        // D s_342_26: cast reint s_342_25 -> u8
        let s_342_26: u8 = (s_342_25.value() as u8);
        // C s_342_27: const #7s : i
        let s_342_27: i128 = 7;
        // C s_342_28: const #1s : i
        let s_342_28: i128 = 1;
        // D s_342_29: read-var u#30662:u32
        let s_342_29: u32 = fn_state.u_30662;
        // D s_342_30: cast zx s_342_29 -> bv
        let s_342_30: Bits = Bits::new(s_342_29 as u128, 32u16);
        // D s_342_31: bit-extract s_342_30 s_342_27 s_342_28
        let s_342_31: Bits = (Bits::new(
            ((s_342_30) >> (s_342_27)).value(),
            u16::try_from(s_342_28).unwrap(),
        ));
        // D s_342_32: cast reint s_342_31 -> u8
        let s_342_32: bool = ((s_342_31.value()) != 0);
        // C s_342_33: const #5s : i
        let s_342_33: i128 = 5;
        // C s_342_34: const #1s : i
        let s_342_34: i128 = 1;
        // D s_342_35: read-var u#30662:u32
        let s_342_35: u32 = fn_state.u_30662;
        // D s_342_36: cast zx s_342_35 -> bv
        let s_342_36: Bits = Bits::new(s_342_35 as u128, 32u16);
        // D s_342_37: bit-extract s_342_36 s_342_33 s_342_34
        let s_342_37: Bits = (Bits::new(
            ((s_342_36) >> (s_342_33)).value(),
            u16::try_from(s_342_34).unwrap(),
        ));
        // D s_342_38: cast reint s_342_37 -> u8
        let s_342_38: bool = ((s_342_37.value()) != 0);
        // C s_342_39: const #0s : i
        let s_342_39: i128 = 0;
        // C s_342_40: const #4s : i
        let s_342_40: i128 = 4;
        // D s_342_41: read-var u#30662:u32
        let s_342_41: u32 = fn_state.u_30662;
        // D s_342_42: cast zx s_342_41 -> bv
        let s_342_42: Bits = Bits::new(s_342_41 as u128, 32u16);
        // D s_342_43: bit-extract s_342_42 s_342_39 s_342_40
        let s_342_43: Bits = (Bits::new(
            ((s_342_42) >> (s_342_39)).value(),
            u16::try_from(s_342_40).unwrap(),
        ));
        // D s_342_44: cast reint s_342_43 -> u8
        let s_342_44: u8 = (s_342_43.value() as u8);
        // D s_342_45: call decode_aarch32_instrs_VADDHN_A1enc_A_txt(s_342_8, s_342_14, s_342_20, s_342_26, s_342_32, s_342_38, s_342_44)
        let s_342_45: () = decode_aarch32_instrs_VADDHN_A1enc_A_txt(
            state,
            tracer,
            s_342_8,
            s_342_14,
            s_342_20,
            s_342_26,
            s_342_32,
            s_342_38,
            s_342_44,
        );
        // N s_342_46: return
        return;
    }
    fn block_343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_343_0: read-var merge#var.1:struct
        let s_343_0: u32 = fn_state.merge_var._1;
        // D s_343_1: write-var u#30671 <= s_343_0
        fn_state.u_30671 = s_343_0;
        // C s_343_2: const #23s : i
        let s_343_2: i128 = 23;
        // D s_343_3: read-var u#30671:u32
        let s_343_3: u32 = fn_state.u_30671;
        // D s_343_4: cast zx s_343_3 -> bv
        let s_343_4: Bits = Bits::new(s_343_3 as u128, 32u16);
        // C s_343_5: const #1s : i64
        let s_343_5: i64 = 1;
        // C s_343_6: cast zx s_343_5 -> i
        let s_343_6: i128 = (i128::try_from(s_343_5).unwrap());
        // C s_343_7: const #8s : i
        let s_343_7: i128 = 8;
        // C s_343_8: add s_343_7 s_343_6
        let s_343_8: i128 = (s_343_7 + s_343_6);
        // D s_343_9: bit-extract s_343_4 s_343_2 s_343_8
        let s_343_9: Bits = (Bits::new(
            ((s_343_4) >> (s_343_2)).value(),
            u16::try_from(s_343_8).unwrap(),
        ));
        // D s_343_10: cast reint s_343_9 -> u9
        let s_343_10: u16 = (s_343_9.value() as u16);
        // D s_343_11: cast zx s_343_10 -> bv
        let s_343_11: Bits = Bits::new(s_343_10 as u128, 9u16);
        // C s_343_12: const #484u : u9
        let s_343_12: u16 = 484;
        // C s_343_13: cast zx s_343_12 -> bv
        let s_343_13: Bits = Bits::new(s_343_12 as u128, 9u16);
        // D s_343_14: cmp-eq s_343_11 s_343_13
        let s_343_14: bool = ((s_343_11) == (s_343_13));
        // N s_343_15: branch s_343_14 b3106 b344
        if s_343_14 {
            return block_3106(state, tracer, fn_state);
        } else {
            return block_344(state, tracer, fn_state);
        };
    }
    fn block_344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_344_0: const #0u : u8
        let s_344_0: bool = false;
        // D s_344_1: write-var gs#398132 <= s_344_0
        fn_state.gs_398132 = s_344_0;
        // N s_344_2: jump b345
        return block_345(state, tracer, fn_state);
    }
    fn block_345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_345_0: read-var gs#398132:u8
        let s_345_0: bool = fn_state.gs_398132;
        // N s_345_1: branch s_345_0 b3105 b346
        if s_345_0 {
            return block_3105(state, tracer, fn_state);
        } else {
            return block_346(state, tracer, fn_state);
        };
    }
    fn block_346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_346_0: const #0u : u8
        let s_346_0: bool = false;
        // D s_346_1: write-var gs#398134 <= s_346_0
        fn_state.gs_398134 = s_346_0;
        // N s_346_2: jump b347
        return block_347(state, tracer, fn_state);
    }
    fn block_347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_347_0: read-var gs#398134:u8
        let s_347_0: bool = fn_state.gs_398134;
        // D s_347_1: not s_347_0
        let s_347_1: bool = !s_347_0;
        // N s_347_2: branch s_347_1 b349 b348
        if s_347_1 {
            return block_349(state, tracer, fn_state);
        } else {
            return block_348(state, tracer, fn_state);
        };
    }
    fn block_348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_348_0: const #3372s : i
        let s_348_0: i128 = 3372;
        // C s_348_1: const #14696u : u32
        let s_348_1: u32 = 14696;
        // N s_348_2: write-reg s_348_1 <= s_348_0
        let s_348_2: () = {
            state.write_register::<i128>(s_348_1 as isize, s_348_0);
            tracer.write_register(s_348_1 as isize, s_348_0);
        };
        // C s_348_3: const #22s : i
        let s_348_3: i128 = 22;
        // C s_348_4: const #1s : i
        let s_348_4: i128 = 1;
        // D s_348_5: read-var u#30671:u32
        let s_348_5: u32 = fn_state.u_30671;
        // D s_348_6: cast zx s_348_5 -> bv
        let s_348_6: Bits = Bits::new(s_348_5 as u128, 32u16);
        // D s_348_7: bit-extract s_348_6 s_348_3 s_348_4
        let s_348_7: Bits = (Bits::new(
            ((s_348_6) >> (s_348_3)).value(),
            u16::try_from(s_348_4).unwrap(),
        ));
        // D s_348_8: cast reint s_348_7 -> u8
        let s_348_8: bool = ((s_348_7.value()) != 0);
        // C s_348_9: const #20s : i
        let s_348_9: i128 = 20;
        // C s_348_10: const #2s : i
        let s_348_10: i128 = 2;
        // D s_348_11: read-var u#30671:u32
        let s_348_11: u32 = fn_state.u_30671;
        // D s_348_12: cast zx s_348_11 -> bv
        let s_348_12: Bits = Bits::new(s_348_11 as u128, 32u16);
        // D s_348_13: bit-extract s_348_12 s_348_9 s_348_10
        let s_348_13: Bits = (Bits::new(
            ((s_348_12) >> (s_348_9)).value(),
            u16::try_from(s_348_10).unwrap(),
        ));
        // D s_348_14: cast reint s_348_13 -> u8
        let s_348_14: u8 = (s_348_13.value() as u8);
        // C s_348_15: const #16s : i
        let s_348_15: i128 = 16;
        // C s_348_16: const #4s : i
        let s_348_16: i128 = 4;
        // D s_348_17: read-var u#30671:u32
        let s_348_17: u32 = fn_state.u_30671;
        // D s_348_18: cast zx s_348_17 -> bv
        let s_348_18: Bits = Bits::new(s_348_17 as u128, 32u16);
        // D s_348_19: bit-extract s_348_18 s_348_15 s_348_16
        let s_348_19: Bits = (Bits::new(
            ((s_348_18) >> (s_348_15)).value(),
            u16::try_from(s_348_16).unwrap(),
        ));
        // D s_348_20: cast reint s_348_19 -> u8
        let s_348_20: u8 = (s_348_19.value() as u8);
        // C s_348_21: const #12s : i
        let s_348_21: i128 = 12;
        // C s_348_22: const #4s : i
        let s_348_22: i128 = 4;
        // D s_348_23: read-var u#30671:u32
        let s_348_23: u32 = fn_state.u_30671;
        // D s_348_24: cast zx s_348_23 -> bv
        let s_348_24: Bits = Bits::new(s_348_23 as u128, 32u16);
        // D s_348_25: bit-extract s_348_24 s_348_21 s_348_22
        let s_348_25: Bits = (Bits::new(
            ((s_348_24) >> (s_348_21)).value(),
            u16::try_from(s_348_22).unwrap(),
        ));
        // D s_348_26: cast reint s_348_25 -> u8
        let s_348_26: u8 = (s_348_25.value() as u8);
        // C s_348_27: const #7s : i
        let s_348_27: i128 = 7;
        // C s_348_28: const #1s : i
        let s_348_28: i128 = 1;
        // D s_348_29: read-var u#30671:u32
        let s_348_29: u32 = fn_state.u_30671;
        // D s_348_30: cast zx s_348_29 -> bv
        let s_348_30: Bits = Bits::new(s_348_29 as u128, 32u16);
        // D s_348_31: bit-extract s_348_30 s_348_27 s_348_28
        let s_348_31: Bits = (Bits::new(
            ((s_348_30) >> (s_348_27)).value(),
            u16::try_from(s_348_28).unwrap(),
        ));
        // D s_348_32: cast reint s_348_31 -> u8
        let s_348_32: bool = ((s_348_31.value()) != 0);
        // C s_348_33: const #6s : i
        let s_348_33: i128 = 6;
        // C s_348_34: const #1s : i
        let s_348_34: i128 = 1;
        // D s_348_35: read-var u#30671:u32
        let s_348_35: u32 = fn_state.u_30671;
        // D s_348_36: cast zx s_348_35 -> bv
        let s_348_36: Bits = Bits::new(s_348_35 as u128, 32u16);
        // D s_348_37: bit-extract s_348_36 s_348_33 s_348_34
        let s_348_37: Bits = (Bits::new(
            ((s_348_36) >> (s_348_33)).value(),
            u16::try_from(s_348_34).unwrap(),
        ));
        // D s_348_38: cast reint s_348_37 -> u8
        let s_348_38: bool = ((s_348_37.value()) != 0);
        // C s_348_39: const #5s : i
        let s_348_39: i128 = 5;
        // C s_348_40: const #1s : i
        let s_348_40: i128 = 1;
        // D s_348_41: read-var u#30671:u32
        let s_348_41: u32 = fn_state.u_30671;
        // D s_348_42: cast zx s_348_41 -> bv
        let s_348_42: Bits = Bits::new(s_348_41 as u128, 32u16);
        // D s_348_43: bit-extract s_348_42 s_348_39 s_348_40
        let s_348_43: Bits = (Bits::new(
            ((s_348_42) >> (s_348_39)).value(),
            u16::try_from(s_348_40).unwrap(),
        ));
        // D s_348_44: cast reint s_348_43 -> u8
        let s_348_44: bool = ((s_348_43.value()) != 0);
        // C s_348_45: const #0s : i
        let s_348_45: i128 = 0;
        // C s_348_46: const #4s : i
        let s_348_46: i128 = 4;
        // D s_348_47: read-var u#30671:u32
        let s_348_47: u32 = fn_state.u_30671;
        // D s_348_48: cast zx s_348_47 -> bv
        let s_348_48: Bits = Bits::new(s_348_47 as u128, 32u16);
        // D s_348_49: bit-extract s_348_48 s_348_45 s_348_46
        let s_348_49: Bits = (Bits::new(
            ((s_348_48) >> (s_348_45)).value(),
            u16::try_from(s_348_46).unwrap(),
        ));
        // D s_348_50: cast reint s_348_49 -> u8
        let s_348_50: u8 = (s_348_49.value() as u8);
        // D s_348_51: call decode_aarch32_instrs_VADD_i_A1enc_A_txt(s_348_8, s_348_14, s_348_20, s_348_26, s_348_32, s_348_38, s_348_44, s_348_50)
        let s_348_51: () = decode_aarch32_instrs_VADD_i_A1enc_A_txt(
            state,
            tracer,
            s_348_8,
            s_348_14,
            s_348_20,
            s_348_26,
            s_348_32,
            s_348_38,
            s_348_44,
            s_348_50,
        );
        // N s_348_52: return
        return;
    }
    fn block_349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_349_0: read-var merge#var.1:struct
        let s_349_0: u32 = fn_state.merge_var._1;
        // D s_349_1: write-var u#30681 <= s_349_0
        fn_state.u_30681 = s_349_0;
        // C s_349_2: const #25s : i
        let s_349_2: i128 = 25;
        // D s_349_3: read-var u#30681:u32
        let s_349_3: u32 = fn_state.u_30681;
        // D s_349_4: cast zx s_349_3 -> bv
        let s_349_4: Bits = Bits::new(s_349_3 as u128, 32u16);
        // C s_349_5: const #1s : i64
        let s_349_5: i64 = 1;
        // C s_349_6: cast zx s_349_5 -> i
        let s_349_6: i128 = (i128::try_from(s_349_5).unwrap());
        // C s_349_7: const #6s : i
        let s_349_7: i128 = 6;
        // C s_349_8: add s_349_7 s_349_6
        let s_349_8: i128 = (s_349_7 + s_349_6);
        // D s_349_9: bit-extract s_349_4 s_349_2 s_349_8
        let s_349_9: Bits = (Bits::new(
            ((s_349_4) >> (s_349_2)).value(),
            u16::try_from(s_349_8).unwrap(),
        ));
        // D s_349_10: cast reint s_349_9 -> u8
        let s_349_10: u8 = (s_349_9.value() as u8);
        // D s_349_11: cast zx s_349_10 -> bv
        let s_349_11: Bits = Bits::new(s_349_10 as u128, 7u16);
        // C s_349_12: const #121u : u8
        let s_349_12: u8 = 121;
        // C s_349_13: cast zx s_349_12 -> bv
        let s_349_13: Bits = Bits::new(s_349_12 as u128, 7u16);
        // D s_349_14: cmp-eq s_349_11 s_349_13
        let s_349_14: bool = ((s_349_11) == (s_349_13));
        // N s_349_15: branch s_349_14 b3095 b350
        if s_349_14 {
            return block_3095(state, tracer, fn_state);
        } else {
            return block_350(state, tracer, fn_state);
        };
    }
    fn block_350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_350_0: const #0u : u8
        let s_350_0: bool = false;
        // D s_350_1: write-var gs#398167 <= s_350_0
        fn_state.gs_398167 = s_350_0;
        // N s_350_2: jump b351
        return block_351(state, tracer, fn_state);
    }
    fn block_351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_351_0: read-var gs#398167:u8
        let s_351_0: bool = fn_state.gs_398167;
        // N s_351_1: branch s_351_0 b3094 b352
        if s_351_0 {
            return block_3094(state, tracer, fn_state);
        } else {
            return block_352(state, tracer, fn_state);
        };
    }
    fn block_352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_352_0: const #0u : u8
        let s_352_0: bool = false;
        // D s_352_1: write-var gs#398169 <= s_352_0
        fn_state.gs_398169 = s_352_0;
        // N s_352_2: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_353_0: read-var gs#398169:u8
        let s_353_0: bool = fn_state.gs_398169;
        // D s_353_1: not s_353_0
        let s_353_1: bool = !s_353_0;
        // N s_353_2: branch s_353_1 b355 b354
        if s_353_1 {
            return block_355(state, tracer, fn_state);
        } else {
            return block_354(state, tracer, fn_state);
        };
    }
    fn block_354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_354_0: const #3374s : i
        let s_354_0: i128 = 3374;
        // C s_354_1: const #14696u : u32
        let s_354_1: u32 = 14696;
        // N s_354_2: write-reg s_354_1 <= s_354_0
        let s_354_2: () = {
            state.write_register::<i128>(s_354_1 as isize, s_354_0);
            tracer.write_register(s_354_1 as isize, s_354_0);
        };
        // C s_354_3: const #24s : i
        let s_354_3: i128 = 24;
        // C s_354_4: const #1s : i
        let s_354_4: i128 = 1;
        // D s_354_5: read-var u#30681:u32
        let s_354_5: u32 = fn_state.u_30681;
        // D s_354_6: cast zx s_354_5 -> bv
        let s_354_6: Bits = Bits::new(s_354_5 as u128, 32u16);
        // D s_354_7: bit-extract s_354_6 s_354_3 s_354_4
        let s_354_7: Bits = (Bits::new(
            ((s_354_6) >> (s_354_3)).value(),
            u16::try_from(s_354_4).unwrap(),
        ));
        // D s_354_8: cast reint s_354_7 -> u8
        let s_354_8: bool = ((s_354_7.value()) != 0);
        // C s_354_9: const #22s : i
        let s_354_9: i128 = 22;
        // C s_354_10: const #1s : i
        let s_354_10: i128 = 1;
        // D s_354_11: read-var u#30681:u32
        let s_354_11: u32 = fn_state.u_30681;
        // D s_354_12: cast zx s_354_11 -> bv
        let s_354_12: Bits = Bits::new(s_354_11 as u128, 32u16);
        // D s_354_13: bit-extract s_354_12 s_354_9 s_354_10
        let s_354_13: Bits = (Bits::new(
            ((s_354_12) >> (s_354_9)).value(),
            u16::try_from(s_354_10).unwrap(),
        ));
        // D s_354_14: cast reint s_354_13 -> u8
        let s_354_14: bool = ((s_354_13.value()) != 0);
        // C s_354_15: const #20s : i
        let s_354_15: i128 = 20;
        // C s_354_16: const #2s : i
        let s_354_16: i128 = 2;
        // D s_354_17: read-var u#30681:u32
        let s_354_17: u32 = fn_state.u_30681;
        // D s_354_18: cast zx s_354_17 -> bv
        let s_354_18: Bits = Bits::new(s_354_17 as u128, 32u16);
        // D s_354_19: bit-extract s_354_18 s_354_15 s_354_16
        let s_354_19: Bits = (Bits::new(
            ((s_354_18) >> (s_354_15)).value(),
            u16::try_from(s_354_16).unwrap(),
        ));
        // D s_354_20: cast reint s_354_19 -> u8
        let s_354_20: u8 = (s_354_19.value() as u8);
        // C s_354_21: const #16s : i
        let s_354_21: i128 = 16;
        // C s_354_22: const #4s : i
        let s_354_22: i128 = 4;
        // D s_354_23: read-var u#30681:u32
        let s_354_23: u32 = fn_state.u_30681;
        // D s_354_24: cast zx s_354_23 -> bv
        let s_354_24: Bits = Bits::new(s_354_23 as u128, 32u16);
        // D s_354_25: bit-extract s_354_24 s_354_21 s_354_22
        let s_354_25: Bits = (Bits::new(
            ((s_354_24) >> (s_354_21)).value(),
            u16::try_from(s_354_22).unwrap(),
        ));
        // D s_354_26: cast reint s_354_25 -> u8
        let s_354_26: u8 = (s_354_25.value() as u8);
        // C s_354_27: const #12s : i
        let s_354_27: i128 = 12;
        // C s_354_28: const #4s : i
        let s_354_28: i128 = 4;
        // D s_354_29: read-var u#30681:u32
        let s_354_29: u32 = fn_state.u_30681;
        // D s_354_30: cast zx s_354_29 -> bv
        let s_354_30: Bits = Bits::new(s_354_29 as u128, 32u16);
        // D s_354_31: bit-extract s_354_30 s_354_27 s_354_28
        let s_354_31: Bits = (Bits::new(
            ((s_354_30) >> (s_354_27)).value(),
            u16::try_from(s_354_28).unwrap(),
        ));
        // D s_354_32: cast reint s_354_31 -> u8
        let s_354_32: u8 = (s_354_31.value() as u8);
        // C s_354_33: const #8s : i
        let s_354_33: i128 = 8;
        // C s_354_34: const #1s : i
        let s_354_34: i128 = 1;
        // D s_354_35: read-var u#30681:u32
        let s_354_35: u32 = fn_state.u_30681;
        // D s_354_36: cast zx s_354_35 -> bv
        let s_354_36: Bits = Bits::new(s_354_35 as u128, 32u16);
        // D s_354_37: bit-extract s_354_36 s_354_33 s_354_34
        let s_354_37: Bits = (Bits::new(
            ((s_354_36) >> (s_354_33)).value(),
            u16::try_from(s_354_34).unwrap(),
        ));
        // D s_354_38: cast reint s_354_37 -> u8
        let s_354_38: bool = ((s_354_37.value()) != 0);
        // C s_354_39: const #7s : i
        let s_354_39: i128 = 7;
        // C s_354_40: const #1s : i
        let s_354_40: i128 = 1;
        // D s_354_41: read-var u#30681:u32
        let s_354_41: u32 = fn_state.u_30681;
        // D s_354_42: cast zx s_354_41 -> bv
        let s_354_42: Bits = Bits::new(s_354_41 as u128, 32u16);
        // D s_354_43: bit-extract s_354_42 s_354_39 s_354_40
        let s_354_43: Bits = (Bits::new(
            ((s_354_42) >> (s_354_39)).value(),
            u16::try_from(s_354_40).unwrap(),
        ));
        // D s_354_44: cast reint s_354_43 -> u8
        let s_354_44: bool = ((s_354_43.value()) != 0);
        // C s_354_45: const #5s : i
        let s_354_45: i128 = 5;
        // C s_354_46: const #1s : i
        let s_354_46: i128 = 1;
        // D s_354_47: read-var u#30681:u32
        let s_354_47: u32 = fn_state.u_30681;
        // D s_354_48: cast zx s_354_47 -> bv
        let s_354_48: Bits = Bits::new(s_354_47 as u128, 32u16);
        // D s_354_49: bit-extract s_354_48 s_354_45 s_354_46
        let s_354_49: Bits = (Bits::new(
            ((s_354_48) >> (s_354_45)).value(),
            u16::try_from(s_354_46).unwrap(),
        ));
        // D s_354_50: cast reint s_354_49 -> u8
        let s_354_50: bool = ((s_354_49.value()) != 0);
        // C s_354_51: const #0s : i
        let s_354_51: i128 = 0;
        // C s_354_52: const #4s : i
        let s_354_52: i128 = 4;
        // D s_354_53: read-var u#30681:u32
        let s_354_53: u32 = fn_state.u_30681;
        // D s_354_54: cast zx s_354_53 -> bv
        let s_354_54: Bits = Bits::new(s_354_53 as u128, 32u16);
        // D s_354_55: bit-extract s_354_54 s_354_51 s_354_52
        let s_354_55: Bits = (Bits::new(
            ((s_354_54) >> (s_354_51)).value(),
            u16::try_from(s_354_52).unwrap(),
        ));
        // D s_354_56: cast reint s_354_55 -> u8
        let s_354_56: u8 = (s_354_55.value() as u8);
        // D s_354_57: call decode_aarch32_instrs_VADDL_A1enc_A_txt(s_354_8, s_354_14, s_354_20, s_354_26, s_354_32, s_354_38, s_354_44, s_354_50, s_354_56)
        let s_354_57: () = decode_aarch32_instrs_VADDL_A1enc_A_txt(
            state,
            tracer,
            s_354_8,
            s_354_14,
            s_354_20,
            s_354_26,
            s_354_32,
            s_354_38,
            s_354_44,
            s_354_50,
            s_354_56,
        );
        // N s_354_58: return
        return;
    }
    fn block_355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_355_0: read-var merge#var.1:struct
        let s_355_0: u32 = fn_state.merge_var._1;
        // D s_355_1: write-var u#30692 <= s_355_0
        fn_state.u_30692 = s_355_0;
        // C s_355_2: const #23s : i
        let s_355_2: i128 = 23;
        // D s_355_3: read-var u#30692:u32
        let s_355_3: u32 = fn_state.u_30692;
        // D s_355_4: cast zx s_355_3 -> bv
        let s_355_4: Bits = Bits::new(s_355_3 as u128, 32u16);
        // C s_355_5: const #1s : i64
        let s_355_5: i64 = 1;
        // C s_355_6: cast zx s_355_5 -> i
        let s_355_6: i128 = (i128::try_from(s_355_5).unwrap());
        // C s_355_7: const #8s : i
        let s_355_7: i128 = 8;
        // C s_355_8: add s_355_7 s_355_6
        let s_355_8: i128 = (s_355_7 + s_355_6);
        // D s_355_9: bit-extract s_355_4 s_355_2 s_355_8
        let s_355_9: Bits = (Bits::new(
            ((s_355_4) >> (s_355_2)).value(),
            u16::try_from(s_355_8).unwrap(),
        ));
        // D s_355_10: cast reint s_355_9 -> u9
        let s_355_10: u16 = (s_355_9.value() as u16);
        // D s_355_11: cast zx s_355_10 -> bv
        let s_355_11: Bits = Bits::new(s_355_10 as u128, 9u16);
        // C s_355_12: const #484u : u9
        let s_355_12: u16 = 484;
        // C s_355_13: cast zx s_355_12 -> bv
        let s_355_13: Bits = Bits::new(s_355_12 as u128, 9u16);
        // D s_355_14: cmp-eq s_355_11 s_355_13
        let s_355_14: bool = ((s_355_11) == (s_355_13));
        // N s_355_15: branch s_355_14 b3087 b356
        if s_355_14 {
            return block_3087(state, tracer, fn_state);
        } else {
            return block_356(state, tracer, fn_state);
        };
    }
    fn block_356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_356_0: const #0u : u8
        let s_356_0: bool = false;
        // D s_356_1: write-var gs#398201 <= s_356_0
        fn_state.gs_398201 = s_356_0;
        // N s_356_2: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_357_0: read-var gs#398201:u8
        let s_357_0: bool = fn_state.gs_398201;
        // N s_357_1: branch s_357_0 b3086 b358
        if s_357_0 {
            return block_3086(state, tracer, fn_state);
        } else {
            return block_358(state, tracer, fn_state);
        };
    }
    fn block_358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_358_0: const #0u : u8
        let s_358_0: bool = false;
        // D s_358_1: write-var gs#398203 <= s_358_0
        fn_state.gs_398203 = s_358_0;
        // N s_358_2: jump b359
        return block_359(state, tracer, fn_state);
    }
    fn block_359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_359_0: read-var gs#398203:u8
        let s_359_0: bool = fn_state.gs_398203;
        // D s_359_1: not s_359_0
        let s_359_1: bool = !s_359_0;
        // N s_359_2: branch s_359_1 b361 b360
        if s_359_1 {
            return block_361(state, tracer, fn_state);
        } else {
            return block_360(state, tracer, fn_state);
        };
    }
    fn block_360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_360_0: const #3376s : i
        let s_360_0: i128 = 3376;
        // C s_360_1: const #14696u : u32
        let s_360_1: u32 = 14696;
        // N s_360_2: write-reg s_360_1 <= s_360_0
        let s_360_2: () = {
            state.write_register::<i128>(s_360_1 as isize, s_360_0);
            tracer.write_register(s_360_1 as isize, s_360_0);
        };
        // C s_360_3: const #22s : i
        let s_360_3: i128 = 22;
        // C s_360_4: const #1s : i
        let s_360_4: i128 = 1;
        // D s_360_5: read-var u#30692:u32
        let s_360_5: u32 = fn_state.u_30692;
        // D s_360_6: cast zx s_360_5 -> bv
        let s_360_6: Bits = Bits::new(s_360_5 as u128, 32u16);
        // D s_360_7: bit-extract s_360_6 s_360_3 s_360_4
        let s_360_7: Bits = (Bits::new(
            ((s_360_6) >> (s_360_3)).value(),
            u16::try_from(s_360_4).unwrap(),
        ));
        // D s_360_8: cast reint s_360_7 -> u8
        let s_360_8: bool = ((s_360_7.value()) != 0);
        // C s_360_9: const #16s : i
        let s_360_9: i128 = 16;
        // C s_360_10: const #4s : i
        let s_360_10: i128 = 4;
        // D s_360_11: read-var u#30692:u32
        let s_360_11: u32 = fn_state.u_30692;
        // D s_360_12: cast zx s_360_11 -> bv
        let s_360_12: Bits = Bits::new(s_360_11 as u128, 32u16);
        // D s_360_13: bit-extract s_360_12 s_360_9 s_360_10
        let s_360_13: Bits = (Bits::new(
            ((s_360_12) >> (s_360_9)).value(),
            u16::try_from(s_360_10).unwrap(),
        ));
        // D s_360_14: cast reint s_360_13 -> u8
        let s_360_14: u8 = (s_360_13.value() as u8);
        // C s_360_15: const #12s : i
        let s_360_15: i128 = 12;
        // C s_360_16: const #4s : i
        let s_360_16: i128 = 4;
        // D s_360_17: read-var u#30692:u32
        let s_360_17: u32 = fn_state.u_30692;
        // D s_360_18: cast zx s_360_17 -> bv
        let s_360_18: Bits = Bits::new(s_360_17 as u128, 32u16);
        // D s_360_19: bit-extract s_360_18 s_360_15 s_360_16
        let s_360_19: Bits = (Bits::new(
            ((s_360_18) >> (s_360_15)).value(),
            u16::try_from(s_360_16).unwrap(),
        ));
        // D s_360_20: cast reint s_360_19 -> u8
        let s_360_20: u8 = (s_360_19.value() as u8);
        // C s_360_21: const #7s : i
        let s_360_21: i128 = 7;
        // C s_360_22: const #1s : i
        let s_360_22: i128 = 1;
        // D s_360_23: read-var u#30692:u32
        let s_360_23: u32 = fn_state.u_30692;
        // D s_360_24: cast zx s_360_23 -> bv
        let s_360_24: Bits = Bits::new(s_360_23 as u128, 32u16);
        // D s_360_25: bit-extract s_360_24 s_360_21 s_360_22
        let s_360_25: Bits = (Bits::new(
            ((s_360_24) >> (s_360_21)).value(),
            u16::try_from(s_360_22).unwrap(),
        ));
        // D s_360_26: cast reint s_360_25 -> u8
        let s_360_26: bool = ((s_360_25.value()) != 0);
        // C s_360_27: const #6s : i
        let s_360_27: i128 = 6;
        // C s_360_28: const #1s : i
        let s_360_28: i128 = 1;
        // D s_360_29: read-var u#30692:u32
        let s_360_29: u32 = fn_state.u_30692;
        // D s_360_30: cast zx s_360_29 -> bv
        let s_360_30: Bits = Bits::new(s_360_29 as u128, 32u16);
        // D s_360_31: bit-extract s_360_30 s_360_27 s_360_28
        let s_360_31: Bits = (Bits::new(
            ((s_360_30) >> (s_360_27)).value(),
            u16::try_from(s_360_28).unwrap(),
        ));
        // D s_360_32: cast reint s_360_31 -> u8
        let s_360_32: bool = ((s_360_31.value()) != 0);
        // C s_360_33: const #5s : i
        let s_360_33: i128 = 5;
        // C s_360_34: const #1s : i
        let s_360_34: i128 = 1;
        // D s_360_35: read-var u#30692:u32
        let s_360_35: u32 = fn_state.u_30692;
        // D s_360_36: cast zx s_360_35 -> bv
        let s_360_36: Bits = Bits::new(s_360_35 as u128, 32u16);
        // D s_360_37: bit-extract s_360_36 s_360_33 s_360_34
        let s_360_37: Bits = (Bits::new(
            ((s_360_36) >> (s_360_33)).value(),
            u16::try_from(s_360_34).unwrap(),
        ));
        // D s_360_38: cast reint s_360_37 -> u8
        let s_360_38: bool = ((s_360_37.value()) != 0);
        // C s_360_39: const #0s : i
        let s_360_39: i128 = 0;
        // C s_360_40: const #4s : i
        let s_360_40: i128 = 4;
        // D s_360_41: read-var u#30692:u32
        let s_360_41: u32 = fn_state.u_30692;
        // D s_360_42: cast zx s_360_41 -> bv
        let s_360_42: Bits = Bits::new(s_360_41 as u128, 32u16);
        // D s_360_43: bit-extract s_360_42 s_360_39 s_360_40
        let s_360_43: Bits = (Bits::new(
            ((s_360_42) >> (s_360_39)).value(),
            u16::try_from(s_360_40).unwrap(),
        ));
        // D s_360_44: cast reint s_360_43 -> u8
        let s_360_44: u8 = (s_360_43.value() as u8);
        // D s_360_45: call decode_aarch32_instrs_VAND_r_A1enc_A_txt(s_360_8, s_360_14, s_360_20, s_360_26, s_360_32, s_360_38, s_360_44)
        let s_360_45: () = decode_aarch32_instrs_VAND_r_A1enc_A_txt(
            state,
            tracer,
            s_360_8,
            s_360_14,
            s_360_20,
            s_360_26,
            s_360_32,
            s_360_38,
            s_360_44,
        );
        // N s_360_46: return
        return;
    }
    fn block_361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_361_0: read-var merge#var.1:struct
        let s_361_0: u32 = fn_state.merge_var._1;
        // D s_361_1: write-var u#30701 <= s_361_0
        fn_state.u_30701 = s_361_0;
        // C s_361_2: const #25s : i
        let s_361_2: i128 = 25;
        // D s_361_3: read-var u#30701:u32
        let s_361_3: u32 = fn_state.u_30701;
        // D s_361_4: cast zx s_361_3 -> bv
        let s_361_4: Bits = Bits::new(s_361_3 as u128, 32u16);
        // C s_361_5: const #1s : i64
        let s_361_5: i64 = 1;
        // C s_361_6: cast zx s_361_5 -> i
        let s_361_6: i128 = (i128::try_from(s_361_5).unwrap());
        // C s_361_7: const #6s : i
        let s_361_7: i128 = 6;
        // C s_361_8: add s_361_7 s_361_6
        let s_361_8: i128 = (s_361_7 + s_361_6);
        // D s_361_9: bit-extract s_361_4 s_361_2 s_361_8
        let s_361_9: Bits = (Bits::new(
            ((s_361_4) >> (s_361_2)).value(),
            u16::try_from(s_361_8).unwrap(),
        ));
        // D s_361_10: cast reint s_361_9 -> u8
        let s_361_10: u8 = (s_361_9.value() as u8);
        // D s_361_11: cast zx s_361_10 -> bv
        let s_361_11: Bits = Bits::new(s_361_10 as u128, 7u16);
        // C s_361_12: const #121u : u8
        let s_361_12: u8 = 121;
        // C s_361_13: cast zx s_361_12 -> bv
        let s_361_13: Bits = Bits::new(s_361_12 as u128, 7u16);
        // D s_361_14: cmp-eq s_361_11 s_361_13
        let s_361_14: bool = ((s_361_11) == (s_361_13));
        // N s_361_15: branch s_361_14 b3073 b362
        if s_361_14 {
            return block_3073(state, tracer, fn_state);
        } else {
            return block_362(state, tracer, fn_state);
        };
    }
    fn block_362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_362_0: const #0u : u8
        let s_362_0: bool = false;
        // D s_362_1: write-var gs#398237 <= s_362_0
        fn_state.gs_398237 = s_362_0;
        // N s_362_2: jump b363
        return block_363(state, tracer, fn_state);
    }
    fn block_363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_363_0: read-var gs#398237:u8
        let s_363_0: bool = fn_state.gs_398237;
        // N s_363_1: branch s_363_0 b3072 b364
        if s_363_0 {
            return block_3072(state, tracer, fn_state);
        } else {
            return block_364(state, tracer, fn_state);
        };
    }
    fn block_364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_364_0: const #0u : u8
        let s_364_0: bool = false;
        // D s_364_1: write-var gs#398239 <= s_364_0
        fn_state.gs_398239 = s_364_0;
        // N s_364_2: jump b365
        return block_365(state, tracer, fn_state);
    }
    fn block_365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_365_0: read-var gs#398239:u8
        let s_365_0: bool = fn_state.gs_398239;
        // D s_365_1: not s_365_0
        let s_365_1: bool = !s_365_0;
        // N s_365_2: branch s_365_1 b367 b366
        if s_365_1 {
            return block_367(state, tracer, fn_state);
        } else {
            return block_366(state, tracer, fn_state);
        };
    }
    fn block_366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_366_0: const #3378s : i
        let s_366_0: i128 = 3378;
        // C s_366_1: const #14696u : u32
        let s_366_1: u32 = 14696;
        // N s_366_2: write-reg s_366_1 <= s_366_0
        let s_366_2: () = {
            state.write_register::<i128>(s_366_1 as isize, s_366_0);
            tracer.write_register(s_366_1 as isize, s_366_0);
        };
        // C s_366_3: const #24s : i
        let s_366_3: i128 = 24;
        // C s_366_4: const #1s : i
        let s_366_4: i128 = 1;
        // D s_366_5: read-var u#30701:u32
        let s_366_5: u32 = fn_state.u_30701;
        // D s_366_6: cast zx s_366_5 -> bv
        let s_366_6: Bits = Bits::new(s_366_5 as u128, 32u16);
        // D s_366_7: bit-extract s_366_6 s_366_3 s_366_4
        let s_366_7: Bits = (Bits::new(
            ((s_366_6) >> (s_366_3)).value(),
            u16::try_from(s_366_4).unwrap(),
        ));
        // D s_366_8: cast reint s_366_7 -> u8
        let s_366_8: bool = ((s_366_7.value()) != 0);
        // C s_366_9: const #22s : i
        let s_366_9: i128 = 22;
        // C s_366_10: const #1s : i
        let s_366_10: i128 = 1;
        // D s_366_11: read-var u#30701:u32
        let s_366_11: u32 = fn_state.u_30701;
        // D s_366_12: cast zx s_366_11 -> bv
        let s_366_12: Bits = Bits::new(s_366_11 as u128, 32u16);
        // D s_366_13: bit-extract s_366_12 s_366_9 s_366_10
        let s_366_13: Bits = (Bits::new(
            ((s_366_12) >> (s_366_9)).value(),
            u16::try_from(s_366_10).unwrap(),
        ));
        // D s_366_14: cast reint s_366_13 -> u8
        let s_366_14: bool = ((s_366_13.value()) != 0);
        // C s_366_15: const #16s : i
        let s_366_15: i128 = 16;
        // C s_366_16: const #3s : i
        let s_366_16: i128 = 3;
        // D s_366_17: read-var u#30701:u32
        let s_366_17: u32 = fn_state.u_30701;
        // D s_366_18: cast zx s_366_17 -> bv
        let s_366_18: Bits = Bits::new(s_366_17 as u128, 32u16);
        // D s_366_19: bit-extract s_366_18 s_366_15 s_366_16
        let s_366_19: Bits = (Bits::new(
            ((s_366_18) >> (s_366_15)).value(),
            u16::try_from(s_366_16).unwrap(),
        ));
        // D s_366_20: cast reint s_366_19 -> u8
        let s_366_20: u8 = (s_366_19.value() as u8);
        // C s_366_21: const #12s : i
        let s_366_21: i128 = 12;
        // C s_366_22: const #4s : i
        let s_366_22: i128 = 4;
        // D s_366_23: read-var u#30701:u32
        let s_366_23: u32 = fn_state.u_30701;
        // D s_366_24: cast zx s_366_23 -> bv
        let s_366_24: Bits = Bits::new(s_366_23 as u128, 32u16);
        // D s_366_25: bit-extract s_366_24 s_366_21 s_366_22
        let s_366_25: Bits = (Bits::new(
            ((s_366_24) >> (s_366_21)).value(),
            u16::try_from(s_366_22).unwrap(),
        ));
        // D s_366_26: cast reint s_366_25 -> u8
        let s_366_26: u8 = (s_366_25.value() as u8);
        // C s_366_27: const #8s : i
        let s_366_27: i128 = 8;
        // C s_366_28: const #4s : i
        let s_366_28: i128 = 4;
        // D s_366_29: read-var u#30701:u32
        let s_366_29: u32 = fn_state.u_30701;
        // D s_366_30: cast zx s_366_29 -> bv
        let s_366_30: Bits = Bits::new(s_366_29 as u128, 32u16);
        // D s_366_31: bit-extract s_366_30 s_366_27 s_366_28
        let s_366_31: Bits = (Bits::new(
            ((s_366_30) >> (s_366_27)).value(),
            u16::try_from(s_366_28).unwrap(),
        ));
        // D s_366_32: cast reint s_366_31 -> u8
        let s_366_32: u8 = (s_366_31.value() as u8);
        // C s_366_33: const #6s : i
        let s_366_33: i128 = 6;
        // C s_366_34: const #1s : i
        let s_366_34: i128 = 1;
        // D s_366_35: read-var u#30701:u32
        let s_366_35: u32 = fn_state.u_30701;
        // D s_366_36: cast zx s_366_35 -> bv
        let s_366_36: Bits = Bits::new(s_366_35 as u128, 32u16);
        // D s_366_37: bit-extract s_366_36 s_366_33 s_366_34
        let s_366_37: Bits = (Bits::new(
            ((s_366_36) >> (s_366_33)).value(),
            u16::try_from(s_366_34).unwrap(),
        ));
        // D s_366_38: cast reint s_366_37 -> u8
        let s_366_38: bool = ((s_366_37.value()) != 0);
        // C s_366_39: const #0s : i
        let s_366_39: i128 = 0;
        // C s_366_40: const #4s : i
        let s_366_40: i128 = 4;
        // D s_366_41: read-var u#30701:u32
        let s_366_41: u32 = fn_state.u_30701;
        // D s_366_42: cast zx s_366_41 -> bv
        let s_366_42: Bits = Bits::new(s_366_41 as u128, 32u16);
        // D s_366_43: bit-extract s_366_42 s_366_39 s_366_40
        let s_366_43: Bits = (Bits::new(
            ((s_366_42) >> (s_366_39)).value(),
            u16::try_from(s_366_40).unwrap(),
        ));
        // D s_366_44: cast reint s_366_43 -> u8
        let s_366_44: u8 = (s_366_43.value() as u8);
        // D s_366_45: call decode_aarch32_instrs_VBIC_i_A1enc_A_txt(s_366_8, s_366_14, s_366_20, s_366_26, s_366_32, s_366_38, s_366_44)
        let s_366_45: () = decode_aarch32_instrs_VBIC_i_A1enc_A_txt(
            state,
            tracer,
            s_366_8,
            s_366_14,
            s_366_20,
            s_366_26,
            s_366_32,
            s_366_38,
            s_366_44,
        );
        // N s_366_46: return
        return;
    }
    fn block_367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_367_0: read-var merge#var.1:struct
        let s_367_0: u32 = fn_state.merge_var._1;
        // D s_367_1: write-var u#30706 <= s_367_0
        fn_state.u_30706 = s_367_0;
        // C s_367_2: const #25s : i
        let s_367_2: i128 = 25;
        // D s_367_3: read-var u#30706:u32
        let s_367_3: u32 = fn_state.u_30706;
        // D s_367_4: cast zx s_367_3 -> bv
        let s_367_4: Bits = Bits::new(s_367_3 as u128, 32u16);
        // C s_367_5: const #1s : i64
        let s_367_5: i64 = 1;
        // C s_367_6: cast zx s_367_5 -> i
        let s_367_6: i128 = (i128::try_from(s_367_5).unwrap());
        // C s_367_7: const #6s : i
        let s_367_7: i128 = 6;
        // C s_367_8: add s_367_7 s_367_6
        let s_367_8: i128 = (s_367_7 + s_367_6);
        // D s_367_9: bit-extract s_367_4 s_367_2 s_367_8
        let s_367_9: Bits = (Bits::new(
            ((s_367_4) >> (s_367_2)).value(),
            u16::try_from(s_367_8).unwrap(),
        ));
        // D s_367_10: cast reint s_367_9 -> u8
        let s_367_10: u8 = (s_367_9.value() as u8);
        // D s_367_11: cast zx s_367_10 -> bv
        let s_367_11: Bits = Bits::new(s_367_10 as u128, 7u16);
        // C s_367_12: const #121u : u8
        let s_367_12: u8 = 121;
        // C s_367_13: cast zx s_367_12 -> bv
        let s_367_13: Bits = Bits::new(s_367_12 as u128, 7u16);
        // D s_367_14: cmp-eq s_367_11 s_367_13
        let s_367_14: bool = ((s_367_11) == (s_367_13));
        // N s_367_15: branch s_367_14 b3059 b368
        if s_367_14 {
            return block_3059(state, tracer, fn_state);
        } else {
            return block_368(state, tracer, fn_state);
        };
    }
    fn block_368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_368_0: const #0u : u8
        let s_368_0: bool = false;
        // D s_368_1: write-var gs#398273 <= s_368_0
        fn_state.gs_398273 = s_368_0;
        // N s_368_2: jump b369
        return block_369(state, tracer, fn_state);
    }
    fn block_369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_369_0: read-var gs#398273:u8
        let s_369_0: bool = fn_state.gs_398273;
        // N s_369_1: branch s_369_0 b3058 b370
        if s_369_0 {
            return block_3058(state, tracer, fn_state);
        } else {
            return block_370(state, tracer, fn_state);
        };
    }
    fn block_370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_370_0: const #0u : u8
        let s_370_0: bool = false;
        // D s_370_1: write-var gs#398275 <= s_370_0
        fn_state.gs_398275 = s_370_0;
        // N s_370_2: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_371_0: read-var gs#398275:u8
        let s_371_0: bool = fn_state.gs_398275;
        // D s_371_1: not s_371_0
        let s_371_1: bool = !s_371_0;
        // N s_371_2: branch s_371_1 b373 b372
        if s_371_1 {
            return block_373(state, tracer, fn_state);
        } else {
            return block_372(state, tracer, fn_state);
        };
    }
    fn block_372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_372_0: const #3379s : i
        let s_372_0: i128 = 3379;
        // C s_372_1: const #14696u : u32
        let s_372_1: u32 = 14696;
        // N s_372_2: write-reg s_372_1 <= s_372_0
        let s_372_2: () = {
            state.write_register::<i128>(s_372_1 as isize, s_372_0);
            tracer.write_register(s_372_1 as isize, s_372_0);
        };
        // C s_372_3: const #24s : i
        let s_372_3: i128 = 24;
        // C s_372_4: const #1s : i
        let s_372_4: i128 = 1;
        // D s_372_5: read-var u#30706:u32
        let s_372_5: u32 = fn_state.u_30706;
        // D s_372_6: cast zx s_372_5 -> bv
        let s_372_6: Bits = Bits::new(s_372_5 as u128, 32u16);
        // D s_372_7: bit-extract s_372_6 s_372_3 s_372_4
        let s_372_7: Bits = (Bits::new(
            ((s_372_6) >> (s_372_3)).value(),
            u16::try_from(s_372_4).unwrap(),
        ));
        // D s_372_8: cast reint s_372_7 -> u8
        let s_372_8: bool = ((s_372_7.value()) != 0);
        // C s_372_9: const #22s : i
        let s_372_9: i128 = 22;
        // C s_372_10: const #1s : i
        let s_372_10: i128 = 1;
        // D s_372_11: read-var u#30706:u32
        let s_372_11: u32 = fn_state.u_30706;
        // D s_372_12: cast zx s_372_11 -> bv
        let s_372_12: Bits = Bits::new(s_372_11 as u128, 32u16);
        // D s_372_13: bit-extract s_372_12 s_372_9 s_372_10
        let s_372_13: Bits = (Bits::new(
            ((s_372_12) >> (s_372_9)).value(),
            u16::try_from(s_372_10).unwrap(),
        ));
        // D s_372_14: cast reint s_372_13 -> u8
        let s_372_14: bool = ((s_372_13.value()) != 0);
        // C s_372_15: const #16s : i
        let s_372_15: i128 = 16;
        // C s_372_16: const #3s : i
        let s_372_16: i128 = 3;
        // D s_372_17: read-var u#30706:u32
        let s_372_17: u32 = fn_state.u_30706;
        // D s_372_18: cast zx s_372_17 -> bv
        let s_372_18: Bits = Bits::new(s_372_17 as u128, 32u16);
        // D s_372_19: bit-extract s_372_18 s_372_15 s_372_16
        let s_372_19: Bits = (Bits::new(
            ((s_372_18) >> (s_372_15)).value(),
            u16::try_from(s_372_16).unwrap(),
        ));
        // D s_372_20: cast reint s_372_19 -> u8
        let s_372_20: u8 = (s_372_19.value() as u8);
        // C s_372_21: const #12s : i
        let s_372_21: i128 = 12;
        // C s_372_22: const #4s : i
        let s_372_22: i128 = 4;
        // D s_372_23: read-var u#30706:u32
        let s_372_23: u32 = fn_state.u_30706;
        // D s_372_24: cast zx s_372_23 -> bv
        let s_372_24: Bits = Bits::new(s_372_23 as u128, 32u16);
        // D s_372_25: bit-extract s_372_24 s_372_21 s_372_22
        let s_372_25: Bits = (Bits::new(
            ((s_372_24) >> (s_372_21)).value(),
            u16::try_from(s_372_22).unwrap(),
        ));
        // D s_372_26: cast reint s_372_25 -> u8
        let s_372_26: u8 = (s_372_25.value() as u8);
        // C s_372_27: const #8s : i
        let s_372_27: i128 = 8;
        // C s_372_28: const #4s : i
        let s_372_28: i128 = 4;
        // D s_372_29: read-var u#30706:u32
        let s_372_29: u32 = fn_state.u_30706;
        // D s_372_30: cast zx s_372_29 -> bv
        let s_372_30: Bits = Bits::new(s_372_29 as u128, 32u16);
        // D s_372_31: bit-extract s_372_30 s_372_27 s_372_28
        let s_372_31: Bits = (Bits::new(
            ((s_372_30) >> (s_372_27)).value(),
            u16::try_from(s_372_28).unwrap(),
        ));
        // D s_372_32: cast reint s_372_31 -> u8
        let s_372_32: u8 = (s_372_31.value() as u8);
        // C s_372_33: const #6s : i
        let s_372_33: i128 = 6;
        // C s_372_34: const #1s : i
        let s_372_34: i128 = 1;
        // D s_372_35: read-var u#30706:u32
        let s_372_35: u32 = fn_state.u_30706;
        // D s_372_36: cast zx s_372_35 -> bv
        let s_372_36: Bits = Bits::new(s_372_35 as u128, 32u16);
        // D s_372_37: bit-extract s_372_36 s_372_33 s_372_34
        let s_372_37: Bits = (Bits::new(
            ((s_372_36) >> (s_372_33)).value(),
            u16::try_from(s_372_34).unwrap(),
        ));
        // D s_372_38: cast reint s_372_37 -> u8
        let s_372_38: bool = ((s_372_37.value()) != 0);
        // C s_372_39: const #0s : i
        let s_372_39: i128 = 0;
        // C s_372_40: const #4s : i
        let s_372_40: i128 = 4;
        // D s_372_41: read-var u#30706:u32
        let s_372_41: u32 = fn_state.u_30706;
        // D s_372_42: cast zx s_372_41 -> bv
        let s_372_42: Bits = Bits::new(s_372_41 as u128, 32u16);
        // D s_372_43: bit-extract s_372_42 s_372_39 s_372_40
        let s_372_43: Bits = (Bits::new(
            ((s_372_42) >> (s_372_39)).value(),
            u16::try_from(s_372_40).unwrap(),
        ));
        // D s_372_44: cast reint s_372_43 -> u8
        let s_372_44: u8 = (s_372_43.value() as u8);
        // D s_372_45: call decode_aarch32_instrs_VBIC_i_A2enc_A_txt(s_372_8, s_372_14, s_372_20, s_372_26, s_372_32, s_372_38, s_372_44)
        let s_372_45: () = decode_aarch32_instrs_VBIC_i_A2enc_A_txt(
            state,
            tracer,
            s_372_8,
            s_372_14,
            s_372_20,
            s_372_26,
            s_372_32,
            s_372_38,
            s_372_44,
        );
        // N s_372_46: return
        return;
    }
    fn block_373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_373_0: read-var merge#var.1:struct
        let s_373_0: u32 = fn_state.merge_var._1;
        // D s_373_1: write-var u#30715 <= s_373_0
        fn_state.u_30715 = s_373_0;
        // C s_373_2: const #23s : i
        let s_373_2: i128 = 23;
        // D s_373_3: read-var u#30715:u32
        let s_373_3: u32 = fn_state.u_30715;
        // D s_373_4: cast zx s_373_3 -> bv
        let s_373_4: Bits = Bits::new(s_373_3 as u128, 32u16);
        // C s_373_5: const #1s : i64
        let s_373_5: i64 = 1;
        // C s_373_6: cast zx s_373_5 -> i
        let s_373_6: i128 = (i128::try_from(s_373_5).unwrap());
        // C s_373_7: const #8s : i
        let s_373_7: i128 = 8;
        // C s_373_8: add s_373_7 s_373_6
        let s_373_8: i128 = (s_373_7 + s_373_6);
        // D s_373_9: bit-extract s_373_4 s_373_2 s_373_8
        let s_373_9: Bits = (Bits::new(
            ((s_373_4) >> (s_373_2)).value(),
            u16::try_from(s_373_8).unwrap(),
        ));
        // D s_373_10: cast reint s_373_9 -> u9
        let s_373_10: u16 = (s_373_9.value() as u16);
        // D s_373_11: cast zx s_373_10 -> bv
        let s_373_11: Bits = Bits::new(s_373_10 as u128, 9u16);
        // C s_373_12: const #484u : u9
        let s_373_12: u16 = 484;
        // C s_373_13: cast zx s_373_12 -> bv
        let s_373_13: Bits = Bits::new(s_373_12 as u128, 9u16);
        // D s_373_14: cmp-eq s_373_11 s_373_13
        let s_373_14: bool = ((s_373_11) == (s_373_13));
        // N s_373_15: branch s_373_14 b3051 b374
        if s_373_14 {
            return block_3051(state, tracer, fn_state);
        } else {
            return block_374(state, tracer, fn_state);
        };
    }
    fn block_374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_374_0: const #0u : u8
        let s_374_0: bool = false;
        // D s_374_1: write-var gs#398303 <= s_374_0
        fn_state.gs_398303 = s_374_0;
        // N s_374_2: jump b375
        return block_375(state, tracer, fn_state);
    }
    fn block_375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_375_0: read-var gs#398303:u8
        let s_375_0: bool = fn_state.gs_398303;
        // N s_375_1: branch s_375_0 b3050 b376
        if s_375_0 {
            return block_3050(state, tracer, fn_state);
        } else {
            return block_376(state, tracer, fn_state);
        };
    }
    fn block_376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_376_0: const #0u : u8
        let s_376_0: bool = false;
        // D s_376_1: write-var gs#398305 <= s_376_0
        fn_state.gs_398305 = s_376_0;
        // N s_376_2: jump b377
        return block_377(state, tracer, fn_state);
    }
    fn block_377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_377_0: read-var gs#398305:u8
        let s_377_0: bool = fn_state.gs_398305;
        // D s_377_1: not s_377_0
        let s_377_1: bool = !s_377_0;
        // N s_377_2: branch s_377_1 b379 b378
        if s_377_1 {
            return block_379(state, tracer, fn_state);
        } else {
            return block_378(state, tracer, fn_state);
        };
    }
    fn block_378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_378_0: const #3382s : i
        let s_378_0: i128 = 3382;
        // C s_378_1: const #14696u : u32
        let s_378_1: u32 = 14696;
        // N s_378_2: write-reg s_378_1 <= s_378_0
        let s_378_2: () = {
            state.write_register::<i128>(s_378_1 as isize, s_378_0);
            tracer.write_register(s_378_1 as isize, s_378_0);
        };
        // C s_378_3: const #22s : i
        let s_378_3: i128 = 22;
        // C s_378_4: const #1s : i
        let s_378_4: i128 = 1;
        // D s_378_5: read-var u#30715:u32
        let s_378_5: u32 = fn_state.u_30715;
        // D s_378_6: cast zx s_378_5 -> bv
        let s_378_6: Bits = Bits::new(s_378_5 as u128, 32u16);
        // D s_378_7: bit-extract s_378_6 s_378_3 s_378_4
        let s_378_7: Bits = (Bits::new(
            ((s_378_6) >> (s_378_3)).value(),
            u16::try_from(s_378_4).unwrap(),
        ));
        // D s_378_8: cast reint s_378_7 -> u8
        let s_378_8: bool = ((s_378_7.value()) != 0);
        // C s_378_9: const #16s : i
        let s_378_9: i128 = 16;
        // C s_378_10: const #4s : i
        let s_378_10: i128 = 4;
        // D s_378_11: read-var u#30715:u32
        let s_378_11: u32 = fn_state.u_30715;
        // D s_378_12: cast zx s_378_11 -> bv
        let s_378_12: Bits = Bits::new(s_378_11 as u128, 32u16);
        // D s_378_13: bit-extract s_378_12 s_378_9 s_378_10
        let s_378_13: Bits = (Bits::new(
            ((s_378_12) >> (s_378_9)).value(),
            u16::try_from(s_378_10).unwrap(),
        ));
        // D s_378_14: cast reint s_378_13 -> u8
        let s_378_14: u8 = (s_378_13.value() as u8);
        // C s_378_15: const #12s : i
        let s_378_15: i128 = 12;
        // C s_378_16: const #4s : i
        let s_378_16: i128 = 4;
        // D s_378_17: read-var u#30715:u32
        let s_378_17: u32 = fn_state.u_30715;
        // D s_378_18: cast zx s_378_17 -> bv
        let s_378_18: Bits = Bits::new(s_378_17 as u128, 32u16);
        // D s_378_19: bit-extract s_378_18 s_378_15 s_378_16
        let s_378_19: Bits = (Bits::new(
            ((s_378_18) >> (s_378_15)).value(),
            u16::try_from(s_378_16).unwrap(),
        ));
        // D s_378_20: cast reint s_378_19 -> u8
        let s_378_20: u8 = (s_378_19.value() as u8);
        // C s_378_21: const #7s : i
        let s_378_21: i128 = 7;
        // C s_378_22: const #1s : i
        let s_378_22: i128 = 1;
        // D s_378_23: read-var u#30715:u32
        let s_378_23: u32 = fn_state.u_30715;
        // D s_378_24: cast zx s_378_23 -> bv
        let s_378_24: Bits = Bits::new(s_378_23 as u128, 32u16);
        // D s_378_25: bit-extract s_378_24 s_378_21 s_378_22
        let s_378_25: Bits = (Bits::new(
            ((s_378_24) >> (s_378_21)).value(),
            u16::try_from(s_378_22).unwrap(),
        ));
        // D s_378_26: cast reint s_378_25 -> u8
        let s_378_26: bool = ((s_378_25.value()) != 0);
        // C s_378_27: const #6s : i
        let s_378_27: i128 = 6;
        // C s_378_28: const #1s : i
        let s_378_28: i128 = 1;
        // D s_378_29: read-var u#30715:u32
        let s_378_29: u32 = fn_state.u_30715;
        // D s_378_30: cast zx s_378_29 -> bv
        let s_378_30: Bits = Bits::new(s_378_29 as u128, 32u16);
        // D s_378_31: bit-extract s_378_30 s_378_27 s_378_28
        let s_378_31: Bits = (Bits::new(
            ((s_378_30) >> (s_378_27)).value(),
            u16::try_from(s_378_28).unwrap(),
        ));
        // D s_378_32: cast reint s_378_31 -> u8
        let s_378_32: bool = ((s_378_31.value()) != 0);
        // C s_378_33: const #5s : i
        let s_378_33: i128 = 5;
        // C s_378_34: const #1s : i
        let s_378_34: i128 = 1;
        // D s_378_35: read-var u#30715:u32
        let s_378_35: u32 = fn_state.u_30715;
        // D s_378_36: cast zx s_378_35 -> bv
        let s_378_36: Bits = Bits::new(s_378_35 as u128, 32u16);
        // D s_378_37: bit-extract s_378_36 s_378_33 s_378_34
        let s_378_37: Bits = (Bits::new(
            ((s_378_36) >> (s_378_33)).value(),
            u16::try_from(s_378_34).unwrap(),
        ));
        // D s_378_38: cast reint s_378_37 -> u8
        let s_378_38: bool = ((s_378_37.value()) != 0);
        // C s_378_39: const #0s : i
        let s_378_39: i128 = 0;
        // C s_378_40: const #4s : i
        let s_378_40: i128 = 4;
        // D s_378_41: read-var u#30715:u32
        let s_378_41: u32 = fn_state.u_30715;
        // D s_378_42: cast zx s_378_41 -> bv
        let s_378_42: Bits = Bits::new(s_378_41 as u128, 32u16);
        // D s_378_43: bit-extract s_378_42 s_378_39 s_378_40
        let s_378_43: Bits = (Bits::new(
            ((s_378_42) >> (s_378_39)).value(),
            u16::try_from(s_378_40).unwrap(),
        ));
        // D s_378_44: cast reint s_378_43 -> u8
        let s_378_44: u8 = (s_378_43.value() as u8);
        // D s_378_45: call decode_aarch32_instrs_VBIC_r_A1enc_A_txt(s_378_8, s_378_14, s_378_20, s_378_26, s_378_32, s_378_38, s_378_44)
        let s_378_45: () = decode_aarch32_instrs_VBIC_r_A1enc_A_txt(
            state,
            tracer,
            s_378_8,
            s_378_14,
            s_378_20,
            s_378_26,
            s_378_32,
            s_378_38,
            s_378_44,
        );
        // N s_378_46: return
        return;
    }
    fn block_379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_379_0: read-var merge#var.1:struct
        let s_379_0: u32 = fn_state.merge_var._1;
        // D s_379_1: write-var u#30724 <= s_379_0
        fn_state.u_30724 = s_379_0;
        // C s_379_2: const #23s : i
        let s_379_2: i128 = 23;
        // D s_379_3: read-var u#30724:u32
        let s_379_3: u32 = fn_state.u_30724;
        // D s_379_4: cast zx s_379_3 -> bv
        let s_379_4: Bits = Bits::new(s_379_3 as u128, 32u16);
        // C s_379_5: const #1s : i64
        let s_379_5: i64 = 1;
        // C s_379_6: cast zx s_379_5 -> i
        let s_379_6: i128 = (i128::try_from(s_379_5).unwrap());
        // C s_379_7: const #8s : i
        let s_379_7: i128 = 8;
        // C s_379_8: add s_379_7 s_379_6
        let s_379_8: i128 = (s_379_7 + s_379_6);
        // D s_379_9: bit-extract s_379_4 s_379_2 s_379_8
        let s_379_9: Bits = (Bits::new(
            ((s_379_4) >> (s_379_2)).value(),
            u16::try_from(s_379_8).unwrap(),
        ));
        // D s_379_10: cast reint s_379_9 -> u9
        let s_379_10: u16 = (s_379_9.value() as u16);
        // D s_379_11: cast zx s_379_10 -> bv
        let s_379_11: Bits = Bits::new(s_379_10 as u128, 9u16);
        // C s_379_12: const #486u : u9
        let s_379_12: u16 = 486;
        // C s_379_13: cast zx s_379_12 -> bv
        let s_379_13: Bits = Bits::new(s_379_12 as u128, 9u16);
        // D s_379_14: cmp-eq s_379_11 s_379_13
        let s_379_14: bool = ((s_379_11) == (s_379_13));
        // N s_379_15: branch s_379_14 b3046 b380
        if s_379_14 {
            return block_3046(state, tracer, fn_state);
        } else {
            return block_380(state, tracer, fn_state);
        };
    }
    fn block_380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_380_0: const #0u : u8
        let s_380_0: bool = false;
        // D s_380_1: write-var gs#398330 <= s_380_0
        fn_state.gs_398330 = s_380_0;
        // N s_380_2: jump b381
        return block_381(state, tracer, fn_state);
    }
    fn block_381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_381_0: read-var gs#398330:u8
        let s_381_0: bool = fn_state.gs_398330;
        // N s_381_1: branch s_381_0 b3045 b382
        if s_381_0 {
            return block_3045(state, tracer, fn_state);
        } else {
            return block_382(state, tracer, fn_state);
        };
    }
    fn block_382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_382_0: const #0u : u8
        let s_382_0: bool = false;
        // D s_382_1: write-var gs#398332 <= s_382_0
        fn_state.gs_398332 = s_382_0;
        // N s_382_2: jump b383
        return block_383(state, tracer, fn_state);
    }
    fn block_383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_383_0: read-var gs#398332:u8
        let s_383_0: bool = fn_state.gs_398332;
        // D s_383_1: not s_383_0
        let s_383_1: bool = !s_383_0;
        // N s_383_2: branch s_383_1 b385 b384
        if s_383_1 {
            return block_385(state, tracer, fn_state);
        } else {
            return block_384(state, tracer, fn_state);
        };
    }
    fn block_384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_384_0: const #3384s : i
        let s_384_0: i128 = 3384;
        // C s_384_1: const #14696u : u32
        let s_384_1: u32 = 14696;
        // N s_384_2: write-reg s_384_1 <= s_384_0
        let s_384_2: () = {
            state.write_register::<i128>(s_384_1 as isize, s_384_0);
            tracer.write_register(s_384_1 as isize, s_384_0);
        };
        // C s_384_3: const #22s : i
        let s_384_3: i128 = 22;
        // C s_384_4: const #1s : i
        let s_384_4: i128 = 1;
        // D s_384_5: read-var u#30724:u32
        let s_384_5: u32 = fn_state.u_30724;
        // D s_384_6: cast zx s_384_5 -> bv
        let s_384_6: Bits = Bits::new(s_384_5 as u128, 32u16);
        // D s_384_7: bit-extract s_384_6 s_384_3 s_384_4
        let s_384_7: Bits = (Bits::new(
            ((s_384_6) >> (s_384_3)).value(),
            u16::try_from(s_384_4).unwrap(),
        ));
        // D s_384_8: cast reint s_384_7 -> u8
        let s_384_8: bool = ((s_384_7.value()) != 0);
        // C s_384_9: const #20s : i
        let s_384_9: i128 = 20;
        // C s_384_10: const #2s : i
        let s_384_10: i128 = 2;
        // D s_384_11: read-var u#30724:u32
        let s_384_11: u32 = fn_state.u_30724;
        // D s_384_12: cast zx s_384_11 -> bv
        let s_384_12: Bits = Bits::new(s_384_11 as u128, 32u16);
        // D s_384_13: bit-extract s_384_12 s_384_9 s_384_10
        let s_384_13: Bits = (Bits::new(
            ((s_384_12) >> (s_384_9)).value(),
            u16::try_from(s_384_10).unwrap(),
        ));
        // D s_384_14: cast reint s_384_13 -> u8
        let s_384_14: u8 = (s_384_13.value() as u8);
        // C s_384_15: const #16s : i
        let s_384_15: i128 = 16;
        // C s_384_16: const #4s : i
        let s_384_16: i128 = 4;
        // D s_384_17: read-var u#30724:u32
        let s_384_17: u32 = fn_state.u_30724;
        // D s_384_18: cast zx s_384_17 -> bv
        let s_384_18: Bits = Bits::new(s_384_17 as u128, 32u16);
        // D s_384_19: bit-extract s_384_18 s_384_15 s_384_16
        let s_384_19: Bits = (Bits::new(
            ((s_384_18) >> (s_384_15)).value(),
            u16::try_from(s_384_16).unwrap(),
        ));
        // D s_384_20: cast reint s_384_19 -> u8
        let s_384_20: u8 = (s_384_19.value() as u8);
        // C s_384_21: const #12s : i
        let s_384_21: i128 = 12;
        // C s_384_22: const #4s : i
        let s_384_22: i128 = 4;
        // D s_384_23: read-var u#30724:u32
        let s_384_23: u32 = fn_state.u_30724;
        // D s_384_24: cast zx s_384_23 -> bv
        let s_384_24: Bits = Bits::new(s_384_23 as u128, 32u16);
        // D s_384_25: bit-extract s_384_24 s_384_21 s_384_22
        let s_384_25: Bits = (Bits::new(
            ((s_384_24) >> (s_384_21)).value(),
            u16::try_from(s_384_22).unwrap(),
        ));
        // D s_384_26: cast reint s_384_25 -> u8
        let s_384_26: u8 = (s_384_25.value() as u8);
        // C s_384_27: const #7s : i
        let s_384_27: i128 = 7;
        // C s_384_28: const #1s : i
        let s_384_28: i128 = 1;
        // D s_384_29: read-var u#30724:u32
        let s_384_29: u32 = fn_state.u_30724;
        // D s_384_30: cast zx s_384_29 -> bv
        let s_384_30: Bits = Bits::new(s_384_29 as u128, 32u16);
        // D s_384_31: bit-extract s_384_30 s_384_27 s_384_28
        let s_384_31: Bits = (Bits::new(
            ((s_384_30) >> (s_384_27)).value(),
            u16::try_from(s_384_28).unwrap(),
        ));
        // D s_384_32: cast reint s_384_31 -> u8
        let s_384_32: bool = ((s_384_31.value()) != 0);
        // C s_384_33: const #6s : i
        let s_384_33: i128 = 6;
        // C s_384_34: const #1s : i
        let s_384_34: i128 = 1;
        // D s_384_35: read-var u#30724:u32
        let s_384_35: u32 = fn_state.u_30724;
        // D s_384_36: cast zx s_384_35 -> bv
        let s_384_36: Bits = Bits::new(s_384_35 as u128, 32u16);
        // D s_384_37: bit-extract s_384_36 s_384_33 s_384_34
        let s_384_37: Bits = (Bits::new(
            ((s_384_36) >> (s_384_33)).value(),
            u16::try_from(s_384_34).unwrap(),
        ));
        // D s_384_38: cast reint s_384_37 -> u8
        let s_384_38: bool = ((s_384_37.value()) != 0);
        // C s_384_39: const #5s : i
        let s_384_39: i128 = 5;
        // C s_384_40: const #1s : i
        let s_384_40: i128 = 1;
        // D s_384_41: read-var u#30724:u32
        let s_384_41: u32 = fn_state.u_30724;
        // D s_384_42: cast zx s_384_41 -> bv
        let s_384_42: Bits = Bits::new(s_384_41 as u128, 32u16);
        // D s_384_43: bit-extract s_384_42 s_384_39 s_384_40
        let s_384_43: Bits = (Bits::new(
            ((s_384_42) >> (s_384_39)).value(),
            u16::try_from(s_384_40).unwrap(),
        ));
        // D s_384_44: cast reint s_384_43 -> u8
        let s_384_44: bool = ((s_384_43.value()) != 0);
        // C s_384_45: const #0s : i
        let s_384_45: i128 = 0;
        // C s_384_46: const #4s : i
        let s_384_46: i128 = 4;
        // D s_384_47: read-var u#30724:u32
        let s_384_47: u32 = fn_state.u_30724;
        // D s_384_48: cast zx s_384_47 -> bv
        let s_384_48: Bits = Bits::new(s_384_47 as u128, 32u16);
        // D s_384_49: bit-extract s_384_48 s_384_45 s_384_46
        let s_384_49: Bits = (Bits::new(
            ((s_384_48) >> (s_384_45)).value(),
            u16::try_from(s_384_46).unwrap(),
        ));
        // D s_384_50: cast reint s_384_49 -> u8
        let s_384_50: u8 = (s_384_49.value() as u8);
        // D s_384_51: call decode_aarch32_instrs_VBIF_A1enc_A_txt(s_384_8, s_384_14, s_384_20, s_384_26, s_384_32, s_384_38, s_384_44, s_384_50)
        let s_384_51: () = decode_aarch32_instrs_VBIF_A1enc_A_txt(
            state,
            tracer,
            s_384_8,
            s_384_14,
            s_384_20,
            s_384_26,
            s_384_32,
            s_384_38,
            s_384_44,
            s_384_50,
        );
        // N s_384_52: return
        return;
    }
    fn block_385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_385_0: read-var merge#var.1:struct
        let s_385_0: u32 = fn_state.merge_var._1;
        // D s_385_1: write-var u#30734 <= s_385_0
        fn_state.u_30734 = s_385_0;
        // C s_385_2: const #23s : i
        let s_385_2: i128 = 23;
        // D s_385_3: read-var u#30734:u32
        let s_385_3: u32 = fn_state.u_30734;
        // D s_385_4: cast zx s_385_3 -> bv
        let s_385_4: Bits = Bits::new(s_385_3 as u128, 32u16);
        // C s_385_5: const #1s : i64
        let s_385_5: i64 = 1;
        // C s_385_6: cast zx s_385_5 -> i
        let s_385_6: i128 = (i128::try_from(s_385_5).unwrap());
        // C s_385_7: const #8s : i
        let s_385_7: i128 = 8;
        // C s_385_8: add s_385_7 s_385_6
        let s_385_8: i128 = (s_385_7 + s_385_6);
        // D s_385_9: bit-extract s_385_4 s_385_2 s_385_8
        let s_385_9: Bits = (Bits::new(
            ((s_385_4) >> (s_385_2)).value(),
            u16::try_from(s_385_8).unwrap(),
        ));
        // D s_385_10: cast reint s_385_9 -> u9
        let s_385_10: u16 = (s_385_9.value() as u16);
        // D s_385_11: cast zx s_385_10 -> bv
        let s_385_11: Bits = Bits::new(s_385_10 as u128, 9u16);
        // C s_385_12: const #487u : u9
        let s_385_12: u16 = 487;
        // C s_385_13: cast zx s_385_12 -> bv
        let s_385_13: Bits = Bits::new(s_385_12 as u128, 9u16);
        // D s_385_14: cmp-eq s_385_11 s_385_13
        let s_385_14: bool = ((s_385_11) == (s_385_13));
        // N s_385_15: branch s_385_14 b3032 b386
        if s_385_14 {
            return block_3032(state, tracer, fn_state);
        } else {
            return block_386(state, tracer, fn_state);
        };
    }
    fn block_386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_386_0: const #0u : u8
        let s_386_0: bool = false;
        // D s_386_1: write-var gs#398368 <= s_386_0
        fn_state.gs_398368 = s_386_0;
        // N s_386_2: jump b387
        return block_387(state, tracer, fn_state);
    }
    fn block_387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_387_0: read-var gs#398368:u8
        let s_387_0: bool = fn_state.gs_398368;
        // N s_387_1: branch s_387_0 b3031 b388
        if s_387_0 {
            return block_3031(state, tracer, fn_state);
        } else {
            return block_388(state, tracer, fn_state);
        };
    }
    fn block_388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_388_0: const #0u : u8
        let s_388_0: bool = false;
        // D s_388_1: write-var gs#398370 <= s_388_0
        fn_state.gs_398370 = s_388_0;
        // N s_388_2: jump b389
        return block_389(state, tracer, fn_state);
    }
    fn block_389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_389_0: read-var gs#398370:u8
        let s_389_0: bool = fn_state.gs_398370;
        // D s_389_1: not s_389_0
        let s_389_1: bool = !s_389_0;
        // N s_389_2: branch s_389_1 b391 b390
        if s_389_1 {
            return block_391(state, tracer, fn_state);
        } else {
            return block_390(state, tracer, fn_state);
        };
    }
    fn block_390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_390_0: const #3386s : i
        let s_390_0: i128 = 3386;
        // C s_390_1: const #14696u : u32
        let s_390_1: u32 = 14696;
        // N s_390_2: write-reg s_390_1 <= s_390_0
        let s_390_2: () = {
            state.write_register::<i128>(s_390_1 as isize, s_390_0);
            tracer.write_register(s_390_1 as isize, s_390_0);
        };
        // C s_390_3: const #22s : i
        let s_390_3: i128 = 22;
        // C s_390_4: const #1s : i
        let s_390_4: i128 = 1;
        // D s_390_5: read-var u#30734:u32
        let s_390_5: u32 = fn_state.u_30734;
        // D s_390_6: cast zx s_390_5 -> bv
        let s_390_6: Bits = Bits::new(s_390_5 as u128, 32u16);
        // D s_390_7: bit-extract s_390_6 s_390_3 s_390_4
        let s_390_7: Bits = (Bits::new(
            ((s_390_6) >> (s_390_3)).value(),
            u16::try_from(s_390_4).unwrap(),
        ));
        // D s_390_8: cast reint s_390_7 -> u8
        let s_390_8: bool = ((s_390_7.value()) != 0);
        // C s_390_9: const #18s : i
        let s_390_9: i128 = 18;
        // C s_390_10: const #2s : i
        let s_390_10: i128 = 2;
        // D s_390_11: read-var u#30734:u32
        let s_390_11: u32 = fn_state.u_30734;
        // D s_390_12: cast zx s_390_11 -> bv
        let s_390_12: Bits = Bits::new(s_390_11 as u128, 32u16);
        // D s_390_13: bit-extract s_390_12 s_390_9 s_390_10
        let s_390_13: Bits = (Bits::new(
            ((s_390_12) >> (s_390_9)).value(),
            u16::try_from(s_390_10).unwrap(),
        ));
        // D s_390_14: cast reint s_390_13 -> u8
        let s_390_14: u8 = (s_390_13.value() as u8);
        // C s_390_15: const #12s : i
        let s_390_15: i128 = 12;
        // C s_390_16: const #4s : i
        let s_390_16: i128 = 4;
        // D s_390_17: read-var u#30734:u32
        let s_390_17: u32 = fn_state.u_30734;
        // D s_390_18: cast zx s_390_17 -> bv
        let s_390_18: Bits = Bits::new(s_390_17 as u128, 32u16);
        // D s_390_19: bit-extract s_390_18 s_390_15 s_390_16
        let s_390_19: Bits = (Bits::new(
            ((s_390_18) >> (s_390_15)).value(),
            u16::try_from(s_390_16).unwrap(),
        ));
        // D s_390_20: cast reint s_390_19 -> u8
        let s_390_20: u8 = (s_390_19.value() as u8);
        // C s_390_21: const #10s : i
        let s_390_21: i128 = 10;
        // C s_390_22: const #1s : i
        let s_390_22: i128 = 1;
        // D s_390_23: read-var u#30734:u32
        let s_390_23: u32 = fn_state.u_30734;
        // D s_390_24: cast zx s_390_23 -> bv
        let s_390_24: Bits = Bits::new(s_390_23 as u128, 32u16);
        // D s_390_25: bit-extract s_390_24 s_390_21 s_390_22
        let s_390_25: Bits = (Bits::new(
            ((s_390_24) >> (s_390_21)).value(),
            u16::try_from(s_390_22).unwrap(),
        ));
        // D s_390_26: cast reint s_390_25 -> u8
        let s_390_26: bool = ((s_390_25.value()) != 0);
        // C s_390_27: const #6s : i
        let s_390_27: i128 = 6;
        // C s_390_28: const #1s : i
        let s_390_28: i128 = 1;
        // D s_390_29: read-var u#30734:u32
        let s_390_29: u32 = fn_state.u_30734;
        // D s_390_30: cast zx s_390_29 -> bv
        let s_390_30: Bits = Bits::new(s_390_29 as u128, 32u16);
        // D s_390_31: bit-extract s_390_30 s_390_27 s_390_28
        let s_390_31: Bits = (Bits::new(
            ((s_390_30) >> (s_390_27)).value(),
            u16::try_from(s_390_28).unwrap(),
        ));
        // D s_390_32: cast reint s_390_31 -> u8
        let s_390_32: bool = ((s_390_31.value()) != 0);
        // C s_390_33: const #5s : i
        let s_390_33: i128 = 5;
        // C s_390_34: const #1s : i
        let s_390_34: i128 = 1;
        // D s_390_35: read-var u#30734:u32
        let s_390_35: u32 = fn_state.u_30734;
        // D s_390_36: cast zx s_390_35 -> bv
        let s_390_36: Bits = Bits::new(s_390_35 as u128, 32u16);
        // D s_390_37: bit-extract s_390_36 s_390_33 s_390_34
        let s_390_37: Bits = (Bits::new(
            ((s_390_36) >> (s_390_33)).value(),
            u16::try_from(s_390_34).unwrap(),
        ));
        // D s_390_38: cast reint s_390_37 -> u8
        let s_390_38: bool = ((s_390_37.value()) != 0);
        // C s_390_39: const #0s : i
        let s_390_39: i128 = 0;
        // C s_390_40: const #4s : i
        let s_390_40: i128 = 4;
        // D s_390_41: read-var u#30734:u32
        let s_390_41: u32 = fn_state.u_30734;
        // D s_390_42: cast zx s_390_41 -> bv
        let s_390_42: Bits = Bits::new(s_390_41 as u128, 32u16);
        // D s_390_43: bit-extract s_390_42 s_390_39 s_390_40
        let s_390_43: Bits = (Bits::new(
            ((s_390_42) >> (s_390_39)).value(),
            u16::try_from(s_390_40).unwrap(),
        ));
        // D s_390_44: cast reint s_390_43 -> u8
        let s_390_44: u8 = (s_390_43.value() as u8);
        // D s_390_45: call decode_aarch32_instrs_VCEQ_i_A1enc_A_txt(s_390_8, s_390_14, s_390_20, s_390_26, s_390_32, s_390_38, s_390_44)
        let s_390_45: () = decode_aarch32_instrs_VCEQ_i_A1enc_A_txt(
            state,
            tracer,
            s_390_8,
            s_390_14,
            s_390_20,
            s_390_26,
            s_390_32,
            s_390_38,
            s_390_44,
        );
        // N s_390_46: return
        return;
    }
    fn block_391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_391_0: read-var merge#var.1:struct
        let s_391_0: u32 = fn_state.merge_var._1;
        // D s_391_1: write-var u#30743 <= s_391_0
        fn_state.u_30743 = s_391_0;
        // C s_391_2: const #23s : i
        let s_391_2: i128 = 23;
        // D s_391_3: read-var u#30743:u32
        let s_391_3: u32 = fn_state.u_30743;
        // D s_391_4: cast zx s_391_3 -> bv
        let s_391_4: Bits = Bits::new(s_391_3 as u128, 32u16);
        // C s_391_5: const #1s : i64
        let s_391_5: i64 = 1;
        // C s_391_6: cast zx s_391_5 -> i
        let s_391_6: i128 = (i128::try_from(s_391_5).unwrap());
        // C s_391_7: const #8s : i
        let s_391_7: i128 = 8;
        // C s_391_8: add s_391_7 s_391_6
        let s_391_8: i128 = (s_391_7 + s_391_6);
        // D s_391_9: bit-extract s_391_4 s_391_2 s_391_8
        let s_391_9: Bits = (Bits::new(
            ((s_391_4) >> (s_391_2)).value(),
            u16::try_from(s_391_8).unwrap(),
        ));
        // D s_391_10: cast reint s_391_9 -> u9
        let s_391_10: u16 = (s_391_9.value() as u16);
        // D s_391_11: cast zx s_391_10 -> bv
        let s_391_11: Bits = Bits::new(s_391_10 as u128, 9u16);
        // C s_391_12: const #486u : u9
        let s_391_12: u16 = 486;
        // C s_391_13: cast zx s_391_12 -> bv
        let s_391_13: Bits = Bits::new(s_391_12 as u128, 9u16);
        // D s_391_14: cmp-eq s_391_11 s_391_13
        let s_391_14: bool = ((s_391_11) == (s_391_13));
        // N s_391_15: branch s_391_14 b3027 b392
        if s_391_14 {
            return block_3027(state, tracer, fn_state);
        } else {
            return block_392(state, tracer, fn_state);
        };
    }
    fn block_392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_392_0: const #0u : u8
        let s_392_0: bool = false;
        // D s_392_1: write-var gs#398395 <= s_392_0
        fn_state.gs_398395 = s_392_0;
        // N s_392_2: jump b393
        return block_393(state, tracer, fn_state);
    }
    fn block_393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_393_0: read-var gs#398395:u8
        let s_393_0: bool = fn_state.gs_398395;
        // N s_393_1: branch s_393_0 b3026 b394
        if s_393_0 {
            return block_3026(state, tracer, fn_state);
        } else {
            return block_394(state, tracer, fn_state);
        };
    }
    fn block_394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_394_0: const #0u : u8
        let s_394_0: bool = false;
        // D s_394_1: write-var gs#398397 <= s_394_0
        fn_state.gs_398397 = s_394_0;
        // N s_394_2: jump b395
        return block_395(state, tracer, fn_state);
    }
    fn block_395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_395_0: read-var gs#398397:u8
        let s_395_0: bool = fn_state.gs_398397;
        // D s_395_1: not s_395_0
        let s_395_1: bool = !s_395_0;
        // N s_395_2: branch s_395_1 b397 b396
        if s_395_1 {
            return block_397(state, tracer, fn_state);
        } else {
            return block_396(state, tracer, fn_state);
        };
    }
    fn block_396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_396_0: const #3388s : i
        let s_396_0: i128 = 3388;
        // C s_396_1: const #14696u : u32
        let s_396_1: u32 = 14696;
        // N s_396_2: write-reg s_396_1 <= s_396_0
        let s_396_2: () = {
            state.write_register::<i128>(s_396_1 as isize, s_396_0);
            tracer.write_register(s_396_1 as isize, s_396_0);
        };
        // C s_396_3: const #22s : i
        let s_396_3: i128 = 22;
        // C s_396_4: const #1s : i
        let s_396_4: i128 = 1;
        // D s_396_5: read-var u#30743:u32
        let s_396_5: u32 = fn_state.u_30743;
        // D s_396_6: cast zx s_396_5 -> bv
        let s_396_6: Bits = Bits::new(s_396_5 as u128, 32u16);
        // D s_396_7: bit-extract s_396_6 s_396_3 s_396_4
        let s_396_7: Bits = (Bits::new(
            ((s_396_6) >> (s_396_3)).value(),
            u16::try_from(s_396_4).unwrap(),
        ));
        // D s_396_8: cast reint s_396_7 -> u8
        let s_396_8: bool = ((s_396_7.value()) != 0);
        // C s_396_9: const #20s : i
        let s_396_9: i128 = 20;
        // C s_396_10: const #2s : i
        let s_396_10: i128 = 2;
        // D s_396_11: read-var u#30743:u32
        let s_396_11: u32 = fn_state.u_30743;
        // D s_396_12: cast zx s_396_11 -> bv
        let s_396_12: Bits = Bits::new(s_396_11 as u128, 32u16);
        // D s_396_13: bit-extract s_396_12 s_396_9 s_396_10
        let s_396_13: Bits = (Bits::new(
            ((s_396_12) >> (s_396_9)).value(),
            u16::try_from(s_396_10).unwrap(),
        ));
        // D s_396_14: cast reint s_396_13 -> u8
        let s_396_14: u8 = (s_396_13.value() as u8);
        // C s_396_15: const #16s : i
        let s_396_15: i128 = 16;
        // C s_396_16: const #4s : i
        let s_396_16: i128 = 4;
        // D s_396_17: read-var u#30743:u32
        let s_396_17: u32 = fn_state.u_30743;
        // D s_396_18: cast zx s_396_17 -> bv
        let s_396_18: Bits = Bits::new(s_396_17 as u128, 32u16);
        // D s_396_19: bit-extract s_396_18 s_396_15 s_396_16
        let s_396_19: Bits = (Bits::new(
            ((s_396_18) >> (s_396_15)).value(),
            u16::try_from(s_396_16).unwrap(),
        ));
        // D s_396_20: cast reint s_396_19 -> u8
        let s_396_20: u8 = (s_396_19.value() as u8);
        // C s_396_21: const #12s : i
        let s_396_21: i128 = 12;
        // C s_396_22: const #4s : i
        let s_396_22: i128 = 4;
        // D s_396_23: read-var u#30743:u32
        let s_396_23: u32 = fn_state.u_30743;
        // D s_396_24: cast zx s_396_23 -> bv
        let s_396_24: Bits = Bits::new(s_396_23 as u128, 32u16);
        // D s_396_25: bit-extract s_396_24 s_396_21 s_396_22
        let s_396_25: Bits = (Bits::new(
            ((s_396_24) >> (s_396_21)).value(),
            u16::try_from(s_396_22).unwrap(),
        ));
        // D s_396_26: cast reint s_396_25 -> u8
        let s_396_26: u8 = (s_396_25.value() as u8);
        // C s_396_27: const #7s : i
        let s_396_27: i128 = 7;
        // C s_396_28: const #1s : i
        let s_396_28: i128 = 1;
        // D s_396_29: read-var u#30743:u32
        let s_396_29: u32 = fn_state.u_30743;
        // D s_396_30: cast zx s_396_29 -> bv
        let s_396_30: Bits = Bits::new(s_396_29 as u128, 32u16);
        // D s_396_31: bit-extract s_396_30 s_396_27 s_396_28
        let s_396_31: Bits = (Bits::new(
            ((s_396_30) >> (s_396_27)).value(),
            u16::try_from(s_396_28).unwrap(),
        ));
        // D s_396_32: cast reint s_396_31 -> u8
        let s_396_32: bool = ((s_396_31.value()) != 0);
        // C s_396_33: const #6s : i
        let s_396_33: i128 = 6;
        // C s_396_34: const #1s : i
        let s_396_34: i128 = 1;
        // D s_396_35: read-var u#30743:u32
        let s_396_35: u32 = fn_state.u_30743;
        // D s_396_36: cast zx s_396_35 -> bv
        let s_396_36: Bits = Bits::new(s_396_35 as u128, 32u16);
        // D s_396_37: bit-extract s_396_36 s_396_33 s_396_34
        let s_396_37: Bits = (Bits::new(
            ((s_396_36) >> (s_396_33)).value(),
            u16::try_from(s_396_34).unwrap(),
        ));
        // D s_396_38: cast reint s_396_37 -> u8
        let s_396_38: bool = ((s_396_37.value()) != 0);
        // C s_396_39: const #5s : i
        let s_396_39: i128 = 5;
        // C s_396_40: const #1s : i
        let s_396_40: i128 = 1;
        // D s_396_41: read-var u#30743:u32
        let s_396_41: u32 = fn_state.u_30743;
        // D s_396_42: cast zx s_396_41 -> bv
        let s_396_42: Bits = Bits::new(s_396_41 as u128, 32u16);
        // D s_396_43: bit-extract s_396_42 s_396_39 s_396_40
        let s_396_43: Bits = (Bits::new(
            ((s_396_42) >> (s_396_39)).value(),
            u16::try_from(s_396_40).unwrap(),
        ));
        // D s_396_44: cast reint s_396_43 -> u8
        let s_396_44: bool = ((s_396_43.value()) != 0);
        // C s_396_45: const #0s : i
        let s_396_45: i128 = 0;
        // C s_396_46: const #4s : i
        let s_396_46: i128 = 4;
        // D s_396_47: read-var u#30743:u32
        let s_396_47: u32 = fn_state.u_30743;
        // D s_396_48: cast zx s_396_47 -> bv
        let s_396_48: Bits = Bits::new(s_396_47 as u128, 32u16);
        // D s_396_49: bit-extract s_396_48 s_396_45 s_396_46
        let s_396_49: Bits = (Bits::new(
            ((s_396_48) >> (s_396_45)).value(),
            u16::try_from(s_396_46).unwrap(),
        ));
        // D s_396_50: cast reint s_396_49 -> u8
        let s_396_50: u8 = (s_396_49.value() as u8);
        // D s_396_51: call decode_aarch32_instrs_VCEQ_r_A1enc_A_txt(s_396_8, s_396_14, s_396_20, s_396_26, s_396_32, s_396_38, s_396_44, s_396_50)
        let s_396_51: () = decode_aarch32_instrs_VCEQ_r_A1enc_A_txt(
            state,
            tracer,
            s_396_8,
            s_396_14,
            s_396_20,
            s_396_26,
            s_396_32,
            s_396_38,
            s_396_44,
            s_396_50,
        );
        // N s_396_52: return
        return;
    }
    fn block_397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_397_0: read-var merge#var.1:struct
        let s_397_0: u32 = fn_state.merge_var._1;
        // D s_397_1: write-var u#30753 <= s_397_0
        fn_state.u_30753 = s_397_0;
        // C s_397_2: const #23s : i
        let s_397_2: i128 = 23;
        // D s_397_3: read-var u#30753:u32
        let s_397_3: u32 = fn_state.u_30753;
        // D s_397_4: cast zx s_397_3 -> bv
        let s_397_4: Bits = Bits::new(s_397_3 as u128, 32u16);
        // C s_397_5: const #1s : i64
        let s_397_5: i64 = 1;
        // C s_397_6: cast zx s_397_5 -> i
        let s_397_6: i128 = (i128::try_from(s_397_5).unwrap());
        // C s_397_7: const #8s : i
        let s_397_7: i128 = 8;
        // C s_397_8: add s_397_7 s_397_6
        let s_397_8: i128 = (s_397_7 + s_397_6);
        // D s_397_9: bit-extract s_397_4 s_397_2 s_397_8
        let s_397_9: Bits = (Bits::new(
            ((s_397_4) >> (s_397_2)).value(),
            u16::try_from(s_397_8).unwrap(),
        ));
        // D s_397_10: cast reint s_397_9 -> u9
        let s_397_10: u16 = (s_397_9.value() as u16);
        // D s_397_11: cast zx s_397_10 -> bv
        let s_397_11: Bits = Bits::new(s_397_10 as u128, 9u16);
        // C s_397_12: const #484u : u9
        let s_397_12: u16 = 484;
        // C s_397_13: cast zx s_397_12 -> bv
        let s_397_13: Bits = Bits::new(s_397_12 as u128, 9u16);
        // D s_397_14: cmp-eq s_397_11 s_397_13
        let s_397_14: bool = ((s_397_11) == (s_397_13));
        // N s_397_15: branch s_397_14 b3019 b398
        if s_397_14 {
            return block_3019(state, tracer, fn_state);
        } else {
            return block_398(state, tracer, fn_state);
        };
    }
    fn block_398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_398_0: const #0u : u8
        let s_398_0: bool = false;
        // D s_398_1: write-var gs#398427 <= s_398_0
        fn_state.gs_398427 = s_398_0;
        // N s_398_2: jump b399
        return block_399(state, tracer, fn_state);
    }
    fn block_399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_399_0: read-var gs#398427:u8
        let s_399_0: bool = fn_state.gs_398427;
        // N s_399_1: branch s_399_0 b3018 b400
        if s_399_0 {
            return block_3018(state, tracer, fn_state);
        } else {
            return block_400(state, tracer, fn_state);
        };
    }
    fn block_400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_400_0: const #0u : u8
        let s_400_0: bool = false;
        // D s_400_1: write-var gs#398429 <= s_400_0
        fn_state.gs_398429 = s_400_0;
        // N s_400_2: jump b401
        return block_401(state, tracer, fn_state);
    }
    fn block_401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_401_0: read-var gs#398429:u8
        let s_401_0: bool = fn_state.gs_398429;
        // D s_401_1: not s_401_0
        let s_401_1: bool = !s_401_0;
        // N s_401_2: branch s_401_1 b403 b402
        if s_401_1 {
            return block_403(state, tracer, fn_state);
        } else {
            return block_402(state, tracer, fn_state);
        };
    }
    fn block_402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_402_0: const #3389s : i
        let s_402_0: i128 = 3389;
        // C s_402_1: const #14696u : u32
        let s_402_1: u32 = 14696;
        // N s_402_2: write-reg s_402_1 <= s_402_0
        let s_402_2: () = {
            state.write_register::<i128>(s_402_1 as isize, s_402_0);
            tracer.write_register(s_402_1 as isize, s_402_0);
        };
        // C s_402_3: const #22s : i
        let s_402_3: i128 = 22;
        // C s_402_4: const #1s : i
        let s_402_4: i128 = 1;
        // D s_402_5: read-var u#30753:u32
        let s_402_5: u32 = fn_state.u_30753;
        // D s_402_6: cast zx s_402_5 -> bv
        let s_402_6: Bits = Bits::new(s_402_5 as u128, 32u16);
        // D s_402_7: bit-extract s_402_6 s_402_3 s_402_4
        let s_402_7: Bits = (Bits::new(
            ((s_402_6) >> (s_402_3)).value(),
            u16::try_from(s_402_4).unwrap(),
        ));
        // D s_402_8: cast reint s_402_7 -> u8
        let s_402_8: bool = ((s_402_7.value()) != 0);
        // C s_402_9: const #20s : i
        let s_402_9: i128 = 20;
        // C s_402_10: const #1s : i
        let s_402_10: i128 = 1;
        // D s_402_11: read-var u#30753:u32
        let s_402_11: u32 = fn_state.u_30753;
        // D s_402_12: cast zx s_402_11 -> bv
        let s_402_12: Bits = Bits::new(s_402_11 as u128, 32u16);
        // D s_402_13: bit-extract s_402_12 s_402_9 s_402_10
        let s_402_13: Bits = (Bits::new(
            ((s_402_12) >> (s_402_9)).value(),
            u16::try_from(s_402_10).unwrap(),
        ));
        // D s_402_14: cast reint s_402_13 -> u8
        let s_402_14: bool = ((s_402_13.value()) != 0);
        // C s_402_15: const #16s : i
        let s_402_15: i128 = 16;
        // C s_402_16: const #4s : i
        let s_402_16: i128 = 4;
        // D s_402_17: read-var u#30753:u32
        let s_402_17: u32 = fn_state.u_30753;
        // D s_402_18: cast zx s_402_17 -> bv
        let s_402_18: Bits = Bits::new(s_402_17 as u128, 32u16);
        // D s_402_19: bit-extract s_402_18 s_402_15 s_402_16
        let s_402_19: Bits = (Bits::new(
            ((s_402_18) >> (s_402_15)).value(),
            u16::try_from(s_402_16).unwrap(),
        ));
        // D s_402_20: cast reint s_402_19 -> u8
        let s_402_20: u8 = (s_402_19.value() as u8);
        // C s_402_21: const #12s : i
        let s_402_21: i128 = 12;
        // C s_402_22: const #4s : i
        let s_402_22: i128 = 4;
        // D s_402_23: read-var u#30753:u32
        let s_402_23: u32 = fn_state.u_30753;
        // D s_402_24: cast zx s_402_23 -> bv
        let s_402_24: Bits = Bits::new(s_402_23 as u128, 32u16);
        // D s_402_25: bit-extract s_402_24 s_402_21 s_402_22
        let s_402_25: Bits = (Bits::new(
            ((s_402_24) >> (s_402_21)).value(),
            u16::try_from(s_402_22).unwrap(),
        ));
        // D s_402_26: cast reint s_402_25 -> u8
        let s_402_26: u8 = (s_402_25.value() as u8);
        // C s_402_27: const #7s : i
        let s_402_27: i128 = 7;
        // C s_402_28: const #1s : i
        let s_402_28: i128 = 1;
        // D s_402_29: read-var u#30753:u32
        let s_402_29: u32 = fn_state.u_30753;
        // D s_402_30: cast zx s_402_29 -> bv
        let s_402_30: Bits = Bits::new(s_402_29 as u128, 32u16);
        // D s_402_31: bit-extract s_402_30 s_402_27 s_402_28
        let s_402_31: Bits = (Bits::new(
            ((s_402_30) >> (s_402_27)).value(),
            u16::try_from(s_402_28).unwrap(),
        ));
        // D s_402_32: cast reint s_402_31 -> u8
        let s_402_32: bool = ((s_402_31.value()) != 0);
        // C s_402_33: const #6s : i
        let s_402_33: i128 = 6;
        // C s_402_34: const #1s : i
        let s_402_34: i128 = 1;
        // D s_402_35: read-var u#30753:u32
        let s_402_35: u32 = fn_state.u_30753;
        // D s_402_36: cast zx s_402_35 -> bv
        let s_402_36: Bits = Bits::new(s_402_35 as u128, 32u16);
        // D s_402_37: bit-extract s_402_36 s_402_33 s_402_34
        let s_402_37: Bits = (Bits::new(
            ((s_402_36) >> (s_402_33)).value(),
            u16::try_from(s_402_34).unwrap(),
        ));
        // D s_402_38: cast reint s_402_37 -> u8
        let s_402_38: bool = ((s_402_37.value()) != 0);
        // C s_402_39: const #5s : i
        let s_402_39: i128 = 5;
        // C s_402_40: const #1s : i
        let s_402_40: i128 = 1;
        // D s_402_41: read-var u#30753:u32
        let s_402_41: u32 = fn_state.u_30753;
        // D s_402_42: cast zx s_402_41 -> bv
        let s_402_42: Bits = Bits::new(s_402_41 as u128, 32u16);
        // D s_402_43: bit-extract s_402_42 s_402_39 s_402_40
        let s_402_43: Bits = (Bits::new(
            ((s_402_42) >> (s_402_39)).value(),
            u16::try_from(s_402_40).unwrap(),
        ));
        // D s_402_44: cast reint s_402_43 -> u8
        let s_402_44: bool = ((s_402_43.value()) != 0);
        // C s_402_45: const #0s : i
        let s_402_45: i128 = 0;
        // C s_402_46: const #4s : i
        let s_402_46: i128 = 4;
        // D s_402_47: read-var u#30753:u32
        let s_402_47: u32 = fn_state.u_30753;
        // D s_402_48: cast zx s_402_47 -> bv
        let s_402_48: Bits = Bits::new(s_402_47 as u128, 32u16);
        // D s_402_49: bit-extract s_402_48 s_402_45 s_402_46
        let s_402_49: Bits = (Bits::new(
            ((s_402_48) >> (s_402_45)).value(),
            u16::try_from(s_402_46).unwrap(),
        ));
        // D s_402_50: cast reint s_402_49 -> u8
        let s_402_50: u8 = (s_402_49.value() as u8);
        // D s_402_51: call decode_aarch32_instrs_VCEQ_r_A2enc_A_txt(s_402_8, s_402_14, s_402_20, s_402_26, s_402_32, s_402_38, s_402_44, s_402_50)
        let s_402_51: () = decode_aarch32_instrs_VCEQ_r_A2enc_A_txt(
            state,
            tracer,
            s_402_8,
            s_402_14,
            s_402_20,
            s_402_26,
            s_402_32,
            s_402_38,
            s_402_44,
            s_402_50,
        );
        // N s_402_52: return
        return;
    }
    fn block_403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_403_0: read-var merge#var.1:struct
        let s_403_0: u32 = fn_state.merge_var._1;
        // D s_403_1: write-var u#30763 <= s_403_0
        fn_state.u_30763 = s_403_0;
        // C s_403_2: const #23s : i
        let s_403_2: i128 = 23;
        // D s_403_3: read-var u#30763:u32
        let s_403_3: u32 = fn_state.u_30763;
        // D s_403_4: cast zx s_403_3 -> bv
        let s_403_4: Bits = Bits::new(s_403_3 as u128, 32u16);
        // C s_403_5: const #1s : i64
        let s_403_5: i64 = 1;
        // C s_403_6: cast zx s_403_5 -> i
        let s_403_6: i128 = (i128::try_from(s_403_5).unwrap());
        // C s_403_7: const #8s : i
        let s_403_7: i128 = 8;
        // C s_403_8: add s_403_7 s_403_6
        let s_403_8: i128 = (s_403_7 + s_403_6);
        // D s_403_9: bit-extract s_403_4 s_403_2 s_403_8
        let s_403_9: Bits = (Bits::new(
            ((s_403_4) >> (s_403_2)).value(),
            u16::try_from(s_403_8).unwrap(),
        ));
        // D s_403_10: cast reint s_403_9 -> u9
        let s_403_10: u16 = (s_403_9.value() as u16);
        // D s_403_11: cast zx s_403_10 -> bv
        let s_403_11: Bits = Bits::new(s_403_10 as u128, 9u16);
        // C s_403_12: const #487u : u9
        let s_403_12: u16 = 487;
        // C s_403_13: cast zx s_403_12 -> bv
        let s_403_13: Bits = Bits::new(s_403_12 as u128, 9u16);
        // D s_403_14: cmp-eq s_403_11 s_403_13
        let s_403_14: bool = ((s_403_11) == (s_403_13));
        // N s_403_15: branch s_403_14 b3005 b404
        if s_403_14 {
            return block_3005(state, tracer, fn_state);
        } else {
            return block_404(state, tracer, fn_state);
        };
    }
    fn block_404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_404_0: const #0u : u8
        let s_404_0: bool = false;
        // D s_404_1: write-var gs#398465 <= s_404_0
        fn_state.gs_398465 = s_404_0;
        // N s_404_2: jump b405
        return block_405(state, tracer, fn_state);
    }
    fn block_405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_405_0: read-var gs#398465:u8
        let s_405_0: bool = fn_state.gs_398465;
        // N s_405_1: branch s_405_0 b3004 b406
        if s_405_0 {
            return block_3004(state, tracer, fn_state);
        } else {
            return block_406(state, tracer, fn_state);
        };
    }
    fn block_406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_406_0: const #0u : u8
        let s_406_0: bool = false;
        // D s_406_1: write-var gs#398467 <= s_406_0
        fn_state.gs_398467 = s_406_0;
        // N s_406_2: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_407_0: read-var gs#398467:u8
        let s_407_0: bool = fn_state.gs_398467;
        // D s_407_1: not s_407_0
        let s_407_1: bool = !s_407_0;
        // N s_407_2: branch s_407_1 b409 b408
        if s_407_1 {
            return block_409(state, tracer, fn_state);
        } else {
            return block_408(state, tracer, fn_state);
        };
    }
    fn block_408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_408_0: const #3392s : i
        let s_408_0: i128 = 3392;
        // C s_408_1: const #14696u : u32
        let s_408_1: u32 = 14696;
        // N s_408_2: write-reg s_408_1 <= s_408_0
        let s_408_2: () = {
            state.write_register::<i128>(s_408_1 as isize, s_408_0);
            tracer.write_register(s_408_1 as isize, s_408_0);
        };
        // C s_408_3: const #22s : i
        let s_408_3: i128 = 22;
        // C s_408_4: const #1s : i
        let s_408_4: i128 = 1;
        // D s_408_5: read-var u#30763:u32
        let s_408_5: u32 = fn_state.u_30763;
        // D s_408_6: cast zx s_408_5 -> bv
        let s_408_6: Bits = Bits::new(s_408_5 as u128, 32u16);
        // D s_408_7: bit-extract s_408_6 s_408_3 s_408_4
        let s_408_7: Bits = (Bits::new(
            ((s_408_6) >> (s_408_3)).value(),
            u16::try_from(s_408_4).unwrap(),
        ));
        // D s_408_8: cast reint s_408_7 -> u8
        let s_408_8: bool = ((s_408_7.value()) != 0);
        // C s_408_9: const #18s : i
        let s_408_9: i128 = 18;
        // C s_408_10: const #2s : i
        let s_408_10: i128 = 2;
        // D s_408_11: read-var u#30763:u32
        let s_408_11: u32 = fn_state.u_30763;
        // D s_408_12: cast zx s_408_11 -> bv
        let s_408_12: Bits = Bits::new(s_408_11 as u128, 32u16);
        // D s_408_13: bit-extract s_408_12 s_408_9 s_408_10
        let s_408_13: Bits = (Bits::new(
            ((s_408_12) >> (s_408_9)).value(),
            u16::try_from(s_408_10).unwrap(),
        ));
        // D s_408_14: cast reint s_408_13 -> u8
        let s_408_14: u8 = (s_408_13.value() as u8);
        // C s_408_15: const #12s : i
        let s_408_15: i128 = 12;
        // C s_408_16: const #4s : i
        let s_408_16: i128 = 4;
        // D s_408_17: read-var u#30763:u32
        let s_408_17: u32 = fn_state.u_30763;
        // D s_408_18: cast zx s_408_17 -> bv
        let s_408_18: Bits = Bits::new(s_408_17 as u128, 32u16);
        // D s_408_19: bit-extract s_408_18 s_408_15 s_408_16
        let s_408_19: Bits = (Bits::new(
            ((s_408_18) >> (s_408_15)).value(),
            u16::try_from(s_408_16).unwrap(),
        ));
        // D s_408_20: cast reint s_408_19 -> u8
        let s_408_20: u8 = (s_408_19.value() as u8);
        // C s_408_21: const #10s : i
        let s_408_21: i128 = 10;
        // C s_408_22: const #1s : i
        let s_408_22: i128 = 1;
        // D s_408_23: read-var u#30763:u32
        let s_408_23: u32 = fn_state.u_30763;
        // D s_408_24: cast zx s_408_23 -> bv
        let s_408_24: Bits = Bits::new(s_408_23 as u128, 32u16);
        // D s_408_25: bit-extract s_408_24 s_408_21 s_408_22
        let s_408_25: Bits = (Bits::new(
            ((s_408_24) >> (s_408_21)).value(),
            u16::try_from(s_408_22).unwrap(),
        ));
        // D s_408_26: cast reint s_408_25 -> u8
        let s_408_26: bool = ((s_408_25.value()) != 0);
        // C s_408_27: const #6s : i
        let s_408_27: i128 = 6;
        // C s_408_28: const #1s : i
        let s_408_28: i128 = 1;
        // D s_408_29: read-var u#30763:u32
        let s_408_29: u32 = fn_state.u_30763;
        // D s_408_30: cast zx s_408_29 -> bv
        let s_408_30: Bits = Bits::new(s_408_29 as u128, 32u16);
        // D s_408_31: bit-extract s_408_30 s_408_27 s_408_28
        let s_408_31: Bits = (Bits::new(
            ((s_408_30) >> (s_408_27)).value(),
            u16::try_from(s_408_28).unwrap(),
        ));
        // D s_408_32: cast reint s_408_31 -> u8
        let s_408_32: bool = ((s_408_31.value()) != 0);
        // C s_408_33: const #5s : i
        let s_408_33: i128 = 5;
        // C s_408_34: const #1s : i
        let s_408_34: i128 = 1;
        // D s_408_35: read-var u#30763:u32
        let s_408_35: u32 = fn_state.u_30763;
        // D s_408_36: cast zx s_408_35 -> bv
        let s_408_36: Bits = Bits::new(s_408_35 as u128, 32u16);
        // D s_408_37: bit-extract s_408_36 s_408_33 s_408_34
        let s_408_37: Bits = (Bits::new(
            ((s_408_36) >> (s_408_33)).value(),
            u16::try_from(s_408_34).unwrap(),
        ));
        // D s_408_38: cast reint s_408_37 -> u8
        let s_408_38: bool = ((s_408_37.value()) != 0);
        // C s_408_39: const #0s : i
        let s_408_39: i128 = 0;
        // C s_408_40: const #4s : i
        let s_408_40: i128 = 4;
        // D s_408_41: read-var u#30763:u32
        let s_408_41: u32 = fn_state.u_30763;
        // D s_408_42: cast zx s_408_41 -> bv
        let s_408_42: Bits = Bits::new(s_408_41 as u128, 32u16);
        // D s_408_43: bit-extract s_408_42 s_408_39 s_408_40
        let s_408_43: Bits = (Bits::new(
            ((s_408_42) >> (s_408_39)).value(),
            u16::try_from(s_408_40).unwrap(),
        ));
        // D s_408_44: cast reint s_408_43 -> u8
        let s_408_44: u8 = (s_408_43.value() as u8);
        // D s_408_45: call decode_aarch32_instrs_VCGE_i_A1enc_A_txt(s_408_8, s_408_14, s_408_20, s_408_26, s_408_32, s_408_38, s_408_44)
        let s_408_45: () = decode_aarch32_instrs_VCGE_i_A1enc_A_txt(
            state,
            tracer,
            s_408_8,
            s_408_14,
            s_408_20,
            s_408_26,
            s_408_32,
            s_408_38,
            s_408_44,
        );
        // N s_408_46: return
        return;
    }
    fn block_409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_409_0: read-var merge#var.1:struct
        let s_409_0: u32 = fn_state.merge_var._1;
        // D s_409_1: write-var u#30772 <= s_409_0
        fn_state.u_30772 = s_409_0;
        // C s_409_2: const #25s : i
        let s_409_2: i128 = 25;
        // D s_409_3: read-var u#30772:u32
        let s_409_3: u32 = fn_state.u_30772;
        // D s_409_4: cast zx s_409_3 -> bv
        let s_409_4: Bits = Bits::new(s_409_3 as u128, 32u16);
        // C s_409_5: const #1s : i64
        let s_409_5: i64 = 1;
        // C s_409_6: cast zx s_409_5 -> i
        let s_409_6: i128 = (i128::try_from(s_409_5).unwrap());
        // C s_409_7: const #6s : i
        let s_409_7: i128 = 6;
        // C s_409_8: add s_409_7 s_409_6
        let s_409_8: i128 = (s_409_7 + s_409_6);
        // D s_409_9: bit-extract s_409_4 s_409_2 s_409_8
        let s_409_9: Bits = (Bits::new(
            ((s_409_4) >> (s_409_2)).value(),
            u16::try_from(s_409_8).unwrap(),
        ));
        // D s_409_10: cast reint s_409_9 -> u8
        let s_409_10: u8 = (s_409_9.value() as u8);
        // D s_409_11: cast zx s_409_10 -> bv
        let s_409_11: Bits = Bits::new(s_409_10 as u128, 7u16);
        // C s_409_12: const #121u : u8
        let s_409_12: u8 = 121;
        // C s_409_13: cast zx s_409_12 -> bv
        let s_409_13: Bits = Bits::new(s_409_12 as u128, 7u16);
        // D s_409_14: cmp-eq s_409_11 s_409_13
        let s_409_14: bool = ((s_409_11) == (s_409_13));
        // N s_409_15: branch s_409_14 b2997 b410
        if s_409_14 {
            return block_2997(state, tracer, fn_state);
        } else {
            return block_410(state, tracer, fn_state);
        };
    }
    fn block_410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_410_0: const #0u : u8
        let s_410_0: bool = false;
        // D s_410_1: write-var gs#398495 <= s_410_0
        fn_state.gs_398495 = s_410_0;
        // N s_410_2: jump b411
        return block_411(state, tracer, fn_state);
    }
    fn block_411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_411_0: read-var gs#398495:u8
        let s_411_0: bool = fn_state.gs_398495;
        // N s_411_1: branch s_411_0 b2996 b412
        if s_411_0 {
            return block_2996(state, tracer, fn_state);
        } else {
            return block_412(state, tracer, fn_state);
        };
    }
    fn block_412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_412_0: const #0u : u8
        let s_412_0: bool = false;
        // D s_412_1: write-var gs#398497 <= s_412_0
        fn_state.gs_398497 = s_412_0;
        // N s_412_2: jump b413
        return block_413(state, tracer, fn_state);
    }
    fn block_413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_413_0: read-var gs#398497:u8
        let s_413_0: bool = fn_state.gs_398497;
        // D s_413_1: not s_413_0
        let s_413_1: bool = !s_413_0;
        // N s_413_2: branch s_413_1 b415 b414
        if s_413_1 {
            return block_415(state, tracer, fn_state);
        } else {
            return block_414(state, tracer, fn_state);
        };
    }
    fn block_414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_414_0: const #3394s : i
        let s_414_0: i128 = 3394;
        // C s_414_1: const #14696u : u32
        let s_414_1: u32 = 14696;
        // N s_414_2: write-reg s_414_1 <= s_414_0
        let s_414_2: () = {
            state.write_register::<i128>(s_414_1 as isize, s_414_0);
            tracer.write_register(s_414_1 as isize, s_414_0);
        };
        // C s_414_3: const #24s : i
        let s_414_3: i128 = 24;
        // C s_414_4: const #1s : i
        let s_414_4: i128 = 1;
        // D s_414_5: read-var u#30772:u32
        let s_414_5: u32 = fn_state.u_30772;
        // D s_414_6: cast zx s_414_5 -> bv
        let s_414_6: Bits = Bits::new(s_414_5 as u128, 32u16);
        // D s_414_7: bit-extract s_414_6 s_414_3 s_414_4
        let s_414_7: Bits = (Bits::new(
            ((s_414_6) >> (s_414_3)).value(),
            u16::try_from(s_414_4).unwrap(),
        ));
        // D s_414_8: cast reint s_414_7 -> u8
        let s_414_8: bool = ((s_414_7.value()) != 0);
        // C s_414_9: const #22s : i
        let s_414_9: i128 = 22;
        // C s_414_10: const #1s : i
        let s_414_10: i128 = 1;
        // D s_414_11: read-var u#30772:u32
        let s_414_11: u32 = fn_state.u_30772;
        // D s_414_12: cast zx s_414_11 -> bv
        let s_414_12: Bits = Bits::new(s_414_11 as u128, 32u16);
        // D s_414_13: bit-extract s_414_12 s_414_9 s_414_10
        let s_414_13: Bits = (Bits::new(
            ((s_414_12) >> (s_414_9)).value(),
            u16::try_from(s_414_10).unwrap(),
        ));
        // D s_414_14: cast reint s_414_13 -> u8
        let s_414_14: bool = ((s_414_13.value()) != 0);
        // C s_414_15: const #20s : i
        let s_414_15: i128 = 20;
        // C s_414_16: const #2s : i
        let s_414_16: i128 = 2;
        // D s_414_17: read-var u#30772:u32
        let s_414_17: u32 = fn_state.u_30772;
        // D s_414_18: cast zx s_414_17 -> bv
        let s_414_18: Bits = Bits::new(s_414_17 as u128, 32u16);
        // D s_414_19: bit-extract s_414_18 s_414_15 s_414_16
        let s_414_19: Bits = (Bits::new(
            ((s_414_18) >> (s_414_15)).value(),
            u16::try_from(s_414_16).unwrap(),
        ));
        // D s_414_20: cast reint s_414_19 -> u8
        let s_414_20: u8 = (s_414_19.value() as u8);
        // C s_414_21: const #16s : i
        let s_414_21: i128 = 16;
        // C s_414_22: const #4s : i
        let s_414_22: i128 = 4;
        // D s_414_23: read-var u#30772:u32
        let s_414_23: u32 = fn_state.u_30772;
        // D s_414_24: cast zx s_414_23 -> bv
        let s_414_24: Bits = Bits::new(s_414_23 as u128, 32u16);
        // D s_414_25: bit-extract s_414_24 s_414_21 s_414_22
        let s_414_25: Bits = (Bits::new(
            ((s_414_24) >> (s_414_21)).value(),
            u16::try_from(s_414_22).unwrap(),
        ));
        // D s_414_26: cast reint s_414_25 -> u8
        let s_414_26: u8 = (s_414_25.value() as u8);
        // C s_414_27: const #12s : i
        let s_414_27: i128 = 12;
        // C s_414_28: const #4s : i
        let s_414_28: i128 = 4;
        // D s_414_29: read-var u#30772:u32
        let s_414_29: u32 = fn_state.u_30772;
        // D s_414_30: cast zx s_414_29 -> bv
        let s_414_30: Bits = Bits::new(s_414_29 as u128, 32u16);
        // D s_414_31: bit-extract s_414_30 s_414_27 s_414_28
        let s_414_31: Bits = (Bits::new(
            ((s_414_30) >> (s_414_27)).value(),
            u16::try_from(s_414_28).unwrap(),
        ));
        // D s_414_32: cast reint s_414_31 -> u8
        let s_414_32: u8 = (s_414_31.value() as u8);
        // C s_414_33: const #7s : i
        let s_414_33: i128 = 7;
        // C s_414_34: const #1s : i
        let s_414_34: i128 = 1;
        // D s_414_35: read-var u#30772:u32
        let s_414_35: u32 = fn_state.u_30772;
        // D s_414_36: cast zx s_414_35 -> bv
        let s_414_36: Bits = Bits::new(s_414_35 as u128, 32u16);
        // D s_414_37: bit-extract s_414_36 s_414_33 s_414_34
        let s_414_37: Bits = (Bits::new(
            ((s_414_36) >> (s_414_33)).value(),
            u16::try_from(s_414_34).unwrap(),
        ));
        // D s_414_38: cast reint s_414_37 -> u8
        let s_414_38: bool = ((s_414_37.value()) != 0);
        // C s_414_39: const #6s : i
        let s_414_39: i128 = 6;
        // C s_414_40: const #1s : i
        let s_414_40: i128 = 1;
        // D s_414_41: read-var u#30772:u32
        let s_414_41: u32 = fn_state.u_30772;
        // D s_414_42: cast zx s_414_41 -> bv
        let s_414_42: Bits = Bits::new(s_414_41 as u128, 32u16);
        // D s_414_43: bit-extract s_414_42 s_414_39 s_414_40
        let s_414_43: Bits = (Bits::new(
            ((s_414_42) >> (s_414_39)).value(),
            u16::try_from(s_414_40).unwrap(),
        ));
        // D s_414_44: cast reint s_414_43 -> u8
        let s_414_44: bool = ((s_414_43.value()) != 0);
        // C s_414_45: const #5s : i
        let s_414_45: i128 = 5;
        // C s_414_46: const #1s : i
        let s_414_46: i128 = 1;
        // D s_414_47: read-var u#30772:u32
        let s_414_47: u32 = fn_state.u_30772;
        // D s_414_48: cast zx s_414_47 -> bv
        let s_414_48: Bits = Bits::new(s_414_47 as u128, 32u16);
        // D s_414_49: bit-extract s_414_48 s_414_45 s_414_46
        let s_414_49: Bits = (Bits::new(
            ((s_414_48) >> (s_414_45)).value(),
            u16::try_from(s_414_46).unwrap(),
        ));
        // D s_414_50: cast reint s_414_49 -> u8
        let s_414_50: bool = ((s_414_49.value()) != 0);
        // C s_414_51: const #0s : i
        let s_414_51: i128 = 0;
        // C s_414_52: const #4s : i
        let s_414_52: i128 = 4;
        // D s_414_53: read-var u#30772:u32
        let s_414_53: u32 = fn_state.u_30772;
        // D s_414_54: cast zx s_414_53 -> bv
        let s_414_54: Bits = Bits::new(s_414_53 as u128, 32u16);
        // D s_414_55: bit-extract s_414_54 s_414_51 s_414_52
        let s_414_55: Bits = (Bits::new(
            ((s_414_54) >> (s_414_51)).value(),
            u16::try_from(s_414_52).unwrap(),
        ));
        // D s_414_56: cast reint s_414_55 -> u8
        let s_414_56: u8 = (s_414_55.value() as u8);
        // D s_414_57: call decode_aarch32_instrs_VCGE_r_A1enc_A_txt(s_414_8, s_414_14, s_414_20, s_414_26, s_414_32, s_414_38, s_414_44, s_414_50, s_414_56)
        let s_414_57: () = decode_aarch32_instrs_VCGE_r_A1enc_A_txt(
            state,
            tracer,
            s_414_8,
            s_414_14,
            s_414_20,
            s_414_26,
            s_414_32,
            s_414_38,
            s_414_44,
            s_414_50,
            s_414_56,
        );
        // N s_414_58: return
        return;
    }
    fn block_415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_415_0: read-var merge#var.1:struct
        let s_415_0: u32 = fn_state.merge_var._1;
        // D s_415_1: write-var u#30783 <= s_415_0
        fn_state.u_30783 = s_415_0;
        // C s_415_2: const #23s : i
        let s_415_2: i128 = 23;
        // D s_415_3: read-var u#30783:u32
        let s_415_3: u32 = fn_state.u_30783;
        // D s_415_4: cast zx s_415_3 -> bv
        let s_415_4: Bits = Bits::new(s_415_3 as u128, 32u16);
        // C s_415_5: const #1s : i64
        let s_415_5: i64 = 1;
        // C s_415_6: cast zx s_415_5 -> i
        let s_415_6: i128 = (i128::try_from(s_415_5).unwrap());
        // C s_415_7: const #8s : i
        let s_415_7: i128 = 8;
        // C s_415_8: add s_415_7 s_415_6
        let s_415_8: i128 = (s_415_7 + s_415_6);
        // D s_415_9: bit-extract s_415_4 s_415_2 s_415_8
        let s_415_9: Bits = (Bits::new(
            ((s_415_4) >> (s_415_2)).value(),
            u16::try_from(s_415_8).unwrap(),
        ));
        // D s_415_10: cast reint s_415_9 -> u9
        let s_415_10: u16 = (s_415_9.value() as u16);
        // D s_415_11: cast zx s_415_10 -> bv
        let s_415_11: Bits = Bits::new(s_415_10 as u128, 9u16);
        // C s_415_12: const #486u : u9
        let s_415_12: u16 = 486;
        // C s_415_13: cast zx s_415_12 -> bv
        let s_415_13: Bits = Bits::new(s_415_12 as u128, 9u16);
        // D s_415_14: cmp-eq s_415_11 s_415_13
        let s_415_14: bool = ((s_415_11) == (s_415_13));
        // N s_415_15: branch s_415_14 b2989 b416
        if s_415_14 {
            return block_2989(state, tracer, fn_state);
        } else {
            return block_416(state, tracer, fn_state);
        };
    }
    fn block_416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_416_0: const #0u : u8
        let s_416_0: bool = false;
        // D s_416_1: write-var gs#398529 <= s_416_0
        fn_state.gs_398529 = s_416_0;
        // N s_416_2: jump b417
        return block_417(state, tracer, fn_state);
    }
    fn block_417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_417_0: read-var gs#398529:u8
        let s_417_0: bool = fn_state.gs_398529;
        // N s_417_1: branch s_417_0 b2988 b418
        if s_417_0 {
            return block_2988(state, tracer, fn_state);
        } else {
            return block_418(state, tracer, fn_state);
        };
    }
    fn block_418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_418_0: const #0u : u8
        let s_418_0: bool = false;
        // D s_418_1: write-var gs#398531 <= s_418_0
        fn_state.gs_398531 = s_418_0;
        // N s_418_2: jump b419
        return block_419(state, tracer, fn_state);
    }
    fn block_419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_419_0: read-var gs#398531:u8
        let s_419_0: bool = fn_state.gs_398531;
        // D s_419_1: not s_419_0
        let s_419_1: bool = !s_419_0;
        // N s_419_2: branch s_419_1 b421 b420
        if s_419_1 {
            return block_421(state, tracer, fn_state);
        } else {
            return block_420(state, tracer, fn_state);
        };
    }
    fn block_420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_420_0: const #3395s : i
        let s_420_0: i128 = 3395;
        // C s_420_1: const #14696u : u32
        let s_420_1: u32 = 14696;
        // N s_420_2: write-reg s_420_1 <= s_420_0
        let s_420_2: () = {
            state.write_register::<i128>(s_420_1 as isize, s_420_0);
            tracer.write_register(s_420_1 as isize, s_420_0);
        };
        // C s_420_3: const #22s : i
        let s_420_3: i128 = 22;
        // C s_420_4: const #1s : i
        let s_420_4: i128 = 1;
        // D s_420_5: read-var u#30783:u32
        let s_420_5: u32 = fn_state.u_30783;
        // D s_420_6: cast zx s_420_5 -> bv
        let s_420_6: Bits = Bits::new(s_420_5 as u128, 32u16);
        // D s_420_7: bit-extract s_420_6 s_420_3 s_420_4
        let s_420_7: Bits = (Bits::new(
            ((s_420_6) >> (s_420_3)).value(),
            u16::try_from(s_420_4).unwrap(),
        ));
        // D s_420_8: cast reint s_420_7 -> u8
        let s_420_8: bool = ((s_420_7.value()) != 0);
        // C s_420_9: const #20s : i
        let s_420_9: i128 = 20;
        // C s_420_10: const #1s : i
        let s_420_10: i128 = 1;
        // D s_420_11: read-var u#30783:u32
        let s_420_11: u32 = fn_state.u_30783;
        // D s_420_12: cast zx s_420_11 -> bv
        let s_420_12: Bits = Bits::new(s_420_11 as u128, 32u16);
        // D s_420_13: bit-extract s_420_12 s_420_9 s_420_10
        let s_420_13: Bits = (Bits::new(
            ((s_420_12) >> (s_420_9)).value(),
            u16::try_from(s_420_10).unwrap(),
        ));
        // D s_420_14: cast reint s_420_13 -> u8
        let s_420_14: bool = ((s_420_13.value()) != 0);
        // C s_420_15: const #16s : i
        let s_420_15: i128 = 16;
        // C s_420_16: const #4s : i
        let s_420_16: i128 = 4;
        // D s_420_17: read-var u#30783:u32
        let s_420_17: u32 = fn_state.u_30783;
        // D s_420_18: cast zx s_420_17 -> bv
        let s_420_18: Bits = Bits::new(s_420_17 as u128, 32u16);
        // D s_420_19: bit-extract s_420_18 s_420_15 s_420_16
        let s_420_19: Bits = (Bits::new(
            ((s_420_18) >> (s_420_15)).value(),
            u16::try_from(s_420_16).unwrap(),
        ));
        // D s_420_20: cast reint s_420_19 -> u8
        let s_420_20: u8 = (s_420_19.value() as u8);
        // C s_420_21: const #12s : i
        let s_420_21: i128 = 12;
        // C s_420_22: const #4s : i
        let s_420_22: i128 = 4;
        // D s_420_23: read-var u#30783:u32
        let s_420_23: u32 = fn_state.u_30783;
        // D s_420_24: cast zx s_420_23 -> bv
        let s_420_24: Bits = Bits::new(s_420_23 as u128, 32u16);
        // D s_420_25: bit-extract s_420_24 s_420_21 s_420_22
        let s_420_25: Bits = (Bits::new(
            ((s_420_24) >> (s_420_21)).value(),
            u16::try_from(s_420_22).unwrap(),
        ));
        // D s_420_26: cast reint s_420_25 -> u8
        let s_420_26: u8 = (s_420_25.value() as u8);
        // C s_420_27: const #7s : i
        let s_420_27: i128 = 7;
        // C s_420_28: const #1s : i
        let s_420_28: i128 = 1;
        // D s_420_29: read-var u#30783:u32
        let s_420_29: u32 = fn_state.u_30783;
        // D s_420_30: cast zx s_420_29 -> bv
        let s_420_30: Bits = Bits::new(s_420_29 as u128, 32u16);
        // D s_420_31: bit-extract s_420_30 s_420_27 s_420_28
        let s_420_31: Bits = (Bits::new(
            ((s_420_30) >> (s_420_27)).value(),
            u16::try_from(s_420_28).unwrap(),
        ));
        // D s_420_32: cast reint s_420_31 -> u8
        let s_420_32: bool = ((s_420_31.value()) != 0);
        // C s_420_33: const #6s : i
        let s_420_33: i128 = 6;
        // C s_420_34: const #1s : i
        let s_420_34: i128 = 1;
        // D s_420_35: read-var u#30783:u32
        let s_420_35: u32 = fn_state.u_30783;
        // D s_420_36: cast zx s_420_35 -> bv
        let s_420_36: Bits = Bits::new(s_420_35 as u128, 32u16);
        // D s_420_37: bit-extract s_420_36 s_420_33 s_420_34
        let s_420_37: Bits = (Bits::new(
            ((s_420_36) >> (s_420_33)).value(),
            u16::try_from(s_420_34).unwrap(),
        ));
        // D s_420_38: cast reint s_420_37 -> u8
        let s_420_38: bool = ((s_420_37.value()) != 0);
        // C s_420_39: const #5s : i
        let s_420_39: i128 = 5;
        // C s_420_40: const #1s : i
        let s_420_40: i128 = 1;
        // D s_420_41: read-var u#30783:u32
        let s_420_41: u32 = fn_state.u_30783;
        // D s_420_42: cast zx s_420_41 -> bv
        let s_420_42: Bits = Bits::new(s_420_41 as u128, 32u16);
        // D s_420_43: bit-extract s_420_42 s_420_39 s_420_40
        let s_420_43: Bits = (Bits::new(
            ((s_420_42) >> (s_420_39)).value(),
            u16::try_from(s_420_40).unwrap(),
        ));
        // D s_420_44: cast reint s_420_43 -> u8
        let s_420_44: bool = ((s_420_43.value()) != 0);
        // C s_420_45: const #0s : i
        let s_420_45: i128 = 0;
        // C s_420_46: const #4s : i
        let s_420_46: i128 = 4;
        // D s_420_47: read-var u#30783:u32
        let s_420_47: u32 = fn_state.u_30783;
        // D s_420_48: cast zx s_420_47 -> bv
        let s_420_48: Bits = Bits::new(s_420_47 as u128, 32u16);
        // D s_420_49: bit-extract s_420_48 s_420_45 s_420_46
        let s_420_49: Bits = (Bits::new(
            ((s_420_48) >> (s_420_45)).value(),
            u16::try_from(s_420_46).unwrap(),
        ));
        // D s_420_50: cast reint s_420_49 -> u8
        let s_420_50: u8 = (s_420_49.value() as u8);
        // D s_420_51: call decode_aarch32_instrs_VCGE_r_A2enc_A_txt(s_420_8, s_420_14, s_420_20, s_420_26, s_420_32, s_420_38, s_420_44, s_420_50)
        let s_420_51: () = decode_aarch32_instrs_VCGE_r_A2enc_A_txt(
            state,
            tracer,
            s_420_8,
            s_420_14,
            s_420_20,
            s_420_26,
            s_420_32,
            s_420_38,
            s_420_44,
            s_420_50,
        );
        // N s_420_52: return
        return;
    }
    fn block_421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_421_0: read-var merge#var.1:struct
        let s_421_0: u32 = fn_state.merge_var._1;
        // D s_421_1: write-var u#30793 <= s_421_0
        fn_state.u_30793 = s_421_0;
        // C s_421_2: const #23s : i
        let s_421_2: i128 = 23;
        // D s_421_3: read-var u#30793:u32
        let s_421_3: u32 = fn_state.u_30793;
        // D s_421_4: cast zx s_421_3 -> bv
        let s_421_4: Bits = Bits::new(s_421_3 as u128, 32u16);
        // C s_421_5: const #1s : i64
        let s_421_5: i64 = 1;
        // C s_421_6: cast zx s_421_5 -> i
        let s_421_6: i128 = (i128::try_from(s_421_5).unwrap());
        // C s_421_7: const #8s : i
        let s_421_7: i128 = 8;
        // C s_421_8: add s_421_7 s_421_6
        let s_421_8: i128 = (s_421_7 + s_421_6);
        // D s_421_9: bit-extract s_421_4 s_421_2 s_421_8
        let s_421_9: Bits = (Bits::new(
            ((s_421_4) >> (s_421_2)).value(),
            u16::try_from(s_421_8).unwrap(),
        ));
        // D s_421_10: cast reint s_421_9 -> u9
        let s_421_10: u16 = (s_421_9.value() as u16);
        // D s_421_11: cast zx s_421_10 -> bv
        let s_421_11: Bits = Bits::new(s_421_10 as u128, 9u16);
        // C s_421_12: const #487u : u9
        let s_421_12: u16 = 487;
        // C s_421_13: cast zx s_421_12 -> bv
        let s_421_13: Bits = Bits::new(s_421_12 as u128, 9u16);
        // D s_421_14: cmp-eq s_421_11 s_421_13
        let s_421_14: bool = ((s_421_11) == (s_421_13));
        // N s_421_15: branch s_421_14 b2975 b422
        if s_421_14 {
            return block_2975(state, tracer, fn_state);
        } else {
            return block_422(state, tracer, fn_state);
        };
    }
    fn block_422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_422_0: const #0u : u8
        let s_422_0: bool = false;
        // D s_422_1: write-var gs#398567 <= s_422_0
        fn_state.gs_398567 = s_422_0;
        // N s_422_2: jump b423
        return block_423(state, tracer, fn_state);
    }
    fn block_423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_423_0: read-var gs#398567:u8
        let s_423_0: bool = fn_state.gs_398567;
        // N s_423_1: branch s_423_0 b2974 b424
        if s_423_0 {
            return block_2974(state, tracer, fn_state);
        } else {
            return block_424(state, tracer, fn_state);
        };
    }
    fn block_424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_424_0: const #0u : u8
        let s_424_0: bool = false;
        // D s_424_1: write-var gs#398569 <= s_424_0
        fn_state.gs_398569 = s_424_0;
        // N s_424_2: jump b425
        return block_425(state, tracer, fn_state);
    }
    fn block_425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_425_0: read-var gs#398569:u8
        let s_425_0: bool = fn_state.gs_398569;
        // D s_425_1: not s_425_0
        let s_425_1: bool = !s_425_0;
        // N s_425_2: branch s_425_1 b427 b426
        if s_425_1 {
            return block_427(state, tracer, fn_state);
        } else {
            return block_426(state, tracer, fn_state);
        };
    }
    fn block_426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_426_0: const #3398s : i
        let s_426_0: i128 = 3398;
        // C s_426_1: const #14696u : u32
        let s_426_1: u32 = 14696;
        // N s_426_2: write-reg s_426_1 <= s_426_0
        let s_426_2: () = {
            state.write_register::<i128>(s_426_1 as isize, s_426_0);
            tracer.write_register(s_426_1 as isize, s_426_0);
        };
        // C s_426_3: const #22s : i
        let s_426_3: i128 = 22;
        // C s_426_4: const #1s : i
        let s_426_4: i128 = 1;
        // D s_426_5: read-var u#30793:u32
        let s_426_5: u32 = fn_state.u_30793;
        // D s_426_6: cast zx s_426_5 -> bv
        let s_426_6: Bits = Bits::new(s_426_5 as u128, 32u16);
        // D s_426_7: bit-extract s_426_6 s_426_3 s_426_4
        let s_426_7: Bits = (Bits::new(
            ((s_426_6) >> (s_426_3)).value(),
            u16::try_from(s_426_4).unwrap(),
        ));
        // D s_426_8: cast reint s_426_7 -> u8
        let s_426_8: bool = ((s_426_7.value()) != 0);
        // C s_426_9: const #18s : i
        let s_426_9: i128 = 18;
        // C s_426_10: const #2s : i
        let s_426_10: i128 = 2;
        // D s_426_11: read-var u#30793:u32
        let s_426_11: u32 = fn_state.u_30793;
        // D s_426_12: cast zx s_426_11 -> bv
        let s_426_12: Bits = Bits::new(s_426_11 as u128, 32u16);
        // D s_426_13: bit-extract s_426_12 s_426_9 s_426_10
        let s_426_13: Bits = (Bits::new(
            ((s_426_12) >> (s_426_9)).value(),
            u16::try_from(s_426_10).unwrap(),
        ));
        // D s_426_14: cast reint s_426_13 -> u8
        let s_426_14: u8 = (s_426_13.value() as u8);
        // C s_426_15: const #12s : i
        let s_426_15: i128 = 12;
        // C s_426_16: const #4s : i
        let s_426_16: i128 = 4;
        // D s_426_17: read-var u#30793:u32
        let s_426_17: u32 = fn_state.u_30793;
        // D s_426_18: cast zx s_426_17 -> bv
        let s_426_18: Bits = Bits::new(s_426_17 as u128, 32u16);
        // D s_426_19: bit-extract s_426_18 s_426_15 s_426_16
        let s_426_19: Bits = (Bits::new(
            ((s_426_18) >> (s_426_15)).value(),
            u16::try_from(s_426_16).unwrap(),
        ));
        // D s_426_20: cast reint s_426_19 -> u8
        let s_426_20: u8 = (s_426_19.value() as u8);
        // C s_426_21: const #10s : i
        let s_426_21: i128 = 10;
        // C s_426_22: const #1s : i
        let s_426_22: i128 = 1;
        // D s_426_23: read-var u#30793:u32
        let s_426_23: u32 = fn_state.u_30793;
        // D s_426_24: cast zx s_426_23 -> bv
        let s_426_24: Bits = Bits::new(s_426_23 as u128, 32u16);
        // D s_426_25: bit-extract s_426_24 s_426_21 s_426_22
        let s_426_25: Bits = (Bits::new(
            ((s_426_24) >> (s_426_21)).value(),
            u16::try_from(s_426_22).unwrap(),
        ));
        // D s_426_26: cast reint s_426_25 -> u8
        let s_426_26: bool = ((s_426_25.value()) != 0);
        // C s_426_27: const #6s : i
        let s_426_27: i128 = 6;
        // C s_426_28: const #1s : i
        let s_426_28: i128 = 1;
        // D s_426_29: read-var u#30793:u32
        let s_426_29: u32 = fn_state.u_30793;
        // D s_426_30: cast zx s_426_29 -> bv
        let s_426_30: Bits = Bits::new(s_426_29 as u128, 32u16);
        // D s_426_31: bit-extract s_426_30 s_426_27 s_426_28
        let s_426_31: Bits = (Bits::new(
            ((s_426_30) >> (s_426_27)).value(),
            u16::try_from(s_426_28).unwrap(),
        ));
        // D s_426_32: cast reint s_426_31 -> u8
        let s_426_32: bool = ((s_426_31.value()) != 0);
        // C s_426_33: const #5s : i
        let s_426_33: i128 = 5;
        // C s_426_34: const #1s : i
        let s_426_34: i128 = 1;
        // D s_426_35: read-var u#30793:u32
        let s_426_35: u32 = fn_state.u_30793;
        // D s_426_36: cast zx s_426_35 -> bv
        let s_426_36: Bits = Bits::new(s_426_35 as u128, 32u16);
        // D s_426_37: bit-extract s_426_36 s_426_33 s_426_34
        let s_426_37: Bits = (Bits::new(
            ((s_426_36) >> (s_426_33)).value(),
            u16::try_from(s_426_34).unwrap(),
        ));
        // D s_426_38: cast reint s_426_37 -> u8
        let s_426_38: bool = ((s_426_37.value()) != 0);
        // C s_426_39: const #0s : i
        let s_426_39: i128 = 0;
        // C s_426_40: const #4s : i
        let s_426_40: i128 = 4;
        // D s_426_41: read-var u#30793:u32
        let s_426_41: u32 = fn_state.u_30793;
        // D s_426_42: cast zx s_426_41 -> bv
        let s_426_42: Bits = Bits::new(s_426_41 as u128, 32u16);
        // D s_426_43: bit-extract s_426_42 s_426_39 s_426_40
        let s_426_43: Bits = (Bits::new(
            ((s_426_42) >> (s_426_39)).value(),
            u16::try_from(s_426_40).unwrap(),
        ));
        // D s_426_44: cast reint s_426_43 -> u8
        let s_426_44: u8 = (s_426_43.value() as u8);
        // D s_426_45: call decode_aarch32_instrs_VCGT_i_A1enc_A_txt(s_426_8, s_426_14, s_426_20, s_426_26, s_426_32, s_426_38, s_426_44)
        let s_426_45: () = decode_aarch32_instrs_VCGT_i_A1enc_A_txt(
            state,
            tracer,
            s_426_8,
            s_426_14,
            s_426_20,
            s_426_26,
            s_426_32,
            s_426_38,
            s_426_44,
        );
        // N s_426_46: return
        return;
    }
    fn block_427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_427_0: read-var merge#var.1:struct
        let s_427_0: u32 = fn_state.merge_var._1;
        // D s_427_1: write-var u#30802 <= s_427_0
        fn_state.u_30802 = s_427_0;
        // C s_427_2: const #25s : i
        let s_427_2: i128 = 25;
        // D s_427_3: read-var u#30802:u32
        let s_427_3: u32 = fn_state.u_30802;
        // D s_427_4: cast zx s_427_3 -> bv
        let s_427_4: Bits = Bits::new(s_427_3 as u128, 32u16);
        // C s_427_5: const #1s : i64
        let s_427_5: i64 = 1;
        // C s_427_6: cast zx s_427_5 -> i
        let s_427_6: i128 = (i128::try_from(s_427_5).unwrap());
        // C s_427_7: const #6s : i
        let s_427_7: i128 = 6;
        // C s_427_8: add s_427_7 s_427_6
        let s_427_8: i128 = (s_427_7 + s_427_6);
        // D s_427_9: bit-extract s_427_4 s_427_2 s_427_8
        let s_427_9: Bits = (Bits::new(
            ((s_427_4) >> (s_427_2)).value(),
            u16::try_from(s_427_8).unwrap(),
        ));
        // D s_427_10: cast reint s_427_9 -> u8
        let s_427_10: u8 = (s_427_9.value() as u8);
        // D s_427_11: cast zx s_427_10 -> bv
        let s_427_11: Bits = Bits::new(s_427_10 as u128, 7u16);
        // C s_427_12: const #121u : u8
        let s_427_12: u8 = 121;
        // C s_427_13: cast zx s_427_12 -> bv
        let s_427_13: Bits = Bits::new(s_427_12 as u128, 7u16);
        // D s_427_14: cmp-eq s_427_11 s_427_13
        let s_427_14: bool = ((s_427_11) == (s_427_13));
        // N s_427_15: branch s_427_14 b2967 b428
        if s_427_14 {
            return block_2967(state, tracer, fn_state);
        } else {
            return block_428(state, tracer, fn_state);
        };
    }
    fn block_428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_428_0: const #0u : u8
        let s_428_0: bool = false;
        // D s_428_1: write-var gs#398597 <= s_428_0
        fn_state.gs_398597 = s_428_0;
        // N s_428_2: jump b429
        return block_429(state, tracer, fn_state);
    }
    fn block_429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_429_0: read-var gs#398597:u8
        let s_429_0: bool = fn_state.gs_398597;
        // N s_429_1: branch s_429_0 b2966 b430
        if s_429_0 {
            return block_2966(state, tracer, fn_state);
        } else {
            return block_430(state, tracer, fn_state);
        };
    }
    fn block_430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_430_0: const #0u : u8
        let s_430_0: bool = false;
        // D s_430_1: write-var gs#398599 <= s_430_0
        fn_state.gs_398599 = s_430_0;
        // N s_430_2: jump b431
        return block_431(state, tracer, fn_state);
    }
    fn block_431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_431_0: read-var gs#398599:u8
        let s_431_0: bool = fn_state.gs_398599;
        // D s_431_1: not s_431_0
        let s_431_1: bool = !s_431_0;
        // N s_431_2: branch s_431_1 b433 b432
        if s_431_1 {
            return block_433(state, tracer, fn_state);
        } else {
            return block_432(state, tracer, fn_state);
        };
    }
    fn block_432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_432_0: const #3400s : i
        let s_432_0: i128 = 3400;
        // C s_432_1: const #14696u : u32
        let s_432_1: u32 = 14696;
        // N s_432_2: write-reg s_432_1 <= s_432_0
        let s_432_2: () = {
            state.write_register::<i128>(s_432_1 as isize, s_432_0);
            tracer.write_register(s_432_1 as isize, s_432_0);
        };
        // C s_432_3: const #24s : i
        let s_432_3: i128 = 24;
        // C s_432_4: const #1s : i
        let s_432_4: i128 = 1;
        // D s_432_5: read-var u#30802:u32
        let s_432_5: u32 = fn_state.u_30802;
        // D s_432_6: cast zx s_432_5 -> bv
        let s_432_6: Bits = Bits::new(s_432_5 as u128, 32u16);
        // D s_432_7: bit-extract s_432_6 s_432_3 s_432_4
        let s_432_7: Bits = (Bits::new(
            ((s_432_6) >> (s_432_3)).value(),
            u16::try_from(s_432_4).unwrap(),
        ));
        // D s_432_8: cast reint s_432_7 -> u8
        let s_432_8: bool = ((s_432_7.value()) != 0);
        // C s_432_9: const #22s : i
        let s_432_9: i128 = 22;
        // C s_432_10: const #1s : i
        let s_432_10: i128 = 1;
        // D s_432_11: read-var u#30802:u32
        let s_432_11: u32 = fn_state.u_30802;
        // D s_432_12: cast zx s_432_11 -> bv
        let s_432_12: Bits = Bits::new(s_432_11 as u128, 32u16);
        // D s_432_13: bit-extract s_432_12 s_432_9 s_432_10
        let s_432_13: Bits = (Bits::new(
            ((s_432_12) >> (s_432_9)).value(),
            u16::try_from(s_432_10).unwrap(),
        ));
        // D s_432_14: cast reint s_432_13 -> u8
        let s_432_14: bool = ((s_432_13.value()) != 0);
        // C s_432_15: const #20s : i
        let s_432_15: i128 = 20;
        // C s_432_16: const #2s : i
        let s_432_16: i128 = 2;
        // D s_432_17: read-var u#30802:u32
        let s_432_17: u32 = fn_state.u_30802;
        // D s_432_18: cast zx s_432_17 -> bv
        let s_432_18: Bits = Bits::new(s_432_17 as u128, 32u16);
        // D s_432_19: bit-extract s_432_18 s_432_15 s_432_16
        let s_432_19: Bits = (Bits::new(
            ((s_432_18) >> (s_432_15)).value(),
            u16::try_from(s_432_16).unwrap(),
        ));
        // D s_432_20: cast reint s_432_19 -> u8
        let s_432_20: u8 = (s_432_19.value() as u8);
        // C s_432_21: const #16s : i
        let s_432_21: i128 = 16;
        // C s_432_22: const #4s : i
        let s_432_22: i128 = 4;
        // D s_432_23: read-var u#30802:u32
        let s_432_23: u32 = fn_state.u_30802;
        // D s_432_24: cast zx s_432_23 -> bv
        let s_432_24: Bits = Bits::new(s_432_23 as u128, 32u16);
        // D s_432_25: bit-extract s_432_24 s_432_21 s_432_22
        let s_432_25: Bits = (Bits::new(
            ((s_432_24) >> (s_432_21)).value(),
            u16::try_from(s_432_22).unwrap(),
        ));
        // D s_432_26: cast reint s_432_25 -> u8
        let s_432_26: u8 = (s_432_25.value() as u8);
        // C s_432_27: const #12s : i
        let s_432_27: i128 = 12;
        // C s_432_28: const #4s : i
        let s_432_28: i128 = 4;
        // D s_432_29: read-var u#30802:u32
        let s_432_29: u32 = fn_state.u_30802;
        // D s_432_30: cast zx s_432_29 -> bv
        let s_432_30: Bits = Bits::new(s_432_29 as u128, 32u16);
        // D s_432_31: bit-extract s_432_30 s_432_27 s_432_28
        let s_432_31: Bits = (Bits::new(
            ((s_432_30) >> (s_432_27)).value(),
            u16::try_from(s_432_28).unwrap(),
        ));
        // D s_432_32: cast reint s_432_31 -> u8
        let s_432_32: u8 = (s_432_31.value() as u8);
        // C s_432_33: const #7s : i
        let s_432_33: i128 = 7;
        // C s_432_34: const #1s : i
        let s_432_34: i128 = 1;
        // D s_432_35: read-var u#30802:u32
        let s_432_35: u32 = fn_state.u_30802;
        // D s_432_36: cast zx s_432_35 -> bv
        let s_432_36: Bits = Bits::new(s_432_35 as u128, 32u16);
        // D s_432_37: bit-extract s_432_36 s_432_33 s_432_34
        let s_432_37: Bits = (Bits::new(
            ((s_432_36) >> (s_432_33)).value(),
            u16::try_from(s_432_34).unwrap(),
        ));
        // D s_432_38: cast reint s_432_37 -> u8
        let s_432_38: bool = ((s_432_37.value()) != 0);
        // C s_432_39: const #6s : i
        let s_432_39: i128 = 6;
        // C s_432_40: const #1s : i
        let s_432_40: i128 = 1;
        // D s_432_41: read-var u#30802:u32
        let s_432_41: u32 = fn_state.u_30802;
        // D s_432_42: cast zx s_432_41 -> bv
        let s_432_42: Bits = Bits::new(s_432_41 as u128, 32u16);
        // D s_432_43: bit-extract s_432_42 s_432_39 s_432_40
        let s_432_43: Bits = (Bits::new(
            ((s_432_42) >> (s_432_39)).value(),
            u16::try_from(s_432_40).unwrap(),
        ));
        // D s_432_44: cast reint s_432_43 -> u8
        let s_432_44: bool = ((s_432_43.value()) != 0);
        // C s_432_45: const #5s : i
        let s_432_45: i128 = 5;
        // C s_432_46: const #1s : i
        let s_432_46: i128 = 1;
        // D s_432_47: read-var u#30802:u32
        let s_432_47: u32 = fn_state.u_30802;
        // D s_432_48: cast zx s_432_47 -> bv
        let s_432_48: Bits = Bits::new(s_432_47 as u128, 32u16);
        // D s_432_49: bit-extract s_432_48 s_432_45 s_432_46
        let s_432_49: Bits = (Bits::new(
            ((s_432_48) >> (s_432_45)).value(),
            u16::try_from(s_432_46).unwrap(),
        ));
        // D s_432_50: cast reint s_432_49 -> u8
        let s_432_50: bool = ((s_432_49.value()) != 0);
        // C s_432_51: const #0s : i
        let s_432_51: i128 = 0;
        // C s_432_52: const #4s : i
        let s_432_52: i128 = 4;
        // D s_432_53: read-var u#30802:u32
        let s_432_53: u32 = fn_state.u_30802;
        // D s_432_54: cast zx s_432_53 -> bv
        let s_432_54: Bits = Bits::new(s_432_53 as u128, 32u16);
        // D s_432_55: bit-extract s_432_54 s_432_51 s_432_52
        let s_432_55: Bits = (Bits::new(
            ((s_432_54) >> (s_432_51)).value(),
            u16::try_from(s_432_52).unwrap(),
        ));
        // D s_432_56: cast reint s_432_55 -> u8
        let s_432_56: u8 = (s_432_55.value() as u8);
        // D s_432_57: call decode_aarch32_instrs_VCGT_r_A1enc_A_txt(s_432_8, s_432_14, s_432_20, s_432_26, s_432_32, s_432_38, s_432_44, s_432_50, s_432_56)
        let s_432_57: () = decode_aarch32_instrs_VCGT_r_A1enc_A_txt(
            state,
            tracer,
            s_432_8,
            s_432_14,
            s_432_20,
            s_432_26,
            s_432_32,
            s_432_38,
            s_432_44,
            s_432_50,
            s_432_56,
        );
        // N s_432_58: return
        return;
    }
    fn block_433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_433_0: read-var merge#var.1:struct
        let s_433_0: u32 = fn_state.merge_var._1;
        // D s_433_1: write-var u#30813 <= s_433_0
        fn_state.u_30813 = s_433_0;
        // C s_433_2: const #23s : i
        let s_433_2: i128 = 23;
        // D s_433_3: read-var u#30813:u32
        let s_433_3: u32 = fn_state.u_30813;
        // D s_433_4: cast zx s_433_3 -> bv
        let s_433_4: Bits = Bits::new(s_433_3 as u128, 32u16);
        // C s_433_5: const #1s : i64
        let s_433_5: i64 = 1;
        // C s_433_6: cast zx s_433_5 -> i
        let s_433_6: i128 = (i128::try_from(s_433_5).unwrap());
        // C s_433_7: const #8s : i
        let s_433_7: i128 = 8;
        // C s_433_8: add s_433_7 s_433_6
        let s_433_8: i128 = (s_433_7 + s_433_6);
        // D s_433_9: bit-extract s_433_4 s_433_2 s_433_8
        let s_433_9: Bits = (Bits::new(
            ((s_433_4) >> (s_433_2)).value(),
            u16::try_from(s_433_8).unwrap(),
        ));
        // D s_433_10: cast reint s_433_9 -> u9
        let s_433_10: u16 = (s_433_9.value() as u16);
        // D s_433_11: cast zx s_433_10 -> bv
        let s_433_11: Bits = Bits::new(s_433_10 as u128, 9u16);
        // C s_433_12: const #486u : u9
        let s_433_12: u16 = 486;
        // C s_433_13: cast zx s_433_12 -> bv
        let s_433_13: Bits = Bits::new(s_433_12 as u128, 9u16);
        // D s_433_14: cmp-eq s_433_11 s_433_13
        let s_433_14: bool = ((s_433_11) == (s_433_13));
        // N s_433_15: branch s_433_14 b2959 b434
        if s_433_14 {
            return block_2959(state, tracer, fn_state);
        } else {
            return block_434(state, tracer, fn_state);
        };
    }
    fn block_434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_434_0: const #0u : u8
        let s_434_0: bool = false;
        // D s_434_1: write-var gs#398631 <= s_434_0
        fn_state.gs_398631 = s_434_0;
        // N s_434_2: jump b435
        return block_435(state, tracer, fn_state);
    }
    fn block_435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_435_0: read-var gs#398631:u8
        let s_435_0: bool = fn_state.gs_398631;
        // N s_435_1: branch s_435_0 b2958 b436
        if s_435_0 {
            return block_2958(state, tracer, fn_state);
        } else {
            return block_436(state, tracer, fn_state);
        };
    }
    fn block_436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_436_0: const #0u : u8
        let s_436_0: bool = false;
        // D s_436_1: write-var gs#398633 <= s_436_0
        fn_state.gs_398633 = s_436_0;
        // N s_436_2: jump b437
        return block_437(state, tracer, fn_state);
    }
    fn block_437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_437_0: read-var gs#398633:u8
        let s_437_0: bool = fn_state.gs_398633;
        // D s_437_1: not s_437_0
        let s_437_1: bool = !s_437_0;
        // N s_437_2: branch s_437_1 b439 b438
        if s_437_1 {
            return block_439(state, tracer, fn_state);
        } else {
            return block_438(state, tracer, fn_state);
        };
    }
    fn block_438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_438_0: const #3401s : i
        let s_438_0: i128 = 3401;
        // C s_438_1: const #14696u : u32
        let s_438_1: u32 = 14696;
        // N s_438_2: write-reg s_438_1 <= s_438_0
        let s_438_2: () = {
            state.write_register::<i128>(s_438_1 as isize, s_438_0);
            tracer.write_register(s_438_1 as isize, s_438_0);
        };
        // C s_438_3: const #22s : i
        let s_438_3: i128 = 22;
        // C s_438_4: const #1s : i
        let s_438_4: i128 = 1;
        // D s_438_5: read-var u#30813:u32
        let s_438_5: u32 = fn_state.u_30813;
        // D s_438_6: cast zx s_438_5 -> bv
        let s_438_6: Bits = Bits::new(s_438_5 as u128, 32u16);
        // D s_438_7: bit-extract s_438_6 s_438_3 s_438_4
        let s_438_7: Bits = (Bits::new(
            ((s_438_6) >> (s_438_3)).value(),
            u16::try_from(s_438_4).unwrap(),
        ));
        // D s_438_8: cast reint s_438_7 -> u8
        let s_438_8: bool = ((s_438_7.value()) != 0);
        // C s_438_9: const #20s : i
        let s_438_9: i128 = 20;
        // C s_438_10: const #1s : i
        let s_438_10: i128 = 1;
        // D s_438_11: read-var u#30813:u32
        let s_438_11: u32 = fn_state.u_30813;
        // D s_438_12: cast zx s_438_11 -> bv
        let s_438_12: Bits = Bits::new(s_438_11 as u128, 32u16);
        // D s_438_13: bit-extract s_438_12 s_438_9 s_438_10
        let s_438_13: Bits = (Bits::new(
            ((s_438_12) >> (s_438_9)).value(),
            u16::try_from(s_438_10).unwrap(),
        ));
        // D s_438_14: cast reint s_438_13 -> u8
        let s_438_14: bool = ((s_438_13.value()) != 0);
        // C s_438_15: const #16s : i
        let s_438_15: i128 = 16;
        // C s_438_16: const #4s : i
        let s_438_16: i128 = 4;
        // D s_438_17: read-var u#30813:u32
        let s_438_17: u32 = fn_state.u_30813;
        // D s_438_18: cast zx s_438_17 -> bv
        let s_438_18: Bits = Bits::new(s_438_17 as u128, 32u16);
        // D s_438_19: bit-extract s_438_18 s_438_15 s_438_16
        let s_438_19: Bits = (Bits::new(
            ((s_438_18) >> (s_438_15)).value(),
            u16::try_from(s_438_16).unwrap(),
        ));
        // D s_438_20: cast reint s_438_19 -> u8
        let s_438_20: u8 = (s_438_19.value() as u8);
        // C s_438_21: const #12s : i
        let s_438_21: i128 = 12;
        // C s_438_22: const #4s : i
        let s_438_22: i128 = 4;
        // D s_438_23: read-var u#30813:u32
        let s_438_23: u32 = fn_state.u_30813;
        // D s_438_24: cast zx s_438_23 -> bv
        let s_438_24: Bits = Bits::new(s_438_23 as u128, 32u16);
        // D s_438_25: bit-extract s_438_24 s_438_21 s_438_22
        let s_438_25: Bits = (Bits::new(
            ((s_438_24) >> (s_438_21)).value(),
            u16::try_from(s_438_22).unwrap(),
        ));
        // D s_438_26: cast reint s_438_25 -> u8
        let s_438_26: u8 = (s_438_25.value() as u8);
        // C s_438_27: const #7s : i
        let s_438_27: i128 = 7;
        // C s_438_28: const #1s : i
        let s_438_28: i128 = 1;
        // D s_438_29: read-var u#30813:u32
        let s_438_29: u32 = fn_state.u_30813;
        // D s_438_30: cast zx s_438_29 -> bv
        let s_438_30: Bits = Bits::new(s_438_29 as u128, 32u16);
        // D s_438_31: bit-extract s_438_30 s_438_27 s_438_28
        let s_438_31: Bits = (Bits::new(
            ((s_438_30) >> (s_438_27)).value(),
            u16::try_from(s_438_28).unwrap(),
        ));
        // D s_438_32: cast reint s_438_31 -> u8
        let s_438_32: bool = ((s_438_31.value()) != 0);
        // C s_438_33: const #6s : i
        let s_438_33: i128 = 6;
        // C s_438_34: const #1s : i
        let s_438_34: i128 = 1;
        // D s_438_35: read-var u#30813:u32
        let s_438_35: u32 = fn_state.u_30813;
        // D s_438_36: cast zx s_438_35 -> bv
        let s_438_36: Bits = Bits::new(s_438_35 as u128, 32u16);
        // D s_438_37: bit-extract s_438_36 s_438_33 s_438_34
        let s_438_37: Bits = (Bits::new(
            ((s_438_36) >> (s_438_33)).value(),
            u16::try_from(s_438_34).unwrap(),
        ));
        // D s_438_38: cast reint s_438_37 -> u8
        let s_438_38: bool = ((s_438_37.value()) != 0);
        // C s_438_39: const #5s : i
        let s_438_39: i128 = 5;
        // C s_438_40: const #1s : i
        let s_438_40: i128 = 1;
        // D s_438_41: read-var u#30813:u32
        let s_438_41: u32 = fn_state.u_30813;
        // D s_438_42: cast zx s_438_41 -> bv
        let s_438_42: Bits = Bits::new(s_438_41 as u128, 32u16);
        // D s_438_43: bit-extract s_438_42 s_438_39 s_438_40
        let s_438_43: Bits = (Bits::new(
            ((s_438_42) >> (s_438_39)).value(),
            u16::try_from(s_438_40).unwrap(),
        ));
        // D s_438_44: cast reint s_438_43 -> u8
        let s_438_44: bool = ((s_438_43.value()) != 0);
        // C s_438_45: const #0s : i
        let s_438_45: i128 = 0;
        // C s_438_46: const #4s : i
        let s_438_46: i128 = 4;
        // D s_438_47: read-var u#30813:u32
        let s_438_47: u32 = fn_state.u_30813;
        // D s_438_48: cast zx s_438_47 -> bv
        let s_438_48: Bits = Bits::new(s_438_47 as u128, 32u16);
        // D s_438_49: bit-extract s_438_48 s_438_45 s_438_46
        let s_438_49: Bits = (Bits::new(
            ((s_438_48) >> (s_438_45)).value(),
            u16::try_from(s_438_46).unwrap(),
        ));
        // D s_438_50: cast reint s_438_49 -> u8
        let s_438_50: u8 = (s_438_49.value() as u8);
        // D s_438_51: call decode_aarch32_instrs_VCGT_r_A2enc_A_txt(s_438_8, s_438_14, s_438_20, s_438_26, s_438_32, s_438_38, s_438_44, s_438_50)
        let s_438_51: () = decode_aarch32_instrs_VCGT_r_A2enc_A_txt(
            state,
            tracer,
            s_438_8,
            s_438_14,
            s_438_20,
            s_438_26,
            s_438_32,
            s_438_38,
            s_438_44,
            s_438_50,
        );
        // N s_438_52: return
        return;
    }
    fn block_439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_439_0: read-var merge#var.1:struct
        let s_439_0: u32 = fn_state.merge_var._1;
        // D s_439_1: write-var u#30823 <= s_439_0
        fn_state.u_30823 = s_439_0;
        // C s_439_2: const #23s : i
        let s_439_2: i128 = 23;
        // D s_439_3: read-var u#30823:u32
        let s_439_3: u32 = fn_state.u_30823;
        // D s_439_4: cast zx s_439_3 -> bv
        let s_439_4: Bits = Bits::new(s_439_3 as u128, 32u16);
        // C s_439_5: const #1s : i64
        let s_439_5: i64 = 1;
        // C s_439_6: cast zx s_439_5 -> i
        let s_439_6: i128 = (i128::try_from(s_439_5).unwrap());
        // C s_439_7: const #8s : i
        let s_439_7: i128 = 8;
        // C s_439_8: add s_439_7 s_439_6
        let s_439_8: i128 = (s_439_7 + s_439_6);
        // D s_439_9: bit-extract s_439_4 s_439_2 s_439_8
        let s_439_9: Bits = (Bits::new(
            ((s_439_4) >> (s_439_2)).value(),
            u16::try_from(s_439_8).unwrap(),
        ));
        // D s_439_10: cast reint s_439_9 -> u9
        let s_439_10: u16 = (s_439_9.value() as u16);
        // D s_439_11: cast zx s_439_10 -> bv
        let s_439_11: Bits = Bits::new(s_439_10 as u128, 9u16);
        // C s_439_12: const #487u : u9
        let s_439_12: u16 = 487;
        // C s_439_13: cast zx s_439_12 -> bv
        let s_439_13: Bits = Bits::new(s_439_12 as u128, 9u16);
        // D s_439_14: cmp-eq s_439_11 s_439_13
        let s_439_14: bool = ((s_439_11) == (s_439_13));
        // N s_439_15: branch s_439_14 b2945 b440
        if s_439_14 {
            return block_2945(state, tracer, fn_state);
        } else {
            return block_440(state, tracer, fn_state);
        };
    }
    fn block_440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_440_0: const #0u : u8
        let s_440_0: bool = false;
        // D s_440_1: write-var gs#398669 <= s_440_0
        fn_state.gs_398669 = s_440_0;
        // N s_440_2: jump b441
        return block_441(state, tracer, fn_state);
    }
    fn block_441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_441_0: read-var gs#398669:u8
        let s_441_0: bool = fn_state.gs_398669;
        // N s_441_1: branch s_441_0 b2944 b442
        if s_441_0 {
            return block_2944(state, tracer, fn_state);
        } else {
            return block_442(state, tracer, fn_state);
        };
    }
    fn block_442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_442_0: const #0u : u8
        let s_442_0: bool = false;
        // D s_442_1: write-var gs#398671 <= s_442_0
        fn_state.gs_398671 = s_442_0;
        // N s_442_2: jump b443
        return block_443(state, tracer, fn_state);
    }
    fn block_443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_443_0: read-var gs#398671:u8
        let s_443_0: bool = fn_state.gs_398671;
        // D s_443_1: not s_443_0
        let s_443_1: bool = !s_443_0;
        // N s_443_2: branch s_443_1 b445 b444
        if s_443_1 {
            return block_445(state, tracer, fn_state);
        } else {
            return block_444(state, tracer, fn_state);
        };
    }
    fn block_444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_444_0: const #3404s : i
        let s_444_0: i128 = 3404;
        // C s_444_1: const #14696u : u32
        let s_444_1: u32 = 14696;
        // N s_444_2: write-reg s_444_1 <= s_444_0
        let s_444_2: () = {
            state.write_register::<i128>(s_444_1 as isize, s_444_0);
            tracer.write_register(s_444_1 as isize, s_444_0);
        };
        // C s_444_3: const #22s : i
        let s_444_3: i128 = 22;
        // C s_444_4: const #1s : i
        let s_444_4: i128 = 1;
        // D s_444_5: read-var u#30823:u32
        let s_444_5: u32 = fn_state.u_30823;
        // D s_444_6: cast zx s_444_5 -> bv
        let s_444_6: Bits = Bits::new(s_444_5 as u128, 32u16);
        // D s_444_7: bit-extract s_444_6 s_444_3 s_444_4
        let s_444_7: Bits = (Bits::new(
            ((s_444_6) >> (s_444_3)).value(),
            u16::try_from(s_444_4).unwrap(),
        ));
        // D s_444_8: cast reint s_444_7 -> u8
        let s_444_8: bool = ((s_444_7.value()) != 0);
        // C s_444_9: const #18s : i
        let s_444_9: i128 = 18;
        // C s_444_10: const #2s : i
        let s_444_10: i128 = 2;
        // D s_444_11: read-var u#30823:u32
        let s_444_11: u32 = fn_state.u_30823;
        // D s_444_12: cast zx s_444_11 -> bv
        let s_444_12: Bits = Bits::new(s_444_11 as u128, 32u16);
        // D s_444_13: bit-extract s_444_12 s_444_9 s_444_10
        let s_444_13: Bits = (Bits::new(
            ((s_444_12) >> (s_444_9)).value(),
            u16::try_from(s_444_10).unwrap(),
        ));
        // D s_444_14: cast reint s_444_13 -> u8
        let s_444_14: u8 = (s_444_13.value() as u8);
        // C s_444_15: const #12s : i
        let s_444_15: i128 = 12;
        // C s_444_16: const #4s : i
        let s_444_16: i128 = 4;
        // D s_444_17: read-var u#30823:u32
        let s_444_17: u32 = fn_state.u_30823;
        // D s_444_18: cast zx s_444_17 -> bv
        let s_444_18: Bits = Bits::new(s_444_17 as u128, 32u16);
        // D s_444_19: bit-extract s_444_18 s_444_15 s_444_16
        let s_444_19: Bits = (Bits::new(
            ((s_444_18) >> (s_444_15)).value(),
            u16::try_from(s_444_16).unwrap(),
        ));
        // D s_444_20: cast reint s_444_19 -> u8
        let s_444_20: u8 = (s_444_19.value() as u8);
        // C s_444_21: const #10s : i
        let s_444_21: i128 = 10;
        // C s_444_22: const #1s : i
        let s_444_22: i128 = 1;
        // D s_444_23: read-var u#30823:u32
        let s_444_23: u32 = fn_state.u_30823;
        // D s_444_24: cast zx s_444_23 -> bv
        let s_444_24: Bits = Bits::new(s_444_23 as u128, 32u16);
        // D s_444_25: bit-extract s_444_24 s_444_21 s_444_22
        let s_444_25: Bits = (Bits::new(
            ((s_444_24) >> (s_444_21)).value(),
            u16::try_from(s_444_22).unwrap(),
        ));
        // D s_444_26: cast reint s_444_25 -> u8
        let s_444_26: bool = ((s_444_25.value()) != 0);
        // C s_444_27: const #6s : i
        let s_444_27: i128 = 6;
        // C s_444_28: const #1s : i
        let s_444_28: i128 = 1;
        // D s_444_29: read-var u#30823:u32
        let s_444_29: u32 = fn_state.u_30823;
        // D s_444_30: cast zx s_444_29 -> bv
        let s_444_30: Bits = Bits::new(s_444_29 as u128, 32u16);
        // D s_444_31: bit-extract s_444_30 s_444_27 s_444_28
        let s_444_31: Bits = (Bits::new(
            ((s_444_30) >> (s_444_27)).value(),
            u16::try_from(s_444_28).unwrap(),
        ));
        // D s_444_32: cast reint s_444_31 -> u8
        let s_444_32: bool = ((s_444_31.value()) != 0);
        // C s_444_33: const #5s : i
        let s_444_33: i128 = 5;
        // C s_444_34: const #1s : i
        let s_444_34: i128 = 1;
        // D s_444_35: read-var u#30823:u32
        let s_444_35: u32 = fn_state.u_30823;
        // D s_444_36: cast zx s_444_35 -> bv
        let s_444_36: Bits = Bits::new(s_444_35 as u128, 32u16);
        // D s_444_37: bit-extract s_444_36 s_444_33 s_444_34
        let s_444_37: Bits = (Bits::new(
            ((s_444_36) >> (s_444_33)).value(),
            u16::try_from(s_444_34).unwrap(),
        ));
        // D s_444_38: cast reint s_444_37 -> u8
        let s_444_38: bool = ((s_444_37.value()) != 0);
        // C s_444_39: const #0s : i
        let s_444_39: i128 = 0;
        // C s_444_40: const #4s : i
        let s_444_40: i128 = 4;
        // D s_444_41: read-var u#30823:u32
        let s_444_41: u32 = fn_state.u_30823;
        // D s_444_42: cast zx s_444_41 -> bv
        let s_444_42: Bits = Bits::new(s_444_41 as u128, 32u16);
        // D s_444_43: bit-extract s_444_42 s_444_39 s_444_40
        let s_444_43: Bits = (Bits::new(
            ((s_444_42) >> (s_444_39)).value(),
            u16::try_from(s_444_40).unwrap(),
        ));
        // D s_444_44: cast reint s_444_43 -> u8
        let s_444_44: u8 = (s_444_43.value() as u8);
        // D s_444_45: call decode_aarch32_instrs_VCLE_i_A1enc_A_txt(s_444_8, s_444_14, s_444_20, s_444_26, s_444_32, s_444_38, s_444_44)
        let s_444_45: () = decode_aarch32_instrs_VCLE_i_A1enc_A_txt(
            state,
            tracer,
            s_444_8,
            s_444_14,
            s_444_20,
            s_444_26,
            s_444_32,
            s_444_38,
            s_444_44,
        );
        // N s_444_46: return
        return;
    }
    fn block_445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_445_0: read-var merge#var.1:struct
        let s_445_0: u32 = fn_state.merge_var._1;
        // D s_445_1: write-var u#30832 <= s_445_0
        fn_state.u_30832 = s_445_0;
        // C s_445_2: const #23s : i
        let s_445_2: i128 = 23;
        // D s_445_3: read-var u#30832:u32
        let s_445_3: u32 = fn_state.u_30832;
        // D s_445_4: cast zx s_445_3 -> bv
        let s_445_4: Bits = Bits::new(s_445_3 as u128, 32u16);
        // C s_445_5: const #1s : i64
        let s_445_5: i64 = 1;
        // C s_445_6: cast zx s_445_5 -> i
        let s_445_6: i128 = (i128::try_from(s_445_5).unwrap());
        // C s_445_7: const #8s : i
        let s_445_7: i128 = 8;
        // C s_445_8: add s_445_7 s_445_6
        let s_445_8: i128 = (s_445_7 + s_445_6);
        // D s_445_9: bit-extract s_445_4 s_445_2 s_445_8
        let s_445_9: Bits = (Bits::new(
            ((s_445_4) >> (s_445_2)).value(),
            u16::try_from(s_445_8).unwrap(),
        ));
        // D s_445_10: cast reint s_445_9 -> u9
        let s_445_10: u16 = (s_445_9.value() as u16);
        // D s_445_11: cast zx s_445_10 -> bv
        let s_445_11: Bits = Bits::new(s_445_10 as u128, 9u16);
        // C s_445_12: const #487u : u9
        let s_445_12: u16 = 487;
        // C s_445_13: cast zx s_445_12 -> bv
        let s_445_13: Bits = Bits::new(s_445_12 as u128, 9u16);
        // D s_445_14: cmp-eq s_445_11 s_445_13
        let s_445_14: bool = ((s_445_11) == (s_445_13));
        // N s_445_15: branch s_445_14 b2934 b446
        if s_445_14 {
            return block_2934(state, tracer, fn_state);
        } else {
            return block_446(state, tracer, fn_state);
        };
    }
    fn block_446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_446_0: const #0u : u8
        let s_446_0: bool = false;
        // D s_446_1: write-var gs#398702 <= s_446_0
        fn_state.gs_398702 = s_446_0;
        // N s_446_2: jump b447
        return block_447(state, tracer, fn_state);
    }
    fn block_447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_447_0: read-var gs#398702:u8
        let s_447_0: bool = fn_state.gs_398702;
        // N s_447_1: branch s_447_0 b2933 b448
        if s_447_0 {
            return block_2933(state, tracer, fn_state);
        } else {
            return block_448(state, tracer, fn_state);
        };
    }
    fn block_448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_448_0: const #0u : u8
        let s_448_0: bool = false;
        // D s_448_1: write-var gs#398704 <= s_448_0
        fn_state.gs_398704 = s_448_0;
        // N s_448_2: jump b449
        return block_449(state, tracer, fn_state);
    }
    fn block_449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_449_0: read-var gs#398704:u8
        let s_449_0: bool = fn_state.gs_398704;
        // D s_449_1: not s_449_0
        let s_449_1: bool = !s_449_0;
        // N s_449_2: branch s_449_1 b451 b450
        if s_449_1 {
            return block_451(state, tracer, fn_state);
        } else {
            return block_450(state, tracer, fn_state);
        };
    }
    fn block_450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_450_0: const #3406s : i
        let s_450_0: i128 = 3406;
        // C s_450_1: const #14696u : u32
        let s_450_1: u32 = 14696;
        // N s_450_2: write-reg s_450_1 <= s_450_0
        let s_450_2: () = {
            state.write_register::<i128>(s_450_1 as isize, s_450_0);
            tracer.write_register(s_450_1 as isize, s_450_0);
        };
        // C s_450_3: const #22s : i
        let s_450_3: i128 = 22;
        // C s_450_4: const #1s : i
        let s_450_4: i128 = 1;
        // D s_450_5: read-var u#30832:u32
        let s_450_5: u32 = fn_state.u_30832;
        // D s_450_6: cast zx s_450_5 -> bv
        let s_450_6: Bits = Bits::new(s_450_5 as u128, 32u16);
        // D s_450_7: bit-extract s_450_6 s_450_3 s_450_4
        let s_450_7: Bits = (Bits::new(
            ((s_450_6) >> (s_450_3)).value(),
            u16::try_from(s_450_4).unwrap(),
        ));
        // D s_450_8: cast reint s_450_7 -> u8
        let s_450_8: bool = ((s_450_7.value()) != 0);
        // C s_450_9: const #18s : i
        let s_450_9: i128 = 18;
        // C s_450_10: const #2s : i
        let s_450_10: i128 = 2;
        // D s_450_11: read-var u#30832:u32
        let s_450_11: u32 = fn_state.u_30832;
        // D s_450_12: cast zx s_450_11 -> bv
        let s_450_12: Bits = Bits::new(s_450_11 as u128, 32u16);
        // D s_450_13: bit-extract s_450_12 s_450_9 s_450_10
        let s_450_13: Bits = (Bits::new(
            ((s_450_12) >> (s_450_9)).value(),
            u16::try_from(s_450_10).unwrap(),
        ));
        // D s_450_14: cast reint s_450_13 -> u8
        let s_450_14: u8 = (s_450_13.value() as u8);
        // C s_450_15: const #12s : i
        let s_450_15: i128 = 12;
        // C s_450_16: const #4s : i
        let s_450_16: i128 = 4;
        // D s_450_17: read-var u#30832:u32
        let s_450_17: u32 = fn_state.u_30832;
        // D s_450_18: cast zx s_450_17 -> bv
        let s_450_18: Bits = Bits::new(s_450_17 as u128, 32u16);
        // D s_450_19: bit-extract s_450_18 s_450_15 s_450_16
        let s_450_19: Bits = (Bits::new(
            ((s_450_18) >> (s_450_15)).value(),
            u16::try_from(s_450_16).unwrap(),
        ));
        // D s_450_20: cast reint s_450_19 -> u8
        let s_450_20: u8 = (s_450_19.value() as u8);
        // C s_450_21: const #6s : i
        let s_450_21: i128 = 6;
        // C s_450_22: const #1s : i
        let s_450_22: i128 = 1;
        // D s_450_23: read-var u#30832:u32
        let s_450_23: u32 = fn_state.u_30832;
        // D s_450_24: cast zx s_450_23 -> bv
        let s_450_24: Bits = Bits::new(s_450_23 as u128, 32u16);
        // D s_450_25: bit-extract s_450_24 s_450_21 s_450_22
        let s_450_25: Bits = (Bits::new(
            ((s_450_24) >> (s_450_21)).value(),
            u16::try_from(s_450_22).unwrap(),
        ));
        // D s_450_26: cast reint s_450_25 -> u8
        let s_450_26: bool = ((s_450_25.value()) != 0);
        // C s_450_27: const #5s : i
        let s_450_27: i128 = 5;
        // C s_450_28: const #1s : i
        let s_450_28: i128 = 1;
        // D s_450_29: read-var u#30832:u32
        let s_450_29: u32 = fn_state.u_30832;
        // D s_450_30: cast zx s_450_29 -> bv
        let s_450_30: Bits = Bits::new(s_450_29 as u128, 32u16);
        // D s_450_31: bit-extract s_450_30 s_450_27 s_450_28
        let s_450_31: Bits = (Bits::new(
            ((s_450_30) >> (s_450_27)).value(),
            u16::try_from(s_450_28).unwrap(),
        ));
        // D s_450_32: cast reint s_450_31 -> u8
        let s_450_32: bool = ((s_450_31.value()) != 0);
        // C s_450_33: const #0s : i
        let s_450_33: i128 = 0;
        // C s_450_34: const #4s : i
        let s_450_34: i128 = 4;
        // D s_450_35: read-var u#30832:u32
        let s_450_35: u32 = fn_state.u_30832;
        // D s_450_36: cast zx s_450_35 -> bv
        let s_450_36: Bits = Bits::new(s_450_35 as u128, 32u16);
        // D s_450_37: bit-extract s_450_36 s_450_33 s_450_34
        let s_450_37: Bits = (Bits::new(
            ((s_450_36) >> (s_450_33)).value(),
            u16::try_from(s_450_34).unwrap(),
        ));
        // D s_450_38: cast reint s_450_37 -> u8
        let s_450_38: u8 = (s_450_37.value() as u8);
        // D s_450_39: call decode_aarch32_instrs_VCLS_A1enc_A_txt(s_450_8, s_450_14, s_450_20, s_450_26, s_450_32, s_450_38)
        let s_450_39: () = decode_aarch32_instrs_VCLS_A1enc_A_txt(
            state,
            tracer,
            s_450_8,
            s_450_14,
            s_450_20,
            s_450_26,
            s_450_32,
            s_450_38,
        );
        // N s_450_40: return
        return;
    }
    fn block_451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_451_0: read-var merge#var.1:struct
        let s_451_0: u32 = fn_state.merge_var._1;
        // D s_451_1: write-var u#30840 <= s_451_0
        fn_state.u_30840 = s_451_0;
        // C s_451_2: const #23s : i
        let s_451_2: i128 = 23;
        // D s_451_3: read-var u#30840:u32
        let s_451_3: u32 = fn_state.u_30840;
        // D s_451_4: cast zx s_451_3 -> bv
        let s_451_4: Bits = Bits::new(s_451_3 as u128, 32u16);
        // C s_451_5: const #1s : i64
        let s_451_5: i64 = 1;
        // C s_451_6: cast zx s_451_5 -> i
        let s_451_6: i128 = (i128::try_from(s_451_5).unwrap());
        // C s_451_7: const #8s : i
        let s_451_7: i128 = 8;
        // C s_451_8: add s_451_7 s_451_6
        let s_451_8: i128 = (s_451_7 + s_451_6);
        // D s_451_9: bit-extract s_451_4 s_451_2 s_451_8
        let s_451_9: Bits = (Bits::new(
            ((s_451_4) >> (s_451_2)).value(),
            u16::try_from(s_451_8).unwrap(),
        ));
        // D s_451_10: cast reint s_451_9 -> u9
        let s_451_10: u16 = (s_451_9.value() as u16);
        // D s_451_11: cast zx s_451_10 -> bv
        let s_451_11: Bits = Bits::new(s_451_10 as u128, 9u16);
        // C s_451_12: const #487u : u9
        let s_451_12: u16 = 487;
        // C s_451_13: cast zx s_451_12 -> bv
        let s_451_13: Bits = Bits::new(s_451_12 as u128, 9u16);
        // D s_451_14: cmp-eq s_451_11 s_451_13
        let s_451_14: bool = ((s_451_11) == (s_451_13));
        // N s_451_15: branch s_451_14 b2920 b452
        if s_451_14 {
            return block_2920(state, tracer, fn_state);
        } else {
            return block_452(state, tracer, fn_state);
        };
    }
    fn block_452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_452_0: const #0u : u8
        let s_452_0: bool = false;
        // D s_452_1: write-var gs#398736 <= s_452_0
        fn_state.gs_398736 = s_452_0;
        // N s_452_2: jump b453
        return block_453(state, tracer, fn_state);
    }
    fn block_453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_453_0: read-var gs#398736:u8
        let s_453_0: bool = fn_state.gs_398736;
        // N s_453_1: branch s_453_0 b2919 b454
        if s_453_0 {
            return block_2919(state, tracer, fn_state);
        } else {
            return block_454(state, tracer, fn_state);
        };
    }
    fn block_454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_454_0: const #0u : u8
        let s_454_0: bool = false;
        // D s_454_1: write-var gs#398738 <= s_454_0
        fn_state.gs_398738 = s_454_0;
        // N s_454_2: jump b455
        return block_455(state, tracer, fn_state);
    }
    fn block_455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_455_0: read-var gs#398738:u8
        let s_455_0: bool = fn_state.gs_398738;
        // D s_455_1: not s_455_0
        let s_455_1: bool = !s_455_0;
        // N s_455_2: branch s_455_1 b457 b456
        if s_455_1 {
            return block_457(state, tracer, fn_state);
        } else {
            return block_456(state, tracer, fn_state);
        };
    }
    fn block_456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_456_0: const #3408s : i
        let s_456_0: i128 = 3408;
        // C s_456_1: const #14696u : u32
        let s_456_1: u32 = 14696;
        // N s_456_2: write-reg s_456_1 <= s_456_0
        let s_456_2: () = {
            state.write_register::<i128>(s_456_1 as isize, s_456_0);
            tracer.write_register(s_456_1 as isize, s_456_0);
        };
        // C s_456_3: const #22s : i
        let s_456_3: i128 = 22;
        // C s_456_4: const #1s : i
        let s_456_4: i128 = 1;
        // D s_456_5: read-var u#30840:u32
        let s_456_5: u32 = fn_state.u_30840;
        // D s_456_6: cast zx s_456_5 -> bv
        let s_456_6: Bits = Bits::new(s_456_5 as u128, 32u16);
        // D s_456_7: bit-extract s_456_6 s_456_3 s_456_4
        let s_456_7: Bits = (Bits::new(
            ((s_456_6) >> (s_456_3)).value(),
            u16::try_from(s_456_4).unwrap(),
        ));
        // D s_456_8: cast reint s_456_7 -> u8
        let s_456_8: bool = ((s_456_7.value()) != 0);
        // C s_456_9: const #18s : i
        let s_456_9: i128 = 18;
        // C s_456_10: const #2s : i
        let s_456_10: i128 = 2;
        // D s_456_11: read-var u#30840:u32
        let s_456_11: u32 = fn_state.u_30840;
        // D s_456_12: cast zx s_456_11 -> bv
        let s_456_12: Bits = Bits::new(s_456_11 as u128, 32u16);
        // D s_456_13: bit-extract s_456_12 s_456_9 s_456_10
        let s_456_13: Bits = (Bits::new(
            ((s_456_12) >> (s_456_9)).value(),
            u16::try_from(s_456_10).unwrap(),
        ));
        // D s_456_14: cast reint s_456_13 -> u8
        let s_456_14: u8 = (s_456_13.value() as u8);
        // C s_456_15: const #12s : i
        let s_456_15: i128 = 12;
        // C s_456_16: const #4s : i
        let s_456_16: i128 = 4;
        // D s_456_17: read-var u#30840:u32
        let s_456_17: u32 = fn_state.u_30840;
        // D s_456_18: cast zx s_456_17 -> bv
        let s_456_18: Bits = Bits::new(s_456_17 as u128, 32u16);
        // D s_456_19: bit-extract s_456_18 s_456_15 s_456_16
        let s_456_19: Bits = (Bits::new(
            ((s_456_18) >> (s_456_15)).value(),
            u16::try_from(s_456_16).unwrap(),
        ));
        // D s_456_20: cast reint s_456_19 -> u8
        let s_456_20: u8 = (s_456_19.value() as u8);
        // C s_456_21: const #10s : i
        let s_456_21: i128 = 10;
        // C s_456_22: const #1s : i
        let s_456_22: i128 = 1;
        // D s_456_23: read-var u#30840:u32
        let s_456_23: u32 = fn_state.u_30840;
        // D s_456_24: cast zx s_456_23 -> bv
        let s_456_24: Bits = Bits::new(s_456_23 as u128, 32u16);
        // D s_456_25: bit-extract s_456_24 s_456_21 s_456_22
        let s_456_25: Bits = (Bits::new(
            ((s_456_24) >> (s_456_21)).value(),
            u16::try_from(s_456_22).unwrap(),
        ));
        // D s_456_26: cast reint s_456_25 -> u8
        let s_456_26: bool = ((s_456_25.value()) != 0);
        // C s_456_27: const #6s : i
        let s_456_27: i128 = 6;
        // C s_456_28: const #1s : i
        let s_456_28: i128 = 1;
        // D s_456_29: read-var u#30840:u32
        let s_456_29: u32 = fn_state.u_30840;
        // D s_456_30: cast zx s_456_29 -> bv
        let s_456_30: Bits = Bits::new(s_456_29 as u128, 32u16);
        // D s_456_31: bit-extract s_456_30 s_456_27 s_456_28
        let s_456_31: Bits = (Bits::new(
            ((s_456_30) >> (s_456_27)).value(),
            u16::try_from(s_456_28).unwrap(),
        ));
        // D s_456_32: cast reint s_456_31 -> u8
        let s_456_32: bool = ((s_456_31.value()) != 0);
        // C s_456_33: const #5s : i
        let s_456_33: i128 = 5;
        // C s_456_34: const #1s : i
        let s_456_34: i128 = 1;
        // D s_456_35: read-var u#30840:u32
        let s_456_35: u32 = fn_state.u_30840;
        // D s_456_36: cast zx s_456_35 -> bv
        let s_456_36: Bits = Bits::new(s_456_35 as u128, 32u16);
        // D s_456_37: bit-extract s_456_36 s_456_33 s_456_34
        let s_456_37: Bits = (Bits::new(
            ((s_456_36) >> (s_456_33)).value(),
            u16::try_from(s_456_34).unwrap(),
        ));
        // D s_456_38: cast reint s_456_37 -> u8
        let s_456_38: bool = ((s_456_37.value()) != 0);
        // C s_456_39: const #0s : i
        let s_456_39: i128 = 0;
        // C s_456_40: const #4s : i
        let s_456_40: i128 = 4;
        // D s_456_41: read-var u#30840:u32
        let s_456_41: u32 = fn_state.u_30840;
        // D s_456_42: cast zx s_456_41 -> bv
        let s_456_42: Bits = Bits::new(s_456_41 as u128, 32u16);
        // D s_456_43: bit-extract s_456_42 s_456_39 s_456_40
        let s_456_43: Bits = (Bits::new(
            ((s_456_42) >> (s_456_39)).value(),
            u16::try_from(s_456_40).unwrap(),
        ));
        // D s_456_44: cast reint s_456_43 -> u8
        let s_456_44: u8 = (s_456_43.value() as u8);
        // D s_456_45: call decode_aarch32_instrs_VCLT_i_A1enc_A_txt(s_456_8, s_456_14, s_456_20, s_456_26, s_456_32, s_456_38, s_456_44)
        let s_456_45: () = decode_aarch32_instrs_VCLT_i_A1enc_A_txt(
            state,
            tracer,
            s_456_8,
            s_456_14,
            s_456_20,
            s_456_26,
            s_456_32,
            s_456_38,
            s_456_44,
        );
        // N s_456_46: return
        return;
    }
    fn block_457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_457_0: read-var merge#var.1:struct
        let s_457_0: u32 = fn_state.merge_var._1;
        // D s_457_1: write-var u#30849 <= s_457_0
        fn_state.u_30849 = s_457_0;
        // C s_457_2: const #23s : i
        let s_457_2: i128 = 23;
        // D s_457_3: read-var u#30849:u32
        let s_457_3: u32 = fn_state.u_30849;
        // D s_457_4: cast zx s_457_3 -> bv
        let s_457_4: Bits = Bits::new(s_457_3 as u128, 32u16);
        // C s_457_5: const #1s : i64
        let s_457_5: i64 = 1;
        // C s_457_6: cast zx s_457_5 -> i
        let s_457_6: i128 = (i128::try_from(s_457_5).unwrap());
        // C s_457_7: const #8s : i
        let s_457_7: i128 = 8;
        // C s_457_8: add s_457_7 s_457_6
        let s_457_8: i128 = (s_457_7 + s_457_6);
        // D s_457_9: bit-extract s_457_4 s_457_2 s_457_8
        let s_457_9: Bits = (Bits::new(
            ((s_457_4) >> (s_457_2)).value(),
            u16::try_from(s_457_8).unwrap(),
        ));
        // D s_457_10: cast reint s_457_9 -> u9
        let s_457_10: u16 = (s_457_9.value() as u16);
        // D s_457_11: cast zx s_457_10 -> bv
        let s_457_11: Bits = Bits::new(s_457_10 as u128, 9u16);
        // C s_457_12: const #487u : u9
        let s_457_12: u16 = 487;
        // C s_457_13: cast zx s_457_12 -> bv
        let s_457_13: Bits = Bits::new(s_457_12 as u128, 9u16);
        // D s_457_14: cmp-eq s_457_11 s_457_13
        let s_457_14: bool = ((s_457_11) == (s_457_13));
        // N s_457_15: branch s_457_14 b2909 b458
        if s_457_14 {
            return block_2909(state, tracer, fn_state);
        } else {
            return block_458(state, tracer, fn_state);
        };
    }
    fn block_458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_458_0: const #0u : u8
        let s_458_0: bool = false;
        // D s_458_1: write-var gs#398769 <= s_458_0
        fn_state.gs_398769 = s_458_0;
        // N s_458_2: jump b459
        return block_459(state, tracer, fn_state);
    }
    fn block_459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_459_0: read-var gs#398769:u8
        let s_459_0: bool = fn_state.gs_398769;
        // N s_459_1: branch s_459_0 b2908 b460
        if s_459_0 {
            return block_2908(state, tracer, fn_state);
        } else {
            return block_460(state, tracer, fn_state);
        };
    }
    fn block_460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_460_0: const #0u : u8
        let s_460_0: bool = false;
        // D s_460_1: write-var gs#398771 <= s_460_0
        fn_state.gs_398771 = s_460_0;
        // N s_460_2: jump b461
        return block_461(state, tracer, fn_state);
    }
    fn block_461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_461_0: read-var gs#398771:u8
        let s_461_0: bool = fn_state.gs_398771;
        // D s_461_1: not s_461_0
        let s_461_1: bool = !s_461_0;
        // N s_461_2: branch s_461_1 b463 b462
        if s_461_1 {
            return block_463(state, tracer, fn_state);
        } else {
            return block_462(state, tracer, fn_state);
        };
    }
    fn block_462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_462_0: const #3410s : i
        let s_462_0: i128 = 3410;
        // C s_462_1: const #14696u : u32
        let s_462_1: u32 = 14696;
        // N s_462_2: write-reg s_462_1 <= s_462_0
        let s_462_2: () = {
            state.write_register::<i128>(s_462_1 as isize, s_462_0);
            tracer.write_register(s_462_1 as isize, s_462_0);
        };
        // C s_462_3: const #22s : i
        let s_462_3: i128 = 22;
        // C s_462_4: const #1s : i
        let s_462_4: i128 = 1;
        // D s_462_5: read-var u#30849:u32
        let s_462_5: u32 = fn_state.u_30849;
        // D s_462_6: cast zx s_462_5 -> bv
        let s_462_6: Bits = Bits::new(s_462_5 as u128, 32u16);
        // D s_462_7: bit-extract s_462_6 s_462_3 s_462_4
        let s_462_7: Bits = (Bits::new(
            ((s_462_6) >> (s_462_3)).value(),
            u16::try_from(s_462_4).unwrap(),
        ));
        // D s_462_8: cast reint s_462_7 -> u8
        let s_462_8: bool = ((s_462_7.value()) != 0);
        // C s_462_9: const #18s : i
        let s_462_9: i128 = 18;
        // C s_462_10: const #2s : i
        let s_462_10: i128 = 2;
        // D s_462_11: read-var u#30849:u32
        let s_462_11: u32 = fn_state.u_30849;
        // D s_462_12: cast zx s_462_11 -> bv
        let s_462_12: Bits = Bits::new(s_462_11 as u128, 32u16);
        // D s_462_13: bit-extract s_462_12 s_462_9 s_462_10
        let s_462_13: Bits = (Bits::new(
            ((s_462_12) >> (s_462_9)).value(),
            u16::try_from(s_462_10).unwrap(),
        ));
        // D s_462_14: cast reint s_462_13 -> u8
        let s_462_14: u8 = (s_462_13.value() as u8);
        // C s_462_15: const #12s : i
        let s_462_15: i128 = 12;
        // C s_462_16: const #4s : i
        let s_462_16: i128 = 4;
        // D s_462_17: read-var u#30849:u32
        let s_462_17: u32 = fn_state.u_30849;
        // D s_462_18: cast zx s_462_17 -> bv
        let s_462_18: Bits = Bits::new(s_462_17 as u128, 32u16);
        // D s_462_19: bit-extract s_462_18 s_462_15 s_462_16
        let s_462_19: Bits = (Bits::new(
            ((s_462_18) >> (s_462_15)).value(),
            u16::try_from(s_462_16).unwrap(),
        ));
        // D s_462_20: cast reint s_462_19 -> u8
        let s_462_20: u8 = (s_462_19.value() as u8);
        // C s_462_21: const #6s : i
        let s_462_21: i128 = 6;
        // C s_462_22: const #1s : i
        let s_462_22: i128 = 1;
        // D s_462_23: read-var u#30849:u32
        let s_462_23: u32 = fn_state.u_30849;
        // D s_462_24: cast zx s_462_23 -> bv
        let s_462_24: Bits = Bits::new(s_462_23 as u128, 32u16);
        // D s_462_25: bit-extract s_462_24 s_462_21 s_462_22
        let s_462_25: Bits = (Bits::new(
            ((s_462_24) >> (s_462_21)).value(),
            u16::try_from(s_462_22).unwrap(),
        ));
        // D s_462_26: cast reint s_462_25 -> u8
        let s_462_26: bool = ((s_462_25.value()) != 0);
        // C s_462_27: const #5s : i
        let s_462_27: i128 = 5;
        // C s_462_28: const #1s : i
        let s_462_28: i128 = 1;
        // D s_462_29: read-var u#30849:u32
        let s_462_29: u32 = fn_state.u_30849;
        // D s_462_30: cast zx s_462_29 -> bv
        let s_462_30: Bits = Bits::new(s_462_29 as u128, 32u16);
        // D s_462_31: bit-extract s_462_30 s_462_27 s_462_28
        let s_462_31: Bits = (Bits::new(
            ((s_462_30) >> (s_462_27)).value(),
            u16::try_from(s_462_28).unwrap(),
        ));
        // D s_462_32: cast reint s_462_31 -> u8
        let s_462_32: bool = ((s_462_31.value()) != 0);
        // C s_462_33: const #0s : i
        let s_462_33: i128 = 0;
        // C s_462_34: const #4s : i
        let s_462_34: i128 = 4;
        // D s_462_35: read-var u#30849:u32
        let s_462_35: u32 = fn_state.u_30849;
        // D s_462_36: cast zx s_462_35 -> bv
        let s_462_36: Bits = Bits::new(s_462_35 as u128, 32u16);
        // D s_462_37: bit-extract s_462_36 s_462_33 s_462_34
        let s_462_37: Bits = (Bits::new(
            ((s_462_36) >> (s_462_33)).value(),
            u16::try_from(s_462_34).unwrap(),
        ));
        // D s_462_38: cast reint s_462_37 -> u8
        let s_462_38: u8 = (s_462_37.value() as u8);
        // D s_462_39: call decode_aarch32_instrs_VCLZ_A1enc_A_txt(s_462_8, s_462_14, s_462_20, s_462_26, s_462_32, s_462_38)
        let s_462_39: () = decode_aarch32_instrs_VCLZ_A1enc_A_txt(
            state,
            tracer,
            s_462_8,
            s_462_14,
            s_462_20,
            s_462_26,
            s_462_32,
            s_462_38,
        );
        // N s_462_40: return
        return;
    }
    fn block_463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_463_0: read-var merge#var.1:struct
        let s_463_0: u32 = fn_state.merge_var._1;
        // D s_463_1: write-var u#30857 <= s_463_0
        fn_state.u_30857 = s_463_0;
        // C s_463_2: const #23s : i
        let s_463_2: i128 = 23;
        // D s_463_3: read-var u#30857:u32
        let s_463_3: u32 = fn_state.u_30857;
        // D s_463_4: cast zx s_463_3 -> bv
        let s_463_4: Bits = Bits::new(s_463_3 as u128, 32u16);
        // C s_463_5: const #1s : i64
        let s_463_5: i64 = 1;
        // C s_463_6: cast zx s_463_5 -> i
        let s_463_6: i128 = (i128::try_from(s_463_5).unwrap());
        // C s_463_7: const #8s : i
        let s_463_7: i128 = 8;
        // C s_463_8: add s_463_7 s_463_6
        let s_463_8: i128 = (s_463_7 + s_463_6);
        // D s_463_9: bit-extract s_463_4 s_463_2 s_463_8
        let s_463_9: Bits = (Bits::new(
            ((s_463_4) >> (s_463_2)).value(),
            u16::try_from(s_463_8).unwrap(),
        ));
        // D s_463_10: cast reint s_463_9 -> u9
        let s_463_10: u16 = (s_463_9.value() as u16);
        // D s_463_11: cast zx s_463_10 -> bv
        let s_463_11: Bits = Bits::new(s_463_10 as u128, 9u16);
        // C s_463_12: const #487u : u9
        let s_463_12: u16 = 487;
        // C s_463_13: cast zx s_463_12 -> bv
        let s_463_13: Bits = Bits::new(s_463_12 as u128, 9u16);
        // D s_463_14: cmp-eq s_463_11 s_463_13
        let s_463_14: bool = ((s_463_11) == (s_463_13));
        // N s_463_15: branch s_463_14 b2898 b464
        if s_463_14 {
            return block_2898(state, tracer, fn_state);
        } else {
            return block_464(state, tracer, fn_state);
        };
    }
    fn block_464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_464_0: const #0u : u8
        let s_464_0: bool = false;
        // D s_464_1: write-var gs#398800 <= s_464_0
        fn_state.gs_398800 = s_464_0;
        // N s_464_2: jump b465
        return block_465(state, tracer, fn_state);
    }
    fn block_465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_465_0: read-var gs#398800:u8
        let s_465_0: bool = fn_state.gs_398800;
        // N s_465_1: branch s_465_0 b2897 b466
        if s_465_0 {
            return block_2897(state, tracer, fn_state);
        } else {
            return block_466(state, tracer, fn_state);
        };
    }
    fn block_466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_466_0: const #0u : u8
        let s_466_0: bool = false;
        // D s_466_1: write-var gs#398802 <= s_466_0
        fn_state.gs_398802 = s_466_0;
        // N s_466_2: jump b467
        return block_467(state, tracer, fn_state);
    }
    fn block_467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_467_0: read-var gs#398802:u8
        let s_467_0: bool = fn_state.gs_398802;
        // D s_467_1: not s_467_0
        let s_467_1: bool = !s_467_0;
        // N s_467_2: branch s_467_1 b469 b468
        if s_467_1 {
            return block_469(state, tracer, fn_state);
        } else {
            return block_468(state, tracer, fn_state);
        };
    }
    fn block_468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_468_0: const #3416s : i
        let s_468_0: i128 = 3416;
        // C s_468_1: const #14696u : u32
        let s_468_1: u32 = 14696;
        // N s_468_2: write-reg s_468_1 <= s_468_0
        let s_468_2: () = {
            state.write_register::<i128>(s_468_1 as isize, s_468_0);
            tracer.write_register(s_468_1 as isize, s_468_0);
        };
        // C s_468_3: const #22s : i
        let s_468_3: i128 = 22;
        // C s_468_4: const #1s : i
        let s_468_4: i128 = 1;
        // D s_468_5: read-var u#30857:u32
        let s_468_5: u32 = fn_state.u_30857;
        // D s_468_6: cast zx s_468_5 -> bv
        let s_468_6: Bits = Bits::new(s_468_5 as u128, 32u16);
        // D s_468_7: bit-extract s_468_6 s_468_3 s_468_4
        let s_468_7: Bits = (Bits::new(
            ((s_468_6) >> (s_468_3)).value(),
            u16::try_from(s_468_4).unwrap(),
        ));
        // D s_468_8: cast reint s_468_7 -> u8
        let s_468_8: bool = ((s_468_7.value()) != 0);
        // C s_468_9: const #18s : i
        let s_468_9: i128 = 18;
        // C s_468_10: const #2s : i
        let s_468_10: i128 = 2;
        // D s_468_11: read-var u#30857:u32
        let s_468_11: u32 = fn_state.u_30857;
        // D s_468_12: cast zx s_468_11 -> bv
        let s_468_12: Bits = Bits::new(s_468_11 as u128, 32u16);
        // D s_468_13: bit-extract s_468_12 s_468_9 s_468_10
        let s_468_13: Bits = (Bits::new(
            ((s_468_12) >> (s_468_9)).value(),
            u16::try_from(s_468_10).unwrap(),
        ));
        // D s_468_14: cast reint s_468_13 -> u8
        let s_468_14: u8 = (s_468_13.value() as u8);
        // C s_468_15: const #12s : i
        let s_468_15: i128 = 12;
        // C s_468_16: const #4s : i
        let s_468_16: i128 = 4;
        // D s_468_17: read-var u#30857:u32
        let s_468_17: u32 = fn_state.u_30857;
        // D s_468_18: cast zx s_468_17 -> bv
        let s_468_18: Bits = Bits::new(s_468_17 as u128, 32u16);
        // D s_468_19: bit-extract s_468_18 s_468_15 s_468_16
        let s_468_19: Bits = (Bits::new(
            ((s_468_18) >> (s_468_15)).value(),
            u16::try_from(s_468_16).unwrap(),
        ));
        // D s_468_20: cast reint s_468_19 -> u8
        let s_468_20: u8 = (s_468_19.value() as u8);
        // C s_468_21: const #6s : i
        let s_468_21: i128 = 6;
        // C s_468_22: const #1s : i
        let s_468_22: i128 = 1;
        // D s_468_23: read-var u#30857:u32
        let s_468_23: u32 = fn_state.u_30857;
        // D s_468_24: cast zx s_468_23 -> bv
        let s_468_24: Bits = Bits::new(s_468_23 as u128, 32u16);
        // D s_468_25: bit-extract s_468_24 s_468_21 s_468_22
        let s_468_25: Bits = (Bits::new(
            ((s_468_24) >> (s_468_21)).value(),
            u16::try_from(s_468_22).unwrap(),
        ));
        // D s_468_26: cast reint s_468_25 -> u8
        let s_468_26: bool = ((s_468_25.value()) != 0);
        // C s_468_27: const #5s : i
        let s_468_27: i128 = 5;
        // C s_468_28: const #1s : i
        let s_468_28: i128 = 1;
        // D s_468_29: read-var u#30857:u32
        let s_468_29: u32 = fn_state.u_30857;
        // D s_468_30: cast zx s_468_29 -> bv
        let s_468_30: Bits = Bits::new(s_468_29 as u128, 32u16);
        // D s_468_31: bit-extract s_468_30 s_468_27 s_468_28
        let s_468_31: Bits = (Bits::new(
            ((s_468_30) >> (s_468_27)).value(),
            u16::try_from(s_468_28).unwrap(),
        ));
        // D s_468_32: cast reint s_468_31 -> u8
        let s_468_32: bool = ((s_468_31.value()) != 0);
        // C s_468_33: const #0s : i
        let s_468_33: i128 = 0;
        // C s_468_34: const #4s : i
        let s_468_34: i128 = 4;
        // D s_468_35: read-var u#30857:u32
        let s_468_35: u32 = fn_state.u_30857;
        // D s_468_36: cast zx s_468_35 -> bv
        let s_468_36: Bits = Bits::new(s_468_35 as u128, 32u16);
        // D s_468_37: bit-extract s_468_36 s_468_33 s_468_34
        let s_468_37: Bits = (Bits::new(
            ((s_468_36) >> (s_468_33)).value(),
            u16::try_from(s_468_34).unwrap(),
        ));
        // D s_468_38: cast reint s_468_37 -> u8
        let s_468_38: u8 = (s_468_37.value() as u8);
        // D s_468_39: call decode_aarch32_instrs_VCNT_A1enc_A_txt(s_468_8, s_468_14, s_468_20, s_468_26, s_468_32, s_468_38)
        let s_468_39: () = decode_aarch32_instrs_VCNT_A1enc_A_txt(
            state,
            tracer,
            s_468_8,
            s_468_14,
            s_468_20,
            s_468_26,
            s_468_32,
            s_468_38,
        );
        // N s_468_40: return
        return;
    }
    fn block_469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_469_0: read-var merge#var.1:struct
        let s_469_0: u32 = fn_state.merge_var._1;
        // D s_469_1: write-var u#30865 <= s_469_0
        fn_state.u_30865 = s_469_0;
        // C s_469_2: const #23s : i
        let s_469_2: i128 = 23;
        // D s_469_3: read-var u#30865:u32
        let s_469_3: u32 = fn_state.u_30865;
        // D s_469_4: cast zx s_469_3 -> bv
        let s_469_4: Bits = Bits::new(s_469_3 as u128, 32u16);
        // C s_469_5: const #1s : i64
        let s_469_5: i64 = 1;
        // C s_469_6: cast zx s_469_5 -> i
        let s_469_6: i128 = (i128::try_from(s_469_5).unwrap());
        // C s_469_7: const #8s : i
        let s_469_7: i128 = 8;
        // C s_469_8: add s_469_7 s_469_6
        let s_469_8: i128 = (s_469_7 + s_469_6);
        // D s_469_9: bit-extract s_469_4 s_469_2 s_469_8
        let s_469_9: Bits = (Bits::new(
            ((s_469_4) >> (s_469_2)).value(),
            u16::try_from(s_469_8).unwrap(),
        ));
        // D s_469_10: cast reint s_469_9 -> u9
        let s_469_10: u16 = (s_469_9.value() as u16);
        // D s_469_11: cast zx s_469_10 -> bv
        let s_469_11: Bits = Bits::new(s_469_10 as u128, 9u16);
        // C s_469_12: const #487u : u9
        let s_469_12: u16 = 487;
        // C s_469_13: cast zx s_469_12 -> bv
        let s_469_13: Bits = Bits::new(s_469_12 as u128, 9u16);
        // D s_469_14: cmp-eq s_469_11 s_469_13
        let s_469_14: bool = ((s_469_11) == (s_469_13));
        // N s_469_15: branch s_469_14 b2884 b470
        if s_469_14 {
            return block_2884(state, tracer, fn_state);
        } else {
            return block_470(state, tracer, fn_state);
        };
    }
    fn block_470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_470_0: const #0u : u8
        let s_470_0: bool = false;
        // D s_470_1: write-var gs#398834 <= s_470_0
        fn_state.gs_398834 = s_470_0;
        // N s_470_2: jump b471
        return block_471(state, tracer, fn_state);
    }
    fn block_471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_471_0: read-var gs#398834:u8
        let s_471_0: bool = fn_state.gs_398834;
        // N s_471_1: branch s_471_0 b2883 b472
        if s_471_0 {
            return block_2883(state, tracer, fn_state);
        } else {
            return block_472(state, tracer, fn_state);
        };
    }
    fn block_472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_472_0: const #0u : u8
        let s_472_0: bool = false;
        // D s_472_1: write-var gs#398836 <= s_472_0
        fn_state.gs_398836 = s_472_0;
        // N s_472_2: jump b473
        return block_473(state, tracer, fn_state);
    }
    fn block_473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_473_0: read-var gs#398836:u8
        let s_473_0: bool = fn_state.gs_398836;
        // D s_473_1: not s_473_0
        let s_473_1: bool = !s_473_0;
        // N s_473_2: branch s_473_1 b475 b474
        if s_473_1 {
            return block_475(state, tracer, fn_state);
        } else {
            return block_474(state, tracer, fn_state);
        };
    }
    fn block_474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_474_0: const #3422s : i
        let s_474_0: i128 = 3422;
        // C s_474_1: const #14696u : u32
        let s_474_1: u32 = 14696;
        // N s_474_2: write-reg s_474_1 <= s_474_0
        let s_474_2: () = {
            state.write_register::<i128>(s_474_1 as isize, s_474_0);
            tracer.write_register(s_474_1 as isize, s_474_0);
        };
        // C s_474_3: const #22s : i
        let s_474_3: i128 = 22;
        // C s_474_4: const #1s : i
        let s_474_4: i128 = 1;
        // D s_474_5: read-var u#30865:u32
        let s_474_5: u32 = fn_state.u_30865;
        // D s_474_6: cast zx s_474_5 -> bv
        let s_474_6: Bits = Bits::new(s_474_5 as u128, 32u16);
        // D s_474_7: bit-extract s_474_6 s_474_3 s_474_4
        let s_474_7: Bits = (Bits::new(
            ((s_474_6) >> (s_474_3)).value(),
            u16::try_from(s_474_4).unwrap(),
        ));
        // D s_474_8: cast reint s_474_7 -> u8
        let s_474_8: bool = ((s_474_7.value()) != 0);
        // C s_474_9: const #18s : i
        let s_474_9: i128 = 18;
        // C s_474_10: const #2s : i
        let s_474_10: i128 = 2;
        // D s_474_11: read-var u#30865:u32
        let s_474_11: u32 = fn_state.u_30865;
        // D s_474_12: cast zx s_474_11 -> bv
        let s_474_12: Bits = Bits::new(s_474_11 as u128, 32u16);
        // D s_474_13: bit-extract s_474_12 s_474_9 s_474_10
        let s_474_13: Bits = (Bits::new(
            ((s_474_12) >> (s_474_9)).value(),
            u16::try_from(s_474_10).unwrap(),
        ));
        // D s_474_14: cast reint s_474_13 -> u8
        let s_474_14: u8 = (s_474_13.value() as u8);
        // C s_474_15: const #12s : i
        let s_474_15: i128 = 12;
        // C s_474_16: const #4s : i
        let s_474_16: i128 = 4;
        // D s_474_17: read-var u#30865:u32
        let s_474_17: u32 = fn_state.u_30865;
        // D s_474_18: cast zx s_474_17 -> bv
        let s_474_18: Bits = Bits::new(s_474_17 as u128, 32u16);
        // D s_474_19: bit-extract s_474_18 s_474_15 s_474_16
        let s_474_19: Bits = (Bits::new(
            ((s_474_18) >> (s_474_15)).value(),
            u16::try_from(s_474_16).unwrap(),
        ));
        // D s_474_20: cast reint s_474_19 -> u8
        let s_474_20: u8 = (s_474_19.value() as u8);
        // C s_474_21: const #8s : i
        let s_474_21: i128 = 8;
        // C s_474_22: const #1s : i
        let s_474_22: i128 = 1;
        // D s_474_23: read-var u#30865:u32
        let s_474_23: u32 = fn_state.u_30865;
        // D s_474_24: cast zx s_474_23 -> bv
        let s_474_24: Bits = Bits::new(s_474_23 as u128, 32u16);
        // D s_474_25: bit-extract s_474_24 s_474_21 s_474_22
        let s_474_25: Bits = (Bits::new(
            ((s_474_24) >> (s_474_21)).value(),
            u16::try_from(s_474_22).unwrap(),
        ));
        // D s_474_26: cast reint s_474_25 -> u8
        let s_474_26: bool = ((s_474_25.value()) != 0);
        // C s_474_27: const #5s : i
        let s_474_27: i128 = 5;
        // C s_474_28: const #1s : i
        let s_474_28: i128 = 1;
        // D s_474_29: read-var u#30865:u32
        let s_474_29: u32 = fn_state.u_30865;
        // D s_474_30: cast zx s_474_29 -> bv
        let s_474_30: Bits = Bits::new(s_474_29 as u128, 32u16);
        // D s_474_31: bit-extract s_474_30 s_474_27 s_474_28
        let s_474_31: Bits = (Bits::new(
            ((s_474_30) >> (s_474_27)).value(),
            u16::try_from(s_474_28).unwrap(),
        ));
        // D s_474_32: cast reint s_474_31 -> u8
        let s_474_32: bool = ((s_474_31.value()) != 0);
        // C s_474_33: const #0s : i
        let s_474_33: i128 = 0;
        // C s_474_34: const #4s : i
        let s_474_34: i128 = 4;
        // D s_474_35: read-var u#30865:u32
        let s_474_35: u32 = fn_state.u_30865;
        // D s_474_36: cast zx s_474_35 -> bv
        let s_474_36: Bits = Bits::new(s_474_35 as u128, 32u16);
        // D s_474_37: bit-extract s_474_36 s_474_33 s_474_34
        let s_474_37: Bits = (Bits::new(
            ((s_474_36) >> (s_474_33)).value(),
            u16::try_from(s_474_34).unwrap(),
        ));
        // D s_474_38: cast reint s_474_37 -> u8
        let s_474_38: u8 = (s_474_37.value() as u8);
        // D s_474_39: call decode_aarch32_instrs_VCVT_hs_A1enc_A_txt(s_474_8, s_474_14, s_474_20, s_474_26, s_474_32, s_474_38)
        let s_474_39: () = decode_aarch32_instrs_VCVT_hs_A1enc_A_txt(
            state,
            tracer,
            s_474_8,
            s_474_14,
            s_474_20,
            s_474_26,
            s_474_32,
            s_474_38,
        );
        // N s_474_40: return
        return;
    }
    fn block_475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_475_0: read-var merge#var.1:struct
        let s_475_0: u32 = fn_state.merge_var._1;
        // D s_475_1: write-var u#30873 <= s_475_0
        fn_state.u_30873 = s_475_0;
        // C s_475_2: const #23s : i
        let s_475_2: i128 = 23;
        // D s_475_3: read-var u#30873:u32
        let s_475_3: u32 = fn_state.u_30873;
        // D s_475_4: cast zx s_475_3 -> bv
        let s_475_4: Bits = Bits::new(s_475_3 as u128, 32u16);
        // C s_475_5: const #1s : i64
        let s_475_5: i64 = 1;
        // C s_475_6: cast zx s_475_5 -> i
        let s_475_6: i128 = (i128::try_from(s_475_5).unwrap());
        // C s_475_7: const #8s : i
        let s_475_7: i128 = 8;
        // C s_475_8: add s_475_7 s_475_6
        let s_475_8: i128 = (s_475_7 + s_475_6);
        // D s_475_9: bit-extract s_475_4 s_475_2 s_475_8
        let s_475_9: Bits = (Bits::new(
            ((s_475_4) >> (s_475_2)).value(),
            u16::try_from(s_475_8).unwrap(),
        ));
        // D s_475_10: cast reint s_475_9 -> u9
        let s_475_10: u16 = (s_475_9.value() as u16);
        // D s_475_11: cast zx s_475_10 -> bv
        let s_475_11: Bits = Bits::new(s_475_10 as u128, 9u16);
        // C s_475_12: const #487u : u9
        let s_475_12: u16 = 487;
        // C s_475_13: cast zx s_475_12 -> bv
        let s_475_13: Bits = Bits::new(s_475_12 as u128, 9u16);
        // D s_475_14: cmp-eq s_475_11 s_475_13
        let s_475_14: bool = ((s_475_11) == (s_475_13));
        // N s_475_15: branch s_475_14 b2873 b476
        if s_475_14 {
            return block_2873(state, tracer, fn_state);
        } else {
            return block_476(state, tracer, fn_state);
        };
    }
    fn block_476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_476_0: const #0u : u8
        let s_476_0: bool = false;
        // D s_476_1: write-var gs#398865 <= s_476_0
        fn_state.gs_398865 = s_476_0;
        // N s_476_2: jump b477
        return block_477(state, tracer, fn_state);
    }
    fn block_477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_477_0: read-var gs#398865:u8
        let s_477_0: bool = fn_state.gs_398865;
        // N s_477_1: branch s_477_0 b2872 b478
        if s_477_0 {
            return block_2872(state, tracer, fn_state);
        } else {
            return block_478(state, tracer, fn_state);
        };
    }
    fn block_478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_478_0: const #0u : u8
        let s_478_0: bool = false;
        // D s_478_1: write-var gs#398867 <= s_478_0
        fn_state.gs_398867 = s_478_0;
        // N s_478_2: jump b479
        return block_479(state, tracer, fn_state);
    }
    fn block_479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_479_0: read-var gs#398867:u8
        let s_479_0: bool = fn_state.gs_398867;
        // D s_479_1: not s_479_0
        let s_479_1: bool = !s_479_0;
        // N s_479_2: branch s_479_1 b481 b480
        if s_479_1 {
            return block_481(state, tracer, fn_state);
        } else {
            return block_480(state, tracer, fn_state);
        };
    }
    fn block_480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_480_0: const #3424s : i
        let s_480_0: i128 = 3424;
        // C s_480_1: const #14696u : u32
        let s_480_1: u32 = 14696;
        // N s_480_2: write-reg s_480_1 <= s_480_0
        let s_480_2: () = {
            state.write_register::<i128>(s_480_1 as isize, s_480_0);
            tracer.write_register(s_480_1 as isize, s_480_0);
        };
        // C s_480_3: const #22s : i
        let s_480_3: i128 = 22;
        // C s_480_4: const #1s : i
        let s_480_4: i128 = 1;
        // D s_480_5: read-var u#30873:u32
        let s_480_5: u32 = fn_state.u_30873;
        // D s_480_6: cast zx s_480_5 -> bv
        let s_480_6: Bits = Bits::new(s_480_5 as u128, 32u16);
        // D s_480_7: bit-extract s_480_6 s_480_3 s_480_4
        let s_480_7: Bits = (Bits::new(
            ((s_480_6) >> (s_480_3)).value(),
            u16::try_from(s_480_4).unwrap(),
        ));
        // D s_480_8: cast reint s_480_7 -> u8
        let s_480_8: bool = ((s_480_7.value()) != 0);
        // C s_480_9: const #18s : i
        let s_480_9: i128 = 18;
        // C s_480_10: const #2s : i
        let s_480_10: i128 = 2;
        // D s_480_11: read-var u#30873:u32
        let s_480_11: u32 = fn_state.u_30873;
        // D s_480_12: cast zx s_480_11 -> bv
        let s_480_12: Bits = Bits::new(s_480_11 as u128, 32u16);
        // D s_480_13: bit-extract s_480_12 s_480_9 s_480_10
        let s_480_13: Bits = (Bits::new(
            ((s_480_12) >> (s_480_9)).value(),
            u16::try_from(s_480_10).unwrap(),
        ));
        // D s_480_14: cast reint s_480_13 -> u8
        let s_480_14: u8 = (s_480_13.value() as u8);
        // C s_480_15: const #12s : i
        let s_480_15: i128 = 12;
        // C s_480_16: const #4s : i
        let s_480_16: i128 = 4;
        // D s_480_17: read-var u#30873:u32
        let s_480_17: u32 = fn_state.u_30873;
        // D s_480_18: cast zx s_480_17 -> bv
        let s_480_18: Bits = Bits::new(s_480_17 as u128, 32u16);
        // D s_480_19: bit-extract s_480_18 s_480_15 s_480_16
        let s_480_19: Bits = (Bits::new(
            ((s_480_18) >> (s_480_15)).value(),
            u16::try_from(s_480_16).unwrap(),
        ));
        // D s_480_20: cast reint s_480_19 -> u8
        let s_480_20: u8 = (s_480_19.value() as u8);
        // C s_480_21: const #7s : i
        let s_480_21: i128 = 7;
        // C s_480_22: const #2s : i
        let s_480_22: i128 = 2;
        // D s_480_23: read-var u#30873:u32
        let s_480_23: u32 = fn_state.u_30873;
        // D s_480_24: cast zx s_480_23 -> bv
        let s_480_24: Bits = Bits::new(s_480_23 as u128, 32u16);
        // D s_480_25: bit-extract s_480_24 s_480_21 s_480_22
        let s_480_25: Bits = (Bits::new(
            ((s_480_24) >> (s_480_21)).value(),
            u16::try_from(s_480_22).unwrap(),
        ));
        // D s_480_26: cast reint s_480_25 -> u8
        let s_480_26: u8 = (s_480_25.value() as u8);
        // C s_480_27: const #6s : i
        let s_480_27: i128 = 6;
        // C s_480_28: const #1s : i
        let s_480_28: i128 = 1;
        // D s_480_29: read-var u#30873:u32
        let s_480_29: u32 = fn_state.u_30873;
        // D s_480_30: cast zx s_480_29 -> bv
        let s_480_30: Bits = Bits::new(s_480_29 as u128, 32u16);
        // D s_480_31: bit-extract s_480_30 s_480_27 s_480_28
        let s_480_31: Bits = (Bits::new(
            ((s_480_30) >> (s_480_27)).value(),
            u16::try_from(s_480_28).unwrap(),
        ));
        // D s_480_32: cast reint s_480_31 -> u8
        let s_480_32: bool = ((s_480_31.value()) != 0);
        // C s_480_33: const #5s : i
        let s_480_33: i128 = 5;
        // C s_480_34: const #1s : i
        let s_480_34: i128 = 1;
        // D s_480_35: read-var u#30873:u32
        let s_480_35: u32 = fn_state.u_30873;
        // D s_480_36: cast zx s_480_35 -> bv
        let s_480_36: Bits = Bits::new(s_480_35 as u128, 32u16);
        // D s_480_37: bit-extract s_480_36 s_480_33 s_480_34
        let s_480_37: Bits = (Bits::new(
            ((s_480_36) >> (s_480_33)).value(),
            u16::try_from(s_480_34).unwrap(),
        ));
        // D s_480_38: cast reint s_480_37 -> u8
        let s_480_38: bool = ((s_480_37.value()) != 0);
        // C s_480_39: const #0s : i
        let s_480_39: i128 = 0;
        // C s_480_40: const #4s : i
        let s_480_40: i128 = 4;
        // D s_480_41: read-var u#30873:u32
        let s_480_41: u32 = fn_state.u_30873;
        // D s_480_42: cast zx s_480_41 -> bv
        let s_480_42: Bits = Bits::new(s_480_41 as u128, 32u16);
        // D s_480_43: bit-extract s_480_42 s_480_39 s_480_40
        let s_480_43: Bits = (Bits::new(
            ((s_480_42) >> (s_480_39)).value(),
            u16::try_from(s_480_40).unwrap(),
        ));
        // D s_480_44: cast reint s_480_43 -> u8
        let s_480_44: u8 = (s_480_43.value() as u8);
        // D s_480_45: call decode_aarch32_instrs_VCVT_is_A1enc_A_txt(s_480_8, s_480_14, s_480_20, s_480_26, s_480_32, s_480_38, s_480_44)
        let s_480_45: () = decode_aarch32_instrs_VCVT_is_A1enc_A_txt(
            state,
            tracer,
            s_480_8,
            s_480_14,
            s_480_20,
            s_480_26,
            s_480_32,
            s_480_38,
            s_480_44,
        );
        // N s_480_46: return
        return;
    }
    fn block_481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_481_0: read-var merge#var.1:struct
        let s_481_0: u32 = fn_state.merge_var._1;
        // D s_481_1: write-var u#30882 <= s_481_0
        fn_state.u_30882 = s_481_0;
        // C s_481_2: const #25s : i
        let s_481_2: i128 = 25;
        // D s_481_3: read-var u#30882:u32
        let s_481_3: u32 = fn_state.u_30882;
        // D s_481_4: cast zx s_481_3 -> bv
        let s_481_4: Bits = Bits::new(s_481_3 as u128, 32u16);
        // C s_481_5: const #1s : i64
        let s_481_5: i64 = 1;
        // C s_481_6: cast zx s_481_5 -> i
        let s_481_6: i128 = (i128::try_from(s_481_5).unwrap());
        // C s_481_7: const #6s : i
        let s_481_7: i128 = 6;
        // C s_481_8: add s_481_7 s_481_6
        let s_481_8: i128 = (s_481_7 + s_481_6);
        // D s_481_9: bit-extract s_481_4 s_481_2 s_481_8
        let s_481_9: Bits = (Bits::new(
            ((s_481_4) >> (s_481_2)).value(),
            u16::try_from(s_481_8).unwrap(),
        ));
        // D s_481_10: cast reint s_481_9 -> u8
        let s_481_10: u8 = (s_481_9.value() as u8);
        // D s_481_11: cast zx s_481_10 -> bv
        let s_481_11: Bits = Bits::new(s_481_10 as u128, 7u16);
        // C s_481_12: const #121u : u8
        let s_481_12: u8 = 121;
        // C s_481_13: cast zx s_481_12 -> bv
        let s_481_13: Bits = Bits::new(s_481_12 as u128, 7u16);
        // D s_481_14: cmp-eq s_481_11 s_481_13
        let s_481_14: bool = ((s_481_11) == (s_481_13));
        // N s_481_15: branch s_481_14 b2862 b482
        if s_481_14 {
            return block_2862(state, tracer, fn_state);
        } else {
            return block_482(state, tracer, fn_state);
        };
    }
    fn block_482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_482_0: const #0u : u8
        let s_482_0: bool = false;
        // D s_482_1: write-var gs#398898 <= s_482_0
        fn_state.gs_398898 = s_482_0;
        // N s_482_2: jump b483
        return block_483(state, tracer, fn_state);
    }
    fn block_483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_483_0: read-var gs#398898:u8
        let s_483_0: bool = fn_state.gs_398898;
        // N s_483_1: branch s_483_0 b2861 b484
        if s_483_0 {
            return block_2861(state, tracer, fn_state);
        } else {
            return block_484(state, tracer, fn_state);
        };
    }
    fn block_484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_484_0: const #0u : u8
        let s_484_0: bool = false;
        // D s_484_1: write-var gs#398900 <= s_484_0
        fn_state.gs_398900 = s_484_0;
        // N s_484_2: jump b485
        return block_485(state, tracer, fn_state);
    }
    fn block_485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_485_0: read-var gs#398900:u8
        let s_485_0: bool = fn_state.gs_398900;
        // D s_485_1: not s_485_0
        let s_485_1: bool = !s_485_0;
        // N s_485_2: branch s_485_1 b487 b486
        if s_485_1 {
            return block_487(state, tracer, fn_state);
        } else {
            return block_486(state, tracer, fn_state);
        };
    }
    fn block_486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_486_0: const #3428s : i
        let s_486_0: i128 = 3428;
        // C s_486_1: const #14696u : u32
        let s_486_1: u32 = 14696;
        // N s_486_2: write-reg s_486_1 <= s_486_0
        let s_486_2: () = {
            state.write_register::<i128>(s_486_1 as isize, s_486_0);
            tracer.write_register(s_486_1 as isize, s_486_0);
        };
        // C s_486_3: const #24s : i
        let s_486_3: i128 = 24;
        // C s_486_4: const #1s : i
        let s_486_4: i128 = 1;
        // D s_486_5: read-var u#30882:u32
        let s_486_5: u32 = fn_state.u_30882;
        // D s_486_6: cast zx s_486_5 -> bv
        let s_486_6: Bits = Bits::new(s_486_5 as u128, 32u16);
        // D s_486_7: bit-extract s_486_6 s_486_3 s_486_4
        let s_486_7: Bits = (Bits::new(
            ((s_486_6) >> (s_486_3)).value(),
            u16::try_from(s_486_4).unwrap(),
        ));
        // D s_486_8: cast reint s_486_7 -> u8
        let s_486_8: bool = ((s_486_7.value()) != 0);
        // C s_486_9: const #22s : i
        let s_486_9: i128 = 22;
        // C s_486_10: const #1s : i
        let s_486_10: i128 = 1;
        // D s_486_11: read-var u#30882:u32
        let s_486_11: u32 = fn_state.u_30882;
        // D s_486_12: cast zx s_486_11 -> bv
        let s_486_12: Bits = Bits::new(s_486_11 as u128, 32u16);
        // D s_486_13: bit-extract s_486_12 s_486_9 s_486_10
        let s_486_13: Bits = (Bits::new(
            ((s_486_12) >> (s_486_9)).value(),
            u16::try_from(s_486_10).unwrap(),
        ));
        // D s_486_14: cast reint s_486_13 -> u8
        let s_486_14: bool = ((s_486_13.value()) != 0);
        // C s_486_15: const #16s : i
        let s_486_15: i128 = 16;
        // C s_486_16: const #6s : i
        let s_486_16: i128 = 6;
        // D s_486_17: read-var u#30882:u32
        let s_486_17: u32 = fn_state.u_30882;
        // D s_486_18: cast zx s_486_17 -> bv
        let s_486_18: Bits = Bits::new(s_486_17 as u128, 32u16);
        // D s_486_19: bit-extract s_486_18 s_486_15 s_486_16
        let s_486_19: Bits = (Bits::new(
            ((s_486_18) >> (s_486_15)).value(),
            u16::try_from(s_486_16).unwrap(),
        ));
        // D s_486_20: cast reint s_486_19 -> u8
        let s_486_20: u8 = (s_486_19.value() as u8);
        // C s_486_21: const #12s : i
        let s_486_21: i128 = 12;
        // C s_486_22: const #4s : i
        let s_486_22: i128 = 4;
        // D s_486_23: read-var u#30882:u32
        let s_486_23: u32 = fn_state.u_30882;
        // D s_486_24: cast zx s_486_23 -> bv
        let s_486_24: Bits = Bits::new(s_486_23 as u128, 32u16);
        // D s_486_25: bit-extract s_486_24 s_486_21 s_486_22
        let s_486_25: Bits = (Bits::new(
            ((s_486_24) >> (s_486_21)).value(),
            u16::try_from(s_486_22).unwrap(),
        ));
        // D s_486_26: cast reint s_486_25 -> u8
        let s_486_26: u8 = (s_486_25.value() as u8);
        // C s_486_27: const #8s : i
        let s_486_27: i128 = 8;
        // C s_486_28: const #2s : i
        let s_486_28: i128 = 2;
        // D s_486_29: read-var u#30882:u32
        let s_486_29: u32 = fn_state.u_30882;
        // D s_486_30: cast zx s_486_29 -> bv
        let s_486_30: Bits = Bits::new(s_486_29 as u128, 32u16);
        // D s_486_31: bit-extract s_486_30 s_486_27 s_486_28
        let s_486_31: Bits = (Bits::new(
            ((s_486_30) >> (s_486_27)).value(),
            u16::try_from(s_486_28).unwrap(),
        ));
        // D s_486_32: cast reint s_486_31 -> u8
        let s_486_32: u8 = (s_486_31.value() as u8);
        // C s_486_33: const #6s : i
        let s_486_33: i128 = 6;
        // C s_486_34: const #1s : i
        let s_486_34: i128 = 1;
        // D s_486_35: read-var u#30882:u32
        let s_486_35: u32 = fn_state.u_30882;
        // D s_486_36: cast zx s_486_35 -> bv
        let s_486_36: Bits = Bits::new(s_486_35 as u128, 32u16);
        // D s_486_37: bit-extract s_486_36 s_486_33 s_486_34
        let s_486_37: Bits = (Bits::new(
            ((s_486_36) >> (s_486_33)).value(),
            u16::try_from(s_486_34).unwrap(),
        ));
        // D s_486_38: cast reint s_486_37 -> u8
        let s_486_38: bool = ((s_486_37.value()) != 0);
        // C s_486_39: const #5s : i
        let s_486_39: i128 = 5;
        // C s_486_40: const #1s : i
        let s_486_40: i128 = 1;
        // D s_486_41: read-var u#30882:u32
        let s_486_41: u32 = fn_state.u_30882;
        // D s_486_42: cast zx s_486_41 -> bv
        let s_486_42: Bits = Bits::new(s_486_41 as u128, 32u16);
        // D s_486_43: bit-extract s_486_42 s_486_39 s_486_40
        let s_486_43: Bits = (Bits::new(
            ((s_486_42) >> (s_486_39)).value(),
            u16::try_from(s_486_40).unwrap(),
        ));
        // D s_486_44: cast reint s_486_43 -> u8
        let s_486_44: bool = ((s_486_43.value()) != 0);
        // C s_486_45: const #0s : i
        let s_486_45: i128 = 0;
        // C s_486_46: const #4s : i
        let s_486_46: i128 = 4;
        // D s_486_47: read-var u#30882:u32
        let s_486_47: u32 = fn_state.u_30882;
        // D s_486_48: cast zx s_486_47 -> bv
        let s_486_48: Bits = Bits::new(s_486_47 as u128, 32u16);
        // D s_486_49: bit-extract s_486_48 s_486_45 s_486_46
        let s_486_49: Bits = (Bits::new(
            ((s_486_48) >> (s_486_45)).value(),
            u16::try_from(s_486_46).unwrap(),
        ));
        // D s_486_50: cast reint s_486_49 -> u8
        let s_486_50: u8 = (s_486_49.value() as u8);
        // D s_486_51: call decode_aarch32_instrs_VCVT_xs_A1enc_A_txt(s_486_8, s_486_14, s_486_20, s_486_26, s_486_32, s_486_38, s_486_44, s_486_50)
        let s_486_51: () = decode_aarch32_instrs_VCVT_xs_A1enc_A_txt(
            state,
            tracer,
            s_486_8,
            s_486_14,
            s_486_20,
            s_486_26,
            s_486_32,
            s_486_38,
            s_486_44,
            s_486_50,
        );
        // N s_486_52: return
        return;
    }
    fn block_487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_487_0: read-var merge#var.1:struct
        let s_487_0: u32 = fn_state.merge_var._1;
        // D s_487_1: write-var u#30891 <= s_487_0
        fn_state.u_30891 = s_487_0;
        // C s_487_2: const #23s : i
        let s_487_2: i128 = 23;
        // D s_487_3: read-var u#30891:u32
        let s_487_3: u32 = fn_state.u_30891;
        // D s_487_4: cast zx s_487_3 -> bv
        let s_487_4: Bits = Bits::new(s_487_3 as u128, 32u16);
        // C s_487_5: const #1s : i64
        let s_487_5: i64 = 1;
        // C s_487_6: cast zx s_487_5 -> i
        let s_487_6: i128 = (i128::try_from(s_487_5).unwrap());
        // C s_487_7: const #8s : i
        let s_487_7: i128 = 8;
        // C s_487_8: add s_487_7 s_487_6
        let s_487_8: i128 = (s_487_7 + s_487_6);
        // D s_487_9: bit-extract s_487_4 s_487_2 s_487_8
        let s_487_9: Bits = (Bits::new(
            ((s_487_4) >> (s_487_2)).value(),
            u16::try_from(s_487_8).unwrap(),
        ));
        // D s_487_10: cast reint s_487_9 -> u9
        let s_487_10: u16 = (s_487_9.value() as u16);
        // D s_487_11: cast zx s_487_10 -> bv
        let s_487_11: Bits = Bits::new(s_487_10 as u128, 9u16);
        // C s_487_12: const #487u : u9
        let s_487_12: u16 = 487;
        // C s_487_13: cast zx s_487_12 -> bv
        let s_487_13: Bits = Bits::new(s_487_12 as u128, 9u16);
        // D s_487_14: cmp-eq s_487_11 s_487_13
        let s_487_14: bool = ((s_487_11) == (s_487_13));
        // N s_487_15: branch s_487_14 b2854 b488
        if s_487_14 {
            return block_2854(state, tracer, fn_state);
        } else {
            return block_488(state, tracer, fn_state);
        };
    }
    fn block_488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_488_0: const #0u : u8
        let s_488_0: bool = false;
        // D s_488_1: write-var gs#398930 <= s_488_0
        fn_state.gs_398930 = s_488_0;
        // N s_488_2: jump b489
        return block_489(state, tracer, fn_state);
    }
    fn block_489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_489_0: read-var gs#398930:u8
        let s_489_0: bool = fn_state.gs_398930;
        // N s_489_1: branch s_489_0 b2853 b490
        if s_489_0 {
            return block_2853(state, tracer, fn_state);
        } else {
            return block_490(state, tracer, fn_state);
        };
    }
    fn block_490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_490_0: const #0u : u8
        let s_490_0: bool = false;
        // D s_490_1: write-var gs#398932 <= s_490_0
        fn_state.gs_398932 = s_490_0;
        // N s_490_2: jump b491
        return block_491(state, tracer, fn_state);
    }
    fn block_491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_491_0: read-var gs#398932:u8
        let s_491_0: bool = fn_state.gs_398932;
        // D s_491_1: not s_491_0
        let s_491_1: bool = !s_491_0;
        // N s_491_2: branch s_491_1 b493 b492
        if s_491_1 {
            return block_493(state, tracer, fn_state);
        } else {
            return block_492(state, tracer, fn_state);
        };
    }
    fn block_492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_492_0: const #3436s : i
        let s_492_0: i128 = 3436;
        // C s_492_1: const #14696u : u32
        let s_492_1: u32 = 14696;
        // N s_492_2: write-reg s_492_1 <= s_492_0
        let s_492_2: () = {
            state.write_register::<i128>(s_492_1 as isize, s_492_0);
            tracer.write_register(s_492_1 as isize, s_492_0);
        };
        // C s_492_3: const #22s : i
        let s_492_3: i128 = 22;
        // C s_492_4: const #1s : i
        let s_492_4: i128 = 1;
        // D s_492_5: read-var u#30891:u32
        let s_492_5: u32 = fn_state.u_30891;
        // D s_492_6: cast zx s_492_5 -> bv
        let s_492_6: Bits = Bits::new(s_492_5 as u128, 32u16);
        // D s_492_7: bit-extract s_492_6 s_492_3 s_492_4
        let s_492_7: Bits = (Bits::new(
            ((s_492_6) >> (s_492_3)).value(),
            u16::try_from(s_492_4).unwrap(),
        ));
        // D s_492_8: cast reint s_492_7 -> u8
        let s_492_8: bool = ((s_492_7.value()) != 0);
        // C s_492_9: const #16s : i
        let s_492_9: i128 = 16;
        // C s_492_10: const #4s : i
        let s_492_10: i128 = 4;
        // D s_492_11: read-var u#30891:u32
        let s_492_11: u32 = fn_state.u_30891;
        // D s_492_12: cast zx s_492_11 -> bv
        let s_492_12: Bits = Bits::new(s_492_11 as u128, 32u16);
        // D s_492_13: bit-extract s_492_12 s_492_9 s_492_10
        let s_492_13: Bits = (Bits::new(
            ((s_492_12) >> (s_492_9)).value(),
            u16::try_from(s_492_10).unwrap(),
        ));
        // D s_492_14: cast reint s_492_13 -> u8
        let s_492_14: u8 = (s_492_13.value() as u8);
        // C s_492_15: const #12s : i
        let s_492_15: i128 = 12;
        // C s_492_16: const #4s : i
        let s_492_16: i128 = 4;
        // D s_492_17: read-var u#30891:u32
        let s_492_17: u32 = fn_state.u_30891;
        // D s_492_18: cast zx s_492_17 -> bv
        let s_492_18: Bits = Bits::new(s_492_17 as u128, 32u16);
        // D s_492_19: bit-extract s_492_18 s_492_15 s_492_16
        let s_492_19: Bits = (Bits::new(
            ((s_492_18) >> (s_492_15)).value(),
            u16::try_from(s_492_16).unwrap(),
        ));
        // D s_492_20: cast reint s_492_19 -> u8
        let s_492_20: u8 = (s_492_19.value() as u8);
        // C s_492_21: const #6s : i
        let s_492_21: i128 = 6;
        // C s_492_22: const #1s : i
        let s_492_22: i128 = 1;
        // D s_492_23: read-var u#30891:u32
        let s_492_23: u32 = fn_state.u_30891;
        // D s_492_24: cast zx s_492_23 -> bv
        let s_492_24: Bits = Bits::new(s_492_23 as u128, 32u16);
        // D s_492_25: bit-extract s_492_24 s_492_21 s_492_22
        let s_492_25: Bits = (Bits::new(
            ((s_492_24) >> (s_492_21)).value(),
            u16::try_from(s_492_22).unwrap(),
        ));
        // D s_492_26: cast reint s_492_25 -> u8
        let s_492_26: bool = ((s_492_25.value()) != 0);
        // C s_492_27: const #5s : i
        let s_492_27: i128 = 5;
        // C s_492_28: const #1s : i
        let s_492_28: i128 = 1;
        // D s_492_29: read-var u#30891:u32
        let s_492_29: u32 = fn_state.u_30891;
        // D s_492_30: cast zx s_492_29 -> bv
        let s_492_30: Bits = Bits::new(s_492_29 as u128, 32u16);
        // D s_492_31: bit-extract s_492_30 s_492_27 s_492_28
        let s_492_31: Bits = (Bits::new(
            ((s_492_30) >> (s_492_27)).value(),
            u16::try_from(s_492_28).unwrap(),
        ));
        // D s_492_32: cast reint s_492_31 -> u8
        let s_492_32: bool = ((s_492_31.value()) != 0);
        // C s_492_33: const #0s : i
        let s_492_33: i128 = 0;
        // C s_492_34: const #4s : i
        let s_492_34: i128 = 4;
        // D s_492_35: read-var u#30891:u32
        let s_492_35: u32 = fn_state.u_30891;
        // D s_492_36: cast zx s_492_35 -> bv
        let s_492_36: Bits = Bits::new(s_492_35 as u128, 32u16);
        // D s_492_37: bit-extract s_492_36 s_492_33 s_492_34
        let s_492_37: Bits = (Bits::new(
            ((s_492_36) >> (s_492_33)).value(),
            u16::try_from(s_492_34).unwrap(),
        ));
        // D s_492_38: cast reint s_492_37 -> u8
        let s_492_38: u8 = (s_492_37.value() as u8);
        // D s_492_39: call decode_aarch32_instrs_VDUP_s_A1enc_A_txt(s_492_8, s_492_14, s_492_20, s_492_26, s_492_32, s_492_38)
        let s_492_39: () = decode_aarch32_instrs_VDUP_s_A1enc_A_txt(
            state,
            tracer,
            s_492_8,
            s_492_14,
            s_492_20,
            s_492_26,
            s_492_32,
            s_492_38,
        );
        // N s_492_40: return
        return;
    }
    fn block_493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_493_0: read-var merge#var.1:struct
        let s_493_0: u32 = fn_state.merge_var._1;
        // D s_493_1: write-var u#30899 <= s_493_0
        fn_state.u_30899 = s_493_0;
        // C s_493_2: const #23s : i
        let s_493_2: i128 = 23;
        // D s_493_3: read-var u#30899:u32
        let s_493_3: u32 = fn_state.u_30899;
        // D s_493_4: cast zx s_493_3 -> bv
        let s_493_4: Bits = Bits::new(s_493_3 as u128, 32u16);
        // C s_493_5: const #1s : i64
        let s_493_5: i64 = 1;
        // C s_493_6: cast zx s_493_5 -> i
        let s_493_6: i128 = (i128::try_from(s_493_5).unwrap());
        // C s_493_7: const #8s : i
        let s_493_7: i128 = 8;
        // C s_493_8: add s_493_7 s_493_6
        let s_493_8: i128 = (s_493_7 + s_493_6);
        // D s_493_9: bit-extract s_493_4 s_493_2 s_493_8
        let s_493_9: Bits = (Bits::new(
            ((s_493_4) >> (s_493_2)).value(),
            u16::try_from(s_493_8).unwrap(),
        ));
        // D s_493_10: cast reint s_493_9 -> u9
        let s_493_10: u16 = (s_493_9.value() as u16);
        // D s_493_11: cast zx s_493_10 -> bv
        let s_493_11: Bits = Bits::new(s_493_10 as u128, 9u16);
        // C s_493_12: const #486u : u9
        let s_493_12: u16 = 486;
        // C s_493_13: cast zx s_493_12 -> bv
        let s_493_13: Bits = Bits::new(s_493_12 as u128, 9u16);
        // D s_493_14: cmp-eq s_493_11 s_493_13
        let s_493_14: bool = ((s_493_11) == (s_493_13));
        // N s_493_15: branch s_493_14 b2846 b494
        if s_493_14 {
            return block_2846(state, tracer, fn_state);
        } else {
            return block_494(state, tracer, fn_state);
        };
    }
    fn block_494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_494_0: const #0u : u8
        let s_494_0: bool = false;
        // D s_494_1: write-var gs#398958 <= s_494_0
        fn_state.gs_398958 = s_494_0;
        // N s_494_2: jump b495
        return block_495(state, tracer, fn_state);
    }
    fn block_495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_495_0: read-var gs#398958:u8
        let s_495_0: bool = fn_state.gs_398958;
        // N s_495_1: branch s_495_0 b2845 b496
        if s_495_0 {
            return block_2845(state, tracer, fn_state);
        } else {
            return block_496(state, tracer, fn_state);
        };
    }
    fn block_496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_496_0: const #0u : u8
        let s_496_0: bool = false;
        // D s_496_1: write-var gs#398960 <= s_496_0
        fn_state.gs_398960 = s_496_0;
        // N s_496_2: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_497_0: read-var gs#398960:u8
        let s_497_0: bool = fn_state.gs_398960;
        // D s_497_1: not s_497_0
        let s_497_1: bool = !s_497_0;
        // N s_497_2: branch s_497_1 b499 b498
        if s_497_1 {
            return block_499(state, tracer, fn_state);
        } else {
            return block_498(state, tracer, fn_state);
        };
    }
    fn block_498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_498_0: const #3438s : i
        let s_498_0: i128 = 3438;
        // C s_498_1: const #14696u : u32
        let s_498_1: u32 = 14696;
        // N s_498_2: write-reg s_498_1 <= s_498_0
        let s_498_2: () = {
            state.write_register::<i128>(s_498_1 as isize, s_498_0);
            tracer.write_register(s_498_1 as isize, s_498_0);
        };
        // C s_498_3: const #22s : i
        let s_498_3: i128 = 22;
        // C s_498_4: const #1s : i
        let s_498_4: i128 = 1;
        // D s_498_5: read-var u#30899:u32
        let s_498_5: u32 = fn_state.u_30899;
        // D s_498_6: cast zx s_498_5 -> bv
        let s_498_6: Bits = Bits::new(s_498_5 as u128, 32u16);
        // D s_498_7: bit-extract s_498_6 s_498_3 s_498_4
        let s_498_7: Bits = (Bits::new(
            ((s_498_6) >> (s_498_3)).value(),
            u16::try_from(s_498_4).unwrap(),
        ));
        // D s_498_8: cast reint s_498_7 -> u8
        let s_498_8: bool = ((s_498_7.value()) != 0);
        // C s_498_9: const #16s : i
        let s_498_9: i128 = 16;
        // C s_498_10: const #4s : i
        let s_498_10: i128 = 4;
        // D s_498_11: read-var u#30899:u32
        let s_498_11: u32 = fn_state.u_30899;
        // D s_498_12: cast zx s_498_11 -> bv
        let s_498_12: Bits = Bits::new(s_498_11 as u128, 32u16);
        // D s_498_13: bit-extract s_498_12 s_498_9 s_498_10
        let s_498_13: Bits = (Bits::new(
            ((s_498_12) >> (s_498_9)).value(),
            u16::try_from(s_498_10).unwrap(),
        ));
        // D s_498_14: cast reint s_498_13 -> u8
        let s_498_14: u8 = (s_498_13.value() as u8);
        // C s_498_15: const #12s : i
        let s_498_15: i128 = 12;
        // C s_498_16: const #4s : i
        let s_498_16: i128 = 4;
        // D s_498_17: read-var u#30899:u32
        let s_498_17: u32 = fn_state.u_30899;
        // D s_498_18: cast zx s_498_17 -> bv
        let s_498_18: Bits = Bits::new(s_498_17 as u128, 32u16);
        // D s_498_19: bit-extract s_498_18 s_498_15 s_498_16
        let s_498_19: Bits = (Bits::new(
            ((s_498_18) >> (s_498_15)).value(),
            u16::try_from(s_498_16).unwrap(),
        ));
        // D s_498_20: cast reint s_498_19 -> u8
        let s_498_20: u8 = (s_498_19.value() as u8);
        // C s_498_21: const #7s : i
        let s_498_21: i128 = 7;
        // C s_498_22: const #1s : i
        let s_498_22: i128 = 1;
        // D s_498_23: read-var u#30899:u32
        let s_498_23: u32 = fn_state.u_30899;
        // D s_498_24: cast zx s_498_23 -> bv
        let s_498_24: Bits = Bits::new(s_498_23 as u128, 32u16);
        // D s_498_25: bit-extract s_498_24 s_498_21 s_498_22
        let s_498_25: Bits = (Bits::new(
            ((s_498_24) >> (s_498_21)).value(),
            u16::try_from(s_498_22).unwrap(),
        ));
        // D s_498_26: cast reint s_498_25 -> u8
        let s_498_26: bool = ((s_498_25.value()) != 0);
        // C s_498_27: const #6s : i
        let s_498_27: i128 = 6;
        // C s_498_28: const #1s : i
        let s_498_28: i128 = 1;
        // D s_498_29: read-var u#30899:u32
        let s_498_29: u32 = fn_state.u_30899;
        // D s_498_30: cast zx s_498_29 -> bv
        let s_498_30: Bits = Bits::new(s_498_29 as u128, 32u16);
        // D s_498_31: bit-extract s_498_30 s_498_27 s_498_28
        let s_498_31: Bits = (Bits::new(
            ((s_498_30) >> (s_498_27)).value(),
            u16::try_from(s_498_28).unwrap(),
        ));
        // D s_498_32: cast reint s_498_31 -> u8
        let s_498_32: bool = ((s_498_31.value()) != 0);
        // C s_498_33: const #5s : i
        let s_498_33: i128 = 5;
        // C s_498_34: const #1s : i
        let s_498_34: i128 = 1;
        // D s_498_35: read-var u#30899:u32
        let s_498_35: u32 = fn_state.u_30899;
        // D s_498_36: cast zx s_498_35 -> bv
        let s_498_36: Bits = Bits::new(s_498_35 as u128, 32u16);
        // D s_498_37: bit-extract s_498_36 s_498_33 s_498_34
        let s_498_37: Bits = (Bits::new(
            ((s_498_36) >> (s_498_33)).value(),
            u16::try_from(s_498_34).unwrap(),
        ));
        // D s_498_38: cast reint s_498_37 -> u8
        let s_498_38: bool = ((s_498_37.value()) != 0);
        // C s_498_39: const #0s : i
        let s_498_39: i128 = 0;
        // C s_498_40: const #4s : i
        let s_498_40: i128 = 4;
        // D s_498_41: read-var u#30899:u32
        let s_498_41: u32 = fn_state.u_30899;
        // D s_498_42: cast zx s_498_41 -> bv
        let s_498_42: Bits = Bits::new(s_498_41 as u128, 32u16);
        // D s_498_43: bit-extract s_498_42 s_498_39 s_498_40
        let s_498_43: Bits = (Bits::new(
            ((s_498_42) >> (s_498_39)).value(),
            u16::try_from(s_498_40).unwrap(),
        ));
        // D s_498_44: cast reint s_498_43 -> u8
        let s_498_44: u8 = (s_498_43.value() as u8);
        // D s_498_45: call decode_aarch32_instrs_VEOR_A1enc_A_txt(s_498_8, s_498_14, s_498_20, s_498_26, s_498_32, s_498_38, s_498_44)
        let s_498_45: () = decode_aarch32_instrs_VEOR_A1enc_A_txt(
            state,
            tracer,
            s_498_8,
            s_498_14,
            s_498_20,
            s_498_26,
            s_498_32,
            s_498_38,
            s_498_44,
        );
        // N s_498_46: return
        return;
    }
    fn block_499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_499_0: read-var merge#var.1:struct
        let s_499_0: u32 = fn_state.merge_var._1;
        // D s_499_1: write-var u#30908 <= s_499_0
        fn_state.u_30908 = s_499_0;
        // C s_499_2: const #23s : i
        let s_499_2: i128 = 23;
        // D s_499_3: read-var u#30908:u32
        let s_499_3: u32 = fn_state.u_30908;
        // D s_499_4: cast zx s_499_3 -> bv
        let s_499_4: Bits = Bits::new(s_499_3 as u128, 32u16);
        // C s_499_5: const #1s : i64
        let s_499_5: i64 = 1;
        // C s_499_6: cast zx s_499_5 -> i
        let s_499_6: i128 = (i128::try_from(s_499_5).unwrap());
        // C s_499_7: const #8s : i
        let s_499_7: i128 = 8;
        // C s_499_8: add s_499_7 s_499_6
        let s_499_8: i128 = (s_499_7 + s_499_6);
        // D s_499_9: bit-extract s_499_4 s_499_2 s_499_8
        let s_499_9: Bits = (Bits::new(
            ((s_499_4) >> (s_499_2)).value(),
            u16::try_from(s_499_8).unwrap(),
        ));
        // D s_499_10: cast reint s_499_9 -> u9
        let s_499_10: u16 = (s_499_9.value() as u16);
        // D s_499_11: cast zx s_499_10 -> bv
        let s_499_11: Bits = Bits::new(s_499_10 as u128, 9u16);
        // C s_499_12: const #485u : u9
        let s_499_12: u16 = 485;
        // C s_499_13: cast zx s_499_12 -> bv
        let s_499_13: Bits = Bits::new(s_499_12 as u128, 9u16);
        // D s_499_14: cmp-eq s_499_11 s_499_13
        let s_499_14: bool = ((s_499_11) == (s_499_13));
        // N s_499_15: branch s_499_14 b2841 b500
        if s_499_14 {
            return block_2841(state, tracer, fn_state);
        } else {
            return block_500(state, tracer, fn_state);
        };
    }
    fn block_500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_500_0: const #0u : u8
        let s_500_0: bool = false;
        // D s_500_1: write-var gs#398985 <= s_500_0
        fn_state.gs_398985 = s_500_0;
        // N s_500_2: jump b501
        return block_501(state, tracer, fn_state);
    }
    fn block_501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_501_0: read-var gs#398985:u8
        let s_501_0: bool = fn_state.gs_398985;
        // N s_501_1: branch s_501_0 b2840 b502
        if s_501_0 {
            return block_2840(state, tracer, fn_state);
        } else {
            return block_502(state, tracer, fn_state);
        };
    }
    fn block_502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_502_0: const #0u : u8
        let s_502_0: bool = false;
        // D s_502_1: write-var gs#398987 <= s_502_0
        fn_state.gs_398987 = s_502_0;
        // N s_502_2: jump b503
        return block_503(state, tracer, fn_state);
    }
    fn block_503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_503_0: read-var gs#398987:u8
        let s_503_0: bool = fn_state.gs_398987;
        // D s_503_1: not s_503_0
        let s_503_1: bool = !s_503_0;
        // N s_503_2: branch s_503_1 b505 b504
        if s_503_1 {
            return block_505(state, tracer, fn_state);
        } else {
            return block_504(state, tracer, fn_state);
        };
    }
    fn block_504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_504_0: const #3440s : i
        let s_504_0: i128 = 3440;
        // C s_504_1: const #14696u : u32
        let s_504_1: u32 = 14696;
        // N s_504_2: write-reg s_504_1 <= s_504_0
        let s_504_2: () = {
            state.write_register::<i128>(s_504_1 as isize, s_504_0);
            tracer.write_register(s_504_1 as isize, s_504_0);
        };
        // C s_504_3: const #22s : i
        let s_504_3: i128 = 22;
        // C s_504_4: const #1s : i
        let s_504_4: i128 = 1;
        // D s_504_5: read-var u#30908:u32
        let s_504_5: u32 = fn_state.u_30908;
        // D s_504_6: cast zx s_504_5 -> bv
        let s_504_6: Bits = Bits::new(s_504_5 as u128, 32u16);
        // D s_504_7: bit-extract s_504_6 s_504_3 s_504_4
        let s_504_7: Bits = (Bits::new(
            ((s_504_6) >> (s_504_3)).value(),
            u16::try_from(s_504_4).unwrap(),
        ));
        // D s_504_8: cast reint s_504_7 -> u8
        let s_504_8: bool = ((s_504_7.value()) != 0);
        // C s_504_9: const #16s : i
        let s_504_9: i128 = 16;
        // C s_504_10: const #4s : i
        let s_504_10: i128 = 4;
        // D s_504_11: read-var u#30908:u32
        let s_504_11: u32 = fn_state.u_30908;
        // D s_504_12: cast zx s_504_11 -> bv
        let s_504_12: Bits = Bits::new(s_504_11 as u128, 32u16);
        // D s_504_13: bit-extract s_504_12 s_504_9 s_504_10
        let s_504_13: Bits = (Bits::new(
            ((s_504_12) >> (s_504_9)).value(),
            u16::try_from(s_504_10).unwrap(),
        ));
        // D s_504_14: cast reint s_504_13 -> u8
        let s_504_14: u8 = (s_504_13.value() as u8);
        // C s_504_15: const #12s : i
        let s_504_15: i128 = 12;
        // C s_504_16: const #4s : i
        let s_504_16: i128 = 4;
        // D s_504_17: read-var u#30908:u32
        let s_504_17: u32 = fn_state.u_30908;
        // D s_504_18: cast zx s_504_17 -> bv
        let s_504_18: Bits = Bits::new(s_504_17 as u128, 32u16);
        // D s_504_19: bit-extract s_504_18 s_504_15 s_504_16
        let s_504_19: Bits = (Bits::new(
            ((s_504_18) >> (s_504_15)).value(),
            u16::try_from(s_504_16).unwrap(),
        ));
        // D s_504_20: cast reint s_504_19 -> u8
        let s_504_20: u8 = (s_504_19.value() as u8);
        // C s_504_21: const #8s : i
        let s_504_21: i128 = 8;
        // C s_504_22: const #4s : i
        let s_504_22: i128 = 4;
        // D s_504_23: read-var u#30908:u32
        let s_504_23: u32 = fn_state.u_30908;
        // D s_504_24: cast zx s_504_23 -> bv
        let s_504_24: Bits = Bits::new(s_504_23 as u128, 32u16);
        // D s_504_25: bit-extract s_504_24 s_504_21 s_504_22
        let s_504_25: Bits = (Bits::new(
            ((s_504_24) >> (s_504_21)).value(),
            u16::try_from(s_504_22).unwrap(),
        ));
        // D s_504_26: cast reint s_504_25 -> u8
        let s_504_26: u8 = (s_504_25.value() as u8);
        // C s_504_27: const #7s : i
        let s_504_27: i128 = 7;
        // C s_504_28: const #1s : i
        let s_504_28: i128 = 1;
        // D s_504_29: read-var u#30908:u32
        let s_504_29: u32 = fn_state.u_30908;
        // D s_504_30: cast zx s_504_29 -> bv
        let s_504_30: Bits = Bits::new(s_504_29 as u128, 32u16);
        // D s_504_31: bit-extract s_504_30 s_504_27 s_504_28
        let s_504_31: Bits = (Bits::new(
            ((s_504_30) >> (s_504_27)).value(),
            u16::try_from(s_504_28).unwrap(),
        ));
        // D s_504_32: cast reint s_504_31 -> u8
        let s_504_32: bool = ((s_504_31.value()) != 0);
        // C s_504_33: const #6s : i
        let s_504_33: i128 = 6;
        // C s_504_34: const #1s : i
        let s_504_34: i128 = 1;
        // D s_504_35: read-var u#30908:u32
        let s_504_35: u32 = fn_state.u_30908;
        // D s_504_36: cast zx s_504_35 -> bv
        let s_504_36: Bits = Bits::new(s_504_35 as u128, 32u16);
        // D s_504_37: bit-extract s_504_36 s_504_33 s_504_34
        let s_504_37: Bits = (Bits::new(
            ((s_504_36) >> (s_504_33)).value(),
            u16::try_from(s_504_34).unwrap(),
        ));
        // D s_504_38: cast reint s_504_37 -> u8
        let s_504_38: bool = ((s_504_37.value()) != 0);
        // C s_504_39: const #5s : i
        let s_504_39: i128 = 5;
        // C s_504_40: const #1s : i
        let s_504_40: i128 = 1;
        // D s_504_41: read-var u#30908:u32
        let s_504_41: u32 = fn_state.u_30908;
        // D s_504_42: cast zx s_504_41 -> bv
        let s_504_42: Bits = Bits::new(s_504_41 as u128, 32u16);
        // D s_504_43: bit-extract s_504_42 s_504_39 s_504_40
        let s_504_43: Bits = (Bits::new(
            ((s_504_42) >> (s_504_39)).value(),
            u16::try_from(s_504_40).unwrap(),
        ));
        // D s_504_44: cast reint s_504_43 -> u8
        let s_504_44: bool = ((s_504_43.value()) != 0);
        // C s_504_45: const #0s : i
        let s_504_45: i128 = 0;
        // C s_504_46: const #4s : i
        let s_504_46: i128 = 4;
        // D s_504_47: read-var u#30908:u32
        let s_504_47: u32 = fn_state.u_30908;
        // D s_504_48: cast zx s_504_47 -> bv
        let s_504_48: Bits = Bits::new(s_504_47 as u128, 32u16);
        // D s_504_49: bit-extract s_504_48 s_504_45 s_504_46
        let s_504_49: Bits = (Bits::new(
            ((s_504_48) >> (s_504_45)).value(),
            u16::try_from(s_504_46).unwrap(),
        ));
        // D s_504_50: cast reint s_504_49 -> u8
        let s_504_50: u8 = (s_504_49.value() as u8);
        // D s_504_51: call decode_aarch32_instrs_VEXT_A1enc_A_txt(s_504_8, s_504_14, s_504_20, s_504_26, s_504_32, s_504_38, s_504_44, s_504_50)
        let s_504_51: () = decode_aarch32_instrs_VEXT_A1enc_A_txt(
            state,
            tracer,
            s_504_8,
            s_504_14,
            s_504_20,
            s_504_26,
            s_504_32,
            s_504_38,
            s_504_44,
            s_504_50,
        );
        // N s_504_52: return
        return;
    }
    fn block_505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_505_0: read-var merge#var.1:struct
        let s_505_0: u32 = fn_state.merge_var._1;
        // D s_505_1: write-var u#30918 <= s_505_0
        fn_state.u_30918 = s_505_0;
        // C s_505_2: const #23s : i
        let s_505_2: i128 = 23;
        // D s_505_3: read-var u#30918:u32
        let s_505_3: u32 = fn_state.u_30918;
        // D s_505_4: cast zx s_505_3 -> bv
        let s_505_4: Bits = Bits::new(s_505_3 as u128, 32u16);
        // C s_505_5: const #1s : i64
        let s_505_5: i64 = 1;
        // C s_505_6: cast zx s_505_5 -> i
        let s_505_6: i128 = (i128::try_from(s_505_5).unwrap());
        // C s_505_7: const #8s : i
        let s_505_7: i128 = 8;
        // C s_505_8: add s_505_7 s_505_6
        let s_505_8: i128 = (s_505_7 + s_505_6);
        // D s_505_9: bit-extract s_505_4 s_505_2 s_505_8
        let s_505_9: Bits = (Bits::new(
            ((s_505_4) >> (s_505_2)).value(),
            u16::try_from(s_505_8).unwrap(),
        ));
        // D s_505_10: cast reint s_505_9 -> u9
        let s_505_10: u16 = (s_505_9.value() as u16);
        // D s_505_11: cast zx s_505_10 -> bv
        let s_505_11: Bits = Bits::new(s_505_10 as u128, 9u16);
        // C s_505_12: const #484u : u9
        let s_505_12: u16 = 484;
        // C s_505_13: cast zx s_505_12 -> bv
        let s_505_13: Bits = Bits::new(s_505_12 as u128, 9u16);
        // D s_505_14: cmp-eq s_505_11 s_505_13
        let s_505_14: bool = ((s_505_11) == (s_505_13));
        // N s_505_15: branch s_505_14 b2836 b506
        if s_505_14 {
            return block_2836(state, tracer, fn_state);
        } else {
            return block_506(state, tracer, fn_state);
        };
    }
    fn block_506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_506_0: const #0u : u8
        let s_506_0: bool = false;
        // D s_506_1: write-var gs#399014 <= s_506_0
        fn_state.gs_399014 = s_506_0;
        // N s_506_2: jump b507
        return block_507(state, tracer, fn_state);
    }
    fn block_507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_507_0: read-var gs#399014:u8
        let s_507_0: bool = fn_state.gs_399014;
        // N s_507_1: branch s_507_0 b2835 b508
        if s_507_0 {
            return block_2835(state, tracer, fn_state);
        } else {
            return block_508(state, tracer, fn_state);
        };
    }
    fn block_508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_508_0: const #0u : u8
        let s_508_0: bool = false;
        // D s_508_1: write-var gs#399016 <= s_508_0
        fn_state.gs_399016 = s_508_0;
        // N s_508_2: jump b509
        return block_509(state, tracer, fn_state);
    }
    fn block_509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_509_0: read-var gs#399016:u8
        let s_509_0: bool = fn_state.gs_399016;
        // D s_509_1: not s_509_0
        let s_509_1: bool = !s_509_0;
        // N s_509_2: branch s_509_1 b511 b510
        if s_509_1 {
            return block_511(state, tracer, fn_state);
        } else {
            return block_510(state, tracer, fn_state);
        };
    }
    fn block_510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_510_0: const #3442s : i
        let s_510_0: i128 = 3442;
        // C s_510_1: const #14696u : u32
        let s_510_1: u32 = 14696;
        // N s_510_2: write-reg s_510_1 <= s_510_0
        let s_510_2: () = {
            state.write_register::<i128>(s_510_1 as isize, s_510_0);
            tracer.write_register(s_510_1 as isize, s_510_0);
        };
        // C s_510_3: const #22s : i
        let s_510_3: i128 = 22;
        // C s_510_4: const #1s : i
        let s_510_4: i128 = 1;
        // D s_510_5: read-var u#30918:u32
        let s_510_5: u32 = fn_state.u_30918;
        // D s_510_6: cast zx s_510_5 -> bv
        let s_510_6: Bits = Bits::new(s_510_5 as u128, 32u16);
        // D s_510_7: bit-extract s_510_6 s_510_3 s_510_4
        let s_510_7: Bits = (Bits::new(
            ((s_510_6) >> (s_510_3)).value(),
            u16::try_from(s_510_4).unwrap(),
        ));
        // D s_510_8: cast reint s_510_7 -> u8
        let s_510_8: bool = ((s_510_7.value()) != 0);
        // C s_510_9: const #21s : i
        let s_510_9: i128 = 21;
        // C s_510_10: const #1s : i
        let s_510_10: i128 = 1;
        // D s_510_11: read-var u#30918:u32
        let s_510_11: u32 = fn_state.u_30918;
        // D s_510_12: cast zx s_510_11 -> bv
        let s_510_12: Bits = Bits::new(s_510_11 as u128, 32u16);
        // D s_510_13: bit-extract s_510_12 s_510_9 s_510_10
        let s_510_13: Bits = (Bits::new(
            ((s_510_12) >> (s_510_9)).value(),
            u16::try_from(s_510_10).unwrap(),
        ));
        // D s_510_14: cast reint s_510_13 -> u8
        let s_510_14: bool = ((s_510_13.value()) != 0);
        // C s_510_15: const #20s : i
        let s_510_15: i128 = 20;
        // C s_510_16: const #1s : i
        let s_510_16: i128 = 1;
        // D s_510_17: read-var u#30918:u32
        let s_510_17: u32 = fn_state.u_30918;
        // D s_510_18: cast zx s_510_17 -> bv
        let s_510_18: Bits = Bits::new(s_510_17 as u128, 32u16);
        // D s_510_19: bit-extract s_510_18 s_510_15 s_510_16
        let s_510_19: Bits = (Bits::new(
            ((s_510_18) >> (s_510_15)).value(),
            u16::try_from(s_510_16).unwrap(),
        ));
        // D s_510_20: cast reint s_510_19 -> u8
        let s_510_20: bool = ((s_510_19.value()) != 0);
        // C s_510_21: const #16s : i
        let s_510_21: i128 = 16;
        // C s_510_22: const #4s : i
        let s_510_22: i128 = 4;
        // D s_510_23: read-var u#30918:u32
        let s_510_23: u32 = fn_state.u_30918;
        // D s_510_24: cast zx s_510_23 -> bv
        let s_510_24: Bits = Bits::new(s_510_23 as u128, 32u16);
        // D s_510_25: bit-extract s_510_24 s_510_21 s_510_22
        let s_510_25: Bits = (Bits::new(
            ((s_510_24) >> (s_510_21)).value(),
            u16::try_from(s_510_22).unwrap(),
        ));
        // D s_510_26: cast reint s_510_25 -> u8
        let s_510_26: u8 = (s_510_25.value() as u8);
        // C s_510_27: const #12s : i
        let s_510_27: i128 = 12;
        // C s_510_28: const #4s : i
        let s_510_28: i128 = 4;
        // D s_510_29: read-var u#30918:u32
        let s_510_29: u32 = fn_state.u_30918;
        // D s_510_30: cast zx s_510_29 -> bv
        let s_510_30: Bits = Bits::new(s_510_29 as u128, 32u16);
        // D s_510_31: bit-extract s_510_30 s_510_27 s_510_28
        let s_510_31: Bits = (Bits::new(
            ((s_510_30) >> (s_510_27)).value(),
            u16::try_from(s_510_28).unwrap(),
        ));
        // D s_510_32: cast reint s_510_31 -> u8
        let s_510_32: u8 = (s_510_31.value() as u8);
        // C s_510_33: const #7s : i
        let s_510_33: i128 = 7;
        // C s_510_34: const #1s : i
        let s_510_34: i128 = 1;
        // D s_510_35: read-var u#30918:u32
        let s_510_35: u32 = fn_state.u_30918;
        // D s_510_36: cast zx s_510_35 -> bv
        let s_510_36: Bits = Bits::new(s_510_35 as u128, 32u16);
        // D s_510_37: bit-extract s_510_36 s_510_33 s_510_34
        let s_510_37: Bits = (Bits::new(
            ((s_510_36) >> (s_510_33)).value(),
            u16::try_from(s_510_34).unwrap(),
        ));
        // D s_510_38: cast reint s_510_37 -> u8
        let s_510_38: bool = ((s_510_37.value()) != 0);
        // C s_510_39: const #6s : i
        let s_510_39: i128 = 6;
        // C s_510_40: const #1s : i
        let s_510_40: i128 = 1;
        // D s_510_41: read-var u#30918:u32
        let s_510_41: u32 = fn_state.u_30918;
        // D s_510_42: cast zx s_510_41 -> bv
        let s_510_42: Bits = Bits::new(s_510_41 as u128, 32u16);
        // D s_510_43: bit-extract s_510_42 s_510_39 s_510_40
        let s_510_43: Bits = (Bits::new(
            ((s_510_42) >> (s_510_39)).value(),
            u16::try_from(s_510_40).unwrap(),
        ));
        // D s_510_44: cast reint s_510_43 -> u8
        let s_510_44: bool = ((s_510_43.value()) != 0);
        // C s_510_45: const #5s : i
        let s_510_45: i128 = 5;
        // C s_510_46: const #1s : i
        let s_510_46: i128 = 1;
        // D s_510_47: read-var u#30918:u32
        let s_510_47: u32 = fn_state.u_30918;
        // D s_510_48: cast zx s_510_47 -> bv
        let s_510_48: Bits = Bits::new(s_510_47 as u128, 32u16);
        // D s_510_49: bit-extract s_510_48 s_510_45 s_510_46
        let s_510_49: Bits = (Bits::new(
            ((s_510_48) >> (s_510_45)).value(),
            u16::try_from(s_510_46).unwrap(),
        ));
        // D s_510_50: cast reint s_510_49 -> u8
        let s_510_50: bool = ((s_510_49.value()) != 0);
        // C s_510_51: const #0s : i
        let s_510_51: i128 = 0;
        // C s_510_52: const #4s : i
        let s_510_52: i128 = 4;
        // D s_510_53: read-var u#30918:u32
        let s_510_53: u32 = fn_state.u_30918;
        // D s_510_54: cast zx s_510_53 -> bv
        let s_510_54: Bits = Bits::new(s_510_53 as u128, 32u16);
        // D s_510_55: bit-extract s_510_54 s_510_51 s_510_52
        let s_510_55: Bits = (Bits::new(
            ((s_510_54) >> (s_510_51)).value(),
            u16::try_from(s_510_52).unwrap(),
        ));
        // D s_510_56: cast reint s_510_55 -> u8
        let s_510_56: u8 = (s_510_55.value() as u8);
        // D s_510_57: call decode_aarch32_instrs_VFMA_A1enc_A_txt(s_510_8, s_510_14, s_510_20, s_510_26, s_510_32, s_510_38, s_510_44, s_510_50, s_510_56)
        let s_510_57: () = decode_aarch32_instrs_VFMA_A1enc_A_txt(
            state,
            tracer,
            s_510_8,
            s_510_14,
            s_510_20,
            s_510_26,
            s_510_32,
            s_510_38,
            s_510_44,
            s_510_50,
            s_510_56,
        );
        // N s_510_58: return
        return;
    }
    fn block_511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_511_0: read-var merge#var.1:struct
        let s_511_0: u32 = fn_state.merge_var._1;
        // D s_511_1: write-var u#30929 <= s_511_0
        fn_state.u_30929 = s_511_0;
        // C s_511_2: const #25s : i
        let s_511_2: i128 = 25;
        // D s_511_3: read-var u#30929:u32
        let s_511_3: u32 = fn_state.u_30929;
        // D s_511_4: cast zx s_511_3 -> bv
        let s_511_4: Bits = Bits::new(s_511_3 as u128, 32u16);
        // C s_511_5: const #1s : i64
        let s_511_5: i64 = 1;
        // C s_511_6: cast zx s_511_5 -> i
        let s_511_6: i128 = (i128::try_from(s_511_5).unwrap());
        // C s_511_7: const #6s : i
        let s_511_7: i128 = 6;
        // C s_511_8: add s_511_7 s_511_6
        let s_511_8: i128 = (s_511_7 + s_511_6);
        // D s_511_9: bit-extract s_511_4 s_511_2 s_511_8
        let s_511_9: Bits = (Bits::new(
            ((s_511_4) >> (s_511_2)).value(),
            u16::try_from(s_511_8).unwrap(),
        ));
        // D s_511_10: cast reint s_511_9 -> u8
        let s_511_10: u8 = (s_511_9.value() as u8);
        // D s_511_11: cast zx s_511_10 -> bv
        let s_511_11: Bits = Bits::new(s_511_10 as u128, 7u16);
        // C s_511_12: const #121u : u8
        let s_511_12: u8 = 121;
        // C s_511_13: cast zx s_511_12 -> bv
        let s_511_13: Bits = Bits::new(s_511_12 as u128, 7u16);
        // D s_511_14: cmp-eq s_511_11 s_511_13
        let s_511_14: bool = ((s_511_11) == (s_511_13));
        // N s_511_15: branch s_511_14 b2825 b512
        if s_511_14 {
            return block_2825(state, tracer, fn_state);
        } else {
            return block_512(state, tracer, fn_state);
        };
    }
    fn block_512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_512_0: const #0u : u8
        let s_512_0: bool = false;
        // D s_512_1: write-var gs#399051 <= s_512_0
        fn_state.gs_399051 = s_512_0;
        // N s_512_2: jump b513
        return block_513(state, tracer, fn_state);
    }
    fn block_513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_513_0: read-var gs#399051:u8
        let s_513_0: bool = fn_state.gs_399051;
        // N s_513_1: branch s_513_0 b2824 b514
        if s_513_0 {
            return block_2824(state, tracer, fn_state);
        } else {
            return block_514(state, tracer, fn_state);
        };
    }
    fn block_514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_514_0: const #0u : u8
        let s_514_0: bool = false;
        // D s_514_1: write-var gs#399053 <= s_514_0
        fn_state.gs_399053 = s_514_0;
        // N s_514_2: jump b515
        return block_515(state, tracer, fn_state);
    }
    fn block_515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_515_0: read-var gs#399053:u8
        let s_515_0: bool = fn_state.gs_399053;
        // D s_515_1: not s_515_0
        let s_515_1: bool = !s_515_0;
        // N s_515_2: branch s_515_1 b517 b516
        if s_515_1 {
            return block_517(state, tracer, fn_state);
        } else {
            return block_516(state, tracer, fn_state);
        };
    }
    fn block_516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_516_0: const #3448s : i
        let s_516_0: i128 = 3448;
        // C s_516_1: const #14696u : u32
        let s_516_1: u32 = 14696;
        // N s_516_2: write-reg s_516_1 <= s_516_0
        let s_516_2: () = {
            state.write_register::<i128>(s_516_1 as isize, s_516_0);
            tracer.write_register(s_516_1 as isize, s_516_0);
        };
        // C s_516_3: const #24s : i
        let s_516_3: i128 = 24;
        // C s_516_4: const #1s : i
        let s_516_4: i128 = 1;
        // D s_516_5: read-var u#30929:u32
        let s_516_5: u32 = fn_state.u_30929;
        // D s_516_6: cast zx s_516_5 -> bv
        let s_516_6: Bits = Bits::new(s_516_5 as u128, 32u16);
        // D s_516_7: bit-extract s_516_6 s_516_3 s_516_4
        let s_516_7: Bits = (Bits::new(
            ((s_516_6) >> (s_516_3)).value(),
            u16::try_from(s_516_4).unwrap(),
        ));
        // D s_516_8: cast reint s_516_7 -> u8
        let s_516_8: bool = ((s_516_7.value()) != 0);
        // C s_516_9: const #22s : i
        let s_516_9: i128 = 22;
        // C s_516_10: const #1s : i
        let s_516_10: i128 = 1;
        // D s_516_11: read-var u#30929:u32
        let s_516_11: u32 = fn_state.u_30929;
        // D s_516_12: cast zx s_516_11 -> bv
        let s_516_12: Bits = Bits::new(s_516_11 as u128, 32u16);
        // D s_516_13: bit-extract s_516_12 s_516_9 s_516_10
        let s_516_13: Bits = (Bits::new(
            ((s_516_12) >> (s_516_9)).value(),
            u16::try_from(s_516_10).unwrap(),
        ));
        // D s_516_14: cast reint s_516_13 -> u8
        let s_516_14: bool = ((s_516_13.value()) != 0);
        // C s_516_15: const #20s : i
        let s_516_15: i128 = 20;
        // C s_516_16: const #2s : i
        let s_516_16: i128 = 2;
        // D s_516_17: read-var u#30929:u32
        let s_516_17: u32 = fn_state.u_30929;
        // D s_516_18: cast zx s_516_17 -> bv
        let s_516_18: Bits = Bits::new(s_516_17 as u128, 32u16);
        // D s_516_19: bit-extract s_516_18 s_516_15 s_516_16
        let s_516_19: Bits = (Bits::new(
            ((s_516_18) >> (s_516_15)).value(),
            u16::try_from(s_516_16).unwrap(),
        ));
        // D s_516_20: cast reint s_516_19 -> u8
        let s_516_20: u8 = (s_516_19.value() as u8);
        // C s_516_21: const #16s : i
        let s_516_21: i128 = 16;
        // C s_516_22: const #4s : i
        let s_516_22: i128 = 4;
        // D s_516_23: read-var u#30929:u32
        let s_516_23: u32 = fn_state.u_30929;
        // D s_516_24: cast zx s_516_23 -> bv
        let s_516_24: Bits = Bits::new(s_516_23 as u128, 32u16);
        // D s_516_25: bit-extract s_516_24 s_516_21 s_516_22
        let s_516_25: Bits = (Bits::new(
            ((s_516_24) >> (s_516_21)).value(),
            u16::try_from(s_516_22).unwrap(),
        ));
        // D s_516_26: cast reint s_516_25 -> u8
        let s_516_26: u8 = (s_516_25.value() as u8);
        // C s_516_27: const #12s : i
        let s_516_27: i128 = 12;
        // C s_516_28: const #4s : i
        let s_516_28: i128 = 4;
        // D s_516_29: read-var u#30929:u32
        let s_516_29: u32 = fn_state.u_30929;
        // D s_516_30: cast zx s_516_29 -> bv
        let s_516_30: Bits = Bits::new(s_516_29 as u128, 32u16);
        // D s_516_31: bit-extract s_516_30 s_516_27 s_516_28
        let s_516_31: Bits = (Bits::new(
            ((s_516_30) >> (s_516_27)).value(),
            u16::try_from(s_516_28).unwrap(),
        ));
        // D s_516_32: cast reint s_516_31 -> u8
        let s_516_32: u8 = (s_516_31.value() as u8);
        // C s_516_33: const #9s : i
        let s_516_33: i128 = 9;
        // C s_516_34: const #1s : i
        let s_516_34: i128 = 1;
        // D s_516_35: read-var u#30929:u32
        let s_516_35: u32 = fn_state.u_30929;
        // D s_516_36: cast zx s_516_35 -> bv
        let s_516_36: Bits = Bits::new(s_516_35 as u128, 32u16);
        // D s_516_37: bit-extract s_516_36 s_516_33 s_516_34
        let s_516_37: Bits = (Bits::new(
            ((s_516_36) >> (s_516_33)).value(),
            u16::try_from(s_516_34).unwrap(),
        ));
        // D s_516_38: cast reint s_516_37 -> u8
        let s_516_38: bool = ((s_516_37.value()) != 0);
        // C s_516_39: const #7s : i
        let s_516_39: i128 = 7;
        // C s_516_40: const #1s : i
        let s_516_40: i128 = 1;
        // D s_516_41: read-var u#30929:u32
        let s_516_41: u32 = fn_state.u_30929;
        // D s_516_42: cast zx s_516_41 -> bv
        let s_516_42: Bits = Bits::new(s_516_41 as u128, 32u16);
        // D s_516_43: bit-extract s_516_42 s_516_39 s_516_40
        let s_516_43: Bits = (Bits::new(
            ((s_516_42) >> (s_516_39)).value(),
            u16::try_from(s_516_40).unwrap(),
        ));
        // D s_516_44: cast reint s_516_43 -> u8
        let s_516_44: bool = ((s_516_43.value()) != 0);
        // C s_516_45: const #6s : i
        let s_516_45: i128 = 6;
        // C s_516_46: const #1s : i
        let s_516_46: i128 = 1;
        // D s_516_47: read-var u#30929:u32
        let s_516_47: u32 = fn_state.u_30929;
        // D s_516_48: cast zx s_516_47 -> bv
        let s_516_48: Bits = Bits::new(s_516_47 as u128, 32u16);
        // D s_516_49: bit-extract s_516_48 s_516_45 s_516_46
        let s_516_49: Bits = (Bits::new(
            ((s_516_48) >> (s_516_45)).value(),
            u16::try_from(s_516_46).unwrap(),
        ));
        // D s_516_50: cast reint s_516_49 -> u8
        let s_516_50: bool = ((s_516_49.value()) != 0);
        // C s_516_51: const #5s : i
        let s_516_51: i128 = 5;
        // C s_516_52: const #1s : i
        let s_516_52: i128 = 1;
        // D s_516_53: read-var u#30929:u32
        let s_516_53: u32 = fn_state.u_30929;
        // D s_516_54: cast zx s_516_53 -> bv
        let s_516_54: Bits = Bits::new(s_516_53 as u128, 32u16);
        // D s_516_55: bit-extract s_516_54 s_516_51 s_516_52
        let s_516_55: Bits = (Bits::new(
            ((s_516_54) >> (s_516_51)).value(),
            u16::try_from(s_516_52).unwrap(),
        ));
        // D s_516_56: cast reint s_516_55 -> u8
        let s_516_56: bool = ((s_516_55.value()) != 0);
        // C s_516_57: const #0s : i
        let s_516_57: i128 = 0;
        // C s_516_58: const #4s : i
        let s_516_58: i128 = 4;
        // D s_516_59: read-var u#30929:u32
        let s_516_59: u32 = fn_state.u_30929;
        // D s_516_60: cast zx s_516_59 -> bv
        let s_516_60: Bits = Bits::new(s_516_59 as u128, 32u16);
        // D s_516_61: bit-extract s_516_60 s_516_57 s_516_58
        let s_516_61: Bits = (Bits::new(
            ((s_516_60) >> (s_516_57)).value(),
            u16::try_from(s_516_58).unwrap(),
        ));
        // D s_516_62: cast reint s_516_61 -> u8
        let s_516_62: u8 = (s_516_61.value() as u8);
        // D s_516_63: call decode_aarch32_instrs_VHADD_A1enc_A_txt(s_516_8, s_516_14, s_516_20, s_516_26, s_516_32, s_516_38, s_516_44, s_516_50, s_516_56, s_516_62)
        let s_516_63: () = decode_aarch32_instrs_VHADD_A1enc_A_txt(
            state,
            tracer,
            s_516_8,
            s_516_14,
            s_516_20,
            s_516_26,
            s_516_32,
            s_516_38,
            s_516_44,
            s_516_50,
            s_516_56,
            s_516_62,
        );
        // N s_516_64: return
        return;
    }
    fn block_517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_517_0: read-var merge#var.1:struct
        let s_517_0: u32 = fn_state.merge_var._1;
        // D s_517_1: write-var u#30941 <= s_517_0
        fn_state.u_30941 = s_517_0;
        // C s_517_2: const #23s : i
        let s_517_2: i128 = 23;
        // D s_517_3: read-var u#30941:u32
        let s_517_3: u32 = fn_state.u_30941;
        // D s_517_4: cast zx s_517_3 -> bv
        let s_517_4: Bits = Bits::new(s_517_3 as u128, 32u16);
        // C s_517_5: const #1s : i64
        let s_517_5: i64 = 1;
        // C s_517_6: cast zx s_517_5 -> i
        let s_517_6: i128 = (i128::try_from(s_517_5).unwrap());
        // C s_517_7: const #8s : i
        let s_517_7: i128 = 8;
        // C s_517_8: add s_517_7 s_517_6
        let s_517_8: i128 = (s_517_7 + s_517_6);
        // D s_517_9: bit-extract s_517_4 s_517_2 s_517_8
        let s_517_9: Bits = (Bits::new(
            ((s_517_4) >> (s_517_2)).value(),
            u16::try_from(s_517_8).unwrap(),
        ));
        // D s_517_10: cast reint s_517_9 -> u9
        let s_517_10: u16 = (s_517_9.value() as u16);
        // D s_517_11: cast zx s_517_10 -> bv
        let s_517_11: Bits = Bits::new(s_517_10 as u128, 9u16);
        // C s_517_12: const #489u : u9
        let s_517_12: u16 = 489;
        // C s_517_13: cast zx s_517_12 -> bv
        let s_517_13: Bits = Bits::new(s_517_12 as u128, 9u16);
        // D s_517_14: cmp-eq s_517_11 s_517_13
        let s_517_14: bool = ((s_517_11) == (s_517_13));
        // N s_517_15: branch s_517_14 b2820 b518
        if s_517_14 {
            return block_2820(state, tracer, fn_state);
        } else {
            return block_518(state, tracer, fn_state);
        };
    }
    fn block_518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_518_0: const #0u : u8
        let s_518_0: bool = false;
        // D s_518_1: write-var gs#399084 <= s_518_0
        fn_state.gs_399084 = s_518_0;
        // N s_518_2: jump b519
        return block_519(state, tracer, fn_state);
    }
    fn block_519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_519_0: read-var gs#399084:u8
        let s_519_0: bool = fn_state.gs_399084;
        // N s_519_1: branch s_519_0 b2819 b520
        if s_519_0 {
            return block_2819(state, tracer, fn_state);
        } else {
            return block_520(state, tracer, fn_state);
        };
    }
    fn block_520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_520_0: const #0u : u8
        let s_520_0: bool = false;
        // D s_520_1: write-var gs#399086 <= s_520_0
        fn_state.gs_399086 = s_520_0;
        // N s_520_2: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_521_0: read-var gs#399086:u8
        let s_521_0: bool = fn_state.gs_399086;
        // D s_521_1: not s_521_0
        let s_521_1: bool = !s_521_0;
        // N s_521_2: branch s_521_1 b523 b522
        if s_521_1 {
            return block_523(state, tracer, fn_state);
        } else {
            return block_522(state, tracer, fn_state);
        };
    }
    fn block_522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_522_0: const #3450s : i
        let s_522_0: i128 = 3450;
        // C s_522_1: const #14696u : u32
        let s_522_1: u32 = 14696;
        // N s_522_2: write-reg s_522_1 <= s_522_0
        let s_522_2: () = {
            state.write_register::<i128>(s_522_1 as isize, s_522_0);
            tracer.write_register(s_522_1 as isize, s_522_0);
        };
        // C s_522_3: const #22s : i
        let s_522_3: i128 = 22;
        // C s_522_4: const #1s : i
        let s_522_4: i128 = 1;
        // D s_522_5: read-var u#30941:u32
        let s_522_5: u32 = fn_state.u_30941;
        // D s_522_6: cast zx s_522_5 -> bv
        let s_522_6: Bits = Bits::new(s_522_5 as u128, 32u16);
        // D s_522_7: bit-extract s_522_6 s_522_3 s_522_4
        let s_522_7: Bits = (Bits::new(
            ((s_522_6) >> (s_522_3)).value(),
            u16::try_from(s_522_4).unwrap(),
        ));
        // D s_522_8: cast reint s_522_7 -> u8
        let s_522_8: bool = ((s_522_7.value()) != 0);
        // C s_522_9: const #16s : i
        let s_522_9: i128 = 16;
        // C s_522_10: const #4s : i
        let s_522_10: i128 = 4;
        // D s_522_11: read-var u#30941:u32
        let s_522_11: u32 = fn_state.u_30941;
        // D s_522_12: cast zx s_522_11 -> bv
        let s_522_12: Bits = Bits::new(s_522_11 as u128, 32u16);
        // D s_522_13: bit-extract s_522_12 s_522_9 s_522_10
        let s_522_13: Bits = (Bits::new(
            ((s_522_12) >> (s_522_9)).value(),
            u16::try_from(s_522_10).unwrap(),
        ));
        // D s_522_14: cast reint s_522_13 -> u8
        let s_522_14: u8 = (s_522_13.value() as u8);
        // C s_522_15: const #12s : i
        let s_522_15: i128 = 12;
        // C s_522_16: const #4s : i
        let s_522_16: i128 = 4;
        // D s_522_17: read-var u#30941:u32
        let s_522_17: u32 = fn_state.u_30941;
        // D s_522_18: cast zx s_522_17 -> bv
        let s_522_18: Bits = Bits::new(s_522_17 as u128, 32u16);
        // D s_522_19: bit-extract s_522_18 s_522_15 s_522_16
        let s_522_19: Bits = (Bits::new(
            ((s_522_18) >> (s_522_15)).value(),
            u16::try_from(s_522_16).unwrap(),
        ));
        // D s_522_20: cast reint s_522_19 -> u8
        let s_522_20: u8 = (s_522_19.value() as u8);
        // C s_522_21: const #10s : i
        let s_522_21: i128 = 10;
        // C s_522_22: const #2s : i
        let s_522_22: i128 = 2;
        // D s_522_23: read-var u#30941:u32
        let s_522_23: u32 = fn_state.u_30941;
        // D s_522_24: cast zx s_522_23 -> bv
        let s_522_24: Bits = Bits::new(s_522_23 as u128, 32u16);
        // D s_522_25: bit-extract s_522_24 s_522_21 s_522_22
        let s_522_25: Bits = (Bits::new(
            ((s_522_24) >> (s_522_21)).value(),
            u16::try_from(s_522_22).unwrap(),
        ));
        // D s_522_26: cast reint s_522_25 -> u8
        let s_522_26: u8 = (s_522_25.value() as u8);
        // C s_522_27: const #4s : i
        let s_522_27: i128 = 4;
        // C s_522_28: const #4s : i
        let s_522_28: i128 = 4;
        // D s_522_29: read-var u#30941:u32
        let s_522_29: u32 = fn_state.u_30941;
        // D s_522_30: cast zx s_522_29 -> bv
        let s_522_30: Bits = Bits::new(s_522_29 as u128, 32u16);
        // D s_522_31: bit-extract s_522_30 s_522_27 s_522_28
        let s_522_31: Bits = (Bits::new(
            ((s_522_30) >> (s_522_27)).value(),
            u16::try_from(s_522_28).unwrap(),
        ));
        // D s_522_32: cast reint s_522_31 -> u8
        let s_522_32: u8 = (s_522_31.value() as u8);
        // C s_522_33: const #0s : i
        let s_522_33: i128 = 0;
        // C s_522_34: const #4s : i
        let s_522_34: i128 = 4;
        // D s_522_35: read-var u#30941:u32
        let s_522_35: u32 = fn_state.u_30941;
        // D s_522_36: cast zx s_522_35 -> bv
        let s_522_36: Bits = Bits::new(s_522_35 as u128, 32u16);
        // D s_522_37: bit-extract s_522_36 s_522_33 s_522_34
        let s_522_37: Bits = (Bits::new(
            ((s_522_36) >> (s_522_33)).value(),
            u16::try_from(s_522_34).unwrap(),
        ));
        // D s_522_38: cast reint s_522_37 -> u8
        let s_522_38: u8 = (s_522_37.value() as u8);
        // D s_522_39: call decode_aarch32_instrs_VLD1_1_A1enc_A_txt(s_522_8, s_522_14, s_522_20, s_522_26, s_522_32, s_522_38)
        let s_522_39: () = decode_aarch32_instrs_VLD1_1_A1enc_A_txt(
            state,
            tracer,
            s_522_8,
            s_522_14,
            s_522_20,
            s_522_26,
            s_522_32,
            s_522_38,
        );
        // N s_522_40: return
        return;
    }
    fn block_523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_523_0: read-var merge#var.1:struct
        let s_523_0: u32 = fn_state.merge_var._1;
        // D s_523_1: write-var u#30948 <= s_523_0
        fn_state.u_30948 = s_523_0;
        // C s_523_2: const #23s : i
        let s_523_2: i128 = 23;
        // D s_523_3: read-var u#30948:u32
        let s_523_3: u32 = fn_state.u_30948;
        // D s_523_4: cast zx s_523_3 -> bv
        let s_523_4: Bits = Bits::new(s_523_3 as u128, 32u16);
        // C s_523_5: const #1s : i64
        let s_523_5: i64 = 1;
        // C s_523_6: cast zx s_523_5 -> i
        let s_523_6: i128 = (i128::try_from(s_523_5).unwrap());
        // C s_523_7: const #8s : i
        let s_523_7: i128 = 8;
        // C s_523_8: add s_523_7 s_523_6
        let s_523_8: i128 = (s_523_7 + s_523_6);
        // D s_523_9: bit-extract s_523_4 s_523_2 s_523_8
        let s_523_9: Bits = (Bits::new(
            ((s_523_4) >> (s_523_2)).value(),
            u16::try_from(s_523_8).unwrap(),
        ));
        // D s_523_10: cast reint s_523_9 -> u9
        let s_523_10: u16 = (s_523_9.value() as u16);
        // D s_523_11: cast zx s_523_10 -> bv
        let s_523_11: Bits = Bits::new(s_523_10 as u128, 9u16);
        // C s_523_12: const #489u : u9
        let s_523_12: u16 = 489;
        // C s_523_13: cast zx s_523_12 -> bv
        let s_523_13: Bits = Bits::new(s_523_12 as u128, 9u16);
        // D s_523_14: cmp-eq s_523_11 s_523_13
        let s_523_14: bool = ((s_523_11) == (s_523_13));
        // N s_523_15: branch s_523_14 b2815 b524
        if s_523_14 {
            return block_2815(state, tracer, fn_state);
        } else {
            return block_524(state, tracer, fn_state);
        };
    }
    fn block_524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_524_0: const #0u : u8
        let s_524_0: bool = false;
        // D s_524_1: write-var gs#399109 <= s_524_0
        fn_state.gs_399109 = s_524_0;
        // N s_524_2: jump b525
        return block_525(state, tracer, fn_state);
    }
    fn block_525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_525_0: read-var gs#399109:u8
        let s_525_0: bool = fn_state.gs_399109;
        // N s_525_1: branch s_525_0 b2814 b526
        if s_525_0 {
            return block_2814(state, tracer, fn_state);
        } else {
            return block_526(state, tracer, fn_state);
        };
    }
    fn block_526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_526_0: const #0u : u8
        let s_526_0: bool = false;
        // D s_526_1: write-var gs#399111 <= s_526_0
        fn_state.gs_399111 = s_526_0;
        // N s_526_2: jump b527
        return block_527(state, tracer, fn_state);
    }
    fn block_527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_527_0: read-var gs#399111:u8
        let s_527_0: bool = fn_state.gs_399111;
        // D s_527_1: not s_527_0
        let s_527_1: bool = !s_527_0;
        // N s_527_2: branch s_527_1 b529 b528
        if s_527_1 {
            return block_529(state, tracer, fn_state);
        } else {
            return block_528(state, tracer, fn_state);
        };
    }
    fn block_528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_528_0: const #3451s : i
        let s_528_0: i128 = 3451;
        // C s_528_1: const #14696u : u32
        let s_528_1: u32 = 14696;
        // N s_528_2: write-reg s_528_1 <= s_528_0
        let s_528_2: () = {
            state.write_register::<i128>(s_528_1 as isize, s_528_0);
            tracer.write_register(s_528_1 as isize, s_528_0);
        };
        // C s_528_3: const #22s : i
        let s_528_3: i128 = 22;
        // C s_528_4: const #1s : i
        let s_528_4: i128 = 1;
        // D s_528_5: read-var u#30948:u32
        let s_528_5: u32 = fn_state.u_30948;
        // D s_528_6: cast zx s_528_5 -> bv
        let s_528_6: Bits = Bits::new(s_528_5 as u128, 32u16);
        // D s_528_7: bit-extract s_528_6 s_528_3 s_528_4
        let s_528_7: Bits = (Bits::new(
            ((s_528_6) >> (s_528_3)).value(),
            u16::try_from(s_528_4).unwrap(),
        ));
        // D s_528_8: cast reint s_528_7 -> u8
        let s_528_8: bool = ((s_528_7.value()) != 0);
        // C s_528_9: const #16s : i
        let s_528_9: i128 = 16;
        // C s_528_10: const #4s : i
        let s_528_10: i128 = 4;
        // D s_528_11: read-var u#30948:u32
        let s_528_11: u32 = fn_state.u_30948;
        // D s_528_12: cast zx s_528_11 -> bv
        let s_528_12: Bits = Bits::new(s_528_11 as u128, 32u16);
        // D s_528_13: bit-extract s_528_12 s_528_9 s_528_10
        let s_528_13: Bits = (Bits::new(
            ((s_528_12) >> (s_528_9)).value(),
            u16::try_from(s_528_10).unwrap(),
        ));
        // D s_528_14: cast reint s_528_13 -> u8
        let s_528_14: u8 = (s_528_13.value() as u8);
        // C s_528_15: const #12s : i
        let s_528_15: i128 = 12;
        // C s_528_16: const #4s : i
        let s_528_16: i128 = 4;
        // D s_528_17: read-var u#30948:u32
        let s_528_17: u32 = fn_state.u_30948;
        // D s_528_18: cast zx s_528_17 -> bv
        let s_528_18: Bits = Bits::new(s_528_17 as u128, 32u16);
        // D s_528_19: bit-extract s_528_18 s_528_15 s_528_16
        let s_528_19: Bits = (Bits::new(
            ((s_528_18) >> (s_528_15)).value(),
            u16::try_from(s_528_16).unwrap(),
        ));
        // D s_528_20: cast reint s_528_19 -> u8
        let s_528_20: u8 = (s_528_19.value() as u8);
        // C s_528_21: const #10s : i
        let s_528_21: i128 = 10;
        // C s_528_22: const #2s : i
        let s_528_22: i128 = 2;
        // D s_528_23: read-var u#30948:u32
        let s_528_23: u32 = fn_state.u_30948;
        // D s_528_24: cast zx s_528_23 -> bv
        let s_528_24: Bits = Bits::new(s_528_23 as u128, 32u16);
        // D s_528_25: bit-extract s_528_24 s_528_21 s_528_22
        let s_528_25: Bits = (Bits::new(
            ((s_528_24) >> (s_528_21)).value(),
            u16::try_from(s_528_22).unwrap(),
        ));
        // D s_528_26: cast reint s_528_25 -> u8
        let s_528_26: u8 = (s_528_25.value() as u8);
        // C s_528_27: const #4s : i
        let s_528_27: i128 = 4;
        // C s_528_28: const #4s : i
        let s_528_28: i128 = 4;
        // D s_528_29: read-var u#30948:u32
        let s_528_29: u32 = fn_state.u_30948;
        // D s_528_30: cast zx s_528_29 -> bv
        let s_528_30: Bits = Bits::new(s_528_29 as u128, 32u16);
        // D s_528_31: bit-extract s_528_30 s_528_27 s_528_28
        let s_528_31: Bits = (Bits::new(
            ((s_528_30) >> (s_528_27)).value(),
            u16::try_from(s_528_28).unwrap(),
        ));
        // D s_528_32: cast reint s_528_31 -> u8
        let s_528_32: u8 = (s_528_31.value() as u8);
        // C s_528_33: const #0s : i
        let s_528_33: i128 = 0;
        // C s_528_34: const #4s : i
        let s_528_34: i128 = 4;
        // D s_528_35: read-var u#30948:u32
        let s_528_35: u32 = fn_state.u_30948;
        // D s_528_36: cast zx s_528_35 -> bv
        let s_528_36: Bits = Bits::new(s_528_35 as u128, 32u16);
        // D s_528_37: bit-extract s_528_36 s_528_33 s_528_34
        let s_528_37: Bits = (Bits::new(
            ((s_528_36) >> (s_528_33)).value(),
            u16::try_from(s_528_34).unwrap(),
        ));
        // D s_528_38: cast reint s_528_37 -> u8
        let s_528_38: u8 = (s_528_37.value() as u8);
        // D s_528_39: call decode_aarch32_instrs_VLD1_1_A2enc_A_txt(s_528_8, s_528_14, s_528_20, s_528_26, s_528_32, s_528_38)
        let s_528_39: () = decode_aarch32_instrs_VLD1_1_A2enc_A_txt(
            state,
            tracer,
            s_528_8,
            s_528_14,
            s_528_20,
            s_528_26,
            s_528_32,
            s_528_38,
        );
        // N s_528_40: return
        return;
    }
    fn block_529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_529_0: read-var merge#var.1:struct
        let s_529_0: u32 = fn_state.merge_var._1;
        // D s_529_1: write-var u#30956 <= s_529_0
        fn_state.u_30956 = s_529_0;
        // C s_529_2: const #23s : i
        let s_529_2: i128 = 23;
        // D s_529_3: read-var u#30956:u32
        let s_529_3: u32 = fn_state.u_30956;
        // D s_529_4: cast zx s_529_3 -> bv
        let s_529_4: Bits = Bits::new(s_529_3 as u128, 32u16);
        // C s_529_5: const #1s : i64
        let s_529_5: i64 = 1;
        // C s_529_6: cast zx s_529_5 -> i
        let s_529_6: i128 = (i128::try_from(s_529_5).unwrap());
        // C s_529_7: const #8s : i
        let s_529_7: i128 = 8;
        // C s_529_8: add s_529_7 s_529_6
        let s_529_8: i128 = (s_529_7 + s_529_6);
        // D s_529_9: bit-extract s_529_4 s_529_2 s_529_8
        let s_529_9: Bits = (Bits::new(
            ((s_529_4) >> (s_529_2)).value(),
            u16::try_from(s_529_8).unwrap(),
        ));
        // D s_529_10: cast reint s_529_9 -> u9
        let s_529_10: u16 = (s_529_9.value() as u16);
        // D s_529_11: cast zx s_529_10 -> bv
        let s_529_11: Bits = Bits::new(s_529_10 as u128, 9u16);
        // C s_529_12: const #489u : u9
        let s_529_12: u16 = 489;
        // C s_529_13: cast zx s_529_12 -> bv
        let s_529_13: Bits = Bits::new(s_529_12 as u128, 9u16);
        // D s_529_14: cmp-eq s_529_11 s_529_13
        let s_529_14: bool = ((s_529_11) == (s_529_13));
        // N s_529_15: branch s_529_14 b2810 b530
        if s_529_14 {
            return block_2810(state, tracer, fn_state);
        } else {
            return block_530(state, tracer, fn_state);
        };
    }
    fn block_530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_530_0: const #0u : u8
        let s_530_0: bool = false;
        // D s_530_1: write-var gs#399134 <= s_530_0
        fn_state.gs_399134 = s_530_0;
        // N s_530_2: jump b531
        return block_531(state, tracer, fn_state);
    }
    fn block_531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_531_0: read-var gs#399134:u8
        let s_531_0: bool = fn_state.gs_399134;
        // N s_531_1: branch s_531_0 b2809 b532
        if s_531_0 {
            return block_2809(state, tracer, fn_state);
        } else {
            return block_532(state, tracer, fn_state);
        };
    }
    fn block_532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_532_0: const #0u : u8
        let s_532_0: bool = false;
        // D s_532_1: write-var gs#399136 <= s_532_0
        fn_state.gs_399136 = s_532_0;
        // N s_532_2: jump b533
        return block_533(state, tracer, fn_state);
    }
    fn block_533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_533_0: read-var gs#399136:u8
        let s_533_0: bool = fn_state.gs_399136;
        // D s_533_1: not s_533_0
        let s_533_1: bool = !s_533_0;
        // N s_533_2: branch s_533_1 b535 b534
        if s_533_1 {
            return block_535(state, tracer, fn_state);
        } else {
            return block_534(state, tracer, fn_state);
        };
    }
    fn block_534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_534_0: const #3452s : i
        let s_534_0: i128 = 3452;
        // C s_534_1: const #14696u : u32
        let s_534_1: u32 = 14696;
        // N s_534_2: write-reg s_534_1 <= s_534_0
        let s_534_2: () = {
            state.write_register::<i128>(s_534_1 as isize, s_534_0);
            tracer.write_register(s_534_1 as isize, s_534_0);
        };
        // C s_534_3: const #22s : i
        let s_534_3: i128 = 22;
        // C s_534_4: const #1s : i
        let s_534_4: i128 = 1;
        // D s_534_5: read-var u#30956:u32
        let s_534_5: u32 = fn_state.u_30956;
        // D s_534_6: cast zx s_534_5 -> bv
        let s_534_6: Bits = Bits::new(s_534_5 as u128, 32u16);
        // D s_534_7: bit-extract s_534_6 s_534_3 s_534_4
        let s_534_7: Bits = (Bits::new(
            ((s_534_6) >> (s_534_3)).value(),
            u16::try_from(s_534_4).unwrap(),
        ));
        // D s_534_8: cast reint s_534_7 -> u8
        let s_534_8: bool = ((s_534_7.value()) != 0);
        // C s_534_9: const #16s : i
        let s_534_9: i128 = 16;
        // C s_534_10: const #4s : i
        let s_534_10: i128 = 4;
        // D s_534_11: read-var u#30956:u32
        let s_534_11: u32 = fn_state.u_30956;
        // D s_534_12: cast zx s_534_11 -> bv
        let s_534_12: Bits = Bits::new(s_534_11 as u128, 32u16);
        // D s_534_13: bit-extract s_534_12 s_534_9 s_534_10
        let s_534_13: Bits = (Bits::new(
            ((s_534_12) >> (s_534_9)).value(),
            u16::try_from(s_534_10).unwrap(),
        ));
        // D s_534_14: cast reint s_534_13 -> u8
        let s_534_14: u8 = (s_534_13.value() as u8);
        // C s_534_15: const #12s : i
        let s_534_15: i128 = 12;
        // C s_534_16: const #4s : i
        let s_534_16: i128 = 4;
        // D s_534_17: read-var u#30956:u32
        let s_534_17: u32 = fn_state.u_30956;
        // D s_534_18: cast zx s_534_17 -> bv
        let s_534_18: Bits = Bits::new(s_534_17 as u128, 32u16);
        // D s_534_19: bit-extract s_534_18 s_534_15 s_534_16
        let s_534_19: Bits = (Bits::new(
            ((s_534_18) >> (s_534_15)).value(),
            u16::try_from(s_534_16).unwrap(),
        ));
        // D s_534_20: cast reint s_534_19 -> u8
        let s_534_20: u8 = (s_534_19.value() as u8);
        // C s_534_21: const #10s : i
        let s_534_21: i128 = 10;
        // C s_534_22: const #2s : i
        let s_534_22: i128 = 2;
        // D s_534_23: read-var u#30956:u32
        let s_534_23: u32 = fn_state.u_30956;
        // D s_534_24: cast zx s_534_23 -> bv
        let s_534_24: Bits = Bits::new(s_534_23 as u128, 32u16);
        // D s_534_25: bit-extract s_534_24 s_534_21 s_534_22
        let s_534_25: Bits = (Bits::new(
            ((s_534_24) >> (s_534_21)).value(),
            u16::try_from(s_534_22).unwrap(),
        ));
        // D s_534_26: cast reint s_534_25 -> u8
        let s_534_26: u8 = (s_534_25.value() as u8);
        // C s_534_27: const #4s : i
        let s_534_27: i128 = 4;
        // C s_534_28: const #4s : i
        let s_534_28: i128 = 4;
        // D s_534_29: read-var u#30956:u32
        let s_534_29: u32 = fn_state.u_30956;
        // D s_534_30: cast zx s_534_29 -> bv
        let s_534_30: Bits = Bits::new(s_534_29 as u128, 32u16);
        // D s_534_31: bit-extract s_534_30 s_534_27 s_534_28
        let s_534_31: Bits = (Bits::new(
            ((s_534_30) >> (s_534_27)).value(),
            u16::try_from(s_534_28).unwrap(),
        ));
        // D s_534_32: cast reint s_534_31 -> u8
        let s_534_32: u8 = (s_534_31.value() as u8);
        // C s_534_33: const #0s : i
        let s_534_33: i128 = 0;
        // C s_534_34: const #4s : i
        let s_534_34: i128 = 4;
        // D s_534_35: read-var u#30956:u32
        let s_534_35: u32 = fn_state.u_30956;
        // D s_534_36: cast zx s_534_35 -> bv
        let s_534_36: Bits = Bits::new(s_534_35 as u128, 32u16);
        // D s_534_37: bit-extract s_534_36 s_534_33 s_534_34
        let s_534_37: Bits = (Bits::new(
            ((s_534_36) >> (s_534_33)).value(),
            u16::try_from(s_534_34).unwrap(),
        ));
        // D s_534_38: cast reint s_534_37 -> u8
        let s_534_38: u8 = (s_534_37.value() as u8);
        // D s_534_39: call decode_aarch32_instrs_VLD1_1_A3enc_A_txt(s_534_8, s_534_14, s_534_20, s_534_26, s_534_32, s_534_38)
        let s_534_39: () = decode_aarch32_instrs_VLD1_1_A3enc_A_txt(
            state,
            tracer,
            s_534_8,
            s_534_14,
            s_534_20,
            s_534_26,
            s_534_32,
            s_534_38,
        );
        // N s_534_40: return
        return;
    }
    fn block_535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_535_0: read-var merge#var.1:struct
        let s_535_0: u32 = fn_state.merge_var._1;
        // D s_535_1: write-var u#30964 <= s_535_0
        fn_state.u_30964 = s_535_0;
        // C s_535_2: const #23s : i
        let s_535_2: i128 = 23;
        // D s_535_3: read-var u#30964:u32
        let s_535_3: u32 = fn_state.u_30964;
        // D s_535_4: cast zx s_535_3 -> bv
        let s_535_4: Bits = Bits::new(s_535_3 as u128, 32u16);
        // C s_535_5: const #1s : i64
        let s_535_5: i64 = 1;
        // C s_535_6: cast zx s_535_5 -> i
        let s_535_6: i128 = (i128::try_from(s_535_5).unwrap());
        // C s_535_7: const #8s : i
        let s_535_7: i128 = 8;
        // C s_535_8: add s_535_7 s_535_6
        let s_535_8: i128 = (s_535_7 + s_535_6);
        // D s_535_9: bit-extract s_535_4 s_535_2 s_535_8
        let s_535_9: Bits = (Bits::new(
            ((s_535_4) >> (s_535_2)).value(),
            u16::try_from(s_535_8).unwrap(),
        ));
        // D s_535_10: cast reint s_535_9 -> u9
        let s_535_10: u16 = (s_535_9.value() as u16);
        // D s_535_11: cast zx s_535_10 -> bv
        let s_535_11: Bits = Bits::new(s_535_10 as u128, 9u16);
        // C s_535_12: const #489u : u9
        let s_535_12: u16 = 489;
        // C s_535_13: cast zx s_535_12 -> bv
        let s_535_13: Bits = Bits::new(s_535_12 as u128, 9u16);
        // D s_535_14: cmp-eq s_535_11 s_535_13
        let s_535_14: bool = ((s_535_11) == (s_535_13));
        // N s_535_15: branch s_535_14 b2805 b536
        if s_535_14 {
            return block_2805(state, tracer, fn_state);
        } else {
            return block_536(state, tracer, fn_state);
        };
    }
    fn block_536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_536_0: const #0u : u8
        let s_536_0: bool = false;
        // D s_536_1: write-var gs#399159 <= s_536_0
        fn_state.gs_399159 = s_536_0;
        // N s_536_2: jump b537
        return block_537(state, tracer, fn_state);
    }
    fn block_537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_537_0: read-var gs#399159:u8
        let s_537_0: bool = fn_state.gs_399159;
        // N s_537_1: branch s_537_0 b2804 b538
        if s_537_0 {
            return block_2804(state, tracer, fn_state);
        } else {
            return block_538(state, tracer, fn_state);
        };
    }
    fn block_538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_538_0: const #0u : u8
        let s_538_0: bool = false;
        // D s_538_1: write-var gs#399161 <= s_538_0
        fn_state.gs_399161 = s_538_0;
        // N s_538_2: jump b539
        return block_539(state, tracer, fn_state);
    }
    fn block_539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_539_0: read-var gs#399161:u8
        let s_539_0: bool = fn_state.gs_399161;
        // D s_539_1: not s_539_0
        let s_539_1: bool = !s_539_0;
        // N s_539_2: branch s_539_1 b541 b540
        if s_539_1 {
            return block_541(state, tracer, fn_state);
        } else {
            return block_540(state, tracer, fn_state);
        };
    }
    fn block_540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_540_0: const #3456s : i
        let s_540_0: i128 = 3456;
        // C s_540_1: const #14696u : u32
        let s_540_1: u32 = 14696;
        // N s_540_2: write-reg s_540_1 <= s_540_0
        let s_540_2: () = {
            state.write_register::<i128>(s_540_1 as isize, s_540_0);
            tracer.write_register(s_540_1 as isize, s_540_0);
        };
        // C s_540_3: const #22s : i
        let s_540_3: i128 = 22;
        // C s_540_4: const #1s : i
        let s_540_4: i128 = 1;
        // D s_540_5: read-var u#30964:u32
        let s_540_5: u32 = fn_state.u_30964;
        // D s_540_6: cast zx s_540_5 -> bv
        let s_540_6: Bits = Bits::new(s_540_5 as u128, 32u16);
        // D s_540_7: bit-extract s_540_6 s_540_3 s_540_4
        let s_540_7: Bits = (Bits::new(
            ((s_540_6) >> (s_540_3)).value(),
            u16::try_from(s_540_4).unwrap(),
        ));
        // D s_540_8: cast reint s_540_7 -> u8
        let s_540_8: bool = ((s_540_7.value()) != 0);
        // C s_540_9: const #16s : i
        let s_540_9: i128 = 16;
        // C s_540_10: const #4s : i
        let s_540_10: i128 = 4;
        // D s_540_11: read-var u#30964:u32
        let s_540_11: u32 = fn_state.u_30964;
        // D s_540_12: cast zx s_540_11 -> bv
        let s_540_12: Bits = Bits::new(s_540_11 as u128, 32u16);
        // D s_540_13: bit-extract s_540_12 s_540_9 s_540_10
        let s_540_13: Bits = (Bits::new(
            ((s_540_12) >> (s_540_9)).value(),
            u16::try_from(s_540_10).unwrap(),
        ));
        // D s_540_14: cast reint s_540_13 -> u8
        let s_540_14: u8 = (s_540_13.value() as u8);
        // C s_540_15: const #12s : i
        let s_540_15: i128 = 12;
        // C s_540_16: const #4s : i
        let s_540_16: i128 = 4;
        // D s_540_17: read-var u#30964:u32
        let s_540_17: u32 = fn_state.u_30964;
        // D s_540_18: cast zx s_540_17 -> bv
        let s_540_18: Bits = Bits::new(s_540_17 as u128, 32u16);
        // D s_540_19: bit-extract s_540_18 s_540_15 s_540_16
        let s_540_19: Bits = (Bits::new(
            ((s_540_18) >> (s_540_15)).value(),
            u16::try_from(s_540_16).unwrap(),
        ));
        // D s_540_20: cast reint s_540_19 -> u8
        let s_540_20: u8 = (s_540_19.value() as u8);
        // C s_540_21: const #6s : i
        let s_540_21: i128 = 6;
        // C s_540_22: const #2s : i
        let s_540_22: i128 = 2;
        // D s_540_23: read-var u#30964:u32
        let s_540_23: u32 = fn_state.u_30964;
        // D s_540_24: cast zx s_540_23 -> bv
        let s_540_24: Bits = Bits::new(s_540_23 as u128, 32u16);
        // D s_540_25: bit-extract s_540_24 s_540_21 s_540_22
        let s_540_25: Bits = (Bits::new(
            ((s_540_24) >> (s_540_21)).value(),
            u16::try_from(s_540_22).unwrap(),
        ));
        // D s_540_26: cast reint s_540_25 -> u8
        let s_540_26: u8 = (s_540_25.value() as u8);
        // C s_540_27: const #5s : i
        let s_540_27: i128 = 5;
        // C s_540_28: const #1s : i
        let s_540_28: i128 = 1;
        // D s_540_29: read-var u#30964:u32
        let s_540_29: u32 = fn_state.u_30964;
        // D s_540_30: cast zx s_540_29 -> bv
        let s_540_30: Bits = Bits::new(s_540_29 as u128, 32u16);
        // D s_540_31: bit-extract s_540_30 s_540_27 s_540_28
        let s_540_31: Bits = (Bits::new(
            ((s_540_30) >> (s_540_27)).value(),
            u16::try_from(s_540_28).unwrap(),
        ));
        // D s_540_32: cast reint s_540_31 -> u8
        let s_540_32: bool = ((s_540_31.value()) != 0);
        // C s_540_33: const #4s : i
        let s_540_33: i128 = 4;
        // C s_540_34: const #1s : i
        let s_540_34: i128 = 1;
        // D s_540_35: read-var u#30964:u32
        let s_540_35: u32 = fn_state.u_30964;
        // D s_540_36: cast zx s_540_35 -> bv
        let s_540_36: Bits = Bits::new(s_540_35 as u128, 32u16);
        // D s_540_37: bit-extract s_540_36 s_540_33 s_540_34
        let s_540_37: Bits = (Bits::new(
            ((s_540_36) >> (s_540_33)).value(),
            u16::try_from(s_540_34).unwrap(),
        ));
        // D s_540_38: cast reint s_540_37 -> u8
        let s_540_38: bool = ((s_540_37.value()) != 0);
        // C s_540_39: const #0s : i
        let s_540_39: i128 = 0;
        // C s_540_40: const #4s : i
        let s_540_40: i128 = 4;
        // D s_540_41: read-var u#30964:u32
        let s_540_41: u32 = fn_state.u_30964;
        // D s_540_42: cast zx s_540_41 -> bv
        let s_540_42: Bits = Bits::new(s_540_41 as u128, 32u16);
        // D s_540_43: bit-extract s_540_42 s_540_39 s_540_40
        let s_540_43: Bits = (Bits::new(
            ((s_540_42) >> (s_540_39)).value(),
            u16::try_from(s_540_40).unwrap(),
        ));
        // D s_540_44: cast reint s_540_43 -> u8
        let s_540_44: u8 = (s_540_43.value() as u8);
        // D s_540_45: call decode_aarch32_instrs_VLD1_a_A1enc_A_txt(s_540_8, s_540_14, s_540_20, s_540_26, s_540_32, s_540_38, s_540_44)
        let s_540_45: () = decode_aarch32_instrs_VLD1_a_A1enc_A_txt(
            state,
            tracer,
            s_540_8,
            s_540_14,
            s_540_20,
            s_540_26,
            s_540_32,
            s_540_38,
            s_540_44,
        );
        // N s_540_46: return
        return;
    }
    fn block_541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_541_0: read-var merge#var.1:struct
        let s_541_0: u32 = fn_state.merge_var._1;
        // D s_541_1: write-var u#30971 <= s_541_0
        fn_state.u_30971 = s_541_0;
        // C s_541_2: const #23s : i
        let s_541_2: i128 = 23;
        // D s_541_3: read-var u#30971:u32
        let s_541_3: u32 = fn_state.u_30971;
        // D s_541_4: cast zx s_541_3 -> bv
        let s_541_4: Bits = Bits::new(s_541_3 as u128, 32u16);
        // C s_541_5: const #1s : i64
        let s_541_5: i64 = 1;
        // C s_541_6: cast zx s_541_5 -> i
        let s_541_6: i128 = (i128::try_from(s_541_5).unwrap());
        // C s_541_7: const #8s : i
        let s_541_7: i128 = 8;
        // C s_541_8: add s_541_7 s_541_6
        let s_541_8: i128 = (s_541_7 + s_541_6);
        // D s_541_9: bit-extract s_541_4 s_541_2 s_541_8
        let s_541_9: Bits = (Bits::new(
            ((s_541_4) >> (s_541_2)).value(),
            u16::try_from(s_541_8).unwrap(),
        ));
        // D s_541_10: cast reint s_541_9 -> u9
        let s_541_10: u16 = (s_541_9.value() as u16);
        // D s_541_11: cast zx s_541_10 -> bv
        let s_541_11: Bits = Bits::new(s_541_10 as u128, 9u16);
        // C s_541_12: const #488u : u9
        let s_541_12: u16 = 488;
        // C s_541_13: cast zx s_541_12 -> bv
        let s_541_13: Bits = Bits::new(s_541_12 as u128, 9u16);
        // D s_541_14: cmp-eq s_541_11 s_541_13
        let s_541_14: bool = ((s_541_11) == (s_541_13));
        // N s_541_15: branch s_541_14 b2800 b542
        if s_541_14 {
            return block_2800(state, tracer, fn_state);
        } else {
            return block_542(state, tracer, fn_state);
        };
    }
    fn block_542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_542_0: const #0u : u8
        let s_542_0: bool = false;
        // D s_542_1: write-var gs#399186 <= s_542_0
        fn_state.gs_399186 = s_542_0;
        // N s_542_2: jump b543
        return block_543(state, tracer, fn_state);
    }
    fn block_543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_543_0: read-var gs#399186:u8
        let s_543_0: bool = fn_state.gs_399186;
        // N s_543_1: branch s_543_0 b2799 b544
        if s_543_0 {
            return block_2799(state, tracer, fn_state);
        } else {
            return block_544(state, tracer, fn_state);
        };
    }
    fn block_544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_544_0: const #0u : u8
        let s_544_0: bool = false;
        // D s_544_1: write-var gs#399188 <= s_544_0
        fn_state.gs_399188 = s_544_0;
        // N s_544_2: jump b545
        return block_545(state, tracer, fn_state);
    }
    fn block_545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_545_0: read-var gs#399188:u8
        let s_545_0: bool = fn_state.gs_399188;
        // D s_545_1: not s_545_0
        let s_545_1: bool = !s_545_0;
        // N s_545_2: branch s_545_1 b547 b546
        if s_545_1 {
            return block_547(state, tracer, fn_state);
        } else {
            return block_546(state, tracer, fn_state);
        };
    }
    fn block_546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_546_0: const #3458s : i
        let s_546_0: i128 = 3458;
        // C s_546_1: const #14696u : u32
        let s_546_1: u32 = 14696;
        // N s_546_2: write-reg s_546_1 <= s_546_0
        let s_546_2: () = {
            state.write_register::<i128>(s_546_1 as isize, s_546_0);
            tracer.write_register(s_546_1 as isize, s_546_0);
        };
        // C s_546_3: const #22s : i
        let s_546_3: i128 = 22;
        // C s_546_4: const #1s : i
        let s_546_4: i128 = 1;
        // D s_546_5: read-var u#30971:u32
        let s_546_5: u32 = fn_state.u_30971;
        // D s_546_6: cast zx s_546_5 -> bv
        let s_546_6: Bits = Bits::new(s_546_5 as u128, 32u16);
        // D s_546_7: bit-extract s_546_6 s_546_3 s_546_4
        let s_546_7: Bits = (Bits::new(
            ((s_546_6) >> (s_546_3)).value(),
            u16::try_from(s_546_4).unwrap(),
        ));
        // D s_546_8: cast reint s_546_7 -> u8
        let s_546_8: bool = ((s_546_7.value()) != 0);
        // C s_546_9: const #16s : i
        let s_546_9: i128 = 16;
        // C s_546_10: const #4s : i
        let s_546_10: i128 = 4;
        // D s_546_11: read-var u#30971:u32
        let s_546_11: u32 = fn_state.u_30971;
        // D s_546_12: cast zx s_546_11 -> bv
        let s_546_12: Bits = Bits::new(s_546_11 as u128, 32u16);
        // D s_546_13: bit-extract s_546_12 s_546_9 s_546_10
        let s_546_13: Bits = (Bits::new(
            ((s_546_12) >> (s_546_9)).value(),
            u16::try_from(s_546_10).unwrap(),
        ));
        // D s_546_14: cast reint s_546_13 -> u8
        let s_546_14: u8 = (s_546_13.value() as u8);
        // C s_546_15: const #12s : i
        let s_546_15: i128 = 12;
        // C s_546_16: const #4s : i
        let s_546_16: i128 = 4;
        // D s_546_17: read-var u#30971:u32
        let s_546_17: u32 = fn_state.u_30971;
        // D s_546_18: cast zx s_546_17 -> bv
        let s_546_18: Bits = Bits::new(s_546_17 as u128, 32u16);
        // D s_546_19: bit-extract s_546_18 s_546_15 s_546_16
        let s_546_19: Bits = (Bits::new(
            ((s_546_18) >> (s_546_15)).value(),
            u16::try_from(s_546_16).unwrap(),
        ));
        // D s_546_20: cast reint s_546_19 -> u8
        let s_546_20: u8 = (s_546_19.value() as u8);
        // C s_546_21: const #8s : i
        let s_546_21: i128 = 8;
        // C s_546_22: const #4s : i
        let s_546_22: i128 = 4;
        // D s_546_23: read-var u#30971:u32
        let s_546_23: u32 = fn_state.u_30971;
        // D s_546_24: cast zx s_546_23 -> bv
        let s_546_24: Bits = Bits::new(s_546_23 as u128, 32u16);
        // D s_546_25: bit-extract s_546_24 s_546_21 s_546_22
        let s_546_25: Bits = (Bits::new(
            ((s_546_24) >> (s_546_21)).value(),
            u16::try_from(s_546_22).unwrap(),
        ));
        // D s_546_26: cast reint s_546_25 -> u8
        let s_546_26: u8 = (s_546_25.value() as u8);
        // C s_546_27: const #6s : i
        let s_546_27: i128 = 6;
        // C s_546_28: const #2s : i
        let s_546_28: i128 = 2;
        // D s_546_29: read-var u#30971:u32
        let s_546_29: u32 = fn_state.u_30971;
        // D s_546_30: cast zx s_546_29 -> bv
        let s_546_30: Bits = Bits::new(s_546_29 as u128, 32u16);
        // D s_546_31: bit-extract s_546_30 s_546_27 s_546_28
        let s_546_31: Bits = (Bits::new(
            ((s_546_30) >> (s_546_27)).value(),
            u16::try_from(s_546_28).unwrap(),
        ));
        // D s_546_32: cast reint s_546_31 -> u8
        let s_546_32: u8 = (s_546_31.value() as u8);
        // C s_546_33: const #4s : i
        let s_546_33: i128 = 4;
        // C s_546_34: const #2s : i
        let s_546_34: i128 = 2;
        // D s_546_35: read-var u#30971:u32
        let s_546_35: u32 = fn_state.u_30971;
        // D s_546_36: cast zx s_546_35 -> bv
        let s_546_36: Bits = Bits::new(s_546_35 as u128, 32u16);
        // D s_546_37: bit-extract s_546_36 s_546_33 s_546_34
        let s_546_37: Bits = (Bits::new(
            ((s_546_36) >> (s_546_33)).value(),
            u16::try_from(s_546_34).unwrap(),
        ));
        // D s_546_38: cast reint s_546_37 -> u8
        let s_546_38: u8 = (s_546_37.value() as u8);
        // C s_546_39: const #0s : i
        let s_546_39: i128 = 0;
        // C s_546_40: const #4s : i
        let s_546_40: i128 = 4;
        // D s_546_41: read-var u#30971:u32
        let s_546_41: u32 = fn_state.u_30971;
        // D s_546_42: cast zx s_546_41 -> bv
        let s_546_42: Bits = Bits::new(s_546_41 as u128, 32u16);
        // D s_546_43: bit-extract s_546_42 s_546_39 s_546_40
        let s_546_43: Bits = (Bits::new(
            ((s_546_42) >> (s_546_39)).value(),
            u16::try_from(s_546_40).unwrap(),
        ));
        // D s_546_44: cast reint s_546_43 -> u8
        let s_546_44: u8 = (s_546_43.value() as u8);
        // D s_546_45: call decode_aarch32_instrs_VLD1_m_A1enc_A_txt(s_546_8, s_546_14, s_546_20, s_546_26, s_546_32, s_546_38, s_546_44)
        let s_546_45: () = decode_aarch32_instrs_VLD1_m_A1enc_A_txt(
            state,
            tracer,
            s_546_8,
            s_546_14,
            s_546_20,
            s_546_26,
            s_546_32,
            s_546_38,
            s_546_44,
        );
        // N s_546_46: return
        return;
    }
    fn block_547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_547_0: read-var merge#var.1:struct
        let s_547_0: u32 = fn_state.merge_var._1;
        // D s_547_1: write-var u#30978 <= s_547_0
        fn_state.u_30978 = s_547_0;
        // C s_547_2: const #23s : i
        let s_547_2: i128 = 23;
        // D s_547_3: read-var u#30978:u32
        let s_547_3: u32 = fn_state.u_30978;
        // D s_547_4: cast zx s_547_3 -> bv
        let s_547_4: Bits = Bits::new(s_547_3 as u128, 32u16);
        // C s_547_5: const #1s : i64
        let s_547_5: i64 = 1;
        // C s_547_6: cast zx s_547_5 -> i
        let s_547_6: i128 = (i128::try_from(s_547_5).unwrap());
        // C s_547_7: const #8s : i
        let s_547_7: i128 = 8;
        // C s_547_8: add s_547_7 s_547_6
        let s_547_8: i128 = (s_547_7 + s_547_6);
        // D s_547_9: bit-extract s_547_4 s_547_2 s_547_8
        let s_547_9: Bits = (Bits::new(
            ((s_547_4) >> (s_547_2)).value(),
            u16::try_from(s_547_8).unwrap(),
        ));
        // D s_547_10: cast reint s_547_9 -> u9
        let s_547_10: u16 = (s_547_9.value() as u16);
        // D s_547_11: cast zx s_547_10 -> bv
        let s_547_11: Bits = Bits::new(s_547_10 as u128, 9u16);
        // C s_547_12: const #488u : u9
        let s_547_12: u16 = 488;
        // C s_547_13: cast zx s_547_12 -> bv
        let s_547_13: Bits = Bits::new(s_547_12 as u128, 9u16);
        // D s_547_14: cmp-eq s_547_11 s_547_13
        let s_547_14: bool = ((s_547_11) == (s_547_13));
        // N s_547_15: branch s_547_14 b2795 b548
        if s_547_14 {
            return block_2795(state, tracer, fn_state);
        } else {
            return block_548(state, tracer, fn_state);
        };
    }
    fn block_548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_548_0: const #0u : u8
        let s_548_0: bool = false;
        // D s_548_1: write-var gs#399213 <= s_548_0
        fn_state.gs_399213 = s_548_0;
        // N s_548_2: jump b549
        return block_549(state, tracer, fn_state);
    }
    fn block_549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_549_0: read-var gs#399213:u8
        let s_549_0: bool = fn_state.gs_399213;
        // N s_549_1: branch s_549_0 b2794 b550
        if s_549_0 {
            return block_2794(state, tracer, fn_state);
        } else {
            return block_550(state, tracer, fn_state);
        };
    }
    fn block_550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_550_0: const #0u : u8
        let s_550_0: bool = false;
        // D s_550_1: write-var gs#399215 <= s_550_0
        fn_state.gs_399215 = s_550_0;
        // N s_550_2: jump b551
        return block_551(state, tracer, fn_state);
    }
    fn block_551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_551_0: read-var gs#399215:u8
        let s_551_0: bool = fn_state.gs_399215;
        // D s_551_1: not s_551_0
        let s_551_1: bool = !s_551_0;
        // N s_551_2: branch s_551_1 b553 b552
        if s_551_1 {
            return block_553(state, tracer, fn_state);
        } else {
            return block_552(state, tracer, fn_state);
        };
    }
    fn block_552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_552_0: const #3459s : i
        let s_552_0: i128 = 3459;
        // C s_552_1: const #14696u : u32
        let s_552_1: u32 = 14696;
        // N s_552_2: write-reg s_552_1 <= s_552_0
        let s_552_2: () = {
            state.write_register::<i128>(s_552_1 as isize, s_552_0);
            tracer.write_register(s_552_1 as isize, s_552_0);
        };
        // C s_552_3: const #22s : i
        let s_552_3: i128 = 22;
        // C s_552_4: const #1s : i
        let s_552_4: i128 = 1;
        // D s_552_5: read-var u#30978:u32
        let s_552_5: u32 = fn_state.u_30978;
        // D s_552_6: cast zx s_552_5 -> bv
        let s_552_6: Bits = Bits::new(s_552_5 as u128, 32u16);
        // D s_552_7: bit-extract s_552_6 s_552_3 s_552_4
        let s_552_7: Bits = (Bits::new(
            ((s_552_6) >> (s_552_3)).value(),
            u16::try_from(s_552_4).unwrap(),
        ));
        // D s_552_8: cast reint s_552_7 -> u8
        let s_552_8: bool = ((s_552_7.value()) != 0);
        // C s_552_9: const #16s : i
        let s_552_9: i128 = 16;
        // C s_552_10: const #4s : i
        let s_552_10: i128 = 4;
        // D s_552_11: read-var u#30978:u32
        let s_552_11: u32 = fn_state.u_30978;
        // D s_552_12: cast zx s_552_11 -> bv
        let s_552_12: Bits = Bits::new(s_552_11 as u128, 32u16);
        // D s_552_13: bit-extract s_552_12 s_552_9 s_552_10
        let s_552_13: Bits = (Bits::new(
            ((s_552_12) >> (s_552_9)).value(),
            u16::try_from(s_552_10).unwrap(),
        ));
        // D s_552_14: cast reint s_552_13 -> u8
        let s_552_14: u8 = (s_552_13.value() as u8);
        // C s_552_15: const #12s : i
        let s_552_15: i128 = 12;
        // C s_552_16: const #4s : i
        let s_552_16: i128 = 4;
        // D s_552_17: read-var u#30978:u32
        let s_552_17: u32 = fn_state.u_30978;
        // D s_552_18: cast zx s_552_17 -> bv
        let s_552_18: Bits = Bits::new(s_552_17 as u128, 32u16);
        // D s_552_19: bit-extract s_552_18 s_552_15 s_552_16
        let s_552_19: Bits = (Bits::new(
            ((s_552_18) >> (s_552_15)).value(),
            u16::try_from(s_552_16).unwrap(),
        ));
        // D s_552_20: cast reint s_552_19 -> u8
        let s_552_20: u8 = (s_552_19.value() as u8);
        // C s_552_21: const #8s : i
        let s_552_21: i128 = 8;
        // C s_552_22: const #4s : i
        let s_552_22: i128 = 4;
        // D s_552_23: read-var u#30978:u32
        let s_552_23: u32 = fn_state.u_30978;
        // D s_552_24: cast zx s_552_23 -> bv
        let s_552_24: Bits = Bits::new(s_552_23 as u128, 32u16);
        // D s_552_25: bit-extract s_552_24 s_552_21 s_552_22
        let s_552_25: Bits = (Bits::new(
            ((s_552_24) >> (s_552_21)).value(),
            u16::try_from(s_552_22).unwrap(),
        ));
        // D s_552_26: cast reint s_552_25 -> u8
        let s_552_26: u8 = (s_552_25.value() as u8);
        // C s_552_27: const #6s : i
        let s_552_27: i128 = 6;
        // C s_552_28: const #2s : i
        let s_552_28: i128 = 2;
        // D s_552_29: read-var u#30978:u32
        let s_552_29: u32 = fn_state.u_30978;
        // D s_552_30: cast zx s_552_29 -> bv
        let s_552_30: Bits = Bits::new(s_552_29 as u128, 32u16);
        // D s_552_31: bit-extract s_552_30 s_552_27 s_552_28
        let s_552_31: Bits = (Bits::new(
            ((s_552_30) >> (s_552_27)).value(),
            u16::try_from(s_552_28).unwrap(),
        ));
        // D s_552_32: cast reint s_552_31 -> u8
        let s_552_32: u8 = (s_552_31.value() as u8);
        // C s_552_33: const #4s : i
        let s_552_33: i128 = 4;
        // C s_552_34: const #2s : i
        let s_552_34: i128 = 2;
        // D s_552_35: read-var u#30978:u32
        let s_552_35: u32 = fn_state.u_30978;
        // D s_552_36: cast zx s_552_35 -> bv
        let s_552_36: Bits = Bits::new(s_552_35 as u128, 32u16);
        // D s_552_37: bit-extract s_552_36 s_552_33 s_552_34
        let s_552_37: Bits = (Bits::new(
            ((s_552_36) >> (s_552_33)).value(),
            u16::try_from(s_552_34).unwrap(),
        ));
        // D s_552_38: cast reint s_552_37 -> u8
        let s_552_38: u8 = (s_552_37.value() as u8);
        // C s_552_39: const #0s : i
        let s_552_39: i128 = 0;
        // C s_552_40: const #4s : i
        let s_552_40: i128 = 4;
        // D s_552_41: read-var u#30978:u32
        let s_552_41: u32 = fn_state.u_30978;
        // D s_552_42: cast zx s_552_41 -> bv
        let s_552_42: Bits = Bits::new(s_552_41 as u128, 32u16);
        // D s_552_43: bit-extract s_552_42 s_552_39 s_552_40
        let s_552_43: Bits = (Bits::new(
            ((s_552_42) >> (s_552_39)).value(),
            u16::try_from(s_552_40).unwrap(),
        ));
        // D s_552_44: cast reint s_552_43 -> u8
        let s_552_44: u8 = (s_552_43.value() as u8);
        // D s_552_45: call decode_aarch32_instrs_VLD1_m_A2enc_A_txt(s_552_8, s_552_14, s_552_20, s_552_26, s_552_32, s_552_38, s_552_44)
        let s_552_45: () = decode_aarch32_instrs_VLD1_m_A2enc_A_txt(
            state,
            tracer,
            s_552_8,
            s_552_14,
            s_552_20,
            s_552_26,
            s_552_32,
            s_552_38,
            s_552_44,
        );
        // N s_552_46: return
        return;
    }
    fn block_553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_553_0: read-var merge#var.1:struct
        let s_553_0: u32 = fn_state.merge_var._1;
        // D s_553_1: write-var u#30987 <= s_553_0
        fn_state.u_30987 = s_553_0;
        // C s_553_2: const #23s : i
        let s_553_2: i128 = 23;
        // D s_553_3: read-var u#30987:u32
        let s_553_3: u32 = fn_state.u_30987;
        // D s_553_4: cast zx s_553_3 -> bv
        let s_553_4: Bits = Bits::new(s_553_3 as u128, 32u16);
        // C s_553_5: const #1s : i64
        let s_553_5: i64 = 1;
        // C s_553_6: cast zx s_553_5 -> i
        let s_553_6: i128 = (i128::try_from(s_553_5).unwrap());
        // C s_553_7: const #8s : i
        let s_553_7: i128 = 8;
        // C s_553_8: add s_553_7 s_553_6
        let s_553_8: i128 = (s_553_7 + s_553_6);
        // D s_553_9: bit-extract s_553_4 s_553_2 s_553_8
        let s_553_9: Bits = (Bits::new(
            ((s_553_4) >> (s_553_2)).value(),
            u16::try_from(s_553_8).unwrap(),
        ));
        // D s_553_10: cast reint s_553_9 -> u9
        let s_553_10: u16 = (s_553_9.value() as u16);
        // D s_553_11: cast zx s_553_10 -> bv
        let s_553_11: Bits = Bits::new(s_553_10 as u128, 9u16);
        // C s_553_12: const #488u : u9
        let s_553_12: u16 = 488;
        // C s_553_13: cast zx s_553_12 -> bv
        let s_553_13: Bits = Bits::new(s_553_12 as u128, 9u16);
        // D s_553_14: cmp-eq s_553_11 s_553_13
        let s_553_14: bool = ((s_553_11) == (s_553_13));
        // N s_553_15: branch s_553_14 b2790 b554
        if s_553_14 {
            return block_2790(state, tracer, fn_state);
        } else {
            return block_554(state, tracer, fn_state);
        };
    }
    fn block_554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_554_0: const #0u : u8
        let s_554_0: bool = false;
        // D s_554_1: write-var gs#399240 <= s_554_0
        fn_state.gs_399240 = s_554_0;
        // N s_554_2: jump b555
        return block_555(state, tracer, fn_state);
    }
    fn block_555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_555_0: read-var gs#399240:u8
        let s_555_0: bool = fn_state.gs_399240;
        // N s_555_1: branch s_555_0 b2789 b556
        if s_555_0 {
            return block_2789(state, tracer, fn_state);
        } else {
            return block_556(state, tracer, fn_state);
        };
    }
    fn block_556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_556_0: const #0u : u8
        let s_556_0: bool = false;
        // D s_556_1: write-var gs#399242 <= s_556_0
        fn_state.gs_399242 = s_556_0;
        // N s_556_2: jump b557
        return block_557(state, tracer, fn_state);
    }
    fn block_557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_557_0: read-var gs#399242:u8
        let s_557_0: bool = fn_state.gs_399242;
        // D s_557_1: not s_557_0
        let s_557_1: bool = !s_557_0;
        // N s_557_2: branch s_557_1 b559 b558
        if s_557_1 {
            return block_559(state, tracer, fn_state);
        } else {
            return block_558(state, tracer, fn_state);
        };
    }
    fn block_558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_558_0: const #3460s : i
        let s_558_0: i128 = 3460;
        // C s_558_1: const #14696u : u32
        let s_558_1: u32 = 14696;
        // N s_558_2: write-reg s_558_1 <= s_558_0
        let s_558_2: () = {
            state.write_register::<i128>(s_558_1 as isize, s_558_0);
            tracer.write_register(s_558_1 as isize, s_558_0);
        };
        // C s_558_3: const #22s : i
        let s_558_3: i128 = 22;
        // C s_558_4: const #1s : i
        let s_558_4: i128 = 1;
        // D s_558_5: read-var u#30987:u32
        let s_558_5: u32 = fn_state.u_30987;
        // D s_558_6: cast zx s_558_5 -> bv
        let s_558_6: Bits = Bits::new(s_558_5 as u128, 32u16);
        // D s_558_7: bit-extract s_558_6 s_558_3 s_558_4
        let s_558_7: Bits = (Bits::new(
            ((s_558_6) >> (s_558_3)).value(),
            u16::try_from(s_558_4).unwrap(),
        ));
        // D s_558_8: cast reint s_558_7 -> u8
        let s_558_8: bool = ((s_558_7.value()) != 0);
        // C s_558_9: const #16s : i
        let s_558_9: i128 = 16;
        // C s_558_10: const #4s : i
        let s_558_10: i128 = 4;
        // D s_558_11: read-var u#30987:u32
        let s_558_11: u32 = fn_state.u_30987;
        // D s_558_12: cast zx s_558_11 -> bv
        let s_558_12: Bits = Bits::new(s_558_11 as u128, 32u16);
        // D s_558_13: bit-extract s_558_12 s_558_9 s_558_10
        let s_558_13: Bits = (Bits::new(
            ((s_558_12) >> (s_558_9)).value(),
            u16::try_from(s_558_10).unwrap(),
        ));
        // D s_558_14: cast reint s_558_13 -> u8
        let s_558_14: u8 = (s_558_13.value() as u8);
        // C s_558_15: const #12s : i
        let s_558_15: i128 = 12;
        // C s_558_16: const #4s : i
        let s_558_16: i128 = 4;
        // D s_558_17: read-var u#30987:u32
        let s_558_17: u32 = fn_state.u_30987;
        // D s_558_18: cast zx s_558_17 -> bv
        let s_558_18: Bits = Bits::new(s_558_17 as u128, 32u16);
        // D s_558_19: bit-extract s_558_18 s_558_15 s_558_16
        let s_558_19: Bits = (Bits::new(
            ((s_558_18) >> (s_558_15)).value(),
            u16::try_from(s_558_16).unwrap(),
        ));
        // D s_558_20: cast reint s_558_19 -> u8
        let s_558_20: u8 = (s_558_19.value() as u8);
        // C s_558_21: const #8s : i
        let s_558_21: i128 = 8;
        // C s_558_22: const #4s : i
        let s_558_22: i128 = 4;
        // D s_558_23: read-var u#30987:u32
        let s_558_23: u32 = fn_state.u_30987;
        // D s_558_24: cast zx s_558_23 -> bv
        let s_558_24: Bits = Bits::new(s_558_23 as u128, 32u16);
        // D s_558_25: bit-extract s_558_24 s_558_21 s_558_22
        let s_558_25: Bits = (Bits::new(
            ((s_558_24) >> (s_558_21)).value(),
            u16::try_from(s_558_22).unwrap(),
        ));
        // D s_558_26: cast reint s_558_25 -> u8
        let s_558_26: u8 = (s_558_25.value() as u8);
        // C s_558_27: const #6s : i
        let s_558_27: i128 = 6;
        // C s_558_28: const #2s : i
        let s_558_28: i128 = 2;
        // D s_558_29: read-var u#30987:u32
        let s_558_29: u32 = fn_state.u_30987;
        // D s_558_30: cast zx s_558_29 -> bv
        let s_558_30: Bits = Bits::new(s_558_29 as u128, 32u16);
        // D s_558_31: bit-extract s_558_30 s_558_27 s_558_28
        let s_558_31: Bits = (Bits::new(
            ((s_558_30) >> (s_558_27)).value(),
            u16::try_from(s_558_28).unwrap(),
        ));
        // D s_558_32: cast reint s_558_31 -> u8
        let s_558_32: u8 = (s_558_31.value() as u8);
        // C s_558_33: const #4s : i
        let s_558_33: i128 = 4;
        // C s_558_34: const #2s : i
        let s_558_34: i128 = 2;
        // D s_558_35: read-var u#30987:u32
        let s_558_35: u32 = fn_state.u_30987;
        // D s_558_36: cast zx s_558_35 -> bv
        let s_558_36: Bits = Bits::new(s_558_35 as u128, 32u16);
        // D s_558_37: bit-extract s_558_36 s_558_33 s_558_34
        let s_558_37: Bits = (Bits::new(
            ((s_558_36) >> (s_558_33)).value(),
            u16::try_from(s_558_34).unwrap(),
        ));
        // D s_558_38: cast reint s_558_37 -> u8
        let s_558_38: u8 = (s_558_37.value() as u8);
        // C s_558_39: const #0s : i
        let s_558_39: i128 = 0;
        // C s_558_40: const #4s : i
        let s_558_40: i128 = 4;
        // D s_558_41: read-var u#30987:u32
        let s_558_41: u32 = fn_state.u_30987;
        // D s_558_42: cast zx s_558_41 -> bv
        let s_558_42: Bits = Bits::new(s_558_41 as u128, 32u16);
        // D s_558_43: bit-extract s_558_42 s_558_39 s_558_40
        let s_558_43: Bits = (Bits::new(
            ((s_558_42) >> (s_558_39)).value(),
            u16::try_from(s_558_40).unwrap(),
        ));
        // D s_558_44: cast reint s_558_43 -> u8
        let s_558_44: u8 = (s_558_43.value() as u8);
        // D s_558_45: call decode_aarch32_instrs_VLD1_m_A3enc_A_txt(s_558_8, s_558_14, s_558_20, s_558_26, s_558_32, s_558_38, s_558_44)
        let s_558_45: () = decode_aarch32_instrs_VLD1_m_A3enc_A_txt(
            state,
            tracer,
            s_558_8,
            s_558_14,
            s_558_20,
            s_558_26,
            s_558_32,
            s_558_38,
            s_558_44,
        );
        // N s_558_46: return
        return;
    }
    fn block_559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_559_0: read-var merge#var.1:struct
        let s_559_0: u32 = fn_state.merge_var._1;
        // D s_559_1: write-var u#30996 <= s_559_0
        fn_state.u_30996 = s_559_0;
        // C s_559_2: const #23s : i
        let s_559_2: i128 = 23;
        // D s_559_3: read-var u#30996:u32
        let s_559_3: u32 = fn_state.u_30996;
        // D s_559_4: cast zx s_559_3 -> bv
        let s_559_4: Bits = Bits::new(s_559_3 as u128, 32u16);
        // C s_559_5: const #1s : i64
        let s_559_5: i64 = 1;
        // C s_559_6: cast zx s_559_5 -> i
        let s_559_6: i128 = (i128::try_from(s_559_5).unwrap());
        // C s_559_7: const #8s : i
        let s_559_7: i128 = 8;
        // C s_559_8: add s_559_7 s_559_6
        let s_559_8: i128 = (s_559_7 + s_559_6);
        // D s_559_9: bit-extract s_559_4 s_559_2 s_559_8
        let s_559_9: Bits = (Bits::new(
            ((s_559_4) >> (s_559_2)).value(),
            u16::try_from(s_559_8).unwrap(),
        ));
        // D s_559_10: cast reint s_559_9 -> u9
        let s_559_10: u16 = (s_559_9.value() as u16);
        // D s_559_11: cast zx s_559_10 -> bv
        let s_559_11: Bits = Bits::new(s_559_10 as u128, 9u16);
        // C s_559_12: const #488u : u9
        let s_559_12: u16 = 488;
        // C s_559_13: cast zx s_559_12 -> bv
        let s_559_13: Bits = Bits::new(s_559_12 as u128, 9u16);
        // D s_559_14: cmp-eq s_559_11 s_559_13
        let s_559_14: bool = ((s_559_11) == (s_559_13));
        // N s_559_15: branch s_559_14 b2785 b560
        if s_559_14 {
            return block_2785(state, tracer, fn_state);
        } else {
            return block_560(state, tracer, fn_state);
        };
    }
    fn block_560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_560_0: const #0u : u8
        let s_560_0: bool = false;
        // D s_560_1: write-var gs#399267 <= s_560_0
        fn_state.gs_399267 = s_560_0;
        // N s_560_2: jump b561
        return block_561(state, tracer, fn_state);
    }
    fn block_561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_561_0: read-var gs#399267:u8
        let s_561_0: bool = fn_state.gs_399267;
        // N s_561_1: branch s_561_0 b2784 b562
        if s_561_0 {
            return block_2784(state, tracer, fn_state);
        } else {
            return block_562(state, tracer, fn_state);
        };
    }
    fn block_562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_562_0: const #0u : u8
        let s_562_0: bool = false;
        // D s_562_1: write-var gs#399269 <= s_562_0
        fn_state.gs_399269 = s_562_0;
        // N s_562_2: jump b563
        return block_563(state, tracer, fn_state);
    }
    fn block_563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_563_0: read-var gs#399269:u8
        let s_563_0: bool = fn_state.gs_399269;
        // D s_563_1: not s_563_0
        let s_563_1: bool = !s_563_0;
        // N s_563_2: branch s_563_1 b565 b564
        if s_563_1 {
            return block_565(state, tracer, fn_state);
        } else {
            return block_564(state, tracer, fn_state);
        };
    }
    fn block_564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_564_0: const #3461s : i
        let s_564_0: i128 = 3461;
        // C s_564_1: const #14696u : u32
        let s_564_1: u32 = 14696;
        // N s_564_2: write-reg s_564_1 <= s_564_0
        let s_564_2: () = {
            state.write_register::<i128>(s_564_1 as isize, s_564_0);
            tracer.write_register(s_564_1 as isize, s_564_0);
        };
        // C s_564_3: const #22s : i
        let s_564_3: i128 = 22;
        // C s_564_4: const #1s : i
        let s_564_4: i128 = 1;
        // D s_564_5: read-var u#30996:u32
        let s_564_5: u32 = fn_state.u_30996;
        // D s_564_6: cast zx s_564_5 -> bv
        let s_564_6: Bits = Bits::new(s_564_5 as u128, 32u16);
        // D s_564_7: bit-extract s_564_6 s_564_3 s_564_4
        let s_564_7: Bits = (Bits::new(
            ((s_564_6) >> (s_564_3)).value(),
            u16::try_from(s_564_4).unwrap(),
        ));
        // D s_564_8: cast reint s_564_7 -> u8
        let s_564_8: bool = ((s_564_7.value()) != 0);
        // C s_564_9: const #16s : i
        let s_564_9: i128 = 16;
        // C s_564_10: const #4s : i
        let s_564_10: i128 = 4;
        // D s_564_11: read-var u#30996:u32
        let s_564_11: u32 = fn_state.u_30996;
        // D s_564_12: cast zx s_564_11 -> bv
        let s_564_12: Bits = Bits::new(s_564_11 as u128, 32u16);
        // D s_564_13: bit-extract s_564_12 s_564_9 s_564_10
        let s_564_13: Bits = (Bits::new(
            ((s_564_12) >> (s_564_9)).value(),
            u16::try_from(s_564_10).unwrap(),
        ));
        // D s_564_14: cast reint s_564_13 -> u8
        let s_564_14: u8 = (s_564_13.value() as u8);
        // C s_564_15: const #12s : i
        let s_564_15: i128 = 12;
        // C s_564_16: const #4s : i
        let s_564_16: i128 = 4;
        // D s_564_17: read-var u#30996:u32
        let s_564_17: u32 = fn_state.u_30996;
        // D s_564_18: cast zx s_564_17 -> bv
        let s_564_18: Bits = Bits::new(s_564_17 as u128, 32u16);
        // D s_564_19: bit-extract s_564_18 s_564_15 s_564_16
        let s_564_19: Bits = (Bits::new(
            ((s_564_18) >> (s_564_15)).value(),
            u16::try_from(s_564_16).unwrap(),
        ));
        // D s_564_20: cast reint s_564_19 -> u8
        let s_564_20: u8 = (s_564_19.value() as u8);
        // C s_564_21: const #8s : i
        let s_564_21: i128 = 8;
        // C s_564_22: const #4s : i
        let s_564_22: i128 = 4;
        // D s_564_23: read-var u#30996:u32
        let s_564_23: u32 = fn_state.u_30996;
        // D s_564_24: cast zx s_564_23 -> bv
        let s_564_24: Bits = Bits::new(s_564_23 as u128, 32u16);
        // D s_564_25: bit-extract s_564_24 s_564_21 s_564_22
        let s_564_25: Bits = (Bits::new(
            ((s_564_24) >> (s_564_21)).value(),
            u16::try_from(s_564_22).unwrap(),
        ));
        // D s_564_26: cast reint s_564_25 -> u8
        let s_564_26: u8 = (s_564_25.value() as u8);
        // C s_564_27: const #6s : i
        let s_564_27: i128 = 6;
        // C s_564_28: const #2s : i
        let s_564_28: i128 = 2;
        // D s_564_29: read-var u#30996:u32
        let s_564_29: u32 = fn_state.u_30996;
        // D s_564_30: cast zx s_564_29 -> bv
        let s_564_30: Bits = Bits::new(s_564_29 as u128, 32u16);
        // D s_564_31: bit-extract s_564_30 s_564_27 s_564_28
        let s_564_31: Bits = (Bits::new(
            ((s_564_30) >> (s_564_27)).value(),
            u16::try_from(s_564_28).unwrap(),
        ));
        // D s_564_32: cast reint s_564_31 -> u8
        let s_564_32: u8 = (s_564_31.value() as u8);
        // C s_564_33: const #4s : i
        let s_564_33: i128 = 4;
        // C s_564_34: const #2s : i
        let s_564_34: i128 = 2;
        // D s_564_35: read-var u#30996:u32
        let s_564_35: u32 = fn_state.u_30996;
        // D s_564_36: cast zx s_564_35 -> bv
        let s_564_36: Bits = Bits::new(s_564_35 as u128, 32u16);
        // D s_564_37: bit-extract s_564_36 s_564_33 s_564_34
        let s_564_37: Bits = (Bits::new(
            ((s_564_36) >> (s_564_33)).value(),
            u16::try_from(s_564_34).unwrap(),
        ));
        // D s_564_38: cast reint s_564_37 -> u8
        let s_564_38: u8 = (s_564_37.value() as u8);
        // C s_564_39: const #0s : i
        let s_564_39: i128 = 0;
        // C s_564_40: const #4s : i
        let s_564_40: i128 = 4;
        // D s_564_41: read-var u#30996:u32
        let s_564_41: u32 = fn_state.u_30996;
        // D s_564_42: cast zx s_564_41 -> bv
        let s_564_42: Bits = Bits::new(s_564_41 as u128, 32u16);
        // D s_564_43: bit-extract s_564_42 s_564_39 s_564_40
        let s_564_43: Bits = (Bits::new(
            ((s_564_42) >> (s_564_39)).value(),
            u16::try_from(s_564_40).unwrap(),
        ));
        // D s_564_44: cast reint s_564_43 -> u8
        let s_564_44: u8 = (s_564_43.value() as u8);
        // D s_564_45: call decode_aarch32_instrs_VLD1_m_A4enc_A_txt(s_564_8, s_564_14, s_564_20, s_564_26, s_564_32, s_564_38, s_564_44)
        let s_564_45: () = decode_aarch32_instrs_VLD1_m_A4enc_A_txt(
            state,
            tracer,
            s_564_8,
            s_564_14,
            s_564_20,
            s_564_26,
            s_564_32,
            s_564_38,
            s_564_44,
        );
        // N s_564_46: return
        return;
    }
    fn block_565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_565_0: read-var merge#var.1:struct
        let s_565_0: u32 = fn_state.merge_var._1;
        // D s_565_1: write-var u#31005 <= s_565_0
        fn_state.u_31005 = s_565_0;
        // C s_565_2: const #23s : i
        let s_565_2: i128 = 23;
        // D s_565_3: read-var u#31005:u32
        let s_565_3: u32 = fn_state.u_31005;
        // D s_565_4: cast zx s_565_3 -> bv
        let s_565_4: Bits = Bits::new(s_565_3 as u128, 32u16);
        // C s_565_5: const #1s : i64
        let s_565_5: i64 = 1;
        // C s_565_6: cast zx s_565_5 -> i
        let s_565_6: i128 = (i128::try_from(s_565_5).unwrap());
        // C s_565_7: const #8s : i
        let s_565_7: i128 = 8;
        // C s_565_8: add s_565_7 s_565_6
        let s_565_8: i128 = (s_565_7 + s_565_6);
        // D s_565_9: bit-extract s_565_4 s_565_2 s_565_8
        let s_565_9: Bits = (Bits::new(
            ((s_565_4) >> (s_565_2)).value(),
            u16::try_from(s_565_8).unwrap(),
        ));
        // D s_565_10: cast reint s_565_9 -> u9
        let s_565_10: u16 = (s_565_9.value() as u16);
        // D s_565_11: cast zx s_565_10 -> bv
        let s_565_11: Bits = Bits::new(s_565_10 as u128, 9u16);
        // C s_565_12: const #489u : u9
        let s_565_12: u16 = 489;
        // C s_565_13: cast zx s_565_12 -> bv
        let s_565_13: Bits = Bits::new(s_565_12 as u128, 9u16);
        // D s_565_14: cmp-eq s_565_11 s_565_13
        let s_565_14: bool = ((s_565_11) == (s_565_13));
        // N s_565_15: branch s_565_14 b2780 b566
        if s_565_14 {
            return block_2780(state, tracer, fn_state);
        } else {
            return block_566(state, tracer, fn_state);
        };
    }
    fn block_566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_566_0: const #0u : u8
        let s_566_0: bool = false;
        // D s_566_1: write-var gs#399294 <= s_566_0
        fn_state.gs_399294 = s_566_0;
        // N s_566_2: jump b567
        return block_567(state, tracer, fn_state);
    }
    fn block_567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_567_0: read-var gs#399294:u8
        let s_567_0: bool = fn_state.gs_399294;
        // N s_567_1: branch s_567_0 b2779 b568
        if s_567_0 {
            return block_2779(state, tracer, fn_state);
        } else {
            return block_568(state, tracer, fn_state);
        };
    }
    fn block_568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_568_0: const #0u : u8
        let s_568_0: bool = false;
        // D s_568_1: write-var gs#399296 <= s_568_0
        fn_state.gs_399296 = s_568_0;
        // N s_568_2: jump b569
        return block_569(state, tracer, fn_state);
    }
    fn block_569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_569_0: read-var gs#399296:u8
        let s_569_0: bool = fn_state.gs_399296;
        // D s_569_1: not s_569_0
        let s_569_1: bool = !s_569_0;
        // N s_569_2: branch s_569_1 b571 b570
        if s_569_1 {
            return block_571(state, tracer, fn_state);
        } else {
            return block_570(state, tracer, fn_state);
        };
    }
    fn block_570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_570_0: const #3466s : i
        let s_570_0: i128 = 3466;
        // C s_570_1: const #14696u : u32
        let s_570_1: u32 = 14696;
        // N s_570_2: write-reg s_570_1 <= s_570_0
        let s_570_2: () = {
            state.write_register::<i128>(s_570_1 as isize, s_570_0);
            tracer.write_register(s_570_1 as isize, s_570_0);
        };
        // C s_570_3: const #22s : i
        let s_570_3: i128 = 22;
        // C s_570_4: const #1s : i
        let s_570_4: i128 = 1;
        // D s_570_5: read-var u#31005:u32
        let s_570_5: u32 = fn_state.u_31005;
        // D s_570_6: cast zx s_570_5 -> bv
        let s_570_6: Bits = Bits::new(s_570_5 as u128, 32u16);
        // D s_570_7: bit-extract s_570_6 s_570_3 s_570_4
        let s_570_7: Bits = (Bits::new(
            ((s_570_6) >> (s_570_3)).value(),
            u16::try_from(s_570_4).unwrap(),
        ));
        // D s_570_8: cast reint s_570_7 -> u8
        let s_570_8: bool = ((s_570_7.value()) != 0);
        // C s_570_9: const #16s : i
        let s_570_9: i128 = 16;
        // C s_570_10: const #4s : i
        let s_570_10: i128 = 4;
        // D s_570_11: read-var u#31005:u32
        let s_570_11: u32 = fn_state.u_31005;
        // D s_570_12: cast zx s_570_11 -> bv
        let s_570_12: Bits = Bits::new(s_570_11 as u128, 32u16);
        // D s_570_13: bit-extract s_570_12 s_570_9 s_570_10
        let s_570_13: Bits = (Bits::new(
            ((s_570_12) >> (s_570_9)).value(),
            u16::try_from(s_570_10).unwrap(),
        ));
        // D s_570_14: cast reint s_570_13 -> u8
        let s_570_14: u8 = (s_570_13.value() as u8);
        // C s_570_15: const #12s : i
        let s_570_15: i128 = 12;
        // C s_570_16: const #4s : i
        let s_570_16: i128 = 4;
        // D s_570_17: read-var u#31005:u32
        let s_570_17: u32 = fn_state.u_31005;
        // D s_570_18: cast zx s_570_17 -> bv
        let s_570_18: Bits = Bits::new(s_570_17 as u128, 32u16);
        // D s_570_19: bit-extract s_570_18 s_570_15 s_570_16
        let s_570_19: Bits = (Bits::new(
            ((s_570_18) >> (s_570_15)).value(),
            u16::try_from(s_570_16).unwrap(),
        ));
        // D s_570_20: cast reint s_570_19 -> u8
        let s_570_20: u8 = (s_570_19.value() as u8);
        // C s_570_21: const #10s : i
        let s_570_21: i128 = 10;
        // C s_570_22: const #2s : i
        let s_570_22: i128 = 2;
        // D s_570_23: read-var u#31005:u32
        let s_570_23: u32 = fn_state.u_31005;
        // D s_570_24: cast zx s_570_23 -> bv
        let s_570_24: Bits = Bits::new(s_570_23 as u128, 32u16);
        // D s_570_25: bit-extract s_570_24 s_570_21 s_570_22
        let s_570_25: Bits = (Bits::new(
            ((s_570_24) >> (s_570_21)).value(),
            u16::try_from(s_570_22).unwrap(),
        ));
        // D s_570_26: cast reint s_570_25 -> u8
        let s_570_26: u8 = (s_570_25.value() as u8);
        // C s_570_27: const #4s : i
        let s_570_27: i128 = 4;
        // C s_570_28: const #4s : i
        let s_570_28: i128 = 4;
        // D s_570_29: read-var u#31005:u32
        let s_570_29: u32 = fn_state.u_31005;
        // D s_570_30: cast zx s_570_29 -> bv
        let s_570_30: Bits = Bits::new(s_570_29 as u128, 32u16);
        // D s_570_31: bit-extract s_570_30 s_570_27 s_570_28
        let s_570_31: Bits = (Bits::new(
            ((s_570_30) >> (s_570_27)).value(),
            u16::try_from(s_570_28).unwrap(),
        ));
        // D s_570_32: cast reint s_570_31 -> u8
        let s_570_32: u8 = (s_570_31.value() as u8);
        // C s_570_33: const #0s : i
        let s_570_33: i128 = 0;
        // C s_570_34: const #4s : i
        let s_570_34: i128 = 4;
        // D s_570_35: read-var u#31005:u32
        let s_570_35: u32 = fn_state.u_31005;
        // D s_570_36: cast zx s_570_35 -> bv
        let s_570_36: Bits = Bits::new(s_570_35 as u128, 32u16);
        // D s_570_37: bit-extract s_570_36 s_570_33 s_570_34
        let s_570_37: Bits = (Bits::new(
            ((s_570_36) >> (s_570_33)).value(),
            u16::try_from(s_570_34).unwrap(),
        ));
        // D s_570_38: cast reint s_570_37 -> u8
        let s_570_38: u8 = (s_570_37.value() as u8);
        // D s_570_39: call decode_aarch32_instrs_VLD2_1_A1enc_A_txt(s_570_8, s_570_14, s_570_20, s_570_26, s_570_32, s_570_38)
        let s_570_39: () = decode_aarch32_instrs_VLD2_1_A1enc_A_txt(
            state,
            tracer,
            s_570_8,
            s_570_14,
            s_570_20,
            s_570_26,
            s_570_32,
            s_570_38,
        );
        // N s_570_40: return
        return;
    }
    fn block_571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_571_0: read-var merge#var.1:struct
        let s_571_0: u32 = fn_state.merge_var._1;
        // D s_571_1: write-var u#31013 <= s_571_0
        fn_state.u_31013 = s_571_0;
        // C s_571_2: const #23s : i
        let s_571_2: i128 = 23;
        // D s_571_3: read-var u#31013:u32
        let s_571_3: u32 = fn_state.u_31013;
        // D s_571_4: cast zx s_571_3 -> bv
        let s_571_4: Bits = Bits::new(s_571_3 as u128, 32u16);
        // C s_571_5: const #1s : i64
        let s_571_5: i64 = 1;
        // C s_571_6: cast zx s_571_5 -> i
        let s_571_6: i128 = (i128::try_from(s_571_5).unwrap());
        // C s_571_7: const #8s : i
        let s_571_7: i128 = 8;
        // C s_571_8: add s_571_7 s_571_6
        let s_571_8: i128 = (s_571_7 + s_571_6);
        // D s_571_9: bit-extract s_571_4 s_571_2 s_571_8
        let s_571_9: Bits = (Bits::new(
            ((s_571_4) >> (s_571_2)).value(),
            u16::try_from(s_571_8).unwrap(),
        ));
        // D s_571_10: cast reint s_571_9 -> u9
        let s_571_10: u16 = (s_571_9.value() as u16);
        // D s_571_11: cast zx s_571_10 -> bv
        let s_571_11: Bits = Bits::new(s_571_10 as u128, 9u16);
        // C s_571_12: const #489u : u9
        let s_571_12: u16 = 489;
        // C s_571_13: cast zx s_571_12 -> bv
        let s_571_13: Bits = Bits::new(s_571_12 as u128, 9u16);
        // D s_571_14: cmp-eq s_571_11 s_571_13
        let s_571_14: bool = ((s_571_11) == (s_571_13));
        // N s_571_15: branch s_571_14 b2775 b572
        if s_571_14 {
            return block_2775(state, tracer, fn_state);
        } else {
            return block_572(state, tracer, fn_state);
        };
    }
    fn block_572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_572_0: const #0u : u8
        let s_572_0: bool = false;
        // D s_572_1: write-var gs#399319 <= s_572_0
        fn_state.gs_399319 = s_572_0;
        // N s_572_2: jump b573
        return block_573(state, tracer, fn_state);
    }
    fn block_573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_573_0: read-var gs#399319:u8
        let s_573_0: bool = fn_state.gs_399319;
        // N s_573_1: branch s_573_0 b2774 b574
        if s_573_0 {
            return block_2774(state, tracer, fn_state);
        } else {
            return block_574(state, tracer, fn_state);
        };
    }
    fn block_574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_574_0: const #0u : u8
        let s_574_0: bool = false;
        // D s_574_1: write-var gs#399321 <= s_574_0
        fn_state.gs_399321 = s_574_0;
        // N s_574_2: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_575_0: read-var gs#399321:u8
        let s_575_0: bool = fn_state.gs_399321;
        // D s_575_1: not s_575_0
        let s_575_1: bool = !s_575_0;
        // N s_575_2: branch s_575_1 b577 b576
        if s_575_1 {
            return block_577(state, tracer, fn_state);
        } else {
            return block_576(state, tracer, fn_state);
        };
    }
    fn block_576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_576_0: const #3467s : i
        let s_576_0: i128 = 3467;
        // C s_576_1: const #14696u : u32
        let s_576_1: u32 = 14696;
        // N s_576_2: write-reg s_576_1 <= s_576_0
        let s_576_2: () = {
            state.write_register::<i128>(s_576_1 as isize, s_576_0);
            tracer.write_register(s_576_1 as isize, s_576_0);
        };
        // C s_576_3: const #22s : i
        let s_576_3: i128 = 22;
        // C s_576_4: const #1s : i
        let s_576_4: i128 = 1;
        // D s_576_5: read-var u#31013:u32
        let s_576_5: u32 = fn_state.u_31013;
        // D s_576_6: cast zx s_576_5 -> bv
        let s_576_6: Bits = Bits::new(s_576_5 as u128, 32u16);
        // D s_576_7: bit-extract s_576_6 s_576_3 s_576_4
        let s_576_7: Bits = (Bits::new(
            ((s_576_6) >> (s_576_3)).value(),
            u16::try_from(s_576_4).unwrap(),
        ));
        // D s_576_8: cast reint s_576_7 -> u8
        let s_576_8: bool = ((s_576_7.value()) != 0);
        // C s_576_9: const #16s : i
        let s_576_9: i128 = 16;
        // C s_576_10: const #4s : i
        let s_576_10: i128 = 4;
        // D s_576_11: read-var u#31013:u32
        let s_576_11: u32 = fn_state.u_31013;
        // D s_576_12: cast zx s_576_11 -> bv
        let s_576_12: Bits = Bits::new(s_576_11 as u128, 32u16);
        // D s_576_13: bit-extract s_576_12 s_576_9 s_576_10
        let s_576_13: Bits = (Bits::new(
            ((s_576_12) >> (s_576_9)).value(),
            u16::try_from(s_576_10).unwrap(),
        ));
        // D s_576_14: cast reint s_576_13 -> u8
        let s_576_14: u8 = (s_576_13.value() as u8);
        // C s_576_15: const #12s : i
        let s_576_15: i128 = 12;
        // C s_576_16: const #4s : i
        let s_576_16: i128 = 4;
        // D s_576_17: read-var u#31013:u32
        let s_576_17: u32 = fn_state.u_31013;
        // D s_576_18: cast zx s_576_17 -> bv
        let s_576_18: Bits = Bits::new(s_576_17 as u128, 32u16);
        // D s_576_19: bit-extract s_576_18 s_576_15 s_576_16
        let s_576_19: Bits = (Bits::new(
            ((s_576_18) >> (s_576_15)).value(),
            u16::try_from(s_576_16).unwrap(),
        ));
        // D s_576_20: cast reint s_576_19 -> u8
        let s_576_20: u8 = (s_576_19.value() as u8);
        // C s_576_21: const #10s : i
        let s_576_21: i128 = 10;
        // C s_576_22: const #2s : i
        let s_576_22: i128 = 2;
        // D s_576_23: read-var u#31013:u32
        let s_576_23: u32 = fn_state.u_31013;
        // D s_576_24: cast zx s_576_23 -> bv
        let s_576_24: Bits = Bits::new(s_576_23 as u128, 32u16);
        // D s_576_25: bit-extract s_576_24 s_576_21 s_576_22
        let s_576_25: Bits = (Bits::new(
            ((s_576_24) >> (s_576_21)).value(),
            u16::try_from(s_576_22).unwrap(),
        ));
        // D s_576_26: cast reint s_576_25 -> u8
        let s_576_26: u8 = (s_576_25.value() as u8);
        // C s_576_27: const #4s : i
        let s_576_27: i128 = 4;
        // C s_576_28: const #4s : i
        let s_576_28: i128 = 4;
        // D s_576_29: read-var u#31013:u32
        let s_576_29: u32 = fn_state.u_31013;
        // D s_576_30: cast zx s_576_29 -> bv
        let s_576_30: Bits = Bits::new(s_576_29 as u128, 32u16);
        // D s_576_31: bit-extract s_576_30 s_576_27 s_576_28
        let s_576_31: Bits = (Bits::new(
            ((s_576_30) >> (s_576_27)).value(),
            u16::try_from(s_576_28).unwrap(),
        ));
        // D s_576_32: cast reint s_576_31 -> u8
        let s_576_32: u8 = (s_576_31.value() as u8);
        // C s_576_33: const #0s : i
        let s_576_33: i128 = 0;
        // C s_576_34: const #4s : i
        let s_576_34: i128 = 4;
        // D s_576_35: read-var u#31013:u32
        let s_576_35: u32 = fn_state.u_31013;
        // D s_576_36: cast zx s_576_35 -> bv
        let s_576_36: Bits = Bits::new(s_576_35 as u128, 32u16);
        // D s_576_37: bit-extract s_576_36 s_576_33 s_576_34
        let s_576_37: Bits = (Bits::new(
            ((s_576_36) >> (s_576_33)).value(),
            u16::try_from(s_576_34).unwrap(),
        ));
        // D s_576_38: cast reint s_576_37 -> u8
        let s_576_38: u8 = (s_576_37.value() as u8);
        // D s_576_39: call decode_aarch32_instrs_VLD2_1_A2enc_A_txt(s_576_8, s_576_14, s_576_20, s_576_26, s_576_32, s_576_38)
        let s_576_39: () = decode_aarch32_instrs_VLD2_1_A2enc_A_txt(
            state,
            tracer,
            s_576_8,
            s_576_14,
            s_576_20,
            s_576_26,
            s_576_32,
            s_576_38,
        );
        // N s_576_40: return
        return;
    }
    fn block_577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_577_0: read-var merge#var.1:struct
        let s_577_0: u32 = fn_state.merge_var._1;
        // D s_577_1: write-var u#31021 <= s_577_0
        fn_state.u_31021 = s_577_0;
        // C s_577_2: const #23s : i
        let s_577_2: i128 = 23;
        // D s_577_3: read-var u#31021:u32
        let s_577_3: u32 = fn_state.u_31021;
        // D s_577_4: cast zx s_577_3 -> bv
        let s_577_4: Bits = Bits::new(s_577_3 as u128, 32u16);
        // C s_577_5: const #1s : i64
        let s_577_5: i64 = 1;
        // C s_577_6: cast zx s_577_5 -> i
        let s_577_6: i128 = (i128::try_from(s_577_5).unwrap());
        // C s_577_7: const #8s : i
        let s_577_7: i128 = 8;
        // C s_577_8: add s_577_7 s_577_6
        let s_577_8: i128 = (s_577_7 + s_577_6);
        // D s_577_9: bit-extract s_577_4 s_577_2 s_577_8
        let s_577_9: Bits = (Bits::new(
            ((s_577_4) >> (s_577_2)).value(),
            u16::try_from(s_577_8).unwrap(),
        ));
        // D s_577_10: cast reint s_577_9 -> u9
        let s_577_10: u16 = (s_577_9.value() as u16);
        // D s_577_11: cast zx s_577_10 -> bv
        let s_577_11: Bits = Bits::new(s_577_10 as u128, 9u16);
        // C s_577_12: const #489u : u9
        let s_577_12: u16 = 489;
        // C s_577_13: cast zx s_577_12 -> bv
        let s_577_13: Bits = Bits::new(s_577_12 as u128, 9u16);
        // D s_577_14: cmp-eq s_577_11 s_577_13
        let s_577_14: bool = ((s_577_11) == (s_577_13));
        // N s_577_15: branch s_577_14 b2770 b578
        if s_577_14 {
            return block_2770(state, tracer, fn_state);
        } else {
            return block_578(state, tracer, fn_state);
        };
    }
    fn block_578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_578_0: const #0u : u8
        let s_578_0: bool = false;
        // D s_578_1: write-var gs#399344 <= s_578_0
        fn_state.gs_399344 = s_578_0;
        // N s_578_2: jump b579
        return block_579(state, tracer, fn_state);
    }
    fn block_579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_579_0: read-var gs#399344:u8
        let s_579_0: bool = fn_state.gs_399344;
        // N s_579_1: branch s_579_0 b2769 b580
        if s_579_0 {
            return block_2769(state, tracer, fn_state);
        } else {
            return block_580(state, tracer, fn_state);
        };
    }
    fn block_580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_580_0: const #0u : u8
        let s_580_0: bool = false;
        // D s_580_1: write-var gs#399346 <= s_580_0
        fn_state.gs_399346 = s_580_0;
        // N s_580_2: jump b581
        return block_581(state, tracer, fn_state);
    }
    fn block_581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_581_0: read-var gs#399346:u8
        let s_581_0: bool = fn_state.gs_399346;
        // D s_581_1: not s_581_0
        let s_581_1: bool = !s_581_0;
        // N s_581_2: branch s_581_1 b583 b582
        if s_581_1 {
            return block_583(state, tracer, fn_state);
        } else {
            return block_582(state, tracer, fn_state);
        };
    }
    fn block_582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_582_0: const #3468s : i
        let s_582_0: i128 = 3468;
        // C s_582_1: const #14696u : u32
        let s_582_1: u32 = 14696;
        // N s_582_2: write-reg s_582_1 <= s_582_0
        let s_582_2: () = {
            state.write_register::<i128>(s_582_1 as isize, s_582_0);
            tracer.write_register(s_582_1 as isize, s_582_0);
        };
        // C s_582_3: const #22s : i
        let s_582_3: i128 = 22;
        // C s_582_4: const #1s : i
        let s_582_4: i128 = 1;
        // D s_582_5: read-var u#31021:u32
        let s_582_5: u32 = fn_state.u_31021;
        // D s_582_6: cast zx s_582_5 -> bv
        let s_582_6: Bits = Bits::new(s_582_5 as u128, 32u16);
        // D s_582_7: bit-extract s_582_6 s_582_3 s_582_4
        let s_582_7: Bits = (Bits::new(
            ((s_582_6) >> (s_582_3)).value(),
            u16::try_from(s_582_4).unwrap(),
        ));
        // D s_582_8: cast reint s_582_7 -> u8
        let s_582_8: bool = ((s_582_7.value()) != 0);
        // C s_582_9: const #16s : i
        let s_582_9: i128 = 16;
        // C s_582_10: const #4s : i
        let s_582_10: i128 = 4;
        // D s_582_11: read-var u#31021:u32
        let s_582_11: u32 = fn_state.u_31021;
        // D s_582_12: cast zx s_582_11 -> bv
        let s_582_12: Bits = Bits::new(s_582_11 as u128, 32u16);
        // D s_582_13: bit-extract s_582_12 s_582_9 s_582_10
        let s_582_13: Bits = (Bits::new(
            ((s_582_12) >> (s_582_9)).value(),
            u16::try_from(s_582_10).unwrap(),
        ));
        // D s_582_14: cast reint s_582_13 -> u8
        let s_582_14: u8 = (s_582_13.value() as u8);
        // C s_582_15: const #12s : i
        let s_582_15: i128 = 12;
        // C s_582_16: const #4s : i
        let s_582_16: i128 = 4;
        // D s_582_17: read-var u#31021:u32
        let s_582_17: u32 = fn_state.u_31021;
        // D s_582_18: cast zx s_582_17 -> bv
        let s_582_18: Bits = Bits::new(s_582_17 as u128, 32u16);
        // D s_582_19: bit-extract s_582_18 s_582_15 s_582_16
        let s_582_19: Bits = (Bits::new(
            ((s_582_18) >> (s_582_15)).value(),
            u16::try_from(s_582_16).unwrap(),
        ));
        // D s_582_20: cast reint s_582_19 -> u8
        let s_582_20: u8 = (s_582_19.value() as u8);
        // C s_582_21: const #10s : i
        let s_582_21: i128 = 10;
        // C s_582_22: const #2s : i
        let s_582_22: i128 = 2;
        // D s_582_23: read-var u#31021:u32
        let s_582_23: u32 = fn_state.u_31021;
        // D s_582_24: cast zx s_582_23 -> bv
        let s_582_24: Bits = Bits::new(s_582_23 as u128, 32u16);
        // D s_582_25: bit-extract s_582_24 s_582_21 s_582_22
        let s_582_25: Bits = (Bits::new(
            ((s_582_24) >> (s_582_21)).value(),
            u16::try_from(s_582_22).unwrap(),
        ));
        // D s_582_26: cast reint s_582_25 -> u8
        let s_582_26: u8 = (s_582_25.value() as u8);
        // C s_582_27: const #4s : i
        let s_582_27: i128 = 4;
        // C s_582_28: const #4s : i
        let s_582_28: i128 = 4;
        // D s_582_29: read-var u#31021:u32
        let s_582_29: u32 = fn_state.u_31021;
        // D s_582_30: cast zx s_582_29 -> bv
        let s_582_30: Bits = Bits::new(s_582_29 as u128, 32u16);
        // D s_582_31: bit-extract s_582_30 s_582_27 s_582_28
        let s_582_31: Bits = (Bits::new(
            ((s_582_30) >> (s_582_27)).value(),
            u16::try_from(s_582_28).unwrap(),
        ));
        // D s_582_32: cast reint s_582_31 -> u8
        let s_582_32: u8 = (s_582_31.value() as u8);
        // C s_582_33: const #0s : i
        let s_582_33: i128 = 0;
        // C s_582_34: const #4s : i
        let s_582_34: i128 = 4;
        // D s_582_35: read-var u#31021:u32
        let s_582_35: u32 = fn_state.u_31021;
        // D s_582_36: cast zx s_582_35 -> bv
        let s_582_36: Bits = Bits::new(s_582_35 as u128, 32u16);
        // D s_582_37: bit-extract s_582_36 s_582_33 s_582_34
        let s_582_37: Bits = (Bits::new(
            ((s_582_36) >> (s_582_33)).value(),
            u16::try_from(s_582_34).unwrap(),
        ));
        // D s_582_38: cast reint s_582_37 -> u8
        let s_582_38: u8 = (s_582_37.value() as u8);
        // D s_582_39: call decode_aarch32_instrs_VLD2_1_A3enc_A_txt(s_582_8, s_582_14, s_582_20, s_582_26, s_582_32, s_582_38)
        let s_582_39: () = decode_aarch32_instrs_VLD2_1_A3enc_A_txt(
            state,
            tracer,
            s_582_8,
            s_582_14,
            s_582_20,
            s_582_26,
            s_582_32,
            s_582_38,
        );
        // N s_582_40: return
        return;
    }
    fn block_583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_583_0: read-var merge#var.1:struct
        let s_583_0: u32 = fn_state.merge_var._1;
        // D s_583_1: write-var u#31029 <= s_583_0
        fn_state.u_31029 = s_583_0;
        // C s_583_2: const #23s : i
        let s_583_2: i128 = 23;
        // D s_583_3: read-var u#31029:u32
        let s_583_3: u32 = fn_state.u_31029;
        // D s_583_4: cast zx s_583_3 -> bv
        let s_583_4: Bits = Bits::new(s_583_3 as u128, 32u16);
        // C s_583_5: const #1s : i64
        let s_583_5: i64 = 1;
        // C s_583_6: cast zx s_583_5 -> i
        let s_583_6: i128 = (i128::try_from(s_583_5).unwrap());
        // C s_583_7: const #8s : i
        let s_583_7: i128 = 8;
        // C s_583_8: add s_583_7 s_583_6
        let s_583_8: i128 = (s_583_7 + s_583_6);
        // D s_583_9: bit-extract s_583_4 s_583_2 s_583_8
        let s_583_9: Bits = (Bits::new(
            ((s_583_4) >> (s_583_2)).value(),
            u16::try_from(s_583_8).unwrap(),
        ));
        // D s_583_10: cast reint s_583_9 -> u9
        let s_583_10: u16 = (s_583_9.value() as u16);
        // D s_583_11: cast zx s_583_10 -> bv
        let s_583_11: Bits = Bits::new(s_583_10 as u128, 9u16);
        // C s_583_12: const #489u : u9
        let s_583_12: u16 = 489;
        // C s_583_13: cast zx s_583_12 -> bv
        let s_583_13: Bits = Bits::new(s_583_12 as u128, 9u16);
        // D s_583_14: cmp-eq s_583_11 s_583_13
        let s_583_14: bool = ((s_583_11) == (s_583_13));
        // N s_583_15: branch s_583_14 b2765 b584
        if s_583_14 {
            return block_2765(state, tracer, fn_state);
        } else {
            return block_584(state, tracer, fn_state);
        };
    }
    fn block_584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_584_0: const #0u : u8
        let s_584_0: bool = false;
        // D s_584_1: write-var gs#399369 <= s_584_0
        fn_state.gs_399369 = s_584_0;
        // N s_584_2: jump b585
        return block_585(state, tracer, fn_state);
    }
    fn block_585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_585_0: read-var gs#399369:u8
        let s_585_0: bool = fn_state.gs_399369;
        // N s_585_1: branch s_585_0 b2764 b586
        if s_585_0 {
            return block_2764(state, tracer, fn_state);
        } else {
            return block_586(state, tracer, fn_state);
        };
    }
    fn block_586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_586_0: const #0u : u8
        let s_586_0: bool = false;
        // D s_586_1: write-var gs#399371 <= s_586_0
        fn_state.gs_399371 = s_586_0;
        // N s_586_2: jump b587
        return block_587(state, tracer, fn_state);
    }
    fn block_587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_587_0: read-var gs#399371:u8
        let s_587_0: bool = fn_state.gs_399371;
        // D s_587_1: not s_587_0
        let s_587_1: bool = !s_587_0;
        // N s_587_2: branch s_587_1 b589 b588
        if s_587_1 {
            return block_589(state, tracer, fn_state);
        } else {
            return block_588(state, tracer, fn_state);
        };
    }
    fn block_588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_588_0: const #3472s : i
        let s_588_0: i128 = 3472;
        // C s_588_1: const #14696u : u32
        let s_588_1: u32 = 14696;
        // N s_588_2: write-reg s_588_1 <= s_588_0
        let s_588_2: () = {
            state.write_register::<i128>(s_588_1 as isize, s_588_0);
            tracer.write_register(s_588_1 as isize, s_588_0);
        };
        // C s_588_3: const #22s : i
        let s_588_3: i128 = 22;
        // C s_588_4: const #1s : i
        let s_588_4: i128 = 1;
        // D s_588_5: read-var u#31029:u32
        let s_588_5: u32 = fn_state.u_31029;
        // D s_588_6: cast zx s_588_5 -> bv
        let s_588_6: Bits = Bits::new(s_588_5 as u128, 32u16);
        // D s_588_7: bit-extract s_588_6 s_588_3 s_588_4
        let s_588_7: Bits = (Bits::new(
            ((s_588_6) >> (s_588_3)).value(),
            u16::try_from(s_588_4).unwrap(),
        ));
        // D s_588_8: cast reint s_588_7 -> u8
        let s_588_8: bool = ((s_588_7.value()) != 0);
        // C s_588_9: const #16s : i
        let s_588_9: i128 = 16;
        // C s_588_10: const #4s : i
        let s_588_10: i128 = 4;
        // D s_588_11: read-var u#31029:u32
        let s_588_11: u32 = fn_state.u_31029;
        // D s_588_12: cast zx s_588_11 -> bv
        let s_588_12: Bits = Bits::new(s_588_11 as u128, 32u16);
        // D s_588_13: bit-extract s_588_12 s_588_9 s_588_10
        let s_588_13: Bits = (Bits::new(
            ((s_588_12) >> (s_588_9)).value(),
            u16::try_from(s_588_10).unwrap(),
        ));
        // D s_588_14: cast reint s_588_13 -> u8
        let s_588_14: u8 = (s_588_13.value() as u8);
        // C s_588_15: const #12s : i
        let s_588_15: i128 = 12;
        // C s_588_16: const #4s : i
        let s_588_16: i128 = 4;
        // D s_588_17: read-var u#31029:u32
        let s_588_17: u32 = fn_state.u_31029;
        // D s_588_18: cast zx s_588_17 -> bv
        let s_588_18: Bits = Bits::new(s_588_17 as u128, 32u16);
        // D s_588_19: bit-extract s_588_18 s_588_15 s_588_16
        let s_588_19: Bits = (Bits::new(
            ((s_588_18) >> (s_588_15)).value(),
            u16::try_from(s_588_16).unwrap(),
        ));
        // D s_588_20: cast reint s_588_19 -> u8
        let s_588_20: u8 = (s_588_19.value() as u8);
        // C s_588_21: const #6s : i
        let s_588_21: i128 = 6;
        // C s_588_22: const #2s : i
        let s_588_22: i128 = 2;
        // D s_588_23: read-var u#31029:u32
        let s_588_23: u32 = fn_state.u_31029;
        // D s_588_24: cast zx s_588_23 -> bv
        let s_588_24: Bits = Bits::new(s_588_23 as u128, 32u16);
        // D s_588_25: bit-extract s_588_24 s_588_21 s_588_22
        let s_588_25: Bits = (Bits::new(
            ((s_588_24) >> (s_588_21)).value(),
            u16::try_from(s_588_22).unwrap(),
        ));
        // D s_588_26: cast reint s_588_25 -> u8
        let s_588_26: u8 = (s_588_25.value() as u8);
        // C s_588_27: const #5s : i
        let s_588_27: i128 = 5;
        // C s_588_28: const #1s : i
        let s_588_28: i128 = 1;
        // D s_588_29: read-var u#31029:u32
        let s_588_29: u32 = fn_state.u_31029;
        // D s_588_30: cast zx s_588_29 -> bv
        let s_588_30: Bits = Bits::new(s_588_29 as u128, 32u16);
        // D s_588_31: bit-extract s_588_30 s_588_27 s_588_28
        let s_588_31: Bits = (Bits::new(
            ((s_588_30) >> (s_588_27)).value(),
            u16::try_from(s_588_28).unwrap(),
        ));
        // D s_588_32: cast reint s_588_31 -> u8
        let s_588_32: bool = ((s_588_31.value()) != 0);
        // C s_588_33: const #4s : i
        let s_588_33: i128 = 4;
        // C s_588_34: const #1s : i
        let s_588_34: i128 = 1;
        // D s_588_35: read-var u#31029:u32
        let s_588_35: u32 = fn_state.u_31029;
        // D s_588_36: cast zx s_588_35 -> bv
        let s_588_36: Bits = Bits::new(s_588_35 as u128, 32u16);
        // D s_588_37: bit-extract s_588_36 s_588_33 s_588_34
        let s_588_37: Bits = (Bits::new(
            ((s_588_36) >> (s_588_33)).value(),
            u16::try_from(s_588_34).unwrap(),
        ));
        // D s_588_38: cast reint s_588_37 -> u8
        let s_588_38: bool = ((s_588_37.value()) != 0);
        // C s_588_39: const #0s : i
        let s_588_39: i128 = 0;
        // C s_588_40: const #4s : i
        let s_588_40: i128 = 4;
        // D s_588_41: read-var u#31029:u32
        let s_588_41: u32 = fn_state.u_31029;
        // D s_588_42: cast zx s_588_41 -> bv
        let s_588_42: Bits = Bits::new(s_588_41 as u128, 32u16);
        // D s_588_43: bit-extract s_588_42 s_588_39 s_588_40
        let s_588_43: Bits = (Bits::new(
            ((s_588_42) >> (s_588_39)).value(),
            u16::try_from(s_588_40).unwrap(),
        ));
        // D s_588_44: cast reint s_588_43 -> u8
        let s_588_44: u8 = (s_588_43.value() as u8);
        // D s_588_45: call decode_aarch32_instrs_VLD2_a_A1enc_A_txt(s_588_8, s_588_14, s_588_20, s_588_26, s_588_32, s_588_38, s_588_44)
        let s_588_45: () = decode_aarch32_instrs_VLD2_a_A1enc_A_txt(
            state,
            tracer,
            s_588_8,
            s_588_14,
            s_588_20,
            s_588_26,
            s_588_32,
            s_588_38,
            s_588_44,
        );
        // N s_588_46: return
        return;
    }
    fn block_589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_589_0: read-var merge#var.1:struct
        let s_589_0: u32 = fn_state.merge_var._1;
        // D s_589_1: write-var u#31038 <= s_589_0
        fn_state.u_31038 = s_589_0;
        // C s_589_2: const #23s : i
        let s_589_2: i128 = 23;
        // D s_589_3: read-var u#31038:u32
        let s_589_3: u32 = fn_state.u_31038;
        // D s_589_4: cast zx s_589_3 -> bv
        let s_589_4: Bits = Bits::new(s_589_3 as u128, 32u16);
        // C s_589_5: const #1s : i64
        let s_589_5: i64 = 1;
        // C s_589_6: cast zx s_589_5 -> i
        let s_589_6: i128 = (i128::try_from(s_589_5).unwrap());
        // C s_589_7: const #8s : i
        let s_589_7: i128 = 8;
        // C s_589_8: add s_589_7 s_589_6
        let s_589_8: i128 = (s_589_7 + s_589_6);
        // D s_589_9: bit-extract s_589_4 s_589_2 s_589_8
        let s_589_9: Bits = (Bits::new(
            ((s_589_4) >> (s_589_2)).value(),
            u16::try_from(s_589_8).unwrap(),
        ));
        // D s_589_10: cast reint s_589_9 -> u9
        let s_589_10: u16 = (s_589_9.value() as u16);
        // D s_589_11: cast zx s_589_10 -> bv
        let s_589_11: Bits = Bits::new(s_589_10 as u128, 9u16);
        // C s_589_12: const #488u : u9
        let s_589_12: u16 = 488;
        // C s_589_13: cast zx s_589_12 -> bv
        let s_589_13: Bits = Bits::new(s_589_12 as u128, 9u16);
        // D s_589_14: cmp-eq s_589_11 s_589_13
        let s_589_14: bool = ((s_589_11) == (s_589_13));
        // N s_589_15: branch s_589_14 b2760 b590
        if s_589_14 {
            return block_2760(state, tracer, fn_state);
        } else {
            return block_590(state, tracer, fn_state);
        };
    }
    fn block_590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_590_0: const #0u : u8
        let s_590_0: bool = false;
        // D s_590_1: write-var gs#399396 <= s_590_0
        fn_state.gs_399396 = s_590_0;
        // N s_590_2: jump b591
        return block_591(state, tracer, fn_state);
    }
    fn block_591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_591_0: read-var gs#399396:u8
        let s_591_0: bool = fn_state.gs_399396;
        // N s_591_1: branch s_591_0 b2759 b592
        if s_591_0 {
            return block_2759(state, tracer, fn_state);
        } else {
            return block_592(state, tracer, fn_state);
        };
    }
    fn block_592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_592_0: const #0u : u8
        let s_592_0: bool = false;
        // D s_592_1: write-var gs#399398 <= s_592_0
        fn_state.gs_399398 = s_592_0;
        // N s_592_2: jump b593
        return block_593(state, tracer, fn_state);
    }
    fn block_593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_593_0: read-var gs#399398:u8
        let s_593_0: bool = fn_state.gs_399398;
        // D s_593_1: not s_593_0
        let s_593_1: bool = !s_593_0;
        // N s_593_2: branch s_593_1 b595 b594
        if s_593_1 {
            return block_595(state, tracer, fn_state);
        } else {
            return block_594(state, tracer, fn_state);
        };
    }
    fn block_594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_594_0: const #3474s : i
        let s_594_0: i128 = 3474;
        // C s_594_1: const #14696u : u32
        let s_594_1: u32 = 14696;
        // N s_594_2: write-reg s_594_1 <= s_594_0
        let s_594_2: () = {
            state.write_register::<i128>(s_594_1 as isize, s_594_0);
            tracer.write_register(s_594_1 as isize, s_594_0);
        };
        // C s_594_3: const #22s : i
        let s_594_3: i128 = 22;
        // C s_594_4: const #1s : i
        let s_594_4: i128 = 1;
        // D s_594_5: read-var u#31038:u32
        let s_594_5: u32 = fn_state.u_31038;
        // D s_594_6: cast zx s_594_5 -> bv
        let s_594_6: Bits = Bits::new(s_594_5 as u128, 32u16);
        // D s_594_7: bit-extract s_594_6 s_594_3 s_594_4
        let s_594_7: Bits = (Bits::new(
            ((s_594_6) >> (s_594_3)).value(),
            u16::try_from(s_594_4).unwrap(),
        ));
        // D s_594_8: cast reint s_594_7 -> u8
        let s_594_8: bool = ((s_594_7.value()) != 0);
        // C s_594_9: const #16s : i
        let s_594_9: i128 = 16;
        // C s_594_10: const #4s : i
        let s_594_10: i128 = 4;
        // D s_594_11: read-var u#31038:u32
        let s_594_11: u32 = fn_state.u_31038;
        // D s_594_12: cast zx s_594_11 -> bv
        let s_594_12: Bits = Bits::new(s_594_11 as u128, 32u16);
        // D s_594_13: bit-extract s_594_12 s_594_9 s_594_10
        let s_594_13: Bits = (Bits::new(
            ((s_594_12) >> (s_594_9)).value(),
            u16::try_from(s_594_10).unwrap(),
        ));
        // D s_594_14: cast reint s_594_13 -> u8
        let s_594_14: u8 = (s_594_13.value() as u8);
        // C s_594_15: const #12s : i
        let s_594_15: i128 = 12;
        // C s_594_16: const #4s : i
        let s_594_16: i128 = 4;
        // D s_594_17: read-var u#31038:u32
        let s_594_17: u32 = fn_state.u_31038;
        // D s_594_18: cast zx s_594_17 -> bv
        let s_594_18: Bits = Bits::new(s_594_17 as u128, 32u16);
        // D s_594_19: bit-extract s_594_18 s_594_15 s_594_16
        let s_594_19: Bits = (Bits::new(
            ((s_594_18) >> (s_594_15)).value(),
            u16::try_from(s_594_16).unwrap(),
        ));
        // D s_594_20: cast reint s_594_19 -> u8
        let s_594_20: u8 = (s_594_19.value() as u8);
        // C s_594_21: const #8s : i
        let s_594_21: i128 = 8;
        // C s_594_22: const #4s : i
        let s_594_22: i128 = 4;
        // D s_594_23: read-var u#31038:u32
        let s_594_23: u32 = fn_state.u_31038;
        // D s_594_24: cast zx s_594_23 -> bv
        let s_594_24: Bits = Bits::new(s_594_23 as u128, 32u16);
        // D s_594_25: bit-extract s_594_24 s_594_21 s_594_22
        let s_594_25: Bits = (Bits::new(
            ((s_594_24) >> (s_594_21)).value(),
            u16::try_from(s_594_22).unwrap(),
        ));
        // D s_594_26: cast reint s_594_25 -> u8
        let s_594_26: u8 = (s_594_25.value() as u8);
        // C s_594_27: const #6s : i
        let s_594_27: i128 = 6;
        // C s_594_28: const #2s : i
        let s_594_28: i128 = 2;
        // D s_594_29: read-var u#31038:u32
        let s_594_29: u32 = fn_state.u_31038;
        // D s_594_30: cast zx s_594_29 -> bv
        let s_594_30: Bits = Bits::new(s_594_29 as u128, 32u16);
        // D s_594_31: bit-extract s_594_30 s_594_27 s_594_28
        let s_594_31: Bits = (Bits::new(
            ((s_594_30) >> (s_594_27)).value(),
            u16::try_from(s_594_28).unwrap(),
        ));
        // D s_594_32: cast reint s_594_31 -> u8
        let s_594_32: u8 = (s_594_31.value() as u8);
        // C s_594_33: const #4s : i
        let s_594_33: i128 = 4;
        // C s_594_34: const #2s : i
        let s_594_34: i128 = 2;
        // D s_594_35: read-var u#31038:u32
        let s_594_35: u32 = fn_state.u_31038;
        // D s_594_36: cast zx s_594_35 -> bv
        let s_594_36: Bits = Bits::new(s_594_35 as u128, 32u16);
        // D s_594_37: bit-extract s_594_36 s_594_33 s_594_34
        let s_594_37: Bits = (Bits::new(
            ((s_594_36) >> (s_594_33)).value(),
            u16::try_from(s_594_34).unwrap(),
        ));
        // D s_594_38: cast reint s_594_37 -> u8
        let s_594_38: u8 = (s_594_37.value() as u8);
        // C s_594_39: const #0s : i
        let s_594_39: i128 = 0;
        // C s_594_40: const #4s : i
        let s_594_40: i128 = 4;
        // D s_594_41: read-var u#31038:u32
        let s_594_41: u32 = fn_state.u_31038;
        // D s_594_42: cast zx s_594_41 -> bv
        let s_594_42: Bits = Bits::new(s_594_41 as u128, 32u16);
        // D s_594_43: bit-extract s_594_42 s_594_39 s_594_40
        let s_594_43: Bits = (Bits::new(
            ((s_594_42) >> (s_594_39)).value(),
            u16::try_from(s_594_40).unwrap(),
        ));
        // D s_594_44: cast reint s_594_43 -> u8
        let s_594_44: u8 = (s_594_43.value() as u8);
        // D s_594_45: call decode_aarch32_instrs_VLD2_m_A1enc_A_txt(s_594_8, s_594_14, s_594_20, s_594_26, s_594_32, s_594_38, s_594_44)
        let s_594_45: () = decode_aarch32_instrs_VLD2_m_A1enc_A_txt(
            state,
            tracer,
            s_594_8,
            s_594_14,
            s_594_20,
            s_594_26,
            s_594_32,
            s_594_38,
            s_594_44,
        );
        // N s_594_46: return
        return;
    }
    fn block_595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_595_0: read-var merge#var.1:struct
        let s_595_0: u32 = fn_state.merge_var._1;
        // D s_595_1: write-var u#31047 <= s_595_0
        fn_state.u_31047 = s_595_0;
        // C s_595_2: const #23s : i
        let s_595_2: i128 = 23;
        // D s_595_3: read-var u#31047:u32
        let s_595_3: u32 = fn_state.u_31047;
        // D s_595_4: cast zx s_595_3 -> bv
        let s_595_4: Bits = Bits::new(s_595_3 as u128, 32u16);
        // C s_595_5: const #1s : i64
        let s_595_5: i64 = 1;
        // C s_595_6: cast zx s_595_5 -> i
        let s_595_6: i128 = (i128::try_from(s_595_5).unwrap());
        // C s_595_7: const #8s : i
        let s_595_7: i128 = 8;
        // C s_595_8: add s_595_7 s_595_6
        let s_595_8: i128 = (s_595_7 + s_595_6);
        // D s_595_9: bit-extract s_595_4 s_595_2 s_595_8
        let s_595_9: Bits = (Bits::new(
            ((s_595_4) >> (s_595_2)).value(),
            u16::try_from(s_595_8).unwrap(),
        ));
        // D s_595_10: cast reint s_595_9 -> u9
        let s_595_10: u16 = (s_595_9.value() as u16);
        // D s_595_11: cast zx s_595_10 -> bv
        let s_595_11: Bits = Bits::new(s_595_10 as u128, 9u16);
        // C s_595_12: const #488u : u9
        let s_595_12: u16 = 488;
        // C s_595_13: cast zx s_595_12 -> bv
        let s_595_13: Bits = Bits::new(s_595_12 as u128, 9u16);
        // D s_595_14: cmp-eq s_595_11 s_595_13
        let s_595_14: bool = ((s_595_11) == (s_595_13));
        // N s_595_15: branch s_595_14 b2755 b596
        if s_595_14 {
            return block_2755(state, tracer, fn_state);
        } else {
            return block_596(state, tracer, fn_state);
        };
    }
    fn block_596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_596_0: const #0u : u8
        let s_596_0: bool = false;
        // D s_596_1: write-var gs#399423 <= s_596_0
        fn_state.gs_399423 = s_596_0;
        // N s_596_2: jump b597
        return block_597(state, tracer, fn_state);
    }
    fn block_597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_597_0: read-var gs#399423:u8
        let s_597_0: bool = fn_state.gs_399423;
        // N s_597_1: branch s_597_0 b2754 b598
        if s_597_0 {
            return block_2754(state, tracer, fn_state);
        } else {
            return block_598(state, tracer, fn_state);
        };
    }
    fn block_598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_598_0: const #0u : u8
        let s_598_0: bool = false;
        // D s_598_1: write-var gs#399425 <= s_598_0
        fn_state.gs_399425 = s_598_0;
        // N s_598_2: jump b599
        return block_599(state, tracer, fn_state);
    }
    fn block_599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_599_0: read-var gs#399425:u8
        let s_599_0: bool = fn_state.gs_399425;
        // D s_599_1: not s_599_0
        let s_599_1: bool = !s_599_0;
        // N s_599_2: branch s_599_1 b601 b600
        if s_599_1 {
            return block_601(state, tracer, fn_state);
        } else {
            return block_600(state, tracer, fn_state);
        };
    }
    fn block_600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_600_0: const #3475s : i
        let s_600_0: i128 = 3475;
        // C s_600_1: const #14696u : u32
        let s_600_1: u32 = 14696;
        // N s_600_2: write-reg s_600_1 <= s_600_0
        let s_600_2: () = {
            state.write_register::<i128>(s_600_1 as isize, s_600_0);
            tracer.write_register(s_600_1 as isize, s_600_0);
        };
        // C s_600_3: const #22s : i
        let s_600_3: i128 = 22;
        // C s_600_4: const #1s : i
        let s_600_4: i128 = 1;
        // D s_600_5: read-var u#31047:u32
        let s_600_5: u32 = fn_state.u_31047;
        // D s_600_6: cast zx s_600_5 -> bv
        let s_600_6: Bits = Bits::new(s_600_5 as u128, 32u16);
        // D s_600_7: bit-extract s_600_6 s_600_3 s_600_4
        let s_600_7: Bits = (Bits::new(
            ((s_600_6) >> (s_600_3)).value(),
            u16::try_from(s_600_4).unwrap(),
        ));
        // D s_600_8: cast reint s_600_7 -> u8
        let s_600_8: bool = ((s_600_7.value()) != 0);
        // C s_600_9: const #16s : i
        let s_600_9: i128 = 16;
        // C s_600_10: const #4s : i
        let s_600_10: i128 = 4;
        // D s_600_11: read-var u#31047:u32
        let s_600_11: u32 = fn_state.u_31047;
        // D s_600_12: cast zx s_600_11 -> bv
        let s_600_12: Bits = Bits::new(s_600_11 as u128, 32u16);
        // D s_600_13: bit-extract s_600_12 s_600_9 s_600_10
        let s_600_13: Bits = (Bits::new(
            ((s_600_12) >> (s_600_9)).value(),
            u16::try_from(s_600_10).unwrap(),
        ));
        // D s_600_14: cast reint s_600_13 -> u8
        let s_600_14: u8 = (s_600_13.value() as u8);
        // C s_600_15: const #12s : i
        let s_600_15: i128 = 12;
        // C s_600_16: const #4s : i
        let s_600_16: i128 = 4;
        // D s_600_17: read-var u#31047:u32
        let s_600_17: u32 = fn_state.u_31047;
        // D s_600_18: cast zx s_600_17 -> bv
        let s_600_18: Bits = Bits::new(s_600_17 as u128, 32u16);
        // D s_600_19: bit-extract s_600_18 s_600_15 s_600_16
        let s_600_19: Bits = (Bits::new(
            ((s_600_18) >> (s_600_15)).value(),
            u16::try_from(s_600_16).unwrap(),
        ));
        // D s_600_20: cast reint s_600_19 -> u8
        let s_600_20: u8 = (s_600_19.value() as u8);
        // C s_600_21: const #8s : i
        let s_600_21: i128 = 8;
        // C s_600_22: const #4s : i
        let s_600_22: i128 = 4;
        // D s_600_23: read-var u#31047:u32
        let s_600_23: u32 = fn_state.u_31047;
        // D s_600_24: cast zx s_600_23 -> bv
        let s_600_24: Bits = Bits::new(s_600_23 as u128, 32u16);
        // D s_600_25: bit-extract s_600_24 s_600_21 s_600_22
        let s_600_25: Bits = (Bits::new(
            ((s_600_24) >> (s_600_21)).value(),
            u16::try_from(s_600_22).unwrap(),
        ));
        // D s_600_26: cast reint s_600_25 -> u8
        let s_600_26: u8 = (s_600_25.value() as u8);
        // C s_600_27: const #6s : i
        let s_600_27: i128 = 6;
        // C s_600_28: const #2s : i
        let s_600_28: i128 = 2;
        // D s_600_29: read-var u#31047:u32
        let s_600_29: u32 = fn_state.u_31047;
        // D s_600_30: cast zx s_600_29 -> bv
        let s_600_30: Bits = Bits::new(s_600_29 as u128, 32u16);
        // D s_600_31: bit-extract s_600_30 s_600_27 s_600_28
        let s_600_31: Bits = (Bits::new(
            ((s_600_30) >> (s_600_27)).value(),
            u16::try_from(s_600_28).unwrap(),
        ));
        // D s_600_32: cast reint s_600_31 -> u8
        let s_600_32: u8 = (s_600_31.value() as u8);
        // C s_600_33: const #4s : i
        let s_600_33: i128 = 4;
        // C s_600_34: const #2s : i
        let s_600_34: i128 = 2;
        // D s_600_35: read-var u#31047:u32
        let s_600_35: u32 = fn_state.u_31047;
        // D s_600_36: cast zx s_600_35 -> bv
        let s_600_36: Bits = Bits::new(s_600_35 as u128, 32u16);
        // D s_600_37: bit-extract s_600_36 s_600_33 s_600_34
        let s_600_37: Bits = (Bits::new(
            ((s_600_36) >> (s_600_33)).value(),
            u16::try_from(s_600_34).unwrap(),
        ));
        // D s_600_38: cast reint s_600_37 -> u8
        let s_600_38: u8 = (s_600_37.value() as u8);
        // C s_600_39: const #0s : i
        let s_600_39: i128 = 0;
        // C s_600_40: const #4s : i
        let s_600_40: i128 = 4;
        // D s_600_41: read-var u#31047:u32
        let s_600_41: u32 = fn_state.u_31047;
        // D s_600_42: cast zx s_600_41 -> bv
        let s_600_42: Bits = Bits::new(s_600_41 as u128, 32u16);
        // D s_600_43: bit-extract s_600_42 s_600_39 s_600_40
        let s_600_43: Bits = (Bits::new(
            ((s_600_42) >> (s_600_39)).value(),
            u16::try_from(s_600_40).unwrap(),
        ));
        // D s_600_44: cast reint s_600_43 -> u8
        let s_600_44: u8 = (s_600_43.value() as u8);
        // D s_600_45: call decode_aarch32_instrs_VLD2_m_A2enc_A_txt(s_600_8, s_600_14, s_600_20, s_600_26, s_600_32, s_600_38, s_600_44)
        let s_600_45: () = decode_aarch32_instrs_VLD2_m_A2enc_A_txt(
            state,
            tracer,
            s_600_8,
            s_600_14,
            s_600_20,
            s_600_26,
            s_600_32,
            s_600_38,
            s_600_44,
        );
        // N s_600_46: return
        return;
    }
    fn block_601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_601_0: read-var merge#var.1:struct
        let s_601_0: u32 = fn_state.merge_var._1;
        // D s_601_1: write-var u#31056 <= s_601_0
        fn_state.u_31056 = s_601_0;
        // C s_601_2: const #23s : i
        let s_601_2: i128 = 23;
        // D s_601_3: read-var u#31056:u32
        let s_601_3: u32 = fn_state.u_31056;
        // D s_601_4: cast zx s_601_3 -> bv
        let s_601_4: Bits = Bits::new(s_601_3 as u128, 32u16);
        // C s_601_5: const #1s : i64
        let s_601_5: i64 = 1;
        // C s_601_6: cast zx s_601_5 -> i
        let s_601_6: i128 = (i128::try_from(s_601_5).unwrap());
        // C s_601_7: const #8s : i
        let s_601_7: i128 = 8;
        // C s_601_8: add s_601_7 s_601_6
        let s_601_8: i128 = (s_601_7 + s_601_6);
        // D s_601_9: bit-extract s_601_4 s_601_2 s_601_8
        let s_601_9: Bits = (Bits::new(
            ((s_601_4) >> (s_601_2)).value(),
            u16::try_from(s_601_8).unwrap(),
        ));
        // D s_601_10: cast reint s_601_9 -> u9
        let s_601_10: u16 = (s_601_9.value() as u16);
        // D s_601_11: cast zx s_601_10 -> bv
        let s_601_11: Bits = Bits::new(s_601_10 as u128, 9u16);
        // C s_601_12: const #489u : u9
        let s_601_12: u16 = 489;
        // C s_601_13: cast zx s_601_12 -> bv
        let s_601_13: Bits = Bits::new(s_601_12 as u128, 9u16);
        // D s_601_14: cmp-eq s_601_11 s_601_13
        let s_601_14: bool = ((s_601_11) == (s_601_13));
        // N s_601_15: branch s_601_14 b2750 b602
        if s_601_14 {
            return block_2750(state, tracer, fn_state);
        } else {
            return block_602(state, tracer, fn_state);
        };
    }
    fn block_602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_602_0: const #0u : u8
        let s_602_0: bool = false;
        // D s_602_1: write-var gs#399450 <= s_602_0
        fn_state.gs_399450 = s_602_0;
        // N s_602_2: jump b603
        return block_603(state, tracer, fn_state);
    }
    fn block_603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_603_0: read-var gs#399450:u8
        let s_603_0: bool = fn_state.gs_399450;
        // N s_603_1: branch s_603_0 b2749 b604
        if s_603_0 {
            return block_2749(state, tracer, fn_state);
        } else {
            return block_604(state, tracer, fn_state);
        };
    }
    fn block_604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_604_0: const #0u : u8
        let s_604_0: bool = false;
        // D s_604_1: write-var gs#399452 <= s_604_0
        fn_state.gs_399452 = s_604_0;
        // N s_604_2: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_605_0: read-var gs#399452:u8
        let s_605_0: bool = fn_state.gs_399452;
        // D s_605_1: not s_605_0
        let s_605_1: bool = !s_605_0;
        // N s_605_2: branch s_605_1 b607 b606
        if s_605_1 {
            return block_607(state, tracer, fn_state);
        } else {
            return block_606(state, tracer, fn_state);
        };
    }
    fn block_606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_606_0: const #3478s : i
        let s_606_0: i128 = 3478;
        // C s_606_1: const #14696u : u32
        let s_606_1: u32 = 14696;
        // N s_606_2: write-reg s_606_1 <= s_606_0
        let s_606_2: () = {
            state.write_register::<i128>(s_606_1 as isize, s_606_0);
            tracer.write_register(s_606_1 as isize, s_606_0);
        };
        // C s_606_3: const #22s : i
        let s_606_3: i128 = 22;
        // C s_606_4: const #1s : i
        let s_606_4: i128 = 1;
        // D s_606_5: read-var u#31056:u32
        let s_606_5: u32 = fn_state.u_31056;
        // D s_606_6: cast zx s_606_5 -> bv
        let s_606_6: Bits = Bits::new(s_606_5 as u128, 32u16);
        // D s_606_7: bit-extract s_606_6 s_606_3 s_606_4
        let s_606_7: Bits = (Bits::new(
            ((s_606_6) >> (s_606_3)).value(),
            u16::try_from(s_606_4).unwrap(),
        ));
        // D s_606_8: cast reint s_606_7 -> u8
        let s_606_8: bool = ((s_606_7.value()) != 0);
        // C s_606_9: const #16s : i
        let s_606_9: i128 = 16;
        // C s_606_10: const #4s : i
        let s_606_10: i128 = 4;
        // D s_606_11: read-var u#31056:u32
        let s_606_11: u32 = fn_state.u_31056;
        // D s_606_12: cast zx s_606_11 -> bv
        let s_606_12: Bits = Bits::new(s_606_11 as u128, 32u16);
        // D s_606_13: bit-extract s_606_12 s_606_9 s_606_10
        let s_606_13: Bits = (Bits::new(
            ((s_606_12) >> (s_606_9)).value(),
            u16::try_from(s_606_10).unwrap(),
        ));
        // D s_606_14: cast reint s_606_13 -> u8
        let s_606_14: u8 = (s_606_13.value() as u8);
        // C s_606_15: const #12s : i
        let s_606_15: i128 = 12;
        // C s_606_16: const #4s : i
        let s_606_16: i128 = 4;
        // D s_606_17: read-var u#31056:u32
        let s_606_17: u32 = fn_state.u_31056;
        // D s_606_18: cast zx s_606_17 -> bv
        let s_606_18: Bits = Bits::new(s_606_17 as u128, 32u16);
        // D s_606_19: bit-extract s_606_18 s_606_15 s_606_16
        let s_606_19: Bits = (Bits::new(
            ((s_606_18) >> (s_606_15)).value(),
            u16::try_from(s_606_16).unwrap(),
        ));
        // D s_606_20: cast reint s_606_19 -> u8
        let s_606_20: u8 = (s_606_19.value() as u8);
        // C s_606_21: const #10s : i
        let s_606_21: i128 = 10;
        // C s_606_22: const #2s : i
        let s_606_22: i128 = 2;
        // D s_606_23: read-var u#31056:u32
        let s_606_23: u32 = fn_state.u_31056;
        // D s_606_24: cast zx s_606_23 -> bv
        let s_606_24: Bits = Bits::new(s_606_23 as u128, 32u16);
        // D s_606_25: bit-extract s_606_24 s_606_21 s_606_22
        let s_606_25: Bits = (Bits::new(
            ((s_606_24) >> (s_606_21)).value(),
            u16::try_from(s_606_22).unwrap(),
        ));
        // D s_606_26: cast reint s_606_25 -> u8
        let s_606_26: u8 = (s_606_25.value() as u8);
        // C s_606_27: const #4s : i
        let s_606_27: i128 = 4;
        // C s_606_28: const #4s : i
        let s_606_28: i128 = 4;
        // D s_606_29: read-var u#31056:u32
        let s_606_29: u32 = fn_state.u_31056;
        // D s_606_30: cast zx s_606_29 -> bv
        let s_606_30: Bits = Bits::new(s_606_29 as u128, 32u16);
        // D s_606_31: bit-extract s_606_30 s_606_27 s_606_28
        let s_606_31: Bits = (Bits::new(
            ((s_606_30) >> (s_606_27)).value(),
            u16::try_from(s_606_28).unwrap(),
        ));
        // D s_606_32: cast reint s_606_31 -> u8
        let s_606_32: u8 = (s_606_31.value() as u8);
        // C s_606_33: const #0s : i
        let s_606_33: i128 = 0;
        // C s_606_34: const #4s : i
        let s_606_34: i128 = 4;
        // D s_606_35: read-var u#31056:u32
        let s_606_35: u32 = fn_state.u_31056;
        // D s_606_36: cast zx s_606_35 -> bv
        let s_606_36: Bits = Bits::new(s_606_35 as u128, 32u16);
        // D s_606_37: bit-extract s_606_36 s_606_33 s_606_34
        let s_606_37: Bits = (Bits::new(
            ((s_606_36) >> (s_606_33)).value(),
            u16::try_from(s_606_34).unwrap(),
        ));
        // D s_606_38: cast reint s_606_37 -> u8
        let s_606_38: u8 = (s_606_37.value() as u8);
        // D s_606_39: call decode_aarch32_instrs_VLD3_1_A1enc_A_txt(s_606_8, s_606_14, s_606_20, s_606_26, s_606_32, s_606_38)
        let s_606_39: () = decode_aarch32_instrs_VLD3_1_A1enc_A_txt(
            state,
            tracer,
            s_606_8,
            s_606_14,
            s_606_20,
            s_606_26,
            s_606_32,
            s_606_38,
        );
        // N s_606_40: return
        return;
    }
    fn block_607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_607_0: read-var merge#var.1:struct
        let s_607_0: u32 = fn_state.merge_var._1;
        // D s_607_1: write-var u#31064 <= s_607_0
        fn_state.u_31064 = s_607_0;
        // C s_607_2: const #23s : i
        let s_607_2: i128 = 23;
        // D s_607_3: read-var u#31064:u32
        let s_607_3: u32 = fn_state.u_31064;
        // D s_607_4: cast zx s_607_3 -> bv
        let s_607_4: Bits = Bits::new(s_607_3 as u128, 32u16);
        // C s_607_5: const #1s : i64
        let s_607_5: i64 = 1;
        // C s_607_6: cast zx s_607_5 -> i
        let s_607_6: i128 = (i128::try_from(s_607_5).unwrap());
        // C s_607_7: const #8s : i
        let s_607_7: i128 = 8;
        // C s_607_8: add s_607_7 s_607_6
        let s_607_8: i128 = (s_607_7 + s_607_6);
        // D s_607_9: bit-extract s_607_4 s_607_2 s_607_8
        let s_607_9: Bits = (Bits::new(
            ((s_607_4) >> (s_607_2)).value(),
            u16::try_from(s_607_8).unwrap(),
        ));
        // D s_607_10: cast reint s_607_9 -> u9
        let s_607_10: u16 = (s_607_9.value() as u16);
        // D s_607_11: cast zx s_607_10 -> bv
        let s_607_11: Bits = Bits::new(s_607_10 as u128, 9u16);
        // C s_607_12: const #489u : u9
        let s_607_12: u16 = 489;
        // C s_607_13: cast zx s_607_12 -> bv
        let s_607_13: Bits = Bits::new(s_607_12 as u128, 9u16);
        // D s_607_14: cmp-eq s_607_11 s_607_13
        let s_607_14: bool = ((s_607_11) == (s_607_13));
        // N s_607_15: branch s_607_14 b2745 b608
        if s_607_14 {
            return block_2745(state, tracer, fn_state);
        } else {
            return block_608(state, tracer, fn_state);
        };
    }
    fn block_608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_608_0: const #0u : u8
        let s_608_0: bool = false;
        // D s_608_1: write-var gs#399475 <= s_608_0
        fn_state.gs_399475 = s_608_0;
        // N s_608_2: jump b609
        return block_609(state, tracer, fn_state);
    }
    fn block_609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_609_0: read-var gs#399475:u8
        let s_609_0: bool = fn_state.gs_399475;
        // N s_609_1: branch s_609_0 b2744 b610
        if s_609_0 {
            return block_2744(state, tracer, fn_state);
        } else {
            return block_610(state, tracer, fn_state);
        };
    }
    fn block_610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_610_0: const #0u : u8
        let s_610_0: bool = false;
        // D s_610_1: write-var gs#399477 <= s_610_0
        fn_state.gs_399477 = s_610_0;
        // N s_610_2: jump b611
        return block_611(state, tracer, fn_state);
    }
    fn block_611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_611_0: read-var gs#399477:u8
        let s_611_0: bool = fn_state.gs_399477;
        // D s_611_1: not s_611_0
        let s_611_1: bool = !s_611_0;
        // N s_611_2: branch s_611_1 b613 b612
        if s_611_1 {
            return block_613(state, tracer, fn_state);
        } else {
            return block_612(state, tracer, fn_state);
        };
    }
    fn block_612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_612_0: const #3479s : i
        let s_612_0: i128 = 3479;
        // C s_612_1: const #14696u : u32
        let s_612_1: u32 = 14696;
        // N s_612_2: write-reg s_612_1 <= s_612_0
        let s_612_2: () = {
            state.write_register::<i128>(s_612_1 as isize, s_612_0);
            tracer.write_register(s_612_1 as isize, s_612_0);
        };
        // C s_612_3: const #22s : i
        let s_612_3: i128 = 22;
        // C s_612_4: const #1s : i
        let s_612_4: i128 = 1;
        // D s_612_5: read-var u#31064:u32
        let s_612_5: u32 = fn_state.u_31064;
        // D s_612_6: cast zx s_612_5 -> bv
        let s_612_6: Bits = Bits::new(s_612_5 as u128, 32u16);
        // D s_612_7: bit-extract s_612_6 s_612_3 s_612_4
        let s_612_7: Bits = (Bits::new(
            ((s_612_6) >> (s_612_3)).value(),
            u16::try_from(s_612_4).unwrap(),
        ));
        // D s_612_8: cast reint s_612_7 -> u8
        let s_612_8: bool = ((s_612_7.value()) != 0);
        // C s_612_9: const #16s : i
        let s_612_9: i128 = 16;
        // C s_612_10: const #4s : i
        let s_612_10: i128 = 4;
        // D s_612_11: read-var u#31064:u32
        let s_612_11: u32 = fn_state.u_31064;
        // D s_612_12: cast zx s_612_11 -> bv
        let s_612_12: Bits = Bits::new(s_612_11 as u128, 32u16);
        // D s_612_13: bit-extract s_612_12 s_612_9 s_612_10
        let s_612_13: Bits = (Bits::new(
            ((s_612_12) >> (s_612_9)).value(),
            u16::try_from(s_612_10).unwrap(),
        ));
        // D s_612_14: cast reint s_612_13 -> u8
        let s_612_14: u8 = (s_612_13.value() as u8);
        // C s_612_15: const #12s : i
        let s_612_15: i128 = 12;
        // C s_612_16: const #4s : i
        let s_612_16: i128 = 4;
        // D s_612_17: read-var u#31064:u32
        let s_612_17: u32 = fn_state.u_31064;
        // D s_612_18: cast zx s_612_17 -> bv
        let s_612_18: Bits = Bits::new(s_612_17 as u128, 32u16);
        // D s_612_19: bit-extract s_612_18 s_612_15 s_612_16
        let s_612_19: Bits = (Bits::new(
            ((s_612_18) >> (s_612_15)).value(),
            u16::try_from(s_612_16).unwrap(),
        ));
        // D s_612_20: cast reint s_612_19 -> u8
        let s_612_20: u8 = (s_612_19.value() as u8);
        // C s_612_21: const #10s : i
        let s_612_21: i128 = 10;
        // C s_612_22: const #2s : i
        let s_612_22: i128 = 2;
        // D s_612_23: read-var u#31064:u32
        let s_612_23: u32 = fn_state.u_31064;
        // D s_612_24: cast zx s_612_23 -> bv
        let s_612_24: Bits = Bits::new(s_612_23 as u128, 32u16);
        // D s_612_25: bit-extract s_612_24 s_612_21 s_612_22
        let s_612_25: Bits = (Bits::new(
            ((s_612_24) >> (s_612_21)).value(),
            u16::try_from(s_612_22).unwrap(),
        ));
        // D s_612_26: cast reint s_612_25 -> u8
        let s_612_26: u8 = (s_612_25.value() as u8);
        // C s_612_27: const #4s : i
        let s_612_27: i128 = 4;
        // C s_612_28: const #4s : i
        let s_612_28: i128 = 4;
        // D s_612_29: read-var u#31064:u32
        let s_612_29: u32 = fn_state.u_31064;
        // D s_612_30: cast zx s_612_29 -> bv
        let s_612_30: Bits = Bits::new(s_612_29 as u128, 32u16);
        // D s_612_31: bit-extract s_612_30 s_612_27 s_612_28
        let s_612_31: Bits = (Bits::new(
            ((s_612_30) >> (s_612_27)).value(),
            u16::try_from(s_612_28).unwrap(),
        ));
        // D s_612_32: cast reint s_612_31 -> u8
        let s_612_32: u8 = (s_612_31.value() as u8);
        // C s_612_33: const #0s : i
        let s_612_33: i128 = 0;
        // C s_612_34: const #4s : i
        let s_612_34: i128 = 4;
        // D s_612_35: read-var u#31064:u32
        let s_612_35: u32 = fn_state.u_31064;
        // D s_612_36: cast zx s_612_35 -> bv
        let s_612_36: Bits = Bits::new(s_612_35 as u128, 32u16);
        // D s_612_37: bit-extract s_612_36 s_612_33 s_612_34
        let s_612_37: Bits = (Bits::new(
            ((s_612_36) >> (s_612_33)).value(),
            u16::try_from(s_612_34).unwrap(),
        ));
        // D s_612_38: cast reint s_612_37 -> u8
        let s_612_38: u8 = (s_612_37.value() as u8);
        // D s_612_39: call decode_aarch32_instrs_VLD3_1_A2enc_A_txt(s_612_8, s_612_14, s_612_20, s_612_26, s_612_32, s_612_38)
        let s_612_39: () = decode_aarch32_instrs_VLD3_1_A2enc_A_txt(
            state,
            tracer,
            s_612_8,
            s_612_14,
            s_612_20,
            s_612_26,
            s_612_32,
            s_612_38,
        );
        // N s_612_40: return
        return;
    }
    fn block_613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_613_0: read-var merge#var.1:struct
        let s_613_0: u32 = fn_state.merge_var._1;
        // D s_613_1: write-var u#31072 <= s_613_0
        fn_state.u_31072 = s_613_0;
        // C s_613_2: const #23s : i
        let s_613_2: i128 = 23;
        // D s_613_3: read-var u#31072:u32
        let s_613_3: u32 = fn_state.u_31072;
        // D s_613_4: cast zx s_613_3 -> bv
        let s_613_4: Bits = Bits::new(s_613_3 as u128, 32u16);
        // C s_613_5: const #1s : i64
        let s_613_5: i64 = 1;
        // C s_613_6: cast zx s_613_5 -> i
        let s_613_6: i128 = (i128::try_from(s_613_5).unwrap());
        // C s_613_7: const #8s : i
        let s_613_7: i128 = 8;
        // C s_613_8: add s_613_7 s_613_6
        let s_613_8: i128 = (s_613_7 + s_613_6);
        // D s_613_9: bit-extract s_613_4 s_613_2 s_613_8
        let s_613_9: Bits = (Bits::new(
            ((s_613_4) >> (s_613_2)).value(),
            u16::try_from(s_613_8).unwrap(),
        ));
        // D s_613_10: cast reint s_613_9 -> u9
        let s_613_10: u16 = (s_613_9.value() as u16);
        // D s_613_11: cast zx s_613_10 -> bv
        let s_613_11: Bits = Bits::new(s_613_10 as u128, 9u16);
        // C s_613_12: const #489u : u9
        let s_613_12: u16 = 489;
        // C s_613_13: cast zx s_613_12 -> bv
        let s_613_13: Bits = Bits::new(s_613_12 as u128, 9u16);
        // D s_613_14: cmp-eq s_613_11 s_613_13
        let s_613_14: bool = ((s_613_11) == (s_613_13));
        // N s_613_15: branch s_613_14 b2740 b614
        if s_613_14 {
            return block_2740(state, tracer, fn_state);
        } else {
            return block_614(state, tracer, fn_state);
        };
    }
    fn block_614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_614_0: const #0u : u8
        let s_614_0: bool = false;
        // D s_614_1: write-var gs#399500 <= s_614_0
        fn_state.gs_399500 = s_614_0;
        // N s_614_2: jump b615
        return block_615(state, tracer, fn_state);
    }
    fn block_615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_615_0: read-var gs#399500:u8
        let s_615_0: bool = fn_state.gs_399500;
        // N s_615_1: branch s_615_0 b2739 b616
        if s_615_0 {
            return block_2739(state, tracer, fn_state);
        } else {
            return block_616(state, tracer, fn_state);
        };
    }
    fn block_616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_616_0: const #0u : u8
        let s_616_0: bool = false;
        // D s_616_1: write-var gs#399502 <= s_616_0
        fn_state.gs_399502 = s_616_0;
        // N s_616_2: jump b617
        return block_617(state, tracer, fn_state);
    }
    fn block_617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_617_0: read-var gs#399502:u8
        let s_617_0: bool = fn_state.gs_399502;
        // D s_617_1: not s_617_0
        let s_617_1: bool = !s_617_0;
        // N s_617_2: branch s_617_1 b619 b618
        if s_617_1 {
            return block_619(state, tracer, fn_state);
        } else {
            return block_618(state, tracer, fn_state);
        };
    }
    fn block_618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_618_0: const #3480s : i
        let s_618_0: i128 = 3480;
        // C s_618_1: const #14696u : u32
        let s_618_1: u32 = 14696;
        // N s_618_2: write-reg s_618_1 <= s_618_0
        let s_618_2: () = {
            state.write_register::<i128>(s_618_1 as isize, s_618_0);
            tracer.write_register(s_618_1 as isize, s_618_0);
        };
        // C s_618_3: const #22s : i
        let s_618_3: i128 = 22;
        // C s_618_4: const #1s : i
        let s_618_4: i128 = 1;
        // D s_618_5: read-var u#31072:u32
        let s_618_5: u32 = fn_state.u_31072;
        // D s_618_6: cast zx s_618_5 -> bv
        let s_618_6: Bits = Bits::new(s_618_5 as u128, 32u16);
        // D s_618_7: bit-extract s_618_6 s_618_3 s_618_4
        let s_618_7: Bits = (Bits::new(
            ((s_618_6) >> (s_618_3)).value(),
            u16::try_from(s_618_4).unwrap(),
        ));
        // D s_618_8: cast reint s_618_7 -> u8
        let s_618_8: bool = ((s_618_7.value()) != 0);
        // C s_618_9: const #16s : i
        let s_618_9: i128 = 16;
        // C s_618_10: const #4s : i
        let s_618_10: i128 = 4;
        // D s_618_11: read-var u#31072:u32
        let s_618_11: u32 = fn_state.u_31072;
        // D s_618_12: cast zx s_618_11 -> bv
        let s_618_12: Bits = Bits::new(s_618_11 as u128, 32u16);
        // D s_618_13: bit-extract s_618_12 s_618_9 s_618_10
        let s_618_13: Bits = (Bits::new(
            ((s_618_12) >> (s_618_9)).value(),
            u16::try_from(s_618_10).unwrap(),
        ));
        // D s_618_14: cast reint s_618_13 -> u8
        let s_618_14: u8 = (s_618_13.value() as u8);
        // C s_618_15: const #12s : i
        let s_618_15: i128 = 12;
        // C s_618_16: const #4s : i
        let s_618_16: i128 = 4;
        // D s_618_17: read-var u#31072:u32
        let s_618_17: u32 = fn_state.u_31072;
        // D s_618_18: cast zx s_618_17 -> bv
        let s_618_18: Bits = Bits::new(s_618_17 as u128, 32u16);
        // D s_618_19: bit-extract s_618_18 s_618_15 s_618_16
        let s_618_19: Bits = (Bits::new(
            ((s_618_18) >> (s_618_15)).value(),
            u16::try_from(s_618_16).unwrap(),
        ));
        // D s_618_20: cast reint s_618_19 -> u8
        let s_618_20: u8 = (s_618_19.value() as u8);
        // C s_618_21: const #10s : i
        let s_618_21: i128 = 10;
        // C s_618_22: const #2s : i
        let s_618_22: i128 = 2;
        // D s_618_23: read-var u#31072:u32
        let s_618_23: u32 = fn_state.u_31072;
        // D s_618_24: cast zx s_618_23 -> bv
        let s_618_24: Bits = Bits::new(s_618_23 as u128, 32u16);
        // D s_618_25: bit-extract s_618_24 s_618_21 s_618_22
        let s_618_25: Bits = (Bits::new(
            ((s_618_24) >> (s_618_21)).value(),
            u16::try_from(s_618_22).unwrap(),
        ));
        // D s_618_26: cast reint s_618_25 -> u8
        let s_618_26: u8 = (s_618_25.value() as u8);
        // C s_618_27: const #4s : i
        let s_618_27: i128 = 4;
        // C s_618_28: const #4s : i
        let s_618_28: i128 = 4;
        // D s_618_29: read-var u#31072:u32
        let s_618_29: u32 = fn_state.u_31072;
        // D s_618_30: cast zx s_618_29 -> bv
        let s_618_30: Bits = Bits::new(s_618_29 as u128, 32u16);
        // D s_618_31: bit-extract s_618_30 s_618_27 s_618_28
        let s_618_31: Bits = (Bits::new(
            ((s_618_30) >> (s_618_27)).value(),
            u16::try_from(s_618_28).unwrap(),
        ));
        // D s_618_32: cast reint s_618_31 -> u8
        let s_618_32: u8 = (s_618_31.value() as u8);
        // C s_618_33: const #0s : i
        let s_618_33: i128 = 0;
        // C s_618_34: const #4s : i
        let s_618_34: i128 = 4;
        // D s_618_35: read-var u#31072:u32
        let s_618_35: u32 = fn_state.u_31072;
        // D s_618_36: cast zx s_618_35 -> bv
        let s_618_36: Bits = Bits::new(s_618_35 as u128, 32u16);
        // D s_618_37: bit-extract s_618_36 s_618_33 s_618_34
        let s_618_37: Bits = (Bits::new(
            ((s_618_36) >> (s_618_33)).value(),
            u16::try_from(s_618_34).unwrap(),
        ));
        // D s_618_38: cast reint s_618_37 -> u8
        let s_618_38: u8 = (s_618_37.value() as u8);
        // D s_618_39: call decode_aarch32_instrs_VLD3_1_A3enc_A_txt(s_618_8, s_618_14, s_618_20, s_618_26, s_618_32, s_618_38)
        let s_618_39: () = decode_aarch32_instrs_VLD3_1_A3enc_A_txt(
            state,
            tracer,
            s_618_8,
            s_618_14,
            s_618_20,
            s_618_26,
            s_618_32,
            s_618_38,
        );
        // N s_618_40: return
        return;
    }
    fn block_619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_619_0: read-var merge#var.1:struct
        let s_619_0: u32 = fn_state.merge_var._1;
        // D s_619_1: write-var u#31080 <= s_619_0
        fn_state.u_31080 = s_619_0;
        // C s_619_2: const #23s : i
        let s_619_2: i128 = 23;
        // D s_619_3: read-var u#31080:u32
        let s_619_3: u32 = fn_state.u_31080;
        // D s_619_4: cast zx s_619_3 -> bv
        let s_619_4: Bits = Bits::new(s_619_3 as u128, 32u16);
        // C s_619_5: const #1s : i64
        let s_619_5: i64 = 1;
        // C s_619_6: cast zx s_619_5 -> i
        let s_619_6: i128 = (i128::try_from(s_619_5).unwrap());
        // C s_619_7: const #8s : i
        let s_619_7: i128 = 8;
        // C s_619_8: add s_619_7 s_619_6
        let s_619_8: i128 = (s_619_7 + s_619_6);
        // D s_619_9: bit-extract s_619_4 s_619_2 s_619_8
        let s_619_9: Bits = (Bits::new(
            ((s_619_4) >> (s_619_2)).value(),
            u16::try_from(s_619_8).unwrap(),
        ));
        // D s_619_10: cast reint s_619_9 -> u9
        let s_619_10: u16 = (s_619_9.value() as u16);
        // D s_619_11: cast zx s_619_10 -> bv
        let s_619_11: Bits = Bits::new(s_619_10 as u128, 9u16);
        // C s_619_12: const #489u : u9
        let s_619_12: u16 = 489;
        // C s_619_13: cast zx s_619_12 -> bv
        let s_619_13: Bits = Bits::new(s_619_12 as u128, 9u16);
        // D s_619_14: cmp-eq s_619_11 s_619_13
        let s_619_14: bool = ((s_619_11) == (s_619_13));
        // N s_619_15: branch s_619_14 b2735 b620
        if s_619_14 {
            return block_2735(state, tracer, fn_state);
        } else {
            return block_620(state, tracer, fn_state);
        };
    }
    fn block_620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_620_0: const #0u : u8
        let s_620_0: bool = false;
        // D s_620_1: write-var gs#399525 <= s_620_0
        fn_state.gs_399525 = s_620_0;
        // N s_620_2: jump b621
        return block_621(state, tracer, fn_state);
    }
    fn block_621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_621_0: read-var gs#399525:u8
        let s_621_0: bool = fn_state.gs_399525;
        // N s_621_1: branch s_621_0 b2734 b622
        if s_621_0 {
            return block_2734(state, tracer, fn_state);
        } else {
            return block_622(state, tracer, fn_state);
        };
    }
    fn block_622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_622_0: const #0u : u8
        let s_622_0: bool = false;
        // D s_622_1: write-var gs#399527 <= s_622_0
        fn_state.gs_399527 = s_622_0;
        // N s_622_2: jump b623
        return block_623(state, tracer, fn_state);
    }
    fn block_623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_623_0: read-var gs#399527:u8
        let s_623_0: bool = fn_state.gs_399527;
        // D s_623_1: not s_623_0
        let s_623_1: bool = !s_623_0;
        // N s_623_2: branch s_623_1 b625 b624
        if s_623_1 {
            return block_625(state, tracer, fn_state);
        } else {
            return block_624(state, tracer, fn_state);
        };
    }
    fn block_624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_624_0: const #3484s : i
        let s_624_0: i128 = 3484;
        // C s_624_1: const #14696u : u32
        let s_624_1: u32 = 14696;
        // N s_624_2: write-reg s_624_1 <= s_624_0
        let s_624_2: () = {
            state.write_register::<i128>(s_624_1 as isize, s_624_0);
            tracer.write_register(s_624_1 as isize, s_624_0);
        };
        // C s_624_3: const #22s : i
        let s_624_3: i128 = 22;
        // C s_624_4: const #1s : i
        let s_624_4: i128 = 1;
        // D s_624_5: read-var u#31080:u32
        let s_624_5: u32 = fn_state.u_31080;
        // D s_624_6: cast zx s_624_5 -> bv
        let s_624_6: Bits = Bits::new(s_624_5 as u128, 32u16);
        // D s_624_7: bit-extract s_624_6 s_624_3 s_624_4
        let s_624_7: Bits = (Bits::new(
            ((s_624_6) >> (s_624_3)).value(),
            u16::try_from(s_624_4).unwrap(),
        ));
        // D s_624_8: cast reint s_624_7 -> u8
        let s_624_8: bool = ((s_624_7.value()) != 0);
        // C s_624_9: const #16s : i
        let s_624_9: i128 = 16;
        // C s_624_10: const #4s : i
        let s_624_10: i128 = 4;
        // D s_624_11: read-var u#31080:u32
        let s_624_11: u32 = fn_state.u_31080;
        // D s_624_12: cast zx s_624_11 -> bv
        let s_624_12: Bits = Bits::new(s_624_11 as u128, 32u16);
        // D s_624_13: bit-extract s_624_12 s_624_9 s_624_10
        let s_624_13: Bits = (Bits::new(
            ((s_624_12) >> (s_624_9)).value(),
            u16::try_from(s_624_10).unwrap(),
        ));
        // D s_624_14: cast reint s_624_13 -> u8
        let s_624_14: u8 = (s_624_13.value() as u8);
        // C s_624_15: const #12s : i
        let s_624_15: i128 = 12;
        // C s_624_16: const #4s : i
        let s_624_16: i128 = 4;
        // D s_624_17: read-var u#31080:u32
        let s_624_17: u32 = fn_state.u_31080;
        // D s_624_18: cast zx s_624_17 -> bv
        let s_624_18: Bits = Bits::new(s_624_17 as u128, 32u16);
        // D s_624_19: bit-extract s_624_18 s_624_15 s_624_16
        let s_624_19: Bits = (Bits::new(
            ((s_624_18) >> (s_624_15)).value(),
            u16::try_from(s_624_16).unwrap(),
        ));
        // D s_624_20: cast reint s_624_19 -> u8
        let s_624_20: u8 = (s_624_19.value() as u8);
        // C s_624_21: const #6s : i
        let s_624_21: i128 = 6;
        // C s_624_22: const #2s : i
        let s_624_22: i128 = 2;
        // D s_624_23: read-var u#31080:u32
        let s_624_23: u32 = fn_state.u_31080;
        // D s_624_24: cast zx s_624_23 -> bv
        let s_624_24: Bits = Bits::new(s_624_23 as u128, 32u16);
        // D s_624_25: bit-extract s_624_24 s_624_21 s_624_22
        let s_624_25: Bits = (Bits::new(
            ((s_624_24) >> (s_624_21)).value(),
            u16::try_from(s_624_22).unwrap(),
        ));
        // D s_624_26: cast reint s_624_25 -> u8
        let s_624_26: u8 = (s_624_25.value() as u8);
        // C s_624_27: const #5s : i
        let s_624_27: i128 = 5;
        // C s_624_28: const #1s : i
        let s_624_28: i128 = 1;
        // D s_624_29: read-var u#31080:u32
        let s_624_29: u32 = fn_state.u_31080;
        // D s_624_30: cast zx s_624_29 -> bv
        let s_624_30: Bits = Bits::new(s_624_29 as u128, 32u16);
        // D s_624_31: bit-extract s_624_30 s_624_27 s_624_28
        let s_624_31: Bits = (Bits::new(
            ((s_624_30) >> (s_624_27)).value(),
            u16::try_from(s_624_28).unwrap(),
        ));
        // D s_624_32: cast reint s_624_31 -> u8
        let s_624_32: bool = ((s_624_31.value()) != 0);
        // C s_624_33: const #4s : i
        let s_624_33: i128 = 4;
        // C s_624_34: const #1s : i
        let s_624_34: i128 = 1;
        // D s_624_35: read-var u#31080:u32
        let s_624_35: u32 = fn_state.u_31080;
        // D s_624_36: cast zx s_624_35 -> bv
        let s_624_36: Bits = Bits::new(s_624_35 as u128, 32u16);
        // D s_624_37: bit-extract s_624_36 s_624_33 s_624_34
        let s_624_37: Bits = (Bits::new(
            ((s_624_36) >> (s_624_33)).value(),
            u16::try_from(s_624_34).unwrap(),
        ));
        // D s_624_38: cast reint s_624_37 -> u8
        let s_624_38: bool = ((s_624_37.value()) != 0);
        // C s_624_39: const #0s : i
        let s_624_39: i128 = 0;
        // C s_624_40: const #4s : i
        let s_624_40: i128 = 4;
        // D s_624_41: read-var u#31080:u32
        let s_624_41: u32 = fn_state.u_31080;
        // D s_624_42: cast zx s_624_41 -> bv
        let s_624_42: Bits = Bits::new(s_624_41 as u128, 32u16);
        // D s_624_43: bit-extract s_624_42 s_624_39 s_624_40
        let s_624_43: Bits = (Bits::new(
            ((s_624_42) >> (s_624_39)).value(),
            u16::try_from(s_624_40).unwrap(),
        ));
        // D s_624_44: cast reint s_624_43 -> u8
        let s_624_44: u8 = (s_624_43.value() as u8);
        // D s_624_45: call decode_aarch32_instrs_VLD3_a_A1enc_A_txt(s_624_8, s_624_14, s_624_20, s_624_26, s_624_32, s_624_38, s_624_44)
        let s_624_45: () = decode_aarch32_instrs_VLD3_a_A1enc_A_txt(
            state,
            tracer,
            s_624_8,
            s_624_14,
            s_624_20,
            s_624_26,
            s_624_32,
            s_624_38,
            s_624_44,
        );
        // N s_624_46: return
        return;
    }
    fn block_625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_625_0: read-var merge#var.1:struct
        let s_625_0: u32 = fn_state.merge_var._1;
        // D s_625_1: write-var u#31089 <= s_625_0
        fn_state.u_31089 = s_625_0;
        // C s_625_2: const #23s : i
        let s_625_2: i128 = 23;
        // D s_625_3: read-var u#31089:u32
        let s_625_3: u32 = fn_state.u_31089;
        // D s_625_4: cast zx s_625_3 -> bv
        let s_625_4: Bits = Bits::new(s_625_3 as u128, 32u16);
        // C s_625_5: const #1s : i64
        let s_625_5: i64 = 1;
        // C s_625_6: cast zx s_625_5 -> i
        let s_625_6: i128 = (i128::try_from(s_625_5).unwrap());
        // C s_625_7: const #8s : i
        let s_625_7: i128 = 8;
        // C s_625_8: add s_625_7 s_625_6
        let s_625_8: i128 = (s_625_7 + s_625_6);
        // D s_625_9: bit-extract s_625_4 s_625_2 s_625_8
        let s_625_9: Bits = (Bits::new(
            ((s_625_4) >> (s_625_2)).value(),
            u16::try_from(s_625_8).unwrap(),
        ));
        // D s_625_10: cast reint s_625_9 -> u9
        let s_625_10: u16 = (s_625_9.value() as u16);
        // D s_625_11: cast zx s_625_10 -> bv
        let s_625_11: Bits = Bits::new(s_625_10 as u128, 9u16);
        // C s_625_12: const #488u : u9
        let s_625_12: u16 = 488;
        // C s_625_13: cast zx s_625_12 -> bv
        let s_625_13: Bits = Bits::new(s_625_12 as u128, 9u16);
        // D s_625_14: cmp-eq s_625_11 s_625_13
        let s_625_14: bool = ((s_625_11) == (s_625_13));
        // N s_625_15: branch s_625_14 b2730 b626
        if s_625_14 {
            return block_2730(state, tracer, fn_state);
        } else {
            return block_626(state, tracer, fn_state);
        };
    }
    fn block_626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_626_0: const #0u : u8
        let s_626_0: bool = false;
        // D s_626_1: write-var gs#399552 <= s_626_0
        fn_state.gs_399552 = s_626_0;
        // N s_626_2: jump b627
        return block_627(state, tracer, fn_state);
    }
    fn block_627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_627_0: read-var gs#399552:u8
        let s_627_0: bool = fn_state.gs_399552;
        // N s_627_1: branch s_627_0 b2729 b628
        if s_627_0 {
            return block_2729(state, tracer, fn_state);
        } else {
            return block_628(state, tracer, fn_state);
        };
    }
    fn block_628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_628_0: const #0u : u8
        let s_628_0: bool = false;
        // D s_628_1: write-var gs#399554 <= s_628_0
        fn_state.gs_399554 = s_628_0;
        // N s_628_2: jump b629
        return block_629(state, tracer, fn_state);
    }
    fn block_629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_629_0: read-var gs#399554:u8
        let s_629_0: bool = fn_state.gs_399554;
        // D s_629_1: not s_629_0
        let s_629_1: bool = !s_629_0;
        // N s_629_2: branch s_629_1 b631 b630
        if s_629_1 {
            return block_631(state, tracer, fn_state);
        } else {
            return block_630(state, tracer, fn_state);
        };
    }
    fn block_630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_630_0: const #3486s : i
        let s_630_0: i128 = 3486;
        // C s_630_1: const #14696u : u32
        let s_630_1: u32 = 14696;
        // N s_630_2: write-reg s_630_1 <= s_630_0
        let s_630_2: () = {
            state.write_register::<i128>(s_630_1 as isize, s_630_0);
            tracer.write_register(s_630_1 as isize, s_630_0);
        };
        // C s_630_3: const #22s : i
        let s_630_3: i128 = 22;
        // C s_630_4: const #1s : i
        let s_630_4: i128 = 1;
        // D s_630_5: read-var u#31089:u32
        let s_630_5: u32 = fn_state.u_31089;
        // D s_630_6: cast zx s_630_5 -> bv
        let s_630_6: Bits = Bits::new(s_630_5 as u128, 32u16);
        // D s_630_7: bit-extract s_630_6 s_630_3 s_630_4
        let s_630_7: Bits = (Bits::new(
            ((s_630_6) >> (s_630_3)).value(),
            u16::try_from(s_630_4).unwrap(),
        ));
        // D s_630_8: cast reint s_630_7 -> u8
        let s_630_8: bool = ((s_630_7.value()) != 0);
        // C s_630_9: const #16s : i
        let s_630_9: i128 = 16;
        // C s_630_10: const #4s : i
        let s_630_10: i128 = 4;
        // D s_630_11: read-var u#31089:u32
        let s_630_11: u32 = fn_state.u_31089;
        // D s_630_12: cast zx s_630_11 -> bv
        let s_630_12: Bits = Bits::new(s_630_11 as u128, 32u16);
        // D s_630_13: bit-extract s_630_12 s_630_9 s_630_10
        let s_630_13: Bits = (Bits::new(
            ((s_630_12) >> (s_630_9)).value(),
            u16::try_from(s_630_10).unwrap(),
        ));
        // D s_630_14: cast reint s_630_13 -> u8
        let s_630_14: u8 = (s_630_13.value() as u8);
        // C s_630_15: const #12s : i
        let s_630_15: i128 = 12;
        // C s_630_16: const #4s : i
        let s_630_16: i128 = 4;
        // D s_630_17: read-var u#31089:u32
        let s_630_17: u32 = fn_state.u_31089;
        // D s_630_18: cast zx s_630_17 -> bv
        let s_630_18: Bits = Bits::new(s_630_17 as u128, 32u16);
        // D s_630_19: bit-extract s_630_18 s_630_15 s_630_16
        let s_630_19: Bits = (Bits::new(
            ((s_630_18) >> (s_630_15)).value(),
            u16::try_from(s_630_16).unwrap(),
        ));
        // D s_630_20: cast reint s_630_19 -> u8
        let s_630_20: u8 = (s_630_19.value() as u8);
        // C s_630_21: const #8s : i
        let s_630_21: i128 = 8;
        // C s_630_22: const #4s : i
        let s_630_22: i128 = 4;
        // D s_630_23: read-var u#31089:u32
        let s_630_23: u32 = fn_state.u_31089;
        // D s_630_24: cast zx s_630_23 -> bv
        let s_630_24: Bits = Bits::new(s_630_23 as u128, 32u16);
        // D s_630_25: bit-extract s_630_24 s_630_21 s_630_22
        let s_630_25: Bits = (Bits::new(
            ((s_630_24) >> (s_630_21)).value(),
            u16::try_from(s_630_22).unwrap(),
        ));
        // D s_630_26: cast reint s_630_25 -> u8
        let s_630_26: u8 = (s_630_25.value() as u8);
        // C s_630_27: const #6s : i
        let s_630_27: i128 = 6;
        // C s_630_28: const #2s : i
        let s_630_28: i128 = 2;
        // D s_630_29: read-var u#31089:u32
        let s_630_29: u32 = fn_state.u_31089;
        // D s_630_30: cast zx s_630_29 -> bv
        let s_630_30: Bits = Bits::new(s_630_29 as u128, 32u16);
        // D s_630_31: bit-extract s_630_30 s_630_27 s_630_28
        let s_630_31: Bits = (Bits::new(
            ((s_630_30) >> (s_630_27)).value(),
            u16::try_from(s_630_28).unwrap(),
        ));
        // D s_630_32: cast reint s_630_31 -> u8
        let s_630_32: u8 = (s_630_31.value() as u8);
        // C s_630_33: const #4s : i
        let s_630_33: i128 = 4;
        // C s_630_34: const #2s : i
        let s_630_34: i128 = 2;
        // D s_630_35: read-var u#31089:u32
        let s_630_35: u32 = fn_state.u_31089;
        // D s_630_36: cast zx s_630_35 -> bv
        let s_630_36: Bits = Bits::new(s_630_35 as u128, 32u16);
        // D s_630_37: bit-extract s_630_36 s_630_33 s_630_34
        let s_630_37: Bits = (Bits::new(
            ((s_630_36) >> (s_630_33)).value(),
            u16::try_from(s_630_34).unwrap(),
        ));
        // D s_630_38: cast reint s_630_37 -> u8
        let s_630_38: u8 = (s_630_37.value() as u8);
        // C s_630_39: const #0s : i
        let s_630_39: i128 = 0;
        // C s_630_40: const #4s : i
        let s_630_40: i128 = 4;
        // D s_630_41: read-var u#31089:u32
        let s_630_41: u32 = fn_state.u_31089;
        // D s_630_42: cast zx s_630_41 -> bv
        let s_630_42: Bits = Bits::new(s_630_41 as u128, 32u16);
        // D s_630_43: bit-extract s_630_42 s_630_39 s_630_40
        let s_630_43: Bits = (Bits::new(
            ((s_630_42) >> (s_630_39)).value(),
            u16::try_from(s_630_40).unwrap(),
        ));
        // D s_630_44: cast reint s_630_43 -> u8
        let s_630_44: u8 = (s_630_43.value() as u8);
        // D s_630_45: call decode_aarch32_instrs_VLD3_m_A1enc_A_txt(s_630_8, s_630_14, s_630_20, s_630_26, s_630_32, s_630_38, s_630_44)
        let s_630_45: () = decode_aarch32_instrs_VLD3_m_A1enc_A_txt(
            state,
            tracer,
            s_630_8,
            s_630_14,
            s_630_20,
            s_630_26,
            s_630_32,
            s_630_38,
            s_630_44,
        );
        // N s_630_46: return
        return;
    }
    fn block_631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_631_0: read-var merge#var.1:struct
        let s_631_0: u32 = fn_state.merge_var._1;
        // D s_631_1: write-var u#31098 <= s_631_0
        fn_state.u_31098 = s_631_0;
        // C s_631_2: const #23s : i
        let s_631_2: i128 = 23;
        // D s_631_3: read-var u#31098:u32
        let s_631_3: u32 = fn_state.u_31098;
        // D s_631_4: cast zx s_631_3 -> bv
        let s_631_4: Bits = Bits::new(s_631_3 as u128, 32u16);
        // C s_631_5: const #1s : i64
        let s_631_5: i64 = 1;
        // C s_631_6: cast zx s_631_5 -> i
        let s_631_6: i128 = (i128::try_from(s_631_5).unwrap());
        // C s_631_7: const #8s : i
        let s_631_7: i128 = 8;
        // C s_631_8: add s_631_7 s_631_6
        let s_631_8: i128 = (s_631_7 + s_631_6);
        // D s_631_9: bit-extract s_631_4 s_631_2 s_631_8
        let s_631_9: Bits = (Bits::new(
            ((s_631_4) >> (s_631_2)).value(),
            u16::try_from(s_631_8).unwrap(),
        ));
        // D s_631_10: cast reint s_631_9 -> u9
        let s_631_10: u16 = (s_631_9.value() as u16);
        // D s_631_11: cast zx s_631_10 -> bv
        let s_631_11: Bits = Bits::new(s_631_10 as u128, 9u16);
        // C s_631_12: const #489u : u9
        let s_631_12: u16 = 489;
        // C s_631_13: cast zx s_631_12 -> bv
        let s_631_13: Bits = Bits::new(s_631_12 as u128, 9u16);
        // D s_631_14: cmp-eq s_631_11 s_631_13
        let s_631_14: bool = ((s_631_11) == (s_631_13));
        // N s_631_15: branch s_631_14 b2725 b632
        if s_631_14 {
            return block_2725(state, tracer, fn_state);
        } else {
            return block_632(state, tracer, fn_state);
        };
    }
    fn block_632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_632_0: const #0u : u8
        let s_632_0: bool = false;
        // D s_632_1: write-var gs#399579 <= s_632_0
        fn_state.gs_399579 = s_632_0;
        // N s_632_2: jump b633
        return block_633(state, tracer, fn_state);
    }
    fn block_633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_633_0: read-var gs#399579:u8
        let s_633_0: bool = fn_state.gs_399579;
        // N s_633_1: branch s_633_0 b2724 b634
        if s_633_0 {
            return block_2724(state, tracer, fn_state);
        } else {
            return block_634(state, tracer, fn_state);
        };
    }
    fn block_634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_634_0: const #0u : u8
        let s_634_0: bool = false;
        // D s_634_1: write-var gs#399581 <= s_634_0
        fn_state.gs_399581 = s_634_0;
        // N s_634_2: jump b635
        return block_635(state, tracer, fn_state);
    }
    fn block_635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_635_0: read-var gs#399581:u8
        let s_635_0: bool = fn_state.gs_399581;
        // D s_635_1: not s_635_0
        let s_635_1: bool = !s_635_0;
        // N s_635_2: branch s_635_1 b637 b636
        if s_635_1 {
            return block_637(state, tracer, fn_state);
        } else {
            return block_636(state, tracer, fn_state);
        };
    }
    fn block_636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_636_0: const #3488s : i
        let s_636_0: i128 = 3488;
        // C s_636_1: const #14696u : u32
        let s_636_1: u32 = 14696;
        // N s_636_2: write-reg s_636_1 <= s_636_0
        let s_636_2: () = {
            state.write_register::<i128>(s_636_1 as isize, s_636_0);
            tracer.write_register(s_636_1 as isize, s_636_0);
        };
        // C s_636_3: const #22s : i
        let s_636_3: i128 = 22;
        // C s_636_4: const #1s : i
        let s_636_4: i128 = 1;
        // D s_636_5: read-var u#31098:u32
        let s_636_5: u32 = fn_state.u_31098;
        // D s_636_6: cast zx s_636_5 -> bv
        let s_636_6: Bits = Bits::new(s_636_5 as u128, 32u16);
        // D s_636_7: bit-extract s_636_6 s_636_3 s_636_4
        let s_636_7: Bits = (Bits::new(
            ((s_636_6) >> (s_636_3)).value(),
            u16::try_from(s_636_4).unwrap(),
        ));
        // D s_636_8: cast reint s_636_7 -> u8
        let s_636_8: bool = ((s_636_7.value()) != 0);
        // C s_636_9: const #16s : i
        let s_636_9: i128 = 16;
        // C s_636_10: const #4s : i
        let s_636_10: i128 = 4;
        // D s_636_11: read-var u#31098:u32
        let s_636_11: u32 = fn_state.u_31098;
        // D s_636_12: cast zx s_636_11 -> bv
        let s_636_12: Bits = Bits::new(s_636_11 as u128, 32u16);
        // D s_636_13: bit-extract s_636_12 s_636_9 s_636_10
        let s_636_13: Bits = (Bits::new(
            ((s_636_12) >> (s_636_9)).value(),
            u16::try_from(s_636_10).unwrap(),
        ));
        // D s_636_14: cast reint s_636_13 -> u8
        let s_636_14: u8 = (s_636_13.value() as u8);
        // C s_636_15: const #12s : i
        let s_636_15: i128 = 12;
        // C s_636_16: const #4s : i
        let s_636_16: i128 = 4;
        // D s_636_17: read-var u#31098:u32
        let s_636_17: u32 = fn_state.u_31098;
        // D s_636_18: cast zx s_636_17 -> bv
        let s_636_18: Bits = Bits::new(s_636_17 as u128, 32u16);
        // D s_636_19: bit-extract s_636_18 s_636_15 s_636_16
        let s_636_19: Bits = (Bits::new(
            ((s_636_18) >> (s_636_15)).value(),
            u16::try_from(s_636_16).unwrap(),
        ));
        // D s_636_20: cast reint s_636_19 -> u8
        let s_636_20: u8 = (s_636_19.value() as u8);
        // C s_636_21: const #10s : i
        let s_636_21: i128 = 10;
        // C s_636_22: const #2s : i
        let s_636_22: i128 = 2;
        // D s_636_23: read-var u#31098:u32
        let s_636_23: u32 = fn_state.u_31098;
        // D s_636_24: cast zx s_636_23 -> bv
        let s_636_24: Bits = Bits::new(s_636_23 as u128, 32u16);
        // D s_636_25: bit-extract s_636_24 s_636_21 s_636_22
        let s_636_25: Bits = (Bits::new(
            ((s_636_24) >> (s_636_21)).value(),
            u16::try_from(s_636_22).unwrap(),
        ));
        // D s_636_26: cast reint s_636_25 -> u8
        let s_636_26: u8 = (s_636_25.value() as u8);
        // C s_636_27: const #4s : i
        let s_636_27: i128 = 4;
        // C s_636_28: const #4s : i
        let s_636_28: i128 = 4;
        // D s_636_29: read-var u#31098:u32
        let s_636_29: u32 = fn_state.u_31098;
        // D s_636_30: cast zx s_636_29 -> bv
        let s_636_30: Bits = Bits::new(s_636_29 as u128, 32u16);
        // D s_636_31: bit-extract s_636_30 s_636_27 s_636_28
        let s_636_31: Bits = (Bits::new(
            ((s_636_30) >> (s_636_27)).value(),
            u16::try_from(s_636_28).unwrap(),
        ));
        // D s_636_32: cast reint s_636_31 -> u8
        let s_636_32: u8 = (s_636_31.value() as u8);
        // C s_636_33: const #0s : i
        let s_636_33: i128 = 0;
        // C s_636_34: const #4s : i
        let s_636_34: i128 = 4;
        // D s_636_35: read-var u#31098:u32
        let s_636_35: u32 = fn_state.u_31098;
        // D s_636_36: cast zx s_636_35 -> bv
        let s_636_36: Bits = Bits::new(s_636_35 as u128, 32u16);
        // D s_636_37: bit-extract s_636_36 s_636_33 s_636_34
        let s_636_37: Bits = (Bits::new(
            ((s_636_36) >> (s_636_33)).value(),
            u16::try_from(s_636_34).unwrap(),
        ));
        // D s_636_38: cast reint s_636_37 -> u8
        let s_636_38: u8 = (s_636_37.value() as u8);
        // D s_636_39: call decode_aarch32_instrs_VLD4_1_A1enc_A_txt(s_636_8, s_636_14, s_636_20, s_636_26, s_636_32, s_636_38)
        let s_636_39: () = decode_aarch32_instrs_VLD4_1_A1enc_A_txt(
            state,
            tracer,
            s_636_8,
            s_636_14,
            s_636_20,
            s_636_26,
            s_636_32,
            s_636_38,
        );
        // N s_636_40: return
        return;
    }
    fn block_637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_637_0: read-var merge#var.1:struct
        let s_637_0: u32 = fn_state.merge_var._1;
        // D s_637_1: write-var u#31106 <= s_637_0
        fn_state.u_31106 = s_637_0;
        // C s_637_2: const #23s : i
        let s_637_2: i128 = 23;
        // D s_637_3: read-var u#31106:u32
        let s_637_3: u32 = fn_state.u_31106;
        // D s_637_4: cast zx s_637_3 -> bv
        let s_637_4: Bits = Bits::new(s_637_3 as u128, 32u16);
        // C s_637_5: const #1s : i64
        let s_637_5: i64 = 1;
        // C s_637_6: cast zx s_637_5 -> i
        let s_637_6: i128 = (i128::try_from(s_637_5).unwrap());
        // C s_637_7: const #8s : i
        let s_637_7: i128 = 8;
        // C s_637_8: add s_637_7 s_637_6
        let s_637_8: i128 = (s_637_7 + s_637_6);
        // D s_637_9: bit-extract s_637_4 s_637_2 s_637_8
        let s_637_9: Bits = (Bits::new(
            ((s_637_4) >> (s_637_2)).value(),
            u16::try_from(s_637_8).unwrap(),
        ));
        // D s_637_10: cast reint s_637_9 -> u9
        let s_637_10: u16 = (s_637_9.value() as u16);
        // D s_637_11: cast zx s_637_10 -> bv
        let s_637_11: Bits = Bits::new(s_637_10 as u128, 9u16);
        // C s_637_12: const #489u : u9
        let s_637_12: u16 = 489;
        // C s_637_13: cast zx s_637_12 -> bv
        let s_637_13: Bits = Bits::new(s_637_12 as u128, 9u16);
        // D s_637_14: cmp-eq s_637_11 s_637_13
        let s_637_14: bool = ((s_637_11) == (s_637_13));
        // N s_637_15: branch s_637_14 b2720 b638
        if s_637_14 {
            return block_2720(state, tracer, fn_state);
        } else {
            return block_638(state, tracer, fn_state);
        };
    }
    fn block_638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_638_0: const #0u : u8
        let s_638_0: bool = false;
        // D s_638_1: write-var gs#399604 <= s_638_0
        fn_state.gs_399604 = s_638_0;
        // N s_638_2: jump b639
        return block_639(state, tracer, fn_state);
    }
    fn block_639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_639_0: read-var gs#399604:u8
        let s_639_0: bool = fn_state.gs_399604;
        // N s_639_1: branch s_639_0 b2719 b640
        if s_639_0 {
            return block_2719(state, tracer, fn_state);
        } else {
            return block_640(state, tracer, fn_state);
        };
    }
    fn block_640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_640_0: const #0u : u8
        let s_640_0: bool = false;
        // D s_640_1: write-var gs#399606 <= s_640_0
        fn_state.gs_399606 = s_640_0;
        // N s_640_2: jump b641
        return block_641(state, tracer, fn_state);
    }
    fn block_641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_641_0: read-var gs#399606:u8
        let s_641_0: bool = fn_state.gs_399606;
        // D s_641_1: not s_641_0
        let s_641_1: bool = !s_641_0;
        // N s_641_2: branch s_641_1 b643 b642
        if s_641_1 {
            return block_643(state, tracer, fn_state);
        } else {
            return block_642(state, tracer, fn_state);
        };
    }
    fn block_642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_642_0: const #3489s : i
        let s_642_0: i128 = 3489;
        // C s_642_1: const #14696u : u32
        let s_642_1: u32 = 14696;
        // N s_642_2: write-reg s_642_1 <= s_642_0
        let s_642_2: () = {
            state.write_register::<i128>(s_642_1 as isize, s_642_0);
            tracer.write_register(s_642_1 as isize, s_642_0);
        };
        // C s_642_3: const #22s : i
        let s_642_3: i128 = 22;
        // C s_642_4: const #1s : i
        let s_642_4: i128 = 1;
        // D s_642_5: read-var u#31106:u32
        let s_642_5: u32 = fn_state.u_31106;
        // D s_642_6: cast zx s_642_5 -> bv
        let s_642_6: Bits = Bits::new(s_642_5 as u128, 32u16);
        // D s_642_7: bit-extract s_642_6 s_642_3 s_642_4
        let s_642_7: Bits = (Bits::new(
            ((s_642_6) >> (s_642_3)).value(),
            u16::try_from(s_642_4).unwrap(),
        ));
        // D s_642_8: cast reint s_642_7 -> u8
        let s_642_8: bool = ((s_642_7.value()) != 0);
        // C s_642_9: const #16s : i
        let s_642_9: i128 = 16;
        // C s_642_10: const #4s : i
        let s_642_10: i128 = 4;
        // D s_642_11: read-var u#31106:u32
        let s_642_11: u32 = fn_state.u_31106;
        // D s_642_12: cast zx s_642_11 -> bv
        let s_642_12: Bits = Bits::new(s_642_11 as u128, 32u16);
        // D s_642_13: bit-extract s_642_12 s_642_9 s_642_10
        let s_642_13: Bits = (Bits::new(
            ((s_642_12) >> (s_642_9)).value(),
            u16::try_from(s_642_10).unwrap(),
        ));
        // D s_642_14: cast reint s_642_13 -> u8
        let s_642_14: u8 = (s_642_13.value() as u8);
        // C s_642_15: const #12s : i
        let s_642_15: i128 = 12;
        // C s_642_16: const #4s : i
        let s_642_16: i128 = 4;
        // D s_642_17: read-var u#31106:u32
        let s_642_17: u32 = fn_state.u_31106;
        // D s_642_18: cast zx s_642_17 -> bv
        let s_642_18: Bits = Bits::new(s_642_17 as u128, 32u16);
        // D s_642_19: bit-extract s_642_18 s_642_15 s_642_16
        let s_642_19: Bits = (Bits::new(
            ((s_642_18) >> (s_642_15)).value(),
            u16::try_from(s_642_16).unwrap(),
        ));
        // D s_642_20: cast reint s_642_19 -> u8
        let s_642_20: u8 = (s_642_19.value() as u8);
        // C s_642_21: const #10s : i
        let s_642_21: i128 = 10;
        // C s_642_22: const #2s : i
        let s_642_22: i128 = 2;
        // D s_642_23: read-var u#31106:u32
        let s_642_23: u32 = fn_state.u_31106;
        // D s_642_24: cast zx s_642_23 -> bv
        let s_642_24: Bits = Bits::new(s_642_23 as u128, 32u16);
        // D s_642_25: bit-extract s_642_24 s_642_21 s_642_22
        let s_642_25: Bits = (Bits::new(
            ((s_642_24) >> (s_642_21)).value(),
            u16::try_from(s_642_22).unwrap(),
        ));
        // D s_642_26: cast reint s_642_25 -> u8
        let s_642_26: u8 = (s_642_25.value() as u8);
        // C s_642_27: const #4s : i
        let s_642_27: i128 = 4;
        // C s_642_28: const #4s : i
        let s_642_28: i128 = 4;
        // D s_642_29: read-var u#31106:u32
        let s_642_29: u32 = fn_state.u_31106;
        // D s_642_30: cast zx s_642_29 -> bv
        let s_642_30: Bits = Bits::new(s_642_29 as u128, 32u16);
        // D s_642_31: bit-extract s_642_30 s_642_27 s_642_28
        let s_642_31: Bits = (Bits::new(
            ((s_642_30) >> (s_642_27)).value(),
            u16::try_from(s_642_28).unwrap(),
        ));
        // D s_642_32: cast reint s_642_31 -> u8
        let s_642_32: u8 = (s_642_31.value() as u8);
        // C s_642_33: const #0s : i
        let s_642_33: i128 = 0;
        // C s_642_34: const #4s : i
        let s_642_34: i128 = 4;
        // D s_642_35: read-var u#31106:u32
        let s_642_35: u32 = fn_state.u_31106;
        // D s_642_36: cast zx s_642_35 -> bv
        let s_642_36: Bits = Bits::new(s_642_35 as u128, 32u16);
        // D s_642_37: bit-extract s_642_36 s_642_33 s_642_34
        let s_642_37: Bits = (Bits::new(
            ((s_642_36) >> (s_642_33)).value(),
            u16::try_from(s_642_34).unwrap(),
        ));
        // D s_642_38: cast reint s_642_37 -> u8
        let s_642_38: u8 = (s_642_37.value() as u8);
        // D s_642_39: call decode_aarch32_instrs_VLD4_1_A2enc_A_txt(s_642_8, s_642_14, s_642_20, s_642_26, s_642_32, s_642_38)
        let s_642_39: () = decode_aarch32_instrs_VLD4_1_A2enc_A_txt(
            state,
            tracer,
            s_642_8,
            s_642_14,
            s_642_20,
            s_642_26,
            s_642_32,
            s_642_38,
        );
        // N s_642_40: return
        return;
    }
    fn block_643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_643_0: read-var merge#var.1:struct
        let s_643_0: u32 = fn_state.merge_var._1;
        // D s_643_1: write-var u#31114 <= s_643_0
        fn_state.u_31114 = s_643_0;
        // C s_643_2: const #23s : i
        let s_643_2: i128 = 23;
        // D s_643_3: read-var u#31114:u32
        let s_643_3: u32 = fn_state.u_31114;
        // D s_643_4: cast zx s_643_3 -> bv
        let s_643_4: Bits = Bits::new(s_643_3 as u128, 32u16);
        // C s_643_5: const #1s : i64
        let s_643_5: i64 = 1;
        // C s_643_6: cast zx s_643_5 -> i
        let s_643_6: i128 = (i128::try_from(s_643_5).unwrap());
        // C s_643_7: const #8s : i
        let s_643_7: i128 = 8;
        // C s_643_8: add s_643_7 s_643_6
        let s_643_8: i128 = (s_643_7 + s_643_6);
        // D s_643_9: bit-extract s_643_4 s_643_2 s_643_8
        let s_643_9: Bits = (Bits::new(
            ((s_643_4) >> (s_643_2)).value(),
            u16::try_from(s_643_8).unwrap(),
        ));
        // D s_643_10: cast reint s_643_9 -> u9
        let s_643_10: u16 = (s_643_9.value() as u16);
        // D s_643_11: cast zx s_643_10 -> bv
        let s_643_11: Bits = Bits::new(s_643_10 as u128, 9u16);
        // C s_643_12: const #489u : u9
        let s_643_12: u16 = 489;
        // C s_643_13: cast zx s_643_12 -> bv
        let s_643_13: Bits = Bits::new(s_643_12 as u128, 9u16);
        // D s_643_14: cmp-eq s_643_11 s_643_13
        let s_643_14: bool = ((s_643_11) == (s_643_13));
        // N s_643_15: branch s_643_14 b2715 b644
        if s_643_14 {
            return block_2715(state, tracer, fn_state);
        } else {
            return block_644(state, tracer, fn_state);
        };
    }
    fn block_644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_644_0: const #0u : u8
        let s_644_0: bool = false;
        // D s_644_1: write-var gs#399629 <= s_644_0
        fn_state.gs_399629 = s_644_0;
        // N s_644_2: jump b645
        return block_645(state, tracer, fn_state);
    }
    fn block_645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_645_0: read-var gs#399629:u8
        let s_645_0: bool = fn_state.gs_399629;
        // N s_645_1: branch s_645_0 b2714 b646
        if s_645_0 {
            return block_2714(state, tracer, fn_state);
        } else {
            return block_646(state, tracer, fn_state);
        };
    }
    fn block_646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_646_0: const #0u : u8
        let s_646_0: bool = false;
        // D s_646_1: write-var gs#399631 <= s_646_0
        fn_state.gs_399631 = s_646_0;
        // N s_646_2: jump b647
        return block_647(state, tracer, fn_state);
    }
    fn block_647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_647_0: read-var gs#399631:u8
        let s_647_0: bool = fn_state.gs_399631;
        // D s_647_1: not s_647_0
        let s_647_1: bool = !s_647_0;
        // N s_647_2: branch s_647_1 b649 b648
        if s_647_1 {
            return block_649(state, tracer, fn_state);
        } else {
            return block_648(state, tracer, fn_state);
        };
    }
    fn block_648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_648_0: const #3490s : i
        let s_648_0: i128 = 3490;
        // C s_648_1: const #14696u : u32
        let s_648_1: u32 = 14696;
        // N s_648_2: write-reg s_648_1 <= s_648_0
        let s_648_2: () = {
            state.write_register::<i128>(s_648_1 as isize, s_648_0);
            tracer.write_register(s_648_1 as isize, s_648_0);
        };
        // C s_648_3: const #22s : i
        let s_648_3: i128 = 22;
        // C s_648_4: const #1s : i
        let s_648_4: i128 = 1;
        // D s_648_5: read-var u#31114:u32
        let s_648_5: u32 = fn_state.u_31114;
        // D s_648_6: cast zx s_648_5 -> bv
        let s_648_6: Bits = Bits::new(s_648_5 as u128, 32u16);
        // D s_648_7: bit-extract s_648_6 s_648_3 s_648_4
        let s_648_7: Bits = (Bits::new(
            ((s_648_6) >> (s_648_3)).value(),
            u16::try_from(s_648_4).unwrap(),
        ));
        // D s_648_8: cast reint s_648_7 -> u8
        let s_648_8: bool = ((s_648_7.value()) != 0);
        // C s_648_9: const #16s : i
        let s_648_9: i128 = 16;
        // C s_648_10: const #4s : i
        let s_648_10: i128 = 4;
        // D s_648_11: read-var u#31114:u32
        let s_648_11: u32 = fn_state.u_31114;
        // D s_648_12: cast zx s_648_11 -> bv
        let s_648_12: Bits = Bits::new(s_648_11 as u128, 32u16);
        // D s_648_13: bit-extract s_648_12 s_648_9 s_648_10
        let s_648_13: Bits = (Bits::new(
            ((s_648_12) >> (s_648_9)).value(),
            u16::try_from(s_648_10).unwrap(),
        ));
        // D s_648_14: cast reint s_648_13 -> u8
        let s_648_14: u8 = (s_648_13.value() as u8);
        // C s_648_15: const #12s : i
        let s_648_15: i128 = 12;
        // C s_648_16: const #4s : i
        let s_648_16: i128 = 4;
        // D s_648_17: read-var u#31114:u32
        let s_648_17: u32 = fn_state.u_31114;
        // D s_648_18: cast zx s_648_17 -> bv
        let s_648_18: Bits = Bits::new(s_648_17 as u128, 32u16);
        // D s_648_19: bit-extract s_648_18 s_648_15 s_648_16
        let s_648_19: Bits = (Bits::new(
            ((s_648_18) >> (s_648_15)).value(),
            u16::try_from(s_648_16).unwrap(),
        ));
        // D s_648_20: cast reint s_648_19 -> u8
        let s_648_20: u8 = (s_648_19.value() as u8);
        // C s_648_21: const #10s : i
        let s_648_21: i128 = 10;
        // C s_648_22: const #2s : i
        let s_648_22: i128 = 2;
        // D s_648_23: read-var u#31114:u32
        let s_648_23: u32 = fn_state.u_31114;
        // D s_648_24: cast zx s_648_23 -> bv
        let s_648_24: Bits = Bits::new(s_648_23 as u128, 32u16);
        // D s_648_25: bit-extract s_648_24 s_648_21 s_648_22
        let s_648_25: Bits = (Bits::new(
            ((s_648_24) >> (s_648_21)).value(),
            u16::try_from(s_648_22).unwrap(),
        ));
        // D s_648_26: cast reint s_648_25 -> u8
        let s_648_26: u8 = (s_648_25.value() as u8);
        // C s_648_27: const #4s : i
        let s_648_27: i128 = 4;
        // C s_648_28: const #4s : i
        let s_648_28: i128 = 4;
        // D s_648_29: read-var u#31114:u32
        let s_648_29: u32 = fn_state.u_31114;
        // D s_648_30: cast zx s_648_29 -> bv
        let s_648_30: Bits = Bits::new(s_648_29 as u128, 32u16);
        // D s_648_31: bit-extract s_648_30 s_648_27 s_648_28
        let s_648_31: Bits = (Bits::new(
            ((s_648_30) >> (s_648_27)).value(),
            u16::try_from(s_648_28).unwrap(),
        ));
        // D s_648_32: cast reint s_648_31 -> u8
        let s_648_32: u8 = (s_648_31.value() as u8);
        // C s_648_33: const #0s : i
        let s_648_33: i128 = 0;
        // C s_648_34: const #4s : i
        let s_648_34: i128 = 4;
        // D s_648_35: read-var u#31114:u32
        let s_648_35: u32 = fn_state.u_31114;
        // D s_648_36: cast zx s_648_35 -> bv
        let s_648_36: Bits = Bits::new(s_648_35 as u128, 32u16);
        // D s_648_37: bit-extract s_648_36 s_648_33 s_648_34
        let s_648_37: Bits = (Bits::new(
            ((s_648_36) >> (s_648_33)).value(),
            u16::try_from(s_648_34).unwrap(),
        ));
        // D s_648_38: cast reint s_648_37 -> u8
        let s_648_38: u8 = (s_648_37.value() as u8);
        // D s_648_39: call decode_aarch32_instrs_VLD4_1_A3enc_A_txt(s_648_8, s_648_14, s_648_20, s_648_26, s_648_32, s_648_38)
        let s_648_39: () = decode_aarch32_instrs_VLD4_1_A3enc_A_txt(
            state,
            tracer,
            s_648_8,
            s_648_14,
            s_648_20,
            s_648_26,
            s_648_32,
            s_648_38,
        );
        // N s_648_40: return
        return;
    }
    fn block_649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_649_0: read-var merge#var.1:struct
        let s_649_0: u32 = fn_state.merge_var._1;
        // D s_649_1: write-var u#31122 <= s_649_0
        fn_state.u_31122 = s_649_0;
        // C s_649_2: const #23s : i
        let s_649_2: i128 = 23;
        // D s_649_3: read-var u#31122:u32
        let s_649_3: u32 = fn_state.u_31122;
        // D s_649_4: cast zx s_649_3 -> bv
        let s_649_4: Bits = Bits::new(s_649_3 as u128, 32u16);
        // C s_649_5: const #1s : i64
        let s_649_5: i64 = 1;
        // C s_649_6: cast zx s_649_5 -> i
        let s_649_6: i128 = (i128::try_from(s_649_5).unwrap());
        // C s_649_7: const #8s : i
        let s_649_7: i128 = 8;
        // C s_649_8: add s_649_7 s_649_6
        let s_649_8: i128 = (s_649_7 + s_649_6);
        // D s_649_9: bit-extract s_649_4 s_649_2 s_649_8
        let s_649_9: Bits = (Bits::new(
            ((s_649_4) >> (s_649_2)).value(),
            u16::try_from(s_649_8).unwrap(),
        ));
        // D s_649_10: cast reint s_649_9 -> u9
        let s_649_10: u16 = (s_649_9.value() as u16);
        // D s_649_11: cast zx s_649_10 -> bv
        let s_649_11: Bits = Bits::new(s_649_10 as u128, 9u16);
        // C s_649_12: const #489u : u9
        let s_649_12: u16 = 489;
        // C s_649_13: cast zx s_649_12 -> bv
        let s_649_13: Bits = Bits::new(s_649_12 as u128, 9u16);
        // D s_649_14: cmp-eq s_649_11 s_649_13
        let s_649_14: bool = ((s_649_11) == (s_649_13));
        // N s_649_15: branch s_649_14 b2710 b650
        if s_649_14 {
            return block_2710(state, tracer, fn_state);
        } else {
            return block_650(state, tracer, fn_state);
        };
    }
    fn block_650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_650_0: const #0u : u8
        let s_650_0: bool = false;
        // D s_650_1: write-var gs#399654 <= s_650_0
        fn_state.gs_399654 = s_650_0;
        // N s_650_2: jump b651
        return block_651(state, tracer, fn_state);
    }
    fn block_651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_651_0: read-var gs#399654:u8
        let s_651_0: bool = fn_state.gs_399654;
        // N s_651_1: branch s_651_0 b2709 b652
        if s_651_0 {
            return block_2709(state, tracer, fn_state);
        } else {
            return block_652(state, tracer, fn_state);
        };
    }
    fn block_652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_652_0: const #0u : u8
        let s_652_0: bool = false;
        // D s_652_1: write-var gs#399656 <= s_652_0
        fn_state.gs_399656 = s_652_0;
        // N s_652_2: jump b653
        return block_653(state, tracer, fn_state);
    }
    fn block_653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_653_0: read-var gs#399656:u8
        let s_653_0: bool = fn_state.gs_399656;
        // D s_653_1: not s_653_0
        let s_653_1: bool = !s_653_0;
        // N s_653_2: branch s_653_1 b655 b654
        if s_653_1 {
            return block_655(state, tracer, fn_state);
        } else {
            return block_654(state, tracer, fn_state);
        };
    }
    fn block_654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_654_0: const #3494s : i
        let s_654_0: i128 = 3494;
        // C s_654_1: const #14696u : u32
        let s_654_1: u32 = 14696;
        // N s_654_2: write-reg s_654_1 <= s_654_0
        let s_654_2: () = {
            state.write_register::<i128>(s_654_1 as isize, s_654_0);
            tracer.write_register(s_654_1 as isize, s_654_0);
        };
        // C s_654_3: const #22s : i
        let s_654_3: i128 = 22;
        // C s_654_4: const #1s : i
        let s_654_4: i128 = 1;
        // D s_654_5: read-var u#31122:u32
        let s_654_5: u32 = fn_state.u_31122;
        // D s_654_6: cast zx s_654_5 -> bv
        let s_654_6: Bits = Bits::new(s_654_5 as u128, 32u16);
        // D s_654_7: bit-extract s_654_6 s_654_3 s_654_4
        let s_654_7: Bits = (Bits::new(
            ((s_654_6) >> (s_654_3)).value(),
            u16::try_from(s_654_4).unwrap(),
        ));
        // D s_654_8: cast reint s_654_7 -> u8
        let s_654_8: bool = ((s_654_7.value()) != 0);
        // C s_654_9: const #16s : i
        let s_654_9: i128 = 16;
        // C s_654_10: const #4s : i
        let s_654_10: i128 = 4;
        // D s_654_11: read-var u#31122:u32
        let s_654_11: u32 = fn_state.u_31122;
        // D s_654_12: cast zx s_654_11 -> bv
        let s_654_12: Bits = Bits::new(s_654_11 as u128, 32u16);
        // D s_654_13: bit-extract s_654_12 s_654_9 s_654_10
        let s_654_13: Bits = (Bits::new(
            ((s_654_12) >> (s_654_9)).value(),
            u16::try_from(s_654_10).unwrap(),
        ));
        // D s_654_14: cast reint s_654_13 -> u8
        let s_654_14: u8 = (s_654_13.value() as u8);
        // C s_654_15: const #12s : i
        let s_654_15: i128 = 12;
        // C s_654_16: const #4s : i
        let s_654_16: i128 = 4;
        // D s_654_17: read-var u#31122:u32
        let s_654_17: u32 = fn_state.u_31122;
        // D s_654_18: cast zx s_654_17 -> bv
        let s_654_18: Bits = Bits::new(s_654_17 as u128, 32u16);
        // D s_654_19: bit-extract s_654_18 s_654_15 s_654_16
        let s_654_19: Bits = (Bits::new(
            ((s_654_18) >> (s_654_15)).value(),
            u16::try_from(s_654_16).unwrap(),
        ));
        // D s_654_20: cast reint s_654_19 -> u8
        let s_654_20: u8 = (s_654_19.value() as u8);
        // C s_654_21: const #6s : i
        let s_654_21: i128 = 6;
        // C s_654_22: const #2s : i
        let s_654_22: i128 = 2;
        // D s_654_23: read-var u#31122:u32
        let s_654_23: u32 = fn_state.u_31122;
        // D s_654_24: cast zx s_654_23 -> bv
        let s_654_24: Bits = Bits::new(s_654_23 as u128, 32u16);
        // D s_654_25: bit-extract s_654_24 s_654_21 s_654_22
        let s_654_25: Bits = (Bits::new(
            ((s_654_24) >> (s_654_21)).value(),
            u16::try_from(s_654_22).unwrap(),
        ));
        // D s_654_26: cast reint s_654_25 -> u8
        let s_654_26: u8 = (s_654_25.value() as u8);
        // C s_654_27: const #5s : i
        let s_654_27: i128 = 5;
        // C s_654_28: const #1s : i
        let s_654_28: i128 = 1;
        // D s_654_29: read-var u#31122:u32
        let s_654_29: u32 = fn_state.u_31122;
        // D s_654_30: cast zx s_654_29 -> bv
        let s_654_30: Bits = Bits::new(s_654_29 as u128, 32u16);
        // D s_654_31: bit-extract s_654_30 s_654_27 s_654_28
        let s_654_31: Bits = (Bits::new(
            ((s_654_30) >> (s_654_27)).value(),
            u16::try_from(s_654_28).unwrap(),
        ));
        // D s_654_32: cast reint s_654_31 -> u8
        let s_654_32: bool = ((s_654_31.value()) != 0);
        // C s_654_33: const #4s : i
        let s_654_33: i128 = 4;
        // C s_654_34: const #1s : i
        let s_654_34: i128 = 1;
        // D s_654_35: read-var u#31122:u32
        let s_654_35: u32 = fn_state.u_31122;
        // D s_654_36: cast zx s_654_35 -> bv
        let s_654_36: Bits = Bits::new(s_654_35 as u128, 32u16);
        // D s_654_37: bit-extract s_654_36 s_654_33 s_654_34
        let s_654_37: Bits = (Bits::new(
            ((s_654_36) >> (s_654_33)).value(),
            u16::try_from(s_654_34).unwrap(),
        ));
        // D s_654_38: cast reint s_654_37 -> u8
        let s_654_38: bool = ((s_654_37.value()) != 0);
        // C s_654_39: const #0s : i
        let s_654_39: i128 = 0;
        // C s_654_40: const #4s : i
        let s_654_40: i128 = 4;
        // D s_654_41: read-var u#31122:u32
        let s_654_41: u32 = fn_state.u_31122;
        // D s_654_42: cast zx s_654_41 -> bv
        let s_654_42: Bits = Bits::new(s_654_41 as u128, 32u16);
        // D s_654_43: bit-extract s_654_42 s_654_39 s_654_40
        let s_654_43: Bits = (Bits::new(
            ((s_654_42) >> (s_654_39)).value(),
            u16::try_from(s_654_40).unwrap(),
        ));
        // D s_654_44: cast reint s_654_43 -> u8
        let s_654_44: u8 = (s_654_43.value() as u8);
        // D s_654_45: call decode_aarch32_instrs_VLD4_a_A1enc_A_txt(s_654_8, s_654_14, s_654_20, s_654_26, s_654_32, s_654_38, s_654_44)
        let s_654_45: () = decode_aarch32_instrs_VLD4_a_A1enc_A_txt(
            state,
            tracer,
            s_654_8,
            s_654_14,
            s_654_20,
            s_654_26,
            s_654_32,
            s_654_38,
            s_654_44,
        );
        // N s_654_46: return
        return;
    }
    fn block_655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_655_0: read-var merge#var.1:struct
        let s_655_0: u32 = fn_state.merge_var._1;
        // D s_655_1: write-var u#31131 <= s_655_0
        fn_state.u_31131 = s_655_0;
        // C s_655_2: const #23s : i
        let s_655_2: i128 = 23;
        // D s_655_3: read-var u#31131:u32
        let s_655_3: u32 = fn_state.u_31131;
        // D s_655_4: cast zx s_655_3 -> bv
        let s_655_4: Bits = Bits::new(s_655_3 as u128, 32u16);
        // C s_655_5: const #1s : i64
        let s_655_5: i64 = 1;
        // C s_655_6: cast zx s_655_5 -> i
        let s_655_6: i128 = (i128::try_from(s_655_5).unwrap());
        // C s_655_7: const #8s : i
        let s_655_7: i128 = 8;
        // C s_655_8: add s_655_7 s_655_6
        let s_655_8: i128 = (s_655_7 + s_655_6);
        // D s_655_9: bit-extract s_655_4 s_655_2 s_655_8
        let s_655_9: Bits = (Bits::new(
            ((s_655_4) >> (s_655_2)).value(),
            u16::try_from(s_655_8).unwrap(),
        ));
        // D s_655_10: cast reint s_655_9 -> u9
        let s_655_10: u16 = (s_655_9.value() as u16);
        // D s_655_11: cast zx s_655_10 -> bv
        let s_655_11: Bits = Bits::new(s_655_10 as u128, 9u16);
        // C s_655_12: const #488u : u9
        let s_655_12: u16 = 488;
        // C s_655_13: cast zx s_655_12 -> bv
        let s_655_13: Bits = Bits::new(s_655_12 as u128, 9u16);
        // D s_655_14: cmp-eq s_655_11 s_655_13
        let s_655_14: bool = ((s_655_11) == (s_655_13));
        // N s_655_15: branch s_655_14 b2705 b656
        if s_655_14 {
            return block_2705(state, tracer, fn_state);
        } else {
            return block_656(state, tracer, fn_state);
        };
    }
    fn block_656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_656_0: const #0u : u8
        let s_656_0: bool = false;
        // D s_656_1: write-var gs#399681 <= s_656_0
        fn_state.gs_399681 = s_656_0;
        // N s_656_2: jump b657
        return block_657(state, tracer, fn_state);
    }
    fn block_657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_657_0: read-var gs#399681:u8
        let s_657_0: bool = fn_state.gs_399681;
        // N s_657_1: branch s_657_0 b2704 b658
        if s_657_0 {
            return block_2704(state, tracer, fn_state);
        } else {
            return block_658(state, tracer, fn_state);
        };
    }
    fn block_658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_658_0: const #0u : u8
        let s_658_0: bool = false;
        // D s_658_1: write-var gs#399683 <= s_658_0
        fn_state.gs_399683 = s_658_0;
        // N s_658_2: jump b659
        return block_659(state, tracer, fn_state);
    }
    fn block_659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_659_0: read-var gs#399683:u8
        let s_659_0: bool = fn_state.gs_399683;
        // D s_659_1: not s_659_0
        let s_659_1: bool = !s_659_0;
        // N s_659_2: branch s_659_1 b661 b660
        if s_659_1 {
            return block_661(state, tracer, fn_state);
        } else {
            return block_660(state, tracer, fn_state);
        };
    }
    fn block_660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_660_0: const #3496s : i
        let s_660_0: i128 = 3496;
        // C s_660_1: const #14696u : u32
        let s_660_1: u32 = 14696;
        // N s_660_2: write-reg s_660_1 <= s_660_0
        let s_660_2: () = {
            state.write_register::<i128>(s_660_1 as isize, s_660_0);
            tracer.write_register(s_660_1 as isize, s_660_0);
        };
        // C s_660_3: const #22s : i
        let s_660_3: i128 = 22;
        // C s_660_4: const #1s : i
        let s_660_4: i128 = 1;
        // D s_660_5: read-var u#31131:u32
        let s_660_5: u32 = fn_state.u_31131;
        // D s_660_6: cast zx s_660_5 -> bv
        let s_660_6: Bits = Bits::new(s_660_5 as u128, 32u16);
        // D s_660_7: bit-extract s_660_6 s_660_3 s_660_4
        let s_660_7: Bits = (Bits::new(
            ((s_660_6) >> (s_660_3)).value(),
            u16::try_from(s_660_4).unwrap(),
        ));
        // D s_660_8: cast reint s_660_7 -> u8
        let s_660_8: bool = ((s_660_7.value()) != 0);
        // C s_660_9: const #16s : i
        let s_660_9: i128 = 16;
        // C s_660_10: const #4s : i
        let s_660_10: i128 = 4;
        // D s_660_11: read-var u#31131:u32
        let s_660_11: u32 = fn_state.u_31131;
        // D s_660_12: cast zx s_660_11 -> bv
        let s_660_12: Bits = Bits::new(s_660_11 as u128, 32u16);
        // D s_660_13: bit-extract s_660_12 s_660_9 s_660_10
        let s_660_13: Bits = (Bits::new(
            ((s_660_12) >> (s_660_9)).value(),
            u16::try_from(s_660_10).unwrap(),
        ));
        // D s_660_14: cast reint s_660_13 -> u8
        let s_660_14: u8 = (s_660_13.value() as u8);
        // C s_660_15: const #12s : i
        let s_660_15: i128 = 12;
        // C s_660_16: const #4s : i
        let s_660_16: i128 = 4;
        // D s_660_17: read-var u#31131:u32
        let s_660_17: u32 = fn_state.u_31131;
        // D s_660_18: cast zx s_660_17 -> bv
        let s_660_18: Bits = Bits::new(s_660_17 as u128, 32u16);
        // D s_660_19: bit-extract s_660_18 s_660_15 s_660_16
        let s_660_19: Bits = (Bits::new(
            ((s_660_18) >> (s_660_15)).value(),
            u16::try_from(s_660_16).unwrap(),
        ));
        // D s_660_20: cast reint s_660_19 -> u8
        let s_660_20: u8 = (s_660_19.value() as u8);
        // C s_660_21: const #8s : i
        let s_660_21: i128 = 8;
        // C s_660_22: const #4s : i
        let s_660_22: i128 = 4;
        // D s_660_23: read-var u#31131:u32
        let s_660_23: u32 = fn_state.u_31131;
        // D s_660_24: cast zx s_660_23 -> bv
        let s_660_24: Bits = Bits::new(s_660_23 as u128, 32u16);
        // D s_660_25: bit-extract s_660_24 s_660_21 s_660_22
        let s_660_25: Bits = (Bits::new(
            ((s_660_24) >> (s_660_21)).value(),
            u16::try_from(s_660_22).unwrap(),
        ));
        // D s_660_26: cast reint s_660_25 -> u8
        let s_660_26: u8 = (s_660_25.value() as u8);
        // C s_660_27: const #6s : i
        let s_660_27: i128 = 6;
        // C s_660_28: const #2s : i
        let s_660_28: i128 = 2;
        // D s_660_29: read-var u#31131:u32
        let s_660_29: u32 = fn_state.u_31131;
        // D s_660_30: cast zx s_660_29 -> bv
        let s_660_30: Bits = Bits::new(s_660_29 as u128, 32u16);
        // D s_660_31: bit-extract s_660_30 s_660_27 s_660_28
        let s_660_31: Bits = (Bits::new(
            ((s_660_30) >> (s_660_27)).value(),
            u16::try_from(s_660_28).unwrap(),
        ));
        // D s_660_32: cast reint s_660_31 -> u8
        let s_660_32: u8 = (s_660_31.value() as u8);
        // C s_660_33: const #4s : i
        let s_660_33: i128 = 4;
        // C s_660_34: const #2s : i
        let s_660_34: i128 = 2;
        // D s_660_35: read-var u#31131:u32
        let s_660_35: u32 = fn_state.u_31131;
        // D s_660_36: cast zx s_660_35 -> bv
        let s_660_36: Bits = Bits::new(s_660_35 as u128, 32u16);
        // D s_660_37: bit-extract s_660_36 s_660_33 s_660_34
        let s_660_37: Bits = (Bits::new(
            ((s_660_36) >> (s_660_33)).value(),
            u16::try_from(s_660_34).unwrap(),
        ));
        // D s_660_38: cast reint s_660_37 -> u8
        let s_660_38: u8 = (s_660_37.value() as u8);
        // C s_660_39: const #0s : i
        let s_660_39: i128 = 0;
        // C s_660_40: const #4s : i
        let s_660_40: i128 = 4;
        // D s_660_41: read-var u#31131:u32
        let s_660_41: u32 = fn_state.u_31131;
        // D s_660_42: cast zx s_660_41 -> bv
        let s_660_42: Bits = Bits::new(s_660_41 as u128, 32u16);
        // D s_660_43: bit-extract s_660_42 s_660_39 s_660_40
        let s_660_43: Bits = (Bits::new(
            ((s_660_42) >> (s_660_39)).value(),
            u16::try_from(s_660_40).unwrap(),
        ));
        // D s_660_44: cast reint s_660_43 -> u8
        let s_660_44: u8 = (s_660_43.value() as u8);
        // D s_660_45: call decode_aarch32_instrs_VLD4_m_A1enc_A_txt(s_660_8, s_660_14, s_660_20, s_660_26, s_660_32, s_660_38, s_660_44)
        let s_660_45: () = decode_aarch32_instrs_VLD4_m_A1enc_A_txt(
            state,
            tracer,
            s_660_8,
            s_660_14,
            s_660_20,
            s_660_26,
            s_660_32,
            s_660_38,
            s_660_44,
        );
        // N s_660_46: return
        return;
    }
    fn block_661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_661_0: read-var merge#var.1:struct
        let s_661_0: u32 = fn_state.merge_var._1;
        // D s_661_1: write-var u#31140 <= s_661_0
        fn_state.u_31140 = s_661_0;
        // C s_661_2: const #23s : i
        let s_661_2: i128 = 23;
        // D s_661_3: read-var u#31140:u32
        let s_661_3: u32 = fn_state.u_31140;
        // D s_661_4: cast zx s_661_3 -> bv
        let s_661_4: Bits = Bits::new(s_661_3 as u128, 32u16);
        // C s_661_5: const #1s : i64
        let s_661_5: i64 = 1;
        // C s_661_6: cast zx s_661_5 -> i
        let s_661_6: i128 = (i128::try_from(s_661_5).unwrap());
        // C s_661_7: const #8s : i
        let s_661_7: i128 = 8;
        // C s_661_8: add s_661_7 s_661_6
        let s_661_8: i128 = (s_661_7 + s_661_6);
        // D s_661_9: bit-extract s_661_4 s_661_2 s_661_8
        let s_661_9: Bits = (Bits::new(
            ((s_661_4) >> (s_661_2)).value(),
            u16::try_from(s_661_8).unwrap(),
        ));
        // D s_661_10: cast reint s_661_9 -> u9
        let s_661_10: u16 = (s_661_9.value() as u16);
        // D s_661_11: cast zx s_661_10 -> bv
        let s_661_11: Bits = Bits::new(s_661_10 as u128, 9u16);
        // C s_661_12: const #484u : u9
        let s_661_12: u16 = 484;
        // C s_661_13: cast zx s_661_12 -> bv
        let s_661_13: Bits = Bits::new(s_661_12 as u128, 9u16);
        // D s_661_14: cmp-eq s_661_11 s_661_13
        let s_661_14: bool = ((s_661_11) == (s_661_13));
        // N s_661_15: branch s_661_14 b2700 b662
        if s_661_14 {
            return block_2700(state, tracer, fn_state);
        } else {
            return block_662(state, tracer, fn_state);
        };
    }
    fn block_662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_662_0: const #0u : u8
        let s_662_0: bool = false;
        // D s_662_1: write-var gs#399708 <= s_662_0
        fn_state.gs_399708 = s_662_0;
        // N s_662_2: jump b663
        return block_663(state, tracer, fn_state);
    }
    fn block_663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_663_0: read-var gs#399708:u8
        let s_663_0: bool = fn_state.gs_399708;
        // N s_663_1: branch s_663_0 b2699 b664
        if s_663_0 {
            return block_2699(state, tracer, fn_state);
        } else {
            return block_664(state, tracer, fn_state);
        };
    }
    fn block_664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_664_0: const #0u : u8
        let s_664_0: bool = false;
        // D s_664_1: write-var gs#399710 <= s_664_0
        fn_state.gs_399710 = s_664_0;
        // N s_664_2: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_665_0: read-var gs#399710:u8
        let s_665_0: bool = fn_state.gs_399710;
        // D s_665_1: not s_665_0
        let s_665_1: bool = !s_665_0;
        // N s_665_2: branch s_665_1 b667 b666
        if s_665_1 {
            return block_667(state, tracer, fn_state);
        } else {
            return block_666(state, tracer, fn_state);
        };
    }
    fn block_666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_666_0: const #3504s : i
        let s_666_0: i128 = 3504;
        // C s_666_1: const #14696u : u32
        let s_666_1: u32 = 14696;
        // N s_666_2: write-reg s_666_1 <= s_666_0
        let s_666_2: () = {
            state.write_register::<i128>(s_666_1 as isize, s_666_0);
            tracer.write_register(s_666_1 as isize, s_666_0);
        };
        // C s_666_3: const #22s : i
        let s_666_3: i128 = 22;
        // C s_666_4: const #1s : i
        let s_666_4: i128 = 1;
        // D s_666_5: read-var u#31140:u32
        let s_666_5: u32 = fn_state.u_31140;
        // D s_666_6: cast zx s_666_5 -> bv
        let s_666_6: Bits = Bits::new(s_666_5 as u128, 32u16);
        // D s_666_7: bit-extract s_666_6 s_666_3 s_666_4
        let s_666_7: Bits = (Bits::new(
            ((s_666_6) >> (s_666_3)).value(),
            u16::try_from(s_666_4).unwrap(),
        ));
        // D s_666_8: cast reint s_666_7 -> u8
        let s_666_8: bool = ((s_666_7.value()) != 0);
        // C s_666_9: const #21s : i
        let s_666_9: i128 = 21;
        // C s_666_10: const #1s : i
        let s_666_10: i128 = 1;
        // D s_666_11: read-var u#31140:u32
        let s_666_11: u32 = fn_state.u_31140;
        // D s_666_12: cast zx s_666_11 -> bv
        let s_666_12: Bits = Bits::new(s_666_11 as u128, 32u16);
        // D s_666_13: bit-extract s_666_12 s_666_9 s_666_10
        let s_666_13: Bits = (Bits::new(
            ((s_666_12) >> (s_666_9)).value(),
            u16::try_from(s_666_10).unwrap(),
        ));
        // D s_666_14: cast reint s_666_13 -> u8
        let s_666_14: bool = ((s_666_13.value()) != 0);
        // C s_666_15: const #20s : i
        let s_666_15: i128 = 20;
        // C s_666_16: const #1s : i
        let s_666_16: i128 = 1;
        // D s_666_17: read-var u#31140:u32
        let s_666_17: u32 = fn_state.u_31140;
        // D s_666_18: cast zx s_666_17 -> bv
        let s_666_18: Bits = Bits::new(s_666_17 as u128, 32u16);
        // D s_666_19: bit-extract s_666_18 s_666_15 s_666_16
        let s_666_19: Bits = (Bits::new(
            ((s_666_18) >> (s_666_15)).value(),
            u16::try_from(s_666_16).unwrap(),
        ));
        // D s_666_20: cast reint s_666_19 -> u8
        let s_666_20: bool = ((s_666_19.value()) != 0);
        // C s_666_21: const #16s : i
        let s_666_21: i128 = 16;
        // C s_666_22: const #4s : i
        let s_666_22: i128 = 4;
        // D s_666_23: read-var u#31140:u32
        let s_666_23: u32 = fn_state.u_31140;
        // D s_666_24: cast zx s_666_23 -> bv
        let s_666_24: Bits = Bits::new(s_666_23 as u128, 32u16);
        // D s_666_25: bit-extract s_666_24 s_666_21 s_666_22
        let s_666_25: Bits = (Bits::new(
            ((s_666_24) >> (s_666_21)).value(),
            u16::try_from(s_666_22).unwrap(),
        ));
        // D s_666_26: cast reint s_666_25 -> u8
        let s_666_26: u8 = (s_666_25.value() as u8);
        // C s_666_27: const #12s : i
        let s_666_27: i128 = 12;
        // C s_666_28: const #4s : i
        let s_666_28: i128 = 4;
        // D s_666_29: read-var u#31140:u32
        let s_666_29: u32 = fn_state.u_31140;
        // D s_666_30: cast zx s_666_29 -> bv
        let s_666_30: Bits = Bits::new(s_666_29 as u128, 32u16);
        // D s_666_31: bit-extract s_666_30 s_666_27 s_666_28
        let s_666_31: Bits = (Bits::new(
            ((s_666_30) >> (s_666_27)).value(),
            u16::try_from(s_666_28).unwrap(),
        ));
        // D s_666_32: cast reint s_666_31 -> u8
        let s_666_32: u8 = (s_666_31.value() as u8);
        // C s_666_33: const #7s : i
        let s_666_33: i128 = 7;
        // C s_666_34: const #1s : i
        let s_666_34: i128 = 1;
        // D s_666_35: read-var u#31140:u32
        let s_666_35: u32 = fn_state.u_31140;
        // D s_666_36: cast zx s_666_35 -> bv
        let s_666_36: Bits = Bits::new(s_666_35 as u128, 32u16);
        // D s_666_37: bit-extract s_666_36 s_666_33 s_666_34
        let s_666_37: Bits = (Bits::new(
            ((s_666_36) >> (s_666_33)).value(),
            u16::try_from(s_666_34).unwrap(),
        ));
        // D s_666_38: cast reint s_666_37 -> u8
        let s_666_38: bool = ((s_666_37.value()) != 0);
        // C s_666_39: const #6s : i
        let s_666_39: i128 = 6;
        // C s_666_40: const #1s : i
        let s_666_40: i128 = 1;
        // D s_666_41: read-var u#31140:u32
        let s_666_41: u32 = fn_state.u_31140;
        // D s_666_42: cast zx s_666_41 -> bv
        let s_666_42: Bits = Bits::new(s_666_41 as u128, 32u16);
        // D s_666_43: bit-extract s_666_42 s_666_39 s_666_40
        let s_666_43: Bits = (Bits::new(
            ((s_666_42) >> (s_666_39)).value(),
            u16::try_from(s_666_40).unwrap(),
        ));
        // D s_666_44: cast reint s_666_43 -> u8
        let s_666_44: bool = ((s_666_43.value()) != 0);
        // C s_666_45: const #5s : i
        let s_666_45: i128 = 5;
        // C s_666_46: const #1s : i
        let s_666_46: i128 = 1;
        // D s_666_47: read-var u#31140:u32
        let s_666_47: u32 = fn_state.u_31140;
        // D s_666_48: cast zx s_666_47 -> bv
        let s_666_48: Bits = Bits::new(s_666_47 as u128, 32u16);
        // D s_666_49: bit-extract s_666_48 s_666_45 s_666_46
        let s_666_49: Bits = (Bits::new(
            ((s_666_48) >> (s_666_45)).value(),
            u16::try_from(s_666_46).unwrap(),
        ));
        // D s_666_50: cast reint s_666_49 -> u8
        let s_666_50: bool = ((s_666_49.value()) != 0);
        // C s_666_51: const #0s : i
        let s_666_51: i128 = 0;
        // C s_666_52: const #4s : i
        let s_666_52: i128 = 4;
        // D s_666_53: read-var u#31140:u32
        let s_666_53: u32 = fn_state.u_31140;
        // D s_666_54: cast zx s_666_53 -> bv
        let s_666_54: Bits = Bits::new(s_666_53 as u128, 32u16);
        // D s_666_55: bit-extract s_666_54 s_666_51 s_666_52
        let s_666_55: Bits = (Bits::new(
            ((s_666_54) >> (s_666_51)).value(),
            u16::try_from(s_666_52).unwrap(),
        ));
        // D s_666_56: cast reint s_666_55 -> u8
        let s_666_56: u8 = (s_666_55.value() as u8);
        // D s_666_57: call decode_aarch32_instrs_VMAX_f_A1enc_A_txt(s_666_8, s_666_14, s_666_20, s_666_26, s_666_32, s_666_38, s_666_44, s_666_50, s_666_56)
        let s_666_57: () = decode_aarch32_instrs_VMAX_f_A1enc_A_txt(
            state,
            tracer,
            s_666_8,
            s_666_14,
            s_666_20,
            s_666_26,
            s_666_32,
            s_666_38,
            s_666_44,
            s_666_50,
            s_666_56,
        );
        // N s_666_58: return
        return;
    }
    fn block_667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_667_0: read-var merge#var.1:struct
        let s_667_0: u32 = fn_state.merge_var._1;
        // D s_667_1: write-var u#31151 <= s_667_0
        fn_state.u_31151 = s_667_0;
        // C s_667_2: const #25s : i
        let s_667_2: i128 = 25;
        // D s_667_3: read-var u#31151:u32
        let s_667_3: u32 = fn_state.u_31151;
        // D s_667_4: cast zx s_667_3 -> bv
        let s_667_4: Bits = Bits::new(s_667_3 as u128, 32u16);
        // C s_667_5: const #1s : i64
        let s_667_5: i64 = 1;
        // C s_667_6: cast zx s_667_5 -> i
        let s_667_6: i128 = (i128::try_from(s_667_5).unwrap());
        // C s_667_7: const #6s : i
        let s_667_7: i128 = 6;
        // C s_667_8: add s_667_7 s_667_6
        let s_667_8: i128 = (s_667_7 + s_667_6);
        // D s_667_9: bit-extract s_667_4 s_667_2 s_667_8
        let s_667_9: Bits = (Bits::new(
            ((s_667_4) >> (s_667_2)).value(),
            u16::try_from(s_667_8).unwrap(),
        ));
        // D s_667_10: cast reint s_667_9 -> u8
        let s_667_10: u8 = (s_667_9.value() as u8);
        // D s_667_11: cast zx s_667_10 -> bv
        let s_667_11: Bits = Bits::new(s_667_10 as u128, 7u16);
        // C s_667_12: const #121u : u8
        let s_667_12: u8 = 121;
        // C s_667_13: cast zx s_667_12 -> bv
        let s_667_13: Bits = Bits::new(s_667_12 as u128, 7u16);
        // D s_667_14: cmp-eq s_667_11 s_667_13
        let s_667_14: bool = ((s_667_11) == (s_667_13));
        // N s_667_15: branch s_667_14 b2695 b668
        if s_667_14 {
            return block_2695(state, tracer, fn_state);
        } else {
            return block_668(state, tracer, fn_state);
        };
    }
    fn block_668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_668_0: const #0u : u8
        let s_668_0: bool = false;
        // D s_668_1: write-var gs#399739 <= s_668_0
        fn_state.gs_399739 = s_668_0;
        // N s_668_2: jump b669
        return block_669(state, tracer, fn_state);
    }
    fn block_669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_669_0: read-var gs#399739:u8
        let s_669_0: bool = fn_state.gs_399739;
        // N s_669_1: branch s_669_0 b2694 b670
        if s_669_0 {
            return block_2694(state, tracer, fn_state);
        } else {
            return block_670(state, tracer, fn_state);
        };
    }
    fn block_670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_670_0: const #0u : u8
        let s_670_0: bool = false;
        // D s_670_1: write-var gs#399741 <= s_670_0
        fn_state.gs_399741 = s_670_0;
        // N s_670_2: jump b671
        return block_671(state, tracer, fn_state);
    }
    fn block_671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_671_0: read-var gs#399741:u8
        let s_671_0: bool = fn_state.gs_399741;
        // D s_671_1: not s_671_0
        let s_671_1: bool = !s_671_0;
        // N s_671_2: branch s_671_1 b673 b672
        if s_671_1 {
            return block_673(state, tracer, fn_state);
        } else {
            return block_672(state, tracer, fn_state);
        };
    }
    fn block_672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_672_0: const #3506s : i
        let s_672_0: i128 = 3506;
        // C s_672_1: const #14696u : u32
        let s_672_1: u32 = 14696;
        // N s_672_2: write-reg s_672_1 <= s_672_0
        let s_672_2: () = {
            state.write_register::<i128>(s_672_1 as isize, s_672_0);
            tracer.write_register(s_672_1 as isize, s_672_0);
        };
        // C s_672_3: const #24s : i
        let s_672_3: i128 = 24;
        // C s_672_4: const #1s : i
        let s_672_4: i128 = 1;
        // D s_672_5: read-var u#31151:u32
        let s_672_5: u32 = fn_state.u_31151;
        // D s_672_6: cast zx s_672_5 -> bv
        let s_672_6: Bits = Bits::new(s_672_5 as u128, 32u16);
        // D s_672_7: bit-extract s_672_6 s_672_3 s_672_4
        let s_672_7: Bits = (Bits::new(
            ((s_672_6) >> (s_672_3)).value(),
            u16::try_from(s_672_4).unwrap(),
        ));
        // D s_672_8: cast reint s_672_7 -> u8
        let s_672_8: bool = ((s_672_7.value()) != 0);
        // C s_672_9: const #22s : i
        let s_672_9: i128 = 22;
        // C s_672_10: const #1s : i
        let s_672_10: i128 = 1;
        // D s_672_11: read-var u#31151:u32
        let s_672_11: u32 = fn_state.u_31151;
        // D s_672_12: cast zx s_672_11 -> bv
        let s_672_12: Bits = Bits::new(s_672_11 as u128, 32u16);
        // D s_672_13: bit-extract s_672_12 s_672_9 s_672_10
        let s_672_13: Bits = (Bits::new(
            ((s_672_12) >> (s_672_9)).value(),
            u16::try_from(s_672_10).unwrap(),
        ));
        // D s_672_14: cast reint s_672_13 -> u8
        let s_672_14: bool = ((s_672_13.value()) != 0);
        // C s_672_15: const #20s : i
        let s_672_15: i128 = 20;
        // C s_672_16: const #2s : i
        let s_672_16: i128 = 2;
        // D s_672_17: read-var u#31151:u32
        let s_672_17: u32 = fn_state.u_31151;
        // D s_672_18: cast zx s_672_17 -> bv
        let s_672_18: Bits = Bits::new(s_672_17 as u128, 32u16);
        // D s_672_19: bit-extract s_672_18 s_672_15 s_672_16
        let s_672_19: Bits = (Bits::new(
            ((s_672_18) >> (s_672_15)).value(),
            u16::try_from(s_672_16).unwrap(),
        ));
        // D s_672_20: cast reint s_672_19 -> u8
        let s_672_20: u8 = (s_672_19.value() as u8);
        // C s_672_21: const #16s : i
        let s_672_21: i128 = 16;
        // C s_672_22: const #4s : i
        let s_672_22: i128 = 4;
        // D s_672_23: read-var u#31151:u32
        let s_672_23: u32 = fn_state.u_31151;
        // D s_672_24: cast zx s_672_23 -> bv
        let s_672_24: Bits = Bits::new(s_672_23 as u128, 32u16);
        // D s_672_25: bit-extract s_672_24 s_672_21 s_672_22
        let s_672_25: Bits = (Bits::new(
            ((s_672_24) >> (s_672_21)).value(),
            u16::try_from(s_672_22).unwrap(),
        ));
        // D s_672_26: cast reint s_672_25 -> u8
        let s_672_26: u8 = (s_672_25.value() as u8);
        // C s_672_27: const #12s : i
        let s_672_27: i128 = 12;
        // C s_672_28: const #4s : i
        let s_672_28: i128 = 4;
        // D s_672_29: read-var u#31151:u32
        let s_672_29: u32 = fn_state.u_31151;
        // D s_672_30: cast zx s_672_29 -> bv
        let s_672_30: Bits = Bits::new(s_672_29 as u128, 32u16);
        // D s_672_31: bit-extract s_672_30 s_672_27 s_672_28
        let s_672_31: Bits = (Bits::new(
            ((s_672_30) >> (s_672_27)).value(),
            u16::try_from(s_672_28).unwrap(),
        ));
        // D s_672_32: cast reint s_672_31 -> u8
        let s_672_32: u8 = (s_672_31.value() as u8);
        // C s_672_33: const #7s : i
        let s_672_33: i128 = 7;
        // C s_672_34: const #1s : i
        let s_672_34: i128 = 1;
        // D s_672_35: read-var u#31151:u32
        let s_672_35: u32 = fn_state.u_31151;
        // D s_672_36: cast zx s_672_35 -> bv
        let s_672_36: Bits = Bits::new(s_672_35 as u128, 32u16);
        // D s_672_37: bit-extract s_672_36 s_672_33 s_672_34
        let s_672_37: Bits = (Bits::new(
            ((s_672_36) >> (s_672_33)).value(),
            u16::try_from(s_672_34).unwrap(),
        ));
        // D s_672_38: cast reint s_672_37 -> u8
        let s_672_38: bool = ((s_672_37.value()) != 0);
        // C s_672_39: const #6s : i
        let s_672_39: i128 = 6;
        // C s_672_40: const #1s : i
        let s_672_40: i128 = 1;
        // D s_672_41: read-var u#31151:u32
        let s_672_41: u32 = fn_state.u_31151;
        // D s_672_42: cast zx s_672_41 -> bv
        let s_672_42: Bits = Bits::new(s_672_41 as u128, 32u16);
        // D s_672_43: bit-extract s_672_42 s_672_39 s_672_40
        let s_672_43: Bits = (Bits::new(
            ((s_672_42) >> (s_672_39)).value(),
            u16::try_from(s_672_40).unwrap(),
        ));
        // D s_672_44: cast reint s_672_43 -> u8
        let s_672_44: bool = ((s_672_43.value()) != 0);
        // C s_672_45: const #5s : i
        let s_672_45: i128 = 5;
        // C s_672_46: const #1s : i
        let s_672_46: i128 = 1;
        // D s_672_47: read-var u#31151:u32
        let s_672_47: u32 = fn_state.u_31151;
        // D s_672_48: cast zx s_672_47 -> bv
        let s_672_48: Bits = Bits::new(s_672_47 as u128, 32u16);
        // D s_672_49: bit-extract s_672_48 s_672_45 s_672_46
        let s_672_49: Bits = (Bits::new(
            ((s_672_48) >> (s_672_45)).value(),
            u16::try_from(s_672_46).unwrap(),
        ));
        // D s_672_50: cast reint s_672_49 -> u8
        let s_672_50: bool = ((s_672_49.value()) != 0);
        // C s_672_51: const #4s : i
        let s_672_51: i128 = 4;
        // C s_672_52: const #1s : i
        let s_672_52: i128 = 1;
        // D s_672_53: read-var u#31151:u32
        let s_672_53: u32 = fn_state.u_31151;
        // D s_672_54: cast zx s_672_53 -> bv
        let s_672_54: Bits = Bits::new(s_672_53 as u128, 32u16);
        // D s_672_55: bit-extract s_672_54 s_672_51 s_672_52
        let s_672_55: Bits = (Bits::new(
            ((s_672_54) >> (s_672_51)).value(),
            u16::try_from(s_672_52).unwrap(),
        ));
        // D s_672_56: cast reint s_672_55 -> u8
        let s_672_56: bool = ((s_672_55.value()) != 0);
        // C s_672_57: const #0s : i
        let s_672_57: i128 = 0;
        // C s_672_58: const #4s : i
        let s_672_58: i128 = 4;
        // D s_672_59: read-var u#31151:u32
        let s_672_59: u32 = fn_state.u_31151;
        // D s_672_60: cast zx s_672_59 -> bv
        let s_672_60: Bits = Bits::new(s_672_59 as u128, 32u16);
        // D s_672_61: bit-extract s_672_60 s_672_57 s_672_58
        let s_672_61: Bits = (Bits::new(
            ((s_672_60) >> (s_672_57)).value(),
            u16::try_from(s_672_58).unwrap(),
        ));
        // D s_672_62: cast reint s_672_61 -> u8
        let s_672_62: u8 = (s_672_61.value() as u8);
        // D s_672_63: call decode_aarch32_instrs_VMAX_i_A1enc_A_txt(s_672_8, s_672_14, s_672_20, s_672_26, s_672_32, s_672_38, s_672_44, s_672_50, s_672_56, s_672_62)
        let s_672_63: () = decode_aarch32_instrs_VMAX_i_A1enc_A_txt(
            state,
            tracer,
            s_672_8,
            s_672_14,
            s_672_20,
            s_672_26,
            s_672_32,
            s_672_38,
            s_672_44,
            s_672_50,
            s_672_56,
            s_672_62,
        );
        // N s_672_64: return
        return;
    }
    fn block_673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_673_0: read-var merge#var.1:struct
        let s_673_0: u32 = fn_state.merge_var._1;
        // D s_673_1: write-var u#31163 <= s_673_0
        fn_state.u_31163 = s_673_0;
        // C s_673_2: const #23s : i
        let s_673_2: i128 = 23;
        // D s_673_3: read-var u#31163:u32
        let s_673_3: u32 = fn_state.u_31163;
        // D s_673_4: cast zx s_673_3 -> bv
        let s_673_4: Bits = Bits::new(s_673_3 as u128, 32u16);
        // C s_673_5: const #1s : i64
        let s_673_5: i64 = 1;
        // C s_673_6: cast zx s_673_5 -> i
        let s_673_6: i128 = (i128::try_from(s_673_5).unwrap());
        // C s_673_7: const #8s : i
        let s_673_7: i128 = 8;
        // C s_673_8: add s_673_7 s_673_6
        let s_673_8: i128 = (s_673_7 + s_673_6);
        // D s_673_9: bit-extract s_673_4 s_673_2 s_673_8
        let s_673_9: Bits = (Bits::new(
            ((s_673_4) >> (s_673_2)).value(),
            u16::try_from(s_673_8).unwrap(),
        ));
        // D s_673_10: cast reint s_673_9 -> u9
        let s_673_10: u16 = (s_673_9.value() as u16);
        // D s_673_11: cast zx s_673_10 -> bv
        let s_673_11: Bits = Bits::new(s_673_10 as u128, 9u16);
        // C s_673_12: const #484u : u9
        let s_673_12: u16 = 484;
        // C s_673_13: cast zx s_673_12 -> bv
        let s_673_13: Bits = Bits::new(s_673_12 as u128, 9u16);
        // D s_673_14: cmp-eq s_673_11 s_673_13
        let s_673_14: bool = ((s_673_11) == (s_673_13));
        // N s_673_15: branch s_673_14 b2690 b674
        if s_673_14 {
            return block_2690(state, tracer, fn_state);
        } else {
            return block_674(state, tracer, fn_state);
        };
    }
    fn block_674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_674_0: const #0u : u8
        let s_674_0: bool = false;
        // D s_674_1: write-var gs#399772 <= s_674_0
        fn_state.gs_399772 = s_674_0;
        // N s_674_2: jump b675
        return block_675(state, tracer, fn_state);
    }
    fn block_675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_675_0: read-var gs#399772:u8
        let s_675_0: bool = fn_state.gs_399772;
        // N s_675_1: branch s_675_0 b2689 b676
        if s_675_0 {
            return block_2689(state, tracer, fn_state);
        } else {
            return block_676(state, tracer, fn_state);
        };
    }
    fn block_676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_676_0: const #0u : u8
        let s_676_0: bool = false;
        // D s_676_1: write-var gs#399774 <= s_676_0
        fn_state.gs_399774 = s_676_0;
        // N s_676_2: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_677_0: read-var gs#399774:u8
        let s_677_0: bool = fn_state.gs_399774;
        // D s_677_1: not s_677_0
        let s_677_1: bool = !s_677_0;
        // N s_677_2: branch s_677_1 b679 b678
        if s_677_1 {
            return block_679(state, tracer, fn_state);
        } else {
            return block_678(state, tracer, fn_state);
        };
    }
    fn block_678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_678_0: const #3508s : i
        let s_678_0: i128 = 3508;
        // C s_678_1: const #14696u : u32
        let s_678_1: u32 = 14696;
        // N s_678_2: write-reg s_678_1 <= s_678_0
        let s_678_2: () = {
            state.write_register::<i128>(s_678_1 as isize, s_678_0);
            tracer.write_register(s_678_1 as isize, s_678_0);
        };
        // C s_678_3: const #22s : i
        let s_678_3: i128 = 22;
        // C s_678_4: const #1s : i
        let s_678_4: i128 = 1;
        // D s_678_5: read-var u#31163:u32
        let s_678_5: u32 = fn_state.u_31163;
        // D s_678_6: cast zx s_678_5 -> bv
        let s_678_6: Bits = Bits::new(s_678_5 as u128, 32u16);
        // D s_678_7: bit-extract s_678_6 s_678_3 s_678_4
        let s_678_7: Bits = (Bits::new(
            ((s_678_6) >> (s_678_3)).value(),
            u16::try_from(s_678_4).unwrap(),
        ));
        // D s_678_8: cast reint s_678_7 -> u8
        let s_678_8: bool = ((s_678_7.value()) != 0);
        // C s_678_9: const #21s : i
        let s_678_9: i128 = 21;
        // C s_678_10: const #1s : i
        let s_678_10: i128 = 1;
        // D s_678_11: read-var u#31163:u32
        let s_678_11: u32 = fn_state.u_31163;
        // D s_678_12: cast zx s_678_11 -> bv
        let s_678_12: Bits = Bits::new(s_678_11 as u128, 32u16);
        // D s_678_13: bit-extract s_678_12 s_678_9 s_678_10
        let s_678_13: Bits = (Bits::new(
            ((s_678_12) >> (s_678_9)).value(),
            u16::try_from(s_678_10).unwrap(),
        ));
        // D s_678_14: cast reint s_678_13 -> u8
        let s_678_14: bool = ((s_678_13.value()) != 0);
        // C s_678_15: const #20s : i
        let s_678_15: i128 = 20;
        // C s_678_16: const #1s : i
        let s_678_16: i128 = 1;
        // D s_678_17: read-var u#31163:u32
        let s_678_17: u32 = fn_state.u_31163;
        // D s_678_18: cast zx s_678_17 -> bv
        let s_678_18: Bits = Bits::new(s_678_17 as u128, 32u16);
        // D s_678_19: bit-extract s_678_18 s_678_15 s_678_16
        let s_678_19: Bits = (Bits::new(
            ((s_678_18) >> (s_678_15)).value(),
            u16::try_from(s_678_16).unwrap(),
        ));
        // D s_678_20: cast reint s_678_19 -> u8
        let s_678_20: bool = ((s_678_19.value()) != 0);
        // C s_678_21: const #16s : i
        let s_678_21: i128 = 16;
        // C s_678_22: const #4s : i
        let s_678_22: i128 = 4;
        // D s_678_23: read-var u#31163:u32
        let s_678_23: u32 = fn_state.u_31163;
        // D s_678_24: cast zx s_678_23 -> bv
        let s_678_24: Bits = Bits::new(s_678_23 as u128, 32u16);
        // D s_678_25: bit-extract s_678_24 s_678_21 s_678_22
        let s_678_25: Bits = (Bits::new(
            ((s_678_24) >> (s_678_21)).value(),
            u16::try_from(s_678_22).unwrap(),
        ));
        // D s_678_26: cast reint s_678_25 -> u8
        let s_678_26: u8 = (s_678_25.value() as u8);
        // C s_678_27: const #12s : i
        let s_678_27: i128 = 12;
        // C s_678_28: const #4s : i
        let s_678_28: i128 = 4;
        // D s_678_29: read-var u#31163:u32
        let s_678_29: u32 = fn_state.u_31163;
        // D s_678_30: cast zx s_678_29 -> bv
        let s_678_30: Bits = Bits::new(s_678_29 as u128, 32u16);
        // D s_678_31: bit-extract s_678_30 s_678_27 s_678_28
        let s_678_31: Bits = (Bits::new(
            ((s_678_30) >> (s_678_27)).value(),
            u16::try_from(s_678_28).unwrap(),
        ));
        // D s_678_32: cast reint s_678_31 -> u8
        let s_678_32: u8 = (s_678_31.value() as u8);
        // C s_678_33: const #7s : i
        let s_678_33: i128 = 7;
        // C s_678_34: const #1s : i
        let s_678_34: i128 = 1;
        // D s_678_35: read-var u#31163:u32
        let s_678_35: u32 = fn_state.u_31163;
        // D s_678_36: cast zx s_678_35 -> bv
        let s_678_36: Bits = Bits::new(s_678_35 as u128, 32u16);
        // D s_678_37: bit-extract s_678_36 s_678_33 s_678_34
        let s_678_37: Bits = (Bits::new(
            ((s_678_36) >> (s_678_33)).value(),
            u16::try_from(s_678_34).unwrap(),
        ));
        // D s_678_38: cast reint s_678_37 -> u8
        let s_678_38: bool = ((s_678_37.value()) != 0);
        // C s_678_39: const #6s : i
        let s_678_39: i128 = 6;
        // C s_678_40: const #1s : i
        let s_678_40: i128 = 1;
        // D s_678_41: read-var u#31163:u32
        let s_678_41: u32 = fn_state.u_31163;
        // D s_678_42: cast zx s_678_41 -> bv
        let s_678_42: Bits = Bits::new(s_678_41 as u128, 32u16);
        // D s_678_43: bit-extract s_678_42 s_678_39 s_678_40
        let s_678_43: Bits = (Bits::new(
            ((s_678_42) >> (s_678_39)).value(),
            u16::try_from(s_678_40).unwrap(),
        ));
        // D s_678_44: cast reint s_678_43 -> u8
        let s_678_44: bool = ((s_678_43.value()) != 0);
        // C s_678_45: const #5s : i
        let s_678_45: i128 = 5;
        // C s_678_46: const #1s : i
        let s_678_46: i128 = 1;
        // D s_678_47: read-var u#31163:u32
        let s_678_47: u32 = fn_state.u_31163;
        // D s_678_48: cast zx s_678_47 -> bv
        let s_678_48: Bits = Bits::new(s_678_47 as u128, 32u16);
        // D s_678_49: bit-extract s_678_48 s_678_45 s_678_46
        let s_678_49: Bits = (Bits::new(
            ((s_678_48) >> (s_678_45)).value(),
            u16::try_from(s_678_46).unwrap(),
        ));
        // D s_678_50: cast reint s_678_49 -> u8
        let s_678_50: bool = ((s_678_49.value()) != 0);
        // C s_678_51: const #0s : i
        let s_678_51: i128 = 0;
        // C s_678_52: const #4s : i
        let s_678_52: i128 = 4;
        // D s_678_53: read-var u#31163:u32
        let s_678_53: u32 = fn_state.u_31163;
        // D s_678_54: cast zx s_678_53 -> bv
        let s_678_54: Bits = Bits::new(s_678_53 as u128, 32u16);
        // D s_678_55: bit-extract s_678_54 s_678_51 s_678_52
        let s_678_55: Bits = (Bits::new(
            ((s_678_54) >> (s_678_51)).value(),
            u16::try_from(s_678_52).unwrap(),
        ));
        // D s_678_56: cast reint s_678_55 -> u8
        let s_678_56: u8 = (s_678_55.value() as u8);
        // D s_678_57: call decode_aarch32_instrs_VMLA_f_A1enc_A_txt(s_678_8, s_678_14, s_678_20, s_678_26, s_678_32, s_678_38, s_678_44, s_678_50, s_678_56)
        let s_678_57: () = decode_aarch32_instrs_VMLA_f_A1enc_A_txt(
            state,
            tracer,
            s_678_8,
            s_678_14,
            s_678_20,
            s_678_26,
            s_678_32,
            s_678_38,
            s_678_44,
            s_678_50,
            s_678_56,
        );
        // N s_678_58: return
        return;
    }
    fn block_679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_679_0: read-var merge#var.1:struct
        let s_679_0: u32 = fn_state.merge_var._1;
        // D s_679_1: write-var u#31174 <= s_679_0
        fn_state.u_31174 = s_679_0;
        // C s_679_2: const #25s : i
        let s_679_2: i128 = 25;
        // D s_679_3: read-var u#31174:u32
        let s_679_3: u32 = fn_state.u_31174;
        // D s_679_4: cast zx s_679_3 -> bv
        let s_679_4: Bits = Bits::new(s_679_3 as u128, 32u16);
        // C s_679_5: const #1s : i64
        let s_679_5: i64 = 1;
        // C s_679_6: cast zx s_679_5 -> i
        let s_679_6: i128 = (i128::try_from(s_679_5).unwrap());
        // C s_679_7: const #6s : i
        let s_679_7: i128 = 6;
        // C s_679_8: add s_679_7 s_679_6
        let s_679_8: i128 = (s_679_7 + s_679_6);
        // D s_679_9: bit-extract s_679_4 s_679_2 s_679_8
        let s_679_9: Bits = (Bits::new(
            ((s_679_4) >> (s_679_2)).value(),
            u16::try_from(s_679_8).unwrap(),
        ));
        // D s_679_10: cast reint s_679_9 -> u8
        let s_679_10: u8 = (s_679_9.value() as u8);
        // D s_679_11: cast zx s_679_10 -> bv
        let s_679_11: Bits = Bits::new(s_679_10 as u128, 7u16);
        // C s_679_12: const #121u : u8
        let s_679_12: u8 = 121;
        // C s_679_13: cast zx s_679_12 -> bv
        let s_679_13: Bits = Bits::new(s_679_12 as u128, 7u16);
        // D s_679_14: cmp-eq s_679_11 s_679_13
        let s_679_14: bool = ((s_679_11) == (s_679_13));
        // N s_679_15: branch s_679_14 b2682 b680
        if s_679_14 {
            return block_2682(state, tracer, fn_state);
        } else {
            return block_680(state, tracer, fn_state);
        };
    }
    fn block_680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_680_0: const #0u : u8
        let s_680_0: bool = false;
        // D s_680_1: write-var gs#399806 <= s_680_0
        fn_state.gs_399806 = s_680_0;
        // N s_680_2: jump b681
        return block_681(state, tracer, fn_state);
    }
    fn block_681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_681_0: read-var gs#399806:u8
        let s_681_0: bool = fn_state.gs_399806;
        // N s_681_1: branch s_681_0 b2681 b682
        if s_681_0 {
            return block_2681(state, tracer, fn_state);
        } else {
            return block_682(state, tracer, fn_state);
        };
    }
    fn block_682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_682_0: const #0u : u8
        let s_682_0: bool = false;
        // D s_682_1: write-var gs#399808 <= s_682_0
        fn_state.gs_399808 = s_682_0;
        // N s_682_2: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_683_0: read-var gs#399808:u8
        let s_683_0: bool = fn_state.gs_399808;
        // D s_683_1: not s_683_0
        let s_683_1: bool = !s_683_0;
        // N s_683_2: branch s_683_1 b685 b684
        if s_683_1 {
            return block_685(state, tracer, fn_state);
        } else {
            return block_684(state, tracer, fn_state);
        };
    }
    fn block_684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_684_0: const #3512s : i
        let s_684_0: i128 = 3512;
        // C s_684_1: const #14696u : u32
        let s_684_1: u32 = 14696;
        // N s_684_2: write-reg s_684_1 <= s_684_0
        let s_684_2: () = {
            state.write_register::<i128>(s_684_1 as isize, s_684_0);
            tracer.write_register(s_684_1 as isize, s_684_0);
        };
        // C s_684_3: const #24s : i
        let s_684_3: i128 = 24;
        // C s_684_4: const #1s : i
        let s_684_4: i128 = 1;
        // D s_684_5: read-var u#31174:u32
        let s_684_5: u32 = fn_state.u_31174;
        // D s_684_6: cast zx s_684_5 -> bv
        let s_684_6: Bits = Bits::new(s_684_5 as u128, 32u16);
        // D s_684_7: bit-extract s_684_6 s_684_3 s_684_4
        let s_684_7: Bits = (Bits::new(
            ((s_684_6) >> (s_684_3)).value(),
            u16::try_from(s_684_4).unwrap(),
        ));
        // D s_684_8: cast reint s_684_7 -> u8
        let s_684_8: bool = ((s_684_7.value()) != 0);
        // C s_684_9: const #22s : i
        let s_684_9: i128 = 22;
        // C s_684_10: const #1s : i
        let s_684_10: i128 = 1;
        // D s_684_11: read-var u#31174:u32
        let s_684_11: u32 = fn_state.u_31174;
        // D s_684_12: cast zx s_684_11 -> bv
        let s_684_12: Bits = Bits::new(s_684_11 as u128, 32u16);
        // D s_684_13: bit-extract s_684_12 s_684_9 s_684_10
        let s_684_13: Bits = (Bits::new(
            ((s_684_12) >> (s_684_9)).value(),
            u16::try_from(s_684_10).unwrap(),
        ));
        // D s_684_14: cast reint s_684_13 -> u8
        let s_684_14: bool = ((s_684_13.value()) != 0);
        // C s_684_15: const #20s : i
        let s_684_15: i128 = 20;
        // C s_684_16: const #2s : i
        let s_684_16: i128 = 2;
        // D s_684_17: read-var u#31174:u32
        let s_684_17: u32 = fn_state.u_31174;
        // D s_684_18: cast zx s_684_17 -> bv
        let s_684_18: Bits = Bits::new(s_684_17 as u128, 32u16);
        // D s_684_19: bit-extract s_684_18 s_684_15 s_684_16
        let s_684_19: Bits = (Bits::new(
            ((s_684_18) >> (s_684_15)).value(),
            u16::try_from(s_684_16).unwrap(),
        ));
        // D s_684_20: cast reint s_684_19 -> u8
        let s_684_20: u8 = (s_684_19.value() as u8);
        // C s_684_21: const #16s : i
        let s_684_21: i128 = 16;
        // C s_684_22: const #4s : i
        let s_684_22: i128 = 4;
        // D s_684_23: read-var u#31174:u32
        let s_684_23: u32 = fn_state.u_31174;
        // D s_684_24: cast zx s_684_23 -> bv
        let s_684_24: Bits = Bits::new(s_684_23 as u128, 32u16);
        // D s_684_25: bit-extract s_684_24 s_684_21 s_684_22
        let s_684_25: Bits = (Bits::new(
            ((s_684_24) >> (s_684_21)).value(),
            u16::try_from(s_684_22).unwrap(),
        ));
        // D s_684_26: cast reint s_684_25 -> u8
        let s_684_26: u8 = (s_684_25.value() as u8);
        // C s_684_27: const #12s : i
        let s_684_27: i128 = 12;
        // C s_684_28: const #4s : i
        let s_684_28: i128 = 4;
        // D s_684_29: read-var u#31174:u32
        let s_684_29: u32 = fn_state.u_31174;
        // D s_684_30: cast zx s_684_29 -> bv
        let s_684_30: Bits = Bits::new(s_684_29 as u128, 32u16);
        // D s_684_31: bit-extract s_684_30 s_684_27 s_684_28
        let s_684_31: Bits = (Bits::new(
            ((s_684_30) >> (s_684_27)).value(),
            u16::try_from(s_684_28).unwrap(),
        ));
        // D s_684_32: cast reint s_684_31 -> u8
        let s_684_32: u8 = (s_684_31.value() as u8);
        // C s_684_33: const #7s : i
        let s_684_33: i128 = 7;
        // C s_684_34: const #1s : i
        let s_684_34: i128 = 1;
        // D s_684_35: read-var u#31174:u32
        let s_684_35: u32 = fn_state.u_31174;
        // D s_684_36: cast zx s_684_35 -> bv
        let s_684_36: Bits = Bits::new(s_684_35 as u128, 32u16);
        // D s_684_37: bit-extract s_684_36 s_684_33 s_684_34
        let s_684_37: Bits = (Bits::new(
            ((s_684_36) >> (s_684_33)).value(),
            u16::try_from(s_684_34).unwrap(),
        ));
        // D s_684_38: cast reint s_684_37 -> u8
        let s_684_38: bool = ((s_684_37.value()) != 0);
        // C s_684_39: const #6s : i
        let s_684_39: i128 = 6;
        // C s_684_40: const #1s : i
        let s_684_40: i128 = 1;
        // D s_684_41: read-var u#31174:u32
        let s_684_41: u32 = fn_state.u_31174;
        // D s_684_42: cast zx s_684_41 -> bv
        let s_684_42: Bits = Bits::new(s_684_41 as u128, 32u16);
        // D s_684_43: bit-extract s_684_42 s_684_39 s_684_40
        let s_684_43: Bits = (Bits::new(
            ((s_684_42) >> (s_684_39)).value(),
            u16::try_from(s_684_40).unwrap(),
        ));
        // D s_684_44: cast reint s_684_43 -> u8
        let s_684_44: bool = ((s_684_43.value()) != 0);
        // C s_684_45: const #5s : i
        let s_684_45: i128 = 5;
        // C s_684_46: const #1s : i
        let s_684_46: i128 = 1;
        // D s_684_47: read-var u#31174:u32
        let s_684_47: u32 = fn_state.u_31174;
        // D s_684_48: cast zx s_684_47 -> bv
        let s_684_48: Bits = Bits::new(s_684_47 as u128, 32u16);
        // D s_684_49: bit-extract s_684_48 s_684_45 s_684_46
        let s_684_49: Bits = (Bits::new(
            ((s_684_48) >> (s_684_45)).value(),
            u16::try_from(s_684_46).unwrap(),
        ));
        // D s_684_50: cast reint s_684_49 -> u8
        let s_684_50: bool = ((s_684_49.value()) != 0);
        // C s_684_51: const #0s : i
        let s_684_51: i128 = 0;
        // C s_684_52: const #4s : i
        let s_684_52: i128 = 4;
        // D s_684_53: read-var u#31174:u32
        let s_684_53: u32 = fn_state.u_31174;
        // D s_684_54: cast zx s_684_53 -> bv
        let s_684_54: Bits = Bits::new(s_684_53 as u128, 32u16);
        // D s_684_55: bit-extract s_684_54 s_684_51 s_684_52
        let s_684_55: Bits = (Bits::new(
            ((s_684_54) >> (s_684_51)).value(),
            u16::try_from(s_684_52).unwrap(),
        ));
        // D s_684_56: cast reint s_684_55 -> u8
        let s_684_56: u8 = (s_684_55.value() as u8);
        // D s_684_57: call decode_aarch32_instrs_VMLA_i_A1enc_A_txt(s_684_8, s_684_14, s_684_20, s_684_26, s_684_32, s_684_38, s_684_44, s_684_50, s_684_56)
        let s_684_57: () = decode_aarch32_instrs_VMLA_i_A1enc_A_txt(
            state,
            tracer,
            s_684_8,
            s_684_14,
            s_684_20,
            s_684_26,
            s_684_32,
            s_684_38,
            s_684_44,
            s_684_50,
            s_684_56,
        );
        // N s_684_58: return
        return;
    }
    fn block_685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_685_0: read-var merge#var.1:struct
        let s_685_0: u32 = fn_state.merge_var._1;
        // D s_685_1: write-var u#31185 <= s_685_0
        fn_state.u_31185 = s_685_0;
        // C s_685_2: const #25s : i
        let s_685_2: i128 = 25;
        // D s_685_3: read-var u#31185:u32
        let s_685_3: u32 = fn_state.u_31185;
        // D s_685_4: cast zx s_685_3 -> bv
        let s_685_4: Bits = Bits::new(s_685_3 as u128, 32u16);
        // C s_685_5: const #1s : i64
        let s_685_5: i64 = 1;
        // C s_685_6: cast zx s_685_5 -> i
        let s_685_6: i128 = (i128::try_from(s_685_5).unwrap());
        // C s_685_7: const #6s : i
        let s_685_7: i128 = 6;
        // C s_685_8: add s_685_7 s_685_6
        let s_685_8: i128 = (s_685_7 + s_685_6);
        // D s_685_9: bit-extract s_685_4 s_685_2 s_685_8
        let s_685_9: Bits = (Bits::new(
            ((s_685_4) >> (s_685_2)).value(),
            u16::try_from(s_685_8).unwrap(),
        ));
        // D s_685_10: cast reint s_685_9 -> u8
        let s_685_10: u8 = (s_685_9.value() as u8);
        // D s_685_11: cast zx s_685_10 -> bv
        let s_685_11: Bits = Bits::new(s_685_10 as u128, 7u16);
        // C s_685_12: const #121u : u8
        let s_685_12: u8 = 121;
        // C s_685_13: cast zx s_685_12 -> bv
        let s_685_13: Bits = Bits::new(s_685_12 as u128, 7u16);
        // D s_685_14: cmp-eq s_685_11 s_685_13
        let s_685_14: bool = ((s_685_11) == (s_685_13));
        // N s_685_15: branch s_685_14 b2668 b686
        if s_685_14 {
            return block_2668(state, tracer, fn_state);
        } else {
            return block_686(state, tracer, fn_state);
        };
    }
    fn block_686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_686_0: const #0u : u8
        let s_686_0: bool = false;
        // D s_686_1: write-var gs#399846 <= s_686_0
        fn_state.gs_399846 = s_686_0;
        // N s_686_2: jump b687
        return block_687(state, tracer, fn_state);
    }
    fn block_687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_687_0: read-var gs#399846:u8
        let s_687_0: bool = fn_state.gs_399846;
        // N s_687_1: branch s_687_0 b2667 b688
        if s_687_0 {
            return block_2667(state, tracer, fn_state);
        } else {
            return block_688(state, tracer, fn_state);
        };
    }
    fn block_688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_688_0: const #0u : u8
        let s_688_0: bool = false;
        // D s_688_1: write-var gs#399848 <= s_688_0
        fn_state.gs_399848 = s_688_0;
        // N s_688_2: jump b689
        return block_689(state, tracer, fn_state);
    }
    fn block_689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_689_0: read-var gs#399848:u8
        let s_689_0: bool = fn_state.gs_399848;
        // D s_689_1: not s_689_0
        let s_689_1: bool = !s_689_0;
        // N s_689_2: branch s_689_1 b691 b690
        if s_689_1 {
            return block_691(state, tracer, fn_state);
        } else {
            return block_690(state, tracer, fn_state);
        };
    }
    fn block_690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_690_0: const #3513s : i
        let s_690_0: i128 = 3513;
        // C s_690_1: const #14696u : u32
        let s_690_1: u32 = 14696;
        // N s_690_2: write-reg s_690_1 <= s_690_0
        let s_690_2: () = {
            state.write_register::<i128>(s_690_1 as isize, s_690_0);
            tracer.write_register(s_690_1 as isize, s_690_0);
        };
        // C s_690_3: const #24s : i
        let s_690_3: i128 = 24;
        // C s_690_4: const #1s : i
        let s_690_4: i128 = 1;
        // D s_690_5: read-var u#31185:u32
        let s_690_5: u32 = fn_state.u_31185;
        // D s_690_6: cast zx s_690_5 -> bv
        let s_690_6: Bits = Bits::new(s_690_5 as u128, 32u16);
        // D s_690_7: bit-extract s_690_6 s_690_3 s_690_4
        let s_690_7: Bits = (Bits::new(
            ((s_690_6) >> (s_690_3)).value(),
            u16::try_from(s_690_4).unwrap(),
        ));
        // D s_690_8: cast reint s_690_7 -> u8
        let s_690_8: bool = ((s_690_7.value()) != 0);
        // C s_690_9: const #22s : i
        let s_690_9: i128 = 22;
        // C s_690_10: const #1s : i
        let s_690_10: i128 = 1;
        // D s_690_11: read-var u#31185:u32
        let s_690_11: u32 = fn_state.u_31185;
        // D s_690_12: cast zx s_690_11 -> bv
        let s_690_12: Bits = Bits::new(s_690_11 as u128, 32u16);
        // D s_690_13: bit-extract s_690_12 s_690_9 s_690_10
        let s_690_13: Bits = (Bits::new(
            ((s_690_12) >> (s_690_9)).value(),
            u16::try_from(s_690_10).unwrap(),
        ));
        // D s_690_14: cast reint s_690_13 -> u8
        let s_690_14: bool = ((s_690_13.value()) != 0);
        // C s_690_15: const #20s : i
        let s_690_15: i128 = 20;
        // C s_690_16: const #2s : i
        let s_690_16: i128 = 2;
        // D s_690_17: read-var u#31185:u32
        let s_690_17: u32 = fn_state.u_31185;
        // D s_690_18: cast zx s_690_17 -> bv
        let s_690_18: Bits = Bits::new(s_690_17 as u128, 32u16);
        // D s_690_19: bit-extract s_690_18 s_690_15 s_690_16
        let s_690_19: Bits = (Bits::new(
            ((s_690_18) >> (s_690_15)).value(),
            u16::try_from(s_690_16).unwrap(),
        ));
        // D s_690_20: cast reint s_690_19 -> u8
        let s_690_20: u8 = (s_690_19.value() as u8);
        // C s_690_21: const #16s : i
        let s_690_21: i128 = 16;
        // C s_690_22: const #4s : i
        let s_690_22: i128 = 4;
        // D s_690_23: read-var u#31185:u32
        let s_690_23: u32 = fn_state.u_31185;
        // D s_690_24: cast zx s_690_23 -> bv
        let s_690_24: Bits = Bits::new(s_690_23 as u128, 32u16);
        // D s_690_25: bit-extract s_690_24 s_690_21 s_690_22
        let s_690_25: Bits = (Bits::new(
            ((s_690_24) >> (s_690_21)).value(),
            u16::try_from(s_690_22).unwrap(),
        ));
        // D s_690_26: cast reint s_690_25 -> u8
        let s_690_26: u8 = (s_690_25.value() as u8);
        // C s_690_27: const #12s : i
        let s_690_27: i128 = 12;
        // C s_690_28: const #4s : i
        let s_690_28: i128 = 4;
        // D s_690_29: read-var u#31185:u32
        let s_690_29: u32 = fn_state.u_31185;
        // D s_690_30: cast zx s_690_29 -> bv
        let s_690_30: Bits = Bits::new(s_690_29 as u128, 32u16);
        // D s_690_31: bit-extract s_690_30 s_690_27 s_690_28
        let s_690_31: Bits = (Bits::new(
            ((s_690_30) >> (s_690_27)).value(),
            u16::try_from(s_690_28).unwrap(),
        ));
        // D s_690_32: cast reint s_690_31 -> u8
        let s_690_32: u8 = (s_690_31.value() as u8);
        // C s_690_33: const #9s : i
        let s_690_33: i128 = 9;
        // C s_690_34: const #1s : i
        let s_690_34: i128 = 1;
        // D s_690_35: read-var u#31185:u32
        let s_690_35: u32 = fn_state.u_31185;
        // D s_690_36: cast zx s_690_35 -> bv
        let s_690_36: Bits = Bits::new(s_690_35 as u128, 32u16);
        // D s_690_37: bit-extract s_690_36 s_690_33 s_690_34
        let s_690_37: Bits = (Bits::new(
            ((s_690_36) >> (s_690_33)).value(),
            u16::try_from(s_690_34).unwrap(),
        ));
        // D s_690_38: cast reint s_690_37 -> u8
        let s_690_38: bool = ((s_690_37.value()) != 0);
        // C s_690_39: const #7s : i
        let s_690_39: i128 = 7;
        // C s_690_40: const #1s : i
        let s_690_40: i128 = 1;
        // D s_690_41: read-var u#31185:u32
        let s_690_41: u32 = fn_state.u_31185;
        // D s_690_42: cast zx s_690_41 -> bv
        let s_690_42: Bits = Bits::new(s_690_41 as u128, 32u16);
        // D s_690_43: bit-extract s_690_42 s_690_39 s_690_40
        let s_690_43: Bits = (Bits::new(
            ((s_690_42) >> (s_690_39)).value(),
            u16::try_from(s_690_40).unwrap(),
        ));
        // D s_690_44: cast reint s_690_43 -> u8
        let s_690_44: bool = ((s_690_43.value()) != 0);
        // C s_690_45: const #5s : i
        let s_690_45: i128 = 5;
        // C s_690_46: const #1s : i
        let s_690_46: i128 = 1;
        // D s_690_47: read-var u#31185:u32
        let s_690_47: u32 = fn_state.u_31185;
        // D s_690_48: cast zx s_690_47 -> bv
        let s_690_48: Bits = Bits::new(s_690_47 as u128, 32u16);
        // D s_690_49: bit-extract s_690_48 s_690_45 s_690_46
        let s_690_49: Bits = (Bits::new(
            ((s_690_48) >> (s_690_45)).value(),
            u16::try_from(s_690_46).unwrap(),
        ));
        // D s_690_50: cast reint s_690_49 -> u8
        let s_690_50: bool = ((s_690_49.value()) != 0);
        // C s_690_51: const #0s : i
        let s_690_51: i128 = 0;
        // C s_690_52: const #4s : i
        let s_690_52: i128 = 4;
        // D s_690_53: read-var u#31185:u32
        let s_690_53: u32 = fn_state.u_31185;
        // D s_690_54: cast zx s_690_53 -> bv
        let s_690_54: Bits = Bits::new(s_690_53 as u128, 32u16);
        // D s_690_55: bit-extract s_690_54 s_690_51 s_690_52
        let s_690_55: Bits = (Bits::new(
            ((s_690_54) >> (s_690_51)).value(),
            u16::try_from(s_690_52).unwrap(),
        ));
        // D s_690_56: cast reint s_690_55 -> u8
        let s_690_56: u8 = (s_690_55.value() as u8);
        // D s_690_57: call decode_aarch32_instrs_VMLA_i_A2enc_A_txt(s_690_8, s_690_14, s_690_20, s_690_26, s_690_32, s_690_38, s_690_44, s_690_50, s_690_56)
        let s_690_57: () = decode_aarch32_instrs_VMLA_i_A2enc_A_txt(
            state,
            tracer,
            s_690_8,
            s_690_14,
            s_690_20,
            s_690_26,
            s_690_32,
            s_690_38,
            s_690_44,
            s_690_50,
            s_690_56,
        );
        // N s_690_58: return
        return;
    }
    fn block_691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_691_0: read-var merge#var.1:struct
        let s_691_0: u32 = fn_state.merge_var._1;
        // D s_691_1: write-var u#31196 <= s_691_0
        fn_state.u_31196 = s_691_0;
        // C s_691_2: const #25s : i
        let s_691_2: i128 = 25;
        // D s_691_3: read-var u#31196:u32
        let s_691_3: u32 = fn_state.u_31196;
        // D s_691_4: cast zx s_691_3 -> bv
        let s_691_4: Bits = Bits::new(s_691_3 as u128, 32u16);
        // C s_691_5: const #1s : i64
        let s_691_5: i64 = 1;
        // C s_691_6: cast zx s_691_5 -> i
        let s_691_6: i128 = (i128::try_from(s_691_5).unwrap());
        // C s_691_7: const #6s : i
        let s_691_7: i128 = 6;
        // C s_691_8: add s_691_7 s_691_6
        let s_691_8: i128 = (s_691_7 + s_691_6);
        // D s_691_9: bit-extract s_691_4 s_691_2 s_691_8
        let s_691_9: Bits = (Bits::new(
            ((s_691_4) >> (s_691_2)).value(),
            u16::try_from(s_691_8).unwrap(),
        ));
        // D s_691_10: cast reint s_691_9 -> u8
        let s_691_10: u8 = (s_691_9.value() as u8);
        // D s_691_11: cast zx s_691_10 -> bv
        let s_691_11: Bits = Bits::new(s_691_10 as u128, 7u16);
        // C s_691_12: const #121u : u8
        let s_691_12: u8 = 121;
        // C s_691_13: cast zx s_691_12 -> bv
        let s_691_13: Bits = Bits::new(s_691_12 as u128, 7u16);
        // D s_691_14: cmp-eq s_691_11 s_691_13
        let s_691_14: bool = ((s_691_11) == (s_691_13));
        // N s_691_15: branch s_691_14 b2654 b692
        if s_691_14 {
            return block_2654(state, tracer, fn_state);
        } else {
            return block_692(state, tracer, fn_state);
        };
    }
    fn block_692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_692_0: const #0u : u8
        let s_692_0: bool = false;
        // D s_692_1: write-var gs#399886 <= s_692_0
        fn_state.gs_399886 = s_692_0;
        // N s_692_2: jump b693
        return block_693(state, tracer, fn_state);
    }
    fn block_693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_693_0: read-var gs#399886:u8
        let s_693_0: bool = fn_state.gs_399886;
        // N s_693_1: branch s_693_0 b2653 b694
        if s_693_0 {
            return block_2653(state, tracer, fn_state);
        } else {
            return block_694(state, tracer, fn_state);
        };
    }
    fn block_694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_694_0: const #0u : u8
        let s_694_0: bool = false;
        // D s_694_1: write-var gs#399888 <= s_694_0
        fn_state.gs_399888 = s_694_0;
        // N s_694_2: jump b695
        return block_695(state, tracer, fn_state);
    }
    fn block_695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_695_0: read-var gs#399888:u8
        let s_695_0: bool = fn_state.gs_399888;
        // D s_695_1: not s_695_0
        let s_695_1: bool = !s_695_0;
        // N s_695_2: branch s_695_1 b697 b696
        if s_695_1 {
            return block_697(state, tracer, fn_state);
        } else {
            return block_696(state, tracer, fn_state);
        };
    }
    fn block_696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_696_0: const #3516s : i
        let s_696_0: i128 = 3516;
        // C s_696_1: const #14696u : u32
        let s_696_1: u32 = 14696;
        // N s_696_2: write-reg s_696_1 <= s_696_0
        let s_696_2: () = {
            state.write_register::<i128>(s_696_1 as isize, s_696_0);
            tracer.write_register(s_696_1 as isize, s_696_0);
        };
        // C s_696_3: const #24s : i
        let s_696_3: i128 = 24;
        // C s_696_4: const #1s : i
        let s_696_4: i128 = 1;
        // D s_696_5: read-var u#31196:u32
        let s_696_5: u32 = fn_state.u_31196;
        // D s_696_6: cast zx s_696_5 -> bv
        let s_696_6: Bits = Bits::new(s_696_5 as u128, 32u16);
        // D s_696_7: bit-extract s_696_6 s_696_3 s_696_4
        let s_696_7: Bits = (Bits::new(
            ((s_696_6) >> (s_696_3)).value(),
            u16::try_from(s_696_4).unwrap(),
        ));
        // D s_696_8: cast reint s_696_7 -> u8
        let s_696_8: bool = ((s_696_7.value()) != 0);
        // C s_696_9: const #22s : i
        let s_696_9: i128 = 22;
        // C s_696_10: const #1s : i
        let s_696_10: i128 = 1;
        // D s_696_11: read-var u#31196:u32
        let s_696_11: u32 = fn_state.u_31196;
        // D s_696_12: cast zx s_696_11 -> bv
        let s_696_12: Bits = Bits::new(s_696_11 as u128, 32u16);
        // D s_696_13: bit-extract s_696_12 s_696_9 s_696_10
        let s_696_13: Bits = (Bits::new(
            ((s_696_12) >> (s_696_9)).value(),
            u16::try_from(s_696_10).unwrap(),
        ));
        // D s_696_14: cast reint s_696_13 -> u8
        let s_696_14: bool = ((s_696_13.value()) != 0);
        // C s_696_15: const #20s : i
        let s_696_15: i128 = 20;
        // C s_696_16: const #2s : i
        let s_696_16: i128 = 2;
        // D s_696_17: read-var u#31196:u32
        let s_696_17: u32 = fn_state.u_31196;
        // D s_696_18: cast zx s_696_17 -> bv
        let s_696_18: Bits = Bits::new(s_696_17 as u128, 32u16);
        // D s_696_19: bit-extract s_696_18 s_696_15 s_696_16
        let s_696_19: Bits = (Bits::new(
            ((s_696_18) >> (s_696_15)).value(),
            u16::try_from(s_696_16).unwrap(),
        ));
        // D s_696_20: cast reint s_696_19 -> u8
        let s_696_20: u8 = (s_696_19.value() as u8);
        // C s_696_21: const #16s : i
        let s_696_21: i128 = 16;
        // C s_696_22: const #4s : i
        let s_696_22: i128 = 4;
        // D s_696_23: read-var u#31196:u32
        let s_696_23: u32 = fn_state.u_31196;
        // D s_696_24: cast zx s_696_23 -> bv
        let s_696_24: Bits = Bits::new(s_696_23 as u128, 32u16);
        // D s_696_25: bit-extract s_696_24 s_696_21 s_696_22
        let s_696_25: Bits = (Bits::new(
            ((s_696_24) >> (s_696_21)).value(),
            u16::try_from(s_696_22).unwrap(),
        ));
        // D s_696_26: cast reint s_696_25 -> u8
        let s_696_26: u8 = (s_696_25.value() as u8);
        // C s_696_27: const #12s : i
        let s_696_27: i128 = 12;
        // C s_696_28: const #4s : i
        let s_696_28: i128 = 4;
        // D s_696_29: read-var u#31196:u32
        let s_696_29: u32 = fn_state.u_31196;
        // D s_696_30: cast zx s_696_29 -> bv
        let s_696_30: Bits = Bits::new(s_696_29 as u128, 32u16);
        // D s_696_31: bit-extract s_696_30 s_696_27 s_696_28
        let s_696_31: Bits = (Bits::new(
            ((s_696_30) >> (s_696_27)).value(),
            u16::try_from(s_696_28).unwrap(),
        ));
        // D s_696_32: cast reint s_696_31 -> u8
        let s_696_32: u8 = (s_696_31.value() as u8);
        // C s_696_33: const #10s : i
        let s_696_33: i128 = 10;
        // C s_696_34: const #1s : i
        let s_696_34: i128 = 1;
        // D s_696_35: read-var u#31196:u32
        let s_696_35: u32 = fn_state.u_31196;
        // D s_696_36: cast zx s_696_35 -> bv
        let s_696_36: Bits = Bits::new(s_696_35 as u128, 32u16);
        // D s_696_37: bit-extract s_696_36 s_696_33 s_696_34
        let s_696_37: Bits = (Bits::new(
            ((s_696_36) >> (s_696_33)).value(),
            u16::try_from(s_696_34).unwrap(),
        ));
        // D s_696_38: cast reint s_696_37 -> u8
        let s_696_38: bool = ((s_696_37.value()) != 0);
        // C s_696_39: const #8s : i
        let s_696_39: i128 = 8;
        // C s_696_40: const #1s : i
        let s_696_40: i128 = 1;
        // D s_696_41: read-var u#31196:u32
        let s_696_41: u32 = fn_state.u_31196;
        // D s_696_42: cast zx s_696_41 -> bv
        let s_696_42: Bits = Bits::new(s_696_41 as u128, 32u16);
        // D s_696_43: bit-extract s_696_42 s_696_39 s_696_40
        let s_696_43: Bits = (Bits::new(
            ((s_696_42) >> (s_696_39)).value(),
            u16::try_from(s_696_40).unwrap(),
        ));
        // D s_696_44: cast reint s_696_43 -> u8
        let s_696_44: bool = ((s_696_43.value()) != 0);
        // C s_696_45: const #7s : i
        let s_696_45: i128 = 7;
        // C s_696_46: const #1s : i
        let s_696_46: i128 = 1;
        // D s_696_47: read-var u#31196:u32
        let s_696_47: u32 = fn_state.u_31196;
        // D s_696_48: cast zx s_696_47 -> bv
        let s_696_48: Bits = Bits::new(s_696_47 as u128, 32u16);
        // D s_696_49: bit-extract s_696_48 s_696_45 s_696_46
        let s_696_49: Bits = (Bits::new(
            ((s_696_48) >> (s_696_45)).value(),
            u16::try_from(s_696_46).unwrap(),
        ));
        // D s_696_50: cast reint s_696_49 -> u8
        let s_696_50: bool = ((s_696_49.value()) != 0);
        // C s_696_51: const #5s : i
        let s_696_51: i128 = 5;
        // C s_696_52: const #1s : i
        let s_696_52: i128 = 1;
        // D s_696_53: read-var u#31196:u32
        let s_696_53: u32 = fn_state.u_31196;
        // D s_696_54: cast zx s_696_53 -> bv
        let s_696_54: Bits = Bits::new(s_696_53 as u128, 32u16);
        // D s_696_55: bit-extract s_696_54 s_696_51 s_696_52
        let s_696_55: Bits = (Bits::new(
            ((s_696_54) >> (s_696_51)).value(),
            u16::try_from(s_696_52).unwrap(),
        ));
        // D s_696_56: cast reint s_696_55 -> u8
        let s_696_56: bool = ((s_696_55.value()) != 0);
        // C s_696_57: const #0s : i
        let s_696_57: i128 = 0;
        // C s_696_58: const #4s : i
        let s_696_58: i128 = 4;
        // D s_696_59: read-var u#31196:u32
        let s_696_59: u32 = fn_state.u_31196;
        // D s_696_60: cast zx s_696_59 -> bv
        let s_696_60: Bits = Bits::new(s_696_59 as u128, 32u16);
        // D s_696_61: bit-extract s_696_60 s_696_57 s_696_58
        let s_696_61: Bits = (Bits::new(
            ((s_696_60) >> (s_696_57)).value(),
            u16::try_from(s_696_58).unwrap(),
        ));
        // D s_696_62: cast reint s_696_61 -> u8
        let s_696_62: u8 = (s_696_61.value() as u8);
        // D s_696_63: call decode_aarch32_instrs_VMLA_s_A1enc_A_txt(s_696_8, s_696_14, s_696_20, s_696_26, s_696_32, s_696_38, s_696_44, s_696_50, s_696_56, s_696_62)
        let s_696_63: () = decode_aarch32_instrs_VMLA_s_A1enc_A_txt(
            state,
            tracer,
            s_696_8,
            s_696_14,
            s_696_20,
            s_696_26,
            s_696_32,
            s_696_38,
            s_696_44,
            s_696_50,
            s_696_56,
            s_696_62,
        );
        // N s_696_64: return
        return;
    }
    fn block_697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_697_0: read-var merge#var.1:struct
        let s_697_0: u32 = fn_state.merge_var._1;
        // D s_697_1: write-var u#31208 <= s_697_0
        fn_state.u_31208 = s_697_0;
        // C s_697_2: const #25s : i
        let s_697_2: i128 = 25;
        // D s_697_3: read-var u#31208:u32
        let s_697_3: u32 = fn_state.u_31208;
        // D s_697_4: cast zx s_697_3 -> bv
        let s_697_4: Bits = Bits::new(s_697_3 as u128, 32u16);
        // C s_697_5: const #1s : i64
        let s_697_5: i64 = 1;
        // C s_697_6: cast zx s_697_5 -> i
        let s_697_6: i128 = (i128::try_from(s_697_5).unwrap());
        // C s_697_7: const #6s : i
        let s_697_7: i128 = 6;
        // C s_697_8: add s_697_7 s_697_6
        let s_697_8: i128 = (s_697_7 + s_697_6);
        // D s_697_9: bit-extract s_697_4 s_697_2 s_697_8
        let s_697_9: Bits = (Bits::new(
            ((s_697_4) >> (s_697_2)).value(),
            u16::try_from(s_697_8).unwrap(),
        ));
        // D s_697_10: cast reint s_697_9 -> u8
        let s_697_10: u8 = (s_697_9.value() as u8);
        // D s_697_11: cast zx s_697_10 -> bv
        let s_697_11: Bits = Bits::new(s_697_10 as u128, 7u16);
        // C s_697_12: const #121u : u8
        let s_697_12: u8 = 121;
        // C s_697_13: cast zx s_697_12 -> bv
        let s_697_13: Bits = Bits::new(s_697_12 as u128, 7u16);
        // D s_697_14: cmp-eq s_697_11 s_697_13
        let s_697_14: bool = ((s_697_11) == (s_697_13));
        // N s_697_15: branch s_697_14 b2640 b698
        if s_697_14 {
            return block_2640(state, tracer, fn_state);
        } else {
            return block_698(state, tracer, fn_state);
        };
    }
    fn block_698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_698_0: const #0u : u8
        let s_698_0: bool = false;
        // D s_698_1: write-var gs#399928 <= s_698_0
        fn_state.gs_399928 = s_698_0;
        // N s_698_2: jump b699
        return block_699(state, tracer, fn_state);
    }
    fn block_699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_699_0: read-var gs#399928:u8
        let s_699_0: bool = fn_state.gs_399928;
        // N s_699_1: branch s_699_0 b2639 b700
        if s_699_0 {
            return block_2639(state, tracer, fn_state);
        } else {
            return block_700(state, tracer, fn_state);
        };
    }
    fn block_700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_700_0: const #0u : u8
        let s_700_0: bool = false;
        // D s_700_1: write-var gs#399930 <= s_700_0
        fn_state.gs_399930 = s_700_0;
        // N s_700_2: jump b701
        return block_701(state, tracer, fn_state);
    }
    fn block_701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_701_0: read-var gs#399930:u8
        let s_701_0: bool = fn_state.gs_399930;
        // D s_701_1: not s_701_0
        let s_701_1: bool = !s_701_0;
        // N s_701_2: branch s_701_1 b703 b702
        if s_701_1 {
            return block_703(state, tracer, fn_state);
        } else {
            return block_702(state, tracer, fn_state);
        };
    }
    fn block_702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_702_0: const #3517s : i
        let s_702_0: i128 = 3517;
        // C s_702_1: const #14696u : u32
        let s_702_1: u32 = 14696;
        // N s_702_2: write-reg s_702_1 <= s_702_0
        let s_702_2: () = {
            state.write_register::<i128>(s_702_1 as isize, s_702_0);
            tracer.write_register(s_702_1 as isize, s_702_0);
        };
        // C s_702_3: const #24s : i
        let s_702_3: i128 = 24;
        // C s_702_4: const #1s : i
        let s_702_4: i128 = 1;
        // D s_702_5: read-var u#31208:u32
        let s_702_5: u32 = fn_state.u_31208;
        // D s_702_6: cast zx s_702_5 -> bv
        let s_702_6: Bits = Bits::new(s_702_5 as u128, 32u16);
        // D s_702_7: bit-extract s_702_6 s_702_3 s_702_4
        let s_702_7: Bits = (Bits::new(
            ((s_702_6) >> (s_702_3)).value(),
            u16::try_from(s_702_4).unwrap(),
        ));
        // D s_702_8: cast reint s_702_7 -> u8
        let s_702_8: bool = ((s_702_7.value()) != 0);
        // C s_702_9: const #22s : i
        let s_702_9: i128 = 22;
        // C s_702_10: const #1s : i
        let s_702_10: i128 = 1;
        // D s_702_11: read-var u#31208:u32
        let s_702_11: u32 = fn_state.u_31208;
        // D s_702_12: cast zx s_702_11 -> bv
        let s_702_12: Bits = Bits::new(s_702_11 as u128, 32u16);
        // D s_702_13: bit-extract s_702_12 s_702_9 s_702_10
        let s_702_13: Bits = (Bits::new(
            ((s_702_12) >> (s_702_9)).value(),
            u16::try_from(s_702_10).unwrap(),
        ));
        // D s_702_14: cast reint s_702_13 -> u8
        let s_702_14: bool = ((s_702_13.value()) != 0);
        // C s_702_15: const #20s : i
        let s_702_15: i128 = 20;
        // C s_702_16: const #2s : i
        let s_702_16: i128 = 2;
        // D s_702_17: read-var u#31208:u32
        let s_702_17: u32 = fn_state.u_31208;
        // D s_702_18: cast zx s_702_17 -> bv
        let s_702_18: Bits = Bits::new(s_702_17 as u128, 32u16);
        // D s_702_19: bit-extract s_702_18 s_702_15 s_702_16
        let s_702_19: Bits = (Bits::new(
            ((s_702_18) >> (s_702_15)).value(),
            u16::try_from(s_702_16).unwrap(),
        ));
        // D s_702_20: cast reint s_702_19 -> u8
        let s_702_20: u8 = (s_702_19.value() as u8);
        // C s_702_21: const #16s : i
        let s_702_21: i128 = 16;
        // C s_702_22: const #4s : i
        let s_702_22: i128 = 4;
        // D s_702_23: read-var u#31208:u32
        let s_702_23: u32 = fn_state.u_31208;
        // D s_702_24: cast zx s_702_23 -> bv
        let s_702_24: Bits = Bits::new(s_702_23 as u128, 32u16);
        // D s_702_25: bit-extract s_702_24 s_702_21 s_702_22
        let s_702_25: Bits = (Bits::new(
            ((s_702_24) >> (s_702_21)).value(),
            u16::try_from(s_702_22).unwrap(),
        ));
        // D s_702_26: cast reint s_702_25 -> u8
        let s_702_26: u8 = (s_702_25.value() as u8);
        // C s_702_27: const #12s : i
        let s_702_27: i128 = 12;
        // C s_702_28: const #4s : i
        let s_702_28: i128 = 4;
        // D s_702_29: read-var u#31208:u32
        let s_702_29: u32 = fn_state.u_31208;
        // D s_702_30: cast zx s_702_29 -> bv
        let s_702_30: Bits = Bits::new(s_702_29 as u128, 32u16);
        // D s_702_31: bit-extract s_702_30 s_702_27 s_702_28
        let s_702_31: Bits = (Bits::new(
            ((s_702_30) >> (s_702_27)).value(),
            u16::try_from(s_702_28).unwrap(),
        ));
        // D s_702_32: cast reint s_702_31 -> u8
        let s_702_32: u8 = (s_702_31.value() as u8);
        // C s_702_33: const #10s : i
        let s_702_33: i128 = 10;
        // C s_702_34: const #1s : i
        let s_702_34: i128 = 1;
        // D s_702_35: read-var u#31208:u32
        let s_702_35: u32 = fn_state.u_31208;
        // D s_702_36: cast zx s_702_35 -> bv
        let s_702_36: Bits = Bits::new(s_702_35 as u128, 32u16);
        // D s_702_37: bit-extract s_702_36 s_702_33 s_702_34
        let s_702_37: Bits = (Bits::new(
            ((s_702_36) >> (s_702_33)).value(),
            u16::try_from(s_702_34).unwrap(),
        ));
        // D s_702_38: cast reint s_702_37 -> u8
        let s_702_38: bool = ((s_702_37.value()) != 0);
        // C s_702_39: const #7s : i
        let s_702_39: i128 = 7;
        // C s_702_40: const #1s : i
        let s_702_40: i128 = 1;
        // D s_702_41: read-var u#31208:u32
        let s_702_41: u32 = fn_state.u_31208;
        // D s_702_42: cast zx s_702_41 -> bv
        let s_702_42: Bits = Bits::new(s_702_41 as u128, 32u16);
        // D s_702_43: bit-extract s_702_42 s_702_39 s_702_40
        let s_702_43: Bits = (Bits::new(
            ((s_702_42) >> (s_702_39)).value(),
            u16::try_from(s_702_40).unwrap(),
        ));
        // D s_702_44: cast reint s_702_43 -> u8
        let s_702_44: bool = ((s_702_43.value()) != 0);
        // C s_702_45: const #5s : i
        let s_702_45: i128 = 5;
        // C s_702_46: const #1s : i
        let s_702_46: i128 = 1;
        // D s_702_47: read-var u#31208:u32
        let s_702_47: u32 = fn_state.u_31208;
        // D s_702_48: cast zx s_702_47 -> bv
        let s_702_48: Bits = Bits::new(s_702_47 as u128, 32u16);
        // D s_702_49: bit-extract s_702_48 s_702_45 s_702_46
        let s_702_49: Bits = (Bits::new(
            ((s_702_48) >> (s_702_45)).value(),
            u16::try_from(s_702_46).unwrap(),
        ));
        // D s_702_50: cast reint s_702_49 -> u8
        let s_702_50: bool = ((s_702_49.value()) != 0);
        // C s_702_51: const #0s : i
        let s_702_51: i128 = 0;
        // C s_702_52: const #4s : i
        let s_702_52: i128 = 4;
        // D s_702_53: read-var u#31208:u32
        let s_702_53: u32 = fn_state.u_31208;
        // D s_702_54: cast zx s_702_53 -> bv
        let s_702_54: Bits = Bits::new(s_702_53 as u128, 32u16);
        // D s_702_55: bit-extract s_702_54 s_702_51 s_702_52
        let s_702_55: Bits = (Bits::new(
            ((s_702_54) >> (s_702_51)).value(),
            u16::try_from(s_702_52).unwrap(),
        ));
        // D s_702_56: cast reint s_702_55 -> u8
        let s_702_56: u8 = (s_702_55.value() as u8);
        // D s_702_57: call decode_aarch32_instrs_VMLA_s_A2enc_A_txt(s_702_8, s_702_14, s_702_20, s_702_26, s_702_32, s_702_38, s_702_44, s_702_50, s_702_56)
        let s_702_57: () = decode_aarch32_instrs_VMLA_s_A2enc_A_txt(
            state,
            tracer,
            s_702_8,
            s_702_14,
            s_702_20,
            s_702_26,
            s_702_32,
            s_702_38,
            s_702_44,
            s_702_50,
            s_702_56,
        );
        // N s_702_58: return
        return;
    }
    fn block_703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_703_0: read-var merge#var.1:struct
        let s_703_0: u32 = fn_state.merge_var._1;
        // D s_703_1: write-var u#31219 <= s_703_0
        fn_state.u_31219 = s_703_0;
        // C s_703_2: const #25s : i
        let s_703_2: i128 = 25;
        // D s_703_3: read-var u#31219:u32
        let s_703_3: u32 = fn_state.u_31219;
        // D s_703_4: cast zx s_703_3 -> bv
        let s_703_4: Bits = Bits::new(s_703_3 as u128, 32u16);
        // C s_703_5: const #1s : i64
        let s_703_5: i64 = 1;
        // C s_703_6: cast zx s_703_5 -> i
        let s_703_6: i128 = (i128::try_from(s_703_5).unwrap());
        // C s_703_7: const #6s : i
        let s_703_7: i128 = 6;
        // C s_703_8: add s_703_7 s_703_6
        let s_703_8: i128 = (s_703_7 + s_703_6);
        // D s_703_9: bit-extract s_703_4 s_703_2 s_703_8
        let s_703_9: Bits = (Bits::new(
            ((s_703_4) >> (s_703_2)).value(),
            u16::try_from(s_703_8).unwrap(),
        ));
        // D s_703_10: cast reint s_703_9 -> u8
        let s_703_10: u8 = (s_703_9.value() as u8);
        // D s_703_11: cast zx s_703_10 -> bv
        let s_703_11: Bits = Bits::new(s_703_10 as u128, 7u16);
        // C s_703_12: const #121u : u8
        let s_703_12: u8 = 121;
        // C s_703_13: cast zx s_703_12 -> bv
        let s_703_13: Bits = Bits::new(s_703_12 as u128, 7u16);
        // D s_703_14: cmp-eq s_703_11 s_703_13
        let s_703_14: bool = ((s_703_11) == (s_703_13));
        // N s_703_15: branch s_703_14 b2626 b704
        if s_703_14 {
            return block_2626(state, tracer, fn_state);
        } else {
            return block_704(state, tracer, fn_state);
        };
    }
    fn block_704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_704_0: const #0u : u8
        let s_704_0: bool = false;
        // D s_704_1: write-var gs#399968 <= s_704_0
        fn_state.gs_399968 = s_704_0;
        // N s_704_2: jump b705
        return block_705(state, tracer, fn_state);
    }
    fn block_705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_705_0: read-var gs#399968:u8
        let s_705_0: bool = fn_state.gs_399968;
        // N s_705_1: branch s_705_0 b2625 b706
        if s_705_0 {
            return block_2625(state, tracer, fn_state);
        } else {
            return block_706(state, tracer, fn_state);
        };
    }
    fn block_706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_706_0: const #0u : u8
        let s_706_0: bool = false;
        // D s_706_1: write-var gs#399970 <= s_706_0
        fn_state.gs_399970 = s_706_0;
        // N s_706_2: jump b707
        return block_707(state, tracer, fn_state);
    }
    fn block_707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_707_0: read-var gs#399970:u8
        let s_707_0: bool = fn_state.gs_399970;
        // D s_707_1: not s_707_0
        let s_707_1: bool = !s_707_0;
        // N s_707_2: branch s_707_1 b709 b708
        if s_707_1 {
            return block_709(state, tracer, fn_state);
        } else {
            return block_708(state, tracer, fn_state);
        };
    }
    fn block_708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_708_0: const #3526s : i
        let s_708_0: i128 = 3526;
        // C s_708_1: const #14696u : u32
        let s_708_1: u32 = 14696;
        // N s_708_2: write-reg s_708_1 <= s_708_0
        let s_708_2: () = {
            state.write_register::<i128>(s_708_1 as isize, s_708_0);
            tracer.write_register(s_708_1 as isize, s_708_0);
        };
        // C s_708_3: const #24s : i
        let s_708_3: i128 = 24;
        // C s_708_4: const #1s : i
        let s_708_4: i128 = 1;
        // D s_708_5: read-var u#31219:u32
        let s_708_5: u32 = fn_state.u_31219;
        // D s_708_6: cast zx s_708_5 -> bv
        let s_708_6: Bits = Bits::new(s_708_5 as u128, 32u16);
        // D s_708_7: bit-extract s_708_6 s_708_3 s_708_4
        let s_708_7: Bits = (Bits::new(
            ((s_708_6) >> (s_708_3)).value(),
            u16::try_from(s_708_4).unwrap(),
        ));
        // D s_708_8: cast reint s_708_7 -> u8
        let s_708_8: bool = ((s_708_7.value()) != 0);
        // C s_708_9: const #22s : i
        let s_708_9: i128 = 22;
        // C s_708_10: const #1s : i
        let s_708_10: i128 = 1;
        // D s_708_11: read-var u#31219:u32
        let s_708_11: u32 = fn_state.u_31219;
        // D s_708_12: cast zx s_708_11 -> bv
        let s_708_12: Bits = Bits::new(s_708_11 as u128, 32u16);
        // D s_708_13: bit-extract s_708_12 s_708_9 s_708_10
        let s_708_13: Bits = (Bits::new(
            ((s_708_12) >> (s_708_9)).value(),
            u16::try_from(s_708_10).unwrap(),
        ));
        // D s_708_14: cast reint s_708_13 -> u8
        let s_708_14: bool = ((s_708_13.value()) != 0);
        // C s_708_15: const #16s : i
        let s_708_15: i128 = 16;
        // C s_708_16: const #3s : i
        let s_708_16: i128 = 3;
        // D s_708_17: read-var u#31219:u32
        let s_708_17: u32 = fn_state.u_31219;
        // D s_708_18: cast zx s_708_17 -> bv
        let s_708_18: Bits = Bits::new(s_708_17 as u128, 32u16);
        // D s_708_19: bit-extract s_708_18 s_708_15 s_708_16
        let s_708_19: Bits = (Bits::new(
            ((s_708_18) >> (s_708_15)).value(),
            u16::try_from(s_708_16).unwrap(),
        ));
        // D s_708_20: cast reint s_708_19 -> u8
        let s_708_20: u8 = (s_708_19.value() as u8);
        // C s_708_21: const #12s : i
        let s_708_21: i128 = 12;
        // C s_708_22: const #4s : i
        let s_708_22: i128 = 4;
        // D s_708_23: read-var u#31219:u32
        let s_708_23: u32 = fn_state.u_31219;
        // D s_708_24: cast zx s_708_23 -> bv
        let s_708_24: Bits = Bits::new(s_708_23 as u128, 32u16);
        // D s_708_25: bit-extract s_708_24 s_708_21 s_708_22
        let s_708_25: Bits = (Bits::new(
            ((s_708_24) >> (s_708_21)).value(),
            u16::try_from(s_708_22).unwrap(),
        ));
        // D s_708_26: cast reint s_708_25 -> u8
        let s_708_26: u8 = (s_708_25.value() as u8);
        // C s_708_27: const #8s : i
        let s_708_27: i128 = 8;
        // C s_708_28: const #4s : i
        let s_708_28: i128 = 4;
        // D s_708_29: read-var u#31219:u32
        let s_708_29: u32 = fn_state.u_31219;
        // D s_708_30: cast zx s_708_29 -> bv
        let s_708_30: Bits = Bits::new(s_708_29 as u128, 32u16);
        // D s_708_31: bit-extract s_708_30 s_708_27 s_708_28
        let s_708_31: Bits = (Bits::new(
            ((s_708_30) >> (s_708_27)).value(),
            u16::try_from(s_708_28).unwrap(),
        ));
        // D s_708_32: cast reint s_708_31 -> u8
        let s_708_32: u8 = (s_708_31.value() as u8);
        // C s_708_33: const #6s : i
        let s_708_33: i128 = 6;
        // C s_708_34: const #1s : i
        let s_708_34: i128 = 1;
        // D s_708_35: read-var u#31219:u32
        let s_708_35: u32 = fn_state.u_31219;
        // D s_708_36: cast zx s_708_35 -> bv
        let s_708_36: Bits = Bits::new(s_708_35 as u128, 32u16);
        // D s_708_37: bit-extract s_708_36 s_708_33 s_708_34
        let s_708_37: Bits = (Bits::new(
            ((s_708_36) >> (s_708_33)).value(),
            u16::try_from(s_708_34).unwrap(),
        ));
        // D s_708_38: cast reint s_708_37 -> u8
        let s_708_38: bool = ((s_708_37.value()) != 0);
        // C s_708_39: const #5s : i
        let s_708_39: i128 = 5;
        // C s_708_40: const #1s : i
        let s_708_40: i128 = 1;
        // D s_708_41: read-var u#31219:u32
        let s_708_41: u32 = fn_state.u_31219;
        // D s_708_42: cast zx s_708_41 -> bv
        let s_708_42: Bits = Bits::new(s_708_41 as u128, 32u16);
        // D s_708_43: bit-extract s_708_42 s_708_39 s_708_40
        let s_708_43: Bits = (Bits::new(
            ((s_708_42) >> (s_708_39)).value(),
            u16::try_from(s_708_40).unwrap(),
        ));
        // D s_708_44: cast reint s_708_43 -> u8
        let s_708_44: bool = ((s_708_43.value()) != 0);
        // C s_708_45: const #0s : i
        let s_708_45: i128 = 0;
        // C s_708_46: const #4s : i
        let s_708_46: i128 = 4;
        // D s_708_47: read-var u#31219:u32
        let s_708_47: u32 = fn_state.u_31219;
        // D s_708_48: cast zx s_708_47 -> bv
        let s_708_48: Bits = Bits::new(s_708_47 as u128, 32u16);
        // D s_708_49: bit-extract s_708_48 s_708_45 s_708_46
        let s_708_49: Bits = (Bits::new(
            ((s_708_48) >> (s_708_45)).value(),
            u16::try_from(s_708_46).unwrap(),
        ));
        // D s_708_50: cast reint s_708_49 -> u8
        let s_708_50: u8 = (s_708_49.value() as u8);
        // D s_708_51: call decode_aarch32_instrs_VMOV_i_A1enc_A_txt(s_708_8, s_708_14, s_708_20, s_708_26, s_708_32, s_708_38, s_708_44, s_708_50)
        let s_708_51: () = decode_aarch32_instrs_VMOV_i_A1enc_A_txt(
            state,
            tracer,
            s_708_8,
            s_708_14,
            s_708_20,
            s_708_26,
            s_708_32,
            s_708_38,
            s_708_44,
            s_708_50,
        );
        // N s_708_52: return
        return;
    }
    fn block_709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_709_0: read-var merge#var.1:struct
        let s_709_0: u32 = fn_state.merge_var._1;
        // D s_709_1: write-var u#31229 <= s_709_0
        fn_state.u_31229 = s_709_0;
        // C s_709_2: const #25s : i
        let s_709_2: i128 = 25;
        // D s_709_3: read-var u#31229:u32
        let s_709_3: u32 = fn_state.u_31229;
        // D s_709_4: cast zx s_709_3 -> bv
        let s_709_4: Bits = Bits::new(s_709_3 as u128, 32u16);
        // C s_709_5: const #1s : i64
        let s_709_5: i64 = 1;
        // C s_709_6: cast zx s_709_5 -> i
        let s_709_6: i128 = (i128::try_from(s_709_5).unwrap());
        // C s_709_7: const #6s : i
        let s_709_7: i128 = 6;
        // C s_709_8: add s_709_7 s_709_6
        let s_709_8: i128 = (s_709_7 + s_709_6);
        // D s_709_9: bit-extract s_709_4 s_709_2 s_709_8
        let s_709_9: Bits = (Bits::new(
            ((s_709_4) >> (s_709_2)).value(),
            u16::try_from(s_709_8).unwrap(),
        ));
        // D s_709_10: cast reint s_709_9 -> u8
        let s_709_10: u8 = (s_709_9.value() as u8);
        // D s_709_11: cast zx s_709_10 -> bv
        let s_709_11: Bits = Bits::new(s_709_10 as u128, 7u16);
        // C s_709_12: const #121u : u8
        let s_709_12: u8 = 121;
        // C s_709_13: cast zx s_709_12 -> bv
        let s_709_13: Bits = Bits::new(s_709_12 as u128, 7u16);
        // D s_709_14: cmp-eq s_709_11 s_709_13
        let s_709_14: bool = ((s_709_11) == (s_709_13));
        // N s_709_15: branch s_709_14 b2612 b710
        if s_709_14 {
            return block_2612(state, tracer, fn_state);
        } else {
            return block_710(state, tracer, fn_state);
        };
    }
    fn block_710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_710_0: const #0u : u8
        let s_710_0: bool = false;
        // D s_710_1: write-var gs#400006 <= s_710_0
        fn_state.gs_400006 = s_710_0;
        // N s_710_2: jump b711
        return block_711(state, tracer, fn_state);
    }
    fn block_711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_711_0: read-var gs#400006:u8
        let s_711_0: bool = fn_state.gs_400006;
        // N s_711_1: branch s_711_0 b2611 b712
        if s_711_0 {
            return block_2611(state, tracer, fn_state);
        } else {
            return block_712(state, tracer, fn_state);
        };
    }
    fn block_712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_712_0: const #0u : u8
        let s_712_0: bool = false;
        // D s_712_1: write-var gs#400008 <= s_712_0
        fn_state.gs_400008 = s_712_0;
        // N s_712_2: jump b713
        return block_713(state, tracer, fn_state);
    }
    fn block_713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_713_0: read-var gs#400008:u8
        let s_713_0: bool = fn_state.gs_400008;
        // D s_713_1: not s_713_0
        let s_713_1: bool = !s_713_0;
        // N s_713_2: branch s_713_1 b715 b714
        if s_713_1 {
            return block_715(state, tracer, fn_state);
        } else {
            return block_714(state, tracer, fn_state);
        };
    }
    fn block_714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_714_0: const #3528s : i
        let s_714_0: i128 = 3528;
        // C s_714_1: const #14696u : u32
        let s_714_1: u32 = 14696;
        // N s_714_2: write-reg s_714_1 <= s_714_0
        let s_714_2: () = {
            state.write_register::<i128>(s_714_1 as isize, s_714_0);
            tracer.write_register(s_714_1 as isize, s_714_0);
        };
        // C s_714_3: const #24s : i
        let s_714_3: i128 = 24;
        // C s_714_4: const #1s : i
        let s_714_4: i128 = 1;
        // D s_714_5: read-var u#31229:u32
        let s_714_5: u32 = fn_state.u_31229;
        // D s_714_6: cast zx s_714_5 -> bv
        let s_714_6: Bits = Bits::new(s_714_5 as u128, 32u16);
        // D s_714_7: bit-extract s_714_6 s_714_3 s_714_4
        let s_714_7: Bits = (Bits::new(
            ((s_714_6) >> (s_714_3)).value(),
            u16::try_from(s_714_4).unwrap(),
        ));
        // D s_714_8: cast reint s_714_7 -> u8
        let s_714_8: bool = ((s_714_7.value()) != 0);
        // C s_714_9: const #22s : i
        let s_714_9: i128 = 22;
        // C s_714_10: const #1s : i
        let s_714_10: i128 = 1;
        // D s_714_11: read-var u#31229:u32
        let s_714_11: u32 = fn_state.u_31229;
        // D s_714_12: cast zx s_714_11 -> bv
        let s_714_12: Bits = Bits::new(s_714_11 as u128, 32u16);
        // D s_714_13: bit-extract s_714_12 s_714_9 s_714_10
        let s_714_13: Bits = (Bits::new(
            ((s_714_12) >> (s_714_9)).value(),
            u16::try_from(s_714_10).unwrap(),
        ));
        // D s_714_14: cast reint s_714_13 -> u8
        let s_714_14: bool = ((s_714_13.value()) != 0);
        // C s_714_15: const #16s : i
        let s_714_15: i128 = 16;
        // C s_714_16: const #3s : i
        let s_714_16: i128 = 3;
        // D s_714_17: read-var u#31229:u32
        let s_714_17: u32 = fn_state.u_31229;
        // D s_714_18: cast zx s_714_17 -> bv
        let s_714_18: Bits = Bits::new(s_714_17 as u128, 32u16);
        // D s_714_19: bit-extract s_714_18 s_714_15 s_714_16
        let s_714_19: Bits = (Bits::new(
            ((s_714_18) >> (s_714_15)).value(),
            u16::try_from(s_714_16).unwrap(),
        ));
        // D s_714_20: cast reint s_714_19 -> u8
        let s_714_20: u8 = (s_714_19.value() as u8);
        // C s_714_21: const #12s : i
        let s_714_21: i128 = 12;
        // C s_714_22: const #4s : i
        let s_714_22: i128 = 4;
        // D s_714_23: read-var u#31229:u32
        let s_714_23: u32 = fn_state.u_31229;
        // D s_714_24: cast zx s_714_23 -> bv
        let s_714_24: Bits = Bits::new(s_714_23 as u128, 32u16);
        // D s_714_25: bit-extract s_714_24 s_714_21 s_714_22
        let s_714_25: Bits = (Bits::new(
            ((s_714_24) >> (s_714_21)).value(),
            u16::try_from(s_714_22).unwrap(),
        ));
        // D s_714_26: cast reint s_714_25 -> u8
        let s_714_26: u8 = (s_714_25.value() as u8);
        // C s_714_27: const #8s : i
        let s_714_27: i128 = 8;
        // C s_714_28: const #4s : i
        let s_714_28: i128 = 4;
        // D s_714_29: read-var u#31229:u32
        let s_714_29: u32 = fn_state.u_31229;
        // D s_714_30: cast zx s_714_29 -> bv
        let s_714_30: Bits = Bits::new(s_714_29 as u128, 32u16);
        // D s_714_31: bit-extract s_714_30 s_714_27 s_714_28
        let s_714_31: Bits = (Bits::new(
            ((s_714_30) >> (s_714_27)).value(),
            u16::try_from(s_714_28).unwrap(),
        ));
        // D s_714_32: cast reint s_714_31 -> u8
        let s_714_32: u8 = (s_714_31.value() as u8);
        // C s_714_33: const #6s : i
        let s_714_33: i128 = 6;
        // C s_714_34: const #1s : i
        let s_714_34: i128 = 1;
        // D s_714_35: read-var u#31229:u32
        let s_714_35: u32 = fn_state.u_31229;
        // D s_714_36: cast zx s_714_35 -> bv
        let s_714_36: Bits = Bits::new(s_714_35 as u128, 32u16);
        // D s_714_37: bit-extract s_714_36 s_714_33 s_714_34
        let s_714_37: Bits = (Bits::new(
            ((s_714_36) >> (s_714_33)).value(),
            u16::try_from(s_714_34).unwrap(),
        ));
        // D s_714_38: cast reint s_714_37 -> u8
        let s_714_38: bool = ((s_714_37.value()) != 0);
        // C s_714_39: const #5s : i
        let s_714_39: i128 = 5;
        // C s_714_40: const #1s : i
        let s_714_40: i128 = 1;
        // D s_714_41: read-var u#31229:u32
        let s_714_41: u32 = fn_state.u_31229;
        // D s_714_42: cast zx s_714_41 -> bv
        let s_714_42: Bits = Bits::new(s_714_41 as u128, 32u16);
        // D s_714_43: bit-extract s_714_42 s_714_39 s_714_40
        let s_714_43: Bits = (Bits::new(
            ((s_714_42) >> (s_714_39)).value(),
            u16::try_from(s_714_40).unwrap(),
        ));
        // D s_714_44: cast reint s_714_43 -> u8
        let s_714_44: bool = ((s_714_43.value()) != 0);
        // C s_714_45: const #0s : i
        let s_714_45: i128 = 0;
        // C s_714_46: const #4s : i
        let s_714_46: i128 = 4;
        // D s_714_47: read-var u#31229:u32
        let s_714_47: u32 = fn_state.u_31229;
        // D s_714_48: cast zx s_714_47 -> bv
        let s_714_48: Bits = Bits::new(s_714_47 as u128, 32u16);
        // D s_714_49: bit-extract s_714_48 s_714_45 s_714_46
        let s_714_49: Bits = (Bits::new(
            ((s_714_48) >> (s_714_45)).value(),
            u16::try_from(s_714_46).unwrap(),
        ));
        // D s_714_50: cast reint s_714_49 -> u8
        let s_714_50: u8 = (s_714_49.value() as u8);
        // D s_714_51: call decode_aarch32_instrs_VMOV_i_A3enc_A_txt(s_714_8, s_714_14, s_714_20, s_714_26, s_714_32, s_714_38, s_714_44, s_714_50)
        let s_714_51: () = decode_aarch32_instrs_VMOV_i_A3enc_A_txt(
            state,
            tracer,
            s_714_8,
            s_714_14,
            s_714_20,
            s_714_26,
            s_714_32,
            s_714_38,
            s_714_44,
            s_714_50,
        );
        // N s_714_52: return
        return;
    }
    fn block_715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_715_0: read-var merge#var.1:struct
        let s_715_0: u32 = fn_state.merge_var._1;
        // D s_715_1: write-var u#31239 <= s_715_0
        fn_state.u_31239 = s_715_0;
        // C s_715_2: const #25s : i
        let s_715_2: i128 = 25;
        // D s_715_3: read-var u#31239:u32
        let s_715_3: u32 = fn_state.u_31239;
        // D s_715_4: cast zx s_715_3 -> bv
        let s_715_4: Bits = Bits::new(s_715_3 as u128, 32u16);
        // C s_715_5: const #1s : i64
        let s_715_5: i64 = 1;
        // C s_715_6: cast zx s_715_5 -> i
        let s_715_6: i128 = (i128::try_from(s_715_5).unwrap());
        // C s_715_7: const #6s : i
        let s_715_7: i128 = 6;
        // C s_715_8: add s_715_7 s_715_6
        let s_715_8: i128 = (s_715_7 + s_715_6);
        // D s_715_9: bit-extract s_715_4 s_715_2 s_715_8
        let s_715_9: Bits = (Bits::new(
            ((s_715_4) >> (s_715_2)).value(),
            u16::try_from(s_715_8).unwrap(),
        ));
        // D s_715_10: cast reint s_715_9 -> u8
        let s_715_10: u8 = (s_715_9.value() as u8);
        // D s_715_11: cast zx s_715_10 -> bv
        let s_715_11: Bits = Bits::new(s_715_10 as u128, 7u16);
        // C s_715_12: const #121u : u8
        let s_715_12: u8 = 121;
        // C s_715_13: cast zx s_715_12 -> bv
        let s_715_13: Bits = Bits::new(s_715_12 as u128, 7u16);
        // D s_715_14: cmp-eq s_715_11 s_715_13
        let s_715_14: bool = ((s_715_11) == (s_715_13));
        // N s_715_15: branch s_715_14 b2598 b716
        if s_715_14 {
            return block_2598(state, tracer, fn_state);
        } else {
            return block_716(state, tracer, fn_state);
        };
    }
    fn block_716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_716_0: const #0u : u8
        let s_716_0: bool = false;
        // D s_716_1: write-var gs#400044 <= s_716_0
        fn_state.gs_400044 = s_716_0;
        // N s_716_2: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_717_0: read-var gs#400044:u8
        let s_717_0: bool = fn_state.gs_400044;
        // N s_717_1: branch s_717_0 b2597 b718
        if s_717_0 {
            return block_2597(state, tracer, fn_state);
        } else {
            return block_718(state, tracer, fn_state);
        };
    }
    fn block_718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_718_0: const #0u : u8
        let s_718_0: bool = false;
        // D s_718_1: write-var gs#400046 <= s_718_0
        fn_state.gs_400046 = s_718_0;
        // N s_718_2: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_719_0: read-var gs#400046:u8
        let s_719_0: bool = fn_state.gs_400046;
        // D s_719_1: not s_719_0
        let s_719_1: bool = !s_719_0;
        // N s_719_2: branch s_719_1 b721 b720
        if s_719_1 {
            return block_721(state, tracer, fn_state);
        } else {
            return block_720(state, tracer, fn_state);
        };
    }
    fn block_720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_720_0: const #3529s : i
        let s_720_0: i128 = 3529;
        // C s_720_1: const #14696u : u32
        let s_720_1: u32 = 14696;
        // N s_720_2: write-reg s_720_1 <= s_720_0
        let s_720_2: () = {
            state.write_register::<i128>(s_720_1 as isize, s_720_0);
            tracer.write_register(s_720_1 as isize, s_720_0);
        };
        // C s_720_3: const #24s : i
        let s_720_3: i128 = 24;
        // C s_720_4: const #1s : i
        let s_720_4: i128 = 1;
        // D s_720_5: read-var u#31239:u32
        let s_720_5: u32 = fn_state.u_31239;
        // D s_720_6: cast zx s_720_5 -> bv
        let s_720_6: Bits = Bits::new(s_720_5 as u128, 32u16);
        // D s_720_7: bit-extract s_720_6 s_720_3 s_720_4
        let s_720_7: Bits = (Bits::new(
            ((s_720_6) >> (s_720_3)).value(),
            u16::try_from(s_720_4).unwrap(),
        ));
        // D s_720_8: cast reint s_720_7 -> u8
        let s_720_8: bool = ((s_720_7.value()) != 0);
        // C s_720_9: const #22s : i
        let s_720_9: i128 = 22;
        // C s_720_10: const #1s : i
        let s_720_10: i128 = 1;
        // D s_720_11: read-var u#31239:u32
        let s_720_11: u32 = fn_state.u_31239;
        // D s_720_12: cast zx s_720_11 -> bv
        let s_720_12: Bits = Bits::new(s_720_11 as u128, 32u16);
        // D s_720_13: bit-extract s_720_12 s_720_9 s_720_10
        let s_720_13: Bits = (Bits::new(
            ((s_720_12) >> (s_720_9)).value(),
            u16::try_from(s_720_10).unwrap(),
        ));
        // D s_720_14: cast reint s_720_13 -> u8
        let s_720_14: bool = ((s_720_13.value()) != 0);
        // C s_720_15: const #16s : i
        let s_720_15: i128 = 16;
        // C s_720_16: const #3s : i
        let s_720_16: i128 = 3;
        // D s_720_17: read-var u#31239:u32
        let s_720_17: u32 = fn_state.u_31239;
        // D s_720_18: cast zx s_720_17 -> bv
        let s_720_18: Bits = Bits::new(s_720_17 as u128, 32u16);
        // D s_720_19: bit-extract s_720_18 s_720_15 s_720_16
        let s_720_19: Bits = (Bits::new(
            ((s_720_18) >> (s_720_15)).value(),
            u16::try_from(s_720_16).unwrap(),
        ));
        // D s_720_20: cast reint s_720_19 -> u8
        let s_720_20: u8 = (s_720_19.value() as u8);
        // C s_720_21: const #12s : i
        let s_720_21: i128 = 12;
        // C s_720_22: const #4s : i
        let s_720_22: i128 = 4;
        // D s_720_23: read-var u#31239:u32
        let s_720_23: u32 = fn_state.u_31239;
        // D s_720_24: cast zx s_720_23 -> bv
        let s_720_24: Bits = Bits::new(s_720_23 as u128, 32u16);
        // D s_720_25: bit-extract s_720_24 s_720_21 s_720_22
        let s_720_25: Bits = (Bits::new(
            ((s_720_24) >> (s_720_21)).value(),
            u16::try_from(s_720_22).unwrap(),
        ));
        // D s_720_26: cast reint s_720_25 -> u8
        let s_720_26: u8 = (s_720_25.value() as u8);
        // C s_720_27: const #8s : i
        let s_720_27: i128 = 8;
        // C s_720_28: const #4s : i
        let s_720_28: i128 = 4;
        // D s_720_29: read-var u#31239:u32
        let s_720_29: u32 = fn_state.u_31239;
        // D s_720_30: cast zx s_720_29 -> bv
        let s_720_30: Bits = Bits::new(s_720_29 as u128, 32u16);
        // D s_720_31: bit-extract s_720_30 s_720_27 s_720_28
        let s_720_31: Bits = (Bits::new(
            ((s_720_30) >> (s_720_27)).value(),
            u16::try_from(s_720_28).unwrap(),
        ));
        // D s_720_32: cast reint s_720_31 -> u8
        let s_720_32: u8 = (s_720_31.value() as u8);
        // C s_720_33: const #6s : i
        let s_720_33: i128 = 6;
        // C s_720_34: const #1s : i
        let s_720_34: i128 = 1;
        // D s_720_35: read-var u#31239:u32
        let s_720_35: u32 = fn_state.u_31239;
        // D s_720_36: cast zx s_720_35 -> bv
        let s_720_36: Bits = Bits::new(s_720_35 as u128, 32u16);
        // D s_720_37: bit-extract s_720_36 s_720_33 s_720_34
        let s_720_37: Bits = (Bits::new(
            ((s_720_36) >> (s_720_33)).value(),
            u16::try_from(s_720_34).unwrap(),
        ));
        // D s_720_38: cast reint s_720_37 -> u8
        let s_720_38: bool = ((s_720_37.value()) != 0);
        // C s_720_39: const #5s : i
        let s_720_39: i128 = 5;
        // C s_720_40: const #1s : i
        let s_720_40: i128 = 1;
        // D s_720_41: read-var u#31239:u32
        let s_720_41: u32 = fn_state.u_31239;
        // D s_720_42: cast zx s_720_41 -> bv
        let s_720_42: Bits = Bits::new(s_720_41 as u128, 32u16);
        // D s_720_43: bit-extract s_720_42 s_720_39 s_720_40
        let s_720_43: Bits = (Bits::new(
            ((s_720_42) >> (s_720_39)).value(),
            u16::try_from(s_720_40).unwrap(),
        ));
        // D s_720_44: cast reint s_720_43 -> u8
        let s_720_44: bool = ((s_720_43.value()) != 0);
        // C s_720_45: const #0s : i
        let s_720_45: i128 = 0;
        // C s_720_46: const #4s : i
        let s_720_46: i128 = 4;
        // D s_720_47: read-var u#31239:u32
        let s_720_47: u32 = fn_state.u_31239;
        // D s_720_48: cast zx s_720_47 -> bv
        let s_720_48: Bits = Bits::new(s_720_47 as u128, 32u16);
        // D s_720_49: bit-extract s_720_48 s_720_45 s_720_46
        let s_720_49: Bits = (Bits::new(
            ((s_720_48) >> (s_720_45)).value(),
            u16::try_from(s_720_46).unwrap(),
        ));
        // D s_720_50: cast reint s_720_49 -> u8
        let s_720_50: u8 = (s_720_49.value() as u8);
        // D s_720_51: call decode_aarch32_instrs_VMOV_i_A4enc_A_txt(s_720_8, s_720_14, s_720_20, s_720_26, s_720_32, s_720_38, s_720_44, s_720_50)
        let s_720_51: () = decode_aarch32_instrs_VMOV_i_A4enc_A_txt(
            state,
            tracer,
            s_720_8,
            s_720_14,
            s_720_20,
            s_720_26,
            s_720_32,
            s_720_38,
            s_720_44,
            s_720_50,
        );
        // N s_720_52: return
        return;
    }
    fn block_721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_721_0: read-var merge#var.1:struct
        let s_721_0: u32 = fn_state.merge_var._1;
        // D s_721_1: write-var u#31249 <= s_721_0
        fn_state.u_31249 = s_721_0;
        // C s_721_2: const #25s : i
        let s_721_2: i128 = 25;
        // D s_721_3: read-var u#31249:u32
        let s_721_3: u32 = fn_state.u_31249;
        // D s_721_4: cast zx s_721_3 -> bv
        let s_721_4: Bits = Bits::new(s_721_3 as u128, 32u16);
        // C s_721_5: const #1s : i64
        let s_721_5: i64 = 1;
        // C s_721_6: cast zx s_721_5 -> i
        let s_721_6: i128 = (i128::try_from(s_721_5).unwrap());
        // C s_721_7: const #6s : i
        let s_721_7: i128 = 6;
        // C s_721_8: add s_721_7 s_721_6
        let s_721_8: i128 = (s_721_7 + s_721_6);
        // D s_721_9: bit-extract s_721_4 s_721_2 s_721_8
        let s_721_9: Bits = (Bits::new(
            ((s_721_4) >> (s_721_2)).value(),
            u16::try_from(s_721_8).unwrap(),
        ));
        // D s_721_10: cast reint s_721_9 -> u8
        let s_721_10: u8 = (s_721_9.value() as u8);
        // D s_721_11: cast zx s_721_10 -> bv
        let s_721_11: Bits = Bits::new(s_721_10 as u128, 7u16);
        // C s_721_12: const #121u : u8
        let s_721_12: u8 = 121;
        // C s_721_13: cast zx s_721_12 -> bv
        let s_721_13: Bits = Bits::new(s_721_12 as u128, 7u16);
        // D s_721_14: cmp-eq s_721_11 s_721_13
        let s_721_14: bool = ((s_721_11) == (s_721_13));
        // N s_721_15: branch s_721_14 b2587 b722
        if s_721_14 {
            return block_2587(state, tracer, fn_state);
        } else {
            return block_722(state, tracer, fn_state);
        };
    }
    fn block_722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_722_0: const #0u : u8
        let s_722_0: bool = false;
        // D s_722_1: write-var gs#400079 <= s_722_0
        fn_state.gs_400079 = s_722_0;
        // N s_722_2: jump b723
        return block_723(state, tracer, fn_state);
    }
    fn block_723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_723_0: read-var gs#400079:u8
        let s_723_0: bool = fn_state.gs_400079;
        // N s_723_1: branch s_723_0 b2586 b724
        if s_723_0 {
            return block_2586(state, tracer, fn_state);
        } else {
            return block_724(state, tracer, fn_state);
        };
    }
    fn block_724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_724_0: const #0u : u8
        let s_724_0: bool = false;
        // D s_724_1: write-var gs#400081 <= s_724_0
        fn_state.gs_400081 = s_724_0;
        // N s_724_2: jump b725
        return block_725(state, tracer, fn_state);
    }
    fn block_725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_725_0: read-var gs#400081:u8
        let s_725_0: bool = fn_state.gs_400081;
        // D s_725_1: not s_725_0
        let s_725_1: bool = !s_725_0;
        // N s_725_2: branch s_725_1 b727 b726
        if s_725_1 {
            return block_727(state, tracer, fn_state);
        } else {
            return block_726(state, tracer, fn_state);
        };
    }
    fn block_726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_726_0: const #3530s : i
        let s_726_0: i128 = 3530;
        // C s_726_1: const #14696u : u32
        let s_726_1: u32 = 14696;
        // N s_726_2: write-reg s_726_1 <= s_726_0
        let s_726_2: () = {
            state.write_register::<i128>(s_726_1 as isize, s_726_0);
            tracer.write_register(s_726_1 as isize, s_726_0);
        };
        // C s_726_3: const #24s : i
        let s_726_3: i128 = 24;
        // C s_726_4: const #1s : i
        let s_726_4: i128 = 1;
        // D s_726_5: read-var u#31249:u32
        let s_726_5: u32 = fn_state.u_31249;
        // D s_726_6: cast zx s_726_5 -> bv
        let s_726_6: Bits = Bits::new(s_726_5 as u128, 32u16);
        // D s_726_7: bit-extract s_726_6 s_726_3 s_726_4
        let s_726_7: Bits = (Bits::new(
            ((s_726_6) >> (s_726_3)).value(),
            u16::try_from(s_726_4).unwrap(),
        ));
        // D s_726_8: cast reint s_726_7 -> u8
        let s_726_8: bool = ((s_726_7.value()) != 0);
        // C s_726_9: const #22s : i
        let s_726_9: i128 = 22;
        // C s_726_10: const #1s : i
        let s_726_10: i128 = 1;
        // D s_726_11: read-var u#31249:u32
        let s_726_11: u32 = fn_state.u_31249;
        // D s_726_12: cast zx s_726_11 -> bv
        let s_726_12: Bits = Bits::new(s_726_11 as u128, 32u16);
        // D s_726_13: bit-extract s_726_12 s_726_9 s_726_10
        let s_726_13: Bits = (Bits::new(
            ((s_726_12) >> (s_726_9)).value(),
            u16::try_from(s_726_10).unwrap(),
        ));
        // D s_726_14: cast reint s_726_13 -> u8
        let s_726_14: bool = ((s_726_13.value()) != 0);
        // C s_726_15: const #16s : i
        let s_726_15: i128 = 16;
        // C s_726_16: const #3s : i
        let s_726_16: i128 = 3;
        // D s_726_17: read-var u#31249:u32
        let s_726_17: u32 = fn_state.u_31249;
        // D s_726_18: cast zx s_726_17 -> bv
        let s_726_18: Bits = Bits::new(s_726_17 as u128, 32u16);
        // D s_726_19: bit-extract s_726_18 s_726_15 s_726_16
        let s_726_19: Bits = (Bits::new(
            ((s_726_18) >> (s_726_15)).value(),
            u16::try_from(s_726_16).unwrap(),
        ));
        // D s_726_20: cast reint s_726_19 -> u8
        let s_726_20: u8 = (s_726_19.value() as u8);
        // C s_726_21: const #12s : i
        let s_726_21: i128 = 12;
        // C s_726_22: const #4s : i
        let s_726_22: i128 = 4;
        // D s_726_23: read-var u#31249:u32
        let s_726_23: u32 = fn_state.u_31249;
        // D s_726_24: cast zx s_726_23 -> bv
        let s_726_24: Bits = Bits::new(s_726_23 as u128, 32u16);
        // D s_726_25: bit-extract s_726_24 s_726_21 s_726_22
        let s_726_25: Bits = (Bits::new(
            ((s_726_24) >> (s_726_21)).value(),
            u16::try_from(s_726_22).unwrap(),
        ));
        // D s_726_26: cast reint s_726_25 -> u8
        let s_726_26: u8 = (s_726_25.value() as u8);
        // C s_726_27: const #8s : i
        let s_726_27: i128 = 8;
        // C s_726_28: const #4s : i
        let s_726_28: i128 = 4;
        // D s_726_29: read-var u#31249:u32
        let s_726_29: u32 = fn_state.u_31249;
        // D s_726_30: cast zx s_726_29 -> bv
        let s_726_30: Bits = Bits::new(s_726_29 as u128, 32u16);
        // D s_726_31: bit-extract s_726_30 s_726_27 s_726_28
        let s_726_31: Bits = (Bits::new(
            ((s_726_30) >> (s_726_27)).value(),
            u16::try_from(s_726_28).unwrap(),
        ));
        // D s_726_32: cast reint s_726_31 -> u8
        let s_726_32: u8 = (s_726_31.value() as u8);
        // C s_726_33: const #6s : i
        let s_726_33: i128 = 6;
        // C s_726_34: const #1s : i
        let s_726_34: i128 = 1;
        // D s_726_35: read-var u#31249:u32
        let s_726_35: u32 = fn_state.u_31249;
        // D s_726_36: cast zx s_726_35 -> bv
        let s_726_36: Bits = Bits::new(s_726_35 as u128, 32u16);
        // D s_726_37: bit-extract s_726_36 s_726_33 s_726_34
        let s_726_37: Bits = (Bits::new(
            ((s_726_36) >> (s_726_33)).value(),
            u16::try_from(s_726_34).unwrap(),
        ));
        // D s_726_38: cast reint s_726_37 -> u8
        let s_726_38: bool = ((s_726_37.value()) != 0);
        // C s_726_39: const #5s : i
        let s_726_39: i128 = 5;
        // C s_726_40: const #1s : i
        let s_726_40: i128 = 1;
        // D s_726_41: read-var u#31249:u32
        let s_726_41: u32 = fn_state.u_31249;
        // D s_726_42: cast zx s_726_41 -> bv
        let s_726_42: Bits = Bits::new(s_726_41 as u128, 32u16);
        // D s_726_43: bit-extract s_726_42 s_726_39 s_726_40
        let s_726_43: Bits = (Bits::new(
            ((s_726_42) >> (s_726_39)).value(),
            u16::try_from(s_726_40).unwrap(),
        ));
        // D s_726_44: cast reint s_726_43 -> u8
        let s_726_44: bool = ((s_726_43.value()) != 0);
        // C s_726_45: const #0s : i
        let s_726_45: i128 = 0;
        // C s_726_46: const #4s : i
        let s_726_46: i128 = 4;
        // D s_726_47: read-var u#31249:u32
        let s_726_47: u32 = fn_state.u_31249;
        // D s_726_48: cast zx s_726_47 -> bv
        let s_726_48: Bits = Bits::new(s_726_47 as u128, 32u16);
        // D s_726_49: bit-extract s_726_48 s_726_45 s_726_46
        let s_726_49: Bits = (Bits::new(
            ((s_726_48) >> (s_726_45)).value(),
            u16::try_from(s_726_46).unwrap(),
        ));
        // D s_726_50: cast reint s_726_49 -> u8
        let s_726_50: u8 = (s_726_49.value() as u8);
        // D s_726_51: call decode_aarch32_instrs_VMOV_i_A5enc_A_txt(s_726_8, s_726_14, s_726_20, s_726_26, s_726_32, s_726_38, s_726_44, s_726_50)
        let s_726_51: () = decode_aarch32_instrs_VMOV_i_A5enc_A_txt(
            state,
            tracer,
            s_726_8,
            s_726_14,
            s_726_20,
            s_726_26,
            s_726_32,
            s_726_38,
            s_726_44,
            s_726_50,
        );
        // N s_726_52: return
        return;
    }
    fn block_727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_727_0: read-var merge#var.1:struct
        let s_727_0: u32 = fn_state.merge_var._1;
        // D s_727_1: write-var u#31259 <= s_727_0
        fn_state.u_31259 = s_727_0;
        // C s_727_2: const #25s : i
        let s_727_2: i128 = 25;
        // D s_727_3: read-var u#31259:u32
        let s_727_3: u32 = fn_state.u_31259;
        // D s_727_4: cast zx s_727_3 -> bv
        let s_727_4: Bits = Bits::new(s_727_3 as u128, 32u16);
        // C s_727_5: const #1s : i64
        let s_727_5: i64 = 1;
        // C s_727_6: cast zx s_727_5 -> i
        let s_727_6: i128 = (i128::try_from(s_727_5).unwrap());
        // C s_727_7: const #6s : i
        let s_727_7: i128 = 6;
        // C s_727_8: add s_727_7 s_727_6
        let s_727_8: i128 = (s_727_7 + s_727_6);
        // D s_727_9: bit-extract s_727_4 s_727_2 s_727_8
        let s_727_9: Bits = (Bits::new(
            ((s_727_4) >> (s_727_2)).value(),
            u16::try_from(s_727_8).unwrap(),
        ));
        // D s_727_10: cast reint s_727_9 -> u8
        let s_727_10: u8 = (s_727_9.value() as u8);
        // D s_727_11: cast zx s_727_10 -> bv
        let s_727_11: Bits = Bits::new(s_727_10 as u128, 7u16);
        // C s_727_12: const #121u : u8
        let s_727_12: u8 = 121;
        // C s_727_13: cast zx s_727_12 -> bv
        let s_727_13: Bits = Bits::new(s_727_12 as u128, 7u16);
        // D s_727_14: cmp-eq s_727_11 s_727_13
        let s_727_14: bool = ((s_727_11) == (s_727_13));
        // N s_727_15: branch s_727_14 b2576 b728
        if s_727_14 {
            return block_2576(state, tracer, fn_state);
        } else {
            return block_728(state, tracer, fn_state);
        };
    }
    fn block_728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_728_0: const #0u : u8
        let s_728_0: bool = false;
        // D s_728_1: write-var gs#400114 <= s_728_0
        fn_state.gs_400114 = s_728_0;
        // N s_728_2: jump b729
        return block_729(state, tracer, fn_state);
    }
    fn block_729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_729_0: read-var gs#400114:u8
        let s_729_0: bool = fn_state.gs_400114;
        // N s_729_1: branch s_729_0 b2575 b730
        if s_729_0 {
            return block_2575(state, tracer, fn_state);
        } else {
            return block_730(state, tracer, fn_state);
        };
    }
    fn block_730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_730_0: const #0u : u8
        let s_730_0: bool = false;
        // D s_730_1: write-var gs#400116 <= s_730_0
        fn_state.gs_400116 = s_730_0;
        // N s_730_2: jump b731
        return block_731(state, tracer, fn_state);
    }
    fn block_731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_731_0: read-var gs#400116:u8
        let s_731_0: bool = fn_state.gs_400116;
        // D s_731_1: not s_731_0
        let s_731_1: bool = !s_731_0;
        // N s_731_2: branch s_731_1 b733 b732
        if s_731_1 {
            return block_733(state, tracer, fn_state);
        } else {
            return block_732(state, tracer, fn_state);
        };
    }
    fn block_732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_732_0: const #3536s : i
        let s_732_0: i128 = 3536;
        // C s_732_1: const #14696u : u32
        let s_732_1: u32 = 14696;
        // N s_732_2: write-reg s_732_1 <= s_732_0
        let s_732_2: () = {
            state.write_register::<i128>(s_732_1 as isize, s_732_0);
            tracer.write_register(s_732_1 as isize, s_732_0);
        };
        // C s_732_3: const #24s : i
        let s_732_3: i128 = 24;
        // C s_732_4: const #1s : i
        let s_732_4: i128 = 1;
        // D s_732_5: read-var u#31259:u32
        let s_732_5: u32 = fn_state.u_31259;
        // D s_732_6: cast zx s_732_5 -> bv
        let s_732_6: Bits = Bits::new(s_732_5 as u128, 32u16);
        // D s_732_7: bit-extract s_732_6 s_732_3 s_732_4
        let s_732_7: Bits = (Bits::new(
            ((s_732_6) >> (s_732_3)).value(),
            u16::try_from(s_732_4).unwrap(),
        ));
        // D s_732_8: cast reint s_732_7 -> u8
        let s_732_8: bool = ((s_732_7.value()) != 0);
        // C s_732_9: const #22s : i
        let s_732_9: i128 = 22;
        // C s_732_10: const #1s : i
        let s_732_10: i128 = 1;
        // D s_732_11: read-var u#31259:u32
        let s_732_11: u32 = fn_state.u_31259;
        // D s_732_12: cast zx s_732_11 -> bv
        let s_732_12: Bits = Bits::new(s_732_11 as u128, 32u16);
        // D s_732_13: bit-extract s_732_12 s_732_9 s_732_10
        let s_732_13: Bits = (Bits::new(
            ((s_732_12) >> (s_732_9)).value(),
            u16::try_from(s_732_10).unwrap(),
        ));
        // D s_732_14: cast reint s_732_13 -> u8
        let s_732_14: bool = ((s_732_13.value()) != 0);
        // C s_732_15: const #19s : i
        let s_732_15: i128 = 19;
        // C s_732_16: const #3s : i
        let s_732_16: i128 = 3;
        // D s_732_17: read-var u#31259:u32
        let s_732_17: u32 = fn_state.u_31259;
        // D s_732_18: cast zx s_732_17 -> bv
        let s_732_18: Bits = Bits::new(s_732_17 as u128, 32u16);
        // D s_732_19: bit-extract s_732_18 s_732_15 s_732_16
        let s_732_19: Bits = (Bits::new(
            ((s_732_18) >> (s_732_15)).value(),
            u16::try_from(s_732_16).unwrap(),
        ));
        // D s_732_20: cast reint s_732_19 -> u8
        let s_732_20: u8 = (s_732_19.value() as u8);
        // C s_732_21: const #12s : i
        let s_732_21: i128 = 12;
        // C s_732_22: const #4s : i
        let s_732_22: i128 = 4;
        // D s_732_23: read-var u#31259:u32
        let s_732_23: u32 = fn_state.u_31259;
        // D s_732_24: cast zx s_732_23 -> bv
        let s_732_24: Bits = Bits::new(s_732_23 as u128, 32u16);
        // D s_732_25: bit-extract s_732_24 s_732_21 s_732_22
        let s_732_25: Bits = (Bits::new(
            ((s_732_24) >> (s_732_21)).value(),
            u16::try_from(s_732_22).unwrap(),
        ));
        // D s_732_26: cast reint s_732_25 -> u8
        let s_732_26: u8 = (s_732_25.value() as u8);
        // C s_732_27: const #5s : i
        let s_732_27: i128 = 5;
        // C s_732_28: const #1s : i
        let s_732_28: i128 = 1;
        // D s_732_29: read-var u#31259:u32
        let s_732_29: u32 = fn_state.u_31259;
        // D s_732_30: cast zx s_732_29 -> bv
        let s_732_30: Bits = Bits::new(s_732_29 as u128, 32u16);
        // D s_732_31: bit-extract s_732_30 s_732_27 s_732_28
        let s_732_31: Bits = (Bits::new(
            ((s_732_30) >> (s_732_27)).value(),
            u16::try_from(s_732_28).unwrap(),
        ));
        // D s_732_32: cast reint s_732_31 -> u8
        let s_732_32: bool = ((s_732_31.value()) != 0);
        // C s_732_33: const #0s : i
        let s_732_33: i128 = 0;
        // C s_732_34: const #4s : i
        let s_732_34: i128 = 4;
        // D s_732_35: read-var u#31259:u32
        let s_732_35: u32 = fn_state.u_31259;
        // D s_732_36: cast zx s_732_35 -> bv
        let s_732_36: Bits = Bits::new(s_732_35 as u128, 32u16);
        // D s_732_37: bit-extract s_732_36 s_732_33 s_732_34
        let s_732_37: Bits = (Bits::new(
            ((s_732_36) >> (s_732_33)).value(),
            u16::try_from(s_732_34).unwrap(),
        ));
        // D s_732_38: cast reint s_732_37 -> u8
        let s_732_38: u8 = (s_732_37.value() as u8);
        // D s_732_39: call decode_aarch32_instrs_VMOVL_A1enc_A_txt(s_732_8, s_732_14, s_732_20, s_732_26, s_732_32, s_732_38)
        let s_732_39: () = decode_aarch32_instrs_VMOVL_A1enc_A_txt(
            state,
            tracer,
            s_732_8,
            s_732_14,
            s_732_20,
            s_732_26,
            s_732_32,
            s_732_38,
        );
        // N s_732_40: return
        return;
    }
    fn block_733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_733_0: read-var merge#var.1:struct
        let s_733_0: u32 = fn_state.merge_var._1;
        // D s_733_1: write-var u#31266 <= s_733_0
        fn_state.u_31266 = s_733_0;
        // C s_733_2: const #23s : i
        let s_733_2: i128 = 23;
        // D s_733_3: read-var u#31266:u32
        let s_733_3: u32 = fn_state.u_31266;
        // D s_733_4: cast zx s_733_3 -> bv
        let s_733_4: Bits = Bits::new(s_733_3 as u128, 32u16);
        // C s_733_5: const #1s : i64
        let s_733_5: i64 = 1;
        // C s_733_6: cast zx s_733_5 -> i
        let s_733_6: i128 = (i128::try_from(s_733_5).unwrap());
        // C s_733_7: const #8s : i
        let s_733_7: i128 = 8;
        // C s_733_8: add s_733_7 s_733_6
        let s_733_8: i128 = (s_733_7 + s_733_6);
        // D s_733_9: bit-extract s_733_4 s_733_2 s_733_8
        let s_733_9: Bits = (Bits::new(
            ((s_733_4) >> (s_733_2)).value(),
            u16::try_from(s_733_8).unwrap(),
        ));
        // D s_733_10: cast reint s_733_9 -> u9
        let s_733_10: u16 = (s_733_9.value() as u16);
        // D s_733_11: cast zx s_733_10 -> bv
        let s_733_11: Bits = Bits::new(s_733_10 as u128, 9u16);
        // C s_733_12: const #487u : u9
        let s_733_12: u16 = 487;
        // C s_733_13: cast zx s_733_12 -> bv
        let s_733_13: Bits = Bits::new(s_733_12 as u128, 9u16);
        // D s_733_14: cmp-eq s_733_11 s_733_13
        let s_733_14: bool = ((s_733_11) == (s_733_13));
        // N s_733_15: branch s_733_14 b2565 b734
        if s_733_14 {
            return block_2565(state, tracer, fn_state);
        } else {
            return block_734(state, tracer, fn_state);
        };
    }
    fn block_734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_734_0: const #0u : u8
        let s_734_0: bool = false;
        // D s_734_1: write-var gs#400145 <= s_734_0
        fn_state.gs_400145 = s_734_0;
        // N s_734_2: jump b735
        return block_735(state, tracer, fn_state);
    }
    fn block_735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_735_0: read-var gs#400145:u8
        let s_735_0: bool = fn_state.gs_400145;
        // N s_735_1: branch s_735_0 b2564 b736
        if s_735_0 {
            return block_2564(state, tracer, fn_state);
        } else {
            return block_736(state, tracer, fn_state);
        };
    }
    fn block_736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_736_0: const #0u : u8
        let s_736_0: bool = false;
        // D s_736_1: write-var gs#400147 <= s_736_0
        fn_state.gs_400147 = s_736_0;
        // N s_736_2: jump b737
        return block_737(state, tracer, fn_state);
    }
    fn block_737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_737_0: read-var gs#400147:u8
        let s_737_0: bool = fn_state.gs_400147;
        // D s_737_1: not s_737_0
        let s_737_1: bool = !s_737_0;
        // N s_737_2: branch s_737_1 b739 b738
        if s_737_1 {
            return block_739(state, tracer, fn_state);
        } else {
            return block_738(state, tracer, fn_state);
        };
    }
    fn block_738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_738_0: const #3538s : i
        let s_738_0: i128 = 3538;
        // C s_738_1: const #14696u : u32
        let s_738_1: u32 = 14696;
        // N s_738_2: write-reg s_738_1 <= s_738_0
        let s_738_2: () = {
            state.write_register::<i128>(s_738_1 as isize, s_738_0);
            tracer.write_register(s_738_1 as isize, s_738_0);
        };
        // C s_738_3: const #22s : i
        let s_738_3: i128 = 22;
        // C s_738_4: const #1s : i
        let s_738_4: i128 = 1;
        // D s_738_5: read-var u#31266:u32
        let s_738_5: u32 = fn_state.u_31266;
        // D s_738_6: cast zx s_738_5 -> bv
        let s_738_6: Bits = Bits::new(s_738_5 as u128, 32u16);
        // D s_738_7: bit-extract s_738_6 s_738_3 s_738_4
        let s_738_7: Bits = (Bits::new(
            ((s_738_6) >> (s_738_3)).value(),
            u16::try_from(s_738_4).unwrap(),
        ));
        // D s_738_8: cast reint s_738_7 -> u8
        let s_738_8: bool = ((s_738_7.value()) != 0);
        // C s_738_9: const #18s : i
        let s_738_9: i128 = 18;
        // C s_738_10: const #2s : i
        let s_738_10: i128 = 2;
        // D s_738_11: read-var u#31266:u32
        let s_738_11: u32 = fn_state.u_31266;
        // D s_738_12: cast zx s_738_11 -> bv
        let s_738_12: Bits = Bits::new(s_738_11 as u128, 32u16);
        // D s_738_13: bit-extract s_738_12 s_738_9 s_738_10
        let s_738_13: Bits = (Bits::new(
            ((s_738_12) >> (s_738_9)).value(),
            u16::try_from(s_738_10).unwrap(),
        ));
        // D s_738_14: cast reint s_738_13 -> u8
        let s_738_14: u8 = (s_738_13.value() as u8);
        // C s_738_15: const #12s : i
        let s_738_15: i128 = 12;
        // C s_738_16: const #4s : i
        let s_738_16: i128 = 4;
        // D s_738_17: read-var u#31266:u32
        let s_738_17: u32 = fn_state.u_31266;
        // D s_738_18: cast zx s_738_17 -> bv
        let s_738_18: Bits = Bits::new(s_738_17 as u128, 32u16);
        // D s_738_19: bit-extract s_738_18 s_738_15 s_738_16
        let s_738_19: Bits = (Bits::new(
            ((s_738_18) >> (s_738_15)).value(),
            u16::try_from(s_738_16).unwrap(),
        ));
        // D s_738_20: cast reint s_738_19 -> u8
        let s_738_20: u8 = (s_738_19.value() as u8);
        // C s_738_21: const #5s : i
        let s_738_21: i128 = 5;
        // C s_738_22: const #1s : i
        let s_738_22: i128 = 1;
        // D s_738_23: read-var u#31266:u32
        let s_738_23: u32 = fn_state.u_31266;
        // D s_738_24: cast zx s_738_23 -> bv
        let s_738_24: Bits = Bits::new(s_738_23 as u128, 32u16);
        // D s_738_25: bit-extract s_738_24 s_738_21 s_738_22
        let s_738_25: Bits = (Bits::new(
            ((s_738_24) >> (s_738_21)).value(),
            u16::try_from(s_738_22).unwrap(),
        ));
        // D s_738_26: cast reint s_738_25 -> u8
        let s_738_26: bool = ((s_738_25.value()) != 0);
        // C s_738_27: const #0s : i
        let s_738_27: i128 = 0;
        // C s_738_28: const #4s : i
        let s_738_28: i128 = 4;
        // D s_738_29: read-var u#31266:u32
        let s_738_29: u32 = fn_state.u_31266;
        // D s_738_30: cast zx s_738_29 -> bv
        let s_738_30: Bits = Bits::new(s_738_29 as u128, 32u16);
        // D s_738_31: bit-extract s_738_30 s_738_27 s_738_28
        let s_738_31: Bits = (Bits::new(
            ((s_738_30) >> (s_738_27)).value(),
            u16::try_from(s_738_28).unwrap(),
        ));
        // D s_738_32: cast reint s_738_31 -> u8
        let s_738_32: u8 = (s_738_31.value() as u8);
        // D s_738_33: call decode_aarch32_instrs_VMOVN_A1enc_A_txt(s_738_8, s_738_14, s_738_20, s_738_26, s_738_32)
        let s_738_33: () = decode_aarch32_instrs_VMOVN_A1enc_A_txt(
            state,
            tracer,
            s_738_8,
            s_738_14,
            s_738_20,
            s_738_26,
            s_738_32,
        );
        // N s_738_34: return
        return;
    }
    fn block_739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_739_0: read-var merge#var.1:struct
        let s_739_0: u32 = fn_state.merge_var._1;
        // D s_739_1: write-var u#31273 <= s_739_0
        fn_state.u_31273 = s_739_0;
        // C s_739_2: const #23s : i
        let s_739_2: i128 = 23;
        // D s_739_3: read-var u#31273:u32
        let s_739_3: u32 = fn_state.u_31273;
        // D s_739_4: cast zx s_739_3 -> bv
        let s_739_4: Bits = Bits::new(s_739_3 as u128, 32u16);
        // C s_739_5: const #1s : i64
        let s_739_5: i64 = 1;
        // C s_739_6: cast zx s_739_5 -> i
        let s_739_6: i128 = (i128::try_from(s_739_5).unwrap());
        // C s_739_7: const #8s : i
        let s_739_7: i128 = 8;
        // C s_739_8: add s_739_7 s_739_6
        let s_739_8: i128 = (s_739_7 + s_739_6);
        // D s_739_9: bit-extract s_739_4 s_739_2 s_739_8
        let s_739_9: Bits = (Bits::new(
            ((s_739_4) >> (s_739_2)).value(),
            u16::try_from(s_739_8).unwrap(),
        ));
        // D s_739_10: cast reint s_739_9 -> u9
        let s_739_10: u16 = (s_739_9.value() as u16);
        // D s_739_11: cast zx s_739_10 -> bv
        let s_739_11: Bits = Bits::new(s_739_10 as u128, 9u16);
        // C s_739_12: const #486u : u9
        let s_739_12: u16 = 486;
        // C s_739_13: cast zx s_739_12 -> bv
        let s_739_13: Bits = Bits::new(s_739_12 as u128, 9u16);
        // D s_739_14: cmp-eq s_739_11 s_739_13
        let s_739_14: bool = ((s_739_11) == (s_739_13));
        // N s_739_15: branch s_739_14 b2557 b740
        if s_739_14 {
            return block_2557(state, tracer, fn_state);
        } else {
            return block_740(state, tracer, fn_state);
        };
    }
    fn block_740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_740_0: const #0u : u8
        let s_740_0: bool = false;
        // D s_740_1: write-var gs#400171 <= s_740_0
        fn_state.gs_400171 = s_740_0;
        // N s_740_2: jump b741
        return block_741(state, tracer, fn_state);
    }
    fn block_741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_741_0: read-var gs#400171:u8
        let s_741_0: bool = fn_state.gs_400171;
        // N s_741_1: branch s_741_0 b2556 b742
        if s_741_0 {
            return block_2556(state, tracer, fn_state);
        } else {
            return block_742(state, tracer, fn_state);
        };
    }
    fn block_742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_742_0: const #0u : u8
        let s_742_0: bool = false;
        // D s_742_1: write-var gs#400173 <= s_742_0
        fn_state.gs_400173 = s_742_0;
        // N s_742_2: jump b743
        return block_743(state, tracer, fn_state);
    }
    fn block_743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_743_0: read-var gs#400173:u8
        let s_743_0: bool = fn_state.gs_400173;
        // D s_743_1: not s_743_0
        let s_743_1: bool = !s_743_0;
        // N s_743_2: branch s_743_1 b745 b744
        if s_743_1 {
            return block_745(state, tracer, fn_state);
        } else {
            return block_744(state, tracer, fn_state);
        };
    }
    fn block_744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_744_0: const #3552s : i
        let s_744_0: i128 = 3552;
        // C s_744_1: const #14696u : u32
        let s_744_1: u32 = 14696;
        // N s_744_2: write-reg s_744_1 <= s_744_0
        let s_744_2: () = {
            state.write_register::<i128>(s_744_1 as isize, s_744_0);
            tracer.write_register(s_744_1 as isize, s_744_0);
        };
        // C s_744_3: const #22s : i
        let s_744_3: i128 = 22;
        // C s_744_4: const #1s : i
        let s_744_4: i128 = 1;
        // D s_744_5: read-var u#31273:u32
        let s_744_5: u32 = fn_state.u_31273;
        // D s_744_6: cast zx s_744_5 -> bv
        let s_744_6: Bits = Bits::new(s_744_5 as u128, 32u16);
        // D s_744_7: bit-extract s_744_6 s_744_3 s_744_4
        let s_744_7: Bits = (Bits::new(
            ((s_744_6) >> (s_744_3)).value(),
            u16::try_from(s_744_4).unwrap(),
        ));
        // D s_744_8: cast reint s_744_7 -> u8
        let s_744_8: bool = ((s_744_7.value()) != 0);
        // C s_744_9: const #20s : i
        let s_744_9: i128 = 20;
        // C s_744_10: const #1s : i
        let s_744_10: i128 = 1;
        // D s_744_11: read-var u#31273:u32
        let s_744_11: u32 = fn_state.u_31273;
        // D s_744_12: cast zx s_744_11 -> bv
        let s_744_12: Bits = Bits::new(s_744_11 as u128, 32u16);
        // D s_744_13: bit-extract s_744_12 s_744_9 s_744_10
        let s_744_13: Bits = (Bits::new(
            ((s_744_12) >> (s_744_9)).value(),
            u16::try_from(s_744_10).unwrap(),
        ));
        // D s_744_14: cast reint s_744_13 -> u8
        let s_744_14: bool = ((s_744_13.value()) != 0);
        // C s_744_15: const #16s : i
        let s_744_15: i128 = 16;
        // C s_744_16: const #4s : i
        let s_744_16: i128 = 4;
        // D s_744_17: read-var u#31273:u32
        let s_744_17: u32 = fn_state.u_31273;
        // D s_744_18: cast zx s_744_17 -> bv
        let s_744_18: Bits = Bits::new(s_744_17 as u128, 32u16);
        // D s_744_19: bit-extract s_744_18 s_744_15 s_744_16
        let s_744_19: Bits = (Bits::new(
            ((s_744_18) >> (s_744_15)).value(),
            u16::try_from(s_744_16).unwrap(),
        ));
        // D s_744_20: cast reint s_744_19 -> u8
        let s_744_20: u8 = (s_744_19.value() as u8);
        // C s_744_21: const #12s : i
        let s_744_21: i128 = 12;
        // C s_744_22: const #4s : i
        let s_744_22: i128 = 4;
        // D s_744_23: read-var u#31273:u32
        let s_744_23: u32 = fn_state.u_31273;
        // D s_744_24: cast zx s_744_23 -> bv
        let s_744_24: Bits = Bits::new(s_744_23 as u128, 32u16);
        // D s_744_25: bit-extract s_744_24 s_744_21 s_744_22
        let s_744_25: Bits = (Bits::new(
            ((s_744_24) >> (s_744_21)).value(),
            u16::try_from(s_744_22).unwrap(),
        ));
        // D s_744_26: cast reint s_744_25 -> u8
        let s_744_26: u8 = (s_744_25.value() as u8);
        // C s_744_27: const #7s : i
        let s_744_27: i128 = 7;
        // C s_744_28: const #1s : i
        let s_744_28: i128 = 1;
        // D s_744_29: read-var u#31273:u32
        let s_744_29: u32 = fn_state.u_31273;
        // D s_744_30: cast zx s_744_29 -> bv
        let s_744_30: Bits = Bits::new(s_744_29 as u128, 32u16);
        // D s_744_31: bit-extract s_744_30 s_744_27 s_744_28
        let s_744_31: Bits = (Bits::new(
            ((s_744_30) >> (s_744_27)).value(),
            u16::try_from(s_744_28).unwrap(),
        ));
        // D s_744_32: cast reint s_744_31 -> u8
        let s_744_32: bool = ((s_744_31.value()) != 0);
        // C s_744_33: const #6s : i
        let s_744_33: i128 = 6;
        // C s_744_34: const #1s : i
        let s_744_34: i128 = 1;
        // D s_744_35: read-var u#31273:u32
        let s_744_35: u32 = fn_state.u_31273;
        // D s_744_36: cast zx s_744_35 -> bv
        let s_744_36: Bits = Bits::new(s_744_35 as u128, 32u16);
        // D s_744_37: bit-extract s_744_36 s_744_33 s_744_34
        let s_744_37: Bits = (Bits::new(
            ((s_744_36) >> (s_744_33)).value(),
            u16::try_from(s_744_34).unwrap(),
        ));
        // D s_744_38: cast reint s_744_37 -> u8
        let s_744_38: bool = ((s_744_37.value()) != 0);
        // C s_744_39: const #5s : i
        let s_744_39: i128 = 5;
        // C s_744_40: const #1s : i
        let s_744_40: i128 = 1;
        // D s_744_41: read-var u#31273:u32
        let s_744_41: u32 = fn_state.u_31273;
        // D s_744_42: cast zx s_744_41 -> bv
        let s_744_42: Bits = Bits::new(s_744_41 as u128, 32u16);
        // D s_744_43: bit-extract s_744_42 s_744_39 s_744_40
        let s_744_43: Bits = (Bits::new(
            ((s_744_42) >> (s_744_39)).value(),
            u16::try_from(s_744_40).unwrap(),
        ));
        // D s_744_44: cast reint s_744_43 -> u8
        let s_744_44: bool = ((s_744_43.value()) != 0);
        // C s_744_45: const #0s : i
        let s_744_45: i128 = 0;
        // C s_744_46: const #4s : i
        let s_744_46: i128 = 4;
        // D s_744_47: read-var u#31273:u32
        let s_744_47: u32 = fn_state.u_31273;
        // D s_744_48: cast zx s_744_47 -> bv
        let s_744_48: Bits = Bits::new(s_744_47 as u128, 32u16);
        // D s_744_49: bit-extract s_744_48 s_744_45 s_744_46
        let s_744_49: Bits = (Bits::new(
            ((s_744_48) >> (s_744_45)).value(),
            u16::try_from(s_744_46).unwrap(),
        ));
        // D s_744_50: cast reint s_744_49 -> u8
        let s_744_50: u8 = (s_744_49.value() as u8);
        // D s_744_51: call decode_aarch32_instrs_VMUL_f_A1enc_A_txt(s_744_8, s_744_14, s_744_20, s_744_26, s_744_32, s_744_38, s_744_44, s_744_50)
        let s_744_51: () = decode_aarch32_instrs_VMUL_f_A1enc_A_txt(
            state,
            tracer,
            s_744_8,
            s_744_14,
            s_744_20,
            s_744_26,
            s_744_32,
            s_744_38,
            s_744_44,
            s_744_50,
        );
        // N s_744_52: return
        return;
    }
    fn block_745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_745_0: read-var merge#var.1:struct
        let s_745_0: u32 = fn_state.merge_var._1;
        // D s_745_1: write-var u#31283 <= s_745_0
        fn_state.u_31283 = s_745_0;
        // C s_745_2: const #25s : i
        let s_745_2: i128 = 25;
        // D s_745_3: read-var u#31283:u32
        let s_745_3: u32 = fn_state.u_31283;
        // D s_745_4: cast zx s_745_3 -> bv
        let s_745_4: Bits = Bits::new(s_745_3 as u128, 32u16);
        // C s_745_5: const #1s : i64
        let s_745_5: i64 = 1;
        // C s_745_6: cast zx s_745_5 -> i
        let s_745_6: i128 = (i128::try_from(s_745_5).unwrap());
        // C s_745_7: const #6s : i
        let s_745_7: i128 = 6;
        // C s_745_8: add s_745_7 s_745_6
        let s_745_8: i128 = (s_745_7 + s_745_6);
        // D s_745_9: bit-extract s_745_4 s_745_2 s_745_8
        let s_745_9: Bits = (Bits::new(
            ((s_745_4) >> (s_745_2)).value(),
            u16::try_from(s_745_8).unwrap(),
        ));
        // D s_745_10: cast reint s_745_9 -> u8
        let s_745_10: u8 = (s_745_9.value() as u8);
        // D s_745_11: cast zx s_745_10 -> bv
        let s_745_11: Bits = Bits::new(s_745_10 as u128, 7u16);
        // C s_745_12: const #121u : u8
        let s_745_12: u8 = 121;
        // C s_745_13: cast zx s_745_12 -> bv
        let s_745_13: Bits = Bits::new(s_745_12 as u128, 7u16);
        // D s_745_14: cmp-eq s_745_11 s_745_13
        let s_745_14: bool = ((s_745_11) == (s_745_13));
        // N s_745_15: branch s_745_14 b2549 b746
        if s_745_14 {
            return block_2549(state, tracer, fn_state);
        } else {
            return block_746(state, tracer, fn_state);
        };
    }
    fn block_746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_746_0: const #0u : u8
        let s_746_0: bool = false;
        // D s_746_1: write-var gs#400203 <= s_746_0
        fn_state.gs_400203 = s_746_0;
        // N s_746_2: jump b747
        return block_747(state, tracer, fn_state);
    }
    fn block_747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_747_0: read-var gs#400203:u8
        let s_747_0: bool = fn_state.gs_400203;
        // N s_747_1: branch s_747_0 b2548 b748
        if s_747_0 {
            return block_2548(state, tracer, fn_state);
        } else {
            return block_748(state, tracer, fn_state);
        };
    }
    fn block_748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_748_0: const #0u : u8
        let s_748_0: bool = false;
        // D s_748_1: write-var gs#400205 <= s_748_0
        fn_state.gs_400205 = s_748_0;
        // N s_748_2: jump b749
        return block_749(state, tracer, fn_state);
    }
    fn block_749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_749_0: read-var gs#400205:u8
        let s_749_0: bool = fn_state.gs_400205;
        // D s_749_1: not s_749_0
        let s_749_1: bool = !s_749_0;
        // N s_749_2: branch s_749_1 b751 b750
        if s_749_1 {
            return block_751(state, tracer, fn_state);
        } else {
            return block_750(state, tracer, fn_state);
        };
    }
    fn block_750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_750_0: const #3556s : i
        let s_750_0: i128 = 3556;
        // C s_750_1: const #14696u : u32
        let s_750_1: u32 = 14696;
        // N s_750_2: write-reg s_750_1 <= s_750_0
        let s_750_2: () = {
            state.write_register::<i128>(s_750_1 as isize, s_750_0);
            tracer.write_register(s_750_1 as isize, s_750_0);
        };
        // C s_750_3: const #24s : i
        let s_750_3: i128 = 24;
        // C s_750_4: const #1s : i
        let s_750_4: i128 = 1;
        // D s_750_5: read-var u#31283:u32
        let s_750_5: u32 = fn_state.u_31283;
        // D s_750_6: cast zx s_750_5 -> bv
        let s_750_6: Bits = Bits::new(s_750_5 as u128, 32u16);
        // D s_750_7: bit-extract s_750_6 s_750_3 s_750_4
        let s_750_7: Bits = (Bits::new(
            ((s_750_6) >> (s_750_3)).value(),
            u16::try_from(s_750_4).unwrap(),
        ));
        // D s_750_8: cast reint s_750_7 -> u8
        let s_750_8: bool = ((s_750_7.value()) != 0);
        // C s_750_9: const #22s : i
        let s_750_9: i128 = 22;
        // C s_750_10: const #1s : i
        let s_750_10: i128 = 1;
        // D s_750_11: read-var u#31283:u32
        let s_750_11: u32 = fn_state.u_31283;
        // D s_750_12: cast zx s_750_11 -> bv
        let s_750_12: Bits = Bits::new(s_750_11 as u128, 32u16);
        // D s_750_13: bit-extract s_750_12 s_750_9 s_750_10
        let s_750_13: Bits = (Bits::new(
            ((s_750_12) >> (s_750_9)).value(),
            u16::try_from(s_750_10).unwrap(),
        ));
        // D s_750_14: cast reint s_750_13 -> u8
        let s_750_14: bool = ((s_750_13.value()) != 0);
        // C s_750_15: const #20s : i
        let s_750_15: i128 = 20;
        // C s_750_16: const #2s : i
        let s_750_16: i128 = 2;
        // D s_750_17: read-var u#31283:u32
        let s_750_17: u32 = fn_state.u_31283;
        // D s_750_18: cast zx s_750_17 -> bv
        let s_750_18: Bits = Bits::new(s_750_17 as u128, 32u16);
        // D s_750_19: bit-extract s_750_18 s_750_15 s_750_16
        let s_750_19: Bits = (Bits::new(
            ((s_750_18) >> (s_750_15)).value(),
            u16::try_from(s_750_16).unwrap(),
        ));
        // D s_750_20: cast reint s_750_19 -> u8
        let s_750_20: u8 = (s_750_19.value() as u8);
        // C s_750_21: const #16s : i
        let s_750_21: i128 = 16;
        // C s_750_22: const #4s : i
        let s_750_22: i128 = 4;
        // D s_750_23: read-var u#31283:u32
        let s_750_23: u32 = fn_state.u_31283;
        // D s_750_24: cast zx s_750_23 -> bv
        let s_750_24: Bits = Bits::new(s_750_23 as u128, 32u16);
        // D s_750_25: bit-extract s_750_24 s_750_21 s_750_22
        let s_750_25: Bits = (Bits::new(
            ((s_750_24) >> (s_750_21)).value(),
            u16::try_from(s_750_22).unwrap(),
        ));
        // D s_750_26: cast reint s_750_25 -> u8
        let s_750_26: u8 = (s_750_25.value() as u8);
        // C s_750_27: const #12s : i
        let s_750_27: i128 = 12;
        // C s_750_28: const #4s : i
        let s_750_28: i128 = 4;
        // D s_750_29: read-var u#31283:u32
        let s_750_29: u32 = fn_state.u_31283;
        // D s_750_30: cast zx s_750_29 -> bv
        let s_750_30: Bits = Bits::new(s_750_29 as u128, 32u16);
        // D s_750_31: bit-extract s_750_30 s_750_27 s_750_28
        let s_750_31: Bits = (Bits::new(
            ((s_750_30) >> (s_750_27)).value(),
            u16::try_from(s_750_28).unwrap(),
        ));
        // D s_750_32: cast reint s_750_31 -> u8
        let s_750_32: u8 = (s_750_31.value() as u8);
        // C s_750_33: const #7s : i
        let s_750_33: i128 = 7;
        // C s_750_34: const #1s : i
        let s_750_34: i128 = 1;
        // D s_750_35: read-var u#31283:u32
        let s_750_35: u32 = fn_state.u_31283;
        // D s_750_36: cast zx s_750_35 -> bv
        let s_750_36: Bits = Bits::new(s_750_35 as u128, 32u16);
        // D s_750_37: bit-extract s_750_36 s_750_33 s_750_34
        let s_750_37: Bits = (Bits::new(
            ((s_750_36) >> (s_750_33)).value(),
            u16::try_from(s_750_34).unwrap(),
        ));
        // D s_750_38: cast reint s_750_37 -> u8
        let s_750_38: bool = ((s_750_37.value()) != 0);
        // C s_750_39: const #6s : i
        let s_750_39: i128 = 6;
        // C s_750_40: const #1s : i
        let s_750_40: i128 = 1;
        // D s_750_41: read-var u#31283:u32
        let s_750_41: u32 = fn_state.u_31283;
        // D s_750_42: cast zx s_750_41 -> bv
        let s_750_42: Bits = Bits::new(s_750_41 as u128, 32u16);
        // D s_750_43: bit-extract s_750_42 s_750_39 s_750_40
        let s_750_43: Bits = (Bits::new(
            ((s_750_42) >> (s_750_39)).value(),
            u16::try_from(s_750_40).unwrap(),
        ));
        // D s_750_44: cast reint s_750_43 -> u8
        let s_750_44: bool = ((s_750_43.value()) != 0);
        // C s_750_45: const #5s : i
        let s_750_45: i128 = 5;
        // C s_750_46: const #1s : i
        let s_750_46: i128 = 1;
        // D s_750_47: read-var u#31283:u32
        let s_750_47: u32 = fn_state.u_31283;
        // D s_750_48: cast zx s_750_47 -> bv
        let s_750_48: Bits = Bits::new(s_750_47 as u128, 32u16);
        // D s_750_49: bit-extract s_750_48 s_750_45 s_750_46
        let s_750_49: Bits = (Bits::new(
            ((s_750_48) >> (s_750_45)).value(),
            u16::try_from(s_750_46).unwrap(),
        ));
        // D s_750_50: cast reint s_750_49 -> u8
        let s_750_50: bool = ((s_750_49.value()) != 0);
        // C s_750_51: const #0s : i
        let s_750_51: i128 = 0;
        // C s_750_52: const #4s : i
        let s_750_52: i128 = 4;
        // D s_750_53: read-var u#31283:u32
        let s_750_53: u32 = fn_state.u_31283;
        // D s_750_54: cast zx s_750_53 -> bv
        let s_750_54: Bits = Bits::new(s_750_53 as u128, 32u16);
        // D s_750_55: bit-extract s_750_54 s_750_51 s_750_52
        let s_750_55: Bits = (Bits::new(
            ((s_750_54) >> (s_750_51)).value(),
            u16::try_from(s_750_52).unwrap(),
        ));
        // D s_750_56: cast reint s_750_55 -> u8
        let s_750_56: u8 = (s_750_55.value() as u8);
        // D s_750_57: call decode_aarch32_instrs_VMUL_i_A1enc_A_txt(s_750_8, s_750_14, s_750_20, s_750_26, s_750_32, s_750_38, s_750_44, s_750_50, s_750_56)
        let s_750_57: () = decode_aarch32_instrs_VMUL_i_A1enc_A_txt(
            state,
            tracer,
            s_750_8,
            s_750_14,
            s_750_20,
            s_750_26,
            s_750_32,
            s_750_38,
            s_750_44,
            s_750_50,
            s_750_56,
        );
        // N s_750_58: return
        return;
    }
    fn block_751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_751_0: read-var merge#var.1:struct
        let s_751_0: u32 = fn_state.merge_var._1;
        // D s_751_1: write-var u#31294 <= s_751_0
        fn_state.u_31294 = s_751_0;
        // C s_751_2: const #25s : i
        let s_751_2: i128 = 25;
        // D s_751_3: read-var u#31294:u32
        let s_751_3: u32 = fn_state.u_31294;
        // D s_751_4: cast zx s_751_3 -> bv
        let s_751_4: Bits = Bits::new(s_751_3 as u128, 32u16);
        // C s_751_5: const #1s : i64
        let s_751_5: i64 = 1;
        // C s_751_6: cast zx s_751_5 -> i
        let s_751_6: i128 = (i128::try_from(s_751_5).unwrap());
        // C s_751_7: const #6s : i
        let s_751_7: i128 = 6;
        // C s_751_8: add s_751_7 s_751_6
        let s_751_8: i128 = (s_751_7 + s_751_6);
        // D s_751_9: bit-extract s_751_4 s_751_2 s_751_8
        let s_751_9: Bits = (Bits::new(
            ((s_751_4) >> (s_751_2)).value(),
            u16::try_from(s_751_8).unwrap(),
        ));
        // D s_751_10: cast reint s_751_9 -> u8
        let s_751_10: u8 = (s_751_9.value() as u8);
        // D s_751_11: cast zx s_751_10 -> bv
        let s_751_11: Bits = Bits::new(s_751_10 as u128, 7u16);
        // C s_751_12: const #121u : u8
        let s_751_12: u8 = 121;
        // C s_751_13: cast zx s_751_12 -> bv
        let s_751_13: Bits = Bits::new(s_751_12 as u128, 7u16);
        // D s_751_14: cmp-eq s_751_11 s_751_13
        let s_751_14: bool = ((s_751_11) == (s_751_13));
        // N s_751_15: branch s_751_14 b2535 b752
        if s_751_14 {
            return block_2535(state, tracer, fn_state);
        } else {
            return block_752(state, tracer, fn_state);
        };
    }
    fn block_752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_752_0: const #0u : u8
        let s_752_0: bool = false;
        // D s_752_1: write-var gs#400243 <= s_752_0
        fn_state.gs_400243 = s_752_0;
        // N s_752_2: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_753_0: read-var gs#400243:u8
        let s_753_0: bool = fn_state.gs_400243;
        // N s_753_1: branch s_753_0 b2534 b754
        if s_753_0 {
            return block_2534(state, tracer, fn_state);
        } else {
            return block_754(state, tracer, fn_state);
        };
    }
    fn block_754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_754_0: const #0u : u8
        let s_754_0: bool = false;
        // D s_754_1: write-var gs#400245 <= s_754_0
        fn_state.gs_400245 = s_754_0;
        // N s_754_2: jump b755
        return block_755(state, tracer, fn_state);
    }
    fn block_755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_755_0: read-var gs#400245:u8
        let s_755_0: bool = fn_state.gs_400245;
        // D s_755_1: not s_755_0
        let s_755_1: bool = !s_755_0;
        // N s_755_2: branch s_755_1 b757 b756
        if s_755_1 {
            return block_757(state, tracer, fn_state);
        } else {
            return block_756(state, tracer, fn_state);
        };
    }
    fn block_756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_756_0: const #3557s : i
        let s_756_0: i128 = 3557;
        // C s_756_1: const #14696u : u32
        let s_756_1: u32 = 14696;
        // N s_756_2: write-reg s_756_1 <= s_756_0
        let s_756_2: () = {
            state.write_register::<i128>(s_756_1 as isize, s_756_0);
            tracer.write_register(s_756_1 as isize, s_756_0);
        };
        // C s_756_3: const #24s : i
        let s_756_3: i128 = 24;
        // C s_756_4: const #1s : i
        let s_756_4: i128 = 1;
        // D s_756_5: read-var u#31294:u32
        let s_756_5: u32 = fn_state.u_31294;
        // D s_756_6: cast zx s_756_5 -> bv
        let s_756_6: Bits = Bits::new(s_756_5 as u128, 32u16);
        // D s_756_7: bit-extract s_756_6 s_756_3 s_756_4
        let s_756_7: Bits = (Bits::new(
            ((s_756_6) >> (s_756_3)).value(),
            u16::try_from(s_756_4).unwrap(),
        ));
        // D s_756_8: cast reint s_756_7 -> u8
        let s_756_8: bool = ((s_756_7.value()) != 0);
        // C s_756_9: const #22s : i
        let s_756_9: i128 = 22;
        // C s_756_10: const #1s : i
        let s_756_10: i128 = 1;
        // D s_756_11: read-var u#31294:u32
        let s_756_11: u32 = fn_state.u_31294;
        // D s_756_12: cast zx s_756_11 -> bv
        let s_756_12: Bits = Bits::new(s_756_11 as u128, 32u16);
        // D s_756_13: bit-extract s_756_12 s_756_9 s_756_10
        let s_756_13: Bits = (Bits::new(
            ((s_756_12) >> (s_756_9)).value(),
            u16::try_from(s_756_10).unwrap(),
        ));
        // D s_756_14: cast reint s_756_13 -> u8
        let s_756_14: bool = ((s_756_13.value()) != 0);
        // C s_756_15: const #20s : i
        let s_756_15: i128 = 20;
        // C s_756_16: const #2s : i
        let s_756_16: i128 = 2;
        // D s_756_17: read-var u#31294:u32
        let s_756_17: u32 = fn_state.u_31294;
        // D s_756_18: cast zx s_756_17 -> bv
        let s_756_18: Bits = Bits::new(s_756_17 as u128, 32u16);
        // D s_756_19: bit-extract s_756_18 s_756_15 s_756_16
        let s_756_19: Bits = (Bits::new(
            ((s_756_18) >> (s_756_15)).value(),
            u16::try_from(s_756_16).unwrap(),
        ));
        // D s_756_20: cast reint s_756_19 -> u8
        let s_756_20: u8 = (s_756_19.value() as u8);
        // C s_756_21: const #16s : i
        let s_756_21: i128 = 16;
        // C s_756_22: const #4s : i
        let s_756_22: i128 = 4;
        // D s_756_23: read-var u#31294:u32
        let s_756_23: u32 = fn_state.u_31294;
        // D s_756_24: cast zx s_756_23 -> bv
        let s_756_24: Bits = Bits::new(s_756_23 as u128, 32u16);
        // D s_756_25: bit-extract s_756_24 s_756_21 s_756_22
        let s_756_25: Bits = (Bits::new(
            ((s_756_24) >> (s_756_21)).value(),
            u16::try_from(s_756_22).unwrap(),
        ));
        // D s_756_26: cast reint s_756_25 -> u8
        let s_756_26: u8 = (s_756_25.value() as u8);
        // C s_756_27: const #12s : i
        let s_756_27: i128 = 12;
        // C s_756_28: const #4s : i
        let s_756_28: i128 = 4;
        // D s_756_29: read-var u#31294:u32
        let s_756_29: u32 = fn_state.u_31294;
        // D s_756_30: cast zx s_756_29 -> bv
        let s_756_30: Bits = Bits::new(s_756_29 as u128, 32u16);
        // D s_756_31: bit-extract s_756_30 s_756_27 s_756_28
        let s_756_31: Bits = (Bits::new(
            ((s_756_30) >> (s_756_27)).value(),
            u16::try_from(s_756_28).unwrap(),
        ));
        // D s_756_32: cast reint s_756_31 -> u8
        let s_756_32: u8 = (s_756_31.value() as u8);
        // C s_756_33: const #9s : i
        let s_756_33: i128 = 9;
        // C s_756_34: const #1s : i
        let s_756_34: i128 = 1;
        // D s_756_35: read-var u#31294:u32
        let s_756_35: u32 = fn_state.u_31294;
        // D s_756_36: cast zx s_756_35 -> bv
        let s_756_36: Bits = Bits::new(s_756_35 as u128, 32u16);
        // D s_756_37: bit-extract s_756_36 s_756_33 s_756_34
        let s_756_37: Bits = (Bits::new(
            ((s_756_36) >> (s_756_33)).value(),
            u16::try_from(s_756_34).unwrap(),
        ));
        // D s_756_38: cast reint s_756_37 -> u8
        let s_756_38: bool = ((s_756_37.value()) != 0);
        // C s_756_39: const #7s : i
        let s_756_39: i128 = 7;
        // C s_756_40: const #1s : i
        let s_756_40: i128 = 1;
        // D s_756_41: read-var u#31294:u32
        let s_756_41: u32 = fn_state.u_31294;
        // D s_756_42: cast zx s_756_41 -> bv
        let s_756_42: Bits = Bits::new(s_756_41 as u128, 32u16);
        // D s_756_43: bit-extract s_756_42 s_756_39 s_756_40
        let s_756_43: Bits = (Bits::new(
            ((s_756_42) >> (s_756_39)).value(),
            u16::try_from(s_756_40).unwrap(),
        ));
        // D s_756_44: cast reint s_756_43 -> u8
        let s_756_44: bool = ((s_756_43.value()) != 0);
        // C s_756_45: const #5s : i
        let s_756_45: i128 = 5;
        // C s_756_46: const #1s : i
        let s_756_46: i128 = 1;
        // D s_756_47: read-var u#31294:u32
        let s_756_47: u32 = fn_state.u_31294;
        // D s_756_48: cast zx s_756_47 -> bv
        let s_756_48: Bits = Bits::new(s_756_47 as u128, 32u16);
        // D s_756_49: bit-extract s_756_48 s_756_45 s_756_46
        let s_756_49: Bits = (Bits::new(
            ((s_756_48) >> (s_756_45)).value(),
            u16::try_from(s_756_46).unwrap(),
        ));
        // D s_756_50: cast reint s_756_49 -> u8
        let s_756_50: bool = ((s_756_49.value()) != 0);
        // C s_756_51: const #0s : i
        let s_756_51: i128 = 0;
        // C s_756_52: const #4s : i
        let s_756_52: i128 = 4;
        // D s_756_53: read-var u#31294:u32
        let s_756_53: u32 = fn_state.u_31294;
        // D s_756_54: cast zx s_756_53 -> bv
        let s_756_54: Bits = Bits::new(s_756_53 as u128, 32u16);
        // D s_756_55: bit-extract s_756_54 s_756_51 s_756_52
        let s_756_55: Bits = (Bits::new(
            ((s_756_54) >> (s_756_51)).value(),
            u16::try_from(s_756_52).unwrap(),
        ));
        // D s_756_56: cast reint s_756_55 -> u8
        let s_756_56: u8 = (s_756_55.value() as u8);
        // D s_756_57: call decode_aarch32_instrs_VMUL_i_A2enc_A_txt(s_756_8, s_756_14, s_756_20, s_756_26, s_756_32, s_756_38, s_756_44, s_756_50, s_756_56)
        let s_756_57: () = decode_aarch32_instrs_VMUL_i_A2enc_A_txt(
            state,
            tracer,
            s_756_8,
            s_756_14,
            s_756_20,
            s_756_26,
            s_756_32,
            s_756_38,
            s_756_44,
            s_756_50,
            s_756_56,
        );
        // N s_756_58: return
        return;
    }
    fn block_757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_757_0: read-var merge#var.1:struct
        let s_757_0: u32 = fn_state.merge_var._1;
        // D s_757_1: write-var u#31305 <= s_757_0
        fn_state.u_31305 = s_757_0;
        // C s_757_2: const #25s : i
        let s_757_2: i128 = 25;
        // D s_757_3: read-var u#31305:u32
        let s_757_3: u32 = fn_state.u_31305;
        // D s_757_4: cast zx s_757_3 -> bv
        let s_757_4: Bits = Bits::new(s_757_3 as u128, 32u16);
        // C s_757_5: const #1s : i64
        let s_757_5: i64 = 1;
        // C s_757_6: cast zx s_757_5 -> i
        let s_757_6: i128 = (i128::try_from(s_757_5).unwrap());
        // C s_757_7: const #6s : i
        let s_757_7: i128 = 6;
        // C s_757_8: add s_757_7 s_757_6
        let s_757_8: i128 = (s_757_7 + s_757_6);
        // D s_757_9: bit-extract s_757_4 s_757_2 s_757_8
        let s_757_9: Bits = (Bits::new(
            ((s_757_4) >> (s_757_2)).value(),
            u16::try_from(s_757_8).unwrap(),
        ));
        // D s_757_10: cast reint s_757_9 -> u8
        let s_757_10: u8 = (s_757_9.value() as u8);
        // D s_757_11: cast zx s_757_10 -> bv
        let s_757_11: Bits = Bits::new(s_757_10 as u128, 7u16);
        // C s_757_12: const #121u : u8
        let s_757_12: u8 = 121;
        // C s_757_13: cast zx s_757_12 -> bv
        let s_757_13: Bits = Bits::new(s_757_12 as u128, 7u16);
        // D s_757_14: cmp-eq s_757_11 s_757_13
        let s_757_14: bool = ((s_757_11) == (s_757_13));
        // N s_757_15: branch s_757_14 b2524 b758
        if s_757_14 {
            return block_2524(state, tracer, fn_state);
        } else {
            return block_758(state, tracer, fn_state);
        };
    }
    fn block_758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_758_0: const #0u : u8
        let s_758_0: bool = false;
        // D s_758_1: write-var gs#400280 <= s_758_0
        fn_state.gs_400280 = s_758_0;
        // N s_758_2: jump b759
        return block_759(state, tracer, fn_state);
    }
    fn block_759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_759_0: read-var gs#400280:u8
        let s_759_0: bool = fn_state.gs_400280;
        // N s_759_1: branch s_759_0 b2523 b760
        if s_759_0 {
            return block_2523(state, tracer, fn_state);
        } else {
            return block_760(state, tracer, fn_state);
        };
    }
    fn block_760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_760_0: const #0u : u8
        let s_760_0: bool = false;
        // D s_760_1: write-var gs#400282 <= s_760_0
        fn_state.gs_400282 = s_760_0;
        // N s_760_2: jump b761
        return block_761(state, tracer, fn_state);
    }
    fn block_761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_761_0: read-var gs#400282:u8
        let s_761_0: bool = fn_state.gs_400282;
        // D s_761_1: not s_761_0
        let s_761_1: bool = !s_761_0;
        // N s_761_2: branch s_761_1 b763 b762
        if s_761_1 {
            return block_763(state, tracer, fn_state);
        } else {
            return block_762(state, tracer, fn_state);
        };
    }
    fn block_762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_762_0: const #3560s : i
        let s_762_0: i128 = 3560;
        // C s_762_1: const #14696u : u32
        let s_762_1: u32 = 14696;
        // N s_762_2: write-reg s_762_1 <= s_762_0
        let s_762_2: () = {
            state.write_register::<i128>(s_762_1 as isize, s_762_0);
            tracer.write_register(s_762_1 as isize, s_762_0);
        };
        // C s_762_3: const #24s : i
        let s_762_3: i128 = 24;
        // C s_762_4: const #1s : i
        let s_762_4: i128 = 1;
        // D s_762_5: read-var u#31305:u32
        let s_762_5: u32 = fn_state.u_31305;
        // D s_762_6: cast zx s_762_5 -> bv
        let s_762_6: Bits = Bits::new(s_762_5 as u128, 32u16);
        // D s_762_7: bit-extract s_762_6 s_762_3 s_762_4
        let s_762_7: Bits = (Bits::new(
            ((s_762_6) >> (s_762_3)).value(),
            u16::try_from(s_762_4).unwrap(),
        ));
        // D s_762_8: cast reint s_762_7 -> u8
        let s_762_8: bool = ((s_762_7.value()) != 0);
        // C s_762_9: const #22s : i
        let s_762_9: i128 = 22;
        // C s_762_10: const #1s : i
        let s_762_10: i128 = 1;
        // D s_762_11: read-var u#31305:u32
        let s_762_11: u32 = fn_state.u_31305;
        // D s_762_12: cast zx s_762_11 -> bv
        let s_762_12: Bits = Bits::new(s_762_11 as u128, 32u16);
        // D s_762_13: bit-extract s_762_12 s_762_9 s_762_10
        let s_762_13: Bits = (Bits::new(
            ((s_762_12) >> (s_762_9)).value(),
            u16::try_from(s_762_10).unwrap(),
        ));
        // D s_762_14: cast reint s_762_13 -> u8
        let s_762_14: bool = ((s_762_13.value()) != 0);
        // C s_762_15: const #20s : i
        let s_762_15: i128 = 20;
        // C s_762_16: const #2s : i
        let s_762_16: i128 = 2;
        // D s_762_17: read-var u#31305:u32
        let s_762_17: u32 = fn_state.u_31305;
        // D s_762_18: cast zx s_762_17 -> bv
        let s_762_18: Bits = Bits::new(s_762_17 as u128, 32u16);
        // D s_762_19: bit-extract s_762_18 s_762_15 s_762_16
        let s_762_19: Bits = (Bits::new(
            ((s_762_18) >> (s_762_15)).value(),
            u16::try_from(s_762_16).unwrap(),
        ));
        // D s_762_20: cast reint s_762_19 -> u8
        let s_762_20: u8 = (s_762_19.value() as u8);
        // C s_762_21: const #16s : i
        let s_762_21: i128 = 16;
        // C s_762_22: const #4s : i
        let s_762_22: i128 = 4;
        // D s_762_23: read-var u#31305:u32
        let s_762_23: u32 = fn_state.u_31305;
        // D s_762_24: cast zx s_762_23 -> bv
        let s_762_24: Bits = Bits::new(s_762_23 as u128, 32u16);
        // D s_762_25: bit-extract s_762_24 s_762_21 s_762_22
        let s_762_25: Bits = (Bits::new(
            ((s_762_24) >> (s_762_21)).value(),
            u16::try_from(s_762_22).unwrap(),
        ));
        // D s_762_26: cast reint s_762_25 -> u8
        let s_762_26: u8 = (s_762_25.value() as u8);
        // C s_762_27: const #12s : i
        let s_762_27: i128 = 12;
        // C s_762_28: const #4s : i
        let s_762_28: i128 = 4;
        // D s_762_29: read-var u#31305:u32
        let s_762_29: u32 = fn_state.u_31305;
        // D s_762_30: cast zx s_762_29 -> bv
        let s_762_30: Bits = Bits::new(s_762_29 as u128, 32u16);
        // D s_762_31: bit-extract s_762_30 s_762_27 s_762_28
        let s_762_31: Bits = (Bits::new(
            ((s_762_30) >> (s_762_27)).value(),
            u16::try_from(s_762_28).unwrap(),
        ));
        // D s_762_32: cast reint s_762_31 -> u8
        let s_762_32: u8 = (s_762_31.value() as u8);
        // C s_762_33: const #8s : i
        let s_762_33: i128 = 8;
        // C s_762_34: const #1s : i
        let s_762_34: i128 = 1;
        // D s_762_35: read-var u#31305:u32
        let s_762_35: u32 = fn_state.u_31305;
        // D s_762_36: cast zx s_762_35 -> bv
        let s_762_36: Bits = Bits::new(s_762_35 as u128, 32u16);
        // D s_762_37: bit-extract s_762_36 s_762_33 s_762_34
        let s_762_37: Bits = (Bits::new(
            ((s_762_36) >> (s_762_33)).value(),
            u16::try_from(s_762_34).unwrap(),
        ));
        // D s_762_38: cast reint s_762_37 -> u8
        let s_762_38: bool = ((s_762_37.value()) != 0);
        // C s_762_39: const #7s : i
        let s_762_39: i128 = 7;
        // C s_762_40: const #1s : i
        let s_762_40: i128 = 1;
        // D s_762_41: read-var u#31305:u32
        let s_762_41: u32 = fn_state.u_31305;
        // D s_762_42: cast zx s_762_41 -> bv
        let s_762_42: Bits = Bits::new(s_762_41 as u128, 32u16);
        // D s_762_43: bit-extract s_762_42 s_762_39 s_762_40
        let s_762_43: Bits = (Bits::new(
            ((s_762_42) >> (s_762_39)).value(),
            u16::try_from(s_762_40).unwrap(),
        ));
        // D s_762_44: cast reint s_762_43 -> u8
        let s_762_44: bool = ((s_762_43.value()) != 0);
        // C s_762_45: const #5s : i
        let s_762_45: i128 = 5;
        // C s_762_46: const #1s : i
        let s_762_46: i128 = 1;
        // D s_762_47: read-var u#31305:u32
        let s_762_47: u32 = fn_state.u_31305;
        // D s_762_48: cast zx s_762_47 -> bv
        let s_762_48: Bits = Bits::new(s_762_47 as u128, 32u16);
        // D s_762_49: bit-extract s_762_48 s_762_45 s_762_46
        let s_762_49: Bits = (Bits::new(
            ((s_762_48) >> (s_762_45)).value(),
            u16::try_from(s_762_46).unwrap(),
        ));
        // D s_762_50: cast reint s_762_49 -> u8
        let s_762_50: bool = ((s_762_49.value()) != 0);
        // C s_762_51: const #0s : i
        let s_762_51: i128 = 0;
        // C s_762_52: const #4s : i
        let s_762_52: i128 = 4;
        // D s_762_53: read-var u#31305:u32
        let s_762_53: u32 = fn_state.u_31305;
        // D s_762_54: cast zx s_762_53 -> bv
        let s_762_54: Bits = Bits::new(s_762_53 as u128, 32u16);
        // D s_762_55: bit-extract s_762_54 s_762_51 s_762_52
        let s_762_55: Bits = (Bits::new(
            ((s_762_54) >> (s_762_51)).value(),
            u16::try_from(s_762_52).unwrap(),
        ));
        // D s_762_56: cast reint s_762_55 -> u8
        let s_762_56: u8 = (s_762_55.value() as u8);
        // D s_762_57: call decode_aarch32_instrs_VMUL_s_A1enc_A_txt(s_762_8, s_762_14, s_762_20, s_762_26, s_762_32, s_762_38, s_762_44, s_762_50, s_762_56)
        let s_762_57: () = decode_aarch32_instrs_VMUL_s_A1enc_A_txt(
            state,
            tracer,
            s_762_8,
            s_762_14,
            s_762_20,
            s_762_26,
            s_762_32,
            s_762_38,
            s_762_44,
            s_762_50,
            s_762_56,
        );
        // N s_762_58: return
        return;
    }
    fn block_763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_763_0: read-var merge#var.1:struct
        let s_763_0: u32 = fn_state.merge_var._1;
        // D s_763_1: write-var u#31316 <= s_763_0
        fn_state.u_31316 = s_763_0;
        // C s_763_2: const #25s : i
        let s_763_2: i128 = 25;
        // D s_763_3: read-var u#31316:u32
        let s_763_3: u32 = fn_state.u_31316;
        // D s_763_4: cast zx s_763_3 -> bv
        let s_763_4: Bits = Bits::new(s_763_3 as u128, 32u16);
        // C s_763_5: const #1s : i64
        let s_763_5: i64 = 1;
        // C s_763_6: cast zx s_763_5 -> i
        let s_763_6: i128 = (i128::try_from(s_763_5).unwrap());
        // C s_763_7: const #6s : i
        let s_763_7: i128 = 6;
        // C s_763_8: add s_763_7 s_763_6
        let s_763_8: i128 = (s_763_7 + s_763_6);
        // D s_763_9: bit-extract s_763_4 s_763_2 s_763_8
        let s_763_9: Bits = (Bits::new(
            ((s_763_4) >> (s_763_2)).value(),
            u16::try_from(s_763_8).unwrap(),
        ));
        // D s_763_10: cast reint s_763_9 -> u8
        let s_763_10: u8 = (s_763_9.value() as u8);
        // D s_763_11: cast zx s_763_10 -> bv
        let s_763_11: Bits = Bits::new(s_763_10 as u128, 7u16);
        // C s_763_12: const #121u : u8
        let s_763_12: u8 = 121;
        // C s_763_13: cast zx s_763_12 -> bv
        let s_763_13: Bits = Bits::new(s_763_12 as u128, 7u16);
        // D s_763_14: cmp-eq s_763_11 s_763_13
        let s_763_14: bool = ((s_763_11) == (s_763_13));
        // N s_763_15: branch s_763_14 b2513 b764
        if s_763_14 {
            return block_2513(state, tracer, fn_state);
        } else {
            return block_764(state, tracer, fn_state);
        };
    }
    fn block_764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_764_0: const #0u : u8
        let s_764_0: bool = false;
        // D s_764_1: write-var gs#400317 <= s_764_0
        fn_state.gs_400317 = s_764_0;
        // N s_764_2: jump b765
        return block_765(state, tracer, fn_state);
    }
    fn block_765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_765_0: read-var gs#400317:u8
        let s_765_0: bool = fn_state.gs_400317;
        // N s_765_1: branch s_765_0 b2512 b766
        if s_765_0 {
            return block_2512(state, tracer, fn_state);
        } else {
            return block_766(state, tracer, fn_state);
        };
    }
    fn block_766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_766_0: const #0u : u8
        let s_766_0: bool = false;
        // D s_766_1: write-var gs#400319 <= s_766_0
        fn_state.gs_400319 = s_766_0;
        // N s_766_2: jump b767
        return block_767(state, tracer, fn_state);
    }
    fn block_767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_767_0: read-var gs#400319:u8
        let s_767_0: bool = fn_state.gs_400319;
        // D s_767_1: not s_767_0
        let s_767_1: bool = !s_767_0;
        // N s_767_2: branch s_767_1 b769 b768
        if s_767_1 {
            return block_769(state, tracer, fn_state);
        } else {
            return block_768(state, tracer, fn_state);
        };
    }
    fn block_768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_768_0: const #3561s : i
        let s_768_0: i128 = 3561;
        // C s_768_1: const #14696u : u32
        let s_768_1: u32 = 14696;
        // N s_768_2: write-reg s_768_1 <= s_768_0
        let s_768_2: () = {
            state.write_register::<i128>(s_768_1 as isize, s_768_0);
            tracer.write_register(s_768_1 as isize, s_768_0);
        };
        // C s_768_3: const #24s : i
        let s_768_3: i128 = 24;
        // C s_768_4: const #1s : i
        let s_768_4: i128 = 1;
        // D s_768_5: read-var u#31316:u32
        let s_768_5: u32 = fn_state.u_31316;
        // D s_768_6: cast zx s_768_5 -> bv
        let s_768_6: Bits = Bits::new(s_768_5 as u128, 32u16);
        // D s_768_7: bit-extract s_768_6 s_768_3 s_768_4
        let s_768_7: Bits = (Bits::new(
            ((s_768_6) >> (s_768_3)).value(),
            u16::try_from(s_768_4).unwrap(),
        ));
        // D s_768_8: cast reint s_768_7 -> u8
        let s_768_8: bool = ((s_768_7.value()) != 0);
        // C s_768_9: const #22s : i
        let s_768_9: i128 = 22;
        // C s_768_10: const #1s : i
        let s_768_10: i128 = 1;
        // D s_768_11: read-var u#31316:u32
        let s_768_11: u32 = fn_state.u_31316;
        // D s_768_12: cast zx s_768_11 -> bv
        let s_768_12: Bits = Bits::new(s_768_11 as u128, 32u16);
        // D s_768_13: bit-extract s_768_12 s_768_9 s_768_10
        let s_768_13: Bits = (Bits::new(
            ((s_768_12) >> (s_768_9)).value(),
            u16::try_from(s_768_10).unwrap(),
        ));
        // D s_768_14: cast reint s_768_13 -> u8
        let s_768_14: bool = ((s_768_13.value()) != 0);
        // C s_768_15: const #20s : i
        let s_768_15: i128 = 20;
        // C s_768_16: const #2s : i
        let s_768_16: i128 = 2;
        // D s_768_17: read-var u#31316:u32
        let s_768_17: u32 = fn_state.u_31316;
        // D s_768_18: cast zx s_768_17 -> bv
        let s_768_18: Bits = Bits::new(s_768_17 as u128, 32u16);
        // D s_768_19: bit-extract s_768_18 s_768_15 s_768_16
        let s_768_19: Bits = (Bits::new(
            ((s_768_18) >> (s_768_15)).value(),
            u16::try_from(s_768_16).unwrap(),
        ));
        // D s_768_20: cast reint s_768_19 -> u8
        let s_768_20: u8 = (s_768_19.value() as u8);
        // C s_768_21: const #16s : i
        let s_768_21: i128 = 16;
        // C s_768_22: const #4s : i
        let s_768_22: i128 = 4;
        // D s_768_23: read-var u#31316:u32
        let s_768_23: u32 = fn_state.u_31316;
        // D s_768_24: cast zx s_768_23 -> bv
        let s_768_24: Bits = Bits::new(s_768_23 as u128, 32u16);
        // D s_768_25: bit-extract s_768_24 s_768_21 s_768_22
        let s_768_25: Bits = (Bits::new(
            ((s_768_24) >> (s_768_21)).value(),
            u16::try_from(s_768_22).unwrap(),
        ));
        // D s_768_26: cast reint s_768_25 -> u8
        let s_768_26: u8 = (s_768_25.value() as u8);
        // C s_768_27: const #12s : i
        let s_768_27: i128 = 12;
        // C s_768_28: const #4s : i
        let s_768_28: i128 = 4;
        // D s_768_29: read-var u#31316:u32
        let s_768_29: u32 = fn_state.u_31316;
        // D s_768_30: cast zx s_768_29 -> bv
        let s_768_30: Bits = Bits::new(s_768_29 as u128, 32u16);
        // D s_768_31: bit-extract s_768_30 s_768_27 s_768_28
        let s_768_31: Bits = (Bits::new(
            ((s_768_30) >> (s_768_27)).value(),
            u16::try_from(s_768_28).unwrap(),
        ));
        // D s_768_32: cast reint s_768_31 -> u8
        let s_768_32: u8 = (s_768_31.value() as u8);
        // C s_768_33: const #7s : i
        let s_768_33: i128 = 7;
        // C s_768_34: const #1s : i
        let s_768_34: i128 = 1;
        // D s_768_35: read-var u#31316:u32
        let s_768_35: u32 = fn_state.u_31316;
        // D s_768_36: cast zx s_768_35 -> bv
        let s_768_36: Bits = Bits::new(s_768_35 as u128, 32u16);
        // D s_768_37: bit-extract s_768_36 s_768_33 s_768_34
        let s_768_37: Bits = (Bits::new(
            ((s_768_36) >> (s_768_33)).value(),
            u16::try_from(s_768_34).unwrap(),
        ));
        // D s_768_38: cast reint s_768_37 -> u8
        let s_768_38: bool = ((s_768_37.value()) != 0);
        // C s_768_39: const #5s : i
        let s_768_39: i128 = 5;
        // C s_768_40: const #1s : i
        let s_768_40: i128 = 1;
        // D s_768_41: read-var u#31316:u32
        let s_768_41: u32 = fn_state.u_31316;
        // D s_768_42: cast zx s_768_41 -> bv
        let s_768_42: Bits = Bits::new(s_768_41 as u128, 32u16);
        // D s_768_43: bit-extract s_768_42 s_768_39 s_768_40
        let s_768_43: Bits = (Bits::new(
            ((s_768_42) >> (s_768_39)).value(),
            u16::try_from(s_768_40).unwrap(),
        ));
        // D s_768_44: cast reint s_768_43 -> u8
        let s_768_44: bool = ((s_768_43.value()) != 0);
        // C s_768_45: const #0s : i
        let s_768_45: i128 = 0;
        // C s_768_46: const #4s : i
        let s_768_46: i128 = 4;
        // D s_768_47: read-var u#31316:u32
        let s_768_47: u32 = fn_state.u_31316;
        // D s_768_48: cast zx s_768_47 -> bv
        let s_768_48: Bits = Bits::new(s_768_47 as u128, 32u16);
        // D s_768_49: bit-extract s_768_48 s_768_45 s_768_46
        let s_768_49: Bits = (Bits::new(
            ((s_768_48) >> (s_768_45)).value(),
            u16::try_from(s_768_46).unwrap(),
        ));
        // D s_768_50: cast reint s_768_49 -> u8
        let s_768_50: u8 = (s_768_49.value() as u8);
        // D s_768_51: call decode_aarch32_instrs_VMUL_s_A2enc_A_txt(s_768_8, s_768_14, s_768_20, s_768_26, s_768_32, s_768_38, s_768_44, s_768_50)
        let s_768_51: () = decode_aarch32_instrs_VMUL_s_A2enc_A_txt(
            state,
            tracer,
            s_768_8,
            s_768_14,
            s_768_20,
            s_768_26,
            s_768_32,
            s_768_38,
            s_768_44,
            s_768_50,
        );
        // N s_768_52: return
        return;
    }
    fn block_769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_769_0: read-var merge#var.1:struct
        let s_769_0: u32 = fn_state.merge_var._1;
        // D s_769_1: write-var u#31326 <= s_769_0
        fn_state.u_31326 = s_769_0;
        // C s_769_2: const #25s : i
        let s_769_2: i128 = 25;
        // D s_769_3: read-var u#31326:u32
        let s_769_3: u32 = fn_state.u_31326;
        // D s_769_4: cast zx s_769_3 -> bv
        let s_769_4: Bits = Bits::new(s_769_3 as u128, 32u16);
        // C s_769_5: const #1s : i64
        let s_769_5: i64 = 1;
        // C s_769_6: cast zx s_769_5 -> i
        let s_769_6: i128 = (i128::try_from(s_769_5).unwrap());
        // C s_769_7: const #6s : i
        let s_769_7: i128 = 6;
        // C s_769_8: add s_769_7 s_769_6
        let s_769_8: i128 = (s_769_7 + s_769_6);
        // D s_769_9: bit-extract s_769_4 s_769_2 s_769_8
        let s_769_9: Bits = (Bits::new(
            ((s_769_4) >> (s_769_2)).value(),
            u16::try_from(s_769_8).unwrap(),
        ));
        // D s_769_10: cast reint s_769_9 -> u8
        let s_769_10: u8 = (s_769_9.value() as u8);
        // D s_769_11: cast zx s_769_10 -> bv
        let s_769_11: Bits = Bits::new(s_769_10 as u128, 7u16);
        // C s_769_12: const #121u : u8
        let s_769_12: u8 = 121;
        // C s_769_13: cast zx s_769_12 -> bv
        let s_769_13: Bits = Bits::new(s_769_12 as u128, 7u16);
        // D s_769_14: cmp-eq s_769_11 s_769_13
        let s_769_14: bool = ((s_769_11) == (s_769_13));
        // N s_769_15: branch s_769_14 b2499 b770
        if s_769_14 {
            return block_2499(state, tracer, fn_state);
        } else {
            return block_770(state, tracer, fn_state);
        };
    }
    fn block_770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_770_0: const #0u : u8
        let s_770_0: bool = false;
        // D s_770_1: write-var gs#400355 <= s_770_0
        fn_state.gs_400355 = s_770_0;
        // N s_770_2: jump b771
        return block_771(state, tracer, fn_state);
    }
    fn block_771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_771_0: read-var gs#400355:u8
        let s_771_0: bool = fn_state.gs_400355;
        // N s_771_1: branch s_771_0 b2498 b772
        if s_771_0 {
            return block_2498(state, tracer, fn_state);
        } else {
            return block_772(state, tracer, fn_state);
        };
    }
    fn block_772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_772_0: const #0u : u8
        let s_772_0: bool = false;
        // D s_772_1: write-var gs#400357 <= s_772_0
        fn_state.gs_400357 = s_772_0;
        // N s_772_2: jump b773
        return block_773(state, tracer, fn_state);
    }
    fn block_773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_773_0: read-var gs#400357:u8
        let s_773_0: bool = fn_state.gs_400357;
        // D s_773_1: not s_773_0
        let s_773_1: bool = !s_773_0;
        // N s_773_2: branch s_773_1 b775 b774
        if s_773_1 {
            return block_775(state, tracer, fn_state);
        } else {
            return block_774(state, tracer, fn_state);
        };
    }
    fn block_774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_774_0: const #3564s : i
        let s_774_0: i128 = 3564;
        // C s_774_1: const #14696u : u32
        let s_774_1: u32 = 14696;
        // N s_774_2: write-reg s_774_1 <= s_774_0
        let s_774_2: () = {
            state.write_register::<i128>(s_774_1 as isize, s_774_0);
            tracer.write_register(s_774_1 as isize, s_774_0);
        };
        // C s_774_3: const #24s : i
        let s_774_3: i128 = 24;
        // C s_774_4: const #1s : i
        let s_774_4: i128 = 1;
        // D s_774_5: read-var u#31326:u32
        let s_774_5: u32 = fn_state.u_31326;
        // D s_774_6: cast zx s_774_5 -> bv
        let s_774_6: Bits = Bits::new(s_774_5 as u128, 32u16);
        // D s_774_7: bit-extract s_774_6 s_774_3 s_774_4
        let s_774_7: Bits = (Bits::new(
            ((s_774_6) >> (s_774_3)).value(),
            u16::try_from(s_774_4).unwrap(),
        ));
        // D s_774_8: cast reint s_774_7 -> u8
        let s_774_8: bool = ((s_774_7.value()) != 0);
        // C s_774_9: const #22s : i
        let s_774_9: i128 = 22;
        // C s_774_10: const #1s : i
        let s_774_10: i128 = 1;
        // D s_774_11: read-var u#31326:u32
        let s_774_11: u32 = fn_state.u_31326;
        // D s_774_12: cast zx s_774_11 -> bv
        let s_774_12: Bits = Bits::new(s_774_11 as u128, 32u16);
        // D s_774_13: bit-extract s_774_12 s_774_9 s_774_10
        let s_774_13: Bits = (Bits::new(
            ((s_774_12) >> (s_774_9)).value(),
            u16::try_from(s_774_10).unwrap(),
        ));
        // D s_774_14: cast reint s_774_13 -> u8
        let s_774_14: bool = ((s_774_13.value()) != 0);
        // C s_774_15: const #16s : i
        let s_774_15: i128 = 16;
        // C s_774_16: const #3s : i
        let s_774_16: i128 = 3;
        // D s_774_17: read-var u#31326:u32
        let s_774_17: u32 = fn_state.u_31326;
        // D s_774_18: cast zx s_774_17 -> bv
        let s_774_18: Bits = Bits::new(s_774_17 as u128, 32u16);
        // D s_774_19: bit-extract s_774_18 s_774_15 s_774_16
        let s_774_19: Bits = (Bits::new(
            ((s_774_18) >> (s_774_15)).value(),
            u16::try_from(s_774_16).unwrap(),
        ));
        // D s_774_20: cast reint s_774_19 -> u8
        let s_774_20: u8 = (s_774_19.value() as u8);
        // C s_774_21: const #12s : i
        let s_774_21: i128 = 12;
        // C s_774_22: const #4s : i
        let s_774_22: i128 = 4;
        // D s_774_23: read-var u#31326:u32
        let s_774_23: u32 = fn_state.u_31326;
        // D s_774_24: cast zx s_774_23 -> bv
        let s_774_24: Bits = Bits::new(s_774_23 as u128, 32u16);
        // D s_774_25: bit-extract s_774_24 s_774_21 s_774_22
        let s_774_25: Bits = (Bits::new(
            ((s_774_24) >> (s_774_21)).value(),
            u16::try_from(s_774_22).unwrap(),
        ));
        // D s_774_26: cast reint s_774_25 -> u8
        let s_774_26: u8 = (s_774_25.value() as u8);
        // C s_774_27: const #8s : i
        let s_774_27: i128 = 8;
        // C s_774_28: const #4s : i
        let s_774_28: i128 = 4;
        // D s_774_29: read-var u#31326:u32
        let s_774_29: u32 = fn_state.u_31326;
        // D s_774_30: cast zx s_774_29 -> bv
        let s_774_30: Bits = Bits::new(s_774_29 as u128, 32u16);
        // D s_774_31: bit-extract s_774_30 s_774_27 s_774_28
        let s_774_31: Bits = (Bits::new(
            ((s_774_30) >> (s_774_27)).value(),
            u16::try_from(s_774_28).unwrap(),
        ));
        // D s_774_32: cast reint s_774_31 -> u8
        let s_774_32: u8 = (s_774_31.value() as u8);
        // C s_774_33: const #6s : i
        let s_774_33: i128 = 6;
        // C s_774_34: const #1s : i
        let s_774_34: i128 = 1;
        // D s_774_35: read-var u#31326:u32
        let s_774_35: u32 = fn_state.u_31326;
        // D s_774_36: cast zx s_774_35 -> bv
        let s_774_36: Bits = Bits::new(s_774_35 as u128, 32u16);
        // D s_774_37: bit-extract s_774_36 s_774_33 s_774_34
        let s_774_37: Bits = (Bits::new(
            ((s_774_36) >> (s_774_33)).value(),
            u16::try_from(s_774_34).unwrap(),
        ));
        // D s_774_38: cast reint s_774_37 -> u8
        let s_774_38: bool = ((s_774_37.value()) != 0);
        // C s_774_39: const #0s : i
        let s_774_39: i128 = 0;
        // C s_774_40: const #4s : i
        let s_774_40: i128 = 4;
        // D s_774_41: read-var u#31326:u32
        let s_774_41: u32 = fn_state.u_31326;
        // D s_774_42: cast zx s_774_41 -> bv
        let s_774_42: Bits = Bits::new(s_774_41 as u128, 32u16);
        // D s_774_43: bit-extract s_774_42 s_774_39 s_774_40
        let s_774_43: Bits = (Bits::new(
            ((s_774_42) >> (s_774_39)).value(),
            u16::try_from(s_774_40).unwrap(),
        ));
        // D s_774_44: cast reint s_774_43 -> u8
        let s_774_44: u8 = (s_774_43.value() as u8);
        // D s_774_45: call decode_aarch32_instrs_VMVN_i_A1enc_A_txt(s_774_8, s_774_14, s_774_20, s_774_26, s_774_32, s_774_38, s_774_44)
        let s_774_45: () = decode_aarch32_instrs_VMVN_i_A1enc_A_txt(
            state,
            tracer,
            s_774_8,
            s_774_14,
            s_774_20,
            s_774_26,
            s_774_32,
            s_774_38,
            s_774_44,
        );
        // N s_774_46: return
        return;
    }
    fn block_775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_775_0: read-var merge#var.1:struct
        let s_775_0: u32 = fn_state.merge_var._1;
        // D s_775_1: write-var u#31335 <= s_775_0
        fn_state.u_31335 = s_775_0;
        // C s_775_2: const #25s : i
        let s_775_2: i128 = 25;
        // D s_775_3: read-var u#31335:u32
        let s_775_3: u32 = fn_state.u_31335;
        // D s_775_4: cast zx s_775_3 -> bv
        let s_775_4: Bits = Bits::new(s_775_3 as u128, 32u16);
        // C s_775_5: const #1s : i64
        let s_775_5: i64 = 1;
        // C s_775_6: cast zx s_775_5 -> i
        let s_775_6: i128 = (i128::try_from(s_775_5).unwrap());
        // C s_775_7: const #6s : i
        let s_775_7: i128 = 6;
        // C s_775_8: add s_775_7 s_775_6
        let s_775_8: i128 = (s_775_7 + s_775_6);
        // D s_775_9: bit-extract s_775_4 s_775_2 s_775_8
        let s_775_9: Bits = (Bits::new(
            ((s_775_4) >> (s_775_2)).value(),
            u16::try_from(s_775_8).unwrap(),
        ));
        // D s_775_10: cast reint s_775_9 -> u8
        let s_775_10: u8 = (s_775_9.value() as u8);
        // D s_775_11: cast zx s_775_10 -> bv
        let s_775_11: Bits = Bits::new(s_775_10 as u128, 7u16);
        // C s_775_12: const #121u : u8
        let s_775_12: u8 = 121;
        // C s_775_13: cast zx s_775_12 -> bv
        let s_775_13: Bits = Bits::new(s_775_12 as u128, 7u16);
        // D s_775_14: cmp-eq s_775_11 s_775_13
        let s_775_14: bool = ((s_775_11) == (s_775_13));
        // N s_775_15: branch s_775_14 b2485 b776
        if s_775_14 {
            return block_2485(state, tracer, fn_state);
        } else {
            return block_776(state, tracer, fn_state);
        };
    }
    fn block_776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_776_0: const #0u : u8
        let s_776_0: bool = false;
        // D s_776_1: write-var gs#400391 <= s_776_0
        fn_state.gs_400391 = s_776_0;
        // N s_776_2: jump b777
        return block_777(state, tracer, fn_state);
    }
    fn block_777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_777_0: read-var gs#400391:u8
        let s_777_0: bool = fn_state.gs_400391;
        // N s_777_1: branch s_777_0 b2484 b778
        if s_777_0 {
            return block_2484(state, tracer, fn_state);
        } else {
            return block_778(state, tracer, fn_state);
        };
    }
    fn block_778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_778_0: const #0u : u8
        let s_778_0: bool = false;
        // D s_778_1: write-var gs#400393 <= s_778_0
        fn_state.gs_400393 = s_778_0;
        // N s_778_2: jump b779
        return block_779(state, tracer, fn_state);
    }
    fn block_779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_779_0: read-var gs#400393:u8
        let s_779_0: bool = fn_state.gs_400393;
        // D s_779_1: not s_779_0
        let s_779_1: bool = !s_779_0;
        // N s_779_2: branch s_779_1 b781 b780
        if s_779_1 {
            return block_781(state, tracer, fn_state);
        } else {
            return block_780(state, tracer, fn_state);
        };
    }
    fn block_780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_780_0: const #3565s : i
        let s_780_0: i128 = 3565;
        // C s_780_1: const #14696u : u32
        let s_780_1: u32 = 14696;
        // N s_780_2: write-reg s_780_1 <= s_780_0
        let s_780_2: () = {
            state.write_register::<i128>(s_780_1 as isize, s_780_0);
            tracer.write_register(s_780_1 as isize, s_780_0);
        };
        // C s_780_3: const #24s : i
        let s_780_3: i128 = 24;
        // C s_780_4: const #1s : i
        let s_780_4: i128 = 1;
        // D s_780_5: read-var u#31335:u32
        let s_780_5: u32 = fn_state.u_31335;
        // D s_780_6: cast zx s_780_5 -> bv
        let s_780_6: Bits = Bits::new(s_780_5 as u128, 32u16);
        // D s_780_7: bit-extract s_780_6 s_780_3 s_780_4
        let s_780_7: Bits = (Bits::new(
            ((s_780_6) >> (s_780_3)).value(),
            u16::try_from(s_780_4).unwrap(),
        ));
        // D s_780_8: cast reint s_780_7 -> u8
        let s_780_8: bool = ((s_780_7.value()) != 0);
        // C s_780_9: const #22s : i
        let s_780_9: i128 = 22;
        // C s_780_10: const #1s : i
        let s_780_10: i128 = 1;
        // D s_780_11: read-var u#31335:u32
        let s_780_11: u32 = fn_state.u_31335;
        // D s_780_12: cast zx s_780_11 -> bv
        let s_780_12: Bits = Bits::new(s_780_11 as u128, 32u16);
        // D s_780_13: bit-extract s_780_12 s_780_9 s_780_10
        let s_780_13: Bits = (Bits::new(
            ((s_780_12) >> (s_780_9)).value(),
            u16::try_from(s_780_10).unwrap(),
        ));
        // D s_780_14: cast reint s_780_13 -> u8
        let s_780_14: bool = ((s_780_13.value()) != 0);
        // C s_780_15: const #16s : i
        let s_780_15: i128 = 16;
        // C s_780_16: const #3s : i
        let s_780_16: i128 = 3;
        // D s_780_17: read-var u#31335:u32
        let s_780_17: u32 = fn_state.u_31335;
        // D s_780_18: cast zx s_780_17 -> bv
        let s_780_18: Bits = Bits::new(s_780_17 as u128, 32u16);
        // D s_780_19: bit-extract s_780_18 s_780_15 s_780_16
        let s_780_19: Bits = (Bits::new(
            ((s_780_18) >> (s_780_15)).value(),
            u16::try_from(s_780_16).unwrap(),
        ));
        // D s_780_20: cast reint s_780_19 -> u8
        let s_780_20: u8 = (s_780_19.value() as u8);
        // C s_780_21: const #12s : i
        let s_780_21: i128 = 12;
        // C s_780_22: const #4s : i
        let s_780_22: i128 = 4;
        // D s_780_23: read-var u#31335:u32
        let s_780_23: u32 = fn_state.u_31335;
        // D s_780_24: cast zx s_780_23 -> bv
        let s_780_24: Bits = Bits::new(s_780_23 as u128, 32u16);
        // D s_780_25: bit-extract s_780_24 s_780_21 s_780_22
        let s_780_25: Bits = (Bits::new(
            ((s_780_24) >> (s_780_21)).value(),
            u16::try_from(s_780_22).unwrap(),
        ));
        // D s_780_26: cast reint s_780_25 -> u8
        let s_780_26: u8 = (s_780_25.value() as u8);
        // C s_780_27: const #8s : i
        let s_780_27: i128 = 8;
        // C s_780_28: const #4s : i
        let s_780_28: i128 = 4;
        // D s_780_29: read-var u#31335:u32
        let s_780_29: u32 = fn_state.u_31335;
        // D s_780_30: cast zx s_780_29 -> bv
        let s_780_30: Bits = Bits::new(s_780_29 as u128, 32u16);
        // D s_780_31: bit-extract s_780_30 s_780_27 s_780_28
        let s_780_31: Bits = (Bits::new(
            ((s_780_30) >> (s_780_27)).value(),
            u16::try_from(s_780_28).unwrap(),
        ));
        // D s_780_32: cast reint s_780_31 -> u8
        let s_780_32: u8 = (s_780_31.value() as u8);
        // C s_780_33: const #6s : i
        let s_780_33: i128 = 6;
        // C s_780_34: const #1s : i
        let s_780_34: i128 = 1;
        // D s_780_35: read-var u#31335:u32
        let s_780_35: u32 = fn_state.u_31335;
        // D s_780_36: cast zx s_780_35 -> bv
        let s_780_36: Bits = Bits::new(s_780_35 as u128, 32u16);
        // D s_780_37: bit-extract s_780_36 s_780_33 s_780_34
        let s_780_37: Bits = (Bits::new(
            ((s_780_36) >> (s_780_33)).value(),
            u16::try_from(s_780_34).unwrap(),
        ));
        // D s_780_38: cast reint s_780_37 -> u8
        let s_780_38: bool = ((s_780_37.value()) != 0);
        // C s_780_39: const #0s : i
        let s_780_39: i128 = 0;
        // C s_780_40: const #4s : i
        let s_780_40: i128 = 4;
        // D s_780_41: read-var u#31335:u32
        let s_780_41: u32 = fn_state.u_31335;
        // D s_780_42: cast zx s_780_41 -> bv
        let s_780_42: Bits = Bits::new(s_780_41 as u128, 32u16);
        // D s_780_43: bit-extract s_780_42 s_780_39 s_780_40
        let s_780_43: Bits = (Bits::new(
            ((s_780_42) >> (s_780_39)).value(),
            u16::try_from(s_780_40).unwrap(),
        ));
        // D s_780_44: cast reint s_780_43 -> u8
        let s_780_44: u8 = (s_780_43.value() as u8);
        // D s_780_45: call decode_aarch32_instrs_VMVN_i_A2enc_A_txt(s_780_8, s_780_14, s_780_20, s_780_26, s_780_32, s_780_38, s_780_44)
        let s_780_45: () = decode_aarch32_instrs_VMVN_i_A2enc_A_txt(
            state,
            tracer,
            s_780_8,
            s_780_14,
            s_780_20,
            s_780_26,
            s_780_32,
            s_780_38,
            s_780_44,
        );
        // N s_780_46: return
        return;
    }
    fn block_781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_781_0: read-var merge#var.1:struct
        let s_781_0: u32 = fn_state.merge_var._1;
        // D s_781_1: write-var u#31344 <= s_781_0
        fn_state.u_31344 = s_781_0;
        // C s_781_2: const #25s : i
        let s_781_2: i128 = 25;
        // D s_781_3: read-var u#31344:u32
        let s_781_3: u32 = fn_state.u_31344;
        // D s_781_4: cast zx s_781_3 -> bv
        let s_781_4: Bits = Bits::new(s_781_3 as u128, 32u16);
        // C s_781_5: const #1s : i64
        let s_781_5: i64 = 1;
        // C s_781_6: cast zx s_781_5 -> i
        let s_781_6: i128 = (i128::try_from(s_781_5).unwrap());
        // C s_781_7: const #6s : i
        let s_781_7: i128 = 6;
        // C s_781_8: add s_781_7 s_781_6
        let s_781_8: i128 = (s_781_7 + s_781_6);
        // D s_781_9: bit-extract s_781_4 s_781_2 s_781_8
        let s_781_9: Bits = (Bits::new(
            ((s_781_4) >> (s_781_2)).value(),
            u16::try_from(s_781_8).unwrap(),
        ));
        // D s_781_10: cast reint s_781_9 -> u8
        let s_781_10: u8 = (s_781_9.value() as u8);
        // D s_781_11: cast zx s_781_10 -> bv
        let s_781_11: Bits = Bits::new(s_781_10 as u128, 7u16);
        // C s_781_12: const #121u : u8
        let s_781_12: u8 = 121;
        // C s_781_13: cast zx s_781_12 -> bv
        let s_781_13: Bits = Bits::new(s_781_12 as u128, 7u16);
        // D s_781_14: cmp-eq s_781_11 s_781_13
        let s_781_14: bool = ((s_781_11) == (s_781_13));
        // N s_781_15: branch s_781_14 b2471 b782
        if s_781_14 {
            return block_2471(state, tracer, fn_state);
        } else {
            return block_782(state, tracer, fn_state);
        };
    }
    fn block_782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_782_0: const #0u : u8
        let s_782_0: bool = false;
        // D s_782_1: write-var gs#400427 <= s_782_0
        fn_state.gs_400427 = s_782_0;
        // N s_782_2: jump b783
        return block_783(state, tracer, fn_state);
    }
    fn block_783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_783_0: read-var gs#400427:u8
        let s_783_0: bool = fn_state.gs_400427;
        // N s_783_1: branch s_783_0 b2470 b784
        if s_783_0 {
            return block_2470(state, tracer, fn_state);
        } else {
            return block_784(state, tracer, fn_state);
        };
    }
    fn block_784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_784_0: const #0u : u8
        let s_784_0: bool = false;
        // D s_784_1: write-var gs#400429 <= s_784_0
        fn_state.gs_400429 = s_784_0;
        // N s_784_2: jump b785
        return block_785(state, tracer, fn_state);
    }
    fn block_785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_785_0: read-var gs#400429:u8
        let s_785_0: bool = fn_state.gs_400429;
        // D s_785_1: not s_785_0
        let s_785_1: bool = !s_785_0;
        // N s_785_2: branch s_785_1 b787 b786
        if s_785_1 {
            return block_787(state, tracer, fn_state);
        } else {
            return block_786(state, tracer, fn_state);
        };
    }
    fn block_786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_786_0: const #3566s : i
        let s_786_0: i128 = 3566;
        // C s_786_1: const #14696u : u32
        let s_786_1: u32 = 14696;
        // N s_786_2: write-reg s_786_1 <= s_786_0
        let s_786_2: () = {
            state.write_register::<i128>(s_786_1 as isize, s_786_0);
            tracer.write_register(s_786_1 as isize, s_786_0);
        };
        // C s_786_3: const #24s : i
        let s_786_3: i128 = 24;
        // C s_786_4: const #1s : i
        let s_786_4: i128 = 1;
        // D s_786_5: read-var u#31344:u32
        let s_786_5: u32 = fn_state.u_31344;
        // D s_786_6: cast zx s_786_5 -> bv
        let s_786_6: Bits = Bits::new(s_786_5 as u128, 32u16);
        // D s_786_7: bit-extract s_786_6 s_786_3 s_786_4
        let s_786_7: Bits = (Bits::new(
            ((s_786_6) >> (s_786_3)).value(),
            u16::try_from(s_786_4).unwrap(),
        ));
        // D s_786_8: cast reint s_786_7 -> u8
        let s_786_8: bool = ((s_786_7.value()) != 0);
        // C s_786_9: const #22s : i
        let s_786_9: i128 = 22;
        // C s_786_10: const #1s : i
        let s_786_10: i128 = 1;
        // D s_786_11: read-var u#31344:u32
        let s_786_11: u32 = fn_state.u_31344;
        // D s_786_12: cast zx s_786_11 -> bv
        let s_786_12: Bits = Bits::new(s_786_11 as u128, 32u16);
        // D s_786_13: bit-extract s_786_12 s_786_9 s_786_10
        let s_786_13: Bits = (Bits::new(
            ((s_786_12) >> (s_786_9)).value(),
            u16::try_from(s_786_10).unwrap(),
        ));
        // D s_786_14: cast reint s_786_13 -> u8
        let s_786_14: bool = ((s_786_13.value()) != 0);
        // C s_786_15: const #16s : i
        let s_786_15: i128 = 16;
        // C s_786_16: const #3s : i
        let s_786_16: i128 = 3;
        // D s_786_17: read-var u#31344:u32
        let s_786_17: u32 = fn_state.u_31344;
        // D s_786_18: cast zx s_786_17 -> bv
        let s_786_18: Bits = Bits::new(s_786_17 as u128, 32u16);
        // D s_786_19: bit-extract s_786_18 s_786_15 s_786_16
        let s_786_19: Bits = (Bits::new(
            ((s_786_18) >> (s_786_15)).value(),
            u16::try_from(s_786_16).unwrap(),
        ));
        // D s_786_20: cast reint s_786_19 -> u8
        let s_786_20: u8 = (s_786_19.value() as u8);
        // C s_786_21: const #12s : i
        let s_786_21: i128 = 12;
        // C s_786_22: const #4s : i
        let s_786_22: i128 = 4;
        // D s_786_23: read-var u#31344:u32
        let s_786_23: u32 = fn_state.u_31344;
        // D s_786_24: cast zx s_786_23 -> bv
        let s_786_24: Bits = Bits::new(s_786_23 as u128, 32u16);
        // D s_786_25: bit-extract s_786_24 s_786_21 s_786_22
        let s_786_25: Bits = (Bits::new(
            ((s_786_24) >> (s_786_21)).value(),
            u16::try_from(s_786_22).unwrap(),
        ));
        // D s_786_26: cast reint s_786_25 -> u8
        let s_786_26: u8 = (s_786_25.value() as u8);
        // C s_786_27: const #8s : i
        let s_786_27: i128 = 8;
        // C s_786_28: const #4s : i
        let s_786_28: i128 = 4;
        // D s_786_29: read-var u#31344:u32
        let s_786_29: u32 = fn_state.u_31344;
        // D s_786_30: cast zx s_786_29 -> bv
        let s_786_30: Bits = Bits::new(s_786_29 as u128, 32u16);
        // D s_786_31: bit-extract s_786_30 s_786_27 s_786_28
        let s_786_31: Bits = (Bits::new(
            ((s_786_30) >> (s_786_27)).value(),
            u16::try_from(s_786_28).unwrap(),
        ));
        // D s_786_32: cast reint s_786_31 -> u8
        let s_786_32: u8 = (s_786_31.value() as u8);
        // C s_786_33: const #6s : i
        let s_786_33: i128 = 6;
        // C s_786_34: const #1s : i
        let s_786_34: i128 = 1;
        // D s_786_35: read-var u#31344:u32
        let s_786_35: u32 = fn_state.u_31344;
        // D s_786_36: cast zx s_786_35 -> bv
        let s_786_36: Bits = Bits::new(s_786_35 as u128, 32u16);
        // D s_786_37: bit-extract s_786_36 s_786_33 s_786_34
        let s_786_37: Bits = (Bits::new(
            ((s_786_36) >> (s_786_33)).value(),
            u16::try_from(s_786_34).unwrap(),
        ));
        // D s_786_38: cast reint s_786_37 -> u8
        let s_786_38: bool = ((s_786_37.value()) != 0);
        // C s_786_39: const #0s : i
        let s_786_39: i128 = 0;
        // C s_786_40: const #4s : i
        let s_786_40: i128 = 4;
        // D s_786_41: read-var u#31344:u32
        let s_786_41: u32 = fn_state.u_31344;
        // D s_786_42: cast zx s_786_41 -> bv
        let s_786_42: Bits = Bits::new(s_786_41 as u128, 32u16);
        // D s_786_43: bit-extract s_786_42 s_786_39 s_786_40
        let s_786_43: Bits = (Bits::new(
            ((s_786_42) >> (s_786_39)).value(),
            u16::try_from(s_786_40).unwrap(),
        ));
        // D s_786_44: cast reint s_786_43 -> u8
        let s_786_44: u8 = (s_786_43.value() as u8);
        // D s_786_45: call decode_aarch32_instrs_VMVN_i_A3enc_A_txt(s_786_8, s_786_14, s_786_20, s_786_26, s_786_32, s_786_38, s_786_44)
        let s_786_45: () = decode_aarch32_instrs_VMVN_i_A3enc_A_txt(
            state,
            tracer,
            s_786_8,
            s_786_14,
            s_786_20,
            s_786_26,
            s_786_32,
            s_786_38,
            s_786_44,
        );
        // N s_786_46: return
        return;
    }
    fn block_787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_787_0: read-var merge#var.1:struct
        let s_787_0: u32 = fn_state.merge_var._1;
        // D s_787_1: write-var u#31353 <= s_787_0
        fn_state.u_31353 = s_787_0;
        // C s_787_2: const #23s : i
        let s_787_2: i128 = 23;
        // D s_787_3: read-var u#31353:u32
        let s_787_3: u32 = fn_state.u_31353;
        // D s_787_4: cast zx s_787_3 -> bv
        let s_787_4: Bits = Bits::new(s_787_3 as u128, 32u16);
        // C s_787_5: const #1s : i64
        let s_787_5: i64 = 1;
        // C s_787_6: cast zx s_787_5 -> i
        let s_787_6: i128 = (i128::try_from(s_787_5).unwrap());
        // C s_787_7: const #8s : i
        let s_787_7: i128 = 8;
        // C s_787_8: add s_787_7 s_787_6
        let s_787_8: i128 = (s_787_7 + s_787_6);
        // D s_787_9: bit-extract s_787_4 s_787_2 s_787_8
        let s_787_9: Bits = (Bits::new(
            ((s_787_4) >> (s_787_2)).value(),
            u16::try_from(s_787_8).unwrap(),
        ));
        // D s_787_10: cast reint s_787_9 -> u9
        let s_787_10: u16 = (s_787_9.value() as u16);
        // D s_787_11: cast zx s_787_10 -> bv
        let s_787_11: Bits = Bits::new(s_787_10 as u128, 9u16);
        // C s_787_12: const #487u : u9
        let s_787_12: u16 = 487;
        // C s_787_13: cast zx s_787_12 -> bv
        let s_787_13: Bits = Bits::new(s_787_12 as u128, 9u16);
        // D s_787_14: cmp-eq s_787_11 s_787_13
        let s_787_14: bool = ((s_787_11) == (s_787_13));
        // N s_787_15: branch s_787_14 b2460 b788
        if s_787_14 {
            return block_2460(state, tracer, fn_state);
        } else {
            return block_788(state, tracer, fn_state);
        };
    }
    fn block_788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_788_0: const #0u : u8
        let s_788_0: bool = false;
        // D s_788_1: write-var gs#400460 <= s_788_0
        fn_state.gs_400460 = s_788_0;
        // N s_788_2: jump b789
        return block_789(state, tracer, fn_state);
    }
    fn block_789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_789_0: read-var gs#400460:u8
        let s_789_0: bool = fn_state.gs_400460;
        // N s_789_1: branch s_789_0 b2459 b790
        if s_789_0 {
            return block_2459(state, tracer, fn_state);
        } else {
            return block_790(state, tracer, fn_state);
        };
    }
    fn block_790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_790_0: const #0u : u8
        let s_790_0: bool = false;
        // D s_790_1: write-var gs#400462 <= s_790_0
        fn_state.gs_400462 = s_790_0;
        // N s_790_2: jump b791
        return block_791(state, tracer, fn_state);
    }
    fn block_791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_791_0: read-var gs#400462:u8
        let s_791_0: bool = fn_state.gs_400462;
        // D s_791_1: not s_791_0
        let s_791_1: bool = !s_791_0;
        // N s_791_2: branch s_791_1 b793 b792
        if s_791_1 {
            return block_793(state, tracer, fn_state);
        } else {
            return block_792(state, tracer, fn_state);
        };
    }
    fn block_792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_792_0: const #3570s : i
        let s_792_0: i128 = 3570;
        // C s_792_1: const #14696u : u32
        let s_792_1: u32 = 14696;
        // N s_792_2: write-reg s_792_1 <= s_792_0
        let s_792_2: () = {
            state.write_register::<i128>(s_792_1 as isize, s_792_0);
            tracer.write_register(s_792_1 as isize, s_792_0);
        };
        // C s_792_3: const #22s : i
        let s_792_3: i128 = 22;
        // C s_792_4: const #1s : i
        let s_792_4: i128 = 1;
        // D s_792_5: read-var u#31353:u32
        let s_792_5: u32 = fn_state.u_31353;
        // D s_792_6: cast zx s_792_5 -> bv
        let s_792_6: Bits = Bits::new(s_792_5 as u128, 32u16);
        // D s_792_7: bit-extract s_792_6 s_792_3 s_792_4
        let s_792_7: Bits = (Bits::new(
            ((s_792_6) >> (s_792_3)).value(),
            u16::try_from(s_792_4).unwrap(),
        ));
        // D s_792_8: cast reint s_792_7 -> u8
        let s_792_8: bool = ((s_792_7.value()) != 0);
        // C s_792_9: const #18s : i
        let s_792_9: i128 = 18;
        // C s_792_10: const #2s : i
        let s_792_10: i128 = 2;
        // D s_792_11: read-var u#31353:u32
        let s_792_11: u32 = fn_state.u_31353;
        // D s_792_12: cast zx s_792_11 -> bv
        let s_792_12: Bits = Bits::new(s_792_11 as u128, 32u16);
        // D s_792_13: bit-extract s_792_12 s_792_9 s_792_10
        let s_792_13: Bits = (Bits::new(
            ((s_792_12) >> (s_792_9)).value(),
            u16::try_from(s_792_10).unwrap(),
        ));
        // D s_792_14: cast reint s_792_13 -> u8
        let s_792_14: u8 = (s_792_13.value() as u8);
        // C s_792_15: const #12s : i
        let s_792_15: i128 = 12;
        // C s_792_16: const #4s : i
        let s_792_16: i128 = 4;
        // D s_792_17: read-var u#31353:u32
        let s_792_17: u32 = fn_state.u_31353;
        // D s_792_18: cast zx s_792_17 -> bv
        let s_792_18: Bits = Bits::new(s_792_17 as u128, 32u16);
        // D s_792_19: bit-extract s_792_18 s_792_15 s_792_16
        let s_792_19: Bits = (Bits::new(
            ((s_792_18) >> (s_792_15)).value(),
            u16::try_from(s_792_16).unwrap(),
        ));
        // D s_792_20: cast reint s_792_19 -> u8
        let s_792_20: u8 = (s_792_19.value() as u8);
        // C s_792_21: const #6s : i
        let s_792_21: i128 = 6;
        // C s_792_22: const #1s : i
        let s_792_22: i128 = 1;
        // D s_792_23: read-var u#31353:u32
        let s_792_23: u32 = fn_state.u_31353;
        // D s_792_24: cast zx s_792_23 -> bv
        let s_792_24: Bits = Bits::new(s_792_23 as u128, 32u16);
        // D s_792_25: bit-extract s_792_24 s_792_21 s_792_22
        let s_792_25: Bits = (Bits::new(
            ((s_792_24) >> (s_792_21)).value(),
            u16::try_from(s_792_22).unwrap(),
        ));
        // D s_792_26: cast reint s_792_25 -> u8
        let s_792_26: bool = ((s_792_25.value()) != 0);
        // C s_792_27: const #5s : i
        let s_792_27: i128 = 5;
        // C s_792_28: const #1s : i
        let s_792_28: i128 = 1;
        // D s_792_29: read-var u#31353:u32
        let s_792_29: u32 = fn_state.u_31353;
        // D s_792_30: cast zx s_792_29 -> bv
        let s_792_30: Bits = Bits::new(s_792_29 as u128, 32u16);
        // D s_792_31: bit-extract s_792_30 s_792_27 s_792_28
        let s_792_31: Bits = (Bits::new(
            ((s_792_30) >> (s_792_27)).value(),
            u16::try_from(s_792_28).unwrap(),
        ));
        // D s_792_32: cast reint s_792_31 -> u8
        let s_792_32: bool = ((s_792_31.value()) != 0);
        // C s_792_33: const #0s : i
        let s_792_33: i128 = 0;
        // C s_792_34: const #4s : i
        let s_792_34: i128 = 4;
        // D s_792_35: read-var u#31353:u32
        let s_792_35: u32 = fn_state.u_31353;
        // D s_792_36: cast zx s_792_35 -> bv
        let s_792_36: Bits = Bits::new(s_792_35 as u128, 32u16);
        // D s_792_37: bit-extract s_792_36 s_792_33 s_792_34
        let s_792_37: Bits = (Bits::new(
            ((s_792_36) >> (s_792_33)).value(),
            u16::try_from(s_792_34).unwrap(),
        ));
        // D s_792_38: cast reint s_792_37 -> u8
        let s_792_38: u8 = (s_792_37.value() as u8);
        // D s_792_39: call decode_aarch32_instrs_VMVN_r_A1enc_A_txt(s_792_8, s_792_14, s_792_20, s_792_26, s_792_32, s_792_38)
        let s_792_39: () = decode_aarch32_instrs_VMVN_r_A1enc_A_txt(
            state,
            tracer,
            s_792_8,
            s_792_14,
            s_792_20,
            s_792_26,
            s_792_32,
            s_792_38,
        );
        // N s_792_40: return
        return;
    }
    fn block_793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_793_0: read-var merge#var.1:struct
        let s_793_0: u32 = fn_state.merge_var._1;
        // D s_793_1: write-var u#31361 <= s_793_0
        fn_state.u_31361 = s_793_0;
        // C s_793_2: const #23s : i
        let s_793_2: i128 = 23;
        // D s_793_3: read-var u#31361:u32
        let s_793_3: u32 = fn_state.u_31361;
        // D s_793_4: cast zx s_793_3 -> bv
        let s_793_4: Bits = Bits::new(s_793_3 as u128, 32u16);
        // C s_793_5: const #1s : i64
        let s_793_5: i64 = 1;
        // C s_793_6: cast zx s_793_5 -> i
        let s_793_6: i128 = (i128::try_from(s_793_5).unwrap());
        // C s_793_7: const #8s : i
        let s_793_7: i128 = 8;
        // C s_793_8: add s_793_7 s_793_6
        let s_793_8: i128 = (s_793_7 + s_793_6);
        // D s_793_9: bit-extract s_793_4 s_793_2 s_793_8
        let s_793_9: Bits = (Bits::new(
            ((s_793_4) >> (s_793_2)).value(),
            u16::try_from(s_793_8).unwrap(),
        ));
        // D s_793_10: cast reint s_793_9 -> u9
        let s_793_10: u16 = (s_793_9.value() as u16);
        // D s_793_11: cast zx s_793_10 -> bv
        let s_793_11: Bits = Bits::new(s_793_10 as u128, 9u16);
        // C s_793_12: const #487u : u9
        let s_793_12: u16 = 487;
        // C s_793_13: cast zx s_793_12 -> bv
        let s_793_13: Bits = Bits::new(s_793_12 as u128, 9u16);
        // D s_793_14: cmp-eq s_793_11 s_793_13
        let s_793_14: bool = ((s_793_11) == (s_793_13));
        // N s_793_15: branch s_793_14 b2446 b794
        if s_793_14 {
            return block_2446(state, tracer, fn_state);
        } else {
            return block_794(state, tracer, fn_state);
        };
    }
    fn block_794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_794_0: const #0u : u8
        let s_794_0: bool = false;
        // D s_794_1: write-var gs#400494 <= s_794_0
        fn_state.gs_400494 = s_794_0;
        // N s_794_2: jump b795
        return block_795(state, tracer, fn_state);
    }
    fn block_795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_795_0: read-var gs#400494:u8
        let s_795_0: bool = fn_state.gs_400494;
        // N s_795_1: branch s_795_0 b2445 b796
        if s_795_0 {
            return block_2445(state, tracer, fn_state);
        } else {
            return block_796(state, tracer, fn_state);
        };
    }
    fn block_796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_796_0: const #0u : u8
        let s_796_0: bool = false;
        // D s_796_1: write-var gs#400496 <= s_796_0
        fn_state.gs_400496 = s_796_0;
        // N s_796_2: jump b797
        return block_797(state, tracer, fn_state);
    }
    fn block_797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_797_0: read-var gs#400496:u8
        let s_797_0: bool = fn_state.gs_400496;
        // D s_797_1: not s_797_0
        let s_797_1: bool = !s_797_0;
        // N s_797_2: branch s_797_1 b799 b798
        if s_797_1 {
            return block_799(state, tracer, fn_state);
        } else {
            return block_798(state, tracer, fn_state);
        };
    }
    fn block_798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_798_0: const #3572s : i
        let s_798_0: i128 = 3572;
        // C s_798_1: const #14696u : u32
        let s_798_1: u32 = 14696;
        // N s_798_2: write-reg s_798_1 <= s_798_0
        let s_798_2: () = {
            state.write_register::<i128>(s_798_1 as isize, s_798_0);
            tracer.write_register(s_798_1 as isize, s_798_0);
        };
        // C s_798_3: const #22s : i
        let s_798_3: i128 = 22;
        // C s_798_4: const #1s : i
        let s_798_4: i128 = 1;
        // D s_798_5: read-var u#31361:u32
        let s_798_5: u32 = fn_state.u_31361;
        // D s_798_6: cast zx s_798_5 -> bv
        let s_798_6: Bits = Bits::new(s_798_5 as u128, 32u16);
        // D s_798_7: bit-extract s_798_6 s_798_3 s_798_4
        let s_798_7: Bits = (Bits::new(
            ((s_798_6) >> (s_798_3)).value(),
            u16::try_from(s_798_4).unwrap(),
        ));
        // D s_798_8: cast reint s_798_7 -> u8
        let s_798_8: bool = ((s_798_7.value()) != 0);
        // C s_798_9: const #18s : i
        let s_798_9: i128 = 18;
        // C s_798_10: const #2s : i
        let s_798_10: i128 = 2;
        // D s_798_11: read-var u#31361:u32
        let s_798_11: u32 = fn_state.u_31361;
        // D s_798_12: cast zx s_798_11 -> bv
        let s_798_12: Bits = Bits::new(s_798_11 as u128, 32u16);
        // D s_798_13: bit-extract s_798_12 s_798_9 s_798_10
        let s_798_13: Bits = (Bits::new(
            ((s_798_12) >> (s_798_9)).value(),
            u16::try_from(s_798_10).unwrap(),
        ));
        // D s_798_14: cast reint s_798_13 -> u8
        let s_798_14: u8 = (s_798_13.value() as u8);
        // C s_798_15: const #12s : i
        let s_798_15: i128 = 12;
        // C s_798_16: const #4s : i
        let s_798_16: i128 = 4;
        // D s_798_17: read-var u#31361:u32
        let s_798_17: u32 = fn_state.u_31361;
        // D s_798_18: cast zx s_798_17 -> bv
        let s_798_18: Bits = Bits::new(s_798_17 as u128, 32u16);
        // D s_798_19: bit-extract s_798_18 s_798_15 s_798_16
        let s_798_19: Bits = (Bits::new(
            ((s_798_18) >> (s_798_15)).value(),
            u16::try_from(s_798_16).unwrap(),
        ));
        // D s_798_20: cast reint s_798_19 -> u8
        let s_798_20: u8 = (s_798_19.value() as u8);
        // C s_798_21: const #10s : i
        let s_798_21: i128 = 10;
        // C s_798_22: const #1s : i
        let s_798_22: i128 = 1;
        // D s_798_23: read-var u#31361:u32
        let s_798_23: u32 = fn_state.u_31361;
        // D s_798_24: cast zx s_798_23 -> bv
        let s_798_24: Bits = Bits::new(s_798_23 as u128, 32u16);
        // D s_798_25: bit-extract s_798_24 s_798_21 s_798_22
        let s_798_25: Bits = (Bits::new(
            ((s_798_24) >> (s_798_21)).value(),
            u16::try_from(s_798_22).unwrap(),
        ));
        // D s_798_26: cast reint s_798_25 -> u8
        let s_798_26: bool = ((s_798_25.value()) != 0);
        // C s_798_27: const #6s : i
        let s_798_27: i128 = 6;
        // C s_798_28: const #1s : i
        let s_798_28: i128 = 1;
        // D s_798_29: read-var u#31361:u32
        let s_798_29: u32 = fn_state.u_31361;
        // D s_798_30: cast zx s_798_29 -> bv
        let s_798_30: Bits = Bits::new(s_798_29 as u128, 32u16);
        // D s_798_31: bit-extract s_798_30 s_798_27 s_798_28
        let s_798_31: Bits = (Bits::new(
            ((s_798_30) >> (s_798_27)).value(),
            u16::try_from(s_798_28).unwrap(),
        ));
        // D s_798_32: cast reint s_798_31 -> u8
        let s_798_32: bool = ((s_798_31.value()) != 0);
        // C s_798_33: const #5s : i
        let s_798_33: i128 = 5;
        // C s_798_34: const #1s : i
        let s_798_34: i128 = 1;
        // D s_798_35: read-var u#31361:u32
        let s_798_35: u32 = fn_state.u_31361;
        // D s_798_36: cast zx s_798_35 -> bv
        let s_798_36: Bits = Bits::new(s_798_35 as u128, 32u16);
        // D s_798_37: bit-extract s_798_36 s_798_33 s_798_34
        let s_798_37: Bits = (Bits::new(
            ((s_798_36) >> (s_798_33)).value(),
            u16::try_from(s_798_34).unwrap(),
        ));
        // D s_798_38: cast reint s_798_37 -> u8
        let s_798_38: bool = ((s_798_37.value()) != 0);
        // C s_798_39: const #0s : i
        let s_798_39: i128 = 0;
        // C s_798_40: const #4s : i
        let s_798_40: i128 = 4;
        // D s_798_41: read-var u#31361:u32
        let s_798_41: u32 = fn_state.u_31361;
        // D s_798_42: cast zx s_798_41 -> bv
        let s_798_42: Bits = Bits::new(s_798_41 as u128, 32u16);
        // D s_798_43: bit-extract s_798_42 s_798_39 s_798_40
        let s_798_43: Bits = (Bits::new(
            ((s_798_42) >> (s_798_39)).value(),
            u16::try_from(s_798_40).unwrap(),
        ));
        // D s_798_44: cast reint s_798_43 -> u8
        let s_798_44: u8 = (s_798_43.value() as u8);
        // D s_798_45: call decode_aarch32_instrs_VNEG_A1enc_A_txt(s_798_8, s_798_14, s_798_20, s_798_26, s_798_32, s_798_38, s_798_44)
        let s_798_45: () = decode_aarch32_instrs_VNEG_A1enc_A_txt(
            state,
            tracer,
            s_798_8,
            s_798_14,
            s_798_20,
            s_798_26,
            s_798_32,
            s_798_38,
            s_798_44,
        );
        // N s_798_46: return
        return;
    }
    fn block_799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_799_0: read-var merge#var.1:struct
        let s_799_0: u32 = fn_state.merge_var._1;
        // D s_799_1: write-var u#31370 <= s_799_0
        fn_state.u_31370 = s_799_0;
        // C s_799_2: const #23s : i
        let s_799_2: i128 = 23;
        // D s_799_3: read-var u#31370:u32
        let s_799_3: u32 = fn_state.u_31370;
        // D s_799_4: cast zx s_799_3 -> bv
        let s_799_4: Bits = Bits::new(s_799_3 as u128, 32u16);
        // C s_799_5: const #1s : i64
        let s_799_5: i64 = 1;
        // C s_799_6: cast zx s_799_5 -> i
        let s_799_6: i128 = (i128::try_from(s_799_5).unwrap());
        // C s_799_7: const #8s : i
        let s_799_7: i128 = 8;
        // C s_799_8: add s_799_7 s_799_6
        let s_799_8: i128 = (s_799_7 + s_799_6);
        // D s_799_9: bit-extract s_799_4 s_799_2 s_799_8
        let s_799_9: Bits = (Bits::new(
            ((s_799_4) >> (s_799_2)).value(),
            u16::try_from(s_799_8).unwrap(),
        ));
        // D s_799_10: cast reint s_799_9 -> u9
        let s_799_10: u16 = (s_799_9.value() as u16);
        // D s_799_11: cast zx s_799_10 -> bv
        let s_799_11: Bits = Bits::new(s_799_10 as u128, 9u16);
        // C s_799_12: const #484u : u9
        let s_799_12: u16 = 484;
        // C s_799_13: cast zx s_799_12 -> bv
        let s_799_13: Bits = Bits::new(s_799_12 as u128, 9u16);
        // D s_799_14: cmp-eq s_799_11 s_799_13
        let s_799_14: bool = ((s_799_11) == (s_799_13));
        // N s_799_15: branch s_799_14 b2438 b800
        if s_799_14 {
            return block_2438(state, tracer, fn_state);
        } else {
            return block_800(state, tracer, fn_state);
        };
    }
    fn block_800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_800_0: const #0u : u8
        let s_800_0: bool = false;
        // D s_800_1: write-var gs#400524 <= s_800_0
        fn_state.gs_400524 = s_800_0;
        // N s_800_2: jump b801
        return block_801(state, tracer, fn_state);
    }
    fn block_801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_801_0: read-var gs#400524:u8
        let s_801_0: bool = fn_state.gs_400524;
        // N s_801_1: branch s_801_0 b2437 b802
        if s_801_0 {
            return block_2437(state, tracer, fn_state);
        } else {
            return block_802(state, tracer, fn_state);
        };
    }
    fn block_802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_802_0: const #0u : u8
        let s_802_0: bool = false;
        // D s_802_1: write-var gs#400526 <= s_802_0
        fn_state.gs_400526 = s_802_0;
        // N s_802_2: jump b803
        return block_803(state, tracer, fn_state);
    }
    fn block_803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_803_0: read-var gs#400526:u8
        let s_803_0: bool = fn_state.gs_400526;
        // D s_803_1: not s_803_0
        let s_803_1: bool = !s_803_0;
        // N s_803_2: branch s_803_1 b805 b804
        if s_803_1 {
            return block_805(state, tracer, fn_state);
        } else {
            return block_804(state, tracer, fn_state);
        };
    }
    fn block_804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_804_0: const #3580s : i
        let s_804_0: i128 = 3580;
        // C s_804_1: const #14696u : u32
        let s_804_1: u32 = 14696;
        // N s_804_2: write-reg s_804_1 <= s_804_0
        let s_804_2: () = {
            state.write_register::<i128>(s_804_1 as isize, s_804_0);
            tracer.write_register(s_804_1 as isize, s_804_0);
        };
        // C s_804_3: const #22s : i
        let s_804_3: i128 = 22;
        // C s_804_4: const #1s : i
        let s_804_4: i128 = 1;
        // D s_804_5: read-var u#31370:u32
        let s_804_5: u32 = fn_state.u_31370;
        // D s_804_6: cast zx s_804_5 -> bv
        let s_804_6: Bits = Bits::new(s_804_5 as u128, 32u16);
        // D s_804_7: bit-extract s_804_6 s_804_3 s_804_4
        let s_804_7: Bits = (Bits::new(
            ((s_804_6) >> (s_804_3)).value(),
            u16::try_from(s_804_4).unwrap(),
        ));
        // D s_804_8: cast reint s_804_7 -> u8
        let s_804_8: bool = ((s_804_7.value()) != 0);
        // C s_804_9: const #16s : i
        let s_804_9: i128 = 16;
        // C s_804_10: const #4s : i
        let s_804_10: i128 = 4;
        // D s_804_11: read-var u#31370:u32
        let s_804_11: u32 = fn_state.u_31370;
        // D s_804_12: cast zx s_804_11 -> bv
        let s_804_12: Bits = Bits::new(s_804_11 as u128, 32u16);
        // D s_804_13: bit-extract s_804_12 s_804_9 s_804_10
        let s_804_13: Bits = (Bits::new(
            ((s_804_12) >> (s_804_9)).value(),
            u16::try_from(s_804_10).unwrap(),
        ));
        // D s_804_14: cast reint s_804_13 -> u8
        let s_804_14: u8 = (s_804_13.value() as u8);
        // C s_804_15: const #12s : i
        let s_804_15: i128 = 12;
        // C s_804_16: const #4s : i
        let s_804_16: i128 = 4;
        // D s_804_17: read-var u#31370:u32
        let s_804_17: u32 = fn_state.u_31370;
        // D s_804_18: cast zx s_804_17 -> bv
        let s_804_18: Bits = Bits::new(s_804_17 as u128, 32u16);
        // D s_804_19: bit-extract s_804_18 s_804_15 s_804_16
        let s_804_19: Bits = (Bits::new(
            ((s_804_18) >> (s_804_15)).value(),
            u16::try_from(s_804_16).unwrap(),
        ));
        // D s_804_20: cast reint s_804_19 -> u8
        let s_804_20: u8 = (s_804_19.value() as u8);
        // C s_804_21: const #7s : i
        let s_804_21: i128 = 7;
        // C s_804_22: const #1s : i
        let s_804_22: i128 = 1;
        // D s_804_23: read-var u#31370:u32
        let s_804_23: u32 = fn_state.u_31370;
        // D s_804_24: cast zx s_804_23 -> bv
        let s_804_24: Bits = Bits::new(s_804_23 as u128, 32u16);
        // D s_804_25: bit-extract s_804_24 s_804_21 s_804_22
        let s_804_25: Bits = (Bits::new(
            ((s_804_24) >> (s_804_21)).value(),
            u16::try_from(s_804_22).unwrap(),
        ));
        // D s_804_26: cast reint s_804_25 -> u8
        let s_804_26: bool = ((s_804_25.value()) != 0);
        // C s_804_27: const #6s : i
        let s_804_27: i128 = 6;
        // C s_804_28: const #1s : i
        let s_804_28: i128 = 1;
        // D s_804_29: read-var u#31370:u32
        let s_804_29: u32 = fn_state.u_31370;
        // D s_804_30: cast zx s_804_29 -> bv
        let s_804_30: Bits = Bits::new(s_804_29 as u128, 32u16);
        // D s_804_31: bit-extract s_804_30 s_804_27 s_804_28
        let s_804_31: Bits = (Bits::new(
            ((s_804_30) >> (s_804_27)).value(),
            u16::try_from(s_804_28).unwrap(),
        ));
        // D s_804_32: cast reint s_804_31 -> u8
        let s_804_32: bool = ((s_804_31.value()) != 0);
        // C s_804_33: const #5s : i
        let s_804_33: i128 = 5;
        // C s_804_34: const #1s : i
        let s_804_34: i128 = 1;
        // D s_804_35: read-var u#31370:u32
        let s_804_35: u32 = fn_state.u_31370;
        // D s_804_36: cast zx s_804_35 -> bv
        let s_804_36: Bits = Bits::new(s_804_35 as u128, 32u16);
        // D s_804_37: bit-extract s_804_36 s_804_33 s_804_34
        let s_804_37: Bits = (Bits::new(
            ((s_804_36) >> (s_804_33)).value(),
            u16::try_from(s_804_34).unwrap(),
        ));
        // D s_804_38: cast reint s_804_37 -> u8
        let s_804_38: bool = ((s_804_37.value()) != 0);
        // C s_804_39: const #0s : i
        let s_804_39: i128 = 0;
        // C s_804_40: const #4s : i
        let s_804_40: i128 = 4;
        // D s_804_41: read-var u#31370:u32
        let s_804_41: u32 = fn_state.u_31370;
        // D s_804_42: cast zx s_804_41 -> bv
        let s_804_42: Bits = Bits::new(s_804_41 as u128, 32u16);
        // D s_804_43: bit-extract s_804_42 s_804_39 s_804_40
        let s_804_43: Bits = (Bits::new(
            ((s_804_42) >> (s_804_39)).value(),
            u16::try_from(s_804_40).unwrap(),
        ));
        // D s_804_44: cast reint s_804_43 -> u8
        let s_804_44: u8 = (s_804_43.value() as u8);
        // D s_804_45: call decode_aarch32_instrs_VORN_r_A1enc_A_txt(s_804_8, s_804_14, s_804_20, s_804_26, s_804_32, s_804_38, s_804_44)
        let s_804_45: () = decode_aarch32_instrs_VORN_r_A1enc_A_txt(
            state,
            tracer,
            s_804_8,
            s_804_14,
            s_804_20,
            s_804_26,
            s_804_32,
            s_804_38,
            s_804_44,
        );
        // N s_804_46: return
        return;
    }
    fn block_805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_805_0: read-var merge#var.1:struct
        let s_805_0: u32 = fn_state.merge_var._1;
        // D s_805_1: write-var u#31379 <= s_805_0
        fn_state.u_31379 = s_805_0;
        // C s_805_2: const #25s : i
        let s_805_2: i128 = 25;
        // D s_805_3: read-var u#31379:u32
        let s_805_3: u32 = fn_state.u_31379;
        // D s_805_4: cast zx s_805_3 -> bv
        let s_805_4: Bits = Bits::new(s_805_3 as u128, 32u16);
        // C s_805_5: const #1s : i64
        let s_805_5: i64 = 1;
        // C s_805_6: cast zx s_805_5 -> i
        let s_805_6: i128 = (i128::try_from(s_805_5).unwrap());
        // C s_805_7: const #6s : i
        let s_805_7: i128 = 6;
        // C s_805_8: add s_805_7 s_805_6
        let s_805_8: i128 = (s_805_7 + s_805_6);
        // D s_805_9: bit-extract s_805_4 s_805_2 s_805_8
        let s_805_9: Bits = (Bits::new(
            ((s_805_4) >> (s_805_2)).value(),
            u16::try_from(s_805_8).unwrap(),
        ));
        // D s_805_10: cast reint s_805_9 -> u8
        let s_805_10: u8 = (s_805_9.value() as u8);
        // D s_805_11: cast zx s_805_10 -> bv
        let s_805_11: Bits = Bits::new(s_805_10 as u128, 7u16);
        // C s_805_12: const #121u : u8
        let s_805_12: u8 = 121;
        // C s_805_13: cast zx s_805_12 -> bv
        let s_805_13: Bits = Bits::new(s_805_12 as u128, 7u16);
        // D s_805_14: cmp-eq s_805_11 s_805_13
        let s_805_14: bool = ((s_805_11) == (s_805_13));
        // N s_805_15: branch s_805_14 b2424 b806
        if s_805_14 {
            return block_2424(state, tracer, fn_state);
        } else {
            return block_806(state, tracer, fn_state);
        };
    }
    fn block_806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_806_0: const #0u : u8
        let s_806_0: bool = false;
        // D s_806_1: write-var gs#400560 <= s_806_0
        fn_state.gs_400560 = s_806_0;
        // N s_806_2: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_807_0: read-var gs#400560:u8
        let s_807_0: bool = fn_state.gs_400560;
        // N s_807_1: branch s_807_0 b2423 b808
        if s_807_0 {
            return block_2423(state, tracer, fn_state);
        } else {
            return block_808(state, tracer, fn_state);
        };
    }
    fn block_808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_808_0: const #0u : u8
        let s_808_0: bool = false;
        // D s_808_1: write-var gs#400562 <= s_808_0
        fn_state.gs_400562 = s_808_0;
        // N s_808_2: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_809_0: read-var gs#400562:u8
        let s_809_0: bool = fn_state.gs_400562;
        // D s_809_1: not s_809_0
        let s_809_1: bool = !s_809_0;
        // N s_809_2: branch s_809_1 b811 b810
        if s_809_1 {
            return block_811(state, tracer, fn_state);
        } else {
            return block_810(state, tracer, fn_state);
        };
    }
    fn block_810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_810_0: const #3582s : i
        let s_810_0: i128 = 3582;
        // C s_810_1: const #14696u : u32
        let s_810_1: u32 = 14696;
        // N s_810_2: write-reg s_810_1 <= s_810_0
        let s_810_2: () = {
            state.write_register::<i128>(s_810_1 as isize, s_810_0);
            tracer.write_register(s_810_1 as isize, s_810_0);
        };
        // C s_810_3: const #24s : i
        let s_810_3: i128 = 24;
        // C s_810_4: const #1s : i
        let s_810_4: i128 = 1;
        // D s_810_5: read-var u#31379:u32
        let s_810_5: u32 = fn_state.u_31379;
        // D s_810_6: cast zx s_810_5 -> bv
        let s_810_6: Bits = Bits::new(s_810_5 as u128, 32u16);
        // D s_810_7: bit-extract s_810_6 s_810_3 s_810_4
        let s_810_7: Bits = (Bits::new(
            ((s_810_6) >> (s_810_3)).value(),
            u16::try_from(s_810_4).unwrap(),
        ));
        // D s_810_8: cast reint s_810_7 -> u8
        let s_810_8: bool = ((s_810_7.value()) != 0);
        // C s_810_9: const #22s : i
        let s_810_9: i128 = 22;
        // C s_810_10: const #1s : i
        let s_810_10: i128 = 1;
        // D s_810_11: read-var u#31379:u32
        let s_810_11: u32 = fn_state.u_31379;
        // D s_810_12: cast zx s_810_11 -> bv
        let s_810_12: Bits = Bits::new(s_810_11 as u128, 32u16);
        // D s_810_13: bit-extract s_810_12 s_810_9 s_810_10
        let s_810_13: Bits = (Bits::new(
            ((s_810_12) >> (s_810_9)).value(),
            u16::try_from(s_810_10).unwrap(),
        ));
        // D s_810_14: cast reint s_810_13 -> u8
        let s_810_14: bool = ((s_810_13.value()) != 0);
        // C s_810_15: const #16s : i
        let s_810_15: i128 = 16;
        // C s_810_16: const #3s : i
        let s_810_16: i128 = 3;
        // D s_810_17: read-var u#31379:u32
        let s_810_17: u32 = fn_state.u_31379;
        // D s_810_18: cast zx s_810_17 -> bv
        let s_810_18: Bits = Bits::new(s_810_17 as u128, 32u16);
        // D s_810_19: bit-extract s_810_18 s_810_15 s_810_16
        let s_810_19: Bits = (Bits::new(
            ((s_810_18) >> (s_810_15)).value(),
            u16::try_from(s_810_16).unwrap(),
        ));
        // D s_810_20: cast reint s_810_19 -> u8
        let s_810_20: u8 = (s_810_19.value() as u8);
        // C s_810_21: const #12s : i
        let s_810_21: i128 = 12;
        // C s_810_22: const #4s : i
        let s_810_22: i128 = 4;
        // D s_810_23: read-var u#31379:u32
        let s_810_23: u32 = fn_state.u_31379;
        // D s_810_24: cast zx s_810_23 -> bv
        let s_810_24: Bits = Bits::new(s_810_23 as u128, 32u16);
        // D s_810_25: bit-extract s_810_24 s_810_21 s_810_22
        let s_810_25: Bits = (Bits::new(
            ((s_810_24) >> (s_810_21)).value(),
            u16::try_from(s_810_22).unwrap(),
        ));
        // D s_810_26: cast reint s_810_25 -> u8
        let s_810_26: u8 = (s_810_25.value() as u8);
        // C s_810_27: const #8s : i
        let s_810_27: i128 = 8;
        // C s_810_28: const #4s : i
        let s_810_28: i128 = 4;
        // D s_810_29: read-var u#31379:u32
        let s_810_29: u32 = fn_state.u_31379;
        // D s_810_30: cast zx s_810_29 -> bv
        let s_810_30: Bits = Bits::new(s_810_29 as u128, 32u16);
        // D s_810_31: bit-extract s_810_30 s_810_27 s_810_28
        let s_810_31: Bits = (Bits::new(
            ((s_810_30) >> (s_810_27)).value(),
            u16::try_from(s_810_28).unwrap(),
        ));
        // D s_810_32: cast reint s_810_31 -> u8
        let s_810_32: u8 = (s_810_31.value() as u8);
        // C s_810_33: const #6s : i
        let s_810_33: i128 = 6;
        // C s_810_34: const #1s : i
        let s_810_34: i128 = 1;
        // D s_810_35: read-var u#31379:u32
        let s_810_35: u32 = fn_state.u_31379;
        // D s_810_36: cast zx s_810_35 -> bv
        let s_810_36: Bits = Bits::new(s_810_35 as u128, 32u16);
        // D s_810_37: bit-extract s_810_36 s_810_33 s_810_34
        let s_810_37: Bits = (Bits::new(
            ((s_810_36) >> (s_810_33)).value(),
            u16::try_from(s_810_34).unwrap(),
        ));
        // D s_810_38: cast reint s_810_37 -> u8
        let s_810_38: bool = ((s_810_37.value()) != 0);
        // C s_810_39: const #0s : i
        let s_810_39: i128 = 0;
        // C s_810_40: const #4s : i
        let s_810_40: i128 = 4;
        // D s_810_41: read-var u#31379:u32
        let s_810_41: u32 = fn_state.u_31379;
        // D s_810_42: cast zx s_810_41 -> bv
        let s_810_42: Bits = Bits::new(s_810_41 as u128, 32u16);
        // D s_810_43: bit-extract s_810_42 s_810_39 s_810_40
        let s_810_43: Bits = (Bits::new(
            ((s_810_42) >> (s_810_39)).value(),
            u16::try_from(s_810_40).unwrap(),
        ));
        // D s_810_44: cast reint s_810_43 -> u8
        let s_810_44: u8 = (s_810_43.value() as u8);
        // D s_810_45: call decode_aarch32_instrs_VORR_i_A1enc_A_txt(s_810_8, s_810_14, s_810_20, s_810_26, s_810_32, s_810_38, s_810_44)
        let s_810_45: () = decode_aarch32_instrs_VORR_i_A1enc_A_txt(
            state,
            tracer,
            s_810_8,
            s_810_14,
            s_810_20,
            s_810_26,
            s_810_32,
            s_810_38,
            s_810_44,
        );
        // N s_810_46: return
        return;
    }
    fn block_811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_811_0: read-var merge#var.1:struct
        let s_811_0: u32 = fn_state.merge_var._1;
        // D s_811_1: write-var u#31388 <= s_811_0
        fn_state.u_31388 = s_811_0;
        // C s_811_2: const #25s : i
        let s_811_2: i128 = 25;
        // D s_811_3: read-var u#31388:u32
        let s_811_3: u32 = fn_state.u_31388;
        // D s_811_4: cast zx s_811_3 -> bv
        let s_811_4: Bits = Bits::new(s_811_3 as u128, 32u16);
        // C s_811_5: const #1s : i64
        let s_811_5: i64 = 1;
        // C s_811_6: cast zx s_811_5 -> i
        let s_811_6: i128 = (i128::try_from(s_811_5).unwrap());
        // C s_811_7: const #6s : i
        let s_811_7: i128 = 6;
        // C s_811_8: add s_811_7 s_811_6
        let s_811_8: i128 = (s_811_7 + s_811_6);
        // D s_811_9: bit-extract s_811_4 s_811_2 s_811_8
        let s_811_9: Bits = (Bits::new(
            ((s_811_4) >> (s_811_2)).value(),
            u16::try_from(s_811_8).unwrap(),
        ));
        // D s_811_10: cast reint s_811_9 -> u8
        let s_811_10: u8 = (s_811_9.value() as u8);
        // D s_811_11: cast zx s_811_10 -> bv
        let s_811_11: Bits = Bits::new(s_811_10 as u128, 7u16);
        // C s_811_12: const #121u : u8
        let s_811_12: u8 = 121;
        // C s_811_13: cast zx s_811_12 -> bv
        let s_811_13: Bits = Bits::new(s_811_12 as u128, 7u16);
        // D s_811_14: cmp-eq s_811_11 s_811_13
        let s_811_14: bool = ((s_811_11) == (s_811_13));
        // N s_811_15: branch s_811_14 b2410 b812
        if s_811_14 {
            return block_2410(state, tracer, fn_state);
        } else {
            return block_812(state, tracer, fn_state);
        };
    }
    fn block_812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_812_0: const #0u : u8
        let s_812_0: bool = false;
        // D s_812_1: write-var gs#400596 <= s_812_0
        fn_state.gs_400596 = s_812_0;
        // N s_812_2: jump b813
        return block_813(state, tracer, fn_state);
    }
    fn block_813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_813_0: read-var gs#400596:u8
        let s_813_0: bool = fn_state.gs_400596;
        // N s_813_1: branch s_813_0 b2409 b814
        if s_813_0 {
            return block_2409(state, tracer, fn_state);
        } else {
            return block_814(state, tracer, fn_state);
        };
    }
    fn block_814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_814_0: const #0u : u8
        let s_814_0: bool = false;
        // D s_814_1: write-var gs#400598 <= s_814_0
        fn_state.gs_400598 = s_814_0;
        // N s_814_2: jump b815
        return block_815(state, tracer, fn_state);
    }
    fn block_815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_815_0: read-var gs#400598:u8
        let s_815_0: bool = fn_state.gs_400598;
        // D s_815_1: not s_815_0
        let s_815_1: bool = !s_815_0;
        // N s_815_2: branch s_815_1 b817 b816
        if s_815_1 {
            return block_817(state, tracer, fn_state);
        } else {
            return block_816(state, tracer, fn_state);
        };
    }
    fn block_816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_816_0: const #3583s : i
        let s_816_0: i128 = 3583;
        // C s_816_1: const #14696u : u32
        let s_816_1: u32 = 14696;
        // N s_816_2: write-reg s_816_1 <= s_816_0
        let s_816_2: () = {
            state.write_register::<i128>(s_816_1 as isize, s_816_0);
            tracer.write_register(s_816_1 as isize, s_816_0);
        };
        // C s_816_3: const #24s : i
        let s_816_3: i128 = 24;
        // C s_816_4: const #1s : i
        let s_816_4: i128 = 1;
        // D s_816_5: read-var u#31388:u32
        let s_816_5: u32 = fn_state.u_31388;
        // D s_816_6: cast zx s_816_5 -> bv
        let s_816_6: Bits = Bits::new(s_816_5 as u128, 32u16);
        // D s_816_7: bit-extract s_816_6 s_816_3 s_816_4
        let s_816_7: Bits = (Bits::new(
            ((s_816_6) >> (s_816_3)).value(),
            u16::try_from(s_816_4).unwrap(),
        ));
        // D s_816_8: cast reint s_816_7 -> u8
        let s_816_8: bool = ((s_816_7.value()) != 0);
        // C s_816_9: const #22s : i
        let s_816_9: i128 = 22;
        // C s_816_10: const #1s : i
        let s_816_10: i128 = 1;
        // D s_816_11: read-var u#31388:u32
        let s_816_11: u32 = fn_state.u_31388;
        // D s_816_12: cast zx s_816_11 -> bv
        let s_816_12: Bits = Bits::new(s_816_11 as u128, 32u16);
        // D s_816_13: bit-extract s_816_12 s_816_9 s_816_10
        let s_816_13: Bits = (Bits::new(
            ((s_816_12) >> (s_816_9)).value(),
            u16::try_from(s_816_10).unwrap(),
        ));
        // D s_816_14: cast reint s_816_13 -> u8
        let s_816_14: bool = ((s_816_13.value()) != 0);
        // C s_816_15: const #16s : i
        let s_816_15: i128 = 16;
        // C s_816_16: const #3s : i
        let s_816_16: i128 = 3;
        // D s_816_17: read-var u#31388:u32
        let s_816_17: u32 = fn_state.u_31388;
        // D s_816_18: cast zx s_816_17 -> bv
        let s_816_18: Bits = Bits::new(s_816_17 as u128, 32u16);
        // D s_816_19: bit-extract s_816_18 s_816_15 s_816_16
        let s_816_19: Bits = (Bits::new(
            ((s_816_18) >> (s_816_15)).value(),
            u16::try_from(s_816_16).unwrap(),
        ));
        // D s_816_20: cast reint s_816_19 -> u8
        let s_816_20: u8 = (s_816_19.value() as u8);
        // C s_816_21: const #12s : i
        let s_816_21: i128 = 12;
        // C s_816_22: const #4s : i
        let s_816_22: i128 = 4;
        // D s_816_23: read-var u#31388:u32
        let s_816_23: u32 = fn_state.u_31388;
        // D s_816_24: cast zx s_816_23 -> bv
        let s_816_24: Bits = Bits::new(s_816_23 as u128, 32u16);
        // D s_816_25: bit-extract s_816_24 s_816_21 s_816_22
        let s_816_25: Bits = (Bits::new(
            ((s_816_24) >> (s_816_21)).value(),
            u16::try_from(s_816_22).unwrap(),
        ));
        // D s_816_26: cast reint s_816_25 -> u8
        let s_816_26: u8 = (s_816_25.value() as u8);
        // C s_816_27: const #8s : i
        let s_816_27: i128 = 8;
        // C s_816_28: const #4s : i
        let s_816_28: i128 = 4;
        // D s_816_29: read-var u#31388:u32
        let s_816_29: u32 = fn_state.u_31388;
        // D s_816_30: cast zx s_816_29 -> bv
        let s_816_30: Bits = Bits::new(s_816_29 as u128, 32u16);
        // D s_816_31: bit-extract s_816_30 s_816_27 s_816_28
        let s_816_31: Bits = (Bits::new(
            ((s_816_30) >> (s_816_27)).value(),
            u16::try_from(s_816_28).unwrap(),
        ));
        // D s_816_32: cast reint s_816_31 -> u8
        let s_816_32: u8 = (s_816_31.value() as u8);
        // C s_816_33: const #6s : i
        let s_816_33: i128 = 6;
        // C s_816_34: const #1s : i
        let s_816_34: i128 = 1;
        // D s_816_35: read-var u#31388:u32
        let s_816_35: u32 = fn_state.u_31388;
        // D s_816_36: cast zx s_816_35 -> bv
        let s_816_36: Bits = Bits::new(s_816_35 as u128, 32u16);
        // D s_816_37: bit-extract s_816_36 s_816_33 s_816_34
        let s_816_37: Bits = (Bits::new(
            ((s_816_36) >> (s_816_33)).value(),
            u16::try_from(s_816_34).unwrap(),
        ));
        // D s_816_38: cast reint s_816_37 -> u8
        let s_816_38: bool = ((s_816_37.value()) != 0);
        // C s_816_39: const #0s : i
        let s_816_39: i128 = 0;
        // C s_816_40: const #4s : i
        let s_816_40: i128 = 4;
        // D s_816_41: read-var u#31388:u32
        let s_816_41: u32 = fn_state.u_31388;
        // D s_816_42: cast zx s_816_41 -> bv
        let s_816_42: Bits = Bits::new(s_816_41 as u128, 32u16);
        // D s_816_43: bit-extract s_816_42 s_816_39 s_816_40
        let s_816_43: Bits = (Bits::new(
            ((s_816_42) >> (s_816_39)).value(),
            u16::try_from(s_816_40).unwrap(),
        ));
        // D s_816_44: cast reint s_816_43 -> u8
        let s_816_44: u8 = (s_816_43.value() as u8);
        // D s_816_45: call decode_aarch32_instrs_VORR_i_A2enc_A_txt(s_816_8, s_816_14, s_816_20, s_816_26, s_816_32, s_816_38, s_816_44)
        let s_816_45: () = decode_aarch32_instrs_VORR_i_A2enc_A_txt(
            state,
            tracer,
            s_816_8,
            s_816_14,
            s_816_20,
            s_816_26,
            s_816_32,
            s_816_38,
            s_816_44,
        );
        // N s_816_46: return
        return;
    }
    fn block_817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_817_0: read-var merge#var.1:struct
        let s_817_0: u32 = fn_state.merge_var._1;
        // D s_817_1: write-var u#31397 <= s_817_0
        fn_state.u_31397 = s_817_0;
        // C s_817_2: const #23s : i
        let s_817_2: i128 = 23;
        // D s_817_3: read-var u#31397:u32
        let s_817_3: u32 = fn_state.u_31397;
        // D s_817_4: cast zx s_817_3 -> bv
        let s_817_4: Bits = Bits::new(s_817_3 as u128, 32u16);
        // C s_817_5: const #1s : i64
        let s_817_5: i64 = 1;
        // C s_817_6: cast zx s_817_5 -> i
        let s_817_6: i128 = (i128::try_from(s_817_5).unwrap());
        // C s_817_7: const #8s : i
        let s_817_7: i128 = 8;
        // C s_817_8: add s_817_7 s_817_6
        let s_817_8: i128 = (s_817_7 + s_817_6);
        // D s_817_9: bit-extract s_817_4 s_817_2 s_817_8
        let s_817_9: Bits = (Bits::new(
            ((s_817_4) >> (s_817_2)).value(),
            u16::try_from(s_817_8).unwrap(),
        ));
        // D s_817_10: cast reint s_817_9 -> u9
        let s_817_10: u16 = (s_817_9.value() as u16);
        // D s_817_11: cast zx s_817_10 -> bv
        let s_817_11: Bits = Bits::new(s_817_10 as u128, 9u16);
        // C s_817_12: const #484u : u9
        let s_817_12: u16 = 484;
        // C s_817_13: cast zx s_817_12 -> bv
        let s_817_13: Bits = Bits::new(s_817_12 as u128, 9u16);
        // D s_817_14: cmp-eq s_817_11 s_817_13
        let s_817_14: bool = ((s_817_11) == (s_817_13));
        // N s_817_15: branch s_817_14 b2402 b818
        if s_817_14 {
            return block_2402(state, tracer, fn_state);
        } else {
            return block_818(state, tracer, fn_state);
        };
    }
    fn block_818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_818_0: const #0u : u8
        let s_818_0: bool = false;
        // D s_818_1: write-var gs#400626 <= s_818_0
        fn_state.gs_400626 = s_818_0;
        // N s_818_2: jump b819
        return block_819(state, tracer, fn_state);
    }
    fn block_819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_819_0: read-var gs#400626:u8
        let s_819_0: bool = fn_state.gs_400626;
        // N s_819_1: branch s_819_0 b2401 b820
        if s_819_0 {
            return block_2401(state, tracer, fn_state);
        } else {
            return block_820(state, tracer, fn_state);
        };
    }
    fn block_820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_820_0: const #0u : u8
        let s_820_0: bool = false;
        // D s_820_1: write-var gs#400628 <= s_820_0
        fn_state.gs_400628 = s_820_0;
        // N s_820_2: jump b821
        return block_821(state, tracer, fn_state);
    }
    fn block_821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_821_0: read-var gs#400628:u8
        let s_821_0: bool = fn_state.gs_400628;
        // D s_821_1: not s_821_0
        let s_821_1: bool = !s_821_0;
        // N s_821_2: branch s_821_1 b823 b822
        if s_821_1 {
            return block_823(state, tracer, fn_state);
        } else {
            return block_822(state, tracer, fn_state);
        };
    }
    fn block_822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_822_0: const #3586s : i
        let s_822_0: i128 = 3586;
        // C s_822_1: const #14696u : u32
        let s_822_1: u32 = 14696;
        // N s_822_2: write-reg s_822_1 <= s_822_0
        let s_822_2: () = {
            state.write_register::<i128>(s_822_1 as isize, s_822_0);
            tracer.write_register(s_822_1 as isize, s_822_0);
        };
        // C s_822_3: const #22s : i
        let s_822_3: i128 = 22;
        // C s_822_4: const #1s : i
        let s_822_4: i128 = 1;
        // D s_822_5: read-var u#31397:u32
        let s_822_5: u32 = fn_state.u_31397;
        // D s_822_6: cast zx s_822_5 -> bv
        let s_822_6: Bits = Bits::new(s_822_5 as u128, 32u16);
        // D s_822_7: bit-extract s_822_6 s_822_3 s_822_4
        let s_822_7: Bits = (Bits::new(
            ((s_822_6) >> (s_822_3)).value(),
            u16::try_from(s_822_4).unwrap(),
        ));
        // D s_822_8: cast reint s_822_7 -> u8
        let s_822_8: bool = ((s_822_7.value()) != 0);
        // C s_822_9: const #16s : i
        let s_822_9: i128 = 16;
        // C s_822_10: const #4s : i
        let s_822_10: i128 = 4;
        // D s_822_11: read-var u#31397:u32
        let s_822_11: u32 = fn_state.u_31397;
        // D s_822_12: cast zx s_822_11 -> bv
        let s_822_12: Bits = Bits::new(s_822_11 as u128, 32u16);
        // D s_822_13: bit-extract s_822_12 s_822_9 s_822_10
        let s_822_13: Bits = (Bits::new(
            ((s_822_12) >> (s_822_9)).value(),
            u16::try_from(s_822_10).unwrap(),
        ));
        // D s_822_14: cast reint s_822_13 -> u8
        let s_822_14: u8 = (s_822_13.value() as u8);
        // C s_822_15: const #12s : i
        let s_822_15: i128 = 12;
        // C s_822_16: const #4s : i
        let s_822_16: i128 = 4;
        // D s_822_17: read-var u#31397:u32
        let s_822_17: u32 = fn_state.u_31397;
        // D s_822_18: cast zx s_822_17 -> bv
        let s_822_18: Bits = Bits::new(s_822_17 as u128, 32u16);
        // D s_822_19: bit-extract s_822_18 s_822_15 s_822_16
        let s_822_19: Bits = (Bits::new(
            ((s_822_18) >> (s_822_15)).value(),
            u16::try_from(s_822_16).unwrap(),
        ));
        // D s_822_20: cast reint s_822_19 -> u8
        let s_822_20: u8 = (s_822_19.value() as u8);
        // C s_822_21: const #7s : i
        let s_822_21: i128 = 7;
        // C s_822_22: const #1s : i
        let s_822_22: i128 = 1;
        // D s_822_23: read-var u#31397:u32
        let s_822_23: u32 = fn_state.u_31397;
        // D s_822_24: cast zx s_822_23 -> bv
        let s_822_24: Bits = Bits::new(s_822_23 as u128, 32u16);
        // D s_822_25: bit-extract s_822_24 s_822_21 s_822_22
        let s_822_25: Bits = (Bits::new(
            ((s_822_24) >> (s_822_21)).value(),
            u16::try_from(s_822_22).unwrap(),
        ));
        // D s_822_26: cast reint s_822_25 -> u8
        let s_822_26: bool = ((s_822_25.value()) != 0);
        // C s_822_27: const #6s : i
        let s_822_27: i128 = 6;
        // C s_822_28: const #1s : i
        let s_822_28: i128 = 1;
        // D s_822_29: read-var u#31397:u32
        let s_822_29: u32 = fn_state.u_31397;
        // D s_822_30: cast zx s_822_29 -> bv
        let s_822_30: Bits = Bits::new(s_822_29 as u128, 32u16);
        // D s_822_31: bit-extract s_822_30 s_822_27 s_822_28
        let s_822_31: Bits = (Bits::new(
            ((s_822_30) >> (s_822_27)).value(),
            u16::try_from(s_822_28).unwrap(),
        ));
        // D s_822_32: cast reint s_822_31 -> u8
        let s_822_32: bool = ((s_822_31.value()) != 0);
        // C s_822_33: const #5s : i
        let s_822_33: i128 = 5;
        // C s_822_34: const #1s : i
        let s_822_34: i128 = 1;
        // D s_822_35: read-var u#31397:u32
        let s_822_35: u32 = fn_state.u_31397;
        // D s_822_36: cast zx s_822_35 -> bv
        let s_822_36: Bits = Bits::new(s_822_35 as u128, 32u16);
        // D s_822_37: bit-extract s_822_36 s_822_33 s_822_34
        let s_822_37: Bits = (Bits::new(
            ((s_822_36) >> (s_822_33)).value(),
            u16::try_from(s_822_34).unwrap(),
        ));
        // D s_822_38: cast reint s_822_37 -> u8
        let s_822_38: bool = ((s_822_37.value()) != 0);
        // C s_822_39: const #0s : i
        let s_822_39: i128 = 0;
        // C s_822_40: const #4s : i
        let s_822_40: i128 = 4;
        // D s_822_41: read-var u#31397:u32
        let s_822_41: u32 = fn_state.u_31397;
        // D s_822_42: cast zx s_822_41 -> bv
        let s_822_42: Bits = Bits::new(s_822_41 as u128, 32u16);
        // D s_822_43: bit-extract s_822_42 s_822_39 s_822_40
        let s_822_43: Bits = (Bits::new(
            ((s_822_42) >> (s_822_39)).value(),
            u16::try_from(s_822_40).unwrap(),
        ));
        // D s_822_44: cast reint s_822_43 -> u8
        let s_822_44: u8 = (s_822_43.value() as u8);
        // D s_822_45: call decode_aarch32_instrs_VORR_r_A1enc_A_txt(s_822_8, s_822_14, s_822_20, s_822_26, s_822_32, s_822_38, s_822_44)
        let s_822_45: () = decode_aarch32_instrs_VORR_r_A1enc_A_txt(
            state,
            tracer,
            s_822_8,
            s_822_14,
            s_822_20,
            s_822_26,
            s_822_32,
            s_822_38,
            s_822_44,
        );
        // N s_822_46: return
        return;
    }
    fn block_823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_823_0: read-var merge#var.1:struct
        let s_823_0: u32 = fn_state.merge_var._1;
        // D s_823_1: write-var u#31406 <= s_823_0
        fn_state.u_31406 = s_823_0;
        // C s_823_2: const #23s : i
        let s_823_2: i128 = 23;
        // D s_823_3: read-var u#31406:u32
        let s_823_3: u32 = fn_state.u_31406;
        // D s_823_4: cast zx s_823_3 -> bv
        let s_823_4: Bits = Bits::new(s_823_3 as u128, 32u16);
        // C s_823_5: const #1s : i64
        let s_823_5: i64 = 1;
        // C s_823_6: cast zx s_823_5 -> i
        let s_823_6: i128 = (i128::try_from(s_823_5).unwrap());
        // C s_823_7: const #8s : i
        let s_823_7: i128 = 8;
        // C s_823_8: add s_823_7 s_823_6
        let s_823_8: i128 = (s_823_7 + s_823_6);
        // D s_823_9: bit-extract s_823_4 s_823_2 s_823_8
        let s_823_9: Bits = (Bits::new(
            ((s_823_4) >> (s_823_2)).value(),
            u16::try_from(s_823_8).unwrap(),
        ));
        // D s_823_10: cast reint s_823_9 -> u9
        let s_823_10: u16 = (s_823_9.value() as u16);
        // D s_823_11: cast zx s_823_10 -> bv
        let s_823_11: Bits = Bits::new(s_823_10 as u128, 9u16);
        // C s_823_12: const #487u : u9
        let s_823_12: u16 = 487;
        // C s_823_13: cast zx s_823_12 -> bv
        let s_823_13: Bits = Bits::new(s_823_12 as u128, 9u16);
        // D s_823_14: cmp-eq s_823_11 s_823_13
        let s_823_14: bool = ((s_823_11) == (s_823_13));
        // N s_823_15: branch s_823_14 b2391 b824
        if s_823_14 {
            return block_2391(state, tracer, fn_state);
        } else {
            return block_824(state, tracer, fn_state);
        };
    }
    fn block_824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_824_0: const #0u : u8
        let s_824_0: bool = false;
        // D s_824_1: write-var gs#400659 <= s_824_0
        fn_state.gs_400659 = s_824_0;
        // N s_824_2: jump b825
        return block_825(state, tracer, fn_state);
    }
    fn block_825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_825_0: read-var gs#400659:u8
        let s_825_0: bool = fn_state.gs_400659;
        // N s_825_1: branch s_825_0 b2390 b826
        if s_825_0 {
            return block_2390(state, tracer, fn_state);
        } else {
            return block_826(state, tracer, fn_state);
        };
    }
    fn block_826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_826_0: const #0u : u8
        let s_826_0: bool = false;
        // D s_826_1: write-var gs#400661 <= s_826_0
        fn_state.gs_400661 = s_826_0;
        // N s_826_2: jump b827
        return block_827(state, tracer, fn_state);
    }
    fn block_827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_827_0: read-var gs#400661:u8
        let s_827_0: bool = fn_state.gs_400661;
        // D s_827_1: not s_827_0
        let s_827_1: bool = !s_827_0;
        // N s_827_2: branch s_827_1 b829 b828
        if s_827_1 {
            return block_829(state, tracer, fn_state);
        } else {
            return block_828(state, tracer, fn_state);
        };
    }
    fn block_828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_828_0: const #3588s : i
        let s_828_0: i128 = 3588;
        // C s_828_1: const #14696u : u32
        let s_828_1: u32 = 14696;
        // N s_828_2: write-reg s_828_1 <= s_828_0
        let s_828_2: () = {
            state.write_register::<i128>(s_828_1 as isize, s_828_0);
            tracer.write_register(s_828_1 as isize, s_828_0);
        };
        // C s_828_3: const #22s : i
        let s_828_3: i128 = 22;
        // C s_828_4: const #1s : i
        let s_828_4: i128 = 1;
        // D s_828_5: read-var u#31406:u32
        let s_828_5: u32 = fn_state.u_31406;
        // D s_828_6: cast zx s_828_5 -> bv
        let s_828_6: Bits = Bits::new(s_828_5 as u128, 32u16);
        // D s_828_7: bit-extract s_828_6 s_828_3 s_828_4
        let s_828_7: Bits = (Bits::new(
            ((s_828_6) >> (s_828_3)).value(),
            u16::try_from(s_828_4).unwrap(),
        ));
        // D s_828_8: cast reint s_828_7 -> u8
        let s_828_8: bool = ((s_828_7.value()) != 0);
        // C s_828_9: const #18s : i
        let s_828_9: i128 = 18;
        // C s_828_10: const #2s : i
        let s_828_10: i128 = 2;
        // D s_828_11: read-var u#31406:u32
        let s_828_11: u32 = fn_state.u_31406;
        // D s_828_12: cast zx s_828_11 -> bv
        let s_828_12: Bits = Bits::new(s_828_11 as u128, 32u16);
        // D s_828_13: bit-extract s_828_12 s_828_9 s_828_10
        let s_828_13: Bits = (Bits::new(
            ((s_828_12) >> (s_828_9)).value(),
            u16::try_from(s_828_10).unwrap(),
        ));
        // D s_828_14: cast reint s_828_13 -> u8
        let s_828_14: u8 = (s_828_13.value() as u8);
        // C s_828_15: const #12s : i
        let s_828_15: i128 = 12;
        // C s_828_16: const #4s : i
        let s_828_16: i128 = 4;
        // D s_828_17: read-var u#31406:u32
        let s_828_17: u32 = fn_state.u_31406;
        // D s_828_18: cast zx s_828_17 -> bv
        let s_828_18: Bits = Bits::new(s_828_17 as u128, 32u16);
        // D s_828_19: bit-extract s_828_18 s_828_15 s_828_16
        let s_828_19: Bits = (Bits::new(
            ((s_828_18) >> (s_828_15)).value(),
            u16::try_from(s_828_16).unwrap(),
        ));
        // D s_828_20: cast reint s_828_19 -> u8
        let s_828_20: u8 = (s_828_19.value() as u8);
        // C s_828_21: const #7s : i
        let s_828_21: i128 = 7;
        // C s_828_22: const #1s : i
        let s_828_22: i128 = 1;
        // D s_828_23: read-var u#31406:u32
        let s_828_23: u32 = fn_state.u_31406;
        // D s_828_24: cast zx s_828_23 -> bv
        let s_828_24: Bits = Bits::new(s_828_23 as u128, 32u16);
        // D s_828_25: bit-extract s_828_24 s_828_21 s_828_22
        let s_828_25: Bits = (Bits::new(
            ((s_828_24) >> (s_828_21)).value(),
            u16::try_from(s_828_22).unwrap(),
        ));
        // D s_828_26: cast reint s_828_25 -> u8
        let s_828_26: bool = ((s_828_25.value()) != 0);
        // C s_828_27: const #6s : i
        let s_828_27: i128 = 6;
        // C s_828_28: const #1s : i
        let s_828_28: i128 = 1;
        // D s_828_29: read-var u#31406:u32
        let s_828_29: u32 = fn_state.u_31406;
        // D s_828_30: cast zx s_828_29 -> bv
        let s_828_30: Bits = Bits::new(s_828_29 as u128, 32u16);
        // D s_828_31: bit-extract s_828_30 s_828_27 s_828_28
        let s_828_31: Bits = (Bits::new(
            ((s_828_30) >> (s_828_27)).value(),
            u16::try_from(s_828_28).unwrap(),
        ));
        // D s_828_32: cast reint s_828_31 -> u8
        let s_828_32: bool = ((s_828_31.value()) != 0);
        // C s_828_33: const #5s : i
        let s_828_33: i128 = 5;
        // C s_828_34: const #1s : i
        let s_828_34: i128 = 1;
        // D s_828_35: read-var u#31406:u32
        let s_828_35: u32 = fn_state.u_31406;
        // D s_828_36: cast zx s_828_35 -> bv
        let s_828_36: Bits = Bits::new(s_828_35 as u128, 32u16);
        // D s_828_37: bit-extract s_828_36 s_828_33 s_828_34
        let s_828_37: Bits = (Bits::new(
            ((s_828_36) >> (s_828_33)).value(),
            u16::try_from(s_828_34).unwrap(),
        ));
        // D s_828_38: cast reint s_828_37 -> u8
        let s_828_38: bool = ((s_828_37.value()) != 0);
        // C s_828_39: const #0s : i
        let s_828_39: i128 = 0;
        // C s_828_40: const #4s : i
        let s_828_40: i128 = 4;
        // D s_828_41: read-var u#31406:u32
        let s_828_41: u32 = fn_state.u_31406;
        // D s_828_42: cast zx s_828_41 -> bv
        let s_828_42: Bits = Bits::new(s_828_41 as u128, 32u16);
        // D s_828_43: bit-extract s_828_42 s_828_39 s_828_40
        let s_828_43: Bits = (Bits::new(
            ((s_828_42) >> (s_828_39)).value(),
            u16::try_from(s_828_40).unwrap(),
        ));
        // D s_828_44: cast reint s_828_43 -> u8
        let s_828_44: u8 = (s_828_43.value() as u8);
        // D s_828_45: call decode_aarch32_instrs_VPADAL_A1enc_A_txt(s_828_8, s_828_14, s_828_20, s_828_26, s_828_32, s_828_38, s_828_44)
        let s_828_45: () = decode_aarch32_instrs_VPADAL_A1enc_A_txt(
            state,
            tracer,
            s_828_8,
            s_828_14,
            s_828_20,
            s_828_26,
            s_828_32,
            s_828_38,
            s_828_44,
        );
        // N s_828_46: return
        return;
    }
    fn block_829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_829_0: read-var merge#var.1:struct
        let s_829_0: u32 = fn_state.merge_var._1;
        // D s_829_1: write-var u#31415 <= s_829_0
        fn_state.u_31415 = s_829_0;
        // C s_829_2: const #23s : i
        let s_829_2: i128 = 23;
        // D s_829_3: read-var u#31415:u32
        let s_829_3: u32 = fn_state.u_31415;
        // D s_829_4: cast zx s_829_3 -> bv
        let s_829_4: Bits = Bits::new(s_829_3 as u128, 32u16);
        // C s_829_5: const #1s : i64
        let s_829_5: i64 = 1;
        // C s_829_6: cast zx s_829_5 -> i
        let s_829_6: i128 = (i128::try_from(s_829_5).unwrap());
        // C s_829_7: const #8s : i
        let s_829_7: i128 = 8;
        // C s_829_8: add s_829_7 s_829_6
        let s_829_8: i128 = (s_829_7 + s_829_6);
        // D s_829_9: bit-extract s_829_4 s_829_2 s_829_8
        let s_829_9: Bits = (Bits::new(
            ((s_829_4) >> (s_829_2)).value(),
            u16::try_from(s_829_8).unwrap(),
        ));
        // D s_829_10: cast reint s_829_9 -> u9
        let s_829_10: u16 = (s_829_9.value() as u16);
        // D s_829_11: cast zx s_829_10 -> bv
        let s_829_11: Bits = Bits::new(s_829_10 as u128, 9u16);
        // C s_829_12: const #486u : u9
        let s_829_12: u16 = 486;
        // C s_829_13: cast zx s_829_12 -> bv
        let s_829_13: Bits = Bits::new(s_829_12 as u128, 9u16);
        // D s_829_14: cmp-eq s_829_11 s_829_13
        let s_829_14: bool = ((s_829_11) == (s_829_13));
        // N s_829_15: branch s_829_14 b2383 b830
        if s_829_14 {
            return block_2383(state, tracer, fn_state);
        } else {
            return block_830(state, tracer, fn_state);
        };
    }
    fn block_830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_830_0: const #0u : u8
        let s_830_0: bool = false;
        // D s_830_1: write-var gs#400689 <= s_830_0
        fn_state.gs_400689 = s_830_0;
        // N s_830_2: jump b831
        return block_831(state, tracer, fn_state);
    }
    fn block_831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_831_0: read-var gs#400689:u8
        let s_831_0: bool = fn_state.gs_400689;
        // N s_831_1: branch s_831_0 b2382 b832
        if s_831_0 {
            return block_2382(state, tracer, fn_state);
        } else {
            return block_832(state, tracer, fn_state);
        };
    }
    fn block_832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_832_0: const #0u : u8
        let s_832_0: bool = false;
        // D s_832_1: write-var gs#400691 <= s_832_0
        fn_state.gs_400691 = s_832_0;
        // N s_832_2: jump b833
        return block_833(state, tracer, fn_state);
    }
    fn block_833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_833_0: read-var gs#400691:u8
        let s_833_0: bool = fn_state.gs_400691;
        // D s_833_1: not s_833_0
        let s_833_1: bool = !s_833_0;
        // N s_833_2: branch s_833_1 b835 b834
        if s_833_1 {
            return block_835(state, tracer, fn_state);
        } else {
            return block_834(state, tracer, fn_state);
        };
    }
    fn block_834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_834_0: const #3590s : i
        let s_834_0: i128 = 3590;
        // C s_834_1: const #14696u : u32
        let s_834_1: u32 = 14696;
        // N s_834_2: write-reg s_834_1 <= s_834_0
        let s_834_2: () = {
            state.write_register::<i128>(s_834_1 as isize, s_834_0);
            tracer.write_register(s_834_1 as isize, s_834_0);
        };
        // C s_834_3: const #22s : i
        let s_834_3: i128 = 22;
        // C s_834_4: const #1s : i
        let s_834_4: i128 = 1;
        // D s_834_5: read-var u#31415:u32
        let s_834_5: u32 = fn_state.u_31415;
        // D s_834_6: cast zx s_834_5 -> bv
        let s_834_6: Bits = Bits::new(s_834_5 as u128, 32u16);
        // D s_834_7: bit-extract s_834_6 s_834_3 s_834_4
        let s_834_7: Bits = (Bits::new(
            ((s_834_6) >> (s_834_3)).value(),
            u16::try_from(s_834_4).unwrap(),
        ));
        // D s_834_8: cast reint s_834_7 -> u8
        let s_834_8: bool = ((s_834_7.value()) != 0);
        // C s_834_9: const #20s : i
        let s_834_9: i128 = 20;
        // C s_834_10: const #1s : i
        let s_834_10: i128 = 1;
        // D s_834_11: read-var u#31415:u32
        let s_834_11: u32 = fn_state.u_31415;
        // D s_834_12: cast zx s_834_11 -> bv
        let s_834_12: Bits = Bits::new(s_834_11 as u128, 32u16);
        // D s_834_13: bit-extract s_834_12 s_834_9 s_834_10
        let s_834_13: Bits = (Bits::new(
            ((s_834_12) >> (s_834_9)).value(),
            u16::try_from(s_834_10).unwrap(),
        ));
        // D s_834_14: cast reint s_834_13 -> u8
        let s_834_14: bool = ((s_834_13.value()) != 0);
        // C s_834_15: const #16s : i
        let s_834_15: i128 = 16;
        // C s_834_16: const #4s : i
        let s_834_16: i128 = 4;
        // D s_834_17: read-var u#31415:u32
        let s_834_17: u32 = fn_state.u_31415;
        // D s_834_18: cast zx s_834_17 -> bv
        let s_834_18: Bits = Bits::new(s_834_17 as u128, 32u16);
        // D s_834_19: bit-extract s_834_18 s_834_15 s_834_16
        let s_834_19: Bits = (Bits::new(
            ((s_834_18) >> (s_834_15)).value(),
            u16::try_from(s_834_16).unwrap(),
        ));
        // D s_834_20: cast reint s_834_19 -> u8
        let s_834_20: u8 = (s_834_19.value() as u8);
        // C s_834_21: const #12s : i
        let s_834_21: i128 = 12;
        // C s_834_22: const #4s : i
        let s_834_22: i128 = 4;
        // D s_834_23: read-var u#31415:u32
        let s_834_23: u32 = fn_state.u_31415;
        // D s_834_24: cast zx s_834_23 -> bv
        let s_834_24: Bits = Bits::new(s_834_23 as u128, 32u16);
        // D s_834_25: bit-extract s_834_24 s_834_21 s_834_22
        let s_834_25: Bits = (Bits::new(
            ((s_834_24) >> (s_834_21)).value(),
            u16::try_from(s_834_22).unwrap(),
        ));
        // D s_834_26: cast reint s_834_25 -> u8
        let s_834_26: u8 = (s_834_25.value() as u8);
        // C s_834_27: const #7s : i
        let s_834_27: i128 = 7;
        // C s_834_28: const #1s : i
        let s_834_28: i128 = 1;
        // D s_834_29: read-var u#31415:u32
        let s_834_29: u32 = fn_state.u_31415;
        // D s_834_30: cast zx s_834_29 -> bv
        let s_834_30: Bits = Bits::new(s_834_29 as u128, 32u16);
        // D s_834_31: bit-extract s_834_30 s_834_27 s_834_28
        let s_834_31: Bits = (Bits::new(
            ((s_834_30) >> (s_834_27)).value(),
            u16::try_from(s_834_28).unwrap(),
        ));
        // D s_834_32: cast reint s_834_31 -> u8
        let s_834_32: bool = ((s_834_31.value()) != 0);
        // C s_834_33: const #6s : i
        let s_834_33: i128 = 6;
        // C s_834_34: const #1s : i
        let s_834_34: i128 = 1;
        // D s_834_35: read-var u#31415:u32
        let s_834_35: u32 = fn_state.u_31415;
        // D s_834_36: cast zx s_834_35 -> bv
        let s_834_36: Bits = Bits::new(s_834_35 as u128, 32u16);
        // D s_834_37: bit-extract s_834_36 s_834_33 s_834_34
        let s_834_37: Bits = (Bits::new(
            ((s_834_36) >> (s_834_33)).value(),
            u16::try_from(s_834_34).unwrap(),
        ));
        // D s_834_38: cast reint s_834_37 -> u8
        let s_834_38: bool = ((s_834_37.value()) != 0);
        // C s_834_39: const #5s : i
        let s_834_39: i128 = 5;
        // C s_834_40: const #1s : i
        let s_834_40: i128 = 1;
        // D s_834_41: read-var u#31415:u32
        let s_834_41: u32 = fn_state.u_31415;
        // D s_834_42: cast zx s_834_41 -> bv
        let s_834_42: Bits = Bits::new(s_834_41 as u128, 32u16);
        // D s_834_43: bit-extract s_834_42 s_834_39 s_834_40
        let s_834_43: Bits = (Bits::new(
            ((s_834_42) >> (s_834_39)).value(),
            u16::try_from(s_834_40).unwrap(),
        ));
        // D s_834_44: cast reint s_834_43 -> u8
        let s_834_44: bool = ((s_834_43.value()) != 0);
        // C s_834_45: const #0s : i
        let s_834_45: i128 = 0;
        // C s_834_46: const #4s : i
        let s_834_46: i128 = 4;
        // D s_834_47: read-var u#31415:u32
        let s_834_47: u32 = fn_state.u_31415;
        // D s_834_48: cast zx s_834_47 -> bv
        let s_834_48: Bits = Bits::new(s_834_47 as u128, 32u16);
        // D s_834_49: bit-extract s_834_48 s_834_45 s_834_46
        let s_834_49: Bits = (Bits::new(
            ((s_834_48) >> (s_834_45)).value(),
            u16::try_from(s_834_46).unwrap(),
        ));
        // D s_834_50: cast reint s_834_49 -> u8
        let s_834_50: u8 = (s_834_49.value() as u8);
        // D s_834_51: call decode_aarch32_instrs_VPADD_f_A1enc_A_txt(s_834_8, s_834_14, s_834_20, s_834_26, s_834_32, s_834_38, s_834_44, s_834_50)
        let s_834_51: () = decode_aarch32_instrs_VPADD_f_A1enc_A_txt(
            state,
            tracer,
            s_834_8,
            s_834_14,
            s_834_20,
            s_834_26,
            s_834_32,
            s_834_38,
            s_834_44,
            s_834_50,
        );
        // N s_834_52: return
        return;
    }
    fn block_835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_835_0: read-var merge#var.1:struct
        let s_835_0: u32 = fn_state.merge_var._1;
        // D s_835_1: write-var u#31425 <= s_835_0
        fn_state.u_31425 = s_835_0;
        // C s_835_2: const #23s : i
        let s_835_2: i128 = 23;
        // D s_835_3: read-var u#31425:u32
        let s_835_3: u32 = fn_state.u_31425;
        // D s_835_4: cast zx s_835_3 -> bv
        let s_835_4: Bits = Bits::new(s_835_3 as u128, 32u16);
        // C s_835_5: const #1s : i64
        let s_835_5: i64 = 1;
        // C s_835_6: cast zx s_835_5 -> i
        let s_835_6: i128 = (i128::try_from(s_835_5).unwrap());
        // C s_835_7: const #8s : i
        let s_835_7: i128 = 8;
        // C s_835_8: add s_835_7 s_835_6
        let s_835_8: i128 = (s_835_7 + s_835_6);
        // D s_835_9: bit-extract s_835_4 s_835_2 s_835_8
        let s_835_9: Bits = (Bits::new(
            ((s_835_4) >> (s_835_2)).value(),
            u16::try_from(s_835_8).unwrap(),
        ));
        // D s_835_10: cast reint s_835_9 -> u9
        let s_835_10: u16 = (s_835_9.value() as u16);
        // D s_835_11: cast zx s_835_10 -> bv
        let s_835_11: Bits = Bits::new(s_835_10 as u128, 9u16);
        // C s_835_12: const #484u : u9
        let s_835_12: u16 = 484;
        // C s_835_13: cast zx s_835_12 -> bv
        let s_835_13: Bits = Bits::new(s_835_12 as u128, 9u16);
        // D s_835_14: cmp-eq s_835_11 s_835_13
        let s_835_14: bool = ((s_835_11) == (s_835_13));
        // N s_835_15: branch s_835_14 b2378 b836
        if s_835_14 {
            return block_2378(state, tracer, fn_state);
        } else {
            return block_836(state, tracer, fn_state);
        };
    }
    fn block_836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_836_0: const #0u : u8
        let s_836_0: bool = false;
        // D s_836_1: write-var gs#400718 <= s_836_0
        fn_state.gs_400718 = s_836_0;
        // N s_836_2: jump b837
        return block_837(state, tracer, fn_state);
    }
    fn block_837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_837_0: read-var gs#400718:u8
        let s_837_0: bool = fn_state.gs_400718;
        // N s_837_1: branch s_837_0 b2377 b838
        if s_837_0 {
            return block_2377(state, tracer, fn_state);
        } else {
            return block_838(state, tracer, fn_state);
        };
    }
    fn block_838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_838_0: const #0u : u8
        let s_838_0: bool = false;
        // D s_838_1: write-var gs#400720 <= s_838_0
        fn_state.gs_400720 = s_838_0;
        // N s_838_2: jump b839
        return block_839(state, tracer, fn_state);
    }
    fn block_839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_839_0: read-var gs#400720:u8
        let s_839_0: bool = fn_state.gs_400720;
        // D s_839_1: not s_839_0
        let s_839_1: bool = !s_839_0;
        // N s_839_2: branch s_839_1 b841 b840
        if s_839_1 {
            return block_841(state, tracer, fn_state);
        } else {
            return block_840(state, tracer, fn_state);
        };
    }
    fn block_840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_840_0: const #3592s : i
        let s_840_0: i128 = 3592;
        // C s_840_1: const #14696u : u32
        let s_840_1: u32 = 14696;
        // N s_840_2: write-reg s_840_1 <= s_840_0
        let s_840_2: () = {
            state.write_register::<i128>(s_840_1 as isize, s_840_0);
            tracer.write_register(s_840_1 as isize, s_840_0);
        };
        // C s_840_3: const #22s : i
        let s_840_3: i128 = 22;
        // C s_840_4: const #1s : i
        let s_840_4: i128 = 1;
        // D s_840_5: read-var u#31425:u32
        let s_840_5: u32 = fn_state.u_31425;
        // D s_840_6: cast zx s_840_5 -> bv
        let s_840_6: Bits = Bits::new(s_840_5 as u128, 32u16);
        // D s_840_7: bit-extract s_840_6 s_840_3 s_840_4
        let s_840_7: Bits = (Bits::new(
            ((s_840_6) >> (s_840_3)).value(),
            u16::try_from(s_840_4).unwrap(),
        ));
        // D s_840_8: cast reint s_840_7 -> u8
        let s_840_8: bool = ((s_840_7.value()) != 0);
        // C s_840_9: const #20s : i
        let s_840_9: i128 = 20;
        // C s_840_10: const #2s : i
        let s_840_10: i128 = 2;
        // D s_840_11: read-var u#31425:u32
        let s_840_11: u32 = fn_state.u_31425;
        // D s_840_12: cast zx s_840_11 -> bv
        let s_840_12: Bits = Bits::new(s_840_11 as u128, 32u16);
        // D s_840_13: bit-extract s_840_12 s_840_9 s_840_10
        let s_840_13: Bits = (Bits::new(
            ((s_840_12) >> (s_840_9)).value(),
            u16::try_from(s_840_10).unwrap(),
        ));
        // D s_840_14: cast reint s_840_13 -> u8
        let s_840_14: u8 = (s_840_13.value() as u8);
        // C s_840_15: const #16s : i
        let s_840_15: i128 = 16;
        // C s_840_16: const #4s : i
        let s_840_16: i128 = 4;
        // D s_840_17: read-var u#31425:u32
        let s_840_17: u32 = fn_state.u_31425;
        // D s_840_18: cast zx s_840_17 -> bv
        let s_840_18: Bits = Bits::new(s_840_17 as u128, 32u16);
        // D s_840_19: bit-extract s_840_18 s_840_15 s_840_16
        let s_840_19: Bits = (Bits::new(
            ((s_840_18) >> (s_840_15)).value(),
            u16::try_from(s_840_16).unwrap(),
        ));
        // D s_840_20: cast reint s_840_19 -> u8
        let s_840_20: u8 = (s_840_19.value() as u8);
        // C s_840_21: const #12s : i
        let s_840_21: i128 = 12;
        // C s_840_22: const #4s : i
        let s_840_22: i128 = 4;
        // D s_840_23: read-var u#31425:u32
        let s_840_23: u32 = fn_state.u_31425;
        // D s_840_24: cast zx s_840_23 -> bv
        let s_840_24: Bits = Bits::new(s_840_23 as u128, 32u16);
        // D s_840_25: bit-extract s_840_24 s_840_21 s_840_22
        let s_840_25: Bits = (Bits::new(
            ((s_840_24) >> (s_840_21)).value(),
            u16::try_from(s_840_22).unwrap(),
        ));
        // D s_840_26: cast reint s_840_25 -> u8
        let s_840_26: u8 = (s_840_25.value() as u8);
        // C s_840_27: const #7s : i
        let s_840_27: i128 = 7;
        // C s_840_28: const #1s : i
        let s_840_28: i128 = 1;
        // D s_840_29: read-var u#31425:u32
        let s_840_29: u32 = fn_state.u_31425;
        // D s_840_30: cast zx s_840_29 -> bv
        let s_840_30: Bits = Bits::new(s_840_29 as u128, 32u16);
        // D s_840_31: bit-extract s_840_30 s_840_27 s_840_28
        let s_840_31: Bits = (Bits::new(
            ((s_840_30) >> (s_840_27)).value(),
            u16::try_from(s_840_28).unwrap(),
        ));
        // D s_840_32: cast reint s_840_31 -> u8
        let s_840_32: bool = ((s_840_31.value()) != 0);
        // C s_840_33: const #6s : i
        let s_840_33: i128 = 6;
        // C s_840_34: const #1s : i
        let s_840_34: i128 = 1;
        // D s_840_35: read-var u#31425:u32
        let s_840_35: u32 = fn_state.u_31425;
        // D s_840_36: cast zx s_840_35 -> bv
        let s_840_36: Bits = Bits::new(s_840_35 as u128, 32u16);
        // D s_840_37: bit-extract s_840_36 s_840_33 s_840_34
        let s_840_37: Bits = (Bits::new(
            ((s_840_36) >> (s_840_33)).value(),
            u16::try_from(s_840_34).unwrap(),
        ));
        // D s_840_38: cast reint s_840_37 -> u8
        let s_840_38: bool = ((s_840_37.value()) != 0);
        // C s_840_39: const #5s : i
        let s_840_39: i128 = 5;
        // C s_840_40: const #1s : i
        let s_840_40: i128 = 1;
        // D s_840_41: read-var u#31425:u32
        let s_840_41: u32 = fn_state.u_31425;
        // D s_840_42: cast zx s_840_41 -> bv
        let s_840_42: Bits = Bits::new(s_840_41 as u128, 32u16);
        // D s_840_43: bit-extract s_840_42 s_840_39 s_840_40
        let s_840_43: Bits = (Bits::new(
            ((s_840_42) >> (s_840_39)).value(),
            u16::try_from(s_840_40).unwrap(),
        ));
        // D s_840_44: cast reint s_840_43 -> u8
        let s_840_44: bool = ((s_840_43.value()) != 0);
        // C s_840_45: const #0s : i
        let s_840_45: i128 = 0;
        // C s_840_46: const #4s : i
        let s_840_46: i128 = 4;
        // D s_840_47: read-var u#31425:u32
        let s_840_47: u32 = fn_state.u_31425;
        // D s_840_48: cast zx s_840_47 -> bv
        let s_840_48: Bits = Bits::new(s_840_47 as u128, 32u16);
        // D s_840_49: bit-extract s_840_48 s_840_45 s_840_46
        let s_840_49: Bits = (Bits::new(
            ((s_840_48) >> (s_840_45)).value(),
            u16::try_from(s_840_46).unwrap(),
        ));
        // D s_840_50: cast reint s_840_49 -> u8
        let s_840_50: u8 = (s_840_49.value() as u8);
        // D s_840_51: call decode_aarch32_instrs_VPADD_i_A1enc_A_txt(s_840_8, s_840_14, s_840_20, s_840_26, s_840_32, s_840_38, s_840_44, s_840_50)
        let s_840_51: () = decode_aarch32_instrs_VPADD_i_A1enc_A_txt(
            state,
            tracer,
            s_840_8,
            s_840_14,
            s_840_20,
            s_840_26,
            s_840_32,
            s_840_38,
            s_840_44,
            s_840_50,
        );
        // N s_840_52: return
        return;
    }
    fn block_841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_841_0: read-var merge#var.1:struct
        let s_841_0: u32 = fn_state.merge_var._1;
        // D s_841_1: write-var u#31435 <= s_841_0
        fn_state.u_31435 = s_841_0;
        // C s_841_2: const #23s : i
        let s_841_2: i128 = 23;
        // D s_841_3: read-var u#31435:u32
        let s_841_3: u32 = fn_state.u_31435;
        // D s_841_4: cast zx s_841_3 -> bv
        let s_841_4: Bits = Bits::new(s_841_3 as u128, 32u16);
        // C s_841_5: const #1s : i64
        let s_841_5: i64 = 1;
        // C s_841_6: cast zx s_841_5 -> i
        let s_841_6: i128 = (i128::try_from(s_841_5).unwrap());
        // C s_841_7: const #8s : i
        let s_841_7: i128 = 8;
        // C s_841_8: add s_841_7 s_841_6
        let s_841_8: i128 = (s_841_7 + s_841_6);
        // D s_841_9: bit-extract s_841_4 s_841_2 s_841_8
        let s_841_9: Bits = (Bits::new(
            ((s_841_4) >> (s_841_2)).value(),
            u16::try_from(s_841_8).unwrap(),
        ));
        // D s_841_10: cast reint s_841_9 -> u9
        let s_841_10: u16 = (s_841_9.value() as u16);
        // D s_841_11: cast zx s_841_10 -> bv
        let s_841_11: Bits = Bits::new(s_841_10 as u128, 9u16);
        // C s_841_12: const #487u : u9
        let s_841_12: u16 = 487;
        // C s_841_13: cast zx s_841_12 -> bv
        let s_841_13: Bits = Bits::new(s_841_12 as u128, 9u16);
        // D s_841_14: cmp-eq s_841_11 s_841_13
        let s_841_14: bool = ((s_841_11) == (s_841_13));
        // N s_841_15: branch s_841_14 b2367 b842
        if s_841_14 {
            return block_2367(state, tracer, fn_state);
        } else {
            return block_842(state, tracer, fn_state);
        };
    }
    fn block_842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_842_0: const #0u : u8
        let s_842_0: bool = false;
        // D s_842_1: write-var gs#400753 <= s_842_0
        fn_state.gs_400753 = s_842_0;
        // N s_842_2: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_843_0: read-var gs#400753:u8
        let s_843_0: bool = fn_state.gs_400753;
        // N s_843_1: branch s_843_0 b2366 b844
        if s_843_0 {
            return block_2366(state, tracer, fn_state);
        } else {
            return block_844(state, tracer, fn_state);
        };
    }
    fn block_844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_844_0: const #0u : u8
        let s_844_0: bool = false;
        // D s_844_1: write-var gs#400755 <= s_844_0
        fn_state.gs_400755 = s_844_0;
        // N s_844_2: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_845_0: read-var gs#400755:u8
        let s_845_0: bool = fn_state.gs_400755;
        // D s_845_1: not s_845_0
        let s_845_1: bool = !s_845_0;
        // N s_845_2: branch s_845_1 b847 b846
        if s_845_1 {
            return block_847(state, tracer, fn_state);
        } else {
            return block_846(state, tracer, fn_state);
        };
    }
    fn block_846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_846_0: const #3594s : i
        let s_846_0: i128 = 3594;
        // C s_846_1: const #14696u : u32
        let s_846_1: u32 = 14696;
        // N s_846_2: write-reg s_846_1 <= s_846_0
        let s_846_2: () = {
            state.write_register::<i128>(s_846_1 as isize, s_846_0);
            tracer.write_register(s_846_1 as isize, s_846_0);
        };
        // C s_846_3: const #22s : i
        let s_846_3: i128 = 22;
        // C s_846_4: const #1s : i
        let s_846_4: i128 = 1;
        // D s_846_5: read-var u#31435:u32
        let s_846_5: u32 = fn_state.u_31435;
        // D s_846_6: cast zx s_846_5 -> bv
        let s_846_6: Bits = Bits::new(s_846_5 as u128, 32u16);
        // D s_846_7: bit-extract s_846_6 s_846_3 s_846_4
        let s_846_7: Bits = (Bits::new(
            ((s_846_6) >> (s_846_3)).value(),
            u16::try_from(s_846_4).unwrap(),
        ));
        // D s_846_8: cast reint s_846_7 -> u8
        let s_846_8: bool = ((s_846_7.value()) != 0);
        // C s_846_9: const #18s : i
        let s_846_9: i128 = 18;
        // C s_846_10: const #2s : i
        let s_846_10: i128 = 2;
        // D s_846_11: read-var u#31435:u32
        let s_846_11: u32 = fn_state.u_31435;
        // D s_846_12: cast zx s_846_11 -> bv
        let s_846_12: Bits = Bits::new(s_846_11 as u128, 32u16);
        // D s_846_13: bit-extract s_846_12 s_846_9 s_846_10
        let s_846_13: Bits = (Bits::new(
            ((s_846_12) >> (s_846_9)).value(),
            u16::try_from(s_846_10).unwrap(),
        ));
        // D s_846_14: cast reint s_846_13 -> u8
        let s_846_14: u8 = (s_846_13.value() as u8);
        // C s_846_15: const #12s : i
        let s_846_15: i128 = 12;
        // C s_846_16: const #4s : i
        let s_846_16: i128 = 4;
        // D s_846_17: read-var u#31435:u32
        let s_846_17: u32 = fn_state.u_31435;
        // D s_846_18: cast zx s_846_17 -> bv
        let s_846_18: Bits = Bits::new(s_846_17 as u128, 32u16);
        // D s_846_19: bit-extract s_846_18 s_846_15 s_846_16
        let s_846_19: Bits = (Bits::new(
            ((s_846_18) >> (s_846_15)).value(),
            u16::try_from(s_846_16).unwrap(),
        ));
        // D s_846_20: cast reint s_846_19 -> u8
        let s_846_20: u8 = (s_846_19.value() as u8);
        // C s_846_21: const #7s : i
        let s_846_21: i128 = 7;
        // C s_846_22: const #1s : i
        let s_846_22: i128 = 1;
        // D s_846_23: read-var u#31435:u32
        let s_846_23: u32 = fn_state.u_31435;
        // D s_846_24: cast zx s_846_23 -> bv
        let s_846_24: Bits = Bits::new(s_846_23 as u128, 32u16);
        // D s_846_25: bit-extract s_846_24 s_846_21 s_846_22
        let s_846_25: Bits = (Bits::new(
            ((s_846_24) >> (s_846_21)).value(),
            u16::try_from(s_846_22).unwrap(),
        ));
        // D s_846_26: cast reint s_846_25 -> u8
        let s_846_26: bool = ((s_846_25.value()) != 0);
        // C s_846_27: const #6s : i
        let s_846_27: i128 = 6;
        // C s_846_28: const #1s : i
        let s_846_28: i128 = 1;
        // D s_846_29: read-var u#31435:u32
        let s_846_29: u32 = fn_state.u_31435;
        // D s_846_30: cast zx s_846_29 -> bv
        let s_846_30: Bits = Bits::new(s_846_29 as u128, 32u16);
        // D s_846_31: bit-extract s_846_30 s_846_27 s_846_28
        let s_846_31: Bits = (Bits::new(
            ((s_846_30) >> (s_846_27)).value(),
            u16::try_from(s_846_28).unwrap(),
        ));
        // D s_846_32: cast reint s_846_31 -> u8
        let s_846_32: bool = ((s_846_31.value()) != 0);
        // C s_846_33: const #5s : i
        let s_846_33: i128 = 5;
        // C s_846_34: const #1s : i
        let s_846_34: i128 = 1;
        // D s_846_35: read-var u#31435:u32
        let s_846_35: u32 = fn_state.u_31435;
        // D s_846_36: cast zx s_846_35 -> bv
        let s_846_36: Bits = Bits::new(s_846_35 as u128, 32u16);
        // D s_846_37: bit-extract s_846_36 s_846_33 s_846_34
        let s_846_37: Bits = (Bits::new(
            ((s_846_36) >> (s_846_33)).value(),
            u16::try_from(s_846_34).unwrap(),
        ));
        // D s_846_38: cast reint s_846_37 -> u8
        let s_846_38: bool = ((s_846_37.value()) != 0);
        // C s_846_39: const #0s : i
        let s_846_39: i128 = 0;
        // C s_846_40: const #4s : i
        let s_846_40: i128 = 4;
        // D s_846_41: read-var u#31435:u32
        let s_846_41: u32 = fn_state.u_31435;
        // D s_846_42: cast zx s_846_41 -> bv
        let s_846_42: Bits = Bits::new(s_846_41 as u128, 32u16);
        // D s_846_43: bit-extract s_846_42 s_846_39 s_846_40
        let s_846_43: Bits = (Bits::new(
            ((s_846_42) >> (s_846_39)).value(),
            u16::try_from(s_846_40).unwrap(),
        ));
        // D s_846_44: cast reint s_846_43 -> u8
        let s_846_44: u8 = (s_846_43.value() as u8);
        // D s_846_45: call decode_aarch32_instrs_VPADDL_A1enc_A_txt(s_846_8, s_846_14, s_846_20, s_846_26, s_846_32, s_846_38, s_846_44)
        let s_846_45: () = decode_aarch32_instrs_VPADDL_A1enc_A_txt(
            state,
            tracer,
            s_846_8,
            s_846_14,
            s_846_20,
            s_846_26,
            s_846_32,
            s_846_38,
            s_846_44,
        );
        // N s_846_46: return
        return;
    }
    fn block_847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_847_0: read-var merge#var.1:struct
        let s_847_0: u32 = fn_state.merge_var._1;
        // D s_847_1: write-var u#31444 <= s_847_0
        fn_state.u_31444 = s_847_0;
        // C s_847_2: const #23s : i
        let s_847_2: i128 = 23;
        // D s_847_3: read-var u#31444:u32
        let s_847_3: u32 = fn_state.u_31444;
        // D s_847_4: cast zx s_847_3 -> bv
        let s_847_4: Bits = Bits::new(s_847_3 as u128, 32u16);
        // C s_847_5: const #1s : i64
        let s_847_5: i64 = 1;
        // C s_847_6: cast zx s_847_5 -> i
        let s_847_6: i128 = (i128::try_from(s_847_5).unwrap());
        // C s_847_7: const #8s : i
        let s_847_7: i128 = 8;
        // C s_847_8: add s_847_7 s_847_6
        let s_847_8: i128 = (s_847_7 + s_847_6);
        // D s_847_9: bit-extract s_847_4 s_847_2 s_847_8
        let s_847_9: Bits = (Bits::new(
            ((s_847_4) >> (s_847_2)).value(),
            u16::try_from(s_847_8).unwrap(),
        ));
        // D s_847_10: cast reint s_847_9 -> u9
        let s_847_10: u16 = (s_847_9.value() as u16);
        // D s_847_11: cast zx s_847_10 -> bv
        let s_847_11: Bits = Bits::new(s_847_10 as u128, 9u16);
        // C s_847_12: const #486u : u9
        let s_847_12: u16 = 486;
        // C s_847_13: cast zx s_847_12 -> bv
        let s_847_13: Bits = Bits::new(s_847_12 as u128, 9u16);
        // D s_847_14: cmp-eq s_847_11 s_847_13
        let s_847_14: bool = ((s_847_11) == (s_847_13));
        // N s_847_15: branch s_847_14 b2359 b848
        if s_847_14 {
            return block_2359(state, tracer, fn_state);
        } else {
            return block_848(state, tracer, fn_state);
        };
    }
    fn block_848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_848_0: const #0u : u8
        let s_848_0: bool = false;
        // D s_848_1: write-var gs#400783 <= s_848_0
        fn_state.gs_400783 = s_848_0;
        // N s_848_2: jump b849
        return block_849(state, tracer, fn_state);
    }
    fn block_849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_849_0: read-var gs#400783:u8
        let s_849_0: bool = fn_state.gs_400783;
        // N s_849_1: branch s_849_0 b2358 b850
        if s_849_0 {
            return block_2358(state, tracer, fn_state);
        } else {
            return block_850(state, tracer, fn_state);
        };
    }
    fn block_850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_850_0: const #0u : u8
        let s_850_0: bool = false;
        // D s_850_1: write-var gs#400785 <= s_850_0
        fn_state.gs_400785 = s_850_0;
        // N s_850_2: jump b851
        return block_851(state, tracer, fn_state);
    }
    fn block_851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_851_0: read-var gs#400785:u8
        let s_851_0: bool = fn_state.gs_400785;
        // D s_851_1: not s_851_0
        let s_851_1: bool = !s_851_0;
        // N s_851_2: branch s_851_1 b853 b852
        if s_851_1 {
            return block_853(state, tracer, fn_state);
        } else {
            return block_852(state, tracer, fn_state);
        };
    }
    fn block_852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_852_0: const #3596s : i
        let s_852_0: i128 = 3596;
        // C s_852_1: const #14696u : u32
        let s_852_1: u32 = 14696;
        // N s_852_2: write-reg s_852_1 <= s_852_0
        let s_852_2: () = {
            state.write_register::<i128>(s_852_1 as isize, s_852_0);
            tracer.write_register(s_852_1 as isize, s_852_0);
        };
        // C s_852_3: const #22s : i
        let s_852_3: i128 = 22;
        // C s_852_4: const #1s : i
        let s_852_4: i128 = 1;
        // D s_852_5: read-var u#31444:u32
        let s_852_5: u32 = fn_state.u_31444;
        // D s_852_6: cast zx s_852_5 -> bv
        let s_852_6: Bits = Bits::new(s_852_5 as u128, 32u16);
        // D s_852_7: bit-extract s_852_6 s_852_3 s_852_4
        let s_852_7: Bits = (Bits::new(
            ((s_852_6) >> (s_852_3)).value(),
            u16::try_from(s_852_4).unwrap(),
        ));
        // D s_852_8: cast reint s_852_7 -> u8
        let s_852_8: bool = ((s_852_7.value()) != 0);
        // C s_852_9: const #21s : i
        let s_852_9: i128 = 21;
        // C s_852_10: const #1s : i
        let s_852_10: i128 = 1;
        // D s_852_11: read-var u#31444:u32
        let s_852_11: u32 = fn_state.u_31444;
        // D s_852_12: cast zx s_852_11 -> bv
        let s_852_12: Bits = Bits::new(s_852_11 as u128, 32u16);
        // D s_852_13: bit-extract s_852_12 s_852_9 s_852_10
        let s_852_13: Bits = (Bits::new(
            ((s_852_12) >> (s_852_9)).value(),
            u16::try_from(s_852_10).unwrap(),
        ));
        // D s_852_14: cast reint s_852_13 -> u8
        let s_852_14: bool = ((s_852_13.value()) != 0);
        // C s_852_15: const #20s : i
        let s_852_15: i128 = 20;
        // C s_852_16: const #1s : i
        let s_852_16: i128 = 1;
        // D s_852_17: read-var u#31444:u32
        let s_852_17: u32 = fn_state.u_31444;
        // D s_852_18: cast zx s_852_17 -> bv
        let s_852_18: Bits = Bits::new(s_852_17 as u128, 32u16);
        // D s_852_19: bit-extract s_852_18 s_852_15 s_852_16
        let s_852_19: Bits = (Bits::new(
            ((s_852_18) >> (s_852_15)).value(),
            u16::try_from(s_852_16).unwrap(),
        ));
        // D s_852_20: cast reint s_852_19 -> u8
        let s_852_20: bool = ((s_852_19.value()) != 0);
        // C s_852_21: const #16s : i
        let s_852_21: i128 = 16;
        // C s_852_22: const #4s : i
        let s_852_22: i128 = 4;
        // D s_852_23: read-var u#31444:u32
        let s_852_23: u32 = fn_state.u_31444;
        // D s_852_24: cast zx s_852_23 -> bv
        let s_852_24: Bits = Bits::new(s_852_23 as u128, 32u16);
        // D s_852_25: bit-extract s_852_24 s_852_21 s_852_22
        let s_852_25: Bits = (Bits::new(
            ((s_852_24) >> (s_852_21)).value(),
            u16::try_from(s_852_22).unwrap(),
        ));
        // D s_852_26: cast reint s_852_25 -> u8
        let s_852_26: u8 = (s_852_25.value() as u8);
        // C s_852_27: const #12s : i
        let s_852_27: i128 = 12;
        // C s_852_28: const #4s : i
        let s_852_28: i128 = 4;
        // D s_852_29: read-var u#31444:u32
        let s_852_29: u32 = fn_state.u_31444;
        // D s_852_30: cast zx s_852_29 -> bv
        let s_852_30: Bits = Bits::new(s_852_29 as u128, 32u16);
        // D s_852_31: bit-extract s_852_30 s_852_27 s_852_28
        let s_852_31: Bits = (Bits::new(
            ((s_852_30) >> (s_852_27)).value(),
            u16::try_from(s_852_28).unwrap(),
        ));
        // D s_852_32: cast reint s_852_31 -> u8
        let s_852_32: u8 = (s_852_31.value() as u8);
        // C s_852_33: const #7s : i
        let s_852_33: i128 = 7;
        // C s_852_34: const #1s : i
        let s_852_34: i128 = 1;
        // D s_852_35: read-var u#31444:u32
        let s_852_35: u32 = fn_state.u_31444;
        // D s_852_36: cast zx s_852_35 -> bv
        let s_852_36: Bits = Bits::new(s_852_35 as u128, 32u16);
        // D s_852_37: bit-extract s_852_36 s_852_33 s_852_34
        let s_852_37: Bits = (Bits::new(
            ((s_852_36) >> (s_852_33)).value(),
            u16::try_from(s_852_34).unwrap(),
        ));
        // D s_852_38: cast reint s_852_37 -> u8
        let s_852_38: bool = ((s_852_37.value()) != 0);
        // C s_852_39: const #5s : i
        let s_852_39: i128 = 5;
        // C s_852_40: const #1s : i
        let s_852_40: i128 = 1;
        // D s_852_41: read-var u#31444:u32
        let s_852_41: u32 = fn_state.u_31444;
        // D s_852_42: cast zx s_852_41 -> bv
        let s_852_42: Bits = Bits::new(s_852_41 as u128, 32u16);
        // D s_852_43: bit-extract s_852_42 s_852_39 s_852_40
        let s_852_43: Bits = (Bits::new(
            ((s_852_42) >> (s_852_39)).value(),
            u16::try_from(s_852_40).unwrap(),
        ));
        // D s_852_44: cast reint s_852_43 -> u8
        let s_852_44: bool = ((s_852_43.value()) != 0);
        // C s_852_45: const #0s : i
        let s_852_45: i128 = 0;
        // C s_852_46: const #4s : i
        let s_852_46: i128 = 4;
        // D s_852_47: read-var u#31444:u32
        let s_852_47: u32 = fn_state.u_31444;
        // D s_852_48: cast zx s_852_47 -> bv
        let s_852_48: Bits = Bits::new(s_852_47 as u128, 32u16);
        // D s_852_49: bit-extract s_852_48 s_852_45 s_852_46
        let s_852_49: Bits = (Bits::new(
            ((s_852_48) >> (s_852_45)).value(),
            u16::try_from(s_852_46).unwrap(),
        ));
        // D s_852_50: cast reint s_852_49 -> u8
        let s_852_50: u8 = (s_852_49.value() as u8);
        // D s_852_51: call decode_aarch32_instrs_VPMAX_f_A1enc_A_txt(s_852_8, s_852_14, s_852_20, s_852_26, s_852_32, s_852_38, s_852_44, s_852_50)
        let s_852_51: () = decode_aarch32_instrs_VPMAX_f_A1enc_A_txt(
            state,
            tracer,
            s_852_8,
            s_852_14,
            s_852_20,
            s_852_26,
            s_852_32,
            s_852_38,
            s_852_44,
            s_852_50,
        );
        // N s_852_52: return
        return;
    }
    fn block_853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_853_0: read-var merge#var.1:struct
        let s_853_0: u32 = fn_state.merge_var._1;
        // D s_853_1: write-var u#31454 <= s_853_0
        fn_state.u_31454 = s_853_0;
        // C s_853_2: const #25s : i
        let s_853_2: i128 = 25;
        // D s_853_3: read-var u#31454:u32
        let s_853_3: u32 = fn_state.u_31454;
        // D s_853_4: cast zx s_853_3 -> bv
        let s_853_4: Bits = Bits::new(s_853_3 as u128, 32u16);
        // C s_853_5: const #1s : i64
        let s_853_5: i64 = 1;
        // C s_853_6: cast zx s_853_5 -> i
        let s_853_6: i128 = (i128::try_from(s_853_5).unwrap());
        // C s_853_7: const #6s : i
        let s_853_7: i128 = 6;
        // C s_853_8: add s_853_7 s_853_6
        let s_853_8: i128 = (s_853_7 + s_853_6);
        // D s_853_9: bit-extract s_853_4 s_853_2 s_853_8
        let s_853_9: Bits = (Bits::new(
            ((s_853_4) >> (s_853_2)).value(),
            u16::try_from(s_853_8).unwrap(),
        ));
        // D s_853_10: cast reint s_853_9 -> u8
        let s_853_10: u8 = (s_853_9.value() as u8);
        // D s_853_11: cast zx s_853_10 -> bv
        let s_853_11: Bits = Bits::new(s_853_10 as u128, 7u16);
        // C s_853_12: const #121u : u8
        let s_853_12: u8 = 121;
        // C s_853_13: cast zx s_853_12 -> bv
        let s_853_13: Bits = Bits::new(s_853_12 as u128, 7u16);
        // D s_853_14: cmp-eq s_853_11 s_853_13
        let s_853_14: bool = ((s_853_11) == (s_853_13));
        // N s_853_15: branch s_853_14 b2351 b854
        if s_853_14 {
            return block_2351(state, tracer, fn_state);
        } else {
            return block_854(state, tracer, fn_state);
        };
    }
    fn block_854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_854_0: const #0u : u8
        let s_854_0: bool = false;
        // D s_854_1: write-var gs#400815 <= s_854_0
        fn_state.gs_400815 = s_854_0;
        // N s_854_2: jump b855
        return block_855(state, tracer, fn_state);
    }
    fn block_855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_855_0: read-var gs#400815:u8
        let s_855_0: bool = fn_state.gs_400815;
        // N s_855_1: branch s_855_0 b2350 b856
        if s_855_0 {
            return block_2350(state, tracer, fn_state);
        } else {
            return block_856(state, tracer, fn_state);
        };
    }
    fn block_856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_856_0: const #0u : u8
        let s_856_0: bool = false;
        // D s_856_1: write-var gs#400817 <= s_856_0
        fn_state.gs_400817 = s_856_0;
        // N s_856_2: jump b857
        return block_857(state, tracer, fn_state);
    }
    fn block_857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_857_0: read-var gs#400817:u8
        let s_857_0: bool = fn_state.gs_400817;
        // D s_857_1: not s_857_0
        let s_857_1: bool = !s_857_0;
        // N s_857_2: branch s_857_1 b859 b858
        if s_857_1 {
            return block_859(state, tracer, fn_state);
        } else {
            return block_858(state, tracer, fn_state);
        };
    }
    fn block_858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_858_0: const #3598s : i
        let s_858_0: i128 = 3598;
        // C s_858_1: const #14696u : u32
        let s_858_1: u32 = 14696;
        // N s_858_2: write-reg s_858_1 <= s_858_0
        let s_858_2: () = {
            state.write_register::<i128>(s_858_1 as isize, s_858_0);
            tracer.write_register(s_858_1 as isize, s_858_0);
        };
        // C s_858_3: const #24s : i
        let s_858_3: i128 = 24;
        // C s_858_4: const #1s : i
        let s_858_4: i128 = 1;
        // D s_858_5: read-var u#31454:u32
        let s_858_5: u32 = fn_state.u_31454;
        // D s_858_6: cast zx s_858_5 -> bv
        let s_858_6: Bits = Bits::new(s_858_5 as u128, 32u16);
        // D s_858_7: bit-extract s_858_6 s_858_3 s_858_4
        let s_858_7: Bits = (Bits::new(
            ((s_858_6) >> (s_858_3)).value(),
            u16::try_from(s_858_4).unwrap(),
        ));
        // D s_858_8: cast reint s_858_7 -> u8
        let s_858_8: bool = ((s_858_7.value()) != 0);
        // C s_858_9: const #22s : i
        let s_858_9: i128 = 22;
        // C s_858_10: const #1s : i
        let s_858_10: i128 = 1;
        // D s_858_11: read-var u#31454:u32
        let s_858_11: u32 = fn_state.u_31454;
        // D s_858_12: cast zx s_858_11 -> bv
        let s_858_12: Bits = Bits::new(s_858_11 as u128, 32u16);
        // D s_858_13: bit-extract s_858_12 s_858_9 s_858_10
        let s_858_13: Bits = (Bits::new(
            ((s_858_12) >> (s_858_9)).value(),
            u16::try_from(s_858_10).unwrap(),
        ));
        // D s_858_14: cast reint s_858_13 -> u8
        let s_858_14: bool = ((s_858_13.value()) != 0);
        // C s_858_15: const #20s : i
        let s_858_15: i128 = 20;
        // C s_858_16: const #2s : i
        let s_858_16: i128 = 2;
        // D s_858_17: read-var u#31454:u32
        let s_858_17: u32 = fn_state.u_31454;
        // D s_858_18: cast zx s_858_17 -> bv
        let s_858_18: Bits = Bits::new(s_858_17 as u128, 32u16);
        // D s_858_19: bit-extract s_858_18 s_858_15 s_858_16
        let s_858_19: Bits = (Bits::new(
            ((s_858_18) >> (s_858_15)).value(),
            u16::try_from(s_858_16).unwrap(),
        ));
        // D s_858_20: cast reint s_858_19 -> u8
        let s_858_20: u8 = (s_858_19.value() as u8);
        // C s_858_21: const #16s : i
        let s_858_21: i128 = 16;
        // C s_858_22: const #4s : i
        let s_858_22: i128 = 4;
        // D s_858_23: read-var u#31454:u32
        let s_858_23: u32 = fn_state.u_31454;
        // D s_858_24: cast zx s_858_23 -> bv
        let s_858_24: Bits = Bits::new(s_858_23 as u128, 32u16);
        // D s_858_25: bit-extract s_858_24 s_858_21 s_858_22
        let s_858_25: Bits = (Bits::new(
            ((s_858_24) >> (s_858_21)).value(),
            u16::try_from(s_858_22).unwrap(),
        ));
        // D s_858_26: cast reint s_858_25 -> u8
        let s_858_26: u8 = (s_858_25.value() as u8);
        // C s_858_27: const #12s : i
        let s_858_27: i128 = 12;
        // C s_858_28: const #4s : i
        let s_858_28: i128 = 4;
        // D s_858_29: read-var u#31454:u32
        let s_858_29: u32 = fn_state.u_31454;
        // D s_858_30: cast zx s_858_29 -> bv
        let s_858_30: Bits = Bits::new(s_858_29 as u128, 32u16);
        // D s_858_31: bit-extract s_858_30 s_858_27 s_858_28
        let s_858_31: Bits = (Bits::new(
            ((s_858_30) >> (s_858_27)).value(),
            u16::try_from(s_858_28).unwrap(),
        ));
        // D s_858_32: cast reint s_858_31 -> u8
        let s_858_32: u8 = (s_858_31.value() as u8);
        // C s_858_33: const #7s : i
        let s_858_33: i128 = 7;
        // C s_858_34: const #1s : i
        let s_858_34: i128 = 1;
        // D s_858_35: read-var u#31454:u32
        let s_858_35: u32 = fn_state.u_31454;
        // D s_858_36: cast zx s_858_35 -> bv
        let s_858_36: Bits = Bits::new(s_858_35 as u128, 32u16);
        // D s_858_37: bit-extract s_858_36 s_858_33 s_858_34
        let s_858_37: Bits = (Bits::new(
            ((s_858_36) >> (s_858_33)).value(),
            u16::try_from(s_858_34).unwrap(),
        ));
        // D s_858_38: cast reint s_858_37 -> u8
        let s_858_38: bool = ((s_858_37.value()) != 0);
        // C s_858_39: const #5s : i
        let s_858_39: i128 = 5;
        // C s_858_40: const #1s : i
        let s_858_40: i128 = 1;
        // D s_858_41: read-var u#31454:u32
        let s_858_41: u32 = fn_state.u_31454;
        // D s_858_42: cast zx s_858_41 -> bv
        let s_858_42: Bits = Bits::new(s_858_41 as u128, 32u16);
        // D s_858_43: bit-extract s_858_42 s_858_39 s_858_40
        let s_858_43: Bits = (Bits::new(
            ((s_858_42) >> (s_858_39)).value(),
            u16::try_from(s_858_40).unwrap(),
        ));
        // D s_858_44: cast reint s_858_43 -> u8
        let s_858_44: bool = ((s_858_43.value()) != 0);
        // C s_858_45: const #4s : i
        let s_858_45: i128 = 4;
        // C s_858_46: const #1s : i
        let s_858_46: i128 = 1;
        // D s_858_47: read-var u#31454:u32
        let s_858_47: u32 = fn_state.u_31454;
        // D s_858_48: cast zx s_858_47 -> bv
        let s_858_48: Bits = Bits::new(s_858_47 as u128, 32u16);
        // D s_858_49: bit-extract s_858_48 s_858_45 s_858_46
        let s_858_49: Bits = (Bits::new(
            ((s_858_48) >> (s_858_45)).value(),
            u16::try_from(s_858_46).unwrap(),
        ));
        // D s_858_50: cast reint s_858_49 -> u8
        let s_858_50: bool = ((s_858_49.value()) != 0);
        // C s_858_51: const #0s : i
        let s_858_51: i128 = 0;
        // C s_858_52: const #4s : i
        let s_858_52: i128 = 4;
        // D s_858_53: read-var u#31454:u32
        let s_858_53: u32 = fn_state.u_31454;
        // D s_858_54: cast zx s_858_53 -> bv
        let s_858_54: Bits = Bits::new(s_858_53 as u128, 32u16);
        // D s_858_55: bit-extract s_858_54 s_858_51 s_858_52
        let s_858_55: Bits = (Bits::new(
            ((s_858_54) >> (s_858_51)).value(),
            u16::try_from(s_858_52).unwrap(),
        ));
        // D s_858_56: cast reint s_858_55 -> u8
        let s_858_56: u8 = (s_858_55.value() as u8);
        // D s_858_57: call decode_aarch32_instrs_VPMAX_i_A1enc_A_txt(s_858_8, s_858_14, s_858_20, s_858_26, s_858_32, s_858_38, s_858_44, s_858_50, s_858_56)
        let s_858_57: () = decode_aarch32_instrs_VPMAX_i_A1enc_A_txt(
            state,
            tracer,
            s_858_8,
            s_858_14,
            s_858_20,
            s_858_26,
            s_858_32,
            s_858_38,
            s_858_44,
            s_858_50,
            s_858_56,
        );
        // N s_858_58: return
        return;
    }
    fn block_859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_859_0: read-var merge#var.1:struct
        let s_859_0: u32 = fn_state.merge_var._1;
        // D s_859_1: write-var u#31465 <= s_859_0
        fn_state.u_31465 = s_859_0;
        // C s_859_2: const #23s : i
        let s_859_2: i128 = 23;
        // D s_859_3: read-var u#31465:u32
        let s_859_3: u32 = fn_state.u_31465;
        // D s_859_4: cast zx s_859_3 -> bv
        let s_859_4: Bits = Bits::new(s_859_3 as u128, 32u16);
        // C s_859_5: const #1s : i64
        let s_859_5: i64 = 1;
        // C s_859_6: cast zx s_859_5 -> i
        let s_859_6: i128 = (i128::try_from(s_859_5).unwrap());
        // C s_859_7: const #8s : i
        let s_859_7: i128 = 8;
        // C s_859_8: add s_859_7 s_859_6
        let s_859_8: i128 = (s_859_7 + s_859_6);
        // D s_859_9: bit-extract s_859_4 s_859_2 s_859_8
        let s_859_9: Bits = (Bits::new(
            ((s_859_4) >> (s_859_2)).value(),
            u16::try_from(s_859_8).unwrap(),
        ));
        // D s_859_10: cast reint s_859_9 -> u9
        let s_859_10: u16 = (s_859_9.value() as u16);
        // D s_859_11: cast zx s_859_10 -> bv
        let s_859_11: Bits = Bits::new(s_859_10 as u128, 9u16);
        // C s_859_12: const #487u : u9
        let s_859_12: u16 = 487;
        // C s_859_13: cast zx s_859_12 -> bv
        let s_859_13: Bits = Bits::new(s_859_12 as u128, 9u16);
        // D s_859_14: cmp-eq s_859_11 s_859_13
        let s_859_14: bool = ((s_859_11) == (s_859_13));
        // N s_859_15: branch s_859_14 b2340 b860
        if s_859_14 {
            return block_2340(state, tracer, fn_state);
        } else {
            return block_860(state, tracer, fn_state);
        };
    }
    fn block_860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_860_0: const #0u : u8
        let s_860_0: bool = false;
        // D s_860_1: write-var gs#400852 <= s_860_0
        fn_state.gs_400852 = s_860_0;
        // N s_860_2: jump b861
        return block_861(state, tracer, fn_state);
    }
    fn block_861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_861_0: read-var gs#400852:u8
        let s_861_0: bool = fn_state.gs_400852;
        // N s_861_1: branch s_861_0 b2339 b862
        if s_861_0 {
            return block_2339(state, tracer, fn_state);
        } else {
            return block_862(state, tracer, fn_state);
        };
    }
    fn block_862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_862_0: const #0u : u8
        let s_862_0: bool = false;
        // D s_862_1: write-var gs#400854 <= s_862_0
        fn_state.gs_400854 = s_862_0;
        // N s_862_2: jump b863
        return block_863(state, tracer, fn_state);
    }
    fn block_863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_863_0: read-var gs#400854:u8
        let s_863_0: bool = fn_state.gs_400854;
        // D s_863_1: not s_863_0
        let s_863_1: bool = !s_863_0;
        // N s_863_2: branch s_863_1 b865 b864
        if s_863_1 {
            return block_865(state, tracer, fn_state);
        } else {
            return block_864(state, tracer, fn_state);
        };
    }
    fn block_864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_864_0: const #3600s : i
        let s_864_0: i128 = 3600;
        // C s_864_1: const #14696u : u32
        let s_864_1: u32 = 14696;
        // N s_864_2: write-reg s_864_1 <= s_864_0
        let s_864_2: () = {
            state.write_register::<i128>(s_864_1 as isize, s_864_0);
            tracer.write_register(s_864_1 as isize, s_864_0);
        };
        // C s_864_3: const #22s : i
        let s_864_3: i128 = 22;
        // C s_864_4: const #1s : i
        let s_864_4: i128 = 1;
        // D s_864_5: read-var u#31465:u32
        let s_864_5: u32 = fn_state.u_31465;
        // D s_864_6: cast zx s_864_5 -> bv
        let s_864_6: Bits = Bits::new(s_864_5 as u128, 32u16);
        // D s_864_7: bit-extract s_864_6 s_864_3 s_864_4
        let s_864_7: Bits = (Bits::new(
            ((s_864_6) >> (s_864_3)).value(),
            u16::try_from(s_864_4).unwrap(),
        ));
        // D s_864_8: cast reint s_864_7 -> u8
        let s_864_8: bool = ((s_864_7.value()) != 0);
        // C s_864_9: const #18s : i
        let s_864_9: i128 = 18;
        // C s_864_10: const #2s : i
        let s_864_10: i128 = 2;
        // D s_864_11: read-var u#31465:u32
        let s_864_11: u32 = fn_state.u_31465;
        // D s_864_12: cast zx s_864_11 -> bv
        let s_864_12: Bits = Bits::new(s_864_11 as u128, 32u16);
        // D s_864_13: bit-extract s_864_12 s_864_9 s_864_10
        let s_864_13: Bits = (Bits::new(
            ((s_864_12) >> (s_864_9)).value(),
            u16::try_from(s_864_10).unwrap(),
        ));
        // D s_864_14: cast reint s_864_13 -> u8
        let s_864_14: u8 = (s_864_13.value() as u8);
        // C s_864_15: const #12s : i
        let s_864_15: i128 = 12;
        // C s_864_16: const #4s : i
        let s_864_16: i128 = 4;
        // D s_864_17: read-var u#31465:u32
        let s_864_17: u32 = fn_state.u_31465;
        // D s_864_18: cast zx s_864_17 -> bv
        let s_864_18: Bits = Bits::new(s_864_17 as u128, 32u16);
        // D s_864_19: bit-extract s_864_18 s_864_15 s_864_16
        let s_864_19: Bits = (Bits::new(
            ((s_864_18) >> (s_864_15)).value(),
            u16::try_from(s_864_16).unwrap(),
        ));
        // D s_864_20: cast reint s_864_19 -> u8
        let s_864_20: u8 = (s_864_19.value() as u8);
        // C s_864_21: const #6s : i
        let s_864_21: i128 = 6;
        // C s_864_22: const #1s : i
        let s_864_22: i128 = 1;
        // D s_864_23: read-var u#31465:u32
        let s_864_23: u32 = fn_state.u_31465;
        // D s_864_24: cast zx s_864_23 -> bv
        let s_864_24: Bits = Bits::new(s_864_23 as u128, 32u16);
        // D s_864_25: bit-extract s_864_24 s_864_21 s_864_22
        let s_864_25: Bits = (Bits::new(
            ((s_864_24) >> (s_864_21)).value(),
            u16::try_from(s_864_22).unwrap(),
        ));
        // D s_864_26: cast reint s_864_25 -> u8
        let s_864_26: bool = ((s_864_25.value()) != 0);
        // C s_864_27: const #5s : i
        let s_864_27: i128 = 5;
        // C s_864_28: const #1s : i
        let s_864_28: i128 = 1;
        // D s_864_29: read-var u#31465:u32
        let s_864_29: u32 = fn_state.u_31465;
        // D s_864_30: cast zx s_864_29 -> bv
        let s_864_30: Bits = Bits::new(s_864_29 as u128, 32u16);
        // D s_864_31: bit-extract s_864_30 s_864_27 s_864_28
        let s_864_31: Bits = (Bits::new(
            ((s_864_30) >> (s_864_27)).value(),
            u16::try_from(s_864_28).unwrap(),
        ));
        // D s_864_32: cast reint s_864_31 -> u8
        let s_864_32: bool = ((s_864_31.value()) != 0);
        // C s_864_33: const #0s : i
        let s_864_33: i128 = 0;
        // C s_864_34: const #4s : i
        let s_864_34: i128 = 4;
        // D s_864_35: read-var u#31465:u32
        let s_864_35: u32 = fn_state.u_31465;
        // D s_864_36: cast zx s_864_35 -> bv
        let s_864_36: Bits = Bits::new(s_864_35 as u128, 32u16);
        // D s_864_37: bit-extract s_864_36 s_864_33 s_864_34
        let s_864_37: Bits = (Bits::new(
            ((s_864_36) >> (s_864_33)).value(),
            u16::try_from(s_864_34).unwrap(),
        ));
        // D s_864_38: cast reint s_864_37 -> u8
        let s_864_38: u8 = (s_864_37.value() as u8);
        // D s_864_39: call decode_aarch32_instrs_VQABS_A1enc_A_txt(s_864_8, s_864_14, s_864_20, s_864_26, s_864_32, s_864_38)
        let s_864_39: () = decode_aarch32_instrs_VQABS_A1enc_A_txt(
            state,
            tracer,
            s_864_8,
            s_864_14,
            s_864_20,
            s_864_26,
            s_864_32,
            s_864_38,
        );
        // N s_864_40: return
        return;
    }
    fn block_865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_865_0: read-var merge#var.1:struct
        let s_865_0: u32 = fn_state.merge_var._1;
        // D s_865_1: write-var u#31473 <= s_865_0
        fn_state.u_31473 = s_865_0;
        // C s_865_2: const #25s : i
        let s_865_2: i128 = 25;
        // D s_865_3: read-var u#31473:u32
        let s_865_3: u32 = fn_state.u_31473;
        // D s_865_4: cast zx s_865_3 -> bv
        let s_865_4: Bits = Bits::new(s_865_3 as u128, 32u16);
        // C s_865_5: const #1s : i64
        let s_865_5: i64 = 1;
        // C s_865_6: cast zx s_865_5 -> i
        let s_865_6: i128 = (i128::try_from(s_865_5).unwrap());
        // C s_865_7: const #6s : i
        let s_865_7: i128 = 6;
        // C s_865_8: add s_865_7 s_865_6
        let s_865_8: i128 = (s_865_7 + s_865_6);
        // D s_865_9: bit-extract s_865_4 s_865_2 s_865_8
        let s_865_9: Bits = (Bits::new(
            ((s_865_4) >> (s_865_2)).value(),
            u16::try_from(s_865_8).unwrap(),
        ));
        // D s_865_10: cast reint s_865_9 -> u8
        let s_865_10: u8 = (s_865_9.value() as u8);
        // D s_865_11: cast zx s_865_10 -> bv
        let s_865_11: Bits = Bits::new(s_865_10 as u128, 7u16);
        // C s_865_12: const #121u : u8
        let s_865_12: u8 = 121;
        // C s_865_13: cast zx s_865_12 -> bv
        let s_865_13: Bits = Bits::new(s_865_12 as u128, 7u16);
        // D s_865_14: cmp-eq s_865_11 s_865_13
        let s_865_14: bool = ((s_865_11) == (s_865_13));
        // N s_865_15: branch s_865_14 b2332 b866
        if s_865_14 {
            return block_2332(state, tracer, fn_state);
        } else {
            return block_866(state, tracer, fn_state);
        };
    }
    fn block_866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_866_0: const #0u : u8
        let s_866_0: bool = false;
        // D s_866_1: write-var gs#400880 <= s_866_0
        fn_state.gs_400880 = s_866_0;
        // N s_866_2: jump b867
        return block_867(state, tracer, fn_state);
    }
    fn block_867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_867_0: read-var gs#400880:u8
        let s_867_0: bool = fn_state.gs_400880;
        // N s_867_1: branch s_867_0 b2331 b868
        if s_867_0 {
            return block_2331(state, tracer, fn_state);
        } else {
            return block_868(state, tracer, fn_state);
        };
    }
    fn block_868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_868_0: const #0u : u8
        let s_868_0: bool = false;
        // D s_868_1: write-var gs#400882 <= s_868_0
        fn_state.gs_400882 = s_868_0;
        // N s_868_2: jump b869
        return block_869(state, tracer, fn_state);
    }
    fn block_869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_869_0: read-var gs#400882:u8
        let s_869_0: bool = fn_state.gs_400882;
        // D s_869_1: not s_869_0
        let s_869_1: bool = !s_869_0;
        // N s_869_2: branch s_869_1 b871 b870
        if s_869_1 {
            return block_871(state, tracer, fn_state);
        } else {
            return block_870(state, tracer, fn_state);
        };
    }
    fn block_870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_870_0: const #3602s : i
        let s_870_0: i128 = 3602;
        // C s_870_1: const #14696u : u32
        let s_870_1: u32 = 14696;
        // N s_870_2: write-reg s_870_1 <= s_870_0
        let s_870_2: () = {
            state.write_register::<i128>(s_870_1 as isize, s_870_0);
            tracer.write_register(s_870_1 as isize, s_870_0);
        };
        // C s_870_3: const #24s : i
        let s_870_3: i128 = 24;
        // C s_870_4: const #1s : i
        let s_870_4: i128 = 1;
        // D s_870_5: read-var u#31473:u32
        let s_870_5: u32 = fn_state.u_31473;
        // D s_870_6: cast zx s_870_5 -> bv
        let s_870_6: Bits = Bits::new(s_870_5 as u128, 32u16);
        // D s_870_7: bit-extract s_870_6 s_870_3 s_870_4
        let s_870_7: Bits = (Bits::new(
            ((s_870_6) >> (s_870_3)).value(),
            u16::try_from(s_870_4).unwrap(),
        ));
        // D s_870_8: cast reint s_870_7 -> u8
        let s_870_8: bool = ((s_870_7.value()) != 0);
        // C s_870_9: const #22s : i
        let s_870_9: i128 = 22;
        // C s_870_10: const #1s : i
        let s_870_10: i128 = 1;
        // D s_870_11: read-var u#31473:u32
        let s_870_11: u32 = fn_state.u_31473;
        // D s_870_12: cast zx s_870_11 -> bv
        let s_870_12: Bits = Bits::new(s_870_11 as u128, 32u16);
        // D s_870_13: bit-extract s_870_12 s_870_9 s_870_10
        let s_870_13: Bits = (Bits::new(
            ((s_870_12) >> (s_870_9)).value(),
            u16::try_from(s_870_10).unwrap(),
        ));
        // D s_870_14: cast reint s_870_13 -> u8
        let s_870_14: bool = ((s_870_13.value()) != 0);
        // C s_870_15: const #20s : i
        let s_870_15: i128 = 20;
        // C s_870_16: const #2s : i
        let s_870_16: i128 = 2;
        // D s_870_17: read-var u#31473:u32
        let s_870_17: u32 = fn_state.u_31473;
        // D s_870_18: cast zx s_870_17 -> bv
        let s_870_18: Bits = Bits::new(s_870_17 as u128, 32u16);
        // D s_870_19: bit-extract s_870_18 s_870_15 s_870_16
        let s_870_19: Bits = (Bits::new(
            ((s_870_18) >> (s_870_15)).value(),
            u16::try_from(s_870_16).unwrap(),
        ));
        // D s_870_20: cast reint s_870_19 -> u8
        let s_870_20: u8 = (s_870_19.value() as u8);
        // C s_870_21: const #16s : i
        let s_870_21: i128 = 16;
        // C s_870_22: const #4s : i
        let s_870_22: i128 = 4;
        // D s_870_23: read-var u#31473:u32
        let s_870_23: u32 = fn_state.u_31473;
        // D s_870_24: cast zx s_870_23 -> bv
        let s_870_24: Bits = Bits::new(s_870_23 as u128, 32u16);
        // D s_870_25: bit-extract s_870_24 s_870_21 s_870_22
        let s_870_25: Bits = (Bits::new(
            ((s_870_24) >> (s_870_21)).value(),
            u16::try_from(s_870_22).unwrap(),
        ));
        // D s_870_26: cast reint s_870_25 -> u8
        let s_870_26: u8 = (s_870_25.value() as u8);
        // C s_870_27: const #12s : i
        let s_870_27: i128 = 12;
        // C s_870_28: const #4s : i
        let s_870_28: i128 = 4;
        // D s_870_29: read-var u#31473:u32
        let s_870_29: u32 = fn_state.u_31473;
        // D s_870_30: cast zx s_870_29 -> bv
        let s_870_30: Bits = Bits::new(s_870_29 as u128, 32u16);
        // D s_870_31: bit-extract s_870_30 s_870_27 s_870_28
        let s_870_31: Bits = (Bits::new(
            ((s_870_30) >> (s_870_27)).value(),
            u16::try_from(s_870_28).unwrap(),
        ));
        // D s_870_32: cast reint s_870_31 -> u8
        let s_870_32: u8 = (s_870_31.value() as u8);
        // C s_870_33: const #7s : i
        let s_870_33: i128 = 7;
        // C s_870_34: const #1s : i
        let s_870_34: i128 = 1;
        // D s_870_35: read-var u#31473:u32
        let s_870_35: u32 = fn_state.u_31473;
        // D s_870_36: cast zx s_870_35 -> bv
        let s_870_36: Bits = Bits::new(s_870_35 as u128, 32u16);
        // D s_870_37: bit-extract s_870_36 s_870_33 s_870_34
        let s_870_37: Bits = (Bits::new(
            ((s_870_36) >> (s_870_33)).value(),
            u16::try_from(s_870_34).unwrap(),
        ));
        // D s_870_38: cast reint s_870_37 -> u8
        let s_870_38: bool = ((s_870_37.value()) != 0);
        // C s_870_39: const #6s : i
        let s_870_39: i128 = 6;
        // C s_870_40: const #1s : i
        let s_870_40: i128 = 1;
        // D s_870_41: read-var u#31473:u32
        let s_870_41: u32 = fn_state.u_31473;
        // D s_870_42: cast zx s_870_41 -> bv
        let s_870_42: Bits = Bits::new(s_870_41 as u128, 32u16);
        // D s_870_43: bit-extract s_870_42 s_870_39 s_870_40
        let s_870_43: Bits = (Bits::new(
            ((s_870_42) >> (s_870_39)).value(),
            u16::try_from(s_870_40).unwrap(),
        ));
        // D s_870_44: cast reint s_870_43 -> u8
        let s_870_44: bool = ((s_870_43.value()) != 0);
        // C s_870_45: const #5s : i
        let s_870_45: i128 = 5;
        // C s_870_46: const #1s : i
        let s_870_46: i128 = 1;
        // D s_870_47: read-var u#31473:u32
        let s_870_47: u32 = fn_state.u_31473;
        // D s_870_48: cast zx s_870_47 -> bv
        let s_870_48: Bits = Bits::new(s_870_47 as u128, 32u16);
        // D s_870_49: bit-extract s_870_48 s_870_45 s_870_46
        let s_870_49: Bits = (Bits::new(
            ((s_870_48) >> (s_870_45)).value(),
            u16::try_from(s_870_46).unwrap(),
        ));
        // D s_870_50: cast reint s_870_49 -> u8
        let s_870_50: bool = ((s_870_49.value()) != 0);
        // C s_870_51: const #0s : i
        let s_870_51: i128 = 0;
        // C s_870_52: const #4s : i
        let s_870_52: i128 = 4;
        // D s_870_53: read-var u#31473:u32
        let s_870_53: u32 = fn_state.u_31473;
        // D s_870_54: cast zx s_870_53 -> bv
        let s_870_54: Bits = Bits::new(s_870_53 as u128, 32u16);
        // D s_870_55: bit-extract s_870_54 s_870_51 s_870_52
        let s_870_55: Bits = (Bits::new(
            ((s_870_54) >> (s_870_51)).value(),
            u16::try_from(s_870_52).unwrap(),
        ));
        // D s_870_56: cast reint s_870_55 -> u8
        let s_870_56: u8 = (s_870_55.value() as u8);
        // D s_870_57: call decode_aarch32_instrs_VQADD_A1enc_A_txt(s_870_8, s_870_14, s_870_20, s_870_26, s_870_32, s_870_38, s_870_44, s_870_50, s_870_56)
        let s_870_57: () = decode_aarch32_instrs_VQADD_A1enc_A_txt(
            state,
            tracer,
            s_870_8,
            s_870_14,
            s_870_20,
            s_870_26,
            s_870_32,
            s_870_38,
            s_870_44,
            s_870_50,
            s_870_56,
        );
        // N s_870_58: return
        return;
    }
    fn block_871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_871_0: read-var merge#var.1:struct
        let s_871_0: u32 = fn_state.merge_var._1;
        // D s_871_1: write-var u#31484 <= s_871_0
        fn_state.u_31484 = s_871_0;
        // C s_871_2: const #23s : i
        let s_871_2: i128 = 23;
        // D s_871_3: read-var u#31484:u32
        let s_871_3: u32 = fn_state.u_31484;
        // D s_871_4: cast zx s_871_3 -> bv
        let s_871_4: Bits = Bits::new(s_871_3 as u128, 32u16);
        // C s_871_5: const #1s : i64
        let s_871_5: i64 = 1;
        // C s_871_6: cast zx s_871_5 -> i
        let s_871_6: i128 = (i128::try_from(s_871_5).unwrap());
        // C s_871_7: const #8s : i
        let s_871_7: i128 = 8;
        // C s_871_8: add s_871_7 s_871_6
        let s_871_8: i128 = (s_871_7 + s_871_6);
        // D s_871_9: bit-extract s_871_4 s_871_2 s_871_8
        let s_871_9: Bits = (Bits::new(
            ((s_871_4) >> (s_871_2)).value(),
            u16::try_from(s_871_8).unwrap(),
        ));
        // D s_871_10: cast reint s_871_9 -> u9
        let s_871_10: u16 = (s_871_9.value() as u16);
        // D s_871_11: cast zx s_871_10 -> bv
        let s_871_11: Bits = Bits::new(s_871_10 as u128, 9u16);
        // C s_871_12: const #485u : u9
        let s_871_12: u16 = 485;
        // C s_871_13: cast zx s_871_12 -> bv
        let s_871_13: Bits = Bits::new(s_871_12 as u128, 9u16);
        // D s_871_14: cmp-eq s_871_11 s_871_13
        let s_871_14: bool = ((s_871_11) == (s_871_13));
        // N s_871_15: branch s_871_14 b2324 b872
        if s_871_14 {
            return block_2324(state, tracer, fn_state);
        } else {
            return block_872(state, tracer, fn_state);
        };
    }
    fn block_872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_872_0: const #0u : u8
        let s_872_0: bool = false;
        // D s_872_1: write-var gs#400914 <= s_872_0
        fn_state.gs_400914 = s_872_0;
        // N s_872_2: jump b873
        return block_873(state, tracer, fn_state);
    }
    fn block_873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_873_0: read-var gs#400914:u8
        let s_873_0: bool = fn_state.gs_400914;
        // N s_873_1: branch s_873_0 b2323 b874
        if s_873_0 {
            return block_2323(state, tracer, fn_state);
        } else {
            return block_874(state, tracer, fn_state);
        };
    }
    fn block_874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_874_0: const #0u : u8
        let s_874_0: bool = false;
        // D s_874_1: write-var gs#400916 <= s_874_0
        fn_state.gs_400916 = s_874_0;
        // N s_874_2: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_875_0: read-var gs#400916:u8
        let s_875_0: bool = fn_state.gs_400916;
        // D s_875_1: not s_875_0
        let s_875_1: bool = !s_875_0;
        // N s_875_2: branch s_875_1 b877 b876
        if s_875_1 {
            return block_877(state, tracer, fn_state);
        } else {
            return block_876(state, tracer, fn_state);
        };
    }
    fn block_876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_876_0: const #3604s : i
        let s_876_0: i128 = 3604;
        // C s_876_1: const #14696u : u32
        let s_876_1: u32 = 14696;
        // N s_876_2: write-reg s_876_1 <= s_876_0
        let s_876_2: () = {
            state.write_register::<i128>(s_876_1 as isize, s_876_0);
            tracer.write_register(s_876_1 as isize, s_876_0);
        };
        // C s_876_3: const #22s : i
        let s_876_3: i128 = 22;
        // C s_876_4: const #1s : i
        let s_876_4: i128 = 1;
        // D s_876_5: read-var u#31484:u32
        let s_876_5: u32 = fn_state.u_31484;
        // D s_876_6: cast zx s_876_5 -> bv
        let s_876_6: Bits = Bits::new(s_876_5 as u128, 32u16);
        // D s_876_7: bit-extract s_876_6 s_876_3 s_876_4
        let s_876_7: Bits = (Bits::new(
            ((s_876_6) >> (s_876_3)).value(),
            u16::try_from(s_876_4).unwrap(),
        ));
        // D s_876_8: cast reint s_876_7 -> u8
        let s_876_8: bool = ((s_876_7.value()) != 0);
        // C s_876_9: const #20s : i
        let s_876_9: i128 = 20;
        // C s_876_10: const #2s : i
        let s_876_10: i128 = 2;
        // D s_876_11: read-var u#31484:u32
        let s_876_11: u32 = fn_state.u_31484;
        // D s_876_12: cast zx s_876_11 -> bv
        let s_876_12: Bits = Bits::new(s_876_11 as u128, 32u16);
        // D s_876_13: bit-extract s_876_12 s_876_9 s_876_10
        let s_876_13: Bits = (Bits::new(
            ((s_876_12) >> (s_876_9)).value(),
            u16::try_from(s_876_10).unwrap(),
        ));
        // D s_876_14: cast reint s_876_13 -> u8
        let s_876_14: u8 = (s_876_13.value() as u8);
        // C s_876_15: const #16s : i
        let s_876_15: i128 = 16;
        // C s_876_16: const #4s : i
        let s_876_16: i128 = 4;
        // D s_876_17: read-var u#31484:u32
        let s_876_17: u32 = fn_state.u_31484;
        // D s_876_18: cast zx s_876_17 -> bv
        let s_876_18: Bits = Bits::new(s_876_17 as u128, 32u16);
        // D s_876_19: bit-extract s_876_18 s_876_15 s_876_16
        let s_876_19: Bits = (Bits::new(
            ((s_876_18) >> (s_876_15)).value(),
            u16::try_from(s_876_16).unwrap(),
        ));
        // D s_876_20: cast reint s_876_19 -> u8
        let s_876_20: u8 = (s_876_19.value() as u8);
        // C s_876_21: const #12s : i
        let s_876_21: i128 = 12;
        // C s_876_22: const #4s : i
        let s_876_22: i128 = 4;
        // D s_876_23: read-var u#31484:u32
        let s_876_23: u32 = fn_state.u_31484;
        // D s_876_24: cast zx s_876_23 -> bv
        let s_876_24: Bits = Bits::new(s_876_23 as u128, 32u16);
        // D s_876_25: bit-extract s_876_24 s_876_21 s_876_22
        let s_876_25: Bits = (Bits::new(
            ((s_876_24) >> (s_876_21)).value(),
            u16::try_from(s_876_22).unwrap(),
        ));
        // D s_876_26: cast reint s_876_25 -> u8
        let s_876_26: u8 = (s_876_25.value() as u8);
        // C s_876_27: const #9s : i
        let s_876_27: i128 = 9;
        // C s_876_28: const #1s : i
        let s_876_28: i128 = 1;
        // D s_876_29: read-var u#31484:u32
        let s_876_29: u32 = fn_state.u_31484;
        // D s_876_30: cast zx s_876_29 -> bv
        let s_876_30: Bits = Bits::new(s_876_29 as u128, 32u16);
        // D s_876_31: bit-extract s_876_30 s_876_27 s_876_28
        let s_876_31: Bits = (Bits::new(
            ((s_876_30) >> (s_876_27)).value(),
            u16::try_from(s_876_28).unwrap(),
        ));
        // D s_876_32: cast reint s_876_31 -> u8
        let s_876_32: bool = ((s_876_31.value()) != 0);
        // C s_876_33: const #7s : i
        let s_876_33: i128 = 7;
        // C s_876_34: const #1s : i
        let s_876_34: i128 = 1;
        // D s_876_35: read-var u#31484:u32
        let s_876_35: u32 = fn_state.u_31484;
        // D s_876_36: cast zx s_876_35 -> bv
        let s_876_36: Bits = Bits::new(s_876_35 as u128, 32u16);
        // D s_876_37: bit-extract s_876_36 s_876_33 s_876_34
        let s_876_37: Bits = (Bits::new(
            ((s_876_36) >> (s_876_33)).value(),
            u16::try_from(s_876_34).unwrap(),
        ));
        // D s_876_38: cast reint s_876_37 -> u8
        let s_876_38: bool = ((s_876_37.value()) != 0);
        // C s_876_39: const #5s : i
        let s_876_39: i128 = 5;
        // C s_876_40: const #1s : i
        let s_876_40: i128 = 1;
        // D s_876_41: read-var u#31484:u32
        let s_876_41: u32 = fn_state.u_31484;
        // D s_876_42: cast zx s_876_41 -> bv
        let s_876_42: Bits = Bits::new(s_876_41 as u128, 32u16);
        // D s_876_43: bit-extract s_876_42 s_876_39 s_876_40
        let s_876_43: Bits = (Bits::new(
            ((s_876_42) >> (s_876_39)).value(),
            u16::try_from(s_876_40).unwrap(),
        ));
        // D s_876_44: cast reint s_876_43 -> u8
        let s_876_44: bool = ((s_876_43.value()) != 0);
        // C s_876_45: const #0s : i
        let s_876_45: i128 = 0;
        // C s_876_46: const #4s : i
        let s_876_46: i128 = 4;
        // D s_876_47: read-var u#31484:u32
        let s_876_47: u32 = fn_state.u_31484;
        // D s_876_48: cast zx s_876_47 -> bv
        let s_876_48: Bits = Bits::new(s_876_47 as u128, 32u16);
        // D s_876_49: bit-extract s_876_48 s_876_45 s_876_46
        let s_876_49: Bits = (Bits::new(
            ((s_876_48) >> (s_876_45)).value(),
            u16::try_from(s_876_46).unwrap(),
        ));
        // D s_876_50: cast reint s_876_49 -> u8
        let s_876_50: u8 = (s_876_49.value() as u8);
        // D s_876_51: call decode_aarch32_instrs_VQDMLAL_A1enc_A_txt(s_876_8, s_876_14, s_876_20, s_876_26, s_876_32, s_876_38, s_876_44, s_876_50)
        let s_876_51: () = decode_aarch32_instrs_VQDMLAL_A1enc_A_txt(
            state,
            tracer,
            s_876_8,
            s_876_14,
            s_876_20,
            s_876_26,
            s_876_32,
            s_876_38,
            s_876_44,
            s_876_50,
        );
        // N s_876_52: return
        return;
    }
    fn block_877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_877_0: read-var merge#var.1:struct
        let s_877_0: u32 = fn_state.merge_var._1;
        // D s_877_1: write-var u#31494 <= s_877_0
        fn_state.u_31494 = s_877_0;
        // C s_877_2: const #23s : i
        let s_877_2: i128 = 23;
        // D s_877_3: read-var u#31494:u32
        let s_877_3: u32 = fn_state.u_31494;
        // D s_877_4: cast zx s_877_3 -> bv
        let s_877_4: Bits = Bits::new(s_877_3 as u128, 32u16);
        // C s_877_5: const #1s : i64
        let s_877_5: i64 = 1;
        // C s_877_6: cast zx s_877_5 -> i
        let s_877_6: i128 = (i128::try_from(s_877_5).unwrap());
        // C s_877_7: const #8s : i
        let s_877_7: i128 = 8;
        // C s_877_8: add s_877_7 s_877_6
        let s_877_8: i128 = (s_877_7 + s_877_6);
        // D s_877_9: bit-extract s_877_4 s_877_2 s_877_8
        let s_877_9: Bits = (Bits::new(
            ((s_877_4) >> (s_877_2)).value(),
            u16::try_from(s_877_8).unwrap(),
        ));
        // D s_877_10: cast reint s_877_9 -> u9
        let s_877_10: u16 = (s_877_9.value() as u16);
        // D s_877_11: cast zx s_877_10 -> bv
        let s_877_11: Bits = Bits::new(s_877_10 as u128, 9u16);
        // C s_877_12: const #485u : u9
        let s_877_12: u16 = 485;
        // C s_877_13: cast zx s_877_12 -> bv
        let s_877_13: Bits = Bits::new(s_877_12 as u128, 9u16);
        // D s_877_14: cmp-eq s_877_11 s_877_13
        let s_877_14: bool = ((s_877_11) == (s_877_13));
        // N s_877_15: branch s_877_14 b2316 b878
        if s_877_14 {
            return block_2316(state, tracer, fn_state);
        } else {
            return block_878(state, tracer, fn_state);
        };
    }
    fn block_878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_878_0: const #0u : u8
        let s_878_0: bool = false;
        // D s_878_1: write-var gs#400946 <= s_878_0
        fn_state.gs_400946 = s_878_0;
        // N s_878_2: jump b879
        return block_879(state, tracer, fn_state);
    }
    fn block_879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_879_0: read-var gs#400946:u8
        let s_879_0: bool = fn_state.gs_400946;
        // N s_879_1: branch s_879_0 b2315 b880
        if s_879_0 {
            return block_2315(state, tracer, fn_state);
        } else {
            return block_880(state, tracer, fn_state);
        };
    }
    fn block_880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_880_0: const #0u : u8
        let s_880_0: bool = false;
        // D s_880_1: write-var gs#400948 <= s_880_0
        fn_state.gs_400948 = s_880_0;
        // N s_880_2: jump b881
        return block_881(state, tracer, fn_state);
    }
    fn block_881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_881_0: read-var gs#400948:u8
        let s_881_0: bool = fn_state.gs_400948;
        // D s_881_1: not s_881_0
        let s_881_1: bool = !s_881_0;
        // N s_881_2: branch s_881_1 b883 b882
        if s_881_1 {
            return block_883(state, tracer, fn_state);
        } else {
            return block_882(state, tracer, fn_state);
        };
    }
    fn block_882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_882_0: const #3605s : i
        let s_882_0: i128 = 3605;
        // C s_882_1: const #14696u : u32
        let s_882_1: u32 = 14696;
        // N s_882_2: write-reg s_882_1 <= s_882_0
        let s_882_2: () = {
            state.write_register::<i128>(s_882_1 as isize, s_882_0);
            tracer.write_register(s_882_1 as isize, s_882_0);
        };
        // C s_882_3: const #22s : i
        let s_882_3: i128 = 22;
        // C s_882_4: const #1s : i
        let s_882_4: i128 = 1;
        // D s_882_5: read-var u#31494:u32
        let s_882_5: u32 = fn_state.u_31494;
        // D s_882_6: cast zx s_882_5 -> bv
        let s_882_6: Bits = Bits::new(s_882_5 as u128, 32u16);
        // D s_882_7: bit-extract s_882_6 s_882_3 s_882_4
        let s_882_7: Bits = (Bits::new(
            ((s_882_6) >> (s_882_3)).value(),
            u16::try_from(s_882_4).unwrap(),
        ));
        // D s_882_8: cast reint s_882_7 -> u8
        let s_882_8: bool = ((s_882_7.value()) != 0);
        // C s_882_9: const #20s : i
        let s_882_9: i128 = 20;
        // C s_882_10: const #2s : i
        let s_882_10: i128 = 2;
        // D s_882_11: read-var u#31494:u32
        let s_882_11: u32 = fn_state.u_31494;
        // D s_882_12: cast zx s_882_11 -> bv
        let s_882_12: Bits = Bits::new(s_882_11 as u128, 32u16);
        // D s_882_13: bit-extract s_882_12 s_882_9 s_882_10
        let s_882_13: Bits = (Bits::new(
            ((s_882_12) >> (s_882_9)).value(),
            u16::try_from(s_882_10).unwrap(),
        ));
        // D s_882_14: cast reint s_882_13 -> u8
        let s_882_14: u8 = (s_882_13.value() as u8);
        // C s_882_15: const #16s : i
        let s_882_15: i128 = 16;
        // C s_882_16: const #4s : i
        let s_882_16: i128 = 4;
        // D s_882_17: read-var u#31494:u32
        let s_882_17: u32 = fn_state.u_31494;
        // D s_882_18: cast zx s_882_17 -> bv
        let s_882_18: Bits = Bits::new(s_882_17 as u128, 32u16);
        // D s_882_19: bit-extract s_882_18 s_882_15 s_882_16
        let s_882_19: Bits = (Bits::new(
            ((s_882_18) >> (s_882_15)).value(),
            u16::try_from(s_882_16).unwrap(),
        ));
        // D s_882_20: cast reint s_882_19 -> u8
        let s_882_20: u8 = (s_882_19.value() as u8);
        // C s_882_21: const #12s : i
        let s_882_21: i128 = 12;
        // C s_882_22: const #4s : i
        let s_882_22: i128 = 4;
        // D s_882_23: read-var u#31494:u32
        let s_882_23: u32 = fn_state.u_31494;
        // D s_882_24: cast zx s_882_23 -> bv
        let s_882_24: Bits = Bits::new(s_882_23 as u128, 32u16);
        // D s_882_25: bit-extract s_882_24 s_882_21 s_882_22
        let s_882_25: Bits = (Bits::new(
            ((s_882_24) >> (s_882_21)).value(),
            u16::try_from(s_882_22).unwrap(),
        ));
        // D s_882_26: cast reint s_882_25 -> u8
        let s_882_26: u8 = (s_882_25.value() as u8);
        // C s_882_27: const #10s : i
        let s_882_27: i128 = 10;
        // C s_882_28: const #1s : i
        let s_882_28: i128 = 1;
        // D s_882_29: read-var u#31494:u32
        let s_882_29: u32 = fn_state.u_31494;
        // D s_882_30: cast zx s_882_29 -> bv
        let s_882_30: Bits = Bits::new(s_882_29 as u128, 32u16);
        // D s_882_31: bit-extract s_882_30 s_882_27 s_882_28
        let s_882_31: Bits = (Bits::new(
            ((s_882_30) >> (s_882_27)).value(),
            u16::try_from(s_882_28).unwrap(),
        ));
        // D s_882_32: cast reint s_882_31 -> u8
        let s_882_32: bool = ((s_882_31.value()) != 0);
        // C s_882_33: const #7s : i
        let s_882_33: i128 = 7;
        // C s_882_34: const #1s : i
        let s_882_34: i128 = 1;
        // D s_882_35: read-var u#31494:u32
        let s_882_35: u32 = fn_state.u_31494;
        // D s_882_36: cast zx s_882_35 -> bv
        let s_882_36: Bits = Bits::new(s_882_35 as u128, 32u16);
        // D s_882_37: bit-extract s_882_36 s_882_33 s_882_34
        let s_882_37: Bits = (Bits::new(
            ((s_882_36) >> (s_882_33)).value(),
            u16::try_from(s_882_34).unwrap(),
        ));
        // D s_882_38: cast reint s_882_37 -> u8
        let s_882_38: bool = ((s_882_37.value()) != 0);
        // C s_882_39: const #5s : i
        let s_882_39: i128 = 5;
        // C s_882_40: const #1s : i
        let s_882_40: i128 = 1;
        // D s_882_41: read-var u#31494:u32
        let s_882_41: u32 = fn_state.u_31494;
        // D s_882_42: cast zx s_882_41 -> bv
        let s_882_42: Bits = Bits::new(s_882_41 as u128, 32u16);
        // D s_882_43: bit-extract s_882_42 s_882_39 s_882_40
        let s_882_43: Bits = (Bits::new(
            ((s_882_42) >> (s_882_39)).value(),
            u16::try_from(s_882_40).unwrap(),
        ));
        // D s_882_44: cast reint s_882_43 -> u8
        let s_882_44: bool = ((s_882_43.value()) != 0);
        // C s_882_45: const #0s : i
        let s_882_45: i128 = 0;
        // C s_882_46: const #4s : i
        let s_882_46: i128 = 4;
        // D s_882_47: read-var u#31494:u32
        let s_882_47: u32 = fn_state.u_31494;
        // D s_882_48: cast zx s_882_47 -> bv
        let s_882_48: Bits = Bits::new(s_882_47 as u128, 32u16);
        // D s_882_49: bit-extract s_882_48 s_882_45 s_882_46
        let s_882_49: Bits = (Bits::new(
            ((s_882_48) >> (s_882_45)).value(),
            u16::try_from(s_882_46).unwrap(),
        ));
        // D s_882_50: cast reint s_882_49 -> u8
        let s_882_50: u8 = (s_882_49.value() as u8);
        // D s_882_51: call decode_aarch32_instrs_VQDMLAL_A2enc_A_txt(s_882_8, s_882_14, s_882_20, s_882_26, s_882_32, s_882_38, s_882_44, s_882_50)
        let s_882_51: () = decode_aarch32_instrs_VQDMLAL_A2enc_A_txt(
            state,
            tracer,
            s_882_8,
            s_882_14,
            s_882_20,
            s_882_26,
            s_882_32,
            s_882_38,
            s_882_44,
            s_882_50,
        );
        // N s_882_52: return
        return;
    }
    fn block_883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_883_0: read-var merge#var.1:struct
        let s_883_0: u32 = fn_state.merge_var._1;
        // D s_883_1: write-var u#31504 <= s_883_0
        fn_state.u_31504 = s_883_0;
        // C s_883_2: const #23s : i
        let s_883_2: i128 = 23;
        // D s_883_3: read-var u#31504:u32
        let s_883_3: u32 = fn_state.u_31504;
        // D s_883_4: cast zx s_883_3 -> bv
        let s_883_4: Bits = Bits::new(s_883_3 as u128, 32u16);
        // C s_883_5: const #1s : i64
        let s_883_5: i64 = 1;
        // C s_883_6: cast zx s_883_5 -> i
        let s_883_6: i128 = (i128::try_from(s_883_5).unwrap());
        // C s_883_7: const #8s : i
        let s_883_7: i128 = 8;
        // C s_883_8: add s_883_7 s_883_6
        let s_883_8: i128 = (s_883_7 + s_883_6);
        // D s_883_9: bit-extract s_883_4 s_883_2 s_883_8
        let s_883_9: Bits = (Bits::new(
            ((s_883_4) >> (s_883_2)).value(),
            u16::try_from(s_883_8).unwrap(),
        ));
        // D s_883_10: cast reint s_883_9 -> u9
        let s_883_10: u16 = (s_883_9.value() as u16);
        // D s_883_11: cast zx s_883_10 -> bv
        let s_883_11: Bits = Bits::new(s_883_10 as u128, 9u16);
        // C s_883_12: const #485u : u9
        let s_883_12: u16 = 485;
        // C s_883_13: cast zx s_883_12 -> bv
        let s_883_13: Bits = Bits::new(s_883_12 as u128, 9u16);
        // D s_883_14: cmp-eq s_883_11 s_883_13
        let s_883_14: bool = ((s_883_11) == (s_883_13));
        // N s_883_15: branch s_883_14 b2308 b884
        if s_883_14 {
            return block_2308(state, tracer, fn_state);
        } else {
            return block_884(state, tracer, fn_state);
        };
    }
    fn block_884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_884_0: const #0u : u8
        let s_884_0: bool = false;
        // D s_884_1: write-var gs#400978 <= s_884_0
        fn_state.gs_400978 = s_884_0;
        // N s_884_2: jump b885
        return block_885(state, tracer, fn_state);
    }
    fn block_885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_885_0: read-var gs#400978:u8
        let s_885_0: bool = fn_state.gs_400978;
        // N s_885_1: branch s_885_0 b2307 b886
        if s_885_0 {
            return block_2307(state, tracer, fn_state);
        } else {
            return block_886(state, tracer, fn_state);
        };
    }
    fn block_886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_886_0: const #0u : u8
        let s_886_0: bool = false;
        // D s_886_1: write-var gs#400980 <= s_886_0
        fn_state.gs_400980 = s_886_0;
        // N s_886_2: jump b887
        return block_887(state, tracer, fn_state);
    }
    fn block_887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_887_0: read-var gs#400980:u8
        let s_887_0: bool = fn_state.gs_400980;
        // D s_887_1: not s_887_0
        let s_887_1: bool = !s_887_0;
        // N s_887_2: branch s_887_1 b889 b888
        if s_887_1 {
            return block_889(state, tracer, fn_state);
        } else {
            return block_888(state, tracer, fn_state);
        };
    }
    fn block_888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_888_0: const #3608s : i
        let s_888_0: i128 = 3608;
        // C s_888_1: const #14696u : u32
        let s_888_1: u32 = 14696;
        // N s_888_2: write-reg s_888_1 <= s_888_0
        let s_888_2: () = {
            state.write_register::<i128>(s_888_1 as isize, s_888_0);
            tracer.write_register(s_888_1 as isize, s_888_0);
        };
        // C s_888_3: const #22s : i
        let s_888_3: i128 = 22;
        // C s_888_4: const #1s : i
        let s_888_4: i128 = 1;
        // D s_888_5: read-var u#31504:u32
        let s_888_5: u32 = fn_state.u_31504;
        // D s_888_6: cast zx s_888_5 -> bv
        let s_888_6: Bits = Bits::new(s_888_5 as u128, 32u16);
        // D s_888_7: bit-extract s_888_6 s_888_3 s_888_4
        let s_888_7: Bits = (Bits::new(
            ((s_888_6) >> (s_888_3)).value(),
            u16::try_from(s_888_4).unwrap(),
        ));
        // D s_888_8: cast reint s_888_7 -> u8
        let s_888_8: bool = ((s_888_7.value()) != 0);
        // C s_888_9: const #20s : i
        let s_888_9: i128 = 20;
        // C s_888_10: const #2s : i
        let s_888_10: i128 = 2;
        // D s_888_11: read-var u#31504:u32
        let s_888_11: u32 = fn_state.u_31504;
        // D s_888_12: cast zx s_888_11 -> bv
        let s_888_12: Bits = Bits::new(s_888_11 as u128, 32u16);
        // D s_888_13: bit-extract s_888_12 s_888_9 s_888_10
        let s_888_13: Bits = (Bits::new(
            ((s_888_12) >> (s_888_9)).value(),
            u16::try_from(s_888_10).unwrap(),
        ));
        // D s_888_14: cast reint s_888_13 -> u8
        let s_888_14: u8 = (s_888_13.value() as u8);
        // C s_888_15: const #16s : i
        let s_888_15: i128 = 16;
        // C s_888_16: const #4s : i
        let s_888_16: i128 = 4;
        // D s_888_17: read-var u#31504:u32
        let s_888_17: u32 = fn_state.u_31504;
        // D s_888_18: cast zx s_888_17 -> bv
        let s_888_18: Bits = Bits::new(s_888_17 as u128, 32u16);
        // D s_888_19: bit-extract s_888_18 s_888_15 s_888_16
        let s_888_19: Bits = (Bits::new(
            ((s_888_18) >> (s_888_15)).value(),
            u16::try_from(s_888_16).unwrap(),
        ));
        // D s_888_20: cast reint s_888_19 -> u8
        let s_888_20: u8 = (s_888_19.value() as u8);
        // C s_888_21: const #12s : i
        let s_888_21: i128 = 12;
        // C s_888_22: const #4s : i
        let s_888_22: i128 = 4;
        // D s_888_23: read-var u#31504:u32
        let s_888_23: u32 = fn_state.u_31504;
        // D s_888_24: cast zx s_888_23 -> bv
        let s_888_24: Bits = Bits::new(s_888_23 as u128, 32u16);
        // D s_888_25: bit-extract s_888_24 s_888_21 s_888_22
        let s_888_25: Bits = (Bits::new(
            ((s_888_24) >> (s_888_21)).value(),
            u16::try_from(s_888_22).unwrap(),
        ));
        // D s_888_26: cast reint s_888_25 -> u8
        let s_888_26: u8 = (s_888_25.value() as u8);
        // C s_888_27: const #9s : i
        let s_888_27: i128 = 9;
        // C s_888_28: const #1s : i
        let s_888_28: i128 = 1;
        // D s_888_29: read-var u#31504:u32
        let s_888_29: u32 = fn_state.u_31504;
        // D s_888_30: cast zx s_888_29 -> bv
        let s_888_30: Bits = Bits::new(s_888_29 as u128, 32u16);
        // D s_888_31: bit-extract s_888_30 s_888_27 s_888_28
        let s_888_31: Bits = (Bits::new(
            ((s_888_30) >> (s_888_27)).value(),
            u16::try_from(s_888_28).unwrap(),
        ));
        // D s_888_32: cast reint s_888_31 -> u8
        let s_888_32: bool = ((s_888_31.value()) != 0);
        // C s_888_33: const #7s : i
        let s_888_33: i128 = 7;
        // C s_888_34: const #1s : i
        let s_888_34: i128 = 1;
        // D s_888_35: read-var u#31504:u32
        let s_888_35: u32 = fn_state.u_31504;
        // D s_888_36: cast zx s_888_35 -> bv
        let s_888_36: Bits = Bits::new(s_888_35 as u128, 32u16);
        // D s_888_37: bit-extract s_888_36 s_888_33 s_888_34
        let s_888_37: Bits = (Bits::new(
            ((s_888_36) >> (s_888_33)).value(),
            u16::try_from(s_888_34).unwrap(),
        ));
        // D s_888_38: cast reint s_888_37 -> u8
        let s_888_38: bool = ((s_888_37.value()) != 0);
        // C s_888_39: const #5s : i
        let s_888_39: i128 = 5;
        // C s_888_40: const #1s : i
        let s_888_40: i128 = 1;
        // D s_888_41: read-var u#31504:u32
        let s_888_41: u32 = fn_state.u_31504;
        // D s_888_42: cast zx s_888_41 -> bv
        let s_888_42: Bits = Bits::new(s_888_41 as u128, 32u16);
        // D s_888_43: bit-extract s_888_42 s_888_39 s_888_40
        let s_888_43: Bits = (Bits::new(
            ((s_888_42) >> (s_888_39)).value(),
            u16::try_from(s_888_40).unwrap(),
        ));
        // D s_888_44: cast reint s_888_43 -> u8
        let s_888_44: bool = ((s_888_43.value()) != 0);
        // C s_888_45: const #0s : i
        let s_888_45: i128 = 0;
        // C s_888_46: const #4s : i
        let s_888_46: i128 = 4;
        // D s_888_47: read-var u#31504:u32
        let s_888_47: u32 = fn_state.u_31504;
        // D s_888_48: cast zx s_888_47 -> bv
        let s_888_48: Bits = Bits::new(s_888_47 as u128, 32u16);
        // D s_888_49: bit-extract s_888_48 s_888_45 s_888_46
        let s_888_49: Bits = (Bits::new(
            ((s_888_48) >> (s_888_45)).value(),
            u16::try_from(s_888_46).unwrap(),
        ));
        // D s_888_50: cast reint s_888_49 -> u8
        let s_888_50: u8 = (s_888_49.value() as u8);
        // D s_888_51: call decode_aarch32_instrs_VQDMLSL_A1enc_A_txt(s_888_8, s_888_14, s_888_20, s_888_26, s_888_32, s_888_38, s_888_44, s_888_50)
        let s_888_51: () = decode_aarch32_instrs_VQDMLSL_A1enc_A_txt(
            state,
            tracer,
            s_888_8,
            s_888_14,
            s_888_20,
            s_888_26,
            s_888_32,
            s_888_38,
            s_888_44,
            s_888_50,
        );
        // N s_888_52: return
        return;
    }
    fn block_889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_889_0: read-var merge#var.1:struct
        let s_889_0: u32 = fn_state.merge_var._1;
        // D s_889_1: write-var u#31514 <= s_889_0
        fn_state.u_31514 = s_889_0;
        // C s_889_2: const #23s : i
        let s_889_2: i128 = 23;
        // D s_889_3: read-var u#31514:u32
        let s_889_3: u32 = fn_state.u_31514;
        // D s_889_4: cast zx s_889_3 -> bv
        let s_889_4: Bits = Bits::new(s_889_3 as u128, 32u16);
        // C s_889_5: const #1s : i64
        let s_889_5: i64 = 1;
        // C s_889_6: cast zx s_889_5 -> i
        let s_889_6: i128 = (i128::try_from(s_889_5).unwrap());
        // C s_889_7: const #8s : i
        let s_889_7: i128 = 8;
        // C s_889_8: add s_889_7 s_889_6
        let s_889_8: i128 = (s_889_7 + s_889_6);
        // D s_889_9: bit-extract s_889_4 s_889_2 s_889_8
        let s_889_9: Bits = (Bits::new(
            ((s_889_4) >> (s_889_2)).value(),
            u16::try_from(s_889_8).unwrap(),
        ));
        // D s_889_10: cast reint s_889_9 -> u9
        let s_889_10: u16 = (s_889_9.value() as u16);
        // D s_889_11: cast zx s_889_10 -> bv
        let s_889_11: Bits = Bits::new(s_889_10 as u128, 9u16);
        // C s_889_12: const #485u : u9
        let s_889_12: u16 = 485;
        // C s_889_13: cast zx s_889_12 -> bv
        let s_889_13: Bits = Bits::new(s_889_12 as u128, 9u16);
        // D s_889_14: cmp-eq s_889_11 s_889_13
        let s_889_14: bool = ((s_889_11) == (s_889_13));
        // N s_889_15: branch s_889_14 b2300 b890
        if s_889_14 {
            return block_2300(state, tracer, fn_state);
        } else {
            return block_890(state, tracer, fn_state);
        };
    }
    fn block_890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_890_0: const #0u : u8
        let s_890_0: bool = false;
        // D s_890_1: write-var gs#401010 <= s_890_0
        fn_state.gs_401010 = s_890_0;
        // N s_890_2: jump b891
        return block_891(state, tracer, fn_state);
    }
    fn block_891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_891_0: read-var gs#401010:u8
        let s_891_0: bool = fn_state.gs_401010;
        // N s_891_1: branch s_891_0 b2299 b892
        if s_891_0 {
            return block_2299(state, tracer, fn_state);
        } else {
            return block_892(state, tracer, fn_state);
        };
    }
    fn block_892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_892_0: const #0u : u8
        let s_892_0: bool = false;
        // D s_892_1: write-var gs#401012 <= s_892_0
        fn_state.gs_401012 = s_892_0;
        // N s_892_2: jump b893
        return block_893(state, tracer, fn_state);
    }
    fn block_893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_893_0: read-var gs#401012:u8
        let s_893_0: bool = fn_state.gs_401012;
        // D s_893_1: not s_893_0
        let s_893_1: bool = !s_893_0;
        // N s_893_2: branch s_893_1 b895 b894
        if s_893_1 {
            return block_895(state, tracer, fn_state);
        } else {
            return block_894(state, tracer, fn_state);
        };
    }
    fn block_894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_894_0: const #3609s : i
        let s_894_0: i128 = 3609;
        // C s_894_1: const #14696u : u32
        let s_894_1: u32 = 14696;
        // N s_894_2: write-reg s_894_1 <= s_894_0
        let s_894_2: () = {
            state.write_register::<i128>(s_894_1 as isize, s_894_0);
            tracer.write_register(s_894_1 as isize, s_894_0);
        };
        // C s_894_3: const #22s : i
        let s_894_3: i128 = 22;
        // C s_894_4: const #1s : i
        let s_894_4: i128 = 1;
        // D s_894_5: read-var u#31514:u32
        let s_894_5: u32 = fn_state.u_31514;
        // D s_894_6: cast zx s_894_5 -> bv
        let s_894_6: Bits = Bits::new(s_894_5 as u128, 32u16);
        // D s_894_7: bit-extract s_894_6 s_894_3 s_894_4
        let s_894_7: Bits = (Bits::new(
            ((s_894_6) >> (s_894_3)).value(),
            u16::try_from(s_894_4).unwrap(),
        ));
        // D s_894_8: cast reint s_894_7 -> u8
        let s_894_8: bool = ((s_894_7.value()) != 0);
        // C s_894_9: const #20s : i
        let s_894_9: i128 = 20;
        // C s_894_10: const #2s : i
        let s_894_10: i128 = 2;
        // D s_894_11: read-var u#31514:u32
        let s_894_11: u32 = fn_state.u_31514;
        // D s_894_12: cast zx s_894_11 -> bv
        let s_894_12: Bits = Bits::new(s_894_11 as u128, 32u16);
        // D s_894_13: bit-extract s_894_12 s_894_9 s_894_10
        let s_894_13: Bits = (Bits::new(
            ((s_894_12) >> (s_894_9)).value(),
            u16::try_from(s_894_10).unwrap(),
        ));
        // D s_894_14: cast reint s_894_13 -> u8
        let s_894_14: u8 = (s_894_13.value() as u8);
        // C s_894_15: const #16s : i
        let s_894_15: i128 = 16;
        // C s_894_16: const #4s : i
        let s_894_16: i128 = 4;
        // D s_894_17: read-var u#31514:u32
        let s_894_17: u32 = fn_state.u_31514;
        // D s_894_18: cast zx s_894_17 -> bv
        let s_894_18: Bits = Bits::new(s_894_17 as u128, 32u16);
        // D s_894_19: bit-extract s_894_18 s_894_15 s_894_16
        let s_894_19: Bits = (Bits::new(
            ((s_894_18) >> (s_894_15)).value(),
            u16::try_from(s_894_16).unwrap(),
        ));
        // D s_894_20: cast reint s_894_19 -> u8
        let s_894_20: u8 = (s_894_19.value() as u8);
        // C s_894_21: const #12s : i
        let s_894_21: i128 = 12;
        // C s_894_22: const #4s : i
        let s_894_22: i128 = 4;
        // D s_894_23: read-var u#31514:u32
        let s_894_23: u32 = fn_state.u_31514;
        // D s_894_24: cast zx s_894_23 -> bv
        let s_894_24: Bits = Bits::new(s_894_23 as u128, 32u16);
        // D s_894_25: bit-extract s_894_24 s_894_21 s_894_22
        let s_894_25: Bits = (Bits::new(
            ((s_894_24) >> (s_894_21)).value(),
            u16::try_from(s_894_22).unwrap(),
        ));
        // D s_894_26: cast reint s_894_25 -> u8
        let s_894_26: u8 = (s_894_25.value() as u8);
        // C s_894_27: const #10s : i
        let s_894_27: i128 = 10;
        // C s_894_28: const #1s : i
        let s_894_28: i128 = 1;
        // D s_894_29: read-var u#31514:u32
        let s_894_29: u32 = fn_state.u_31514;
        // D s_894_30: cast zx s_894_29 -> bv
        let s_894_30: Bits = Bits::new(s_894_29 as u128, 32u16);
        // D s_894_31: bit-extract s_894_30 s_894_27 s_894_28
        let s_894_31: Bits = (Bits::new(
            ((s_894_30) >> (s_894_27)).value(),
            u16::try_from(s_894_28).unwrap(),
        ));
        // D s_894_32: cast reint s_894_31 -> u8
        let s_894_32: bool = ((s_894_31.value()) != 0);
        // C s_894_33: const #7s : i
        let s_894_33: i128 = 7;
        // C s_894_34: const #1s : i
        let s_894_34: i128 = 1;
        // D s_894_35: read-var u#31514:u32
        let s_894_35: u32 = fn_state.u_31514;
        // D s_894_36: cast zx s_894_35 -> bv
        let s_894_36: Bits = Bits::new(s_894_35 as u128, 32u16);
        // D s_894_37: bit-extract s_894_36 s_894_33 s_894_34
        let s_894_37: Bits = (Bits::new(
            ((s_894_36) >> (s_894_33)).value(),
            u16::try_from(s_894_34).unwrap(),
        ));
        // D s_894_38: cast reint s_894_37 -> u8
        let s_894_38: bool = ((s_894_37.value()) != 0);
        // C s_894_39: const #5s : i
        let s_894_39: i128 = 5;
        // C s_894_40: const #1s : i
        let s_894_40: i128 = 1;
        // D s_894_41: read-var u#31514:u32
        let s_894_41: u32 = fn_state.u_31514;
        // D s_894_42: cast zx s_894_41 -> bv
        let s_894_42: Bits = Bits::new(s_894_41 as u128, 32u16);
        // D s_894_43: bit-extract s_894_42 s_894_39 s_894_40
        let s_894_43: Bits = (Bits::new(
            ((s_894_42) >> (s_894_39)).value(),
            u16::try_from(s_894_40).unwrap(),
        ));
        // D s_894_44: cast reint s_894_43 -> u8
        let s_894_44: bool = ((s_894_43.value()) != 0);
        // C s_894_45: const #0s : i
        let s_894_45: i128 = 0;
        // C s_894_46: const #4s : i
        let s_894_46: i128 = 4;
        // D s_894_47: read-var u#31514:u32
        let s_894_47: u32 = fn_state.u_31514;
        // D s_894_48: cast zx s_894_47 -> bv
        let s_894_48: Bits = Bits::new(s_894_47 as u128, 32u16);
        // D s_894_49: bit-extract s_894_48 s_894_45 s_894_46
        let s_894_49: Bits = (Bits::new(
            ((s_894_48) >> (s_894_45)).value(),
            u16::try_from(s_894_46).unwrap(),
        ));
        // D s_894_50: cast reint s_894_49 -> u8
        let s_894_50: u8 = (s_894_49.value() as u8);
        // D s_894_51: call decode_aarch32_instrs_VQDMLSL_A2enc_A_txt(s_894_8, s_894_14, s_894_20, s_894_26, s_894_32, s_894_38, s_894_44, s_894_50)
        let s_894_51: () = decode_aarch32_instrs_VQDMLSL_A2enc_A_txt(
            state,
            tracer,
            s_894_8,
            s_894_14,
            s_894_20,
            s_894_26,
            s_894_32,
            s_894_38,
            s_894_44,
            s_894_50,
        );
        // N s_894_52: return
        return;
    }
    fn block_895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_895_0: read-var merge#var.1:struct
        let s_895_0: u32 = fn_state.merge_var._1;
        // D s_895_1: write-var u#31524 <= s_895_0
        fn_state.u_31524 = s_895_0;
        // C s_895_2: const #23s : i
        let s_895_2: i128 = 23;
        // D s_895_3: read-var u#31524:u32
        let s_895_3: u32 = fn_state.u_31524;
        // D s_895_4: cast zx s_895_3 -> bv
        let s_895_4: Bits = Bits::new(s_895_3 as u128, 32u16);
        // C s_895_5: const #1s : i64
        let s_895_5: i64 = 1;
        // C s_895_6: cast zx s_895_5 -> i
        let s_895_6: i128 = (i128::try_from(s_895_5).unwrap());
        // C s_895_7: const #8s : i
        let s_895_7: i128 = 8;
        // C s_895_8: add s_895_7 s_895_6
        let s_895_8: i128 = (s_895_7 + s_895_6);
        // D s_895_9: bit-extract s_895_4 s_895_2 s_895_8
        let s_895_9: Bits = (Bits::new(
            ((s_895_4) >> (s_895_2)).value(),
            u16::try_from(s_895_8).unwrap(),
        ));
        // D s_895_10: cast reint s_895_9 -> u9
        let s_895_10: u16 = (s_895_9.value() as u16);
        // D s_895_11: cast zx s_895_10 -> bv
        let s_895_11: Bits = Bits::new(s_895_10 as u128, 9u16);
        // C s_895_12: const #484u : u9
        let s_895_12: u16 = 484;
        // C s_895_13: cast zx s_895_12 -> bv
        let s_895_13: Bits = Bits::new(s_895_12 as u128, 9u16);
        // D s_895_14: cmp-eq s_895_11 s_895_13
        let s_895_14: bool = ((s_895_11) == (s_895_13));
        // N s_895_15: branch s_895_14 b2295 b896
        if s_895_14 {
            return block_2295(state, tracer, fn_state);
        } else {
            return block_896(state, tracer, fn_state);
        };
    }
    fn block_896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_896_0: const #0u : u8
        let s_896_0: bool = false;
        // D s_896_1: write-var gs#401039 <= s_896_0
        fn_state.gs_401039 = s_896_0;
        // N s_896_2: jump b897
        return block_897(state, tracer, fn_state);
    }
    fn block_897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_897_0: read-var gs#401039:u8
        let s_897_0: bool = fn_state.gs_401039;
        // N s_897_1: branch s_897_0 b2294 b898
        if s_897_0 {
            return block_2294(state, tracer, fn_state);
        } else {
            return block_898(state, tracer, fn_state);
        };
    }
    fn block_898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_898_0: const #0u : u8
        let s_898_0: bool = false;
        // D s_898_1: write-var gs#401041 <= s_898_0
        fn_state.gs_401041 = s_898_0;
        // N s_898_2: jump b899
        return block_899(state, tracer, fn_state);
    }
    fn block_899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_899_0: read-var gs#401041:u8
        let s_899_0: bool = fn_state.gs_401041;
        // D s_899_1: not s_899_0
        let s_899_1: bool = !s_899_0;
        // N s_899_2: branch s_899_1 b901 b900
        if s_899_1 {
            return block_901(state, tracer, fn_state);
        } else {
            return block_900(state, tracer, fn_state);
        };
    }
    fn block_900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_900_0: const #3612s : i
        let s_900_0: i128 = 3612;
        // C s_900_1: const #14696u : u32
        let s_900_1: u32 = 14696;
        // N s_900_2: write-reg s_900_1 <= s_900_0
        let s_900_2: () = {
            state.write_register::<i128>(s_900_1 as isize, s_900_0);
            tracer.write_register(s_900_1 as isize, s_900_0);
        };
        // C s_900_3: const #22s : i
        let s_900_3: i128 = 22;
        // C s_900_4: const #1s : i
        let s_900_4: i128 = 1;
        // D s_900_5: read-var u#31524:u32
        let s_900_5: u32 = fn_state.u_31524;
        // D s_900_6: cast zx s_900_5 -> bv
        let s_900_6: Bits = Bits::new(s_900_5 as u128, 32u16);
        // D s_900_7: bit-extract s_900_6 s_900_3 s_900_4
        let s_900_7: Bits = (Bits::new(
            ((s_900_6) >> (s_900_3)).value(),
            u16::try_from(s_900_4).unwrap(),
        ));
        // D s_900_8: cast reint s_900_7 -> u8
        let s_900_8: bool = ((s_900_7.value()) != 0);
        // C s_900_9: const #20s : i
        let s_900_9: i128 = 20;
        // C s_900_10: const #2s : i
        let s_900_10: i128 = 2;
        // D s_900_11: read-var u#31524:u32
        let s_900_11: u32 = fn_state.u_31524;
        // D s_900_12: cast zx s_900_11 -> bv
        let s_900_12: Bits = Bits::new(s_900_11 as u128, 32u16);
        // D s_900_13: bit-extract s_900_12 s_900_9 s_900_10
        let s_900_13: Bits = (Bits::new(
            ((s_900_12) >> (s_900_9)).value(),
            u16::try_from(s_900_10).unwrap(),
        ));
        // D s_900_14: cast reint s_900_13 -> u8
        let s_900_14: u8 = (s_900_13.value() as u8);
        // C s_900_15: const #16s : i
        let s_900_15: i128 = 16;
        // C s_900_16: const #4s : i
        let s_900_16: i128 = 4;
        // D s_900_17: read-var u#31524:u32
        let s_900_17: u32 = fn_state.u_31524;
        // D s_900_18: cast zx s_900_17 -> bv
        let s_900_18: Bits = Bits::new(s_900_17 as u128, 32u16);
        // D s_900_19: bit-extract s_900_18 s_900_15 s_900_16
        let s_900_19: Bits = (Bits::new(
            ((s_900_18) >> (s_900_15)).value(),
            u16::try_from(s_900_16).unwrap(),
        ));
        // D s_900_20: cast reint s_900_19 -> u8
        let s_900_20: u8 = (s_900_19.value() as u8);
        // C s_900_21: const #12s : i
        let s_900_21: i128 = 12;
        // C s_900_22: const #4s : i
        let s_900_22: i128 = 4;
        // D s_900_23: read-var u#31524:u32
        let s_900_23: u32 = fn_state.u_31524;
        // D s_900_24: cast zx s_900_23 -> bv
        let s_900_24: Bits = Bits::new(s_900_23 as u128, 32u16);
        // D s_900_25: bit-extract s_900_24 s_900_21 s_900_22
        let s_900_25: Bits = (Bits::new(
            ((s_900_24) >> (s_900_21)).value(),
            u16::try_from(s_900_22).unwrap(),
        ));
        // D s_900_26: cast reint s_900_25 -> u8
        let s_900_26: u8 = (s_900_25.value() as u8);
        // C s_900_27: const #7s : i
        let s_900_27: i128 = 7;
        // C s_900_28: const #1s : i
        let s_900_28: i128 = 1;
        // D s_900_29: read-var u#31524:u32
        let s_900_29: u32 = fn_state.u_31524;
        // D s_900_30: cast zx s_900_29 -> bv
        let s_900_30: Bits = Bits::new(s_900_29 as u128, 32u16);
        // D s_900_31: bit-extract s_900_30 s_900_27 s_900_28
        let s_900_31: Bits = (Bits::new(
            ((s_900_30) >> (s_900_27)).value(),
            u16::try_from(s_900_28).unwrap(),
        ));
        // D s_900_32: cast reint s_900_31 -> u8
        let s_900_32: bool = ((s_900_31.value()) != 0);
        // C s_900_33: const #6s : i
        let s_900_33: i128 = 6;
        // C s_900_34: const #1s : i
        let s_900_34: i128 = 1;
        // D s_900_35: read-var u#31524:u32
        let s_900_35: u32 = fn_state.u_31524;
        // D s_900_36: cast zx s_900_35 -> bv
        let s_900_36: Bits = Bits::new(s_900_35 as u128, 32u16);
        // D s_900_37: bit-extract s_900_36 s_900_33 s_900_34
        let s_900_37: Bits = (Bits::new(
            ((s_900_36) >> (s_900_33)).value(),
            u16::try_from(s_900_34).unwrap(),
        ));
        // D s_900_38: cast reint s_900_37 -> u8
        let s_900_38: bool = ((s_900_37.value()) != 0);
        // C s_900_39: const #5s : i
        let s_900_39: i128 = 5;
        // C s_900_40: const #1s : i
        let s_900_40: i128 = 1;
        // D s_900_41: read-var u#31524:u32
        let s_900_41: u32 = fn_state.u_31524;
        // D s_900_42: cast zx s_900_41 -> bv
        let s_900_42: Bits = Bits::new(s_900_41 as u128, 32u16);
        // D s_900_43: bit-extract s_900_42 s_900_39 s_900_40
        let s_900_43: Bits = (Bits::new(
            ((s_900_42) >> (s_900_39)).value(),
            u16::try_from(s_900_40).unwrap(),
        ));
        // D s_900_44: cast reint s_900_43 -> u8
        let s_900_44: bool = ((s_900_43.value()) != 0);
        // C s_900_45: const #0s : i
        let s_900_45: i128 = 0;
        // C s_900_46: const #4s : i
        let s_900_46: i128 = 4;
        // D s_900_47: read-var u#31524:u32
        let s_900_47: u32 = fn_state.u_31524;
        // D s_900_48: cast zx s_900_47 -> bv
        let s_900_48: Bits = Bits::new(s_900_47 as u128, 32u16);
        // D s_900_49: bit-extract s_900_48 s_900_45 s_900_46
        let s_900_49: Bits = (Bits::new(
            ((s_900_48) >> (s_900_45)).value(),
            u16::try_from(s_900_46).unwrap(),
        ));
        // D s_900_50: cast reint s_900_49 -> u8
        let s_900_50: u8 = (s_900_49.value() as u8);
        // D s_900_51: call decode_aarch32_instrs_VQDMULH_A1enc_A_txt(s_900_8, s_900_14, s_900_20, s_900_26, s_900_32, s_900_38, s_900_44, s_900_50)
        let s_900_51: () = decode_aarch32_instrs_VQDMULH_A1enc_A_txt(
            state,
            tracer,
            s_900_8,
            s_900_14,
            s_900_20,
            s_900_26,
            s_900_32,
            s_900_38,
            s_900_44,
            s_900_50,
        );
        // N s_900_52: return
        return;
    }
    fn block_901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_901_0: read-var merge#var.1:struct
        let s_901_0: u32 = fn_state.merge_var._1;
        // D s_901_1: write-var u#31534 <= s_901_0
        fn_state.u_31534 = s_901_0;
        // C s_901_2: const #25s : i
        let s_901_2: i128 = 25;
        // D s_901_3: read-var u#31534:u32
        let s_901_3: u32 = fn_state.u_31534;
        // D s_901_4: cast zx s_901_3 -> bv
        let s_901_4: Bits = Bits::new(s_901_3 as u128, 32u16);
        // C s_901_5: const #1s : i64
        let s_901_5: i64 = 1;
        // C s_901_6: cast zx s_901_5 -> i
        let s_901_6: i128 = (i128::try_from(s_901_5).unwrap());
        // C s_901_7: const #6s : i
        let s_901_7: i128 = 6;
        // C s_901_8: add s_901_7 s_901_6
        let s_901_8: i128 = (s_901_7 + s_901_6);
        // D s_901_9: bit-extract s_901_4 s_901_2 s_901_8
        let s_901_9: Bits = (Bits::new(
            ((s_901_4) >> (s_901_2)).value(),
            u16::try_from(s_901_8).unwrap(),
        ));
        // D s_901_10: cast reint s_901_9 -> u8
        let s_901_10: u8 = (s_901_9.value() as u8);
        // D s_901_11: cast zx s_901_10 -> bv
        let s_901_11: Bits = Bits::new(s_901_10 as u128, 7u16);
        // C s_901_12: const #121u : u8
        let s_901_12: u8 = 121;
        // C s_901_13: cast zx s_901_12 -> bv
        let s_901_13: Bits = Bits::new(s_901_12 as u128, 7u16);
        // D s_901_14: cmp-eq s_901_11 s_901_13
        let s_901_14: bool = ((s_901_11) == (s_901_13));
        // N s_901_15: branch s_901_14 b2284 b902
        if s_901_14 {
            return block_2284(state, tracer, fn_state);
        } else {
            return block_902(state, tracer, fn_state);
        };
    }
    fn block_902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_902_0: const #0u : u8
        let s_902_0: bool = false;
        // D s_902_1: write-var gs#401074 <= s_902_0
        fn_state.gs_401074 = s_902_0;
        // N s_902_2: jump b903
        return block_903(state, tracer, fn_state);
    }
    fn block_903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_903_0: read-var gs#401074:u8
        let s_903_0: bool = fn_state.gs_401074;
        // N s_903_1: branch s_903_0 b2283 b904
        if s_903_0 {
            return block_2283(state, tracer, fn_state);
        } else {
            return block_904(state, tracer, fn_state);
        };
    }
    fn block_904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_904_0: const #0u : u8
        let s_904_0: bool = false;
        // D s_904_1: write-var gs#401076 <= s_904_0
        fn_state.gs_401076 = s_904_0;
        // N s_904_2: jump b905
        return block_905(state, tracer, fn_state);
    }
    fn block_905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_905_0: read-var gs#401076:u8
        let s_905_0: bool = fn_state.gs_401076;
        // D s_905_1: not s_905_0
        let s_905_1: bool = !s_905_0;
        // N s_905_2: branch s_905_1 b907 b906
        if s_905_1 {
            return block_907(state, tracer, fn_state);
        } else {
            return block_906(state, tracer, fn_state);
        };
    }
    fn block_906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_906_0: const #3613s : i
        let s_906_0: i128 = 3613;
        // C s_906_1: const #14696u : u32
        let s_906_1: u32 = 14696;
        // N s_906_2: write-reg s_906_1 <= s_906_0
        let s_906_2: () = {
            state.write_register::<i128>(s_906_1 as isize, s_906_0);
            tracer.write_register(s_906_1 as isize, s_906_0);
        };
        // C s_906_3: const #24s : i
        let s_906_3: i128 = 24;
        // C s_906_4: const #1s : i
        let s_906_4: i128 = 1;
        // D s_906_5: read-var u#31534:u32
        let s_906_5: u32 = fn_state.u_31534;
        // D s_906_6: cast zx s_906_5 -> bv
        let s_906_6: Bits = Bits::new(s_906_5 as u128, 32u16);
        // D s_906_7: bit-extract s_906_6 s_906_3 s_906_4
        let s_906_7: Bits = (Bits::new(
            ((s_906_6) >> (s_906_3)).value(),
            u16::try_from(s_906_4).unwrap(),
        ));
        // D s_906_8: cast reint s_906_7 -> u8
        let s_906_8: bool = ((s_906_7.value()) != 0);
        // C s_906_9: const #22s : i
        let s_906_9: i128 = 22;
        // C s_906_10: const #1s : i
        let s_906_10: i128 = 1;
        // D s_906_11: read-var u#31534:u32
        let s_906_11: u32 = fn_state.u_31534;
        // D s_906_12: cast zx s_906_11 -> bv
        let s_906_12: Bits = Bits::new(s_906_11 as u128, 32u16);
        // D s_906_13: bit-extract s_906_12 s_906_9 s_906_10
        let s_906_13: Bits = (Bits::new(
            ((s_906_12) >> (s_906_9)).value(),
            u16::try_from(s_906_10).unwrap(),
        ));
        // D s_906_14: cast reint s_906_13 -> u8
        let s_906_14: bool = ((s_906_13.value()) != 0);
        // C s_906_15: const #20s : i
        let s_906_15: i128 = 20;
        // C s_906_16: const #2s : i
        let s_906_16: i128 = 2;
        // D s_906_17: read-var u#31534:u32
        let s_906_17: u32 = fn_state.u_31534;
        // D s_906_18: cast zx s_906_17 -> bv
        let s_906_18: Bits = Bits::new(s_906_17 as u128, 32u16);
        // D s_906_19: bit-extract s_906_18 s_906_15 s_906_16
        let s_906_19: Bits = (Bits::new(
            ((s_906_18) >> (s_906_15)).value(),
            u16::try_from(s_906_16).unwrap(),
        ));
        // D s_906_20: cast reint s_906_19 -> u8
        let s_906_20: u8 = (s_906_19.value() as u8);
        // C s_906_21: const #16s : i
        let s_906_21: i128 = 16;
        // C s_906_22: const #4s : i
        let s_906_22: i128 = 4;
        // D s_906_23: read-var u#31534:u32
        let s_906_23: u32 = fn_state.u_31534;
        // D s_906_24: cast zx s_906_23 -> bv
        let s_906_24: Bits = Bits::new(s_906_23 as u128, 32u16);
        // D s_906_25: bit-extract s_906_24 s_906_21 s_906_22
        let s_906_25: Bits = (Bits::new(
            ((s_906_24) >> (s_906_21)).value(),
            u16::try_from(s_906_22).unwrap(),
        ));
        // D s_906_26: cast reint s_906_25 -> u8
        let s_906_26: u8 = (s_906_25.value() as u8);
        // C s_906_27: const #12s : i
        let s_906_27: i128 = 12;
        // C s_906_28: const #4s : i
        let s_906_28: i128 = 4;
        // D s_906_29: read-var u#31534:u32
        let s_906_29: u32 = fn_state.u_31534;
        // D s_906_30: cast zx s_906_29 -> bv
        let s_906_30: Bits = Bits::new(s_906_29 as u128, 32u16);
        // D s_906_31: bit-extract s_906_30 s_906_27 s_906_28
        let s_906_31: Bits = (Bits::new(
            ((s_906_30) >> (s_906_27)).value(),
            u16::try_from(s_906_28).unwrap(),
        ));
        // D s_906_32: cast reint s_906_31 -> u8
        let s_906_32: u8 = (s_906_31.value() as u8);
        // C s_906_33: const #7s : i
        let s_906_33: i128 = 7;
        // C s_906_34: const #1s : i
        let s_906_34: i128 = 1;
        // D s_906_35: read-var u#31534:u32
        let s_906_35: u32 = fn_state.u_31534;
        // D s_906_36: cast zx s_906_35 -> bv
        let s_906_36: Bits = Bits::new(s_906_35 as u128, 32u16);
        // D s_906_37: bit-extract s_906_36 s_906_33 s_906_34
        let s_906_37: Bits = (Bits::new(
            ((s_906_36) >> (s_906_33)).value(),
            u16::try_from(s_906_34).unwrap(),
        ));
        // D s_906_38: cast reint s_906_37 -> u8
        let s_906_38: bool = ((s_906_37.value()) != 0);
        // C s_906_39: const #5s : i
        let s_906_39: i128 = 5;
        // C s_906_40: const #1s : i
        let s_906_40: i128 = 1;
        // D s_906_41: read-var u#31534:u32
        let s_906_41: u32 = fn_state.u_31534;
        // D s_906_42: cast zx s_906_41 -> bv
        let s_906_42: Bits = Bits::new(s_906_41 as u128, 32u16);
        // D s_906_43: bit-extract s_906_42 s_906_39 s_906_40
        let s_906_43: Bits = (Bits::new(
            ((s_906_42) >> (s_906_39)).value(),
            u16::try_from(s_906_40).unwrap(),
        ));
        // D s_906_44: cast reint s_906_43 -> u8
        let s_906_44: bool = ((s_906_43.value()) != 0);
        // C s_906_45: const #0s : i
        let s_906_45: i128 = 0;
        // C s_906_46: const #4s : i
        let s_906_46: i128 = 4;
        // D s_906_47: read-var u#31534:u32
        let s_906_47: u32 = fn_state.u_31534;
        // D s_906_48: cast zx s_906_47 -> bv
        let s_906_48: Bits = Bits::new(s_906_47 as u128, 32u16);
        // D s_906_49: bit-extract s_906_48 s_906_45 s_906_46
        let s_906_49: Bits = (Bits::new(
            ((s_906_48) >> (s_906_45)).value(),
            u16::try_from(s_906_46).unwrap(),
        ));
        // D s_906_50: cast reint s_906_49 -> u8
        let s_906_50: u8 = (s_906_49.value() as u8);
        // D s_906_51: call decode_aarch32_instrs_VQDMULH_A2enc_A_txt(s_906_8, s_906_14, s_906_20, s_906_26, s_906_32, s_906_38, s_906_44, s_906_50)
        let s_906_51: () = decode_aarch32_instrs_VQDMULH_A2enc_A_txt(
            state,
            tracer,
            s_906_8,
            s_906_14,
            s_906_20,
            s_906_26,
            s_906_32,
            s_906_38,
            s_906_44,
            s_906_50,
        );
        // N s_906_52: return
        return;
    }
    fn block_907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_907_0: read-var merge#var.1:struct
        let s_907_0: u32 = fn_state.merge_var._1;
        // D s_907_1: write-var u#31544 <= s_907_0
        fn_state.u_31544 = s_907_0;
        // C s_907_2: const #23s : i
        let s_907_2: i128 = 23;
        // D s_907_3: read-var u#31544:u32
        let s_907_3: u32 = fn_state.u_31544;
        // D s_907_4: cast zx s_907_3 -> bv
        let s_907_4: Bits = Bits::new(s_907_3 as u128, 32u16);
        // C s_907_5: const #1s : i64
        let s_907_5: i64 = 1;
        // C s_907_6: cast zx s_907_5 -> i
        let s_907_6: i128 = (i128::try_from(s_907_5).unwrap());
        // C s_907_7: const #8s : i
        let s_907_7: i128 = 8;
        // C s_907_8: add s_907_7 s_907_6
        let s_907_8: i128 = (s_907_7 + s_907_6);
        // D s_907_9: bit-extract s_907_4 s_907_2 s_907_8
        let s_907_9: Bits = (Bits::new(
            ((s_907_4) >> (s_907_2)).value(),
            u16::try_from(s_907_8).unwrap(),
        ));
        // D s_907_10: cast reint s_907_9 -> u9
        let s_907_10: u16 = (s_907_9.value() as u16);
        // D s_907_11: cast zx s_907_10 -> bv
        let s_907_11: Bits = Bits::new(s_907_10 as u128, 9u16);
        // C s_907_12: const #485u : u9
        let s_907_12: u16 = 485;
        // C s_907_13: cast zx s_907_12 -> bv
        let s_907_13: Bits = Bits::new(s_907_12 as u128, 9u16);
        // D s_907_14: cmp-eq s_907_11 s_907_13
        let s_907_14: bool = ((s_907_11) == (s_907_13));
        // N s_907_15: branch s_907_14 b2276 b908
        if s_907_14 {
            return block_2276(state, tracer, fn_state);
        } else {
            return block_908(state, tracer, fn_state);
        };
    }
    fn block_908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_908_0: const #0u : u8
        let s_908_0: bool = false;
        // D s_908_1: write-var gs#401106 <= s_908_0
        fn_state.gs_401106 = s_908_0;
        // N s_908_2: jump b909
        return block_909(state, tracer, fn_state);
    }
    fn block_909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_909_0: read-var gs#401106:u8
        let s_909_0: bool = fn_state.gs_401106;
        // N s_909_1: branch s_909_0 b2275 b910
        if s_909_0 {
            return block_2275(state, tracer, fn_state);
        } else {
            return block_910(state, tracer, fn_state);
        };
    }
    fn block_910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_910_0: const #0u : u8
        let s_910_0: bool = false;
        // D s_910_1: write-var gs#401108 <= s_910_0
        fn_state.gs_401108 = s_910_0;
        // N s_910_2: jump b911
        return block_911(state, tracer, fn_state);
    }
    fn block_911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_911_0: read-var gs#401108:u8
        let s_911_0: bool = fn_state.gs_401108;
        // D s_911_1: not s_911_0
        let s_911_1: bool = !s_911_0;
        // N s_911_2: branch s_911_1 b913 b912
        if s_911_1 {
            return block_913(state, tracer, fn_state);
        } else {
            return block_912(state, tracer, fn_state);
        };
    }
    fn block_912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_912_0: const #3616s : i
        let s_912_0: i128 = 3616;
        // C s_912_1: const #14696u : u32
        let s_912_1: u32 = 14696;
        // N s_912_2: write-reg s_912_1 <= s_912_0
        let s_912_2: () = {
            state.write_register::<i128>(s_912_1 as isize, s_912_0);
            tracer.write_register(s_912_1 as isize, s_912_0);
        };
        // C s_912_3: const #22s : i
        let s_912_3: i128 = 22;
        // C s_912_4: const #1s : i
        let s_912_4: i128 = 1;
        // D s_912_5: read-var u#31544:u32
        let s_912_5: u32 = fn_state.u_31544;
        // D s_912_6: cast zx s_912_5 -> bv
        let s_912_6: Bits = Bits::new(s_912_5 as u128, 32u16);
        // D s_912_7: bit-extract s_912_6 s_912_3 s_912_4
        let s_912_7: Bits = (Bits::new(
            ((s_912_6) >> (s_912_3)).value(),
            u16::try_from(s_912_4).unwrap(),
        ));
        // D s_912_8: cast reint s_912_7 -> u8
        let s_912_8: bool = ((s_912_7.value()) != 0);
        // C s_912_9: const #20s : i
        let s_912_9: i128 = 20;
        // C s_912_10: const #2s : i
        let s_912_10: i128 = 2;
        // D s_912_11: read-var u#31544:u32
        let s_912_11: u32 = fn_state.u_31544;
        // D s_912_12: cast zx s_912_11 -> bv
        let s_912_12: Bits = Bits::new(s_912_11 as u128, 32u16);
        // D s_912_13: bit-extract s_912_12 s_912_9 s_912_10
        let s_912_13: Bits = (Bits::new(
            ((s_912_12) >> (s_912_9)).value(),
            u16::try_from(s_912_10).unwrap(),
        ));
        // D s_912_14: cast reint s_912_13 -> u8
        let s_912_14: u8 = (s_912_13.value() as u8);
        // C s_912_15: const #16s : i
        let s_912_15: i128 = 16;
        // C s_912_16: const #4s : i
        let s_912_16: i128 = 4;
        // D s_912_17: read-var u#31544:u32
        let s_912_17: u32 = fn_state.u_31544;
        // D s_912_18: cast zx s_912_17 -> bv
        let s_912_18: Bits = Bits::new(s_912_17 as u128, 32u16);
        // D s_912_19: bit-extract s_912_18 s_912_15 s_912_16
        let s_912_19: Bits = (Bits::new(
            ((s_912_18) >> (s_912_15)).value(),
            u16::try_from(s_912_16).unwrap(),
        ));
        // D s_912_20: cast reint s_912_19 -> u8
        let s_912_20: u8 = (s_912_19.value() as u8);
        // C s_912_21: const #12s : i
        let s_912_21: i128 = 12;
        // C s_912_22: const #4s : i
        let s_912_22: i128 = 4;
        // D s_912_23: read-var u#31544:u32
        let s_912_23: u32 = fn_state.u_31544;
        // D s_912_24: cast zx s_912_23 -> bv
        let s_912_24: Bits = Bits::new(s_912_23 as u128, 32u16);
        // D s_912_25: bit-extract s_912_24 s_912_21 s_912_22
        let s_912_25: Bits = (Bits::new(
            ((s_912_24) >> (s_912_21)).value(),
            u16::try_from(s_912_22).unwrap(),
        ));
        // D s_912_26: cast reint s_912_25 -> u8
        let s_912_26: u8 = (s_912_25.value() as u8);
        // C s_912_27: const #7s : i
        let s_912_27: i128 = 7;
        // C s_912_28: const #1s : i
        let s_912_28: i128 = 1;
        // D s_912_29: read-var u#31544:u32
        let s_912_29: u32 = fn_state.u_31544;
        // D s_912_30: cast zx s_912_29 -> bv
        let s_912_30: Bits = Bits::new(s_912_29 as u128, 32u16);
        // D s_912_31: bit-extract s_912_30 s_912_27 s_912_28
        let s_912_31: Bits = (Bits::new(
            ((s_912_30) >> (s_912_27)).value(),
            u16::try_from(s_912_28).unwrap(),
        ));
        // D s_912_32: cast reint s_912_31 -> u8
        let s_912_32: bool = ((s_912_31.value()) != 0);
        // C s_912_33: const #5s : i
        let s_912_33: i128 = 5;
        // C s_912_34: const #1s : i
        let s_912_34: i128 = 1;
        // D s_912_35: read-var u#31544:u32
        let s_912_35: u32 = fn_state.u_31544;
        // D s_912_36: cast zx s_912_35 -> bv
        let s_912_36: Bits = Bits::new(s_912_35 as u128, 32u16);
        // D s_912_37: bit-extract s_912_36 s_912_33 s_912_34
        let s_912_37: Bits = (Bits::new(
            ((s_912_36) >> (s_912_33)).value(),
            u16::try_from(s_912_34).unwrap(),
        ));
        // D s_912_38: cast reint s_912_37 -> u8
        let s_912_38: bool = ((s_912_37.value()) != 0);
        // C s_912_39: const #0s : i
        let s_912_39: i128 = 0;
        // C s_912_40: const #4s : i
        let s_912_40: i128 = 4;
        // D s_912_41: read-var u#31544:u32
        let s_912_41: u32 = fn_state.u_31544;
        // D s_912_42: cast zx s_912_41 -> bv
        let s_912_42: Bits = Bits::new(s_912_41 as u128, 32u16);
        // D s_912_43: bit-extract s_912_42 s_912_39 s_912_40
        let s_912_43: Bits = (Bits::new(
            ((s_912_42) >> (s_912_39)).value(),
            u16::try_from(s_912_40).unwrap(),
        ));
        // D s_912_44: cast reint s_912_43 -> u8
        let s_912_44: u8 = (s_912_43.value() as u8);
        // D s_912_45: call decode_aarch32_instrs_VQDMULL_A1enc_A_txt(s_912_8, s_912_14, s_912_20, s_912_26, s_912_32, s_912_38, s_912_44)
        let s_912_45: () = decode_aarch32_instrs_VQDMULL_A1enc_A_txt(
            state,
            tracer,
            s_912_8,
            s_912_14,
            s_912_20,
            s_912_26,
            s_912_32,
            s_912_38,
            s_912_44,
        );
        // N s_912_46: return
        return;
    }
    fn block_913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_913_0: read-var merge#var.1:struct
        let s_913_0: u32 = fn_state.merge_var._1;
        // D s_913_1: write-var u#31553 <= s_913_0
        fn_state.u_31553 = s_913_0;
        // C s_913_2: const #23s : i
        let s_913_2: i128 = 23;
        // D s_913_3: read-var u#31553:u32
        let s_913_3: u32 = fn_state.u_31553;
        // D s_913_4: cast zx s_913_3 -> bv
        let s_913_4: Bits = Bits::new(s_913_3 as u128, 32u16);
        // C s_913_5: const #1s : i64
        let s_913_5: i64 = 1;
        // C s_913_6: cast zx s_913_5 -> i
        let s_913_6: i128 = (i128::try_from(s_913_5).unwrap());
        // C s_913_7: const #8s : i
        let s_913_7: i128 = 8;
        // C s_913_8: add s_913_7 s_913_6
        let s_913_8: i128 = (s_913_7 + s_913_6);
        // D s_913_9: bit-extract s_913_4 s_913_2 s_913_8
        let s_913_9: Bits = (Bits::new(
            ((s_913_4) >> (s_913_2)).value(),
            u16::try_from(s_913_8).unwrap(),
        ));
        // D s_913_10: cast reint s_913_9 -> u9
        let s_913_10: u16 = (s_913_9.value() as u16);
        // D s_913_11: cast zx s_913_10 -> bv
        let s_913_11: Bits = Bits::new(s_913_10 as u128, 9u16);
        // C s_913_12: const #485u : u9
        let s_913_12: u16 = 485;
        // C s_913_13: cast zx s_913_12 -> bv
        let s_913_13: Bits = Bits::new(s_913_12 as u128, 9u16);
        // D s_913_14: cmp-eq s_913_11 s_913_13
        let s_913_14: bool = ((s_913_11) == (s_913_13));
        // N s_913_15: branch s_913_14 b2268 b914
        if s_913_14 {
            return block_2268(state, tracer, fn_state);
        } else {
            return block_914(state, tracer, fn_state);
        };
    }
    fn block_914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_914_0: const #0u : u8
        let s_914_0: bool = false;
        // D s_914_1: write-var gs#401136 <= s_914_0
        fn_state.gs_401136 = s_914_0;
        // N s_914_2: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_915_0: read-var gs#401136:u8
        let s_915_0: bool = fn_state.gs_401136;
        // N s_915_1: branch s_915_0 b2267 b916
        if s_915_0 {
            return block_2267(state, tracer, fn_state);
        } else {
            return block_916(state, tracer, fn_state);
        };
    }
    fn block_916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_916_0: const #0u : u8
        let s_916_0: bool = false;
        // D s_916_1: write-var gs#401138 <= s_916_0
        fn_state.gs_401138 = s_916_0;
        // N s_916_2: jump b917
        return block_917(state, tracer, fn_state);
    }
    fn block_917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_917_0: read-var gs#401138:u8
        let s_917_0: bool = fn_state.gs_401138;
        // D s_917_1: not s_917_0
        let s_917_1: bool = !s_917_0;
        // N s_917_2: branch s_917_1 b919 b918
        if s_917_1 {
            return block_919(state, tracer, fn_state);
        } else {
            return block_918(state, tracer, fn_state);
        };
    }
    fn block_918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_918_0: const #3617s : i
        let s_918_0: i128 = 3617;
        // C s_918_1: const #14696u : u32
        let s_918_1: u32 = 14696;
        // N s_918_2: write-reg s_918_1 <= s_918_0
        let s_918_2: () = {
            state.write_register::<i128>(s_918_1 as isize, s_918_0);
            tracer.write_register(s_918_1 as isize, s_918_0);
        };
        // C s_918_3: const #22s : i
        let s_918_3: i128 = 22;
        // C s_918_4: const #1s : i
        let s_918_4: i128 = 1;
        // D s_918_5: read-var u#31553:u32
        let s_918_5: u32 = fn_state.u_31553;
        // D s_918_6: cast zx s_918_5 -> bv
        let s_918_6: Bits = Bits::new(s_918_5 as u128, 32u16);
        // D s_918_7: bit-extract s_918_6 s_918_3 s_918_4
        let s_918_7: Bits = (Bits::new(
            ((s_918_6) >> (s_918_3)).value(),
            u16::try_from(s_918_4).unwrap(),
        ));
        // D s_918_8: cast reint s_918_7 -> u8
        let s_918_8: bool = ((s_918_7.value()) != 0);
        // C s_918_9: const #20s : i
        let s_918_9: i128 = 20;
        // C s_918_10: const #2s : i
        let s_918_10: i128 = 2;
        // D s_918_11: read-var u#31553:u32
        let s_918_11: u32 = fn_state.u_31553;
        // D s_918_12: cast zx s_918_11 -> bv
        let s_918_12: Bits = Bits::new(s_918_11 as u128, 32u16);
        // D s_918_13: bit-extract s_918_12 s_918_9 s_918_10
        let s_918_13: Bits = (Bits::new(
            ((s_918_12) >> (s_918_9)).value(),
            u16::try_from(s_918_10).unwrap(),
        ));
        // D s_918_14: cast reint s_918_13 -> u8
        let s_918_14: u8 = (s_918_13.value() as u8);
        // C s_918_15: const #16s : i
        let s_918_15: i128 = 16;
        // C s_918_16: const #4s : i
        let s_918_16: i128 = 4;
        // D s_918_17: read-var u#31553:u32
        let s_918_17: u32 = fn_state.u_31553;
        // D s_918_18: cast zx s_918_17 -> bv
        let s_918_18: Bits = Bits::new(s_918_17 as u128, 32u16);
        // D s_918_19: bit-extract s_918_18 s_918_15 s_918_16
        let s_918_19: Bits = (Bits::new(
            ((s_918_18) >> (s_918_15)).value(),
            u16::try_from(s_918_16).unwrap(),
        ));
        // D s_918_20: cast reint s_918_19 -> u8
        let s_918_20: u8 = (s_918_19.value() as u8);
        // C s_918_21: const #12s : i
        let s_918_21: i128 = 12;
        // C s_918_22: const #4s : i
        let s_918_22: i128 = 4;
        // D s_918_23: read-var u#31553:u32
        let s_918_23: u32 = fn_state.u_31553;
        // D s_918_24: cast zx s_918_23 -> bv
        let s_918_24: Bits = Bits::new(s_918_23 as u128, 32u16);
        // D s_918_25: bit-extract s_918_24 s_918_21 s_918_22
        let s_918_25: Bits = (Bits::new(
            ((s_918_24) >> (s_918_21)).value(),
            u16::try_from(s_918_22).unwrap(),
        ));
        // D s_918_26: cast reint s_918_25 -> u8
        let s_918_26: u8 = (s_918_25.value() as u8);
        // C s_918_27: const #7s : i
        let s_918_27: i128 = 7;
        // C s_918_28: const #1s : i
        let s_918_28: i128 = 1;
        // D s_918_29: read-var u#31553:u32
        let s_918_29: u32 = fn_state.u_31553;
        // D s_918_30: cast zx s_918_29 -> bv
        let s_918_30: Bits = Bits::new(s_918_29 as u128, 32u16);
        // D s_918_31: bit-extract s_918_30 s_918_27 s_918_28
        let s_918_31: Bits = (Bits::new(
            ((s_918_30) >> (s_918_27)).value(),
            u16::try_from(s_918_28).unwrap(),
        ));
        // D s_918_32: cast reint s_918_31 -> u8
        let s_918_32: bool = ((s_918_31.value()) != 0);
        // C s_918_33: const #5s : i
        let s_918_33: i128 = 5;
        // C s_918_34: const #1s : i
        let s_918_34: i128 = 1;
        // D s_918_35: read-var u#31553:u32
        let s_918_35: u32 = fn_state.u_31553;
        // D s_918_36: cast zx s_918_35 -> bv
        let s_918_36: Bits = Bits::new(s_918_35 as u128, 32u16);
        // D s_918_37: bit-extract s_918_36 s_918_33 s_918_34
        let s_918_37: Bits = (Bits::new(
            ((s_918_36) >> (s_918_33)).value(),
            u16::try_from(s_918_34).unwrap(),
        ));
        // D s_918_38: cast reint s_918_37 -> u8
        let s_918_38: bool = ((s_918_37.value()) != 0);
        // C s_918_39: const #0s : i
        let s_918_39: i128 = 0;
        // C s_918_40: const #4s : i
        let s_918_40: i128 = 4;
        // D s_918_41: read-var u#31553:u32
        let s_918_41: u32 = fn_state.u_31553;
        // D s_918_42: cast zx s_918_41 -> bv
        let s_918_42: Bits = Bits::new(s_918_41 as u128, 32u16);
        // D s_918_43: bit-extract s_918_42 s_918_39 s_918_40
        let s_918_43: Bits = (Bits::new(
            ((s_918_42) >> (s_918_39)).value(),
            u16::try_from(s_918_40).unwrap(),
        ));
        // D s_918_44: cast reint s_918_43 -> u8
        let s_918_44: u8 = (s_918_43.value() as u8);
        // D s_918_45: call decode_aarch32_instrs_VQDMULL_A2enc_A_txt(s_918_8, s_918_14, s_918_20, s_918_26, s_918_32, s_918_38, s_918_44)
        let s_918_45: () = decode_aarch32_instrs_VQDMULL_A2enc_A_txt(
            state,
            tracer,
            s_918_8,
            s_918_14,
            s_918_20,
            s_918_26,
            s_918_32,
            s_918_38,
            s_918_44,
        );
        // N s_918_46: return
        return;
    }
    fn block_919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_919_0: read-var merge#var.1:struct
        let s_919_0: u32 = fn_state.merge_var._1;
        // D s_919_1: write-var u#31562 <= s_919_0
        fn_state.u_31562 = s_919_0;
        // C s_919_2: const #23s : i
        let s_919_2: i128 = 23;
        // D s_919_3: read-var u#31562:u32
        let s_919_3: u32 = fn_state.u_31562;
        // D s_919_4: cast zx s_919_3 -> bv
        let s_919_4: Bits = Bits::new(s_919_3 as u128, 32u16);
        // C s_919_5: const #1s : i64
        let s_919_5: i64 = 1;
        // C s_919_6: cast zx s_919_5 -> i
        let s_919_6: i128 = (i128::try_from(s_919_5).unwrap());
        // C s_919_7: const #8s : i
        let s_919_7: i128 = 8;
        // C s_919_8: add s_919_7 s_919_6
        let s_919_8: i128 = (s_919_7 + s_919_6);
        // D s_919_9: bit-extract s_919_4 s_919_2 s_919_8
        let s_919_9: Bits = (Bits::new(
            ((s_919_4) >> (s_919_2)).value(),
            u16::try_from(s_919_8).unwrap(),
        ));
        // D s_919_10: cast reint s_919_9 -> u9
        let s_919_10: u16 = (s_919_9.value() as u16);
        // D s_919_11: cast zx s_919_10 -> bv
        let s_919_11: Bits = Bits::new(s_919_10 as u128, 9u16);
        // C s_919_12: const #487u : u9
        let s_919_12: u16 = 487;
        // C s_919_13: cast zx s_919_12 -> bv
        let s_919_13: Bits = Bits::new(s_919_12 as u128, 9u16);
        // D s_919_14: cmp-eq s_919_11 s_919_13
        let s_919_14: bool = ((s_919_11) == (s_919_13));
        // N s_919_15: branch s_919_14 b2257 b920
        if s_919_14 {
            return block_2257(state, tracer, fn_state);
        } else {
            return block_920(state, tracer, fn_state);
        };
    }
    fn block_920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_920_0: const #0u : u8
        let s_920_0: bool = false;
        // D s_920_1: write-var gs#401169 <= s_920_0
        fn_state.gs_401169 = s_920_0;
        // N s_920_2: jump b921
        return block_921(state, tracer, fn_state);
    }
    fn block_921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_921_0: read-var gs#401169:u8
        let s_921_0: bool = fn_state.gs_401169;
        // N s_921_1: branch s_921_0 b2256 b922
        if s_921_0 {
            return block_2256(state, tracer, fn_state);
        } else {
            return block_922(state, tracer, fn_state);
        };
    }
    fn block_922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_922_0: const #0u : u8
        let s_922_0: bool = false;
        // D s_922_1: write-var gs#401171 <= s_922_0
        fn_state.gs_401171 = s_922_0;
        // N s_922_2: jump b923
        return block_923(state, tracer, fn_state);
    }
    fn block_923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_923_0: read-var gs#401171:u8
        let s_923_0: bool = fn_state.gs_401171;
        // D s_923_1: not s_923_0
        let s_923_1: bool = !s_923_0;
        // N s_923_2: branch s_923_1 b925 b924
        if s_923_1 {
            return block_925(state, tracer, fn_state);
        } else {
            return block_924(state, tracer, fn_state);
        };
    }
    fn block_924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_924_0: const #3620s : i
        let s_924_0: i128 = 3620;
        // C s_924_1: const #14696u : u32
        let s_924_1: u32 = 14696;
        // N s_924_2: write-reg s_924_1 <= s_924_0
        let s_924_2: () = {
            state.write_register::<i128>(s_924_1 as isize, s_924_0);
            tracer.write_register(s_924_1 as isize, s_924_0);
        };
        // C s_924_3: const #22s : i
        let s_924_3: i128 = 22;
        // C s_924_4: const #1s : i
        let s_924_4: i128 = 1;
        // D s_924_5: read-var u#31562:u32
        let s_924_5: u32 = fn_state.u_31562;
        // D s_924_6: cast zx s_924_5 -> bv
        let s_924_6: Bits = Bits::new(s_924_5 as u128, 32u16);
        // D s_924_7: bit-extract s_924_6 s_924_3 s_924_4
        let s_924_7: Bits = (Bits::new(
            ((s_924_6) >> (s_924_3)).value(),
            u16::try_from(s_924_4).unwrap(),
        ));
        // D s_924_8: cast reint s_924_7 -> u8
        let s_924_8: bool = ((s_924_7.value()) != 0);
        // C s_924_9: const #18s : i
        let s_924_9: i128 = 18;
        // C s_924_10: const #2s : i
        let s_924_10: i128 = 2;
        // D s_924_11: read-var u#31562:u32
        let s_924_11: u32 = fn_state.u_31562;
        // D s_924_12: cast zx s_924_11 -> bv
        let s_924_12: Bits = Bits::new(s_924_11 as u128, 32u16);
        // D s_924_13: bit-extract s_924_12 s_924_9 s_924_10
        let s_924_13: Bits = (Bits::new(
            ((s_924_12) >> (s_924_9)).value(),
            u16::try_from(s_924_10).unwrap(),
        ));
        // D s_924_14: cast reint s_924_13 -> u8
        let s_924_14: u8 = (s_924_13.value() as u8);
        // C s_924_15: const #12s : i
        let s_924_15: i128 = 12;
        // C s_924_16: const #4s : i
        let s_924_16: i128 = 4;
        // D s_924_17: read-var u#31562:u32
        let s_924_17: u32 = fn_state.u_31562;
        // D s_924_18: cast zx s_924_17 -> bv
        let s_924_18: Bits = Bits::new(s_924_17 as u128, 32u16);
        // D s_924_19: bit-extract s_924_18 s_924_15 s_924_16
        let s_924_19: Bits = (Bits::new(
            ((s_924_18) >> (s_924_15)).value(),
            u16::try_from(s_924_16).unwrap(),
        ));
        // D s_924_20: cast reint s_924_19 -> u8
        let s_924_20: u8 = (s_924_19.value() as u8);
        // C s_924_21: const #6s : i
        let s_924_21: i128 = 6;
        // C s_924_22: const #2s : i
        let s_924_22: i128 = 2;
        // D s_924_23: read-var u#31562:u32
        let s_924_23: u32 = fn_state.u_31562;
        // D s_924_24: cast zx s_924_23 -> bv
        let s_924_24: Bits = Bits::new(s_924_23 as u128, 32u16);
        // D s_924_25: bit-extract s_924_24 s_924_21 s_924_22
        let s_924_25: Bits = (Bits::new(
            ((s_924_24) >> (s_924_21)).value(),
            u16::try_from(s_924_22).unwrap(),
        ));
        // D s_924_26: cast reint s_924_25 -> u8
        let s_924_26: u8 = (s_924_25.value() as u8);
        // C s_924_27: const #5s : i
        let s_924_27: i128 = 5;
        // C s_924_28: const #1s : i
        let s_924_28: i128 = 1;
        // D s_924_29: read-var u#31562:u32
        let s_924_29: u32 = fn_state.u_31562;
        // D s_924_30: cast zx s_924_29 -> bv
        let s_924_30: Bits = Bits::new(s_924_29 as u128, 32u16);
        // D s_924_31: bit-extract s_924_30 s_924_27 s_924_28
        let s_924_31: Bits = (Bits::new(
            ((s_924_30) >> (s_924_27)).value(),
            u16::try_from(s_924_28).unwrap(),
        ));
        // D s_924_32: cast reint s_924_31 -> u8
        let s_924_32: bool = ((s_924_31.value()) != 0);
        // C s_924_33: const #0s : i
        let s_924_33: i128 = 0;
        // C s_924_34: const #4s : i
        let s_924_34: i128 = 4;
        // D s_924_35: read-var u#31562:u32
        let s_924_35: u32 = fn_state.u_31562;
        // D s_924_36: cast zx s_924_35 -> bv
        let s_924_36: Bits = Bits::new(s_924_35 as u128, 32u16);
        // D s_924_37: bit-extract s_924_36 s_924_33 s_924_34
        let s_924_37: Bits = (Bits::new(
            ((s_924_36) >> (s_924_33)).value(),
            u16::try_from(s_924_34).unwrap(),
        ));
        // D s_924_38: cast reint s_924_37 -> u8
        let s_924_38: u8 = (s_924_37.value() as u8);
        // D s_924_39: call decode_aarch32_instrs_VQMOVN_A1enc_A_txt(s_924_8, s_924_14, s_924_20, s_924_26, s_924_32, s_924_38)
        let s_924_39: () = decode_aarch32_instrs_VQMOVN_A1enc_A_txt(
            state,
            tracer,
            s_924_8,
            s_924_14,
            s_924_20,
            s_924_26,
            s_924_32,
            s_924_38,
        );
        // N s_924_40: return
        return;
    }
    fn block_925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_925_0: read-var merge#var.1:struct
        let s_925_0: u32 = fn_state.merge_var._1;
        // D s_925_1: write-var u#31570 <= s_925_0
        fn_state.u_31570 = s_925_0;
        // C s_925_2: const #23s : i
        let s_925_2: i128 = 23;
        // D s_925_3: read-var u#31570:u32
        let s_925_3: u32 = fn_state.u_31570;
        // D s_925_4: cast zx s_925_3 -> bv
        let s_925_4: Bits = Bits::new(s_925_3 as u128, 32u16);
        // C s_925_5: const #1s : i64
        let s_925_5: i64 = 1;
        // C s_925_6: cast zx s_925_5 -> i
        let s_925_6: i128 = (i128::try_from(s_925_5).unwrap());
        // C s_925_7: const #8s : i
        let s_925_7: i128 = 8;
        // C s_925_8: add s_925_7 s_925_6
        let s_925_8: i128 = (s_925_7 + s_925_6);
        // D s_925_9: bit-extract s_925_4 s_925_2 s_925_8
        let s_925_9: Bits = (Bits::new(
            ((s_925_4) >> (s_925_2)).value(),
            u16::try_from(s_925_8).unwrap(),
        ));
        // D s_925_10: cast reint s_925_9 -> u9
        let s_925_10: u16 = (s_925_9.value() as u16);
        // D s_925_11: cast zx s_925_10 -> bv
        let s_925_11: Bits = Bits::new(s_925_10 as u128, 9u16);
        // C s_925_12: const #487u : u9
        let s_925_12: u16 = 487;
        // C s_925_13: cast zx s_925_12 -> bv
        let s_925_13: Bits = Bits::new(s_925_12 as u128, 9u16);
        // D s_925_14: cmp-eq s_925_11 s_925_13
        let s_925_14: bool = ((s_925_11) == (s_925_13));
        // N s_925_15: branch s_925_14 b2246 b926
        if s_925_14 {
            return block_2246(state, tracer, fn_state);
        } else {
            return block_926(state, tracer, fn_state);
        };
    }
    fn block_926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_926_0: const #0u : u8
        let s_926_0: bool = false;
        // D s_926_1: write-var gs#401200 <= s_926_0
        fn_state.gs_401200 = s_926_0;
        // N s_926_2: jump b927
        return block_927(state, tracer, fn_state);
    }
    fn block_927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_927_0: read-var gs#401200:u8
        let s_927_0: bool = fn_state.gs_401200;
        // N s_927_1: branch s_927_0 b2245 b928
        if s_927_0 {
            return block_2245(state, tracer, fn_state);
        } else {
            return block_928(state, tracer, fn_state);
        };
    }
    fn block_928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_928_0: const #0u : u8
        let s_928_0: bool = false;
        // D s_928_1: write-var gs#401202 <= s_928_0
        fn_state.gs_401202 = s_928_0;
        // N s_928_2: jump b929
        return block_929(state, tracer, fn_state);
    }
    fn block_929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_929_0: read-var gs#401202:u8
        let s_929_0: bool = fn_state.gs_401202;
        // D s_929_1: not s_929_0
        let s_929_1: bool = !s_929_0;
        // N s_929_2: branch s_929_1 b931 b930
        if s_929_1 {
            return block_931(state, tracer, fn_state);
        } else {
            return block_930(state, tracer, fn_state);
        };
    }
    fn block_930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_930_0: const #3622s : i
        let s_930_0: i128 = 3622;
        // C s_930_1: const #14696u : u32
        let s_930_1: u32 = 14696;
        // N s_930_2: write-reg s_930_1 <= s_930_0
        let s_930_2: () = {
            state.write_register::<i128>(s_930_1 as isize, s_930_0);
            tracer.write_register(s_930_1 as isize, s_930_0);
        };
        // C s_930_3: const #22s : i
        let s_930_3: i128 = 22;
        // C s_930_4: const #1s : i
        let s_930_4: i128 = 1;
        // D s_930_5: read-var u#31570:u32
        let s_930_5: u32 = fn_state.u_31570;
        // D s_930_6: cast zx s_930_5 -> bv
        let s_930_6: Bits = Bits::new(s_930_5 as u128, 32u16);
        // D s_930_7: bit-extract s_930_6 s_930_3 s_930_4
        let s_930_7: Bits = (Bits::new(
            ((s_930_6) >> (s_930_3)).value(),
            u16::try_from(s_930_4).unwrap(),
        ));
        // D s_930_8: cast reint s_930_7 -> u8
        let s_930_8: bool = ((s_930_7.value()) != 0);
        // C s_930_9: const #18s : i
        let s_930_9: i128 = 18;
        // C s_930_10: const #2s : i
        let s_930_10: i128 = 2;
        // D s_930_11: read-var u#31570:u32
        let s_930_11: u32 = fn_state.u_31570;
        // D s_930_12: cast zx s_930_11 -> bv
        let s_930_12: Bits = Bits::new(s_930_11 as u128, 32u16);
        // D s_930_13: bit-extract s_930_12 s_930_9 s_930_10
        let s_930_13: Bits = (Bits::new(
            ((s_930_12) >> (s_930_9)).value(),
            u16::try_from(s_930_10).unwrap(),
        ));
        // D s_930_14: cast reint s_930_13 -> u8
        let s_930_14: u8 = (s_930_13.value() as u8);
        // C s_930_15: const #12s : i
        let s_930_15: i128 = 12;
        // C s_930_16: const #4s : i
        let s_930_16: i128 = 4;
        // D s_930_17: read-var u#31570:u32
        let s_930_17: u32 = fn_state.u_31570;
        // D s_930_18: cast zx s_930_17 -> bv
        let s_930_18: Bits = Bits::new(s_930_17 as u128, 32u16);
        // D s_930_19: bit-extract s_930_18 s_930_15 s_930_16
        let s_930_19: Bits = (Bits::new(
            ((s_930_18) >> (s_930_15)).value(),
            u16::try_from(s_930_16).unwrap(),
        ));
        // D s_930_20: cast reint s_930_19 -> u8
        let s_930_20: u8 = (s_930_19.value() as u8);
        // C s_930_21: const #6s : i
        let s_930_21: i128 = 6;
        // C s_930_22: const #1s : i
        let s_930_22: i128 = 1;
        // D s_930_23: read-var u#31570:u32
        let s_930_23: u32 = fn_state.u_31570;
        // D s_930_24: cast zx s_930_23 -> bv
        let s_930_24: Bits = Bits::new(s_930_23 as u128, 32u16);
        // D s_930_25: bit-extract s_930_24 s_930_21 s_930_22
        let s_930_25: Bits = (Bits::new(
            ((s_930_24) >> (s_930_21)).value(),
            u16::try_from(s_930_22).unwrap(),
        ));
        // D s_930_26: cast reint s_930_25 -> u8
        let s_930_26: bool = ((s_930_25.value()) != 0);
        // C s_930_27: const #5s : i
        let s_930_27: i128 = 5;
        // C s_930_28: const #1s : i
        let s_930_28: i128 = 1;
        // D s_930_29: read-var u#31570:u32
        let s_930_29: u32 = fn_state.u_31570;
        // D s_930_30: cast zx s_930_29 -> bv
        let s_930_30: Bits = Bits::new(s_930_29 as u128, 32u16);
        // D s_930_31: bit-extract s_930_30 s_930_27 s_930_28
        let s_930_31: Bits = (Bits::new(
            ((s_930_30) >> (s_930_27)).value(),
            u16::try_from(s_930_28).unwrap(),
        ));
        // D s_930_32: cast reint s_930_31 -> u8
        let s_930_32: bool = ((s_930_31.value()) != 0);
        // C s_930_33: const #0s : i
        let s_930_33: i128 = 0;
        // C s_930_34: const #4s : i
        let s_930_34: i128 = 4;
        // D s_930_35: read-var u#31570:u32
        let s_930_35: u32 = fn_state.u_31570;
        // D s_930_36: cast zx s_930_35 -> bv
        let s_930_36: Bits = Bits::new(s_930_35 as u128, 32u16);
        // D s_930_37: bit-extract s_930_36 s_930_33 s_930_34
        let s_930_37: Bits = (Bits::new(
            ((s_930_36) >> (s_930_33)).value(),
            u16::try_from(s_930_34).unwrap(),
        ));
        // D s_930_38: cast reint s_930_37 -> u8
        let s_930_38: u8 = (s_930_37.value() as u8);
        // D s_930_39: call decode_aarch32_instrs_VQNEG_A1enc_A_txt(s_930_8, s_930_14, s_930_20, s_930_26, s_930_32, s_930_38)
        let s_930_39: () = decode_aarch32_instrs_VQNEG_A1enc_A_txt(
            state,
            tracer,
            s_930_8,
            s_930_14,
            s_930_20,
            s_930_26,
            s_930_32,
            s_930_38,
        );
        // N s_930_40: return
        return;
    }
    fn block_931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_931_0: read-var merge#var.1:struct
        let s_931_0: u32 = fn_state.merge_var._1;
        // D s_931_1: write-var u#31578 <= s_931_0
        fn_state.u_31578 = s_931_0;
        // C s_931_2: const #23s : i
        let s_931_2: i128 = 23;
        // D s_931_3: read-var u#31578:u32
        let s_931_3: u32 = fn_state.u_31578;
        // D s_931_4: cast zx s_931_3 -> bv
        let s_931_4: Bits = Bits::new(s_931_3 as u128, 32u16);
        // C s_931_5: const #1s : i64
        let s_931_5: i64 = 1;
        // C s_931_6: cast zx s_931_5 -> i
        let s_931_6: i128 = (i128::try_from(s_931_5).unwrap());
        // C s_931_7: const #8s : i
        let s_931_7: i128 = 8;
        // C s_931_8: add s_931_7 s_931_6
        let s_931_8: i128 = (s_931_7 + s_931_6);
        // D s_931_9: bit-extract s_931_4 s_931_2 s_931_8
        let s_931_9: Bits = (Bits::new(
            ((s_931_4) >> (s_931_2)).value(),
            u16::try_from(s_931_8).unwrap(),
        ));
        // D s_931_10: cast reint s_931_9 -> u9
        let s_931_10: u16 = (s_931_9.value() as u16);
        // D s_931_11: cast zx s_931_10 -> bv
        let s_931_11: Bits = Bits::new(s_931_10 as u128, 9u16);
        // C s_931_12: const #486u : u9
        let s_931_12: u16 = 486;
        // C s_931_13: cast zx s_931_12 -> bv
        let s_931_13: Bits = Bits::new(s_931_12 as u128, 9u16);
        // D s_931_14: cmp-eq s_931_11 s_931_13
        let s_931_14: bool = ((s_931_11) == (s_931_13));
        // N s_931_15: branch s_931_14 b2241 b932
        if s_931_14 {
            return block_2241(state, tracer, fn_state);
        } else {
            return block_932(state, tracer, fn_state);
        };
    }
    fn block_932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_932_0: const #0u : u8
        let s_932_0: bool = false;
        // D s_932_1: write-var gs#401225 <= s_932_0
        fn_state.gs_401225 = s_932_0;
        // N s_932_2: jump b933
        return block_933(state, tracer, fn_state);
    }
    fn block_933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_933_0: read-var gs#401225:u8
        let s_933_0: bool = fn_state.gs_401225;
        // N s_933_1: branch s_933_0 b2240 b934
        if s_933_0 {
            return block_2240(state, tracer, fn_state);
        } else {
            return block_934(state, tracer, fn_state);
        };
    }
    fn block_934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_934_0: const #0u : u8
        let s_934_0: bool = false;
        // D s_934_1: write-var gs#401227 <= s_934_0
        fn_state.gs_401227 = s_934_0;
        // N s_934_2: jump b935
        return block_935(state, tracer, fn_state);
    }
    fn block_935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_935_0: read-var gs#401227:u8
        let s_935_0: bool = fn_state.gs_401227;
        // D s_935_1: not s_935_0
        let s_935_1: bool = !s_935_0;
        // N s_935_2: branch s_935_1 b937 b936
        if s_935_1 {
            return block_937(state, tracer, fn_state);
        } else {
            return block_936(state, tracer, fn_state);
        };
    }
    fn block_936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_936_0: const #3624s : i
        let s_936_0: i128 = 3624;
        // C s_936_1: const #14696u : u32
        let s_936_1: u32 = 14696;
        // N s_936_2: write-reg s_936_1 <= s_936_0
        let s_936_2: () = {
            state.write_register::<i128>(s_936_1 as isize, s_936_0);
            tracer.write_register(s_936_1 as isize, s_936_0);
        };
        // C s_936_3: const #22s : i
        let s_936_3: i128 = 22;
        // C s_936_4: const #1s : i
        let s_936_4: i128 = 1;
        // D s_936_5: read-var u#31578:u32
        let s_936_5: u32 = fn_state.u_31578;
        // D s_936_6: cast zx s_936_5 -> bv
        let s_936_6: Bits = Bits::new(s_936_5 as u128, 32u16);
        // D s_936_7: bit-extract s_936_6 s_936_3 s_936_4
        let s_936_7: Bits = (Bits::new(
            ((s_936_6) >> (s_936_3)).value(),
            u16::try_from(s_936_4).unwrap(),
        ));
        // D s_936_8: cast reint s_936_7 -> u8
        let s_936_8: bool = ((s_936_7.value()) != 0);
        // C s_936_9: const #20s : i
        let s_936_9: i128 = 20;
        // C s_936_10: const #2s : i
        let s_936_10: i128 = 2;
        // D s_936_11: read-var u#31578:u32
        let s_936_11: u32 = fn_state.u_31578;
        // D s_936_12: cast zx s_936_11 -> bv
        let s_936_12: Bits = Bits::new(s_936_11 as u128, 32u16);
        // D s_936_13: bit-extract s_936_12 s_936_9 s_936_10
        let s_936_13: Bits = (Bits::new(
            ((s_936_12) >> (s_936_9)).value(),
            u16::try_from(s_936_10).unwrap(),
        ));
        // D s_936_14: cast reint s_936_13 -> u8
        let s_936_14: u8 = (s_936_13.value() as u8);
        // C s_936_15: const #16s : i
        let s_936_15: i128 = 16;
        // C s_936_16: const #4s : i
        let s_936_16: i128 = 4;
        // D s_936_17: read-var u#31578:u32
        let s_936_17: u32 = fn_state.u_31578;
        // D s_936_18: cast zx s_936_17 -> bv
        let s_936_18: Bits = Bits::new(s_936_17 as u128, 32u16);
        // D s_936_19: bit-extract s_936_18 s_936_15 s_936_16
        let s_936_19: Bits = (Bits::new(
            ((s_936_18) >> (s_936_15)).value(),
            u16::try_from(s_936_16).unwrap(),
        ));
        // D s_936_20: cast reint s_936_19 -> u8
        let s_936_20: u8 = (s_936_19.value() as u8);
        // C s_936_21: const #12s : i
        let s_936_21: i128 = 12;
        // C s_936_22: const #4s : i
        let s_936_22: i128 = 4;
        // D s_936_23: read-var u#31578:u32
        let s_936_23: u32 = fn_state.u_31578;
        // D s_936_24: cast zx s_936_23 -> bv
        let s_936_24: Bits = Bits::new(s_936_23 as u128, 32u16);
        // D s_936_25: bit-extract s_936_24 s_936_21 s_936_22
        let s_936_25: Bits = (Bits::new(
            ((s_936_24) >> (s_936_21)).value(),
            u16::try_from(s_936_22).unwrap(),
        ));
        // D s_936_26: cast reint s_936_25 -> u8
        let s_936_26: u8 = (s_936_25.value() as u8);
        // C s_936_27: const #7s : i
        let s_936_27: i128 = 7;
        // C s_936_28: const #1s : i
        let s_936_28: i128 = 1;
        // D s_936_29: read-var u#31578:u32
        let s_936_29: u32 = fn_state.u_31578;
        // D s_936_30: cast zx s_936_29 -> bv
        let s_936_30: Bits = Bits::new(s_936_29 as u128, 32u16);
        // D s_936_31: bit-extract s_936_30 s_936_27 s_936_28
        let s_936_31: Bits = (Bits::new(
            ((s_936_30) >> (s_936_27)).value(),
            u16::try_from(s_936_28).unwrap(),
        ));
        // D s_936_32: cast reint s_936_31 -> u8
        let s_936_32: bool = ((s_936_31.value()) != 0);
        // C s_936_33: const #6s : i
        let s_936_33: i128 = 6;
        // C s_936_34: const #1s : i
        let s_936_34: i128 = 1;
        // D s_936_35: read-var u#31578:u32
        let s_936_35: u32 = fn_state.u_31578;
        // D s_936_36: cast zx s_936_35 -> bv
        let s_936_36: Bits = Bits::new(s_936_35 as u128, 32u16);
        // D s_936_37: bit-extract s_936_36 s_936_33 s_936_34
        let s_936_37: Bits = (Bits::new(
            ((s_936_36) >> (s_936_33)).value(),
            u16::try_from(s_936_34).unwrap(),
        ));
        // D s_936_38: cast reint s_936_37 -> u8
        let s_936_38: bool = ((s_936_37.value()) != 0);
        // C s_936_39: const #5s : i
        let s_936_39: i128 = 5;
        // C s_936_40: const #1s : i
        let s_936_40: i128 = 1;
        // D s_936_41: read-var u#31578:u32
        let s_936_41: u32 = fn_state.u_31578;
        // D s_936_42: cast zx s_936_41 -> bv
        let s_936_42: Bits = Bits::new(s_936_41 as u128, 32u16);
        // D s_936_43: bit-extract s_936_42 s_936_39 s_936_40
        let s_936_43: Bits = (Bits::new(
            ((s_936_42) >> (s_936_39)).value(),
            u16::try_from(s_936_40).unwrap(),
        ));
        // D s_936_44: cast reint s_936_43 -> u8
        let s_936_44: bool = ((s_936_43.value()) != 0);
        // C s_936_45: const #0s : i
        let s_936_45: i128 = 0;
        // C s_936_46: const #4s : i
        let s_936_46: i128 = 4;
        // D s_936_47: read-var u#31578:u32
        let s_936_47: u32 = fn_state.u_31578;
        // D s_936_48: cast zx s_936_47 -> bv
        let s_936_48: Bits = Bits::new(s_936_47 as u128, 32u16);
        // D s_936_49: bit-extract s_936_48 s_936_45 s_936_46
        let s_936_49: Bits = (Bits::new(
            ((s_936_48) >> (s_936_45)).value(),
            u16::try_from(s_936_46).unwrap(),
        ));
        // D s_936_50: cast reint s_936_49 -> u8
        let s_936_50: u8 = (s_936_49.value() as u8);
        // D s_936_51: call decode_aarch32_instrs_VQRDMULH_A1enc_A_txt(s_936_8, s_936_14, s_936_20, s_936_26, s_936_32, s_936_38, s_936_44, s_936_50)
        let s_936_51: () = decode_aarch32_instrs_VQRDMULH_A1enc_A_txt(
            state,
            tracer,
            s_936_8,
            s_936_14,
            s_936_20,
            s_936_26,
            s_936_32,
            s_936_38,
            s_936_44,
            s_936_50,
        );
        // N s_936_52: return
        return;
    }
    fn block_937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_937_0: read-var merge#var.1:struct
        let s_937_0: u32 = fn_state.merge_var._1;
        // D s_937_1: write-var u#31588 <= s_937_0
        fn_state.u_31588 = s_937_0;
        // C s_937_2: const #25s : i
        let s_937_2: i128 = 25;
        // D s_937_3: read-var u#31588:u32
        let s_937_3: u32 = fn_state.u_31588;
        // D s_937_4: cast zx s_937_3 -> bv
        let s_937_4: Bits = Bits::new(s_937_3 as u128, 32u16);
        // C s_937_5: const #1s : i64
        let s_937_5: i64 = 1;
        // C s_937_6: cast zx s_937_5 -> i
        let s_937_6: i128 = (i128::try_from(s_937_5).unwrap());
        // C s_937_7: const #6s : i
        let s_937_7: i128 = 6;
        // C s_937_8: add s_937_7 s_937_6
        let s_937_8: i128 = (s_937_7 + s_937_6);
        // D s_937_9: bit-extract s_937_4 s_937_2 s_937_8
        let s_937_9: Bits = (Bits::new(
            ((s_937_4) >> (s_937_2)).value(),
            u16::try_from(s_937_8).unwrap(),
        ));
        // D s_937_10: cast reint s_937_9 -> u8
        let s_937_10: u8 = (s_937_9.value() as u8);
        // D s_937_11: cast zx s_937_10 -> bv
        let s_937_11: Bits = Bits::new(s_937_10 as u128, 7u16);
        // C s_937_12: const #121u : u8
        let s_937_12: u8 = 121;
        // C s_937_13: cast zx s_937_12 -> bv
        let s_937_13: Bits = Bits::new(s_937_12 as u128, 7u16);
        // D s_937_14: cmp-eq s_937_11 s_937_13
        let s_937_14: bool = ((s_937_11) == (s_937_13));
        // N s_937_15: branch s_937_14 b2230 b938
        if s_937_14 {
            return block_2230(state, tracer, fn_state);
        } else {
            return block_938(state, tracer, fn_state);
        };
    }
    fn block_938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_938_0: const #0u : u8
        let s_938_0: bool = false;
        // D s_938_1: write-var gs#401260 <= s_938_0
        fn_state.gs_401260 = s_938_0;
        // N s_938_2: jump b939
        return block_939(state, tracer, fn_state);
    }
    fn block_939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_939_0: read-var gs#401260:u8
        let s_939_0: bool = fn_state.gs_401260;
        // N s_939_1: branch s_939_0 b2229 b940
        if s_939_0 {
            return block_2229(state, tracer, fn_state);
        } else {
            return block_940(state, tracer, fn_state);
        };
    }
    fn block_940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_940_0: const #0u : u8
        let s_940_0: bool = false;
        // D s_940_1: write-var gs#401262 <= s_940_0
        fn_state.gs_401262 = s_940_0;
        // N s_940_2: jump b941
        return block_941(state, tracer, fn_state);
    }
    fn block_941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_941_0: read-var gs#401262:u8
        let s_941_0: bool = fn_state.gs_401262;
        // D s_941_1: not s_941_0
        let s_941_1: bool = !s_941_0;
        // N s_941_2: branch s_941_1 b943 b942
        if s_941_1 {
            return block_943(state, tracer, fn_state);
        } else {
            return block_942(state, tracer, fn_state);
        };
    }
    fn block_942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_942_0: const #3625s : i
        let s_942_0: i128 = 3625;
        // C s_942_1: const #14696u : u32
        let s_942_1: u32 = 14696;
        // N s_942_2: write-reg s_942_1 <= s_942_0
        let s_942_2: () = {
            state.write_register::<i128>(s_942_1 as isize, s_942_0);
            tracer.write_register(s_942_1 as isize, s_942_0);
        };
        // C s_942_3: const #24s : i
        let s_942_3: i128 = 24;
        // C s_942_4: const #1s : i
        let s_942_4: i128 = 1;
        // D s_942_5: read-var u#31588:u32
        let s_942_5: u32 = fn_state.u_31588;
        // D s_942_6: cast zx s_942_5 -> bv
        let s_942_6: Bits = Bits::new(s_942_5 as u128, 32u16);
        // D s_942_7: bit-extract s_942_6 s_942_3 s_942_4
        let s_942_7: Bits = (Bits::new(
            ((s_942_6) >> (s_942_3)).value(),
            u16::try_from(s_942_4).unwrap(),
        ));
        // D s_942_8: cast reint s_942_7 -> u8
        let s_942_8: bool = ((s_942_7.value()) != 0);
        // C s_942_9: const #22s : i
        let s_942_9: i128 = 22;
        // C s_942_10: const #1s : i
        let s_942_10: i128 = 1;
        // D s_942_11: read-var u#31588:u32
        let s_942_11: u32 = fn_state.u_31588;
        // D s_942_12: cast zx s_942_11 -> bv
        let s_942_12: Bits = Bits::new(s_942_11 as u128, 32u16);
        // D s_942_13: bit-extract s_942_12 s_942_9 s_942_10
        let s_942_13: Bits = (Bits::new(
            ((s_942_12) >> (s_942_9)).value(),
            u16::try_from(s_942_10).unwrap(),
        ));
        // D s_942_14: cast reint s_942_13 -> u8
        let s_942_14: bool = ((s_942_13.value()) != 0);
        // C s_942_15: const #20s : i
        let s_942_15: i128 = 20;
        // C s_942_16: const #2s : i
        let s_942_16: i128 = 2;
        // D s_942_17: read-var u#31588:u32
        let s_942_17: u32 = fn_state.u_31588;
        // D s_942_18: cast zx s_942_17 -> bv
        let s_942_18: Bits = Bits::new(s_942_17 as u128, 32u16);
        // D s_942_19: bit-extract s_942_18 s_942_15 s_942_16
        let s_942_19: Bits = (Bits::new(
            ((s_942_18) >> (s_942_15)).value(),
            u16::try_from(s_942_16).unwrap(),
        ));
        // D s_942_20: cast reint s_942_19 -> u8
        let s_942_20: u8 = (s_942_19.value() as u8);
        // C s_942_21: const #16s : i
        let s_942_21: i128 = 16;
        // C s_942_22: const #4s : i
        let s_942_22: i128 = 4;
        // D s_942_23: read-var u#31588:u32
        let s_942_23: u32 = fn_state.u_31588;
        // D s_942_24: cast zx s_942_23 -> bv
        let s_942_24: Bits = Bits::new(s_942_23 as u128, 32u16);
        // D s_942_25: bit-extract s_942_24 s_942_21 s_942_22
        let s_942_25: Bits = (Bits::new(
            ((s_942_24) >> (s_942_21)).value(),
            u16::try_from(s_942_22).unwrap(),
        ));
        // D s_942_26: cast reint s_942_25 -> u8
        let s_942_26: u8 = (s_942_25.value() as u8);
        // C s_942_27: const #12s : i
        let s_942_27: i128 = 12;
        // C s_942_28: const #4s : i
        let s_942_28: i128 = 4;
        // D s_942_29: read-var u#31588:u32
        let s_942_29: u32 = fn_state.u_31588;
        // D s_942_30: cast zx s_942_29 -> bv
        let s_942_30: Bits = Bits::new(s_942_29 as u128, 32u16);
        // D s_942_31: bit-extract s_942_30 s_942_27 s_942_28
        let s_942_31: Bits = (Bits::new(
            ((s_942_30) >> (s_942_27)).value(),
            u16::try_from(s_942_28).unwrap(),
        ));
        // D s_942_32: cast reint s_942_31 -> u8
        let s_942_32: u8 = (s_942_31.value() as u8);
        // C s_942_33: const #7s : i
        let s_942_33: i128 = 7;
        // C s_942_34: const #1s : i
        let s_942_34: i128 = 1;
        // D s_942_35: read-var u#31588:u32
        let s_942_35: u32 = fn_state.u_31588;
        // D s_942_36: cast zx s_942_35 -> bv
        let s_942_36: Bits = Bits::new(s_942_35 as u128, 32u16);
        // D s_942_37: bit-extract s_942_36 s_942_33 s_942_34
        let s_942_37: Bits = (Bits::new(
            ((s_942_36) >> (s_942_33)).value(),
            u16::try_from(s_942_34).unwrap(),
        ));
        // D s_942_38: cast reint s_942_37 -> u8
        let s_942_38: bool = ((s_942_37.value()) != 0);
        // C s_942_39: const #5s : i
        let s_942_39: i128 = 5;
        // C s_942_40: const #1s : i
        let s_942_40: i128 = 1;
        // D s_942_41: read-var u#31588:u32
        let s_942_41: u32 = fn_state.u_31588;
        // D s_942_42: cast zx s_942_41 -> bv
        let s_942_42: Bits = Bits::new(s_942_41 as u128, 32u16);
        // D s_942_43: bit-extract s_942_42 s_942_39 s_942_40
        let s_942_43: Bits = (Bits::new(
            ((s_942_42) >> (s_942_39)).value(),
            u16::try_from(s_942_40).unwrap(),
        ));
        // D s_942_44: cast reint s_942_43 -> u8
        let s_942_44: bool = ((s_942_43.value()) != 0);
        // C s_942_45: const #0s : i
        let s_942_45: i128 = 0;
        // C s_942_46: const #4s : i
        let s_942_46: i128 = 4;
        // D s_942_47: read-var u#31588:u32
        let s_942_47: u32 = fn_state.u_31588;
        // D s_942_48: cast zx s_942_47 -> bv
        let s_942_48: Bits = Bits::new(s_942_47 as u128, 32u16);
        // D s_942_49: bit-extract s_942_48 s_942_45 s_942_46
        let s_942_49: Bits = (Bits::new(
            ((s_942_48) >> (s_942_45)).value(),
            u16::try_from(s_942_46).unwrap(),
        ));
        // D s_942_50: cast reint s_942_49 -> u8
        let s_942_50: u8 = (s_942_49.value() as u8);
        // D s_942_51: call decode_aarch32_instrs_VQRDMULH_A2enc_A_txt(s_942_8, s_942_14, s_942_20, s_942_26, s_942_32, s_942_38, s_942_44, s_942_50)
        let s_942_51: () = decode_aarch32_instrs_VQRDMULH_A2enc_A_txt(
            state,
            tracer,
            s_942_8,
            s_942_14,
            s_942_20,
            s_942_26,
            s_942_32,
            s_942_38,
            s_942_44,
            s_942_50,
        );
        // N s_942_52: return
        return;
    }
    fn block_943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_943_0: read-var merge#var.1:struct
        let s_943_0: u32 = fn_state.merge_var._1;
        // D s_943_1: write-var u#31598 <= s_943_0
        fn_state.u_31598 = s_943_0;
        // C s_943_2: const #23s : i
        let s_943_2: i128 = 23;
        // D s_943_3: read-var u#31598:u32
        let s_943_3: u32 = fn_state.u_31598;
        // D s_943_4: cast zx s_943_3 -> bv
        let s_943_4: Bits = Bits::new(s_943_3 as u128, 32u16);
        // C s_943_5: const #1s : i64
        let s_943_5: i64 = 1;
        // C s_943_6: cast zx s_943_5 -> i
        let s_943_6: i128 = (i128::try_from(s_943_5).unwrap());
        // C s_943_7: const #8s : i
        let s_943_7: i128 = 8;
        // C s_943_8: add s_943_7 s_943_6
        let s_943_8: i128 = (s_943_7 + s_943_6);
        // D s_943_9: bit-extract s_943_4 s_943_2 s_943_8
        let s_943_9: Bits = (Bits::new(
            ((s_943_4) >> (s_943_2)).value(),
            u16::try_from(s_943_8).unwrap(),
        ));
        // D s_943_10: cast reint s_943_9 -> u9
        let s_943_10: u16 = (s_943_9.value() as u16);
        // D s_943_11: cast zx s_943_10 -> bv
        let s_943_11: Bits = Bits::new(s_943_10 as u128, 9u16);
        // C s_943_12: const #486u : u9
        let s_943_12: u16 = 486;
        // C s_943_13: cast zx s_943_12 -> bv
        let s_943_13: Bits = Bits::new(s_943_12 as u128, 9u16);
        // D s_943_14: cmp-eq s_943_11 s_943_13
        let s_943_14: bool = ((s_943_11) == (s_943_13));
        // N s_943_15: branch s_943_14 b2225 b944
        if s_943_14 {
            return block_2225(state, tracer, fn_state);
        } else {
            return block_944(state, tracer, fn_state);
        };
    }
    fn block_944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_944_0: const #0u : u8
        let s_944_0: bool = false;
        // D s_944_1: write-var gs#401289 <= s_944_0
        fn_state.gs_401289 = s_944_0;
        // N s_944_2: jump b945
        return block_945(state, tracer, fn_state);
    }
    fn block_945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_945_0: read-var gs#401289:u8
        let s_945_0: bool = fn_state.gs_401289;
        // N s_945_1: branch s_945_0 b2224 b946
        if s_945_0 {
            return block_2224(state, tracer, fn_state);
        } else {
            return block_946(state, tracer, fn_state);
        };
    }
    fn block_946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_946_0: const #0u : u8
        let s_946_0: bool = false;
        // D s_946_1: write-var gs#401291 <= s_946_0
        fn_state.gs_401291 = s_946_0;
        // N s_946_2: jump b947
        return block_947(state, tracer, fn_state);
    }
    fn block_947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_947_0: read-var gs#401291:u8
        let s_947_0: bool = fn_state.gs_401291;
        // D s_947_1: not s_947_0
        let s_947_1: bool = !s_947_0;
        // N s_947_2: branch s_947_1 b949 b948
        if s_947_1 {
            return block_949(state, tracer, fn_state);
        } else {
            return block_948(state, tracer, fn_state);
        };
    }
    fn block_948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_948_0: const #3628s : i
        let s_948_0: i128 = 3628;
        // C s_948_1: const #14696u : u32
        let s_948_1: u32 = 14696;
        // N s_948_2: write-reg s_948_1 <= s_948_0
        let s_948_2: () = {
            state.write_register::<i128>(s_948_1 as isize, s_948_0);
            tracer.write_register(s_948_1 as isize, s_948_0);
        };
        // C s_948_3: const #22s : i
        let s_948_3: i128 = 22;
        // C s_948_4: const #1s : i
        let s_948_4: i128 = 1;
        // D s_948_5: read-var u#31598:u32
        let s_948_5: u32 = fn_state.u_31598;
        // D s_948_6: cast zx s_948_5 -> bv
        let s_948_6: Bits = Bits::new(s_948_5 as u128, 32u16);
        // D s_948_7: bit-extract s_948_6 s_948_3 s_948_4
        let s_948_7: Bits = (Bits::new(
            ((s_948_6) >> (s_948_3)).value(),
            u16::try_from(s_948_4).unwrap(),
        ));
        // D s_948_8: cast reint s_948_7 -> u8
        let s_948_8: bool = ((s_948_7.value()) != 0);
        // C s_948_9: const #20s : i
        let s_948_9: i128 = 20;
        // C s_948_10: const #2s : i
        let s_948_10: i128 = 2;
        // D s_948_11: read-var u#31598:u32
        let s_948_11: u32 = fn_state.u_31598;
        // D s_948_12: cast zx s_948_11 -> bv
        let s_948_12: Bits = Bits::new(s_948_11 as u128, 32u16);
        // D s_948_13: bit-extract s_948_12 s_948_9 s_948_10
        let s_948_13: Bits = (Bits::new(
            ((s_948_12) >> (s_948_9)).value(),
            u16::try_from(s_948_10).unwrap(),
        ));
        // D s_948_14: cast reint s_948_13 -> u8
        let s_948_14: u8 = (s_948_13.value() as u8);
        // C s_948_15: const #16s : i
        let s_948_15: i128 = 16;
        // C s_948_16: const #4s : i
        let s_948_16: i128 = 4;
        // D s_948_17: read-var u#31598:u32
        let s_948_17: u32 = fn_state.u_31598;
        // D s_948_18: cast zx s_948_17 -> bv
        let s_948_18: Bits = Bits::new(s_948_17 as u128, 32u16);
        // D s_948_19: bit-extract s_948_18 s_948_15 s_948_16
        let s_948_19: Bits = (Bits::new(
            ((s_948_18) >> (s_948_15)).value(),
            u16::try_from(s_948_16).unwrap(),
        ));
        // D s_948_20: cast reint s_948_19 -> u8
        let s_948_20: u8 = (s_948_19.value() as u8);
        // C s_948_21: const #12s : i
        let s_948_21: i128 = 12;
        // C s_948_22: const #4s : i
        let s_948_22: i128 = 4;
        // D s_948_23: read-var u#31598:u32
        let s_948_23: u32 = fn_state.u_31598;
        // D s_948_24: cast zx s_948_23 -> bv
        let s_948_24: Bits = Bits::new(s_948_23 as u128, 32u16);
        // D s_948_25: bit-extract s_948_24 s_948_21 s_948_22
        let s_948_25: Bits = (Bits::new(
            ((s_948_24) >> (s_948_21)).value(),
            u16::try_from(s_948_22).unwrap(),
        ));
        // D s_948_26: cast reint s_948_25 -> u8
        let s_948_26: u8 = (s_948_25.value() as u8);
        // C s_948_27: const #7s : i
        let s_948_27: i128 = 7;
        // C s_948_28: const #1s : i
        let s_948_28: i128 = 1;
        // D s_948_29: read-var u#31598:u32
        let s_948_29: u32 = fn_state.u_31598;
        // D s_948_30: cast zx s_948_29 -> bv
        let s_948_30: Bits = Bits::new(s_948_29 as u128, 32u16);
        // D s_948_31: bit-extract s_948_30 s_948_27 s_948_28
        let s_948_31: Bits = (Bits::new(
            ((s_948_30) >> (s_948_27)).value(),
            u16::try_from(s_948_28).unwrap(),
        ));
        // D s_948_32: cast reint s_948_31 -> u8
        let s_948_32: bool = ((s_948_31.value()) != 0);
        // C s_948_33: const #6s : i
        let s_948_33: i128 = 6;
        // C s_948_34: const #1s : i
        let s_948_34: i128 = 1;
        // D s_948_35: read-var u#31598:u32
        let s_948_35: u32 = fn_state.u_31598;
        // D s_948_36: cast zx s_948_35 -> bv
        let s_948_36: Bits = Bits::new(s_948_35 as u128, 32u16);
        // D s_948_37: bit-extract s_948_36 s_948_33 s_948_34
        let s_948_37: Bits = (Bits::new(
            ((s_948_36) >> (s_948_33)).value(),
            u16::try_from(s_948_34).unwrap(),
        ));
        // D s_948_38: cast reint s_948_37 -> u8
        let s_948_38: bool = ((s_948_37.value()) != 0);
        // C s_948_39: const #5s : i
        let s_948_39: i128 = 5;
        // C s_948_40: const #1s : i
        let s_948_40: i128 = 1;
        // D s_948_41: read-var u#31598:u32
        let s_948_41: u32 = fn_state.u_31598;
        // D s_948_42: cast zx s_948_41 -> bv
        let s_948_42: Bits = Bits::new(s_948_41 as u128, 32u16);
        // D s_948_43: bit-extract s_948_42 s_948_39 s_948_40
        let s_948_43: Bits = (Bits::new(
            ((s_948_42) >> (s_948_39)).value(),
            u16::try_from(s_948_40).unwrap(),
        ));
        // D s_948_44: cast reint s_948_43 -> u8
        let s_948_44: bool = ((s_948_43.value()) != 0);
        // C s_948_45: const #0s : i
        let s_948_45: i128 = 0;
        // C s_948_46: const #4s : i
        let s_948_46: i128 = 4;
        // D s_948_47: read-var u#31598:u32
        let s_948_47: u32 = fn_state.u_31598;
        // D s_948_48: cast zx s_948_47 -> bv
        let s_948_48: Bits = Bits::new(s_948_47 as u128, 32u16);
        // D s_948_49: bit-extract s_948_48 s_948_45 s_948_46
        let s_948_49: Bits = (Bits::new(
            ((s_948_48) >> (s_948_45)).value(),
            u16::try_from(s_948_46).unwrap(),
        ));
        // D s_948_50: cast reint s_948_49 -> u8
        let s_948_50: u8 = (s_948_49.value() as u8);
        // D s_948_51: call decode_aarch32_instrs_VQRDMLAH_A1enc_A_txt(s_948_8, s_948_14, s_948_20, s_948_26, s_948_32, s_948_38, s_948_44, s_948_50)
        let s_948_51: () = decode_aarch32_instrs_VQRDMLAH_A1enc_A_txt(
            state,
            tracer,
            s_948_8,
            s_948_14,
            s_948_20,
            s_948_26,
            s_948_32,
            s_948_38,
            s_948_44,
            s_948_50,
        );
        // N s_948_52: return
        return;
    }
    fn block_949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_949_0: read-var merge#var.1:struct
        let s_949_0: u32 = fn_state.merge_var._1;
        // D s_949_1: write-var u#31608 <= s_949_0
        fn_state.u_31608 = s_949_0;
        // C s_949_2: const #25s : i
        let s_949_2: i128 = 25;
        // D s_949_3: read-var u#31608:u32
        let s_949_3: u32 = fn_state.u_31608;
        // D s_949_4: cast zx s_949_3 -> bv
        let s_949_4: Bits = Bits::new(s_949_3 as u128, 32u16);
        // C s_949_5: const #1s : i64
        let s_949_5: i64 = 1;
        // C s_949_6: cast zx s_949_5 -> i
        let s_949_6: i128 = (i128::try_from(s_949_5).unwrap());
        // C s_949_7: const #6s : i
        let s_949_7: i128 = 6;
        // C s_949_8: add s_949_7 s_949_6
        let s_949_8: i128 = (s_949_7 + s_949_6);
        // D s_949_9: bit-extract s_949_4 s_949_2 s_949_8
        let s_949_9: Bits = (Bits::new(
            ((s_949_4) >> (s_949_2)).value(),
            u16::try_from(s_949_8).unwrap(),
        ));
        // D s_949_10: cast reint s_949_9 -> u8
        let s_949_10: u8 = (s_949_9.value() as u8);
        // D s_949_11: cast zx s_949_10 -> bv
        let s_949_11: Bits = Bits::new(s_949_10 as u128, 7u16);
        // C s_949_12: const #121u : u8
        let s_949_12: u8 = 121;
        // C s_949_13: cast zx s_949_12 -> bv
        let s_949_13: Bits = Bits::new(s_949_12 as u128, 7u16);
        // D s_949_14: cmp-eq s_949_11 s_949_13
        let s_949_14: bool = ((s_949_11) == (s_949_13));
        // N s_949_15: branch s_949_14 b2214 b950
        if s_949_14 {
            return block_2214(state, tracer, fn_state);
        } else {
            return block_950(state, tracer, fn_state);
        };
    }
    fn block_950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_950_0: const #0u : u8
        let s_950_0: bool = false;
        // D s_950_1: write-var gs#401324 <= s_950_0
        fn_state.gs_401324 = s_950_0;
        // N s_950_2: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_951_0: read-var gs#401324:u8
        let s_951_0: bool = fn_state.gs_401324;
        // N s_951_1: branch s_951_0 b2213 b952
        if s_951_0 {
            return block_2213(state, tracer, fn_state);
        } else {
            return block_952(state, tracer, fn_state);
        };
    }
    fn block_952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_952_0: const #0u : u8
        let s_952_0: bool = false;
        // D s_952_1: write-var gs#401326 <= s_952_0
        fn_state.gs_401326 = s_952_0;
        // N s_952_2: jump b953
        return block_953(state, tracer, fn_state);
    }
    fn block_953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_953_0: read-var gs#401326:u8
        let s_953_0: bool = fn_state.gs_401326;
        // D s_953_1: not s_953_0
        let s_953_1: bool = !s_953_0;
        // N s_953_2: branch s_953_1 b955 b954
        if s_953_1 {
            return block_955(state, tracer, fn_state);
        } else {
            return block_954(state, tracer, fn_state);
        };
    }
    fn block_954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_954_0: const #3629s : i
        let s_954_0: i128 = 3629;
        // C s_954_1: const #14696u : u32
        let s_954_1: u32 = 14696;
        // N s_954_2: write-reg s_954_1 <= s_954_0
        let s_954_2: () = {
            state.write_register::<i128>(s_954_1 as isize, s_954_0);
            tracer.write_register(s_954_1 as isize, s_954_0);
        };
        // C s_954_3: const #24s : i
        let s_954_3: i128 = 24;
        // C s_954_4: const #1s : i
        let s_954_4: i128 = 1;
        // D s_954_5: read-var u#31608:u32
        let s_954_5: u32 = fn_state.u_31608;
        // D s_954_6: cast zx s_954_5 -> bv
        let s_954_6: Bits = Bits::new(s_954_5 as u128, 32u16);
        // D s_954_7: bit-extract s_954_6 s_954_3 s_954_4
        let s_954_7: Bits = (Bits::new(
            ((s_954_6) >> (s_954_3)).value(),
            u16::try_from(s_954_4).unwrap(),
        ));
        // D s_954_8: cast reint s_954_7 -> u8
        let s_954_8: bool = ((s_954_7.value()) != 0);
        // C s_954_9: const #22s : i
        let s_954_9: i128 = 22;
        // C s_954_10: const #1s : i
        let s_954_10: i128 = 1;
        // D s_954_11: read-var u#31608:u32
        let s_954_11: u32 = fn_state.u_31608;
        // D s_954_12: cast zx s_954_11 -> bv
        let s_954_12: Bits = Bits::new(s_954_11 as u128, 32u16);
        // D s_954_13: bit-extract s_954_12 s_954_9 s_954_10
        let s_954_13: Bits = (Bits::new(
            ((s_954_12) >> (s_954_9)).value(),
            u16::try_from(s_954_10).unwrap(),
        ));
        // D s_954_14: cast reint s_954_13 -> u8
        let s_954_14: bool = ((s_954_13.value()) != 0);
        // C s_954_15: const #20s : i
        let s_954_15: i128 = 20;
        // C s_954_16: const #2s : i
        let s_954_16: i128 = 2;
        // D s_954_17: read-var u#31608:u32
        let s_954_17: u32 = fn_state.u_31608;
        // D s_954_18: cast zx s_954_17 -> bv
        let s_954_18: Bits = Bits::new(s_954_17 as u128, 32u16);
        // D s_954_19: bit-extract s_954_18 s_954_15 s_954_16
        let s_954_19: Bits = (Bits::new(
            ((s_954_18) >> (s_954_15)).value(),
            u16::try_from(s_954_16).unwrap(),
        ));
        // D s_954_20: cast reint s_954_19 -> u8
        let s_954_20: u8 = (s_954_19.value() as u8);
        // C s_954_21: const #16s : i
        let s_954_21: i128 = 16;
        // C s_954_22: const #4s : i
        let s_954_22: i128 = 4;
        // D s_954_23: read-var u#31608:u32
        let s_954_23: u32 = fn_state.u_31608;
        // D s_954_24: cast zx s_954_23 -> bv
        let s_954_24: Bits = Bits::new(s_954_23 as u128, 32u16);
        // D s_954_25: bit-extract s_954_24 s_954_21 s_954_22
        let s_954_25: Bits = (Bits::new(
            ((s_954_24) >> (s_954_21)).value(),
            u16::try_from(s_954_22).unwrap(),
        ));
        // D s_954_26: cast reint s_954_25 -> u8
        let s_954_26: u8 = (s_954_25.value() as u8);
        // C s_954_27: const #12s : i
        let s_954_27: i128 = 12;
        // C s_954_28: const #4s : i
        let s_954_28: i128 = 4;
        // D s_954_29: read-var u#31608:u32
        let s_954_29: u32 = fn_state.u_31608;
        // D s_954_30: cast zx s_954_29 -> bv
        let s_954_30: Bits = Bits::new(s_954_29 as u128, 32u16);
        // D s_954_31: bit-extract s_954_30 s_954_27 s_954_28
        let s_954_31: Bits = (Bits::new(
            ((s_954_30) >> (s_954_27)).value(),
            u16::try_from(s_954_28).unwrap(),
        ));
        // D s_954_32: cast reint s_954_31 -> u8
        let s_954_32: u8 = (s_954_31.value() as u8);
        // C s_954_33: const #7s : i
        let s_954_33: i128 = 7;
        // C s_954_34: const #1s : i
        let s_954_34: i128 = 1;
        // D s_954_35: read-var u#31608:u32
        let s_954_35: u32 = fn_state.u_31608;
        // D s_954_36: cast zx s_954_35 -> bv
        let s_954_36: Bits = Bits::new(s_954_35 as u128, 32u16);
        // D s_954_37: bit-extract s_954_36 s_954_33 s_954_34
        let s_954_37: Bits = (Bits::new(
            ((s_954_36) >> (s_954_33)).value(),
            u16::try_from(s_954_34).unwrap(),
        ));
        // D s_954_38: cast reint s_954_37 -> u8
        let s_954_38: bool = ((s_954_37.value()) != 0);
        // C s_954_39: const #5s : i
        let s_954_39: i128 = 5;
        // C s_954_40: const #1s : i
        let s_954_40: i128 = 1;
        // D s_954_41: read-var u#31608:u32
        let s_954_41: u32 = fn_state.u_31608;
        // D s_954_42: cast zx s_954_41 -> bv
        let s_954_42: Bits = Bits::new(s_954_41 as u128, 32u16);
        // D s_954_43: bit-extract s_954_42 s_954_39 s_954_40
        let s_954_43: Bits = (Bits::new(
            ((s_954_42) >> (s_954_39)).value(),
            u16::try_from(s_954_40).unwrap(),
        ));
        // D s_954_44: cast reint s_954_43 -> u8
        let s_954_44: bool = ((s_954_43.value()) != 0);
        // C s_954_45: const #0s : i
        let s_954_45: i128 = 0;
        // C s_954_46: const #4s : i
        let s_954_46: i128 = 4;
        // D s_954_47: read-var u#31608:u32
        let s_954_47: u32 = fn_state.u_31608;
        // D s_954_48: cast zx s_954_47 -> bv
        let s_954_48: Bits = Bits::new(s_954_47 as u128, 32u16);
        // D s_954_49: bit-extract s_954_48 s_954_45 s_954_46
        let s_954_49: Bits = (Bits::new(
            ((s_954_48) >> (s_954_45)).value(),
            u16::try_from(s_954_46).unwrap(),
        ));
        // D s_954_50: cast reint s_954_49 -> u8
        let s_954_50: u8 = (s_954_49.value() as u8);
        // D s_954_51: call decode_aarch32_instrs_VQRDMLAH_A2enc_A_txt(s_954_8, s_954_14, s_954_20, s_954_26, s_954_32, s_954_38, s_954_44, s_954_50)
        let s_954_51: () = decode_aarch32_instrs_VQRDMLAH_A2enc_A_txt(
            state,
            tracer,
            s_954_8,
            s_954_14,
            s_954_20,
            s_954_26,
            s_954_32,
            s_954_38,
            s_954_44,
            s_954_50,
        );
        // N s_954_52: return
        return;
    }
    fn block_955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_955_0: read-var merge#var.1:struct
        let s_955_0: u32 = fn_state.merge_var._1;
        // D s_955_1: write-var u#31618 <= s_955_0
        fn_state.u_31618 = s_955_0;
        // C s_955_2: const #23s : i
        let s_955_2: i128 = 23;
        // D s_955_3: read-var u#31618:u32
        let s_955_3: u32 = fn_state.u_31618;
        // D s_955_4: cast zx s_955_3 -> bv
        let s_955_4: Bits = Bits::new(s_955_3 as u128, 32u16);
        // C s_955_5: const #1s : i64
        let s_955_5: i64 = 1;
        // C s_955_6: cast zx s_955_5 -> i
        let s_955_6: i128 = (i128::try_from(s_955_5).unwrap());
        // C s_955_7: const #8s : i
        let s_955_7: i128 = 8;
        // C s_955_8: add s_955_7 s_955_6
        let s_955_8: i128 = (s_955_7 + s_955_6);
        // D s_955_9: bit-extract s_955_4 s_955_2 s_955_8
        let s_955_9: Bits = (Bits::new(
            ((s_955_4) >> (s_955_2)).value(),
            u16::try_from(s_955_8).unwrap(),
        ));
        // D s_955_10: cast reint s_955_9 -> u9
        let s_955_10: u16 = (s_955_9.value() as u16);
        // D s_955_11: cast zx s_955_10 -> bv
        let s_955_11: Bits = Bits::new(s_955_10 as u128, 9u16);
        // C s_955_12: const #486u : u9
        let s_955_12: u16 = 486;
        // C s_955_13: cast zx s_955_12 -> bv
        let s_955_13: Bits = Bits::new(s_955_12 as u128, 9u16);
        // D s_955_14: cmp-eq s_955_11 s_955_13
        let s_955_14: bool = ((s_955_11) == (s_955_13));
        // N s_955_15: branch s_955_14 b2209 b956
        if s_955_14 {
            return block_2209(state, tracer, fn_state);
        } else {
            return block_956(state, tracer, fn_state);
        };
    }
    fn block_956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_956_0: const #0u : u8
        let s_956_0: bool = false;
        // D s_956_1: write-var gs#401353 <= s_956_0
        fn_state.gs_401353 = s_956_0;
        // N s_956_2: jump b957
        return block_957(state, tracer, fn_state);
    }
    fn block_957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_957_0: read-var gs#401353:u8
        let s_957_0: bool = fn_state.gs_401353;
        // N s_957_1: branch s_957_0 b2208 b958
        if s_957_0 {
            return block_2208(state, tracer, fn_state);
        } else {
            return block_958(state, tracer, fn_state);
        };
    }
    fn block_958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_958_0: const #0u : u8
        let s_958_0: bool = false;
        // D s_958_1: write-var gs#401355 <= s_958_0
        fn_state.gs_401355 = s_958_0;
        // N s_958_2: jump b959
        return block_959(state, tracer, fn_state);
    }
    fn block_959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_959_0: read-var gs#401355:u8
        let s_959_0: bool = fn_state.gs_401355;
        // D s_959_1: not s_959_0
        let s_959_1: bool = !s_959_0;
        // N s_959_2: branch s_959_1 b961 b960
        if s_959_1 {
            return block_961(state, tracer, fn_state);
        } else {
            return block_960(state, tracer, fn_state);
        };
    }
    fn block_960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_960_0: const #3632s : i
        let s_960_0: i128 = 3632;
        // C s_960_1: const #14696u : u32
        let s_960_1: u32 = 14696;
        // N s_960_2: write-reg s_960_1 <= s_960_0
        let s_960_2: () = {
            state.write_register::<i128>(s_960_1 as isize, s_960_0);
            tracer.write_register(s_960_1 as isize, s_960_0);
        };
        // C s_960_3: const #22s : i
        let s_960_3: i128 = 22;
        // C s_960_4: const #1s : i
        let s_960_4: i128 = 1;
        // D s_960_5: read-var u#31618:u32
        let s_960_5: u32 = fn_state.u_31618;
        // D s_960_6: cast zx s_960_5 -> bv
        let s_960_6: Bits = Bits::new(s_960_5 as u128, 32u16);
        // D s_960_7: bit-extract s_960_6 s_960_3 s_960_4
        let s_960_7: Bits = (Bits::new(
            ((s_960_6) >> (s_960_3)).value(),
            u16::try_from(s_960_4).unwrap(),
        ));
        // D s_960_8: cast reint s_960_7 -> u8
        let s_960_8: bool = ((s_960_7.value()) != 0);
        // C s_960_9: const #20s : i
        let s_960_9: i128 = 20;
        // C s_960_10: const #2s : i
        let s_960_10: i128 = 2;
        // D s_960_11: read-var u#31618:u32
        let s_960_11: u32 = fn_state.u_31618;
        // D s_960_12: cast zx s_960_11 -> bv
        let s_960_12: Bits = Bits::new(s_960_11 as u128, 32u16);
        // D s_960_13: bit-extract s_960_12 s_960_9 s_960_10
        let s_960_13: Bits = (Bits::new(
            ((s_960_12) >> (s_960_9)).value(),
            u16::try_from(s_960_10).unwrap(),
        ));
        // D s_960_14: cast reint s_960_13 -> u8
        let s_960_14: u8 = (s_960_13.value() as u8);
        // C s_960_15: const #16s : i
        let s_960_15: i128 = 16;
        // C s_960_16: const #4s : i
        let s_960_16: i128 = 4;
        // D s_960_17: read-var u#31618:u32
        let s_960_17: u32 = fn_state.u_31618;
        // D s_960_18: cast zx s_960_17 -> bv
        let s_960_18: Bits = Bits::new(s_960_17 as u128, 32u16);
        // D s_960_19: bit-extract s_960_18 s_960_15 s_960_16
        let s_960_19: Bits = (Bits::new(
            ((s_960_18) >> (s_960_15)).value(),
            u16::try_from(s_960_16).unwrap(),
        ));
        // D s_960_20: cast reint s_960_19 -> u8
        let s_960_20: u8 = (s_960_19.value() as u8);
        // C s_960_21: const #12s : i
        let s_960_21: i128 = 12;
        // C s_960_22: const #4s : i
        let s_960_22: i128 = 4;
        // D s_960_23: read-var u#31618:u32
        let s_960_23: u32 = fn_state.u_31618;
        // D s_960_24: cast zx s_960_23 -> bv
        let s_960_24: Bits = Bits::new(s_960_23 as u128, 32u16);
        // D s_960_25: bit-extract s_960_24 s_960_21 s_960_22
        let s_960_25: Bits = (Bits::new(
            ((s_960_24) >> (s_960_21)).value(),
            u16::try_from(s_960_22).unwrap(),
        ));
        // D s_960_26: cast reint s_960_25 -> u8
        let s_960_26: u8 = (s_960_25.value() as u8);
        // C s_960_27: const #7s : i
        let s_960_27: i128 = 7;
        // C s_960_28: const #1s : i
        let s_960_28: i128 = 1;
        // D s_960_29: read-var u#31618:u32
        let s_960_29: u32 = fn_state.u_31618;
        // D s_960_30: cast zx s_960_29 -> bv
        let s_960_30: Bits = Bits::new(s_960_29 as u128, 32u16);
        // D s_960_31: bit-extract s_960_30 s_960_27 s_960_28
        let s_960_31: Bits = (Bits::new(
            ((s_960_30) >> (s_960_27)).value(),
            u16::try_from(s_960_28).unwrap(),
        ));
        // D s_960_32: cast reint s_960_31 -> u8
        let s_960_32: bool = ((s_960_31.value()) != 0);
        // C s_960_33: const #6s : i
        let s_960_33: i128 = 6;
        // C s_960_34: const #1s : i
        let s_960_34: i128 = 1;
        // D s_960_35: read-var u#31618:u32
        let s_960_35: u32 = fn_state.u_31618;
        // D s_960_36: cast zx s_960_35 -> bv
        let s_960_36: Bits = Bits::new(s_960_35 as u128, 32u16);
        // D s_960_37: bit-extract s_960_36 s_960_33 s_960_34
        let s_960_37: Bits = (Bits::new(
            ((s_960_36) >> (s_960_33)).value(),
            u16::try_from(s_960_34).unwrap(),
        ));
        // D s_960_38: cast reint s_960_37 -> u8
        let s_960_38: bool = ((s_960_37.value()) != 0);
        // C s_960_39: const #5s : i
        let s_960_39: i128 = 5;
        // C s_960_40: const #1s : i
        let s_960_40: i128 = 1;
        // D s_960_41: read-var u#31618:u32
        let s_960_41: u32 = fn_state.u_31618;
        // D s_960_42: cast zx s_960_41 -> bv
        let s_960_42: Bits = Bits::new(s_960_41 as u128, 32u16);
        // D s_960_43: bit-extract s_960_42 s_960_39 s_960_40
        let s_960_43: Bits = (Bits::new(
            ((s_960_42) >> (s_960_39)).value(),
            u16::try_from(s_960_40).unwrap(),
        ));
        // D s_960_44: cast reint s_960_43 -> u8
        let s_960_44: bool = ((s_960_43.value()) != 0);
        // C s_960_45: const #0s : i
        let s_960_45: i128 = 0;
        // C s_960_46: const #4s : i
        let s_960_46: i128 = 4;
        // D s_960_47: read-var u#31618:u32
        let s_960_47: u32 = fn_state.u_31618;
        // D s_960_48: cast zx s_960_47 -> bv
        let s_960_48: Bits = Bits::new(s_960_47 as u128, 32u16);
        // D s_960_49: bit-extract s_960_48 s_960_45 s_960_46
        let s_960_49: Bits = (Bits::new(
            ((s_960_48) >> (s_960_45)).value(),
            u16::try_from(s_960_46).unwrap(),
        ));
        // D s_960_50: cast reint s_960_49 -> u8
        let s_960_50: u8 = (s_960_49.value() as u8);
        // D s_960_51: call decode_aarch32_instrs_VQRDMLSH_A1enc_A_txt(s_960_8, s_960_14, s_960_20, s_960_26, s_960_32, s_960_38, s_960_44, s_960_50)
        let s_960_51: () = decode_aarch32_instrs_VQRDMLSH_A1enc_A_txt(
            state,
            tracer,
            s_960_8,
            s_960_14,
            s_960_20,
            s_960_26,
            s_960_32,
            s_960_38,
            s_960_44,
            s_960_50,
        );
        // N s_960_52: return
        return;
    }
    fn block_961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_961_0: read-var merge#var.1:struct
        let s_961_0: u32 = fn_state.merge_var._1;
        // D s_961_1: write-var u#31628 <= s_961_0
        fn_state.u_31628 = s_961_0;
        // C s_961_2: const #25s : i
        let s_961_2: i128 = 25;
        // D s_961_3: read-var u#31628:u32
        let s_961_3: u32 = fn_state.u_31628;
        // D s_961_4: cast zx s_961_3 -> bv
        let s_961_4: Bits = Bits::new(s_961_3 as u128, 32u16);
        // C s_961_5: const #1s : i64
        let s_961_5: i64 = 1;
        // C s_961_6: cast zx s_961_5 -> i
        let s_961_6: i128 = (i128::try_from(s_961_5).unwrap());
        // C s_961_7: const #6s : i
        let s_961_7: i128 = 6;
        // C s_961_8: add s_961_7 s_961_6
        let s_961_8: i128 = (s_961_7 + s_961_6);
        // D s_961_9: bit-extract s_961_4 s_961_2 s_961_8
        let s_961_9: Bits = (Bits::new(
            ((s_961_4) >> (s_961_2)).value(),
            u16::try_from(s_961_8).unwrap(),
        ));
        // D s_961_10: cast reint s_961_9 -> u8
        let s_961_10: u8 = (s_961_9.value() as u8);
        // D s_961_11: cast zx s_961_10 -> bv
        let s_961_11: Bits = Bits::new(s_961_10 as u128, 7u16);
        // C s_961_12: const #121u : u8
        let s_961_12: u8 = 121;
        // C s_961_13: cast zx s_961_12 -> bv
        let s_961_13: Bits = Bits::new(s_961_12 as u128, 7u16);
        // D s_961_14: cmp-eq s_961_11 s_961_13
        let s_961_14: bool = ((s_961_11) == (s_961_13));
        // N s_961_15: branch s_961_14 b2198 b962
        if s_961_14 {
            return block_2198(state, tracer, fn_state);
        } else {
            return block_962(state, tracer, fn_state);
        };
    }
    fn block_962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_962_0: const #0u : u8
        let s_962_0: bool = false;
        // D s_962_1: write-var gs#401388 <= s_962_0
        fn_state.gs_401388 = s_962_0;
        // N s_962_2: jump b963
        return block_963(state, tracer, fn_state);
    }
    fn block_963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_963_0: read-var gs#401388:u8
        let s_963_0: bool = fn_state.gs_401388;
        // N s_963_1: branch s_963_0 b2197 b964
        if s_963_0 {
            return block_2197(state, tracer, fn_state);
        } else {
            return block_964(state, tracer, fn_state);
        };
    }
    fn block_964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_964_0: const #0u : u8
        let s_964_0: bool = false;
        // D s_964_1: write-var gs#401390 <= s_964_0
        fn_state.gs_401390 = s_964_0;
        // N s_964_2: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_965_0: read-var gs#401390:u8
        let s_965_0: bool = fn_state.gs_401390;
        // D s_965_1: not s_965_0
        let s_965_1: bool = !s_965_0;
        // N s_965_2: branch s_965_1 b967 b966
        if s_965_1 {
            return block_967(state, tracer, fn_state);
        } else {
            return block_966(state, tracer, fn_state);
        };
    }
    fn block_966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_966_0: const #3633s : i
        let s_966_0: i128 = 3633;
        // C s_966_1: const #14696u : u32
        let s_966_1: u32 = 14696;
        // N s_966_2: write-reg s_966_1 <= s_966_0
        let s_966_2: () = {
            state.write_register::<i128>(s_966_1 as isize, s_966_0);
            tracer.write_register(s_966_1 as isize, s_966_0);
        };
        // C s_966_3: const #24s : i
        let s_966_3: i128 = 24;
        // C s_966_4: const #1s : i
        let s_966_4: i128 = 1;
        // D s_966_5: read-var u#31628:u32
        let s_966_5: u32 = fn_state.u_31628;
        // D s_966_6: cast zx s_966_5 -> bv
        let s_966_6: Bits = Bits::new(s_966_5 as u128, 32u16);
        // D s_966_7: bit-extract s_966_6 s_966_3 s_966_4
        let s_966_7: Bits = (Bits::new(
            ((s_966_6) >> (s_966_3)).value(),
            u16::try_from(s_966_4).unwrap(),
        ));
        // D s_966_8: cast reint s_966_7 -> u8
        let s_966_8: bool = ((s_966_7.value()) != 0);
        // C s_966_9: const #22s : i
        let s_966_9: i128 = 22;
        // C s_966_10: const #1s : i
        let s_966_10: i128 = 1;
        // D s_966_11: read-var u#31628:u32
        let s_966_11: u32 = fn_state.u_31628;
        // D s_966_12: cast zx s_966_11 -> bv
        let s_966_12: Bits = Bits::new(s_966_11 as u128, 32u16);
        // D s_966_13: bit-extract s_966_12 s_966_9 s_966_10
        let s_966_13: Bits = (Bits::new(
            ((s_966_12) >> (s_966_9)).value(),
            u16::try_from(s_966_10).unwrap(),
        ));
        // D s_966_14: cast reint s_966_13 -> u8
        let s_966_14: bool = ((s_966_13.value()) != 0);
        // C s_966_15: const #20s : i
        let s_966_15: i128 = 20;
        // C s_966_16: const #2s : i
        let s_966_16: i128 = 2;
        // D s_966_17: read-var u#31628:u32
        let s_966_17: u32 = fn_state.u_31628;
        // D s_966_18: cast zx s_966_17 -> bv
        let s_966_18: Bits = Bits::new(s_966_17 as u128, 32u16);
        // D s_966_19: bit-extract s_966_18 s_966_15 s_966_16
        let s_966_19: Bits = (Bits::new(
            ((s_966_18) >> (s_966_15)).value(),
            u16::try_from(s_966_16).unwrap(),
        ));
        // D s_966_20: cast reint s_966_19 -> u8
        let s_966_20: u8 = (s_966_19.value() as u8);
        // C s_966_21: const #16s : i
        let s_966_21: i128 = 16;
        // C s_966_22: const #4s : i
        let s_966_22: i128 = 4;
        // D s_966_23: read-var u#31628:u32
        let s_966_23: u32 = fn_state.u_31628;
        // D s_966_24: cast zx s_966_23 -> bv
        let s_966_24: Bits = Bits::new(s_966_23 as u128, 32u16);
        // D s_966_25: bit-extract s_966_24 s_966_21 s_966_22
        let s_966_25: Bits = (Bits::new(
            ((s_966_24) >> (s_966_21)).value(),
            u16::try_from(s_966_22).unwrap(),
        ));
        // D s_966_26: cast reint s_966_25 -> u8
        let s_966_26: u8 = (s_966_25.value() as u8);
        // C s_966_27: const #12s : i
        let s_966_27: i128 = 12;
        // C s_966_28: const #4s : i
        let s_966_28: i128 = 4;
        // D s_966_29: read-var u#31628:u32
        let s_966_29: u32 = fn_state.u_31628;
        // D s_966_30: cast zx s_966_29 -> bv
        let s_966_30: Bits = Bits::new(s_966_29 as u128, 32u16);
        // D s_966_31: bit-extract s_966_30 s_966_27 s_966_28
        let s_966_31: Bits = (Bits::new(
            ((s_966_30) >> (s_966_27)).value(),
            u16::try_from(s_966_28).unwrap(),
        ));
        // D s_966_32: cast reint s_966_31 -> u8
        let s_966_32: u8 = (s_966_31.value() as u8);
        // C s_966_33: const #7s : i
        let s_966_33: i128 = 7;
        // C s_966_34: const #1s : i
        let s_966_34: i128 = 1;
        // D s_966_35: read-var u#31628:u32
        let s_966_35: u32 = fn_state.u_31628;
        // D s_966_36: cast zx s_966_35 -> bv
        let s_966_36: Bits = Bits::new(s_966_35 as u128, 32u16);
        // D s_966_37: bit-extract s_966_36 s_966_33 s_966_34
        let s_966_37: Bits = (Bits::new(
            ((s_966_36) >> (s_966_33)).value(),
            u16::try_from(s_966_34).unwrap(),
        ));
        // D s_966_38: cast reint s_966_37 -> u8
        let s_966_38: bool = ((s_966_37.value()) != 0);
        // C s_966_39: const #5s : i
        let s_966_39: i128 = 5;
        // C s_966_40: const #1s : i
        let s_966_40: i128 = 1;
        // D s_966_41: read-var u#31628:u32
        let s_966_41: u32 = fn_state.u_31628;
        // D s_966_42: cast zx s_966_41 -> bv
        let s_966_42: Bits = Bits::new(s_966_41 as u128, 32u16);
        // D s_966_43: bit-extract s_966_42 s_966_39 s_966_40
        let s_966_43: Bits = (Bits::new(
            ((s_966_42) >> (s_966_39)).value(),
            u16::try_from(s_966_40).unwrap(),
        ));
        // D s_966_44: cast reint s_966_43 -> u8
        let s_966_44: bool = ((s_966_43.value()) != 0);
        // C s_966_45: const #0s : i
        let s_966_45: i128 = 0;
        // C s_966_46: const #4s : i
        let s_966_46: i128 = 4;
        // D s_966_47: read-var u#31628:u32
        let s_966_47: u32 = fn_state.u_31628;
        // D s_966_48: cast zx s_966_47 -> bv
        let s_966_48: Bits = Bits::new(s_966_47 as u128, 32u16);
        // D s_966_49: bit-extract s_966_48 s_966_45 s_966_46
        let s_966_49: Bits = (Bits::new(
            ((s_966_48) >> (s_966_45)).value(),
            u16::try_from(s_966_46).unwrap(),
        ));
        // D s_966_50: cast reint s_966_49 -> u8
        let s_966_50: u8 = (s_966_49.value() as u8);
        // D s_966_51: call decode_aarch32_instrs_VQRDMLSH_A2enc_A_txt(s_966_8, s_966_14, s_966_20, s_966_26, s_966_32, s_966_38, s_966_44, s_966_50)
        let s_966_51: () = decode_aarch32_instrs_VQRDMLSH_A2enc_A_txt(
            state,
            tracer,
            s_966_8,
            s_966_14,
            s_966_20,
            s_966_26,
            s_966_32,
            s_966_38,
            s_966_44,
            s_966_50,
        );
        // N s_966_52: return
        return;
    }
    fn block_967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_967_0: read-var merge#var.1:struct
        let s_967_0: u32 = fn_state.merge_var._1;
        // D s_967_1: write-var u#31638 <= s_967_0
        fn_state.u_31638 = s_967_0;
        // C s_967_2: const #25s : i
        let s_967_2: i128 = 25;
        // D s_967_3: read-var u#31638:u32
        let s_967_3: u32 = fn_state.u_31638;
        // D s_967_4: cast zx s_967_3 -> bv
        let s_967_4: Bits = Bits::new(s_967_3 as u128, 32u16);
        // C s_967_5: const #1s : i64
        let s_967_5: i64 = 1;
        // C s_967_6: cast zx s_967_5 -> i
        let s_967_6: i128 = (i128::try_from(s_967_5).unwrap());
        // C s_967_7: const #6s : i
        let s_967_7: i128 = 6;
        // C s_967_8: add s_967_7 s_967_6
        let s_967_8: i128 = (s_967_7 + s_967_6);
        // D s_967_9: bit-extract s_967_4 s_967_2 s_967_8
        let s_967_9: Bits = (Bits::new(
            ((s_967_4) >> (s_967_2)).value(),
            u16::try_from(s_967_8).unwrap(),
        ));
        // D s_967_10: cast reint s_967_9 -> u8
        let s_967_10: u8 = (s_967_9.value() as u8);
        // D s_967_11: cast zx s_967_10 -> bv
        let s_967_11: Bits = Bits::new(s_967_10 as u128, 7u16);
        // C s_967_12: const #121u : u8
        let s_967_12: u8 = 121;
        // C s_967_13: cast zx s_967_12 -> bv
        let s_967_13: Bits = Bits::new(s_967_12 as u128, 7u16);
        // D s_967_14: cmp-eq s_967_11 s_967_13
        let s_967_14: bool = ((s_967_11) == (s_967_13));
        // N s_967_15: branch s_967_14 b2190 b968
        if s_967_14 {
            return block_2190(state, tracer, fn_state);
        } else {
            return block_968(state, tracer, fn_state);
        };
    }
    fn block_968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_968_0: const #0u : u8
        let s_968_0: bool = false;
        // D s_968_1: write-var gs#401420 <= s_968_0
        fn_state.gs_401420 = s_968_0;
        // N s_968_2: jump b969
        return block_969(state, tracer, fn_state);
    }
    fn block_969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_969_0: read-var gs#401420:u8
        let s_969_0: bool = fn_state.gs_401420;
        // N s_969_1: branch s_969_0 b2189 b970
        if s_969_0 {
            return block_2189(state, tracer, fn_state);
        } else {
            return block_970(state, tracer, fn_state);
        };
    }
    fn block_970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_970_0: const #0u : u8
        let s_970_0: bool = false;
        // D s_970_1: write-var gs#401422 <= s_970_0
        fn_state.gs_401422 = s_970_0;
        // N s_970_2: jump b971
        return block_971(state, tracer, fn_state);
    }
    fn block_971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_971_0: read-var gs#401422:u8
        let s_971_0: bool = fn_state.gs_401422;
        // D s_971_1: not s_971_0
        let s_971_1: bool = !s_971_0;
        // N s_971_2: branch s_971_1 b973 b972
        if s_971_1 {
            return block_973(state, tracer, fn_state);
        } else {
            return block_972(state, tracer, fn_state);
        };
    }
    fn block_972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_972_0: const #3636s : i
        let s_972_0: i128 = 3636;
        // C s_972_1: const #14696u : u32
        let s_972_1: u32 = 14696;
        // N s_972_2: write-reg s_972_1 <= s_972_0
        let s_972_2: () = {
            state.write_register::<i128>(s_972_1 as isize, s_972_0);
            tracer.write_register(s_972_1 as isize, s_972_0);
        };
        // C s_972_3: const #24s : i
        let s_972_3: i128 = 24;
        // C s_972_4: const #1s : i
        let s_972_4: i128 = 1;
        // D s_972_5: read-var u#31638:u32
        let s_972_5: u32 = fn_state.u_31638;
        // D s_972_6: cast zx s_972_5 -> bv
        let s_972_6: Bits = Bits::new(s_972_5 as u128, 32u16);
        // D s_972_7: bit-extract s_972_6 s_972_3 s_972_4
        let s_972_7: Bits = (Bits::new(
            ((s_972_6) >> (s_972_3)).value(),
            u16::try_from(s_972_4).unwrap(),
        ));
        // D s_972_8: cast reint s_972_7 -> u8
        let s_972_8: bool = ((s_972_7.value()) != 0);
        // C s_972_9: const #22s : i
        let s_972_9: i128 = 22;
        // C s_972_10: const #1s : i
        let s_972_10: i128 = 1;
        // D s_972_11: read-var u#31638:u32
        let s_972_11: u32 = fn_state.u_31638;
        // D s_972_12: cast zx s_972_11 -> bv
        let s_972_12: Bits = Bits::new(s_972_11 as u128, 32u16);
        // D s_972_13: bit-extract s_972_12 s_972_9 s_972_10
        let s_972_13: Bits = (Bits::new(
            ((s_972_12) >> (s_972_9)).value(),
            u16::try_from(s_972_10).unwrap(),
        ));
        // D s_972_14: cast reint s_972_13 -> u8
        let s_972_14: bool = ((s_972_13.value()) != 0);
        // C s_972_15: const #20s : i
        let s_972_15: i128 = 20;
        // C s_972_16: const #2s : i
        let s_972_16: i128 = 2;
        // D s_972_17: read-var u#31638:u32
        let s_972_17: u32 = fn_state.u_31638;
        // D s_972_18: cast zx s_972_17 -> bv
        let s_972_18: Bits = Bits::new(s_972_17 as u128, 32u16);
        // D s_972_19: bit-extract s_972_18 s_972_15 s_972_16
        let s_972_19: Bits = (Bits::new(
            ((s_972_18) >> (s_972_15)).value(),
            u16::try_from(s_972_16).unwrap(),
        ));
        // D s_972_20: cast reint s_972_19 -> u8
        let s_972_20: u8 = (s_972_19.value() as u8);
        // C s_972_21: const #16s : i
        let s_972_21: i128 = 16;
        // C s_972_22: const #4s : i
        let s_972_22: i128 = 4;
        // D s_972_23: read-var u#31638:u32
        let s_972_23: u32 = fn_state.u_31638;
        // D s_972_24: cast zx s_972_23 -> bv
        let s_972_24: Bits = Bits::new(s_972_23 as u128, 32u16);
        // D s_972_25: bit-extract s_972_24 s_972_21 s_972_22
        let s_972_25: Bits = (Bits::new(
            ((s_972_24) >> (s_972_21)).value(),
            u16::try_from(s_972_22).unwrap(),
        ));
        // D s_972_26: cast reint s_972_25 -> u8
        let s_972_26: u8 = (s_972_25.value() as u8);
        // C s_972_27: const #12s : i
        let s_972_27: i128 = 12;
        // C s_972_28: const #4s : i
        let s_972_28: i128 = 4;
        // D s_972_29: read-var u#31638:u32
        let s_972_29: u32 = fn_state.u_31638;
        // D s_972_30: cast zx s_972_29 -> bv
        let s_972_30: Bits = Bits::new(s_972_29 as u128, 32u16);
        // D s_972_31: bit-extract s_972_30 s_972_27 s_972_28
        let s_972_31: Bits = (Bits::new(
            ((s_972_30) >> (s_972_27)).value(),
            u16::try_from(s_972_28).unwrap(),
        ));
        // D s_972_32: cast reint s_972_31 -> u8
        let s_972_32: u8 = (s_972_31.value() as u8);
        // C s_972_33: const #7s : i
        let s_972_33: i128 = 7;
        // C s_972_34: const #1s : i
        let s_972_34: i128 = 1;
        // D s_972_35: read-var u#31638:u32
        let s_972_35: u32 = fn_state.u_31638;
        // D s_972_36: cast zx s_972_35 -> bv
        let s_972_36: Bits = Bits::new(s_972_35 as u128, 32u16);
        // D s_972_37: bit-extract s_972_36 s_972_33 s_972_34
        let s_972_37: Bits = (Bits::new(
            ((s_972_36) >> (s_972_33)).value(),
            u16::try_from(s_972_34).unwrap(),
        ));
        // D s_972_38: cast reint s_972_37 -> u8
        let s_972_38: bool = ((s_972_37.value()) != 0);
        // C s_972_39: const #6s : i
        let s_972_39: i128 = 6;
        // C s_972_40: const #1s : i
        let s_972_40: i128 = 1;
        // D s_972_41: read-var u#31638:u32
        let s_972_41: u32 = fn_state.u_31638;
        // D s_972_42: cast zx s_972_41 -> bv
        let s_972_42: Bits = Bits::new(s_972_41 as u128, 32u16);
        // D s_972_43: bit-extract s_972_42 s_972_39 s_972_40
        let s_972_43: Bits = (Bits::new(
            ((s_972_42) >> (s_972_39)).value(),
            u16::try_from(s_972_40).unwrap(),
        ));
        // D s_972_44: cast reint s_972_43 -> u8
        let s_972_44: bool = ((s_972_43.value()) != 0);
        // C s_972_45: const #5s : i
        let s_972_45: i128 = 5;
        // C s_972_46: const #1s : i
        let s_972_46: i128 = 1;
        // D s_972_47: read-var u#31638:u32
        let s_972_47: u32 = fn_state.u_31638;
        // D s_972_48: cast zx s_972_47 -> bv
        let s_972_48: Bits = Bits::new(s_972_47 as u128, 32u16);
        // D s_972_49: bit-extract s_972_48 s_972_45 s_972_46
        let s_972_49: Bits = (Bits::new(
            ((s_972_48) >> (s_972_45)).value(),
            u16::try_from(s_972_46).unwrap(),
        ));
        // D s_972_50: cast reint s_972_49 -> u8
        let s_972_50: bool = ((s_972_49.value()) != 0);
        // C s_972_51: const #0s : i
        let s_972_51: i128 = 0;
        // C s_972_52: const #4s : i
        let s_972_52: i128 = 4;
        // D s_972_53: read-var u#31638:u32
        let s_972_53: u32 = fn_state.u_31638;
        // D s_972_54: cast zx s_972_53 -> bv
        let s_972_54: Bits = Bits::new(s_972_53 as u128, 32u16);
        // D s_972_55: bit-extract s_972_54 s_972_51 s_972_52
        let s_972_55: Bits = (Bits::new(
            ((s_972_54) >> (s_972_51)).value(),
            u16::try_from(s_972_52).unwrap(),
        ));
        // D s_972_56: cast reint s_972_55 -> u8
        let s_972_56: u8 = (s_972_55.value() as u8);
        // D s_972_57: call decode_aarch32_instrs_VQRSHL_A1enc_A_txt(s_972_8, s_972_14, s_972_20, s_972_26, s_972_32, s_972_38, s_972_44, s_972_50, s_972_56)
        let s_972_57: () = decode_aarch32_instrs_VQRSHL_A1enc_A_txt(
            state,
            tracer,
            s_972_8,
            s_972_14,
            s_972_20,
            s_972_26,
            s_972_32,
            s_972_38,
            s_972_44,
            s_972_50,
            s_972_56,
        );
        // N s_972_58: return
        return;
    }
    fn block_973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_973_0: read-var merge#var.1:struct
        let s_973_0: u32 = fn_state.merge_var._1;
        // D s_973_1: write-var u#31649 <= s_973_0
        fn_state.u_31649 = s_973_0;
        // C s_973_2: const #25s : i
        let s_973_2: i128 = 25;
        // D s_973_3: read-var u#31649:u32
        let s_973_3: u32 = fn_state.u_31649;
        // D s_973_4: cast zx s_973_3 -> bv
        let s_973_4: Bits = Bits::new(s_973_3 as u128, 32u16);
        // C s_973_5: const #1s : i64
        let s_973_5: i64 = 1;
        // C s_973_6: cast zx s_973_5 -> i
        let s_973_6: i128 = (i128::try_from(s_973_5).unwrap());
        // C s_973_7: const #6s : i
        let s_973_7: i128 = 6;
        // C s_973_8: add s_973_7 s_973_6
        let s_973_8: i128 = (s_973_7 + s_973_6);
        // D s_973_9: bit-extract s_973_4 s_973_2 s_973_8
        let s_973_9: Bits = (Bits::new(
            ((s_973_4) >> (s_973_2)).value(),
            u16::try_from(s_973_8).unwrap(),
        ));
        // D s_973_10: cast reint s_973_9 -> u8
        let s_973_10: u8 = (s_973_9.value() as u8);
        // D s_973_11: cast zx s_973_10 -> bv
        let s_973_11: Bits = Bits::new(s_973_10 as u128, 7u16);
        // C s_973_12: const #121u : u8
        let s_973_12: u8 = 121;
        // C s_973_13: cast zx s_973_12 -> bv
        let s_973_13: Bits = Bits::new(s_973_12 as u128, 7u16);
        // D s_973_14: cmp-eq s_973_11 s_973_13
        let s_973_14: bool = ((s_973_11) == (s_973_13));
        // N s_973_15: branch s_973_14 b2179 b974
        if s_973_14 {
            return block_2179(state, tracer, fn_state);
        } else {
            return block_974(state, tracer, fn_state);
        };
    }
    fn block_974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_974_0: const #0u : u8
        let s_974_0: bool = false;
        // D s_974_1: write-var gs#401457 <= s_974_0
        fn_state.gs_401457 = s_974_0;
        // N s_974_2: jump b975
        return block_975(state, tracer, fn_state);
    }
    fn block_975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_975_0: read-var gs#401457:u8
        let s_975_0: bool = fn_state.gs_401457;
        // N s_975_1: branch s_975_0 b2178 b976
        if s_975_0 {
            return block_2178(state, tracer, fn_state);
        } else {
            return block_976(state, tracer, fn_state);
        };
    }
    fn block_976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_976_0: const #0u : u8
        let s_976_0: bool = false;
        // D s_976_1: write-var gs#401459 <= s_976_0
        fn_state.gs_401459 = s_976_0;
        // N s_976_2: jump b977
        return block_977(state, tracer, fn_state);
    }
    fn block_977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_977_0: read-var gs#401459:u8
        let s_977_0: bool = fn_state.gs_401459;
        // D s_977_1: not s_977_0
        let s_977_1: bool = !s_977_0;
        // N s_977_2: branch s_977_1 b979 b978
        if s_977_1 {
            return block_979(state, tracer, fn_state);
        } else {
            return block_978(state, tracer, fn_state);
        };
    }
    fn block_978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_978_0: const #3638s : i
        let s_978_0: i128 = 3638;
        // C s_978_1: const #14696u : u32
        let s_978_1: u32 = 14696;
        // N s_978_2: write-reg s_978_1 <= s_978_0
        let s_978_2: () = {
            state.write_register::<i128>(s_978_1 as isize, s_978_0);
            tracer.write_register(s_978_1 as isize, s_978_0);
        };
        // C s_978_3: const #24s : i
        let s_978_3: i128 = 24;
        // C s_978_4: const #1s : i
        let s_978_4: i128 = 1;
        // D s_978_5: read-var u#31649:u32
        let s_978_5: u32 = fn_state.u_31649;
        // D s_978_6: cast zx s_978_5 -> bv
        let s_978_6: Bits = Bits::new(s_978_5 as u128, 32u16);
        // D s_978_7: bit-extract s_978_6 s_978_3 s_978_4
        let s_978_7: Bits = (Bits::new(
            ((s_978_6) >> (s_978_3)).value(),
            u16::try_from(s_978_4).unwrap(),
        ));
        // D s_978_8: cast reint s_978_7 -> u8
        let s_978_8: bool = ((s_978_7.value()) != 0);
        // C s_978_9: const #22s : i
        let s_978_9: i128 = 22;
        // C s_978_10: const #1s : i
        let s_978_10: i128 = 1;
        // D s_978_11: read-var u#31649:u32
        let s_978_11: u32 = fn_state.u_31649;
        // D s_978_12: cast zx s_978_11 -> bv
        let s_978_12: Bits = Bits::new(s_978_11 as u128, 32u16);
        // D s_978_13: bit-extract s_978_12 s_978_9 s_978_10
        let s_978_13: Bits = (Bits::new(
            ((s_978_12) >> (s_978_9)).value(),
            u16::try_from(s_978_10).unwrap(),
        ));
        // D s_978_14: cast reint s_978_13 -> u8
        let s_978_14: bool = ((s_978_13.value()) != 0);
        // C s_978_15: const #16s : i
        let s_978_15: i128 = 16;
        // C s_978_16: const #6s : i
        let s_978_16: i128 = 6;
        // D s_978_17: read-var u#31649:u32
        let s_978_17: u32 = fn_state.u_31649;
        // D s_978_18: cast zx s_978_17 -> bv
        let s_978_18: Bits = Bits::new(s_978_17 as u128, 32u16);
        // D s_978_19: bit-extract s_978_18 s_978_15 s_978_16
        let s_978_19: Bits = (Bits::new(
            ((s_978_18) >> (s_978_15)).value(),
            u16::try_from(s_978_16).unwrap(),
        ));
        // D s_978_20: cast reint s_978_19 -> u8
        let s_978_20: u8 = (s_978_19.value() as u8);
        // C s_978_21: const #12s : i
        let s_978_21: i128 = 12;
        // C s_978_22: const #4s : i
        let s_978_22: i128 = 4;
        // D s_978_23: read-var u#31649:u32
        let s_978_23: u32 = fn_state.u_31649;
        // D s_978_24: cast zx s_978_23 -> bv
        let s_978_24: Bits = Bits::new(s_978_23 as u128, 32u16);
        // D s_978_25: bit-extract s_978_24 s_978_21 s_978_22
        let s_978_25: Bits = (Bits::new(
            ((s_978_24) >> (s_978_21)).value(),
            u16::try_from(s_978_22).unwrap(),
        ));
        // D s_978_26: cast reint s_978_25 -> u8
        let s_978_26: u8 = (s_978_25.value() as u8);
        // C s_978_27: const #8s : i
        let s_978_27: i128 = 8;
        // C s_978_28: const #1s : i
        let s_978_28: i128 = 1;
        // D s_978_29: read-var u#31649:u32
        let s_978_29: u32 = fn_state.u_31649;
        // D s_978_30: cast zx s_978_29 -> bv
        let s_978_30: Bits = Bits::new(s_978_29 as u128, 32u16);
        // D s_978_31: bit-extract s_978_30 s_978_27 s_978_28
        let s_978_31: Bits = (Bits::new(
            ((s_978_30) >> (s_978_27)).value(),
            u16::try_from(s_978_28).unwrap(),
        ));
        // D s_978_32: cast reint s_978_31 -> u8
        let s_978_32: bool = ((s_978_31.value()) != 0);
        // C s_978_33: const #5s : i
        let s_978_33: i128 = 5;
        // C s_978_34: const #1s : i
        let s_978_34: i128 = 1;
        // D s_978_35: read-var u#31649:u32
        let s_978_35: u32 = fn_state.u_31649;
        // D s_978_36: cast zx s_978_35 -> bv
        let s_978_36: Bits = Bits::new(s_978_35 as u128, 32u16);
        // D s_978_37: bit-extract s_978_36 s_978_33 s_978_34
        let s_978_37: Bits = (Bits::new(
            ((s_978_36) >> (s_978_33)).value(),
            u16::try_from(s_978_34).unwrap(),
        ));
        // D s_978_38: cast reint s_978_37 -> u8
        let s_978_38: bool = ((s_978_37.value()) != 0);
        // C s_978_39: const #0s : i
        let s_978_39: i128 = 0;
        // C s_978_40: const #4s : i
        let s_978_40: i128 = 4;
        // D s_978_41: read-var u#31649:u32
        let s_978_41: u32 = fn_state.u_31649;
        // D s_978_42: cast zx s_978_41 -> bv
        let s_978_42: Bits = Bits::new(s_978_41 as u128, 32u16);
        // D s_978_43: bit-extract s_978_42 s_978_39 s_978_40
        let s_978_43: Bits = (Bits::new(
            ((s_978_42) >> (s_978_39)).value(),
            u16::try_from(s_978_40).unwrap(),
        ));
        // D s_978_44: cast reint s_978_43 -> u8
        let s_978_44: u8 = (s_978_43.value() as u8);
        // D s_978_45: call decode_aarch32_instrs_VQRSHRN_A1enc_A_txt(s_978_8, s_978_14, s_978_20, s_978_26, s_978_32, s_978_38, s_978_44)
        let s_978_45: () = decode_aarch32_instrs_VQRSHRN_A1enc_A_txt(
            state,
            tracer,
            s_978_8,
            s_978_14,
            s_978_20,
            s_978_26,
            s_978_32,
            s_978_38,
            s_978_44,
        );
        // N s_978_46: return
        return;
    }
    fn block_979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_979_0: read-var merge#var.1:struct
        let s_979_0: u32 = fn_state.merge_var._1;
        // D s_979_1: write-var u#31658 <= s_979_0
        fn_state.u_31658 = s_979_0;
        // C s_979_2: const #25s : i
        let s_979_2: i128 = 25;
        // D s_979_3: read-var u#31658:u32
        let s_979_3: u32 = fn_state.u_31658;
        // D s_979_4: cast zx s_979_3 -> bv
        let s_979_4: Bits = Bits::new(s_979_3 as u128, 32u16);
        // C s_979_5: const #1s : i64
        let s_979_5: i64 = 1;
        // C s_979_6: cast zx s_979_5 -> i
        let s_979_6: i128 = (i128::try_from(s_979_5).unwrap());
        // C s_979_7: const #6s : i
        let s_979_7: i128 = 6;
        // C s_979_8: add s_979_7 s_979_6
        let s_979_8: i128 = (s_979_7 + s_979_6);
        // D s_979_9: bit-extract s_979_4 s_979_2 s_979_8
        let s_979_9: Bits = (Bits::new(
            ((s_979_4) >> (s_979_2)).value(),
            u16::try_from(s_979_8).unwrap(),
        ));
        // D s_979_10: cast reint s_979_9 -> u8
        let s_979_10: u8 = (s_979_9.value() as u8);
        // D s_979_11: cast zx s_979_10 -> bv
        let s_979_11: Bits = Bits::new(s_979_10 as u128, 7u16);
        // C s_979_12: const #121u : u8
        let s_979_12: u8 = 121;
        // C s_979_13: cast zx s_979_12 -> bv
        let s_979_13: Bits = Bits::new(s_979_12 as u128, 7u16);
        // D s_979_14: cmp-eq s_979_11 s_979_13
        let s_979_14: bool = ((s_979_11) == (s_979_13));
        // N s_979_15: branch s_979_14 b2171 b980
        if s_979_14 {
            return block_2171(state, tracer, fn_state);
        } else {
            return block_980(state, tracer, fn_state);
        };
    }
    fn block_980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_980_0: const #0u : u8
        let s_980_0: bool = false;
        // D s_980_1: write-var gs#401487 <= s_980_0
        fn_state.gs_401487 = s_980_0;
        // N s_980_2: jump b981
        return block_981(state, tracer, fn_state);
    }
    fn block_981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_981_0: read-var gs#401487:u8
        let s_981_0: bool = fn_state.gs_401487;
        // N s_981_1: branch s_981_0 b2170 b982
        if s_981_0 {
            return block_2170(state, tracer, fn_state);
        } else {
            return block_982(state, tracer, fn_state);
        };
    }
    fn block_982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_982_0: const #0u : u8
        let s_982_0: bool = false;
        // D s_982_1: write-var gs#401489 <= s_982_0
        fn_state.gs_401489 = s_982_0;
        // N s_982_2: jump b983
        return block_983(state, tracer, fn_state);
    }
    fn block_983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_983_0: read-var gs#401489:u8
        let s_983_0: bool = fn_state.gs_401489;
        // D s_983_1: not s_983_0
        let s_983_1: bool = !s_983_0;
        // N s_983_2: branch s_983_1 b985 b984
        if s_983_1 {
            return block_985(state, tracer, fn_state);
        } else {
            return block_984(state, tracer, fn_state);
        };
    }
    fn block_984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_984_0: const #3640s : i
        let s_984_0: i128 = 3640;
        // C s_984_1: const #14696u : u32
        let s_984_1: u32 = 14696;
        // N s_984_2: write-reg s_984_1 <= s_984_0
        let s_984_2: () = {
            state.write_register::<i128>(s_984_1 as isize, s_984_0);
            tracer.write_register(s_984_1 as isize, s_984_0);
        };
        // C s_984_3: const #24s : i
        let s_984_3: i128 = 24;
        // C s_984_4: const #1s : i
        let s_984_4: i128 = 1;
        // D s_984_5: read-var u#31658:u32
        let s_984_5: u32 = fn_state.u_31658;
        // D s_984_6: cast zx s_984_5 -> bv
        let s_984_6: Bits = Bits::new(s_984_5 as u128, 32u16);
        // D s_984_7: bit-extract s_984_6 s_984_3 s_984_4
        let s_984_7: Bits = (Bits::new(
            ((s_984_6) >> (s_984_3)).value(),
            u16::try_from(s_984_4).unwrap(),
        ));
        // D s_984_8: cast reint s_984_7 -> u8
        let s_984_8: bool = ((s_984_7.value()) != 0);
        // C s_984_9: const #22s : i
        let s_984_9: i128 = 22;
        // C s_984_10: const #1s : i
        let s_984_10: i128 = 1;
        // D s_984_11: read-var u#31658:u32
        let s_984_11: u32 = fn_state.u_31658;
        // D s_984_12: cast zx s_984_11 -> bv
        let s_984_12: Bits = Bits::new(s_984_11 as u128, 32u16);
        // D s_984_13: bit-extract s_984_12 s_984_9 s_984_10
        let s_984_13: Bits = (Bits::new(
            ((s_984_12) >> (s_984_9)).value(),
            u16::try_from(s_984_10).unwrap(),
        ));
        // D s_984_14: cast reint s_984_13 -> u8
        let s_984_14: bool = ((s_984_13.value()) != 0);
        // C s_984_15: const #16s : i
        let s_984_15: i128 = 16;
        // C s_984_16: const #6s : i
        let s_984_16: i128 = 6;
        // D s_984_17: read-var u#31658:u32
        let s_984_17: u32 = fn_state.u_31658;
        // D s_984_18: cast zx s_984_17 -> bv
        let s_984_18: Bits = Bits::new(s_984_17 as u128, 32u16);
        // D s_984_19: bit-extract s_984_18 s_984_15 s_984_16
        let s_984_19: Bits = (Bits::new(
            ((s_984_18) >> (s_984_15)).value(),
            u16::try_from(s_984_16).unwrap(),
        ));
        // D s_984_20: cast reint s_984_19 -> u8
        let s_984_20: u8 = (s_984_19.value() as u8);
        // C s_984_21: const #12s : i
        let s_984_21: i128 = 12;
        // C s_984_22: const #4s : i
        let s_984_22: i128 = 4;
        // D s_984_23: read-var u#31658:u32
        let s_984_23: u32 = fn_state.u_31658;
        // D s_984_24: cast zx s_984_23 -> bv
        let s_984_24: Bits = Bits::new(s_984_23 as u128, 32u16);
        // D s_984_25: bit-extract s_984_24 s_984_21 s_984_22
        let s_984_25: Bits = (Bits::new(
            ((s_984_24) >> (s_984_21)).value(),
            u16::try_from(s_984_22).unwrap(),
        ));
        // D s_984_26: cast reint s_984_25 -> u8
        let s_984_26: u8 = (s_984_25.value() as u8);
        // C s_984_27: const #8s : i
        let s_984_27: i128 = 8;
        // C s_984_28: const #1s : i
        let s_984_28: i128 = 1;
        // D s_984_29: read-var u#31658:u32
        let s_984_29: u32 = fn_state.u_31658;
        // D s_984_30: cast zx s_984_29 -> bv
        let s_984_30: Bits = Bits::new(s_984_29 as u128, 32u16);
        // D s_984_31: bit-extract s_984_30 s_984_27 s_984_28
        let s_984_31: Bits = (Bits::new(
            ((s_984_30) >> (s_984_27)).value(),
            u16::try_from(s_984_28).unwrap(),
        ));
        // D s_984_32: cast reint s_984_31 -> u8
        let s_984_32: bool = ((s_984_31.value()) != 0);
        // C s_984_33: const #7s : i
        let s_984_33: i128 = 7;
        // C s_984_34: const #1s : i
        let s_984_34: i128 = 1;
        // D s_984_35: read-var u#31658:u32
        let s_984_35: u32 = fn_state.u_31658;
        // D s_984_36: cast zx s_984_35 -> bv
        let s_984_36: Bits = Bits::new(s_984_35 as u128, 32u16);
        // D s_984_37: bit-extract s_984_36 s_984_33 s_984_34
        let s_984_37: Bits = (Bits::new(
            ((s_984_36) >> (s_984_33)).value(),
            u16::try_from(s_984_34).unwrap(),
        ));
        // D s_984_38: cast reint s_984_37 -> u8
        let s_984_38: bool = ((s_984_37.value()) != 0);
        // C s_984_39: const #6s : i
        let s_984_39: i128 = 6;
        // C s_984_40: const #1s : i
        let s_984_40: i128 = 1;
        // D s_984_41: read-var u#31658:u32
        let s_984_41: u32 = fn_state.u_31658;
        // D s_984_42: cast zx s_984_41 -> bv
        let s_984_42: Bits = Bits::new(s_984_41 as u128, 32u16);
        // D s_984_43: bit-extract s_984_42 s_984_39 s_984_40
        let s_984_43: Bits = (Bits::new(
            ((s_984_42) >> (s_984_39)).value(),
            u16::try_from(s_984_40).unwrap(),
        ));
        // D s_984_44: cast reint s_984_43 -> u8
        let s_984_44: bool = ((s_984_43.value()) != 0);
        // C s_984_45: const #5s : i
        let s_984_45: i128 = 5;
        // C s_984_46: const #1s : i
        let s_984_46: i128 = 1;
        // D s_984_47: read-var u#31658:u32
        let s_984_47: u32 = fn_state.u_31658;
        // D s_984_48: cast zx s_984_47 -> bv
        let s_984_48: Bits = Bits::new(s_984_47 as u128, 32u16);
        // D s_984_49: bit-extract s_984_48 s_984_45 s_984_46
        let s_984_49: Bits = (Bits::new(
            ((s_984_48) >> (s_984_45)).value(),
            u16::try_from(s_984_46).unwrap(),
        ));
        // D s_984_50: cast reint s_984_49 -> u8
        let s_984_50: bool = ((s_984_49.value()) != 0);
        // C s_984_51: const #0s : i
        let s_984_51: i128 = 0;
        // C s_984_52: const #4s : i
        let s_984_52: i128 = 4;
        // D s_984_53: read-var u#31658:u32
        let s_984_53: u32 = fn_state.u_31658;
        // D s_984_54: cast zx s_984_53 -> bv
        let s_984_54: Bits = Bits::new(s_984_53 as u128, 32u16);
        // D s_984_55: bit-extract s_984_54 s_984_51 s_984_52
        let s_984_55: Bits = (Bits::new(
            ((s_984_54) >> (s_984_51)).value(),
            u16::try_from(s_984_52).unwrap(),
        ));
        // D s_984_56: cast reint s_984_55 -> u8
        let s_984_56: u8 = (s_984_55.value() as u8);
        // D s_984_57: call decode_aarch32_instrs_VQSHL_i_A1enc_A_txt(s_984_8, s_984_14, s_984_20, s_984_26, s_984_32, s_984_38, s_984_44, s_984_50, s_984_56)
        let s_984_57: () = decode_aarch32_instrs_VQSHL_i_A1enc_A_txt(
            state,
            tracer,
            s_984_8,
            s_984_14,
            s_984_20,
            s_984_26,
            s_984_32,
            s_984_38,
            s_984_44,
            s_984_50,
            s_984_56,
        );
        // N s_984_58: return
        return;
    }
    fn block_985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_985_0: read-var merge#var.1:struct
        let s_985_0: u32 = fn_state.merge_var._1;
        // D s_985_1: write-var u#31668 <= s_985_0
        fn_state.u_31668 = s_985_0;
        // C s_985_2: const #25s : i
        let s_985_2: i128 = 25;
        // D s_985_3: read-var u#31668:u32
        let s_985_3: u32 = fn_state.u_31668;
        // D s_985_4: cast zx s_985_3 -> bv
        let s_985_4: Bits = Bits::new(s_985_3 as u128, 32u16);
        // C s_985_5: const #1s : i64
        let s_985_5: i64 = 1;
        // C s_985_6: cast zx s_985_5 -> i
        let s_985_6: i128 = (i128::try_from(s_985_5).unwrap());
        // C s_985_7: const #6s : i
        let s_985_7: i128 = 6;
        // C s_985_8: add s_985_7 s_985_6
        let s_985_8: i128 = (s_985_7 + s_985_6);
        // D s_985_9: bit-extract s_985_4 s_985_2 s_985_8
        let s_985_9: Bits = (Bits::new(
            ((s_985_4) >> (s_985_2)).value(),
            u16::try_from(s_985_8).unwrap(),
        ));
        // D s_985_10: cast reint s_985_9 -> u8
        let s_985_10: u8 = (s_985_9.value() as u8);
        // D s_985_11: cast zx s_985_10 -> bv
        let s_985_11: Bits = Bits::new(s_985_10 as u128, 7u16);
        // C s_985_12: const #121u : u8
        let s_985_12: u8 = 121;
        // C s_985_13: cast zx s_985_12 -> bv
        let s_985_13: Bits = Bits::new(s_985_12 as u128, 7u16);
        // D s_985_14: cmp-eq s_985_11 s_985_13
        let s_985_14: bool = ((s_985_11) == (s_985_13));
        // N s_985_15: branch s_985_14 b2163 b986
        if s_985_14 {
            return block_2163(state, tracer, fn_state);
        } else {
            return block_986(state, tracer, fn_state);
        };
    }
    fn block_986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_986_0: const #0u : u8
        let s_986_0: bool = false;
        // D s_986_1: write-var gs#401521 <= s_986_0
        fn_state.gs_401521 = s_986_0;
        // N s_986_2: jump b987
        return block_987(state, tracer, fn_state);
    }
    fn block_987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_987_0: read-var gs#401521:u8
        let s_987_0: bool = fn_state.gs_401521;
        // N s_987_1: branch s_987_0 b2162 b988
        if s_987_0 {
            return block_2162(state, tracer, fn_state);
        } else {
            return block_988(state, tracer, fn_state);
        };
    }
    fn block_988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_988_0: const #0u : u8
        let s_988_0: bool = false;
        // D s_988_1: write-var gs#401523 <= s_988_0
        fn_state.gs_401523 = s_988_0;
        // N s_988_2: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_989_0: read-var gs#401523:u8
        let s_989_0: bool = fn_state.gs_401523;
        // D s_989_1: not s_989_0
        let s_989_1: bool = !s_989_0;
        // N s_989_2: branch s_989_1 b991 b990
        if s_989_1 {
            return block_991(state, tracer, fn_state);
        } else {
            return block_990(state, tracer, fn_state);
        };
    }
    fn block_990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_990_0: const #3642s : i
        let s_990_0: i128 = 3642;
        // C s_990_1: const #14696u : u32
        let s_990_1: u32 = 14696;
        // N s_990_2: write-reg s_990_1 <= s_990_0
        let s_990_2: () = {
            state.write_register::<i128>(s_990_1 as isize, s_990_0);
            tracer.write_register(s_990_1 as isize, s_990_0);
        };
        // C s_990_3: const #24s : i
        let s_990_3: i128 = 24;
        // C s_990_4: const #1s : i
        let s_990_4: i128 = 1;
        // D s_990_5: read-var u#31668:u32
        let s_990_5: u32 = fn_state.u_31668;
        // D s_990_6: cast zx s_990_5 -> bv
        let s_990_6: Bits = Bits::new(s_990_5 as u128, 32u16);
        // D s_990_7: bit-extract s_990_6 s_990_3 s_990_4
        let s_990_7: Bits = (Bits::new(
            ((s_990_6) >> (s_990_3)).value(),
            u16::try_from(s_990_4).unwrap(),
        ));
        // D s_990_8: cast reint s_990_7 -> u8
        let s_990_8: bool = ((s_990_7.value()) != 0);
        // C s_990_9: const #22s : i
        let s_990_9: i128 = 22;
        // C s_990_10: const #1s : i
        let s_990_10: i128 = 1;
        // D s_990_11: read-var u#31668:u32
        let s_990_11: u32 = fn_state.u_31668;
        // D s_990_12: cast zx s_990_11 -> bv
        let s_990_12: Bits = Bits::new(s_990_11 as u128, 32u16);
        // D s_990_13: bit-extract s_990_12 s_990_9 s_990_10
        let s_990_13: Bits = (Bits::new(
            ((s_990_12) >> (s_990_9)).value(),
            u16::try_from(s_990_10).unwrap(),
        ));
        // D s_990_14: cast reint s_990_13 -> u8
        let s_990_14: bool = ((s_990_13.value()) != 0);
        // C s_990_15: const #20s : i
        let s_990_15: i128 = 20;
        // C s_990_16: const #2s : i
        let s_990_16: i128 = 2;
        // D s_990_17: read-var u#31668:u32
        let s_990_17: u32 = fn_state.u_31668;
        // D s_990_18: cast zx s_990_17 -> bv
        let s_990_18: Bits = Bits::new(s_990_17 as u128, 32u16);
        // D s_990_19: bit-extract s_990_18 s_990_15 s_990_16
        let s_990_19: Bits = (Bits::new(
            ((s_990_18) >> (s_990_15)).value(),
            u16::try_from(s_990_16).unwrap(),
        ));
        // D s_990_20: cast reint s_990_19 -> u8
        let s_990_20: u8 = (s_990_19.value() as u8);
        // C s_990_21: const #16s : i
        let s_990_21: i128 = 16;
        // C s_990_22: const #4s : i
        let s_990_22: i128 = 4;
        // D s_990_23: read-var u#31668:u32
        let s_990_23: u32 = fn_state.u_31668;
        // D s_990_24: cast zx s_990_23 -> bv
        let s_990_24: Bits = Bits::new(s_990_23 as u128, 32u16);
        // D s_990_25: bit-extract s_990_24 s_990_21 s_990_22
        let s_990_25: Bits = (Bits::new(
            ((s_990_24) >> (s_990_21)).value(),
            u16::try_from(s_990_22).unwrap(),
        ));
        // D s_990_26: cast reint s_990_25 -> u8
        let s_990_26: u8 = (s_990_25.value() as u8);
        // C s_990_27: const #12s : i
        let s_990_27: i128 = 12;
        // C s_990_28: const #4s : i
        let s_990_28: i128 = 4;
        // D s_990_29: read-var u#31668:u32
        let s_990_29: u32 = fn_state.u_31668;
        // D s_990_30: cast zx s_990_29 -> bv
        let s_990_30: Bits = Bits::new(s_990_29 as u128, 32u16);
        // D s_990_31: bit-extract s_990_30 s_990_27 s_990_28
        let s_990_31: Bits = (Bits::new(
            ((s_990_30) >> (s_990_27)).value(),
            u16::try_from(s_990_28).unwrap(),
        ));
        // D s_990_32: cast reint s_990_31 -> u8
        let s_990_32: u8 = (s_990_31.value() as u8);
        // C s_990_33: const #7s : i
        let s_990_33: i128 = 7;
        // C s_990_34: const #1s : i
        let s_990_34: i128 = 1;
        // D s_990_35: read-var u#31668:u32
        let s_990_35: u32 = fn_state.u_31668;
        // D s_990_36: cast zx s_990_35 -> bv
        let s_990_36: Bits = Bits::new(s_990_35 as u128, 32u16);
        // D s_990_37: bit-extract s_990_36 s_990_33 s_990_34
        let s_990_37: Bits = (Bits::new(
            ((s_990_36) >> (s_990_33)).value(),
            u16::try_from(s_990_34).unwrap(),
        ));
        // D s_990_38: cast reint s_990_37 -> u8
        let s_990_38: bool = ((s_990_37.value()) != 0);
        // C s_990_39: const #6s : i
        let s_990_39: i128 = 6;
        // C s_990_40: const #1s : i
        let s_990_40: i128 = 1;
        // D s_990_41: read-var u#31668:u32
        let s_990_41: u32 = fn_state.u_31668;
        // D s_990_42: cast zx s_990_41 -> bv
        let s_990_42: Bits = Bits::new(s_990_41 as u128, 32u16);
        // D s_990_43: bit-extract s_990_42 s_990_39 s_990_40
        let s_990_43: Bits = (Bits::new(
            ((s_990_42) >> (s_990_39)).value(),
            u16::try_from(s_990_40).unwrap(),
        ));
        // D s_990_44: cast reint s_990_43 -> u8
        let s_990_44: bool = ((s_990_43.value()) != 0);
        // C s_990_45: const #5s : i
        let s_990_45: i128 = 5;
        // C s_990_46: const #1s : i
        let s_990_46: i128 = 1;
        // D s_990_47: read-var u#31668:u32
        let s_990_47: u32 = fn_state.u_31668;
        // D s_990_48: cast zx s_990_47 -> bv
        let s_990_48: Bits = Bits::new(s_990_47 as u128, 32u16);
        // D s_990_49: bit-extract s_990_48 s_990_45 s_990_46
        let s_990_49: Bits = (Bits::new(
            ((s_990_48) >> (s_990_45)).value(),
            u16::try_from(s_990_46).unwrap(),
        ));
        // D s_990_50: cast reint s_990_49 -> u8
        let s_990_50: bool = ((s_990_49.value()) != 0);
        // C s_990_51: const #0s : i
        let s_990_51: i128 = 0;
        // C s_990_52: const #4s : i
        let s_990_52: i128 = 4;
        // D s_990_53: read-var u#31668:u32
        let s_990_53: u32 = fn_state.u_31668;
        // D s_990_54: cast zx s_990_53 -> bv
        let s_990_54: Bits = Bits::new(s_990_53 as u128, 32u16);
        // D s_990_55: bit-extract s_990_54 s_990_51 s_990_52
        let s_990_55: Bits = (Bits::new(
            ((s_990_54) >> (s_990_51)).value(),
            u16::try_from(s_990_52).unwrap(),
        ));
        // D s_990_56: cast reint s_990_55 -> u8
        let s_990_56: u8 = (s_990_55.value() as u8);
        // D s_990_57: call decode_aarch32_instrs_VQSHL_r_A1enc_A_txt(s_990_8, s_990_14, s_990_20, s_990_26, s_990_32, s_990_38, s_990_44, s_990_50, s_990_56)
        let s_990_57: () = decode_aarch32_instrs_VQSHL_r_A1enc_A_txt(
            state,
            tracer,
            s_990_8,
            s_990_14,
            s_990_20,
            s_990_26,
            s_990_32,
            s_990_38,
            s_990_44,
            s_990_50,
            s_990_56,
        );
        // N s_990_58: return
        return;
    }
    fn block_991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_991_0: read-var merge#var.1:struct
        let s_991_0: u32 = fn_state.merge_var._1;
        // D s_991_1: write-var u#31679 <= s_991_0
        fn_state.u_31679 = s_991_0;
        // C s_991_2: const #25s : i
        let s_991_2: i128 = 25;
        // D s_991_3: read-var u#31679:u32
        let s_991_3: u32 = fn_state.u_31679;
        // D s_991_4: cast zx s_991_3 -> bv
        let s_991_4: Bits = Bits::new(s_991_3 as u128, 32u16);
        // C s_991_5: const #1s : i64
        let s_991_5: i64 = 1;
        // C s_991_6: cast zx s_991_5 -> i
        let s_991_6: i128 = (i128::try_from(s_991_5).unwrap());
        // C s_991_7: const #6s : i
        let s_991_7: i128 = 6;
        // C s_991_8: add s_991_7 s_991_6
        let s_991_8: i128 = (s_991_7 + s_991_6);
        // D s_991_9: bit-extract s_991_4 s_991_2 s_991_8
        let s_991_9: Bits = (Bits::new(
            ((s_991_4) >> (s_991_2)).value(),
            u16::try_from(s_991_8).unwrap(),
        ));
        // D s_991_10: cast reint s_991_9 -> u8
        let s_991_10: u8 = (s_991_9.value() as u8);
        // D s_991_11: cast zx s_991_10 -> bv
        let s_991_11: Bits = Bits::new(s_991_10 as u128, 7u16);
        // C s_991_12: const #121u : u8
        let s_991_12: u8 = 121;
        // C s_991_13: cast zx s_991_12 -> bv
        let s_991_13: Bits = Bits::new(s_991_12 as u128, 7u16);
        // D s_991_14: cmp-eq s_991_11 s_991_13
        let s_991_14: bool = ((s_991_11) == (s_991_13));
        // N s_991_15: branch s_991_14 b2152 b992
        if s_991_14 {
            return block_2152(state, tracer, fn_state);
        } else {
            return block_992(state, tracer, fn_state);
        };
    }
    fn block_992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_992_0: const #0u : u8
        let s_992_0: bool = false;
        // D s_992_1: write-var gs#401558 <= s_992_0
        fn_state.gs_401558 = s_992_0;
        // N s_992_2: jump b993
        return block_993(state, tracer, fn_state);
    }
    fn block_993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_993_0: read-var gs#401558:u8
        let s_993_0: bool = fn_state.gs_401558;
        // N s_993_1: branch s_993_0 b2151 b994
        if s_993_0 {
            return block_2151(state, tracer, fn_state);
        } else {
            return block_994(state, tracer, fn_state);
        };
    }
    fn block_994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_994_0: const #0u : u8
        let s_994_0: bool = false;
        // D s_994_1: write-var gs#401560 <= s_994_0
        fn_state.gs_401560 = s_994_0;
        // N s_994_2: jump b995
        return block_995(state, tracer, fn_state);
    }
    fn block_995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_995_0: read-var gs#401560:u8
        let s_995_0: bool = fn_state.gs_401560;
        // D s_995_1: not s_995_0
        let s_995_1: bool = !s_995_0;
        // N s_995_2: branch s_995_1 b997 b996
        if s_995_1 {
            return block_997(state, tracer, fn_state);
        } else {
            return block_996(state, tracer, fn_state);
        };
    }
    fn block_996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_996_0: const #3644s : i
        let s_996_0: i128 = 3644;
        // C s_996_1: const #14696u : u32
        let s_996_1: u32 = 14696;
        // N s_996_2: write-reg s_996_1 <= s_996_0
        let s_996_2: () = {
            state.write_register::<i128>(s_996_1 as isize, s_996_0);
            tracer.write_register(s_996_1 as isize, s_996_0);
        };
        // C s_996_3: const #24s : i
        let s_996_3: i128 = 24;
        // C s_996_4: const #1s : i
        let s_996_4: i128 = 1;
        // D s_996_5: read-var u#31679:u32
        let s_996_5: u32 = fn_state.u_31679;
        // D s_996_6: cast zx s_996_5 -> bv
        let s_996_6: Bits = Bits::new(s_996_5 as u128, 32u16);
        // D s_996_7: bit-extract s_996_6 s_996_3 s_996_4
        let s_996_7: Bits = (Bits::new(
            ((s_996_6) >> (s_996_3)).value(),
            u16::try_from(s_996_4).unwrap(),
        ));
        // D s_996_8: cast reint s_996_7 -> u8
        let s_996_8: bool = ((s_996_7.value()) != 0);
        // C s_996_9: const #22s : i
        let s_996_9: i128 = 22;
        // C s_996_10: const #1s : i
        let s_996_10: i128 = 1;
        // D s_996_11: read-var u#31679:u32
        let s_996_11: u32 = fn_state.u_31679;
        // D s_996_12: cast zx s_996_11 -> bv
        let s_996_12: Bits = Bits::new(s_996_11 as u128, 32u16);
        // D s_996_13: bit-extract s_996_12 s_996_9 s_996_10
        let s_996_13: Bits = (Bits::new(
            ((s_996_12) >> (s_996_9)).value(),
            u16::try_from(s_996_10).unwrap(),
        ));
        // D s_996_14: cast reint s_996_13 -> u8
        let s_996_14: bool = ((s_996_13.value()) != 0);
        // C s_996_15: const #16s : i
        let s_996_15: i128 = 16;
        // C s_996_16: const #6s : i
        let s_996_16: i128 = 6;
        // D s_996_17: read-var u#31679:u32
        let s_996_17: u32 = fn_state.u_31679;
        // D s_996_18: cast zx s_996_17 -> bv
        let s_996_18: Bits = Bits::new(s_996_17 as u128, 32u16);
        // D s_996_19: bit-extract s_996_18 s_996_15 s_996_16
        let s_996_19: Bits = (Bits::new(
            ((s_996_18) >> (s_996_15)).value(),
            u16::try_from(s_996_16).unwrap(),
        ));
        // D s_996_20: cast reint s_996_19 -> u8
        let s_996_20: u8 = (s_996_19.value() as u8);
        // C s_996_21: const #12s : i
        let s_996_21: i128 = 12;
        // C s_996_22: const #4s : i
        let s_996_22: i128 = 4;
        // D s_996_23: read-var u#31679:u32
        let s_996_23: u32 = fn_state.u_31679;
        // D s_996_24: cast zx s_996_23 -> bv
        let s_996_24: Bits = Bits::new(s_996_23 as u128, 32u16);
        // D s_996_25: bit-extract s_996_24 s_996_21 s_996_22
        let s_996_25: Bits = (Bits::new(
            ((s_996_24) >> (s_996_21)).value(),
            u16::try_from(s_996_22).unwrap(),
        ));
        // D s_996_26: cast reint s_996_25 -> u8
        let s_996_26: u8 = (s_996_25.value() as u8);
        // C s_996_27: const #8s : i
        let s_996_27: i128 = 8;
        // C s_996_28: const #1s : i
        let s_996_28: i128 = 1;
        // D s_996_29: read-var u#31679:u32
        let s_996_29: u32 = fn_state.u_31679;
        // D s_996_30: cast zx s_996_29 -> bv
        let s_996_30: Bits = Bits::new(s_996_29 as u128, 32u16);
        // D s_996_31: bit-extract s_996_30 s_996_27 s_996_28
        let s_996_31: Bits = (Bits::new(
            ((s_996_30) >> (s_996_27)).value(),
            u16::try_from(s_996_28).unwrap(),
        ));
        // D s_996_32: cast reint s_996_31 -> u8
        let s_996_32: bool = ((s_996_31.value()) != 0);
        // C s_996_33: const #5s : i
        let s_996_33: i128 = 5;
        // C s_996_34: const #1s : i
        let s_996_34: i128 = 1;
        // D s_996_35: read-var u#31679:u32
        let s_996_35: u32 = fn_state.u_31679;
        // D s_996_36: cast zx s_996_35 -> bv
        let s_996_36: Bits = Bits::new(s_996_35 as u128, 32u16);
        // D s_996_37: bit-extract s_996_36 s_996_33 s_996_34
        let s_996_37: Bits = (Bits::new(
            ((s_996_36) >> (s_996_33)).value(),
            u16::try_from(s_996_34).unwrap(),
        ));
        // D s_996_38: cast reint s_996_37 -> u8
        let s_996_38: bool = ((s_996_37.value()) != 0);
        // C s_996_39: const #0s : i
        let s_996_39: i128 = 0;
        // C s_996_40: const #4s : i
        let s_996_40: i128 = 4;
        // D s_996_41: read-var u#31679:u32
        let s_996_41: u32 = fn_state.u_31679;
        // D s_996_42: cast zx s_996_41 -> bv
        let s_996_42: Bits = Bits::new(s_996_41 as u128, 32u16);
        // D s_996_43: bit-extract s_996_42 s_996_39 s_996_40
        let s_996_43: Bits = (Bits::new(
            ((s_996_42) >> (s_996_39)).value(),
            u16::try_from(s_996_40).unwrap(),
        ));
        // D s_996_44: cast reint s_996_43 -> u8
        let s_996_44: u8 = (s_996_43.value() as u8);
        // D s_996_45: call decode_aarch32_instrs_VQSHRN_A1enc_A_txt(s_996_8, s_996_14, s_996_20, s_996_26, s_996_32, s_996_38, s_996_44)
        let s_996_45: () = decode_aarch32_instrs_VQSHRN_A1enc_A_txt(
            state,
            tracer,
            s_996_8,
            s_996_14,
            s_996_20,
            s_996_26,
            s_996_32,
            s_996_38,
            s_996_44,
        );
        // N s_996_46: return
        return;
    }
    fn block_997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_997_0: read-var merge#var.1:struct
        let s_997_0: u32 = fn_state.merge_var._1;
        // D s_997_1: write-var u#31688 <= s_997_0
        fn_state.u_31688 = s_997_0;
        // C s_997_2: const #25s : i
        let s_997_2: i128 = 25;
        // D s_997_3: read-var u#31688:u32
        let s_997_3: u32 = fn_state.u_31688;
        // D s_997_4: cast zx s_997_3 -> bv
        let s_997_4: Bits = Bits::new(s_997_3 as u128, 32u16);
        // C s_997_5: const #1s : i64
        let s_997_5: i64 = 1;
        // C s_997_6: cast zx s_997_5 -> i
        let s_997_6: i128 = (i128::try_from(s_997_5).unwrap());
        // C s_997_7: const #6s : i
        let s_997_7: i128 = 6;
        // C s_997_8: add s_997_7 s_997_6
        let s_997_8: i128 = (s_997_7 + s_997_6);
        // D s_997_9: bit-extract s_997_4 s_997_2 s_997_8
        let s_997_9: Bits = (Bits::new(
            ((s_997_4) >> (s_997_2)).value(),
            u16::try_from(s_997_8).unwrap(),
        ));
        // D s_997_10: cast reint s_997_9 -> u8
        let s_997_10: u8 = (s_997_9.value() as u8);
        // D s_997_11: cast zx s_997_10 -> bv
        let s_997_11: Bits = Bits::new(s_997_10 as u128, 7u16);
        // C s_997_12: const #121u : u8
        let s_997_12: u8 = 121;
        // C s_997_13: cast zx s_997_12 -> bv
        let s_997_13: Bits = Bits::new(s_997_12 as u128, 7u16);
        // D s_997_14: cmp-eq s_997_11 s_997_13
        let s_997_14: bool = ((s_997_11) == (s_997_13));
        // N s_997_15: branch s_997_14 b2144 b998
        if s_997_14 {
            return block_2144(state, tracer, fn_state);
        } else {
            return block_998(state, tracer, fn_state);
        };
    }
    fn block_998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_998_0: const #0u : u8
        let s_998_0: bool = false;
        // D s_998_1: write-var gs#401588 <= s_998_0
        fn_state.gs_401588 = s_998_0;
        // N s_998_2: jump b999
        return block_999(state, tracer, fn_state);
    }
    fn block_999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_999_0: read-var gs#401588:u8
        let s_999_0: bool = fn_state.gs_401588;
        // N s_999_1: branch s_999_0 b2143 b1000
        if s_999_0 {
            return block_2143(state, tracer, fn_state);
        } else {
            return block_1000(state, tracer, fn_state);
        };
    }
    fn block_1000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1000_0: const #0u : u8
        let s_1000_0: bool = false;
        // D s_1000_1: write-var gs#401590 <= s_1000_0
        fn_state.gs_401590 = s_1000_0;
        // N s_1000_2: jump b1001
        return block_1001(state, tracer, fn_state);
    }
    fn block_1001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1001_0: read-var gs#401590:u8
        let s_1001_0: bool = fn_state.gs_401590;
        // D s_1001_1: not s_1001_0
        let s_1001_1: bool = !s_1001_0;
        // N s_1001_2: branch s_1001_1 b1003 b1002
        if s_1001_1 {
            return block_1003(state, tracer, fn_state);
        } else {
            return block_1002(state, tracer, fn_state);
        };
    }
    fn block_1002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1002_0: const #3646s : i
        let s_1002_0: i128 = 3646;
        // C s_1002_1: const #14696u : u32
        let s_1002_1: u32 = 14696;
        // N s_1002_2: write-reg s_1002_1 <= s_1002_0
        let s_1002_2: () = {
            state.write_register::<i128>(s_1002_1 as isize, s_1002_0);
            tracer.write_register(s_1002_1 as isize, s_1002_0);
        };
        // C s_1002_3: const #24s : i
        let s_1002_3: i128 = 24;
        // C s_1002_4: const #1s : i
        let s_1002_4: i128 = 1;
        // D s_1002_5: read-var u#31688:u32
        let s_1002_5: u32 = fn_state.u_31688;
        // D s_1002_6: cast zx s_1002_5 -> bv
        let s_1002_6: Bits = Bits::new(s_1002_5 as u128, 32u16);
        // D s_1002_7: bit-extract s_1002_6 s_1002_3 s_1002_4
        let s_1002_7: Bits = (Bits::new(
            ((s_1002_6) >> (s_1002_3)).value(),
            u16::try_from(s_1002_4).unwrap(),
        ));
        // D s_1002_8: cast reint s_1002_7 -> u8
        let s_1002_8: bool = ((s_1002_7.value()) != 0);
        // C s_1002_9: const #22s : i
        let s_1002_9: i128 = 22;
        // C s_1002_10: const #1s : i
        let s_1002_10: i128 = 1;
        // D s_1002_11: read-var u#31688:u32
        let s_1002_11: u32 = fn_state.u_31688;
        // D s_1002_12: cast zx s_1002_11 -> bv
        let s_1002_12: Bits = Bits::new(s_1002_11 as u128, 32u16);
        // D s_1002_13: bit-extract s_1002_12 s_1002_9 s_1002_10
        let s_1002_13: Bits = (Bits::new(
            ((s_1002_12) >> (s_1002_9)).value(),
            u16::try_from(s_1002_10).unwrap(),
        ));
        // D s_1002_14: cast reint s_1002_13 -> u8
        let s_1002_14: bool = ((s_1002_13.value()) != 0);
        // C s_1002_15: const #20s : i
        let s_1002_15: i128 = 20;
        // C s_1002_16: const #2s : i
        let s_1002_16: i128 = 2;
        // D s_1002_17: read-var u#31688:u32
        let s_1002_17: u32 = fn_state.u_31688;
        // D s_1002_18: cast zx s_1002_17 -> bv
        let s_1002_18: Bits = Bits::new(s_1002_17 as u128, 32u16);
        // D s_1002_19: bit-extract s_1002_18 s_1002_15 s_1002_16
        let s_1002_19: Bits = (Bits::new(
            ((s_1002_18) >> (s_1002_15)).value(),
            u16::try_from(s_1002_16).unwrap(),
        ));
        // D s_1002_20: cast reint s_1002_19 -> u8
        let s_1002_20: u8 = (s_1002_19.value() as u8);
        // C s_1002_21: const #16s : i
        let s_1002_21: i128 = 16;
        // C s_1002_22: const #4s : i
        let s_1002_22: i128 = 4;
        // D s_1002_23: read-var u#31688:u32
        let s_1002_23: u32 = fn_state.u_31688;
        // D s_1002_24: cast zx s_1002_23 -> bv
        let s_1002_24: Bits = Bits::new(s_1002_23 as u128, 32u16);
        // D s_1002_25: bit-extract s_1002_24 s_1002_21 s_1002_22
        let s_1002_25: Bits = (Bits::new(
            ((s_1002_24) >> (s_1002_21)).value(),
            u16::try_from(s_1002_22).unwrap(),
        ));
        // D s_1002_26: cast reint s_1002_25 -> u8
        let s_1002_26: u8 = (s_1002_25.value() as u8);
        // C s_1002_27: const #12s : i
        let s_1002_27: i128 = 12;
        // C s_1002_28: const #4s : i
        let s_1002_28: i128 = 4;
        // D s_1002_29: read-var u#31688:u32
        let s_1002_29: u32 = fn_state.u_31688;
        // D s_1002_30: cast zx s_1002_29 -> bv
        let s_1002_30: Bits = Bits::new(s_1002_29 as u128, 32u16);
        // D s_1002_31: bit-extract s_1002_30 s_1002_27 s_1002_28
        let s_1002_31: Bits = (Bits::new(
            ((s_1002_30) >> (s_1002_27)).value(),
            u16::try_from(s_1002_28).unwrap(),
        ));
        // D s_1002_32: cast reint s_1002_31 -> u8
        let s_1002_32: u8 = (s_1002_31.value() as u8);
        // C s_1002_33: const #7s : i
        let s_1002_33: i128 = 7;
        // C s_1002_34: const #1s : i
        let s_1002_34: i128 = 1;
        // D s_1002_35: read-var u#31688:u32
        let s_1002_35: u32 = fn_state.u_31688;
        // D s_1002_36: cast zx s_1002_35 -> bv
        let s_1002_36: Bits = Bits::new(s_1002_35 as u128, 32u16);
        // D s_1002_37: bit-extract s_1002_36 s_1002_33 s_1002_34
        let s_1002_37: Bits = (Bits::new(
            ((s_1002_36) >> (s_1002_33)).value(),
            u16::try_from(s_1002_34).unwrap(),
        ));
        // D s_1002_38: cast reint s_1002_37 -> u8
        let s_1002_38: bool = ((s_1002_37.value()) != 0);
        // C s_1002_39: const #6s : i
        let s_1002_39: i128 = 6;
        // C s_1002_40: const #1s : i
        let s_1002_40: i128 = 1;
        // D s_1002_41: read-var u#31688:u32
        let s_1002_41: u32 = fn_state.u_31688;
        // D s_1002_42: cast zx s_1002_41 -> bv
        let s_1002_42: Bits = Bits::new(s_1002_41 as u128, 32u16);
        // D s_1002_43: bit-extract s_1002_42 s_1002_39 s_1002_40
        let s_1002_43: Bits = (Bits::new(
            ((s_1002_42) >> (s_1002_39)).value(),
            u16::try_from(s_1002_40).unwrap(),
        ));
        // D s_1002_44: cast reint s_1002_43 -> u8
        let s_1002_44: bool = ((s_1002_43.value()) != 0);
        // C s_1002_45: const #5s : i
        let s_1002_45: i128 = 5;
        // C s_1002_46: const #1s : i
        let s_1002_46: i128 = 1;
        // D s_1002_47: read-var u#31688:u32
        let s_1002_47: u32 = fn_state.u_31688;
        // D s_1002_48: cast zx s_1002_47 -> bv
        let s_1002_48: Bits = Bits::new(s_1002_47 as u128, 32u16);
        // D s_1002_49: bit-extract s_1002_48 s_1002_45 s_1002_46
        let s_1002_49: Bits = (Bits::new(
            ((s_1002_48) >> (s_1002_45)).value(),
            u16::try_from(s_1002_46).unwrap(),
        ));
        // D s_1002_50: cast reint s_1002_49 -> u8
        let s_1002_50: bool = ((s_1002_49.value()) != 0);
        // C s_1002_51: const #0s : i
        let s_1002_51: i128 = 0;
        // C s_1002_52: const #4s : i
        let s_1002_52: i128 = 4;
        // D s_1002_53: read-var u#31688:u32
        let s_1002_53: u32 = fn_state.u_31688;
        // D s_1002_54: cast zx s_1002_53 -> bv
        let s_1002_54: Bits = Bits::new(s_1002_53 as u128, 32u16);
        // D s_1002_55: bit-extract s_1002_54 s_1002_51 s_1002_52
        let s_1002_55: Bits = (Bits::new(
            ((s_1002_54) >> (s_1002_51)).value(),
            u16::try_from(s_1002_52).unwrap(),
        ));
        // D s_1002_56: cast reint s_1002_55 -> u8
        let s_1002_56: u8 = (s_1002_55.value() as u8);
        // D s_1002_57: call decode_aarch32_instrs_VQSUB_A1enc_A_txt(s_1002_8, s_1002_14, s_1002_20, s_1002_26, s_1002_32, s_1002_38, s_1002_44, s_1002_50, s_1002_56)
        let s_1002_57: () = decode_aarch32_instrs_VQSUB_A1enc_A_txt(
            state,
            tracer,
            s_1002_8,
            s_1002_14,
            s_1002_20,
            s_1002_26,
            s_1002_32,
            s_1002_38,
            s_1002_44,
            s_1002_50,
            s_1002_56,
        );
        // N s_1002_58: return
        return;
    }
    fn block_1003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1003_0: read-var merge#var.1:struct
        let s_1003_0: u32 = fn_state.merge_var._1;
        // D s_1003_1: write-var u#31699 <= s_1003_0
        fn_state.u_31699 = s_1003_0;
        // C s_1003_2: const #23s : i
        let s_1003_2: i128 = 23;
        // D s_1003_3: read-var u#31699:u32
        let s_1003_3: u32 = fn_state.u_31699;
        // D s_1003_4: cast zx s_1003_3 -> bv
        let s_1003_4: Bits = Bits::new(s_1003_3 as u128, 32u16);
        // C s_1003_5: const #1s : i64
        let s_1003_5: i64 = 1;
        // C s_1003_6: cast zx s_1003_5 -> i
        let s_1003_6: i128 = (i128::try_from(s_1003_5).unwrap());
        // C s_1003_7: const #8s : i
        let s_1003_7: i128 = 8;
        // C s_1003_8: add s_1003_7 s_1003_6
        let s_1003_8: i128 = (s_1003_7 + s_1003_6);
        // D s_1003_9: bit-extract s_1003_4 s_1003_2 s_1003_8
        let s_1003_9: Bits = (Bits::new(
            ((s_1003_4) >> (s_1003_2)).value(),
            u16::try_from(s_1003_8).unwrap(),
        ));
        // D s_1003_10: cast reint s_1003_9 -> u9
        let s_1003_10: u16 = (s_1003_9.value() as u16);
        // D s_1003_11: cast zx s_1003_10 -> bv
        let s_1003_11: Bits = Bits::new(s_1003_10 as u128, 9u16);
        // C s_1003_12: const #487u : u9
        let s_1003_12: u16 = 487;
        // C s_1003_13: cast zx s_1003_12 -> bv
        let s_1003_13: Bits = Bits::new(s_1003_12 as u128, 9u16);
        // D s_1003_14: cmp-eq s_1003_11 s_1003_13
        let s_1003_14: bool = ((s_1003_11) == (s_1003_13));
        // N s_1003_15: branch s_1003_14 b2136 b1004
        if s_1003_14 {
            return block_2136(state, tracer, fn_state);
        } else {
            return block_1004(state, tracer, fn_state);
        };
    }
    fn block_1004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1004_0: const #0u : u8
        let s_1004_0: bool = false;
        // D s_1004_1: write-var gs#401622 <= s_1004_0
        fn_state.gs_401622 = s_1004_0;
        // N s_1004_2: jump b1005
        return block_1005(state, tracer, fn_state);
    }
    fn block_1005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1005_0: read-var gs#401622:u8
        let s_1005_0: bool = fn_state.gs_401622;
        // N s_1005_1: branch s_1005_0 b2135 b1006
        if s_1005_0 {
            return block_2135(state, tracer, fn_state);
        } else {
            return block_1006(state, tracer, fn_state);
        };
    }
    fn block_1006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1006_0: const #0u : u8
        let s_1006_0: bool = false;
        // D s_1006_1: write-var gs#401624 <= s_1006_0
        fn_state.gs_401624 = s_1006_0;
        // N s_1006_2: jump b1007
        return block_1007(state, tracer, fn_state);
    }
    fn block_1007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1007_0: read-var gs#401624:u8
        let s_1007_0: bool = fn_state.gs_401624;
        // D s_1007_1: not s_1007_0
        let s_1007_1: bool = !s_1007_0;
        // N s_1007_2: branch s_1007_1 b1009 b1008
        if s_1007_1 {
            return block_1009(state, tracer, fn_state);
        } else {
            return block_1008(state, tracer, fn_state);
        };
    }
    fn block_1008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1008_0: const #3648s : i
        let s_1008_0: i128 = 3648;
        // C s_1008_1: const #14696u : u32
        let s_1008_1: u32 = 14696;
        // N s_1008_2: write-reg s_1008_1 <= s_1008_0
        let s_1008_2: () = {
            state.write_register::<i128>(s_1008_1 as isize, s_1008_0);
            tracer.write_register(s_1008_1 as isize, s_1008_0);
        };
        // C s_1008_3: const #22s : i
        let s_1008_3: i128 = 22;
        // C s_1008_4: const #1s : i
        let s_1008_4: i128 = 1;
        // D s_1008_5: read-var u#31699:u32
        let s_1008_5: u32 = fn_state.u_31699;
        // D s_1008_6: cast zx s_1008_5 -> bv
        let s_1008_6: Bits = Bits::new(s_1008_5 as u128, 32u16);
        // D s_1008_7: bit-extract s_1008_6 s_1008_3 s_1008_4
        let s_1008_7: Bits = (Bits::new(
            ((s_1008_6) >> (s_1008_3)).value(),
            u16::try_from(s_1008_4).unwrap(),
        ));
        // D s_1008_8: cast reint s_1008_7 -> u8
        let s_1008_8: bool = ((s_1008_7.value()) != 0);
        // C s_1008_9: const #20s : i
        let s_1008_9: i128 = 20;
        // C s_1008_10: const #2s : i
        let s_1008_10: i128 = 2;
        // D s_1008_11: read-var u#31699:u32
        let s_1008_11: u32 = fn_state.u_31699;
        // D s_1008_12: cast zx s_1008_11 -> bv
        let s_1008_12: Bits = Bits::new(s_1008_11 as u128, 32u16);
        // D s_1008_13: bit-extract s_1008_12 s_1008_9 s_1008_10
        let s_1008_13: Bits = (Bits::new(
            ((s_1008_12) >> (s_1008_9)).value(),
            u16::try_from(s_1008_10).unwrap(),
        ));
        // D s_1008_14: cast reint s_1008_13 -> u8
        let s_1008_14: u8 = (s_1008_13.value() as u8);
        // C s_1008_15: const #16s : i
        let s_1008_15: i128 = 16;
        // C s_1008_16: const #4s : i
        let s_1008_16: i128 = 4;
        // D s_1008_17: read-var u#31699:u32
        let s_1008_17: u32 = fn_state.u_31699;
        // D s_1008_18: cast zx s_1008_17 -> bv
        let s_1008_18: Bits = Bits::new(s_1008_17 as u128, 32u16);
        // D s_1008_19: bit-extract s_1008_18 s_1008_15 s_1008_16
        let s_1008_19: Bits = (Bits::new(
            ((s_1008_18) >> (s_1008_15)).value(),
            u16::try_from(s_1008_16).unwrap(),
        ));
        // D s_1008_20: cast reint s_1008_19 -> u8
        let s_1008_20: u8 = (s_1008_19.value() as u8);
        // C s_1008_21: const #12s : i
        let s_1008_21: i128 = 12;
        // C s_1008_22: const #4s : i
        let s_1008_22: i128 = 4;
        // D s_1008_23: read-var u#31699:u32
        let s_1008_23: u32 = fn_state.u_31699;
        // D s_1008_24: cast zx s_1008_23 -> bv
        let s_1008_24: Bits = Bits::new(s_1008_23 as u128, 32u16);
        // D s_1008_25: bit-extract s_1008_24 s_1008_21 s_1008_22
        let s_1008_25: Bits = (Bits::new(
            ((s_1008_24) >> (s_1008_21)).value(),
            u16::try_from(s_1008_22).unwrap(),
        ));
        // D s_1008_26: cast reint s_1008_25 -> u8
        let s_1008_26: u8 = (s_1008_25.value() as u8);
        // C s_1008_27: const #7s : i
        let s_1008_27: i128 = 7;
        // C s_1008_28: const #1s : i
        let s_1008_28: i128 = 1;
        // D s_1008_29: read-var u#31699:u32
        let s_1008_29: u32 = fn_state.u_31699;
        // D s_1008_30: cast zx s_1008_29 -> bv
        let s_1008_30: Bits = Bits::new(s_1008_29 as u128, 32u16);
        // D s_1008_31: bit-extract s_1008_30 s_1008_27 s_1008_28
        let s_1008_31: Bits = (Bits::new(
            ((s_1008_30) >> (s_1008_27)).value(),
            u16::try_from(s_1008_28).unwrap(),
        ));
        // D s_1008_32: cast reint s_1008_31 -> u8
        let s_1008_32: bool = ((s_1008_31.value()) != 0);
        // C s_1008_33: const #5s : i
        let s_1008_33: i128 = 5;
        // C s_1008_34: const #1s : i
        let s_1008_34: i128 = 1;
        // D s_1008_35: read-var u#31699:u32
        let s_1008_35: u32 = fn_state.u_31699;
        // D s_1008_36: cast zx s_1008_35 -> bv
        let s_1008_36: Bits = Bits::new(s_1008_35 as u128, 32u16);
        // D s_1008_37: bit-extract s_1008_36 s_1008_33 s_1008_34
        let s_1008_37: Bits = (Bits::new(
            ((s_1008_36) >> (s_1008_33)).value(),
            u16::try_from(s_1008_34).unwrap(),
        ));
        // D s_1008_38: cast reint s_1008_37 -> u8
        let s_1008_38: bool = ((s_1008_37.value()) != 0);
        // C s_1008_39: const #0s : i
        let s_1008_39: i128 = 0;
        // C s_1008_40: const #4s : i
        let s_1008_40: i128 = 4;
        // D s_1008_41: read-var u#31699:u32
        let s_1008_41: u32 = fn_state.u_31699;
        // D s_1008_42: cast zx s_1008_41 -> bv
        let s_1008_42: Bits = Bits::new(s_1008_41 as u128, 32u16);
        // D s_1008_43: bit-extract s_1008_42 s_1008_39 s_1008_40
        let s_1008_43: Bits = (Bits::new(
            ((s_1008_42) >> (s_1008_39)).value(),
            u16::try_from(s_1008_40).unwrap(),
        ));
        // D s_1008_44: cast reint s_1008_43 -> u8
        let s_1008_44: u8 = (s_1008_43.value() as u8);
        // D s_1008_45: call decode_aarch32_instrs_VRADDHN_A1enc_A_txt(s_1008_8, s_1008_14, s_1008_20, s_1008_26, s_1008_32, s_1008_38, s_1008_44)
        let s_1008_45: () = decode_aarch32_instrs_VRADDHN_A1enc_A_txt(
            state,
            tracer,
            s_1008_8,
            s_1008_14,
            s_1008_20,
            s_1008_26,
            s_1008_32,
            s_1008_38,
            s_1008_44,
        );
        // N s_1008_46: return
        return;
    }
    fn block_1009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1009_0: read-var merge#var.1:struct
        let s_1009_0: u32 = fn_state.merge_var._1;
        // D s_1009_1: write-var u#31708 <= s_1009_0
        fn_state.u_31708 = s_1009_0;
        // C s_1009_2: const #23s : i
        let s_1009_2: i128 = 23;
        // D s_1009_3: read-var u#31708:u32
        let s_1009_3: u32 = fn_state.u_31708;
        // D s_1009_4: cast zx s_1009_3 -> bv
        let s_1009_4: Bits = Bits::new(s_1009_3 as u128, 32u16);
        // C s_1009_5: const #1s : i64
        let s_1009_5: i64 = 1;
        // C s_1009_6: cast zx s_1009_5 -> i
        let s_1009_6: i128 = (i128::try_from(s_1009_5).unwrap());
        // C s_1009_7: const #8s : i
        let s_1009_7: i128 = 8;
        // C s_1009_8: add s_1009_7 s_1009_6
        let s_1009_8: i128 = (s_1009_7 + s_1009_6);
        // D s_1009_9: bit-extract s_1009_4 s_1009_2 s_1009_8
        let s_1009_9: Bits = (Bits::new(
            ((s_1009_4) >> (s_1009_2)).value(),
            u16::try_from(s_1009_8).unwrap(),
        ));
        // D s_1009_10: cast reint s_1009_9 -> u9
        let s_1009_10: u16 = (s_1009_9.value() as u16);
        // D s_1009_11: cast zx s_1009_10 -> bv
        let s_1009_11: Bits = Bits::new(s_1009_10 as u128, 9u16);
        // C s_1009_12: const #487u : u9
        let s_1009_12: u16 = 487;
        // C s_1009_13: cast zx s_1009_12 -> bv
        let s_1009_13: Bits = Bits::new(s_1009_12 as u128, 9u16);
        // D s_1009_14: cmp-eq s_1009_11 s_1009_13
        let s_1009_14: bool = ((s_1009_11) == (s_1009_13));
        // N s_1009_15: branch s_1009_14 b2122 b1010
        if s_1009_14 {
            return block_2122(state, tracer, fn_state);
        } else {
            return block_1010(state, tracer, fn_state);
        };
    }
    fn block_1010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1010_0: const #0u : u8
        let s_1010_0: bool = false;
        // D s_1010_1: write-var gs#401658 <= s_1010_0
        fn_state.gs_401658 = s_1010_0;
        // N s_1010_2: jump b1011
        return block_1011(state, tracer, fn_state);
    }
    fn block_1011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1011_0: read-var gs#401658:u8
        let s_1011_0: bool = fn_state.gs_401658;
        // N s_1011_1: branch s_1011_0 b2121 b1012
        if s_1011_0 {
            return block_2121(state, tracer, fn_state);
        } else {
            return block_1012(state, tracer, fn_state);
        };
    }
    fn block_1012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1012_0: const #0u : u8
        let s_1012_0: bool = false;
        // D s_1012_1: write-var gs#401660 <= s_1012_0
        fn_state.gs_401660 = s_1012_0;
        // N s_1012_2: jump b1013
        return block_1013(state, tracer, fn_state);
    }
    fn block_1013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1013_0: read-var gs#401660:u8
        let s_1013_0: bool = fn_state.gs_401660;
        // D s_1013_1: not s_1013_0
        let s_1013_1: bool = !s_1013_0;
        // N s_1013_2: branch s_1013_1 b1015 b1014
        if s_1013_1 {
            return block_1015(state, tracer, fn_state);
        } else {
            return block_1014(state, tracer, fn_state);
        };
    }
    fn block_1014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1014_0: const #3650s : i
        let s_1014_0: i128 = 3650;
        // C s_1014_1: const #14696u : u32
        let s_1014_1: u32 = 14696;
        // N s_1014_2: write-reg s_1014_1 <= s_1014_0
        let s_1014_2: () = {
            state.write_register::<i128>(s_1014_1 as isize, s_1014_0);
            tracer.write_register(s_1014_1 as isize, s_1014_0);
        };
        // C s_1014_3: const #22s : i
        let s_1014_3: i128 = 22;
        // C s_1014_4: const #1s : i
        let s_1014_4: i128 = 1;
        // D s_1014_5: read-var u#31708:u32
        let s_1014_5: u32 = fn_state.u_31708;
        // D s_1014_6: cast zx s_1014_5 -> bv
        let s_1014_6: Bits = Bits::new(s_1014_5 as u128, 32u16);
        // D s_1014_7: bit-extract s_1014_6 s_1014_3 s_1014_4
        let s_1014_7: Bits = (Bits::new(
            ((s_1014_6) >> (s_1014_3)).value(),
            u16::try_from(s_1014_4).unwrap(),
        ));
        // D s_1014_8: cast reint s_1014_7 -> u8
        let s_1014_8: bool = ((s_1014_7.value()) != 0);
        // C s_1014_9: const #18s : i
        let s_1014_9: i128 = 18;
        // C s_1014_10: const #2s : i
        let s_1014_10: i128 = 2;
        // D s_1014_11: read-var u#31708:u32
        let s_1014_11: u32 = fn_state.u_31708;
        // D s_1014_12: cast zx s_1014_11 -> bv
        let s_1014_12: Bits = Bits::new(s_1014_11 as u128, 32u16);
        // D s_1014_13: bit-extract s_1014_12 s_1014_9 s_1014_10
        let s_1014_13: Bits = (Bits::new(
            ((s_1014_12) >> (s_1014_9)).value(),
            u16::try_from(s_1014_10).unwrap(),
        ));
        // D s_1014_14: cast reint s_1014_13 -> u8
        let s_1014_14: u8 = (s_1014_13.value() as u8);
        // C s_1014_15: const #12s : i
        let s_1014_15: i128 = 12;
        // C s_1014_16: const #4s : i
        let s_1014_16: i128 = 4;
        // D s_1014_17: read-var u#31708:u32
        let s_1014_17: u32 = fn_state.u_31708;
        // D s_1014_18: cast zx s_1014_17 -> bv
        let s_1014_18: Bits = Bits::new(s_1014_17 as u128, 32u16);
        // D s_1014_19: bit-extract s_1014_18 s_1014_15 s_1014_16
        let s_1014_19: Bits = (Bits::new(
            ((s_1014_18) >> (s_1014_15)).value(),
            u16::try_from(s_1014_16).unwrap(),
        ));
        // D s_1014_20: cast reint s_1014_19 -> u8
        let s_1014_20: u8 = (s_1014_19.value() as u8);
        // C s_1014_21: const #8s : i
        let s_1014_21: i128 = 8;
        // C s_1014_22: const #1s : i
        let s_1014_22: i128 = 1;
        // D s_1014_23: read-var u#31708:u32
        let s_1014_23: u32 = fn_state.u_31708;
        // D s_1014_24: cast zx s_1014_23 -> bv
        let s_1014_24: Bits = Bits::new(s_1014_23 as u128, 32u16);
        // D s_1014_25: bit-extract s_1014_24 s_1014_21 s_1014_22
        let s_1014_25: Bits = (Bits::new(
            ((s_1014_24) >> (s_1014_21)).value(),
            u16::try_from(s_1014_22).unwrap(),
        ));
        // D s_1014_26: cast reint s_1014_25 -> u8
        let s_1014_26: bool = ((s_1014_25.value()) != 0);
        // C s_1014_27: const #6s : i
        let s_1014_27: i128 = 6;
        // C s_1014_28: const #1s : i
        let s_1014_28: i128 = 1;
        // D s_1014_29: read-var u#31708:u32
        let s_1014_29: u32 = fn_state.u_31708;
        // D s_1014_30: cast zx s_1014_29 -> bv
        let s_1014_30: Bits = Bits::new(s_1014_29 as u128, 32u16);
        // D s_1014_31: bit-extract s_1014_30 s_1014_27 s_1014_28
        let s_1014_31: Bits = (Bits::new(
            ((s_1014_30) >> (s_1014_27)).value(),
            u16::try_from(s_1014_28).unwrap(),
        ));
        // D s_1014_32: cast reint s_1014_31 -> u8
        let s_1014_32: bool = ((s_1014_31.value()) != 0);
        // C s_1014_33: const #5s : i
        let s_1014_33: i128 = 5;
        // C s_1014_34: const #1s : i
        let s_1014_34: i128 = 1;
        // D s_1014_35: read-var u#31708:u32
        let s_1014_35: u32 = fn_state.u_31708;
        // D s_1014_36: cast zx s_1014_35 -> bv
        let s_1014_36: Bits = Bits::new(s_1014_35 as u128, 32u16);
        // D s_1014_37: bit-extract s_1014_36 s_1014_33 s_1014_34
        let s_1014_37: Bits = (Bits::new(
            ((s_1014_36) >> (s_1014_33)).value(),
            u16::try_from(s_1014_34).unwrap(),
        ));
        // D s_1014_38: cast reint s_1014_37 -> u8
        let s_1014_38: bool = ((s_1014_37.value()) != 0);
        // C s_1014_39: const #0s : i
        let s_1014_39: i128 = 0;
        // C s_1014_40: const #4s : i
        let s_1014_40: i128 = 4;
        // D s_1014_41: read-var u#31708:u32
        let s_1014_41: u32 = fn_state.u_31708;
        // D s_1014_42: cast zx s_1014_41 -> bv
        let s_1014_42: Bits = Bits::new(s_1014_41 as u128, 32u16);
        // D s_1014_43: bit-extract s_1014_42 s_1014_39 s_1014_40
        let s_1014_43: Bits = (Bits::new(
            ((s_1014_42) >> (s_1014_39)).value(),
            u16::try_from(s_1014_40).unwrap(),
        ));
        // D s_1014_44: cast reint s_1014_43 -> u8
        let s_1014_44: u8 = (s_1014_43.value() as u8);
        // D s_1014_45: call decode_aarch32_instrs_VRECPE_A1enc_A_txt(s_1014_8, s_1014_14, s_1014_20, s_1014_26, s_1014_32, s_1014_38, s_1014_44)
        let s_1014_45: () = decode_aarch32_instrs_VRECPE_A1enc_A_txt(
            state,
            tracer,
            s_1014_8,
            s_1014_14,
            s_1014_20,
            s_1014_26,
            s_1014_32,
            s_1014_38,
            s_1014_44,
        );
        // N s_1014_46: return
        return;
    }
    fn block_1015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1015_0: read-var merge#var.1:struct
        let s_1015_0: u32 = fn_state.merge_var._1;
        // D s_1015_1: write-var u#31717 <= s_1015_0
        fn_state.u_31717 = s_1015_0;
        // C s_1015_2: const #23s : i
        let s_1015_2: i128 = 23;
        // D s_1015_3: read-var u#31717:u32
        let s_1015_3: u32 = fn_state.u_31717;
        // D s_1015_4: cast zx s_1015_3 -> bv
        let s_1015_4: Bits = Bits::new(s_1015_3 as u128, 32u16);
        // C s_1015_5: const #1s : i64
        let s_1015_5: i64 = 1;
        // C s_1015_6: cast zx s_1015_5 -> i
        let s_1015_6: i128 = (i128::try_from(s_1015_5).unwrap());
        // C s_1015_7: const #8s : i
        let s_1015_7: i128 = 8;
        // C s_1015_8: add s_1015_7 s_1015_6
        let s_1015_8: i128 = (s_1015_7 + s_1015_6);
        // D s_1015_9: bit-extract s_1015_4 s_1015_2 s_1015_8
        let s_1015_9: Bits = (Bits::new(
            ((s_1015_4) >> (s_1015_2)).value(),
            u16::try_from(s_1015_8).unwrap(),
        ));
        // D s_1015_10: cast reint s_1015_9 -> u9
        let s_1015_10: u16 = (s_1015_9.value() as u16);
        // D s_1015_11: cast zx s_1015_10 -> bv
        let s_1015_11: Bits = Bits::new(s_1015_10 as u128, 9u16);
        // C s_1015_12: const #484u : u9
        let s_1015_12: u16 = 484;
        // C s_1015_13: cast zx s_1015_12 -> bv
        let s_1015_13: Bits = Bits::new(s_1015_12 as u128, 9u16);
        // D s_1015_14: cmp-eq s_1015_11 s_1015_13
        let s_1015_14: bool = ((s_1015_11) == (s_1015_13));
        // N s_1015_15: branch s_1015_14 b2114 b1016
        if s_1015_14 {
            return block_2114(state, tracer, fn_state);
        } else {
            return block_1016(state, tracer, fn_state);
        };
    }
    fn block_1016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1016_0: const #0u : u8
        let s_1016_0: bool = false;
        // D s_1016_1: write-var gs#401688 <= s_1016_0
        fn_state.gs_401688 = s_1016_0;
        // N s_1016_2: jump b1017
        return block_1017(state, tracer, fn_state);
    }
    fn block_1017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1017_0: read-var gs#401688:u8
        let s_1017_0: bool = fn_state.gs_401688;
        // N s_1017_1: branch s_1017_0 b2113 b1018
        if s_1017_0 {
            return block_2113(state, tracer, fn_state);
        } else {
            return block_1018(state, tracer, fn_state);
        };
    }
    fn block_1018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1018_0: const #0u : u8
        let s_1018_0: bool = false;
        // D s_1018_1: write-var gs#401690 <= s_1018_0
        fn_state.gs_401690 = s_1018_0;
        // N s_1018_2: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_1019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1019_0: read-var gs#401690:u8
        let s_1019_0: bool = fn_state.gs_401690;
        // D s_1019_1: not s_1019_0
        let s_1019_1: bool = !s_1019_0;
        // N s_1019_2: branch s_1019_1 b1021 b1020
        if s_1019_1 {
            return block_1021(state, tracer, fn_state);
        } else {
            return block_1020(state, tracer, fn_state);
        };
    }
    fn block_1020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1020_0: const #3652s : i
        let s_1020_0: i128 = 3652;
        // C s_1020_1: const #14696u : u32
        let s_1020_1: u32 = 14696;
        // N s_1020_2: write-reg s_1020_1 <= s_1020_0
        let s_1020_2: () = {
            state.write_register::<i128>(s_1020_1 as isize, s_1020_0);
            tracer.write_register(s_1020_1 as isize, s_1020_0);
        };
        // C s_1020_3: const #22s : i
        let s_1020_3: i128 = 22;
        // C s_1020_4: const #1s : i
        let s_1020_4: i128 = 1;
        // D s_1020_5: read-var u#31717:u32
        let s_1020_5: u32 = fn_state.u_31717;
        // D s_1020_6: cast zx s_1020_5 -> bv
        let s_1020_6: Bits = Bits::new(s_1020_5 as u128, 32u16);
        // D s_1020_7: bit-extract s_1020_6 s_1020_3 s_1020_4
        let s_1020_7: Bits = (Bits::new(
            ((s_1020_6) >> (s_1020_3)).value(),
            u16::try_from(s_1020_4).unwrap(),
        ));
        // D s_1020_8: cast reint s_1020_7 -> u8
        let s_1020_8: bool = ((s_1020_7.value()) != 0);
        // C s_1020_9: const #20s : i
        let s_1020_9: i128 = 20;
        // C s_1020_10: const #1s : i
        let s_1020_10: i128 = 1;
        // D s_1020_11: read-var u#31717:u32
        let s_1020_11: u32 = fn_state.u_31717;
        // D s_1020_12: cast zx s_1020_11 -> bv
        let s_1020_12: Bits = Bits::new(s_1020_11 as u128, 32u16);
        // D s_1020_13: bit-extract s_1020_12 s_1020_9 s_1020_10
        let s_1020_13: Bits = (Bits::new(
            ((s_1020_12) >> (s_1020_9)).value(),
            u16::try_from(s_1020_10).unwrap(),
        ));
        // D s_1020_14: cast reint s_1020_13 -> u8
        let s_1020_14: bool = ((s_1020_13.value()) != 0);
        // C s_1020_15: const #16s : i
        let s_1020_15: i128 = 16;
        // C s_1020_16: const #4s : i
        let s_1020_16: i128 = 4;
        // D s_1020_17: read-var u#31717:u32
        let s_1020_17: u32 = fn_state.u_31717;
        // D s_1020_18: cast zx s_1020_17 -> bv
        let s_1020_18: Bits = Bits::new(s_1020_17 as u128, 32u16);
        // D s_1020_19: bit-extract s_1020_18 s_1020_15 s_1020_16
        let s_1020_19: Bits = (Bits::new(
            ((s_1020_18) >> (s_1020_15)).value(),
            u16::try_from(s_1020_16).unwrap(),
        ));
        // D s_1020_20: cast reint s_1020_19 -> u8
        let s_1020_20: u8 = (s_1020_19.value() as u8);
        // C s_1020_21: const #12s : i
        let s_1020_21: i128 = 12;
        // C s_1020_22: const #4s : i
        let s_1020_22: i128 = 4;
        // D s_1020_23: read-var u#31717:u32
        let s_1020_23: u32 = fn_state.u_31717;
        // D s_1020_24: cast zx s_1020_23 -> bv
        let s_1020_24: Bits = Bits::new(s_1020_23 as u128, 32u16);
        // D s_1020_25: bit-extract s_1020_24 s_1020_21 s_1020_22
        let s_1020_25: Bits = (Bits::new(
            ((s_1020_24) >> (s_1020_21)).value(),
            u16::try_from(s_1020_22).unwrap(),
        ));
        // D s_1020_26: cast reint s_1020_25 -> u8
        let s_1020_26: u8 = (s_1020_25.value() as u8);
        // C s_1020_27: const #7s : i
        let s_1020_27: i128 = 7;
        // C s_1020_28: const #1s : i
        let s_1020_28: i128 = 1;
        // D s_1020_29: read-var u#31717:u32
        let s_1020_29: u32 = fn_state.u_31717;
        // D s_1020_30: cast zx s_1020_29 -> bv
        let s_1020_30: Bits = Bits::new(s_1020_29 as u128, 32u16);
        // D s_1020_31: bit-extract s_1020_30 s_1020_27 s_1020_28
        let s_1020_31: Bits = (Bits::new(
            ((s_1020_30) >> (s_1020_27)).value(),
            u16::try_from(s_1020_28).unwrap(),
        ));
        // D s_1020_32: cast reint s_1020_31 -> u8
        let s_1020_32: bool = ((s_1020_31.value()) != 0);
        // C s_1020_33: const #6s : i
        let s_1020_33: i128 = 6;
        // C s_1020_34: const #1s : i
        let s_1020_34: i128 = 1;
        // D s_1020_35: read-var u#31717:u32
        let s_1020_35: u32 = fn_state.u_31717;
        // D s_1020_36: cast zx s_1020_35 -> bv
        let s_1020_36: Bits = Bits::new(s_1020_35 as u128, 32u16);
        // D s_1020_37: bit-extract s_1020_36 s_1020_33 s_1020_34
        let s_1020_37: Bits = (Bits::new(
            ((s_1020_36) >> (s_1020_33)).value(),
            u16::try_from(s_1020_34).unwrap(),
        ));
        // D s_1020_38: cast reint s_1020_37 -> u8
        let s_1020_38: bool = ((s_1020_37.value()) != 0);
        // C s_1020_39: const #5s : i
        let s_1020_39: i128 = 5;
        // C s_1020_40: const #1s : i
        let s_1020_40: i128 = 1;
        // D s_1020_41: read-var u#31717:u32
        let s_1020_41: u32 = fn_state.u_31717;
        // D s_1020_42: cast zx s_1020_41 -> bv
        let s_1020_42: Bits = Bits::new(s_1020_41 as u128, 32u16);
        // D s_1020_43: bit-extract s_1020_42 s_1020_39 s_1020_40
        let s_1020_43: Bits = (Bits::new(
            ((s_1020_42) >> (s_1020_39)).value(),
            u16::try_from(s_1020_40).unwrap(),
        ));
        // D s_1020_44: cast reint s_1020_43 -> u8
        let s_1020_44: bool = ((s_1020_43.value()) != 0);
        // C s_1020_45: const #0s : i
        let s_1020_45: i128 = 0;
        // C s_1020_46: const #4s : i
        let s_1020_46: i128 = 4;
        // D s_1020_47: read-var u#31717:u32
        let s_1020_47: u32 = fn_state.u_31717;
        // D s_1020_48: cast zx s_1020_47 -> bv
        let s_1020_48: Bits = Bits::new(s_1020_47 as u128, 32u16);
        // D s_1020_49: bit-extract s_1020_48 s_1020_45 s_1020_46
        let s_1020_49: Bits = (Bits::new(
            ((s_1020_48) >> (s_1020_45)).value(),
            u16::try_from(s_1020_46).unwrap(),
        ));
        // D s_1020_50: cast reint s_1020_49 -> u8
        let s_1020_50: u8 = (s_1020_49.value() as u8);
        // D s_1020_51: call decode_aarch32_instrs_VRECPS_A1enc_A_txt(s_1020_8, s_1020_14, s_1020_20, s_1020_26, s_1020_32, s_1020_38, s_1020_44, s_1020_50)
        let s_1020_51: () = decode_aarch32_instrs_VRECPS_A1enc_A_txt(
            state,
            tracer,
            s_1020_8,
            s_1020_14,
            s_1020_20,
            s_1020_26,
            s_1020_32,
            s_1020_38,
            s_1020_44,
            s_1020_50,
        );
        // N s_1020_52: return
        return;
    }
    fn block_1021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1021_0: read-var merge#var.1:struct
        let s_1021_0: u32 = fn_state.merge_var._1;
        // D s_1021_1: write-var u#31727 <= s_1021_0
        fn_state.u_31727 = s_1021_0;
        // C s_1021_2: const #23s : i
        let s_1021_2: i128 = 23;
        // D s_1021_3: read-var u#31727:u32
        let s_1021_3: u32 = fn_state.u_31727;
        // D s_1021_4: cast zx s_1021_3 -> bv
        let s_1021_4: Bits = Bits::new(s_1021_3 as u128, 32u16);
        // C s_1021_5: const #1s : i64
        let s_1021_5: i64 = 1;
        // C s_1021_6: cast zx s_1021_5 -> i
        let s_1021_6: i128 = (i128::try_from(s_1021_5).unwrap());
        // C s_1021_7: const #8s : i
        let s_1021_7: i128 = 8;
        // C s_1021_8: add s_1021_7 s_1021_6
        let s_1021_8: i128 = (s_1021_7 + s_1021_6);
        // D s_1021_9: bit-extract s_1021_4 s_1021_2 s_1021_8
        let s_1021_9: Bits = (Bits::new(
            ((s_1021_4) >> (s_1021_2)).value(),
            u16::try_from(s_1021_8).unwrap(),
        ));
        // D s_1021_10: cast reint s_1021_9 -> u9
        let s_1021_10: u16 = (s_1021_9.value() as u16);
        // D s_1021_11: cast zx s_1021_10 -> bv
        let s_1021_11: Bits = Bits::new(s_1021_10 as u128, 9u16);
        // C s_1021_12: const #487u : u9
        let s_1021_12: u16 = 487;
        // C s_1021_13: cast zx s_1021_12 -> bv
        let s_1021_13: Bits = Bits::new(s_1021_12 as u128, 9u16);
        // D s_1021_14: cmp-eq s_1021_11 s_1021_13
        let s_1021_14: bool = ((s_1021_11) == (s_1021_13));
        // N s_1021_15: branch s_1021_14 b2103 b1022
        if s_1021_14 {
            return block_2103(state, tracer, fn_state);
        } else {
            return block_1022(state, tracer, fn_state);
        };
    }
    fn block_1022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1022_0: const #0u : u8
        let s_1022_0: bool = false;
        // D s_1022_1: write-var gs#401723 <= s_1022_0
        fn_state.gs_401723 = s_1022_0;
        // N s_1022_2: jump b1023
        return block_1023(state, tracer, fn_state);
    }
    fn block_1023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1023_0: read-var gs#401723:u8
        let s_1023_0: bool = fn_state.gs_401723;
        // N s_1023_1: branch s_1023_0 b2102 b1024
        if s_1023_0 {
            return block_2102(state, tracer, fn_state);
        } else {
            return block_1024(state, tracer, fn_state);
        };
    }
    fn block_1024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1024_0: const #0u : u8
        let s_1024_0: bool = false;
        // D s_1024_1: write-var gs#401725 <= s_1024_0
        fn_state.gs_401725 = s_1024_0;
        // N s_1024_2: jump b1025
        return block_1025(state, tracer, fn_state);
    }
    fn block_1025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1025_0: read-var gs#401725:u8
        let s_1025_0: bool = fn_state.gs_401725;
        // D s_1025_1: not s_1025_0
        let s_1025_1: bool = !s_1025_0;
        // N s_1025_2: branch s_1025_1 b1027 b1026
        if s_1025_1 {
            return block_1027(state, tracer, fn_state);
        } else {
            return block_1026(state, tracer, fn_state);
        };
    }
    fn block_1026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1026_0: const #3654s : i
        let s_1026_0: i128 = 3654;
        // C s_1026_1: const #14696u : u32
        let s_1026_1: u32 = 14696;
        // N s_1026_2: write-reg s_1026_1 <= s_1026_0
        let s_1026_2: () = {
            state.write_register::<i128>(s_1026_1 as isize, s_1026_0);
            tracer.write_register(s_1026_1 as isize, s_1026_0);
        };
        // C s_1026_3: const #22s : i
        let s_1026_3: i128 = 22;
        // C s_1026_4: const #1s : i
        let s_1026_4: i128 = 1;
        // D s_1026_5: read-var u#31727:u32
        let s_1026_5: u32 = fn_state.u_31727;
        // D s_1026_6: cast zx s_1026_5 -> bv
        let s_1026_6: Bits = Bits::new(s_1026_5 as u128, 32u16);
        // D s_1026_7: bit-extract s_1026_6 s_1026_3 s_1026_4
        let s_1026_7: Bits = (Bits::new(
            ((s_1026_6) >> (s_1026_3)).value(),
            u16::try_from(s_1026_4).unwrap(),
        ));
        // D s_1026_8: cast reint s_1026_7 -> u8
        let s_1026_8: bool = ((s_1026_7.value()) != 0);
        // C s_1026_9: const #18s : i
        let s_1026_9: i128 = 18;
        // C s_1026_10: const #2s : i
        let s_1026_10: i128 = 2;
        // D s_1026_11: read-var u#31727:u32
        let s_1026_11: u32 = fn_state.u_31727;
        // D s_1026_12: cast zx s_1026_11 -> bv
        let s_1026_12: Bits = Bits::new(s_1026_11 as u128, 32u16);
        // D s_1026_13: bit-extract s_1026_12 s_1026_9 s_1026_10
        let s_1026_13: Bits = (Bits::new(
            ((s_1026_12) >> (s_1026_9)).value(),
            u16::try_from(s_1026_10).unwrap(),
        ));
        // D s_1026_14: cast reint s_1026_13 -> u8
        let s_1026_14: u8 = (s_1026_13.value() as u8);
        // C s_1026_15: const #12s : i
        let s_1026_15: i128 = 12;
        // C s_1026_16: const #4s : i
        let s_1026_16: i128 = 4;
        // D s_1026_17: read-var u#31727:u32
        let s_1026_17: u32 = fn_state.u_31727;
        // D s_1026_18: cast zx s_1026_17 -> bv
        let s_1026_18: Bits = Bits::new(s_1026_17 as u128, 32u16);
        // D s_1026_19: bit-extract s_1026_18 s_1026_15 s_1026_16
        let s_1026_19: Bits = (Bits::new(
            ((s_1026_18) >> (s_1026_15)).value(),
            u16::try_from(s_1026_16).unwrap(),
        ));
        // D s_1026_20: cast reint s_1026_19 -> u8
        let s_1026_20: u8 = (s_1026_19.value() as u8);
        // C s_1026_21: const #7s : i
        let s_1026_21: i128 = 7;
        // C s_1026_22: const #2s : i
        let s_1026_22: i128 = 2;
        // D s_1026_23: read-var u#31727:u32
        let s_1026_23: u32 = fn_state.u_31727;
        // D s_1026_24: cast zx s_1026_23 -> bv
        let s_1026_24: Bits = Bits::new(s_1026_23 as u128, 32u16);
        // D s_1026_25: bit-extract s_1026_24 s_1026_21 s_1026_22
        let s_1026_25: Bits = (Bits::new(
            ((s_1026_24) >> (s_1026_21)).value(),
            u16::try_from(s_1026_22).unwrap(),
        ));
        // D s_1026_26: cast reint s_1026_25 -> u8
        let s_1026_26: u8 = (s_1026_25.value() as u8);
        // C s_1026_27: const #6s : i
        let s_1026_27: i128 = 6;
        // C s_1026_28: const #1s : i
        let s_1026_28: i128 = 1;
        // D s_1026_29: read-var u#31727:u32
        let s_1026_29: u32 = fn_state.u_31727;
        // D s_1026_30: cast zx s_1026_29 -> bv
        let s_1026_30: Bits = Bits::new(s_1026_29 as u128, 32u16);
        // D s_1026_31: bit-extract s_1026_30 s_1026_27 s_1026_28
        let s_1026_31: Bits = (Bits::new(
            ((s_1026_30) >> (s_1026_27)).value(),
            u16::try_from(s_1026_28).unwrap(),
        ));
        // D s_1026_32: cast reint s_1026_31 -> u8
        let s_1026_32: bool = ((s_1026_31.value()) != 0);
        // C s_1026_33: const #5s : i
        let s_1026_33: i128 = 5;
        // C s_1026_34: const #1s : i
        let s_1026_34: i128 = 1;
        // D s_1026_35: read-var u#31727:u32
        let s_1026_35: u32 = fn_state.u_31727;
        // D s_1026_36: cast zx s_1026_35 -> bv
        let s_1026_36: Bits = Bits::new(s_1026_35 as u128, 32u16);
        // D s_1026_37: bit-extract s_1026_36 s_1026_33 s_1026_34
        let s_1026_37: Bits = (Bits::new(
            ((s_1026_36) >> (s_1026_33)).value(),
            u16::try_from(s_1026_34).unwrap(),
        ));
        // D s_1026_38: cast reint s_1026_37 -> u8
        let s_1026_38: bool = ((s_1026_37.value()) != 0);
        // C s_1026_39: const #0s : i
        let s_1026_39: i128 = 0;
        // C s_1026_40: const #4s : i
        let s_1026_40: i128 = 4;
        // D s_1026_41: read-var u#31727:u32
        let s_1026_41: u32 = fn_state.u_31727;
        // D s_1026_42: cast zx s_1026_41 -> bv
        let s_1026_42: Bits = Bits::new(s_1026_41 as u128, 32u16);
        // D s_1026_43: bit-extract s_1026_42 s_1026_39 s_1026_40
        let s_1026_43: Bits = (Bits::new(
            ((s_1026_42) >> (s_1026_39)).value(),
            u16::try_from(s_1026_40).unwrap(),
        ));
        // D s_1026_44: cast reint s_1026_43 -> u8
        let s_1026_44: u8 = (s_1026_43.value() as u8);
        // D s_1026_45: call decode_aarch32_instrs_VREV16_A1enc_A_txt(s_1026_8, s_1026_14, s_1026_20, s_1026_26, s_1026_32, s_1026_38, s_1026_44)
        let s_1026_45: () = decode_aarch32_instrs_VREV16_A1enc_A_txt(
            state,
            tracer,
            s_1026_8,
            s_1026_14,
            s_1026_20,
            s_1026_26,
            s_1026_32,
            s_1026_38,
            s_1026_44,
        );
        // N s_1026_46: return
        return;
    }
    fn block_1027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1027_0: read-var merge#var.1:struct
        let s_1027_0: u32 = fn_state.merge_var._1;
        // D s_1027_1: write-var u#31736 <= s_1027_0
        fn_state.u_31736 = s_1027_0;
        // C s_1027_2: const #25s : i
        let s_1027_2: i128 = 25;
        // D s_1027_3: read-var u#31736:u32
        let s_1027_3: u32 = fn_state.u_31736;
        // D s_1027_4: cast zx s_1027_3 -> bv
        let s_1027_4: Bits = Bits::new(s_1027_3 as u128, 32u16);
        // C s_1027_5: const #1s : i64
        let s_1027_5: i64 = 1;
        // C s_1027_6: cast zx s_1027_5 -> i
        let s_1027_6: i128 = (i128::try_from(s_1027_5).unwrap());
        // C s_1027_7: const #6s : i
        let s_1027_7: i128 = 6;
        // C s_1027_8: add s_1027_7 s_1027_6
        let s_1027_8: i128 = (s_1027_7 + s_1027_6);
        // D s_1027_9: bit-extract s_1027_4 s_1027_2 s_1027_8
        let s_1027_9: Bits = (Bits::new(
            ((s_1027_4) >> (s_1027_2)).value(),
            u16::try_from(s_1027_8).unwrap(),
        ));
        // D s_1027_10: cast reint s_1027_9 -> u8
        let s_1027_10: u8 = (s_1027_9.value() as u8);
        // D s_1027_11: cast zx s_1027_10 -> bv
        let s_1027_11: Bits = Bits::new(s_1027_10 as u128, 7u16);
        // C s_1027_12: const #121u : u8
        let s_1027_12: u8 = 121;
        // C s_1027_13: cast zx s_1027_12 -> bv
        let s_1027_13: Bits = Bits::new(s_1027_12 as u128, 7u16);
        // D s_1027_14: cmp-eq s_1027_11 s_1027_13
        let s_1027_14: bool = ((s_1027_11) == (s_1027_13));
        // N s_1027_15: branch s_1027_14 b2095 b1028
        if s_1027_14 {
            return block_2095(state, tracer, fn_state);
        } else {
            return block_1028(state, tracer, fn_state);
        };
    }
    fn block_1028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1028_0: const #0u : u8
        let s_1028_0: bool = false;
        // D s_1028_1: write-var gs#401753 <= s_1028_0
        fn_state.gs_401753 = s_1028_0;
        // N s_1028_2: jump b1029
        return block_1029(state, tracer, fn_state);
    }
    fn block_1029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1029_0: read-var gs#401753:u8
        let s_1029_0: bool = fn_state.gs_401753;
        // N s_1029_1: branch s_1029_0 b2094 b1030
        if s_1029_0 {
            return block_2094(state, tracer, fn_state);
        } else {
            return block_1030(state, tracer, fn_state);
        };
    }
    fn block_1030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1030_0: const #0u : u8
        let s_1030_0: bool = false;
        // D s_1030_1: write-var gs#401755 <= s_1030_0
        fn_state.gs_401755 = s_1030_0;
        // N s_1030_2: jump b1031
        return block_1031(state, tracer, fn_state);
    }
    fn block_1031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1031_0: read-var gs#401755:u8
        let s_1031_0: bool = fn_state.gs_401755;
        // D s_1031_1: not s_1031_0
        let s_1031_1: bool = !s_1031_0;
        // N s_1031_2: branch s_1031_1 b1033 b1032
        if s_1031_1 {
            return block_1033(state, tracer, fn_state);
        } else {
            return block_1032(state, tracer, fn_state);
        };
    }
    fn block_1032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1032_0: const #3656s : i
        let s_1032_0: i128 = 3656;
        // C s_1032_1: const #14696u : u32
        let s_1032_1: u32 = 14696;
        // N s_1032_2: write-reg s_1032_1 <= s_1032_0
        let s_1032_2: () = {
            state.write_register::<i128>(s_1032_1 as isize, s_1032_0);
            tracer.write_register(s_1032_1 as isize, s_1032_0);
        };
        // C s_1032_3: const #24s : i
        let s_1032_3: i128 = 24;
        // C s_1032_4: const #1s : i
        let s_1032_4: i128 = 1;
        // D s_1032_5: read-var u#31736:u32
        let s_1032_5: u32 = fn_state.u_31736;
        // D s_1032_6: cast zx s_1032_5 -> bv
        let s_1032_6: Bits = Bits::new(s_1032_5 as u128, 32u16);
        // D s_1032_7: bit-extract s_1032_6 s_1032_3 s_1032_4
        let s_1032_7: Bits = (Bits::new(
            ((s_1032_6) >> (s_1032_3)).value(),
            u16::try_from(s_1032_4).unwrap(),
        ));
        // D s_1032_8: cast reint s_1032_7 -> u8
        let s_1032_8: bool = ((s_1032_7.value()) != 0);
        // C s_1032_9: const #22s : i
        let s_1032_9: i128 = 22;
        // C s_1032_10: const #1s : i
        let s_1032_10: i128 = 1;
        // D s_1032_11: read-var u#31736:u32
        let s_1032_11: u32 = fn_state.u_31736;
        // D s_1032_12: cast zx s_1032_11 -> bv
        let s_1032_12: Bits = Bits::new(s_1032_11 as u128, 32u16);
        // D s_1032_13: bit-extract s_1032_12 s_1032_9 s_1032_10
        let s_1032_13: Bits = (Bits::new(
            ((s_1032_12) >> (s_1032_9)).value(),
            u16::try_from(s_1032_10).unwrap(),
        ));
        // D s_1032_14: cast reint s_1032_13 -> u8
        let s_1032_14: bool = ((s_1032_13.value()) != 0);
        // C s_1032_15: const #20s : i
        let s_1032_15: i128 = 20;
        // C s_1032_16: const #2s : i
        let s_1032_16: i128 = 2;
        // D s_1032_17: read-var u#31736:u32
        let s_1032_17: u32 = fn_state.u_31736;
        // D s_1032_18: cast zx s_1032_17 -> bv
        let s_1032_18: Bits = Bits::new(s_1032_17 as u128, 32u16);
        // D s_1032_19: bit-extract s_1032_18 s_1032_15 s_1032_16
        let s_1032_19: Bits = (Bits::new(
            ((s_1032_18) >> (s_1032_15)).value(),
            u16::try_from(s_1032_16).unwrap(),
        ));
        // D s_1032_20: cast reint s_1032_19 -> u8
        let s_1032_20: u8 = (s_1032_19.value() as u8);
        // C s_1032_21: const #16s : i
        let s_1032_21: i128 = 16;
        // C s_1032_22: const #4s : i
        let s_1032_22: i128 = 4;
        // D s_1032_23: read-var u#31736:u32
        let s_1032_23: u32 = fn_state.u_31736;
        // D s_1032_24: cast zx s_1032_23 -> bv
        let s_1032_24: Bits = Bits::new(s_1032_23 as u128, 32u16);
        // D s_1032_25: bit-extract s_1032_24 s_1032_21 s_1032_22
        let s_1032_25: Bits = (Bits::new(
            ((s_1032_24) >> (s_1032_21)).value(),
            u16::try_from(s_1032_22).unwrap(),
        ));
        // D s_1032_26: cast reint s_1032_25 -> u8
        let s_1032_26: u8 = (s_1032_25.value() as u8);
        // C s_1032_27: const #12s : i
        let s_1032_27: i128 = 12;
        // C s_1032_28: const #4s : i
        let s_1032_28: i128 = 4;
        // D s_1032_29: read-var u#31736:u32
        let s_1032_29: u32 = fn_state.u_31736;
        // D s_1032_30: cast zx s_1032_29 -> bv
        let s_1032_30: Bits = Bits::new(s_1032_29 as u128, 32u16);
        // D s_1032_31: bit-extract s_1032_30 s_1032_27 s_1032_28
        let s_1032_31: Bits = (Bits::new(
            ((s_1032_30) >> (s_1032_27)).value(),
            u16::try_from(s_1032_28).unwrap(),
        ));
        // D s_1032_32: cast reint s_1032_31 -> u8
        let s_1032_32: u8 = (s_1032_31.value() as u8);
        // C s_1032_33: const #7s : i
        let s_1032_33: i128 = 7;
        // C s_1032_34: const #1s : i
        let s_1032_34: i128 = 1;
        // D s_1032_35: read-var u#31736:u32
        let s_1032_35: u32 = fn_state.u_31736;
        // D s_1032_36: cast zx s_1032_35 -> bv
        let s_1032_36: Bits = Bits::new(s_1032_35 as u128, 32u16);
        // D s_1032_37: bit-extract s_1032_36 s_1032_33 s_1032_34
        let s_1032_37: Bits = (Bits::new(
            ((s_1032_36) >> (s_1032_33)).value(),
            u16::try_from(s_1032_34).unwrap(),
        ));
        // D s_1032_38: cast reint s_1032_37 -> u8
        let s_1032_38: bool = ((s_1032_37.value()) != 0);
        // C s_1032_39: const #6s : i
        let s_1032_39: i128 = 6;
        // C s_1032_40: const #1s : i
        let s_1032_40: i128 = 1;
        // D s_1032_41: read-var u#31736:u32
        let s_1032_41: u32 = fn_state.u_31736;
        // D s_1032_42: cast zx s_1032_41 -> bv
        let s_1032_42: Bits = Bits::new(s_1032_41 as u128, 32u16);
        // D s_1032_43: bit-extract s_1032_42 s_1032_39 s_1032_40
        let s_1032_43: Bits = (Bits::new(
            ((s_1032_42) >> (s_1032_39)).value(),
            u16::try_from(s_1032_40).unwrap(),
        ));
        // D s_1032_44: cast reint s_1032_43 -> u8
        let s_1032_44: bool = ((s_1032_43.value()) != 0);
        // C s_1032_45: const #5s : i
        let s_1032_45: i128 = 5;
        // C s_1032_46: const #1s : i
        let s_1032_46: i128 = 1;
        // D s_1032_47: read-var u#31736:u32
        let s_1032_47: u32 = fn_state.u_31736;
        // D s_1032_48: cast zx s_1032_47 -> bv
        let s_1032_48: Bits = Bits::new(s_1032_47 as u128, 32u16);
        // D s_1032_49: bit-extract s_1032_48 s_1032_45 s_1032_46
        let s_1032_49: Bits = (Bits::new(
            ((s_1032_48) >> (s_1032_45)).value(),
            u16::try_from(s_1032_46).unwrap(),
        ));
        // D s_1032_50: cast reint s_1032_49 -> u8
        let s_1032_50: bool = ((s_1032_49.value()) != 0);
        // C s_1032_51: const #0s : i
        let s_1032_51: i128 = 0;
        // C s_1032_52: const #4s : i
        let s_1032_52: i128 = 4;
        // D s_1032_53: read-var u#31736:u32
        let s_1032_53: u32 = fn_state.u_31736;
        // D s_1032_54: cast zx s_1032_53 -> bv
        let s_1032_54: Bits = Bits::new(s_1032_53 as u128, 32u16);
        // D s_1032_55: bit-extract s_1032_54 s_1032_51 s_1032_52
        let s_1032_55: Bits = (Bits::new(
            ((s_1032_54) >> (s_1032_51)).value(),
            u16::try_from(s_1032_52).unwrap(),
        ));
        // D s_1032_56: cast reint s_1032_55 -> u8
        let s_1032_56: u8 = (s_1032_55.value() as u8);
        // D s_1032_57: call decode_aarch32_instrs_VRHADD_A1enc_A_txt(s_1032_8, s_1032_14, s_1032_20, s_1032_26, s_1032_32, s_1032_38, s_1032_44, s_1032_50, s_1032_56)
        let s_1032_57: () = decode_aarch32_instrs_VRHADD_A1enc_A_txt(
            state,
            tracer,
            s_1032_8,
            s_1032_14,
            s_1032_20,
            s_1032_26,
            s_1032_32,
            s_1032_38,
            s_1032_44,
            s_1032_50,
            s_1032_56,
        );
        // N s_1032_58: return
        return;
    }
    fn block_1033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1033_0: read-var merge#var.1:struct
        let s_1033_0: u32 = fn_state.merge_var._1;
        // D s_1033_1: write-var u#31747 <= s_1033_0
        fn_state.u_31747 = s_1033_0;
        // C s_1033_2: const #25s : i
        let s_1033_2: i128 = 25;
        // D s_1033_3: read-var u#31747:u32
        let s_1033_3: u32 = fn_state.u_31747;
        // D s_1033_4: cast zx s_1033_3 -> bv
        let s_1033_4: Bits = Bits::new(s_1033_3 as u128, 32u16);
        // C s_1033_5: const #1s : i64
        let s_1033_5: i64 = 1;
        // C s_1033_6: cast zx s_1033_5 -> i
        let s_1033_6: i128 = (i128::try_from(s_1033_5).unwrap());
        // C s_1033_7: const #6s : i
        let s_1033_7: i128 = 6;
        // C s_1033_8: add s_1033_7 s_1033_6
        let s_1033_8: i128 = (s_1033_7 + s_1033_6);
        // D s_1033_9: bit-extract s_1033_4 s_1033_2 s_1033_8
        let s_1033_9: Bits = (Bits::new(
            ((s_1033_4) >> (s_1033_2)).value(),
            u16::try_from(s_1033_8).unwrap(),
        ));
        // D s_1033_10: cast reint s_1033_9 -> u8
        let s_1033_10: u8 = (s_1033_9.value() as u8);
        // D s_1033_11: cast zx s_1033_10 -> bv
        let s_1033_11: Bits = Bits::new(s_1033_10 as u128, 7u16);
        // C s_1033_12: const #121u : u8
        let s_1033_12: u8 = 121;
        // C s_1033_13: cast zx s_1033_12 -> bv
        let s_1033_13: Bits = Bits::new(s_1033_12 as u128, 7u16);
        // D s_1033_14: cmp-eq s_1033_11 s_1033_13
        let s_1033_14: bool = ((s_1033_11) == (s_1033_13));
        // N s_1033_15: branch s_1033_14 b2087 b1034
        if s_1033_14 {
            return block_2087(state, tracer, fn_state);
        } else {
            return block_1034(state, tracer, fn_state);
        };
    }
    fn block_1034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1034_0: const #0u : u8
        let s_1034_0: bool = false;
        // D s_1034_1: write-var gs#401787 <= s_1034_0
        fn_state.gs_401787 = s_1034_0;
        // N s_1034_2: jump b1035
        return block_1035(state, tracer, fn_state);
    }
    fn block_1035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1035_0: read-var gs#401787:u8
        let s_1035_0: bool = fn_state.gs_401787;
        // N s_1035_1: branch s_1035_0 b2086 b1036
        if s_1035_0 {
            return block_2086(state, tracer, fn_state);
        } else {
            return block_1036(state, tracer, fn_state);
        };
    }
    fn block_1036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1036_0: const #0u : u8
        let s_1036_0: bool = false;
        // D s_1036_1: write-var gs#401789 <= s_1036_0
        fn_state.gs_401789 = s_1036_0;
        // N s_1036_2: jump b1037
        return block_1037(state, tracer, fn_state);
    }
    fn block_1037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1037_0: read-var gs#401789:u8
        let s_1037_0: bool = fn_state.gs_401789;
        // D s_1037_1: not s_1037_0
        let s_1037_1: bool = !s_1037_0;
        // N s_1037_2: branch s_1037_1 b1039 b1038
        if s_1037_1 {
            return block_1039(state, tracer, fn_state);
        } else {
            return block_1038(state, tracer, fn_state);
        };
    }
    fn block_1038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1038_0: const #3658s : i
        let s_1038_0: i128 = 3658;
        // C s_1038_1: const #14696u : u32
        let s_1038_1: u32 = 14696;
        // N s_1038_2: write-reg s_1038_1 <= s_1038_0
        let s_1038_2: () = {
            state.write_register::<i128>(s_1038_1 as isize, s_1038_0);
            tracer.write_register(s_1038_1 as isize, s_1038_0);
        };
        // C s_1038_3: const #24s : i
        let s_1038_3: i128 = 24;
        // C s_1038_4: const #1s : i
        let s_1038_4: i128 = 1;
        // D s_1038_5: read-var u#31747:u32
        let s_1038_5: u32 = fn_state.u_31747;
        // D s_1038_6: cast zx s_1038_5 -> bv
        let s_1038_6: Bits = Bits::new(s_1038_5 as u128, 32u16);
        // D s_1038_7: bit-extract s_1038_6 s_1038_3 s_1038_4
        let s_1038_7: Bits = (Bits::new(
            ((s_1038_6) >> (s_1038_3)).value(),
            u16::try_from(s_1038_4).unwrap(),
        ));
        // D s_1038_8: cast reint s_1038_7 -> u8
        let s_1038_8: bool = ((s_1038_7.value()) != 0);
        // C s_1038_9: const #22s : i
        let s_1038_9: i128 = 22;
        // C s_1038_10: const #1s : i
        let s_1038_10: i128 = 1;
        // D s_1038_11: read-var u#31747:u32
        let s_1038_11: u32 = fn_state.u_31747;
        // D s_1038_12: cast zx s_1038_11 -> bv
        let s_1038_12: Bits = Bits::new(s_1038_11 as u128, 32u16);
        // D s_1038_13: bit-extract s_1038_12 s_1038_9 s_1038_10
        let s_1038_13: Bits = (Bits::new(
            ((s_1038_12) >> (s_1038_9)).value(),
            u16::try_from(s_1038_10).unwrap(),
        ));
        // D s_1038_14: cast reint s_1038_13 -> u8
        let s_1038_14: bool = ((s_1038_13.value()) != 0);
        // C s_1038_15: const #20s : i
        let s_1038_15: i128 = 20;
        // C s_1038_16: const #2s : i
        let s_1038_16: i128 = 2;
        // D s_1038_17: read-var u#31747:u32
        let s_1038_17: u32 = fn_state.u_31747;
        // D s_1038_18: cast zx s_1038_17 -> bv
        let s_1038_18: Bits = Bits::new(s_1038_17 as u128, 32u16);
        // D s_1038_19: bit-extract s_1038_18 s_1038_15 s_1038_16
        let s_1038_19: Bits = (Bits::new(
            ((s_1038_18) >> (s_1038_15)).value(),
            u16::try_from(s_1038_16).unwrap(),
        ));
        // D s_1038_20: cast reint s_1038_19 -> u8
        let s_1038_20: u8 = (s_1038_19.value() as u8);
        // C s_1038_21: const #16s : i
        let s_1038_21: i128 = 16;
        // C s_1038_22: const #4s : i
        let s_1038_22: i128 = 4;
        // D s_1038_23: read-var u#31747:u32
        let s_1038_23: u32 = fn_state.u_31747;
        // D s_1038_24: cast zx s_1038_23 -> bv
        let s_1038_24: Bits = Bits::new(s_1038_23 as u128, 32u16);
        // D s_1038_25: bit-extract s_1038_24 s_1038_21 s_1038_22
        let s_1038_25: Bits = (Bits::new(
            ((s_1038_24) >> (s_1038_21)).value(),
            u16::try_from(s_1038_22).unwrap(),
        ));
        // D s_1038_26: cast reint s_1038_25 -> u8
        let s_1038_26: u8 = (s_1038_25.value() as u8);
        // C s_1038_27: const #12s : i
        let s_1038_27: i128 = 12;
        // C s_1038_28: const #4s : i
        let s_1038_28: i128 = 4;
        // D s_1038_29: read-var u#31747:u32
        let s_1038_29: u32 = fn_state.u_31747;
        // D s_1038_30: cast zx s_1038_29 -> bv
        let s_1038_30: Bits = Bits::new(s_1038_29 as u128, 32u16);
        // D s_1038_31: bit-extract s_1038_30 s_1038_27 s_1038_28
        let s_1038_31: Bits = (Bits::new(
            ((s_1038_30) >> (s_1038_27)).value(),
            u16::try_from(s_1038_28).unwrap(),
        ));
        // D s_1038_32: cast reint s_1038_31 -> u8
        let s_1038_32: u8 = (s_1038_31.value() as u8);
        // C s_1038_33: const #7s : i
        let s_1038_33: i128 = 7;
        // C s_1038_34: const #1s : i
        let s_1038_34: i128 = 1;
        // D s_1038_35: read-var u#31747:u32
        let s_1038_35: u32 = fn_state.u_31747;
        // D s_1038_36: cast zx s_1038_35 -> bv
        let s_1038_36: Bits = Bits::new(s_1038_35 as u128, 32u16);
        // D s_1038_37: bit-extract s_1038_36 s_1038_33 s_1038_34
        let s_1038_37: Bits = (Bits::new(
            ((s_1038_36) >> (s_1038_33)).value(),
            u16::try_from(s_1038_34).unwrap(),
        ));
        // D s_1038_38: cast reint s_1038_37 -> u8
        let s_1038_38: bool = ((s_1038_37.value()) != 0);
        // C s_1038_39: const #6s : i
        let s_1038_39: i128 = 6;
        // C s_1038_40: const #1s : i
        let s_1038_40: i128 = 1;
        // D s_1038_41: read-var u#31747:u32
        let s_1038_41: u32 = fn_state.u_31747;
        // D s_1038_42: cast zx s_1038_41 -> bv
        let s_1038_42: Bits = Bits::new(s_1038_41 as u128, 32u16);
        // D s_1038_43: bit-extract s_1038_42 s_1038_39 s_1038_40
        let s_1038_43: Bits = (Bits::new(
            ((s_1038_42) >> (s_1038_39)).value(),
            u16::try_from(s_1038_40).unwrap(),
        ));
        // D s_1038_44: cast reint s_1038_43 -> u8
        let s_1038_44: bool = ((s_1038_43.value()) != 0);
        // C s_1038_45: const #5s : i
        let s_1038_45: i128 = 5;
        // C s_1038_46: const #1s : i
        let s_1038_46: i128 = 1;
        // D s_1038_47: read-var u#31747:u32
        let s_1038_47: u32 = fn_state.u_31747;
        // D s_1038_48: cast zx s_1038_47 -> bv
        let s_1038_48: Bits = Bits::new(s_1038_47 as u128, 32u16);
        // D s_1038_49: bit-extract s_1038_48 s_1038_45 s_1038_46
        let s_1038_49: Bits = (Bits::new(
            ((s_1038_48) >> (s_1038_45)).value(),
            u16::try_from(s_1038_46).unwrap(),
        ));
        // D s_1038_50: cast reint s_1038_49 -> u8
        let s_1038_50: bool = ((s_1038_49.value()) != 0);
        // C s_1038_51: const #0s : i
        let s_1038_51: i128 = 0;
        // C s_1038_52: const #4s : i
        let s_1038_52: i128 = 4;
        // D s_1038_53: read-var u#31747:u32
        let s_1038_53: u32 = fn_state.u_31747;
        // D s_1038_54: cast zx s_1038_53 -> bv
        let s_1038_54: Bits = Bits::new(s_1038_53 as u128, 32u16);
        // D s_1038_55: bit-extract s_1038_54 s_1038_51 s_1038_52
        let s_1038_55: Bits = (Bits::new(
            ((s_1038_54) >> (s_1038_51)).value(),
            u16::try_from(s_1038_52).unwrap(),
        ));
        // D s_1038_56: cast reint s_1038_55 -> u8
        let s_1038_56: u8 = (s_1038_55.value() as u8);
        // D s_1038_57: call decode_aarch32_instrs_VRSHL_A1enc_A_txt(s_1038_8, s_1038_14, s_1038_20, s_1038_26, s_1038_32, s_1038_38, s_1038_44, s_1038_50, s_1038_56)
        let s_1038_57: () = decode_aarch32_instrs_VRSHL_A1enc_A_txt(
            state,
            tracer,
            s_1038_8,
            s_1038_14,
            s_1038_20,
            s_1038_26,
            s_1038_32,
            s_1038_38,
            s_1038_44,
            s_1038_50,
            s_1038_56,
        );
        // N s_1038_58: return
        return;
    }
    fn block_1039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1039_0: read-var merge#var.1:struct
        let s_1039_0: u32 = fn_state.merge_var._1;
        // D s_1039_1: write-var u#31758 <= s_1039_0
        fn_state.u_31758 = s_1039_0;
        // C s_1039_2: const #25s : i
        let s_1039_2: i128 = 25;
        // D s_1039_3: read-var u#31758:u32
        let s_1039_3: u32 = fn_state.u_31758;
        // D s_1039_4: cast zx s_1039_3 -> bv
        let s_1039_4: Bits = Bits::new(s_1039_3 as u128, 32u16);
        // C s_1039_5: const #1s : i64
        let s_1039_5: i64 = 1;
        // C s_1039_6: cast zx s_1039_5 -> i
        let s_1039_6: i128 = (i128::try_from(s_1039_5).unwrap());
        // C s_1039_7: const #6s : i
        let s_1039_7: i128 = 6;
        // C s_1039_8: add s_1039_7 s_1039_6
        let s_1039_8: i128 = (s_1039_7 + s_1039_6);
        // D s_1039_9: bit-extract s_1039_4 s_1039_2 s_1039_8
        let s_1039_9: Bits = (Bits::new(
            ((s_1039_4) >> (s_1039_2)).value(),
            u16::try_from(s_1039_8).unwrap(),
        ));
        // D s_1039_10: cast reint s_1039_9 -> u8
        let s_1039_10: u8 = (s_1039_9.value() as u8);
        // D s_1039_11: cast zx s_1039_10 -> bv
        let s_1039_11: Bits = Bits::new(s_1039_10 as u128, 7u16);
        // C s_1039_12: const #121u : u8
        let s_1039_12: u8 = 121;
        // C s_1039_13: cast zx s_1039_12 -> bv
        let s_1039_13: Bits = Bits::new(s_1039_12 as u128, 7u16);
        // D s_1039_14: cmp-eq s_1039_11 s_1039_13
        let s_1039_14: bool = ((s_1039_11) == (s_1039_13));
        // N s_1039_15: branch s_1039_14 b2079 b1040
        if s_1039_14 {
            return block_2079(state, tracer, fn_state);
        } else {
            return block_1040(state, tracer, fn_state);
        };
    }
    fn block_1040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1040_0: const #0u : u8
        let s_1040_0: bool = false;
        // D s_1040_1: write-var gs#401821 <= s_1040_0
        fn_state.gs_401821 = s_1040_0;
        // N s_1040_2: jump b1041
        return block_1041(state, tracer, fn_state);
    }
    fn block_1041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1041_0: read-var gs#401821:u8
        let s_1041_0: bool = fn_state.gs_401821;
        // N s_1041_1: branch s_1041_0 b2078 b1042
        if s_1041_0 {
            return block_2078(state, tracer, fn_state);
        } else {
            return block_1042(state, tracer, fn_state);
        };
    }
    fn block_1042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1042_0: const #0u : u8
        let s_1042_0: bool = false;
        // D s_1042_1: write-var gs#401823 <= s_1042_0
        fn_state.gs_401823 = s_1042_0;
        // N s_1042_2: jump b1043
        return block_1043(state, tracer, fn_state);
    }
    fn block_1043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1043_0: read-var gs#401823:u8
        let s_1043_0: bool = fn_state.gs_401823;
        // D s_1043_1: not s_1043_0
        let s_1043_1: bool = !s_1043_0;
        // N s_1043_2: branch s_1043_1 b1045 b1044
        if s_1043_1 {
            return block_1045(state, tracer, fn_state);
        } else {
            return block_1044(state, tracer, fn_state);
        };
    }
    fn block_1044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1044_0: const #3660s : i
        let s_1044_0: i128 = 3660;
        // C s_1044_1: const #14696u : u32
        let s_1044_1: u32 = 14696;
        // N s_1044_2: write-reg s_1044_1 <= s_1044_0
        let s_1044_2: () = {
            state.write_register::<i128>(s_1044_1 as isize, s_1044_0);
            tracer.write_register(s_1044_1 as isize, s_1044_0);
        };
        // C s_1044_3: const #24s : i
        let s_1044_3: i128 = 24;
        // C s_1044_4: const #1s : i
        let s_1044_4: i128 = 1;
        // D s_1044_5: read-var u#31758:u32
        let s_1044_5: u32 = fn_state.u_31758;
        // D s_1044_6: cast zx s_1044_5 -> bv
        let s_1044_6: Bits = Bits::new(s_1044_5 as u128, 32u16);
        // D s_1044_7: bit-extract s_1044_6 s_1044_3 s_1044_4
        let s_1044_7: Bits = (Bits::new(
            ((s_1044_6) >> (s_1044_3)).value(),
            u16::try_from(s_1044_4).unwrap(),
        ));
        // D s_1044_8: cast reint s_1044_7 -> u8
        let s_1044_8: bool = ((s_1044_7.value()) != 0);
        // C s_1044_9: const #22s : i
        let s_1044_9: i128 = 22;
        // C s_1044_10: const #1s : i
        let s_1044_10: i128 = 1;
        // D s_1044_11: read-var u#31758:u32
        let s_1044_11: u32 = fn_state.u_31758;
        // D s_1044_12: cast zx s_1044_11 -> bv
        let s_1044_12: Bits = Bits::new(s_1044_11 as u128, 32u16);
        // D s_1044_13: bit-extract s_1044_12 s_1044_9 s_1044_10
        let s_1044_13: Bits = (Bits::new(
            ((s_1044_12) >> (s_1044_9)).value(),
            u16::try_from(s_1044_10).unwrap(),
        ));
        // D s_1044_14: cast reint s_1044_13 -> u8
        let s_1044_14: bool = ((s_1044_13.value()) != 0);
        // C s_1044_15: const #16s : i
        let s_1044_15: i128 = 16;
        // C s_1044_16: const #6s : i
        let s_1044_16: i128 = 6;
        // D s_1044_17: read-var u#31758:u32
        let s_1044_17: u32 = fn_state.u_31758;
        // D s_1044_18: cast zx s_1044_17 -> bv
        let s_1044_18: Bits = Bits::new(s_1044_17 as u128, 32u16);
        // D s_1044_19: bit-extract s_1044_18 s_1044_15 s_1044_16
        let s_1044_19: Bits = (Bits::new(
            ((s_1044_18) >> (s_1044_15)).value(),
            u16::try_from(s_1044_16).unwrap(),
        ));
        // D s_1044_20: cast reint s_1044_19 -> u8
        let s_1044_20: u8 = (s_1044_19.value() as u8);
        // C s_1044_21: const #12s : i
        let s_1044_21: i128 = 12;
        // C s_1044_22: const #4s : i
        let s_1044_22: i128 = 4;
        // D s_1044_23: read-var u#31758:u32
        let s_1044_23: u32 = fn_state.u_31758;
        // D s_1044_24: cast zx s_1044_23 -> bv
        let s_1044_24: Bits = Bits::new(s_1044_23 as u128, 32u16);
        // D s_1044_25: bit-extract s_1044_24 s_1044_21 s_1044_22
        let s_1044_25: Bits = (Bits::new(
            ((s_1044_24) >> (s_1044_21)).value(),
            u16::try_from(s_1044_22).unwrap(),
        ));
        // D s_1044_26: cast reint s_1044_25 -> u8
        let s_1044_26: u8 = (s_1044_25.value() as u8);
        // C s_1044_27: const #7s : i
        let s_1044_27: i128 = 7;
        // C s_1044_28: const #1s : i
        let s_1044_28: i128 = 1;
        // D s_1044_29: read-var u#31758:u32
        let s_1044_29: u32 = fn_state.u_31758;
        // D s_1044_30: cast zx s_1044_29 -> bv
        let s_1044_30: Bits = Bits::new(s_1044_29 as u128, 32u16);
        // D s_1044_31: bit-extract s_1044_30 s_1044_27 s_1044_28
        let s_1044_31: Bits = (Bits::new(
            ((s_1044_30) >> (s_1044_27)).value(),
            u16::try_from(s_1044_28).unwrap(),
        ));
        // D s_1044_32: cast reint s_1044_31 -> u8
        let s_1044_32: bool = ((s_1044_31.value()) != 0);
        // C s_1044_33: const #6s : i
        let s_1044_33: i128 = 6;
        // C s_1044_34: const #1s : i
        let s_1044_34: i128 = 1;
        // D s_1044_35: read-var u#31758:u32
        let s_1044_35: u32 = fn_state.u_31758;
        // D s_1044_36: cast zx s_1044_35 -> bv
        let s_1044_36: Bits = Bits::new(s_1044_35 as u128, 32u16);
        // D s_1044_37: bit-extract s_1044_36 s_1044_33 s_1044_34
        let s_1044_37: Bits = (Bits::new(
            ((s_1044_36) >> (s_1044_33)).value(),
            u16::try_from(s_1044_34).unwrap(),
        ));
        // D s_1044_38: cast reint s_1044_37 -> u8
        let s_1044_38: bool = ((s_1044_37.value()) != 0);
        // C s_1044_39: const #5s : i
        let s_1044_39: i128 = 5;
        // C s_1044_40: const #1s : i
        let s_1044_40: i128 = 1;
        // D s_1044_41: read-var u#31758:u32
        let s_1044_41: u32 = fn_state.u_31758;
        // D s_1044_42: cast zx s_1044_41 -> bv
        let s_1044_42: Bits = Bits::new(s_1044_41 as u128, 32u16);
        // D s_1044_43: bit-extract s_1044_42 s_1044_39 s_1044_40
        let s_1044_43: Bits = (Bits::new(
            ((s_1044_42) >> (s_1044_39)).value(),
            u16::try_from(s_1044_40).unwrap(),
        ));
        // D s_1044_44: cast reint s_1044_43 -> u8
        let s_1044_44: bool = ((s_1044_43.value()) != 0);
        // C s_1044_45: const #0s : i
        let s_1044_45: i128 = 0;
        // C s_1044_46: const #4s : i
        let s_1044_46: i128 = 4;
        // D s_1044_47: read-var u#31758:u32
        let s_1044_47: u32 = fn_state.u_31758;
        // D s_1044_48: cast zx s_1044_47 -> bv
        let s_1044_48: Bits = Bits::new(s_1044_47 as u128, 32u16);
        // D s_1044_49: bit-extract s_1044_48 s_1044_45 s_1044_46
        let s_1044_49: Bits = (Bits::new(
            ((s_1044_48) >> (s_1044_45)).value(),
            u16::try_from(s_1044_46).unwrap(),
        ));
        // D s_1044_50: cast reint s_1044_49 -> u8
        let s_1044_50: u8 = (s_1044_49.value() as u8);
        // D s_1044_51: call decode_aarch32_instrs_VRSHR_A1enc_A_txt(s_1044_8, s_1044_14, s_1044_20, s_1044_26, s_1044_32, s_1044_38, s_1044_44, s_1044_50)
        let s_1044_51: () = decode_aarch32_instrs_VRSHR_A1enc_A_txt(
            state,
            tracer,
            s_1044_8,
            s_1044_14,
            s_1044_20,
            s_1044_26,
            s_1044_32,
            s_1044_38,
            s_1044_44,
            s_1044_50,
        );
        // N s_1044_52: return
        return;
    }
    fn block_1045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1045_0: read-var merge#var.1:struct
        let s_1045_0: u32 = fn_state.merge_var._1;
        // D s_1045_1: write-var u#31768 <= s_1045_0
        fn_state.u_31768 = s_1045_0;
        // C s_1045_2: const #23s : i
        let s_1045_2: i128 = 23;
        // D s_1045_3: read-var u#31768:u32
        let s_1045_3: u32 = fn_state.u_31768;
        // D s_1045_4: cast zx s_1045_3 -> bv
        let s_1045_4: Bits = Bits::new(s_1045_3 as u128, 32u16);
        // C s_1045_5: const #1s : i64
        let s_1045_5: i64 = 1;
        // C s_1045_6: cast zx s_1045_5 -> i
        let s_1045_6: i128 = (i128::try_from(s_1045_5).unwrap());
        // C s_1045_7: const #8s : i
        let s_1045_7: i128 = 8;
        // C s_1045_8: add s_1045_7 s_1045_6
        let s_1045_8: i128 = (s_1045_7 + s_1045_6);
        // D s_1045_9: bit-extract s_1045_4 s_1045_2 s_1045_8
        let s_1045_9: Bits = (Bits::new(
            ((s_1045_4) >> (s_1045_2)).value(),
            u16::try_from(s_1045_8).unwrap(),
        ));
        // D s_1045_10: cast reint s_1045_9 -> u9
        let s_1045_10: u16 = (s_1045_9.value() as u16);
        // D s_1045_11: cast zx s_1045_10 -> bv
        let s_1045_11: Bits = Bits::new(s_1045_10 as u128, 9u16);
        // C s_1045_12: const #485u : u9
        let s_1045_12: u16 = 485;
        // C s_1045_13: cast zx s_1045_12 -> bv
        let s_1045_13: Bits = Bits::new(s_1045_12 as u128, 9u16);
        // D s_1045_14: cmp-eq s_1045_11 s_1045_13
        let s_1045_14: bool = ((s_1045_11) == (s_1045_13));
        // N s_1045_15: branch s_1045_14 b2074 b1046
        if s_1045_14 {
            return block_2074(state, tracer, fn_state);
        } else {
            return block_1046(state, tracer, fn_state);
        };
    }
    fn block_1046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1046_0: const #0u : u8
        let s_1046_0: bool = false;
        // D s_1046_1: write-var gs#401850 <= s_1046_0
        fn_state.gs_401850 = s_1046_0;
        // N s_1046_2: jump b1047
        return block_1047(state, tracer, fn_state);
    }
    fn block_1047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1047_0: read-var gs#401850:u8
        let s_1047_0: bool = fn_state.gs_401850;
        // N s_1047_1: branch s_1047_0 b2073 b1048
        if s_1047_0 {
            return block_2073(state, tracer, fn_state);
        } else {
            return block_1048(state, tracer, fn_state);
        };
    }
    fn block_1048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1048_0: const #0u : u8
        let s_1048_0: bool = false;
        // D s_1048_1: write-var gs#401852 <= s_1048_0
        fn_state.gs_401852 = s_1048_0;
        // N s_1048_2: jump b1049
        return block_1049(state, tracer, fn_state);
    }
    fn block_1049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1049_0: read-var gs#401852:u8
        let s_1049_0: bool = fn_state.gs_401852;
        // D s_1049_1: not s_1049_0
        let s_1049_1: bool = !s_1049_0;
        // N s_1049_2: branch s_1049_1 b1051 b1050
        if s_1049_1 {
            return block_1051(state, tracer, fn_state);
        } else {
            return block_1050(state, tracer, fn_state);
        };
    }
    fn block_1050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1050_0: const #3662s : i
        let s_1050_0: i128 = 3662;
        // C s_1050_1: const #14696u : u32
        let s_1050_1: u32 = 14696;
        // N s_1050_2: write-reg s_1050_1 <= s_1050_0
        let s_1050_2: () = {
            state.write_register::<i128>(s_1050_1 as isize, s_1050_0);
            tracer.write_register(s_1050_1 as isize, s_1050_0);
        };
        // C s_1050_3: const #22s : i
        let s_1050_3: i128 = 22;
        // C s_1050_4: const #1s : i
        let s_1050_4: i128 = 1;
        // D s_1050_5: read-var u#31768:u32
        let s_1050_5: u32 = fn_state.u_31768;
        // D s_1050_6: cast zx s_1050_5 -> bv
        let s_1050_6: Bits = Bits::new(s_1050_5 as u128, 32u16);
        // D s_1050_7: bit-extract s_1050_6 s_1050_3 s_1050_4
        let s_1050_7: Bits = (Bits::new(
            ((s_1050_6) >> (s_1050_3)).value(),
            u16::try_from(s_1050_4).unwrap(),
        ));
        // D s_1050_8: cast reint s_1050_7 -> u8
        let s_1050_8: bool = ((s_1050_7.value()) != 0);
        // C s_1050_9: const #16s : i
        let s_1050_9: i128 = 16;
        // C s_1050_10: const #6s : i
        let s_1050_10: i128 = 6;
        // D s_1050_11: read-var u#31768:u32
        let s_1050_11: u32 = fn_state.u_31768;
        // D s_1050_12: cast zx s_1050_11 -> bv
        let s_1050_12: Bits = Bits::new(s_1050_11 as u128, 32u16);
        // D s_1050_13: bit-extract s_1050_12 s_1050_9 s_1050_10
        let s_1050_13: Bits = (Bits::new(
            ((s_1050_12) >> (s_1050_9)).value(),
            u16::try_from(s_1050_10).unwrap(),
        ));
        // D s_1050_14: cast reint s_1050_13 -> u8
        let s_1050_14: u8 = (s_1050_13.value() as u8);
        // C s_1050_15: const #12s : i
        let s_1050_15: i128 = 12;
        // C s_1050_16: const #4s : i
        let s_1050_16: i128 = 4;
        // D s_1050_17: read-var u#31768:u32
        let s_1050_17: u32 = fn_state.u_31768;
        // D s_1050_18: cast zx s_1050_17 -> bv
        let s_1050_18: Bits = Bits::new(s_1050_17 as u128, 32u16);
        // D s_1050_19: bit-extract s_1050_18 s_1050_15 s_1050_16
        let s_1050_19: Bits = (Bits::new(
            ((s_1050_18) >> (s_1050_15)).value(),
            u16::try_from(s_1050_16).unwrap(),
        ));
        // D s_1050_20: cast reint s_1050_19 -> u8
        let s_1050_20: u8 = (s_1050_19.value() as u8);
        // C s_1050_21: const #5s : i
        let s_1050_21: i128 = 5;
        // C s_1050_22: const #1s : i
        let s_1050_22: i128 = 1;
        // D s_1050_23: read-var u#31768:u32
        let s_1050_23: u32 = fn_state.u_31768;
        // D s_1050_24: cast zx s_1050_23 -> bv
        let s_1050_24: Bits = Bits::new(s_1050_23 as u128, 32u16);
        // D s_1050_25: bit-extract s_1050_24 s_1050_21 s_1050_22
        let s_1050_25: Bits = (Bits::new(
            ((s_1050_24) >> (s_1050_21)).value(),
            u16::try_from(s_1050_22).unwrap(),
        ));
        // D s_1050_26: cast reint s_1050_25 -> u8
        let s_1050_26: bool = ((s_1050_25.value()) != 0);
        // C s_1050_27: const #0s : i
        let s_1050_27: i128 = 0;
        // C s_1050_28: const #4s : i
        let s_1050_28: i128 = 4;
        // D s_1050_29: read-var u#31768:u32
        let s_1050_29: u32 = fn_state.u_31768;
        // D s_1050_30: cast zx s_1050_29 -> bv
        let s_1050_30: Bits = Bits::new(s_1050_29 as u128, 32u16);
        // D s_1050_31: bit-extract s_1050_30 s_1050_27 s_1050_28
        let s_1050_31: Bits = (Bits::new(
            ((s_1050_30) >> (s_1050_27)).value(),
            u16::try_from(s_1050_28).unwrap(),
        ));
        // D s_1050_32: cast reint s_1050_31 -> u8
        let s_1050_32: u8 = (s_1050_31.value() as u8);
        // D s_1050_33: call decode_aarch32_instrs_VRSHRN_A1enc_A_txt(s_1050_8, s_1050_14, s_1050_20, s_1050_26, s_1050_32)
        let s_1050_33: () = decode_aarch32_instrs_VRSHRN_A1enc_A_txt(
            state,
            tracer,
            s_1050_8,
            s_1050_14,
            s_1050_20,
            s_1050_26,
            s_1050_32,
        );
        // N s_1050_34: return
        return;
    }
    fn block_1051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1051_0: read-var merge#var.1:struct
        let s_1051_0: u32 = fn_state.merge_var._1;
        // D s_1051_1: write-var u#31775 <= s_1051_0
        fn_state.u_31775 = s_1051_0;
        // C s_1051_2: const #23s : i
        let s_1051_2: i128 = 23;
        // D s_1051_3: read-var u#31775:u32
        let s_1051_3: u32 = fn_state.u_31775;
        // D s_1051_4: cast zx s_1051_3 -> bv
        let s_1051_4: Bits = Bits::new(s_1051_3 as u128, 32u16);
        // C s_1051_5: const #1s : i64
        let s_1051_5: i64 = 1;
        // C s_1051_6: cast zx s_1051_5 -> i
        let s_1051_6: i128 = (i128::try_from(s_1051_5).unwrap());
        // C s_1051_7: const #8s : i
        let s_1051_7: i128 = 8;
        // C s_1051_8: add s_1051_7 s_1051_6
        let s_1051_8: i128 = (s_1051_7 + s_1051_6);
        // D s_1051_9: bit-extract s_1051_4 s_1051_2 s_1051_8
        let s_1051_9: Bits = (Bits::new(
            ((s_1051_4) >> (s_1051_2)).value(),
            u16::try_from(s_1051_8).unwrap(),
        ));
        // D s_1051_10: cast reint s_1051_9 -> u9
        let s_1051_10: u16 = (s_1051_9.value() as u16);
        // D s_1051_11: cast zx s_1051_10 -> bv
        let s_1051_11: Bits = Bits::new(s_1051_10 as u128, 9u16);
        // C s_1051_12: const #487u : u9
        let s_1051_12: u16 = 487;
        // C s_1051_13: cast zx s_1051_12 -> bv
        let s_1051_13: Bits = Bits::new(s_1051_12 as u128, 9u16);
        // D s_1051_14: cmp-eq s_1051_11 s_1051_13
        let s_1051_14: bool = ((s_1051_11) == (s_1051_13));
        // N s_1051_15: branch s_1051_14 b2060 b1052
        if s_1051_14 {
            return block_2060(state, tracer, fn_state);
        } else {
            return block_1052(state, tracer, fn_state);
        };
    }
    fn block_1052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1052_0: const #0u : u8
        let s_1052_0: bool = false;
        // D s_1052_1: write-var gs#401882 <= s_1052_0
        fn_state.gs_401882 = s_1052_0;
        // N s_1052_2: jump b1053
        return block_1053(state, tracer, fn_state);
    }
    fn block_1053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1053_0: read-var gs#401882:u8
        let s_1053_0: bool = fn_state.gs_401882;
        // N s_1053_1: branch s_1053_0 b2059 b1054
        if s_1053_0 {
            return block_2059(state, tracer, fn_state);
        } else {
            return block_1054(state, tracer, fn_state);
        };
    }
    fn block_1054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1054_0: const #0u : u8
        let s_1054_0: bool = false;
        // D s_1054_1: write-var gs#401884 <= s_1054_0
        fn_state.gs_401884 = s_1054_0;
        // N s_1054_2: jump b1055
        return block_1055(state, tracer, fn_state);
    }
    fn block_1055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1055_0: read-var gs#401884:u8
        let s_1055_0: bool = fn_state.gs_401884;
        // D s_1055_1: not s_1055_0
        let s_1055_1: bool = !s_1055_0;
        // N s_1055_2: branch s_1055_1 b1057 b1056
        if s_1055_1 {
            return block_1057(state, tracer, fn_state);
        } else {
            return block_1056(state, tracer, fn_state);
        };
    }
    fn block_1056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1056_0: const #3664s : i
        let s_1056_0: i128 = 3664;
        // C s_1056_1: const #14696u : u32
        let s_1056_1: u32 = 14696;
        // N s_1056_2: write-reg s_1056_1 <= s_1056_0
        let s_1056_2: () = {
            state.write_register::<i128>(s_1056_1 as isize, s_1056_0);
            tracer.write_register(s_1056_1 as isize, s_1056_0);
        };
        // C s_1056_3: const #22s : i
        let s_1056_3: i128 = 22;
        // C s_1056_4: const #1s : i
        let s_1056_4: i128 = 1;
        // D s_1056_5: read-var u#31775:u32
        let s_1056_5: u32 = fn_state.u_31775;
        // D s_1056_6: cast zx s_1056_5 -> bv
        let s_1056_6: Bits = Bits::new(s_1056_5 as u128, 32u16);
        // D s_1056_7: bit-extract s_1056_6 s_1056_3 s_1056_4
        let s_1056_7: Bits = (Bits::new(
            ((s_1056_6) >> (s_1056_3)).value(),
            u16::try_from(s_1056_4).unwrap(),
        ));
        // D s_1056_8: cast reint s_1056_7 -> u8
        let s_1056_8: bool = ((s_1056_7.value()) != 0);
        // C s_1056_9: const #18s : i
        let s_1056_9: i128 = 18;
        // C s_1056_10: const #2s : i
        let s_1056_10: i128 = 2;
        // D s_1056_11: read-var u#31775:u32
        let s_1056_11: u32 = fn_state.u_31775;
        // D s_1056_12: cast zx s_1056_11 -> bv
        let s_1056_12: Bits = Bits::new(s_1056_11 as u128, 32u16);
        // D s_1056_13: bit-extract s_1056_12 s_1056_9 s_1056_10
        let s_1056_13: Bits = (Bits::new(
            ((s_1056_12) >> (s_1056_9)).value(),
            u16::try_from(s_1056_10).unwrap(),
        ));
        // D s_1056_14: cast reint s_1056_13 -> u8
        let s_1056_14: u8 = (s_1056_13.value() as u8);
        // C s_1056_15: const #12s : i
        let s_1056_15: i128 = 12;
        // C s_1056_16: const #4s : i
        let s_1056_16: i128 = 4;
        // D s_1056_17: read-var u#31775:u32
        let s_1056_17: u32 = fn_state.u_31775;
        // D s_1056_18: cast zx s_1056_17 -> bv
        let s_1056_18: Bits = Bits::new(s_1056_17 as u128, 32u16);
        // D s_1056_19: bit-extract s_1056_18 s_1056_15 s_1056_16
        let s_1056_19: Bits = (Bits::new(
            ((s_1056_18) >> (s_1056_15)).value(),
            u16::try_from(s_1056_16).unwrap(),
        ));
        // D s_1056_20: cast reint s_1056_19 -> u8
        let s_1056_20: u8 = (s_1056_19.value() as u8);
        // C s_1056_21: const #8s : i
        let s_1056_21: i128 = 8;
        // C s_1056_22: const #1s : i
        let s_1056_22: i128 = 1;
        // D s_1056_23: read-var u#31775:u32
        let s_1056_23: u32 = fn_state.u_31775;
        // D s_1056_24: cast zx s_1056_23 -> bv
        let s_1056_24: Bits = Bits::new(s_1056_23 as u128, 32u16);
        // D s_1056_25: bit-extract s_1056_24 s_1056_21 s_1056_22
        let s_1056_25: Bits = (Bits::new(
            ((s_1056_24) >> (s_1056_21)).value(),
            u16::try_from(s_1056_22).unwrap(),
        ));
        // D s_1056_26: cast reint s_1056_25 -> u8
        let s_1056_26: bool = ((s_1056_25.value()) != 0);
        // C s_1056_27: const #6s : i
        let s_1056_27: i128 = 6;
        // C s_1056_28: const #1s : i
        let s_1056_28: i128 = 1;
        // D s_1056_29: read-var u#31775:u32
        let s_1056_29: u32 = fn_state.u_31775;
        // D s_1056_30: cast zx s_1056_29 -> bv
        let s_1056_30: Bits = Bits::new(s_1056_29 as u128, 32u16);
        // D s_1056_31: bit-extract s_1056_30 s_1056_27 s_1056_28
        let s_1056_31: Bits = (Bits::new(
            ((s_1056_30) >> (s_1056_27)).value(),
            u16::try_from(s_1056_28).unwrap(),
        ));
        // D s_1056_32: cast reint s_1056_31 -> u8
        let s_1056_32: bool = ((s_1056_31.value()) != 0);
        // C s_1056_33: const #5s : i
        let s_1056_33: i128 = 5;
        // C s_1056_34: const #1s : i
        let s_1056_34: i128 = 1;
        // D s_1056_35: read-var u#31775:u32
        let s_1056_35: u32 = fn_state.u_31775;
        // D s_1056_36: cast zx s_1056_35 -> bv
        let s_1056_36: Bits = Bits::new(s_1056_35 as u128, 32u16);
        // D s_1056_37: bit-extract s_1056_36 s_1056_33 s_1056_34
        let s_1056_37: Bits = (Bits::new(
            ((s_1056_36) >> (s_1056_33)).value(),
            u16::try_from(s_1056_34).unwrap(),
        ));
        // D s_1056_38: cast reint s_1056_37 -> u8
        let s_1056_38: bool = ((s_1056_37.value()) != 0);
        // C s_1056_39: const #0s : i
        let s_1056_39: i128 = 0;
        // C s_1056_40: const #4s : i
        let s_1056_40: i128 = 4;
        // D s_1056_41: read-var u#31775:u32
        let s_1056_41: u32 = fn_state.u_31775;
        // D s_1056_42: cast zx s_1056_41 -> bv
        let s_1056_42: Bits = Bits::new(s_1056_41 as u128, 32u16);
        // D s_1056_43: bit-extract s_1056_42 s_1056_39 s_1056_40
        let s_1056_43: Bits = (Bits::new(
            ((s_1056_42) >> (s_1056_39)).value(),
            u16::try_from(s_1056_40).unwrap(),
        ));
        // D s_1056_44: cast reint s_1056_43 -> u8
        let s_1056_44: u8 = (s_1056_43.value() as u8);
        // D s_1056_45: call decode_aarch32_instrs_VRSQRTE_A1enc_A_txt(s_1056_8, s_1056_14, s_1056_20, s_1056_26, s_1056_32, s_1056_38, s_1056_44)
        let s_1056_45: () = decode_aarch32_instrs_VRSQRTE_A1enc_A_txt(
            state,
            tracer,
            s_1056_8,
            s_1056_14,
            s_1056_20,
            s_1056_26,
            s_1056_32,
            s_1056_38,
            s_1056_44,
        );
        // N s_1056_46: return
        return;
    }
    fn block_1057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1057_0: read-var merge#var.1:struct
        let s_1057_0: u32 = fn_state.merge_var._1;
        // D s_1057_1: write-var u#31784 <= s_1057_0
        fn_state.u_31784 = s_1057_0;
        // C s_1057_2: const #23s : i
        let s_1057_2: i128 = 23;
        // D s_1057_3: read-var u#31784:u32
        let s_1057_3: u32 = fn_state.u_31784;
        // D s_1057_4: cast zx s_1057_3 -> bv
        let s_1057_4: Bits = Bits::new(s_1057_3 as u128, 32u16);
        // C s_1057_5: const #1s : i64
        let s_1057_5: i64 = 1;
        // C s_1057_6: cast zx s_1057_5 -> i
        let s_1057_6: i128 = (i128::try_from(s_1057_5).unwrap());
        // C s_1057_7: const #8s : i
        let s_1057_7: i128 = 8;
        // C s_1057_8: add s_1057_7 s_1057_6
        let s_1057_8: i128 = (s_1057_7 + s_1057_6);
        // D s_1057_9: bit-extract s_1057_4 s_1057_2 s_1057_8
        let s_1057_9: Bits = (Bits::new(
            ((s_1057_4) >> (s_1057_2)).value(),
            u16::try_from(s_1057_8).unwrap(),
        ));
        // D s_1057_10: cast reint s_1057_9 -> u9
        let s_1057_10: u16 = (s_1057_9.value() as u16);
        // D s_1057_11: cast zx s_1057_10 -> bv
        let s_1057_11: Bits = Bits::new(s_1057_10 as u128, 9u16);
        // C s_1057_12: const #484u : u9
        let s_1057_12: u16 = 484;
        // C s_1057_13: cast zx s_1057_12 -> bv
        let s_1057_13: Bits = Bits::new(s_1057_12 as u128, 9u16);
        // D s_1057_14: cmp-eq s_1057_11 s_1057_13
        let s_1057_14: bool = ((s_1057_11) == (s_1057_13));
        // N s_1057_15: branch s_1057_14 b2052 b1058
        if s_1057_14 {
            return block_2052(state, tracer, fn_state);
        } else {
            return block_1058(state, tracer, fn_state);
        };
    }
    fn block_1058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1058_0: const #0u : u8
        let s_1058_0: bool = false;
        // D s_1058_1: write-var gs#401912 <= s_1058_0
        fn_state.gs_401912 = s_1058_0;
        // N s_1058_2: jump b1059
        return block_1059(state, tracer, fn_state);
    }
    fn block_1059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1059_0: read-var gs#401912:u8
        let s_1059_0: bool = fn_state.gs_401912;
        // N s_1059_1: branch s_1059_0 b2051 b1060
        if s_1059_0 {
            return block_2051(state, tracer, fn_state);
        } else {
            return block_1060(state, tracer, fn_state);
        };
    }
    fn block_1060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1060_0: const #0u : u8
        let s_1060_0: bool = false;
        // D s_1060_1: write-var gs#401914 <= s_1060_0
        fn_state.gs_401914 = s_1060_0;
        // N s_1060_2: jump b1061
        return block_1061(state, tracer, fn_state);
    }
    fn block_1061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1061_0: read-var gs#401914:u8
        let s_1061_0: bool = fn_state.gs_401914;
        // D s_1061_1: not s_1061_0
        let s_1061_1: bool = !s_1061_0;
        // N s_1061_2: branch s_1061_1 b1063 b1062
        if s_1061_1 {
            return block_1063(state, tracer, fn_state);
        } else {
            return block_1062(state, tracer, fn_state);
        };
    }
    fn block_1062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1062_0: const #3666s : i
        let s_1062_0: i128 = 3666;
        // C s_1062_1: const #14696u : u32
        let s_1062_1: u32 = 14696;
        // N s_1062_2: write-reg s_1062_1 <= s_1062_0
        let s_1062_2: () = {
            state.write_register::<i128>(s_1062_1 as isize, s_1062_0);
            tracer.write_register(s_1062_1 as isize, s_1062_0);
        };
        // C s_1062_3: const #22s : i
        let s_1062_3: i128 = 22;
        // C s_1062_4: const #1s : i
        let s_1062_4: i128 = 1;
        // D s_1062_5: read-var u#31784:u32
        let s_1062_5: u32 = fn_state.u_31784;
        // D s_1062_6: cast zx s_1062_5 -> bv
        let s_1062_6: Bits = Bits::new(s_1062_5 as u128, 32u16);
        // D s_1062_7: bit-extract s_1062_6 s_1062_3 s_1062_4
        let s_1062_7: Bits = (Bits::new(
            ((s_1062_6) >> (s_1062_3)).value(),
            u16::try_from(s_1062_4).unwrap(),
        ));
        // D s_1062_8: cast reint s_1062_7 -> u8
        let s_1062_8: bool = ((s_1062_7.value()) != 0);
        // C s_1062_9: const #20s : i
        let s_1062_9: i128 = 20;
        // C s_1062_10: const #1s : i
        let s_1062_10: i128 = 1;
        // D s_1062_11: read-var u#31784:u32
        let s_1062_11: u32 = fn_state.u_31784;
        // D s_1062_12: cast zx s_1062_11 -> bv
        let s_1062_12: Bits = Bits::new(s_1062_11 as u128, 32u16);
        // D s_1062_13: bit-extract s_1062_12 s_1062_9 s_1062_10
        let s_1062_13: Bits = (Bits::new(
            ((s_1062_12) >> (s_1062_9)).value(),
            u16::try_from(s_1062_10).unwrap(),
        ));
        // D s_1062_14: cast reint s_1062_13 -> u8
        let s_1062_14: bool = ((s_1062_13.value()) != 0);
        // C s_1062_15: const #16s : i
        let s_1062_15: i128 = 16;
        // C s_1062_16: const #4s : i
        let s_1062_16: i128 = 4;
        // D s_1062_17: read-var u#31784:u32
        let s_1062_17: u32 = fn_state.u_31784;
        // D s_1062_18: cast zx s_1062_17 -> bv
        let s_1062_18: Bits = Bits::new(s_1062_17 as u128, 32u16);
        // D s_1062_19: bit-extract s_1062_18 s_1062_15 s_1062_16
        let s_1062_19: Bits = (Bits::new(
            ((s_1062_18) >> (s_1062_15)).value(),
            u16::try_from(s_1062_16).unwrap(),
        ));
        // D s_1062_20: cast reint s_1062_19 -> u8
        let s_1062_20: u8 = (s_1062_19.value() as u8);
        // C s_1062_21: const #12s : i
        let s_1062_21: i128 = 12;
        // C s_1062_22: const #4s : i
        let s_1062_22: i128 = 4;
        // D s_1062_23: read-var u#31784:u32
        let s_1062_23: u32 = fn_state.u_31784;
        // D s_1062_24: cast zx s_1062_23 -> bv
        let s_1062_24: Bits = Bits::new(s_1062_23 as u128, 32u16);
        // D s_1062_25: bit-extract s_1062_24 s_1062_21 s_1062_22
        let s_1062_25: Bits = (Bits::new(
            ((s_1062_24) >> (s_1062_21)).value(),
            u16::try_from(s_1062_22).unwrap(),
        ));
        // D s_1062_26: cast reint s_1062_25 -> u8
        let s_1062_26: u8 = (s_1062_25.value() as u8);
        // C s_1062_27: const #7s : i
        let s_1062_27: i128 = 7;
        // C s_1062_28: const #1s : i
        let s_1062_28: i128 = 1;
        // D s_1062_29: read-var u#31784:u32
        let s_1062_29: u32 = fn_state.u_31784;
        // D s_1062_30: cast zx s_1062_29 -> bv
        let s_1062_30: Bits = Bits::new(s_1062_29 as u128, 32u16);
        // D s_1062_31: bit-extract s_1062_30 s_1062_27 s_1062_28
        let s_1062_31: Bits = (Bits::new(
            ((s_1062_30) >> (s_1062_27)).value(),
            u16::try_from(s_1062_28).unwrap(),
        ));
        // D s_1062_32: cast reint s_1062_31 -> u8
        let s_1062_32: bool = ((s_1062_31.value()) != 0);
        // C s_1062_33: const #6s : i
        let s_1062_33: i128 = 6;
        // C s_1062_34: const #1s : i
        let s_1062_34: i128 = 1;
        // D s_1062_35: read-var u#31784:u32
        let s_1062_35: u32 = fn_state.u_31784;
        // D s_1062_36: cast zx s_1062_35 -> bv
        let s_1062_36: Bits = Bits::new(s_1062_35 as u128, 32u16);
        // D s_1062_37: bit-extract s_1062_36 s_1062_33 s_1062_34
        let s_1062_37: Bits = (Bits::new(
            ((s_1062_36) >> (s_1062_33)).value(),
            u16::try_from(s_1062_34).unwrap(),
        ));
        // D s_1062_38: cast reint s_1062_37 -> u8
        let s_1062_38: bool = ((s_1062_37.value()) != 0);
        // C s_1062_39: const #5s : i
        let s_1062_39: i128 = 5;
        // C s_1062_40: const #1s : i
        let s_1062_40: i128 = 1;
        // D s_1062_41: read-var u#31784:u32
        let s_1062_41: u32 = fn_state.u_31784;
        // D s_1062_42: cast zx s_1062_41 -> bv
        let s_1062_42: Bits = Bits::new(s_1062_41 as u128, 32u16);
        // D s_1062_43: bit-extract s_1062_42 s_1062_39 s_1062_40
        let s_1062_43: Bits = (Bits::new(
            ((s_1062_42) >> (s_1062_39)).value(),
            u16::try_from(s_1062_40).unwrap(),
        ));
        // D s_1062_44: cast reint s_1062_43 -> u8
        let s_1062_44: bool = ((s_1062_43.value()) != 0);
        // C s_1062_45: const #0s : i
        let s_1062_45: i128 = 0;
        // C s_1062_46: const #4s : i
        let s_1062_46: i128 = 4;
        // D s_1062_47: read-var u#31784:u32
        let s_1062_47: u32 = fn_state.u_31784;
        // D s_1062_48: cast zx s_1062_47 -> bv
        let s_1062_48: Bits = Bits::new(s_1062_47 as u128, 32u16);
        // D s_1062_49: bit-extract s_1062_48 s_1062_45 s_1062_46
        let s_1062_49: Bits = (Bits::new(
            ((s_1062_48) >> (s_1062_45)).value(),
            u16::try_from(s_1062_46).unwrap(),
        ));
        // D s_1062_50: cast reint s_1062_49 -> u8
        let s_1062_50: u8 = (s_1062_49.value() as u8);
        // D s_1062_51: call decode_aarch32_instrs_VRSQRTS_A1enc_A_txt(s_1062_8, s_1062_14, s_1062_20, s_1062_26, s_1062_32, s_1062_38, s_1062_44, s_1062_50)
        let s_1062_51: () = decode_aarch32_instrs_VRSQRTS_A1enc_A_txt(
            state,
            tracer,
            s_1062_8,
            s_1062_14,
            s_1062_20,
            s_1062_26,
            s_1062_32,
            s_1062_38,
            s_1062_44,
            s_1062_50,
        );
        // N s_1062_52: return
        return;
    }
    fn block_1063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1063_0: read-var merge#var.1:struct
        let s_1063_0: u32 = fn_state.merge_var._1;
        // D s_1063_1: write-var u#31794 <= s_1063_0
        fn_state.u_31794 = s_1063_0;
        // C s_1063_2: const #25s : i
        let s_1063_2: i128 = 25;
        // D s_1063_3: read-var u#31794:u32
        let s_1063_3: u32 = fn_state.u_31794;
        // D s_1063_4: cast zx s_1063_3 -> bv
        let s_1063_4: Bits = Bits::new(s_1063_3 as u128, 32u16);
        // C s_1063_5: const #1s : i64
        let s_1063_5: i64 = 1;
        // C s_1063_6: cast zx s_1063_5 -> i
        let s_1063_6: i128 = (i128::try_from(s_1063_5).unwrap());
        // C s_1063_7: const #6s : i
        let s_1063_7: i128 = 6;
        // C s_1063_8: add s_1063_7 s_1063_6
        let s_1063_8: i128 = (s_1063_7 + s_1063_6);
        // D s_1063_9: bit-extract s_1063_4 s_1063_2 s_1063_8
        let s_1063_9: Bits = (Bits::new(
            ((s_1063_4) >> (s_1063_2)).value(),
            u16::try_from(s_1063_8).unwrap(),
        ));
        // D s_1063_10: cast reint s_1063_9 -> u8
        let s_1063_10: u8 = (s_1063_9.value() as u8);
        // D s_1063_11: cast zx s_1063_10 -> bv
        let s_1063_11: Bits = Bits::new(s_1063_10 as u128, 7u16);
        // C s_1063_12: const #121u : u8
        let s_1063_12: u8 = 121;
        // C s_1063_13: cast zx s_1063_12 -> bv
        let s_1063_13: Bits = Bits::new(s_1063_12 as u128, 7u16);
        // D s_1063_14: cmp-eq s_1063_11 s_1063_13
        let s_1063_14: bool = ((s_1063_11) == (s_1063_13));
        // N s_1063_15: branch s_1063_14 b2044 b1064
        if s_1063_14 {
            return block_2044(state, tracer, fn_state);
        } else {
            return block_1064(state, tracer, fn_state);
        };
    }
    fn block_1064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1064_0: const #0u : u8
        let s_1064_0: bool = false;
        // D s_1064_1: write-var gs#401944 <= s_1064_0
        fn_state.gs_401944 = s_1064_0;
        // N s_1064_2: jump b1065
        return block_1065(state, tracer, fn_state);
    }
    fn block_1065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1065_0: read-var gs#401944:u8
        let s_1065_0: bool = fn_state.gs_401944;
        // N s_1065_1: branch s_1065_0 b2043 b1066
        if s_1065_0 {
            return block_2043(state, tracer, fn_state);
        } else {
            return block_1066(state, tracer, fn_state);
        };
    }
    fn block_1066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1066_0: const #0u : u8
        let s_1066_0: bool = false;
        // D s_1066_1: write-var gs#401946 <= s_1066_0
        fn_state.gs_401946 = s_1066_0;
        // N s_1066_2: jump b1067
        return block_1067(state, tracer, fn_state);
    }
    fn block_1067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1067_0: read-var gs#401946:u8
        let s_1067_0: bool = fn_state.gs_401946;
        // D s_1067_1: not s_1067_0
        let s_1067_1: bool = !s_1067_0;
        // N s_1067_2: branch s_1067_1 b1069 b1068
        if s_1067_1 {
            return block_1069(state, tracer, fn_state);
        } else {
            return block_1068(state, tracer, fn_state);
        };
    }
    fn block_1068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1068_0: const #3668s : i
        let s_1068_0: i128 = 3668;
        // C s_1068_1: const #14696u : u32
        let s_1068_1: u32 = 14696;
        // N s_1068_2: write-reg s_1068_1 <= s_1068_0
        let s_1068_2: () = {
            state.write_register::<i128>(s_1068_1 as isize, s_1068_0);
            tracer.write_register(s_1068_1 as isize, s_1068_0);
        };
        // C s_1068_3: const #24s : i
        let s_1068_3: i128 = 24;
        // C s_1068_4: const #1s : i
        let s_1068_4: i128 = 1;
        // D s_1068_5: read-var u#31794:u32
        let s_1068_5: u32 = fn_state.u_31794;
        // D s_1068_6: cast zx s_1068_5 -> bv
        let s_1068_6: Bits = Bits::new(s_1068_5 as u128, 32u16);
        // D s_1068_7: bit-extract s_1068_6 s_1068_3 s_1068_4
        let s_1068_7: Bits = (Bits::new(
            ((s_1068_6) >> (s_1068_3)).value(),
            u16::try_from(s_1068_4).unwrap(),
        ));
        // D s_1068_8: cast reint s_1068_7 -> u8
        let s_1068_8: bool = ((s_1068_7.value()) != 0);
        // C s_1068_9: const #22s : i
        let s_1068_9: i128 = 22;
        // C s_1068_10: const #1s : i
        let s_1068_10: i128 = 1;
        // D s_1068_11: read-var u#31794:u32
        let s_1068_11: u32 = fn_state.u_31794;
        // D s_1068_12: cast zx s_1068_11 -> bv
        let s_1068_12: Bits = Bits::new(s_1068_11 as u128, 32u16);
        // D s_1068_13: bit-extract s_1068_12 s_1068_9 s_1068_10
        let s_1068_13: Bits = (Bits::new(
            ((s_1068_12) >> (s_1068_9)).value(),
            u16::try_from(s_1068_10).unwrap(),
        ));
        // D s_1068_14: cast reint s_1068_13 -> u8
        let s_1068_14: bool = ((s_1068_13.value()) != 0);
        // C s_1068_15: const #16s : i
        let s_1068_15: i128 = 16;
        // C s_1068_16: const #6s : i
        let s_1068_16: i128 = 6;
        // D s_1068_17: read-var u#31794:u32
        let s_1068_17: u32 = fn_state.u_31794;
        // D s_1068_18: cast zx s_1068_17 -> bv
        let s_1068_18: Bits = Bits::new(s_1068_17 as u128, 32u16);
        // D s_1068_19: bit-extract s_1068_18 s_1068_15 s_1068_16
        let s_1068_19: Bits = (Bits::new(
            ((s_1068_18) >> (s_1068_15)).value(),
            u16::try_from(s_1068_16).unwrap(),
        ));
        // D s_1068_20: cast reint s_1068_19 -> u8
        let s_1068_20: u8 = (s_1068_19.value() as u8);
        // C s_1068_21: const #12s : i
        let s_1068_21: i128 = 12;
        // C s_1068_22: const #4s : i
        let s_1068_22: i128 = 4;
        // D s_1068_23: read-var u#31794:u32
        let s_1068_23: u32 = fn_state.u_31794;
        // D s_1068_24: cast zx s_1068_23 -> bv
        let s_1068_24: Bits = Bits::new(s_1068_23 as u128, 32u16);
        // D s_1068_25: bit-extract s_1068_24 s_1068_21 s_1068_22
        let s_1068_25: Bits = (Bits::new(
            ((s_1068_24) >> (s_1068_21)).value(),
            u16::try_from(s_1068_22).unwrap(),
        ));
        // D s_1068_26: cast reint s_1068_25 -> u8
        let s_1068_26: u8 = (s_1068_25.value() as u8);
        // C s_1068_27: const #7s : i
        let s_1068_27: i128 = 7;
        // C s_1068_28: const #1s : i
        let s_1068_28: i128 = 1;
        // D s_1068_29: read-var u#31794:u32
        let s_1068_29: u32 = fn_state.u_31794;
        // D s_1068_30: cast zx s_1068_29 -> bv
        let s_1068_30: Bits = Bits::new(s_1068_29 as u128, 32u16);
        // D s_1068_31: bit-extract s_1068_30 s_1068_27 s_1068_28
        let s_1068_31: Bits = (Bits::new(
            ((s_1068_30) >> (s_1068_27)).value(),
            u16::try_from(s_1068_28).unwrap(),
        ));
        // D s_1068_32: cast reint s_1068_31 -> u8
        let s_1068_32: bool = ((s_1068_31.value()) != 0);
        // C s_1068_33: const #6s : i
        let s_1068_33: i128 = 6;
        // C s_1068_34: const #1s : i
        let s_1068_34: i128 = 1;
        // D s_1068_35: read-var u#31794:u32
        let s_1068_35: u32 = fn_state.u_31794;
        // D s_1068_36: cast zx s_1068_35 -> bv
        let s_1068_36: Bits = Bits::new(s_1068_35 as u128, 32u16);
        // D s_1068_37: bit-extract s_1068_36 s_1068_33 s_1068_34
        let s_1068_37: Bits = (Bits::new(
            ((s_1068_36) >> (s_1068_33)).value(),
            u16::try_from(s_1068_34).unwrap(),
        ));
        // D s_1068_38: cast reint s_1068_37 -> u8
        let s_1068_38: bool = ((s_1068_37.value()) != 0);
        // C s_1068_39: const #5s : i
        let s_1068_39: i128 = 5;
        // C s_1068_40: const #1s : i
        let s_1068_40: i128 = 1;
        // D s_1068_41: read-var u#31794:u32
        let s_1068_41: u32 = fn_state.u_31794;
        // D s_1068_42: cast zx s_1068_41 -> bv
        let s_1068_42: Bits = Bits::new(s_1068_41 as u128, 32u16);
        // D s_1068_43: bit-extract s_1068_42 s_1068_39 s_1068_40
        let s_1068_43: Bits = (Bits::new(
            ((s_1068_42) >> (s_1068_39)).value(),
            u16::try_from(s_1068_40).unwrap(),
        ));
        // D s_1068_44: cast reint s_1068_43 -> u8
        let s_1068_44: bool = ((s_1068_43.value()) != 0);
        // C s_1068_45: const #0s : i
        let s_1068_45: i128 = 0;
        // C s_1068_46: const #4s : i
        let s_1068_46: i128 = 4;
        // D s_1068_47: read-var u#31794:u32
        let s_1068_47: u32 = fn_state.u_31794;
        // D s_1068_48: cast zx s_1068_47 -> bv
        let s_1068_48: Bits = Bits::new(s_1068_47 as u128, 32u16);
        // D s_1068_49: bit-extract s_1068_48 s_1068_45 s_1068_46
        let s_1068_49: Bits = (Bits::new(
            ((s_1068_48) >> (s_1068_45)).value(),
            u16::try_from(s_1068_46).unwrap(),
        ));
        // D s_1068_50: cast reint s_1068_49 -> u8
        let s_1068_50: u8 = (s_1068_49.value() as u8);
        // D s_1068_51: call decode_aarch32_instrs_VRSRA_A1enc_A_txt(s_1068_8, s_1068_14, s_1068_20, s_1068_26, s_1068_32, s_1068_38, s_1068_44, s_1068_50)
        let s_1068_51: () = decode_aarch32_instrs_VRSRA_A1enc_A_txt(
            state,
            tracer,
            s_1068_8,
            s_1068_14,
            s_1068_20,
            s_1068_26,
            s_1068_32,
            s_1068_38,
            s_1068_44,
            s_1068_50,
        );
        // N s_1068_52: return
        return;
    }
    fn block_1069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1069_0: read-var merge#var.1:struct
        let s_1069_0: u32 = fn_state.merge_var._1;
        // D s_1069_1: write-var u#31804 <= s_1069_0
        fn_state.u_31804 = s_1069_0;
        // C s_1069_2: const #23s : i
        let s_1069_2: i128 = 23;
        // D s_1069_3: read-var u#31804:u32
        let s_1069_3: u32 = fn_state.u_31804;
        // D s_1069_4: cast zx s_1069_3 -> bv
        let s_1069_4: Bits = Bits::new(s_1069_3 as u128, 32u16);
        // C s_1069_5: const #1s : i64
        let s_1069_5: i64 = 1;
        // C s_1069_6: cast zx s_1069_5 -> i
        let s_1069_6: i128 = (i128::try_from(s_1069_5).unwrap());
        // C s_1069_7: const #8s : i
        let s_1069_7: i128 = 8;
        // C s_1069_8: add s_1069_7 s_1069_6
        let s_1069_8: i128 = (s_1069_7 + s_1069_6);
        // D s_1069_9: bit-extract s_1069_4 s_1069_2 s_1069_8
        let s_1069_9: Bits = (Bits::new(
            ((s_1069_4) >> (s_1069_2)).value(),
            u16::try_from(s_1069_8).unwrap(),
        ));
        // D s_1069_10: cast reint s_1069_9 -> u9
        let s_1069_10: u16 = (s_1069_9.value() as u16);
        // D s_1069_11: cast zx s_1069_10 -> bv
        let s_1069_11: Bits = Bits::new(s_1069_10 as u128, 9u16);
        // C s_1069_12: const #487u : u9
        let s_1069_12: u16 = 487;
        // C s_1069_13: cast zx s_1069_12 -> bv
        let s_1069_13: Bits = Bits::new(s_1069_12 as u128, 9u16);
        // D s_1069_14: cmp-eq s_1069_11 s_1069_13
        let s_1069_14: bool = ((s_1069_11) == (s_1069_13));
        // N s_1069_15: branch s_1069_14 b2036 b1070
        if s_1069_14 {
            return block_2036(state, tracer, fn_state);
        } else {
            return block_1070(state, tracer, fn_state);
        };
    }
    fn block_1070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1070_0: const #0u : u8
        let s_1070_0: bool = false;
        // D s_1070_1: write-var gs#401976 <= s_1070_0
        fn_state.gs_401976 = s_1070_0;
        // N s_1070_2: jump b1071
        return block_1071(state, tracer, fn_state);
    }
    fn block_1071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1071_0: read-var gs#401976:u8
        let s_1071_0: bool = fn_state.gs_401976;
        // N s_1071_1: branch s_1071_0 b2035 b1072
        if s_1071_0 {
            return block_2035(state, tracer, fn_state);
        } else {
            return block_1072(state, tracer, fn_state);
        };
    }
    fn block_1072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1072_0: const #0u : u8
        let s_1072_0: bool = false;
        // D s_1072_1: write-var gs#401978 <= s_1072_0
        fn_state.gs_401978 = s_1072_0;
        // N s_1072_2: jump b1073
        return block_1073(state, tracer, fn_state);
    }
    fn block_1073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1073_0: read-var gs#401978:u8
        let s_1073_0: bool = fn_state.gs_401978;
        // D s_1073_1: not s_1073_0
        let s_1073_1: bool = !s_1073_0;
        // N s_1073_2: branch s_1073_1 b1075 b1074
        if s_1073_1 {
            return block_1075(state, tracer, fn_state);
        } else {
            return block_1074(state, tracer, fn_state);
        };
    }
    fn block_1074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1074_0: const #3670s : i
        let s_1074_0: i128 = 3670;
        // C s_1074_1: const #14696u : u32
        let s_1074_1: u32 = 14696;
        // N s_1074_2: write-reg s_1074_1 <= s_1074_0
        let s_1074_2: () = {
            state.write_register::<i128>(s_1074_1 as isize, s_1074_0);
            tracer.write_register(s_1074_1 as isize, s_1074_0);
        };
        // C s_1074_3: const #22s : i
        let s_1074_3: i128 = 22;
        // C s_1074_4: const #1s : i
        let s_1074_4: i128 = 1;
        // D s_1074_5: read-var u#31804:u32
        let s_1074_5: u32 = fn_state.u_31804;
        // D s_1074_6: cast zx s_1074_5 -> bv
        let s_1074_6: Bits = Bits::new(s_1074_5 as u128, 32u16);
        // D s_1074_7: bit-extract s_1074_6 s_1074_3 s_1074_4
        let s_1074_7: Bits = (Bits::new(
            ((s_1074_6) >> (s_1074_3)).value(),
            u16::try_from(s_1074_4).unwrap(),
        ));
        // D s_1074_8: cast reint s_1074_7 -> u8
        let s_1074_8: bool = ((s_1074_7.value()) != 0);
        // C s_1074_9: const #20s : i
        let s_1074_9: i128 = 20;
        // C s_1074_10: const #2s : i
        let s_1074_10: i128 = 2;
        // D s_1074_11: read-var u#31804:u32
        let s_1074_11: u32 = fn_state.u_31804;
        // D s_1074_12: cast zx s_1074_11 -> bv
        let s_1074_12: Bits = Bits::new(s_1074_11 as u128, 32u16);
        // D s_1074_13: bit-extract s_1074_12 s_1074_9 s_1074_10
        let s_1074_13: Bits = (Bits::new(
            ((s_1074_12) >> (s_1074_9)).value(),
            u16::try_from(s_1074_10).unwrap(),
        ));
        // D s_1074_14: cast reint s_1074_13 -> u8
        let s_1074_14: u8 = (s_1074_13.value() as u8);
        // C s_1074_15: const #16s : i
        let s_1074_15: i128 = 16;
        // C s_1074_16: const #4s : i
        let s_1074_16: i128 = 4;
        // D s_1074_17: read-var u#31804:u32
        let s_1074_17: u32 = fn_state.u_31804;
        // D s_1074_18: cast zx s_1074_17 -> bv
        let s_1074_18: Bits = Bits::new(s_1074_17 as u128, 32u16);
        // D s_1074_19: bit-extract s_1074_18 s_1074_15 s_1074_16
        let s_1074_19: Bits = (Bits::new(
            ((s_1074_18) >> (s_1074_15)).value(),
            u16::try_from(s_1074_16).unwrap(),
        ));
        // D s_1074_20: cast reint s_1074_19 -> u8
        let s_1074_20: u8 = (s_1074_19.value() as u8);
        // C s_1074_21: const #12s : i
        let s_1074_21: i128 = 12;
        // C s_1074_22: const #4s : i
        let s_1074_22: i128 = 4;
        // D s_1074_23: read-var u#31804:u32
        let s_1074_23: u32 = fn_state.u_31804;
        // D s_1074_24: cast zx s_1074_23 -> bv
        let s_1074_24: Bits = Bits::new(s_1074_23 as u128, 32u16);
        // D s_1074_25: bit-extract s_1074_24 s_1074_21 s_1074_22
        let s_1074_25: Bits = (Bits::new(
            ((s_1074_24) >> (s_1074_21)).value(),
            u16::try_from(s_1074_22).unwrap(),
        ));
        // D s_1074_26: cast reint s_1074_25 -> u8
        let s_1074_26: u8 = (s_1074_25.value() as u8);
        // C s_1074_27: const #7s : i
        let s_1074_27: i128 = 7;
        // C s_1074_28: const #1s : i
        let s_1074_28: i128 = 1;
        // D s_1074_29: read-var u#31804:u32
        let s_1074_29: u32 = fn_state.u_31804;
        // D s_1074_30: cast zx s_1074_29 -> bv
        let s_1074_30: Bits = Bits::new(s_1074_29 as u128, 32u16);
        // D s_1074_31: bit-extract s_1074_30 s_1074_27 s_1074_28
        let s_1074_31: Bits = (Bits::new(
            ((s_1074_30) >> (s_1074_27)).value(),
            u16::try_from(s_1074_28).unwrap(),
        ));
        // D s_1074_32: cast reint s_1074_31 -> u8
        let s_1074_32: bool = ((s_1074_31.value()) != 0);
        // C s_1074_33: const #5s : i
        let s_1074_33: i128 = 5;
        // C s_1074_34: const #1s : i
        let s_1074_34: i128 = 1;
        // D s_1074_35: read-var u#31804:u32
        let s_1074_35: u32 = fn_state.u_31804;
        // D s_1074_36: cast zx s_1074_35 -> bv
        let s_1074_36: Bits = Bits::new(s_1074_35 as u128, 32u16);
        // D s_1074_37: bit-extract s_1074_36 s_1074_33 s_1074_34
        let s_1074_37: Bits = (Bits::new(
            ((s_1074_36) >> (s_1074_33)).value(),
            u16::try_from(s_1074_34).unwrap(),
        ));
        // D s_1074_38: cast reint s_1074_37 -> u8
        let s_1074_38: bool = ((s_1074_37.value()) != 0);
        // C s_1074_39: const #0s : i
        let s_1074_39: i128 = 0;
        // C s_1074_40: const #4s : i
        let s_1074_40: i128 = 4;
        // D s_1074_41: read-var u#31804:u32
        let s_1074_41: u32 = fn_state.u_31804;
        // D s_1074_42: cast zx s_1074_41 -> bv
        let s_1074_42: Bits = Bits::new(s_1074_41 as u128, 32u16);
        // D s_1074_43: bit-extract s_1074_42 s_1074_39 s_1074_40
        let s_1074_43: Bits = (Bits::new(
            ((s_1074_42) >> (s_1074_39)).value(),
            u16::try_from(s_1074_40).unwrap(),
        ));
        // D s_1074_44: cast reint s_1074_43 -> u8
        let s_1074_44: u8 = (s_1074_43.value() as u8);
        // D s_1074_45: call decode_aarch32_instrs_VRSUBHN_A1enc_A_txt(s_1074_8, s_1074_14, s_1074_20, s_1074_26, s_1074_32, s_1074_38, s_1074_44)
        let s_1074_45: () = decode_aarch32_instrs_VRSUBHN_A1enc_A_txt(
            state,
            tracer,
            s_1074_8,
            s_1074_14,
            s_1074_20,
            s_1074_26,
            s_1074_32,
            s_1074_38,
            s_1074_44,
        );
        // N s_1074_46: return
        return;
    }
    fn block_1075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1075_0: read-var merge#var.1:struct
        let s_1075_0: u32 = fn_state.merge_var._1;
        // D s_1075_1: write-var u#31813 <= s_1075_0
        fn_state.u_31813 = s_1075_0;
        // C s_1075_2: const #23s : i
        let s_1075_2: i128 = 23;
        // D s_1075_3: read-var u#31813:u32
        let s_1075_3: u32 = fn_state.u_31813;
        // D s_1075_4: cast zx s_1075_3 -> bv
        let s_1075_4: Bits = Bits::new(s_1075_3 as u128, 32u16);
        // C s_1075_5: const #1s : i64
        let s_1075_5: i64 = 1;
        // C s_1075_6: cast zx s_1075_5 -> i
        let s_1075_6: i128 = (i128::try_from(s_1075_5).unwrap());
        // C s_1075_7: const #8s : i
        let s_1075_7: i128 = 8;
        // C s_1075_8: add s_1075_7 s_1075_6
        let s_1075_8: i128 = (s_1075_7 + s_1075_6);
        // D s_1075_9: bit-extract s_1075_4 s_1075_2 s_1075_8
        let s_1075_9: Bits = (Bits::new(
            ((s_1075_4) >> (s_1075_2)).value(),
            u16::try_from(s_1075_8).unwrap(),
        ));
        // D s_1075_10: cast reint s_1075_9 -> u9
        let s_1075_10: u16 = (s_1075_9.value() as u16);
        // D s_1075_11: cast zx s_1075_10 -> bv
        let s_1075_11: Bits = Bits::new(s_1075_10 as u128, 9u16);
        // C s_1075_12: const #485u : u9
        let s_1075_12: u16 = 485;
        // C s_1075_13: cast zx s_1075_12 -> bv
        let s_1075_13: Bits = Bits::new(s_1075_12 as u128, 9u16);
        // D s_1075_14: cmp-eq s_1075_11 s_1075_13
        let s_1075_14: bool = ((s_1075_11) == (s_1075_13));
        // N s_1075_15: branch s_1075_14 b2031 b1076
        if s_1075_14 {
            return block_2031(state, tracer, fn_state);
        } else {
            return block_1076(state, tracer, fn_state);
        };
    }
    fn block_1076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1076_0: const #0u : u8
        let s_1076_0: bool = false;
        // D s_1076_1: write-var gs#402003 <= s_1076_0
        fn_state.gs_402003 = s_1076_0;
        // N s_1076_2: jump b1077
        return block_1077(state, tracer, fn_state);
    }
    fn block_1077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1077_0: read-var gs#402003:u8
        let s_1077_0: bool = fn_state.gs_402003;
        // N s_1077_1: branch s_1077_0 b2030 b1078
        if s_1077_0 {
            return block_2030(state, tracer, fn_state);
        } else {
            return block_1078(state, tracer, fn_state);
        };
    }
    fn block_1078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1078_0: const #0u : u8
        let s_1078_0: bool = false;
        // D s_1078_1: write-var gs#402005 <= s_1078_0
        fn_state.gs_402005 = s_1078_0;
        // N s_1078_2: jump b1079
        return block_1079(state, tracer, fn_state);
    }
    fn block_1079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1079_0: read-var gs#402005:u8
        let s_1079_0: bool = fn_state.gs_402005;
        // D s_1079_1: not s_1079_0
        let s_1079_1: bool = !s_1079_0;
        // N s_1079_2: branch s_1079_1 b1081 b1080
        if s_1079_1 {
            return block_1081(state, tracer, fn_state);
        } else {
            return block_1080(state, tracer, fn_state);
        };
    }
    fn block_1080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1080_0: const #3672s : i
        let s_1080_0: i128 = 3672;
        // C s_1080_1: const #14696u : u32
        let s_1080_1: u32 = 14696;
        // N s_1080_2: write-reg s_1080_1 <= s_1080_0
        let s_1080_2: () = {
            state.write_register::<i128>(s_1080_1 as isize, s_1080_0);
            tracer.write_register(s_1080_1 as isize, s_1080_0);
        };
        // C s_1080_3: const #22s : i
        let s_1080_3: i128 = 22;
        // C s_1080_4: const #1s : i
        let s_1080_4: i128 = 1;
        // D s_1080_5: read-var u#31813:u32
        let s_1080_5: u32 = fn_state.u_31813;
        // D s_1080_6: cast zx s_1080_5 -> bv
        let s_1080_6: Bits = Bits::new(s_1080_5 as u128, 32u16);
        // D s_1080_7: bit-extract s_1080_6 s_1080_3 s_1080_4
        let s_1080_7: Bits = (Bits::new(
            ((s_1080_6) >> (s_1080_3)).value(),
            u16::try_from(s_1080_4).unwrap(),
        ));
        // D s_1080_8: cast reint s_1080_7 -> u8
        let s_1080_8: bool = ((s_1080_7.value()) != 0);
        // C s_1080_9: const #16s : i
        let s_1080_9: i128 = 16;
        // C s_1080_10: const #6s : i
        let s_1080_10: i128 = 6;
        // D s_1080_11: read-var u#31813:u32
        let s_1080_11: u32 = fn_state.u_31813;
        // D s_1080_12: cast zx s_1080_11 -> bv
        let s_1080_12: Bits = Bits::new(s_1080_11 as u128, 32u16);
        // D s_1080_13: bit-extract s_1080_12 s_1080_9 s_1080_10
        let s_1080_13: Bits = (Bits::new(
            ((s_1080_12) >> (s_1080_9)).value(),
            u16::try_from(s_1080_10).unwrap(),
        ));
        // D s_1080_14: cast reint s_1080_13 -> u8
        let s_1080_14: u8 = (s_1080_13.value() as u8);
        // C s_1080_15: const #12s : i
        let s_1080_15: i128 = 12;
        // C s_1080_16: const #4s : i
        let s_1080_16: i128 = 4;
        // D s_1080_17: read-var u#31813:u32
        let s_1080_17: u32 = fn_state.u_31813;
        // D s_1080_18: cast zx s_1080_17 -> bv
        let s_1080_18: Bits = Bits::new(s_1080_17 as u128, 32u16);
        // D s_1080_19: bit-extract s_1080_18 s_1080_15 s_1080_16
        let s_1080_19: Bits = (Bits::new(
            ((s_1080_18) >> (s_1080_15)).value(),
            u16::try_from(s_1080_16).unwrap(),
        ));
        // D s_1080_20: cast reint s_1080_19 -> u8
        let s_1080_20: u8 = (s_1080_19.value() as u8);
        // C s_1080_21: const #7s : i
        let s_1080_21: i128 = 7;
        // C s_1080_22: const #1s : i
        let s_1080_22: i128 = 1;
        // D s_1080_23: read-var u#31813:u32
        let s_1080_23: u32 = fn_state.u_31813;
        // D s_1080_24: cast zx s_1080_23 -> bv
        let s_1080_24: Bits = Bits::new(s_1080_23 as u128, 32u16);
        // D s_1080_25: bit-extract s_1080_24 s_1080_21 s_1080_22
        let s_1080_25: Bits = (Bits::new(
            ((s_1080_24) >> (s_1080_21)).value(),
            u16::try_from(s_1080_22).unwrap(),
        ));
        // D s_1080_26: cast reint s_1080_25 -> u8
        let s_1080_26: bool = ((s_1080_25.value()) != 0);
        // C s_1080_27: const #6s : i
        let s_1080_27: i128 = 6;
        // C s_1080_28: const #1s : i
        let s_1080_28: i128 = 1;
        // D s_1080_29: read-var u#31813:u32
        let s_1080_29: u32 = fn_state.u_31813;
        // D s_1080_30: cast zx s_1080_29 -> bv
        let s_1080_30: Bits = Bits::new(s_1080_29 as u128, 32u16);
        // D s_1080_31: bit-extract s_1080_30 s_1080_27 s_1080_28
        let s_1080_31: Bits = (Bits::new(
            ((s_1080_30) >> (s_1080_27)).value(),
            u16::try_from(s_1080_28).unwrap(),
        ));
        // D s_1080_32: cast reint s_1080_31 -> u8
        let s_1080_32: bool = ((s_1080_31.value()) != 0);
        // C s_1080_33: const #5s : i
        let s_1080_33: i128 = 5;
        // C s_1080_34: const #1s : i
        let s_1080_34: i128 = 1;
        // D s_1080_35: read-var u#31813:u32
        let s_1080_35: u32 = fn_state.u_31813;
        // D s_1080_36: cast zx s_1080_35 -> bv
        let s_1080_36: Bits = Bits::new(s_1080_35 as u128, 32u16);
        // D s_1080_37: bit-extract s_1080_36 s_1080_33 s_1080_34
        let s_1080_37: Bits = (Bits::new(
            ((s_1080_36) >> (s_1080_33)).value(),
            u16::try_from(s_1080_34).unwrap(),
        ));
        // D s_1080_38: cast reint s_1080_37 -> u8
        let s_1080_38: bool = ((s_1080_37.value()) != 0);
        // C s_1080_39: const #0s : i
        let s_1080_39: i128 = 0;
        // C s_1080_40: const #4s : i
        let s_1080_40: i128 = 4;
        // D s_1080_41: read-var u#31813:u32
        let s_1080_41: u32 = fn_state.u_31813;
        // D s_1080_42: cast zx s_1080_41 -> bv
        let s_1080_42: Bits = Bits::new(s_1080_41 as u128, 32u16);
        // D s_1080_43: bit-extract s_1080_42 s_1080_39 s_1080_40
        let s_1080_43: Bits = (Bits::new(
            ((s_1080_42) >> (s_1080_39)).value(),
            u16::try_from(s_1080_40).unwrap(),
        ));
        // D s_1080_44: cast reint s_1080_43 -> u8
        let s_1080_44: u8 = (s_1080_43.value() as u8);
        // D s_1080_45: call decode_aarch32_instrs_VSHL_i_A1enc_A_txt(s_1080_8, s_1080_14, s_1080_20, s_1080_26, s_1080_32, s_1080_38, s_1080_44)
        let s_1080_45: () = decode_aarch32_instrs_VSHL_i_A1enc_A_txt(
            state,
            tracer,
            s_1080_8,
            s_1080_14,
            s_1080_20,
            s_1080_26,
            s_1080_32,
            s_1080_38,
            s_1080_44,
        );
        // N s_1080_46: return
        return;
    }
    fn block_1081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1081_0: read-var merge#var.1:struct
        let s_1081_0: u32 = fn_state.merge_var._1;
        // D s_1081_1: write-var u#31822 <= s_1081_0
        fn_state.u_31822 = s_1081_0;
        // C s_1081_2: const #25s : i
        let s_1081_2: i128 = 25;
        // D s_1081_3: read-var u#31822:u32
        let s_1081_3: u32 = fn_state.u_31822;
        // D s_1081_4: cast zx s_1081_3 -> bv
        let s_1081_4: Bits = Bits::new(s_1081_3 as u128, 32u16);
        // C s_1081_5: const #1s : i64
        let s_1081_5: i64 = 1;
        // C s_1081_6: cast zx s_1081_5 -> i
        let s_1081_6: i128 = (i128::try_from(s_1081_5).unwrap());
        // C s_1081_7: const #6s : i
        let s_1081_7: i128 = 6;
        // C s_1081_8: add s_1081_7 s_1081_6
        let s_1081_8: i128 = (s_1081_7 + s_1081_6);
        // D s_1081_9: bit-extract s_1081_4 s_1081_2 s_1081_8
        let s_1081_9: Bits = (Bits::new(
            ((s_1081_4) >> (s_1081_2)).value(),
            u16::try_from(s_1081_8).unwrap(),
        ));
        // D s_1081_10: cast reint s_1081_9 -> u8
        let s_1081_10: u8 = (s_1081_9.value() as u8);
        // D s_1081_11: cast zx s_1081_10 -> bv
        let s_1081_11: Bits = Bits::new(s_1081_10 as u128, 7u16);
        // C s_1081_12: const #121u : u8
        let s_1081_12: u8 = 121;
        // C s_1081_13: cast zx s_1081_12 -> bv
        let s_1081_13: Bits = Bits::new(s_1081_12 as u128, 7u16);
        // D s_1081_14: cmp-eq s_1081_11 s_1081_13
        let s_1081_14: bool = ((s_1081_11) == (s_1081_13));
        // N s_1081_15: branch s_1081_14 b2023 b1082
        if s_1081_14 {
            return block_2023(state, tracer, fn_state);
        } else {
            return block_1082(state, tracer, fn_state);
        };
    }
    fn block_1082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1082_0: const #0u : u8
        let s_1082_0: bool = false;
        // D s_1082_1: write-var gs#402033 <= s_1082_0
        fn_state.gs_402033 = s_1082_0;
        // N s_1082_2: jump b1083
        return block_1083(state, tracer, fn_state);
    }
    fn block_1083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1083_0: read-var gs#402033:u8
        let s_1083_0: bool = fn_state.gs_402033;
        // N s_1083_1: branch s_1083_0 b2022 b1084
        if s_1083_0 {
            return block_2022(state, tracer, fn_state);
        } else {
            return block_1084(state, tracer, fn_state);
        };
    }
    fn block_1084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1084_0: const #0u : u8
        let s_1084_0: bool = false;
        // D s_1084_1: write-var gs#402035 <= s_1084_0
        fn_state.gs_402035 = s_1084_0;
        // N s_1084_2: jump b1085
        return block_1085(state, tracer, fn_state);
    }
    fn block_1085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1085_0: read-var gs#402035:u8
        let s_1085_0: bool = fn_state.gs_402035;
        // D s_1085_1: not s_1085_0
        let s_1085_1: bool = !s_1085_0;
        // N s_1085_2: branch s_1085_1 b1087 b1086
        if s_1085_1 {
            return block_1087(state, tracer, fn_state);
        } else {
            return block_1086(state, tracer, fn_state);
        };
    }
    fn block_1086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1086_0: const #3674s : i
        let s_1086_0: i128 = 3674;
        // C s_1086_1: const #14696u : u32
        let s_1086_1: u32 = 14696;
        // N s_1086_2: write-reg s_1086_1 <= s_1086_0
        let s_1086_2: () = {
            state.write_register::<i128>(s_1086_1 as isize, s_1086_0);
            tracer.write_register(s_1086_1 as isize, s_1086_0);
        };
        // C s_1086_3: const #24s : i
        let s_1086_3: i128 = 24;
        // C s_1086_4: const #1s : i
        let s_1086_4: i128 = 1;
        // D s_1086_5: read-var u#31822:u32
        let s_1086_5: u32 = fn_state.u_31822;
        // D s_1086_6: cast zx s_1086_5 -> bv
        let s_1086_6: Bits = Bits::new(s_1086_5 as u128, 32u16);
        // D s_1086_7: bit-extract s_1086_6 s_1086_3 s_1086_4
        let s_1086_7: Bits = (Bits::new(
            ((s_1086_6) >> (s_1086_3)).value(),
            u16::try_from(s_1086_4).unwrap(),
        ));
        // D s_1086_8: cast reint s_1086_7 -> u8
        let s_1086_8: bool = ((s_1086_7.value()) != 0);
        // C s_1086_9: const #22s : i
        let s_1086_9: i128 = 22;
        // C s_1086_10: const #1s : i
        let s_1086_10: i128 = 1;
        // D s_1086_11: read-var u#31822:u32
        let s_1086_11: u32 = fn_state.u_31822;
        // D s_1086_12: cast zx s_1086_11 -> bv
        let s_1086_12: Bits = Bits::new(s_1086_11 as u128, 32u16);
        // D s_1086_13: bit-extract s_1086_12 s_1086_9 s_1086_10
        let s_1086_13: Bits = (Bits::new(
            ((s_1086_12) >> (s_1086_9)).value(),
            u16::try_from(s_1086_10).unwrap(),
        ));
        // D s_1086_14: cast reint s_1086_13 -> u8
        let s_1086_14: bool = ((s_1086_13.value()) != 0);
        // C s_1086_15: const #16s : i
        let s_1086_15: i128 = 16;
        // C s_1086_16: const #6s : i
        let s_1086_16: i128 = 6;
        // D s_1086_17: read-var u#31822:u32
        let s_1086_17: u32 = fn_state.u_31822;
        // D s_1086_18: cast zx s_1086_17 -> bv
        let s_1086_18: Bits = Bits::new(s_1086_17 as u128, 32u16);
        // D s_1086_19: bit-extract s_1086_18 s_1086_15 s_1086_16
        let s_1086_19: Bits = (Bits::new(
            ((s_1086_18) >> (s_1086_15)).value(),
            u16::try_from(s_1086_16).unwrap(),
        ));
        // D s_1086_20: cast reint s_1086_19 -> u8
        let s_1086_20: u8 = (s_1086_19.value() as u8);
        // C s_1086_21: const #12s : i
        let s_1086_21: i128 = 12;
        // C s_1086_22: const #4s : i
        let s_1086_22: i128 = 4;
        // D s_1086_23: read-var u#31822:u32
        let s_1086_23: u32 = fn_state.u_31822;
        // D s_1086_24: cast zx s_1086_23 -> bv
        let s_1086_24: Bits = Bits::new(s_1086_23 as u128, 32u16);
        // D s_1086_25: bit-extract s_1086_24 s_1086_21 s_1086_22
        let s_1086_25: Bits = (Bits::new(
            ((s_1086_24) >> (s_1086_21)).value(),
            u16::try_from(s_1086_22).unwrap(),
        ));
        // D s_1086_26: cast reint s_1086_25 -> u8
        let s_1086_26: u8 = (s_1086_25.value() as u8);
        // C s_1086_27: const #5s : i
        let s_1086_27: i128 = 5;
        // C s_1086_28: const #1s : i
        let s_1086_28: i128 = 1;
        // D s_1086_29: read-var u#31822:u32
        let s_1086_29: u32 = fn_state.u_31822;
        // D s_1086_30: cast zx s_1086_29 -> bv
        let s_1086_30: Bits = Bits::new(s_1086_29 as u128, 32u16);
        // D s_1086_31: bit-extract s_1086_30 s_1086_27 s_1086_28
        let s_1086_31: Bits = (Bits::new(
            ((s_1086_30) >> (s_1086_27)).value(),
            u16::try_from(s_1086_28).unwrap(),
        ));
        // D s_1086_32: cast reint s_1086_31 -> u8
        let s_1086_32: bool = ((s_1086_31.value()) != 0);
        // C s_1086_33: const #0s : i
        let s_1086_33: i128 = 0;
        // C s_1086_34: const #4s : i
        let s_1086_34: i128 = 4;
        // D s_1086_35: read-var u#31822:u32
        let s_1086_35: u32 = fn_state.u_31822;
        // D s_1086_36: cast zx s_1086_35 -> bv
        let s_1086_36: Bits = Bits::new(s_1086_35 as u128, 32u16);
        // D s_1086_37: bit-extract s_1086_36 s_1086_33 s_1086_34
        let s_1086_37: Bits = (Bits::new(
            ((s_1086_36) >> (s_1086_33)).value(),
            u16::try_from(s_1086_34).unwrap(),
        ));
        // D s_1086_38: cast reint s_1086_37 -> u8
        let s_1086_38: u8 = (s_1086_37.value() as u8);
        // D s_1086_39: call decode_aarch32_instrs_VSHLL_A1enc_A_txt(s_1086_8, s_1086_14, s_1086_20, s_1086_26, s_1086_32, s_1086_38)
        let s_1086_39: () = decode_aarch32_instrs_VSHLL_A1enc_A_txt(
            state,
            tracer,
            s_1086_8,
            s_1086_14,
            s_1086_20,
            s_1086_26,
            s_1086_32,
            s_1086_38,
        );
        // N s_1086_40: return
        return;
    }
    fn block_1087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1087_0: read-var merge#var.1:struct
        let s_1087_0: u32 = fn_state.merge_var._1;
        // D s_1087_1: write-var u#31830 <= s_1087_0
        fn_state.u_31830 = s_1087_0;
        // C s_1087_2: const #23s : i
        let s_1087_2: i128 = 23;
        // D s_1087_3: read-var u#31830:u32
        let s_1087_3: u32 = fn_state.u_31830;
        // D s_1087_4: cast zx s_1087_3 -> bv
        let s_1087_4: Bits = Bits::new(s_1087_3 as u128, 32u16);
        // C s_1087_5: const #1s : i64
        let s_1087_5: i64 = 1;
        // C s_1087_6: cast zx s_1087_5 -> i
        let s_1087_6: i128 = (i128::try_from(s_1087_5).unwrap());
        // C s_1087_7: const #8s : i
        let s_1087_7: i128 = 8;
        // C s_1087_8: add s_1087_7 s_1087_6
        let s_1087_8: i128 = (s_1087_7 + s_1087_6);
        // D s_1087_9: bit-extract s_1087_4 s_1087_2 s_1087_8
        let s_1087_9: Bits = (Bits::new(
            ((s_1087_4) >> (s_1087_2)).value(),
            u16::try_from(s_1087_8).unwrap(),
        ));
        // D s_1087_10: cast reint s_1087_9 -> u9
        let s_1087_10: u16 = (s_1087_9.value() as u16);
        // D s_1087_11: cast zx s_1087_10 -> bv
        let s_1087_11: Bits = Bits::new(s_1087_10 as u128, 9u16);
        // C s_1087_12: const #487u : u9
        let s_1087_12: u16 = 487;
        // C s_1087_13: cast zx s_1087_12 -> bv
        let s_1087_13: Bits = Bits::new(s_1087_12 as u128, 9u16);
        // D s_1087_14: cmp-eq s_1087_11 s_1087_13
        let s_1087_14: bool = ((s_1087_11) == (s_1087_13));
        // N s_1087_15: branch s_1087_14 b2012 b1088
        if s_1087_14 {
            return block_2012(state, tracer, fn_state);
        } else {
            return block_1088(state, tracer, fn_state);
        };
    }
    fn block_1088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1088_0: const #0u : u8
        let s_1088_0: bool = false;
        // D s_1088_1: write-var gs#402064 <= s_1088_0
        fn_state.gs_402064 = s_1088_0;
        // N s_1088_2: jump b1089
        return block_1089(state, tracer, fn_state);
    }
    fn block_1089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1089_0: read-var gs#402064:u8
        let s_1089_0: bool = fn_state.gs_402064;
        // N s_1089_1: branch s_1089_0 b2011 b1090
        if s_1089_0 {
            return block_2011(state, tracer, fn_state);
        } else {
            return block_1090(state, tracer, fn_state);
        };
    }
    fn block_1090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1090_0: const #0u : u8
        let s_1090_0: bool = false;
        // D s_1090_1: write-var gs#402066 <= s_1090_0
        fn_state.gs_402066 = s_1090_0;
        // N s_1090_2: jump b1091
        return block_1091(state, tracer, fn_state);
    }
    fn block_1091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1091_0: read-var gs#402066:u8
        let s_1091_0: bool = fn_state.gs_402066;
        // D s_1091_1: not s_1091_0
        let s_1091_1: bool = !s_1091_0;
        // N s_1091_2: branch s_1091_1 b1093 b1092
        if s_1091_1 {
            return block_1093(state, tracer, fn_state);
        } else {
            return block_1092(state, tracer, fn_state);
        };
    }
    fn block_1092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1092_0: const #3675s : i
        let s_1092_0: i128 = 3675;
        // C s_1092_1: const #14696u : u32
        let s_1092_1: u32 = 14696;
        // N s_1092_2: write-reg s_1092_1 <= s_1092_0
        let s_1092_2: () = {
            state.write_register::<i128>(s_1092_1 as isize, s_1092_0);
            tracer.write_register(s_1092_1 as isize, s_1092_0);
        };
        // C s_1092_3: const #22s : i
        let s_1092_3: i128 = 22;
        // C s_1092_4: const #1s : i
        let s_1092_4: i128 = 1;
        // D s_1092_5: read-var u#31830:u32
        let s_1092_5: u32 = fn_state.u_31830;
        // D s_1092_6: cast zx s_1092_5 -> bv
        let s_1092_6: Bits = Bits::new(s_1092_5 as u128, 32u16);
        // D s_1092_7: bit-extract s_1092_6 s_1092_3 s_1092_4
        let s_1092_7: Bits = (Bits::new(
            ((s_1092_6) >> (s_1092_3)).value(),
            u16::try_from(s_1092_4).unwrap(),
        ));
        // D s_1092_8: cast reint s_1092_7 -> u8
        let s_1092_8: bool = ((s_1092_7.value()) != 0);
        // C s_1092_9: const #18s : i
        let s_1092_9: i128 = 18;
        // C s_1092_10: const #2s : i
        let s_1092_10: i128 = 2;
        // D s_1092_11: read-var u#31830:u32
        let s_1092_11: u32 = fn_state.u_31830;
        // D s_1092_12: cast zx s_1092_11 -> bv
        let s_1092_12: Bits = Bits::new(s_1092_11 as u128, 32u16);
        // D s_1092_13: bit-extract s_1092_12 s_1092_9 s_1092_10
        let s_1092_13: Bits = (Bits::new(
            ((s_1092_12) >> (s_1092_9)).value(),
            u16::try_from(s_1092_10).unwrap(),
        ));
        // D s_1092_14: cast reint s_1092_13 -> u8
        let s_1092_14: u8 = (s_1092_13.value() as u8);
        // C s_1092_15: const #12s : i
        let s_1092_15: i128 = 12;
        // C s_1092_16: const #4s : i
        let s_1092_16: i128 = 4;
        // D s_1092_17: read-var u#31830:u32
        let s_1092_17: u32 = fn_state.u_31830;
        // D s_1092_18: cast zx s_1092_17 -> bv
        let s_1092_18: Bits = Bits::new(s_1092_17 as u128, 32u16);
        // D s_1092_19: bit-extract s_1092_18 s_1092_15 s_1092_16
        let s_1092_19: Bits = (Bits::new(
            ((s_1092_18) >> (s_1092_15)).value(),
            u16::try_from(s_1092_16).unwrap(),
        ));
        // D s_1092_20: cast reint s_1092_19 -> u8
        let s_1092_20: u8 = (s_1092_19.value() as u8);
        // C s_1092_21: const #5s : i
        let s_1092_21: i128 = 5;
        // C s_1092_22: const #1s : i
        let s_1092_22: i128 = 1;
        // D s_1092_23: read-var u#31830:u32
        let s_1092_23: u32 = fn_state.u_31830;
        // D s_1092_24: cast zx s_1092_23 -> bv
        let s_1092_24: Bits = Bits::new(s_1092_23 as u128, 32u16);
        // D s_1092_25: bit-extract s_1092_24 s_1092_21 s_1092_22
        let s_1092_25: Bits = (Bits::new(
            ((s_1092_24) >> (s_1092_21)).value(),
            u16::try_from(s_1092_22).unwrap(),
        ));
        // D s_1092_26: cast reint s_1092_25 -> u8
        let s_1092_26: bool = ((s_1092_25.value()) != 0);
        // C s_1092_27: const #0s : i
        let s_1092_27: i128 = 0;
        // C s_1092_28: const #4s : i
        let s_1092_28: i128 = 4;
        // D s_1092_29: read-var u#31830:u32
        let s_1092_29: u32 = fn_state.u_31830;
        // D s_1092_30: cast zx s_1092_29 -> bv
        let s_1092_30: Bits = Bits::new(s_1092_29 as u128, 32u16);
        // D s_1092_31: bit-extract s_1092_30 s_1092_27 s_1092_28
        let s_1092_31: Bits = (Bits::new(
            ((s_1092_30) >> (s_1092_27)).value(),
            u16::try_from(s_1092_28).unwrap(),
        ));
        // D s_1092_32: cast reint s_1092_31 -> u8
        let s_1092_32: u8 = (s_1092_31.value() as u8);
        // D s_1092_33: call decode_aarch32_instrs_VSHLL_A2enc_A_txt(s_1092_8, s_1092_14, s_1092_20, s_1092_26, s_1092_32)
        let s_1092_33: () = decode_aarch32_instrs_VSHLL_A2enc_A_txt(
            state,
            tracer,
            s_1092_8,
            s_1092_14,
            s_1092_20,
            s_1092_26,
            s_1092_32,
        );
        // N s_1092_34: return
        return;
    }
    fn block_1093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1093_0: read-var merge#var.1:struct
        let s_1093_0: u32 = fn_state.merge_var._1;
        // D s_1093_1: write-var u#31837 <= s_1093_0
        fn_state.u_31837 = s_1093_0;
        // C s_1093_2: const #25s : i
        let s_1093_2: i128 = 25;
        // D s_1093_3: read-var u#31837:u32
        let s_1093_3: u32 = fn_state.u_31837;
        // D s_1093_4: cast zx s_1093_3 -> bv
        let s_1093_4: Bits = Bits::new(s_1093_3 as u128, 32u16);
        // C s_1093_5: const #1s : i64
        let s_1093_5: i64 = 1;
        // C s_1093_6: cast zx s_1093_5 -> i
        let s_1093_6: i128 = (i128::try_from(s_1093_5).unwrap());
        // C s_1093_7: const #6s : i
        let s_1093_7: i128 = 6;
        // C s_1093_8: add s_1093_7 s_1093_6
        let s_1093_8: i128 = (s_1093_7 + s_1093_6);
        // D s_1093_9: bit-extract s_1093_4 s_1093_2 s_1093_8
        let s_1093_9: Bits = (Bits::new(
            ((s_1093_4) >> (s_1093_2)).value(),
            u16::try_from(s_1093_8).unwrap(),
        ));
        // D s_1093_10: cast reint s_1093_9 -> u8
        let s_1093_10: u8 = (s_1093_9.value() as u8);
        // D s_1093_11: cast zx s_1093_10 -> bv
        let s_1093_11: Bits = Bits::new(s_1093_10 as u128, 7u16);
        // C s_1093_12: const #121u : u8
        let s_1093_12: u8 = 121;
        // C s_1093_13: cast zx s_1093_12 -> bv
        let s_1093_13: Bits = Bits::new(s_1093_12 as u128, 7u16);
        // D s_1093_14: cmp-eq s_1093_11 s_1093_13
        let s_1093_14: bool = ((s_1093_11) == (s_1093_13));
        // N s_1093_15: branch s_1093_14 b2004 b1094
        if s_1093_14 {
            return block_2004(state, tracer, fn_state);
        } else {
            return block_1094(state, tracer, fn_state);
        };
    }
    fn block_1094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1094_0: const #0u : u8
        let s_1094_0: bool = false;
        // D s_1094_1: write-var gs#402090 <= s_1094_0
        fn_state.gs_402090 = s_1094_0;
        // N s_1094_2: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_1095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1095_0: read-var gs#402090:u8
        let s_1095_0: bool = fn_state.gs_402090;
        // N s_1095_1: branch s_1095_0 b2003 b1096
        if s_1095_0 {
            return block_2003(state, tracer, fn_state);
        } else {
            return block_1096(state, tracer, fn_state);
        };
    }
    fn block_1096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1096_0: const #0u : u8
        let s_1096_0: bool = false;
        // D s_1096_1: write-var gs#402092 <= s_1096_0
        fn_state.gs_402092 = s_1096_0;
        // N s_1096_2: jump b1097
        return block_1097(state, tracer, fn_state);
    }
    fn block_1097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1097_0: read-var gs#402092:u8
        let s_1097_0: bool = fn_state.gs_402092;
        // D s_1097_1: not s_1097_0
        let s_1097_1: bool = !s_1097_0;
        // N s_1097_2: branch s_1097_1 b1099 b1098
        if s_1097_1 {
            return block_1099(state, tracer, fn_state);
        } else {
            return block_1098(state, tracer, fn_state);
        };
    }
    fn block_1098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1098_0: const #3678s : i
        let s_1098_0: i128 = 3678;
        // C s_1098_1: const #14696u : u32
        let s_1098_1: u32 = 14696;
        // N s_1098_2: write-reg s_1098_1 <= s_1098_0
        let s_1098_2: () = {
            state.write_register::<i128>(s_1098_1 as isize, s_1098_0);
            tracer.write_register(s_1098_1 as isize, s_1098_0);
        };
        // C s_1098_3: const #24s : i
        let s_1098_3: i128 = 24;
        // C s_1098_4: const #1s : i
        let s_1098_4: i128 = 1;
        // D s_1098_5: read-var u#31837:u32
        let s_1098_5: u32 = fn_state.u_31837;
        // D s_1098_6: cast zx s_1098_5 -> bv
        let s_1098_6: Bits = Bits::new(s_1098_5 as u128, 32u16);
        // D s_1098_7: bit-extract s_1098_6 s_1098_3 s_1098_4
        let s_1098_7: Bits = (Bits::new(
            ((s_1098_6) >> (s_1098_3)).value(),
            u16::try_from(s_1098_4).unwrap(),
        ));
        // D s_1098_8: cast reint s_1098_7 -> u8
        let s_1098_8: bool = ((s_1098_7.value()) != 0);
        // C s_1098_9: const #22s : i
        let s_1098_9: i128 = 22;
        // C s_1098_10: const #1s : i
        let s_1098_10: i128 = 1;
        // D s_1098_11: read-var u#31837:u32
        let s_1098_11: u32 = fn_state.u_31837;
        // D s_1098_12: cast zx s_1098_11 -> bv
        let s_1098_12: Bits = Bits::new(s_1098_11 as u128, 32u16);
        // D s_1098_13: bit-extract s_1098_12 s_1098_9 s_1098_10
        let s_1098_13: Bits = (Bits::new(
            ((s_1098_12) >> (s_1098_9)).value(),
            u16::try_from(s_1098_10).unwrap(),
        ));
        // D s_1098_14: cast reint s_1098_13 -> u8
        let s_1098_14: bool = ((s_1098_13.value()) != 0);
        // C s_1098_15: const #20s : i
        let s_1098_15: i128 = 20;
        // C s_1098_16: const #2s : i
        let s_1098_16: i128 = 2;
        // D s_1098_17: read-var u#31837:u32
        let s_1098_17: u32 = fn_state.u_31837;
        // D s_1098_18: cast zx s_1098_17 -> bv
        let s_1098_18: Bits = Bits::new(s_1098_17 as u128, 32u16);
        // D s_1098_19: bit-extract s_1098_18 s_1098_15 s_1098_16
        let s_1098_19: Bits = (Bits::new(
            ((s_1098_18) >> (s_1098_15)).value(),
            u16::try_from(s_1098_16).unwrap(),
        ));
        // D s_1098_20: cast reint s_1098_19 -> u8
        let s_1098_20: u8 = (s_1098_19.value() as u8);
        // C s_1098_21: const #16s : i
        let s_1098_21: i128 = 16;
        // C s_1098_22: const #4s : i
        let s_1098_22: i128 = 4;
        // D s_1098_23: read-var u#31837:u32
        let s_1098_23: u32 = fn_state.u_31837;
        // D s_1098_24: cast zx s_1098_23 -> bv
        let s_1098_24: Bits = Bits::new(s_1098_23 as u128, 32u16);
        // D s_1098_25: bit-extract s_1098_24 s_1098_21 s_1098_22
        let s_1098_25: Bits = (Bits::new(
            ((s_1098_24) >> (s_1098_21)).value(),
            u16::try_from(s_1098_22).unwrap(),
        ));
        // D s_1098_26: cast reint s_1098_25 -> u8
        let s_1098_26: u8 = (s_1098_25.value() as u8);
        // C s_1098_27: const #12s : i
        let s_1098_27: i128 = 12;
        // C s_1098_28: const #4s : i
        let s_1098_28: i128 = 4;
        // D s_1098_29: read-var u#31837:u32
        let s_1098_29: u32 = fn_state.u_31837;
        // D s_1098_30: cast zx s_1098_29 -> bv
        let s_1098_30: Bits = Bits::new(s_1098_29 as u128, 32u16);
        // D s_1098_31: bit-extract s_1098_30 s_1098_27 s_1098_28
        let s_1098_31: Bits = (Bits::new(
            ((s_1098_30) >> (s_1098_27)).value(),
            u16::try_from(s_1098_28).unwrap(),
        ));
        // D s_1098_32: cast reint s_1098_31 -> u8
        let s_1098_32: u8 = (s_1098_31.value() as u8);
        // C s_1098_33: const #7s : i
        let s_1098_33: i128 = 7;
        // C s_1098_34: const #1s : i
        let s_1098_34: i128 = 1;
        // D s_1098_35: read-var u#31837:u32
        let s_1098_35: u32 = fn_state.u_31837;
        // D s_1098_36: cast zx s_1098_35 -> bv
        let s_1098_36: Bits = Bits::new(s_1098_35 as u128, 32u16);
        // D s_1098_37: bit-extract s_1098_36 s_1098_33 s_1098_34
        let s_1098_37: Bits = (Bits::new(
            ((s_1098_36) >> (s_1098_33)).value(),
            u16::try_from(s_1098_34).unwrap(),
        ));
        // D s_1098_38: cast reint s_1098_37 -> u8
        let s_1098_38: bool = ((s_1098_37.value()) != 0);
        // C s_1098_39: const #6s : i
        let s_1098_39: i128 = 6;
        // C s_1098_40: const #1s : i
        let s_1098_40: i128 = 1;
        // D s_1098_41: read-var u#31837:u32
        let s_1098_41: u32 = fn_state.u_31837;
        // D s_1098_42: cast zx s_1098_41 -> bv
        let s_1098_42: Bits = Bits::new(s_1098_41 as u128, 32u16);
        // D s_1098_43: bit-extract s_1098_42 s_1098_39 s_1098_40
        let s_1098_43: Bits = (Bits::new(
            ((s_1098_42) >> (s_1098_39)).value(),
            u16::try_from(s_1098_40).unwrap(),
        ));
        // D s_1098_44: cast reint s_1098_43 -> u8
        let s_1098_44: bool = ((s_1098_43.value()) != 0);
        // C s_1098_45: const #5s : i
        let s_1098_45: i128 = 5;
        // C s_1098_46: const #1s : i
        let s_1098_46: i128 = 1;
        // D s_1098_47: read-var u#31837:u32
        let s_1098_47: u32 = fn_state.u_31837;
        // D s_1098_48: cast zx s_1098_47 -> bv
        let s_1098_48: Bits = Bits::new(s_1098_47 as u128, 32u16);
        // D s_1098_49: bit-extract s_1098_48 s_1098_45 s_1098_46
        let s_1098_49: Bits = (Bits::new(
            ((s_1098_48) >> (s_1098_45)).value(),
            u16::try_from(s_1098_46).unwrap(),
        ));
        // D s_1098_50: cast reint s_1098_49 -> u8
        let s_1098_50: bool = ((s_1098_49.value()) != 0);
        // C s_1098_51: const #0s : i
        let s_1098_51: i128 = 0;
        // C s_1098_52: const #4s : i
        let s_1098_52: i128 = 4;
        // D s_1098_53: read-var u#31837:u32
        let s_1098_53: u32 = fn_state.u_31837;
        // D s_1098_54: cast zx s_1098_53 -> bv
        let s_1098_54: Bits = Bits::new(s_1098_53 as u128, 32u16);
        // D s_1098_55: bit-extract s_1098_54 s_1098_51 s_1098_52
        let s_1098_55: Bits = (Bits::new(
            ((s_1098_54) >> (s_1098_51)).value(),
            u16::try_from(s_1098_52).unwrap(),
        ));
        // D s_1098_56: cast reint s_1098_55 -> u8
        let s_1098_56: u8 = (s_1098_55.value() as u8);
        // D s_1098_57: call decode_aarch32_instrs_VSHL_r_A1enc_A_txt(s_1098_8, s_1098_14, s_1098_20, s_1098_26, s_1098_32, s_1098_38, s_1098_44, s_1098_50, s_1098_56)
        let s_1098_57: () = decode_aarch32_instrs_VSHL_r_A1enc_A_txt(
            state,
            tracer,
            s_1098_8,
            s_1098_14,
            s_1098_20,
            s_1098_26,
            s_1098_32,
            s_1098_38,
            s_1098_44,
            s_1098_50,
            s_1098_56,
        );
        // N s_1098_58: return
        return;
    }
    fn block_1099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1099_0: read-var merge#var.1:struct
        let s_1099_0: u32 = fn_state.merge_var._1;
        // D s_1099_1: write-var u#31848 <= s_1099_0
        fn_state.u_31848 = s_1099_0;
        // C s_1099_2: const #25s : i
        let s_1099_2: i128 = 25;
        // D s_1099_3: read-var u#31848:u32
        let s_1099_3: u32 = fn_state.u_31848;
        // D s_1099_4: cast zx s_1099_3 -> bv
        let s_1099_4: Bits = Bits::new(s_1099_3 as u128, 32u16);
        // C s_1099_5: const #1s : i64
        let s_1099_5: i64 = 1;
        // C s_1099_6: cast zx s_1099_5 -> i
        let s_1099_6: i128 = (i128::try_from(s_1099_5).unwrap());
        // C s_1099_7: const #6s : i
        let s_1099_7: i128 = 6;
        // C s_1099_8: add s_1099_7 s_1099_6
        let s_1099_8: i128 = (s_1099_7 + s_1099_6);
        // D s_1099_9: bit-extract s_1099_4 s_1099_2 s_1099_8
        let s_1099_9: Bits = (Bits::new(
            ((s_1099_4) >> (s_1099_2)).value(),
            u16::try_from(s_1099_8).unwrap(),
        ));
        // D s_1099_10: cast reint s_1099_9 -> u8
        let s_1099_10: u8 = (s_1099_9.value() as u8);
        // D s_1099_11: cast zx s_1099_10 -> bv
        let s_1099_11: Bits = Bits::new(s_1099_10 as u128, 7u16);
        // C s_1099_12: const #121u : u8
        let s_1099_12: u8 = 121;
        // C s_1099_13: cast zx s_1099_12 -> bv
        let s_1099_13: Bits = Bits::new(s_1099_12 as u128, 7u16);
        // D s_1099_14: cmp-eq s_1099_11 s_1099_13
        let s_1099_14: bool = ((s_1099_11) == (s_1099_13));
        // N s_1099_15: branch s_1099_14 b1996 b1100
        if s_1099_14 {
            return block_1996(state, tracer, fn_state);
        } else {
            return block_1100(state, tracer, fn_state);
        };
    }
    fn block_1100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1100_0: const #0u : u8
        let s_1100_0: bool = false;
        // D s_1100_1: write-var gs#402124 <= s_1100_0
        fn_state.gs_402124 = s_1100_0;
        // N s_1100_2: jump b1101
        return block_1101(state, tracer, fn_state);
    }
    fn block_1101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1101_0: read-var gs#402124:u8
        let s_1101_0: bool = fn_state.gs_402124;
        // N s_1101_1: branch s_1101_0 b1995 b1102
        if s_1101_0 {
            return block_1995(state, tracer, fn_state);
        } else {
            return block_1102(state, tracer, fn_state);
        };
    }
    fn block_1102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1102_0: const #0u : u8
        let s_1102_0: bool = false;
        // D s_1102_1: write-var gs#402126 <= s_1102_0
        fn_state.gs_402126 = s_1102_0;
        // N s_1102_2: jump b1103
        return block_1103(state, tracer, fn_state);
    }
    fn block_1103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1103_0: read-var gs#402126:u8
        let s_1103_0: bool = fn_state.gs_402126;
        // D s_1103_1: not s_1103_0
        let s_1103_1: bool = !s_1103_0;
        // N s_1103_2: branch s_1103_1 b1105 b1104
        if s_1103_1 {
            return block_1105(state, tracer, fn_state);
        } else {
            return block_1104(state, tracer, fn_state);
        };
    }
    fn block_1104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1104_0: const #3680s : i
        let s_1104_0: i128 = 3680;
        // C s_1104_1: const #14696u : u32
        let s_1104_1: u32 = 14696;
        // N s_1104_2: write-reg s_1104_1 <= s_1104_0
        let s_1104_2: () = {
            state.write_register::<i128>(s_1104_1 as isize, s_1104_0);
            tracer.write_register(s_1104_1 as isize, s_1104_0);
        };
        // C s_1104_3: const #24s : i
        let s_1104_3: i128 = 24;
        // C s_1104_4: const #1s : i
        let s_1104_4: i128 = 1;
        // D s_1104_5: read-var u#31848:u32
        let s_1104_5: u32 = fn_state.u_31848;
        // D s_1104_6: cast zx s_1104_5 -> bv
        let s_1104_6: Bits = Bits::new(s_1104_5 as u128, 32u16);
        // D s_1104_7: bit-extract s_1104_6 s_1104_3 s_1104_4
        let s_1104_7: Bits = (Bits::new(
            ((s_1104_6) >> (s_1104_3)).value(),
            u16::try_from(s_1104_4).unwrap(),
        ));
        // D s_1104_8: cast reint s_1104_7 -> u8
        let s_1104_8: bool = ((s_1104_7.value()) != 0);
        // C s_1104_9: const #22s : i
        let s_1104_9: i128 = 22;
        // C s_1104_10: const #1s : i
        let s_1104_10: i128 = 1;
        // D s_1104_11: read-var u#31848:u32
        let s_1104_11: u32 = fn_state.u_31848;
        // D s_1104_12: cast zx s_1104_11 -> bv
        let s_1104_12: Bits = Bits::new(s_1104_11 as u128, 32u16);
        // D s_1104_13: bit-extract s_1104_12 s_1104_9 s_1104_10
        let s_1104_13: Bits = (Bits::new(
            ((s_1104_12) >> (s_1104_9)).value(),
            u16::try_from(s_1104_10).unwrap(),
        ));
        // D s_1104_14: cast reint s_1104_13 -> u8
        let s_1104_14: bool = ((s_1104_13.value()) != 0);
        // C s_1104_15: const #16s : i
        let s_1104_15: i128 = 16;
        // C s_1104_16: const #6s : i
        let s_1104_16: i128 = 6;
        // D s_1104_17: read-var u#31848:u32
        let s_1104_17: u32 = fn_state.u_31848;
        // D s_1104_18: cast zx s_1104_17 -> bv
        let s_1104_18: Bits = Bits::new(s_1104_17 as u128, 32u16);
        // D s_1104_19: bit-extract s_1104_18 s_1104_15 s_1104_16
        let s_1104_19: Bits = (Bits::new(
            ((s_1104_18) >> (s_1104_15)).value(),
            u16::try_from(s_1104_16).unwrap(),
        ));
        // D s_1104_20: cast reint s_1104_19 -> u8
        let s_1104_20: u8 = (s_1104_19.value() as u8);
        // C s_1104_21: const #12s : i
        let s_1104_21: i128 = 12;
        // C s_1104_22: const #4s : i
        let s_1104_22: i128 = 4;
        // D s_1104_23: read-var u#31848:u32
        let s_1104_23: u32 = fn_state.u_31848;
        // D s_1104_24: cast zx s_1104_23 -> bv
        let s_1104_24: Bits = Bits::new(s_1104_23 as u128, 32u16);
        // D s_1104_25: bit-extract s_1104_24 s_1104_21 s_1104_22
        let s_1104_25: Bits = (Bits::new(
            ((s_1104_24) >> (s_1104_21)).value(),
            u16::try_from(s_1104_22).unwrap(),
        ));
        // D s_1104_26: cast reint s_1104_25 -> u8
        let s_1104_26: u8 = (s_1104_25.value() as u8);
        // C s_1104_27: const #7s : i
        let s_1104_27: i128 = 7;
        // C s_1104_28: const #1s : i
        let s_1104_28: i128 = 1;
        // D s_1104_29: read-var u#31848:u32
        let s_1104_29: u32 = fn_state.u_31848;
        // D s_1104_30: cast zx s_1104_29 -> bv
        let s_1104_30: Bits = Bits::new(s_1104_29 as u128, 32u16);
        // D s_1104_31: bit-extract s_1104_30 s_1104_27 s_1104_28
        let s_1104_31: Bits = (Bits::new(
            ((s_1104_30) >> (s_1104_27)).value(),
            u16::try_from(s_1104_28).unwrap(),
        ));
        // D s_1104_32: cast reint s_1104_31 -> u8
        let s_1104_32: bool = ((s_1104_31.value()) != 0);
        // C s_1104_33: const #6s : i
        let s_1104_33: i128 = 6;
        // C s_1104_34: const #1s : i
        let s_1104_34: i128 = 1;
        // D s_1104_35: read-var u#31848:u32
        let s_1104_35: u32 = fn_state.u_31848;
        // D s_1104_36: cast zx s_1104_35 -> bv
        let s_1104_36: Bits = Bits::new(s_1104_35 as u128, 32u16);
        // D s_1104_37: bit-extract s_1104_36 s_1104_33 s_1104_34
        let s_1104_37: Bits = (Bits::new(
            ((s_1104_36) >> (s_1104_33)).value(),
            u16::try_from(s_1104_34).unwrap(),
        ));
        // D s_1104_38: cast reint s_1104_37 -> u8
        let s_1104_38: bool = ((s_1104_37.value()) != 0);
        // C s_1104_39: const #5s : i
        let s_1104_39: i128 = 5;
        // C s_1104_40: const #1s : i
        let s_1104_40: i128 = 1;
        // D s_1104_41: read-var u#31848:u32
        let s_1104_41: u32 = fn_state.u_31848;
        // D s_1104_42: cast zx s_1104_41 -> bv
        let s_1104_42: Bits = Bits::new(s_1104_41 as u128, 32u16);
        // D s_1104_43: bit-extract s_1104_42 s_1104_39 s_1104_40
        let s_1104_43: Bits = (Bits::new(
            ((s_1104_42) >> (s_1104_39)).value(),
            u16::try_from(s_1104_40).unwrap(),
        ));
        // D s_1104_44: cast reint s_1104_43 -> u8
        let s_1104_44: bool = ((s_1104_43.value()) != 0);
        // C s_1104_45: const #0s : i
        let s_1104_45: i128 = 0;
        // C s_1104_46: const #4s : i
        let s_1104_46: i128 = 4;
        // D s_1104_47: read-var u#31848:u32
        let s_1104_47: u32 = fn_state.u_31848;
        // D s_1104_48: cast zx s_1104_47 -> bv
        let s_1104_48: Bits = Bits::new(s_1104_47 as u128, 32u16);
        // D s_1104_49: bit-extract s_1104_48 s_1104_45 s_1104_46
        let s_1104_49: Bits = (Bits::new(
            ((s_1104_48) >> (s_1104_45)).value(),
            u16::try_from(s_1104_46).unwrap(),
        ));
        // D s_1104_50: cast reint s_1104_49 -> u8
        let s_1104_50: u8 = (s_1104_49.value() as u8);
        // D s_1104_51: call decode_aarch32_instrs_VSHR_A1enc_A_txt(s_1104_8, s_1104_14, s_1104_20, s_1104_26, s_1104_32, s_1104_38, s_1104_44, s_1104_50)
        let s_1104_51: () = decode_aarch32_instrs_VSHR_A1enc_A_txt(
            state,
            tracer,
            s_1104_8,
            s_1104_14,
            s_1104_20,
            s_1104_26,
            s_1104_32,
            s_1104_38,
            s_1104_44,
            s_1104_50,
        );
        // N s_1104_52: return
        return;
    }
    fn block_1105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1105_0: read-var merge#var.1:struct
        let s_1105_0: u32 = fn_state.merge_var._1;
        // D s_1105_1: write-var u#31858 <= s_1105_0
        fn_state.u_31858 = s_1105_0;
        // C s_1105_2: const #23s : i
        let s_1105_2: i128 = 23;
        // D s_1105_3: read-var u#31858:u32
        let s_1105_3: u32 = fn_state.u_31858;
        // D s_1105_4: cast zx s_1105_3 -> bv
        let s_1105_4: Bits = Bits::new(s_1105_3 as u128, 32u16);
        // C s_1105_5: const #1s : i64
        let s_1105_5: i64 = 1;
        // C s_1105_6: cast zx s_1105_5 -> i
        let s_1105_6: i128 = (i128::try_from(s_1105_5).unwrap());
        // C s_1105_7: const #8s : i
        let s_1105_7: i128 = 8;
        // C s_1105_8: add s_1105_7 s_1105_6
        let s_1105_8: i128 = (s_1105_7 + s_1105_6);
        // D s_1105_9: bit-extract s_1105_4 s_1105_2 s_1105_8
        let s_1105_9: Bits = (Bits::new(
            ((s_1105_4) >> (s_1105_2)).value(),
            u16::try_from(s_1105_8).unwrap(),
        ));
        // D s_1105_10: cast reint s_1105_9 -> u9
        let s_1105_10: u16 = (s_1105_9.value() as u16);
        // D s_1105_11: cast zx s_1105_10 -> bv
        let s_1105_11: Bits = Bits::new(s_1105_10 as u128, 9u16);
        // C s_1105_12: const #485u : u9
        let s_1105_12: u16 = 485;
        // C s_1105_13: cast zx s_1105_12 -> bv
        let s_1105_13: Bits = Bits::new(s_1105_12 as u128, 9u16);
        // D s_1105_14: cmp-eq s_1105_11 s_1105_13
        let s_1105_14: bool = ((s_1105_11) == (s_1105_13));
        // N s_1105_15: branch s_1105_14 b1991 b1106
        if s_1105_14 {
            return block_1991(state, tracer, fn_state);
        } else {
            return block_1106(state, tracer, fn_state);
        };
    }
    fn block_1106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1106_0: const #0u : u8
        let s_1106_0: bool = false;
        // D s_1106_1: write-var gs#402153 <= s_1106_0
        fn_state.gs_402153 = s_1106_0;
        // N s_1106_2: jump b1107
        return block_1107(state, tracer, fn_state);
    }
    fn block_1107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1107_0: read-var gs#402153:u8
        let s_1107_0: bool = fn_state.gs_402153;
        // N s_1107_1: branch s_1107_0 b1990 b1108
        if s_1107_0 {
            return block_1990(state, tracer, fn_state);
        } else {
            return block_1108(state, tracer, fn_state);
        };
    }
    fn block_1108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1108_0: const #0u : u8
        let s_1108_0: bool = false;
        // D s_1108_1: write-var gs#402155 <= s_1108_0
        fn_state.gs_402155 = s_1108_0;
        // N s_1108_2: jump b1109
        return block_1109(state, tracer, fn_state);
    }
    fn block_1109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1109_0: read-var gs#402155:u8
        let s_1109_0: bool = fn_state.gs_402155;
        // D s_1109_1: not s_1109_0
        let s_1109_1: bool = !s_1109_0;
        // N s_1109_2: branch s_1109_1 b1111 b1110
        if s_1109_1 {
            return block_1111(state, tracer, fn_state);
        } else {
            return block_1110(state, tracer, fn_state);
        };
    }
    fn block_1110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1110_0: const #3682s : i
        let s_1110_0: i128 = 3682;
        // C s_1110_1: const #14696u : u32
        let s_1110_1: u32 = 14696;
        // N s_1110_2: write-reg s_1110_1 <= s_1110_0
        let s_1110_2: () = {
            state.write_register::<i128>(s_1110_1 as isize, s_1110_0);
            tracer.write_register(s_1110_1 as isize, s_1110_0);
        };
        // C s_1110_3: const #22s : i
        let s_1110_3: i128 = 22;
        // C s_1110_4: const #1s : i
        let s_1110_4: i128 = 1;
        // D s_1110_5: read-var u#31858:u32
        let s_1110_5: u32 = fn_state.u_31858;
        // D s_1110_6: cast zx s_1110_5 -> bv
        let s_1110_6: Bits = Bits::new(s_1110_5 as u128, 32u16);
        // D s_1110_7: bit-extract s_1110_6 s_1110_3 s_1110_4
        let s_1110_7: Bits = (Bits::new(
            ((s_1110_6) >> (s_1110_3)).value(),
            u16::try_from(s_1110_4).unwrap(),
        ));
        // D s_1110_8: cast reint s_1110_7 -> u8
        let s_1110_8: bool = ((s_1110_7.value()) != 0);
        // C s_1110_9: const #16s : i
        let s_1110_9: i128 = 16;
        // C s_1110_10: const #6s : i
        let s_1110_10: i128 = 6;
        // D s_1110_11: read-var u#31858:u32
        let s_1110_11: u32 = fn_state.u_31858;
        // D s_1110_12: cast zx s_1110_11 -> bv
        let s_1110_12: Bits = Bits::new(s_1110_11 as u128, 32u16);
        // D s_1110_13: bit-extract s_1110_12 s_1110_9 s_1110_10
        let s_1110_13: Bits = (Bits::new(
            ((s_1110_12) >> (s_1110_9)).value(),
            u16::try_from(s_1110_10).unwrap(),
        ));
        // D s_1110_14: cast reint s_1110_13 -> u8
        let s_1110_14: u8 = (s_1110_13.value() as u8);
        // C s_1110_15: const #12s : i
        let s_1110_15: i128 = 12;
        // C s_1110_16: const #4s : i
        let s_1110_16: i128 = 4;
        // D s_1110_17: read-var u#31858:u32
        let s_1110_17: u32 = fn_state.u_31858;
        // D s_1110_18: cast zx s_1110_17 -> bv
        let s_1110_18: Bits = Bits::new(s_1110_17 as u128, 32u16);
        // D s_1110_19: bit-extract s_1110_18 s_1110_15 s_1110_16
        let s_1110_19: Bits = (Bits::new(
            ((s_1110_18) >> (s_1110_15)).value(),
            u16::try_from(s_1110_16).unwrap(),
        ));
        // D s_1110_20: cast reint s_1110_19 -> u8
        let s_1110_20: u8 = (s_1110_19.value() as u8);
        // C s_1110_21: const #5s : i
        let s_1110_21: i128 = 5;
        // C s_1110_22: const #1s : i
        let s_1110_22: i128 = 1;
        // D s_1110_23: read-var u#31858:u32
        let s_1110_23: u32 = fn_state.u_31858;
        // D s_1110_24: cast zx s_1110_23 -> bv
        let s_1110_24: Bits = Bits::new(s_1110_23 as u128, 32u16);
        // D s_1110_25: bit-extract s_1110_24 s_1110_21 s_1110_22
        let s_1110_25: Bits = (Bits::new(
            ((s_1110_24) >> (s_1110_21)).value(),
            u16::try_from(s_1110_22).unwrap(),
        ));
        // D s_1110_26: cast reint s_1110_25 -> u8
        let s_1110_26: bool = ((s_1110_25.value()) != 0);
        // C s_1110_27: const #0s : i
        let s_1110_27: i128 = 0;
        // C s_1110_28: const #4s : i
        let s_1110_28: i128 = 4;
        // D s_1110_29: read-var u#31858:u32
        let s_1110_29: u32 = fn_state.u_31858;
        // D s_1110_30: cast zx s_1110_29 -> bv
        let s_1110_30: Bits = Bits::new(s_1110_29 as u128, 32u16);
        // D s_1110_31: bit-extract s_1110_30 s_1110_27 s_1110_28
        let s_1110_31: Bits = (Bits::new(
            ((s_1110_30) >> (s_1110_27)).value(),
            u16::try_from(s_1110_28).unwrap(),
        ));
        // D s_1110_32: cast reint s_1110_31 -> u8
        let s_1110_32: u8 = (s_1110_31.value() as u8);
        // D s_1110_33: call decode_aarch32_instrs_VSHRN_A1enc_A_txt(s_1110_8, s_1110_14, s_1110_20, s_1110_26, s_1110_32)
        let s_1110_33: () = decode_aarch32_instrs_VSHRN_A1enc_A_txt(
            state,
            tracer,
            s_1110_8,
            s_1110_14,
            s_1110_20,
            s_1110_26,
            s_1110_32,
        );
        // N s_1110_34: return
        return;
    }
    fn block_1111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1111_0: read-var merge#var.1:struct
        let s_1111_0: u32 = fn_state.merge_var._1;
        // D s_1111_1: write-var u#31865 <= s_1111_0
        fn_state.u_31865 = s_1111_0;
        // C s_1111_2: const #23s : i
        let s_1111_2: i128 = 23;
        // D s_1111_3: read-var u#31865:u32
        let s_1111_3: u32 = fn_state.u_31865;
        // D s_1111_4: cast zx s_1111_3 -> bv
        let s_1111_4: Bits = Bits::new(s_1111_3 as u128, 32u16);
        // C s_1111_5: const #1s : i64
        let s_1111_5: i64 = 1;
        // C s_1111_6: cast zx s_1111_5 -> i
        let s_1111_6: i128 = (i128::try_from(s_1111_5).unwrap());
        // C s_1111_7: const #8s : i
        let s_1111_7: i128 = 8;
        // C s_1111_8: add s_1111_7 s_1111_6
        let s_1111_8: i128 = (s_1111_7 + s_1111_6);
        // D s_1111_9: bit-extract s_1111_4 s_1111_2 s_1111_8
        let s_1111_9: Bits = (Bits::new(
            ((s_1111_4) >> (s_1111_2)).value(),
            u16::try_from(s_1111_8).unwrap(),
        ));
        // D s_1111_10: cast reint s_1111_9 -> u9
        let s_1111_10: u16 = (s_1111_9.value() as u16);
        // D s_1111_11: cast zx s_1111_10 -> bv
        let s_1111_11: Bits = Bits::new(s_1111_10 as u128, 9u16);
        // C s_1111_12: const #487u : u9
        let s_1111_12: u16 = 487;
        // C s_1111_13: cast zx s_1111_12 -> bv
        let s_1111_13: Bits = Bits::new(s_1111_12 as u128, 9u16);
        // D s_1111_14: cmp-eq s_1111_11 s_1111_13
        let s_1111_14: bool = ((s_1111_11) == (s_1111_13));
        // N s_1111_15: branch s_1111_14 b1986 b1112
        if s_1111_14 {
            return block_1986(state, tracer, fn_state);
        } else {
            return block_1112(state, tracer, fn_state);
        };
    }
    fn block_1112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1112_0: const #0u : u8
        let s_1112_0: bool = false;
        // D s_1112_1: write-var gs#402176 <= s_1112_0
        fn_state.gs_402176 = s_1112_0;
        // N s_1112_2: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_1113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1113_0: read-var gs#402176:u8
        let s_1113_0: bool = fn_state.gs_402176;
        // N s_1113_1: branch s_1113_0 b1985 b1114
        if s_1113_0 {
            return block_1985(state, tracer, fn_state);
        } else {
            return block_1114(state, tracer, fn_state);
        };
    }
    fn block_1114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1114_0: const #0u : u8
        let s_1114_0: bool = false;
        // D s_1114_1: write-var gs#402178 <= s_1114_0
        fn_state.gs_402178 = s_1114_0;
        // N s_1114_2: jump b1115
        return block_1115(state, tracer, fn_state);
    }
    fn block_1115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1115_0: read-var gs#402178:u8
        let s_1115_0: bool = fn_state.gs_402178;
        // D s_1115_1: not s_1115_0
        let s_1115_1: bool = !s_1115_0;
        // N s_1115_2: branch s_1115_1 b1117 b1116
        if s_1115_1 {
            return block_1117(state, tracer, fn_state);
        } else {
            return block_1116(state, tracer, fn_state);
        };
    }
    fn block_1116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1116_0: const #3684s : i
        let s_1116_0: i128 = 3684;
        // C s_1116_1: const #14696u : u32
        let s_1116_1: u32 = 14696;
        // N s_1116_2: write-reg s_1116_1 <= s_1116_0
        let s_1116_2: () = {
            state.write_register::<i128>(s_1116_1 as isize, s_1116_0);
            tracer.write_register(s_1116_1 as isize, s_1116_0);
        };
        // C s_1116_3: const #22s : i
        let s_1116_3: i128 = 22;
        // C s_1116_4: const #1s : i
        let s_1116_4: i128 = 1;
        // D s_1116_5: read-var u#31865:u32
        let s_1116_5: u32 = fn_state.u_31865;
        // D s_1116_6: cast zx s_1116_5 -> bv
        let s_1116_6: Bits = Bits::new(s_1116_5 as u128, 32u16);
        // D s_1116_7: bit-extract s_1116_6 s_1116_3 s_1116_4
        let s_1116_7: Bits = (Bits::new(
            ((s_1116_6) >> (s_1116_3)).value(),
            u16::try_from(s_1116_4).unwrap(),
        ));
        // D s_1116_8: cast reint s_1116_7 -> u8
        let s_1116_8: bool = ((s_1116_7.value()) != 0);
        // C s_1116_9: const #16s : i
        let s_1116_9: i128 = 16;
        // C s_1116_10: const #6s : i
        let s_1116_10: i128 = 6;
        // D s_1116_11: read-var u#31865:u32
        let s_1116_11: u32 = fn_state.u_31865;
        // D s_1116_12: cast zx s_1116_11 -> bv
        let s_1116_12: Bits = Bits::new(s_1116_11 as u128, 32u16);
        // D s_1116_13: bit-extract s_1116_12 s_1116_9 s_1116_10
        let s_1116_13: Bits = (Bits::new(
            ((s_1116_12) >> (s_1116_9)).value(),
            u16::try_from(s_1116_10).unwrap(),
        ));
        // D s_1116_14: cast reint s_1116_13 -> u8
        let s_1116_14: u8 = (s_1116_13.value() as u8);
        // C s_1116_15: const #12s : i
        let s_1116_15: i128 = 12;
        // C s_1116_16: const #4s : i
        let s_1116_16: i128 = 4;
        // D s_1116_17: read-var u#31865:u32
        let s_1116_17: u32 = fn_state.u_31865;
        // D s_1116_18: cast zx s_1116_17 -> bv
        let s_1116_18: Bits = Bits::new(s_1116_17 as u128, 32u16);
        // D s_1116_19: bit-extract s_1116_18 s_1116_15 s_1116_16
        let s_1116_19: Bits = (Bits::new(
            ((s_1116_18) >> (s_1116_15)).value(),
            u16::try_from(s_1116_16).unwrap(),
        ));
        // D s_1116_20: cast reint s_1116_19 -> u8
        let s_1116_20: u8 = (s_1116_19.value() as u8);
        // C s_1116_21: const #7s : i
        let s_1116_21: i128 = 7;
        // C s_1116_22: const #1s : i
        let s_1116_22: i128 = 1;
        // D s_1116_23: read-var u#31865:u32
        let s_1116_23: u32 = fn_state.u_31865;
        // D s_1116_24: cast zx s_1116_23 -> bv
        let s_1116_24: Bits = Bits::new(s_1116_23 as u128, 32u16);
        // D s_1116_25: bit-extract s_1116_24 s_1116_21 s_1116_22
        let s_1116_25: Bits = (Bits::new(
            ((s_1116_24) >> (s_1116_21)).value(),
            u16::try_from(s_1116_22).unwrap(),
        ));
        // D s_1116_26: cast reint s_1116_25 -> u8
        let s_1116_26: bool = ((s_1116_25.value()) != 0);
        // C s_1116_27: const #6s : i
        let s_1116_27: i128 = 6;
        // C s_1116_28: const #1s : i
        let s_1116_28: i128 = 1;
        // D s_1116_29: read-var u#31865:u32
        let s_1116_29: u32 = fn_state.u_31865;
        // D s_1116_30: cast zx s_1116_29 -> bv
        let s_1116_30: Bits = Bits::new(s_1116_29 as u128, 32u16);
        // D s_1116_31: bit-extract s_1116_30 s_1116_27 s_1116_28
        let s_1116_31: Bits = (Bits::new(
            ((s_1116_30) >> (s_1116_27)).value(),
            u16::try_from(s_1116_28).unwrap(),
        ));
        // D s_1116_32: cast reint s_1116_31 -> u8
        let s_1116_32: bool = ((s_1116_31.value()) != 0);
        // C s_1116_33: const #5s : i
        let s_1116_33: i128 = 5;
        // C s_1116_34: const #1s : i
        let s_1116_34: i128 = 1;
        // D s_1116_35: read-var u#31865:u32
        let s_1116_35: u32 = fn_state.u_31865;
        // D s_1116_36: cast zx s_1116_35 -> bv
        let s_1116_36: Bits = Bits::new(s_1116_35 as u128, 32u16);
        // D s_1116_37: bit-extract s_1116_36 s_1116_33 s_1116_34
        let s_1116_37: Bits = (Bits::new(
            ((s_1116_36) >> (s_1116_33)).value(),
            u16::try_from(s_1116_34).unwrap(),
        ));
        // D s_1116_38: cast reint s_1116_37 -> u8
        let s_1116_38: bool = ((s_1116_37.value()) != 0);
        // C s_1116_39: const #0s : i
        let s_1116_39: i128 = 0;
        // C s_1116_40: const #4s : i
        let s_1116_40: i128 = 4;
        // D s_1116_41: read-var u#31865:u32
        let s_1116_41: u32 = fn_state.u_31865;
        // D s_1116_42: cast zx s_1116_41 -> bv
        let s_1116_42: Bits = Bits::new(s_1116_41 as u128, 32u16);
        // D s_1116_43: bit-extract s_1116_42 s_1116_39 s_1116_40
        let s_1116_43: Bits = (Bits::new(
            ((s_1116_42) >> (s_1116_39)).value(),
            u16::try_from(s_1116_40).unwrap(),
        ));
        // D s_1116_44: cast reint s_1116_43 -> u8
        let s_1116_44: u8 = (s_1116_43.value() as u8);
        // D s_1116_45: call decode_aarch32_instrs_VSLI_A1enc_A_txt(s_1116_8, s_1116_14, s_1116_20, s_1116_26, s_1116_32, s_1116_38, s_1116_44)
        let s_1116_45: () = decode_aarch32_instrs_VSLI_A1enc_A_txt(
            state,
            tracer,
            s_1116_8,
            s_1116_14,
            s_1116_20,
            s_1116_26,
            s_1116_32,
            s_1116_38,
            s_1116_44,
        );
        // N s_1116_46: return
        return;
    }
    fn block_1117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1117_0: read-var merge#var.1:struct
        let s_1117_0: u32 = fn_state.merge_var._1;
        // D s_1117_1: write-var u#31874 <= s_1117_0
        fn_state.u_31874 = s_1117_0;
        // C s_1117_2: const #25s : i
        let s_1117_2: i128 = 25;
        // D s_1117_3: read-var u#31874:u32
        let s_1117_3: u32 = fn_state.u_31874;
        // D s_1117_4: cast zx s_1117_3 -> bv
        let s_1117_4: Bits = Bits::new(s_1117_3 as u128, 32u16);
        // C s_1117_5: const #1s : i64
        let s_1117_5: i64 = 1;
        // C s_1117_6: cast zx s_1117_5 -> i
        let s_1117_6: i128 = (i128::try_from(s_1117_5).unwrap());
        // C s_1117_7: const #6s : i
        let s_1117_7: i128 = 6;
        // C s_1117_8: add s_1117_7 s_1117_6
        let s_1117_8: i128 = (s_1117_7 + s_1117_6);
        // D s_1117_9: bit-extract s_1117_4 s_1117_2 s_1117_8
        let s_1117_9: Bits = (Bits::new(
            ((s_1117_4) >> (s_1117_2)).value(),
            u16::try_from(s_1117_8).unwrap(),
        ));
        // D s_1117_10: cast reint s_1117_9 -> u8
        let s_1117_10: u8 = (s_1117_9.value() as u8);
        // D s_1117_11: cast zx s_1117_10 -> bv
        let s_1117_11: Bits = Bits::new(s_1117_10 as u128, 7u16);
        // C s_1117_12: const #121u : u8
        let s_1117_12: u8 = 121;
        // C s_1117_13: cast zx s_1117_12 -> bv
        let s_1117_13: Bits = Bits::new(s_1117_12 as u128, 7u16);
        // D s_1117_14: cmp-eq s_1117_11 s_1117_13
        let s_1117_14: bool = ((s_1117_11) == (s_1117_13));
        // N s_1117_15: branch s_1117_14 b1978 b1118
        if s_1117_14 {
            return block_1978(state, tracer, fn_state);
        } else {
            return block_1118(state, tracer, fn_state);
        };
    }
    fn block_1118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1118_0: const #0u : u8
        let s_1118_0: bool = false;
        // D s_1118_1: write-var gs#402206 <= s_1118_0
        fn_state.gs_402206 = s_1118_0;
        // N s_1118_2: jump b1119
        return block_1119(state, tracer, fn_state);
    }
    fn block_1119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1119_0: read-var gs#402206:u8
        let s_1119_0: bool = fn_state.gs_402206;
        // N s_1119_1: branch s_1119_0 b1977 b1120
        if s_1119_0 {
            return block_1977(state, tracer, fn_state);
        } else {
            return block_1120(state, tracer, fn_state);
        };
    }
    fn block_1120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1120_0: const #0u : u8
        let s_1120_0: bool = false;
        // D s_1120_1: write-var gs#402208 <= s_1120_0
        fn_state.gs_402208 = s_1120_0;
        // N s_1120_2: jump b1121
        return block_1121(state, tracer, fn_state);
    }
    fn block_1121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1121_0: read-var gs#402208:u8
        let s_1121_0: bool = fn_state.gs_402208;
        // D s_1121_1: not s_1121_0
        let s_1121_1: bool = !s_1121_0;
        // N s_1121_2: branch s_1121_1 b1123 b1122
        if s_1121_1 {
            return block_1123(state, tracer, fn_state);
        } else {
            return block_1122(state, tracer, fn_state);
        };
    }
    fn block_1122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1122_0: const #3688s : i
        let s_1122_0: i128 = 3688;
        // C s_1122_1: const #14696u : u32
        let s_1122_1: u32 = 14696;
        // N s_1122_2: write-reg s_1122_1 <= s_1122_0
        let s_1122_2: () = {
            state.write_register::<i128>(s_1122_1 as isize, s_1122_0);
            tracer.write_register(s_1122_1 as isize, s_1122_0);
        };
        // C s_1122_3: const #24s : i
        let s_1122_3: i128 = 24;
        // C s_1122_4: const #1s : i
        let s_1122_4: i128 = 1;
        // D s_1122_5: read-var u#31874:u32
        let s_1122_5: u32 = fn_state.u_31874;
        // D s_1122_6: cast zx s_1122_5 -> bv
        let s_1122_6: Bits = Bits::new(s_1122_5 as u128, 32u16);
        // D s_1122_7: bit-extract s_1122_6 s_1122_3 s_1122_4
        let s_1122_7: Bits = (Bits::new(
            ((s_1122_6) >> (s_1122_3)).value(),
            u16::try_from(s_1122_4).unwrap(),
        ));
        // D s_1122_8: cast reint s_1122_7 -> u8
        let s_1122_8: bool = ((s_1122_7.value()) != 0);
        // C s_1122_9: const #22s : i
        let s_1122_9: i128 = 22;
        // C s_1122_10: const #1s : i
        let s_1122_10: i128 = 1;
        // D s_1122_11: read-var u#31874:u32
        let s_1122_11: u32 = fn_state.u_31874;
        // D s_1122_12: cast zx s_1122_11 -> bv
        let s_1122_12: Bits = Bits::new(s_1122_11 as u128, 32u16);
        // D s_1122_13: bit-extract s_1122_12 s_1122_9 s_1122_10
        let s_1122_13: Bits = (Bits::new(
            ((s_1122_12) >> (s_1122_9)).value(),
            u16::try_from(s_1122_10).unwrap(),
        ));
        // D s_1122_14: cast reint s_1122_13 -> u8
        let s_1122_14: bool = ((s_1122_13.value()) != 0);
        // C s_1122_15: const #16s : i
        let s_1122_15: i128 = 16;
        // C s_1122_16: const #6s : i
        let s_1122_16: i128 = 6;
        // D s_1122_17: read-var u#31874:u32
        let s_1122_17: u32 = fn_state.u_31874;
        // D s_1122_18: cast zx s_1122_17 -> bv
        let s_1122_18: Bits = Bits::new(s_1122_17 as u128, 32u16);
        // D s_1122_19: bit-extract s_1122_18 s_1122_15 s_1122_16
        let s_1122_19: Bits = (Bits::new(
            ((s_1122_18) >> (s_1122_15)).value(),
            u16::try_from(s_1122_16).unwrap(),
        ));
        // D s_1122_20: cast reint s_1122_19 -> u8
        let s_1122_20: u8 = (s_1122_19.value() as u8);
        // C s_1122_21: const #12s : i
        let s_1122_21: i128 = 12;
        // C s_1122_22: const #4s : i
        let s_1122_22: i128 = 4;
        // D s_1122_23: read-var u#31874:u32
        let s_1122_23: u32 = fn_state.u_31874;
        // D s_1122_24: cast zx s_1122_23 -> bv
        let s_1122_24: Bits = Bits::new(s_1122_23 as u128, 32u16);
        // D s_1122_25: bit-extract s_1122_24 s_1122_21 s_1122_22
        let s_1122_25: Bits = (Bits::new(
            ((s_1122_24) >> (s_1122_21)).value(),
            u16::try_from(s_1122_22).unwrap(),
        ));
        // D s_1122_26: cast reint s_1122_25 -> u8
        let s_1122_26: u8 = (s_1122_25.value() as u8);
        // C s_1122_27: const #7s : i
        let s_1122_27: i128 = 7;
        // C s_1122_28: const #1s : i
        let s_1122_28: i128 = 1;
        // D s_1122_29: read-var u#31874:u32
        let s_1122_29: u32 = fn_state.u_31874;
        // D s_1122_30: cast zx s_1122_29 -> bv
        let s_1122_30: Bits = Bits::new(s_1122_29 as u128, 32u16);
        // D s_1122_31: bit-extract s_1122_30 s_1122_27 s_1122_28
        let s_1122_31: Bits = (Bits::new(
            ((s_1122_30) >> (s_1122_27)).value(),
            u16::try_from(s_1122_28).unwrap(),
        ));
        // D s_1122_32: cast reint s_1122_31 -> u8
        let s_1122_32: bool = ((s_1122_31.value()) != 0);
        // C s_1122_33: const #6s : i
        let s_1122_33: i128 = 6;
        // C s_1122_34: const #1s : i
        let s_1122_34: i128 = 1;
        // D s_1122_35: read-var u#31874:u32
        let s_1122_35: u32 = fn_state.u_31874;
        // D s_1122_36: cast zx s_1122_35 -> bv
        let s_1122_36: Bits = Bits::new(s_1122_35 as u128, 32u16);
        // D s_1122_37: bit-extract s_1122_36 s_1122_33 s_1122_34
        let s_1122_37: Bits = (Bits::new(
            ((s_1122_36) >> (s_1122_33)).value(),
            u16::try_from(s_1122_34).unwrap(),
        ));
        // D s_1122_38: cast reint s_1122_37 -> u8
        let s_1122_38: bool = ((s_1122_37.value()) != 0);
        // C s_1122_39: const #5s : i
        let s_1122_39: i128 = 5;
        // C s_1122_40: const #1s : i
        let s_1122_40: i128 = 1;
        // D s_1122_41: read-var u#31874:u32
        let s_1122_41: u32 = fn_state.u_31874;
        // D s_1122_42: cast zx s_1122_41 -> bv
        let s_1122_42: Bits = Bits::new(s_1122_41 as u128, 32u16);
        // D s_1122_43: bit-extract s_1122_42 s_1122_39 s_1122_40
        let s_1122_43: Bits = (Bits::new(
            ((s_1122_42) >> (s_1122_39)).value(),
            u16::try_from(s_1122_40).unwrap(),
        ));
        // D s_1122_44: cast reint s_1122_43 -> u8
        let s_1122_44: bool = ((s_1122_43.value()) != 0);
        // C s_1122_45: const #0s : i
        let s_1122_45: i128 = 0;
        // C s_1122_46: const #4s : i
        let s_1122_46: i128 = 4;
        // D s_1122_47: read-var u#31874:u32
        let s_1122_47: u32 = fn_state.u_31874;
        // D s_1122_48: cast zx s_1122_47 -> bv
        let s_1122_48: Bits = Bits::new(s_1122_47 as u128, 32u16);
        // D s_1122_49: bit-extract s_1122_48 s_1122_45 s_1122_46
        let s_1122_49: Bits = (Bits::new(
            ((s_1122_48) >> (s_1122_45)).value(),
            u16::try_from(s_1122_46).unwrap(),
        ));
        // D s_1122_50: cast reint s_1122_49 -> u8
        let s_1122_50: u8 = (s_1122_49.value() as u8);
        // D s_1122_51: call decode_aarch32_instrs_VSRA_A1enc_A_txt(s_1122_8, s_1122_14, s_1122_20, s_1122_26, s_1122_32, s_1122_38, s_1122_44, s_1122_50)
        let s_1122_51: () = decode_aarch32_instrs_VSRA_A1enc_A_txt(
            state,
            tracer,
            s_1122_8,
            s_1122_14,
            s_1122_20,
            s_1122_26,
            s_1122_32,
            s_1122_38,
            s_1122_44,
            s_1122_50,
        );
        // N s_1122_52: return
        return;
    }
    fn block_1123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1123_0: read-var merge#var.1:struct
        let s_1123_0: u32 = fn_state.merge_var._1;
        // D s_1123_1: write-var u#31884 <= s_1123_0
        fn_state.u_31884 = s_1123_0;
        // C s_1123_2: const #23s : i
        let s_1123_2: i128 = 23;
        // D s_1123_3: read-var u#31884:u32
        let s_1123_3: u32 = fn_state.u_31884;
        // D s_1123_4: cast zx s_1123_3 -> bv
        let s_1123_4: Bits = Bits::new(s_1123_3 as u128, 32u16);
        // C s_1123_5: const #1s : i64
        let s_1123_5: i64 = 1;
        // C s_1123_6: cast zx s_1123_5 -> i
        let s_1123_6: i128 = (i128::try_from(s_1123_5).unwrap());
        // C s_1123_7: const #8s : i
        let s_1123_7: i128 = 8;
        // C s_1123_8: add s_1123_7 s_1123_6
        let s_1123_8: i128 = (s_1123_7 + s_1123_6);
        // D s_1123_9: bit-extract s_1123_4 s_1123_2 s_1123_8
        let s_1123_9: Bits = (Bits::new(
            ((s_1123_4) >> (s_1123_2)).value(),
            u16::try_from(s_1123_8).unwrap(),
        ));
        // D s_1123_10: cast reint s_1123_9 -> u9
        let s_1123_10: u16 = (s_1123_9.value() as u16);
        // D s_1123_11: cast zx s_1123_10 -> bv
        let s_1123_11: Bits = Bits::new(s_1123_10 as u128, 9u16);
        // C s_1123_12: const #487u : u9
        let s_1123_12: u16 = 487;
        // C s_1123_13: cast zx s_1123_12 -> bv
        let s_1123_13: Bits = Bits::new(s_1123_12 as u128, 9u16);
        // D s_1123_14: cmp-eq s_1123_11 s_1123_13
        let s_1123_14: bool = ((s_1123_11) == (s_1123_13));
        // N s_1123_15: branch s_1123_14 b1973 b1124
        if s_1123_14 {
            return block_1973(state, tracer, fn_state);
        } else {
            return block_1124(state, tracer, fn_state);
        };
    }
    fn block_1124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1124_0: const #0u : u8
        let s_1124_0: bool = false;
        // D s_1124_1: write-var gs#402235 <= s_1124_0
        fn_state.gs_402235 = s_1124_0;
        // N s_1124_2: jump b1125
        return block_1125(state, tracer, fn_state);
    }
    fn block_1125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1125_0: read-var gs#402235:u8
        let s_1125_0: bool = fn_state.gs_402235;
        // N s_1125_1: branch s_1125_0 b1972 b1126
        if s_1125_0 {
            return block_1972(state, tracer, fn_state);
        } else {
            return block_1126(state, tracer, fn_state);
        };
    }
    fn block_1126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1126_0: const #0u : u8
        let s_1126_0: bool = false;
        // D s_1126_1: write-var gs#402237 <= s_1126_0
        fn_state.gs_402237 = s_1126_0;
        // N s_1126_2: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_1127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1127_0: read-var gs#402237:u8
        let s_1127_0: bool = fn_state.gs_402237;
        // D s_1127_1: not s_1127_0
        let s_1127_1: bool = !s_1127_0;
        // N s_1127_2: branch s_1127_1 b1129 b1128
        if s_1127_1 {
            return block_1129(state, tracer, fn_state);
        } else {
            return block_1128(state, tracer, fn_state);
        };
    }
    fn block_1128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1128_0: const #3690s : i
        let s_1128_0: i128 = 3690;
        // C s_1128_1: const #14696u : u32
        let s_1128_1: u32 = 14696;
        // N s_1128_2: write-reg s_1128_1 <= s_1128_0
        let s_1128_2: () = {
            state.write_register::<i128>(s_1128_1 as isize, s_1128_0);
            tracer.write_register(s_1128_1 as isize, s_1128_0);
        };
        // C s_1128_3: const #22s : i
        let s_1128_3: i128 = 22;
        // C s_1128_4: const #1s : i
        let s_1128_4: i128 = 1;
        // D s_1128_5: read-var u#31884:u32
        let s_1128_5: u32 = fn_state.u_31884;
        // D s_1128_6: cast zx s_1128_5 -> bv
        let s_1128_6: Bits = Bits::new(s_1128_5 as u128, 32u16);
        // D s_1128_7: bit-extract s_1128_6 s_1128_3 s_1128_4
        let s_1128_7: Bits = (Bits::new(
            ((s_1128_6) >> (s_1128_3)).value(),
            u16::try_from(s_1128_4).unwrap(),
        ));
        // D s_1128_8: cast reint s_1128_7 -> u8
        let s_1128_8: bool = ((s_1128_7.value()) != 0);
        // C s_1128_9: const #16s : i
        let s_1128_9: i128 = 16;
        // C s_1128_10: const #6s : i
        let s_1128_10: i128 = 6;
        // D s_1128_11: read-var u#31884:u32
        let s_1128_11: u32 = fn_state.u_31884;
        // D s_1128_12: cast zx s_1128_11 -> bv
        let s_1128_12: Bits = Bits::new(s_1128_11 as u128, 32u16);
        // D s_1128_13: bit-extract s_1128_12 s_1128_9 s_1128_10
        let s_1128_13: Bits = (Bits::new(
            ((s_1128_12) >> (s_1128_9)).value(),
            u16::try_from(s_1128_10).unwrap(),
        ));
        // D s_1128_14: cast reint s_1128_13 -> u8
        let s_1128_14: u8 = (s_1128_13.value() as u8);
        // C s_1128_15: const #12s : i
        let s_1128_15: i128 = 12;
        // C s_1128_16: const #4s : i
        let s_1128_16: i128 = 4;
        // D s_1128_17: read-var u#31884:u32
        let s_1128_17: u32 = fn_state.u_31884;
        // D s_1128_18: cast zx s_1128_17 -> bv
        let s_1128_18: Bits = Bits::new(s_1128_17 as u128, 32u16);
        // D s_1128_19: bit-extract s_1128_18 s_1128_15 s_1128_16
        let s_1128_19: Bits = (Bits::new(
            ((s_1128_18) >> (s_1128_15)).value(),
            u16::try_from(s_1128_16).unwrap(),
        ));
        // D s_1128_20: cast reint s_1128_19 -> u8
        let s_1128_20: u8 = (s_1128_19.value() as u8);
        // C s_1128_21: const #7s : i
        let s_1128_21: i128 = 7;
        // C s_1128_22: const #1s : i
        let s_1128_22: i128 = 1;
        // D s_1128_23: read-var u#31884:u32
        let s_1128_23: u32 = fn_state.u_31884;
        // D s_1128_24: cast zx s_1128_23 -> bv
        let s_1128_24: Bits = Bits::new(s_1128_23 as u128, 32u16);
        // D s_1128_25: bit-extract s_1128_24 s_1128_21 s_1128_22
        let s_1128_25: Bits = (Bits::new(
            ((s_1128_24) >> (s_1128_21)).value(),
            u16::try_from(s_1128_22).unwrap(),
        ));
        // D s_1128_26: cast reint s_1128_25 -> u8
        let s_1128_26: bool = ((s_1128_25.value()) != 0);
        // C s_1128_27: const #6s : i
        let s_1128_27: i128 = 6;
        // C s_1128_28: const #1s : i
        let s_1128_28: i128 = 1;
        // D s_1128_29: read-var u#31884:u32
        let s_1128_29: u32 = fn_state.u_31884;
        // D s_1128_30: cast zx s_1128_29 -> bv
        let s_1128_30: Bits = Bits::new(s_1128_29 as u128, 32u16);
        // D s_1128_31: bit-extract s_1128_30 s_1128_27 s_1128_28
        let s_1128_31: Bits = (Bits::new(
            ((s_1128_30) >> (s_1128_27)).value(),
            u16::try_from(s_1128_28).unwrap(),
        ));
        // D s_1128_32: cast reint s_1128_31 -> u8
        let s_1128_32: bool = ((s_1128_31.value()) != 0);
        // C s_1128_33: const #5s : i
        let s_1128_33: i128 = 5;
        // C s_1128_34: const #1s : i
        let s_1128_34: i128 = 1;
        // D s_1128_35: read-var u#31884:u32
        let s_1128_35: u32 = fn_state.u_31884;
        // D s_1128_36: cast zx s_1128_35 -> bv
        let s_1128_36: Bits = Bits::new(s_1128_35 as u128, 32u16);
        // D s_1128_37: bit-extract s_1128_36 s_1128_33 s_1128_34
        let s_1128_37: Bits = (Bits::new(
            ((s_1128_36) >> (s_1128_33)).value(),
            u16::try_from(s_1128_34).unwrap(),
        ));
        // D s_1128_38: cast reint s_1128_37 -> u8
        let s_1128_38: bool = ((s_1128_37.value()) != 0);
        // C s_1128_39: const #0s : i
        let s_1128_39: i128 = 0;
        // C s_1128_40: const #4s : i
        let s_1128_40: i128 = 4;
        // D s_1128_41: read-var u#31884:u32
        let s_1128_41: u32 = fn_state.u_31884;
        // D s_1128_42: cast zx s_1128_41 -> bv
        let s_1128_42: Bits = Bits::new(s_1128_41 as u128, 32u16);
        // D s_1128_43: bit-extract s_1128_42 s_1128_39 s_1128_40
        let s_1128_43: Bits = (Bits::new(
            ((s_1128_42) >> (s_1128_39)).value(),
            u16::try_from(s_1128_40).unwrap(),
        ));
        // D s_1128_44: cast reint s_1128_43 -> u8
        let s_1128_44: u8 = (s_1128_43.value() as u8);
        // D s_1128_45: call decode_aarch32_instrs_VSRI_A1enc_A_txt(s_1128_8, s_1128_14, s_1128_20, s_1128_26, s_1128_32, s_1128_38, s_1128_44)
        let s_1128_45: () = decode_aarch32_instrs_VSRI_A1enc_A_txt(
            state,
            tracer,
            s_1128_8,
            s_1128_14,
            s_1128_20,
            s_1128_26,
            s_1128_32,
            s_1128_38,
            s_1128_44,
        );
        // N s_1128_46: return
        return;
    }
    fn block_1129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1129_0: read-var merge#var.1:struct
        let s_1129_0: u32 = fn_state.merge_var._1;
        // D s_1129_1: write-var u#31893 <= s_1129_0
        fn_state.u_31893 = s_1129_0;
        // C s_1129_2: const #23s : i
        let s_1129_2: i128 = 23;
        // D s_1129_3: read-var u#31893:u32
        let s_1129_3: u32 = fn_state.u_31893;
        // D s_1129_4: cast zx s_1129_3 -> bv
        let s_1129_4: Bits = Bits::new(s_1129_3 as u128, 32u16);
        // C s_1129_5: const #1s : i64
        let s_1129_5: i64 = 1;
        // C s_1129_6: cast zx s_1129_5 -> i
        let s_1129_6: i128 = (i128::try_from(s_1129_5).unwrap());
        // C s_1129_7: const #8s : i
        let s_1129_7: i128 = 8;
        // C s_1129_8: add s_1129_7 s_1129_6
        let s_1129_8: i128 = (s_1129_7 + s_1129_6);
        // D s_1129_9: bit-extract s_1129_4 s_1129_2 s_1129_8
        let s_1129_9: Bits = (Bits::new(
            ((s_1129_4) >> (s_1129_2)).value(),
            u16::try_from(s_1129_8).unwrap(),
        ));
        // D s_1129_10: cast reint s_1129_9 -> u9
        let s_1129_10: u16 = (s_1129_9.value() as u16);
        // D s_1129_11: cast zx s_1129_10 -> bv
        let s_1129_11: Bits = Bits::new(s_1129_10 as u128, 9u16);
        // C s_1129_12: const #489u : u9
        let s_1129_12: u16 = 489;
        // C s_1129_13: cast zx s_1129_12 -> bv
        let s_1129_13: Bits = Bits::new(s_1129_12 as u128, 9u16);
        // D s_1129_14: cmp-eq s_1129_11 s_1129_13
        let s_1129_14: bool = ((s_1129_11) == (s_1129_13));
        // N s_1129_15: branch s_1129_14 b1968 b1130
        if s_1129_14 {
            return block_1968(state, tracer, fn_state);
        } else {
            return block_1130(state, tracer, fn_state);
        };
    }
    fn block_1130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1130_0: const #0u : u8
        let s_1130_0: bool = false;
        // D s_1130_1: write-var gs#402262 <= s_1130_0
        fn_state.gs_402262 = s_1130_0;
        // N s_1130_2: jump b1131
        return block_1131(state, tracer, fn_state);
    }
    fn block_1131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1131_0: read-var gs#402262:u8
        let s_1131_0: bool = fn_state.gs_402262;
        // N s_1131_1: branch s_1131_0 b1967 b1132
        if s_1131_0 {
            return block_1967(state, tracer, fn_state);
        } else {
            return block_1132(state, tracer, fn_state);
        };
    }
    fn block_1132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1132_0: const #0u : u8
        let s_1132_0: bool = false;
        // D s_1132_1: write-var gs#402264 <= s_1132_0
        fn_state.gs_402264 = s_1132_0;
        // N s_1132_2: jump b1133
        return block_1133(state, tracer, fn_state);
    }
    fn block_1133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1133_0: read-var gs#402264:u8
        let s_1133_0: bool = fn_state.gs_402264;
        // D s_1133_1: not s_1133_0
        let s_1133_1: bool = !s_1133_0;
        // N s_1133_2: branch s_1133_1 b1135 b1134
        if s_1133_1 {
            return block_1135(state, tracer, fn_state);
        } else {
            return block_1134(state, tracer, fn_state);
        };
    }
    fn block_1134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1134_0: const #3692s : i
        let s_1134_0: i128 = 3692;
        // C s_1134_1: const #14696u : u32
        let s_1134_1: u32 = 14696;
        // N s_1134_2: write-reg s_1134_1 <= s_1134_0
        let s_1134_2: () = {
            state.write_register::<i128>(s_1134_1 as isize, s_1134_0);
            tracer.write_register(s_1134_1 as isize, s_1134_0);
        };
        // C s_1134_3: const #22s : i
        let s_1134_3: i128 = 22;
        // C s_1134_4: const #1s : i
        let s_1134_4: i128 = 1;
        // D s_1134_5: read-var u#31893:u32
        let s_1134_5: u32 = fn_state.u_31893;
        // D s_1134_6: cast zx s_1134_5 -> bv
        let s_1134_6: Bits = Bits::new(s_1134_5 as u128, 32u16);
        // D s_1134_7: bit-extract s_1134_6 s_1134_3 s_1134_4
        let s_1134_7: Bits = (Bits::new(
            ((s_1134_6) >> (s_1134_3)).value(),
            u16::try_from(s_1134_4).unwrap(),
        ));
        // D s_1134_8: cast reint s_1134_7 -> u8
        let s_1134_8: bool = ((s_1134_7.value()) != 0);
        // C s_1134_9: const #16s : i
        let s_1134_9: i128 = 16;
        // C s_1134_10: const #4s : i
        let s_1134_10: i128 = 4;
        // D s_1134_11: read-var u#31893:u32
        let s_1134_11: u32 = fn_state.u_31893;
        // D s_1134_12: cast zx s_1134_11 -> bv
        let s_1134_12: Bits = Bits::new(s_1134_11 as u128, 32u16);
        // D s_1134_13: bit-extract s_1134_12 s_1134_9 s_1134_10
        let s_1134_13: Bits = (Bits::new(
            ((s_1134_12) >> (s_1134_9)).value(),
            u16::try_from(s_1134_10).unwrap(),
        ));
        // D s_1134_14: cast reint s_1134_13 -> u8
        let s_1134_14: u8 = (s_1134_13.value() as u8);
        // C s_1134_15: const #12s : i
        let s_1134_15: i128 = 12;
        // C s_1134_16: const #4s : i
        let s_1134_16: i128 = 4;
        // D s_1134_17: read-var u#31893:u32
        let s_1134_17: u32 = fn_state.u_31893;
        // D s_1134_18: cast zx s_1134_17 -> bv
        let s_1134_18: Bits = Bits::new(s_1134_17 as u128, 32u16);
        // D s_1134_19: bit-extract s_1134_18 s_1134_15 s_1134_16
        let s_1134_19: Bits = (Bits::new(
            ((s_1134_18) >> (s_1134_15)).value(),
            u16::try_from(s_1134_16).unwrap(),
        ));
        // D s_1134_20: cast reint s_1134_19 -> u8
        let s_1134_20: u8 = (s_1134_19.value() as u8);
        // C s_1134_21: const #10s : i
        let s_1134_21: i128 = 10;
        // C s_1134_22: const #2s : i
        let s_1134_22: i128 = 2;
        // D s_1134_23: read-var u#31893:u32
        let s_1134_23: u32 = fn_state.u_31893;
        // D s_1134_24: cast zx s_1134_23 -> bv
        let s_1134_24: Bits = Bits::new(s_1134_23 as u128, 32u16);
        // D s_1134_25: bit-extract s_1134_24 s_1134_21 s_1134_22
        let s_1134_25: Bits = (Bits::new(
            ((s_1134_24) >> (s_1134_21)).value(),
            u16::try_from(s_1134_22).unwrap(),
        ));
        // D s_1134_26: cast reint s_1134_25 -> u8
        let s_1134_26: u8 = (s_1134_25.value() as u8);
        // C s_1134_27: const #4s : i
        let s_1134_27: i128 = 4;
        // C s_1134_28: const #4s : i
        let s_1134_28: i128 = 4;
        // D s_1134_29: read-var u#31893:u32
        let s_1134_29: u32 = fn_state.u_31893;
        // D s_1134_30: cast zx s_1134_29 -> bv
        let s_1134_30: Bits = Bits::new(s_1134_29 as u128, 32u16);
        // D s_1134_31: bit-extract s_1134_30 s_1134_27 s_1134_28
        let s_1134_31: Bits = (Bits::new(
            ((s_1134_30) >> (s_1134_27)).value(),
            u16::try_from(s_1134_28).unwrap(),
        ));
        // D s_1134_32: cast reint s_1134_31 -> u8
        let s_1134_32: u8 = (s_1134_31.value() as u8);
        // C s_1134_33: const #0s : i
        let s_1134_33: i128 = 0;
        // C s_1134_34: const #4s : i
        let s_1134_34: i128 = 4;
        // D s_1134_35: read-var u#31893:u32
        let s_1134_35: u32 = fn_state.u_31893;
        // D s_1134_36: cast zx s_1134_35 -> bv
        let s_1134_36: Bits = Bits::new(s_1134_35 as u128, 32u16);
        // D s_1134_37: bit-extract s_1134_36 s_1134_33 s_1134_34
        let s_1134_37: Bits = (Bits::new(
            ((s_1134_36) >> (s_1134_33)).value(),
            u16::try_from(s_1134_34).unwrap(),
        ));
        // D s_1134_38: cast reint s_1134_37 -> u8
        let s_1134_38: u8 = (s_1134_37.value() as u8);
        // D s_1134_39: call decode_aarch32_instrs_VST1_1_A1enc_A_txt(s_1134_8, s_1134_14, s_1134_20, s_1134_26, s_1134_32, s_1134_38)
        let s_1134_39: () = decode_aarch32_instrs_VST1_1_A1enc_A_txt(
            state,
            tracer,
            s_1134_8,
            s_1134_14,
            s_1134_20,
            s_1134_26,
            s_1134_32,
            s_1134_38,
        );
        // N s_1134_40: return
        return;
    }
    fn block_1135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1135_0: read-var merge#var.1:struct
        let s_1135_0: u32 = fn_state.merge_var._1;
        // D s_1135_1: write-var u#31901 <= s_1135_0
        fn_state.u_31901 = s_1135_0;
        // C s_1135_2: const #23s : i
        let s_1135_2: i128 = 23;
        // D s_1135_3: read-var u#31901:u32
        let s_1135_3: u32 = fn_state.u_31901;
        // D s_1135_4: cast zx s_1135_3 -> bv
        let s_1135_4: Bits = Bits::new(s_1135_3 as u128, 32u16);
        // C s_1135_5: const #1s : i64
        let s_1135_5: i64 = 1;
        // C s_1135_6: cast zx s_1135_5 -> i
        let s_1135_6: i128 = (i128::try_from(s_1135_5).unwrap());
        // C s_1135_7: const #8s : i
        let s_1135_7: i128 = 8;
        // C s_1135_8: add s_1135_7 s_1135_6
        let s_1135_8: i128 = (s_1135_7 + s_1135_6);
        // D s_1135_9: bit-extract s_1135_4 s_1135_2 s_1135_8
        let s_1135_9: Bits = (Bits::new(
            ((s_1135_4) >> (s_1135_2)).value(),
            u16::try_from(s_1135_8).unwrap(),
        ));
        // D s_1135_10: cast reint s_1135_9 -> u9
        let s_1135_10: u16 = (s_1135_9.value() as u16);
        // D s_1135_11: cast zx s_1135_10 -> bv
        let s_1135_11: Bits = Bits::new(s_1135_10 as u128, 9u16);
        // C s_1135_12: const #489u : u9
        let s_1135_12: u16 = 489;
        // C s_1135_13: cast zx s_1135_12 -> bv
        let s_1135_13: Bits = Bits::new(s_1135_12 as u128, 9u16);
        // D s_1135_14: cmp-eq s_1135_11 s_1135_13
        let s_1135_14: bool = ((s_1135_11) == (s_1135_13));
        // N s_1135_15: branch s_1135_14 b1963 b1136
        if s_1135_14 {
            return block_1963(state, tracer, fn_state);
        } else {
            return block_1136(state, tracer, fn_state);
        };
    }
    fn block_1136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1136_0: const #0u : u8
        let s_1136_0: bool = false;
        // D s_1136_1: write-var gs#402287 <= s_1136_0
        fn_state.gs_402287 = s_1136_0;
        // N s_1136_2: jump b1137
        return block_1137(state, tracer, fn_state);
    }
    fn block_1137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1137_0: read-var gs#402287:u8
        let s_1137_0: bool = fn_state.gs_402287;
        // N s_1137_1: branch s_1137_0 b1962 b1138
        if s_1137_0 {
            return block_1962(state, tracer, fn_state);
        } else {
            return block_1138(state, tracer, fn_state);
        };
    }
    fn block_1138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1138_0: const #0u : u8
        let s_1138_0: bool = false;
        // D s_1138_1: write-var gs#402289 <= s_1138_0
        fn_state.gs_402289 = s_1138_0;
        // N s_1138_2: jump b1139
        return block_1139(state, tracer, fn_state);
    }
    fn block_1139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1139_0: read-var gs#402289:u8
        let s_1139_0: bool = fn_state.gs_402289;
        // D s_1139_1: not s_1139_0
        let s_1139_1: bool = !s_1139_0;
        // N s_1139_2: branch s_1139_1 b1141 b1140
        if s_1139_1 {
            return block_1141(state, tracer, fn_state);
        } else {
            return block_1140(state, tracer, fn_state);
        };
    }
    fn block_1140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1140_0: const #3693s : i
        let s_1140_0: i128 = 3693;
        // C s_1140_1: const #14696u : u32
        let s_1140_1: u32 = 14696;
        // N s_1140_2: write-reg s_1140_1 <= s_1140_0
        let s_1140_2: () = {
            state.write_register::<i128>(s_1140_1 as isize, s_1140_0);
            tracer.write_register(s_1140_1 as isize, s_1140_0);
        };
        // C s_1140_3: const #22s : i
        let s_1140_3: i128 = 22;
        // C s_1140_4: const #1s : i
        let s_1140_4: i128 = 1;
        // D s_1140_5: read-var u#31901:u32
        let s_1140_5: u32 = fn_state.u_31901;
        // D s_1140_6: cast zx s_1140_5 -> bv
        let s_1140_6: Bits = Bits::new(s_1140_5 as u128, 32u16);
        // D s_1140_7: bit-extract s_1140_6 s_1140_3 s_1140_4
        let s_1140_7: Bits = (Bits::new(
            ((s_1140_6) >> (s_1140_3)).value(),
            u16::try_from(s_1140_4).unwrap(),
        ));
        // D s_1140_8: cast reint s_1140_7 -> u8
        let s_1140_8: bool = ((s_1140_7.value()) != 0);
        // C s_1140_9: const #16s : i
        let s_1140_9: i128 = 16;
        // C s_1140_10: const #4s : i
        let s_1140_10: i128 = 4;
        // D s_1140_11: read-var u#31901:u32
        let s_1140_11: u32 = fn_state.u_31901;
        // D s_1140_12: cast zx s_1140_11 -> bv
        let s_1140_12: Bits = Bits::new(s_1140_11 as u128, 32u16);
        // D s_1140_13: bit-extract s_1140_12 s_1140_9 s_1140_10
        let s_1140_13: Bits = (Bits::new(
            ((s_1140_12) >> (s_1140_9)).value(),
            u16::try_from(s_1140_10).unwrap(),
        ));
        // D s_1140_14: cast reint s_1140_13 -> u8
        let s_1140_14: u8 = (s_1140_13.value() as u8);
        // C s_1140_15: const #12s : i
        let s_1140_15: i128 = 12;
        // C s_1140_16: const #4s : i
        let s_1140_16: i128 = 4;
        // D s_1140_17: read-var u#31901:u32
        let s_1140_17: u32 = fn_state.u_31901;
        // D s_1140_18: cast zx s_1140_17 -> bv
        let s_1140_18: Bits = Bits::new(s_1140_17 as u128, 32u16);
        // D s_1140_19: bit-extract s_1140_18 s_1140_15 s_1140_16
        let s_1140_19: Bits = (Bits::new(
            ((s_1140_18) >> (s_1140_15)).value(),
            u16::try_from(s_1140_16).unwrap(),
        ));
        // D s_1140_20: cast reint s_1140_19 -> u8
        let s_1140_20: u8 = (s_1140_19.value() as u8);
        // C s_1140_21: const #10s : i
        let s_1140_21: i128 = 10;
        // C s_1140_22: const #2s : i
        let s_1140_22: i128 = 2;
        // D s_1140_23: read-var u#31901:u32
        let s_1140_23: u32 = fn_state.u_31901;
        // D s_1140_24: cast zx s_1140_23 -> bv
        let s_1140_24: Bits = Bits::new(s_1140_23 as u128, 32u16);
        // D s_1140_25: bit-extract s_1140_24 s_1140_21 s_1140_22
        let s_1140_25: Bits = (Bits::new(
            ((s_1140_24) >> (s_1140_21)).value(),
            u16::try_from(s_1140_22).unwrap(),
        ));
        // D s_1140_26: cast reint s_1140_25 -> u8
        let s_1140_26: u8 = (s_1140_25.value() as u8);
        // C s_1140_27: const #4s : i
        let s_1140_27: i128 = 4;
        // C s_1140_28: const #4s : i
        let s_1140_28: i128 = 4;
        // D s_1140_29: read-var u#31901:u32
        let s_1140_29: u32 = fn_state.u_31901;
        // D s_1140_30: cast zx s_1140_29 -> bv
        let s_1140_30: Bits = Bits::new(s_1140_29 as u128, 32u16);
        // D s_1140_31: bit-extract s_1140_30 s_1140_27 s_1140_28
        let s_1140_31: Bits = (Bits::new(
            ((s_1140_30) >> (s_1140_27)).value(),
            u16::try_from(s_1140_28).unwrap(),
        ));
        // D s_1140_32: cast reint s_1140_31 -> u8
        let s_1140_32: u8 = (s_1140_31.value() as u8);
        // C s_1140_33: const #0s : i
        let s_1140_33: i128 = 0;
        // C s_1140_34: const #4s : i
        let s_1140_34: i128 = 4;
        // D s_1140_35: read-var u#31901:u32
        let s_1140_35: u32 = fn_state.u_31901;
        // D s_1140_36: cast zx s_1140_35 -> bv
        let s_1140_36: Bits = Bits::new(s_1140_35 as u128, 32u16);
        // D s_1140_37: bit-extract s_1140_36 s_1140_33 s_1140_34
        let s_1140_37: Bits = (Bits::new(
            ((s_1140_36) >> (s_1140_33)).value(),
            u16::try_from(s_1140_34).unwrap(),
        ));
        // D s_1140_38: cast reint s_1140_37 -> u8
        let s_1140_38: u8 = (s_1140_37.value() as u8);
        // D s_1140_39: call decode_aarch32_instrs_VST1_1_A2enc_A_txt(s_1140_8, s_1140_14, s_1140_20, s_1140_26, s_1140_32, s_1140_38)
        let s_1140_39: () = decode_aarch32_instrs_VST1_1_A2enc_A_txt(
            state,
            tracer,
            s_1140_8,
            s_1140_14,
            s_1140_20,
            s_1140_26,
            s_1140_32,
            s_1140_38,
        );
        // N s_1140_40: return
        return;
    }
    fn block_1141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1141_0: read-var merge#var.1:struct
        let s_1141_0: u32 = fn_state.merge_var._1;
        // D s_1141_1: write-var u#31909 <= s_1141_0
        fn_state.u_31909 = s_1141_0;
        // C s_1141_2: const #23s : i
        let s_1141_2: i128 = 23;
        // D s_1141_3: read-var u#31909:u32
        let s_1141_3: u32 = fn_state.u_31909;
        // D s_1141_4: cast zx s_1141_3 -> bv
        let s_1141_4: Bits = Bits::new(s_1141_3 as u128, 32u16);
        // C s_1141_5: const #1s : i64
        let s_1141_5: i64 = 1;
        // C s_1141_6: cast zx s_1141_5 -> i
        let s_1141_6: i128 = (i128::try_from(s_1141_5).unwrap());
        // C s_1141_7: const #8s : i
        let s_1141_7: i128 = 8;
        // C s_1141_8: add s_1141_7 s_1141_6
        let s_1141_8: i128 = (s_1141_7 + s_1141_6);
        // D s_1141_9: bit-extract s_1141_4 s_1141_2 s_1141_8
        let s_1141_9: Bits = (Bits::new(
            ((s_1141_4) >> (s_1141_2)).value(),
            u16::try_from(s_1141_8).unwrap(),
        ));
        // D s_1141_10: cast reint s_1141_9 -> u9
        let s_1141_10: u16 = (s_1141_9.value() as u16);
        // D s_1141_11: cast zx s_1141_10 -> bv
        let s_1141_11: Bits = Bits::new(s_1141_10 as u128, 9u16);
        // C s_1141_12: const #489u : u9
        let s_1141_12: u16 = 489;
        // C s_1141_13: cast zx s_1141_12 -> bv
        let s_1141_13: Bits = Bits::new(s_1141_12 as u128, 9u16);
        // D s_1141_14: cmp-eq s_1141_11 s_1141_13
        let s_1141_14: bool = ((s_1141_11) == (s_1141_13));
        // N s_1141_15: branch s_1141_14 b1958 b1142
        if s_1141_14 {
            return block_1958(state, tracer, fn_state);
        } else {
            return block_1142(state, tracer, fn_state);
        };
    }
    fn block_1142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1142_0: const #0u : u8
        let s_1142_0: bool = false;
        // D s_1142_1: write-var gs#402312 <= s_1142_0
        fn_state.gs_402312 = s_1142_0;
        // N s_1142_2: jump b1143
        return block_1143(state, tracer, fn_state);
    }
    fn block_1143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1143_0: read-var gs#402312:u8
        let s_1143_0: bool = fn_state.gs_402312;
        // N s_1143_1: branch s_1143_0 b1957 b1144
        if s_1143_0 {
            return block_1957(state, tracer, fn_state);
        } else {
            return block_1144(state, tracer, fn_state);
        };
    }
    fn block_1144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1144_0: const #0u : u8
        let s_1144_0: bool = false;
        // D s_1144_1: write-var gs#402314 <= s_1144_0
        fn_state.gs_402314 = s_1144_0;
        // N s_1144_2: jump b1145
        return block_1145(state, tracer, fn_state);
    }
    fn block_1145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1145_0: read-var gs#402314:u8
        let s_1145_0: bool = fn_state.gs_402314;
        // D s_1145_1: not s_1145_0
        let s_1145_1: bool = !s_1145_0;
        // N s_1145_2: branch s_1145_1 b1147 b1146
        if s_1145_1 {
            return block_1147(state, tracer, fn_state);
        } else {
            return block_1146(state, tracer, fn_state);
        };
    }
    fn block_1146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1146_0: const #3694s : i
        let s_1146_0: i128 = 3694;
        // C s_1146_1: const #14696u : u32
        let s_1146_1: u32 = 14696;
        // N s_1146_2: write-reg s_1146_1 <= s_1146_0
        let s_1146_2: () = {
            state.write_register::<i128>(s_1146_1 as isize, s_1146_0);
            tracer.write_register(s_1146_1 as isize, s_1146_0);
        };
        // C s_1146_3: const #22s : i
        let s_1146_3: i128 = 22;
        // C s_1146_4: const #1s : i
        let s_1146_4: i128 = 1;
        // D s_1146_5: read-var u#31909:u32
        let s_1146_5: u32 = fn_state.u_31909;
        // D s_1146_6: cast zx s_1146_5 -> bv
        let s_1146_6: Bits = Bits::new(s_1146_5 as u128, 32u16);
        // D s_1146_7: bit-extract s_1146_6 s_1146_3 s_1146_4
        let s_1146_7: Bits = (Bits::new(
            ((s_1146_6) >> (s_1146_3)).value(),
            u16::try_from(s_1146_4).unwrap(),
        ));
        // D s_1146_8: cast reint s_1146_7 -> u8
        let s_1146_8: bool = ((s_1146_7.value()) != 0);
        // C s_1146_9: const #16s : i
        let s_1146_9: i128 = 16;
        // C s_1146_10: const #4s : i
        let s_1146_10: i128 = 4;
        // D s_1146_11: read-var u#31909:u32
        let s_1146_11: u32 = fn_state.u_31909;
        // D s_1146_12: cast zx s_1146_11 -> bv
        let s_1146_12: Bits = Bits::new(s_1146_11 as u128, 32u16);
        // D s_1146_13: bit-extract s_1146_12 s_1146_9 s_1146_10
        let s_1146_13: Bits = (Bits::new(
            ((s_1146_12) >> (s_1146_9)).value(),
            u16::try_from(s_1146_10).unwrap(),
        ));
        // D s_1146_14: cast reint s_1146_13 -> u8
        let s_1146_14: u8 = (s_1146_13.value() as u8);
        // C s_1146_15: const #12s : i
        let s_1146_15: i128 = 12;
        // C s_1146_16: const #4s : i
        let s_1146_16: i128 = 4;
        // D s_1146_17: read-var u#31909:u32
        let s_1146_17: u32 = fn_state.u_31909;
        // D s_1146_18: cast zx s_1146_17 -> bv
        let s_1146_18: Bits = Bits::new(s_1146_17 as u128, 32u16);
        // D s_1146_19: bit-extract s_1146_18 s_1146_15 s_1146_16
        let s_1146_19: Bits = (Bits::new(
            ((s_1146_18) >> (s_1146_15)).value(),
            u16::try_from(s_1146_16).unwrap(),
        ));
        // D s_1146_20: cast reint s_1146_19 -> u8
        let s_1146_20: u8 = (s_1146_19.value() as u8);
        // C s_1146_21: const #10s : i
        let s_1146_21: i128 = 10;
        // C s_1146_22: const #2s : i
        let s_1146_22: i128 = 2;
        // D s_1146_23: read-var u#31909:u32
        let s_1146_23: u32 = fn_state.u_31909;
        // D s_1146_24: cast zx s_1146_23 -> bv
        let s_1146_24: Bits = Bits::new(s_1146_23 as u128, 32u16);
        // D s_1146_25: bit-extract s_1146_24 s_1146_21 s_1146_22
        let s_1146_25: Bits = (Bits::new(
            ((s_1146_24) >> (s_1146_21)).value(),
            u16::try_from(s_1146_22).unwrap(),
        ));
        // D s_1146_26: cast reint s_1146_25 -> u8
        let s_1146_26: u8 = (s_1146_25.value() as u8);
        // C s_1146_27: const #4s : i
        let s_1146_27: i128 = 4;
        // C s_1146_28: const #4s : i
        let s_1146_28: i128 = 4;
        // D s_1146_29: read-var u#31909:u32
        let s_1146_29: u32 = fn_state.u_31909;
        // D s_1146_30: cast zx s_1146_29 -> bv
        let s_1146_30: Bits = Bits::new(s_1146_29 as u128, 32u16);
        // D s_1146_31: bit-extract s_1146_30 s_1146_27 s_1146_28
        let s_1146_31: Bits = (Bits::new(
            ((s_1146_30) >> (s_1146_27)).value(),
            u16::try_from(s_1146_28).unwrap(),
        ));
        // D s_1146_32: cast reint s_1146_31 -> u8
        let s_1146_32: u8 = (s_1146_31.value() as u8);
        // C s_1146_33: const #0s : i
        let s_1146_33: i128 = 0;
        // C s_1146_34: const #4s : i
        let s_1146_34: i128 = 4;
        // D s_1146_35: read-var u#31909:u32
        let s_1146_35: u32 = fn_state.u_31909;
        // D s_1146_36: cast zx s_1146_35 -> bv
        let s_1146_36: Bits = Bits::new(s_1146_35 as u128, 32u16);
        // D s_1146_37: bit-extract s_1146_36 s_1146_33 s_1146_34
        let s_1146_37: Bits = (Bits::new(
            ((s_1146_36) >> (s_1146_33)).value(),
            u16::try_from(s_1146_34).unwrap(),
        ));
        // D s_1146_38: cast reint s_1146_37 -> u8
        let s_1146_38: u8 = (s_1146_37.value() as u8);
        // D s_1146_39: call decode_aarch32_instrs_VST1_1_A3enc_A_txt(s_1146_8, s_1146_14, s_1146_20, s_1146_26, s_1146_32, s_1146_38)
        let s_1146_39: () = decode_aarch32_instrs_VST1_1_A3enc_A_txt(
            state,
            tracer,
            s_1146_8,
            s_1146_14,
            s_1146_20,
            s_1146_26,
            s_1146_32,
            s_1146_38,
        );
        // N s_1146_40: return
        return;
    }
    fn block_1147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1147_0: read-var merge#var.1:struct
        let s_1147_0: u32 = fn_state.merge_var._1;
        // D s_1147_1: write-var u#31917 <= s_1147_0
        fn_state.u_31917 = s_1147_0;
        // C s_1147_2: const #23s : i
        let s_1147_2: i128 = 23;
        // D s_1147_3: read-var u#31917:u32
        let s_1147_3: u32 = fn_state.u_31917;
        // D s_1147_4: cast zx s_1147_3 -> bv
        let s_1147_4: Bits = Bits::new(s_1147_3 as u128, 32u16);
        // C s_1147_5: const #1s : i64
        let s_1147_5: i64 = 1;
        // C s_1147_6: cast zx s_1147_5 -> i
        let s_1147_6: i128 = (i128::try_from(s_1147_5).unwrap());
        // C s_1147_7: const #8s : i
        let s_1147_7: i128 = 8;
        // C s_1147_8: add s_1147_7 s_1147_6
        let s_1147_8: i128 = (s_1147_7 + s_1147_6);
        // D s_1147_9: bit-extract s_1147_4 s_1147_2 s_1147_8
        let s_1147_9: Bits = (Bits::new(
            ((s_1147_4) >> (s_1147_2)).value(),
            u16::try_from(s_1147_8).unwrap(),
        ));
        // D s_1147_10: cast reint s_1147_9 -> u9
        let s_1147_10: u16 = (s_1147_9.value() as u16);
        // D s_1147_11: cast zx s_1147_10 -> bv
        let s_1147_11: Bits = Bits::new(s_1147_10 as u128, 9u16);
        // C s_1147_12: const #488u : u9
        let s_1147_12: u16 = 488;
        // C s_1147_13: cast zx s_1147_12 -> bv
        let s_1147_13: Bits = Bits::new(s_1147_12 as u128, 9u16);
        // D s_1147_14: cmp-eq s_1147_11 s_1147_13
        let s_1147_14: bool = ((s_1147_11) == (s_1147_13));
        // N s_1147_15: branch s_1147_14 b1953 b1148
        if s_1147_14 {
            return block_1953(state, tracer, fn_state);
        } else {
            return block_1148(state, tracer, fn_state);
        };
    }
    fn block_1148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1148_0: const #0u : u8
        let s_1148_0: bool = false;
        // D s_1148_1: write-var gs#402337 <= s_1148_0
        fn_state.gs_402337 = s_1148_0;
        // N s_1148_2: jump b1149
        return block_1149(state, tracer, fn_state);
    }
    fn block_1149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1149_0: read-var gs#402337:u8
        let s_1149_0: bool = fn_state.gs_402337;
        // N s_1149_1: branch s_1149_0 b1952 b1150
        if s_1149_0 {
            return block_1952(state, tracer, fn_state);
        } else {
            return block_1150(state, tracer, fn_state);
        };
    }
    fn block_1150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1150_0: const #0u : u8
        let s_1150_0: bool = false;
        // D s_1150_1: write-var gs#402339 <= s_1150_0
        fn_state.gs_402339 = s_1150_0;
        // N s_1150_2: jump b1151
        return block_1151(state, tracer, fn_state);
    }
    fn block_1151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1151_0: read-var gs#402339:u8
        let s_1151_0: bool = fn_state.gs_402339;
        // D s_1151_1: not s_1151_0
        let s_1151_1: bool = !s_1151_0;
        // N s_1151_2: branch s_1151_1 b1153 b1152
        if s_1151_1 {
            return block_1153(state, tracer, fn_state);
        } else {
            return block_1152(state, tracer, fn_state);
        };
    }
    fn block_1152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1152_0: const #3698s : i
        let s_1152_0: i128 = 3698;
        // C s_1152_1: const #14696u : u32
        let s_1152_1: u32 = 14696;
        // N s_1152_2: write-reg s_1152_1 <= s_1152_0
        let s_1152_2: () = {
            state.write_register::<i128>(s_1152_1 as isize, s_1152_0);
            tracer.write_register(s_1152_1 as isize, s_1152_0);
        };
        // C s_1152_3: const #22s : i
        let s_1152_3: i128 = 22;
        // C s_1152_4: const #1s : i
        let s_1152_4: i128 = 1;
        // D s_1152_5: read-var u#31917:u32
        let s_1152_5: u32 = fn_state.u_31917;
        // D s_1152_6: cast zx s_1152_5 -> bv
        let s_1152_6: Bits = Bits::new(s_1152_5 as u128, 32u16);
        // D s_1152_7: bit-extract s_1152_6 s_1152_3 s_1152_4
        let s_1152_7: Bits = (Bits::new(
            ((s_1152_6) >> (s_1152_3)).value(),
            u16::try_from(s_1152_4).unwrap(),
        ));
        // D s_1152_8: cast reint s_1152_7 -> u8
        let s_1152_8: bool = ((s_1152_7.value()) != 0);
        // C s_1152_9: const #16s : i
        let s_1152_9: i128 = 16;
        // C s_1152_10: const #4s : i
        let s_1152_10: i128 = 4;
        // D s_1152_11: read-var u#31917:u32
        let s_1152_11: u32 = fn_state.u_31917;
        // D s_1152_12: cast zx s_1152_11 -> bv
        let s_1152_12: Bits = Bits::new(s_1152_11 as u128, 32u16);
        // D s_1152_13: bit-extract s_1152_12 s_1152_9 s_1152_10
        let s_1152_13: Bits = (Bits::new(
            ((s_1152_12) >> (s_1152_9)).value(),
            u16::try_from(s_1152_10).unwrap(),
        ));
        // D s_1152_14: cast reint s_1152_13 -> u8
        let s_1152_14: u8 = (s_1152_13.value() as u8);
        // C s_1152_15: const #12s : i
        let s_1152_15: i128 = 12;
        // C s_1152_16: const #4s : i
        let s_1152_16: i128 = 4;
        // D s_1152_17: read-var u#31917:u32
        let s_1152_17: u32 = fn_state.u_31917;
        // D s_1152_18: cast zx s_1152_17 -> bv
        let s_1152_18: Bits = Bits::new(s_1152_17 as u128, 32u16);
        // D s_1152_19: bit-extract s_1152_18 s_1152_15 s_1152_16
        let s_1152_19: Bits = (Bits::new(
            ((s_1152_18) >> (s_1152_15)).value(),
            u16::try_from(s_1152_16).unwrap(),
        ));
        // D s_1152_20: cast reint s_1152_19 -> u8
        let s_1152_20: u8 = (s_1152_19.value() as u8);
        // C s_1152_21: const #8s : i
        let s_1152_21: i128 = 8;
        // C s_1152_22: const #4s : i
        let s_1152_22: i128 = 4;
        // D s_1152_23: read-var u#31917:u32
        let s_1152_23: u32 = fn_state.u_31917;
        // D s_1152_24: cast zx s_1152_23 -> bv
        let s_1152_24: Bits = Bits::new(s_1152_23 as u128, 32u16);
        // D s_1152_25: bit-extract s_1152_24 s_1152_21 s_1152_22
        let s_1152_25: Bits = (Bits::new(
            ((s_1152_24) >> (s_1152_21)).value(),
            u16::try_from(s_1152_22).unwrap(),
        ));
        // D s_1152_26: cast reint s_1152_25 -> u8
        let s_1152_26: u8 = (s_1152_25.value() as u8);
        // C s_1152_27: const #6s : i
        let s_1152_27: i128 = 6;
        // C s_1152_28: const #2s : i
        let s_1152_28: i128 = 2;
        // D s_1152_29: read-var u#31917:u32
        let s_1152_29: u32 = fn_state.u_31917;
        // D s_1152_30: cast zx s_1152_29 -> bv
        let s_1152_30: Bits = Bits::new(s_1152_29 as u128, 32u16);
        // D s_1152_31: bit-extract s_1152_30 s_1152_27 s_1152_28
        let s_1152_31: Bits = (Bits::new(
            ((s_1152_30) >> (s_1152_27)).value(),
            u16::try_from(s_1152_28).unwrap(),
        ));
        // D s_1152_32: cast reint s_1152_31 -> u8
        let s_1152_32: u8 = (s_1152_31.value() as u8);
        // C s_1152_33: const #4s : i
        let s_1152_33: i128 = 4;
        // C s_1152_34: const #2s : i
        let s_1152_34: i128 = 2;
        // D s_1152_35: read-var u#31917:u32
        let s_1152_35: u32 = fn_state.u_31917;
        // D s_1152_36: cast zx s_1152_35 -> bv
        let s_1152_36: Bits = Bits::new(s_1152_35 as u128, 32u16);
        // D s_1152_37: bit-extract s_1152_36 s_1152_33 s_1152_34
        let s_1152_37: Bits = (Bits::new(
            ((s_1152_36) >> (s_1152_33)).value(),
            u16::try_from(s_1152_34).unwrap(),
        ));
        // D s_1152_38: cast reint s_1152_37 -> u8
        let s_1152_38: u8 = (s_1152_37.value() as u8);
        // C s_1152_39: const #0s : i
        let s_1152_39: i128 = 0;
        // C s_1152_40: const #4s : i
        let s_1152_40: i128 = 4;
        // D s_1152_41: read-var u#31917:u32
        let s_1152_41: u32 = fn_state.u_31917;
        // D s_1152_42: cast zx s_1152_41 -> bv
        let s_1152_42: Bits = Bits::new(s_1152_41 as u128, 32u16);
        // D s_1152_43: bit-extract s_1152_42 s_1152_39 s_1152_40
        let s_1152_43: Bits = (Bits::new(
            ((s_1152_42) >> (s_1152_39)).value(),
            u16::try_from(s_1152_40).unwrap(),
        ));
        // D s_1152_44: cast reint s_1152_43 -> u8
        let s_1152_44: u8 = (s_1152_43.value() as u8);
        // D s_1152_45: call decode_aarch32_instrs_VST1_m_A1enc_A_txt(s_1152_8, s_1152_14, s_1152_20, s_1152_26, s_1152_32, s_1152_38, s_1152_44)
        let s_1152_45: () = decode_aarch32_instrs_VST1_m_A1enc_A_txt(
            state,
            tracer,
            s_1152_8,
            s_1152_14,
            s_1152_20,
            s_1152_26,
            s_1152_32,
            s_1152_38,
            s_1152_44,
        );
        // N s_1152_46: return
        return;
    }
    fn block_1153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1153_0: read-var merge#var.1:struct
        let s_1153_0: u32 = fn_state.merge_var._1;
        // D s_1153_1: write-var u#31926 <= s_1153_0
        fn_state.u_31926 = s_1153_0;
        // C s_1153_2: const #23s : i
        let s_1153_2: i128 = 23;
        // D s_1153_3: read-var u#31926:u32
        let s_1153_3: u32 = fn_state.u_31926;
        // D s_1153_4: cast zx s_1153_3 -> bv
        let s_1153_4: Bits = Bits::new(s_1153_3 as u128, 32u16);
        // C s_1153_5: const #1s : i64
        let s_1153_5: i64 = 1;
        // C s_1153_6: cast zx s_1153_5 -> i
        let s_1153_6: i128 = (i128::try_from(s_1153_5).unwrap());
        // C s_1153_7: const #8s : i
        let s_1153_7: i128 = 8;
        // C s_1153_8: add s_1153_7 s_1153_6
        let s_1153_8: i128 = (s_1153_7 + s_1153_6);
        // D s_1153_9: bit-extract s_1153_4 s_1153_2 s_1153_8
        let s_1153_9: Bits = (Bits::new(
            ((s_1153_4) >> (s_1153_2)).value(),
            u16::try_from(s_1153_8).unwrap(),
        ));
        // D s_1153_10: cast reint s_1153_9 -> u9
        let s_1153_10: u16 = (s_1153_9.value() as u16);
        // D s_1153_11: cast zx s_1153_10 -> bv
        let s_1153_11: Bits = Bits::new(s_1153_10 as u128, 9u16);
        // C s_1153_12: const #488u : u9
        let s_1153_12: u16 = 488;
        // C s_1153_13: cast zx s_1153_12 -> bv
        let s_1153_13: Bits = Bits::new(s_1153_12 as u128, 9u16);
        // D s_1153_14: cmp-eq s_1153_11 s_1153_13
        let s_1153_14: bool = ((s_1153_11) == (s_1153_13));
        // N s_1153_15: branch s_1153_14 b1948 b1154
        if s_1153_14 {
            return block_1948(state, tracer, fn_state);
        } else {
            return block_1154(state, tracer, fn_state);
        };
    }
    fn block_1154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1154_0: const #0u : u8
        let s_1154_0: bool = false;
        // D s_1154_1: write-var gs#402364 <= s_1154_0
        fn_state.gs_402364 = s_1154_0;
        // N s_1154_2: jump b1155
        return block_1155(state, tracer, fn_state);
    }
    fn block_1155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1155_0: read-var gs#402364:u8
        let s_1155_0: bool = fn_state.gs_402364;
        // N s_1155_1: branch s_1155_0 b1947 b1156
        if s_1155_0 {
            return block_1947(state, tracer, fn_state);
        } else {
            return block_1156(state, tracer, fn_state);
        };
    }
    fn block_1156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1156_0: const #0u : u8
        let s_1156_0: bool = false;
        // D s_1156_1: write-var gs#402366 <= s_1156_0
        fn_state.gs_402366 = s_1156_0;
        // N s_1156_2: jump b1157
        return block_1157(state, tracer, fn_state);
    }
    fn block_1157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1157_0: read-var gs#402366:u8
        let s_1157_0: bool = fn_state.gs_402366;
        // D s_1157_1: not s_1157_0
        let s_1157_1: bool = !s_1157_0;
        // N s_1157_2: branch s_1157_1 b1159 b1158
        if s_1157_1 {
            return block_1159(state, tracer, fn_state);
        } else {
            return block_1158(state, tracer, fn_state);
        };
    }
    fn block_1158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1158_0: const #3699s : i
        let s_1158_0: i128 = 3699;
        // C s_1158_1: const #14696u : u32
        let s_1158_1: u32 = 14696;
        // N s_1158_2: write-reg s_1158_1 <= s_1158_0
        let s_1158_2: () = {
            state.write_register::<i128>(s_1158_1 as isize, s_1158_0);
            tracer.write_register(s_1158_1 as isize, s_1158_0);
        };
        // C s_1158_3: const #22s : i
        let s_1158_3: i128 = 22;
        // C s_1158_4: const #1s : i
        let s_1158_4: i128 = 1;
        // D s_1158_5: read-var u#31926:u32
        let s_1158_5: u32 = fn_state.u_31926;
        // D s_1158_6: cast zx s_1158_5 -> bv
        let s_1158_6: Bits = Bits::new(s_1158_5 as u128, 32u16);
        // D s_1158_7: bit-extract s_1158_6 s_1158_3 s_1158_4
        let s_1158_7: Bits = (Bits::new(
            ((s_1158_6) >> (s_1158_3)).value(),
            u16::try_from(s_1158_4).unwrap(),
        ));
        // D s_1158_8: cast reint s_1158_7 -> u8
        let s_1158_8: bool = ((s_1158_7.value()) != 0);
        // C s_1158_9: const #16s : i
        let s_1158_9: i128 = 16;
        // C s_1158_10: const #4s : i
        let s_1158_10: i128 = 4;
        // D s_1158_11: read-var u#31926:u32
        let s_1158_11: u32 = fn_state.u_31926;
        // D s_1158_12: cast zx s_1158_11 -> bv
        let s_1158_12: Bits = Bits::new(s_1158_11 as u128, 32u16);
        // D s_1158_13: bit-extract s_1158_12 s_1158_9 s_1158_10
        let s_1158_13: Bits = (Bits::new(
            ((s_1158_12) >> (s_1158_9)).value(),
            u16::try_from(s_1158_10).unwrap(),
        ));
        // D s_1158_14: cast reint s_1158_13 -> u8
        let s_1158_14: u8 = (s_1158_13.value() as u8);
        // C s_1158_15: const #12s : i
        let s_1158_15: i128 = 12;
        // C s_1158_16: const #4s : i
        let s_1158_16: i128 = 4;
        // D s_1158_17: read-var u#31926:u32
        let s_1158_17: u32 = fn_state.u_31926;
        // D s_1158_18: cast zx s_1158_17 -> bv
        let s_1158_18: Bits = Bits::new(s_1158_17 as u128, 32u16);
        // D s_1158_19: bit-extract s_1158_18 s_1158_15 s_1158_16
        let s_1158_19: Bits = (Bits::new(
            ((s_1158_18) >> (s_1158_15)).value(),
            u16::try_from(s_1158_16).unwrap(),
        ));
        // D s_1158_20: cast reint s_1158_19 -> u8
        let s_1158_20: u8 = (s_1158_19.value() as u8);
        // C s_1158_21: const #8s : i
        let s_1158_21: i128 = 8;
        // C s_1158_22: const #4s : i
        let s_1158_22: i128 = 4;
        // D s_1158_23: read-var u#31926:u32
        let s_1158_23: u32 = fn_state.u_31926;
        // D s_1158_24: cast zx s_1158_23 -> bv
        let s_1158_24: Bits = Bits::new(s_1158_23 as u128, 32u16);
        // D s_1158_25: bit-extract s_1158_24 s_1158_21 s_1158_22
        let s_1158_25: Bits = (Bits::new(
            ((s_1158_24) >> (s_1158_21)).value(),
            u16::try_from(s_1158_22).unwrap(),
        ));
        // D s_1158_26: cast reint s_1158_25 -> u8
        let s_1158_26: u8 = (s_1158_25.value() as u8);
        // C s_1158_27: const #6s : i
        let s_1158_27: i128 = 6;
        // C s_1158_28: const #2s : i
        let s_1158_28: i128 = 2;
        // D s_1158_29: read-var u#31926:u32
        let s_1158_29: u32 = fn_state.u_31926;
        // D s_1158_30: cast zx s_1158_29 -> bv
        let s_1158_30: Bits = Bits::new(s_1158_29 as u128, 32u16);
        // D s_1158_31: bit-extract s_1158_30 s_1158_27 s_1158_28
        let s_1158_31: Bits = (Bits::new(
            ((s_1158_30) >> (s_1158_27)).value(),
            u16::try_from(s_1158_28).unwrap(),
        ));
        // D s_1158_32: cast reint s_1158_31 -> u8
        let s_1158_32: u8 = (s_1158_31.value() as u8);
        // C s_1158_33: const #4s : i
        let s_1158_33: i128 = 4;
        // C s_1158_34: const #2s : i
        let s_1158_34: i128 = 2;
        // D s_1158_35: read-var u#31926:u32
        let s_1158_35: u32 = fn_state.u_31926;
        // D s_1158_36: cast zx s_1158_35 -> bv
        let s_1158_36: Bits = Bits::new(s_1158_35 as u128, 32u16);
        // D s_1158_37: bit-extract s_1158_36 s_1158_33 s_1158_34
        let s_1158_37: Bits = (Bits::new(
            ((s_1158_36) >> (s_1158_33)).value(),
            u16::try_from(s_1158_34).unwrap(),
        ));
        // D s_1158_38: cast reint s_1158_37 -> u8
        let s_1158_38: u8 = (s_1158_37.value() as u8);
        // C s_1158_39: const #0s : i
        let s_1158_39: i128 = 0;
        // C s_1158_40: const #4s : i
        let s_1158_40: i128 = 4;
        // D s_1158_41: read-var u#31926:u32
        let s_1158_41: u32 = fn_state.u_31926;
        // D s_1158_42: cast zx s_1158_41 -> bv
        let s_1158_42: Bits = Bits::new(s_1158_41 as u128, 32u16);
        // D s_1158_43: bit-extract s_1158_42 s_1158_39 s_1158_40
        let s_1158_43: Bits = (Bits::new(
            ((s_1158_42) >> (s_1158_39)).value(),
            u16::try_from(s_1158_40).unwrap(),
        ));
        // D s_1158_44: cast reint s_1158_43 -> u8
        let s_1158_44: u8 = (s_1158_43.value() as u8);
        // D s_1158_45: call decode_aarch32_instrs_VST1_m_A2enc_A_txt(s_1158_8, s_1158_14, s_1158_20, s_1158_26, s_1158_32, s_1158_38, s_1158_44)
        let s_1158_45: () = decode_aarch32_instrs_VST1_m_A2enc_A_txt(
            state,
            tracer,
            s_1158_8,
            s_1158_14,
            s_1158_20,
            s_1158_26,
            s_1158_32,
            s_1158_38,
            s_1158_44,
        );
        // N s_1158_46: return
        return;
    }
    fn block_1159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1159_0: read-var merge#var.1:struct
        let s_1159_0: u32 = fn_state.merge_var._1;
        // D s_1159_1: write-var u#31935 <= s_1159_0
        fn_state.u_31935 = s_1159_0;
        // C s_1159_2: const #23s : i
        let s_1159_2: i128 = 23;
        // D s_1159_3: read-var u#31935:u32
        let s_1159_3: u32 = fn_state.u_31935;
        // D s_1159_4: cast zx s_1159_3 -> bv
        let s_1159_4: Bits = Bits::new(s_1159_3 as u128, 32u16);
        // C s_1159_5: const #1s : i64
        let s_1159_5: i64 = 1;
        // C s_1159_6: cast zx s_1159_5 -> i
        let s_1159_6: i128 = (i128::try_from(s_1159_5).unwrap());
        // C s_1159_7: const #8s : i
        let s_1159_7: i128 = 8;
        // C s_1159_8: add s_1159_7 s_1159_6
        let s_1159_8: i128 = (s_1159_7 + s_1159_6);
        // D s_1159_9: bit-extract s_1159_4 s_1159_2 s_1159_8
        let s_1159_9: Bits = (Bits::new(
            ((s_1159_4) >> (s_1159_2)).value(),
            u16::try_from(s_1159_8).unwrap(),
        ));
        // D s_1159_10: cast reint s_1159_9 -> u9
        let s_1159_10: u16 = (s_1159_9.value() as u16);
        // D s_1159_11: cast zx s_1159_10 -> bv
        let s_1159_11: Bits = Bits::new(s_1159_10 as u128, 9u16);
        // C s_1159_12: const #488u : u9
        let s_1159_12: u16 = 488;
        // C s_1159_13: cast zx s_1159_12 -> bv
        let s_1159_13: Bits = Bits::new(s_1159_12 as u128, 9u16);
        // D s_1159_14: cmp-eq s_1159_11 s_1159_13
        let s_1159_14: bool = ((s_1159_11) == (s_1159_13));
        // N s_1159_15: branch s_1159_14 b1943 b1160
        if s_1159_14 {
            return block_1943(state, tracer, fn_state);
        } else {
            return block_1160(state, tracer, fn_state);
        };
    }
    fn block_1160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1160_0: const #0u : u8
        let s_1160_0: bool = false;
        // D s_1160_1: write-var gs#402391 <= s_1160_0
        fn_state.gs_402391 = s_1160_0;
        // N s_1160_2: jump b1161
        return block_1161(state, tracer, fn_state);
    }
    fn block_1161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1161_0: read-var gs#402391:u8
        let s_1161_0: bool = fn_state.gs_402391;
        // N s_1161_1: branch s_1161_0 b1942 b1162
        if s_1161_0 {
            return block_1942(state, tracer, fn_state);
        } else {
            return block_1162(state, tracer, fn_state);
        };
    }
    fn block_1162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1162_0: const #0u : u8
        let s_1162_0: bool = false;
        // D s_1162_1: write-var gs#402393 <= s_1162_0
        fn_state.gs_402393 = s_1162_0;
        // N s_1162_2: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_1163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1163_0: read-var gs#402393:u8
        let s_1163_0: bool = fn_state.gs_402393;
        // D s_1163_1: not s_1163_0
        let s_1163_1: bool = !s_1163_0;
        // N s_1163_2: branch s_1163_1 b1165 b1164
        if s_1163_1 {
            return block_1165(state, tracer, fn_state);
        } else {
            return block_1164(state, tracer, fn_state);
        };
    }
    fn block_1164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1164_0: const #3700s : i
        let s_1164_0: i128 = 3700;
        // C s_1164_1: const #14696u : u32
        let s_1164_1: u32 = 14696;
        // N s_1164_2: write-reg s_1164_1 <= s_1164_0
        let s_1164_2: () = {
            state.write_register::<i128>(s_1164_1 as isize, s_1164_0);
            tracer.write_register(s_1164_1 as isize, s_1164_0);
        };
        // C s_1164_3: const #22s : i
        let s_1164_3: i128 = 22;
        // C s_1164_4: const #1s : i
        let s_1164_4: i128 = 1;
        // D s_1164_5: read-var u#31935:u32
        let s_1164_5: u32 = fn_state.u_31935;
        // D s_1164_6: cast zx s_1164_5 -> bv
        let s_1164_6: Bits = Bits::new(s_1164_5 as u128, 32u16);
        // D s_1164_7: bit-extract s_1164_6 s_1164_3 s_1164_4
        let s_1164_7: Bits = (Bits::new(
            ((s_1164_6) >> (s_1164_3)).value(),
            u16::try_from(s_1164_4).unwrap(),
        ));
        // D s_1164_8: cast reint s_1164_7 -> u8
        let s_1164_8: bool = ((s_1164_7.value()) != 0);
        // C s_1164_9: const #16s : i
        let s_1164_9: i128 = 16;
        // C s_1164_10: const #4s : i
        let s_1164_10: i128 = 4;
        // D s_1164_11: read-var u#31935:u32
        let s_1164_11: u32 = fn_state.u_31935;
        // D s_1164_12: cast zx s_1164_11 -> bv
        let s_1164_12: Bits = Bits::new(s_1164_11 as u128, 32u16);
        // D s_1164_13: bit-extract s_1164_12 s_1164_9 s_1164_10
        let s_1164_13: Bits = (Bits::new(
            ((s_1164_12) >> (s_1164_9)).value(),
            u16::try_from(s_1164_10).unwrap(),
        ));
        // D s_1164_14: cast reint s_1164_13 -> u8
        let s_1164_14: u8 = (s_1164_13.value() as u8);
        // C s_1164_15: const #12s : i
        let s_1164_15: i128 = 12;
        // C s_1164_16: const #4s : i
        let s_1164_16: i128 = 4;
        // D s_1164_17: read-var u#31935:u32
        let s_1164_17: u32 = fn_state.u_31935;
        // D s_1164_18: cast zx s_1164_17 -> bv
        let s_1164_18: Bits = Bits::new(s_1164_17 as u128, 32u16);
        // D s_1164_19: bit-extract s_1164_18 s_1164_15 s_1164_16
        let s_1164_19: Bits = (Bits::new(
            ((s_1164_18) >> (s_1164_15)).value(),
            u16::try_from(s_1164_16).unwrap(),
        ));
        // D s_1164_20: cast reint s_1164_19 -> u8
        let s_1164_20: u8 = (s_1164_19.value() as u8);
        // C s_1164_21: const #8s : i
        let s_1164_21: i128 = 8;
        // C s_1164_22: const #4s : i
        let s_1164_22: i128 = 4;
        // D s_1164_23: read-var u#31935:u32
        let s_1164_23: u32 = fn_state.u_31935;
        // D s_1164_24: cast zx s_1164_23 -> bv
        let s_1164_24: Bits = Bits::new(s_1164_23 as u128, 32u16);
        // D s_1164_25: bit-extract s_1164_24 s_1164_21 s_1164_22
        let s_1164_25: Bits = (Bits::new(
            ((s_1164_24) >> (s_1164_21)).value(),
            u16::try_from(s_1164_22).unwrap(),
        ));
        // D s_1164_26: cast reint s_1164_25 -> u8
        let s_1164_26: u8 = (s_1164_25.value() as u8);
        // C s_1164_27: const #6s : i
        let s_1164_27: i128 = 6;
        // C s_1164_28: const #2s : i
        let s_1164_28: i128 = 2;
        // D s_1164_29: read-var u#31935:u32
        let s_1164_29: u32 = fn_state.u_31935;
        // D s_1164_30: cast zx s_1164_29 -> bv
        let s_1164_30: Bits = Bits::new(s_1164_29 as u128, 32u16);
        // D s_1164_31: bit-extract s_1164_30 s_1164_27 s_1164_28
        let s_1164_31: Bits = (Bits::new(
            ((s_1164_30) >> (s_1164_27)).value(),
            u16::try_from(s_1164_28).unwrap(),
        ));
        // D s_1164_32: cast reint s_1164_31 -> u8
        let s_1164_32: u8 = (s_1164_31.value() as u8);
        // C s_1164_33: const #4s : i
        let s_1164_33: i128 = 4;
        // C s_1164_34: const #2s : i
        let s_1164_34: i128 = 2;
        // D s_1164_35: read-var u#31935:u32
        let s_1164_35: u32 = fn_state.u_31935;
        // D s_1164_36: cast zx s_1164_35 -> bv
        let s_1164_36: Bits = Bits::new(s_1164_35 as u128, 32u16);
        // D s_1164_37: bit-extract s_1164_36 s_1164_33 s_1164_34
        let s_1164_37: Bits = (Bits::new(
            ((s_1164_36) >> (s_1164_33)).value(),
            u16::try_from(s_1164_34).unwrap(),
        ));
        // D s_1164_38: cast reint s_1164_37 -> u8
        let s_1164_38: u8 = (s_1164_37.value() as u8);
        // C s_1164_39: const #0s : i
        let s_1164_39: i128 = 0;
        // C s_1164_40: const #4s : i
        let s_1164_40: i128 = 4;
        // D s_1164_41: read-var u#31935:u32
        let s_1164_41: u32 = fn_state.u_31935;
        // D s_1164_42: cast zx s_1164_41 -> bv
        let s_1164_42: Bits = Bits::new(s_1164_41 as u128, 32u16);
        // D s_1164_43: bit-extract s_1164_42 s_1164_39 s_1164_40
        let s_1164_43: Bits = (Bits::new(
            ((s_1164_42) >> (s_1164_39)).value(),
            u16::try_from(s_1164_40).unwrap(),
        ));
        // D s_1164_44: cast reint s_1164_43 -> u8
        let s_1164_44: u8 = (s_1164_43.value() as u8);
        // D s_1164_45: call decode_aarch32_instrs_VST1_m_A3enc_A_txt(s_1164_8, s_1164_14, s_1164_20, s_1164_26, s_1164_32, s_1164_38, s_1164_44)
        let s_1164_45: () = decode_aarch32_instrs_VST1_m_A3enc_A_txt(
            state,
            tracer,
            s_1164_8,
            s_1164_14,
            s_1164_20,
            s_1164_26,
            s_1164_32,
            s_1164_38,
            s_1164_44,
        );
        // N s_1164_46: return
        return;
    }
    fn block_1165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1165_0: read-var merge#var.1:struct
        let s_1165_0: u32 = fn_state.merge_var._1;
        // D s_1165_1: write-var u#31944 <= s_1165_0
        fn_state.u_31944 = s_1165_0;
        // C s_1165_2: const #23s : i
        let s_1165_2: i128 = 23;
        // D s_1165_3: read-var u#31944:u32
        let s_1165_3: u32 = fn_state.u_31944;
        // D s_1165_4: cast zx s_1165_3 -> bv
        let s_1165_4: Bits = Bits::new(s_1165_3 as u128, 32u16);
        // C s_1165_5: const #1s : i64
        let s_1165_5: i64 = 1;
        // C s_1165_6: cast zx s_1165_5 -> i
        let s_1165_6: i128 = (i128::try_from(s_1165_5).unwrap());
        // C s_1165_7: const #8s : i
        let s_1165_7: i128 = 8;
        // C s_1165_8: add s_1165_7 s_1165_6
        let s_1165_8: i128 = (s_1165_7 + s_1165_6);
        // D s_1165_9: bit-extract s_1165_4 s_1165_2 s_1165_8
        let s_1165_9: Bits = (Bits::new(
            ((s_1165_4) >> (s_1165_2)).value(),
            u16::try_from(s_1165_8).unwrap(),
        ));
        // D s_1165_10: cast reint s_1165_9 -> u9
        let s_1165_10: u16 = (s_1165_9.value() as u16);
        // D s_1165_11: cast zx s_1165_10 -> bv
        let s_1165_11: Bits = Bits::new(s_1165_10 as u128, 9u16);
        // C s_1165_12: const #488u : u9
        let s_1165_12: u16 = 488;
        // C s_1165_13: cast zx s_1165_12 -> bv
        let s_1165_13: Bits = Bits::new(s_1165_12 as u128, 9u16);
        // D s_1165_14: cmp-eq s_1165_11 s_1165_13
        let s_1165_14: bool = ((s_1165_11) == (s_1165_13));
        // N s_1165_15: branch s_1165_14 b1938 b1166
        if s_1165_14 {
            return block_1938(state, tracer, fn_state);
        } else {
            return block_1166(state, tracer, fn_state);
        };
    }
    fn block_1166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1166_0: const #0u : u8
        let s_1166_0: bool = false;
        // D s_1166_1: write-var gs#402418 <= s_1166_0
        fn_state.gs_402418 = s_1166_0;
        // N s_1166_2: jump b1167
        return block_1167(state, tracer, fn_state);
    }
    fn block_1167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1167_0: read-var gs#402418:u8
        let s_1167_0: bool = fn_state.gs_402418;
        // N s_1167_1: branch s_1167_0 b1937 b1168
        if s_1167_0 {
            return block_1937(state, tracer, fn_state);
        } else {
            return block_1168(state, tracer, fn_state);
        };
    }
    fn block_1168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1168_0: const #0u : u8
        let s_1168_0: bool = false;
        // D s_1168_1: write-var gs#402420 <= s_1168_0
        fn_state.gs_402420 = s_1168_0;
        // N s_1168_2: jump b1169
        return block_1169(state, tracer, fn_state);
    }
    fn block_1169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1169_0: read-var gs#402420:u8
        let s_1169_0: bool = fn_state.gs_402420;
        // D s_1169_1: not s_1169_0
        let s_1169_1: bool = !s_1169_0;
        // N s_1169_2: branch s_1169_1 b1171 b1170
        if s_1169_1 {
            return block_1171(state, tracer, fn_state);
        } else {
            return block_1170(state, tracer, fn_state);
        };
    }
    fn block_1170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1170_0: const #3701s : i
        let s_1170_0: i128 = 3701;
        // C s_1170_1: const #14696u : u32
        let s_1170_1: u32 = 14696;
        // N s_1170_2: write-reg s_1170_1 <= s_1170_0
        let s_1170_2: () = {
            state.write_register::<i128>(s_1170_1 as isize, s_1170_0);
            tracer.write_register(s_1170_1 as isize, s_1170_0);
        };
        // C s_1170_3: const #22s : i
        let s_1170_3: i128 = 22;
        // C s_1170_4: const #1s : i
        let s_1170_4: i128 = 1;
        // D s_1170_5: read-var u#31944:u32
        let s_1170_5: u32 = fn_state.u_31944;
        // D s_1170_6: cast zx s_1170_5 -> bv
        let s_1170_6: Bits = Bits::new(s_1170_5 as u128, 32u16);
        // D s_1170_7: bit-extract s_1170_6 s_1170_3 s_1170_4
        let s_1170_7: Bits = (Bits::new(
            ((s_1170_6) >> (s_1170_3)).value(),
            u16::try_from(s_1170_4).unwrap(),
        ));
        // D s_1170_8: cast reint s_1170_7 -> u8
        let s_1170_8: bool = ((s_1170_7.value()) != 0);
        // C s_1170_9: const #16s : i
        let s_1170_9: i128 = 16;
        // C s_1170_10: const #4s : i
        let s_1170_10: i128 = 4;
        // D s_1170_11: read-var u#31944:u32
        let s_1170_11: u32 = fn_state.u_31944;
        // D s_1170_12: cast zx s_1170_11 -> bv
        let s_1170_12: Bits = Bits::new(s_1170_11 as u128, 32u16);
        // D s_1170_13: bit-extract s_1170_12 s_1170_9 s_1170_10
        let s_1170_13: Bits = (Bits::new(
            ((s_1170_12) >> (s_1170_9)).value(),
            u16::try_from(s_1170_10).unwrap(),
        ));
        // D s_1170_14: cast reint s_1170_13 -> u8
        let s_1170_14: u8 = (s_1170_13.value() as u8);
        // C s_1170_15: const #12s : i
        let s_1170_15: i128 = 12;
        // C s_1170_16: const #4s : i
        let s_1170_16: i128 = 4;
        // D s_1170_17: read-var u#31944:u32
        let s_1170_17: u32 = fn_state.u_31944;
        // D s_1170_18: cast zx s_1170_17 -> bv
        let s_1170_18: Bits = Bits::new(s_1170_17 as u128, 32u16);
        // D s_1170_19: bit-extract s_1170_18 s_1170_15 s_1170_16
        let s_1170_19: Bits = (Bits::new(
            ((s_1170_18) >> (s_1170_15)).value(),
            u16::try_from(s_1170_16).unwrap(),
        ));
        // D s_1170_20: cast reint s_1170_19 -> u8
        let s_1170_20: u8 = (s_1170_19.value() as u8);
        // C s_1170_21: const #8s : i
        let s_1170_21: i128 = 8;
        // C s_1170_22: const #4s : i
        let s_1170_22: i128 = 4;
        // D s_1170_23: read-var u#31944:u32
        let s_1170_23: u32 = fn_state.u_31944;
        // D s_1170_24: cast zx s_1170_23 -> bv
        let s_1170_24: Bits = Bits::new(s_1170_23 as u128, 32u16);
        // D s_1170_25: bit-extract s_1170_24 s_1170_21 s_1170_22
        let s_1170_25: Bits = (Bits::new(
            ((s_1170_24) >> (s_1170_21)).value(),
            u16::try_from(s_1170_22).unwrap(),
        ));
        // D s_1170_26: cast reint s_1170_25 -> u8
        let s_1170_26: u8 = (s_1170_25.value() as u8);
        // C s_1170_27: const #6s : i
        let s_1170_27: i128 = 6;
        // C s_1170_28: const #2s : i
        let s_1170_28: i128 = 2;
        // D s_1170_29: read-var u#31944:u32
        let s_1170_29: u32 = fn_state.u_31944;
        // D s_1170_30: cast zx s_1170_29 -> bv
        let s_1170_30: Bits = Bits::new(s_1170_29 as u128, 32u16);
        // D s_1170_31: bit-extract s_1170_30 s_1170_27 s_1170_28
        let s_1170_31: Bits = (Bits::new(
            ((s_1170_30) >> (s_1170_27)).value(),
            u16::try_from(s_1170_28).unwrap(),
        ));
        // D s_1170_32: cast reint s_1170_31 -> u8
        let s_1170_32: u8 = (s_1170_31.value() as u8);
        // C s_1170_33: const #4s : i
        let s_1170_33: i128 = 4;
        // C s_1170_34: const #2s : i
        let s_1170_34: i128 = 2;
        // D s_1170_35: read-var u#31944:u32
        let s_1170_35: u32 = fn_state.u_31944;
        // D s_1170_36: cast zx s_1170_35 -> bv
        let s_1170_36: Bits = Bits::new(s_1170_35 as u128, 32u16);
        // D s_1170_37: bit-extract s_1170_36 s_1170_33 s_1170_34
        let s_1170_37: Bits = (Bits::new(
            ((s_1170_36) >> (s_1170_33)).value(),
            u16::try_from(s_1170_34).unwrap(),
        ));
        // D s_1170_38: cast reint s_1170_37 -> u8
        let s_1170_38: u8 = (s_1170_37.value() as u8);
        // C s_1170_39: const #0s : i
        let s_1170_39: i128 = 0;
        // C s_1170_40: const #4s : i
        let s_1170_40: i128 = 4;
        // D s_1170_41: read-var u#31944:u32
        let s_1170_41: u32 = fn_state.u_31944;
        // D s_1170_42: cast zx s_1170_41 -> bv
        let s_1170_42: Bits = Bits::new(s_1170_41 as u128, 32u16);
        // D s_1170_43: bit-extract s_1170_42 s_1170_39 s_1170_40
        let s_1170_43: Bits = (Bits::new(
            ((s_1170_42) >> (s_1170_39)).value(),
            u16::try_from(s_1170_40).unwrap(),
        ));
        // D s_1170_44: cast reint s_1170_43 -> u8
        let s_1170_44: u8 = (s_1170_43.value() as u8);
        // D s_1170_45: call decode_aarch32_instrs_VST1_m_A4enc_A_txt(s_1170_8, s_1170_14, s_1170_20, s_1170_26, s_1170_32, s_1170_38, s_1170_44)
        let s_1170_45: () = decode_aarch32_instrs_VST1_m_A4enc_A_txt(
            state,
            tracer,
            s_1170_8,
            s_1170_14,
            s_1170_20,
            s_1170_26,
            s_1170_32,
            s_1170_38,
            s_1170_44,
        );
        // N s_1170_46: return
        return;
    }
    fn block_1171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1171_0: read-var merge#var.1:struct
        let s_1171_0: u32 = fn_state.merge_var._1;
        // D s_1171_1: write-var u#31953 <= s_1171_0
        fn_state.u_31953 = s_1171_0;
        // C s_1171_2: const #23s : i
        let s_1171_2: i128 = 23;
        // D s_1171_3: read-var u#31953:u32
        let s_1171_3: u32 = fn_state.u_31953;
        // D s_1171_4: cast zx s_1171_3 -> bv
        let s_1171_4: Bits = Bits::new(s_1171_3 as u128, 32u16);
        // C s_1171_5: const #1s : i64
        let s_1171_5: i64 = 1;
        // C s_1171_6: cast zx s_1171_5 -> i
        let s_1171_6: i128 = (i128::try_from(s_1171_5).unwrap());
        // C s_1171_7: const #8s : i
        let s_1171_7: i128 = 8;
        // C s_1171_8: add s_1171_7 s_1171_6
        let s_1171_8: i128 = (s_1171_7 + s_1171_6);
        // D s_1171_9: bit-extract s_1171_4 s_1171_2 s_1171_8
        let s_1171_9: Bits = (Bits::new(
            ((s_1171_4) >> (s_1171_2)).value(),
            u16::try_from(s_1171_8).unwrap(),
        ));
        // D s_1171_10: cast reint s_1171_9 -> u9
        let s_1171_10: u16 = (s_1171_9.value() as u16);
        // D s_1171_11: cast zx s_1171_10 -> bv
        let s_1171_11: Bits = Bits::new(s_1171_10 as u128, 9u16);
        // C s_1171_12: const #489u : u9
        let s_1171_12: u16 = 489;
        // C s_1171_13: cast zx s_1171_12 -> bv
        let s_1171_13: Bits = Bits::new(s_1171_12 as u128, 9u16);
        // D s_1171_14: cmp-eq s_1171_11 s_1171_13
        let s_1171_14: bool = ((s_1171_11) == (s_1171_13));
        // N s_1171_15: branch s_1171_14 b1933 b1172
        if s_1171_14 {
            return block_1933(state, tracer, fn_state);
        } else {
            return block_1172(state, tracer, fn_state);
        };
    }
    fn block_1172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1172_0: const #0u : u8
        let s_1172_0: bool = false;
        // D s_1172_1: write-var gs#402445 <= s_1172_0
        fn_state.gs_402445 = s_1172_0;
        // N s_1172_2: jump b1173
        return block_1173(state, tracer, fn_state);
    }
    fn block_1173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1173_0: read-var gs#402445:u8
        let s_1173_0: bool = fn_state.gs_402445;
        // N s_1173_1: branch s_1173_0 b1932 b1174
        if s_1173_0 {
            return block_1932(state, tracer, fn_state);
        } else {
            return block_1174(state, tracer, fn_state);
        };
    }
    fn block_1174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1174_0: const #0u : u8
        let s_1174_0: bool = false;
        // D s_1174_1: write-var gs#402447 <= s_1174_0
        fn_state.gs_402447 = s_1174_0;
        // N s_1174_2: jump b1175
        return block_1175(state, tracer, fn_state);
    }
    fn block_1175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1175_0: read-var gs#402447:u8
        let s_1175_0: bool = fn_state.gs_402447;
        // D s_1175_1: not s_1175_0
        let s_1175_1: bool = !s_1175_0;
        // N s_1175_2: branch s_1175_1 b1177 b1176
        if s_1175_1 {
            return block_1177(state, tracer, fn_state);
        } else {
            return block_1176(state, tracer, fn_state);
        };
    }
    fn block_1176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1176_0: const #3706s : i
        let s_1176_0: i128 = 3706;
        // C s_1176_1: const #14696u : u32
        let s_1176_1: u32 = 14696;
        // N s_1176_2: write-reg s_1176_1 <= s_1176_0
        let s_1176_2: () = {
            state.write_register::<i128>(s_1176_1 as isize, s_1176_0);
            tracer.write_register(s_1176_1 as isize, s_1176_0);
        };
        // C s_1176_3: const #22s : i
        let s_1176_3: i128 = 22;
        // C s_1176_4: const #1s : i
        let s_1176_4: i128 = 1;
        // D s_1176_5: read-var u#31953:u32
        let s_1176_5: u32 = fn_state.u_31953;
        // D s_1176_6: cast zx s_1176_5 -> bv
        let s_1176_6: Bits = Bits::new(s_1176_5 as u128, 32u16);
        // D s_1176_7: bit-extract s_1176_6 s_1176_3 s_1176_4
        let s_1176_7: Bits = (Bits::new(
            ((s_1176_6) >> (s_1176_3)).value(),
            u16::try_from(s_1176_4).unwrap(),
        ));
        // D s_1176_8: cast reint s_1176_7 -> u8
        let s_1176_8: bool = ((s_1176_7.value()) != 0);
        // C s_1176_9: const #16s : i
        let s_1176_9: i128 = 16;
        // C s_1176_10: const #4s : i
        let s_1176_10: i128 = 4;
        // D s_1176_11: read-var u#31953:u32
        let s_1176_11: u32 = fn_state.u_31953;
        // D s_1176_12: cast zx s_1176_11 -> bv
        let s_1176_12: Bits = Bits::new(s_1176_11 as u128, 32u16);
        // D s_1176_13: bit-extract s_1176_12 s_1176_9 s_1176_10
        let s_1176_13: Bits = (Bits::new(
            ((s_1176_12) >> (s_1176_9)).value(),
            u16::try_from(s_1176_10).unwrap(),
        ));
        // D s_1176_14: cast reint s_1176_13 -> u8
        let s_1176_14: u8 = (s_1176_13.value() as u8);
        // C s_1176_15: const #12s : i
        let s_1176_15: i128 = 12;
        // C s_1176_16: const #4s : i
        let s_1176_16: i128 = 4;
        // D s_1176_17: read-var u#31953:u32
        let s_1176_17: u32 = fn_state.u_31953;
        // D s_1176_18: cast zx s_1176_17 -> bv
        let s_1176_18: Bits = Bits::new(s_1176_17 as u128, 32u16);
        // D s_1176_19: bit-extract s_1176_18 s_1176_15 s_1176_16
        let s_1176_19: Bits = (Bits::new(
            ((s_1176_18) >> (s_1176_15)).value(),
            u16::try_from(s_1176_16).unwrap(),
        ));
        // D s_1176_20: cast reint s_1176_19 -> u8
        let s_1176_20: u8 = (s_1176_19.value() as u8);
        // C s_1176_21: const #10s : i
        let s_1176_21: i128 = 10;
        // C s_1176_22: const #2s : i
        let s_1176_22: i128 = 2;
        // D s_1176_23: read-var u#31953:u32
        let s_1176_23: u32 = fn_state.u_31953;
        // D s_1176_24: cast zx s_1176_23 -> bv
        let s_1176_24: Bits = Bits::new(s_1176_23 as u128, 32u16);
        // D s_1176_25: bit-extract s_1176_24 s_1176_21 s_1176_22
        let s_1176_25: Bits = (Bits::new(
            ((s_1176_24) >> (s_1176_21)).value(),
            u16::try_from(s_1176_22).unwrap(),
        ));
        // D s_1176_26: cast reint s_1176_25 -> u8
        let s_1176_26: u8 = (s_1176_25.value() as u8);
        // C s_1176_27: const #4s : i
        let s_1176_27: i128 = 4;
        // C s_1176_28: const #4s : i
        let s_1176_28: i128 = 4;
        // D s_1176_29: read-var u#31953:u32
        let s_1176_29: u32 = fn_state.u_31953;
        // D s_1176_30: cast zx s_1176_29 -> bv
        let s_1176_30: Bits = Bits::new(s_1176_29 as u128, 32u16);
        // D s_1176_31: bit-extract s_1176_30 s_1176_27 s_1176_28
        let s_1176_31: Bits = (Bits::new(
            ((s_1176_30) >> (s_1176_27)).value(),
            u16::try_from(s_1176_28).unwrap(),
        ));
        // D s_1176_32: cast reint s_1176_31 -> u8
        let s_1176_32: u8 = (s_1176_31.value() as u8);
        // C s_1176_33: const #0s : i
        let s_1176_33: i128 = 0;
        // C s_1176_34: const #4s : i
        let s_1176_34: i128 = 4;
        // D s_1176_35: read-var u#31953:u32
        let s_1176_35: u32 = fn_state.u_31953;
        // D s_1176_36: cast zx s_1176_35 -> bv
        let s_1176_36: Bits = Bits::new(s_1176_35 as u128, 32u16);
        // D s_1176_37: bit-extract s_1176_36 s_1176_33 s_1176_34
        let s_1176_37: Bits = (Bits::new(
            ((s_1176_36) >> (s_1176_33)).value(),
            u16::try_from(s_1176_34).unwrap(),
        ));
        // D s_1176_38: cast reint s_1176_37 -> u8
        let s_1176_38: u8 = (s_1176_37.value() as u8);
        // D s_1176_39: call decode_aarch32_instrs_VST2_1_A1enc_A_txt(s_1176_8, s_1176_14, s_1176_20, s_1176_26, s_1176_32, s_1176_38)
        let s_1176_39: () = decode_aarch32_instrs_VST2_1_A1enc_A_txt(
            state,
            tracer,
            s_1176_8,
            s_1176_14,
            s_1176_20,
            s_1176_26,
            s_1176_32,
            s_1176_38,
        );
        // N s_1176_40: return
        return;
    }
    fn block_1177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1177_0: read-var merge#var.1:struct
        let s_1177_0: u32 = fn_state.merge_var._1;
        // D s_1177_1: write-var u#31961 <= s_1177_0
        fn_state.u_31961 = s_1177_0;
        // C s_1177_2: const #23s : i
        let s_1177_2: i128 = 23;
        // D s_1177_3: read-var u#31961:u32
        let s_1177_3: u32 = fn_state.u_31961;
        // D s_1177_4: cast zx s_1177_3 -> bv
        let s_1177_4: Bits = Bits::new(s_1177_3 as u128, 32u16);
        // C s_1177_5: const #1s : i64
        let s_1177_5: i64 = 1;
        // C s_1177_6: cast zx s_1177_5 -> i
        let s_1177_6: i128 = (i128::try_from(s_1177_5).unwrap());
        // C s_1177_7: const #8s : i
        let s_1177_7: i128 = 8;
        // C s_1177_8: add s_1177_7 s_1177_6
        let s_1177_8: i128 = (s_1177_7 + s_1177_6);
        // D s_1177_9: bit-extract s_1177_4 s_1177_2 s_1177_8
        let s_1177_9: Bits = (Bits::new(
            ((s_1177_4) >> (s_1177_2)).value(),
            u16::try_from(s_1177_8).unwrap(),
        ));
        // D s_1177_10: cast reint s_1177_9 -> u9
        let s_1177_10: u16 = (s_1177_9.value() as u16);
        // D s_1177_11: cast zx s_1177_10 -> bv
        let s_1177_11: Bits = Bits::new(s_1177_10 as u128, 9u16);
        // C s_1177_12: const #489u : u9
        let s_1177_12: u16 = 489;
        // C s_1177_13: cast zx s_1177_12 -> bv
        let s_1177_13: Bits = Bits::new(s_1177_12 as u128, 9u16);
        // D s_1177_14: cmp-eq s_1177_11 s_1177_13
        let s_1177_14: bool = ((s_1177_11) == (s_1177_13));
        // N s_1177_15: branch s_1177_14 b1928 b1178
        if s_1177_14 {
            return block_1928(state, tracer, fn_state);
        } else {
            return block_1178(state, tracer, fn_state);
        };
    }
    fn block_1178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1178_0: const #0u : u8
        let s_1178_0: bool = false;
        // D s_1178_1: write-var gs#402470 <= s_1178_0
        fn_state.gs_402470 = s_1178_0;
        // N s_1178_2: jump b1179
        return block_1179(state, tracer, fn_state);
    }
    fn block_1179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1179_0: read-var gs#402470:u8
        let s_1179_0: bool = fn_state.gs_402470;
        // N s_1179_1: branch s_1179_0 b1927 b1180
        if s_1179_0 {
            return block_1927(state, tracer, fn_state);
        } else {
            return block_1180(state, tracer, fn_state);
        };
    }
    fn block_1180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1180_0: const #0u : u8
        let s_1180_0: bool = false;
        // D s_1180_1: write-var gs#402472 <= s_1180_0
        fn_state.gs_402472 = s_1180_0;
        // N s_1180_2: jump b1181
        return block_1181(state, tracer, fn_state);
    }
    fn block_1181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1181_0: read-var gs#402472:u8
        let s_1181_0: bool = fn_state.gs_402472;
        // D s_1181_1: not s_1181_0
        let s_1181_1: bool = !s_1181_0;
        // N s_1181_2: branch s_1181_1 b1183 b1182
        if s_1181_1 {
            return block_1183(state, tracer, fn_state);
        } else {
            return block_1182(state, tracer, fn_state);
        };
    }
    fn block_1182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1182_0: const #3707s : i
        let s_1182_0: i128 = 3707;
        // C s_1182_1: const #14696u : u32
        let s_1182_1: u32 = 14696;
        // N s_1182_2: write-reg s_1182_1 <= s_1182_0
        let s_1182_2: () = {
            state.write_register::<i128>(s_1182_1 as isize, s_1182_0);
            tracer.write_register(s_1182_1 as isize, s_1182_0);
        };
        // C s_1182_3: const #22s : i
        let s_1182_3: i128 = 22;
        // C s_1182_4: const #1s : i
        let s_1182_4: i128 = 1;
        // D s_1182_5: read-var u#31961:u32
        let s_1182_5: u32 = fn_state.u_31961;
        // D s_1182_6: cast zx s_1182_5 -> bv
        let s_1182_6: Bits = Bits::new(s_1182_5 as u128, 32u16);
        // D s_1182_7: bit-extract s_1182_6 s_1182_3 s_1182_4
        let s_1182_7: Bits = (Bits::new(
            ((s_1182_6) >> (s_1182_3)).value(),
            u16::try_from(s_1182_4).unwrap(),
        ));
        // D s_1182_8: cast reint s_1182_7 -> u8
        let s_1182_8: bool = ((s_1182_7.value()) != 0);
        // C s_1182_9: const #16s : i
        let s_1182_9: i128 = 16;
        // C s_1182_10: const #4s : i
        let s_1182_10: i128 = 4;
        // D s_1182_11: read-var u#31961:u32
        let s_1182_11: u32 = fn_state.u_31961;
        // D s_1182_12: cast zx s_1182_11 -> bv
        let s_1182_12: Bits = Bits::new(s_1182_11 as u128, 32u16);
        // D s_1182_13: bit-extract s_1182_12 s_1182_9 s_1182_10
        let s_1182_13: Bits = (Bits::new(
            ((s_1182_12) >> (s_1182_9)).value(),
            u16::try_from(s_1182_10).unwrap(),
        ));
        // D s_1182_14: cast reint s_1182_13 -> u8
        let s_1182_14: u8 = (s_1182_13.value() as u8);
        // C s_1182_15: const #12s : i
        let s_1182_15: i128 = 12;
        // C s_1182_16: const #4s : i
        let s_1182_16: i128 = 4;
        // D s_1182_17: read-var u#31961:u32
        let s_1182_17: u32 = fn_state.u_31961;
        // D s_1182_18: cast zx s_1182_17 -> bv
        let s_1182_18: Bits = Bits::new(s_1182_17 as u128, 32u16);
        // D s_1182_19: bit-extract s_1182_18 s_1182_15 s_1182_16
        let s_1182_19: Bits = (Bits::new(
            ((s_1182_18) >> (s_1182_15)).value(),
            u16::try_from(s_1182_16).unwrap(),
        ));
        // D s_1182_20: cast reint s_1182_19 -> u8
        let s_1182_20: u8 = (s_1182_19.value() as u8);
        // C s_1182_21: const #10s : i
        let s_1182_21: i128 = 10;
        // C s_1182_22: const #2s : i
        let s_1182_22: i128 = 2;
        // D s_1182_23: read-var u#31961:u32
        let s_1182_23: u32 = fn_state.u_31961;
        // D s_1182_24: cast zx s_1182_23 -> bv
        let s_1182_24: Bits = Bits::new(s_1182_23 as u128, 32u16);
        // D s_1182_25: bit-extract s_1182_24 s_1182_21 s_1182_22
        let s_1182_25: Bits = (Bits::new(
            ((s_1182_24) >> (s_1182_21)).value(),
            u16::try_from(s_1182_22).unwrap(),
        ));
        // D s_1182_26: cast reint s_1182_25 -> u8
        let s_1182_26: u8 = (s_1182_25.value() as u8);
        // C s_1182_27: const #4s : i
        let s_1182_27: i128 = 4;
        // C s_1182_28: const #4s : i
        let s_1182_28: i128 = 4;
        // D s_1182_29: read-var u#31961:u32
        let s_1182_29: u32 = fn_state.u_31961;
        // D s_1182_30: cast zx s_1182_29 -> bv
        let s_1182_30: Bits = Bits::new(s_1182_29 as u128, 32u16);
        // D s_1182_31: bit-extract s_1182_30 s_1182_27 s_1182_28
        let s_1182_31: Bits = (Bits::new(
            ((s_1182_30) >> (s_1182_27)).value(),
            u16::try_from(s_1182_28).unwrap(),
        ));
        // D s_1182_32: cast reint s_1182_31 -> u8
        let s_1182_32: u8 = (s_1182_31.value() as u8);
        // C s_1182_33: const #0s : i
        let s_1182_33: i128 = 0;
        // C s_1182_34: const #4s : i
        let s_1182_34: i128 = 4;
        // D s_1182_35: read-var u#31961:u32
        let s_1182_35: u32 = fn_state.u_31961;
        // D s_1182_36: cast zx s_1182_35 -> bv
        let s_1182_36: Bits = Bits::new(s_1182_35 as u128, 32u16);
        // D s_1182_37: bit-extract s_1182_36 s_1182_33 s_1182_34
        let s_1182_37: Bits = (Bits::new(
            ((s_1182_36) >> (s_1182_33)).value(),
            u16::try_from(s_1182_34).unwrap(),
        ));
        // D s_1182_38: cast reint s_1182_37 -> u8
        let s_1182_38: u8 = (s_1182_37.value() as u8);
        // D s_1182_39: call decode_aarch32_instrs_VST2_1_A2enc_A_txt(s_1182_8, s_1182_14, s_1182_20, s_1182_26, s_1182_32, s_1182_38)
        let s_1182_39: () = decode_aarch32_instrs_VST2_1_A2enc_A_txt(
            state,
            tracer,
            s_1182_8,
            s_1182_14,
            s_1182_20,
            s_1182_26,
            s_1182_32,
            s_1182_38,
        );
        // N s_1182_40: return
        return;
    }
    fn block_1183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1183_0: read-var merge#var.1:struct
        let s_1183_0: u32 = fn_state.merge_var._1;
        // D s_1183_1: write-var u#31969 <= s_1183_0
        fn_state.u_31969 = s_1183_0;
        // C s_1183_2: const #23s : i
        let s_1183_2: i128 = 23;
        // D s_1183_3: read-var u#31969:u32
        let s_1183_3: u32 = fn_state.u_31969;
        // D s_1183_4: cast zx s_1183_3 -> bv
        let s_1183_4: Bits = Bits::new(s_1183_3 as u128, 32u16);
        // C s_1183_5: const #1s : i64
        let s_1183_5: i64 = 1;
        // C s_1183_6: cast zx s_1183_5 -> i
        let s_1183_6: i128 = (i128::try_from(s_1183_5).unwrap());
        // C s_1183_7: const #8s : i
        let s_1183_7: i128 = 8;
        // C s_1183_8: add s_1183_7 s_1183_6
        let s_1183_8: i128 = (s_1183_7 + s_1183_6);
        // D s_1183_9: bit-extract s_1183_4 s_1183_2 s_1183_8
        let s_1183_9: Bits = (Bits::new(
            ((s_1183_4) >> (s_1183_2)).value(),
            u16::try_from(s_1183_8).unwrap(),
        ));
        // D s_1183_10: cast reint s_1183_9 -> u9
        let s_1183_10: u16 = (s_1183_9.value() as u16);
        // D s_1183_11: cast zx s_1183_10 -> bv
        let s_1183_11: Bits = Bits::new(s_1183_10 as u128, 9u16);
        // C s_1183_12: const #489u : u9
        let s_1183_12: u16 = 489;
        // C s_1183_13: cast zx s_1183_12 -> bv
        let s_1183_13: Bits = Bits::new(s_1183_12 as u128, 9u16);
        // D s_1183_14: cmp-eq s_1183_11 s_1183_13
        let s_1183_14: bool = ((s_1183_11) == (s_1183_13));
        // N s_1183_15: branch s_1183_14 b1923 b1184
        if s_1183_14 {
            return block_1923(state, tracer, fn_state);
        } else {
            return block_1184(state, tracer, fn_state);
        };
    }
    fn block_1184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1184_0: const #0u : u8
        let s_1184_0: bool = false;
        // D s_1184_1: write-var gs#402495 <= s_1184_0
        fn_state.gs_402495 = s_1184_0;
        // N s_1184_2: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_1185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1185_0: read-var gs#402495:u8
        let s_1185_0: bool = fn_state.gs_402495;
        // N s_1185_1: branch s_1185_0 b1922 b1186
        if s_1185_0 {
            return block_1922(state, tracer, fn_state);
        } else {
            return block_1186(state, tracer, fn_state);
        };
    }
    fn block_1186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1186_0: const #0u : u8
        let s_1186_0: bool = false;
        // D s_1186_1: write-var gs#402497 <= s_1186_0
        fn_state.gs_402497 = s_1186_0;
        // N s_1186_2: jump b1187
        return block_1187(state, tracer, fn_state);
    }
    fn block_1187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1187_0: read-var gs#402497:u8
        let s_1187_0: bool = fn_state.gs_402497;
        // D s_1187_1: not s_1187_0
        let s_1187_1: bool = !s_1187_0;
        // N s_1187_2: branch s_1187_1 b1189 b1188
        if s_1187_1 {
            return block_1189(state, tracer, fn_state);
        } else {
            return block_1188(state, tracer, fn_state);
        };
    }
    fn block_1188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1188_0: const #3708s : i
        let s_1188_0: i128 = 3708;
        // C s_1188_1: const #14696u : u32
        let s_1188_1: u32 = 14696;
        // N s_1188_2: write-reg s_1188_1 <= s_1188_0
        let s_1188_2: () = {
            state.write_register::<i128>(s_1188_1 as isize, s_1188_0);
            tracer.write_register(s_1188_1 as isize, s_1188_0);
        };
        // C s_1188_3: const #22s : i
        let s_1188_3: i128 = 22;
        // C s_1188_4: const #1s : i
        let s_1188_4: i128 = 1;
        // D s_1188_5: read-var u#31969:u32
        let s_1188_5: u32 = fn_state.u_31969;
        // D s_1188_6: cast zx s_1188_5 -> bv
        let s_1188_6: Bits = Bits::new(s_1188_5 as u128, 32u16);
        // D s_1188_7: bit-extract s_1188_6 s_1188_3 s_1188_4
        let s_1188_7: Bits = (Bits::new(
            ((s_1188_6) >> (s_1188_3)).value(),
            u16::try_from(s_1188_4).unwrap(),
        ));
        // D s_1188_8: cast reint s_1188_7 -> u8
        let s_1188_8: bool = ((s_1188_7.value()) != 0);
        // C s_1188_9: const #16s : i
        let s_1188_9: i128 = 16;
        // C s_1188_10: const #4s : i
        let s_1188_10: i128 = 4;
        // D s_1188_11: read-var u#31969:u32
        let s_1188_11: u32 = fn_state.u_31969;
        // D s_1188_12: cast zx s_1188_11 -> bv
        let s_1188_12: Bits = Bits::new(s_1188_11 as u128, 32u16);
        // D s_1188_13: bit-extract s_1188_12 s_1188_9 s_1188_10
        let s_1188_13: Bits = (Bits::new(
            ((s_1188_12) >> (s_1188_9)).value(),
            u16::try_from(s_1188_10).unwrap(),
        ));
        // D s_1188_14: cast reint s_1188_13 -> u8
        let s_1188_14: u8 = (s_1188_13.value() as u8);
        // C s_1188_15: const #12s : i
        let s_1188_15: i128 = 12;
        // C s_1188_16: const #4s : i
        let s_1188_16: i128 = 4;
        // D s_1188_17: read-var u#31969:u32
        let s_1188_17: u32 = fn_state.u_31969;
        // D s_1188_18: cast zx s_1188_17 -> bv
        let s_1188_18: Bits = Bits::new(s_1188_17 as u128, 32u16);
        // D s_1188_19: bit-extract s_1188_18 s_1188_15 s_1188_16
        let s_1188_19: Bits = (Bits::new(
            ((s_1188_18) >> (s_1188_15)).value(),
            u16::try_from(s_1188_16).unwrap(),
        ));
        // D s_1188_20: cast reint s_1188_19 -> u8
        let s_1188_20: u8 = (s_1188_19.value() as u8);
        // C s_1188_21: const #10s : i
        let s_1188_21: i128 = 10;
        // C s_1188_22: const #2s : i
        let s_1188_22: i128 = 2;
        // D s_1188_23: read-var u#31969:u32
        let s_1188_23: u32 = fn_state.u_31969;
        // D s_1188_24: cast zx s_1188_23 -> bv
        let s_1188_24: Bits = Bits::new(s_1188_23 as u128, 32u16);
        // D s_1188_25: bit-extract s_1188_24 s_1188_21 s_1188_22
        let s_1188_25: Bits = (Bits::new(
            ((s_1188_24) >> (s_1188_21)).value(),
            u16::try_from(s_1188_22).unwrap(),
        ));
        // D s_1188_26: cast reint s_1188_25 -> u8
        let s_1188_26: u8 = (s_1188_25.value() as u8);
        // C s_1188_27: const #4s : i
        let s_1188_27: i128 = 4;
        // C s_1188_28: const #4s : i
        let s_1188_28: i128 = 4;
        // D s_1188_29: read-var u#31969:u32
        let s_1188_29: u32 = fn_state.u_31969;
        // D s_1188_30: cast zx s_1188_29 -> bv
        let s_1188_30: Bits = Bits::new(s_1188_29 as u128, 32u16);
        // D s_1188_31: bit-extract s_1188_30 s_1188_27 s_1188_28
        let s_1188_31: Bits = (Bits::new(
            ((s_1188_30) >> (s_1188_27)).value(),
            u16::try_from(s_1188_28).unwrap(),
        ));
        // D s_1188_32: cast reint s_1188_31 -> u8
        let s_1188_32: u8 = (s_1188_31.value() as u8);
        // C s_1188_33: const #0s : i
        let s_1188_33: i128 = 0;
        // C s_1188_34: const #4s : i
        let s_1188_34: i128 = 4;
        // D s_1188_35: read-var u#31969:u32
        let s_1188_35: u32 = fn_state.u_31969;
        // D s_1188_36: cast zx s_1188_35 -> bv
        let s_1188_36: Bits = Bits::new(s_1188_35 as u128, 32u16);
        // D s_1188_37: bit-extract s_1188_36 s_1188_33 s_1188_34
        let s_1188_37: Bits = (Bits::new(
            ((s_1188_36) >> (s_1188_33)).value(),
            u16::try_from(s_1188_34).unwrap(),
        ));
        // D s_1188_38: cast reint s_1188_37 -> u8
        let s_1188_38: u8 = (s_1188_37.value() as u8);
        // D s_1188_39: call decode_aarch32_instrs_VST2_1_A3enc_A_txt(s_1188_8, s_1188_14, s_1188_20, s_1188_26, s_1188_32, s_1188_38)
        let s_1188_39: () = decode_aarch32_instrs_VST2_1_A3enc_A_txt(
            state,
            tracer,
            s_1188_8,
            s_1188_14,
            s_1188_20,
            s_1188_26,
            s_1188_32,
            s_1188_38,
        );
        // N s_1188_40: return
        return;
    }
    fn block_1189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1189_0: read-var merge#var.1:struct
        let s_1189_0: u32 = fn_state.merge_var._1;
        // D s_1189_1: write-var u#31977 <= s_1189_0
        fn_state.u_31977 = s_1189_0;
        // C s_1189_2: const #23s : i
        let s_1189_2: i128 = 23;
        // D s_1189_3: read-var u#31977:u32
        let s_1189_3: u32 = fn_state.u_31977;
        // D s_1189_4: cast zx s_1189_3 -> bv
        let s_1189_4: Bits = Bits::new(s_1189_3 as u128, 32u16);
        // C s_1189_5: const #1s : i64
        let s_1189_5: i64 = 1;
        // C s_1189_6: cast zx s_1189_5 -> i
        let s_1189_6: i128 = (i128::try_from(s_1189_5).unwrap());
        // C s_1189_7: const #8s : i
        let s_1189_7: i128 = 8;
        // C s_1189_8: add s_1189_7 s_1189_6
        let s_1189_8: i128 = (s_1189_7 + s_1189_6);
        // D s_1189_9: bit-extract s_1189_4 s_1189_2 s_1189_8
        let s_1189_9: Bits = (Bits::new(
            ((s_1189_4) >> (s_1189_2)).value(),
            u16::try_from(s_1189_8).unwrap(),
        ));
        // D s_1189_10: cast reint s_1189_9 -> u9
        let s_1189_10: u16 = (s_1189_9.value() as u16);
        // D s_1189_11: cast zx s_1189_10 -> bv
        let s_1189_11: Bits = Bits::new(s_1189_10 as u128, 9u16);
        // C s_1189_12: const #488u : u9
        let s_1189_12: u16 = 488;
        // C s_1189_13: cast zx s_1189_12 -> bv
        let s_1189_13: Bits = Bits::new(s_1189_12 as u128, 9u16);
        // D s_1189_14: cmp-eq s_1189_11 s_1189_13
        let s_1189_14: bool = ((s_1189_11) == (s_1189_13));
        // N s_1189_15: branch s_1189_14 b1918 b1190
        if s_1189_14 {
            return block_1918(state, tracer, fn_state);
        } else {
            return block_1190(state, tracer, fn_state);
        };
    }
    fn block_1190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1190_0: const #0u : u8
        let s_1190_0: bool = false;
        // D s_1190_1: write-var gs#402520 <= s_1190_0
        fn_state.gs_402520 = s_1190_0;
        // N s_1190_2: jump b1191
        return block_1191(state, tracer, fn_state);
    }
    fn block_1191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1191_0: read-var gs#402520:u8
        let s_1191_0: bool = fn_state.gs_402520;
        // N s_1191_1: branch s_1191_0 b1917 b1192
        if s_1191_0 {
            return block_1917(state, tracer, fn_state);
        } else {
            return block_1192(state, tracer, fn_state);
        };
    }
    fn block_1192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1192_0: const #0u : u8
        let s_1192_0: bool = false;
        // D s_1192_1: write-var gs#402522 <= s_1192_0
        fn_state.gs_402522 = s_1192_0;
        // N s_1192_2: jump b1193
        return block_1193(state, tracer, fn_state);
    }
    fn block_1193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1193_0: read-var gs#402522:u8
        let s_1193_0: bool = fn_state.gs_402522;
        // D s_1193_1: not s_1193_0
        let s_1193_1: bool = !s_1193_0;
        // N s_1193_2: branch s_1193_1 b1195 b1194
        if s_1193_1 {
            return block_1195(state, tracer, fn_state);
        } else {
            return block_1194(state, tracer, fn_state);
        };
    }
    fn block_1194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1194_0: const #3712s : i
        let s_1194_0: i128 = 3712;
        // C s_1194_1: const #14696u : u32
        let s_1194_1: u32 = 14696;
        // N s_1194_2: write-reg s_1194_1 <= s_1194_0
        let s_1194_2: () = {
            state.write_register::<i128>(s_1194_1 as isize, s_1194_0);
            tracer.write_register(s_1194_1 as isize, s_1194_0);
        };
        // C s_1194_3: const #22s : i
        let s_1194_3: i128 = 22;
        // C s_1194_4: const #1s : i
        let s_1194_4: i128 = 1;
        // D s_1194_5: read-var u#31977:u32
        let s_1194_5: u32 = fn_state.u_31977;
        // D s_1194_6: cast zx s_1194_5 -> bv
        let s_1194_6: Bits = Bits::new(s_1194_5 as u128, 32u16);
        // D s_1194_7: bit-extract s_1194_6 s_1194_3 s_1194_4
        let s_1194_7: Bits = (Bits::new(
            ((s_1194_6) >> (s_1194_3)).value(),
            u16::try_from(s_1194_4).unwrap(),
        ));
        // D s_1194_8: cast reint s_1194_7 -> u8
        let s_1194_8: bool = ((s_1194_7.value()) != 0);
        // C s_1194_9: const #16s : i
        let s_1194_9: i128 = 16;
        // C s_1194_10: const #4s : i
        let s_1194_10: i128 = 4;
        // D s_1194_11: read-var u#31977:u32
        let s_1194_11: u32 = fn_state.u_31977;
        // D s_1194_12: cast zx s_1194_11 -> bv
        let s_1194_12: Bits = Bits::new(s_1194_11 as u128, 32u16);
        // D s_1194_13: bit-extract s_1194_12 s_1194_9 s_1194_10
        let s_1194_13: Bits = (Bits::new(
            ((s_1194_12) >> (s_1194_9)).value(),
            u16::try_from(s_1194_10).unwrap(),
        ));
        // D s_1194_14: cast reint s_1194_13 -> u8
        let s_1194_14: u8 = (s_1194_13.value() as u8);
        // C s_1194_15: const #12s : i
        let s_1194_15: i128 = 12;
        // C s_1194_16: const #4s : i
        let s_1194_16: i128 = 4;
        // D s_1194_17: read-var u#31977:u32
        let s_1194_17: u32 = fn_state.u_31977;
        // D s_1194_18: cast zx s_1194_17 -> bv
        let s_1194_18: Bits = Bits::new(s_1194_17 as u128, 32u16);
        // D s_1194_19: bit-extract s_1194_18 s_1194_15 s_1194_16
        let s_1194_19: Bits = (Bits::new(
            ((s_1194_18) >> (s_1194_15)).value(),
            u16::try_from(s_1194_16).unwrap(),
        ));
        // D s_1194_20: cast reint s_1194_19 -> u8
        let s_1194_20: u8 = (s_1194_19.value() as u8);
        // C s_1194_21: const #8s : i
        let s_1194_21: i128 = 8;
        // C s_1194_22: const #4s : i
        let s_1194_22: i128 = 4;
        // D s_1194_23: read-var u#31977:u32
        let s_1194_23: u32 = fn_state.u_31977;
        // D s_1194_24: cast zx s_1194_23 -> bv
        let s_1194_24: Bits = Bits::new(s_1194_23 as u128, 32u16);
        // D s_1194_25: bit-extract s_1194_24 s_1194_21 s_1194_22
        let s_1194_25: Bits = (Bits::new(
            ((s_1194_24) >> (s_1194_21)).value(),
            u16::try_from(s_1194_22).unwrap(),
        ));
        // D s_1194_26: cast reint s_1194_25 -> u8
        let s_1194_26: u8 = (s_1194_25.value() as u8);
        // C s_1194_27: const #6s : i
        let s_1194_27: i128 = 6;
        // C s_1194_28: const #2s : i
        let s_1194_28: i128 = 2;
        // D s_1194_29: read-var u#31977:u32
        let s_1194_29: u32 = fn_state.u_31977;
        // D s_1194_30: cast zx s_1194_29 -> bv
        let s_1194_30: Bits = Bits::new(s_1194_29 as u128, 32u16);
        // D s_1194_31: bit-extract s_1194_30 s_1194_27 s_1194_28
        let s_1194_31: Bits = (Bits::new(
            ((s_1194_30) >> (s_1194_27)).value(),
            u16::try_from(s_1194_28).unwrap(),
        ));
        // D s_1194_32: cast reint s_1194_31 -> u8
        let s_1194_32: u8 = (s_1194_31.value() as u8);
        // C s_1194_33: const #4s : i
        let s_1194_33: i128 = 4;
        // C s_1194_34: const #2s : i
        let s_1194_34: i128 = 2;
        // D s_1194_35: read-var u#31977:u32
        let s_1194_35: u32 = fn_state.u_31977;
        // D s_1194_36: cast zx s_1194_35 -> bv
        let s_1194_36: Bits = Bits::new(s_1194_35 as u128, 32u16);
        // D s_1194_37: bit-extract s_1194_36 s_1194_33 s_1194_34
        let s_1194_37: Bits = (Bits::new(
            ((s_1194_36) >> (s_1194_33)).value(),
            u16::try_from(s_1194_34).unwrap(),
        ));
        // D s_1194_38: cast reint s_1194_37 -> u8
        let s_1194_38: u8 = (s_1194_37.value() as u8);
        // C s_1194_39: const #0s : i
        let s_1194_39: i128 = 0;
        // C s_1194_40: const #4s : i
        let s_1194_40: i128 = 4;
        // D s_1194_41: read-var u#31977:u32
        let s_1194_41: u32 = fn_state.u_31977;
        // D s_1194_42: cast zx s_1194_41 -> bv
        let s_1194_42: Bits = Bits::new(s_1194_41 as u128, 32u16);
        // D s_1194_43: bit-extract s_1194_42 s_1194_39 s_1194_40
        let s_1194_43: Bits = (Bits::new(
            ((s_1194_42) >> (s_1194_39)).value(),
            u16::try_from(s_1194_40).unwrap(),
        ));
        // D s_1194_44: cast reint s_1194_43 -> u8
        let s_1194_44: u8 = (s_1194_43.value() as u8);
        // D s_1194_45: call decode_aarch32_instrs_VST2_m_A1enc_A_txt(s_1194_8, s_1194_14, s_1194_20, s_1194_26, s_1194_32, s_1194_38, s_1194_44)
        let s_1194_45: () = decode_aarch32_instrs_VST2_m_A1enc_A_txt(
            state,
            tracer,
            s_1194_8,
            s_1194_14,
            s_1194_20,
            s_1194_26,
            s_1194_32,
            s_1194_38,
            s_1194_44,
        );
        // N s_1194_46: return
        return;
    }
    fn block_1195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1195_0: read-var merge#var.1:struct
        let s_1195_0: u32 = fn_state.merge_var._1;
        // D s_1195_1: write-var u#31986 <= s_1195_0
        fn_state.u_31986 = s_1195_0;
        // C s_1195_2: const #23s : i
        let s_1195_2: i128 = 23;
        // D s_1195_3: read-var u#31986:u32
        let s_1195_3: u32 = fn_state.u_31986;
        // D s_1195_4: cast zx s_1195_3 -> bv
        let s_1195_4: Bits = Bits::new(s_1195_3 as u128, 32u16);
        // C s_1195_5: const #1s : i64
        let s_1195_5: i64 = 1;
        // C s_1195_6: cast zx s_1195_5 -> i
        let s_1195_6: i128 = (i128::try_from(s_1195_5).unwrap());
        // C s_1195_7: const #8s : i
        let s_1195_7: i128 = 8;
        // C s_1195_8: add s_1195_7 s_1195_6
        let s_1195_8: i128 = (s_1195_7 + s_1195_6);
        // D s_1195_9: bit-extract s_1195_4 s_1195_2 s_1195_8
        let s_1195_9: Bits = (Bits::new(
            ((s_1195_4) >> (s_1195_2)).value(),
            u16::try_from(s_1195_8).unwrap(),
        ));
        // D s_1195_10: cast reint s_1195_9 -> u9
        let s_1195_10: u16 = (s_1195_9.value() as u16);
        // D s_1195_11: cast zx s_1195_10 -> bv
        let s_1195_11: Bits = Bits::new(s_1195_10 as u128, 9u16);
        // C s_1195_12: const #488u : u9
        let s_1195_12: u16 = 488;
        // C s_1195_13: cast zx s_1195_12 -> bv
        let s_1195_13: Bits = Bits::new(s_1195_12 as u128, 9u16);
        // D s_1195_14: cmp-eq s_1195_11 s_1195_13
        let s_1195_14: bool = ((s_1195_11) == (s_1195_13));
        // N s_1195_15: branch s_1195_14 b1913 b1196
        if s_1195_14 {
            return block_1913(state, tracer, fn_state);
        } else {
            return block_1196(state, tracer, fn_state);
        };
    }
    fn block_1196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1196_0: const #0u : u8
        let s_1196_0: bool = false;
        // D s_1196_1: write-var gs#402547 <= s_1196_0
        fn_state.gs_402547 = s_1196_0;
        // N s_1196_2: jump b1197
        return block_1197(state, tracer, fn_state);
    }
    fn block_1197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1197_0: read-var gs#402547:u8
        let s_1197_0: bool = fn_state.gs_402547;
        // N s_1197_1: branch s_1197_0 b1912 b1198
        if s_1197_0 {
            return block_1912(state, tracer, fn_state);
        } else {
            return block_1198(state, tracer, fn_state);
        };
    }
    fn block_1198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1198_0: const #0u : u8
        let s_1198_0: bool = false;
        // D s_1198_1: write-var gs#402549 <= s_1198_0
        fn_state.gs_402549 = s_1198_0;
        // N s_1198_2: jump b1199
        return block_1199(state, tracer, fn_state);
    }
    fn block_1199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1199_0: read-var gs#402549:u8
        let s_1199_0: bool = fn_state.gs_402549;
        // D s_1199_1: not s_1199_0
        let s_1199_1: bool = !s_1199_0;
        // N s_1199_2: branch s_1199_1 b1201 b1200
        if s_1199_1 {
            return block_1201(state, tracer, fn_state);
        } else {
            return block_1200(state, tracer, fn_state);
        };
    }
    fn block_1200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1200_0: const #3713s : i
        let s_1200_0: i128 = 3713;
        // C s_1200_1: const #14696u : u32
        let s_1200_1: u32 = 14696;
        // N s_1200_2: write-reg s_1200_1 <= s_1200_0
        let s_1200_2: () = {
            state.write_register::<i128>(s_1200_1 as isize, s_1200_0);
            tracer.write_register(s_1200_1 as isize, s_1200_0);
        };
        // C s_1200_3: const #22s : i
        let s_1200_3: i128 = 22;
        // C s_1200_4: const #1s : i
        let s_1200_4: i128 = 1;
        // D s_1200_5: read-var u#31986:u32
        let s_1200_5: u32 = fn_state.u_31986;
        // D s_1200_6: cast zx s_1200_5 -> bv
        let s_1200_6: Bits = Bits::new(s_1200_5 as u128, 32u16);
        // D s_1200_7: bit-extract s_1200_6 s_1200_3 s_1200_4
        let s_1200_7: Bits = (Bits::new(
            ((s_1200_6) >> (s_1200_3)).value(),
            u16::try_from(s_1200_4).unwrap(),
        ));
        // D s_1200_8: cast reint s_1200_7 -> u8
        let s_1200_8: bool = ((s_1200_7.value()) != 0);
        // C s_1200_9: const #16s : i
        let s_1200_9: i128 = 16;
        // C s_1200_10: const #4s : i
        let s_1200_10: i128 = 4;
        // D s_1200_11: read-var u#31986:u32
        let s_1200_11: u32 = fn_state.u_31986;
        // D s_1200_12: cast zx s_1200_11 -> bv
        let s_1200_12: Bits = Bits::new(s_1200_11 as u128, 32u16);
        // D s_1200_13: bit-extract s_1200_12 s_1200_9 s_1200_10
        let s_1200_13: Bits = (Bits::new(
            ((s_1200_12) >> (s_1200_9)).value(),
            u16::try_from(s_1200_10).unwrap(),
        ));
        // D s_1200_14: cast reint s_1200_13 -> u8
        let s_1200_14: u8 = (s_1200_13.value() as u8);
        // C s_1200_15: const #12s : i
        let s_1200_15: i128 = 12;
        // C s_1200_16: const #4s : i
        let s_1200_16: i128 = 4;
        // D s_1200_17: read-var u#31986:u32
        let s_1200_17: u32 = fn_state.u_31986;
        // D s_1200_18: cast zx s_1200_17 -> bv
        let s_1200_18: Bits = Bits::new(s_1200_17 as u128, 32u16);
        // D s_1200_19: bit-extract s_1200_18 s_1200_15 s_1200_16
        let s_1200_19: Bits = (Bits::new(
            ((s_1200_18) >> (s_1200_15)).value(),
            u16::try_from(s_1200_16).unwrap(),
        ));
        // D s_1200_20: cast reint s_1200_19 -> u8
        let s_1200_20: u8 = (s_1200_19.value() as u8);
        // C s_1200_21: const #8s : i
        let s_1200_21: i128 = 8;
        // C s_1200_22: const #4s : i
        let s_1200_22: i128 = 4;
        // D s_1200_23: read-var u#31986:u32
        let s_1200_23: u32 = fn_state.u_31986;
        // D s_1200_24: cast zx s_1200_23 -> bv
        let s_1200_24: Bits = Bits::new(s_1200_23 as u128, 32u16);
        // D s_1200_25: bit-extract s_1200_24 s_1200_21 s_1200_22
        let s_1200_25: Bits = (Bits::new(
            ((s_1200_24) >> (s_1200_21)).value(),
            u16::try_from(s_1200_22).unwrap(),
        ));
        // D s_1200_26: cast reint s_1200_25 -> u8
        let s_1200_26: u8 = (s_1200_25.value() as u8);
        // C s_1200_27: const #6s : i
        let s_1200_27: i128 = 6;
        // C s_1200_28: const #2s : i
        let s_1200_28: i128 = 2;
        // D s_1200_29: read-var u#31986:u32
        let s_1200_29: u32 = fn_state.u_31986;
        // D s_1200_30: cast zx s_1200_29 -> bv
        let s_1200_30: Bits = Bits::new(s_1200_29 as u128, 32u16);
        // D s_1200_31: bit-extract s_1200_30 s_1200_27 s_1200_28
        let s_1200_31: Bits = (Bits::new(
            ((s_1200_30) >> (s_1200_27)).value(),
            u16::try_from(s_1200_28).unwrap(),
        ));
        // D s_1200_32: cast reint s_1200_31 -> u8
        let s_1200_32: u8 = (s_1200_31.value() as u8);
        // C s_1200_33: const #4s : i
        let s_1200_33: i128 = 4;
        // C s_1200_34: const #2s : i
        let s_1200_34: i128 = 2;
        // D s_1200_35: read-var u#31986:u32
        let s_1200_35: u32 = fn_state.u_31986;
        // D s_1200_36: cast zx s_1200_35 -> bv
        let s_1200_36: Bits = Bits::new(s_1200_35 as u128, 32u16);
        // D s_1200_37: bit-extract s_1200_36 s_1200_33 s_1200_34
        let s_1200_37: Bits = (Bits::new(
            ((s_1200_36) >> (s_1200_33)).value(),
            u16::try_from(s_1200_34).unwrap(),
        ));
        // D s_1200_38: cast reint s_1200_37 -> u8
        let s_1200_38: u8 = (s_1200_37.value() as u8);
        // C s_1200_39: const #0s : i
        let s_1200_39: i128 = 0;
        // C s_1200_40: const #4s : i
        let s_1200_40: i128 = 4;
        // D s_1200_41: read-var u#31986:u32
        let s_1200_41: u32 = fn_state.u_31986;
        // D s_1200_42: cast zx s_1200_41 -> bv
        let s_1200_42: Bits = Bits::new(s_1200_41 as u128, 32u16);
        // D s_1200_43: bit-extract s_1200_42 s_1200_39 s_1200_40
        let s_1200_43: Bits = (Bits::new(
            ((s_1200_42) >> (s_1200_39)).value(),
            u16::try_from(s_1200_40).unwrap(),
        ));
        // D s_1200_44: cast reint s_1200_43 -> u8
        let s_1200_44: u8 = (s_1200_43.value() as u8);
        // D s_1200_45: call decode_aarch32_instrs_VST2_m_A2enc_A_txt(s_1200_8, s_1200_14, s_1200_20, s_1200_26, s_1200_32, s_1200_38, s_1200_44)
        let s_1200_45: () = decode_aarch32_instrs_VST2_m_A2enc_A_txt(
            state,
            tracer,
            s_1200_8,
            s_1200_14,
            s_1200_20,
            s_1200_26,
            s_1200_32,
            s_1200_38,
            s_1200_44,
        );
        // N s_1200_46: return
        return;
    }
    fn block_1201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1201_0: read-var merge#var.1:struct
        let s_1201_0: u32 = fn_state.merge_var._1;
        // D s_1201_1: write-var u#31995 <= s_1201_0
        fn_state.u_31995 = s_1201_0;
        // C s_1201_2: const #23s : i
        let s_1201_2: i128 = 23;
        // D s_1201_3: read-var u#31995:u32
        let s_1201_3: u32 = fn_state.u_31995;
        // D s_1201_4: cast zx s_1201_3 -> bv
        let s_1201_4: Bits = Bits::new(s_1201_3 as u128, 32u16);
        // C s_1201_5: const #1s : i64
        let s_1201_5: i64 = 1;
        // C s_1201_6: cast zx s_1201_5 -> i
        let s_1201_6: i128 = (i128::try_from(s_1201_5).unwrap());
        // C s_1201_7: const #8s : i
        let s_1201_7: i128 = 8;
        // C s_1201_8: add s_1201_7 s_1201_6
        let s_1201_8: i128 = (s_1201_7 + s_1201_6);
        // D s_1201_9: bit-extract s_1201_4 s_1201_2 s_1201_8
        let s_1201_9: Bits = (Bits::new(
            ((s_1201_4) >> (s_1201_2)).value(),
            u16::try_from(s_1201_8).unwrap(),
        ));
        // D s_1201_10: cast reint s_1201_9 -> u9
        let s_1201_10: u16 = (s_1201_9.value() as u16);
        // D s_1201_11: cast zx s_1201_10 -> bv
        let s_1201_11: Bits = Bits::new(s_1201_10 as u128, 9u16);
        // C s_1201_12: const #489u : u9
        let s_1201_12: u16 = 489;
        // C s_1201_13: cast zx s_1201_12 -> bv
        let s_1201_13: Bits = Bits::new(s_1201_12 as u128, 9u16);
        // D s_1201_14: cmp-eq s_1201_11 s_1201_13
        let s_1201_14: bool = ((s_1201_11) == (s_1201_13));
        // N s_1201_15: branch s_1201_14 b1908 b1202
        if s_1201_14 {
            return block_1908(state, tracer, fn_state);
        } else {
            return block_1202(state, tracer, fn_state);
        };
    }
    fn block_1202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1202_0: const #0u : u8
        let s_1202_0: bool = false;
        // D s_1202_1: write-var gs#402574 <= s_1202_0
        fn_state.gs_402574 = s_1202_0;
        // N s_1202_2: jump b1203
        return block_1203(state, tracer, fn_state);
    }
    fn block_1203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1203_0: read-var gs#402574:u8
        let s_1203_0: bool = fn_state.gs_402574;
        // N s_1203_1: branch s_1203_0 b1907 b1204
        if s_1203_0 {
            return block_1907(state, tracer, fn_state);
        } else {
            return block_1204(state, tracer, fn_state);
        };
    }
    fn block_1204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1204_0: const #0u : u8
        let s_1204_0: bool = false;
        // D s_1204_1: write-var gs#402576 <= s_1204_0
        fn_state.gs_402576 = s_1204_0;
        // N s_1204_2: jump b1205
        return block_1205(state, tracer, fn_state);
    }
    fn block_1205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1205_0: read-var gs#402576:u8
        let s_1205_0: bool = fn_state.gs_402576;
        // D s_1205_1: not s_1205_0
        let s_1205_1: bool = !s_1205_0;
        // N s_1205_2: branch s_1205_1 b1207 b1206
        if s_1205_1 {
            return block_1207(state, tracer, fn_state);
        } else {
            return block_1206(state, tracer, fn_state);
        };
    }
    fn block_1206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1206_0: const #3716s : i
        let s_1206_0: i128 = 3716;
        // C s_1206_1: const #14696u : u32
        let s_1206_1: u32 = 14696;
        // N s_1206_2: write-reg s_1206_1 <= s_1206_0
        let s_1206_2: () = {
            state.write_register::<i128>(s_1206_1 as isize, s_1206_0);
            tracer.write_register(s_1206_1 as isize, s_1206_0);
        };
        // C s_1206_3: const #22s : i
        let s_1206_3: i128 = 22;
        // C s_1206_4: const #1s : i
        let s_1206_4: i128 = 1;
        // D s_1206_5: read-var u#31995:u32
        let s_1206_5: u32 = fn_state.u_31995;
        // D s_1206_6: cast zx s_1206_5 -> bv
        let s_1206_6: Bits = Bits::new(s_1206_5 as u128, 32u16);
        // D s_1206_7: bit-extract s_1206_6 s_1206_3 s_1206_4
        let s_1206_7: Bits = (Bits::new(
            ((s_1206_6) >> (s_1206_3)).value(),
            u16::try_from(s_1206_4).unwrap(),
        ));
        // D s_1206_8: cast reint s_1206_7 -> u8
        let s_1206_8: bool = ((s_1206_7.value()) != 0);
        // C s_1206_9: const #16s : i
        let s_1206_9: i128 = 16;
        // C s_1206_10: const #4s : i
        let s_1206_10: i128 = 4;
        // D s_1206_11: read-var u#31995:u32
        let s_1206_11: u32 = fn_state.u_31995;
        // D s_1206_12: cast zx s_1206_11 -> bv
        let s_1206_12: Bits = Bits::new(s_1206_11 as u128, 32u16);
        // D s_1206_13: bit-extract s_1206_12 s_1206_9 s_1206_10
        let s_1206_13: Bits = (Bits::new(
            ((s_1206_12) >> (s_1206_9)).value(),
            u16::try_from(s_1206_10).unwrap(),
        ));
        // D s_1206_14: cast reint s_1206_13 -> u8
        let s_1206_14: u8 = (s_1206_13.value() as u8);
        // C s_1206_15: const #12s : i
        let s_1206_15: i128 = 12;
        // C s_1206_16: const #4s : i
        let s_1206_16: i128 = 4;
        // D s_1206_17: read-var u#31995:u32
        let s_1206_17: u32 = fn_state.u_31995;
        // D s_1206_18: cast zx s_1206_17 -> bv
        let s_1206_18: Bits = Bits::new(s_1206_17 as u128, 32u16);
        // D s_1206_19: bit-extract s_1206_18 s_1206_15 s_1206_16
        let s_1206_19: Bits = (Bits::new(
            ((s_1206_18) >> (s_1206_15)).value(),
            u16::try_from(s_1206_16).unwrap(),
        ));
        // D s_1206_20: cast reint s_1206_19 -> u8
        let s_1206_20: u8 = (s_1206_19.value() as u8);
        // C s_1206_21: const #10s : i
        let s_1206_21: i128 = 10;
        // C s_1206_22: const #2s : i
        let s_1206_22: i128 = 2;
        // D s_1206_23: read-var u#31995:u32
        let s_1206_23: u32 = fn_state.u_31995;
        // D s_1206_24: cast zx s_1206_23 -> bv
        let s_1206_24: Bits = Bits::new(s_1206_23 as u128, 32u16);
        // D s_1206_25: bit-extract s_1206_24 s_1206_21 s_1206_22
        let s_1206_25: Bits = (Bits::new(
            ((s_1206_24) >> (s_1206_21)).value(),
            u16::try_from(s_1206_22).unwrap(),
        ));
        // D s_1206_26: cast reint s_1206_25 -> u8
        let s_1206_26: u8 = (s_1206_25.value() as u8);
        // C s_1206_27: const #4s : i
        let s_1206_27: i128 = 4;
        // C s_1206_28: const #4s : i
        let s_1206_28: i128 = 4;
        // D s_1206_29: read-var u#31995:u32
        let s_1206_29: u32 = fn_state.u_31995;
        // D s_1206_30: cast zx s_1206_29 -> bv
        let s_1206_30: Bits = Bits::new(s_1206_29 as u128, 32u16);
        // D s_1206_31: bit-extract s_1206_30 s_1206_27 s_1206_28
        let s_1206_31: Bits = (Bits::new(
            ((s_1206_30) >> (s_1206_27)).value(),
            u16::try_from(s_1206_28).unwrap(),
        ));
        // D s_1206_32: cast reint s_1206_31 -> u8
        let s_1206_32: u8 = (s_1206_31.value() as u8);
        // C s_1206_33: const #0s : i
        let s_1206_33: i128 = 0;
        // C s_1206_34: const #4s : i
        let s_1206_34: i128 = 4;
        // D s_1206_35: read-var u#31995:u32
        let s_1206_35: u32 = fn_state.u_31995;
        // D s_1206_36: cast zx s_1206_35 -> bv
        let s_1206_36: Bits = Bits::new(s_1206_35 as u128, 32u16);
        // D s_1206_37: bit-extract s_1206_36 s_1206_33 s_1206_34
        let s_1206_37: Bits = (Bits::new(
            ((s_1206_36) >> (s_1206_33)).value(),
            u16::try_from(s_1206_34).unwrap(),
        ));
        // D s_1206_38: cast reint s_1206_37 -> u8
        let s_1206_38: u8 = (s_1206_37.value() as u8);
        // D s_1206_39: call decode_aarch32_instrs_VST3_1_A1enc_A_txt(s_1206_8, s_1206_14, s_1206_20, s_1206_26, s_1206_32, s_1206_38)
        let s_1206_39: () = decode_aarch32_instrs_VST3_1_A1enc_A_txt(
            state,
            tracer,
            s_1206_8,
            s_1206_14,
            s_1206_20,
            s_1206_26,
            s_1206_32,
            s_1206_38,
        );
        // N s_1206_40: return
        return;
    }
    fn block_1207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1207_0: read-var merge#var.1:struct
        let s_1207_0: u32 = fn_state.merge_var._1;
        // D s_1207_1: write-var u#32003 <= s_1207_0
        fn_state.u_32003 = s_1207_0;
        // C s_1207_2: const #23s : i
        let s_1207_2: i128 = 23;
        // D s_1207_3: read-var u#32003:u32
        let s_1207_3: u32 = fn_state.u_32003;
        // D s_1207_4: cast zx s_1207_3 -> bv
        let s_1207_4: Bits = Bits::new(s_1207_3 as u128, 32u16);
        // C s_1207_5: const #1s : i64
        let s_1207_5: i64 = 1;
        // C s_1207_6: cast zx s_1207_5 -> i
        let s_1207_6: i128 = (i128::try_from(s_1207_5).unwrap());
        // C s_1207_7: const #8s : i
        let s_1207_7: i128 = 8;
        // C s_1207_8: add s_1207_7 s_1207_6
        let s_1207_8: i128 = (s_1207_7 + s_1207_6);
        // D s_1207_9: bit-extract s_1207_4 s_1207_2 s_1207_8
        let s_1207_9: Bits = (Bits::new(
            ((s_1207_4) >> (s_1207_2)).value(),
            u16::try_from(s_1207_8).unwrap(),
        ));
        // D s_1207_10: cast reint s_1207_9 -> u9
        let s_1207_10: u16 = (s_1207_9.value() as u16);
        // D s_1207_11: cast zx s_1207_10 -> bv
        let s_1207_11: Bits = Bits::new(s_1207_10 as u128, 9u16);
        // C s_1207_12: const #489u : u9
        let s_1207_12: u16 = 489;
        // C s_1207_13: cast zx s_1207_12 -> bv
        let s_1207_13: Bits = Bits::new(s_1207_12 as u128, 9u16);
        // D s_1207_14: cmp-eq s_1207_11 s_1207_13
        let s_1207_14: bool = ((s_1207_11) == (s_1207_13));
        // N s_1207_15: branch s_1207_14 b1903 b1208
        if s_1207_14 {
            return block_1903(state, tracer, fn_state);
        } else {
            return block_1208(state, tracer, fn_state);
        };
    }
    fn block_1208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1208_0: const #0u : u8
        let s_1208_0: bool = false;
        // D s_1208_1: write-var gs#402599 <= s_1208_0
        fn_state.gs_402599 = s_1208_0;
        // N s_1208_2: jump b1209
        return block_1209(state, tracer, fn_state);
    }
    fn block_1209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1209_0: read-var gs#402599:u8
        let s_1209_0: bool = fn_state.gs_402599;
        // N s_1209_1: branch s_1209_0 b1902 b1210
        if s_1209_0 {
            return block_1902(state, tracer, fn_state);
        } else {
            return block_1210(state, tracer, fn_state);
        };
    }
    fn block_1210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1210_0: const #0u : u8
        let s_1210_0: bool = false;
        // D s_1210_1: write-var gs#402601 <= s_1210_0
        fn_state.gs_402601 = s_1210_0;
        // N s_1210_2: jump b1211
        return block_1211(state, tracer, fn_state);
    }
    fn block_1211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1211_0: read-var gs#402601:u8
        let s_1211_0: bool = fn_state.gs_402601;
        // D s_1211_1: not s_1211_0
        let s_1211_1: bool = !s_1211_0;
        // N s_1211_2: branch s_1211_1 b1213 b1212
        if s_1211_1 {
            return block_1213(state, tracer, fn_state);
        } else {
            return block_1212(state, tracer, fn_state);
        };
    }
    fn block_1212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1212_0: const #3717s : i
        let s_1212_0: i128 = 3717;
        // C s_1212_1: const #14696u : u32
        let s_1212_1: u32 = 14696;
        // N s_1212_2: write-reg s_1212_1 <= s_1212_0
        let s_1212_2: () = {
            state.write_register::<i128>(s_1212_1 as isize, s_1212_0);
            tracer.write_register(s_1212_1 as isize, s_1212_0);
        };
        // C s_1212_3: const #22s : i
        let s_1212_3: i128 = 22;
        // C s_1212_4: const #1s : i
        let s_1212_4: i128 = 1;
        // D s_1212_5: read-var u#32003:u32
        let s_1212_5: u32 = fn_state.u_32003;
        // D s_1212_6: cast zx s_1212_5 -> bv
        let s_1212_6: Bits = Bits::new(s_1212_5 as u128, 32u16);
        // D s_1212_7: bit-extract s_1212_6 s_1212_3 s_1212_4
        let s_1212_7: Bits = (Bits::new(
            ((s_1212_6) >> (s_1212_3)).value(),
            u16::try_from(s_1212_4).unwrap(),
        ));
        // D s_1212_8: cast reint s_1212_7 -> u8
        let s_1212_8: bool = ((s_1212_7.value()) != 0);
        // C s_1212_9: const #16s : i
        let s_1212_9: i128 = 16;
        // C s_1212_10: const #4s : i
        let s_1212_10: i128 = 4;
        // D s_1212_11: read-var u#32003:u32
        let s_1212_11: u32 = fn_state.u_32003;
        // D s_1212_12: cast zx s_1212_11 -> bv
        let s_1212_12: Bits = Bits::new(s_1212_11 as u128, 32u16);
        // D s_1212_13: bit-extract s_1212_12 s_1212_9 s_1212_10
        let s_1212_13: Bits = (Bits::new(
            ((s_1212_12) >> (s_1212_9)).value(),
            u16::try_from(s_1212_10).unwrap(),
        ));
        // D s_1212_14: cast reint s_1212_13 -> u8
        let s_1212_14: u8 = (s_1212_13.value() as u8);
        // C s_1212_15: const #12s : i
        let s_1212_15: i128 = 12;
        // C s_1212_16: const #4s : i
        let s_1212_16: i128 = 4;
        // D s_1212_17: read-var u#32003:u32
        let s_1212_17: u32 = fn_state.u_32003;
        // D s_1212_18: cast zx s_1212_17 -> bv
        let s_1212_18: Bits = Bits::new(s_1212_17 as u128, 32u16);
        // D s_1212_19: bit-extract s_1212_18 s_1212_15 s_1212_16
        let s_1212_19: Bits = (Bits::new(
            ((s_1212_18) >> (s_1212_15)).value(),
            u16::try_from(s_1212_16).unwrap(),
        ));
        // D s_1212_20: cast reint s_1212_19 -> u8
        let s_1212_20: u8 = (s_1212_19.value() as u8);
        // C s_1212_21: const #10s : i
        let s_1212_21: i128 = 10;
        // C s_1212_22: const #2s : i
        let s_1212_22: i128 = 2;
        // D s_1212_23: read-var u#32003:u32
        let s_1212_23: u32 = fn_state.u_32003;
        // D s_1212_24: cast zx s_1212_23 -> bv
        let s_1212_24: Bits = Bits::new(s_1212_23 as u128, 32u16);
        // D s_1212_25: bit-extract s_1212_24 s_1212_21 s_1212_22
        let s_1212_25: Bits = (Bits::new(
            ((s_1212_24) >> (s_1212_21)).value(),
            u16::try_from(s_1212_22).unwrap(),
        ));
        // D s_1212_26: cast reint s_1212_25 -> u8
        let s_1212_26: u8 = (s_1212_25.value() as u8);
        // C s_1212_27: const #4s : i
        let s_1212_27: i128 = 4;
        // C s_1212_28: const #4s : i
        let s_1212_28: i128 = 4;
        // D s_1212_29: read-var u#32003:u32
        let s_1212_29: u32 = fn_state.u_32003;
        // D s_1212_30: cast zx s_1212_29 -> bv
        let s_1212_30: Bits = Bits::new(s_1212_29 as u128, 32u16);
        // D s_1212_31: bit-extract s_1212_30 s_1212_27 s_1212_28
        let s_1212_31: Bits = (Bits::new(
            ((s_1212_30) >> (s_1212_27)).value(),
            u16::try_from(s_1212_28).unwrap(),
        ));
        // D s_1212_32: cast reint s_1212_31 -> u8
        let s_1212_32: u8 = (s_1212_31.value() as u8);
        // C s_1212_33: const #0s : i
        let s_1212_33: i128 = 0;
        // C s_1212_34: const #4s : i
        let s_1212_34: i128 = 4;
        // D s_1212_35: read-var u#32003:u32
        let s_1212_35: u32 = fn_state.u_32003;
        // D s_1212_36: cast zx s_1212_35 -> bv
        let s_1212_36: Bits = Bits::new(s_1212_35 as u128, 32u16);
        // D s_1212_37: bit-extract s_1212_36 s_1212_33 s_1212_34
        let s_1212_37: Bits = (Bits::new(
            ((s_1212_36) >> (s_1212_33)).value(),
            u16::try_from(s_1212_34).unwrap(),
        ));
        // D s_1212_38: cast reint s_1212_37 -> u8
        let s_1212_38: u8 = (s_1212_37.value() as u8);
        // D s_1212_39: call decode_aarch32_instrs_VST3_1_A2enc_A_txt(s_1212_8, s_1212_14, s_1212_20, s_1212_26, s_1212_32, s_1212_38)
        let s_1212_39: () = decode_aarch32_instrs_VST3_1_A2enc_A_txt(
            state,
            tracer,
            s_1212_8,
            s_1212_14,
            s_1212_20,
            s_1212_26,
            s_1212_32,
            s_1212_38,
        );
        // N s_1212_40: return
        return;
    }
    fn block_1213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1213_0: read-var merge#var.1:struct
        let s_1213_0: u32 = fn_state.merge_var._1;
        // D s_1213_1: write-var u#32011 <= s_1213_0
        fn_state.u_32011 = s_1213_0;
        // C s_1213_2: const #23s : i
        let s_1213_2: i128 = 23;
        // D s_1213_3: read-var u#32011:u32
        let s_1213_3: u32 = fn_state.u_32011;
        // D s_1213_4: cast zx s_1213_3 -> bv
        let s_1213_4: Bits = Bits::new(s_1213_3 as u128, 32u16);
        // C s_1213_5: const #1s : i64
        let s_1213_5: i64 = 1;
        // C s_1213_6: cast zx s_1213_5 -> i
        let s_1213_6: i128 = (i128::try_from(s_1213_5).unwrap());
        // C s_1213_7: const #8s : i
        let s_1213_7: i128 = 8;
        // C s_1213_8: add s_1213_7 s_1213_6
        let s_1213_8: i128 = (s_1213_7 + s_1213_6);
        // D s_1213_9: bit-extract s_1213_4 s_1213_2 s_1213_8
        let s_1213_9: Bits = (Bits::new(
            ((s_1213_4) >> (s_1213_2)).value(),
            u16::try_from(s_1213_8).unwrap(),
        ));
        // D s_1213_10: cast reint s_1213_9 -> u9
        let s_1213_10: u16 = (s_1213_9.value() as u16);
        // D s_1213_11: cast zx s_1213_10 -> bv
        let s_1213_11: Bits = Bits::new(s_1213_10 as u128, 9u16);
        // C s_1213_12: const #489u : u9
        let s_1213_12: u16 = 489;
        // C s_1213_13: cast zx s_1213_12 -> bv
        let s_1213_13: Bits = Bits::new(s_1213_12 as u128, 9u16);
        // D s_1213_14: cmp-eq s_1213_11 s_1213_13
        let s_1213_14: bool = ((s_1213_11) == (s_1213_13));
        // N s_1213_15: branch s_1213_14 b1898 b1214
        if s_1213_14 {
            return block_1898(state, tracer, fn_state);
        } else {
            return block_1214(state, tracer, fn_state);
        };
    }
    fn block_1214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1214_0: const #0u : u8
        let s_1214_0: bool = false;
        // D s_1214_1: write-var gs#402624 <= s_1214_0
        fn_state.gs_402624 = s_1214_0;
        // N s_1214_2: jump b1215
        return block_1215(state, tracer, fn_state);
    }
    fn block_1215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1215_0: read-var gs#402624:u8
        let s_1215_0: bool = fn_state.gs_402624;
        // N s_1215_1: branch s_1215_0 b1897 b1216
        if s_1215_0 {
            return block_1897(state, tracer, fn_state);
        } else {
            return block_1216(state, tracer, fn_state);
        };
    }
    fn block_1216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1216_0: const #0u : u8
        let s_1216_0: bool = false;
        // D s_1216_1: write-var gs#402626 <= s_1216_0
        fn_state.gs_402626 = s_1216_0;
        // N s_1216_2: jump b1217
        return block_1217(state, tracer, fn_state);
    }
    fn block_1217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1217_0: read-var gs#402626:u8
        let s_1217_0: bool = fn_state.gs_402626;
        // D s_1217_1: not s_1217_0
        let s_1217_1: bool = !s_1217_0;
        // N s_1217_2: branch s_1217_1 b1219 b1218
        if s_1217_1 {
            return block_1219(state, tracer, fn_state);
        } else {
            return block_1218(state, tracer, fn_state);
        };
    }
    fn block_1218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1218_0: const #3718s : i
        let s_1218_0: i128 = 3718;
        // C s_1218_1: const #14696u : u32
        let s_1218_1: u32 = 14696;
        // N s_1218_2: write-reg s_1218_1 <= s_1218_0
        let s_1218_2: () = {
            state.write_register::<i128>(s_1218_1 as isize, s_1218_0);
            tracer.write_register(s_1218_1 as isize, s_1218_0);
        };
        // C s_1218_3: const #22s : i
        let s_1218_3: i128 = 22;
        // C s_1218_4: const #1s : i
        let s_1218_4: i128 = 1;
        // D s_1218_5: read-var u#32011:u32
        let s_1218_5: u32 = fn_state.u_32011;
        // D s_1218_6: cast zx s_1218_5 -> bv
        let s_1218_6: Bits = Bits::new(s_1218_5 as u128, 32u16);
        // D s_1218_7: bit-extract s_1218_6 s_1218_3 s_1218_4
        let s_1218_7: Bits = (Bits::new(
            ((s_1218_6) >> (s_1218_3)).value(),
            u16::try_from(s_1218_4).unwrap(),
        ));
        // D s_1218_8: cast reint s_1218_7 -> u8
        let s_1218_8: bool = ((s_1218_7.value()) != 0);
        // C s_1218_9: const #16s : i
        let s_1218_9: i128 = 16;
        // C s_1218_10: const #4s : i
        let s_1218_10: i128 = 4;
        // D s_1218_11: read-var u#32011:u32
        let s_1218_11: u32 = fn_state.u_32011;
        // D s_1218_12: cast zx s_1218_11 -> bv
        let s_1218_12: Bits = Bits::new(s_1218_11 as u128, 32u16);
        // D s_1218_13: bit-extract s_1218_12 s_1218_9 s_1218_10
        let s_1218_13: Bits = (Bits::new(
            ((s_1218_12) >> (s_1218_9)).value(),
            u16::try_from(s_1218_10).unwrap(),
        ));
        // D s_1218_14: cast reint s_1218_13 -> u8
        let s_1218_14: u8 = (s_1218_13.value() as u8);
        // C s_1218_15: const #12s : i
        let s_1218_15: i128 = 12;
        // C s_1218_16: const #4s : i
        let s_1218_16: i128 = 4;
        // D s_1218_17: read-var u#32011:u32
        let s_1218_17: u32 = fn_state.u_32011;
        // D s_1218_18: cast zx s_1218_17 -> bv
        let s_1218_18: Bits = Bits::new(s_1218_17 as u128, 32u16);
        // D s_1218_19: bit-extract s_1218_18 s_1218_15 s_1218_16
        let s_1218_19: Bits = (Bits::new(
            ((s_1218_18) >> (s_1218_15)).value(),
            u16::try_from(s_1218_16).unwrap(),
        ));
        // D s_1218_20: cast reint s_1218_19 -> u8
        let s_1218_20: u8 = (s_1218_19.value() as u8);
        // C s_1218_21: const #10s : i
        let s_1218_21: i128 = 10;
        // C s_1218_22: const #2s : i
        let s_1218_22: i128 = 2;
        // D s_1218_23: read-var u#32011:u32
        let s_1218_23: u32 = fn_state.u_32011;
        // D s_1218_24: cast zx s_1218_23 -> bv
        let s_1218_24: Bits = Bits::new(s_1218_23 as u128, 32u16);
        // D s_1218_25: bit-extract s_1218_24 s_1218_21 s_1218_22
        let s_1218_25: Bits = (Bits::new(
            ((s_1218_24) >> (s_1218_21)).value(),
            u16::try_from(s_1218_22).unwrap(),
        ));
        // D s_1218_26: cast reint s_1218_25 -> u8
        let s_1218_26: u8 = (s_1218_25.value() as u8);
        // C s_1218_27: const #4s : i
        let s_1218_27: i128 = 4;
        // C s_1218_28: const #4s : i
        let s_1218_28: i128 = 4;
        // D s_1218_29: read-var u#32011:u32
        let s_1218_29: u32 = fn_state.u_32011;
        // D s_1218_30: cast zx s_1218_29 -> bv
        let s_1218_30: Bits = Bits::new(s_1218_29 as u128, 32u16);
        // D s_1218_31: bit-extract s_1218_30 s_1218_27 s_1218_28
        let s_1218_31: Bits = (Bits::new(
            ((s_1218_30) >> (s_1218_27)).value(),
            u16::try_from(s_1218_28).unwrap(),
        ));
        // D s_1218_32: cast reint s_1218_31 -> u8
        let s_1218_32: u8 = (s_1218_31.value() as u8);
        // C s_1218_33: const #0s : i
        let s_1218_33: i128 = 0;
        // C s_1218_34: const #4s : i
        let s_1218_34: i128 = 4;
        // D s_1218_35: read-var u#32011:u32
        let s_1218_35: u32 = fn_state.u_32011;
        // D s_1218_36: cast zx s_1218_35 -> bv
        let s_1218_36: Bits = Bits::new(s_1218_35 as u128, 32u16);
        // D s_1218_37: bit-extract s_1218_36 s_1218_33 s_1218_34
        let s_1218_37: Bits = (Bits::new(
            ((s_1218_36) >> (s_1218_33)).value(),
            u16::try_from(s_1218_34).unwrap(),
        ));
        // D s_1218_38: cast reint s_1218_37 -> u8
        let s_1218_38: u8 = (s_1218_37.value() as u8);
        // D s_1218_39: call decode_aarch32_instrs_VST3_1_A3enc_A_txt(s_1218_8, s_1218_14, s_1218_20, s_1218_26, s_1218_32, s_1218_38)
        let s_1218_39: () = decode_aarch32_instrs_VST3_1_A3enc_A_txt(
            state,
            tracer,
            s_1218_8,
            s_1218_14,
            s_1218_20,
            s_1218_26,
            s_1218_32,
            s_1218_38,
        );
        // N s_1218_40: return
        return;
    }
    fn block_1219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1219_0: read-var merge#var.1:struct
        let s_1219_0: u32 = fn_state.merge_var._1;
        // D s_1219_1: write-var u#32019 <= s_1219_0
        fn_state.u_32019 = s_1219_0;
        // C s_1219_2: const #23s : i
        let s_1219_2: i128 = 23;
        // D s_1219_3: read-var u#32019:u32
        let s_1219_3: u32 = fn_state.u_32019;
        // D s_1219_4: cast zx s_1219_3 -> bv
        let s_1219_4: Bits = Bits::new(s_1219_3 as u128, 32u16);
        // C s_1219_5: const #1s : i64
        let s_1219_5: i64 = 1;
        // C s_1219_6: cast zx s_1219_5 -> i
        let s_1219_6: i128 = (i128::try_from(s_1219_5).unwrap());
        // C s_1219_7: const #8s : i
        let s_1219_7: i128 = 8;
        // C s_1219_8: add s_1219_7 s_1219_6
        let s_1219_8: i128 = (s_1219_7 + s_1219_6);
        // D s_1219_9: bit-extract s_1219_4 s_1219_2 s_1219_8
        let s_1219_9: Bits = (Bits::new(
            ((s_1219_4) >> (s_1219_2)).value(),
            u16::try_from(s_1219_8).unwrap(),
        ));
        // D s_1219_10: cast reint s_1219_9 -> u9
        let s_1219_10: u16 = (s_1219_9.value() as u16);
        // D s_1219_11: cast zx s_1219_10 -> bv
        let s_1219_11: Bits = Bits::new(s_1219_10 as u128, 9u16);
        // C s_1219_12: const #488u : u9
        let s_1219_12: u16 = 488;
        // C s_1219_13: cast zx s_1219_12 -> bv
        let s_1219_13: Bits = Bits::new(s_1219_12 as u128, 9u16);
        // D s_1219_14: cmp-eq s_1219_11 s_1219_13
        let s_1219_14: bool = ((s_1219_11) == (s_1219_13));
        // N s_1219_15: branch s_1219_14 b1893 b1220
        if s_1219_14 {
            return block_1893(state, tracer, fn_state);
        } else {
            return block_1220(state, tracer, fn_state);
        };
    }
    fn block_1220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1220_0: const #0u : u8
        let s_1220_0: bool = false;
        // D s_1220_1: write-var gs#402649 <= s_1220_0
        fn_state.gs_402649 = s_1220_0;
        // N s_1220_2: jump b1221
        return block_1221(state, tracer, fn_state);
    }
    fn block_1221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1221_0: read-var gs#402649:u8
        let s_1221_0: bool = fn_state.gs_402649;
        // N s_1221_1: branch s_1221_0 b1892 b1222
        if s_1221_0 {
            return block_1892(state, tracer, fn_state);
        } else {
            return block_1222(state, tracer, fn_state);
        };
    }
    fn block_1222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1222_0: const #0u : u8
        let s_1222_0: bool = false;
        // D s_1222_1: write-var gs#402651 <= s_1222_0
        fn_state.gs_402651 = s_1222_0;
        // N s_1222_2: jump b1223
        return block_1223(state, tracer, fn_state);
    }
    fn block_1223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1223_0: read-var gs#402651:u8
        let s_1223_0: bool = fn_state.gs_402651;
        // D s_1223_1: not s_1223_0
        let s_1223_1: bool = !s_1223_0;
        // N s_1223_2: branch s_1223_1 b1225 b1224
        if s_1223_1 {
            return block_1225(state, tracer, fn_state);
        } else {
            return block_1224(state, tracer, fn_state);
        };
    }
    fn block_1224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1224_0: const #3722s : i
        let s_1224_0: i128 = 3722;
        // C s_1224_1: const #14696u : u32
        let s_1224_1: u32 = 14696;
        // N s_1224_2: write-reg s_1224_1 <= s_1224_0
        let s_1224_2: () = {
            state.write_register::<i128>(s_1224_1 as isize, s_1224_0);
            tracer.write_register(s_1224_1 as isize, s_1224_0);
        };
        // C s_1224_3: const #22s : i
        let s_1224_3: i128 = 22;
        // C s_1224_4: const #1s : i
        let s_1224_4: i128 = 1;
        // D s_1224_5: read-var u#32019:u32
        let s_1224_5: u32 = fn_state.u_32019;
        // D s_1224_6: cast zx s_1224_5 -> bv
        let s_1224_6: Bits = Bits::new(s_1224_5 as u128, 32u16);
        // D s_1224_7: bit-extract s_1224_6 s_1224_3 s_1224_4
        let s_1224_7: Bits = (Bits::new(
            ((s_1224_6) >> (s_1224_3)).value(),
            u16::try_from(s_1224_4).unwrap(),
        ));
        // D s_1224_8: cast reint s_1224_7 -> u8
        let s_1224_8: bool = ((s_1224_7.value()) != 0);
        // C s_1224_9: const #16s : i
        let s_1224_9: i128 = 16;
        // C s_1224_10: const #4s : i
        let s_1224_10: i128 = 4;
        // D s_1224_11: read-var u#32019:u32
        let s_1224_11: u32 = fn_state.u_32019;
        // D s_1224_12: cast zx s_1224_11 -> bv
        let s_1224_12: Bits = Bits::new(s_1224_11 as u128, 32u16);
        // D s_1224_13: bit-extract s_1224_12 s_1224_9 s_1224_10
        let s_1224_13: Bits = (Bits::new(
            ((s_1224_12) >> (s_1224_9)).value(),
            u16::try_from(s_1224_10).unwrap(),
        ));
        // D s_1224_14: cast reint s_1224_13 -> u8
        let s_1224_14: u8 = (s_1224_13.value() as u8);
        // C s_1224_15: const #12s : i
        let s_1224_15: i128 = 12;
        // C s_1224_16: const #4s : i
        let s_1224_16: i128 = 4;
        // D s_1224_17: read-var u#32019:u32
        let s_1224_17: u32 = fn_state.u_32019;
        // D s_1224_18: cast zx s_1224_17 -> bv
        let s_1224_18: Bits = Bits::new(s_1224_17 as u128, 32u16);
        // D s_1224_19: bit-extract s_1224_18 s_1224_15 s_1224_16
        let s_1224_19: Bits = (Bits::new(
            ((s_1224_18) >> (s_1224_15)).value(),
            u16::try_from(s_1224_16).unwrap(),
        ));
        // D s_1224_20: cast reint s_1224_19 -> u8
        let s_1224_20: u8 = (s_1224_19.value() as u8);
        // C s_1224_21: const #8s : i
        let s_1224_21: i128 = 8;
        // C s_1224_22: const #4s : i
        let s_1224_22: i128 = 4;
        // D s_1224_23: read-var u#32019:u32
        let s_1224_23: u32 = fn_state.u_32019;
        // D s_1224_24: cast zx s_1224_23 -> bv
        let s_1224_24: Bits = Bits::new(s_1224_23 as u128, 32u16);
        // D s_1224_25: bit-extract s_1224_24 s_1224_21 s_1224_22
        let s_1224_25: Bits = (Bits::new(
            ((s_1224_24) >> (s_1224_21)).value(),
            u16::try_from(s_1224_22).unwrap(),
        ));
        // D s_1224_26: cast reint s_1224_25 -> u8
        let s_1224_26: u8 = (s_1224_25.value() as u8);
        // C s_1224_27: const #6s : i
        let s_1224_27: i128 = 6;
        // C s_1224_28: const #2s : i
        let s_1224_28: i128 = 2;
        // D s_1224_29: read-var u#32019:u32
        let s_1224_29: u32 = fn_state.u_32019;
        // D s_1224_30: cast zx s_1224_29 -> bv
        let s_1224_30: Bits = Bits::new(s_1224_29 as u128, 32u16);
        // D s_1224_31: bit-extract s_1224_30 s_1224_27 s_1224_28
        let s_1224_31: Bits = (Bits::new(
            ((s_1224_30) >> (s_1224_27)).value(),
            u16::try_from(s_1224_28).unwrap(),
        ));
        // D s_1224_32: cast reint s_1224_31 -> u8
        let s_1224_32: u8 = (s_1224_31.value() as u8);
        // C s_1224_33: const #4s : i
        let s_1224_33: i128 = 4;
        // C s_1224_34: const #2s : i
        let s_1224_34: i128 = 2;
        // D s_1224_35: read-var u#32019:u32
        let s_1224_35: u32 = fn_state.u_32019;
        // D s_1224_36: cast zx s_1224_35 -> bv
        let s_1224_36: Bits = Bits::new(s_1224_35 as u128, 32u16);
        // D s_1224_37: bit-extract s_1224_36 s_1224_33 s_1224_34
        let s_1224_37: Bits = (Bits::new(
            ((s_1224_36) >> (s_1224_33)).value(),
            u16::try_from(s_1224_34).unwrap(),
        ));
        // D s_1224_38: cast reint s_1224_37 -> u8
        let s_1224_38: u8 = (s_1224_37.value() as u8);
        // C s_1224_39: const #0s : i
        let s_1224_39: i128 = 0;
        // C s_1224_40: const #4s : i
        let s_1224_40: i128 = 4;
        // D s_1224_41: read-var u#32019:u32
        let s_1224_41: u32 = fn_state.u_32019;
        // D s_1224_42: cast zx s_1224_41 -> bv
        let s_1224_42: Bits = Bits::new(s_1224_41 as u128, 32u16);
        // D s_1224_43: bit-extract s_1224_42 s_1224_39 s_1224_40
        let s_1224_43: Bits = (Bits::new(
            ((s_1224_42) >> (s_1224_39)).value(),
            u16::try_from(s_1224_40).unwrap(),
        ));
        // D s_1224_44: cast reint s_1224_43 -> u8
        let s_1224_44: u8 = (s_1224_43.value() as u8);
        // D s_1224_45: call decode_aarch32_instrs_VST3_m_A1enc_A_txt(s_1224_8, s_1224_14, s_1224_20, s_1224_26, s_1224_32, s_1224_38, s_1224_44)
        let s_1224_45: () = decode_aarch32_instrs_VST3_m_A1enc_A_txt(
            state,
            tracer,
            s_1224_8,
            s_1224_14,
            s_1224_20,
            s_1224_26,
            s_1224_32,
            s_1224_38,
            s_1224_44,
        );
        // N s_1224_46: return
        return;
    }
    fn block_1225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1225_0: read-var merge#var.1:struct
        let s_1225_0: u32 = fn_state.merge_var._1;
        // D s_1225_1: write-var u#32028 <= s_1225_0
        fn_state.u_32028 = s_1225_0;
        // C s_1225_2: const #23s : i
        let s_1225_2: i128 = 23;
        // D s_1225_3: read-var u#32028:u32
        let s_1225_3: u32 = fn_state.u_32028;
        // D s_1225_4: cast zx s_1225_3 -> bv
        let s_1225_4: Bits = Bits::new(s_1225_3 as u128, 32u16);
        // C s_1225_5: const #1s : i64
        let s_1225_5: i64 = 1;
        // C s_1225_6: cast zx s_1225_5 -> i
        let s_1225_6: i128 = (i128::try_from(s_1225_5).unwrap());
        // C s_1225_7: const #8s : i
        let s_1225_7: i128 = 8;
        // C s_1225_8: add s_1225_7 s_1225_6
        let s_1225_8: i128 = (s_1225_7 + s_1225_6);
        // D s_1225_9: bit-extract s_1225_4 s_1225_2 s_1225_8
        let s_1225_9: Bits = (Bits::new(
            ((s_1225_4) >> (s_1225_2)).value(),
            u16::try_from(s_1225_8).unwrap(),
        ));
        // D s_1225_10: cast reint s_1225_9 -> u9
        let s_1225_10: u16 = (s_1225_9.value() as u16);
        // D s_1225_11: cast zx s_1225_10 -> bv
        let s_1225_11: Bits = Bits::new(s_1225_10 as u128, 9u16);
        // C s_1225_12: const #489u : u9
        let s_1225_12: u16 = 489;
        // C s_1225_13: cast zx s_1225_12 -> bv
        let s_1225_13: Bits = Bits::new(s_1225_12 as u128, 9u16);
        // D s_1225_14: cmp-eq s_1225_11 s_1225_13
        let s_1225_14: bool = ((s_1225_11) == (s_1225_13));
        // N s_1225_15: branch s_1225_14 b1888 b1226
        if s_1225_14 {
            return block_1888(state, tracer, fn_state);
        } else {
            return block_1226(state, tracer, fn_state);
        };
    }
    fn block_1226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1226_0: const #0u : u8
        let s_1226_0: bool = false;
        // D s_1226_1: write-var gs#402676 <= s_1226_0
        fn_state.gs_402676 = s_1226_0;
        // N s_1226_2: jump b1227
        return block_1227(state, tracer, fn_state);
    }
    fn block_1227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1227_0: read-var gs#402676:u8
        let s_1227_0: bool = fn_state.gs_402676;
        // N s_1227_1: branch s_1227_0 b1887 b1228
        if s_1227_0 {
            return block_1887(state, tracer, fn_state);
        } else {
            return block_1228(state, tracer, fn_state);
        };
    }
    fn block_1228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1228_0: const #0u : u8
        let s_1228_0: bool = false;
        // D s_1228_1: write-var gs#402678 <= s_1228_0
        fn_state.gs_402678 = s_1228_0;
        // N s_1228_2: jump b1229
        return block_1229(state, tracer, fn_state);
    }
    fn block_1229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1229_0: read-var gs#402678:u8
        let s_1229_0: bool = fn_state.gs_402678;
        // D s_1229_1: not s_1229_0
        let s_1229_1: bool = !s_1229_0;
        // N s_1229_2: branch s_1229_1 b1231 b1230
        if s_1229_1 {
            return block_1231(state, tracer, fn_state);
        } else {
            return block_1230(state, tracer, fn_state);
        };
    }
    fn block_1230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1230_0: const #3724s : i
        let s_1230_0: i128 = 3724;
        // C s_1230_1: const #14696u : u32
        let s_1230_1: u32 = 14696;
        // N s_1230_2: write-reg s_1230_1 <= s_1230_0
        let s_1230_2: () = {
            state.write_register::<i128>(s_1230_1 as isize, s_1230_0);
            tracer.write_register(s_1230_1 as isize, s_1230_0);
        };
        // C s_1230_3: const #22s : i
        let s_1230_3: i128 = 22;
        // C s_1230_4: const #1s : i
        let s_1230_4: i128 = 1;
        // D s_1230_5: read-var u#32028:u32
        let s_1230_5: u32 = fn_state.u_32028;
        // D s_1230_6: cast zx s_1230_5 -> bv
        let s_1230_6: Bits = Bits::new(s_1230_5 as u128, 32u16);
        // D s_1230_7: bit-extract s_1230_6 s_1230_3 s_1230_4
        let s_1230_7: Bits = (Bits::new(
            ((s_1230_6) >> (s_1230_3)).value(),
            u16::try_from(s_1230_4).unwrap(),
        ));
        // D s_1230_8: cast reint s_1230_7 -> u8
        let s_1230_8: bool = ((s_1230_7.value()) != 0);
        // C s_1230_9: const #16s : i
        let s_1230_9: i128 = 16;
        // C s_1230_10: const #4s : i
        let s_1230_10: i128 = 4;
        // D s_1230_11: read-var u#32028:u32
        let s_1230_11: u32 = fn_state.u_32028;
        // D s_1230_12: cast zx s_1230_11 -> bv
        let s_1230_12: Bits = Bits::new(s_1230_11 as u128, 32u16);
        // D s_1230_13: bit-extract s_1230_12 s_1230_9 s_1230_10
        let s_1230_13: Bits = (Bits::new(
            ((s_1230_12) >> (s_1230_9)).value(),
            u16::try_from(s_1230_10).unwrap(),
        ));
        // D s_1230_14: cast reint s_1230_13 -> u8
        let s_1230_14: u8 = (s_1230_13.value() as u8);
        // C s_1230_15: const #12s : i
        let s_1230_15: i128 = 12;
        // C s_1230_16: const #4s : i
        let s_1230_16: i128 = 4;
        // D s_1230_17: read-var u#32028:u32
        let s_1230_17: u32 = fn_state.u_32028;
        // D s_1230_18: cast zx s_1230_17 -> bv
        let s_1230_18: Bits = Bits::new(s_1230_17 as u128, 32u16);
        // D s_1230_19: bit-extract s_1230_18 s_1230_15 s_1230_16
        let s_1230_19: Bits = (Bits::new(
            ((s_1230_18) >> (s_1230_15)).value(),
            u16::try_from(s_1230_16).unwrap(),
        ));
        // D s_1230_20: cast reint s_1230_19 -> u8
        let s_1230_20: u8 = (s_1230_19.value() as u8);
        // C s_1230_21: const #10s : i
        let s_1230_21: i128 = 10;
        // C s_1230_22: const #2s : i
        let s_1230_22: i128 = 2;
        // D s_1230_23: read-var u#32028:u32
        let s_1230_23: u32 = fn_state.u_32028;
        // D s_1230_24: cast zx s_1230_23 -> bv
        let s_1230_24: Bits = Bits::new(s_1230_23 as u128, 32u16);
        // D s_1230_25: bit-extract s_1230_24 s_1230_21 s_1230_22
        let s_1230_25: Bits = (Bits::new(
            ((s_1230_24) >> (s_1230_21)).value(),
            u16::try_from(s_1230_22).unwrap(),
        ));
        // D s_1230_26: cast reint s_1230_25 -> u8
        let s_1230_26: u8 = (s_1230_25.value() as u8);
        // C s_1230_27: const #4s : i
        let s_1230_27: i128 = 4;
        // C s_1230_28: const #4s : i
        let s_1230_28: i128 = 4;
        // D s_1230_29: read-var u#32028:u32
        let s_1230_29: u32 = fn_state.u_32028;
        // D s_1230_30: cast zx s_1230_29 -> bv
        let s_1230_30: Bits = Bits::new(s_1230_29 as u128, 32u16);
        // D s_1230_31: bit-extract s_1230_30 s_1230_27 s_1230_28
        let s_1230_31: Bits = (Bits::new(
            ((s_1230_30) >> (s_1230_27)).value(),
            u16::try_from(s_1230_28).unwrap(),
        ));
        // D s_1230_32: cast reint s_1230_31 -> u8
        let s_1230_32: u8 = (s_1230_31.value() as u8);
        // C s_1230_33: const #0s : i
        let s_1230_33: i128 = 0;
        // C s_1230_34: const #4s : i
        let s_1230_34: i128 = 4;
        // D s_1230_35: read-var u#32028:u32
        let s_1230_35: u32 = fn_state.u_32028;
        // D s_1230_36: cast zx s_1230_35 -> bv
        let s_1230_36: Bits = Bits::new(s_1230_35 as u128, 32u16);
        // D s_1230_37: bit-extract s_1230_36 s_1230_33 s_1230_34
        let s_1230_37: Bits = (Bits::new(
            ((s_1230_36) >> (s_1230_33)).value(),
            u16::try_from(s_1230_34).unwrap(),
        ));
        // D s_1230_38: cast reint s_1230_37 -> u8
        let s_1230_38: u8 = (s_1230_37.value() as u8);
        // D s_1230_39: call decode_aarch32_instrs_VST4_1_A1enc_A_txt(s_1230_8, s_1230_14, s_1230_20, s_1230_26, s_1230_32, s_1230_38)
        let s_1230_39: () = decode_aarch32_instrs_VST4_1_A1enc_A_txt(
            state,
            tracer,
            s_1230_8,
            s_1230_14,
            s_1230_20,
            s_1230_26,
            s_1230_32,
            s_1230_38,
        );
        // N s_1230_40: return
        return;
    }
    fn block_1231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1231_0: read-var merge#var.1:struct
        let s_1231_0: u32 = fn_state.merge_var._1;
        // D s_1231_1: write-var u#32036 <= s_1231_0
        fn_state.u_32036 = s_1231_0;
        // C s_1231_2: const #23s : i
        let s_1231_2: i128 = 23;
        // D s_1231_3: read-var u#32036:u32
        let s_1231_3: u32 = fn_state.u_32036;
        // D s_1231_4: cast zx s_1231_3 -> bv
        let s_1231_4: Bits = Bits::new(s_1231_3 as u128, 32u16);
        // C s_1231_5: const #1s : i64
        let s_1231_5: i64 = 1;
        // C s_1231_6: cast zx s_1231_5 -> i
        let s_1231_6: i128 = (i128::try_from(s_1231_5).unwrap());
        // C s_1231_7: const #8s : i
        let s_1231_7: i128 = 8;
        // C s_1231_8: add s_1231_7 s_1231_6
        let s_1231_8: i128 = (s_1231_7 + s_1231_6);
        // D s_1231_9: bit-extract s_1231_4 s_1231_2 s_1231_8
        let s_1231_9: Bits = (Bits::new(
            ((s_1231_4) >> (s_1231_2)).value(),
            u16::try_from(s_1231_8).unwrap(),
        ));
        // D s_1231_10: cast reint s_1231_9 -> u9
        let s_1231_10: u16 = (s_1231_9.value() as u16);
        // D s_1231_11: cast zx s_1231_10 -> bv
        let s_1231_11: Bits = Bits::new(s_1231_10 as u128, 9u16);
        // C s_1231_12: const #489u : u9
        let s_1231_12: u16 = 489;
        // C s_1231_13: cast zx s_1231_12 -> bv
        let s_1231_13: Bits = Bits::new(s_1231_12 as u128, 9u16);
        // D s_1231_14: cmp-eq s_1231_11 s_1231_13
        let s_1231_14: bool = ((s_1231_11) == (s_1231_13));
        // N s_1231_15: branch s_1231_14 b1883 b1232
        if s_1231_14 {
            return block_1883(state, tracer, fn_state);
        } else {
            return block_1232(state, tracer, fn_state);
        };
    }
    fn block_1232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1232_0: const #0u : u8
        let s_1232_0: bool = false;
        // D s_1232_1: write-var gs#402701 <= s_1232_0
        fn_state.gs_402701 = s_1232_0;
        // N s_1232_2: jump b1233
        return block_1233(state, tracer, fn_state);
    }
    fn block_1233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1233_0: read-var gs#402701:u8
        let s_1233_0: bool = fn_state.gs_402701;
        // N s_1233_1: branch s_1233_0 b1882 b1234
        if s_1233_0 {
            return block_1882(state, tracer, fn_state);
        } else {
            return block_1234(state, tracer, fn_state);
        };
    }
    fn block_1234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1234_0: const #0u : u8
        let s_1234_0: bool = false;
        // D s_1234_1: write-var gs#402703 <= s_1234_0
        fn_state.gs_402703 = s_1234_0;
        // N s_1234_2: jump b1235
        return block_1235(state, tracer, fn_state);
    }
    fn block_1235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1235_0: read-var gs#402703:u8
        let s_1235_0: bool = fn_state.gs_402703;
        // D s_1235_1: not s_1235_0
        let s_1235_1: bool = !s_1235_0;
        // N s_1235_2: branch s_1235_1 b1237 b1236
        if s_1235_1 {
            return block_1237(state, tracer, fn_state);
        } else {
            return block_1236(state, tracer, fn_state);
        };
    }
    fn block_1236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1236_0: const #3725s : i
        let s_1236_0: i128 = 3725;
        // C s_1236_1: const #14696u : u32
        let s_1236_1: u32 = 14696;
        // N s_1236_2: write-reg s_1236_1 <= s_1236_0
        let s_1236_2: () = {
            state.write_register::<i128>(s_1236_1 as isize, s_1236_0);
            tracer.write_register(s_1236_1 as isize, s_1236_0);
        };
        // C s_1236_3: const #22s : i
        let s_1236_3: i128 = 22;
        // C s_1236_4: const #1s : i
        let s_1236_4: i128 = 1;
        // D s_1236_5: read-var u#32036:u32
        let s_1236_5: u32 = fn_state.u_32036;
        // D s_1236_6: cast zx s_1236_5 -> bv
        let s_1236_6: Bits = Bits::new(s_1236_5 as u128, 32u16);
        // D s_1236_7: bit-extract s_1236_6 s_1236_3 s_1236_4
        let s_1236_7: Bits = (Bits::new(
            ((s_1236_6) >> (s_1236_3)).value(),
            u16::try_from(s_1236_4).unwrap(),
        ));
        // D s_1236_8: cast reint s_1236_7 -> u8
        let s_1236_8: bool = ((s_1236_7.value()) != 0);
        // C s_1236_9: const #16s : i
        let s_1236_9: i128 = 16;
        // C s_1236_10: const #4s : i
        let s_1236_10: i128 = 4;
        // D s_1236_11: read-var u#32036:u32
        let s_1236_11: u32 = fn_state.u_32036;
        // D s_1236_12: cast zx s_1236_11 -> bv
        let s_1236_12: Bits = Bits::new(s_1236_11 as u128, 32u16);
        // D s_1236_13: bit-extract s_1236_12 s_1236_9 s_1236_10
        let s_1236_13: Bits = (Bits::new(
            ((s_1236_12) >> (s_1236_9)).value(),
            u16::try_from(s_1236_10).unwrap(),
        ));
        // D s_1236_14: cast reint s_1236_13 -> u8
        let s_1236_14: u8 = (s_1236_13.value() as u8);
        // C s_1236_15: const #12s : i
        let s_1236_15: i128 = 12;
        // C s_1236_16: const #4s : i
        let s_1236_16: i128 = 4;
        // D s_1236_17: read-var u#32036:u32
        let s_1236_17: u32 = fn_state.u_32036;
        // D s_1236_18: cast zx s_1236_17 -> bv
        let s_1236_18: Bits = Bits::new(s_1236_17 as u128, 32u16);
        // D s_1236_19: bit-extract s_1236_18 s_1236_15 s_1236_16
        let s_1236_19: Bits = (Bits::new(
            ((s_1236_18) >> (s_1236_15)).value(),
            u16::try_from(s_1236_16).unwrap(),
        ));
        // D s_1236_20: cast reint s_1236_19 -> u8
        let s_1236_20: u8 = (s_1236_19.value() as u8);
        // C s_1236_21: const #10s : i
        let s_1236_21: i128 = 10;
        // C s_1236_22: const #2s : i
        let s_1236_22: i128 = 2;
        // D s_1236_23: read-var u#32036:u32
        let s_1236_23: u32 = fn_state.u_32036;
        // D s_1236_24: cast zx s_1236_23 -> bv
        let s_1236_24: Bits = Bits::new(s_1236_23 as u128, 32u16);
        // D s_1236_25: bit-extract s_1236_24 s_1236_21 s_1236_22
        let s_1236_25: Bits = (Bits::new(
            ((s_1236_24) >> (s_1236_21)).value(),
            u16::try_from(s_1236_22).unwrap(),
        ));
        // D s_1236_26: cast reint s_1236_25 -> u8
        let s_1236_26: u8 = (s_1236_25.value() as u8);
        // C s_1236_27: const #4s : i
        let s_1236_27: i128 = 4;
        // C s_1236_28: const #4s : i
        let s_1236_28: i128 = 4;
        // D s_1236_29: read-var u#32036:u32
        let s_1236_29: u32 = fn_state.u_32036;
        // D s_1236_30: cast zx s_1236_29 -> bv
        let s_1236_30: Bits = Bits::new(s_1236_29 as u128, 32u16);
        // D s_1236_31: bit-extract s_1236_30 s_1236_27 s_1236_28
        let s_1236_31: Bits = (Bits::new(
            ((s_1236_30) >> (s_1236_27)).value(),
            u16::try_from(s_1236_28).unwrap(),
        ));
        // D s_1236_32: cast reint s_1236_31 -> u8
        let s_1236_32: u8 = (s_1236_31.value() as u8);
        // C s_1236_33: const #0s : i
        let s_1236_33: i128 = 0;
        // C s_1236_34: const #4s : i
        let s_1236_34: i128 = 4;
        // D s_1236_35: read-var u#32036:u32
        let s_1236_35: u32 = fn_state.u_32036;
        // D s_1236_36: cast zx s_1236_35 -> bv
        let s_1236_36: Bits = Bits::new(s_1236_35 as u128, 32u16);
        // D s_1236_37: bit-extract s_1236_36 s_1236_33 s_1236_34
        let s_1236_37: Bits = (Bits::new(
            ((s_1236_36) >> (s_1236_33)).value(),
            u16::try_from(s_1236_34).unwrap(),
        ));
        // D s_1236_38: cast reint s_1236_37 -> u8
        let s_1236_38: u8 = (s_1236_37.value() as u8);
        // D s_1236_39: call decode_aarch32_instrs_VST4_1_A2enc_A_txt(s_1236_8, s_1236_14, s_1236_20, s_1236_26, s_1236_32, s_1236_38)
        let s_1236_39: () = decode_aarch32_instrs_VST4_1_A2enc_A_txt(
            state,
            tracer,
            s_1236_8,
            s_1236_14,
            s_1236_20,
            s_1236_26,
            s_1236_32,
            s_1236_38,
        );
        // N s_1236_40: return
        return;
    }
    fn block_1237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1237_0: read-var merge#var.1:struct
        let s_1237_0: u32 = fn_state.merge_var._1;
        // D s_1237_1: write-var u#32044 <= s_1237_0
        fn_state.u_32044 = s_1237_0;
        // C s_1237_2: const #23s : i
        let s_1237_2: i128 = 23;
        // D s_1237_3: read-var u#32044:u32
        let s_1237_3: u32 = fn_state.u_32044;
        // D s_1237_4: cast zx s_1237_3 -> bv
        let s_1237_4: Bits = Bits::new(s_1237_3 as u128, 32u16);
        // C s_1237_5: const #1s : i64
        let s_1237_5: i64 = 1;
        // C s_1237_6: cast zx s_1237_5 -> i
        let s_1237_6: i128 = (i128::try_from(s_1237_5).unwrap());
        // C s_1237_7: const #8s : i
        let s_1237_7: i128 = 8;
        // C s_1237_8: add s_1237_7 s_1237_6
        let s_1237_8: i128 = (s_1237_7 + s_1237_6);
        // D s_1237_9: bit-extract s_1237_4 s_1237_2 s_1237_8
        let s_1237_9: Bits = (Bits::new(
            ((s_1237_4) >> (s_1237_2)).value(),
            u16::try_from(s_1237_8).unwrap(),
        ));
        // D s_1237_10: cast reint s_1237_9 -> u9
        let s_1237_10: u16 = (s_1237_9.value() as u16);
        // D s_1237_11: cast zx s_1237_10 -> bv
        let s_1237_11: Bits = Bits::new(s_1237_10 as u128, 9u16);
        // C s_1237_12: const #489u : u9
        let s_1237_12: u16 = 489;
        // C s_1237_13: cast zx s_1237_12 -> bv
        let s_1237_13: Bits = Bits::new(s_1237_12 as u128, 9u16);
        // D s_1237_14: cmp-eq s_1237_11 s_1237_13
        let s_1237_14: bool = ((s_1237_11) == (s_1237_13));
        // N s_1237_15: branch s_1237_14 b1878 b1238
        if s_1237_14 {
            return block_1878(state, tracer, fn_state);
        } else {
            return block_1238(state, tracer, fn_state);
        };
    }
    fn block_1238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1238_0: const #0u : u8
        let s_1238_0: bool = false;
        // D s_1238_1: write-var gs#402726 <= s_1238_0
        fn_state.gs_402726 = s_1238_0;
        // N s_1238_2: jump b1239
        return block_1239(state, tracer, fn_state);
    }
    fn block_1239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1239_0: read-var gs#402726:u8
        let s_1239_0: bool = fn_state.gs_402726;
        // N s_1239_1: branch s_1239_0 b1877 b1240
        if s_1239_0 {
            return block_1877(state, tracer, fn_state);
        } else {
            return block_1240(state, tracer, fn_state);
        };
    }
    fn block_1240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1240_0: const #0u : u8
        let s_1240_0: bool = false;
        // D s_1240_1: write-var gs#402728 <= s_1240_0
        fn_state.gs_402728 = s_1240_0;
        // N s_1240_2: jump b1241
        return block_1241(state, tracer, fn_state);
    }
    fn block_1241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1241_0: read-var gs#402728:u8
        let s_1241_0: bool = fn_state.gs_402728;
        // D s_1241_1: not s_1241_0
        let s_1241_1: bool = !s_1241_0;
        // N s_1241_2: branch s_1241_1 b1243 b1242
        if s_1241_1 {
            return block_1243(state, tracer, fn_state);
        } else {
            return block_1242(state, tracer, fn_state);
        };
    }
    fn block_1242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1242_0: const #3726s : i
        let s_1242_0: i128 = 3726;
        // C s_1242_1: const #14696u : u32
        let s_1242_1: u32 = 14696;
        // N s_1242_2: write-reg s_1242_1 <= s_1242_0
        let s_1242_2: () = {
            state.write_register::<i128>(s_1242_1 as isize, s_1242_0);
            tracer.write_register(s_1242_1 as isize, s_1242_0);
        };
        // C s_1242_3: const #22s : i
        let s_1242_3: i128 = 22;
        // C s_1242_4: const #1s : i
        let s_1242_4: i128 = 1;
        // D s_1242_5: read-var u#32044:u32
        let s_1242_5: u32 = fn_state.u_32044;
        // D s_1242_6: cast zx s_1242_5 -> bv
        let s_1242_6: Bits = Bits::new(s_1242_5 as u128, 32u16);
        // D s_1242_7: bit-extract s_1242_6 s_1242_3 s_1242_4
        let s_1242_7: Bits = (Bits::new(
            ((s_1242_6) >> (s_1242_3)).value(),
            u16::try_from(s_1242_4).unwrap(),
        ));
        // D s_1242_8: cast reint s_1242_7 -> u8
        let s_1242_8: bool = ((s_1242_7.value()) != 0);
        // C s_1242_9: const #16s : i
        let s_1242_9: i128 = 16;
        // C s_1242_10: const #4s : i
        let s_1242_10: i128 = 4;
        // D s_1242_11: read-var u#32044:u32
        let s_1242_11: u32 = fn_state.u_32044;
        // D s_1242_12: cast zx s_1242_11 -> bv
        let s_1242_12: Bits = Bits::new(s_1242_11 as u128, 32u16);
        // D s_1242_13: bit-extract s_1242_12 s_1242_9 s_1242_10
        let s_1242_13: Bits = (Bits::new(
            ((s_1242_12) >> (s_1242_9)).value(),
            u16::try_from(s_1242_10).unwrap(),
        ));
        // D s_1242_14: cast reint s_1242_13 -> u8
        let s_1242_14: u8 = (s_1242_13.value() as u8);
        // C s_1242_15: const #12s : i
        let s_1242_15: i128 = 12;
        // C s_1242_16: const #4s : i
        let s_1242_16: i128 = 4;
        // D s_1242_17: read-var u#32044:u32
        let s_1242_17: u32 = fn_state.u_32044;
        // D s_1242_18: cast zx s_1242_17 -> bv
        let s_1242_18: Bits = Bits::new(s_1242_17 as u128, 32u16);
        // D s_1242_19: bit-extract s_1242_18 s_1242_15 s_1242_16
        let s_1242_19: Bits = (Bits::new(
            ((s_1242_18) >> (s_1242_15)).value(),
            u16::try_from(s_1242_16).unwrap(),
        ));
        // D s_1242_20: cast reint s_1242_19 -> u8
        let s_1242_20: u8 = (s_1242_19.value() as u8);
        // C s_1242_21: const #10s : i
        let s_1242_21: i128 = 10;
        // C s_1242_22: const #2s : i
        let s_1242_22: i128 = 2;
        // D s_1242_23: read-var u#32044:u32
        let s_1242_23: u32 = fn_state.u_32044;
        // D s_1242_24: cast zx s_1242_23 -> bv
        let s_1242_24: Bits = Bits::new(s_1242_23 as u128, 32u16);
        // D s_1242_25: bit-extract s_1242_24 s_1242_21 s_1242_22
        let s_1242_25: Bits = (Bits::new(
            ((s_1242_24) >> (s_1242_21)).value(),
            u16::try_from(s_1242_22).unwrap(),
        ));
        // D s_1242_26: cast reint s_1242_25 -> u8
        let s_1242_26: u8 = (s_1242_25.value() as u8);
        // C s_1242_27: const #4s : i
        let s_1242_27: i128 = 4;
        // C s_1242_28: const #4s : i
        let s_1242_28: i128 = 4;
        // D s_1242_29: read-var u#32044:u32
        let s_1242_29: u32 = fn_state.u_32044;
        // D s_1242_30: cast zx s_1242_29 -> bv
        let s_1242_30: Bits = Bits::new(s_1242_29 as u128, 32u16);
        // D s_1242_31: bit-extract s_1242_30 s_1242_27 s_1242_28
        let s_1242_31: Bits = (Bits::new(
            ((s_1242_30) >> (s_1242_27)).value(),
            u16::try_from(s_1242_28).unwrap(),
        ));
        // D s_1242_32: cast reint s_1242_31 -> u8
        let s_1242_32: u8 = (s_1242_31.value() as u8);
        // C s_1242_33: const #0s : i
        let s_1242_33: i128 = 0;
        // C s_1242_34: const #4s : i
        let s_1242_34: i128 = 4;
        // D s_1242_35: read-var u#32044:u32
        let s_1242_35: u32 = fn_state.u_32044;
        // D s_1242_36: cast zx s_1242_35 -> bv
        let s_1242_36: Bits = Bits::new(s_1242_35 as u128, 32u16);
        // D s_1242_37: bit-extract s_1242_36 s_1242_33 s_1242_34
        let s_1242_37: Bits = (Bits::new(
            ((s_1242_36) >> (s_1242_33)).value(),
            u16::try_from(s_1242_34).unwrap(),
        ));
        // D s_1242_38: cast reint s_1242_37 -> u8
        let s_1242_38: u8 = (s_1242_37.value() as u8);
        // D s_1242_39: call decode_aarch32_instrs_VST4_1_A3enc_A_txt(s_1242_8, s_1242_14, s_1242_20, s_1242_26, s_1242_32, s_1242_38)
        let s_1242_39: () = decode_aarch32_instrs_VST4_1_A3enc_A_txt(
            state,
            tracer,
            s_1242_8,
            s_1242_14,
            s_1242_20,
            s_1242_26,
            s_1242_32,
            s_1242_38,
        );
        // N s_1242_40: return
        return;
    }
    fn block_1243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1243_0: read-var merge#var.1:struct
        let s_1243_0: u32 = fn_state.merge_var._1;
        // D s_1243_1: write-var u#32052 <= s_1243_0
        fn_state.u_32052 = s_1243_0;
        // C s_1243_2: const #23s : i
        let s_1243_2: i128 = 23;
        // D s_1243_3: read-var u#32052:u32
        let s_1243_3: u32 = fn_state.u_32052;
        // D s_1243_4: cast zx s_1243_3 -> bv
        let s_1243_4: Bits = Bits::new(s_1243_3 as u128, 32u16);
        // C s_1243_5: const #1s : i64
        let s_1243_5: i64 = 1;
        // C s_1243_6: cast zx s_1243_5 -> i
        let s_1243_6: i128 = (i128::try_from(s_1243_5).unwrap());
        // C s_1243_7: const #8s : i
        let s_1243_7: i128 = 8;
        // C s_1243_8: add s_1243_7 s_1243_6
        let s_1243_8: i128 = (s_1243_7 + s_1243_6);
        // D s_1243_9: bit-extract s_1243_4 s_1243_2 s_1243_8
        let s_1243_9: Bits = (Bits::new(
            ((s_1243_4) >> (s_1243_2)).value(),
            u16::try_from(s_1243_8).unwrap(),
        ));
        // D s_1243_10: cast reint s_1243_9 -> u9
        let s_1243_10: u16 = (s_1243_9.value() as u16);
        // D s_1243_11: cast zx s_1243_10 -> bv
        let s_1243_11: Bits = Bits::new(s_1243_10 as u128, 9u16);
        // C s_1243_12: const #488u : u9
        let s_1243_12: u16 = 488;
        // C s_1243_13: cast zx s_1243_12 -> bv
        let s_1243_13: Bits = Bits::new(s_1243_12 as u128, 9u16);
        // D s_1243_14: cmp-eq s_1243_11 s_1243_13
        let s_1243_14: bool = ((s_1243_11) == (s_1243_13));
        // N s_1243_15: branch s_1243_14 b1873 b1244
        if s_1243_14 {
            return block_1873(state, tracer, fn_state);
        } else {
            return block_1244(state, tracer, fn_state);
        };
    }
    fn block_1244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1244_0: const #0u : u8
        let s_1244_0: bool = false;
        // D s_1244_1: write-var gs#402751 <= s_1244_0
        fn_state.gs_402751 = s_1244_0;
        // N s_1244_2: jump b1245
        return block_1245(state, tracer, fn_state);
    }
    fn block_1245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1245_0: read-var gs#402751:u8
        let s_1245_0: bool = fn_state.gs_402751;
        // N s_1245_1: branch s_1245_0 b1872 b1246
        if s_1245_0 {
            return block_1872(state, tracer, fn_state);
        } else {
            return block_1246(state, tracer, fn_state);
        };
    }
    fn block_1246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1246_0: const #0u : u8
        let s_1246_0: bool = false;
        // D s_1246_1: write-var gs#402753 <= s_1246_0
        fn_state.gs_402753 = s_1246_0;
        // N s_1246_2: jump b1247
        return block_1247(state, tracer, fn_state);
    }
    fn block_1247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1247_0: read-var gs#402753:u8
        let s_1247_0: bool = fn_state.gs_402753;
        // D s_1247_1: not s_1247_0
        let s_1247_1: bool = !s_1247_0;
        // N s_1247_2: branch s_1247_1 b1249 b1248
        if s_1247_1 {
            return block_1249(state, tracer, fn_state);
        } else {
            return block_1248(state, tracer, fn_state);
        };
    }
    fn block_1248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1248_0: const #3730s : i
        let s_1248_0: i128 = 3730;
        // C s_1248_1: const #14696u : u32
        let s_1248_1: u32 = 14696;
        // N s_1248_2: write-reg s_1248_1 <= s_1248_0
        let s_1248_2: () = {
            state.write_register::<i128>(s_1248_1 as isize, s_1248_0);
            tracer.write_register(s_1248_1 as isize, s_1248_0);
        };
        // C s_1248_3: const #22s : i
        let s_1248_3: i128 = 22;
        // C s_1248_4: const #1s : i
        let s_1248_4: i128 = 1;
        // D s_1248_5: read-var u#32052:u32
        let s_1248_5: u32 = fn_state.u_32052;
        // D s_1248_6: cast zx s_1248_5 -> bv
        let s_1248_6: Bits = Bits::new(s_1248_5 as u128, 32u16);
        // D s_1248_7: bit-extract s_1248_6 s_1248_3 s_1248_4
        let s_1248_7: Bits = (Bits::new(
            ((s_1248_6) >> (s_1248_3)).value(),
            u16::try_from(s_1248_4).unwrap(),
        ));
        // D s_1248_8: cast reint s_1248_7 -> u8
        let s_1248_8: bool = ((s_1248_7.value()) != 0);
        // C s_1248_9: const #16s : i
        let s_1248_9: i128 = 16;
        // C s_1248_10: const #4s : i
        let s_1248_10: i128 = 4;
        // D s_1248_11: read-var u#32052:u32
        let s_1248_11: u32 = fn_state.u_32052;
        // D s_1248_12: cast zx s_1248_11 -> bv
        let s_1248_12: Bits = Bits::new(s_1248_11 as u128, 32u16);
        // D s_1248_13: bit-extract s_1248_12 s_1248_9 s_1248_10
        let s_1248_13: Bits = (Bits::new(
            ((s_1248_12) >> (s_1248_9)).value(),
            u16::try_from(s_1248_10).unwrap(),
        ));
        // D s_1248_14: cast reint s_1248_13 -> u8
        let s_1248_14: u8 = (s_1248_13.value() as u8);
        // C s_1248_15: const #12s : i
        let s_1248_15: i128 = 12;
        // C s_1248_16: const #4s : i
        let s_1248_16: i128 = 4;
        // D s_1248_17: read-var u#32052:u32
        let s_1248_17: u32 = fn_state.u_32052;
        // D s_1248_18: cast zx s_1248_17 -> bv
        let s_1248_18: Bits = Bits::new(s_1248_17 as u128, 32u16);
        // D s_1248_19: bit-extract s_1248_18 s_1248_15 s_1248_16
        let s_1248_19: Bits = (Bits::new(
            ((s_1248_18) >> (s_1248_15)).value(),
            u16::try_from(s_1248_16).unwrap(),
        ));
        // D s_1248_20: cast reint s_1248_19 -> u8
        let s_1248_20: u8 = (s_1248_19.value() as u8);
        // C s_1248_21: const #8s : i
        let s_1248_21: i128 = 8;
        // C s_1248_22: const #4s : i
        let s_1248_22: i128 = 4;
        // D s_1248_23: read-var u#32052:u32
        let s_1248_23: u32 = fn_state.u_32052;
        // D s_1248_24: cast zx s_1248_23 -> bv
        let s_1248_24: Bits = Bits::new(s_1248_23 as u128, 32u16);
        // D s_1248_25: bit-extract s_1248_24 s_1248_21 s_1248_22
        let s_1248_25: Bits = (Bits::new(
            ((s_1248_24) >> (s_1248_21)).value(),
            u16::try_from(s_1248_22).unwrap(),
        ));
        // D s_1248_26: cast reint s_1248_25 -> u8
        let s_1248_26: u8 = (s_1248_25.value() as u8);
        // C s_1248_27: const #6s : i
        let s_1248_27: i128 = 6;
        // C s_1248_28: const #2s : i
        let s_1248_28: i128 = 2;
        // D s_1248_29: read-var u#32052:u32
        let s_1248_29: u32 = fn_state.u_32052;
        // D s_1248_30: cast zx s_1248_29 -> bv
        let s_1248_30: Bits = Bits::new(s_1248_29 as u128, 32u16);
        // D s_1248_31: bit-extract s_1248_30 s_1248_27 s_1248_28
        let s_1248_31: Bits = (Bits::new(
            ((s_1248_30) >> (s_1248_27)).value(),
            u16::try_from(s_1248_28).unwrap(),
        ));
        // D s_1248_32: cast reint s_1248_31 -> u8
        let s_1248_32: u8 = (s_1248_31.value() as u8);
        // C s_1248_33: const #4s : i
        let s_1248_33: i128 = 4;
        // C s_1248_34: const #2s : i
        let s_1248_34: i128 = 2;
        // D s_1248_35: read-var u#32052:u32
        let s_1248_35: u32 = fn_state.u_32052;
        // D s_1248_36: cast zx s_1248_35 -> bv
        let s_1248_36: Bits = Bits::new(s_1248_35 as u128, 32u16);
        // D s_1248_37: bit-extract s_1248_36 s_1248_33 s_1248_34
        let s_1248_37: Bits = (Bits::new(
            ((s_1248_36) >> (s_1248_33)).value(),
            u16::try_from(s_1248_34).unwrap(),
        ));
        // D s_1248_38: cast reint s_1248_37 -> u8
        let s_1248_38: u8 = (s_1248_37.value() as u8);
        // C s_1248_39: const #0s : i
        let s_1248_39: i128 = 0;
        // C s_1248_40: const #4s : i
        let s_1248_40: i128 = 4;
        // D s_1248_41: read-var u#32052:u32
        let s_1248_41: u32 = fn_state.u_32052;
        // D s_1248_42: cast zx s_1248_41 -> bv
        let s_1248_42: Bits = Bits::new(s_1248_41 as u128, 32u16);
        // D s_1248_43: bit-extract s_1248_42 s_1248_39 s_1248_40
        let s_1248_43: Bits = (Bits::new(
            ((s_1248_42) >> (s_1248_39)).value(),
            u16::try_from(s_1248_40).unwrap(),
        ));
        // D s_1248_44: cast reint s_1248_43 -> u8
        let s_1248_44: u8 = (s_1248_43.value() as u8);
        // D s_1248_45: call decode_aarch32_instrs_VST4_m_A1enc_A_txt(s_1248_8, s_1248_14, s_1248_20, s_1248_26, s_1248_32, s_1248_38, s_1248_44)
        let s_1248_45: () = decode_aarch32_instrs_VST4_m_A1enc_A_txt(
            state,
            tracer,
            s_1248_8,
            s_1248_14,
            s_1248_20,
            s_1248_26,
            s_1248_32,
            s_1248_38,
            s_1248_44,
        );
        // N s_1248_46: return
        return;
    }
    fn block_1249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1249_0: read-var merge#var.1:struct
        let s_1249_0: u32 = fn_state.merge_var._1;
        // D s_1249_1: write-var u#32061 <= s_1249_0
        fn_state.u_32061 = s_1249_0;
        // C s_1249_2: const #23s : i
        let s_1249_2: i128 = 23;
        // D s_1249_3: read-var u#32061:u32
        let s_1249_3: u32 = fn_state.u_32061;
        // D s_1249_4: cast zx s_1249_3 -> bv
        let s_1249_4: Bits = Bits::new(s_1249_3 as u128, 32u16);
        // C s_1249_5: const #1s : i64
        let s_1249_5: i64 = 1;
        // C s_1249_6: cast zx s_1249_5 -> i
        let s_1249_6: i128 = (i128::try_from(s_1249_5).unwrap());
        // C s_1249_7: const #8s : i
        let s_1249_7: i128 = 8;
        // C s_1249_8: add s_1249_7 s_1249_6
        let s_1249_8: i128 = (s_1249_7 + s_1249_6);
        // D s_1249_9: bit-extract s_1249_4 s_1249_2 s_1249_8
        let s_1249_9: Bits = (Bits::new(
            ((s_1249_4) >> (s_1249_2)).value(),
            u16::try_from(s_1249_8).unwrap(),
        ));
        // D s_1249_10: cast reint s_1249_9 -> u9
        let s_1249_10: u16 = (s_1249_9.value() as u16);
        // D s_1249_11: cast zx s_1249_10 -> bv
        let s_1249_11: Bits = Bits::new(s_1249_10 as u128, 9u16);
        // C s_1249_12: const #484u : u9
        let s_1249_12: u16 = 484;
        // C s_1249_13: cast zx s_1249_12 -> bv
        let s_1249_13: Bits = Bits::new(s_1249_12 as u128, 9u16);
        // D s_1249_14: cmp-eq s_1249_11 s_1249_13
        let s_1249_14: bool = ((s_1249_11) == (s_1249_13));
        // N s_1249_15: branch s_1249_14 b1865 b1250
        if s_1249_14 {
            return block_1865(state, tracer, fn_state);
        } else {
            return block_1250(state, tracer, fn_state);
        };
    }
    fn block_1250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1250_0: const #0u : u8
        let s_1250_0: bool = false;
        // D s_1250_1: write-var gs#402781 <= s_1250_0
        fn_state.gs_402781 = s_1250_0;
        // N s_1250_2: jump b1251
        return block_1251(state, tracer, fn_state);
    }
    fn block_1251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1251_0: read-var gs#402781:u8
        let s_1251_0: bool = fn_state.gs_402781;
        // N s_1251_1: branch s_1251_0 b1864 b1252
        if s_1251_0 {
            return block_1864(state, tracer, fn_state);
        } else {
            return block_1252(state, tracer, fn_state);
        };
    }
    fn block_1252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1252_0: const #0u : u8
        let s_1252_0: bool = false;
        // D s_1252_1: write-var gs#402783 <= s_1252_0
        fn_state.gs_402783 = s_1252_0;
        // N s_1252_2: jump b1253
        return block_1253(state, tracer, fn_state);
    }
    fn block_1253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1253_0: read-var gs#402783:u8
        let s_1253_0: bool = fn_state.gs_402783;
        // D s_1253_1: not s_1253_0
        let s_1253_1: bool = !s_1253_0;
        // N s_1253_2: branch s_1253_1 b1255 b1254
        if s_1253_1 {
            return block_1255(state, tracer, fn_state);
        } else {
            return block_1254(state, tracer, fn_state);
        };
    }
    fn block_1254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1254_0: const #3738s : i
        let s_1254_0: i128 = 3738;
        // C s_1254_1: const #14696u : u32
        let s_1254_1: u32 = 14696;
        // N s_1254_2: write-reg s_1254_1 <= s_1254_0
        let s_1254_2: () = {
            state.write_register::<i128>(s_1254_1 as isize, s_1254_0);
            tracer.write_register(s_1254_1 as isize, s_1254_0);
        };
        // C s_1254_3: const #22s : i
        let s_1254_3: i128 = 22;
        // C s_1254_4: const #1s : i
        let s_1254_4: i128 = 1;
        // D s_1254_5: read-var u#32061:u32
        let s_1254_5: u32 = fn_state.u_32061;
        // D s_1254_6: cast zx s_1254_5 -> bv
        let s_1254_6: Bits = Bits::new(s_1254_5 as u128, 32u16);
        // D s_1254_7: bit-extract s_1254_6 s_1254_3 s_1254_4
        let s_1254_7: Bits = (Bits::new(
            ((s_1254_6) >> (s_1254_3)).value(),
            u16::try_from(s_1254_4).unwrap(),
        ));
        // D s_1254_8: cast reint s_1254_7 -> u8
        let s_1254_8: bool = ((s_1254_7.value()) != 0);
        // C s_1254_9: const #20s : i
        let s_1254_9: i128 = 20;
        // C s_1254_10: const #1s : i
        let s_1254_10: i128 = 1;
        // D s_1254_11: read-var u#32061:u32
        let s_1254_11: u32 = fn_state.u_32061;
        // D s_1254_12: cast zx s_1254_11 -> bv
        let s_1254_12: Bits = Bits::new(s_1254_11 as u128, 32u16);
        // D s_1254_13: bit-extract s_1254_12 s_1254_9 s_1254_10
        let s_1254_13: Bits = (Bits::new(
            ((s_1254_12) >> (s_1254_9)).value(),
            u16::try_from(s_1254_10).unwrap(),
        ));
        // D s_1254_14: cast reint s_1254_13 -> u8
        let s_1254_14: bool = ((s_1254_13.value()) != 0);
        // C s_1254_15: const #16s : i
        let s_1254_15: i128 = 16;
        // C s_1254_16: const #4s : i
        let s_1254_16: i128 = 4;
        // D s_1254_17: read-var u#32061:u32
        let s_1254_17: u32 = fn_state.u_32061;
        // D s_1254_18: cast zx s_1254_17 -> bv
        let s_1254_18: Bits = Bits::new(s_1254_17 as u128, 32u16);
        // D s_1254_19: bit-extract s_1254_18 s_1254_15 s_1254_16
        let s_1254_19: Bits = (Bits::new(
            ((s_1254_18) >> (s_1254_15)).value(),
            u16::try_from(s_1254_16).unwrap(),
        ));
        // D s_1254_20: cast reint s_1254_19 -> u8
        let s_1254_20: u8 = (s_1254_19.value() as u8);
        // C s_1254_21: const #12s : i
        let s_1254_21: i128 = 12;
        // C s_1254_22: const #4s : i
        let s_1254_22: i128 = 4;
        // D s_1254_23: read-var u#32061:u32
        let s_1254_23: u32 = fn_state.u_32061;
        // D s_1254_24: cast zx s_1254_23 -> bv
        let s_1254_24: Bits = Bits::new(s_1254_23 as u128, 32u16);
        // D s_1254_25: bit-extract s_1254_24 s_1254_21 s_1254_22
        let s_1254_25: Bits = (Bits::new(
            ((s_1254_24) >> (s_1254_21)).value(),
            u16::try_from(s_1254_22).unwrap(),
        ));
        // D s_1254_26: cast reint s_1254_25 -> u8
        let s_1254_26: u8 = (s_1254_25.value() as u8);
        // C s_1254_27: const #7s : i
        let s_1254_27: i128 = 7;
        // C s_1254_28: const #1s : i
        let s_1254_28: i128 = 1;
        // D s_1254_29: read-var u#32061:u32
        let s_1254_29: u32 = fn_state.u_32061;
        // D s_1254_30: cast zx s_1254_29 -> bv
        let s_1254_30: Bits = Bits::new(s_1254_29 as u128, 32u16);
        // D s_1254_31: bit-extract s_1254_30 s_1254_27 s_1254_28
        let s_1254_31: Bits = (Bits::new(
            ((s_1254_30) >> (s_1254_27)).value(),
            u16::try_from(s_1254_28).unwrap(),
        ));
        // D s_1254_32: cast reint s_1254_31 -> u8
        let s_1254_32: bool = ((s_1254_31.value()) != 0);
        // C s_1254_33: const #6s : i
        let s_1254_33: i128 = 6;
        // C s_1254_34: const #1s : i
        let s_1254_34: i128 = 1;
        // D s_1254_35: read-var u#32061:u32
        let s_1254_35: u32 = fn_state.u_32061;
        // D s_1254_36: cast zx s_1254_35 -> bv
        let s_1254_36: Bits = Bits::new(s_1254_35 as u128, 32u16);
        // D s_1254_37: bit-extract s_1254_36 s_1254_33 s_1254_34
        let s_1254_37: Bits = (Bits::new(
            ((s_1254_36) >> (s_1254_33)).value(),
            u16::try_from(s_1254_34).unwrap(),
        ));
        // D s_1254_38: cast reint s_1254_37 -> u8
        let s_1254_38: bool = ((s_1254_37.value()) != 0);
        // C s_1254_39: const #5s : i
        let s_1254_39: i128 = 5;
        // C s_1254_40: const #1s : i
        let s_1254_40: i128 = 1;
        // D s_1254_41: read-var u#32061:u32
        let s_1254_41: u32 = fn_state.u_32061;
        // D s_1254_42: cast zx s_1254_41 -> bv
        let s_1254_42: Bits = Bits::new(s_1254_41 as u128, 32u16);
        // D s_1254_43: bit-extract s_1254_42 s_1254_39 s_1254_40
        let s_1254_43: Bits = (Bits::new(
            ((s_1254_42) >> (s_1254_39)).value(),
            u16::try_from(s_1254_40).unwrap(),
        ));
        // D s_1254_44: cast reint s_1254_43 -> u8
        let s_1254_44: bool = ((s_1254_43.value()) != 0);
        // C s_1254_45: const #0s : i
        let s_1254_45: i128 = 0;
        // C s_1254_46: const #4s : i
        let s_1254_46: i128 = 4;
        // D s_1254_47: read-var u#32061:u32
        let s_1254_47: u32 = fn_state.u_32061;
        // D s_1254_48: cast zx s_1254_47 -> bv
        let s_1254_48: Bits = Bits::new(s_1254_47 as u128, 32u16);
        // D s_1254_49: bit-extract s_1254_48 s_1254_45 s_1254_46
        let s_1254_49: Bits = (Bits::new(
            ((s_1254_48) >> (s_1254_45)).value(),
            u16::try_from(s_1254_46).unwrap(),
        ));
        // D s_1254_50: cast reint s_1254_49 -> u8
        let s_1254_50: u8 = (s_1254_49.value() as u8);
        // D s_1254_51: call decode_aarch32_instrs_VSUB_f_A1enc_A_txt(s_1254_8, s_1254_14, s_1254_20, s_1254_26, s_1254_32, s_1254_38, s_1254_44, s_1254_50)
        let s_1254_51: () = decode_aarch32_instrs_VSUB_f_A1enc_A_txt(
            state,
            tracer,
            s_1254_8,
            s_1254_14,
            s_1254_20,
            s_1254_26,
            s_1254_32,
            s_1254_38,
            s_1254_44,
            s_1254_50,
        );
        // N s_1254_52: return
        return;
    }
    fn block_1255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1255_0: read-var merge#var.1:struct
        let s_1255_0: u32 = fn_state.merge_var._1;
        // D s_1255_1: write-var u#32071 <= s_1255_0
        fn_state.u_32071 = s_1255_0;
        // C s_1255_2: const #23s : i
        let s_1255_2: i128 = 23;
        // D s_1255_3: read-var u#32071:u32
        let s_1255_3: u32 = fn_state.u_32071;
        // D s_1255_4: cast zx s_1255_3 -> bv
        let s_1255_4: Bits = Bits::new(s_1255_3 as u128, 32u16);
        // C s_1255_5: const #1s : i64
        let s_1255_5: i64 = 1;
        // C s_1255_6: cast zx s_1255_5 -> i
        let s_1255_6: i128 = (i128::try_from(s_1255_5).unwrap());
        // C s_1255_7: const #8s : i
        let s_1255_7: i128 = 8;
        // C s_1255_8: add s_1255_7 s_1255_6
        let s_1255_8: i128 = (s_1255_7 + s_1255_6);
        // D s_1255_9: bit-extract s_1255_4 s_1255_2 s_1255_8
        let s_1255_9: Bits = (Bits::new(
            ((s_1255_4) >> (s_1255_2)).value(),
            u16::try_from(s_1255_8).unwrap(),
        ));
        // D s_1255_10: cast reint s_1255_9 -> u9
        let s_1255_10: u16 = (s_1255_9.value() as u16);
        // D s_1255_11: cast zx s_1255_10 -> bv
        let s_1255_11: Bits = Bits::new(s_1255_10 as u128, 9u16);
        // C s_1255_12: const #485u : u9
        let s_1255_12: u16 = 485;
        // C s_1255_13: cast zx s_1255_12 -> bv
        let s_1255_13: Bits = Bits::new(s_1255_12 as u128, 9u16);
        // D s_1255_14: cmp-eq s_1255_11 s_1255_13
        let s_1255_14: bool = ((s_1255_11) == (s_1255_13));
        // N s_1255_15: branch s_1255_14 b1857 b1256
        if s_1255_14 {
            return block_1857(state, tracer, fn_state);
        } else {
            return block_1256(state, tracer, fn_state);
        };
    }
    fn block_1256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1256_0: const #0u : u8
        let s_1256_0: bool = false;
        // D s_1256_1: write-var gs#402813 <= s_1256_0
        fn_state.gs_402813 = s_1256_0;
        // N s_1256_2: jump b1257
        return block_1257(state, tracer, fn_state);
    }
    fn block_1257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1257_0: read-var gs#402813:u8
        let s_1257_0: bool = fn_state.gs_402813;
        // N s_1257_1: branch s_1257_0 b1856 b1258
        if s_1257_0 {
            return block_1856(state, tracer, fn_state);
        } else {
            return block_1258(state, tracer, fn_state);
        };
    }
    fn block_1258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1258_0: const #0u : u8
        let s_1258_0: bool = false;
        // D s_1258_1: write-var gs#402815 <= s_1258_0
        fn_state.gs_402815 = s_1258_0;
        // N s_1258_2: jump b1259
        return block_1259(state, tracer, fn_state);
    }
    fn block_1259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1259_0: read-var gs#402815:u8
        let s_1259_0: bool = fn_state.gs_402815;
        // D s_1259_1: not s_1259_0
        let s_1259_1: bool = !s_1259_0;
        // N s_1259_2: branch s_1259_1 b1261 b1260
        if s_1259_1 {
            return block_1261(state, tracer, fn_state);
        } else {
            return block_1260(state, tracer, fn_state);
        };
    }
    fn block_1260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1260_0: const #3742s : i
        let s_1260_0: i128 = 3742;
        // C s_1260_1: const #14696u : u32
        let s_1260_1: u32 = 14696;
        // N s_1260_2: write-reg s_1260_1 <= s_1260_0
        let s_1260_2: () = {
            state.write_register::<i128>(s_1260_1 as isize, s_1260_0);
            tracer.write_register(s_1260_1 as isize, s_1260_0);
        };
        // C s_1260_3: const #22s : i
        let s_1260_3: i128 = 22;
        // C s_1260_4: const #1s : i
        let s_1260_4: i128 = 1;
        // D s_1260_5: read-var u#32071:u32
        let s_1260_5: u32 = fn_state.u_32071;
        // D s_1260_6: cast zx s_1260_5 -> bv
        let s_1260_6: Bits = Bits::new(s_1260_5 as u128, 32u16);
        // D s_1260_7: bit-extract s_1260_6 s_1260_3 s_1260_4
        let s_1260_7: Bits = (Bits::new(
            ((s_1260_6) >> (s_1260_3)).value(),
            u16::try_from(s_1260_4).unwrap(),
        ));
        // D s_1260_8: cast reint s_1260_7 -> u8
        let s_1260_8: bool = ((s_1260_7.value()) != 0);
        // C s_1260_9: const #20s : i
        let s_1260_9: i128 = 20;
        // C s_1260_10: const #2s : i
        let s_1260_10: i128 = 2;
        // D s_1260_11: read-var u#32071:u32
        let s_1260_11: u32 = fn_state.u_32071;
        // D s_1260_12: cast zx s_1260_11 -> bv
        let s_1260_12: Bits = Bits::new(s_1260_11 as u128, 32u16);
        // D s_1260_13: bit-extract s_1260_12 s_1260_9 s_1260_10
        let s_1260_13: Bits = (Bits::new(
            ((s_1260_12) >> (s_1260_9)).value(),
            u16::try_from(s_1260_10).unwrap(),
        ));
        // D s_1260_14: cast reint s_1260_13 -> u8
        let s_1260_14: u8 = (s_1260_13.value() as u8);
        // C s_1260_15: const #16s : i
        let s_1260_15: i128 = 16;
        // C s_1260_16: const #4s : i
        let s_1260_16: i128 = 4;
        // D s_1260_17: read-var u#32071:u32
        let s_1260_17: u32 = fn_state.u_32071;
        // D s_1260_18: cast zx s_1260_17 -> bv
        let s_1260_18: Bits = Bits::new(s_1260_17 as u128, 32u16);
        // D s_1260_19: bit-extract s_1260_18 s_1260_15 s_1260_16
        let s_1260_19: Bits = (Bits::new(
            ((s_1260_18) >> (s_1260_15)).value(),
            u16::try_from(s_1260_16).unwrap(),
        ));
        // D s_1260_20: cast reint s_1260_19 -> u8
        let s_1260_20: u8 = (s_1260_19.value() as u8);
        // C s_1260_21: const #12s : i
        let s_1260_21: i128 = 12;
        // C s_1260_22: const #4s : i
        let s_1260_22: i128 = 4;
        // D s_1260_23: read-var u#32071:u32
        let s_1260_23: u32 = fn_state.u_32071;
        // D s_1260_24: cast zx s_1260_23 -> bv
        let s_1260_24: Bits = Bits::new(s_1260_23 as u128, 32u16);
        // D s_1260_25: bit-extract s_1260_24 s_1260_21 s_1260_22
        let s_1260_25: Bits = (Bits::new(
            ((s_1260_24) >> (s_1260_21)).value(),
            u16::try_from(s_1260_22).unwrap(),
        ));
        // D s_1260_26: cast reint s_1260_25 -> u8
        let s_1260_26: u8 = (s_1260_25.value() as u8);
        // C s_1260_27: const #7s : i
        let s_1260_27: i128 = 7;
        // C s_1260_28: const #1s : i
        let s_1260_28: i128 = 1;
        // D s_1260_29: read-var u#32071:u32
        let s_1260_29: u32 = fn_state.u_32071;
        // D s_1260_30: cast zx s_1260_29 -> bv
        let s_1260_30: Bits = Bits::new(s_1260_29 as u128, 32u16);
        // D s_1260_31: bit-extract s_1260_30 s_1260_27 s_1260_28
        let s_1260_31: Bits = (Bits::new(
            ((s_1260_30) >> (s_1260_27)).value(),
            u16::try_from(s_1260_28).unwrap(),
        ));
        // D s_1260_32: cast reint s_1260_31 -> u8
        let s_1260_32: bool = ((s_1260_31.value()) != 0);
        // C s_1260_33: const #5s : i
        let s_1260_33: i128 = 5;
        // C s_1260_34: const #1s : i
        let s_1260_34: i128 = 1;
        // D s_1260_35: read-var u#32071:u32
        let s_1260_35: u32 = fn_state.u_32071;
        // D s_1260_36: cast zx s_1260_35 -> bv
        let s_1260_36: Bits = Bits::new(s_1260_35 as u128, 32u16);
        // D s_1260_37: bit-extract s_1260_36 s_1260_33 s_1260_34
        let s_1260_37: Bits = (Bits::new(
            ((s_1260_36) >> (s_1260_33)).value(),
            u16::try_from(s_1260_34).unwrap(),
        ));
        // D s_1260_38: cast reint s_1260_37 -> u8
        let s_1260_38: bool = ((s_1260_37.value()) != 0);
        // C s_1260_39: const #0s : i
        let s_1260_39: i128 = 0;
        // C s_1260_40: const #4s : i
        let s_1260_40: i128 = 4;
        // D s_1260_41: read-var u#32071:u32
        let s_1260_41: u32 = fn_state.u_32071;
        // D s_1260_42: cast zx s_1260_41 -> bv
        let s_1260_42: Bits = Bits::new(s_1260_41 as u128, 32u16);
        // D s_1260_43: bit-extract s_1260_42 s_1260_39 s_1260_40
        let s_1260_43: Bits = (Bits::new(
            ((s_1260_42) >> (s_1260_39)).value(),
            u16::try_from(s_1260_40).unwrap(),
        ));
        // D s_1260_44: cast reint s_1260_43 -> u8
        let s_1260_44: u8 = (s_1260_43.value() as u8);
        // D s_1260_45: call decode_aarch32_instrs_VSUBHN_A1enc_A_txt(s_1260_8, s_1260_14, s_1260_20, s_1260_26, s_1260_32, s_1260_38, s_1260_44)
        let s_1260_45: () = decode_aarch32_instrs_VSUBHN_A1enc_A_txt(
            state,
            tracer,
            s_1260_8,
            s_1260_14,
            s_1260_20,
            s_1260_26,
            s_1260_32,
            s_1260_38,
            s_1260_44,
        );
        // N s_1260_46: return
        return;
    }
    fn block_1261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1261_0: read-var merge#var.1:struct
        let s_1261_0: u32 = fn_state.merge_var._1;
        // D s_1261_1: write-var u#32080 <= s_1261_0
        fn_state.u_32080 = s_1261_0;
        // C s_1261_2: const #23s : i
        let s_1261_2: i128 = 23;
        // D s_1261_3: read-var u#32080:u32
        let s_1261_3: u32 = fn_state.u_32080;
        // D s_1261_4: cast zx s_1261_3 -> bv
        let s_1261_4: Bits = Bits::new(s_1261_3 as u128, 32u16);
        // C s_1261_5: const #1s : i64
        let s_1261_5: i64 = 1;
        // C s_1261_6: cast zx s_1261_5 -> i
        let s_1261_6: i128 = (i128::try_from(s_1261_5).unwrap());
        // C s_1261_7: const #8s : i
        let s_1261_7: i128 = 8;
        // C s_1261_8: add s_1261_7 s_1261_6
        let s_1261_8: i128 = (s_1261_7 + s_1261_6);
        // D s_1261_9: bit-extract s_1261_4 s_1261_2 s_1261_8
        let s_1261_9: Bits = (Bits::new(
            ((s_1261_4) >> (s_1261_2)).value(),
            u16::try_from(s_1261_8).unwrap(),
        ));
        // D s_1261_10: cast reint s_1261_9 -> u9
        let s_1261_10: u16 = (s_1261_9.value() as u16);
        // D s_1261_11: cast zx s_1261_10 -> bv
        let s_1261_11: Bits = Bits::new(s_1261_10 as u128, 9u16);
        // C s_1261_12: const #486u : u9
        let s_1261_12: u16 = 486;
        // C s_1261_13: cast zx s_1261_12 -> bv
        let s_1261_13: Bits = Bits::new(s_1261_12 as u128, 9u16);
        // D s_1261_14: cmp-eq s_1261_11 s_1261_13
        let s_1261_14: bool = ((s_1261_11) == (s_1261_13));
        // N s_1261_15: branch s_1261_14 b1852 b1262
        if s_1261_14 {
            return block_1852(state, tracer, fn_state);
        } else {
            return block_1262(state, tracer, fn_state);
        };
    }
    fn block_1262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1262_0: const #0u : u8
        let s_1262_0: bool = false;
        // D s_1262_1: write-var gs#402840 <= s_1262_0
        fn_state.gs_402840 = s_1262_0;
        // N s_1262_2: jump b1263
        return block_1263(state, tracer, fn_state);
    }
    fn block_1263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1263_0: read-var gs#402840:u8
        let s_1263_0: bool = fn_state.gs_402840;
        // N s_1263_1: branch s_1263_0 b1851 b1264
        if s_1263_0 {
            return block_1851(state, tracer, fn_state);
        } else {
            return block_1264(state, tracer, fn_state);
        };
    }
    fn block_1264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1264_0: const #0u : u8
        let s_1264_0: bool = false;
        // D s_1264_1: write-var gs#402842 <= s_1264_0
        fn_state.gs_402842 = s_1264_0;
        // N s_1264_2: jump b1265
        return block_1265(state, tracer, fn_state);
    }
    fn block_1265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1265_0: read-var gs#402842:u8
        let s_1265_0: bool = fn_state.gs_402842;
        // D s_1265_1: not s_1265_0
        let s_1265_1: bool = !s_1265_0;
        // N s_1265_2: branch s_1265_1 b1267 b1266
        if s_1265_1 {
            return block_1267(state, tracer, fn_state);
        } else {
            return block_1266(state, tracer, fn_state);
        };
    }
    fn block_1266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1266_0: const #3744s : i
        let s_1266_0: i128 = 3744;
        // C s_1266_1: const #14696u : u32
        let s_1266_1: u32 = 14696;
        // N s_1266_2: write-reg s_1266_1 <= s_1266_0
        let s_1266_2: () = {
            state.write_register::<i128>(s_1266_1 as isize, s_1266_0);
            tracer.write_register(s_1266_1 as isize, s_1266_0);
        };
        // C s_1266_3: const #22s : i
        let s_1266_3: i128 = 22;
        // C s_1266_4: const #1s : i
        let s_1266_4: i128 = 1;
        // D s_1266_5: read-var u#32080:u32
        let s_1266_5: u32 = fn_state.u_32080;
        // D s_1266_6: cast zx s_1266_5 -> bv
        let s_1266_6: Bits = Bits::new(s_1266_5 as u128, 32u16);
        // D s_1266_7: bit-extract s_1266_6 s_1266_3 s_1266_4
        let s_1266_7: Bits = (Bits::new(
            ((s_1266_6) >> (s_1266_3)).value(),
            u16::try_from(s_1266_4).unwrap(),
        ));
        // D s_1266_8: cast reint s_1266_7 -> u8
        let s_1266_8: bool = ((s_1266_7.value()) != 0);
        // C s_1266_9: const #20s : i
        let s_1266_9: i128 = 20;
        // C s_1266_10: const #2s : i
        let s_1266_10: i128 = 2;
        // D s_1266_11: read-var u#32080:u32
        let s_1266_11: u32 = fn_state.u_32080;
        // D s_1266_12: cast zx s_1266_11 -> bv
        let s_1266_12: Bits = Bits::new(s_1266_11 as u128, 32u16);
        // D s_1266_13: bit-extract s_1266_12 s_1266_9 s_1266_10
        let s_1266_13: Bits = (Bits::new(
            ((s_1266_12) >> (s_1266_9)).value(),
            u16::try_from(s_1266_10).unwrap(),
        ));
        // D s_1266_14: cast reint s_1266_13 -> u8
        let s_1266_14: u8 = (s_1266_13.value() as u8);
        // C s_1266_15: const #16s : i
        let s_1266_15: i128 = 16;
        // C s_1266_16: const #4s : i
        let s_1266_16: i128 = 4;
        // D s_1266_17: read-var u#32080:u32
        let s_1266_17: u32 = fn_state.u_32080;
        // D s_1266_18: cast zx s_1266_17 -> bv
        let s_1266_18: Bits = Bits::new(s_1266_17 as u128, 32u16);
        // D s_1266_19: bit-extract s_1266_18 s_1266_15 s_1266_16
        let s_1266_19: Bits = (Bits::new(
            ((s_1266_18) >> (s_1266_15)).value(),
            u16::try_from(s_1266_16).unwrap(),
        ));
        // D s_1266_20: cast reint s_1266_19 -> u8
        let s_1266_20: u8 = (s_1266_19.value() as u8);
        // C s_1266_21: const #12s : i
        let s_1266_21: i128 = 12;
        // C s_1266_22: const #4s : i
        let s_1266_22: i128 = 4;
        // D s_1266_23: read-var u#32080:u32
        let s_1266_23: u32 = fn_state.u_32080;
        // D s_1266_24: cast zx s_1266_23 -> bv
        let s_1266_24: Bits = Bits::new(s_1266_23 as u128, 32u16);
        // D s_1266_25: bit-extract s_1266_24 s_1266_21 s_1266_22
        let s_1266_25: Bits = (Bits::new(
            ((s_1266_24) >> (s_1266_21)).value(),
            u16::try_from(s_1266_22).unwrap(),
        ));
        // D s_1266_26: cast reint s_1266_25 -> u8
        let s_1266_26: u8 = (s_1266_25.value() as u8);
        // C s_1266_27: const #7s : i
        let s_1266_27: i128 = 7;
        // C s_1266_28: const #1s : i
        let s_1266_28: i128 = 1;
        // D s_1266_29: read-var u#32080:u32
        let s_1266_29: u32 = fn_state.u_32080;
        // D s_1266_30: cast zx s_1266_29 -> bv
        let s_1266_30: Bits = Bits::new(s_1266_29 as u128, 32u16);
        // D s_1266_31: bit-extract s_1266_30 s_1266_27 s_1266_28
        let s_1266_31: Bits = (Bits::new(
            ((s_1266_30) >> (s_1266_27)).value(),
            u16::try_from(s_1266_28).unwrap(),
        ));
        // D s_1266_32: cast reint s_1266_31 -> u8
        let s_1266_32: bool = ((s_1266_31.value()) != 0);
        // C s_1266_33: const #6s : i
        let s_1266_33: i128 = 6;
        // C s_1266_34: const #1s : i
        let s_1266_34: i128 = 1;
        // D s_1266_35: read-var u#32080:u32
        let s_1266_35: u32 = fn_state.u_32080;
        // D s_1266_36: cast zx s_1266_35 -> bv
        let s_1266_36: Bits = Bits::new(s_1266_35 as u128, 32u16);
        // D s_1266_37: bit-extract s_1266_36 s_1266_33 s_1266_34
        let s_1266_37: Bits = (Bits::new(
            ((s_1266_36) >> (s_1266_33)).value(),
            u16::try_from(s_1266_34).unwrap(),
        ));
        // D s_1266_38: cast reint s_1266_37 -> u8
        let s_1266_38: bool = ((s_1266_37.value()) != 0);
        // C s_1266_39: const #5s : i
        let s_1266_39: i128 = 5;
        // C s_1266_40: const #1s : i
        let s_1266_40: i128 = 1;
        // D s_1266_41: read-var u#32080:u32
        let s_1266_41: u32 = fn_state.u_32080;
        // D s_1266_42: cast zx s_1266_41 -> bv
        let s_1266_42: Bits = Bits::new(s_1266_41 as u128, 32u16);
        // D s_1266_43: bit-extract s_1266_42 s_1266_39 s_1266_40
        let s_1266_43: Bits = (Bits::new(
            ((s_1266_42) >> (s_1266_39)).value(),
            u16::try_from(s_1266_40).unwrap(),
        ));
        // D s_1266_44: cast reint s_1266_43 -> u8
        let s_1266_44: bool = ((s_1266_43.value()) != 0);
        // C s_1266_45: const #0s : i
        let s_1266_45: i128 = 0;
        // C s_1266_46: const #4s : i
        let s_1266_46: i128 = 4;
        // D s_1266_47: read-var u#32080:u32
        let s_1266_47: u32 = fn_state.u_32080;
        // D s_1266_48: cast zx s_1266_47 -> bv
        let s_1266_48: Bits = Bits::new(s_1266_47 as u128, 32u16);
        // D s_1266_49: bit-extract s_1266_48 s_1266_45 s_1266_46
        let s_1266_49: Bits = (Bits::new(
            ((s_1266_48) >> (s_1266_45)).value(),
            u16::try_from(s_1266_46).unwrap(),
        ));
        // D s_1266_50: cast reint s_1266_49 -> u8
        let s_1266_50: u8 = (s_1266_49.value() as u8);
        // D s_1266_51: call decode_aarch32_instrs_VSUB_i_A1enc_A_txt(s_1266_8, s_1266_14, s_1266_20, s_1266_26, s_1266_32, s_1266_38, s_1266_44, s_1266_50)
        let s_1266_51: () = decode_aarch32_instrs_VSUB_i_A1enc_A_txt(
            state,
            tracer,
            s_1266_8,
            s_1266_14,
            s_1266_20,
            s_1266_26,
            s_1266_32,
            s_1266_38,
            s_1266_44,
            s_1266_50,
        );
        // N s_1266_52: return
        return;
    }
    fn block_1267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1267_0: read-var merge#var.1:struct
        let s_1267_0: u32 = fn_state.merge_var._1;
        // D s_1267_1: write-var u#32090 <= s_1267_0
        fn_state.u_32090 = s_1267_0;
        // C s_1267_2: const #25s : i
        let s_1267_2: i128 = 25;
        // D s_1267_3: read-var u#32090:u32
        let s_1267_3: u32 = fn_state.u_32090;
        // D s_1267_4: cast zx s_1267_3 -> bv
        let s_1267_4: Bits = Bits::new(s_1267_3 as u128, 32u16);
        // C s_1267_5: const #1s : i64
        let s_1267_5: i64 = 1;
        // C s_1267_6: cast zx s_1267_5 -> i
        let s_1267_6: i128 = (i128::try_from(s_1267_5).unwrap());
        // C s_1267_7: const #6s : i
        let s_1267_7: i128 = 6;
        // C s_1267_8: add s_1267_7 s_1267_6
        let s_1267_8: i128 = (s_1267_7 + s_1267_6);
        // D s_1267_9: bit-extract s_1267_4 s_1267_2 s_1267_8
        let s_1267_9: Bits = (Bits::new(
            ((s_1267_4) >> (s_1267_2)).value(),
            u16::try_from(s_1267_8).unwrap(),
        ));
        // D s_1267_10: cast reint s_1267_9 -> u8
        let s_1267_10: u8 = (s_1267_9.value() as u8);
        // D s_1267_11: cast zx s_1267_10 -> bv
        let s_1267_11: Bits = Bits::new(s_1267_10 as u128, 7u16);
        // C s_1267_12: const #121u : u8
        let s_1267_12: u8 = 121;
        // C s_1267_13: cast zx s_1267_12 -> bv
        let s_1267_13: Bits = Bits::new(s_1267_12 as u128, 7u16);
        // D s_1267_14: cmp-eq s_1267_11 s_1267_13
        let s_1267_14: bool = ((s_1267_11) == (s_1267_13));
        // N s_1267_15: branch s_1267_14 b1841 b1268
        if s_1267_14 {
            return block_1841(state, tracer, fn_state);
        } else {
            return block_1268(state, tracer, fn_state);
        };
    }
    fn block_1268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1268_0: const #0u : u8
        let s_1268_0: bool = false;
        // D s_1268_1: write-var gs#402875 <= s_1268_0
        fn_state.gs_402875 = s_1268_0;
        // N s_1268_2: jump b1269
        return block_1269(state, tracer, fn_state);
    }
    fn block_1269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1269_0: read-var gs#402875:u8
        let s_1269_0: bool = fn_state.gs_402875;
        // N s_1269_1: branch s_1269_0 b1840 b1270
        if s_1269_0 {
            return block_1840(state, tracer, fn_state);
        } else {
            return block_1270(state, tracer, fn_state);
        };
    }
    fn block_1270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1270_0: const #0u : u8
        let s_1270_0: bool = false;
        // D s_1270_1: write-var gs#402877 <= s_1270_0
        fn_state.gs_402877 = s_1270_0;
        // N s_1270_2: jump b1271
        return block_1271(state, tracer, fn_state);
    }
    fn block_1271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1271_0: read-var gs#402877:u8
        let s_1271_0: bool = fn_state.gs_402877;
        // D s_1271_1: not s_1271_0
        let s_1271_1: bool = !s_1271_0;
        // N s_1271_2: branch s_1271_1 b1273 b1272
        if s_1271_1 {
            return block_1273(state, tracer, fn_state);
        } else {
            return block_1272(state, tracer, fn_state);
        };
    }
    fn block_1272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1272_0: const #3746s : i
        let s_1272_0: i128 = 3746;
        // C s_1272_1: const #14696u : u32
        let s_1272_1: u32 = 14696;
        // N s_1272_2: write-reg s_1272_1 <= s_1272_0
        let s_1272_2: () = {
            state.write_register::<i128>(s_1272_1 as isize, s_1272_0);
            tracer.write_register(s_1272_1 as isize, s_1272_0);
        };
        // C s_1272_3: const #24s : i
        let s_1272_3: i128 = 24;
        // C s_1272_4: const #1s : i
        let s_1272_4: i128 = 1;
        // D s_1272_5: read-var u#32090:u32
        let s_1272_5: u32 = fn_state.u_32090;
        // D s_1272_6: cast zx s_1272_5 -> bv
        let s_1272_6: Bits = Bits::new(s_1272_5 as u128, 32u16);
        // D s_1272_7: bit-extract s_1272_6 s_1272_3 s_1272_4
        let s_1272_7: Bits = (Bits::new(
            ((s_1272_6) >> (s_1272_3)).value(),
            u16::try_from(s_1272_4).unwrap(),
        ));
        // D s_1272_8: cast reint s_1272_7 -> u8
        let s_1272_8: bool = ((s_1272_7.value()) != 0);
        // C s_1272_9: const #22s : i
        let s_1272_9: i128 = 22;
        // C s_1272_10: const #1s : i
        let s_1272_10: i128 = 1;
        // D s_1272_11: read-var u#32090:u32
        let s_1272_11: u32 = fn_state.u_32090;
        // D s_1272_12: cast zx s_1272_11 -> bv
        let s_1272_12: Bits = Bits::new(s_1272_11 as u128, 32u16);
        // D s_1272_13: bit-extract s_1272_12 s_1272_9 s_1272_10
        let s_1272_13: Bits = (Bits::new(
            ((s_1272_12) >> (s_1272_9)).value(),
            u16::try_from(s_1272_10).unwrap(),
        ));
        // D s_1272_14: cast reint s_1272_13 -> u8
        let s_1272_14: bool = ((s_1272_13.value()) != 0);
        // C s_1272_15: const #20s : i
        let s_1272_15: i128 = 20;
        // C s_1272_16: const #2s : i
        let s_1272_16: i128 = 2;
        // D s_1272_17: read-var u#32090:u32
        let s_1272_17: u32 = fn_state.u_32090;
        // D s_1272_18: cast zx s_1272_17 -> bv
        let s_1272_18: Bits = Bits::new(s_1272_17 as u128, 32u16);
        // D s_1272_19: bit-extract s_1272_18 s_1272_15 s_1272_16
        let s_1272_19: Bits = (Bits::new(
            ((s_1272_18) >> (s_1272_15)).value(),
            u16::try_from(s_1272_16).unwrap(),
        ));
        // D s_1272_20: cast reint s_1272_19 -> u8
        let s_1272_20: u8 = (s_1272_19.value() as u8);
        // C s_1272_21: const #16s : i
        let s_1272_21: i128 = 16;
        // C s_1272_22: const #4s : i
        let s_1272_22: i128 = 4;
        // D s_1272_23: read-var u#32090:u32
        let s_1272_23: u32 = fn_state.u_32090;
        // D s_1272_24: cast zx s_1272_23 -> bv
        let s_1272_24: Bits = Bits::new(s_1272_23 as u128, 32u16);
        // D s_1272_25: bit-extract s_1272_24 s_1272_21 s_1272_22
        let s_1272_25: Bits = (Bits::new(
            ((s_1272_24) >> (s_1272_21)).value(),
            u16::try_from(s_1272_22).unwrap(),
        ));
        // D s_1272_26: cast reint s_1272_25 -> u8
        let s_1272_26: u8 = (s_1272_25.value() as u8);
        // C s_1272_27: const #12s : i
        let s_1272_27: i128 = 12;
        // C s_1272_28: const #4s : i
        let s_1272_28: i128 = 4;
        // D s_1272_29: read-var u#32090:u32
        let s_1272_29: u32 = fn_state.u_32090;
        // D s_1272_30: cast zx s_1272_29 -> bv
        let s_1272_30: Bits = Bits::new(s_1272_29 as u128, 32u16);
        // D s_1272_31: bit-extract s_1272_30 s_1272_27 s_1272_28
        let s_1272_31: Bits = (Bits::new(
            ((s_1272_30) >> (s_1272_27)).value(),
            u16::try_from(s_1272_28).unwrap(),
        ));
        // D s_1272_32: cast reint s_1272_31 -> u8
        let s_1272_32: u8 = (s_1272_31.value() as u8);
        // C s_1272_33: const #8s : i
        let s_1272_33: i128 = 8;
        // C s_1272_34: const #1s : i
        let s_1272_34: i128 = 1;
        // D s_1272_35: read-var u#32090:u32
        let s_1272_35: u32 = fn_state.u_32090;
        // D s_1272_36: cast zx s_1272_35 -> bv
        let s_1272_36: Bits = Bits::new(s_1272_35 as u128, 32u16);
        // D s_1272_37: bit-extract s_1272_36 s_1272_33 s_1272_34
        let s_1272_37: Bits = (Bits::new(
            ((s_1272_36) >> (s_1272_33)).value(),
            u16::try_from(s_1272_34).unwrap(),
        ));
        // D s_1272_38: cast reint s_1272_37 -> u8
        let s_1272_38: bool = ((s_1272_37.value()) != 0);
        // C s_1272_39: const #7s : i
        let s_1272_39: i128 = 7;
        // C s_1272_40: const #1s : i
        let s_1272_40: i128 = 1;
        // D s_1272_41: read-var u#32090:u32
        let s_1272_41: u32 = fn_state.u_32090;
        // D s_1272_42: cast zx s_1272_41 -> bv
        let s_1272_42: Bits = Bits::new(s_1272_41 as u128, 32u16);
        // D s_1272_43: bit-extract s_1272_42 s_1272_39 s_1272_40
        let s_1272_43: Bits = (Bits::new(
            ((s_1272_42) >> (s_1272_39)).value(),
            u16::try_from(s_1272_40).unwrap(),
        ));
        // D s_1272_44: cast reint s_1272_43 -> u8
        let s_1272_44: bool = ((s_1272_43.value()) != 0);
        // C s_1272_45: const #5s : i
        let s_1272_45: i128 = 5;
        // C s_1272_46: const #1s : i
        let s_1272_46: i128 = 1;
        // D s_1272_47: read-var u#32090:u32
        let s_1272_47: u32 = fn_state.u_32090;
        // D s_1272_48: cast zx s_1272_47 -> bv
        let s_1272_48: Bits = Bits::new(s_1272_47 as u128, 32u16);
        // D s_1272_49: bit-extract s_1272_48 s_1272_45 s_1272_46
        let s_1272_49: Bits = (Bits::new(
            ((s_1272_48) >> (s_1272_45)).value(),
            u16::try_from(s_1272_46).unwrap(),
        ));
        // D s_1272_50: cast reint s_1272_49 -> u8
        let s_1272_50: bool = ((s_1272_49.value()) != 0);
        // C s_1272_51: const #0s : i
        let s_1272_51: i128 = 0;
        // C s_1272_52: const #4s : i
        let s_1272_52: i128 = 4;
        // D s_1272_53: read-var u#32090:u32
        let s_1272_53: u32 = fn_state.u_32090;
        // D s_1272_54: cast zx s_1272_53 -> bv
        let s_1272_54: Bits = Bits::new(s_1272_53 as u128, 32u16);
        // D s_1272_55: bit-extract s_1272_54 s_1272_51 s_1272_52
        let s_1272_55: Bits = (Bits::new(
            ((s_1272_54) >> (s_1272_51)).value(),
            u16::try_from(s_1272_52).unwrap(),
        ));
        // D s_1272_56: cast reint s_1272_55 -> u8
        let s_1272_56: u8 = (s_1272_55.value() as u8);
        // D s_1272_57: call decode_aarch32_instrs_VSUBL_A1enc_A_txt(s_1272_8, s_1272_14, s_1272_20, s_1272_26, s_1272_32, s_1272_38, s_1272_44, s_1272_50, s_1272_56)
        let s_1272_57: () = decode_aarch32_instrs_VSUBL_A1enc_A_txt(
            state,
            tracer,
            s_1272_8,
            s_1272_14,
            s_1272_20,
            s_1272_26,
            s_1272_32,
            s_1272_38,
            s_1272_44,
            s_1272_50,
            s_1272_56,
        );
        // N s_1272_58: return
        return;
    }
    fn block_1273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1273_0: read-var merge#var.1:struct
        let s_1273_0: u32 = fn_state.merge_var._1;
        // D s_1273_1: write-var u#32101 <= s_1273_0
        fn_state.u_32101 = s_1273_0;
        // C s_1273_2: const #23s : i
        let s_1273_2: i128 = 23;
        // D s_1273_3: read-var u#32101:u32
        let s_1273_3: u32 = fn_state.u_32101;
        // D s_1273_4: cast zx s_1273_3 -> bv
        let s_1273_4: Bits = Bits::new(s_1273_3 as u128, 32u16);
        // C s_1273_5: const #1s : i64
        let s_1273_5: i64 = 1;
        // C s_1273_6: cast zx s_1273_5 -> i
        let s_1273_6: i128 = (i128::try_from(s_1273_5).unwrap());
        // C s_1273_7: const #8s : i
        let s_1273_7: i128 = 8;
        // C s_1273_8: add s_1273_7 s_1273_6
        let s_1273_8: i128 = (s_1273_7 + s_1273_6);
        // D s_1273_9: bit-extract s_1273_4 s_1273_2 s_1273_8
        let s_1273_9: Bits = (Bits::new(
            ((s_1273_4) >> (s_1273_2)).value(),
            u16::try_from(s_1273_8).unwrap(),
        ));
        // D s_1273_10: cast reint s_1273_9 -> u9
        let s_1273_10: u16 = (s_1273_9.value() as u16);
        // D s_1273_11: cast zx s_1273_10 -> bv
        let s_1273_11: Bits = Bits::new(s_1273_10 as u128, 9u16);
        // C s_1273_12: const #487u : u9
        let s_1273_12: u16 = 487;
        // C s_1273_13: cast zx s_1273_12 -> bv
        let s_1273_13: Bits = Bits::new(s_1273_12 as u128, 9u16);
        // D s_1273_14: cmp-eq s_1273_11 s_1273_13
        let s_1273_14: bool = ((s_1273_11) == (s_1273_13));
        // N s_1273_15: branch s_1273_14 b1830 b1274
        if s_1273_14 {
            return block_1830(state, tracer, fn_state);
        } else {
            return block_1274(state, tracer, fn_state);
        };
    }
    fn block_1274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1274_0: const #0u : u8
        let s_1274_0: bool = false;
        // D s_1274_1: write-var gs#402912 <= s_1274_0
        fn_state.gs_402912 = s_1274_0;
        // N s_1274_2: jump b1275
        return block_1275(state, tracer, fn_state);
    }
    fn block_1275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1275_0: read-var gs#402912:u8
        let s_1275_0: bool = fn_state.gs_402912;
        // N s_1275_1: branch s_1275_0 b1829 b1276
        if s_1275_0 {
            return block_1829(state, tracer, fn_state);
        } else {
            return block_1276(state, tracer, fn_state);
        };
    }
    fn block_1276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1276_0: const #0u : u8
        let s_1276_0: bool = false;
        // D s_1276_1: write-var gs#402914 <= s_1276_0
        fn_state.gs_402914 = s_1276_0;
        // N s_1276_2: jump b1277
        return block_1277(state, tracer, fn_state);
    }
    fn block_1277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1277_0: read-var gs#402914:u8
        let s_1277_0: bool = fn_state.gs_402914;
        // D s_1277_1: not s_1277_0
        let s_1277_1: bool = !s_1277_0;
        // N s_1277_2: branch s_1277_1 b1279 b1278
        if s_1277_1 {
            return block_1279(state, tracer, fn_state);
        } else {
            return block_1278(state, tracer, fn_state);
        };
    }
    fn block_1278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1278_0: const #3748s : i
        let s_1278_0: i128 = 3748;
        // C s_1278_1: const #14696u : u32
        let s_1278_1: u32 = 14696;
        // N s_1278_2: write-reg s_1278_1 <= s_1278_0
        let s_1278_2: () = {
            state.write_register::<i128>(s_1278_1 as isize, s_1278_0);
            tracer.write_register(s_1278_1 as isize, s_1278_0);
        };
        // C s_1278_3: const #22s : i
        let s_1278_3: i128 = 22;
        // C s_1278_4: const #1s : i
        let s_1278_4: i128 = 1;
        // D s_1278_5: read-var u#32101:u32
        let s_1278_5: u32 = fn_state.u_32101;
        // D s_1278_6: cast zx s_1278_5 -> bv
        let s_1278_6: Bits = Bits::new(s_1278_5 as u128, 32u16);
        // D s_1278_7: bit-extract s_1278_6 s_1278_3 s_1278_4
        let s_1278_7: Bits = (Bits::new(
            ((s_1278_6) >> (s_1278_3)).value(),
            u16::try_from(s_1278_4).unwrap(),
        ));
        // D s_1278_8: cast reint s_1278_7 -> u8
        let s_1278_8: bool = ((s_1278_7.value()) != 0);
        // C s_1278_9: const #18s : i
        let s_1278_9: i128 = 18;
        // C s_1278_10: const #2s : i
        let s_1278_10: i128 = 2;
        // D s_1278_11: read-var u#32101:u32
        let s_1278_11: u32 = fn_state.u_32101;
        // D s_1278_12: cast zx s_1278_11 -> bv
        let s_1278_12: Bits = Bits::new(s_1278_11 as u128, 32u16);
        // D s_1278_13: bit-extract s_1278_12 s_1278_9 s_1278_10
        let s_1278_13: Bits = (Bits::new(
            ((s_1278_12) >> (s_1278_9)).value(),
            u16::try_from(s_1278_10).unwrap(),
        ));
        // D s_1278_14: cast reint s_1278_13 -> u8
        let s_1278_14: u8 = (s_1278_13.value() as u8);
        // C s_1278_15: const #12s : i
        let s_1278_15: i128 = 12;
        // C s_1278_16: const #4s : i
        let s_1278_16: i128 = 4;
        // D s_1278_17: read-var u#32101:u32
        let s_1278_17: u32 = fn_state.u_32101;
        // D s_1278_18: cast zx s_1278_17 -> bv
        let s_1278_18: Bits = Bits::new(s_1278_17 as u128, 32u16);
        // D s_1278_19: bit-extract s_1278_18 s_1278_15 s_1278_16
        let s_1278_19: Bits = (Bits::new(
            ((s_1278_18) >> (s_1278_15)).value(),
            u16::try_from(s_1278_16).unwrap(),
        ));
        // D s_1278_20: cast reint s_1278_19 -> u8
        let s_1278_20: u8 = (s_1278_19.value() as u8);
        // C s_1278_21: const #6s : i
        let s_1278_21: i128 = 6;
        // C s_1278_22: const #1s : i
        let s_1278_22: i128 = 1;
        // D s_1278_23: read-var u#32101:u32
        let s_1278_23: u32 = fn_state.u_32101;
        // D s_1278_24: cast zx s_1278_23 -> bv
        let s_1278_24: Bits = Bits::new(s_1278_23 as u128, 32u16);
        // D s_1278_25: bit-extract s_1278_24 s_1278_21 s_1278_22
        let s_1278_25: Bits = (Bits::new(
            ((s_1278_24) >> (s_1278_21)).value(),
            u16::try_from(s_1278_22).unwrap(),
        ));
        // D s_1278_26: cast reint s_1278_25 -> u8
        let s_1278_26: bool = ((s_1278_25.value()) != 0);
        // C s_1278_27: const #5s : i
        let s_1278_27: i128 = 5;
        // C s_1278_28: const #1s : i
        let s_1278_28: i128 = 1;
        // D s_1278_29: read-var u#32101:u32
        let s_1278_29: u32 = fn_state.u_32101;
        // D s_1278_30: cast zx s_1278_29 -> bv
        let s_1278_30: Bits = Bits::new(s_1278_29 as u128, 32u16);
        // D s_1278_31: bit-extract s_1278_30 s_1278_27 s_1278_28
        let s_1278_31: Bits = (Bits::new(
            ((s_1278_30) >> (s_1278_27)).value(),
            u16::try_from(s_1278_28).unwrap(),
        ));
        // D s_1278_32: cast reint s_1278_31 -> u8
        let s_1278_32: bool = ((s_1278_31.value()) != 0);
        // C s_1278_33: const #0s : i
        let s_1278_33: i128 = 0;
        // C s_1278_34: const #4s : i
        let s_1278_34: i128 = 4;
        // D s_1278_35: read-var u#32101:u32
        let s_1278_35: u32 = fn_state.u_32101;
        // D s_1278_36: cast zx s_1278_35 -> bv
        let s_1278_36: Bits = Bits::new(s_1278_35 as u128, 32u16);
        // D s_1278_37: bit-extract s_1278_36 s_1278_33 s_1278_34
        let s_1278_37: Bits = (Bits::new(
            ((s_1278_36) >> (s_1278_33)).value(),
            u16::try_from(s_1278_34).unwrap(),
        ));
        // D s_1278_38: cast reint s_1278_37 -> u8
        let s_1278_38: u8 = (s_1278_37.value() as u8);
        // D s_1278_39: call decode_aarch32_instrs_VSWP_A1enc_A_txt(s_1278_8, s_1278_14, s_1278_20, s_1278_26, s_1278_32, s_1278_38)
        let s_1278_39: () = decode_aarch32_instrs_VSWP_A1enc_A_txt(
            state,
            tracer,
            s_1278_8,
            s_1278_14,
            s_1278_20,
            s_1278_26,
            s_1278_32,
            s_1278_38,
        );
        // N s_1278_40: return
        return;
    }
    fn block_1279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1279_0: read-var merge#var.1:struct
        let s_1279_0: u32 = fn_state.merge_var._1;
        // D s_1279_1: write-var u#32109 <= s_1279_0
        fn_state.u_32109 = s_1279_0;
        // C s_1279_2: const #23s : i
        let s_1279_2: i128 = 23;
        // D s_1279_3: read-var u#32109:u32
        let s_1279_3: u32 = fn_state.u_32109;
        // D s_1279_4: cast zx s_1279_3 -> bv
        let s_1279_4: Bits = Bits::new(s_1279_3 as u128, 32u16);
        // C s_1279_5: const #1s : i64
        let s_1279_5: i64 = 1;
        // C s_1279_6: cast zx s_1279_5 -> i
        let s_1279_6: i128 = (i128::try_from(s_1279_5).unwrap());
        // C s_1279_7: const #8s : i
        let s_1279_7: i128 = 8;
        // C s_1279_8: add s_1279_7 s_1279_6
        let s_1279_8: i128 = (s_1279_7 + s_1279_6);
        // D s_1279_9: bit-extract s_1279_4 s_1279_2 s_1279_8
        let s_1279_9: Bits = (Bits::new(
            ((s_1279_4) >> (s_1279_2)).value(),
            u16::try_from(s_1279_8).unwrap(),
        ));
        // D s_1279_10: cast reint s_1279_9 -> u9
        let s_1279_10: u16 = (s_1279_9.value() as u16);
        // D s_1279_11: cast zx s_1279_10 -> bv
        let s_1279_11: Bits = Bits::new(s_1279_10 as u128, 9u16);
        // C s_1279_12: const #487u : u9
        let s_1279_12: u16 = 487;
        // C s_1279_13: cast zx s_1279_12 -> bv
        let s_1279_13: Bits = Bits::new(s_1279_12 as u128, 9u16);
        // D s_1279_14: cmp-eq s_1279_11 s_1279_13
        let s_1279_14: bool = ((s_1279_11) == (s_1279_13));
        // N s_1279_15: branch s_1279_14 b1822 b1280
        if s_1279_14 {
            return block_1822(state, tracer, fn_state);
        } else {
            return block_1280(state, tracer, fn_state);
        };
    }
    fn block_1280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1280_0: const #0u : u8
        let s_1280_0: bool = false;
        // D s_1280_1: write-var gs#402940 <= s_1280_0
        fn_state.gs_402940 = s_1280_0;
        // N s_1280_2: jump b1281
        return block_1281(state, tracer, fn_state);
    }
    fn block_1281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1281_0: read-var gs#402940:u8
        let s_1281_0: bool = fn_state.gs_402940;
        // N s_1281_1: branch s_1281_0 b1821 b1282
        if s_1281_0 {
            return block_1821(state, tracer, fn_state);
        } else {
            return block_1282(state, tracer, fn_state);
        };
    }
    fn block_1282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1282_0: const #0u : u8
        let s_1282_0: bool = false;
        // D s_1282_1: write-var gs#402942 <= s_1282_0
        fn_state.gs_402942 = s_1282_0;
        // N s_1282_2: jump b1283
        return block_1283(state, tracer, fn_state);
    }
    fn block_1283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1283_0: read-var gs#402942:u8
        let s_1283_0: bool = fn_state.gs_402942;
        // D s_1283_1: not s_1283_0
        let s_1283_1: bool = !s_1283_0;
        // N s_1283_2: branch s_1283_1 b1285 b1284
        if s_1283_1 {
            return block_1285(state, tracer, fn_state);
        } else {
            return block_1284(state, tracer, fn_state);
        };
    }
    fn block_1284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1284_0: const #3750s : i
        let s_1284_0: i128 = 3750;
        // C s_1284_1: const #14696u : u32
        let s_1284_1: u32 = 14696;
        // N s_1284_2: write-reg s_1284_1 <= s_1284_0
        let s_1284_2: () = {
            state.write_register::<i128>(s_1284_1 as isize, s_1284_0);
            tracer.write_register(s_1284_1 as isize, s_1284_0);
        };
        // C s_1284_3: const #22s : i
        let s_1284_3: i128 = 22;
        // C s_1284_4: const #1s : i
        let s_1284_4: i128 = 1;
        // D s_1284_5: read-var u#32109:u32
        let s_1284_5: u32 = fn_state.u_32109;
        // D s_1284_6: cast zx s_1284_5 -> bv
        let s_1284_6: Bits = Bits::new(s_1284_5 as u128, 32u16);
        // D s_1284_7: bit-extract s_1284_6 s_1284_3 s_1284_4
        let s_1284_7: Bits = (Bits::new(
            ((s_1284_6) >> (s_1284_3)).value(),
            u16::try_from(s_1284_4).unwrap(),
        ));
        // D s_1284_8: cast reint s_1284_7 -> u8
        let s_1284_8: bool = ((s_1284_7.value()) != 0);
        // C s_1284_9: const #16s : i
        let s_1284_9: i128 = 16;
        // C s_1284_10: const #4s : i
        let s_1284_10: i128 = 4;
        // D s_1284_11: read-var u#32109:u32
        let s_1284_11: u32 = fn_state.u_32109;
        // D s_1284_12: cast zx s_1284_11 -> bv
        let s_1284_12: Bits = Bits::new(s_1284_11 as u128, 32u16);
        // D s_1284_13: bit-extract s_1284_12 s_1284_9 s_1284_10
        let s_1284_13: Bits = (Bits::new(
            ((s_1284_12) >> (s_1284_9)).value(),
            u16::try_from(s_1284_10).unwrap(),
        ));
        // D s_1284_14: cast reint s_1284_13 -> u8
        let s_1284_14: u8 = (s_1284_13.value() as u8);
        // C s_1284_15: const #12s : i
        let s_1284_15: i128 = 12;
        // C s_1284_16: const #4s : i
        let s_1284_16: i128 = 4;
        // D s_1284_17: read-var u#32109:u32
        let s_1284_17: u32 = fn_state.u_32109;
        // D s_1284_18: cast zx s_1284_17 -> bv
        let s_1284_18: Bits = Bits::new(s_1284_17 as u128, 32u16);
        // D s_1284_19: bit-extract s_1284_18 s_1284_15 s_1284_16
        let s_1284_19: Bits = (Bits::new(
            ((s_1284_18) >> (s_1284_15)).value(),
            u16::try_from(s_1284_16).unwrap(),
        ));
        // D s_1284_20: cast reint s_1284_19 -> u8
        let s_1284_20: u8 = (s_1284_19.value() as u8);
        // C s_1284_21: const #8s : i
        let s_1284_21: i128 = 8;
        // C s_1284_22: const #2s : i
        let s_1284_22: i128 = 2;
        // D s_1284_23: read-var u#32109:u32
        let s_1284_23: u32 = fn_state.u_32109;
        // D s_1284_24: cast zx s_1284_23 -> bv
        let s_1284_24: Bits = Bits::new(s_1284_23 as u128, 32u16);
        // D s_1284_25: bit-extract s_1284_24 s_1284_21 s_1284_22
        let s_1284_25: Bits = (Bits::new(
            ((s_1284_24) >> (s_1284_21)).value(),
            u16::try_from(s_1284_22).unwrap(),
        ));
        // D s_1284_26: cast reint s_1284_25 -> u8
        let s_1284_26: u8 = (s_1284_25.value() as u8);
        // C s_1284_27: const #7s : i
        let s_1284_27: i128 = 7;
        // C s_1284_28: const #1s : i
        let s_1284_28: i128 = 1;
        // D s_1284_29: read-var u#32109:u32
        let s_1284_29: u32 = fn_state.u_32109;
        // D s_1284_30: cast zx s_1284_29 -> bv
        let s_1284_30: Bits = Bits::new(s_1284_29 as u128, 32u16);
        // D s_1284_31: bit-extract s_1284_30 s_1284_27 s_1284_28
        let s_1284_31: Bits = (Bits::new(
            ((s_1284_30) >> (s_1284_27)).value(),
            u16::try_from(s_1284_28).unwrap(),
        ));
        // D s_1284_32: cast reint s_1284_31 -> u8
        let s_1284_32: bool = ((s_1284_31.value()) != 0);
        // C s_1284_33: const #6s : i
        let s_1284_33: i128 = 6;
        // C s_1284_34: const #1s : i
        let s_1284_34: i128 = 1;
        // D s_1284_35: read-var u#32109:u32
        let s_1284_35: u32 = fn_state.u_32109;
        // D s_1284_36: cast zx s_1284_35 -> bv
        let s_1284_36: Bits = Bits::new(s_1284_35 as u128, 32u16);
        // D s_1284_37: bit-extract s_1284_36 s_1284_33 s_1284_34
        let s_1284_37: Bits = (Bits::new(
            ((s_1284_36) >> (s_1284_33)).value(),
            u16::try_from(s_1284_34).unwrap(),
        ));
        // D s_1284_38: cast reint s_1284_37 -> u8
        let s_1284_38: bool = ((s_1284_37.value()) != 0);
        // C s_1284_39: const #5s : i
        let s_1284_39: i128 = 5;
        // C s_1284_40: const #1s : i
        let s_1284_40: i128 = 1;
        // D s_1284_41: read-var u#32109:u32
        let s_1284_41: u32 = fn_state.u_32109;
        // D s_1284_42: cast zx s_1284_41 -> bv
        let s_1284_42: Bits = Bits::new(s_1284_41 as u128, 32u16);
        // D s_1284_43: bit-extract s_1284_42 s_1284_39 s_1284_40
        let s_1284_43: Bits = (Bits::new(
            ((s_1284_42) >> (s_1284_39)).value(),
            u16::try_from(s_1284_40).unwrap(),
        ));
        // D s_1284_44: cast reint s_1284_43 -> u8
        let s_1284_44: bool = ((s_1284_43.value()) != 0);
        // C s_1284_45: const #0s : i
        let s_1284_45: i128 = 0;
        // C s_1284_46: const #4s : i
        let s_1284_46: i128 = 4;
        // D s_1284_47: read-var u#32109:u32
        let s_1284_47: u32 = fn_state.u_32109;
        // D s_1284_48: cast zx s_1284_47 -> bv
        let s_1284_48: Bits = Bits::new(s_1284_47 as u128, 32u16);
        // D s_1284_49: bit-extract s_1284_48 s_1284_45 s_1284_46
        let s_1284_49: Bits = (Bits::new(
            ((s_1284_48) >> (s_1284_45)).value(),
            u16::try_from(s_1284_46).unwrap(),
        ));
        // D s_1284_50: cast reint s_1284_49 -> u8
        let s_1284_50: u8 = (s_1284_49.value() as u8);
        // D s_1284_51: call decode_aarch32_instrs_VTBL_A1enc_A_txt(s_1284_8, s_1284_14, s_1284_20, s_1284_26, s_1284_32, s_1284_38, s_1284_44, s_1284_50)
        let s_1284_51: () = decode_aarch32_instrs_VTBL_A1enc_A_txt(
            state,
            tracer,
            s_1284_8,
            s_1284_14,
            s_1284_20,
            s_1284_26,
            s_1284_32,
            s_1284_38,
            s_1284_44,
            s_1284_50,
        );
        // N s_1284_52: return
        return;
    }
    fn block_1285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1285_0: read-var merge#var.1:struct
        let s_1285_0: u32 = fn_state.merge_var._1;
        // D s_1285_1: write-var u#32118 <= s_1285_0
        fn_state.u_32118 = s_1285_0;
        // C s_1285_2: const #23s : i
        let s_1285_2: i128 = 23;
        // D s_1285_3: read-var u#32118:u32
        let s_1285_3: u32 = fn_state.u_32118;
        // D s_1285_4: cast zx s_1285_3 -> bv
        let s_1285_4: Bits = Bits::new(s_1285_3 as u128, 32u16);
        // C s_1285_5: const #1s : i64
        let s_1285_5: i64 = 1;
        // C s_1285_6: cast zx s_1285_5 -> i
        let s_1285_6: i128 = (i128::try_from(s_1285_5).unwrap());
        // C s_1285_7: const #8s : i
        let s_1285_7: i128 = 8;
        // C s_1285_8: add s_1285_7 s_1285_6
        let s_1285_8: i128 = (s_1285_7 + s_1285_6);
        // D s_1285_9: bit-extract s_1285_4 s_1285_2 s_1285_8
        let s_1285_9: Bits = (Bits::new(
            ((s_1285_4) >> (s_1285_2)).value(),
            u16::try_from(s_1285_8).unwrap(),
        ));
        // D s_1285_10: cast reint s_1285_9 -> u9
        let s_1285_10: u16 = (s_1285_9.value() as u16);
        // D s_1285_11: cast zx s_1285_10 -> bv
        let s_1285_11: Bits = Bits::new(s_1285_10 as u128, 9u16);
        // C s_1285_12: const #487u : u9
        let s_1285_12: u16 = 487;
        // C s_1285_13: cast zx s_1285_12 -> bv
        let s_1285_13: Bits = Bits::new(s_1285_12 as u128, 9u16);
        // D s_1285_14: cmp-eq s_1285_11 s_1285_13
        let s_1285_14: bool = ((s_1285_11) == (s_1285_13));
        // N s_1285_15: branch s_1285_14 b1811 b1286
        if s_1285_14 {
            return block_1811(state, tracer, fn_state);
        } else {
            return block_1286(state, tracer, fn_state);
        };
    }
    fn block_1286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1286_0: const #0u : u8
        let s_1286_0: bool = false;
        // D s_1286_1: write-var gs#402975 <= s_1286_0
        fn_state.gs_402975 = s_1286_0;
        // N s_1286_2: jump b1287
        return block_1287(state, tracer, fn_state);
    }
    fn block_1287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1287_0: read-var gs#402975:u8
        let s_1287_0: bool = fn_state.gs_402975;
        // N s_1287_1: branch s_1287_0 b1810 b1288
        if s_1287_0 {
            return block_1810(state, tracer, fn_state);
        } else {
            return block_1288(state, tracer, fn_state);
        };
    }
    fn block_1288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1288_0: const #0u : u8
        let s_1288_0: bool = false;
        // D s_1288_1: write-var gs#402977 <= s_1288_0
        fn_state.gs_402977 = s_1288_0;
        // N s_1288_2: jump b1289
        return block_1289(state, tracer, fn_state);
    }
    fn block_1289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1289_0: read-var gs#402977:u8
        let s_1289_0: bool = fn_state.gs_402977;
        // D s_1289_1: not s_1289_0
        let s_1289_1: bool = !s_1289_0;
        // N s_1289_2: branch s_1289_1 b1291 b1290
        if s_1289_1 {
            return block_1291(state, tracer, fn_state);
        } else {
            return block_1290(state, tracer, fn_state);
        };
    }
    fn block_1290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1290_0: const #3752s : i
        let s_1290_0: i128 = 3752;
        // C s_1290_1: const #14696u : u32
        let s_1290_1: u32 = 14696;
        // N s_1290_2: write-reg s_1290_1 <= s_1290_0
        let s_1290_2: () = {
            state.write_register::<i128>(s_1290_1 as isize, s_1290_0);
            tracer.write_register(s_1290_1 as isize, s_1290_0);
        };
        // C s_1290_3: const #22s : i
        let s_1290_3: i128 = 22;
        // C s_1290_4: const #1s : i
        let s_1290_4: i128 = 1;
        // D s_1290_5: read-var u#32118:u32
        let s_1290_5: u32 = fn_state.u_32118;
        // D s_1290_6: cast zx s_1290_5 -> bv
        let s_1290_6: Bits = Bits::new(s_1290_5 as u128, 32u16);
        // D s_1290_7: bit-extract s_1290_6 s_1290_3 s_1290_4
        let s_1290_7: Bits = (Bits::new(
            ((s_1290_6) >> (s_1290_3)).value(),
            u16::try_from(s_1290_4).unwrap(),
        ));
        // D s_1290_8: cast reint s_1290_7 -> u8
        let s_1290_8: bool = ((s_1290_7.value()) != 0);
        // C s_1290_9: const #18s : i
        let s_1290_9: i128 = 18;
        // C s_1290_10: const #2s : i
        let s_1290_10: i128 = 2;
        // D s_1290_11: read-var u#32118:u32
        let s_1290_11: u32 = fn_state.u_32118;
        // D s_1290_12: cast zx s_1290_11 -> bv
        let s_1290_12: Bits = Bits::new(s_1290_11 as u128, 32u16);
        // D s_1290_13: bit-extract s_1290_12 s_1290_9 s_1290_10
        let s_1290_13: Bits = (Bits::new(
            ((s_1290_12) >> (s_1290_9)).value(),
            u16::try_from(s_1290_10).unwrap(),
        ));
        // D s_1290_14: cast reint s_1290_13 -> u8
        let s_1290_14: u8 = (s_1290_13.value() as u8);
        // C s_1290_15: const #12s : i
        let s_1290_15: i128 = 12;
        // C s_1290_16: const #4s : i
        let s_1290_16: i128 = 4;
        // D s_1290_17: read-var u#32118:u32
        let s_1290_17: u32 = fn_state.u_32118;
        // D s_1290_18: cast zx s_1290_17 -> bv
        let s_1290_18: Bits = Bits::new(s_1290_17 as u128, 32u16);
        // D s_1290_19: bit-extract s_1290_18 s_1290_15 s_1290_16
        let s_1290_19: Bits = (Bits::new(
            ((s_1290_18) >> (s_1290_15)).value(),
            u16::try_from(s_1290_16).unwrap(),
        ));
        // D s_1290_20: cast reint s_1290_19 -> u8
        let s_1290_20: u8 = (s_1290_19.value() as u8);
        // C s_1290_21: const #6s : i
        let s_1290_21: i128 = 6;
        // C s_1290_22: const #1s : i
        let s_1290_22: i128 = 1;
        // D s_1290_23: read-var u#32118:u32
        let s_1290_23: u32 = fn_state.u_32118;
        // D s_1290_24: cast zx s_1290_23 -> bv
        let s_1290_24: Bits = Bits::new(s_1290_23 as u128, 32u16);
        // D s_1290_25: bit-extract s_1290_24 s_1290_21 s_1290_22
        let s_1290_25: Bits = (Bits::new(
            ((s_1290_24) >> (s_1290_21)).value(),
            u16::try_from(s_1290_22).unwrap(),
        ));
        // D s_1290_26: cast reint s_1290_25 -> u8
        let s_1290_26: bool = ((s_1290_25.value()) != 0);
        // C s_1290_27: const #5s : i
        let s_1290_27: i128 = 5;
        // C s_1290_28: const #1s : i
        let s_1290_28: i128 = 1;
        // D s_1290_29: read-var u#32118:u32
        let s_1290_29: u32 = fn_state.u_32118;
        // D s_1290_30: cast zx s_1290_29 -> bv
        let s_1290_30: Bits = Bits::new(s_1290_29 as u128, 32u16);
        // D s_1290_31: bit-extract s_1290_30 s_1290_27 s_1290_28
        let s_1290_31: Bits = (Bits::new(
            ((s_1290_30) >> (s_1290_27)).value(),
            u16::try_from(s_1290_28).unwrap(),
        ));
        // D s_1290_32: cast reint s_1290_31 -> u8
        let s_1290_32: bool = ((s_1290_31.value()) != 0);
        // C s_1290_33: const #0s : i
        let s_1290_33: i128 = 0;
        // C s_1290_34: const #4s : i
        let s_1290_34: i128 = 4;
        // D s_1290_35: read-var u#32118:u32
        let s_1290_35: u32 = fn_state.u_32118;
        // D s_1290_36: cast zx s_1290_35 -> bv
        let s_1290_36: Bits = Bits::new(s_1290_35 as u128, 32u16);
        // D s_1290_37: bit-extract s_1290_36 s_1290_33 s_1290_34
        let s_1290_37: Bits = (Bits::new(
            ((s_1290_36) >> (s_1290_33)).value(),
            u16::try_from(s_1290_34).unwrap(),
        ));
        // D s_1290_38: cast reint s_1290_37 -> u8
        let s_1290_38: u8 = (s_1290_37.value() as u8);
        // D s_1290_39: call decode_aarch32_instrs_VTRN_A1enc_A_txt(s_1290_8, s_1290_14, s_1290_20, s_1290_26, s_1290_32, s_1290_38)
        let s_1290_39: () = decode_aarch32_instrs_VTRN_A1enc_A_txt(
            state,
            tracer,
            s_1290_8,
            s_1290_14,
            s_1290_20,
            s_1290_26,
            s_1290_32,
            s_1290_38,
        );
        // N s_1290_40: return
        return;
    }
    fn block_1291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1291_0: read-var merge#var.1:struct
        let s_1291_0: u32 = fn_state.merge_var._1;
        // D s_1291_1: write-var u#32126 <= s_1291_0
        fn_state.u_32126 = s_1291_0;
        // C s_1291_2: const #23s : i
        let s_1291_2: i128 = 23;
        // D s_1291_3: read-var u#32126:u32
        let s_1291_3: u32 = fn_state.u_32126;
        // D s_1291_4: cast zx s_1291_3 -> bv
        let s_1291_4: Bits = Bits::new(s_1291_3 as u128, 32u16);
        // C s_1291_5: const #1s : i64
        let s_1291_5: i64 = 1;
        // C s_1291_6: cast zx s_1291_5 -> i
        let s_1291_6: i128 = (i128::try_from(s_1291_5).unwrap());
        // C s_1291_7: const #8s : i
        let s_1291_7: i128 = 8;
        // C s_1291_8: add s_1291_7 s_1291_6
        let s_1291_8: i128 = (s_1291_7 + s_1291_6);
        // D s_1291_9: bit-extract s_1291_4 s_1291_2 s_1291_8
        let s_1291_9: Bits = (Bits::new(
            ((s_1291_4) >> (s_1291_2)).value(),
            u16::try_from(s_1291_8).unwrap(),
        ));
        // D s_1291_10: cast reint s_1291_9 -> u9
        let s_1291_10: u16 = (s_1291_9.value() as u16);
        // D s_1291_11: cast zx s_1291_10 -> bv
        let s_1291_11: Bits = Bits::new(s_1291_10 as u128, 9u16);
        // C s_1291_12: const #484u : u9
        let s_1291_12: u16 = 484;
        // C s_1291_13: cast zx s_1291_12 -> bv
        let s_1291_13: Bits = Bits::new(s_1291_12 as u128, 9u16);
        // D s_1291_14: cmp-eq s_1291_11 s_1291_13
        let s_1291_14: bool = ((s_1291_11) == (s_1291_13));
        // N s_1291_15: branch s_1291_14 b1806 b1292
        if s_1291_14 {
            return block_1806(state, tracer, fn_state);
        } else {
            return block_1292(state, tracer, fn_state);
        };
    }
    fn block_1292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1292_0: const #0u : u8
        let s_1292_0: bool = false;
        // D s_1292_1: write-var gs#403000 <= s_1292_0
        fn_state.gs_403000 = s_1292_0;
        // N s_1292_2: jump b1293
        return block_1293(state, tracer, fn_state);
    }
    fn block_1293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1293_0: read-var gs#403000:u8
        let s_1293_0: bool = fn_state.gs_403000;
        // N s_1293_1: branch s_1293_0 b1805 b1294
        if s_1293_0 {
            return block_1805(state, tracer, fn_state);
        } else {
            return block_1294(state, tracer, fn_state);
        };
    }
    fn block_1294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1294_0: const #0u : u8
        let s_1294_0: bool = false;
        // D s_1294_1: write-var gs#403002 <= s_1294_0
        fn_state.gs_403002 = s_1294_0;
        // N s_1294_2: jump b1295
        return block_1295(state, tracer, fn_state);
    }
    fn block_1295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1295_0: read-var gs#403002:u8
        let s_1295_0: bool = fn_state.gs_403002;
        // D s_1295_1: not s_1295_0
        let s_1295_1: bool = !s_1295_0;
        // N s_1295_2: branch s_1295_1 b1297 b1296
        if s_1295_1 {
            return block_1297(state, tracer, fn_state);
        } else {
            return block_1296(state, tracer, fn_state);
        };
    }
    fn block_1296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1296_0: const #3754s : i
        let s_1296_0: i128 = 3754;
        // C s_1296_1: const #14696u : u32
        let s_1296_1: u32 = 14696;
        // N s_1296_2: write-reg s_1296_1 <= s_1296_0
        let s_1296_2: () = {
            state.write_register::<i128>(s_1296_1 as isize, s_1296_0);
            tracer.write_register(s_1296_1 as isize, s_1296_0);
        };
        // C s_1296_3: const #22s : i
        let s_1296_3: i128 = 22;
        // C s_1296_4: const #1s : i
        let s_1296_4: i128 = 1;
        // D s_1296_5: read-var u#32126:u32
        let s_1296_5: u32 = fn_state.u_32126;
        // D s_1296_6: cast zx s_1296_5 -> bv
        let s_1296_6: Bits = Bits::new(s_1296_5 as u128, 32u16);
        // D s_1296_7: bit-extract s_1296_6 s_1296_3 s_1296_4
        let s_1296_7: Bits = (Bits::new(
            ((s_1296_6) >> (s_1296_3)).value(),
            u16::try_from(s_1296_4).unwrap(),
        ));
        // D s_1296_8: cast reint s_1296_7 -> u8
        let s_1296_8: bool = ((s_1296_7.value()) != 0);
        // C s_1296_9: const #20s : i
        let s_1296_9: i128 = 20;
        // C s_1296_10: const #2s : i
        let s_1296_10: i128 = 2;
        // D s_1296_11: read-var u#32126:u32
        let s_1296_11: u32 = fn_state.u_32126;
        // D s_1296_12: cast zx s_1296_11 -> bv
        let s_1296_12: Bits = Bits::new(s_1296_11 as u128, 32u16);
        // D s_1296_13: bit-extract s_1296_12 s_1296_9 s_1296_10
        let s_1296_13: Bits = (Bits::new(
            ((s_1296_12) >> (s_1296_9)).value(),
            u16::try_from(s_1296_10).unwrap(),
        ));
        // D s_1296_14: cast reint s_1296_13 -> u8
        let s_1296_14: u8 = (s_1296_13.value() as u8);
        // C s_1296_15: const #16s : i
        let s_1296_15: i128 = 16;
        // C s_1296_16: const #4s : i
        let s_1296_16: i128 = 4;
        // D s_1296_17: read-var u#32126:u32
        let s_1296_17: u32 = fn_state.u_32126;
        // D s_1296_18: cast zx s_1296_17 -> bv
        let s_1296_18: Bits = Bits::new(s_1296_17 as u128, 32u16);
        // D s_1296_19: bit-extract s_1296_18 s_1296_15 s_1296_16
        let s_1296_19: Bits = (Bits::new(
            ((s_1296_18) >> (s_1296_15)).value(),
            u16::try_from(s_1296_16).unwrap(),
        ));
        // D s_1296_20: cast reint s_1296_19 -> u8
        let s_1296_20: u8 = (s_1296_19.value() as u8);
        // C s_1296_21: const #12s : i
        let s_1296_21: i128 = 12;
        // C s_1296_22: const #4s : i
        let s_1296_22: i128 = 4;
        // D s_1296_23: read-var u#32126:u32
        let s_1296_23: u32 = fn_state.u_32126;
        // D s_1296_24: cast zx s_1296_23 -> bv
        let s_1296_24: Bits = Bits::new(s_1296_23 as u128, 32u16);
        // D s_1296_25: bit-extract s_1296_24 s_1296_21 s_1296_22
        let s_1296_25: Bits = (Bits::new(
            ((s_1296_24) >> (s_1296_21)).value(),
            u16::try_from(s_1296_22).unwrap(),
        ));
        // D s_1296_26: cast reint s_1296_25 -> u8
        let s_1296_26: u8 = (s_1296_25.value() as u8);
        // C s_1296_27: const #7s : i
        let s_1296_27: i128 = 7;
        // C s_1296_28: const #1s : i
        let s_1296_28: i128 = 1;
        // D s_1296_29: read-var u#32126:u32
        let s_1296_29: u32 = fn_state.u_32126;
        // D s_1296_30: cast zx s_1296_29 -> bv
        let s_1296_30: Bits = Bits::new(s_1296_29 as u128, 32u16);
        // D s_1296_31: bit-extract s_1296_30 s_1296_27 s_1296_28
        let s_1296_31: Bits = (Bits::new(
            ((s_1296_30) >> (s_1296_27)).value(),
            u16::try_from(s_1296_28).unwrap(),
        ));
        // D s_1296_32: cast reint s_1296_31 -> u8
        let s_1296_32: bool = ((s_1296_31.value()) != 0);
        // C s_1296_33: const #6s : i
        let s_1296_33: i128 = 6;
        // C s_1296_34: const #1s : i
        let s_1296_34: i128 = 1;
        // D s_1296_35: read-var u#32126:u32
        let s_1296_35: u32 = fn_state.u_32126;
        // D s_1296_36: cast zx s_1296_35 -> bv
        let s_1296_36: Bits = Bits::new(s_1296_35 as u128, 32u16);
        // D s_1296_37: bit-extract s_1296_36 s_1296_33 s_1296_34
        let s_1296_37: Bits = (Bits::new(
            ((s_1296_36) >> (s_1296_33)).value(),
            u16::try_from(s_1296_34).unwrap(),
        ));
        // D s_1296_38: cast reint s_1296_37 -> u8
        let s_1296_38: bool = ((s_1296_37.value()) != 0);
        // C s_1296_39: const #5s : i
        let s_1296_39: i128 = 5;
        // C s_1296_40: const #1s : i
        let s_1296_40: i128 = 1;
        // D s_1296_41: read-var u#32126:u32
        let s_1296_41: u32 = fn_state.u_32126;
        // D s_1296_42: cast zx s_1296_41 -> bv
        let s_1296_42: Bits = Bits::new(s_1296_41 as u128, 32u16);
        // D s_1296_43: bit-extract s_1296_42 s_1296_39 s_1296_40
        let s_1296_43: Bits = (Bits::new(
            ((s_1296_42) >> (s_1296_39)).value(),
            u16::try_from(s_1296_40).unwrap(),
        ));
        // D s_1296_44: cast reint s_1296_43 -> u8
        let s_1296_44: bool = ((s_1296_43.value()) != 0);
        // C s_1296_45: const #0s : i
        let s_1296_45: i128 = 0;
        // C s_1296_46: const #4s : i
        let s_1296_46: i128 = 4;
        // D s_1296_47: read-var u#32126:u32
        let s_1296_47: u32 = fn_state.u_32126;
        // D s_1296_48: cast zx s_1296_47 -> bv
        let s_1296_48: Bits = Bits::new(s_1296_47 as u128, 32u16);
        // D s_1296_49: bit-extract s_1296_48 s_1296_45 s_1296_46
        let s_1296_49: Bits = (Bits::new(
            ((s_1296_48) >> (s_1296_45)).value(),
            u16::try_from(s_1296_46).unwrap(),
        ));
        // D s_1296_50: cast reint s_1296_49 -> u8
        let s_1296_50: u8 = (s_1296_49.value() as u8);
        // D s_1296_51: call decode_aarch32_instrs_VTST_A1enc_A_txt(s_1296_8, s_1296_14, s_1296_20, s_1296_26, s_1296_32, s_1296_38, s_1296_44, s_1296_50)
        let s_1296_51: () = decode_aarch32_instrs_VTST_A1enc_A_txt(
            state,
            tracer,
            s_1296_8,
            s_1296_14,
            s_1296_20,
            s_1296_26,
            s_1296_32,
            s_1296_38,
            s_1296_44,
            s_1296_50,
        );
        // N s_1296_52: return
        return;
    }
    fn block_1297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1297_0: read-var merge#var.1:struct
        let s_1297_0: u32 = fn_state.merge_var._1;
        // D s_1297_1: write-var u#32136 <= s_1297_0
        fn_state.u_32136 = s_1297_0;
        // C s_1297_2: const #23s : i
        let s_1297_2: i128 = 23;
        // D s_1297_3: read-var u#32136:u32
        let s_1297_3: u32 = fn_state.u_32136;
        // D s_1297_4: cast zx s_1297_3 -> bv
        let s_1297_4: Bits = Bits::new(s_1297_3 as u128, 32u16);
        // C s_1297_5: const #1s : i64
        let s_1297_5: i64 = 1;
        // C s_1297_6: cast zx s_1297_5 -> i
        let s_1297_6: i128 = (i128::try_from(s_1297_5).unwrap());
        // C s_1297_7: const #8s : i
        let s_1297_7: i128 = 8;
        // C s_1297_8: add s_1297_7 s_1297_6
        let s_1297_8: i128 = (s_1297_7 + s_1297_6);
        // D s_1297_9: bit-extract s_1297_4 s_1297_2 s_1297_8
        let s_1297_9: Bits = (Bits::new(
            ((s_1297_4) >> (s_1297_2)).value(),
            u16::try_from(s_1297_8).unwrap(),
        ));
        // D s_1297_10: cast reint s_1297_9 -> u9
        let s_1297_10: u16 = (s_1297_9.value() as u16);
        // D s_1297_11: cast zx s_1297_10 -> bv
        let s_1297_11: Bits = Bits::new(s_1297_10 as u128, 9u16);
        // C s_1297_12: const #487u : u9
        let s_1297_12: u16 = 487;
        // C s_1297_13: cast zx s_1297_12 -> bv
        let s_1297_13: Bits = Bits::new(s_1297_12 as u128, 9u16);
        // D s_1297_14: cmp-eq s_1297_11 s_1297_13
        let s_1297_14: bool = ((s_1297_11) == (s_1297_13));
        // N s_1297_15: branch s_1297_14 b1795 b1298
        if s_1297_14 {
            return block_1795(state, tracer, fn_state);
        } else {
            return block_1298(state, tracer, fn_state);
        };
    }
    fn block_1298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1298_0: const #0u : u8
        let s_1298_0: bool = false;
        // D s_1298_1: write-var gs#403035 <= s_1298_0
        fn_state.gs_403035 = s_1298_0;
        // N s_1298_2: jump b1299
        return block_1299(state, tracer, fn_state);
    }
    fn block_1299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1299_0: read-var gs#403035:u8
        let s_1299_0: bool = fn_state.gs_403035;
        // N s_1299_1: branch s_1299_0 b1794 b1300
        if s_1299_0 {
            return block_1794(state, tracer, fn_state);
        } else {
            return block_1300(state, tracer, fn_state);
        };
    }
    fn block_1300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1300_0: const #0u : u8
        let s_1300_0: bool = false;
        // D s_1300_1: write-var gs#403037 <= s_1300_0
        fn_state.gs_403037 = s_1300_0;
        // N s_1300_2: jump b1301
        return block_1301(state, tracer, fn_state);
    }
    fn block_1301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1301_0: read-var gs#403037:u8
        let s_1301_0: bool = fn_state.gs_403037;
        // D s_1301_1: not s_1301_0
        let s_1301_1: bool = !s_1301_0;
        // N s_1301_2: branch s_1301_1 b1303 b1302
        if s_1301_1 {
            return block_1303(state, tracer, fn_state);
        } else {
            return block_1302(state, tracer, fn_state);
        };
    }
    fn block_1302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1302_0: const #3756s : i
        let s_1302_0: i128 = 3756;
        // C s_1302_1: const #14696u : u32
        let s_1302_1: u32 = 14696;
        // N s_1302_2: write-reg s_1302_1 <= s_1302_0
        let s_1302_2: () = {
            state.write_register::<i128>(s_1302_1 as isize, s_1302_0);
            tracer.write_register(s_1302_1 as isize, s_1302_0);
        };
        // C s_1302_3: const #22s : i
        let s_1302_3: i128 = 22;
        // C s_1302_4: const #1s : i
        let s_1302_4: i128 = 1;
        // D s_1302_5: read-var u#32136:u32
        let s_1302_5: u32 = fn_state.u_32136;
        // D s_1302_6: cast zx s_1302_5 -> bv
        let s_1302_6: Bits = Bits::new(s_1302_5 as u128, 32u16);
        // D s_1302_7: bit-extract s_1302_6 s_1302_3 s_1302_4
        let s_1302_7: Bits = (Bits::new(
            ((s_1302_6) >> (s_1302_3)).value(),
            u16::try_from(s_1302_4).unwrap(),
        ));
        // D s_1302_8: cast reint s_1302_7 -> u8
        let s_1302_8: bool = ((s_1302_7.value()) != 0);
        // C s_1302_9: const #18s : i
        let s_1302_9: i128 = 18;
        // C s_1302_10: const #2s : i
        let s_1302_10: i128 = 2;
        // D s_1302_11: read-var u#32136:u32
        let s_1302_11: u32 = fn_state.u_32136;
        // D s_1302_12: cast zx s_1302_11 -> bv
        let s_1302_12: Bits = Bits::new(s_1302_11 as u128, 32u16);
        // D s_1302_13: bit-extract s_1302_12 s_1302_9 s_1302_10
        let s_1302_13: Bits = (Bits::new(
            ((s_1302_12) >> (s_1302_9)).value(),
            u16::try_from(s_1302_10).unwrap(),
        ));
        // D s_1302_14: cast reint s_1302_13 -> u8
        let s_1302_14: u8 = (s_1302_13.value() as u8);
        // C s_1302_15: const #12s : i
        let s_1302_15: i128 = 12;
        // C s_1302_16: const #4s : i
        let s_1302_16: i128 = 4;
        // D s_1302_17: read-var u#32136:u32
        let s_1302_17: u32 = fn_state.u_32136;
        // D s_1302_18: cast zx s_1302_17 -> bv
        let s_1302_18: Bits = Bits::new(s_1302_17 as u128, 32u16);
        // D s_1302_19: bit-extract s_1302_18 s_1302_15 s_1302_16
        let s_1302_19: Bits = (Bits::new(
            ((s_1302_18) >> (s_1302_15)).value(),
            u16::try_from(s_1302_16).unwrap(),
        ));
        // D s_1302_20: cast reint s_1302_19 -> u8
        let s_1302_20: u8 = (s_1302_19.value() as u8);
        // C s_1302_21: const #6s : i
        let s_1302_21: i128 = 6;
        // C s_1302_22: const #1s : i
        let s_1302_22: i128 = 1;
        // D s_1302_23: read-var u#32136:u32
        let s_1302_23: u32 = fn_state.u_32136;
        // D s_1302_24: cast zx s_1302_23 -> bv
        let s_1302_24: Bits = Bits::new(s_1302_23 as u128, 32u16);
        // D s_1302_25: bit-extract s_1302_24 s_1302_21 s_1302_22
        let s_1302_25: Bits = (Bits::new(
            ((s_1302_24) >> (s_1302_21)).value(),
            u16::try_from(s_1302_22).unwrap(),
        ));
        // D s_1302_26: cast reint s_1302_25 -> u8
        let s_1302_26: bool = ((s_1302_25.value()) != 0);
        // C s_1302_27: const #5s : i
        let s_1302_27: i128 = 5;
        // C s_1302_28: const #1s : i
        let s_1302_28: i128 = 1;
        // D s_1302_29: read-var u#32136:u32
        let s_1302_29: u32 = fn_state.u_32136;
        // D s_1302_30: cast zx s_1302_29 -> bv
        let s_1302_30: Bits = Bits::new(s_1302_29 as u128, 32u16);
        // D s_1302_31: bit-extract s_1302_30 s_1302_27 s_1302_28
        let s_1302_31: Bits = (Bits::new(
            ((s_1302_30) >> (s_1302_27)).value(),
            u16::try_from(s_1302_28).unwrap(),
        ));
        // D s_1302_32: cast reint s_1302_31 -> u8
        let s_1302_32: bool = ((s_1302_31.value()) != 0);
        // C s_1302_33: const #0s : i
        let s_1302_33: i128 = 0;
        // C s_1302_34: const #4s : i
        let s_1302_34: i128 = 4;
        // D s_1302_35: read-var u#32136:u32
        let s_1302_35: u32 = fn_state.u_32136;
        // D s_1302_36: cast zx s_1302_35 -> bv
        let s_1302_36: Bits = Bits::new(s_1302_35 as u128, 32u16);
        // D s_1302_37: bit-extract s_1302_36 s_1302_33 s_1302_34
        let s_1302_37: Bits = (Bits::new(
            ((s_1302_36) >> (s_1302_33)).value(),
            u16::try_from(s_1302_34).unwrap(),
        ));
        // D s_1302_38: cast reint s_1302_37 -> u8
        let s_1302_38: u8 = (s_1302_37.value() as u8);
        // D s_1302_39: call decode_aarch32_instrs_VUZP_A1enc_A_txt(s_1302_8, s_1302_14, s_1302_20, s_1302_26, s_1302_32, s_1302_38)
        let s_1302_39: () = decode_aarch32_instrs_VUZP_A1enc_A_txt(
            state,
            tracer,
            s_1302_8,
            s_1302_14,
            s_1302_20,
            s_1302_26,
            s_1302_32,
            s_1302_38,
        );
        // N s_1302_40: return
        return;
    }
    fn block_1303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1303_0: read-var merge#var.1:struct
        let s_1303_0: u32 = fn_state.merge_var._1;
        // D s_1303_1: write-var u#32144 <= s_1303_0
        fn_state.u_32144 = s_1303_0;
        // C s_1303_2: const #23s : i
        let s_1303_2: i128 = 23;
        // D s_1303_3: read-var u#32144:u32
        let s_1303_3: u32 = fn_state.u_32144;
        // D s_1303_4: cast zx s_1303_3 -> bv
        let s_1303_4: Bits = Bits::new(s_1303_3 as u128, 32u16);
        // C s_1303_5: const #1s : i64
        let s_1303_5: i64 = 1;
        // C s_1303_6: cast zx s_1303_5 -> i
        let s_1303_6: i128 = (i128::try_from(s_1303_5).unwrap());
        // C s_1303_7: const #8s : i
        let s_1303_7: i128 = 8;
        // C s_1303_8: add s_1303_7 s_1303_6
        let s_1303_8: i128 = (s_1303_7 + s_1303_6);
        // D s_1303_9: bit-extract s_1303_4 s_1303_2 s_1303_8
        let s_1303_9: Bits = (Bits::new(
            ((s_1303_4) >> (s_1303_2)).value(),
            u16::try_from(s_1303_8).unwrap(),
        ));
        // D s_1303_10: cast reint s_1303_9 -> u9
        let s_1303_10: u16 = (s_1303_9.value() as u16);
        // D s_1303_11: cast zx s_1303_10 -> bv
        let s_1303_11: Bits = Bits::new(s_1303_10 as u128, 9u16);
        // C s_1303_12: const #487u : u9
        let s_1303_12: u16 = 487;
        // C s_1303_13: cast zx s_1303_12 -> bv
        let s_1303_13: Bits = Bits::new(s_1303_12 as u128, 9u16);
        // D s_1303_14: cmp-eq s_1303_11 s_1303_13
        let s_1303_14: bool = ((s_1303_11) == (s_1303_13));
        // N s_1303_15: branch s_1303_14 b1784 b1304
        if s_1303_14 {
            return block_1784(state, tracer, fn_state);
        } else {
            return block_1304(state, tracer, fn_state);
        };
    }
    fn block_1304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1304_0: const #0u : u8
        let s_1304_0: bool = false;
        // D s_1304_1: write-var gs#403066 <= s_1304_0
        fn_state.gs_403066 = s_1304_0;
        // N s_1304_2: jump b1305
        return block_1305(state, tracer, fn_state);
    }
    fn block_1305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1305_0: read-var gs#403066:u8
        let s_1305_0: bool = fn_state.gs_403066;
        // N s_1305_1: branch s_1305_0 b1783 b1306
        if s_1305_0 {
            return block_1783(state, tracer, fn_state);
        } else {
            return block_1306(state, tracer, fn_state);
        };
    }
    fn block_1306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1306_0: const #0u : u8
        let s_1306_0: bool = false;
        // D s_1306_1: write-var gs#403068 <= s_1306_0
        fn_state.gs_403068 = s_1306_0;
        // N s_1306_2: jump b1307
        return block_1307(state, tracer, fn_state);
    }
    fn block_1307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1307_0: read-var gs#403068:u8
        let s_1307_0: bool = fn_state.gs_403068;
        // D s_1307_1: not s_1307_0
        let s_1307_1: bool = !s_1307_0;
        // N s_1307_2: branch s_1307_1 b1309 b1308
        if s_1307_1 {
            return block_1309(state, tracer, fn_state);
        } else {
            return block_1308(state, tracer, fn_state);
        };
    }
    fn block_1308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1308_0: const #3758s : i
        let s_1308_0: i128 = 3758;
        // C s_1308_1: const #14696u : u32
        let s_1308_1: u32 = 14696;
        // N s_1308_2: write-reg s_1308_1 <= s_1308_0
        let s_1308_2: () = {
            state.write_register::<i128>(s_1308_1 as isize, s_1308_0);
            tracer.write_register(s_1308_1 as isize, s_1308_0);
        };
        // C s_1308_3: const #22s : i
        let s_1308_3: i128 = 22;
        // C s_1308_4: const #1s : i
        let s_1308_4: i128 = 1;
        // D s_1308_5: read-var u#32144:u32
        let s_1308_5: u32 = fn_state.u_32144;
        // D s_1308_6: cast zx s_1308_5 -> bv
        let s_1308_6: Bits = Bits::new(s_1308_5 as u128, 32u16);
        // D s_1308_7: bit-extract s_1308_6 s_1308_3 s_1308_4
        let s_1308_7: Bits = (Bits::new(
            ((s_1308_6) >> (s_1308_3)).value(),
            u16::try_from(s_1308_4).unwrap(),
        ));
        // D s_1308_8: cast reint s_1308_7 -> u8
        let s_1308_8: bool = ((s_1308_7.value()) != 0);
        // C s_1308_9: const #18s : i
        let s_1308_9: i128 = 18;
        // C s_1308_10: const #2s : i
        let s_1308_10: i128 = 2;
        // D s_1308_11: read-var u#32144:u32
        let s_1308_11: u32 = fn_state.u_32144;
        // D s_1308_12: cast zx s_1308_11 -> bv
        let s_1308_12: Bits = Bits::new(s_1308_11 as u128, 32u16);
        // D s_1308_13: bit-extract s_1308_12 s_1308_9 s_1308_10
        let s_1308_13: Bits = (Bits::new(
            ((s_1308_12) >> (s_1308_9)).value(),
            u16::try_from(s_1308_10).unwrap(),
        ));
        // D s_1308_14: cast reint s_1308_13 -> u8
        let s_1308_14: u8 = (s_1308_13.value() as u8);
        // C s_1308_15: const #12s : i
        let s_1308_15: i128 = 12;
        // C s_1308_16: const #4s : i
        let s_1308_16: i128 = 4;
        // D s_1308_17: read-var u#32144:u32
        let s_1308_17: u32 = fn_state.u_32144;
        // D s_1308_18: cast zx s_1308_17 -> bv
        let s_1308_18: Bits = Bits::new(s_1308_17 as u128, 32u16);
        // D s_1308_19: bit-extract s_1308_18 s_1308_15 s_1308_16
        let s_1308_19: Bits = (Bits::new(
            ((s_1308_18) >> (s_1308_15)).value(),
            u16::try_from(s_1308_16).unwrap(),
        ));
        // D s_1308_20: cast reint s_1308_19 -> u8
        let s_1308_20: u8 = (s_1308_19.value() as u8);
        // C s_1308_21: const #6s : i
        let s_1308_21: i128 = 6;
        // C s_1308_22: const #1s : i
        let s_1308_22: i128 = 1;
        // D s_1308_23: read-var u#32144:u32
        let s_1308_23: u32 = fn_state.u_32144;
        // D s_1308_24: cast zx s_1308_23 -> bv
        let s_1308_24: Bits = Bits::new(s_1308_23 as u128, 32u16);
        // D s_1308_25: bit-extract s_1308_24 s_1308_21 s_1308_22
        let s_1308_25: Bits = (Bits::new(
            ((s_1308_24) >> (s_1308_21)).value(),
            u16::try_from(s_1308_22).unwrap(),
        ));
        // D s_1308_26: cast reint s_1308_25 -> u8
        let s_1308_26: bool = ((s_1308_25.value()) != 0);
        // C s_1308_27: const #5s : i
        let s_1308_27: i128 = 5;
        // C s_1308_28: const #1s : i
        let s_1308_28: i128 = 1;
        // D s_1308_29: read-var u#32144:u32
        let s_1308_29: u32 = fn_state.u_32144;
        // D s_1308_30: cast zx s_1308_29 -> bv
        let s_1308_30: Bits = Bits::new(s_1308_29 as u128, 32u16);
        // D s_1308_31: bit-extract s_1308_30 s_1308_27 s_1308_28
        let s_1308_31: Bits = (Bits::new(
            ((s_1308_30) >> (s_1308_27)).value(),
            u16::try_from(s_1308_28).unwrap(),
        ));
        // D s_1308_32: cast reint s_1308_31 -> u8
        let s_1308_32: bool = ((s_1308_31.value()) != 0);
        // C s_1308_33: const #0s : i
        let s_1308_33: i128 = 0;
        // C s_1308_34: const #4s : i
        let s_1308_34: i128 = 4;
        // D s_1308_35: read-var u#32144:u32
        let s_1308_35: u32 = fn_state.u_32144;
        // D s_1308_36: cast zx s_1308_35 -> bv
        let s_1308_36: Bits = Bits::new(s_1308_35 as u128, 32u16);
        // D s_1308_37: bit-extract s_1308_36 s_1308_33 s_1308_34
        let s_1308_37: Bits = (Bits::new(
            ((s_1308_36) >> (s_1308_33)).value(),
            u16::try_from(s_1308_34).unwrap(),
        ));
        // D s_1308_38: cast reint s_1308_37 -> u8
        let s_1308_38: u8 = (s_1308_37.value() as u8);
        // D s_1308_39: call decode_aarch32_instrs_VZIP_A1enc_A_txt(s_1308_8, s_1308_14, s_1308_20, s_1308_26, s_1308_32, s_1308_38)
        let s_1308_39: () = decode_aarch32_instrs_VZIP_A1enc_A_txt(
            state,
            tracer,
            s_1308_8,
            s_1308_14,
            s_1308_20,
            s_1308_26,
            s_1308_32,
            s_1308_38,
        );
        // N s_1308_40: return
        return;
    }
    fn block_1309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1309_0: read-var merge#var.1:struct
        let s_1309_0: u32 = fn_state.merge_var._1;
        // D s_1309_1: write-var u#32152 <= s_1309_0
        fn_state.u_32152 = s_1309_0;
        // C s_1309_2: const #20s : i
        let s_1309_2: i128 = 20;
        // D s_1309_3: read-var u#32152:u32
        let s_1309_3: u32 = fn_state.u_32152;
        // D s_1309_4: cast zx s_1309_3 -> bv
        let s_1309_4: Bits = Bits::new(s_1309_3 as u128, 32u16);
        // C s_1309_5: const #1s : i64
        let s_1309_5: i64 = 1;
        // C s_1309_6: cast zx s_1309_5 -> i
        let s_1309_6: i128 = (i128::try_from(s_1309_5).unwrap());
        // C s_1309_7: const #11s : i
        let s_1309_7: i128 = 11;
        // C s_1309_8: add s_1309_7 s_1309_6
        let s_1309_8: i128 = (s_1309_7 + s_1309_6);
        // D s_1309_9: bit-extract s_1309_4 s_1309_2 s_1309_8
        let s_1309_9: Bits = (Bits::new(
            ((s_1309_4) >> (s_1309_2)).value(),
            u16::try_from(s_1309_8).unwrap(),
        ));
        // D s_1309_10: cast reint s_1309_9 -> u12
        let s_1309_10: u16 = (s_1309_9.value() as u16);
        // D s_1309_11: cast zx s_1309_10 -> bv
        let s_1309_11: Bits = Bits::new(s_1309_10 as u128, 12u16);
        // C s_1309_12: const #3856u : u12
        let s_1309_12: u16 = 3856;
        // C s_1309_13: cast zx s_1309_12 -> bv
        let s_1309_13: Bits = Bits::new(s_1309_12 as u128, 12u16);
        // D s_1309_14: cmp-eq s_1309_11 s_1309_13
        let s_1309_14: bool = ((s_1309_11) == (s_1309_13));
        // N s_1309_15: branch s_1309_14 b1779 b1310
        if s_1309_14 {
            return block_1779(state, tracer, fn_state);
        } else {
            return block_1310(state, tracer, fn_state);
        };
    }
    fn block_1310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1310_0: const #0u : u8
        let s_1310_0: bool = false;
        // D s_1310_1: write-var gs#403091 <= s_1310_0
        fn_state.gs_403091 = s_1310_0;
        // N s_1310_2: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_1311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1311_0: read-var gs#403091:u8
        let s_1311_0: bool = fn_state.gs_403091;
        // N s_1311_1: branch s_1311_0 b1778 b1312
        if s_1311_0 {
            return block_1778(state, tracer, fn_state);
        } else {
            return block_1312(state, tracer, fn_state);
        };
    }
    fn block_1312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1312_0: const #0u : u8
        let s_1312_0: bool = false;
        // D s_1312_1: write-var gs#403093 <= s_1312_0
        fn_state.gs_403093 = s_1312_0;
        // N s_1312_2: jump b1313
        return block_1313(state, tracer, fn_state);
    }
    fn block_1313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1313_0: read-var gs#403093:u8
        let s_1313_0: bool = fn_state.gs_403093;
        // D s_1313_1: not s_1313_0
        let s_1313_1: bool = !s_1313_0;
        // N s_1313_2: branch s_1313_1 b1335 b1314
        if s_1313_1 {
            return block_1335(state, tracer, fn_state);
        } else {
            return block_1314(state, tracer, fn_state);
        };
    }
    fn block_1314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1314_0: const #3769s : i
        let s_1314_0: i128 = 3769;
        // C s_1314_1: const #14696u : u32
        let s_1314_1: u32 = 14696;
        // N s_1314_2: write-reg s_1314_1 <= s_1314_0
        let s_1314_2: () = {
            state.write_register::<i128>(s_1314_1 as isize, s_1314_0);
            tracer.write_register(s_1314_1 as isize, s_1314_0);
        };
        // C s_1314_3: const #18s : i
        let s_1314_3: i128 = 18;
        // C s_1314_4: const #2s : i
        let s_1314_4: i128 = 2;
        // D s_1314_5: read-var u#32152:u32
        let s_1314_5: u32 = fn_state.u_32152;
        // D s_1314_6: cast zx s_1314_5 -> bv
        let s_1314_6: Bits = Bits::new(s_1314_5 as u128, 32u16);
        // D s_1314_7: bit-extract s_1314_6 s_1314_3 s_1314_4
        let s_1314_7: Bits = (Bits::new(
            ((s_1314_6) >> (s_1314_3)).value(),
            u16::try_from(s_1314_4).unwrap(),
        ));
        // D s_1314_8: cast reint s_1314_7 -> u8
        let s_1314_8: u8 = (s_1314_7.value() as u8);
        // D s_1314_9: write-var imod <= s_1314_8
        fn_state.imod = s_1314_8;
        // C s_1314_10: const #17s : i
        let s_1314_10: i128 = 17;
        // C s_1314_11: const #1s : i
        let s_1314_11: i128 = 1;
        // D s_1314_12: read-var u#32152:u32
        let s_1314_12: u32 = fn_state.u_32152;
        // D s_1314_13: cast zx s_1314_12 -> bv
        let s_1314_13: Bits = Bits::new(s_1314_12 as u128, 32u16);
        // D s_1314_14: bit-extract s_1314_13 s_1314_10 s_1314_11
        let s_1314_14: Bits = (Bits::new(
            ((s_1314_13) >> (s_1314_10)).value(),
            u16::try_from(s_1314_11).unwrap(),
        ));
        // D s_1314_15: cast reint s_1314_14 -> u8
        let s_1314_15: bool = ((s_1314_14.value()) != 0);
        // D s_1314_16: write-var u#32153 <= s_1314_15
        fn_state.u_32153 = s_1314_15;
        // C s_1314_17: const #8s : i
        let s_1314_17: i128 = 8;
        // C s_1314_18: const #1s : i
        let s_1314_18: i128 = 1;
        // D s_1314_19: read-var u#32152:u32
        let s_1314_19: u32 = fn_state.u_32152;
        // D s_1314_20: cast zx s_1314_19 -> bv
        let s_1314_20: Bits = Bits::new(s_1314_19 as u128, 32u16);
        // D s_1314_21: bit-extract s_1314_20 s_1314_17 s_1314_18
        let s_1314_21: Bits = (Bits::new(
            ((s_1314_20) >> (s_1314_17)).value(),
            u16::try_from(s_1314_18).unwrap(),
        ));
        // D s_1314_22: cast reint s_1314_21 -> u8
        let s_1314_22: bool = ((s_1314_21.value()) != 0);
        // D s_1314_23: write-var A <= s_1314_22
        fn_state.A = s_1314_22;
        // C s_1314_24: const #7s : i
        let s_1314_24: i128 = 7;
        // C s_1314_25: const #1s : i
        let s_1314_25: i128 = 1;
        // D s_1314_26: read-var u#32152:u32
        let s_1314_26: u32 = fn_state.u_32152;
        // D s_1314_27: cast zx s_1314_26 -> bv
        let s_1314_27: Bits = Bits::new(s_1314_26 as u128, 32u16);
        // D s_1314_28: bit-extract s_1314_27 s_1314_24 s_1314_25
        let s_1314_28: Bits = (Bits::new(
            ((s_1314_27) >> (s_1314_24)).value(),
            u16::try_from(s_1314_25).unwrap(),
        ));
        // D s_1314_29: cast reint s_1314_28 -> u8
        let s_1314_29: bool = ((s_1314_28.value()) != 0);
        // D s_1314_30: write-var I <= s_1314_29
        fn_state.I = s_1314_29;
        // C s_1314_31: const #6s : i
        let s_1314_31: i128 = 6;
        // C s_1314_32: const #1s : i
        let s_1314_32: i128 = 1;
        // D s_1314_33: read-var u#32152:u32
        let s_1314_33: u32 = fn_state.u_32152;
        // D s_1314_34: cast zx s_1314_33 -> bv
        let s_1314_34: Bits = Bits::new(s_1314_33 as u128, 32u16);
        // D s_1314_35: bit-extract s_1314_34 s_1314_31 s_1314_32
        let s_1314_35: Bits = (Bits::new(
            ((s_1314_34) >> (s_1314_31)).value(),
            u16::try_from(s_1314_32).unwrap(),
        ));
        // D s_1314_36: cast reint s_1314_35 -> u8
        let s_1314_36: bool = ((s_1314_35.value()) != 0);
        // D s_1314_37: write-var u#32154 <= s_1314_36
        fn_state.u_32154 = s_1314_36;
        // C s_1314_38: const #0s : i
        let s_1314_38: i128 = 0;
        // C s_1314_39: const #5s : i
        let s_1314_39: i128 = 5;
        // D s_1314_40: read-var u#32152:u32
        let s_1314_40: u32 = fn_state.u_32152;
        // D s_1314_41: cast zx s_1314_40 -> bv
        let s_1314_41: Bits = Bits::new(s_1314_40 as u128, 32u16);
        // D s_1314_42: bit-extract s_1314_41 s_1314_38 s_1314_39
        let s_1314_42: Bits = (Bits::new(
            ((s_1314_41) >> (s_1314_38)).value(),
            u16::try_from(s_1314_39).unwrap(),
        ));
        // D s_1314_43: cast reint s_1314_42 -> u8
        let s_1314_43: u8 = (s_1314_42.value() as u8);
        // D s_1314_44: write-var mode <= s_1314_43
        fn_state.mode = s_1314_43;
        // C s_1314_45: const #9s : i
        let s_1314_45: i128 = 9;
        // D s_1314_46: read-var u#32152:u32
        let s_1314_46: u32 = fn_state.u_32152;
        // D s_1314_47: cast zx s_1314_46 -> bv
        let s_1314_47: Bits = Bits::new(s_1314_46 as u128, 32u16);
        // C s_1314_48: const #1u : u64
        let s_1314_48: u64 = 1;
        // D s_1314_49: bit-extract s_1314_47 s_1314_45 s_1314_48
        let s_1314_49: Bits = (Bits::new(
            ((s_1314_47) >> (s_1314_45)).value(),
            u16::try_from(s_1314_48).unwrap(),
        ));
        // D s_1314_50: cast reint s_1314_49 -> u8
        let s_1314_50: bool = ((s_1314_49.value()) != 0);
        // C s_1314_51: const #0s : i
        let s_1314_51: i128 = 0;
        // C s_1314_52: const #0u : u64
        let s_1314_52: u64 = 0;
        // D s_1314_53: cast zx s_1314_50 -> u64
        let s_1314_53: u64 = (s_1314_50 as u64);
        // C s_1314_54: const #1u : u64
        let s_1314_54: u64 = 1;
        // D s_1314_55: and s_1314_53 s_1314_54
        let s_1314_55: u64 = ((s_1314_53) & (s_1314_54));
        // D s_1314_56: cmp-eq s_1314_55 s_1314_54
        let s_1314_56: bool = ((s_1314_55) == (s_1314_54));
        // D s_1314_57: lsl s_1314_53 s_1314_51
        let s_1314_57: u64 = s_1314_53 << s_1314_51;
        // D s_1314_58: or s_1314_52 s_1314_57
        let s_1314_58: u64 = ((s_1314_52) | (s_1314_57));
        // D s_1314_59: cmpl s_1314_57
        let s_1314_59: u64 = !s_1314_57;
        // D s_1314_60: and s_1314_52 s_1314_59
        let s_1314_60: u64 = ((s_1314_52) & (s_1314_59));
        // D s_1314_61: select s_1314_56 s_1314_58 s_1314_60
        let s_1314_61: u64 = if s_1314_56 { s_1314_58 } else { s_1314_60 };
        // D s_1314_62: cast trunc s_1314_61 -> u8
        let s_1314_62: bool = ((s_1314_61) != 0);
        // D s_1314_63: cast zx s_1314_62 -> bv
        let s_1314_63: Bits = Bits::new(s_1314_62 as u128, 1u16);
        // C s_1314_64: const #0u : u8
        let s_1314_64: bool = false;
        // C s_1314_65: cast zx s_1314_64 -> bv
        let s_1314_65: Bits = Bits::new(s_1314_64 as u128, 1u16);
        // D s_1314_66: cmp-ne s_1314_63 s_1314_65
        let s_1314_66: bool = ((s_1314_63) != (s_1314_65));
        // N s_1314_67: branch s_1314_66 b1334 b1315
        if s_1314_66 {
            return block_1334(state, tracer, fn_state);
        } else {
            return block_1315(state, tracer, fn_state);
        };
    }
    fn block_1315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1315_0: const #10s : i
        let s_1315_0: i128 = 10;
        // D s_1315_1: read-var u#32152:u32
        let s_1315_1: u32 = fn_state.u_32152;
        // D s_1315_2: cast zx s_1315_1 -> bv
        let s_1315_2: Bits = Bits::new(s_1315_1 as u128, 32u16);
        // C s_1315_3: const #1u : u64
        let s_1315_3: u64 = 1;
        // D s_1315_4: bit-extract s_1315_2 s_1315_0 s_1315_3
        let s_1315_4: Bits = (Bits::new(
            ((s_1315_2) >> (s_1315_0)).value(),
            u16::try_from(s_1315_3).unwrap(),
        ));
        // D s_1315_5: cast reint s_1315_4 -> u8
        let s_1315_5: bool = ((s_1315_4.value()) != 0);
        // C s_1315_6: const #0s : i
        let s_1315_6: i128 = 0;
        // C s_1315_7: const #0u : u64
        let s_1315_7: u64 = 0;
        // D s_1315_8: cast zx s_1315_5 -> u64
        let s_1315_8: u64 = (s_1315_5 as u64);
        // C s_1315_9: const #1u : u64
        let s_1315_9: u64 = 1;
        // D s_1315_10: and s_1315_8 s_1315_9
        let s_1315_10: u64 = ((s_1315_8) & (s_1315_9));
        // D s_1315_11: cmp-eq s_1315_10 s_1315_9
        let s_1315_11: bool = ((s_1315_10) == (s_1315_9));
        // D s_1315_12: lsl s_1315_8 s_1315_6
        let s_1315_12: u64 = s_1315_8 << s_1315_6;
        // D s_1315_13: or s_1315_7 s_1315_12
        let s_1315_13: u64 = ((s_1315_7) | (s_1315_12));
        // D s_1315_14: cmpl s_1315_12
        let s_1315_14: u64 = !s_1315_12;
        // D s_1315_15: and s_1315_7 s_1315_14
        let s_1315_15: u64 = ((s_1315_7) & (s_1315_14));
        // D s_1315_16: select s_1315_11 s_1315_13 s_1315_15
        let s_1315_16: u64 = if s_1315_11 { s_1315_13 } else { s_1315_15 };
        // D s_1315_17: cast trunc s_1315_16 -> u8
        let s_1315_17: bool = ((s_1315_16) != 0);
        // D s_1315_18: cast zx s_1315_17 -> bv
        let s_1315_18: Bits = Bits::new(s_1315_17 as u128, 1u16);
        // C s_1315_19: const #0u : u8
        let s_1315_19: bool = false;
        // C s_1315_20: cast zx s_1315_19 -> bv
        let s_1315_20: Bits = Bits::new(s_1315_19 as u128, 1u16);
        // D s_1315_21: cmp-ne s_1315_18 s_1315_20
        let s_1315_21: bool = ((s_1315_18) != (s_1315_20));
        // D s_1315_22: write-var gs#403112 <= s_1315_21
        fn_state.gs_403112 = s_1315_21;
        // N s_1315_23: jump b1316
        return block_1316(state, tracer, fn_state);
    }
    fn block_1316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1316_0: read-var gs#403112:u8
        let s_1316_0: bool = fn_state.gs_403112;
        // N s_1316_1: branch s_1316_0 b1333 b1317
        if s_1316_0 {
            return block_1333(state, tracer, fn_state);
        } else {
            return block_1317(state, tracer, fn_state);
        };
    }
    fn block_1317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1317_0: const #11s : i
        let s_1317_0: i128 = 11;
        // D s_1317_1: read-var u#32152:u32
        let s_1317_1: u32 = fn_state.u_32152;
        // D s_1317_2: cast zx s_1317_1 -> bv
        let s_1317_2: Bits = Bits::new(s_1317_1 as u128, 32u16);
        // C s_1317_3: const #1u : u64
        let s_1317_3: u64 = 1;
        // D s_1317_4: bit-extract s_1317_2 s_1317_0 s_1317_3
        let s_1317_4: Bits = (Bits::new(
            ((s_1317_2) >> (s_1317_0)).value(),
            u16::try_from(s_1317_3).unwrap(),
        ));
        // D s_1317_5: cast reint s_1317_4 -> u8
        let s_1317_5: bool = ((s_1317_4.value()) != 0);
        // C s_1317_6: const #0s : i
        let s_1317_6: i128 = 0;
        // C s_1317_7: const #0u : u64
        let s_1317_7: u64 = 0;
        // D s_1317_8: cast zx s_1317_5 -> u64
        let s_1317_8: u64 = (s_1317_5 as u64);
        // C s_1317_9: const #1u : u64
        let s_1317_9: u64 = 1;
        // D s_1317_10: and s_1317_8 s_1317_9
        let s_1317_10: u64 = ((s_1317_8) & (s_1317_9));
        // D s_1317_11: cmp-eq s_1317_10 s_1317_9
        let s_1317_11: bool = ((s_1317_10) == (s_1317_9));
        // D s_1317_12: lsl s_1317_8 s_1317_6
        let s_1317_12: u64 = s_1317_8 << s_1317_6;
        // D s_1317_13: or s_1317_7 s_1317_12
        let s_1317_13: u64 = ((s_1317_7) | (s_1317_12));
        // D s_1317_14: cmpl s_1317_12
        let s_1317_14: u64 = !s_1317_12;
        // D s_1317_15: and s_1317_7 s_1317_14
        let s_1317_15: u64 = ((s_1317_7) & (s_1317_14));
        // D s_1317_16: select s_1317_11 s_1317_13 s_1317_15
        let s_1317_16: u64 = if s_1317_11 { s_1317_13 } else { s_1317_15 };
        // D s_1317_17: cast trunc s_1317_16 -> u8
        let s_1317_17: bool = ((s_1317_16) != 0);
        // D s_1317_18: cast zx s_1317_17 -> bv
        let s_1317_18: Bits = Bits::new(s_1317_17 as u128, 1u16);
        // C s_1317_19: const #0u : u8
        let s_1317_19: bool = false;
        // C s_1317_20: cast zx s_1317_19 -> bv
        let s_1317_20: Bits = Bits::new(s_1317_19 as u128, 1u16);
        // D s_1317_21: cmp-ne s_1317_18 s_1317_20
        let s_1317_21: bool = ((s_1317_18) != (s_1317_20));
        // D s_1317_22: write-var gs#403115 <= s_1317_21
        fn_state.gs_403115 = s_1317_21;
        // N s_1317_23: jump b1318
        return block_1318(state, tracer, fn_state);
    }
    fn block_1318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1318_0: read-var gs#403115:u8
        let s_1318_0: bool = fn_state.gs_403115;
        // N s_1318_1: branch s_1318_0 b1332 b1319
        if s_1318_0 {
            return block_1332(state, tracer, fn_state);
        } else {
            return block_1319(state, tracer, fn_state);
        };
    }
    fn block_1319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1319_0: const #12s : i
        let s_1319_0: i128 = 12;
        // D s_1319_1: read-var u#32152:u32
        let s_1319_1: u32 = fn_state.u_32152;
        // D s_1319_2: cast zx s_1319_1 -> bv
        let s_1319_2: Bits = Bits::new(s_1319_1 as u128, 32u16);
        // C s_1319_3: const #1u : u64
        let s_1319_3: u64 = 1;
        // D s_1319_4: bit-extract s_1319_2 s_1319_0 s_1319_3
        let s_1319_4: Bits = (Bits::new(
            ((s_1319_2) >> (s_1319_0)).value(),
            u16::try_from(s_1319_3).unwrap(),
        ));
        // D s_1319_5: cast reint s_1319_4 -> u8
        let s_1319_5: bool = ((s_1319_4.value()) != 0);
        // C s_1319_6: const #0s : i
        let s_1319_6: i128 = 0;
        // C s_1319_7: const #0u : u64
        let s_1319_7: u64 = 0;
        // D s_1319_8: cast zx s_1319_5 -> u64
        let s_1319_8: u64 = (s_1319_5 as u64);
        // C s_1319_9: const #1u : u64
        let s_1319_9: u64 = 1;
        // D s_1319_10: and s_1319_8 s_1319_9
        let s_1319_10: u64 = ((s_1319_8) & (s_1319_9));
        // D s_1319_11: cmp-eq s_1319_10 s_1319_9
        let s_1319_11: bool = ((s_1319_10) == (s_1319_9));
        // D s_1319_12: lsl s_1319_8 s_1319_6
        let s_1319_12: u64 = s_1319_8 << s_1319_6;
        // D s_1319_13: or s_1319_7 s_1319_12
        let s_1319_13: u64 = ((s_1319_7) | (s_1319_12));
        // D s_1319_14: cmpl s_1319_12
        let s_1319_14: u64 = !s_1319_12;
        // D s_1319_15: and s_1319_7 s_1319_14
        let s_1319_15: u64 = ((s_1319_7) & (s_1319_14));
        // D s_1319_16: select s_1319_11 s_1319_13 s_1319_15
        let s_1319_16: u64 = if s_1319_11 { s_1319_13 } else { s_1319_15 };
        // D s_1319_17: cast trunc s_1319_16 -> u8
        let s_1319_17: bool = ((s_1319_16) != 0);
        // D s_1319_18: cast zx s_1319_17 -> bv
        let s_1319_18: Bits = Bits::new(s_1319_17 as u128, 1u16);
        // C s_1319_19: const #0u : u8
        let s_1319_19: bool = false;
        // C s_1319_20: cast zx s_1319_19 -> bv
        let s_1319_20: Bits = Bits::new(s_1319_19 as u128, 1u16);
        // D s_1319_21: cmp-ne s_1319_18 s_1319_20
        let s_1319_21: bool = ((s_1319_18) != (s_1319_20));
        // D s_1319_22: write-var gs#403118 <= s_1319_21
        fn_state.gs_403118 = s_1319_21;
        // N s_1319_23: jump b1320
        return block_1320(state, tracer, fn_state);
    }
    fn block_1320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1320_0: read-var gs#403118:u8
        let s_1320_0: bool = fn_state.gs_403118;
        // N s_1320_1: branch s_1320_0 b1331 b1321
        if s_1320_0 {
            return block_1331(state, tracer, fn_state);
        } else {
            return block_1321(state, tracer, fn_state);
        };
    }
    fn block_1321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1321_0: const #13s : i
        let s_1321_0: i128 = 13;
        // D s_1321_1: read-var u#32152:u32
        let s_1321_1: u32 = fn_state.u_32152;
        // D s_1321_2: cast zx s_1321_1 -> bv
        let s_1321_2: Bits = Bits::new(s_1321_1 as u128, 32u16);
        // C s_1321_3: const #1u : u64
        let s_1321_3: u64 = 1;
        // D s_1321_4: bit-extract s_1321_2 s_1321_0 s_1321_3
        let s_1321_4: Bits = (Bits::new(
            ((s_1321_2) >> (s_1321_0)).value(),
            u16::try_from(s_1321_3).unwrap(),
        ));
        // D s_1321_5: cast reint s_1321_4 -> u8
        let s_1321_5: bool = ((s_1321_4.value()) != 0);
        // C s_1321_6: const #0s : i
        let s_1321_6: i128 = 0;
        // C s_1321_7: const #0u : u64
        let s_1321_7: u64 = 0;
        // D s_1321_8: cast zx s_1321_5 -> u64
        let s_1321_8: u64 = (s_1321_5 as u64);
        // C s_1321_9: const #1u : u64
        let s_1321_9: u64 = 1;
        // D s_1321_10: and s_1321_8 s_1321_9
        let s_1321_10: u64 = ((s_1321_8) & (s_1321_9));
        // D s_1321_11: cmp-eq s_1321_10 s_1321_9
        let s_1321_11: bool = ((s_1321_10) == (s_1321_9));
        // D s_1321_12: lsl s_1321_8 s_1321_6
        let s_1321_12: u64 = s_1321_8 << s_1321_6;
        // D s_1321_13: or s_1321_7 s_1321_12
        let s_1321_13: u64 = ((s_1321_7) | (s_1321_12));
        // D s_1321_14: cmpl s_1321_12
        let s_1321_14: u64 = !s_1321_12;
        // D s_1321_15: and s_1321_7 s_1321_14
        let s_1321_15: u64 = ((s_1321_7) & (s_1321_14));
        // D s_1321_16: select s_1321_11 s_1321_13 s_1321_15
        let s_1321_16: u64 = if s_1321_11 { s_1321_13 } else { s_1321_15 };
        // D s_1321_17: cast trunc s_1321_16 -> u8
        let s_1321_17: bool = ((s_1321_16) != 0);
        // D s_1321_18: cast zx s_1321_17 -> bv
        let s_1321_18: Bits = Bits::new(s_1321_17 as u128, 1u16);
        // C s_1321_19: const #0u : u8
        let s_1321_19: bool = false;
        // C s_1321_20: cast zx s_1321_19 -> bv
        let s_1321_20: Bits = Bits::new(s_1321_19 as u128, 1u16);
        // D s_1321_21: cmp-ne s_1321_18 s_1321_20
        let s_1321_21: bool = ((s_1321_18) != (s_1321_20));
        // D s_1321_22: write-var gs#403121 <= s_1321_21
        fn_state.gs_403121 = s_1321_21;
        // N s_1321_23: jump b1322
        return block_1322(state, tracer, fn_state);
    }
    fn block_1322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1322_0: read-var gs#403121:u8
        let s_1322_0: bool = fn_state.gs_403121;
        // N s_1322_1: branch s_1322_0 b1330 b1323
        if s_1322_0 {
            return block_1330(state, tracer, fn_state);
        } else {
            return block_1323(state, tracer, fn_state);
        };
    }
    fn block_1323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1323_0: const #14s : i
        let s_1323_0: i128 = 14;
        // D s_1323_1: read-var u#32152:u32
        let s_1323_1: u32 = fn_state.u_32152;
        // D s_1323_2: cast zx s_1323_1 -> bv
        let s_1323_2: Bits = Bits::new(s_1323_1 as u128, 32u16);
        // C s_1323_3: const #1u : u64
        let s_1323_3: u64 = 1;
        // D s_1323_4: bit-extract s_1323_2 s_1323_0 s_1323_3
        let s_1323_4: Bits = (Bits::new(
            ((s_1323_2) >> (s_1323_0)).value(),
            u16::try_from(s_1323_3).unwrap(),
        ));
        // D s_1323_5: cast reint s_1323_4 -> u8
        let s_1323_5: bool = ((s_1323_4.value()) != 0);
        // C s_1323_6: const #0s : i
        let s_1323_6: i128 = 0;
        // C s_1323_7: const #0u : u64
        let s_1323_7: u64 = 0;
        // D s_1323_8: cast zx s_1323_5 -> u64
        let s_1323_8: u64 = (s_1323_5 as u64);
        // C s_1323_9: const #1u : u64
        let s_1323_9: u64 = 1;
        // D s_1323_10: and s_1323_8 s_1323_9
        let s_1323_10: u64 = ((s_1323_8) & (s_1323_9));
        // D s_1323_11: cmp-eq s_1323_10 s_1323_9
        let s_1323_11: bool = ((s_1323_10) == (s_1323_9));
        // D s_1323_12: lsl s_1323_8 s_1323_6
        let s_1323_12: u64 = s_1323_8 << s_1323_6;
        // D s_1323_13: or s_1323_7 s_1323_12
        let s_1323_13: u64 = ((s_1323_7) | (s_1323_12));
        // D s_1323_14: cmpl s_1323_12
        let s_1323_14: u64 = !s_1323_12;
        // D s_1323_15: and s_1323_7 s_1323_14
        let s_1323_15: u64 = ((s_1323_7) & (s_1323_14));
        // D s_1323_16: select s_1323_11 s_1323_13 s_1323_15
        let s_1323_16: u64 = if s_1323_11 { s_1323_13 } else { s_1323_15 };
        // D s_1323_17: cast trunc s_1323_16 -> u8
        let s_1323_17: bool = ((s_1323_16) != 0);
        // D s_1323_18: cast zx s_1323_17 -> bv
        let s_1323_18: Bits = Bits::new(s_1323_17 as u128, 1u16);
        // C s_1323_19: const #0u : u8
        let s_1323_19: bool = false;
        // C s_1323_20: cast zx s_1323_19 -> bv
        let s_1323_20: Bits = Bits::new(s_1323_19 as u128, 1u16);
        // D s_1323_21: cmp-ne s_1323_18 s_1323_20
        let s_1323_21: bool = ((s_1323_18) != (s_1323_20));
        // D s_1323_22: write-var gs#403124 <= s_1323_21
        fn_state.gs_403124 = s_1323_21;
        // N s_1323_23: jump b1324
        return block_1324(state, tracer, fn_state);
    }
    fn block_1324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1324_0: read-var gs#403124:u8
        let s_1324_0: bool = fn_state.gs_403124;
        // N s_1324_1: branch s_1324_0 b1329 b1325
        if s_1324_0 {
            return block_1329(state, tracer, fn_state);
        } else {
            return block_1325(state, tracer, fn_state);
        };
    }
    fn block_1325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1325_0: const #15s : i
        let s_1325_0: i128 = 15;
        // D s_1325_1: read-var u#32152:u32
        let s_1325_1: u32 = fn_state.u_32152;
        // D s_1325_2: cast zx s_1325_1 -> bv
        let s_1325_2: Bits = Bits::new(s_1325_1 as u128, 32u16);
        // C s_1325_3: const #1u : u64
        let s_1325_3: u64 = 1;
        // D s_1325_4: bit-extract s_1325_2 s_1325_0 s_1325_3
        let s_1325_4: Bits = (Bits::new(
            ((s_1325_2) >> (s_1325_0)).value(),
            u16::try_from(s_1325_3).unwrap(),
        ));
        // D s_1325_5: cast reint s_1325_4 -> u8
        let s_1325_5: bool = ((s_1325_4.value()) != 0);
        // C s_1325_6: const #0s : i
        let s_1325_6: i128 = 0;
        // C s_1325_7: const #0u : u64
        let s_1325_7: u64 = 0;
        // D s_1325_8: cast zx s_1325_5 -> u64
        let s_1325_8: u64 = (s_1325_5 as u64);
        // C s_1325_9: const #1u : u64
        let s_1325_9: u64 = 1;
        // D s_1325_10: and s_1325_8 s_1325_9
        let s_1325_10: u64 = ((s_1325_8) & (s_1325_9));
        // D s_1325_11: cmp-eq s_1325_10 s_1325_9
        let s_1325_11: bool = ((s_1325_10) == (s_1325_9));
        // D s_1325_12: lsl s_1325_8 s_1325_6
        let s_1325_12: u64 = s_1325_8 << s_1325_6;
        // D s_1325_13: or s_1325_7 s_1325_12
        let s_1325_13: u64 = ((s_1325_7) | (s_1325_12));
        // D s_1325_14: cmpl s_1325_12
        let s_1325_14: u64 = !s_1325_12;
        // D s_1325_15: and s_1325_7 s_1325_14
        let s_1325_15: u64 = ((s_1325_7) & (s_1325_14));
        // D s_1325_16: select s_1325_11 s_1325_13 s_1325_15
        let s_1325_16: u64 = if s_1325_11 { s_1325_13 } else { s_1325_15 };
        // D s_1325_17: cast trunc s_1325_16 -> u8
        let s_1325_17: bool = ((s_1325_16) != 0);
        // D s_1325_18: cast zx s_1325_17 -> bv
        let s_1325_18: Bits = Bits::new(s_1325_17 as u128, 1u16);
        // C s_1325_19: const #0u : u8
        let s_1325_19: bool = false;
        // C s_1325_20: cast zx s_1325_19 -> bv
        let s_1325_20: Bits = Bits::new(s_1325_19 as u128, 1u16);
        // D s_1325_21: cmp-ne s_1325_18 s_1325_20
        let s_1325_21: bool = ((s_1325_18) != (s_1325_20));
        // D s_1325_22: write-var gs#403127 <= s_1325_21
        fn_state.gs_403127 = s_1325_21;
        // N s_1325_23: jump b1326
        return block_1326(state, tracer, fn_state);
    }
    fn block_1326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1326_0: read-var gs#403127:u8
        let s_1326_0: bool = fn_state.gs_403127;
        // N s_1326_1: branch s_1326_0 b1328 b1327
        if s_1326_0 {
            return block_1328(state, tracer, fn_state);
        } else {
            return block_1327(state, tracer, fn_state);
        };
    }
    fn block_1327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1327_0: read-var imod:u8
        let s_1327_0: u8 = fn_state.imod;
        // D s_1327_1: read-var u#32153:u8
        let s_1327_1: bool = fn_state.u_32153;
        // D s_1327_2: read-var A:u8
        let s_1327_2: bool = fn_state.A;
        // D s_1327_3: read-var I:u8
        let s_1327_3: bool = fn_state.I;
        // D s_1327_4: read-var u#32154:u8
        let s_1327_4: bool = fn_state.u_32154;
        // D s_1327_5: read-var mode:u8
        let s_1327_5: u8 = fn_state.mode;
        // D s_1327_6: call decode_aarch32_instrs_CPS_A1enc_AS_txt(s_1327_0, s_1327_1, s_1327_2, s_1327_3, s_1327_4, s_1327_5)
        let s_1327_6: () = decode_aarch32_instrs_CPS_A1enc_AS_txt(
            state,
            tracer,
            s_1327_0,
            s_1327_1,
            s_1327_2,
            s_1327_3,
            s_1327_4,
            s_1327_5,
        );
        // N s_1327_7: return
        return;
    }
    fn block_1328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1328_0: panic
        panic!("{:?}", ());
        // N s_1328_1: return
        return;
    }
    fn block_1329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1329_0: const #1u : u8
        let s_1329_0: bool = true;
        // D s_1329_1: write-var gs#403127 <= s_1329_0
        fn_state.gs_403127 = s_1329_0;
        // N s_1329_2: jump b1326
        return block_1326(state, tracer, fn_state);
    }
    fn block_1330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1330_0: const #1u : u8
        let s_1330_0: bool = true;
        // D s_1330_1: write-var gs#403124 <= s_1330_0
        fn_state.gs_403124 = s_1330_0;
        // N s_1330_2: jump b1324
        return block_1324(state, tracer, fn_state);
    }
    fn block_1331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1331_0: const #1u : u8
        let s_1331_0: bool = true;
        // D s_1331_1: write-var gs#403121 <= s_1331_0
        fn_state.gs_403121 = s_1331_0;
        // N s_1331_2: jump b1322
        return block_1322(state, tracer, fn_state);
    }
    fn block_1332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1332_0: const #1u : u8
        let s_1332_0: bool = true;
        // D s_1332_1: write-var gs#403118 <= s_1332_0
        fn_state.gs_403118 = s_1332_0;
        // N s_1332_2: jump b1320
        return block_1320(state, tracer, fn_state);
    }
    fn block_1333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1333_0: const #1u : u8
        let s_1333_0: bool = true;
        // D s_1333_1: write-var gs#403115 <= s_1333_0
        fn_state.gs_403115 = s_1333_0;
        // N s_1333_2: jump b1318
        return block_1318(state, tracer, fn_state);
    }
    fn block_1334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1334_0: const #1u : u8
        let s_1334_0: bool = true;
        // D s_1334_1: write-var gs#403112 <= s_1334_0
        fn_state.gs_403112 = s_1334_0;
        // N s_1334_2: jump b1316
        return block_1316(state, tracer, fn_state);
    }
    fn block_1335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1335_0: read-var merge#var.1:struct
        let s_1335_0: u32 = fn_state.merge_var._1;
        // D s_1335_1: write-var u#32156 <= s_1335_0
        fn_state.u_32156 = s_1335_0;
        // C s_1335_2: const #23s : i
        let s_1335_2: i128 = 23;
        // D s_1335_3: read-var u#32156:u32
        let s_1335_3: u32 = fn_state.u_32156;
        // D s_1335_4: cast zx s_1335_3 -> bv
        let s_1335_4: Bits = Bits::new(s_1335_3 as u128, 32u16);
        // C s_1335_5: const #1s : i64
        let s_1335_5: i64 = 1;
        // C s_1335_6: cast zx s_1335_5 -> i
        let s_1335_6: i128 = (i128::try_from(s_1335_5).unwrap());
        // C s_1335_7: const #8s : i
        let s_1335_7: i128 = 8;
        // C s_1335_8: add s_1335_7 s_1335_6
        let s_1335_8: i128 = (s_1335_7 + s_1335_6);
        // D s_1335_9: bit-extract s_1335_4 s_1335_2 s_1335_8
        let s_1335_9: Bits = (Bits::new(
            ((s_1335_4) >> (s_1335_2)).value(),
            u16::try_from(s_1335_8).unwrap(),
        ));
        // D s_1335_10: cast reint s_1335_9 -> u9
        let s_1335_10: u16 = (s_1335_9.value() as u16);
        // D s_1335_11: cast zx s_1335_10 -> bv
        let s_1335_11: Bits = Bits::new(s_1335_10 as u128, 9u16);
        // C s_1335_12: const #487u : u9
        let s_1335_12: u16 = 487;
        // C s_1335_13: cast zx s_1335_12 -> bv
        let s_1335_13: Bits = Bits::new(s_1335_12 as u128, 9u16);
        // D s_1335_14: cmp-eq s_1335_11 s_1335_13
        let s_1335_14: bool = ((s_1335_11) == (s_1335_13));
        // N s_1335_15: branch s_1335_14 b1768 b1336
        if s_1335_14 {
            return block_1768(state, tracer, fn_state);
        } else {
            return block_1336(state, tracer, fn_state);
        };
    }
    fn block_1336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1336_0: const #0u : u8
        let s_1336_0: bool = false;
        // D s_1336_1: write-var gs#403142 <= s_1336_0
        fn_state.gs_403142 = s_1336_0;
        // N s_1336_2: jump b1337
        return block_1337(state, tracer, fn_state);
    }
    fn block_1337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1337_0: read-var gs#403142:u8
        let s_1337_0: bool = fn_state.gs_403142;
        // N s_1337_1: branch s_1337_0 b1767 b1338
        if s_1337_0 {
            return block_1767(state, tracer, fn_state);
        } else {
            return block_1338(state, tracer, fn_state);
        };
    }
    fn block_1338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1338_0: const #0u : u8
        let s_1338_0: bool = false;
        // D s_1338_1: write-var gs#403144 <= s_1338_0
        fn_state.gs_403144 = s_1338_0;
        // N s_1338_2: jump b1339
        return block_1339(state, tracer, fn_state);
    }
    fn block_1339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1339_0: read-var gs#403144:u8
        let s_1339_0: bool = fn_state.gs_403144;
        // D s_1339_1: not s_1339_0
        let s_1339_1: bool = !s_1339_0;
        // N s_1339_2: branch s_1339_1 b1341 b1340
        if s_1339_1 {
            return block_1341(state, tracer, fn_state);
        } else {
            return block_1340(state, tracer, fn_state);
        };
    }
    fn block_1340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1340_0: const #3800s : i
        let s_1340_0: i128 = 3800;
        // C s_1340_1: const #14696u : u32
        let s_1340_1: u32 = 14696;
        // N s_1340_2: write-reg s_1340_1 <= s_1340_0
        let s_1340_2: () = {
            state.write_register::<i128>(s_1340_1 as isize, s_1340_0);
            tracer.write_register(s_1340_1 as isize, s_1340_0);
        };
        // C s_1340_3: const #22s : i
        let s_1340_3: i128 = 22;
        // C s_1340_4: const #1s : i
        let s_1340_4: i128 = 1;
        // D s_1340_5: read-var u#32156:u32
        let s_1340_5: u32 = fn_state.u_32156;
        // D s_1340_6: cast zx s_1340_5 -> bv
        let s_1340_6: Bits = Bits::new(s_1340_5 as u128, 32u16);
        // D s_1340_7: bit-extract s_1340_6 s_1340_3 s_1340_4
        let s_1340_7: Bits = (Bits::new(
            ((s_1340_6) >> (s_1340_3)).value(),
            u16::try_from(s_1340_4).unwrap(),
        ));
        // D s_1340_8: cast reint s_1340_7 -> u8
        let s_1340_8: bool = ((s_1340_7.value()) != 0);
        // C s_1340_9: const #18s : i
        let s_1340_9: i128 = 18;
        // C s_1340_10: const #2s : i
        let s_1340_10: i128 = 2;
        // D s_1340_11: read-var u#32156:u32
        let s_1340_11: u32 = fn_state.u_32156;
        // D s_1340_12: cast zx s_1340_11 -> bv
        let s_1340_12: Bits = Bits::new(s_1340_11 as u128, 32u16);
        // D s_1340_13: bit-extract s_1340_12 s_1340_9 s_1340_10
        let s_1340_13: Bits = (Bits::new(
            ((s_1340_12) >> (s_1340_9)).value(),
            u16::try_from(s_1340_10).unwrap(),
        ));
        // D s_1340_14: cast reint s_1340_13 -> u8
        let s_1340_14: u8 = (s_1340_13.value() as u8);
        // C s_1340_15: const #12s : i
        let s_1340_15: i128 = 12;
        // C s_1340_16: const #4s : i
        let s_1340_16: i128 = 4;
        // D s_1340_17: read-var u#32156:u32
        let s_1340_17: u32 = fn_state.u_32156;
        // D s_1340_18: cast zx s_1340_17 -> bv
        let s_1340_18: Bits = Bits::new(s_1340_17 as u128, 32u16);
        // D s_1340_19: bit-extract s_1340_18 s_1340_15 s_1340_16
        let s_1340_19: Bits = (Bits::new(
            ((s_1340_18) >> (s_1340_15)).value(),
            u16::try_from(s_1340_16).unwrap(),
        ));
        // D s_1340_20: cast reint s_1340_19 -> u8
        let s_1340_20: u8 = (s_1340_19.value() as u8);
        // C s_1340_21: const #5s : i
        let s_1340_21: i128 = 5;
        // C s_1340_22: const #1s : i
        let s_1340_22: i128 = 1;
        // D s_1340_23: read-var u#32156:u32
        let s_1340_23: u32 = fn_state.u_32156;
        // D s_1340_24: cast zx s_1340_23 -> bv
        let s_1340_24: Bits = Bits::new(s_1340_23 as u128, 32u16);
        // D s_1340_25: bit-extract s_1340_24 s_1340_21 s_1340_22
        let s_1340_25: Bits = (Bits::new(
            ((s_1340_24) >> (s_1340_21)).value(),
            u16::try_from(s_1340_22).unwrap(),
        ));
        // D s_1340_26: cast reint s_1340_25 -> u8
        let s_1340_26: bool = ((s_1340_25.value()) != 0);
        // C s_1340_27: const #0s : i
        let s_1340_27: i128 = 0;
        // C s_1340_28: const #4s : i
        let s_1340_28: i128 = 4;
        // D s_1340_29: read-var u#32156:u32
        let s_1340_29: u32 = fn_state.u_32156;
        // D s_1340_30: cast zx s_1340_29 -> bv
        let s_1340_30: Bits = Bits::new(s_1340_29 as u128, 32u16);
        // D s_1340_31: bit-extract s_1340_30 s_1340_27 s_1340_28
        let s_1340_31: Bits = (Bits::new(
            ((s_1340_30) >> (s_1340_27)).value(),
            u16::try_from(s_1340_28).unwrap(),
        ));
        // D s_1340_32: cast reint s_1340_31 -> u8
        let s_1340_32: u8 = (s_1340_31.value() as u8);
        // D s_1340_33: call decode_aarch32_instrs_AESD_A1enc_A_txt(s_1340_8, s_1340_14, s_1340_20, s_1340_26, s_1340_32)
        let s_1340_33: () = decode_aarch32_instrs_AESD_A1enc_A_txt(
            state,
            tracer,
            s_1340_8,
            s_1340_14,
            s_1340_20,
            s_1340_26,
            s_1340_32,
        );
        // N s_1340_34: return
        return;
    }
    fn block_1341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1341_0: read-var merge#var.1:struct
        let s_1341_0: u32 = fn_state.merge_var._1;
        // D s_1341_1: write-var u#32163 <= s_1341_0
        fn_state.u_32163 = s_1341_0;
        // C s_1341_2: const #23s : i
        let s_1341_2: i128 = 23;
        // D s_1341_3: read-var u#32163:u32
        let s_1341_3: u32 = fn_state.u_32163;
        // D s_1341_4: cast zx s_1341_3 -> bv
        let s_1341_4: Bits = Bits::new(s_1341_3 as u128, 32u16);
        // C s_1341_5: const #1s : i64
        let s_1341_5: i64 = 1;
        // C s_1341_6: cast zx s_1341_5 -> i
        let s_1341_6: i128 = (i128::try_from(s_1341_5).unwrap());
        // C s_1341_7: const #8s : i
        let s_1341_7: i128 = 8;
        // C s_1341_8: add s_1341_7 s_1341_6
        let s_1341_8: i128 = (s_1341_7 + s_1341_6);
        // D s_1341_9: bit-extract s_1341_4 s_1341_2 s_1341_8
        let s_1341_9: Bits = (Bits::new(
            ((s_1341_4) >> (s_1341_2)).value(),
            u16::try_from(s_1341_8).unwrap(),
        ));
        // D s_1341_10: cast reint s_1341_9 -> u9
        let s_1341_10: u16 = (s_1341_9.value() as u16);
        // D s_1341_11: cast zx s_1341_10 -> bv
        let s_1341_11: Bits = Bits::new(s_1341_10 as u128, 9u16);
        // C s_1341_12: const #487u : u9
        let s_1341_12: u16 = 487;
        // C s_1341_13: cast zx s_1341_12 -> bv
        let s_1341_13: Bits = Bits::new(s_1341_12 as u128, 9u16);
        // D s_1341_14: cmp-eq s_1341_11 s_1341_13
        let s_1341_14: bool = ((s_1341_11) == (s_1341_13));
        // N s_1341_15: branch s_1341_14 b1757 b1342
        if s_1341_14 {
            return block_1757(state, tracer, fn_state);
        } else {
            return block_1342(state, tracer, fn_state);
        };
    }
    fn block_1342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1342_0: const #0u : u8
        let s_1342_0: bool = false;
        // D s_1342_1: write-var gs#403171 <= s_1342_0
        fn_state.gs_403171 = s_1342_0;
        // N s_1342_2: jump b1343
        return block_1343(state, tracer, fn_state);
    }
    fn block_1343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1343_0: read-var gs#403171:u8
        let s_1343_0: bool = fn_state.gs_403171;
        // N s_1343_1: branch s_1343_0 b1756 b1344
        if s_1343_0 {
            return block_1756(state, tracer, fn_state);
        } else {
            return block_1344(state, tracer, fn_state);
        };
    }
    fn block_1344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1344_0: const #0u : u8
        let s_1344_0: bool = false;
        // D s_1344_1: write-var gs#403173 <= s_1344_0
        fn_state.gs_403173 = s_1344_0;
        // N s_1344_2: jump b1345
        return block_1345(state, tracer, fn_state);
    }
    fn block_1345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1345_0: read-var gs#403173:u8
        let s_1345_0: bool = fn_state.gs_403173;
        // D s_1345_1: not s_1345_0
        let s_1345_1: bool = !s_1345_0;
        // N s_1345_2: branch s_1345_1 b1347 b1346
        if s_1345_1 {
            return block_1347(state, tracer, fn_state);
        } else {
            return block_1346(state, tracer, fn_state);
        };
    }
    fn block_1346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1346_0: const #3802s : i
        let s_1346_0: i128 = 3802;
        // C s_1346_1: const #14696u : u32
        let s_1346_1: u32 = 14696;
        // N s_1346_2: write-reg s_1346_1 <= s_1346_0
        let s_1346_2: () = {
            state.write_register::<i128>(s_1346_1 as isize, s_1346_0);
            tracer.write_register(s_1346_1 as isize, s_1346_0);
        };
        // C s_1346_3: const #22s : i
        let s_1346_3: i128 = 22;
        // C s_1346_4: const #1s : i
        let s_1346_4: i128 = 1;
        // D s_1346_5: read-var u#32163:u32
        let s_1346_5: u32 = fn_state.u_32163;
        // D s_1346_6: cast zx s_1346_5 -> bv
        let s_1346_6: Bits = Bits::new(s_1346_5 as u128, 32u16);
        // D s_1346_7: bit-extract s_1346_6 s_1346_3 s_1346_4
        let s_1346_7: Bits = (Bits::new(
            ((s_1346_6) >> (s_1346_3)).value(),
            u16::try_from(s_1346_4).unwrap(),
        ));
        // D s_1346_8: cast reint s_1346_7 -> u8
        let s_1346_8: bool = ((s_1346_7.value()) != 0);
        // C s_1346_9: const #18s : i
        let s_1346_9: i128 = 18;
        // C s_1346_10: const #2s : i
        let s_1346_10: i128 = 2;
        // D s_1346_11: read-var u#32163:u32
        let s_1346_11: u32 = fn_state.u_32163;
        // D s_1346_12: cast zx s_1346_11 -> bv
        let s_1346_12: Bits = Bits::new(s_1346_11 as u128, 32u16);
        // D s_1346_13: bit-extract s_1346_12 s_1346_9 s_1346_10
        let s_1346_13: Bits = (Bits::new(
            ((s_1346_12) >> (s_1346_9)).value(),
            u16::try_from(s_1346_10).unwrap(),
        ));
        // D s_1346_14: cast reint s_1346_13 -> u8
        let s_1346_14: u8 = (s_1346_13.value() as u8);
        // C s_1346_15: const #12s : i
        let s_1346_15: i128 = 12;
        // C s_1346_16: const #4s : i
        let s_1346_16: i128 = 4;
        // D s_1346_17: read-var u#32163:u32
        let s_1346_17: u32 = fn_state.u_32163;
        // D s_1346_18: cast zx s_1346_17 -> bv
        let s_1346_18: Bits = Bits::new(s_1346_17 as u128, 32u16);
        // D s_1346_19: bit-extract s_1346_18 s_1346_15 s_1346_16
        let s_1346_19: Bits = (Bits::new(
            ((s_1346_18) >> (s_1346_15)).value(),
            u16::try_from(s_1346_16).unwrap(),
        ));
        // D s_1346_20: cast reint s_1346_19 -> u8
        let s_1346_20: u8 = (s_1346_19.value() as u8);
        // C s_1346_21: const #5s : i
        let s_1346_21: i128 = 5;
        // C s_1346_22: const #1s : i
        let s_1346_22: i128 = 1;
        // D s_1346_23: read-var u#32163:u32
        let s_1346_23: u32 = fn_state.u_32163;
        // D s_1346_24: cast zx s_1346_23 -> bv
        let s_1346_24: Bits = Bits::new(s_1346_23 as u128, 32u16);
        // D s_1346_25: bit-extract s_1346_24 s_1346_21 s_1346_22
        let s_1346_25: Bits = (Bits::new(
            ((s_1346_24) >> (s_1346_21)).value(),
            u16::try_from(s_1346_22).unwrap(),
        ));
        // D s_1346_26: cast reint s_1346_25 -> u8
        let s_1346_26: bool = ((s_1346_25.value()) != 0);
        // C s_1346_27: const #0s : i
        let s_1346_27: i128 = 0;
        // C s_1346_28: const #4s : i
        let s_1346_28: i128 = 4;
        // D s_1346_29: read-var u#32163:u32
        let s_1346_29: u32 = fn_state.u_32163;
        // D s_1346_30: cast zx s_1346_29 -> bv
        let s_1346_30: Bits = Bits::new(s_1346_29 as u128, 32u16);
        // D s_1346_31: bit-extract s_1346_30 s_1346_27 s_1346_28
        let s_1346_31: Bits = (Bits::new(
            ((s_1346_30) >> (s_1346_27)).value(),
            u16::try_from(s_1346_28).unwrap(),
        ));
        // D s_1346_32: cast reint s_1346_31 -> u8
        let s_1346_32: u8 = (s_1346_31.value() as u8);
        // D s_1346_33: call decode_aarch32_instrs_AESE_A1enc_A_txt(s_1346_8, s_1346_14, s_1346_20, s_1346_26, s_1346_32)
        let s_1346_33: () = decode_aarch32_instrs_AESE_A1enc_A_txt(
            state,
            tracer,
            s_1346_8,
            s_1346_14,
            s_1346_20,
            s_1346_26,
            s_1346_32,
        );
        // N s_1346_34: return
        return;
    }
    fn block_1347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1347_0: read-var merge#var.1:struct
        let s_1347_0: u32 = fn_state.merge_var._1;
        // D s_1347_1: write-var u#32170 <= s_1347_0
        fn_state.u_32170 = s_1347_0;
        // C s_1347_2: const #23s : i
        let s_1347_2: i128 = 23;
        // D s_1347_3: read-var u#32170:u32
        let s_1347_3: u32 = fn_state.u_32170;
        // D s_1347_4: cast zx s_1347_3 -> bv
        let s_1347_4: Bits = Bits::new(s_1347_3 as u128, 32u16);
        // C s_1347_5: const #1s : i64
        let s_1347_5: i64 = 1;
        // C s_1347_6: cast zx s_1347_5 -> i
        let s_1347_6: i128 = (i128::try_from(s_1347_5).unwrap());
        // C s_1347_7: const #8s : i
        let s_1347_7: i128 = 8;
        // C s_1347_8: add s_1347_7 s_1347_6
        let s_1347_8: i128 = (s_1347_7 + s_1347_6);
        // D s_1347_9: bit-extract s_1347_4 s_1347_2 s_1347_8
        let s_1347_9: Bits = (Bits::new(
            ((s_1347_4) >> (s_1347_2)).value(),
            u16::try_from(s_1347_8).unwrap(),
        ));
        // D s_1347_10: cast reint s_1347_9 -> u9
        let s_1347_10: u16 = (s_1347_9.value() as u16);
        // D s_1347_11: cast zx s_1347_10 -> bv
        let s_1347_11: Bits = Bits::new(s_1347_10 as u128, 9u16);
        // C s_1347_12: const #487u : u9
        let s_1347_12: u16 = 487;
        // C s_1347_13: cast zx s_1347_12 -> bv
        let s_1347_13: Bits = Bits::new(s_1347_12 as u128, 9u16);
        // D s_1347_14: cmp-eq s_1347_11 s_1347_13
        let s_1347_14: bool = ((s_1347_11) == (s_1347_13));
        // N s_1347_15: branch s_1347_14 b1746 b1348
        if s_1347_14 {
            return block_1746(state, tracer, fn_state);
        } else {
            return block_1348(state, tracer, fn_state);
        };
    }
    fn block_1348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1348_0: const #0u : u8
        let s_1348_0: bool = false;
        // D s_1348_1: write-var gs#403200 <= s_1348_0
        fn_state.gs_403200 = s_1348_0;
        // N s_1348_2: jump b1349
        return block_1349(state, tracer, fn_state);
    }
    fn block_1349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1349_0: read-var gs#403200:u8
        let s_1349_0: bool = fn_state.gs_403200;
        // N s_1349_1: branch s_1349_0 b1745 b1350
        if s_1349_0 {
            return block_1745(state, tracer, fn_state);
        } else {
            return block_1350(state, tracer, fn_state);
        };
    }
    fn block_1350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1350_0: const #0u : u8
        let s_1350_0: bool = false;
        // D s_1350_1: write-var gs#403202 <= s_1350_0
        fn_state.gs_403202 = s_1350_0;
        // N s_1350_2: jump b1351
        return block_1351(state, tracer, fn_state);
    }
    fn block_1351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1351_0: read-var gs#403202:u8
        let s_1351_0: bool = fn_state.gs_403202;
        // D s_1351_1: not s_1351_0
        let s_1351_1: bool = !s_1351_0;
        // N s_1351_2: branch s_1351_1 b1353 b1352
        if s_1351_1 {
            return block_1353(state, tracer, fn_state);
        } else {
            return block_1352(state, tracer, fn_state);
        };
    }
    fn block_1352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1352_0: const #3804s : i
        let s_1352_0: i128 = 3804;
        // C s_1352_1: const #14696u : u32
        let s_1352_1: u32 = 14696;
        // N s_1352_2: write-reg s_1352_1 <= s_1352_0
        let s_1352_2: () = {
            state.write_register::<i128>(s_1352_1 as isize, s_1352_0);
            tracer.write_register(s_1352_1 as isize, s_1352_0);
        };
        // C s_1352_3: const #22s : i
        let s_1352_3: i128 = 22;
        // C s_1352_4: const #1s : i
        let s_1352_4: i128 = 1;
        // D s_1352_5: read-var u#32170:u32
        let s_1352_5: u32 = fn_state.u_32170;
        // D s_1352_6: cast zx s_1352_5 -> bv
        let s_1352_6: Bits = Bits::new(s_1352_5 as u128, 32u16);
        // D s_1352_7: bit-extract s_1352_6 s_1352_3 s_1352_4
        let s_1352_7: Bits = (Bits::new(
            ((s_1352_6) >> (s_1352_3)).value(),
            u16::try_from(s_1352_4).unwrap(),
        ));
        // D s_1352_8: cast reint s_1352_7 -> u8
        let s_1352_8: bool = ((s_1352_7.value()) != 0);
        // C s_1352_9: const #18s : i
        let s_1352_9: i128 = 18;
        // C s_1352_10: const #2s : i
        let s_1352_10: i128 = 2;
        // D s_1352_11: read-var u#32170:u32
        let s_1352_11: u32 = fn_state.u_32170;
        // D s_1352_12: cast zx s_1352_11 -> bv
        let s_1352_12: Bits = Bits::new(s_1352_11 as u128, 32u16);
        // D s_1352_13: bit-extract s_1352_12 s_1352_9 s_1352_10
        let s_1352_13: Bits = (Bits::new(
            ((s_1352_12) >> (s_1352_9)).value(),
            u16::try_from(s_1352_10).unwrap(),
        ));
        // D s_1352_14: cast reint s_1352_13 -> u8
        let s_1352_14: u8 = (s_1352_13.value() as u8);
        // C s_1352_15: const #12s : i
        let s_1352_15: i128 = 12;
        // C s_1352_16: const #4s : i
        let s_1352_16: i128 = 4;
        // D s_1352_17: read-var u#32170:u32
        let s_1352_17: u32 = fn_state.u_32170;
        // D s_1352_18: cast zx s_1352_17 -> bv
        let s_1352_18: Bits = Bits::new(s_1352_17 as u128, 32u16);
        // D s_1352_19: bit-extract s_1352_18 s_1352_15 s_1352_16
        let s_1352_19: Bits = (Bits::new(
            ((s_1352_18) >> (s_1352_15)).value(),
            u16::try_from(s_1352_16).unwrap(),
        ));
        // D s_1352_20: cast reint s_1352_19 -> u8
        let s_1352_20: u8 = (s_1352_19.value() as u8);
        // C s_1352_21: const #5s : i
        let s_1352_21: i128 = 5;
        // C s_1352_22: const #1s : i
        let s_1352_22: i128 = 1;
        // D s_1352_23: read-var u#32170:u32
        let s_1352_23: u32 = fn_state.u_32170;
        // D s_1352_24: cast zx s_1352_23 -> bv
        let s_1352_24: Bits = Bits::new(s_1352_23 as u128, 32u16);
        // D s_1352_25: bit-extract s_1352_24 s_1352_21 s_1352_22
        let s_1352_25: Bits = (Bits::new(
            ((s_1352_24) >> (s_1352_21)).value(),
            u16::try_from(s_1352_22).unwrap(),
        ));
        // D s_1352_26: cast reint s_1352_25 -> u8
        let s_1352_26: bool = ((s_1352_25.value()) != 0);
        // C s_1352_27: const #0s : i
        let s_1352_27: i128 = 0;
        // C s_1352_28: const #4s : i
        let s_1352_28: i128 = 4;
        // D s_1352_29: read-var u#32170:u32
        let s_1352_29: u32 = fn_state.u_32170;
        // D s_1352_30: cast zx s_1352_29 -> bv
        let s_1352_30: Bits = Bits::new(s_1352_29 as u128, 32u16);
        // D s_1352_31: bit-extract s_1352_30 s_1352_27 s_1352_28
        let s_1352_31: Bits = (Bits::new(
            ((s_1352_30) >> (s_1352_27)).value(),
            u16::try_from(s_1352_28).unwrap(),
        ));
        // D s_1352_32: cast reint s_1352_31 -> u8
        let s_1352_32: u8 = (s_1352_31.value() as u8);
        // D s_1352_33: call decode_aarch32_instrs_AESIMC_A1enc_A_txt(s_1352_8, s_1352_14, s_1352_20, s_1352_26, s_1352_32)
        let s_1352_33: () = decode_aarch32_instrs_AESIMC_A1enc_A_txt(
            state,
            tracer,
            s_1352_8,
            s_1352_14,
            s_1352_20,
            s_1352_26,
            s_1352_32,
        );
        // N s_1352_34: return
        return;
    }
    fn block_1353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1353_0: read-var merge#var.1:struct
        let s_1353_0: u32 = fn_state.merge_var._1;
        // D s_1353_1: write-var u#32177 <= s_1353_0
        fn_state.u_32177 = s_1353_0;
        // C s_1353_2: const #23s : i
        let s_1353_2: i128 = 23;
        // D s_1353_3: read-var u#32177:u32
        let s_1353_3: u32 = fn_state.u_32177;
        // D s_1353_4: cast zx s_1353_3 -> bv
        let s_1353_4: Bits = Bits::new(s_1353_3 as u128, 32u16);
        // C s_1353_5: const #1s : i64
        let s_1353_5: i64 = 1;
        // C s_1353_6: cast zx s_1353_5 -> i
        let s_1353_6: i128 = (i128::try_from(s_1353_5).unwrap());
        // C s_1353_7: const #8s : i
        let s_1353_7: i128 = 8;
        // C s_1353_8: add s_1353_7 s_1353_6
        let s_1353_8: i128 = (s_1353_7 + s_1353_6);
        // D s_1353_9: bit-extract s_1353_4 s_1353_2 s_1353_8
        let s_1353_9: Bits = (Bits::new(
            ((s_1353_4) >> (s_1353_2)).value(),
            u16::try_from(s_1353_8).unwrap(),
        ));
        // D s_1353_10: cast reint s_1353_9 -> u9
        let s_1353_10: u16 = (s_1353_9.value() as u16);
        // D s_1353_11: cast zx s_1353_10 -> bv
        let s_1353_11: Bits = Bits::new(s_1353_10 as u128, 9u16);
        // C s_1353_12: const #487u : u9
        let s_1353_12: u16 = 487;
        // C s_1353_13: cast zx s_1353_12 -> bv
        let s_1353_13: Bits = Bits::new(s_1353_12 as u128, 9u16);
        // D s_1353_14: cmp-eq s_1353_11 s_1353_13
        let s_1353_14: bool = ((s_1353_11) == (s_1353_13));
        // N s_1353_15: branch s_1353_14 b1735 b1354
        if s_1353_14 {
            return block_1735(state, tracer, fn_state);
        } else {
            return block_1354(state, tracer, fn_state);
        };
    }
    fn block_1354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1354_0: const #0u : u8
        let s_1354_0: bool = false;
        // D s_1354_1: write-var gs#403229 <= s_1354_0
        fn_state.gs_403229 = s_1354_0;
        // N s_1354_2: jump b1355
        return block_1355(state, tracer, fn_state);
    }
    fn block_1355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1355_0: read-var gs#403229:u8
        let s_1355_0: bool = fn_state.gs_403229;
        // N s_1355_1: branch s_1355_0 b1734 b1356
        if s_1355_0 {
            return block_1734(state, tracer, fn_state);
        } else {
            return block_1356(state, tracer, fn_state);
        };
    }
    fn block_1356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1356_0: const #0u : u8
        let s_1356_0: bool = false;
        // D s_1356_1: write-var gs#403231 <= s_1356_0
        fn_state.gs_403231 = s_1356_0;
        // N s_1356_2: jump b1357
        return block_1357(state, tracer, fn_state);
    }
    fn block_1357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1357_0: read-var gs#403231:u8
        let s_1357_0: bool = fn_state.gs_403231;
        // D s_1357_1: not s_1357_0
        let s_1357_1: bool = !s_1357_0;
        // N s_1357_2: branch s_1357_1 b1359 b1358
        if s_1357_1 {
            return block_1359(state, tracer, fn_state);
        } else {
            return block_1358(state, tracer, fn_state);
        };
    }
    fn block_1358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1358_0: const #3806s : i
        let s_1358_0: i128 = 3806;
        // C s_1358_1: const #14696u : u32
        let s_1358_1: u32 = 14696;
        // N s_1358_2: write-reg s_1358_1 <= s_1358_0
        let s_1358_2: () = {
            state.write_register::<i128>(s_1358_1 as isize, s_1358_0);
            tracer.write_register(s_1358_1 as isize, s_1358_0);
        };
        // C s_1358_3: const #22s : i
        let s_1358_3: i128 = 22;
        // C s_1358_4: const #1s : i
        let s_1358_4: i128 = 1;
        // D s_1358_5: read-var u#32177:u32
        let s_1358_5: u32 = fn_state.u_32177;
        // D s_1358_6: cast zx s_1358_5 -> bv
        let s_1358_6: Bits = Bits::new(s_1358_5 as u128, 32u16);
        // D s_1358_7: bit-extract s_1358_6 s_1358_3 s_1358_4
        let s_1358_7: Bits = (Bits::new(
            ((s_1358_6) >> (s_1358_3)).value(),
            u16::try_from(s_1358_4).unwrap(),
        ));
        // D s_1358_8: cast reint s_1358_7 -> u8
        let s_1358_8: bool = ((s_1358_7.value()) != 0);
        // C s_1358_9: const #18s : i
        let s_1358_9: i128 = 18;
        // C s_1358_10: const #2s : i
        let s_1358_10: i128 = 2;
        // D s_1358_11: read-var u#32177:u32
        let s_1358_11: u32 = fn_state.u_32177;
        // D s_1358_12: cast zx s_1358_11 -> bv
        let s_1358_12: Bits = Bits::new(s_1358_11 as u128, 32u16);
        // D s_1358_13: bit-extract s_1358_12 s_1358_9 s_1358_10
        let s_1358_13: Bits = (Bits::new(
            ((s_1358_12) >> (s_1358_9)).value(),
            u16::try_from(s_1358_10).unwrap(),
        ));
        // D s_1358_14: cast reint s_1358_13 -> u8
        let s_1358_14: u8 = (s_1358_13.value() as u8);
        // C s_1358_15: const #12s : i
        let s_1358_15: i128 = 12;
        // C s_1358_16: const #4s : i
        let s_1358_16: i128 = 4;
        // D s_1358_17: read-var u#32177:u32
        let s_1358_17: u32 = fn_state.u_32177;
        // D s_1358_18: cast zx s_1358_17 -> bv
        let s_1358_18: Bits = Bits::new(s_1358_17 as u128, 32u16);
        // D s_1358_19: bit-extract s_1358_18 s_1358_15 s_1358_16
        let s_1358_19: Bits = (Bits::new(
            ((s_1358_18) >> (s_1358_15)).value(),
            u16::try_from(s_1358_16).unwrap(),
        ));
        // D s_1358_20: cast reint s_1358_19 -> u8
        let s_1358_20: u8 = (s_1358_19.value() as u8);
        // C s_1358_21: const #5s : i
        let s_1358_21: i128 = 5;
        // C s_1358_22: const #1s : i
        let s_1358_22: i128 = 1;
        // D s_1358_23: read-var u#32177:u32
        let s_1358_23: u32 = fn_state.u_32177;
        // D s_1358_24: cast zx s_1358_23 -> bv
        let s_1358_24: Bits = Bits::new(s_1358_23 as u128, 32u16);
        // D s_1358_25: bit-extract s_1358_24 s_1358_21 s_1358_22
        let s_1358_25: Bits = (Bits::new(
            ((s_1358_24) >> (s_1358_21)).value(),
            u16::try_from(s_1358_22).unwrap(),
        ));
        // D s_1358_26: cast reint s_1358_25 -> u8
        let s_1358_26: bool = ((s_1358_25.value()) != 0);
        // C s_1358_27: const #0s : i
        let s_1358_27: i128 = 0;
        // C s_1358_28: const #4s : i
        let s_1358_28: i128 = 4;
        // D s_1358_29: read-var u#32177:u32
        let s_1358_29: u32 = fn_state.u_32177;
        // D s_1358_30: cast zx s_1358_29 -> bv
        let s_1358_30: Bits = Bits::new(s_1358_29 as u128, 32u16);
        // D s_1358_31: bit-extract s_1358_30 s_1358_27 s_1358_28
        let s_1358_31: Bits = (Bits::new(
            ((s_1358_30) >> (s_1358_27)).value(),
            u16::try_from(s_1358_28).unwrap(),
        ));
        // D s_1358_32: cast reint s_1358_31 -> u8
        let s_1358_32: u8 = (s_1358_31.value() as u8);
        // D s_1358_33: call decode_aarch32_instrs_AESMC_A1enc_A_txt(s_1358_8, s_1358_14, s_1358_20, s_1358_26, s_1358_32)
        let s_1358_33: () = decode_aarch32_instrs_AESMC_A1enc_A_txt(
            state,
            tracer,
            s_1358_8,
            s_1358_14,
            s_1358_20,
            s_1358_26,
            s_1358_32,
        );
        // N s_1358_34: return
        return;
    }
    fn block_1359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1359_0: read-var merge#var.1:struct
        let s_1359_0: u32 = fn_state.merge_var._1;
        // D s_1359_1: write-var u#32184 <= s_1359_0
        fn_state.u_32184 = s_1359_0;
        // C s_1359_2: const #23s : i
        let s_1359_2: i128 = 23;
        // D s_1359_3: read-var u#32184:u32
        let s_1359_3: u32 = fn_state.u_32184;
        // D s_1359_4: cast zx s_1359_3 -> bv
        let s_1359_4: Bits = Bits::new(s_1359_3 as u128, 32u16);
        // C s_1359_5: const #1s : i64
        let s_1359_5: i64 = 1;
        // C s_1359_6: cast zx s_1359_5 -> i
        let s_1359_6: i128 = (i128::try_from(s_1359_5).unwrap());
        // C s_1359_7: const #8s : i
        let s_1359_7: i128 = 8;
        // C s_1359_8: add s_1359_7 s_1359_6
        let s_1359_8: i128 = (s_1359_7 + s_1359_6);
        // D s_1359_9: bit-extract s_1359_4 s_1359_2 s_1359_8
        let s_1359_9: Bits = (Bits::new(
            ((s_1359_4) >> (s_1359_2)).value(),
            u16::try_from(s_1359_8).unwrap(),
        ));
        // D s_1359_10: cast reint s_1359_9 -> u9
        let s_1359_10: u16 = (s_1359_9.value() as u16);
        // D s_1359_11: cast zx s_1359_10 -> bv
        let s_1359_11: Bits = Bits::new(s_1359_10 as u128, 9u16);
        // C s_1359_12: const #484u : u9
        let s_1359_12: u16 = 484;
        // C s_1359_13: cast zx s_1359_12 -> bv
        let s_1359_13: Bits = Bits::new(s_1359_12 as u128, 9u16);
        // D s_1359_14: cmp-eq s_1359_11 s_1359_13
        let s_1359_14: bool = ((s_1359_11) == (s_1359_13));
        // N s_1359_15: branch s_1359_14 b1727 b1360
        if s_1359_14 {
            return block_1727(state, tracer, fn_state);
        } else {
            return block_1360(state, tracer, fn_state);
        };
    }
    fn block_1360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1360_0: const #0u : u8
        let s_1360_0: bool = false;
        // D s_1360_1: write-var gs#403255 <= s_1360_0
        fn_state.gs_403255 = s_1360_0;
        // N s_1360_2: jump b1361
        return block_1361(state, tracer, fn_state);
    }
    fn block_1361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1361_0: read-var gs#403255:u8
        let s_1361_0: bool = fn_state.gs_403255;
        // N s_1361_1: branch s_1361_0 b1726 b1362
        if s_1361_0 {
            return block_1726(state, tracer, fn_state);
        } else {
            return block_1362(state, tracer, fn_state);
        };
    }
    fn block_1362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1362_0: const #0u : u8
        let s_1362_0: bool = false;
        // D s_1362_1: write-var gs#403257 <= s_1362_0
        fn_state.gs_403257 = s_1362_0;
        // N s_1362_2: jump b1363
        return block_1363(state, tracer, fn_state);
    }
    fn block_1363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1363_0: read-var gs#403257:u8
        let s_1363_0: bool = fn_state.gs_403257;
        // D s_1363_1: not s_1363_0
        let s_1363_1: bool = !s_1363_0;
        // N s_1363_2: branch s_1363_1 b1365 b1364
        if s_1363_1 {
            return block_1365(state, tracer, fn_state);
        } else {
            return block_1364(state, tracer, fn_state);
        };
    }
    fn block_1364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1364_0: const #3832s : i
        let s_1364_0: i128 = 3832;
        // C s_1364_1: const #14696u : u32
        let s_1364_1: u32 = 14696;
        // N s_1364_2: write-reg s_1364_1 <= s_1364_0
        let s_1364_2: () = {
            state.write_register::<i128>(s_1364_1 as isize, s_1364_0);
            tracer.write_register(s_1364_1 as isize, s_1364_0);
        };
        // C s_1364_3: const #22s : i
        let s_1364_3: i128 = 22;
        // C s_1364_4: const #1s : i
        let s_1364_4: i128 = 1;
        // D s_1364_5: read-var u#32184:u32
        let s_1364_5: u32 = fn_state.u_32184;
        // D s_1364_6: cast zx s_1364_5 -> bv
        let s_1364_6: Bits = Bits::new(s_1364_5 as u128, 32u16);
        // D s_1364_7: bit-extract s_1364_6 s_1364_3 s_1364_4
        let s_1364_7: Bits = (Bits::new(
            ((s_1364_6) >> (s_1364_3)).value(),
            u16::try_from(s_1364_4).unwrap(),
        ));
        // D s_1364_8: cast reint s_1364_7 -> u8
        let s_1364_8: bool = ((s_1364_7.value()) != 0);
        // C s_1364_9: const #16s : i
        let s_1364_9: i128 = 16;
        // C s_1364_10: const #4s : i
        let s_1364_10: i128 = 4;
        // D s_1364_11: read-var u#32184:u32
        let s_1364_11: u32 = fn_state.u_32184;
        // D s_1364_12: cast zx s_1364_11 -> bv
        let s_1364_12: Bits = Bits::new(s_1364_11 as u128, 32u16);
        // D s_1364_13: bit-extract s_1364_12 s_1364_9 s_1364_10
        let s_1364_13: Bits = (Bits::new(
            ((s_1364_12) >> (s_1364_9)).value(),
            u16::try_from(s_1364_10).unwrap(),
        ));
        // D s_1364_14: cast reint s_1364_13 -> u8
        let s_1364_14: u8 = (s_1364_13.value() as u8);
        // C s_1364_15: const #12s : i
        let s_1364_15: i128 = 12;
        // C s_1364_16: const #4s : i
        let s_1364_16: i128 = 4;
        // D s_1364_17: read-var u#32184:u32
        let s_1364_17: u32 = fn_state.u_32184;
        // D s_1364_18: cast zx s_1364_17 -> bv
        let s_1364_18: Bits = Bits::new(s_1364_17 as u128, 32u16);
        // D s_1364_19: bit-extract s_1364_18 s_1364_15 s_1364_16
        let s_1364_19: Bits = (Bits::new(
            ((s_1364_18) >> (s_1364_15)).value(),
            u16::try_from(s_1364_16).unwrap(),
        ));
        // D s_1364_20: cast reint s_1364_19 -> u8
        let s_1364_20: u8 = (s_1364_19.value() as u8);
        // C s_1364_21: const #7s : i
        let s_1364_21: i128 = 7;
        // C s_1364_22: const #1s : i
        let s_1364_22: i128 = 1;
        // D s_1364_23: read-var u#32184:u32
        let s_1364_23: u32 = fn_state.u_32184;
        // D s_1364_24: cast zx s_1364_23 -> bv
        let s_1364_24: Bits = Bits::new(s_1364_23 as u128, 32u16);
        // D s_1364_25: bit-extract s_1364_24 s_1364_21 s_1364_22
        let s_1364_25: Bits = (Bits::new(
            ((s_1364_24) >> (s_1364_21)).value(),
            u16::try_from(s_1364_22).unwrap(),
        ));
        // D s_1364_26: cast reint s_1364_25 -> u8
        let s_1364_26: bool = ((s_1364_25.value()) != 0);
        // C s_1364_27: const #6s : i
        let s_1364_27: i128 = 6;
        // C s_1364_28: const #1s : i
        let s_1364_28: i128 = 1;
        // D s_1364_29: read-var u#32184:u32
        let s_1364_29: u32 = fn_state.u_32184;
        // D s_1364_30: cast zx s_1364_29 -> bv
        let s_1364_30: Bits = Bits::new(s_1364_29 as u128, 32u16);
        // D s_1364_31: bit-extract s_1364_30 s_1364_27 s_1364_28
        let s_1364_31: Bits = (Bits::new(
            ((s_1364_30) >> (s_1364_27)).value(),
            u16::try_from(s_1364_28).unwrap(),
        ));
        // D s_1364_32: cast reint s_1364_31 -> u8
        let s_1364_32: bool = ((s_1364_31.value()) != 0);
        // C s_1364_33: const #5s : i
        let s_1364_33: i128 = 5;
        // C s_1364_34: const #1s : i
        let s_1364_34: i128 = 1;
        // D s_1364_35: read-var u#32184:u32
        let s_1364_35: u32 = fn_state.u_32184;
        // D s_1364_36: cast zx s_1364_35 -> bv
        let s_1364_36: Bits = Bits::new(s_1364_35 as u128, 32u16);
        // D s_1364_37: bit-extract s_1364_36 s_1364_33 s_1364_34
        let s_1364_37: Bits = (Bits::new(
            ((s_1364_36) >> (s_1364_33)).value(),
            u16::try_from(s_1364_34).unwrap(),
        ));
        // D s_1364_38: cast reint s_1364_37 -> u8
        let s_1364_38: bool = ((s_1364_37.value()) != 0);
        // C s_1364_39: const #0s : i
        let s_1364_39: i128 = 0;
        // C s_1364_40: const #4s : i
        let s_1364_40: i128 = 4;
        // D s_1364_41: read-var u#32184:u32
        let s_1364_41: u32 = fn_state.u_32184;
        // D s_1364_42: cast zx s_1364_41 -> bv
        let s_1364_42: Bits = Bits::new(s_1364_41 as u128, 32u16);
        // D s_1364_43: bit-extract s_1364_42 s_1364_39 s_1364_40
        let s_1364_43: Bits = (Bits::new(
            ((s_1364_42) >> (s_1364_39)).value(),
            u16::try_from(s_1364_40).unwrap(),
        ));
        // D s_1364_44: cast reint s_1364_43 -> u8
        let s_1364_44: u8 = (s_1364_43.value() as u8);
        // D s_1364_45: call decode_aarch32_instrs_SHA1C_A1enc_A_txt(s_1364_8, s_1364_14, s_1364_20, s_1364_26, s_1364_32, s_1364_38, s_1364_44)
        let s_1364_45: () = decode_aarch32_instrs_SHA1C_A1enc_A_txt(
            state,
            tracer,
            s_1364_8,
            s_1364_14,
            s_1364_20,
            s_1364_26,
            s_1364_32,
            s_1364_38,
            s_1364_44,
        );
        // N s_1364_46: return
        return;
    }
    fn block_1365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1365_0: read-var merge#var.1:struct
        let s_1365_0: u32 = fn_state.merge_var._1;
        // D s_1365_1: write-var u#32193 <= s_1365_0
        fn_state.u_32193 = s_1365_0;
        // C s_1365_2: const #23s : i
        let s_1365_2: i128 = 23;
        // D s_1365_3: read-var u#32193:u32
        let s_1365_3: u32 = fn_state.u_32193;
        // D s_1365_4: cast zx s_1365_3 -> bv
        let s_1365_4: Bits = Bits::new(s_1365_3 as u128, 32u16);
        // C s_1365_5: const #1s : i64
        let s_1365_5: i64 = 1;
        // C s_1365_6: cast zx s_1365_5 -> i
        let s_1365_6: i128 = (i128::try_from(s_1365_5).unwrap());
        // C s_1365_7: const #8s : i
        let s_1365_7: i128 = 8;
        // C s_1365_8: add s_1365_7 s_1365_6
        let s_1365_8: i128 = (s_1365_7 + s_1365_6);
        // D s_1365_9: bit-extract s_1365_4 s_1365_2 s_1365_8
        let s_1365_9: Bits = (Bits::new(
            ((s_1365_4) >> (s_1365_2)).value(),
            u16::try_from(s_1365_8).unwrap(),
        ));
        // D s_1365_10: cast reint s_1365_9 -> u9
        let s_1365_10: u16 = (s_1365_9.value() as u16);
        // D s_1365_11: cast zx s_1365_10 -> bv
        let s_1365_11: Bits = Bits::new(s_1365_10 as u128, 9u16);
        // C s_1365_12: const #487u : u9
        let s_1365_12: u16 = 487;
        // C s_1365_13: cast zx s_1365_12 -> bv
        let s_1365_13: Bits = Bits::new(s_1365_12 as u128, 9u16);
        // D s_1365_14: cmp-eq s_1365_11 s_1365_13
        let s_1365_14: bool = ((s_1365_11) == (s_1365_13));
        // N s_1365_15: branch s_1365_14 b1716 b1366
        if s_1365_14 {
            return block_1716(state, tracer, fn_state);
        } else {
            return block_1366(state, tracer, fn_state);
        };
    }
    fn block_1366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1366_0: const #0u : u8
        let s_1366_0: bool = false;
        // D s_1366_1: write-var gs#403288 <= s_1366_0
        fn_state.gs_403288 = s_1366_0;
        // N s_1366_2: jump b1367
        return block_1367(state, tracer, fn_state);
    }
    fn block_1367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1367_0: read-var gs#403288:u8
        let s_1367_0: bool = fn_state.gs_403288;
        // N s_1367_1: branch s_1367_0 b1715 b1368
        if s_1367_0 {
            return block_1715(state, tracer, fn_state);
        } else {
            return block_1368(state, tracer, fn_state);
        };
    }
    fn block_1368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1368_0: const #0u : u8
        let s_1368_0: bool = false;
        // D s_1368_1: write-var gs#403290 <= s_1368_0
        fn_state.gs_403290 = s_1368_0;
        // N s_1368_2: jump b1369
        return block_1369(state, tracer, fn_state);
    }
    fn block_1369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1369_0: read-var gs#403290:u8
        let s_1369_0: bool = fn_state.gs_403290;
        // D s_1369_1: not s_1369_0
        let s_1369_1: bool = !s_1369_0;
        // N s_1369_2: branch s_1369_1 b1371 b1370
        if s_1369_1 {
            return block_1371(state, tracer, fn_state);
        } else {
            return block_1370(state, tracer, fn_state);
        };
    }
    fn block_1370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1370_0: const #3834s : i
        let s_1370_0: i128 = 3834;
        // C s_1370_1: const #14696u : u32
        let s_1370_1: u32 = 14696;
        // N s_1370_2: write-reg s_1370_1 <= s_1370_0
        let s_1370_2: () = {
            state.write_register::<i128>(s_1370_1 as isize, s_1370_0);
            tracer.write_register(s_1370_1 as isize, s_1370_0);
        };
        // C s_1370_3: const #22s : i
        let s_1370_3: i128 = 22;
        // C s_1370_4: const #1s : i
        let s_1370_4: i128 = 1;
        // D s_1370_5: read-var u#32193:u32
        let s_1370_5: u32 = fn_state.u_32193;
        // D s_1370_6: cast zx s_1370_5 -> bv
        let s_1370_6: Bits = Bits::new(s_1370_5 as u128, 32u16);
        // D s_1370_7: bit-extract s_1370_6 s_1370_3 s_1370_4
        let s_1370_7: Bits = (Bits::new(
            ((s_1370_6) >> (s_1370_3)).value(),
            u16::try_from(s_1370_4).unwrap(),
        ));
        // D s_1370_8: cast reint s_1370_7 -> u8
        let s_1370_8: bool = ((s_1370_7.value()) != 0);
        // C s_1370_9: const #18s : i
        let s_1370_9: i128 = 18;
        // C s_1370_10: const #2s : i
        let s_1370_10: i128 = 2;
        // D s_1370_11: read-var u#32193:u32
        let s_1370_11: u32 = fn_state.u_32193;
        // D s_1370_12: cast zx s_1370_11 -> bv
        let s_1370_12: Bits = Bits::new(s_1370_11 as u128, 32u16);
        // D s_1370_13: bit-extract s_1370_12 s_1370_9 s_1370_10
        let s_1370_13: Bits = (Bits::new(
            ((s_1370_12) >> (s_1370_9)).value(),
            u16::try_from(s_1370_10).unwrap(),
        ));
        // D s_1370_14: cast reint s_1370_13 -> u8
        let s_1370_14: u8 = (s_1370_13.value() as u8);
        // C s_1370_15: const #12s : i
        let s_1370_15: i128 = 12;
        // C s_1370_16: const #4s : i
        let s_1370_16: i128 = 4;
        // D s_1370_17: read-var u#32193:u32
        let s_1370_17: u32 = fn_state.u_32193;
        // D s_1370_18: cast zx s_1370_17 -> bv
        let s_1370_18: Bits = Bits::new(s_1370_17 as u128, 32u16);
        // D s_1370_19: bit-extract s_1370_18 s_1370_15 s_1370_16
        let s_1370_19: Bits = (Bits::new(
            ((s_1370_18) >> (s_1370_15)).value(),
            u16::try_from(s_1370_16).unwrap(),
        ));
        // D s_1370_20: cast reint s_1370_19 -> u8
        let s_1370_20: u8 = (s_1370_19.value() as u8);
        // C s_1370_21: const #5s : i
        let s_1370_21: i128 = 5;
        // C s_1370_22: const #1s : i
        let s_1370_22: i128 = 1;
        // D s_1370_23: read-var u#32193:u32
        let s_1370_23: u32 = fn_state.u_32193;
        // D s_1370_24: cast zx s_1370_23 -> bv
        let s_1370_24: Bits = Bits::new(s_1370_23 as u128, 32u16);
        // D s_1370_25: bit-extract s_1370_24 s_1370_21 s_1370_22
        let s_1370_25: Bits = (Bits::new(
            ((s_1370_24) >> (s_1370_21)).value(),
            u16::try_from(s_1370_22).unwrap(),
        ));
        // D s_1370_26: cast reint s_1370_25 -> u8
        let s_1370_26: bool = ((s_1370_25.value()) != 0);
        // C s_1370_27: const #0s : i
        let s_1370_27: i128 = 0;
        // C s_1370_28: const #4s : i
        let s_1370_28: i128 = 4;
        // D s_1370_29: read-var u#32193:u32
        let s_1370_29: u32 = fn_state.u_32193;
        // D s_1370_30: cast zx s_1370_29 -> bv
        let s_1370_30: Bits = Bits::new(s_1370_29 as u128, 32u16);
        // D s_1370_31: bit-extract s_1370_30 s_1370_27 s_1370_28
        let s_1370_31: Bits = (Bits::new(
            ((s_1370_30) >> (s_1370_27)).value(),
            u16::try_from(s_1370_28).unwrap(),
        ));
        // D s_1370_32: cast reint s_1370_31 -> u8
        let s_1370_32: u8 = (s_1370_31.value() as u8);
        // D s_1370_33: call decode_aarch32_instrs_SHA1H_A1enc_A_txt(s_1370_8, s_1370_14, s_1370_20, s_1370_26, s_1370_32)
        let s_1370_33: () = decode_aarch32_instrs_SHA1H_A1enc_A_txt(
            state,
            tracer,
            s_1370_8,
            s_1370_14,
            s_1370_20,
            s_1370_26,
            s_1370_32,
        );
        // N s_1370_34: return
        return;
    }
    fn block_1371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1371_0: read-var merge#var.1:struct
        let s_1371_0: u32 = fn_state.merge_var._1;
        // D s_1371_1: write-var u#32200 <= s_1371_0
        fn_state.u_32200 = s_1371_0;
        // C s_1371_2: const #23s : i
        let s_1371_2: i128 = 23;
        // D s_1371_3: read-var u#32200:u32
        let s_1371_3: u32 = fn_state.u_32200;
        // D s_1371_4: cast zx s_1371_3 -> bv
        let s_1371_4: Bits = Bits::new(s_1371_3 as u128, 32u16);
        // C s_1371_5: const #1s : i64
        let s_1371_5: i64 = 1;
        // C s_1371_6: cast zx s_1371_5 -> i
        let s_1371_6: i128 = (i128::try_from(s_1371_5).unwrap());
        // C s_1371_7: const #8s : i
        let s_1371_7: i128 = 8;
        // C s_1371_8: add s_1371_7 s_1371_6
        let s_1371_8: i128 = (s_1371_7 + s_1371_6);
        // D s_1371_9: bit-extract s_1371_4 s_1371_2 s_1371_8
        let s_1371_9: Bits = (Bits::new(
            ((s_1371_4) >> (s_1371_2)).value(),
            u16::try_from(s_1371_8).unwrap(),
        ));
        // D s_1371_10: cast reint s_1371_9 -> u9
        let s_1371_10: u16 = (s_1371_9.value() as u16);
        // D s_1371_11: cast zx s_1371_10 -> bv
        let s_1371_11: Bits = Bits::new(s_1371_10 as u128, 9u16);
        // C s_1371_12: const #484u : u9
        let s_1371_12: u16 = 484;
        // C s_1371_13: cast zx s_1371_12 -> bv
        let s_1371_13: Bits = Bits::new(s_1371_12 as u128, 9u16);
        // D s_1371_14: cmp-eq s_1371_11 s_1371_13
        let s_1371_14: bool = ((s_1371_11) == (s_1371_13));
        // N s_1371_15: branch s_1371_14 b1708 b1372
        if s_1371_14 {
            return block_1708(state, tracer, fn_state);
        } else {
            return block_1372(state, tracer, fn_state);
        };
    }
    fn block_1372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1372_0: const #0u : u8
        let s_1372_0: bool = false;
        // D s_1372_1: write-var gs#403314 <= s_1372_0
        fn_state.gs_403314 = s_1372_0;
        // N s_1372_2: jump b1373
        return block_1373(state, tracer, fn_state);
    }
    fn block_1373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1373_0: read-var gs#403314:u8
        let s_1373_0: bool = fn_state.gs_403314;
        // N s_1373_1: branch s_1373_0 b1707 b1374
        if s_1373_0 {
            return block_1707(state, tracer, fn_state);
        } else {
            return block_1374(state, tracer, fn_state);
        };
    }
    fn block_1374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1374_0: const #0u : u8
        let s_1374_0: bool = false;
        // D s_1374_1: write-var gs#403316 <= s_1374_0
        fn_state.gs_403316 = s_1374_0;
        // N s_1374_2: jump b1375
        return block_1375(state, tracer, fn_state);
    }
    fn block_1375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1375_0: read-var gs#403316:u8
        let s_1375_0: bool = fn_state.gs_403316;
        // D s_1375_1: not s_1375_0
        let s_1375_1: bool = !s_1375_0;
        // N s_1375_2: branch s_1375_1 b1377 b1376
        if s_1375_1 {
            return block_1377(state, tracer, fn_state);
        } else {
            return block_1376(state, tracer, fn_state);
        };
    }
    fn block_1376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1376_0: const #3836s : i
        let s_1376_0: i128 = 3836;
        // C s_1376_1: const #14696u : u32
        let s_1376_1: u32 = 14696;
        // N s_1376_2: write-reg s_1376_1 <= s_1376_0
        let s_1376_2: () = {
            state.write_register::<i128>(s_1376_1 as isize, s_1376_0);
            tracer.write_register(s_1376_1 as isize, s_1376_0);
        };
        // C s_1376_3: const #22s : i
        let s_1376_3: i128 = 22;
        // C s_1376_4: const #1s : i
        let s_1376_4: i128 = 1;
        // D s_1376_5: read-var u#32200:u32
        let s_1376_5: u32 = fn_state.u_32200;
        // D s_1376_6: cast zx s_1376_5 -> bv
        let s_1376_6: Bits = Bits::new(s_1376_5 as u128, 32u16);
        // D s_1376_7: bit-extract s_1376_6 s_1376_3 s_1376_4
        let s_1376_7: Bits = (Bits::new(
            ((s_1376_6) >> (s_1376_3)).value(),
            u16::try_from(s_1376_4).unwrap(),
        ));
        // D s_1376_8: cast reint s_1376_7 -> u8
        let s_1376_8: bool = ((s_1376_7.value()) != 0);
        // C s_1376_9: const #16s : i
        let s_1376_9: i128 = 16;
        // C s_1376_10: const #4s : i
        let s_1376_10: i128 = 4;
        // D s_1376_11: read-var u#32200:u32
        let s_1376_11: u32 = fn_state.u_32200;
        // D s_1376_12: cast zx s_1376_11 -> bv
        let s_1376_12: Bits = Bits::new(s_1376_11 as u128, 32u16);
        // D s_1376_13: bit-extract s_1376_12 s_1376_9 s_1376_10
        let s_1376_13: Bits = (Bits::new(
            ((s_1376_12) >> (s_1376_9)).value(),
            u16::try_from(s_1376_10).unwrap(),
        ));
        // D s_1376_14: cast reint s_1376_13 -> u8
        let s_1376_14: u8 = (s_1376_13.value() as u8);
        // C s_1376_15: const #12s : i
        let s_1376_15: i128 = 12;
        // C s_1376_16: const #4s : i
        let s_1376_16: i128 = 4;
        // D s_1376_17: read-var u#32200:u32
        let s_1376_17: u32 = fn_state.u_32200;
        // D s_1376_18: cast zx s_1376_17 -> bv
        let s_1376_18: Bits = Bits::new(s_1376_17 as u128, 32u16);
        // D s_1376_19: bit-extract s_1376_18 s_1376_15 s_1376_16
        let s_1376_19: Bits = (Bits::new(
            ((s_1376_18) >> (s_1376_15)).value(),
            u16::try_from(s_1376_16).unwrap(),
        ));
        // D s_1376_20: cast reint s_1376_19 -> u8
        let s_1376_20: u8 = (s_1376_19.value() as u8);
        // C s_1376_21: const #7s : i
        let s_1376_21: i128 = 7;
        // C s_1376_22: const #1s : i
        let s_1376_22: i128 = 1;
        // D s_1376_23: read-var u#32200:u32
        let s_1376_23: u32 = fn_state.u_32200;
        // D s_1376_24: cast zx s_1376_23 -> bv
        let s_1376_24: Bits = Bits::new(s_1376_23 as u128, 32u16);
        // D s_1376_25: bit-extract s_1376_24 s_1376_21 s_1376_22
        let s_1376_25: Bits = (Bits::new(
            ((s_1376_24) >> (s_1376_21)).value(),
            u16::try_from(s_1376_22).unwrap(),
        ));
        // D s_1376_26: cast reint s_1376_25 -> u8
        let s_1376_26: bool = ((s_1376_25.value()) != 0);
        // C s_1376_27: const #6s : i
        let s_1376_27: i128 = 6;
        // C s_1376_28: const #1s : i
        let s_1376_28: i128 = 1;
        // D s_1376_29: read-var u#32200:u32
        let s_1376_29: u32 = fn_state.u_32200;
        // D s_1376_30: cast zx s_1376_29 -> bv
        let s_1376_30: Bits = Bits::new(s_1376_29 as u128, 32u16);
        // D s_1376_31: bit-extract s_1376_30 s_1376_27 s_1376_28
        let s_1376_31: Bits = (Bits::new(
            ((s_1376_30) >> (s_1376_27)).value(),
            u16::try_from(s_1376_28).unwrap(),
        ));
        // D s_1376_32: cast reint s_1376_31 -> u8
        let s_1376_32: bool = ((s_1376_31.value()) != 0);
        // C s_1376_33: const #5s : i
        let s_1376_33: i128 = 5;
        // C s_1376_34: const #1s : i
        let s_1376_34: i128 = 1;
        // D s_1376_35: read-var u#32200:u32
        let s_1376_35: u32 = fn_state.u_32200;
        // D s_1376_36: cast zx s_1376_35 -> bv
        let s_1376_36: Bits = Bits::new(s_1376_35 as u128, 32u16);
        // D s_1376_37: bit-extract s_1376_36 s_1376_33 s_1376_34
        let s_1376_37: Bits = (Bits::new(
            ((s_1376_36) >> (s_1376_33)).value(),
            u16::try_from(s_1376_34).unwrap(),
        ));
        // D s_1376_38: cast reint s_1376_37 -> u8
        let s_1376_38: bool = ((s_1376_37.value()) != 0);
        // C s_1376_39: const #0s : i
        let s_1376_39: i128 = 0;
        // C s_1376_40: const #4s : i
        let s_1376_40: i128 = 4;
        // D s_1376_41: read-var u#32200:u32
        let s_1376_41: u32 = fn_state.u_32200;
        // D s_1376_42: cast zx s_1376_41 -> bv
        let s_1376_42: Bits = Bits::new(s_1376_41 as u128, 32u16);
        // D s_1376_43: bit-extract s_1376_42 s_1376_39 s_1376_40
        let s_1376_43: Bits = (Bits::new(
            ((s_1376_42) >> (s_1376_39)).value(),
            u16::try_from(s_1376_40).unwrap(),
        ));
        // D s_1376_44: cast reint s_1376_43 -> u8
        let s_1376_44: u8 = (s_1376_43.value() as u8);
        // D s_1376_45: call decode_aarch32_instrs_SHA1M_A1enc_A_txt(s_1376_8, s_1376_14, s_1376_20, s_1376_26, s_1376_32, s_1376_38, s_1376_44)
        let s_1376_45: () = decode_aarch32_instrs_SHA1M_A1enc_A_txt(
            state,
            tracer,
            s_1376_8,
            s_1376_14,
            s_1376_20,
            s_1376_26,
            s_1376_32,
            s_1376_38,
            s_1376_44,
        );
        // N s_1376_46: return
        return;
    }
    fn block_1377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1377_0: read-var merge#var.1:struct
        let s_1377_0: u32 = fn_state.merge_var._1;
        // D s_1377_1: write-var u#32209 <= s_1377_0
        fn_state.u_32209 = s_1377_0;
        // C s_1377_2: const #23s : i
        let s_1377_2: i128 = 23;
        // D s_1377_3: read-var u#32209:u32
        let s_1377_3: u32 = fn_state.u_32209;
        // D s_1377_4: cast zx s_1377_3 -> bv
        let s_1377_4: Bits = Bits::new(s_1377_3 as u128, 32u16);
        // C s_1377_5: const #1s : i64
        let s_1377_5: i64 = 1;
        // C s_1377_6: cast zx s_1377_5 -> i
        let s_1377_6: i128 = (i128::try_from(s_1377_5).unwrap());
        // C s_1377_7: const #8s : i
        let s_1377_7: i128 = 8;
        // C s_1377_8: add s_1377_7 s_1377_6
        let s_1377_8: i128 = (s_1377_7 + s_1377_6);
        // D s_1377_9: bit-extract s_1377_4 s_1377_2 s_1377_8
        let s_1377_9: Bits = (Bits::new(
            ((s_1377_4) >> (s_1377_2)).value(),
            u16::try_from(s_1377_8).unwrap(),
        ));
        // D s_1377_10: cast reint s_1377_9 -> u9
        let s_1377_10: u16 = (s_1377_9.value() as u16);
        // D s_1377_11: cast zx s_1377_10 -> bv
        let s_1377_11: Bits = Bits::new(s_1377_10 as u128, 9u16);
        // C s_1377_12: const #484u : u9
        let s_1377_12: u16 = 484;
        // C s_1377_13: cast zx s_1377_12 -> bv
        let s_1377_13: Bits = Bits::new(s_1377_12 as u128, 9u16);
        // D s_1377_14: cmp-eq s_1377_11 s_1377_13
        let s_1377_14: bool = ((s_1377_11) == (s_1377_13));
        // N s_1377_15: branch s_1377_14 b1700 b1378
        if s_1377_14 {
            return block_1700(state, tracer, fn_state);
        } else {
            return block_1378(state, tracer, fn_state);
        };
    }
    fn block_1378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1378_0: const #0u : u8
        let s_1378_0: bool = false;
        // D s_1378_1: write-var gs#403344 <= s_1378_0
        fn_state.gs_403344 = s_1378_0;
        // N s_1378_2: jump b1379
        return block_1379(state, tracer, fn_state);
    }
    fn block_1379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1379_0: read-var gs#403344:u8
        let s_1379_0: bool = fn_state.gs_403344;
        // N s_1379_1: branch s_1379_0 b1699 b1380
        if s_1379_0 {
            return block_1699(state, tracer, fn_state);
        } else {
            return block_1380(state, tracer, fn_state);
        };
    }
    fn block_1380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1380_0: const #0u : u8
        let s_1380_0: bool = false;
        // D s_1380_1: write-var gs#403346 <= s_1380_0
        fn_state.gs_403346 = s_1380_0;
        // N s_1380_2: jump b1381
        return block_1381(state, tracer, fn_state);
    }
    fn block_1381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1381_0: read-var gs#403346:u8
        let s_1381_0: bool = fn_state.gs_403346;
        // D s_1381_1: not s_1381_0
        let s_1381_1: bool = !s_1381_0;
        // N s_1381_2: branch s_1381_1 b1383 b1382
        if s_1381_1 {
            return block_1383(state, tracer, fn_state);
        } else {
            return block_1382(state, tracer, fn_state);
        };
    }
    fn block_1382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1382_0: const #3838s : i
        let s_1382_0: i128 = 3838;
        // C s_1382_1: const #14696u : u32
        let s_1382_1: u32 = 14696;
        // N s_1382_2: write-reg s_1382_1 <= s_1382_0
        let s_1382_2: () = {
            state.write_register::<i128>(s_1382_1 as isize, s_1382_0);
            tracer.write_register(s_1382_1 as isize, s_1382_0);
        };
        // C s_1382_3: const #22s : i
        let s_1382_3: i128 = 22;
        // C s_1382_4: const #1s : i
        let s_1382_4: i128 = 1;
        // D s_1382_5: read-var u#32209:u32
        let s_1382_5: u32 = fn_state.u_32209;
        // D s_1382_6: cast zx s_1382_5 -> bv
        let s_1382_6: Bits = Bits::new(s_1382_5 as u128, 32u16);
        // D s_1382_7: bit-extract s_1382_6 s_1382_3 s_1382_4
        let s_1382_7: Bits = (Bits::new(
            ((s_1382_6) >> (s_1382_3)).value(),
            u16::try_from(s_1382_4).unwrap(),
        ));
        // D s_1382_8: cast reint s_1382_7 -> u8
        let s_1382_8: bool = ((s_1382_7.value()) != 0);
        // C s_1382_9: const #16s : i
        let s_1382_9: i128 = 16;
        // C s_1382_10: const #4s : i
        let s_1382_10: i128 = 4;
        // D s_1382_11: read-var u#32209:u32
        let s_1382_11: u32 = fn_state.u_32209;
        // D s_1382_12: cast zx s_1382_11 -> bv
        let s_1382_12: Bits = Bits::new(s_1382_11 as u128, 32u16);
        // D s_1382_13: bit-extract s_1382_12 s_1382_9 s_1382_10
        let s_1382_13: Bits = (Bits::new(
            ((s_1382_12) >> (s_1382_9)).value(),
            u16::try_from(s_1382_10).unwrap(),
        ));
        // D s_1382_14: cast reint s_1382_13 -> u8
        let s_1382_14: u8 = (s_1382_13.value() as u8);
        // C s_1382_15: const #12s : i
        let s_1382_15: i128 = 12;
        // C s_1382_16: const #4s : i
        let s_1382_16: i128 = 4;
        // D s_1382_17: read-var u#32209:u32
        let s_1382_17: u32 = fn_state.u_32209;
        // D s_1382_18: cast zx s_1382_17 -> bv
        let s_1382_18: Bits = Bits::new(s_1382_17 as u128, 32u16);
        // D s_1382_19: bit-extract s_1382_18 s_1382_15 s_1382_16
        let s_1382_19: Bits = (Bits::new(
            ((s_1382_18) >> (s_1382_15)).value(),
            u16::try_from(s_1382_16).unwrap(),
        ));
        // D s_1382_20: cast reint s_1382_19 -> u8
        let s_1382_20: u8 = (s_1382_19.value() as u8);
        // C s_1382_21: const #7s : i
        let s_1382_21: i128 = 7;
        // C s_1382_22: const #1s : i
        let s_1382_22: i128 = 1;
        // D s_1382_23: read-var u#32209:u32
        let s_1382_23: u32 = fn_state.u_32209;
        // D s_1382_24: cast zx s_1382_23 -> bv
        let s_1382_24: Bits = Bits::new(s_1382_23 as u128, 32u16);
        // D s_1382_25: bit-extract s_1382_24 s_1382_21 s_1382_22
        let s_1382_25: Bits = (Bits::new(
            ((s_1382_24) >> (s_1382_21)).value(),
            u16::try_from(s_1382_22).unwrap(),
        ));
        // D s_1382_26: cast reint s_1382_25 -> u8
        let s_1382_26: bool = ((s_1382_25.value()) != 0);
        // C s_1382_27: const #6s : i
        let s_1382_27: i128 = 6;
        // C s_1382_28: const #1s : i
        let s_1382_28: i128 = 1;
        // D s_1382_29: read-var u#32209:u32
        let s_1382_29: u32 = fn_state.u_32209;
        // D s_1382_30: cast zx s_1382_29 -> bv
        let s_1382_30: Bits = Bits::new(s_1382_29 as u128, 32u16);
        // D s_1382_31: bit-extract s_1382_30 s_1382_27 s_1382_28
        let s_1382_31: Bits = (Bits::new(
            ((s_1382_30) >> (s_1382_27)).value(),
            u16::try_from(s_1382_28).unwrap(),
        ));
        // D s_1382_32: cast reint s_1382_31 -> u8
        let s_1382_32: bool = ((s_1382_31.value()) != 0);
        // C s_1382_33: const #5s : i
        let s_1382_33: i128 = 5;
        // C s_1382_34: const #1s : i
        let s_1382_34: i128 = 1;
        // D s_1382_35: read-var u#32209:u32
        let s_1382_35: u32 = fn_state.u_32209;
        // D s_1382_36: cast zx s_1382_35 -> bv
        let s_1382_36: Bits = Bits::new(s_1382_35 as u128, 32u16);
        // D s_1382_37: bit-extract s_1382_36 s_1382_33 s_1382_34
        let s_1382_37: Bits = (Bits::new(
            ((s_1382_36) >> (s_1382_33)).value(),
            u16::try_from(s_1382_34).unwrap(),
        ));
        // D s_1382_38: cast reint s_1382_37 -> u8
        let s_1382_38: bool = ((s_1382_37.value()) != 0);
        // C s_1382_39: const #0s : i
        let s_1382_39: i128 = 0;
        // C s_1382_40: const #4s : i
        let s_1382_40: i128 = 4;
        // D s_1382_41: read-var u#32209:u32
        let s_1382_41: u32 = fn_state.u_32209;
        // D s_1382_42: cast zx s_1382_41 -> bv
        let s_1382_42: Bits = Bits::new(s_1382_41 as u128, 32u16);
        // D s_1382_43: bit-extract s_1382_42 s_1382_39 s_1382_40
        let s_1382_43: Bits = (Bits::new(
            ((s_1382_42) >> (s_1382_39)).value(),
            u16::try_from(s_1382_40).unwrap(),
        ));
        // D s_1382_44: cast reint s_1382_43 -> u8
        let s_1382_44: u8 = (s_1382_43.value() as u8);
        // D s_1382_45: call decode_aarch32_instrs_SHA1P_A1enc_A_txt(s_1382_8, s_1382_14, s_1382_20, s_1382_26, s_1382_32, s_1382_38, s_1382_44)
        let s_1382_45: () = decode_aarch32_instrs_SHA1P_A1enc_A_txt(
            state,
            tracer,
            s_1382_8,
            s_1382_14,
            s_1382_20,
            s_1382_26,
            s_1382_32,
            s_1382_38,
            s_1382_44,
        );
        // N s_1382_46: return
        return;
    }
    fn block_1383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1383_0: read-var merge#var.1:struct
        let s_1383_0: u32 = fn_state.merge_var._1;
        // D s_1383_1: write-var u#32218 <= s_1383_0
        fn_state.u_32218 = s_1383_0;
        // C s_1383_2: const #23s : i
        let s_1383_2: i128 = 23;
        // D s_1383_3: read-var u#32218:u32
        let s_1383_3: u32 = fn_state.u_32218;
        // D s_1383_4: cast zx s_1383_3 -> bv
        let s_1383_4: Bits = Bits::new(s_1383_3 as u128, 32u16);
        // C s_1383_5: const #1s : i64
        let s_1383_5: i64 = 1;
        // C s_1383_6: cast zx s_1383_5 -> i
        let s_1383_6: i128 = (i128::try_from(s_1383_5).unwrap());
        // C s_1383_7: const #8s : i
        let s_1383_7: i128 = 8;
        // C s_1383_8: add s_1383_7 s_1383_6
        let s_1383_8: i128 = (s_1383_7 + s_1383_6);
        // D s_1383_9: bit-extract s_1383_4 s_1383_2 s_1383_8
        let s_1383_9: Bits = (Bits::new(
            ((s_1383_4) >> (s_1383_2)).value(),
            u16::try_from(s_1383_8).unwrap(),
        ));
        // D s_1383_10: cast reint s_1383_9 -> u9
        let s_1383_10: u16 = (s_1383_9.value() as u16);
        // D s_1383_11: cast zx s_1383_10 -> bv
        let s_1383_11: Bits = Bits::new(s_1383_10 as u128, 9u16);
        // C s_1383_12: const #484u : u9
        let s_1383_12: u16 = 484;
        // C s_1383_13: cast zx s_1383_12 -> bv
        let s_1383_13: Bits = Bits::new(s_1383_12 as u128, 9u16);
        // D s_1383_14: cmp-eq s_1383_11 s_1383_13
        let s_1383_14: bool = ((s_1383_11) == (s_1383_13));
        // N s_1383_15: branch s_1383_14 b1692 b1384
        if s_1383_14 {
            return block_1692(state, tracer, fn_state);
        } else {
            return block_1384(state, tracer, fn_state);
        };
    }
    fn block_1384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1384_0: const #0u : u8
        let s_1384_0: bool = false;
        // D s_1384_1: write-var gs#403374 <= s_1384_0
        fn_state.gs_403374 = s_1384_0;
        // N s_1384_2: jump b1385
        return block_1385(state, tracer, fn_state);
    }
    fn block_1385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1385_0: read-var gs#403374:u8
        let s_1385_0: bool = fn_state.gs_403374;
        // N s_1385_1: branch s_1385_0 b1691 b1386
        if s_1385_0 {
            return block_1691(state, tracer, fn_state);
        } else {
            return block_1386(state, tracer, fn_state);
        };
    }
    fn block_1386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1386_0: const #0u : u8
        let s_1386_0: bool = false;
        // D s_1386_1: write-var gs#403376 <= s_1386_0
        fn_state.gs_403376 = s_1386_0;
        // N s_1386_2: jump b1387
        return block_1387(state, tracer, fn_state);
    }
    fn block_1387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1387_0: read-var gs#403376:u8
        let s_1387_0: bool = fn_state.gs_403376;
        // D s_1387_1: not s_1387_0
        let s_1387_1: bool = !s_1387_0;
        // N s_1387_2: branch s_1387_1 b1389 b1388
        if s_1387_1 {
            return block_1389(state, tracer, fn_state);
        } else {
            return block_1388(state, tracer, fn_state);
        };
    }
    fn block_1388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1388_0: const #3840s : i
        let s_1388_0: i128 = 3840;
        // C s_1388_1: const #14696u : u32
        let s_1388_1: u32 = 14696;
        // N s_1388_2: write-reg s_1388_1 <= s_1388_0
        let s_1388_2: () = {
            state.write_register::<i128>(s_1388_1 as isize, s_1388_0);
            tracer.write_register(s_1388_1 as isize, s_1388_0);
        };
        // C s_1388_3: const #22s : i
        let s_1388_3: i128 = 22;
        // C s_1388_4: const #1s : i
        let s_1388_4: i128 = 1;
        // D s_1388_5: read-var u#32218:u32
        let s_1388_5: u32 = fn_state.u_32218;
        // D s_1388_6: cast zx s_1388_5 -> bv
        let s_1388_6: Bits = Bits::new(s_1388_5 as u128, 32u16);
        // D s_1388_7: bit-extract s_1388_6 s_1388_3 s_1388_4
        let s_1388_7: Bits = (Bits::new(
            ((s_1388_6) >> (s_1388_3)).value(),
            u16::try_from(s_1388_4).unwrap(),
        ));
        // D s_1388_8: cast reint s_1388_7 -> u8
        let s_1388_8: bool = ((s_1388_7.value()) != 0);
        // C s_1388_9: const #16s : i
        let s_1388_9: i128 = 16;
        // C s_1388_10: const #4s : i
        let s_1388_10: i128 = 4;
        // D s_1388_11: read-var u#32218:u32
        let s_1388_11: u32 = fn_state.u_32218;
        // D s_1388_12: cast zx s_1388_11 -> bv
        let s_1388_12: Bits = Bits::new(s_1388_11 as u128, 32u16);
        // D s_1388_13: bit-extract s_1388_12 s_1388_9 s_1388_10
        let s_1388_13: Bits = (Bits::new(
            ((s_1388_12) >> (s_1388_9)).value(),
            u16::try_from(s_1388_10).unwrap(),
        ));
        // D s_1388_14: cast reint s_1388_13 -> u8
        let s_1388_14: u8 = (s_1388_13.value() as u8);
        // C s_1388_15: const #12s : i
        let s_1388_15: i128 = 12;
        // C s_1388_16: const #4s : i
        let s_1388_16: i128 = 4;
        // D s_1388_17: read-var u#32218:u32
        let s_1388_17: u32 = fn_state.u_32218;
        // D s_1388_18: cast zx s_1388_17 -> bv
        let s_1388_18: Bits = Bits::new(s_1388_17 as u128, 32u16);
        // D s_1388_19: bit-extract s_1388_18 s_1388_15 s_1388_16
        let s_1388_19: Bits = (Bits::new(
            ((s_1388_18) >> (s_1388_15)).value(),
            u16::try_from(s_1388_16).unwrap(),
        ));
        // D s_1388_20: cast reint s_1388_19 -> u8
        let s_1388_20: u8 = (s_1388_19.value() as u8);
        // C s_1388_21: const #7s : i
        let s_1388_21: i128 = 7;
        // C s_1388_22: const #1s : i
        let s_1388_22: i128 = 1;
        // D s_1388_23: read-var u#32218:u32
        let s_1388_23: u32 = fn_state.u_32218;
        // D s_1388_24: cast zx s_1388_23 -> bv
        let s_1388_24: Bits = Bits::new(s_1388_23 as u128, 32u16);
        // D s_1388_25: bit-extract s_1388_24 s_1388_21 s_1388_22
        let s_1388_25: Bits = (Bits::new(
            ((s_1388_24) >> (s_1388_21)).value(),
            u16::try_from(s_1388_22).unwrap(),
        ));
        // D s_1388_26: cast reint s_1388_25 -> u8
        let s_1388_26: bool = ((s_1388_25.value()) != 0);
        // C s_1388_27: const #6s : i
        let s_1388_27: i128 = 6;
        // C s_1388_28: const #1s : i
        let s_1388_28: i128 = 1;
        // D s_1388_29: read-var u#32218:u32
        let s_1388_29: u32 = fn_state.u_32218;
        // D s_1388_30: cast zx s_1388_29 -> bv
        let s_1388_30: Bits = Bits::new(s_1388_29 as u128, 32u16);
        // D s_1388_31: bit-extract s_1388_30 s_1388_27 s_1388_28
        let s_1388_31: Bits = (Bits::new(
            ((s_1388_30) >> (s_1388_27)).value(),
            u16::try_from(s_1388_28).unwrap(),
        ));
        // D s_1388_32: cast reint s_1388_31 -> u8
        let s_1388_32: bool = ((s_1388_31.value()) != 0);
        // C s_1388_33: const #5s : i
        let s_1388_33: i128 = 5;
        // C s_1388_34: const #1s : i
        let s_1388_34: i128 = 1;
        // D s_1388_35: read-var u#32218:u32
        let s_1388_35: u32 = fn_state.u_32218;
        // D s_1388_36: cast zx s_1388_35 -> bv
        let s_1388_36: Bits = Bits::new(s_1388_35 as u128, 32u16);
        // D s_1388_37: bit-extract s_1388_36 s_1388_33 s_1388_34
        let s_1388_37: Bits = (Bits::new(
            ((s_1388_36) >> (s_1388_33)).value(),
            u16::try_from(s_1388_34).unwrap(),
        ));
        // D s_1388_38: cast reint s_1388_37 -> u8
        let s_1388_38: bool = ((s_1388_37.value()) != 0);
        // C s_1388_39: const #0s : i
        let s_1388_39: i128 = 0;
        // C s_1388_40: const #4s : i
        let s_1388_40: i128 = 4;
        // D s_1388_41: read-var u#32218:u32
        let s_1388_41: u32 = fn_state.u_32218;
        // D s_1388_42: cast zx s_1388_41 -> bv
        let s_1388_42: Bits = Bits::new(s_1388_41 as u128, 32u16);
        // D s_1388_43: bit-extract s_1388_42 s_1388_39 s_1388_40
        let s_1388_43: Bits = (Bits::new(
            ((s_1388_42) >> (s_1388_39)).value(),
            u16::try_from(s_1388_40).unwrap(),
        ));
        // D s_1388_44: cast reint s_1388_43 -> u8
        let s_1388_44: u8 = (s_1388_43.value() as u8);
        // D s_1388_45: call decode_aarch32_instrs_SHA1SU0_A1enc_A_txt(s_1388_8, s_1388_14, s_1388_20, s_1388_26, s_1388_32, s_1388_38, s_1388_44)
        let s_1388_45: () = decode_aarch32_instrs_SHA1SU0_A1enc_A_txt(
            state,
            tracer,
            s_1388_8,
            s_1388_14,
            s_1388_20,
            s_1388_26,
            s_1388_32,
            s_1388_38,
            s_1388_44,
        );
        // N s_1388_46: return
        return;
    }
    fn block_1389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1389_0: read-var merge#var.1:struct
        let s_1389_0: u32 = fn_state.merge_var._1;
        // D s_1389_1: write-var u#32227 <= s_1389_0
        fn_state.u_32227 = s_1389_0;
        // C s_1389_2: const #23s : i
        let s_1389_2: i128 = 23;
        // D s_1389_3: read-var u#32227:u32
        let s_1389_3: u32 = fn_state.u_32227;
        // D s_1389_4: cast zx s_1389_3 -> bv
        let s_1389_4: Bits = Bits::new(s_1389_3 as u128, 32u16);
        // C s_1389_5: const #1s : i64
        let s_1389_5: i64 = 1;
        // C s_1389_6: cast zx s_1389_5 -> i
        let s_1389_6: i128 = (i128::try_from(s_1389_5).unwrap());
        // C s_1389_7: const #8s : i
        let s_1389_7: i128 = 8;
        // C s_1389_8: add s_1389_7 s_1389_6
        let s_1389_8: i128 = (s_1389_7 + s_1389_6);
        // D s_1389_9: bit-extract s_1389_4 s_1389_2 s_1389_8
        let s_1389_9: Bits = (Bits::new(
            ((s_1389_4) >> (s_1389_2)).value(),
            u16::try_from(s_1389_8).unwrap(),
        ));
        // D s_1389_10: cast reint s_1389_9 -> u9
        let s_1389_10: u16 = (s_1389_9.value() as u16);
        // D s_1389_11: cast zx s_1389_10 -> bv
        let s_1389_11: Bits = Bits::new(s_1389_10 as u128, 9u16);
        // C s_1389_12: const #487u : u9
        let s_1389_12: u16 = 487;
        // C s_1389_13: cast zx s_1389_12 -> bv
        let s_1389_13: Bits = Bits::new(s_1389_12 as u128, 9u16);
        // D s_1389_14: cmp-eq s_1389_11 s_1389_13
        let s_1389_14: bool = ((s_1389_11) == (s_1389_13));
        // N s_1389_15: branch s_1389_14 b1681 b1390
        if s_1389_14 {
            return block_1681(state, tracer, fn_state);
        } else {
            return block_1390(state, tracer, fn_state);
        };
    }
    fn block_1390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1390_0: const #0u : u8
        let s_1390_0: bool = false;
        // D s_1390_1: write-var gs#403407 <= s_1390_0
        fn_state.gs_403407 = s_1390_0;
        // N s_1390_2: jump b1391
        return block_1391(state, tracer, fn_state);
    }
    fn block_1391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1391_0: read-var gs#403407:u8
        let s_1391_0: bool = fn_state.gs_403407;
        // N s_1391_1: branch s_1391_0 b1680 b1392
        if s_1391_0 {
            return block_1680(state, tracer, fn_state);
        } else {
            return block_1392(state, tracer, fn_state);
        };
    }
    fn block_1392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1392_0: const #0u : u8
        let s_1392_0: bool = false;
        // D s_1392_1: write-var gs#403409 <= s_1392_0
        fn_state.gs_403409 = s_1392_0;
        // N s_1392_2: jump b1393
        return block_1393(state, tracer, fn_state);
    }
    fn block_1393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1393_0: read-var gs#403409:u8
        let s_1393_0: bool = fn_state.gs_403409;
        // D s_1393_1: not s_1393_0
        let s_1393_1: bool = !s_1393_0;
        // N s_1393_2: branch s_1393_1 b1395 b1394
        if s_1393_1 {
            return block_1395(state, tracer, fn_state);
        } else {
            return block_1394(state, tracer, fn_state);
        };
    }
    fn block_1394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1394_0: const #3842s : i
        let s_1394_0: i128 = 3842;
        // C s_1394_1: const #14696u : u32
        let s_1394_1: u32 = 14696;
        // N s_1394_2: write-reg s_1394_1 <= s_1394_0
        let s_1394_2: () = {
            state.write_register::<i128>(s_1394_1 as isize, s_1394_0);
            tracer.write_register(s_1394_1 as isize, s_1394_0);
        };
        // C s_1394_3: const #22s : i
        let s_1394_3: i128 = 22;
        // C s_1394_4: const #1s : i
        let s_1394_4: i128 = 1;
        // D s_1394_5: read-var u#32227:u32
        let s_1394_5: u32 = fn_state.u_32227;
        // D s_1394_6: cast zx s_1394_5 -> bv
        let s_1394_6: Bits = Bits::new(s_1394_5 as u128, 32u16);
        // D s_1394_7: bit-extract s_1394_6 s_1394_3 s_1394_4
        let s_1394_7: Bits = (Bits::new(
            ((s_1394_6) >> (s_1394_3)).value(),
            u16::try_from(s_1394_4).unwrap(),
        ));
        // D s_1394_8: cast reint s_1394_7 -> u8
        let s_1394_8: bool = ((s_1394_7.value()) != 0);
        // C s_1394_9: const #18s : i
        let s_1394_9: i128 = 18;
        // C s_1394_10: const #2s : i
        let s_1394_10: i128 = 2;
        // D s_1394_11: read-var u#32227:u32
        let s_1394_11: u32 = fn_state.u_32227;
        // D s_1394_12: cast zx s_1394_11 -> bv
        let s_1394_12: Bits = Bits::new(s_1394_11 as u128, 32u16);
        // D s_1394_13: bit-extract s_1394_12 s_1394_9 s_1394_10
        let s_1394_13: Bits = (Bits::new(
            ((s_1394_12) >> (s_1394_9)).value(),
            u16::try_from(s_1394_10).unwrap(),
        ));
        // D s_1394_14: cast reint s_1394_13 -> u8
        let s_1394_14: u8 = (s_1394_13.value() as u8);
        // C s_1394_15: const #12s : i
        let s_1394_15: i128 = 12;
        // C s_1394_16: const #4s : i
        let s_1394_16: i128 = 4;
        // D s_1394_17: read-var u#32227:u32
        let s_1394_17: u32 = fn_state.u_32227;
        // D s_1394_18: cast zx s_1394_17 -> bv
        let s_1394_18: Bits = Bits::new(s_1394_17 as u128, 32u16);
        // D s_1394_19: bit-extract s_1394_18 s_1394_15 s_1394_16
        let s_1394_19: Bits = (Bits::new(
            ((s_1394_18) >> (s_1394_15)).value(),
            u16::try_from(s_1394_16).unwrap(),
        ));
        // D s_1394_20: cast reint s_1394_19 -> u8
        let s_1394_20: u8 = (s_1394_19.value() as u8);
        // C s_1394_21: const #5s : i
        let s_1394_21: i128 = 5;
        // C s_1394_22: const #1s : i
        let s_1394_22: i128 = 1;
        // D s_1394_23: read-var u#32227:u32
        let s_1394_23: u32 = fn_state.u_32227;
        // D s_1394_24: cast zx s_1394_23 -> bv
        let s_1394_24: Bits = Bits::new(s_1394_23 as u128, 32u16);
        // D s_1394_25: bit-extract s_1394_24 s_1394_21 s_1394_22
        let s_1394_25: Bits = (Bits::new(
            ((s_1394_24) >> (s_1394_21)).value(),
            u16::try_from(s_1394_22).unwrap(),
        ));
        // D s_1394_26: cast reint s_1394_25 -> u8
        let s_1394_26: bool = ((s_1394_25.value()) != 0);
        // C s_1394_27: const #0s : i
        let s_1394_27: i128 = 0;
        // C s_1394_28: const #4s : i
        let s_1394_28: i128 = 4;
        // D s_1394_29: read-var u#32227:u32
        let s_1394_29: u32 = fn_state.u_32227;
        // D s_1394_30: cast zx s_1394_29 -> bv
        let s_1394_30: Bits = Bits::new(s_1394_29 as u128, 32u16);
        // D s_1394_31: bit-extract s_1394_30 s_1394_27 s_1394_28
        let s_1394_31: Bits = (Bits::new(
            ((s_1394_30) >> (s_1394_27)).value(),
            u16::try_from(s_1394_28).unwrap(),
        ));
        // D s_1394_32: cast reint s_1394_31 -> u8
        let s_1394_32: u8 = (s_1394_31.value() as u8);
        // D s_1394_33: call decode_aarch32_instrs_SHA1SU1_A1enc_A_txt(s_1394_8, s_1394_14, s_1394_20, s_1394_26, s_1394_32)
        let s_1394_33: () = decode_aarch32_instrs_SHA1SU1_A1enc_A_txt(
            state,
            tracer,
            s_1394_8,
            s_1394_14,
            s_1394_20,
            s_1394_26,
            s_1394_32,
        );
        // N s_1394_34: return
        return;
    }
    fn block_1395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1395_0: read-var merge#var.1:struct
        let s_1395_0: u32 = fn_state.merge_var._1;
        // D s_1395_1: write-var u#32234 <= s_1395_0
        fn_state.u_32234 = s_1395_0;
        // C s_1395_2: const #23s : i
        let s_1395_2: i128 = 23;
        // D s_1395_3: read-var u#32234:u32
        let s_1395_3: u32 = fn_state.u_32234;
        // D s_1395_4: cast zx s_1395_3 -> bv
        let s_1395_4: Bits = Bits::new(s_1395_3 as u128, 32u16);
        // C s_1395_5: const #1s : i64
        let s_1395_5: i64 = 1;
        // C s_1395_6: cast zx s_1395_5 -> i
        let s_1395_6: i128 = (i128::try_from(s_1395_5).unwrap());
        // C s_1395_7: const #8s : i
        let s_1395_7: i128 = 8;
        // C s_1395_8: add s_1395_7 s_1395_6
        let s_1395_8: i128 = (s_1395_7 + s_1395_6);
        // D s_1395_9: bit-extract s_1395_4 s_1395_2 s_1395_8
        let s_1395_9: Bits = (Bits::new(
            ((s_1395_4) >> (s_1395_2)).value(),
            u16::try_from(s_1395_8).unwrap(),
        ));
        // D s_1395_10: cast reint s_1395_9 -> u9
        let s_1395_10: u16 = (s_1395_9.value() as u16);
        // D s_1395_11: cast zx s_1395_10 -> bv
        let s_1395_11: Bits = Bits::new(s_1395_10 as u128, 9u16);
        // C s_1395_12: const #486u : u9
        let s_1395_12: u16 = 486;
        // C s_1395_13: cast zx s_1395_12 -> bv
        let s_1395_13: Bits = Bits::new(s_1395_12 as u128, 9u16);
        // D s_1395_14: cmp-eq s_1395_11 s_1395_13
        let s_1395_14: bool = ((s_1395_11) == (s_1395_13));
        // N s_1395_15: branch s_1395_14 b1673 b1396
        if s_1395_14 {
            return block_1673(state, tracer, fn_state);
        } else {
            return block_1396(state, tracer, fn_state);
        };
    }
    fn block_1396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1396_0: const #0u : u8
        let s_1396_0: bool = false;
        // D s_1396_1: write-var gs#403433 <= s_1396_0
        fn_state.gs_403433 = s_1396_0;
        // N s_1396_2: jump b1397
        return block_1397(state, tracer, fn_state);
    }
    fn block_1397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1397_0: read-var gs#403433:u8
        let s_1397_0: bool = fn_state.gs_403433;
        // N s_1397_1: branch s_1397_0 b1672 b1398
        if s_1397_0 {
            return block_1672(state, tracer, fn_state);
        } else {
            return block_1398(state, tracer, fn_state);
        };
    }
    fn block_1398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1398_0: const #0u : u8
        let s_1398_0: bool = false;
        // D s_1398_1: write-var gs#403435 <= s_1398_0
        fn_state.gs_403435 = s_1398_0;
        // N s_1398_2: jump b1399
        return block_1399(state, tracer, fn_state);
    }
    fn block_1399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1399_0: read-var gs#403435:u8
        let s_1399_0: bool = fn_state.gs_403435;
        // D s_1399_1: not s_1399_0
        let s_1399_1: bool = !s_1399_0;
        // N s_1399_2: branch s_1399_1 b1401 b1400
        if s_1399_1 {
            return block_1401(state, tracer, fn_state);
        } else {
            return block_1400(state, tracer, fn_state);
        };
    }
    fn block_1400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1400_0: const #3844s : i
        let s_1400_0: i128 = 3844;
        // C s_1400_1: const #14696u : u32
        let s_1400_1: u32 = 14696;
        // N s_1400_2: write-reg s_1400_1 <= s_1400_0
        let s_1400_2: () = {
            state.write_register::<i128>(s_1400_1 as isize, s_1400_0);
            tracer.write_register(s_1400_1 as isize, s_1400_0);
        };
        // C s_1400_3: const #22s : i
        let s_1400_3: i128 = 22;
        // C s_1400_4: const #1s : i
        let s_1400_4: i128 = 1;
        // D s_1400_5: read-var u#32234:u32
        let s_1400_5: u32 = fn_state.u_32234;
        // D s_1400_6: cast zx s_1400_5 -> bv
        let s_1400_6: Bits = Bits::new(s_1400_5 as u128, 32u16);
        // D s_1400_7: bit-extract s_1400_6 s_1400_3 s_1400_4
        let s_1400_7: Bits = (Bits::new(
            ((s_1400_6) >> (s_1400_3)).value(),
            u16::try_from(s_1400_4).unwrap(),
        ));
        // D s_1400_8: cast reint s_1400_7 -> u8
        let s_1400_8: bool = ((s_1400_7.value()) != 0);
        // C s_1400_9: const #16s : i
        let s_1400_9: i128 = 16;
        // C s_1400_10: const #4s : i
        let s_1400_10: i128 = 4;
        // D s_1400_11: read-var u#32234:u32
        let s_1400_11: u32 = fn_state.u_32234;
        // D s_1400_12: cast zx s_1400_11 -> bv
        let s_1400_12: Bits = Bits::new(s_1400_11 as u128, 32u16);
        // D s_1400_13: bit-extract s_1400_12 s_1400_9 s_1400_10
        let s_1400_13: Bits = (Bits::new(
            ((s_1400_12) >> (s_1400_9)).value(),
            u16::try_from(s_1400_10).unwrap(),
        ));
        // D s_1400_14: cast reint s_1400_13 -> u8
        let s_1400_14: u8 = (s_1400_13.value() as u8);
        // C s_1400_15: const #12s : i
        let s_1400_15: i128 = 12;
        // C s_1400_16: const #4s : i
        let s_1400_16: i128 = 4;
        // D s_1400_17: read-var u#32234:u32
        let s_1400_17: u32 = fn_state.u_32234;
        // D s_1400_18: cast zx s_1400_17 -> bv
        let s_1400_18: Bits = Bits::new(s_1400_17 as u128, 32u16);
        // D s_1400_19: bit-extract s_1400_18 s_1400_15 s_1400_16
        let s_1400_19: Bits = (Bits::new(
            ((s_1400_18) >> (s_1400_15)).value(),
            u16::try_from(s_1400_16).unwrap(),
        ));
        // D s_1400_20: cast reint s_1400_19 -> u8
        let s_1400_20: u8 = (s_1400_19.value() as u8);
        // C s_1400_21: const #7s : i
        let s_1400_21: i128 = 7;
        // C s_1400_22: const #1s : i
        let s_1400_22: i128 = 1;
        // D s_1400_23: read-var u#32234:u32
        let s_1400_23: u32 = fn_state.u_32234;
        // D s_1400_24: cast zx s_1400_23 -> bv
        let s_1400_24: Bits = Bits::new(s_1400_23 as u128, 32u16);
        // D s_1400_25: bit-extract s_1400_24 s_1400_21 s_1400_22
        let s_1400_25: Bits = (Bits::new(
            ((s_1400_24) >> (s_1400_21)).value(),
            u16::try_from(s_1400_22).unwrap(),
        ));
        // D s_1400_26: cast reint s_1400_25 -> u8
        let s_1400_26: bool = ((s_1400_25.value()) != 0);
        // C s_1400_27: const #6s : i
        let s_1400_27: i128 = 6;
        // C s_1400_28: const #1s : i
        let s_1400_28: i128 = 1;
        // D s_1400_29: read-var u#32234:u32
        let s_1400_29: u32 = fn_state.u_32234;
        // D s_1400_30: cast zx s_1400_29 -> bv
        let s_1400_30: Bits = Bits::new(s_1400_29 as u128, 32u16);
        // D s_1400_31: bit-extract s_1400_30 s_1400_27 s_1400_28
        let s_1400_31: Bits = (Bits::new(
            ((s_1400_30) >> (s_1400_27)).value(),
            u16::try_from(s_1400_28).unwrap(),
        ));
        // D s_1400_32: cast reint s_1400_31 -> u8
        let s_1400_32: bool = ((s_1400_31.value()) != 0);
        // C s_1400_33: const #5s : i
        let s_1400_33: i128 = 5;
        // C s_1400_34: const #1s : i
        let s_1400_34: i128 = 1;
        // D s_1400_35: read-var u#32234:u32
        let s_1400_35: u32 = fn_state.u_32234;
        // D s_1400_36: cast zx s_1400_35 -> bv
        let s_1400_36: Bits = Bits::new(s_1400_35 as u128, 32u16);
        // D s_1400_37: bit-extract s_1400_36 s_1400_33 s_1400_34
        let s_1400_37: Bits = (Bits::new(
            ((s_1400_36) >> (s_1400_33)).value(),
            u16::try_from(s_1400_34).unwrap(),
        ));
        // D s_1400_38: cast reint s_1400_37 -> u8
        let s_1400_38: bool = ((s_1400_37.value()) != 0);
        // C s_1400_39: const #0s : i
        let s_1400_39: i128 = 0;
        // C s_1400_40: const #4s : i
        let s_1400_40: i128 = 4;
        // D s_1400_41: read-var u#32234:u32
        let s_1400_41: u32 = fn_state.u_32234;
        // D s_1400_42: cast zx s_1400_41 -> bv
        let s_1400_42: Bits = Bits::new(s_1400_41 as u128, 32u16);
        // D s_1400_43: bit-extract s_1400_42 s_1400_39 s_1400_40
        let s_1400_43: Bits = (Bits::new(
            ((s_1400_42) >> (s_1400_39)).value(),
            u16::try_from(s_1400_40).unwrap(),
        ));
        // D s_1400_44: cast reint s_1400_43 -> u8
        let s_1400_44: u8 = (s_1400_43.value() as u8);
        // D s_1400_45: call decode_aarch32_instrs_SHA256H_A1enc_A_txt(s_1400_8, s_1400_14, s_1400_20, s_1400_26, s_1400_32, s_1400_38, s_1400_44)
        let s_1400_45: () = decode_aarch32_instrs_SHA256H_A1enc_A_txt(
            state,
            tracer,
            s_1400_8,
            s_1400_14,
            s_1400_20,
            s_1400_26,
            s_1400_32,
            s_1400_38,
            s_1400_44,
        );
        // N s_1400_46: return
        return;
    }
    fn block_1401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1401_0: read-var merge#var.1:struct
        let s_1401_0: u32 = fn_state.merge_var._1;
        // D s_1401_1: write-var u#32243 <= s_1401_0
        fn_state.u_32243 = s_1401_0;
        // C s_1401_2: const #23s : i
        let s_1401_2: i128 = 23;
        // D s_1401_3: read-var u#32243:u32
        let s_1401_3: u32 = fn_state.u_32243;
        // D s_1401_4: cast zx s_1401_3 -> bv
        let s_1401_4: Bits = Bits::new(s_1401_3 as u128, 32u16);
        // C s_1401_5: const #1s : i64
        let s_1401_5: i64 = 1;
        // C s_1401_6: cast zx s_1401_5 -> i
        let s_1401_6: i128 = (i128::try_from(s_1401_5).unwrap());
        // C s_1401_7: const #8s : i
        let s_1401_7: i128 = 8;
        // C s_1401_8: add s_1401_7 s_1401_6
        let s_1401_8: i128 = (s_1401_7 + s_1401_6);
        // D s_1401_9: bit-extract s_1401_4 s_1401_2 s_1401_8
        let s_1401_9: Bits = (Bits::new(
            ((s_1401_4) >> (s_1401_2)).value(),
            u16::try_from(s_1401_8).unwrap(),
        ));
        // D s_1401_10: cast reint s_1401_9 -> u9
        let s_1401_10: u16 = (s_1401_9.value() as u16);
        // D s_1401_11: cast zx s_1401_10 -> bv
        let s_1401_11: Bits = Bits::new(s_1401_10 as u128, 9u16);
        // C s_1401_12: const #486u : u9
        let s_1401_12: u16 = 486;
        // C s_1401_13: cast zx s_1401_12 -> bv
        let s_1401_13: Bits = Bits::new(s_1401_12 as u128, 9u16);
        // D s_1401_14: cmp-eq s_1401_11 s_1401_13
        let s_1401_14: bool = ((s_1401_11) == (s_1401_13));
        // N s_1401_15: branch s_1401_14 b1665 b1402
        if s_1401_14 {
            return block_1665(state, tracer, fn_state);
        } else {
            return block_1402(state, tracer, fn_state);
        };
    }
    fn block_1402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1402_0: const #0u : u8
        let s_1402_0: bool = false;
        // D s_1402_1: write-var gs#403463 <= s_1402_0
        fn_state.gs_403463 = s_1402_0;
        // N s_1402_2: jump b1403
        return block_1403(state, tracer, fn_state);
    }
    fn block_1403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1403_0: read-var gs#403463:u8
        let s_1403_0: bool = fn_state.gs_403463;
        // N s_1403_1: branch s_1403_0 b1664 b1404
        if s_1403_0 {
            return block_1664(state, tracer, fn_state);
        } else {
            return block_1404(state, tracer, fn_state);
        };
    }
    fn block_1404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1404_0: const #0u : u8
        let s_1404_0: bool = false;
        // D s_1404_1: write-var gs#403465 <= s_1404_0
        fn_state.gs_403465 = s_1404_0;
        // N s_1404_2: jump b1405
        return block_1405(state, tracer, fn_state);
    }
    fn block_1405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1405_0: read-var gs#403465:u8
        let s_1405_0: bool = fn_state.gs_403465;
        // D s_1405_1: not s_1405_0
        let s_1405_1: bool = !s_1405_0;
        // N s_1405_2: branch s_1405_1 b1407 b1406
        if s_1405_1 {
            return block_1407(state, tracer, fn_state);
        } else {
            return block_1406(state, tracer, fn_state);
        };
    }
    fn block_1406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1406_0: const #3846s : i
        let s_1406_0: i128 = 3846;
        // C s_1406_1: const #14696u : u32
        let s_1406_1: u32 = 14696;
        // N s_1406_2: write-reg s_1406_1 <= s_1406_0
        let s_1406_2: () = {
            state.write_register::<i128>(s_1406_1 as isize, s_1406_0);
            tracer.write_register(s_1406_1 as isize, s_1406_0);
        };
        // C s_1406_3: const #22s : i
        let s_1406_3: i128 = 22;
        // C s_1406_4: const #1s : i
        let s_1406_4: i128 = 1;
        // D s_1406_5: read-var u#32243:u32
        let s_1406_5: u32 = fn_state.u_32243;
        // D s_1406_6: cast zx s_1406_5 -> bv
        let s_1406_6: Bits = Bits::new(s_1406_5 as u128, 32u16);
        // D s_1406_7: bit-extract s_1406_6 s_1406_3 s_1406_4
        let s_1406_7: Bits = (Bits::new(
            ((s_1406_6) >> (s_1406_3)).value(),
            u16::try_from(s_1406_4).unwrap(),
        ));
        // D s_1406_8: cast reint s_1406_7 -> u8
        let s_1406_8: bool = ((s_1406_7.value()) != 0);
        // C s_1406_9: const #16s : i
        let s_1406_9: i128 = 16;
        // C s_1406_10: const #4s : i
        let s_1406_10: i128 = 4;
        // D s_1406_11: read-var u#32243:u32
        let s_1406_11: u32 = fn_state.u_32243;
        // D s_1406_12: cast zx s_1406_11 -> bv
        let s_1406_12: Bits = Bits::new(s_1406_11 as u128, 32u16);
        // D s_1406_13: bit-extract s_1406_12 s_1406_9 s_1406_10
        let s_1406_13: Bits = (Bits::new(
            ((s_1406_12) >> (s_1406_9)).value(),
            u16::try_from(s_1406_10).unwrap(),
        ));
        // D s_1406_14: cast reint s_1406_13 -> u8
        let s_1406_14: u8 = (s_1406_13.value() as u8);
        // C s_1406_15: const #12s : i
        let s_1406_15: i128 = 12;
        // C s_1406_16: const #4s : i
        let s_1406_16: i128 = 4;
        // D s_1406_17: read-var u#32243:u32
        let s_1406_17: u32 = fn_state.u_32243;
        // D s_1406_18: cast zx s_1406_17 -> bv
        let s_1406_18: Bits = Bits::new(s_1406_17 as u128, 32u16);
        // D s_1406_19: bit-extract s_1406_18 s_1406_15 s_1406_16
        let s_1406_19: Bits = (Bits::new(
            ((s_1406_18) >> (s_1406_15)).value(),
            u16::try_from(s_1406_16).unwrap(),
        ));
        // D s_1406_20: cast reint s_1406_19 -> u8
        let s_1406_20: u8 = (s_1406_19.value() as u8);
        // C s_1406_21: const #7s : i
        let s_1406_21: i128 = 7;
        // C s_1406_22: const #1s : i
        let s_1406_22: i128 = 1;
        // D s_1406_23: read-var u#32243:u32
        let s_1406_23: u32 = fn_state.u_32243;
        // D s_1406_24: cast zx s_1406_23 -> bv
        let s_1406_24: Bits = Bits::new(s_1406_23 as u128, 32u16);
        // D s_1406_25: bit-extract s_1406_24 s_1406_21 s_1406_22
        let s_1406_25: Bits = (Bits::new(
            ((s_1406_24) >> (s_1406_21)).value(),
            u16::try_from(s_1406_22).unwrap(),
        ));
        // D s_1406_26: cast reint s_1406_25 -> u8
        let s_1406_26: bool = ((s_1406_25.value()) != 0);
        // C s_1406_27: const #6s : i
        let s_1406_27: i128 = 6;
        // C s_1406_28: const #1s : i
        let s_1406_28: i128 = 1;
        // D s_1406_29: read-var u#32243:u32
        let s_1406_29: u32 = fn_state.u_32243;
        // D s_1406_30: cast zx s_1406_29 -> bv
        let s_1406_30: Bits = Bits::new(s_1406_29 as u128, 32u16);
        // D s_1406_31: bit-extract s_1406_30 s_1406_27 s_1406_28
        let s_1406_31: Bits = (Bits::new(
            ((s_1406_30) >> (s_1406_27)).value(),
            u16::try_from(s_1406_28).unwrap(),
        ));
        // D s_1406_32: cast reint s_1406_31 -> u8
        let s_1406_32: bool = ((s_1406_31.value()) != 0);
        // C s_1406_33: const #5s : i
        let s_1406_33: i128 = 5;
        // C s_1406_34: const #1s : i
        let s_1406_34: i128 = 1;
        // D s_1406_35: read-var u#32243:u32
        let s_1406_35: u32 = fn_state.u_32243;
        // D s_1406_36: cast zx s_1406_35 -> bv
        let s_1406_36: Bits = Bits::new(s_1406_35 as u128, 32u16);
        // D s_1406_37: bit-extract s_1406_36 s_1406_33 s_1406_34
        let s_1406_37: Bits = (Bits::new(
            ((s_1406_36) >> (s_1406_33)).value(),
            u16::try_from(s_1406_34).unwrap(),
        ));
        // D s_1406_38: cast reint s_1406_37 -> u8
        let s_1406_38: bool = ((s_1406_37.value()) != 0);
        // C s_1406_39: const #0s : i
        let s_1406_39: i128 = 0;
        // C s_1406_40: const #4s : i
        let s_1406_40: i128 = 4;
        // D s_1406_41: read-var u#32243:u32
        let s_1406_41: u32 = fn_state.u_32243;
        // D s_1406_42: cast zx s_1406_41 -> bv
        let s_1406_42: Bits = Bits::new(s_1406_41 as u128, 32u16);
        // D s_1406_43: bit-extract s_1406_42 s_1406_39 s_1406_40
        let s_1406_43: Bits = (Bits::new(
            ((s_1406_42) >> (s_1406_39)).value(),
            u16::try_from(s_1406_40).unwrap(),
        ));
        // D s_1406_44: cast reint s_1406_43 -> u8
        let s_1406_44: u8 = (s_1406_43.value() as u8);
        // D s_1406_45: call decode_aarch32_instrs_SHA256H2_A1enc_A_txt(s_1406_8, s_1406_14, s_1406_20, s_1406_26, s_1406_32, s_1406_38, s_1406_44)
        let s_1406_45: () = decode_aarch32_instrs_SHA256H2_A1enc_A_txt(
            state,
            tracer,
            s_1406_8,
            s_1406_14,
            s_1406_20,
            s_1406_26,
            s_1406_32,
            s_1406_38,
            s_1406_44,
        );
        // N s_1406_46: return
        return;
    }
    fn block_1407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1407_0: read-var merge#var.1:struct
        let s_1407_0: u32 = fn_state.merge_var._1;
        // D s_1407_1: write-var u#32252 <= s_1407_0
        fn_state.u_32252 = s_1407_0;
        // C s_1407_2: const #23s : i
        let s_1407_2: i128 = 23;
        // D s_1407_3: read-var u#32252:u32
        let s_1407_3: u32 = fn_state.u_32252;
        // D s_1407_4: cast zx s_1407_3 -> bv
        let s_1407_4: Bits = Bits::new(s_1407_3 as u128, 32u16);
        // C s_1407_5: const #1s : i64
        let s_1407_5: i64 = 1;
        // C s_1407_6: cast zx s_1407_5 -> i
        let s_1407_6: i128 = (i128::try_from(s_1407_5).unwrap());
        // C s_1407_7: const #8s : i
        let s_1407_7: i128 = 8;
        // C s_1407_8: add s_1407_7 s_1407_6
        let s_1407_8: i128 = (s_1407_7 + s_1407_6);
        // D s_1407_9: bit-extract s_1407_4 s_1407_2 s_1407_8
        let s_1407_9: Bits = (Bits::new(
            ((s_1407_4) >> (s_1407_2)).value(),
            u16::try_from(s_1407_8).unwrap(),
        ));
        // D s_1407_10: cast reint s_1407_9 -> u9
        let s_1407_10: u16 = (s_1407_9.value() as u16);
        // D s_1407_11: cast zx s_1407_10 -> bv
        let s_1407_11: Bits = Bits::new(s_1407_10 as u128, 9u16);
        // C s_1407_12: const #487u : u9
        let s_1407_12: u16 = 487;
        // C s_1407_13: cast zx s_1407_12 -> bv
        let s_1407_13: Bits = Bits::new(s_1407_12 as u128, 9u16);
        // D s_1407_14: cmp-eq s_1407_11 s_1407_13
        let s_1407_14: bool = ((s_1407_11) == (s_1407_13));
        // N s_1407_15: branch s_1407_14 b1654 b1408
        if s_1407_14 {
            return block_1654(state, tracer, fn_state);
        } else {
            return block_1408(state, tracer, fn_state);
        };
    }
    fn block_1408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1408_0: const #0u : u8
        let s_1408_0: bool = false;
        // D s_1408_1: write-var gs#403496 <= s_1408_0
        fn_state.gs_403496 = s_1408_0;
        // N s_1408_2: jump b1409
        return block_1409(state, tracer, fn_state);
    }
    fn block_1409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1409_0: read-var gs#403496:u8
        let s_1409_0: bool = fn_state.gs_403496;
        // N s_1409_1: branch s_1409_0 b1653 b1410
        if s_1409_0 {
            return block_1653(state, tracer, fn_state);
        } else {
            return block_1410(state, tracer, fn_state);
        };
    }
    fn block_1410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1410_0: const #0u : u8
        let s_1410_0: bool = false;
        // D s_1410_1: write-var gs#403498 <= s_1410_0
        fn_state.gs_403498 = s_1410_0;
        // N s_1410_2: jump b1411
        return block_1411(state, tracer, fn_state);
    }
    fn block_1411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1411_0: read-var gs#403498:u8
        let s_1411_0: bool = fn_state.gs_403498;
        // D s_1411_1: not s_1411_0
        let s_1411_1: bool = !s_1411_0;
        // N s_1411_2: branch s_1411_1 b1413 b1412
        if s_1411_1 {
            return block_1413(state, tracer, fn_state);
        } else {
            return block_1412(state, tracer, fn_state);
        };
    }
    fn block_1412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1412_0: const #3848s : i
        let s_1412_0: i128 = 3848;
        // C s_1412_1: const #14696u : u32
        let s_1412_1: u32 = 14696;
        // N s_1412_2: write-reg s_1412_1 <= s_1412_0
        let s_1412_2: () = {
            state.write_register::<i128>(s_1412_1 as isize, s_1412_0);
            tracer.write_register(s_1412_1 as isize, s_1412_0);
        };
        // C s_1412_3: const #22s : i
        let s_1412_3: i128 = 22;
        // C s_1412_4: const #1s : i
        let s_1412_4: i128 = 1;
        // D s_1412_5: read-var u#32252:u32
        let s_1412_5: u32 = fn_state.u_32252;
        // D s_1412_6: cast zx s_1412_5 -> bv
        let s_1412_6: Bits = Bits::new(s_1412_5 as u128, 32u16);
        // D s_1412_7: bit-extract s_1412_6 s_1412_3 s_1412_4
        let s_1412_7: Bits = (Bits::new(
            ((s_1412_6) >> (s_1412_3)).value(),
            u16::try_from(s_1412_4).unwrap(),
        ));
        // D s_1412_8: cast reint s_1412_7 -> u8
        let s_1412_8: bool = ((s_1412_7.value()) != 0);
        // C s_1412_9: const #18s : i
        let s_1412_9: i128 = 18;
        // C s_1412_10: const #2s : i
        let s_1412_10: i128 = 2;
        // D s_1412_11: read-var u#32252:u32
        let s_1412_11: u32 = fn_state.u_32252;
        // D s_1412_12: cast zx s_1412_11 -> bv
        let s_1412_12: Bits = Bits::new(s_1412_11 as u128, 32u16);
        // D s_1412_13: bit-extract s_1412_12 s_1412_9 s_1412_10
        let s_1412_13: Bits = (Bits::new(
            ((s_1412_12) >> (s_1412_9)).value(),
            u16::try_from(s_1412_10).unwrap(),
        ));
        // D s_1412_14: cast reint s_1412_13 -> u8
        let s_1412_14: u8 = (s_1412_13.value() as u8);
        // C s_1412_15: const #12s : i
        let s_1412_15: i128 = 12;
        // C s_1412_16: const #4s : i
        let s_1412_16: i128 = 4;
        // D s_1412_17: read-var u#32252:u32
        let s_1412_17: u32 = fn_state.u_32252;
        // D s_1412_18: cast zx s_1412_17 -> bv
        let s_1412_18: Bits = Bits::new(s_1412_17 as u128, 32u16);
        // D s_1412_19: bit-extract s_1412_18 s_1412_15 s_1412_16
        let s_1412_19: Bits = (Bits::new(
            ((s_1412_18) >> (s_1412_15)).value(),
            u16::try_from(s_1412_16).unwrap(),
        ));
        // D s_1412_20: cast reint s_1412_19 -> u8
        let s_1412_20: u8 = (s_1412_19.value() as u8);
        // C s_1412_21: const #5s : i
        let s_1412_21: i128 = 5;
        // C s_1412_22: const #1s : i
        let s_1412_22: i128 = 1;
        // D s_1412_23: read-var u#32252:u32
        let s_1412_23: u32 = fn_state.u_32252;
        // D s_1412_24: cast zx s_1412_23 -> bv
        let s_1412_24: Bits = Bits::new(s_1412_23 as u128, 32u16);
        // D s_1412_25: bit-extract s_1412_24 s_1412_21 s_1412_22
        let s_1412_25: Bits = (Bits::new(
            ((s_1412_24) >> (s_1412_21)).value(),
            u16::try_from(s_1412_22).unwrap(),
        ));
        // D s_1412_26: cast reint s_1412_25 -> u8
        let s_1412_26: bool = ((s_1412_25.value()) != 0);
        // C s_1412_27: const #0s : i
        let s_1412_27: i128 = 0;
        // C s_1412_28: const #4s : i
        let s_1412_28: i128 = 4;
        // D s_1412_29: read-var u#32252:u32
        let s_1412_29: u32 = fn_state.u_32252;
        // D s_1412_30: cast zx s_1412_29 -> bv
        let s_1412_30: Bits = Bits::new(s_1412_29 as u128, 32u16);
        // D s_1412_31: bit-extract s_1412_30 s_1412_27 s_1412_28
        let s_1412_31: Bits = (Bits::new(
            ((s_1412_30) >> (s_1412_27)).value(),
            u16::try_from(s_1412_28).unwrap(),
        ));
        // D s_1412_32: cast reint s_1412_31 -> u8
        let s_1412_32: u8 = (s_1412_31.value() as u8);
        // D s_1412_33: call decode_aarch32_instrs_SHA256SU0_A1enc_A_txt(s_1412_8, s_1412_14, s_1412_20, s_1412_26, s_1412_32)
        let s_1412_33: () = decode_aarch32_instrs_SHA256SU0_A1enc_A_txt(
            state,
            tracer,
            s_1412_8,
            s_1412_14,
            s_1412_20,
            s_1412_26,
            s_1412_32,
        );
        // N s_1412_34: return
        return;
    }
    fn block_1413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1413_0: read-var merge#var.1:struct
        let s_1413_0: u32 = fn_state.merge_var._1;
        // D s_1413_1: write-var u#32259 <= s_1413_0
        fn_state.u_32259 = s_1413_0;
        // C s_1413_2: const #23s : i
        let s_1413_2: i128 = 23;
        // D s_1413_3: read-var u#32259:u32
        let s_1413_3: u32 = fn_state.u_32259;
        // D s_1413_4: cast zx s_1413_3 -> bv
        let s_1413_4: Bits = Bits::new(s_1413_3 as u128, 32u16);
        // C s_1413_5: const #1s : i64
        let s_1413_5: i64 = 1;
        // C s_1413_6: cast zx s_1413_5 -> i
        let s_1413_6: i128 = (i128::try_from(s_1413_5).unwrap());
        // C s_1413_7: const #8s : i
        let s_1413_7: i128 = 8;
        // C s_1413_8: add s_1413_7 s_1413_6
        let s_1413_8: i128 = (s_1413_7 + s_1413_6);
        // D s_1413_9: bit-extract s_1413_4 s_1413_2 s_1413_8
        let s_1413_9: Bits = (Bits::new(
            ((s_1413_4) >> (s_1413_2)).value(),
            u16::try_from(s_1413_8).unwrap(),
        ));
        // D s_1413_10: cast reint s_1413_9 -> u9
        let s_1413_10: u16 = (s_1413_9.value() as u16);
        // D s_1413_11: cast zx s_1413_10 -> bv
        let s_1413_11: Bits = Bits::new(s_1413_10 as u128, 9u16);
        // C s_1413_12: const #486u : u9
        let s_1413_12: u16 = 486;
        // C s_1413_13: cast zx s_1413_12 -> bv
        let s_1413_13: Bits = Bits::new(s_1413_12 as u128, 9u16);
        // D s_1413_14: cmp-eq s_1413_11 s_1413_13
        let s_1413_14: bool = ((s_1413_11) == (s_1413_13));
        // N s_1413_15: branch s_1413_14 b1646 b1414
        if s_1413_14 {
            return block_1646(state, tracer, fn_state);
        } else {
            return block_1414(state, tracer, fn_state);
        };
    }
    fn block_1414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1414_0: const #0u : u8
        let s_1414_0: bool = false;
        // D s_1414_1: write-var gs#403522 <= s_1414_0
        fn_state.gs_403522 = s_1414_0;
        // N s_1414_2: jump b1415
        return block_1415(state, tracer, fn_state);
    }
    fn block_1415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1415_0: read-var gs#403522:u8
        let s_1415_0: bool = fn_state.gs_403522;
        // N s_1415_1: branch s_1415_0 b1645 b1416
        if s_1415_0 {
            return block_1645(state, tracer, fn_state);
        } else {
            return block_1416(state, tracer, fn_state);
        };
    }
    fn block_1416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1416_0: const #0u : u8
        let s_1416_0: bool = false;
        // D s_1416_1: write-var gs#403524 <= s_1416_0
        fn_state.gs_403524 = s_1416_0;
        // N s_1416_2: jump b1417
        return block_1417(state, tracer, fn_state);
    }
    fn block_1417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1417_0: read-var gs#403524:u8
        let s_1417_0: bool = fn_state.gs_403524;
        // D s_1417_1: not s_1417_0
        let s_1417_1: bool = !s_1417_0;
        // N s_1417_2: branch s_1417_1 b1419 b1418
        if s_1417_1 {
            return block_1419(state, tracer, fn_state);
        } else {
            return block_1418(state, tracer, fn_state);
        };
    }
    fn block_1418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1418_0: const #3850s : i
        let s_1418_0: i128 = 3850;
        // C s_1418_1: const #14696u : u32
        let s_1418_1: u32 = 14696;
        // N s_1418_2: write-reg s_1418_1 <= s_1418_0
        let s_1418_2: () = {
            state.write_register::<i128>(s_1418_1 as isize, s_1418_0);
            tracer.write_register(s_1418_1 as isize, s_1418_0);
        };
        // C s_1418_3: const #22s : i
        let s_1418_3: i128 = 22;
        // C s_1418_4: const #1s : i
        let s_1418_4: i128 = 1;
        // D s_1418_5: read-var u#32259:u32
        let s_1418_5: u32 = fn_state.u_32259;
        // D s_1418_6: cast zx s_1418_5 -> bv
        let s_1418_6: Bits = Bits::new(s_1418_5 as u128, 32u16);
        // D s_1418_7: bit-extract s_1418_6 s_1418_3 s_1418_4
        let s_1418_7: Bits = (Bits::new(
            ((s_1418_6) >> (s_1418_3)).value(),
            u16::try_from(s_1418_4).unwrap(),
        ));
        // D s_1418_8: cast reint s_1418_7 -> u8
        let s_1418_8: bool = ((s_1418_7.value()) != 0);
        // C s_1418_9: const #16s : i
        let s_1418_9: i128 = 16;
        // C s_1418_10: const #4s : i
        let s_1418_10: i128 = 4;
        // D s_1418_11: read-var u#32259:u32
        let s_1418_11: u32 = fn_state.u_32259;
        // D s_1418_12: cast zx s_1418_11 -> bv
        let s_1418_12: Bits = Bits::new(s_1418_11 as u128, 32u16);
        // D s_1418_13: bit-extract s_1418_12 s_1418_9 s_1418_10
        let s_1418_13: Bits = (Bits::new(
            ((s_1418_12) >> (s_1418_9)).value(),
            u16::try_from(s_1418_10).unwrap(),
        ));
        // D s_1418_14: cast reint s_1418_13 -> u8
        let s_1418_14: u8 = (s_1418_13.value() as u8);
        // C s_1418_15: const #12s : i
        let s_1418_15: i128 = 12;
        // C s_1418_16: const #4s : i
        let s_1418_16: i128 = 4;
        // D s_1418_17: read-var u#32259:u32
        let s_1418_17: u32 = fn_state.u_32259;
        // D s_1418_18: cast zx s_1418_17 -> bv
        let s_1418_18: Bits = Bits::new(s_1418_17 as u128, 32u16);
        // D s_1418_19: bit-extract s_1418_18 s_1418_15 s_1418_16
        let s_1418_19: Bits = (Bits::new(
            ((s_1418_18) >> (s_1418_15)).value(),
            u16::try_from(s_1418_16).unwrap(),
        ));
        // D s_1418_20: cast reint s_1418_19 -> u8
        let s_1418_20: u8 = (s_1418_19.value() as u8);
        // C s_1418_21: const #7s : i
        let s_1418_21: i128 = 7;
        // C s_1418_22: const #1s : i
        let s_1418_22: i128 = 1;
        // D s_1418_23: read-var u#32259:u32
        let s_1418_23: u32 = fn_state.u_32259;
        // D s_1418_24: cast zx s_1418_23 -> bv
        let s_1418_24: Bits = Bits::new(s_1418_23 as u128, 32u16);
        // D s_1418_25: bit-extract s_1418_24 s_1418_21 s_1418_22
        let s_1418_25: Bits = (Bits::new(
            ((s_1418_24) >> (s_1418_21)).value(),
            u16::try_from(s_1418_22).unwrap(),
        ));
        // D s_1418_26: cast reint s_1418_25 -> u8
        let s_1418_26: bool = ((s_1418_25.value()) != 0);
        // C s_1418_27: const #6s : i
        let s_1418_27: i128 = 6;
        // C s_1418_28: const #1s : i
        let s_1418_28: i128 = 1;
        // D s_1418_29: read-var u#32259:u32
        let s_1418_29: u32 = fn_state.u_32259;
        // D s_1418_30: cast zx s_1418_29 -> bv
        let s_1418_30: Bits = Bits::new(s_1418_29 as u128, 32u16);
        // D s_1418_31: bit-extract s_1418_30 s_1418_27 s_1418_28
        let s_1418_31: Bits = (Bits::new(
            ((s_1418_30) >> (s_1418_27)).value(),
            u16::try_from(s_1418_28).unwrap(),
        ));
        // D s_1418_32: cast reint s_1418_31 -> u8
        let s_1418_32: bool = ((s_1418_31.value()) != 0);
        // C s_1418_33: const #5s : i
        let s_1418_33: i128 = 5;
        // C s_1418_34: const #1s : i
        let s_1418_34: i128 = 1;
        // D s_1418_35: read-var u#32259:u32
        let s_1418_35: u32 = fn_state.u_32259;
        // D s_1418_36: cast zx s_1418_35 -> bv
        let s_1418_36: Bits = Bits::new(s_1418_35 as u128, 32u16);
        // D s_1418_37: bit-extract s_1418_36 s_1418_33 s_1418_34
        let s_1418_37: Bits = (Bits::new(
            ((s_1418_36) >> (s_1418_33)).value(),
            u16::try_from(s_1418_34).unwrap(),
        ));
        // D s_1418_38: cast reint s_1418_37 -> u8
        let s_1418_38: bool = ((s_1418_37.value()) != 0);
        // C s_1418_39: const #0s : i
        let s_1418_39: i128 = 0;
        // C s_1418_40: const #4s : i
        let s_1418_40: i128 = 4;
        // D s_1418_41: read-var u#32259:u32
        let s_1418_41: u32 = fn_state.u_32259;
        // D s_1418_42: cast zx s_1418_41 -> bv
        let s_1418_42: Bits = Bits::new(s_1418_41 as u128, 32u16);
        // D s_1418_43: bit-extract s_1418_42 s_1418_39 s_1418_40
        let s_1418_43: Bits = (Bits::new(
            ((s_1418_42) >> (s_1418_39)).value(),
            u16::try_from(s_1418_40).unwrap(),
        ));
        // D s_1418_44: cast reint s_1418_43 -> u8
        let s_1418_44: u8 = (s_1418_43.value() as u8);
        // D s_1418_45: call decode_aarch32_instrs_SHA256SU1_A1enc_A_txt(s_1418_8, s_1418_14, s_1418_20, s_1418_26, s_1418_32, s_1418_38, s_1418_44)
        let s_1418_45: () = decode_aarch32_instrs_SHA256SU1_A1enc_A_txt(
            state,
            tracer,
            s_1418_8,
            s_1418_14,
            s_1418_20,
            s_1418_26,
            s_1418_32,
            s_1418_38,
            s_1418_44,
        );
        // N s_1418_46: return
        return;
    }
    fn block_1419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1419_0: read-var merge#var.1:struct
        let s_1419_0: u32 = fn_state.merge_var._1;
        // D s_1419_1: write-var u#32268 <= s_1419_0
        fn_state.u_32268 = s_1419_0;
        // C s_1419_2: const #23s : i
        let s_1419_2: i128 = 23;
        // D s_1419_3: read-var u#32268:u32
        let s_1419_3: u32 = fn_state.u_32268;
        // D s_1419_4: cast zx s_1419_3 -> bv
        let s_1419_4: Bits = Bits::new(s_1419_3 as u128, 32u16);
        // C s_1419_5: const #1s : i64
        let s_1419_5: i64 = 1;
        // C s_1419_6: cast zx s_1419_5 -> i
        let s_1419_6: i128 = (i128::try_from(s_1419_5).unwrap());
        // C s_1419_7: const #8s : i
        let s_1419_7: i128 = 8;
        // C s_1419_8: add s_1419_7 s_1419_6
        let s_1419_8: i128 = (s_1419_7 + s_1419_6);
        // D s_1419_9: bit-extract s_1419_4 s_1419_2 s_1419_8
        let s_1419_9: Bits = (Bits::new(
            ((s_1419_4) >> (s_1419_2)).value(),
            u16::try_from(s_1419_8).unwrap(),
        ));
        // D s_1419_10: cast reint s_1419_9 -> u9
        let s_1419_10: u16 = (s_1419_9.value() as u16);
        // D s_1419_11: cast zx s_1419_10 -> bv
        let s_1419_11: Bits = Bits::new(s_1419_10 as u128, 9u16);
        // C s_1419_12: const #487u : u9
        let s_1419_12: u16 = 487;
        // C s_1419_13: cast zx s_1419_12 -> bv
        let s_1419_13: Bits = Bits::new(s_1419_12 as u128, 9u16);
        // D s_1419_14: cmp-eq s_1419_11 s_1419_13
        let s_1419_14: bool = ((s_1419_11) == (s_1419_13));
        // N s_1419_15: branch s_1419_14 b1635 b1420
        if s_1419_14 {
            return block_1635(state, tracer, fn_state);
        } else {
            return block_1420(state, tracer, fn_state);
        };
    }
    fn block_1420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1420_0: const #0u : u8
        let s_1420_0: bool = false;
        // D s_1420_1: write-var gs#403555 <= s_1420_0
        fn_state.gs_403555 = s_1420_0;
        // N s_1420_2: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_1421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1421_0: read-var gs#403555:u8
        let s_1421_0: bool = fn_state.gs_403555;
        // N s_1421_1: branch s_1421_0 b1634 b1422
        if s_1421_0 {
            return block_1634(state, tracer, fn_state);
        } else {
            return block_1422(state, tracer, fn_state);
        };
    }
    fn block_1422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1422_0: const #0u : u8
        let s_1422_0: bool = false;
        // D s_1422_1: write-var gs#403557 <= s_1422_0
        fn_state.gs_403557 = s_1422_0;
        // N s_1422_2: jump b1423
        return block_1423(state, tracer, fn_state);
    }
    fn block_1423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1423_0: read-var gs#403557:u8
        let s_1423_0: bool = fn_state.gs_403557;
        // D s_1423_1: not s_1423_0
        let s_1423_1: bool = !s_1423_0;
        // N s_1423_2: branch s_1423_1 b1425 b1424
        if s_1423_1 {
            return block_1425(state, tracer, fn_state);
        } else {
            return block_1424(state, tracer, fn_state);
        };
    }
    fn block_1424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1424_0: const #3866s : i
        let s_1424_0: i128 = 3866;
        // C s_1424_1: const #14696u : u32
        let s_1424_1: u32 = 14696;
        // N s_1424_2: write-reg s_1424_1 <= s_1424_0
        let s_1424_2: () = {
            state.write_register::<i128>(s_1424_1 as isize, s_1424_0);
            tracer.write_register(s_1424_1 as isize, s_1424_0);
        };
        // C s_1424_3: const #22s : i
        let s_1424_3: i128 = 22;
        // C s_1424_4: const #1s : i
        let s_1424_4: i128 = 1;
        // D s_1424_5: read-var u#32268:u32
        let s_1424_5: u32 = fn_state.u_32268;
        // D s_1424_6: cast zx s_1424_5 -> bv
        let s_1424_6: Bits = Bits::new(s_1424_5 as u128, 32u16);
        // D s_1424_7: bit-extract s_1424_6 s_1424_3 s_1424_4
        let s_1424_7: Bits = (Bits::new(
            ((s_1424_6) >> (s_1424_3)).value(),
            u16::try_from(s_1424_4).unwrap(),
        ));
        // D s_1424_8: cast reint s_1424_7 -> u8
        let s_1424_8: bool = ((s_1424_7.value()) != 0);
        // C s_1424_9: const #18s : i
        let s_1424_9: i128 = 18;
        // C s_1424_10: const #2s : i
        let s_1424_10: i128 = 2;
        // D s_1424_11: read-var u#32268:u32
        let s_1424_11: u32 = fn_state.u_32268;
        // D s_1424_12: cast zx s_1424_11 -> bv
        let s_1424_12: Bits = Bits::new(s_1424_11 as u128, 32u16);
        // D s_1424_13: bit-extract s_1424_12 s_1424_9 s_1424_10
        let s_1424_13: Bits = (Bits::new(
            ((s_1424_12) >> (s_1424_9)).value(),
            u16::try_from(s_1424_10).unwrap(),
        ));
        // D s_1424_14: cast reint s_1424_13 -> u8
        let s_1424_14: u8 = (s_1424_13.value() as u8);
        // C s_1424_15: const #12s : i
        let s_1424_15: i128 = 12;
        // C s_1424_16: const #4s : i
        let s_1424_16: i128 = 4;
        // D s_1424_17: read-var u#32268:u32
        let s_1424_17: u32 = fn_state.u_32268;
        // D s_1424_18: cast zx s_1424_17 -> bv
        let s_1424_18: Bits = Bits::new(s_1424_17 as u128, 32u16);
        // D s_1424_19: bit-extract s_1424_18 s_1424_15 s_1424_16
        let s_1424_19: Bits = (Bits::new(
            ((s_1424_18) >> (s_1424_15)).value(),
            u16::try_from(s_1424_16).unwrap(),
        ));
        // D s_1424_20: cast reint s_1424_19 -> u8
        let s_1424_20: u8 = (s_1424_19.value() as u8);
        // C s_1424_21: const #8s : i
        let s_1424_21: i128 = 8;
        // C s_1424_22: const #2s : i
        let s_1424_22: i128 = 2;
        // D s_1424_23: read-var u#32268:u32
        let s_1424_23: u32 = fn_state.u_32268;
        // D s_1424_24: cast zx s_1424_23 -> bv
        let s_1424_24: Bits = Bits::new(s_1424_23 as u128, 32u16);
        // D s_1424_25: bit-extract s_1424_24 s_1424_21 s_1424_22
        let s_1424_25: Bits = (Bits::new(
            ((s_1424_24) >> (s_1424_21)).value(),
            u16::try_from(s_1424_22).unwrap(),
        ));
        // D s_1424_26: cast reint s_1424_25 -> u8
        let s_1424_26: u8 = (s_1424_25.value() as u8);
        // C s_1424_27: const #7s : i
        let s_1424_27: i128 = 7;
        // C s_1424_28: const #1s : i
        let s_1424_28: i128 = 1;
        // D s_1424_29: read-var u#32268:u32
        let s_1424_29: u32 = fn_state.u_32268;
        // D s_1424_30: cast zx s_1424_29 -> bv
        let s_1424_30: Bits = Bits::new(s_1424_29 as u128, 32u16);
        // D s_1424_31: bit-extract s_1424_30 s_1424_27 s_1424_28
        let s_1424_31: Bits = (Bits::new(
            ((s_1424_30) >> (s_1424_27)).value(),
            u16::try_from(s_1424_28).unwrap(),
        ));
        // D s_1424_32: cast reint s_1424_31 -> u8
        let s_1424_32: bool = ((s_1424_31.value()) != 0);
        // C s_1424_33: const #6s : i
        let s_1424_33: i128 = 6;
        // C s_1424_34: const #1s : i
        let s_1424_34: i128 = 1;
        // D s_1424_35: read-var u#32268:u32
        let s_1424_35: u32 = fn_state.u_32268;
        // D s_1424_36: cast zx s_1424_35 -> bv
        let s_1424_36: Bits = Bits::new(s_1424_35 as u128, 32u16);
        // D s_1424_37: bit-extract s_1424_36 s_1424_33 s_1424_34
        let s_1424_37: Bits = (Bits::new(
            ((s_1424_36) >> (s_1424_33)).value(),
            u16::try_from(s_1424_34).unwrap(),
        ));
        // D s_1424_38: cast reint s_1424_37 -> u8
        let s_1424_38: bool = ((s_1424_37.value()) != 0);
        // C s_1424_39: const #5s : i
        let s_1424_39: i128 = 5;
        // C s_1424_40: const #1s : i
        let s_1424_40: i128 = 1;
        // D s_1424_41: read-var u#32268:u32
        let s_1424_41: u32 = fn_state.u_32268;
        // D s_1424_42: cast zx s_1424_41 -> bv
        let s_1424_42: Bits = Bits::new(s_1424_41 as u128, 32u16);
        // D s_1424_43: bit-extract s_1424_42 s_1424_39 s_1424_40
        let s_1424_43: Bits = (Bits::new(
            ((s_1424_42) >> (s_1424_39)).value(),
            u16::try_from(s_1424_40).unwrap(),
        ));
        // D s_1424_44: cast reint s_1424_43 -> u8
        let s_1424_44: bool = ((s_1424_43.value()) != 0);
        // C s_1424_45: const #0s : i
        let s_1424_45: i128 = 0;
        // C s_1424_46: const #4s : i
        let s_1424_46: i128 = 4;
        // D s_1424_47: read-var u#32268:u32
        let s_1424_47: u32 = fn_state.u_32268;
        // D s_1424_48: cast zx s_1424_47 -> bv
        let s_1424_48: Bits = Bits::new(s_1424_47 as u128, 32u16);
        // D s_1424_49: bit-extract s_1424_48 s_1424_45 s_1424_46
        let s_1424_49: Bits = (Bits::new(
            ((s_1424_48) >> (s_1424_45)).value(),
            u16::try_from(s_1424_46).unwrap(),
        ));
        // D s_1424_50: cast reint s_1424_49 -> u8
        let s_1424_50: u8 = (s_1424_49.value() as u8);
        // D s_1424_51: call decode_aarch32_instrs_VCVTA_asimd_A1enc_A_txt(s_1424_8, s_1424_14, s_1424_20, s_1424_26, s_1424_32, s_1424_38, s_1424_44, s_1424_50)
        let s_1424_51: () = decode_aarch32_instrs_VCVTA_asimd_A1enc_A_txt(
            state,
            tracer,
            s_1424_8,
            s_1424_14,
            s_1424_20,
            s_1424_26,
            s_1424_32,
            s_1424_38,
            s_1424_44,
            s_1424_50,
        );
        // N s_1424_52: return
        return;
    }
    fn block_1425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1425_0: read-var merge#var.1:struct
        let s_1425_0: u32 = fn_state.merge_var._1;
        // D s_1425_1: write-var u#32277 <= s_1425_0
        fn_state.u_32277 = s_1425_0;
        // C s_1425_2: const #23s : i
        let s_1425_2: i128 = 23;
        // D s_1425_3: read-var u#32277:u32
        let s_1425_3: u32 = fn_state.u_32277;
        // D s_1425_4: cast zx s_1425_3 -> bv
        let s_1425_4: Bits = Bits::new(s_1425_3 as u128, 32u16);
        // C s_1425_5: const #1s : i64
        let s_1425_5: i64 = 1;
        // C s_1425_6: cast zx s_1425_5 -> i
        let s_1425_6: i128 = (i128::try_from(s_1425_5).unwrap());
        // C s_1425_7: const #8s : i
        let s_1425_7: i128 = 8;
        // C s_1425_8: add s_1425_7 s_1425_6
        let s_1425_8: i128 = (s_1425_7 + s_1425_6);
        // D s_1425_9: bit-extract s_1425_4 s_1425_2 s_1425_8
        let s_1425_9: Bits = (Bits::new(
            ((s_1425_4) >> (s_1425_2)).value(),
            u16::try_from(s_1425_8).unwrap(),
        ));
        // D s_1425_10: cast reint s_1425_9 -> u9
        let s_1425_10: u16 = (s_1425_9.value() as u16);
        // D s_1425_11: cast zx s_1425_10 -> bv
        let s_1425_11: Bits = Bits::new(s_1425_10 as u128, 9u16);
        // C s_1425_12: const #486u : u9
        let s_1425_12: u16 = 486;
        // C s_1425_13: cast zx s_1425_12 -> bv
        let s_1425_13: Bits = Bits::new(s_1425_12 as u128, 9u16);
        // D s_1425_14: cmp-eq s_1425_11 s_1425_13
        let s_1425_14: bool = ((s_1425_11) == (s_1425_13));
        // N s_1425_15: branch s_1425_14 b1630 b1426
        if s_1425_14 {
            return block_1630(state, tracer, fn_state);
        } else {
            return block_1426(state, tracer, fn_state);
        };
    }
    fn block_1426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1426_0: const #0u : u8
        let s_1426_0: bool = false;
        // D s_1426_1: write-var gs#403584 <= s_1426_0
        fn_state.gs_403584 = s_1426_0;
        // N s_1426_2: jump b1427
        return block_1427(state, tracer, fn_state);
    }
    fn block_1427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1427_0: read-var gs#403584:u8
        let s_1427_0: bool = fn_state.gs_403584;
        // N s_1427_1: branch s_1427_0 b1629 b1428
        if s_1427_0 {
            return block_1629(state, tracer, fn_state);
        } else {
            return block_1428(state, tracer, fn_state);
        };
    }
    fn block_1428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1428_0: const #0u : u8
        let s_1428_0: bool = false;
        // D s_1428_1: write-var gs#403586 <= s_1428_0
        fn_state.gs_403586 = s_1428_0;
        // N s_1428_2: jump b1429
        return block_1429(state, tracer, fn_state);
    }
    fn block_1429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1429_0: read-var gs#403586:u8
        let s_1429_0: bool = fn_state.gs_403586;
        // D s_1429_1: not s_1429_0
        let s_1429_1: bool = !s_1429_0;
        // N s_1429_2: branch s_1429_1 b1431 b1430
        if s_1429_1 {
            return block_1431(state, tracer, fn_state);
        } else {
            return block_1430(state, tracer, fn_state);
        };
    }
    fn block_1430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1430_0: const #3870s : i
        let s_1430_0: i128 = 3870;
        // C s_1430_1: const #14696u : u32
        let s_1430_1: u32 = 14696;
        // N s_1430_2: write-reg s_1430_1 <= s_1430_0
        let s_1430_2: () = {
            state.write_register::<i128>(s_1430_1 as isize, s_1430_0);
            tracer.write_register(s_1430_1 as isize, s_1430_0);
        };
        // C s_1430_3: const #22s : i
        let s_1430_3: i128 = 22;
        // C s_1430_4: const #1s : i
        let s_1430_4: i128 = 1;
        // D s_1430_5: read-var u#32277:u32
        let s_1430_5: u32 = fn_state.u_32277;
        // D s_1430_6: cast zx s_1430_5 -> bv
        let s_1430_6: Bits = Bits::new(s_1430_5 as u128, 32u16);
        // D s_1430_7: bit-extract s_1430_6 s_1430_3 s_1430_4
        let s_1430_7: Bits = (Bits::new(
            ((s_1430_6) >> (s_1430_3)).value(),
            u16::try_from(s_1430_4).unwrap(),
        ));
        // D s_1430_8: cast reint s_1430_7 -> u8
        let s_1430_8: bool = ((s_1430_7.value()) != 0);
        // C s_1430_9: const #21s : i
        let s_1430_9: i128 = 21;
        // C s_1430_10: const #1s : i
        let s_1430_10: i128 = 1;
        // D s_1430_11: read-var u#32277:u32
        let s_1430_11: u32 = fn_state.u_32277;
        // D s_1430_12: cast zx s_1430_11 -> bv
        let s_1430_12: Bits = Bits::new(s_1430_11 as u128, 32u16);
        // D s_1430_13: bit-extract s_1430_12 s_1430_9 s_1430_10
        let s_1430_13: Bits = (Bits::new(
            ((s_1430_12) >> (s_1430_9)).value(),
            u16::try_from(s_1430_10).unwrap(),
        ));
        // D s_1430_14: cast reint s_1430_13 -> u8
        let s_1430_14: bool = ((s_1430_13.value()) != 0);
        // C s_1430_15: const #20s : i
        let s_1430_15: i128 = 20;
        // C s_1430_16: const #1s : i
        let s_1430_16: i128 = 1;
        // D s_1430_17: read-var u#32277:u32
        let s_1430_17: u32 = fn_state.u_32277;
        // D s_1430_18: cast zx s_1430_17 -> bv
        let s_1430_18: Bits = Bits::new(s_1430_17 as u128, 32u16);
        // D s_1430_19: bit-extract s_1430_18 s_1430_15 s_1430_16
        let s_1430_19: Bits = (Bits::new(
            ((s_1430_18) >> (s_1430_15)).value(),
            u16::try_from(s_1430_16).unwrap(),
        ));
        // D s_1430_20: cast reint s_1430_19 -> u8
        let s_1430_20: bool = ((s_1430_19.value()) != 0);
        // C s_1430_21: const #16s : i
        let s_1430_21: i128 = 16;
        // C s_1430_22: const #4s : i
        let s_1430_22: i128 = 4;
        // D s_1430_23: read-var u#32277:u32
        let s_1430_23: u32 = fn_state.u_32277;
        // D s_1430_24: cast zx s_1430_23 -> bv
        let s_1430_24: Bits = Bits::new(s_1430_23 as u128, 32u16);
        // D s_1430_25: bit-extract s_1430_24 s_1430_21 s_1430_22
        let s_1430_25: Bits = (Bits::new(
            ((s_1430_24) >> (s_1430_21)).value(),
            u16::try_from(s_1430_22).unwrap(),
        ));
        // D s_1430_26: cast reint s_1430_25 -> u8
        let s_1430_26: u8 = (s_1430_25.value() as u8);
        // C s_1430_27: const #12s : i
        let s_1430_27: i128 = 12;
        // C s_1430_28: const #4s : i
        let s_1430_28: i128 = 4;
        // D s_1430_29: read-var u#32277:u32
        let s_1430_29: u32 = fn_state.u_32277;
        // D s_1430_30: cast zx s_1430_29 -> bv
        let s_1430_30: Bits = Bits::new(s_1430_29 as u128, 32u16);
        // D s_1430_31: bit-extract s_1430_30 s_1430_27 s_1430_28
        let s_1430_31: Bits = (Bits::new(
            ((s_1430_30) >> (s_1430_27)).value(),
            u16::try_from(s_1430_28).unwrap(),
        ));
        // D s_1430_32: cast reint s_1430_31 -> u8
        let s_1430_32: u8 = (s_1430_31.value() as u8);
        // C s_1430_33: const #7s : i
        let s_1430_33: i128 = 7;
        // C s_1430_34: const #1s : i
        let s_1430_34: i128 = 1;
        // D s_1430_35: read-var u#32277:u32
        let s_1430_35: u32 = fn_state.u_32277;
        // D s_1430_36: cast zx s_1430_35 -> bv
        let s_1430_36: Bits = Bits::new(s_1430_35 as u128, 32u16);
        // D s_1430_37: bit-extract s_1430_36 s_1430_33 s_1430_34
        let s_1430_37: Bits = (Bits::new(
            ((s_1430_36) >> (s_1430_33)).value(),
            u16::try_from(s_1430_34).unwrap(),
        ));
        // D s_1430_38: cast reint s_1430_37 -> u8
        let s_1430_38: bool = ((s_1430_37.value()) != 0);
        // C s_1430_39: const #6s : i
        let s_1430_39: i128 = 6;
        // C s_1430_40: const #1s : i
        let s_1430_40: i128 = 1;
        // D s_1430_41: read-var u#32277:u32
        let s_1430_41: u32 = fn_state.u_32277;
        // D s_1430_42: cast zx s_1430_41 -> bv
        let s_1430_42: Bits = Bits::new(s_1430_41 as u128, 32u16);
        // D s_1430_43: bit-extract s_1430_42 s_1430_39 s_1430_40
        let s_1430_43: Bits = (Bits::new(
            ((s_1430_42) >> (s_1430_39)).value(),
            u16::try_from(s_1430_40).unwrap(),
        ));
        // D s_1430_44: cast reint s_1430_43 -> u8
        let s_1430_44: bool = ((s_1430_43.value()) != 0);
        // C s_1430_45: const #5s : i
        let s_1430_45: i128 = 5;
        // C s_1430_46: const #1s : i
        let s_1430_46: i128 = 1;
        // D s_1430_47: read-var u#32277:u32
        let s_1430_47: u32 = fn_state.u_32277;
        // D s_1430_48: cast zx s_1430_47 -> bv
        let s_1430_48: Bits = Bits::new(s_1430_47 as u128, 32u16);
        // D s_1430_49: bit-extract s_1430_48 s_1430_45 s_1430_46
        let s_1430_49: Bits = (Bits::new(
            ((s_1430_48) >> (s_1430_45)).value(),
            u16::try_from(s_1430_46).unwrap(),
        ));
        // D s_1430_50: cast reint s_1430_49 -> u8
        let s_1430_50: bool = ((s_1430_49.value()) != 0);
        // C s_1430_51: const #0s : i
        let s_1430_51: i128 = 0;
        // C s_1430_52: const #4s : i
        let s_1430_52: i128 = 4;
        // D s_1430_53: read-var u#32277:u32
        let s_1430_53: u32 = fn_state.u_32277;
        // D s_1430_54: cast zx s_1430_53 -> bv
        let s_1430_54: Bits = Bits::new(s_1430_53 as u128, 32u16);
        // D s_1430_55: bit-extract s_1430_54 s_1430_51 s_1430_52
        let s_1430_55: Bits = (Bits::new(
            ((s_1430_54) >> (s_1430_51)).value(),
            u16::try_from(s_1430_52).unwrap(),
        ));
        // D s_1430_56: cast reint s_1430_55 -> u8
        let s_1430_56: u8 = (s_1430_55.value() as u8);
        // D s_1430_57: call decode_aarch32_instrs_VMAXNM_A1enc_A_txt(s_1430_8, s_1430_14, s_1430_20, s_1430_26, s_1430_32, s_1430_38, s_1430_44, s_1430_50, s_1430_56)
        let s_1430_57: () = decode_aarch32_instrs_VMAXNM_A1enc_A_txt(
            state,
            tracer,
            s_1430_8,
            s_1430_14,
            s_1430_20,
            s_1430_26,
            s_1430_32,
            s_1430_38,
            s_1430_44,
            s_1430_50,
            s_1430_56,
        );
        // N s_1430_58: return
        return;
    }
    fn block_1431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1431_0: read-var merge#var.1:struct
        let s_1431_0: u32 = fn_state.merge_var._1;
        // D s_1431_1: write-var u#32288 <= s_1431_0
        fn_state.u_32288 = s_1431_0;
        // C s_1431_2: const #23s : i
        let s_1431_2: i128 = 23;
        // D s_1431_3: read-var u#32288:u32
        let s_1431_3: u32 = fn_state.u_32288;
        // D s_1431_4: cast zx s_1431_3 -> bv
        let s_1431_4: Bits = Bits::new(s_1431_3 as u128, 32u16);
        // C s_1431_5: const #1s : i64
        let s_1431_5: i64 = 1;
        // C s_1431_6: cast zx s_1431_5 -> i
        let s_1431_6: i128 = (i128::try_from(s_1431_5).unwrap());
        // C s_1431_7: const #8s : i
        let s_1431_7: i128 = 8;
        // C s_1431_8: add s_1431_7 s_1431_6
        let s_1431_8: i128 = (s_1431_7 + s_1431_6);
        // D s_1431_9: bit-extract s_1431_4 s_1431_2 s_1431_8
        let s_1431_9: Bits = (Bits::new(
            ((s_1431_4) >> (s_1431_2)).value(),
            u16::try_from(s_1431_8).unwrap(),
        ));
        // D s_1431_10: cast reint s_1431_9 -> u9
        let s_1431_10: u16 = (s_1431_9.value() as u16);
        // D s_1431_11: cast zx s_1431_10 -> bv
        let s_1431_11: Bits = Bits::new(s_1431_10 as u128, 9u16);
        // C s_1431_12: const #487u : u9
        let s_1431_12: u16 = 487;
        // C s_1431_13: cast zx s_1431_12 -> bv
        let s_1431_13: Bits = Bits::new(s_1431_12 as u128, 9u16);
        // D s_1431_14: cmp-eq s_1431_11 s_1431_13
        let s_1431_14: bool = ((s_1431_11) == (s_1431_13));
        // N s_1431_15: branch s_1431_14 b1619 b1432
        if s_1431_14 {
            return block_1619(state, tracer, fn_state);
        } else {
            return block_1432(state, tracer, fn_state);
        };
    }
    fn block_1432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1432_0: const #0u : u8
        let s_1432_0: bool = false;
        // D s_1432_1: write-var gs#403621 <= s_1432_0
        fn_state.gs_403621 = s_1432_0;
        // N s_1432_2: jump b1433
        return block_1433(state, tracer, fn_state);
    }
    fn block_1433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1433_0: read-var gs#403621:u8
        let s_1433_0: bool = fn_state.gs_403621;
        // N s_1433_1: branch s_1433_0 b1618 b1434
        if s_1433_0 {
            return block_1618(state, tracer, fn_state);
        } else {
            return block_1434(state, tracer, fn_state);
        };
    }
    fn block_1434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1434_0: const #0u : u8
        let s_1434_0: bool = false;
        // D s_1434_1: write-var gs#403623 <= s_1434_0
        fn_state.gs_403623 = s_1434_0;
        // N s_1434_2: jump b1435
        return block_1435(state, tracer, fn_state);
    }
    fn block_1435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1435_0: read-var gs#403623:u8
        let s_1435_0: bool = fn_state.gs_403623;
        // D s_1435_1: not s_1435_0
        let s_1435_1: bool = !s_1435_0;
        // N s_1435_2: branch s_1435_1 b1437 b1436
        if s_1435_1 {
            return block_1437(state, tracer, fn_state);
        } else {
            return block_1436(state, tracer, fn_state);
        };
    }
    fn block_1436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1436_0: const #3874s : i
        let s_1436_0: i128 = 3874;
        // C s_1436_1: const #14696u : u32
        let s_1436_1: u32 = 14696;
        // N s_1436_2: write-reg s_1436_1 <= s_1436_0
        let s_1436_2: () = {
            state.write_register::<i128>(s_1436_1 as isize, s_1436_0);
            tracer.write_register(s_1436_1 as isize, s_1436_0);
        };
        // C s_1436_3: const #22s : i
        let s_1436_3: i128 = 22;
        // C s_1436_4: const #1s : i
        let s_1436_4: i128 = 1;
        // D s_1436_5: read-var u#32288:u32
        let s_1436_5: u32 = fn_state.u_32288;
        // D s_1436_6: cast zx s_1436_5 -> bv
        let s_1436_6: Bits = Bits::new(s_1436_5 as u128, 32u16);
        // D s_1436_7: bit-extract s_1436_6 s_1436_3 s_1436_4
        let s_1436_7: Bits = (Bits::new(
            ((s_1436_6) >> (s_1436_3)).value(),
            u16::try_from(s_1436_4).unwrap(),
        ));
        // D s_1436_8: cast reint s_1436_7 -> u8
        let s_1436_8: bool = ((s_1436_7.value()) != 0);
        // C s_1436_9: const #18s : i
        let s_1436_9: i128 = 18;
        // C s_1436_10: const #2s : i
        let s_1436_10: i128 = 2;
        // D s_1436_11: read-var u#32288:u32
        let s_1436_11: u32 = fn_state.u_32288;
        // D s_1436_12: cast zx s_1436_11 -> bv
        let s_1436_12: Bits = Bits::new(s_1436_11 as u128, 32u16);
        // D s_1436_13: bit-extract s_1436_12 s_1436_9 s_1436_10
        let s_1436_13: Bits = (Bits::new(
            ((s_1436_12) >> (s_1436_9)).value(),
            u16::try_from(s_1436_10).unwrap(),
        ));
        // D s_1436_14: cast reint s_1436_13 -> u8
        let s_1436_14: u8 = (s_1436_13.value() as u8);
        // C s_1436_15: const #12s : i
        let s_1436_15: i128 = 12;
        // C s_1436_16: const #4s : i
        let s_1436_16: i128 = 4;
        // D s_1436_17: read-var u#32288:u32
        let s_1436_17: u32 = fn_state.u_32288;
        // D s_1436_18: cast zx s_1436_17 -> bv
        let s_1436_18: Bits = Bits::new(s_1436_17 as u128, 32u16);
        // D s_1436_19: bit-extract s_1436_18 s_1436_15 s_1436_16
        let s_1436_19: Bits = (Bits::new(
            ((s_1436_18) >> (s_1436_15)).value(),
            u16::try_from(s_1436_16).unwrap(),
        ));
        // D s_1436_20: cast reint s_1436_19 -> u8
        let s_1436_20: u8 = (s_1436_19.value() as u8);
        // C s_1436_21: const #7s : i
        let s_1436_21: i128 = 7;
        // C s_1436_22: const #3s : i
        let s_1436_22: i128 = 3;
        // D s_1436_23: read-var u#32288:u32
        let s_1436_23: u32 = fn_state.u_32288;
        // D s_1436_24: cast zx s_1436_23 -> bv
        let s_1436_24: Bits = Bits::new(s_1436_23 as u128, 32u16);
        // D s_1436_25: bit-extract s_1436_24 s_1436_21 s_1436_22
        let s_1436_25: Bits = (Bits::new(
            ((s_1436_24) >> (s_1436_21)).value(),
            u16::try_from(s_1436_22).unwrap(),
        ));
        // D s_1436_26: cast reint s_1436_25 -> u8
        let s_1436_26: u8 = (s_1436_25.value() as u8);
        // C s_1436_27: const #6s : i
        let s_1436_27: i128 = 6;
        // C s_1436_28: const #1s : i
        let s_1436_28: i128 = 1;
        // D s_1436_29: read-var u#32288:u32
        let s_1436_29: u32 = fn_state.u_32288;
        // D s_1436_30: cast zx s_1436_29 -> bv
        let s_1436_30: Bits = Bits::new(s_1436_29 as u128, 32u16);
        // D s_1436_31: bit-extract s_1436_30 s_1436_27 s_1436_28
        let s_1436_31: Bits = (Bits::new(
            ((s_1436_30) >> (s_1436_27)).value(),
            u16::try_from(s_1436_28).unwrap(),
        ));
        // D s_1436_32: cast reint s_1436_31 -> u8
        let s_1436_32: bool = ((s_1436_31.value()) != 0);
        // C s_1436_33: const #5s : i
        let s_1436_33: i128 = 5;
        // C s_1436_34: const #1s : i
        let s_1436_34: i128 = 1;
        // D s_1436_35: read-var u#32288:u32
        let s_1436_35: u32 = fn_state.u_32288;
        // D s_1436_36: cast zx s_1436_35 -> bv
        let s_1436_36: Bits = Bits::new(s_1436_35 as u128, 32u16);
        // D s_1436_37: bit-extract s_1436_36 s_1436_33 s_1436_34
        let s_1436_37: Bits = (Bits::new(
            ((s_1436_36) >> (s_1436_33)).value(),
            u16::try_from(s_1436_34).unwrap(),
        ));
        // D s_1436_38: cast reint s_1436_37 -> u8
        let s_1436_38: bool = ((s_1436_37.value()) != 0);
        // C s_1436_39: const #0s : i
        let s_1436_39: i128 = 0;
        // C s_1436_40: const #4s : i
        let s_1436_40: i128 = 4;
        // D s_1436_41: read-var u#32288:u32
        let s_1436_41: u32 = fn_state.u_32288;
        // D s_1436_42: cast zx s_1436_41 -> bv
        let s_1436_42: Bits = Bits::new(s_1436_41 as u128, 32u16);
        // D s_1436_43: bit-extract s_1436_42 s_1436_39 s_1436_40
        let s_1436_43: Bits = (Bits::new(
            ((s_1436_42) >> (s_1436_39)).value(),
            u16::try_from(s_1436_40).unwrap(),
        ));
        // D s_1436_44: cast reint s_1436_43 -> u8
        let s_1436_44: u8 = (s_1436_43.value() as u8);
        // D s_1436_45: call decode_aarch32_instrs_VRINTA_asimd_A1enc_A_txt(s_1436_8, s_1436_14, s_1436_20, s_1436_26, s_1436_32, s_1436_38, s_1436_44)
        let s_1436_45: () = decode_aarch32_instrs_VRINTA_asimd_A1enc_A_txt(
            state,
            tracer,
            s_1436_8,
            s_1436_14,
            s_1436_20,
            s_1436_26,
            s_1436_32,
            s_1436_38,
            s_1436_44,
        );
        // N s_1436_46: return
        return;
    }
    fn block_1437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1437_0: read-var merge#var.1:struct
        let s_1437_0: u32 = fn_state.merge_var._1;
        // D s_1437_1: write-var u#32297 <= s_1437_0
        fn_state.u_32297 = s_1437_0;
        // C s_1437_2: const #23s : i
        let s_1437_2: i128 = 23;
        // D s_1437_3: read-var u#32297:u32
        let s_1437_3: u32 = fn_state.u_32297;
        // D s_1437_4: cast zx s_1437_3 -> bv
        let s_1437_4: Bits = Bits::new(s_1437_3 as u128, 32u16);
        // C s_1437_5: const #1s : i64
        let s_1437_5: i64 = 1;
        // C s_1437_6: cast zx s_1437_5 -> i
        let s_1437_6: i128 = (i128::try_from(s_1437_5).unwrap());
        // C s_1437_7: const #8s : i
        let s_1437_7: i128 = 8;
        // C s_1437_8: add s_1437_7 s_1437_6
        let s_1437_8: i128 = (s_1437_7 + s_1437_6);
        // D s_1437_9: bit-extract s_1437_4 s_1437_2 s_1437_8
        let s_1437_9: Bits = (Bits::new(
            ((s_1437_4) >> (s_1437_2)).value(),
            u16::try_from(s_1437_8).unwrap(),
        ));
        // D s_1437_10: cast reint s_1437_9 -> u9
        let s_1437_10: u16 = (s_1437_9.value() as u16);
        // D s_1437_11: cast zx s_1437_10 -> bv
        let s_1437_11: Bits = Bits::new(s_1437_10 as u128, 9u16);
        // C s_1437_12: const #487u : u9
        let s_1437_12: u16 = 487;
        // C s_1437_13: cast zx s_1437_12 -> bv
        let s_1437_13: Bits = Bits::new(s_1437_12 as u128, 9u16);
        // D s_1437_14: cmp-eq s_1437_11 s_1437_13
        let s_1437_14: bool = ((s_1437_11) == (s_1437_13));
        // N s_1437_15: branch s_1437_14 b1608 b1438
        if s_1437_14 {
            return block_1608(state, tracer, fn_state);
        } else {
            return block_1438(state, tracer, fn_state);
        };
    }
    fn block_1438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1438_0: const #0u : u8
        let s_1438_0: bool = false;
        // D s_1438_1: write-var gs#403654 <= s_1438_0
        fn_state.gs_403654 = s_1438_0;
        // N s_1438_2: jump b1439
        return block_1439(state, tracer, fn_state);
    }
    fn block_1439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1439_0: read-var gs#403654:u8
        let s_1439_0: bool = fn_state.gs_403654;
        // N s_1439_1: branch s_1439_0 b1607 b1440
        if s_1439_0 {
            return block_1607(state, tracer, fn_state);
        } else {
            return block_1440(state, tracer, fn_state);
        };
    }
    fn block_1440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1440_0: const #0u : u8
        let s_1440_0: bool = false;
        // D s_1440_1: write-var gs#403656 <= s_1440_0
        fn_state.gs_403656 = s_1440_0;
        // N s_1440_2: jump b1441
        return block_1441(state, tracer, fn_state);
    }
    fn block_1441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1441_0: read-var gs#403656:u8
        let s_1441_0: bool = fn_state.gs_403656;
        // D s_1441_1: not s_1441_0
        let s_1441_1: bool = !s_1441_0;
        // N s_1441_2: branch s_1441_1 b1443 b1442
        if s_1441_1 {
            return block_1443(state, tracer, fn_state);
        } else {
            return block_1442(state, tracer, fn_state);
        };
    }
    fn block_1442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1442_0: const #3878s : i
        let s_1442_0: i128 = 3878;
        // C s_1442_1: const #14696u : u32
        let s_1442_1: u32 = 14696;
        // N s_1442_2: write-reg s_1442_1 <= s_1442_0
        let s_1442_2: () = {
            state.write_register::<i128>(s_1442_1 as isize, s_1442_0);
            tracer.write_register(s_1442_1 as isize, s_1442_0);
        };
        // C s_1442_3: const #22s : i
        let s_1442_3: i128 = 22;
        // C s_1442_4: const #1s : i
        let s_1442_4: i128 = 1;
        // D s_1442_5: read-var u#32297:u32
        let s_1442_5: u32 = fn_state.u_32297;
        // D s_1442_6: cast zx s_1442_5 -> bv
        let s_1442_6: Bits = Bits::new(s_1442_5 as u128, 32u16);
        // D s_1442_7: bit-extract s_1442_6 s_1442_3 s_1442_4
        let s_1442_7: Bits = (Bits::new(
            ((s_1442_6) >> (s_1442_3)).value(),
            u16::try_from(s_1442_4).unwrap(),
        ));
        // D s_1442_8: cast reint s_1442_7 -> u8
        let s_1442_8: bool = ((s_1442_7.value()) != 0);
        // C s_1442_9: const #18s : i
        let s_1442_9: i128 = 18;
        // C s_1442_10: const #2s : i
        let s_1442_10: i128 = 2;
        // D s_1442_11: read-var u#32297:u32
        let s_1442_11: u32 = fn_state.u_32297;
        // D s_1442_12: cast zx s_1442_11 -> bv
        let s_1442_12: Bits = Bits::new(s_1442_11 as u128, 32u16);
        // D s_1442_13: bit-extract s_1442_12 s_1442_9 s_1442_10
        let s_1442_13: Bits = (Bits::new(
            ((s_1442_12) >> (s_1442_9)).value(),
            u16::try_from(s_1442_10).unwrap(),
        ));
        // D s_1442_14: cast reint s_1442_13 -> u8
        let s_1442_14: u8 = (s_1442_13.value() as u8);
        // C s_1442_15: const #12s : i
        let s_1442_15: i128 = 12;
        // C s_1442_16: const #4s : i
        let s_1442_16: i128 = 4;
        // D s_1442_17: read-var u#32297:u32
        let s_1442_17: u32 = fn_state.u_32297;
        // D s_1442_18: cast zx s_1442_17 -> bv
        let s_1442_18: Bits = Bits::new(s_1442_17 as u128, 32u16);
        // D s_1442_19: bit-extract s_1442_18 s_1442_15 s_1442_16
        let s_1442_19: Bits = (Bits::new(
            ((s_1442_18) >> (s_1442_15)).value(),
            u16::try_from(s_1442_16).unwrap(),
        ));
        // D s_1442_20: cast reint s_1442_19 -> u8
        let s_1442_20: u8 = (s_1442_19.value() as u8);
        // C s_1442_21: const #6s : i
        let s_1442_21: i128 = 6;
        // C s_1442_22: const #1s : i
        let s_1442_22: i128 = 1;
        // D s_1442_23: read-var u#32297:u32
        let s_1442_23: u32 = fn_state.u_32297;
        // D s_1442_24: cast zx s_1442_23 -> bv
        let s_1442_24: Bits = Bits::new(s_1442_23 as u128, 32u16);
        // D s_1442_25: bit-extract s_1442_24 s_1442_21 s_1442_22
        let s_1442_25: Bits = (Bits::new(
            ((s_1442_24) >> (s_1442_21)).value(),
            u16::try_from(s_1442_22).unwrap(),
        ));
        // D s_1442_26: cast reint s_1442_25 -> u8
        let s_1442_26: bool = ((s_1442_25.value()) != 0);
        // C s_1442_27: const #5s : i
        let s_1442_27: i128 = 5;
        // C s_1442_28: const #1s : i
        let s_1442_28: i128 = 1;
        // D s_1442_29: read-var u#32297:u32
        let s_1442_29: u32 = fn_state.u_32297;
        // D s_1442_30: cast zx s_1442_29 -> bv
        let s_1442_30: Bits = Bits::new(s_1442_29 as u128, 32u16);
        // D s_1442_31: bit-extract s_1442_30 s_1442_27 s_1442_28
        let s_1442_31: Bits = (Bits::new(
            ((s_1442_30) >> (s_1442_27)).value(),
            u16::try_from(s_1442_28).unwrap(),
        ));
        // D s_1442_32: cast reint s_1442_31 -> u8
        let s_1442_32: bool = ((s_1442_31.value()) != 0);
        // C s_1442_33: const #0s : i
        let s_1442_33: i128 = 0;
        // C s_1442_34: const #4s : i
        let s_1442_34: i128 = 4;
        // D s_1442_35: read-var u#32297:u32
        let s_1442_35: u32 = fn_state.u_32297;
        // D s_1442_36: cast zx s_1442_35 -> bv
        let s_1442_36: Bits = Bits::new(s_1442_35 as u128, 32u16);
        // D s_1442_37: bit-extract s_1442_36 s_1442_33 s_1442_34
        let s_1442_37: Bits = (Bits::new(
            ((s_1442_36) >> (s_1442_33)).value(),
            u16::try_from(s_1442_34).unwrap(),
        ));
        // D s_1442_38: cast reint s_1442_37 -> u8
        let s_1442_38: u8 = (s_1442_37.value() as u8);
        // D s_1442_39: call decode_aarch32_instrs_VRINTX_asimd_A1enc_A_txt(s_1442_8, s_1442_14, s_1442_20, s_1442_26, s_1442_32, s_1442_38)
        let s_1442_39: () = decode_aarch32_instrs_VRINTX_asimd_A1enc_A_txt(
            state,
            tracer,
            s_1442_8,
            s_1442_14,
            s_1442_20,
            s_1442_26,
            s_1442_32,
            s_1442_38,
        );
        // N s_1442_40: return
        return;
    }
    fn block_1443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1443_0: read-var merge#var.1:struct
        let s_1443_0: u32 = fn_state.merge_var._1;
        // D s_1443_1: write-var u#32305 <= s_1443_0
        fn_state.u_32305 = s_1443_0;
        // C s_1443_2: const #23s : i
        let s_1443_2: i128 = 23;
        // D s_1443_3: read-var u#32305:u32
        let s_1443_3: u32 = fn_state.u_32305;
        // D s_1443_4: cast zx s_1443_3 -> bv
        let s_1443_4: Bits = Bits::new(s_1443_3 as u128, 32u16);
        // C s_1443_5: const #1s : i64
        let s_1443_5: i64 = 1;
        // C s_1443_6: cast zx s_1443_5 -> i
        let s_1443_6: i128 = (i128::try_from(s_1443_5).unwrap());
        // C s_1443_7: const #8s : i
        let s_1443_7: i128 = 8;
        // C s_1443_8: add s_1443_7 s_1443_6
        let s_1443_8: i128 = (s_1443_7 + s_1443_6);
        // D s_1443_9: bit-extract s_1443_4 s_1443_2 s_1443_8
        let s_1443_9: Bits = (Bits::new(
            ((s_1443_4) >> (s_1443_2)).value(),
            u16::try_from(s_1443_8).unwrap(),
        ));
        // D s_1443_10: cast reint s_1443_9 -> u9
        let s_1443_10: u16 = (s_1443_9.value() as u16);
        // D s_1443_11: cast zx s_1443_10 -> bv
        let s_1443_11: Bits = Bits::new(s_1443_10 as u128, 9u16);
        // C s_1443_12: const #487u : u9
        let s_1443_12: u16 = 487;
        // C s_1443_13: cast zx s_1443_12 -> bv
        let s_1443_13: Bits = Bits::new(s_1443_12 as u128, 9u16);
        // D s_1443_14: cmp-eq s_1443_11 s_1443_13
        let s_1443_14: bool = ((s_1443_11) == (s_1443_13));
        // N s_1443_15: branch s_1443_14 b1597 b1444
        if s_1443_14 {
            return block_1597(state, tracer, fn_state);
        } else {
            return block_1444(state, tracer, fn_state);
        };
    }
    fn block_1444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1444_0: const #0u : u8
        let s_1444_0: bool = false;
        // D s_1444_1: write-var gs#403685 <= s_1444_0
        fn_state.gs_403685 = s_1444_0;
        // N s_1444_2: jump b1445
        return block_1445(state, tracer, fn_state);
    }
    fn block_1445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1445_0: read-var gs#403685:u8
        let s_1445_0: bool = fn_state.gs_403685;
        // N s_1445_1: branch s_1445_0 b1596 b1446
        if s_1445_0 {
            return block_1596(state, tracer, fn_state);
        } else {
            return block_1446(state, tracer, fn_state);
        };
    }
    fn block_1446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1446_0: const #0u : u8
        let s_1446_0: bool = false;
        // D s_1446_1: write-var gs#403687 <= s_1446_0
        fn_state.gs_403687 = s_1446_0;
        // N s_1446_2: jump b1447
        return block_1447(state, tracer, fn_state);
    }
    fn block_1447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1447_0: read-var gs#403687:u8
        let s_1447_0: bool = fn_state.gs_403687;
        // D s_1447_1: not s_1447_0
        let s_1447_1: bool = !s_1447_0;
        // N s_1447_2: branch s_1447_1 b1449 b1448
        if s_1447_1 {
            return block_1449(state, tracer, fn_state);
        } else {
            return block_1448(state, tracer, fn_state);
        };
    }
    fn block_1448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1448_0: const #3882s : i
        let s_1448_0: i128 = 3882;
        // C s_1448_1: const #14696u : u32
        let s_1448_1: u32 = 14696;
        // N s_1448_2: write-reg s_1448_1 <= s_1448_0
        let s_1448_2: () = {
            state.write_register::<i128>(s_1448_1 as isize, s_1448_0);
            tracer.write_register(s_1448_1 as isize, s_1448_0);
        };
        // C s_1448_3: const #22s : i
        let s_1448_3: i128 = 22;
        // C s_1448_4: const #1s : i
        let s_1448_4: i128 = 1;
        // D s_1448_5: read-var u#32305:u32
        let s_1448_5: u32 = fn_state.u_32305;
        // D s_1448_6: cast zx s_1448_5 -> bv
        let s_1448_6: Bits = Bits::new(s_1448_5 as u128, 32u16);
        // D s_1448_7: bit-extract s_1448_6 s_1448_3 s_1448_4
        let s_1448_7: Bits = (Bits::new(
            ((s_1448_6) >> (s_1448_3)).value(),
            u16::try_from(s_1448_4).unwrap(),
        ));
        // D s_1448_8: cast reint s_1448_7 -> u8
        let s_1448_8: bool = ((s_1448_7.value()) != 0);
        // C s_1448_9: const #18s : i
        let s_1448_9: i128 = 18;
        // C s_1448_10: const #2s : i
        let s_1448_10: i128 = 2;
        // D s_1448_11: read-var u#32305:u32
        let s_1448_11: u32 = fn_state.u_32305;
        // D s_1448_12: cast zx s_1448_11 -> bv
        let s_1448_12: Bits = Bits::new(s_1448_11 as u128, 32u16);
        // D s_1448_13: bit-extract s_1448_12 s_1448_9 s_1448_10
        let s_1448_13: Bits = (Bits::new(
            ((s_1448_12) >> (s_1448_9)).value(),
            u16::try_from(s_1448_10).unwrap(),
        ));
        // D s_1448_14: cast reint s_1448_13 -> u8
        let s_1448_14: u8 = (s_1448_13.value() as u8);
        // C s_1448_15: const #12s : i
        let s_1448_15: i128 = 12;
        // C s_1448_16: const #4s : i
        let s_1448_16: i128 = 4;
        // D s_1448_17: read-var u#32305:u32
        let s_1448_17: u32 = fn_state.u_32305;
        // D s_1448_18: cast zx s_1448_17 -> bv
        let s_1448_18: Bits = Bits::new(s_1448_17 as u128, 32u16);
        // D s_1448_19: bit-extract s_1448_18 s_1448_15 s_1448_16
        let s_1448_19: Bits = (Bits::new(
            ((s_1448_18) >> (s_1448_15)).value(),
            u16::try_from(s_1448_16).unwrap(),
        ));
        // D s_1448_20: cast reint s_1448_19 -> u8
        let s_1448_20: u8 = (s_1448_19.value() as u8);
        // C s_1448_21: const #6s : i
        let s_1448_21: i128 = 6;
        // C s_1448_22: const #1s : i
        let s_1448_22: i128 = 1;
        // D s_1448_23: read-var u#32305:u32
        let s_1448_23: u32 = fn_state.u_32305;
        // D s_1448_24: cast zx s_1448_23 -> bv
        let s_1448_24: Bits = Bits::new(s_1448_23 as u128, 32u16);
        // D s_1448_25: bit-extract s_1448_24 s_1448_21 s_1448_22
        let s_1448_25: Bits = (Bits::new(
            ((s_1448_24) >> (s_1448_21)).value(),
            u16::try_from(s_1448_22).unwrap(),
        ));
        // D s_1448_26: cast reint s_1448_25 -> u8
        let s_1448_26: bool = ((s_1448_25.value()) != 0);
        // C s_1448_27: const #5s : i
        let s_1448_27: i128 = 5;
        // C s_1448_28: const #1s : i
        let s_1448_28: i128 = 1;
        // D s_1448_29: read-var u#32305:u32
        let s_1448_29: u32 = fn_state.u_32305;
        // D s_1448_30: cast zx s_1448_29 -> bv
        let s_1448_30: Bits = Bits::new(s_1448_29 as u128, 32u16);
        // D s_1448_31: bit-extract s_1448_30 s_1448_27 s_1448_28
        let s_1448_31: Bits = (Bits::new(
            ((s_1448_30) >> (s_1448_27)).value(),
            u16::try_from(s_1448_28).unwrap(),
        ));
        // D s_1448_32: cast reint s_1448_31 -> u8
        let s_1448_32: bool = ((s_1448_31.value()) != 0);
        // C s_1448_33: const #0s : i
        let s_1448_33: i128 = 0;
        // C s_1448_34: const #4s : i
        let s_1448_34: i128 = 4;
        // D s_1448_35: read-var u#32305:u32
        let s_1448_35: u32 = fn_state.u_32305;
        // D s_1448_36: cast zx s_1448_35 -> bv
        let s_1448_36: Bits = Bits::new(s_1448_35 as u128, 32u16);
        // D s_1448_37: bit-extract s_1448_36 s_1448_33 s_1448_34
        let s_1448_37: Bits = (Bits::new(
            ((s_1448_36) >> (s_1448_33)).value(),
            u16::try_from(s_1448_34).unwrap(),
        ));
        // D s_1448_38: cast reint s_1448_37 -> u8
        let s_1448_38: u8 = (s_1448_37.value() as u8);
        // D s_1448_39: call decode_aarch32_instrs_VRINTZ_asimd_A1enc_A_txt(s_1448_8, s_1448_14, s_1448_20, s_1448_26, s_1448_32, s_1448_38)
        let s_1448_39: () = decode_aarch32_instrs_VRINTZ_asimd_A1enc_A_txt(
            state,
            tracer,
            s_1448_8,
            s_1448_14,
            s_1448_20,
            s_1448_26,
            s_1448_32,
            s_1448_38,
        );
        // N s_1448_40: return
        return;
    }
    fn block_1449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1449_0: read-var merge#var.1:struct
        let s_1449_0: u32 = fn_state.merge_var._1;
        // D s_1449_1: write-var u#32313 <= s_1449_0
        fn_state.u_32313 = s_1449_0;
        // C s_1449_2: const #10s : i
        let s_1449_2: i128 = 10;
        // D s_1449_3: read-var u#32313:u32
        let s_1449_3: u32 = fn_state.u_32313;
        // D s_1449_4: cast zx s_1449_3 -> bv
        let s_1449_4: Bits = Bits::new(s_1449_3 as u128, 32u16);
        // C s_1449_5: const #1s : i64
        let s_1449_5: i64 = 1;
        // C s_1449_6: cast zx s_1449_5 -> i
        let s_1449_6: i128 = (i128::try_from(s_1449_5).unwrap());
        // C s_1449_7: const #21s : i
        let s_1449_7: i128 = 21;
        // C s_1449_8: add s_1449_7 s_1449_6
        let s_1449_8: i128 = (s_1449_7 + s_1449_6);
        // D s_1449_9: bit-extract s_1449_4 s_1449_2 s_1449_8
        let s_1449_9: Bits = (Bits::new(
            ((s_1449_4) >> (s_1449_2)).value(),
            u16::try_from(s_1449_8).unwrap(),
        ));
        // D s_1449_10: cast reint s_1449_9 -> u22
        let s_1449_10: u32 = (s_1449_9.value() as u32);
        // D s_1449_11: cast zx s_1449_10 -> bv
        let s_1449_11: Bits = Bits::new(s_1449_10 as u128, 22u16);
        // C s_1449_12: const #3949568u : u22
        let s_1449_12: u32 = 3949568;
        // C s_1449_13: cast zx s_1449_12 -> bv
        let s_1449_13: Bits = Bits::new(s_1449_12 as u128, 22u16);
        // D s_1449_14: cmp-eq s_1449_11 s_1449_13
        let s_1449_14: bool = ((s_1449_11) == (s_1449_13));
        // N s_1449_15: branch s_1449_14 b1595 b1450
        if s_1449_14 {
            return block_1595(state, tracer, fn_state);
        } else {
            return block_1450(state, tracer, fn_state);
        };
    }
    fn block_1450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1450_0: const #0u : u8
        let s_1450_0: bool = false;
        // D s_1450_1: write-var gs#403707 <= s_1450_0
        fn_state.gs_403707 = s_1450_0;
        // N s_1450_2: jump b1451
        return block_1451(state, tracer, fn_state);
    }
    fn block_1451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1451_0: read-var gs#403707:u8
        let s_1451_0: bool = fn_state.gs_403707;
        // N s_1451_1: branch s_1451_0 b1594 b1452
        if s_1451_0 {
            return block_1594(state, tracer, fn_state);
        } else {
            return block_1452(state, tracer, fn_state);
        };
    }
    fn block_1452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1452_0: const #0u : u8
        let s_1452_0: bool = false;
        // D s_1452_1: write-var gs#403709 <= s_1452_0
        fn_state.gs_403709 = s_1452_0;
        // N s_1452_2: jump b1453
        return block_1453(state, tracer, fn_state);
    }
    fn block_1453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1453_0: read-var gs#403709:u8
        let s_1453_0: bool = fn_state.gs_403709;
        // D s_1453_1: not s_1453_0
        let s_1453_1: bool = !s_1453_0;
        // N s_1453_2: branch s_1453_1 b1499 b1454
        if s_1453_1 {
            return block_1499(state, tracer, fn_state);
        } else {
            return block_1454(state, tracer, fn_state);
        };
    }
    fn block_1454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1454_0: const #3888s : i
        let s_1454_0: i128 = 3888;
        // C s_1454_1: const #14696u : u32
        let s_1454_1: u32 = 14696;
        // N s_1454_2: write-reg s_1454_1 <= s_1454_0
        let s_1454_2: () = {
            state.write_register::<i128>(s_1454_1 as isize, s_1454_0);
            tracer.write_register(s_1454_1 as isize, s_1454_0);
        };
        // C s_1454_3: const #9s : i
        let s_1454_3: i128 = 9;
        // C s_1454_4: const #1s : i
        let s_1454_4: i128 = 1;
        // D s_1454_5: read-var u#32313:u32
        let s_1454_5: u32 = fn_state.u_32313;
        // D s_1454_6: cast zx s_1454_5 -> bv
        let s_1454_6: Bits = Bits::new(s_1454_5 as u128, 32u16);
        // D s_1454_7: bit-extract s_1454_6 s_1454_3 s_1454_4
        let s_1454_7: Bits = (Bits::new(
            ((s_1454_6) >> (s_1454_3)).value(),
            u16::try_from(s_1454_4).unwrap(),
        ));
        // D s_1454_8: cast reint s_1454_7 -> u8
        let s_1454_8: bool = ((s_1454_7.value()) != 0);
        // D s_1454_9: write-var imm1 <= s_1454_8
        fn_state.imm1 = s_1454_8;
        // C s_1454_10: const #16s : i
        let s_1454_10: i128 = 16;
        // D s_1454_11: read-var u#32313:u32
        let s_1454_11: u32 = fn_state.u_32313;
        // D s_1454_12: cast zx s_1454_11 -> bv
        let s_1454_12: Bits = Bits::new(s_1454_11 as u128, 32u16);
        // C s_1454_13: const #1u : u64
        let s_1454_13: u64 = 1;
        // D s_1454_14: bit-extract s_1454_12 s_1454_10 s_1454_13
        let s_1454_14: Bits = (Bits::new(
            ((s_1454_12) >> (s_1454_10)).value(),
            u16::try_from(s_1454_13).unwrap(),
        ));
        // D s_1454_15: cast reint s_1454_14 -> u8
        let s_1454_15: bool = ((s_1454_14.value()) != 0);
        // C s_1454_16: const #0s : i
        let s_1454_16: i128 = 0;
        // C s_1454_17: const #0u : u64
        let s_1454_17: u64 = 0;
        // D s_1454_18: cast zx s_1454_15 -> u64
        let s_1454_18: u64 = (s_1454_15 as u64);
        // C s_1454_19: const #1u : u64
        let s_1454_19: u64 = 1;
        // D s_1454_20: and s_1454_18 s_1454_19
        let s_1454_20: u64 = ((s_1454_18) & (s_1454_19));
        // D s_1454_21: cmp-eq s_1454_20 s_1454_19
        let s_1454_21: bool = ((s_1454_20) == (s_1454_19));
        // D s_1454_22: lsl s_1454_18 s_1454_16
        let s_1454_22: u64 = s_1454_18 << s_1454_16;
        // D s_1454_23: or s_1454_17 s_1454_22
        let s_1454_23: u64 = ((s_1454_17) | (s_1454_22));
        // D s_1454_24: cmpl s_1454_22
        let s_1454_24: u64 = !s_1454_22;
        // D s_1454_25: and s_1454_17 s_1454_24
        let s_1454_25: u64 = ((s_1454_17) & (s_1454_24));
        // D s_1454_26: select s_1454_21 s_1454_23 s_1454_25
        let s_1454_26: u64 = if s_1454_21 { s_1454_23 } else { s_1454_25 };
        // D s_1454_27: cast trunc s_1454_26 -> u8
        let s_1454_27: bool = ((s_1454_26) != 0);
        // D s_1454_28: cast zx s_1454_27 -> bv
        let s_1454_28: Bits = Bits::new(s_1454_27 as u128, 1u16);
        // C s_1454_29: const #0u : u8
        let s_1454_29: bool = false;
        // C s_1454_30: cast zx s_1454_29 -> bv
        let s_1454_30: Bits = Bits::new(s_1454_29 as u128, 1u16);
        // D s_1454_31: cmp-ne s_1454_28 s_1454_30
        let s_1454_31: bool = ((s_1454_28) != (s_1454_30));
        // N s_1454_32: branch s_1454_31 b1498 b1455
        if s_1454_31 {
            return block_1498(state, tracer, fn_state);
        } else {
            return block_1455(state, tracer, fn_state);
        };
    }
    fn block_1455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1455_0: const #17s : i
        let s_1455_0: i128 = 17;
        // D s_1455_1: read-var u#32313:u32
        let s_1455_1: u32 = fn_state.u_32313;
        // D s_1455_2: cast zx s_1455_1 -> bv
        let s_1455_2: Bits = Bits::new(s_1455_1 as u128, 32u16);
        // C s_1455_3: const #1u : u64
        let s_1455_3: u64 = 1;
        // D s_1455_4: bit-extract s_1455_2 s_1455_0 s_1455_3
        let s_1455_4: Bits = (Bits::new(
            ((s_1455_2) >> (s_1455_0)).value(),
            u16::try_from(s_1455_3).unwrap(),
        ));
        // D s_1455_5: cast reint s_1455_4 -> u8
        let s_1455_5: bool = ((s_1455_4.value()) != 0);
        // C s_1455_6: const #0s : i
        let s_1455_6: i128 = 0;
        // C s_1455_7: const #0u : u64
        let s_1455_7: u64 = 0;
        // D s_1455_8: cast zx s_1455_5 -> u64
        let s_1455_8: u64 = (s_1455_5 as u64);
        // C s_1455_9: const #1u : u64
        let s_1455_9: u64 = 1;
        // D s_1455_10: and s_1455_8 s_1455_9
        let s_1455_10: u64 = ((s_1455_8) & (s_1455_9));
        // D s_1455_11: cmp-eq s_1455_10 s_1455_9
        let s_1455_11: bool = ((s_1455_10) == (s_1455_9));
        // D s_1455_12: lsl s_1455_8 s_1455_6
        let s_1455_12: u64 = s_1455_8 << s_1455_6;
        // D s_1455_13: or s_1455_7 s_1455_12
        let s_1455_13: u64 = ((s_1455_7) | (s_1455_12));
        // D s_1455_14: cmpl s_1455_12
        let s_1455_14: u64 = !s_1455_12;
        // D s_1455_15: and s_1455_7 s_1455_14
        let s_1455_15: u64 = ((s_1455_7) & (s_1455_14));
        // D s_1455_16: select s_1455_11 s_1455_13 s_1455_15
        let s_1455_16: u64 = if s_1455_11 { s_1455_13 } else { s_1455_15 };
        // D s_1455_17: cast trunc s_1455_16 -> u8
        let s_1455_17: bool = ((s_1455_16) != 0);
        // D s_1455_18: cast zx s_1455_17 -> bv
        let s_1455_18: Bits = Bits::new(s_1455_17 as u128, 1u16);
        // C s_1455_19: const #0u : u8
        let s_1455_19: bool = false;
        // C s_1455_20: cast zx s_1455_19 -> bv
        let s_1455_20: Bits = Bits::new(s_1455_19 as u128, 1u16);
        // D s_1455_21: cmp-ne s_1455_18 s_1455_20
        let s_1455_21: bool = ((s_1455_18) != (s_1455_20));
        // D s_1455_22: write-var gs#403718 <= s_1455_21
        fn_state.gs_403718 = s_1455_21;
        // N s_1455_23: jump b1456
        return block_1456(state, tracer, fn_state);
    }
    fn block_1456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1456_0: read-var gs#403718:u8
        let s_1456_0: bool = fn_state.gs_403718;
        // N s_1456_1: branch s_1456_0 b1497 b1457
        if s_1456_0 {
            return block_1497(state, tracer, fn_state);
        } else {
            return block_1457(state, tracer, fn_state);
        };
    }
    fn block_1457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1457_0: const #18s : i
        let s_1457_0: i128 = 18;
        // D s_1457_1: read-var u#32313:u32
        let s_1457_1: u32 = fn_state.u_32313;
        // D s_1457_2: cast zx s_1457_1 -> bv
        let s_1457_2: Bits = Bits::new(s_1457_1 as u128, 32u16);
        // C s_1457_3: const #1u : u64
        let s_1457_3: u64 = 1;
        // D s_1457_4: bit-extract s_1457_2 s_1457_0 s_1457_3
        let s_1457_4: Bits = (Bits::new(
            ((s_1457_2) >> (s_1457_0)).value(),
            u16::try_from(s_1457_3).unwrap(),
        ));
        // D s_1457_5: cast reint s_1457_4 -> u8
        let s_1457_5: bool = ((s_1457_4.value()) != 0);
        // C s_1457_6: const #0s : i
        let s_1457_6: i128 = 0;
        // C s_1457_7: const #0u : u64
        let s_1457_7: u64 = 0;
        // D s_1457_8: cast zx s_1457_5 -> u64
        let s_1457_8: u64 = (s_1457_5 as u64);
        // C s_1457_9: const #1u : u64
        let s_1457_9: u64 = 1;
        // D s_1457_10: and s_1457_8 s_1457_9
        let s_1457_10: u64 = ((s_1457_8) & (s_1457_9));
        // D s_1457_11: cmp-eq s_1457_10 s_1457_9
        let s_1457_11: bool = ((s_1457_10) == (s_1457_9));
        // D s_1457_12: lsl s_1457_8 s_1457_6
        let s_1457_12: u64 = s_1457_8 << s_1457_6;
        // D s_1457_13: or s_1457_7 s_1457_12
        let s_1457_13: u64 = ((s_1457_7) | (s_1457_12));
        // D s_1457_14: cmpl s_1457_12
        let s_1457_14: u64 = !s_1457_12;
        // D s_1457_15: and s_1457_7 s_1457_14
        let s_1457_15: u64 = ((s_1457_7) & (s_1457_14));
        // D s_1457_16: select s_1457_11 s_1457_13 s_1457_15
        let s_1457_16: u64 = if s_1457_11 { s_1457_13 } else { s_1457_15 };
        // D s_1457_17: cast trunc s_1457_16 -> u8
        let s_1457_17: bool = ((s_1457_16) != 0);
        // D s_1457_18: cast zx s_1457_17 -> bv
        let s_1457_18: Bits = Bits::new(s_1457_17 as u128, 1u16);
        // C s_1457_19: const #0u : u8
        let s_1457_19: bool = false;
        // C s_1457_20: cast zx s_1457_19 -> bv
        let s_1457_20: Bits = Bits::new(s_1457_19 as u128, 1u16);
        // D s_1457_21: cmp-ne s_1457_18 s_1457_20
        let s_1457_21: bool = ((s_1457_18) != (s_1457_20));
        // D s_1457_22: write-var gs#403721 <= s_1457_21
        fn_state.gs_403721 = s_1457_21;
        // N s_1457_23: jump b1458
        return block_1458(state, tracer, fn_state);
    }
    fn block_1458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1458_0: read-var gs#403721:u8
        let s_1458_0: bool = fn_state.gs_403721;
        // N s_1458_1: branch s_1458_0 b1496 b1459
        if s_1458_0 {
            return block_1496(state, tracer, fn_state);
        } else {
            return block_1459(state, tracer, fn_state);
        };
    }
    fn block_1459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1459_0: const #19s : i
        let s_1459_0: i128 = 19;
        // D s_1459_1: read-var u#32313:u32
        let s_1459_1: u32 = fn_state.u_32313;
        // D s_1459_2: cast zx s_1459_1 -> bv
        let s_1459_2: Bits = Bits::new(s_1459_1 as u128, 32u16);
        // C s_1459_3: const #1u : u64
        let s_1459_3: u64 = 1;
        // D s_1459_4: bit-extract s_1459_2 s_1459_0 s_1459_3
        let s_1459_4: Bits = (Bits::new(
            ((s_1459_2) >> (s_1459_0)).value(),
            u16::try_from(s_1459_3).unwrap(),
        ));
        // D s_1459_5: cast reint s_1459_4 -> u8
        let s_1459_5: bool = ((s_1459_4.value()) != 0);
        // C s_1459_6: const #0s : i
        let s_1459_6: i128 = 0;
        // C s_1459_7: const #0u : u64
        let s_1459_7: u64 = 0;
        // D s_1459_8: cast zx s_1459_5 -> u64
        let s_1459_8: u64 = (s_1459_5 as u64);
        // C s_1459_9: const #1u : u64
        let s_1459_9: u64 = 1;
        // D s_1459_10: and s_1459_8 s_1459_9
        let s_1459_10: u64 = ((s_1459_8) & (s_1459_9));
        // D s_1459_11: cmp-eq s_1459_10 s_1459_9
        let s_1459_11: bool = ((s_1459_10) == (s_1459_9));
        // D s_1459_12: lsl s_1459_8 s_1459_6
        let s_1459_12: u64 = s_1459_8 << s_1459_6;
        // D s_1459_13: or s_1459_7 s_1459_12
        let s_1459_13: u64 = ((s_1459_7) | (s_1459_12));
        // D s_1459_14: cmpl s_1459_12
        let s_1459_14: u64 = !s_1459_12;
        // D s_1459_15: and s_1459_7 s_1459_14
        let s_1459_15: u64 = ((s_1459_7) & (s_1459_14));
        // D s_1459_16: select s_1459_11 s_1459_13 s_1459_15
        let s_1459_16: u64 = if s_1459_11 { s_1459_13 } else { s_1459_15 };
        // D s_1459_17: cast trunc s_1459_16 -> u8
        let s_1459_17: bool = ((s_1459_16) != 0);
        // D s_1459_18: cast zx s_1459_17 -> bv
        let s_1459_18: Bits = Bits::new(s_1459_17 as u128, 1u16);
        // C s_1459_19: const #0u : u8
        let s_1459_19: bool = false;
        // C s_1459_20: cast zx s_1459_19 -> bv
        let s_1459_20: Bits = Bits::new(s_1459_19 as u128, 1u16);
        // D s_1459_21: cmp-ne s_1459_18 s_1459_20
        let s_1459_21: bool = ((s_1459_18) != (s_1459_20));
        // D s_1459_22: write-var gs#403724 <= s_1459_21
        fn_state.gs_403724 = s_1459_21;
        // N s_1459_23: jump b1460
        return block_1460(state, tracer, fn_state);
    }
    fn block_1460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1460_0: read-var gs#403724:u8
        let s_1460_0: bool = fn_state.gs_403724;
        // N s_1460_1: branch s_1460_0 b1495 b1461
        if s_1460_0 {
            return block_1495(state, tracer, fn_state);
        } else {
            return block_1461(state, tracer, fn_state);
        };
    }
    fn block_1461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1461_0: const #10s : i
        let s_1461_0: i128 = 10;
        // D s_1461_1: read-var u#32313:u32
        let s_1461_1: u32 = fn_state.u_32313;
        // D s_1461_2: cast zx s_1461_1 -> bv
        let s_1461_2: Bits = Bits::new(s_1461_1 as u128, 32u16);
        // C s_1461_3: const #1u : u64
        let s_1461_3: u64 = 1;
        // D s_1461_4: bit-extract s_1461_2 s_1461_0 s_1461_3
        let s_1461_4: Bits = (Bits::new(
            ((s_1461_2) >> (s_1461_0)).value(),
            u16::try_from(s_1461_3).unwrap(),
        ));
        // D s_1461_5: cast reint s_1461_4 -> u8
        let s_1461_5: bool = ((s_1461_4.value()) != 0);
        // C s_1461_6: const #0s : i
        let s_1461_6: i128 = 0;
        // C s_1461_7: const #0u : u64
        let s_1461_7: u64 = 0;
        // D s_1461_8: cast zx s_1461_5 -> u64
        let s_1461_8: u64 = (s_1461_5 as u64);
        // C s_1461_9: const #1u : u64
        let s_1461_9: u64 = 1;
        // D s_1461_10: and s_1461_8 s_1461_9
        let s_1461_10: u64 = ((s_1461_8) & (s_1461_9));
        // D s_1461_11: cmp-eq s_1461_10 s_1461_9
        let s_1461_11: bool = ((s_1461_10) == (s_1461_9));
        // D s_1461_12: lsl s_1461_8 s_1461_6
        let s_1461_12: u64 = s_1461_8 << s_1461_6;
        // D s_1461_13: or s_1461_7 s_1461_12
        let s_1461_13: u64 = ((s_1461_7) | (s_1461_12));
        // D s_1461_14: cmpl s_1461_12
        let s_1461_14: u64 = !s_1461_12;
        // D s_1461_15: and s_1461_7 s_1461_14
        let s_1461_15: u64 = ((s_1461_7) & (s_1461_14));
        // D s_1461_16: select s_1461_11 s_1461_13 s_1461_15
        let s_1461_16: u64 = if s_1461_11 { s_1461_13 } else { s_1461_15 };
        // D s_1461_17: cast trunc s_1461_16 -> u8
        let s_1461_17: bool = ((s_1461_16) != 0);
        // D s_1461_18: cast zx s_1461_17 -> bv
        let s_1461_18: Bits = Bits::new(s_1461_17 as u128, 1u16);
        // C s_1461_19: const #0u : u8
        let s_1461_19: bool = false;
        // C s_1461_20: cast zx s_1461_19 -> bv
        let s_1461_20: Bits = Bits::new(s_1461_19 as u128, 1u16);
        // D s_1461_21: cmp-ne s_1461_18 s_1461_20
        let s_1461_21: bool = ((s_1461_18) != (s_1461_20));
        // D s_1461_22: write-var gs#403727 <= s_1461_21
        fn_state.gs_403727 = s_1461_21;
        // N s_1461_23: jump b1462
        return block_1462(state, tracer, fn_state);
    }
    fn block_1462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1462_0: read-var gs#403727:u8
        let s_1462_0: bool = fn_state.gs_403727;
        // N s_1462_1: branch s_1462_0 b1494 b1463
        if s_1462_0 {
            return block_1494(state, tracer, fn_state);
        } else {
            return block_1463(state, tracer, fn_state);
        };
    }
    fn block_1463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1463_0: const #11s : i
        let s_1463_0: i128 = 11;
        // D s_1463_1: read-var u#32313:u32
        let s_1463_1: u32 = fn_state.u_32313;
        // D s_1463_2: cast zx s_1463_1 -> bv
        let s_1463_2: Bits = Bits::new(s_1463_1 as u128, 32u16);
        // C s_1463_3: const #1u : u64
        let s_1463_3: u64 = 1;
        // D s_1463_4: bit-extract s_1463_2 s_1463_0 s_1463_3
        let s_1463_4: Bits = (Bits::new(
            ((s_1463_2) >> (s_1463_0)).value(),
            u16::try_from(s_1463_3).unwrap(),
        ));
        // D s_1463_5: cast reint s_1463_4 -> u8
        let s_1463_5: bool = ((s_1463_4.value()) != 0);
        // C s_1463_6: const #0s : i
        let s_1463_6: i128 = 0;
        // C s_1463_7: const #0u : u64
        let s_1463_7: u64 = 0;
        // D s_1463_8: cast zx s_1463_5 -> u64
        let s_1463_8: u64 = (s_1463_5 as u64);
        // C s_1463_9: const #1u : u64
        let s_1463_9: u64 = 1;
        // D s_1463_10: and s_1463_8 s_1463_9
        let s_1463_10: u64 = ((s_1463_8) & (s_1463_9));
        // D s_1463_11: cmp-eq s_1463_10 s_1463_9
        let s_1463_11: bool = ((s_1463_10) == (s_1463_9));
        // D s_1463_12: lsl s_1463_8 s_1463_6
        let s_1463_12: u64 = s_1463_8 << s_1463_6;
        // D s_1463_13: or s_1463_7 s_1463_12
        let s_1463_13: u64 = ((s_1463_7) | (s_1463_12));
        // D s_1463_14: cmpl s_1463_12
        let s_1463_14: u64 = !s_1463_12;
        // D s_1463_15: and s_1463_7 s_1463_14
        let s_1463_15: u64 = ((s_1463_7) & (s_1463_14));
        // D s_1463_16: select s_1463_11 s_1463_13 s_1463_15
        let s_1463_16: u64 = if s_1463_11 { s_1463_13 } else { s_1463_15 };
        // D s_1463_17: cast trunc s_1463_16 -> u8
        let s_1463_17: bool = ((s_1463_16) != 0);
        // D s_1463_18: cast zx s_1463_17 -> bv
        let s_1463_18: Bits = Bits::new(s_1463_17 as u128, 1u16);
        // C s_1463_19: const #0u : u8
        let s_1463_19: bool = false;
        // C s_1463_20: cast zx s_1463_19 -> bv
        let s_1463_20: Bits = Bits::new(s_1463_19 as u128, 1u16);
        // D s_1463_21: cmp-ne s_1463_18 s_1463_20
        let s_1463_21: bool = ((s_1463_18) != (s_1463_20));
        // D s_1463_22: write-var gs#403730 <= s_1463_21
        fn_state.gs_403730 = s_1463_21;
        // N s_1463_23: jump b1464
        return block_1464(state, tracer, fn_state);
    }
    fn block_1464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1464_0: read-var gs#403730:u8
        let s_1464_0: bool = fn_state.gs_403730;
        // N s_1464_1: branch s_1464_0 b1493 b1465
        if s_1464_0 {
            return block_1493(state, tracer, fn_state);
        } else {
            return block_1465(state, tracer, fn_state);
        };
    }
    fn block_1465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1465_0: const #12s : i
        let s_1465_0: i128 = 12;
        // D s_1465_1: read-var u#32313:u32
        let s_1465_1: u32 = fn_state.u_32313;
        // D s_1465_2: cast zx s_1465_1 -> bv
        let s_1465_2: Bits = Bits::new(s_1465_1 as u128, 32u16);
        // C s_1465_3: const #1u : u64
        let s_1465_3: u64 = 1;
        // D s_1465_4: bit-extract s_1465_2 s_1465_0 s_1465_3
        let s_1465_4: Bits = (Bits::new(
            ((s_1465_2) >> (s_1465_0)).value(),
            u16::try_from(s_1465_3).unwrap(),
        ));
        // D s_1465_5: cast reint s_1465_4 -> u8
        let s_1465_5: bool = ((s_1465_4.value()) != 0);
        // C s_1465_6: const #0s : i
        let s_1465_6: i128 = 0;
        // C s_1465_7: const #0u : u64
        let s_1465_7: u64 = 0;
        // D s_1465_8: cast zx s_1465_5 -> u64
        let s_1465_8: u64 = (s_1465_5 as u64);
        // C s_1465_9: const #1u : u64
        let s_1465_9: u64 = 1;
        // D s_1465_10: and s_1465_8 s_1465_9
        let s_1465_10: u64 = ((s_1465_8) & (s_1465_9));
        // D s_1465_11: cmp-eq s_1465_10 s_1465_9
        let s_1465_11: bool = ((s_1465_10) == (s_1465_9));
        // D s_1465_12: lsl s_1465_8 s_1465_6
        let s_1465_12: u64 = s_1465_8 << s_1465_6;
        // D s_1465_13: or s_1465_7 s_1465_12
        let s_1465_13: u64 = ((s_1465_7) | (s_1465_12));
        // D s_1465_14: cmpl s_1465_12
        let s_1465_14: u64 = !s_1465_12;
        // D s_1465_15: and s_1465_7 s_1465_14
        let s_1465_15: u64 = ((s_1465_7) & (s_1465_14));
        // D s_1465_16: select s_1465_11 s_1465_13 s_1465_15
        let s_1465_16: u64 = if s_1465_11 { s_1465_13 } else { s_1465_15 };
        // D s_1465_17: cast trunc s_1465_16 -> u8
        let s_1465_17: bool = ((s_1465_16) != 0);
        // D s_1465_18: cast zx s_1465_17 -> bv
        let s_1465_18: Bits = Bits::new(s_1465_17 as u128, 1u16);
        // C s_1465_19: const #0u : u8
        let s_1465_19: bool = false;
        // C s_1465_20: cast zx s_1465_19 -> bv
        let s_1465_20: Bits = Bits::new(s_1465_19 as u128, 1u16);
        // D s_1465_21: cmp-ne s_1465_18 s_1465_20
        let s_1465_21: bool = ((s_1465_18) != (s_1465_20));
        // D s_1465_22: write-var gs#403733 <= s_1465_21
        fn_state.gs_403733 = s_1465_21;
        // N s_1465_23: jump b1466
        return block_1466(state, tracer, fn_state);
    }
    fn block_1466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1466_0: read-var gs#403733:u8
        let s_1466_0: bool = fn_state.gs_403733;
        // N s_1466_1: branch s_1466_0 b1492 b1467
        if s_1466_0 {
            return block_1492(state, tracer, fn_state);
        } else {
            return block_1467(state, tracer, fn_state);
        };
    }
    fn block_1467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1467_0: const #13s : i
        let s_1467_0: i128 = 13;
        // D s_1467_1: read-var u#32313:u32
        let s_1467_1: u32 = fn_state.u_32313;
        // D s_1467_2: cast zx s_1467_1 -> bv
        let s_1467_2: Bits = Bits::new(s_1467_1 as u128, 32u16);
        // C s_1467_3: const #1u : u64
        let s_1467_3: u64 = 1;
        // D s_1467_4: bit-extract s_1467_2 s_1467_0 s_1467_3
        let s_1467_4: Bits = (Bits::new(
            ((s_1467_2) >> (s_1467_0)).value(),
            u16::try_from(s_1467_3).unwrap(),
        ));
        // D s_1467_5: cast reint s_1467_4 -> u8
        let s_1467_5: bool = ((s_1467_4.value()) != 0);
        // C s_1467_6: const #0s : i
        let s_1467_6: i128 = 0;
        // C s_1467_7: const #0u : u64
        let s_1467_7: u64 = 0;
        // D s_1467_8: cast zx s_1467_5 -> u64
        let s_1467_8: u64 = (s_1467_5 as u64);
        // C s_1467_9: const #1u : u64
        let s_1467_9: u64 = 1;
        // D s_1467_10: and s_1467_8 s_1467_9
        let s_1467_10: u64 = ((s_1467_8) & (s_1467_9));
        // D s_1467_11: cmp-eq s_1467_10 s_1467_9
        let s_1467_11: bool = ((s_1467_10) == (s_1467_9));
        // D s_1467_12: lsl s_1467_8 s_1467_6
        let s_1467_12: u64 = s_1467_8 << s_1467_6;
        // D s_1467_13: or s_1467_7 s_1467_12
        let s_1467_13: u64 = ((s_1467_7) | (s_1467_12));
        // D s_1467_14: cmpl s_1467_12
        let s_1467_14: u64 = !s_1467_12;
        // D s_1467_15: and s_1467_7 s_1467_14
        let s_1467_15: u64 = ((s_1467_7) & (s_1467_14));
        // D s_1467_16: select s_1467_11 s_1467_13 s_1467_15
        let s_1467_16: u64 = if s_1467_11 { s_1467_13 } else { s_1467_15 };
        // D s_1467_17: cast trunc s_1467_16 -> u8
        let s_1467_17: bool = ((s_1467_16) != 0);
        // D s_1467_18: cast zx s_1467_17 -> bv
        let s_1467_18: Bits = Bits::new(s_1467_17 as u128, 1u16);
        // C s_1467_19: const #0u : u8
        let s_1467_19: bool = false;
        // C s_1467_20: cast zx s_1467_19 -> bv
        let s_1467_20: Bits = Bits::new(s_1467_19 as u128, 1u16);
        // D s_1467_21: cmp-ne s_1467_18 s_1467_20
        let s_1467_21: bool = ((s_1467_18) != (s_1467_20));
        // D s_1467_22: write-var gs#403736 <= s_1467_21
        fn_state.gs_403736 = s_1467_21;
        // N s_1467_23: jump b1468
        return block_1468(state, tracer, fn_state);
    }
    fn block_1468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1468_0: read-var gs#403736:u8
        let s_1468_0: bool = fn_state.gs_403736;
        // N s_1468_1: branch s_1468_0 b1491 b1469
        if s_1468_0 {
            return block_1491(state, tracer, fn_state);
        } else {
            return block_1469(state, tracer, fn_state);
        };
    }
    fn block_1469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1469_0: const #14s : i
        let s_1469_0: i128 = 14;
        // D s_1469_1: read-var u#32313:u32
        let s_1469_1: u32 = fn_state.u_32313;
        // D s_1469_2: cast zx s_1469_1 -> bv
        let s_1469_2: Bits = Bits::new(s_1469_1 as u128, 32u16);
        // C s_1469_3: const #1u : u64
        let s_1469_3: u64 = 1;
        // D s_1469_4: bit-extract s_1469_2 s_1469_0 s_1469_3
        let s_1469_4: Bits = (Bits::new(
            ((s_1469_2) >> (s_1469_0)).value(),
            u16::try_from(s_1469_3).unwrap(),
        ));
        // D s_1469_5: cast reint s_1469_4 -> u8
        let s_1469_5: bool = ((s_1469_4.value()) != 0);
        // C s_1469_6: const #0s : i
        let s_1469_6: i128 = 0;
        // C s_1469_7: const #0u : u64
        let s_1469_7: u64 = 0;
        // D s_1469_8: cast zx s_1469_5 -> u64
        let s_1469_8: u64 = (s_1469_5 as u64);
        // C s_1469_9: const #1u : u64
        let s_1469_9: u64 = 1;
        // D s_1469_10: and s_1469_8 s_1469_9
        let s_1469_10: u64 = ((s_1469_8) & (s_1469_9));
        // D s_1469_11: cmp-eq s_1469_10 s_1469_9
        let s_1469_11: bool = ((s_1469_10) == (s_1469_9));
        // D s_1469_12: lsl s_1469_8 s_1469_6
        let s_1469_12: u64 = s_1469_8 << s_1469_6;
        // D s_1469_13: or s_1469_7 s_1469_12
        let s_1469_13: u64 = ((s_1469_7) | (s_1469_12));
        // D s_1469_14: cmpl s_1469_12
        let s_1469_14: u64 = !s_1469_12;
        // D s_1469_15: and s_1469_7 s_1469_14
        let s_1469_15: u64 = ((s_1469_7) & (s_1469_14));
        // D s_1469_16: select s_1469_11 s_1469_13 s_1469_15
        let s_1469_16: u64 = if s_1469_11 { s_1469_13 } else { s_1469_15 };
        // D s_1469_17: cast trunc s_1469_16 -> u8
        let s_1469_17: bool = ((s_1469_16) != 0);
        // D s_1469_18: cast zx s_1469_17 -> bv
        let s_1469_18: Bits = Bits::new(s_1469_17 as u128, 1u16);
        // C s_1469_19: const #0u : u8
        let s_1469_19: bool = false;
        // C s_1469_20: cast zx s_1469_19 -> bv
        let s_1469_20: Bits = Bits::new(s_1469_19 as u128, 1u16);
        // D s_1469_21: cmp-ne s_1469_18 s_1469_20
        let s_1469_21: bool = ((s_1469_18) != (s_1469_20));
        // D s_1469_22: write-var gs#403739 <= s_1469_21
        fn_state.gs_403739 = s_1469_21;
        // N s_1469_23: jump b1470
        return block_1470(state, tracer, fn_state);
    }
    fn block_1470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1470_0: read-var gs#403739:u8
        let s_1470_0: bool = fn_state.gs_403739;
        // N s_1470_1: branch s_1470_0 b1490 b1471
        if s_1470_0 {
            return block_1490(state, tracer, fn_state);
        } else {
            return block_1471(state, tracer, fn_state);
        };
    }
    fn block_1471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1471_0: const #15s : i
        let s_1471_0: i128 = 15;
        // D s_1471_1: read-var u#32313:u32
        let s_1471_1: u32 = fn_state.u_32313;
        // D s_1471_2: cast zx s_1471_1 -> bv
        let s_1471_2: Bits = Bits::new(s_1471_1 as u128, 32u16);
        // C s_1471_3: const #1u : u64
        let s_1471_3: u64 = 1;
        // D s_1471_4: bit-extract s_1471_2 s_1471_0 s_1471_3
        let s_1471_4: Bits = (Bits::new(
            ((s_1471_2) >> (s_1471_0)).value(),
            u16::try_from(s_1471_3).unwrap(),
        ));
        // D s_1471_5: cast reint s_1471_4 -> u8
        let s_1471_5: bool = ((s_1471_4.value()) != 0);
        // C s_1471_6: const #0s : i
        let s_1471_6: i128 = 0;
        // C s_1471_7: const #0u : u64
        let s_1471_7: u64 = 0;
        // D s_1471_8: cast zx s_1471_5 -> u64
        let s_1471_8: u64 = (s_1471_5 as u64);
        // C s_1471_9: const #1u : u64
        let s_1471_9: u64 = 1;
        // D s_1471_10: and s_1471_8 s_1471_9
        let s_1471_10: u64 = ((s_1471_8) & (s_1471_9));
        // D s_1471_11: cmp-eq s_1471_10 s_1471_9
        let s_1471_11: bool = ((s_1471_10) == (s_1471_9));
        // D s_1471_12: lsl s_1471_8 s_1471_6
        let s_1471_12: u64 = s_1471_8 << s_1471_6;
        // D s_1471_13: or s_1471_7 s_1471_12
        let s_1471_13: u64 = ((s_1471_7) | (s_1471_12));
        // D s_1471_14: cmpl s_1471_12
        let s_1471_14: u64 = !s_1471_12;
        // D s_1471_15: and s_1471_7 s_1471_14
        let s_1471_15: u64 = ((s_1471_7) & (s_1471_14));
        // D s_1471_16: select s_1471_11 s_1471_13 s_1471_15
        let s_1471_16: u64 = if s_1471_11 { s_1471_13 } else { s_1471_15 };
        // D s_1471_17: cast trunc s_1471_16 -> u8
        let s_1471_17: bool = ((s_1471_16) != 0);
        // D s_1471_18: cast zx s_1471_17 -> bv
        let s_1471_18: Bits = Bits::new(s_1471_17 as u128, 1u16);
        // C s_1471_19: const #0u : u8
        let s_1471_19: bool = false;
        // C s_1471_20: cast zx s_1471_19 -> bv
        let s_1471_20: Bits = Bits::new(s_1471_19 as u128, 1u16);
        // D s_1471_21: cmp-ne s_1471_18 s_1471_20
        let s_1471_21: bool = ((s_1471_18) != (s_1471_20));
        // D s_1471_22: write-var gs#403742 <= s_1471_21
        fn_state.gs_403742 = s_1471_21;
        // N s_1471_23: jump b1472
        return block_1472(state, tracer, fn_state);
    }
    fn block_1472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1472_0: read-var gs#403742:u8
        let s_1472_0: bool = fn_state.gs_403742;
        // N s_1472_1: branch s_1472_0 b1489 b1473
        if s_1472_0 {
            return block_1489(state, tracer, fn_state);
        } else {
            return block_1473(state, tracer, fn_state);
        };
    }
    fn block_1473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1473_0: const #8s : i
        let s_1473_0: i128 = 8;
        // D s_1473_1: read-var u#32313:u32
        let s_1473_1: u32 = fn_state.u_32313;
        // D s_1473_2: cast zx s_1473_1 -> bv
        let s_1473_2: Bits = Bits::new(s_1473_1 as u128, 32u16);
        // C s_1473_3: const #1u : u64
        let s_1473_3: u64 = 1;
        // D s_1473_4: bit-extract s_1473_2 s_1473_0 s_1473_3
        let s_1473_4: Bits = (Bits::new(
            ((s_1473_2) >> (s_1473_0)).value(),
            u16::try_from(s_1473_3).unwrap(),
        ));
        // D s_1473_5: cast reint s_1473_4 -> u8
        let s_1473_5: bool = ((s_1473_4.value()) != 0);
        // C s_1473_6: const #0s : i
        let s_1473_6: i128 = 0;
        // C s_1473_7: const #0u : u64
        let s_1473_7: u64 = 0;
        // D s_1473_8: cast zx s_1473_5 -> u64
        let s_1473_8: u64 = (s_1473_5 as u64);
        // C s_1473_9: const #1u : u64
        let s_1473_9: u64 = 1;
        // D s_1473_10: and s_1473_8 s_1473_9
        let s_1473_10: u64 = ((s_1473_8) & (s_1473_9));
        // D s_1473_11: cmp-eq s_1473_10 s_1473_9
        let s_1473_11: bool = ((s_1473_10) == (s_1473_9));
        // D s_1473_12: lsl s_1473_8 s_1473_6
        let s_1473_12: u64 = s_1473_8 << s_1473_6;
        // D s_1473_13: or s_1473_7 s_1473_12
        let s_1473_13: u64 = ((s_1473_7) | (s_1473_12));
        // D s_1473_14: cmpl s_1473_12
        let s_1473_14: u64 = !s_1473_12;
        // D s_1473_15: and s_1473_7 s_1473_14
        let s_1473_15: u64 = ((s_1473_7) & (s_1473_14));
        // D s_1473_16: select s_1473_11 s_1473_13 s_1473_15
        let s_1473_16: u64 = if s_1473_11 { s_1473_13 } else { s_1473_15 };
        // D s_1473_17: cast trunc s_1473_16 -> u8
        let s_1473_17: bool = ((s_1473_16) != 0);
        // D s_1473_18: cast zx s_1473_17 -> bv
        let s_1473_18: Bits = Bits::new(s_1473_17 as u128, 1u16);
        // C s_1473_19: const #0u : u8
        let s_1473_19: bool = false;
        // C s_1473_20: cast zx s_1473_19 -> bv
        let s_1473_20: Bits = Bits::new(s_1473_19 as u128, 1u16);
        // D s_1473_21: cmp-ne s_1473_18 s_1473_20
        let s_1473_21: bool = ((s_1473_18) != (s_1473_20));
        // D s_1473_22: write-var gs#403745 <= s_1473_21
        fn_state.gs_403745 = s_1473_21;
        // N s_1473_23: jump b1474
        return block_1474(state, tracer, fn_state);
    }
    fn block_1474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1474_0: read-var gs#403745:u8
        let s_1474_0: bool = fn_state.gs_403745;
        // N s_1474_1: branch s_1474_0 b1488 b1475
        if s_1474_0 {
            return block_1488(state, tracer, fn_state);
        } else {
            return block_1475(state, tracer, fn_state);
        };
    }
    fn block_1475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1475_0: const #0s : i
        let s_1475_0: i128 = 0;
        // D s_1475_1: read-var u#32313:u32
        let s_1475_1: u32 = fn_state.u_32313;
        // D s_1475_2: cast zx s_1475_1 -> bv
        let s_1475_2: Bits = Bits::new(s_1475_1 as u128, 32u16);
        // C s_1475_3: const #1u : u64
        let s_1475_3: u64 = 1;
        // D s_1475_4: bit-extract s_1475_2 s_1475_0 s_1475_3
        let s_1475_4: Bits = (Bits::new(
            ((s_1475_2) >> (s_1475_0)).value(),
            u16::try_from(s_1475_3).unwrap(),
        ));
        // D s_1475_5: cast reint s_1475_4 -> u8
        let s_1475_5: bool = ((s_1475_4.value()) != 0);
        // C s_1475_6: const #0s : i
        let s_1475_6: i128 = 0;
        // C s_1475_7: const #0u : u64
        let s_1475_7: u64 = 0;
        // D s_1475_8: cast zx s_1475_5 -> u64
        let s_1475_8: u64 = (s_1475_5 as u64);
        // C s_1475_9: const #1u : u64
        let s_1475_9: u64 = 1;
        // D s_1475_10: and s_1475_8 s_1475_9
        let s_1475_10: u64 = ((s_1475_8) & (s_1475_9));
        // D s_1475_11: cmp-eq s_1475_10 s_1475_9
        let s_1475_11: bool = ((s_1475_10) == (s_1475_9));
        // D s_1475_12: lsl s_1475_8 s_1475_6
        let s_1475_12: u64 = s_1475_8 << s_1475_6;
        // D s_1475_13: or s_1475_7 s_1475_12
        let s_1475_13: u64 = ((s_1475_7) | (s_1475_12));
        // D s_1475_14: cmpl s_1475_12
        let s_1475_14: u64 = !s_1475_12;
        // D s_1475_15: and s_1475_7 s_1475_14
        let s_1475_15: u64 = ((s_1475_7) & (s_1475_14));
        // D s_1475_16: select s_1475_11 s_1475_13 s_1475_15
        let s_1475_16: u64 = if s_1475_11 { s_1475_13 } else { s_1475_15 };
        // D s_1475_17: cast trunc s_1475_16 -> u8
        let s_1475_17: bool = ((s_1475_16) != 0);
        // D s_1475_18: cast zx s_1475_17 -> bv
        let s_1475_18: Bits = Bits::new(s_1475_17 as u128, 1u16);
        // C s_1475_19: const #0u : u8
        let s_1475_19: bool = false;
        // C s_1475_20: cast zx s_1475_19 -> bv
        let s_1475_20: Bits = Bits::new(s_1475_19 as u128, 1u16);
        // D s_1475_21: cmp-ne s_1475_18 s_1475_20
        let s_1475_21: bool = ((s_1475_18) != (s_1475_20));
        // D s_1475_22: write-var gs#403748 <= s_1475_21
        fn_state.gs_403748 = s_1475_21;
        // N s_1475_23: jump b1476
        return block_1476(state, tracer, fn_state);
    }
    fn block_1476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1476_0: read-var gs#403748:u8
        let s_1476_0: bool = fn_state.gs_403748;
        // N s_1476_1: branch s_1476_0 b1487 b1477
        if s_1476_0 {
            return block_1487(state, tracer, fn_state);
        } else {
            return block_1477(state, tracer, fn_state);
        };
    }
    fn block_1477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1477_0: const #1s : i
        let s_1477_0: i128 = 1;
        // D s_1477_1: read-var u#32313:u32
        let s_1477_1: u32 = fn_state.u_32313;
        // D s_1477_2: cast zx s_1477_1 -> bv
        let s_1477_2: Bits = Bits::new(s_1477_1 as u128, 32u16);
        // C s_1477_3: const #1u : u64
        let s_1477_3: u64 = 1;
        // D s_1477_4: bit-extract s_1477_2 s_1477_0 s_1477_3
        let s_1477_4: Bits = (Bits::new(
            ((s_1477_2) >> (s_1477_0)).value(),
            u16::try_from(s_1477_3).unwrap(),
        ));
        // D s_1477_5: cast reint s_1477_4 -> u8
        let s_1477_5: bool = ((s_1477_4.value()) != 0);
        // C s_1477_6: const #0s : i
        let s_1477_6: i128 = 0;
        // C s_1477_7: const #0u : u64
        let s_1477_7: u64 = 0;
        // D s_1477_8: cast zx s_1477_5 -> u64
        let s_1477_8: u64 = (s_1477_5 as u64);
        // C s_1477_9: const #1u : u64
        let s_1477_9: u64 = 1;
        // D s_1477_10: and s_1477_8 s_1477_9
        let s_1477_10: u64 = ((s_1477_8) & (s_1477_9));
        // D s_1477_11: cmp-eq s_1477_10 s_1477_9
        let s_1477_11: bool = ((s_1477_10) == (s_1477_9));
        // D s_1477_12: lsl s_1477_8 s_1477_6
        let s_1477_12: u64 = s_1477_8 << s_1477_6;
        // D s_1477_13: or s_1477_7 s_1477_12
        let s_1477_13: u64 = ((s_1477_7) | (s_1477_12));
        // D s_1477_14: cmpl s_1477_12
        let s_1477_14: u64 = !s_1477_12;
        // D s_1477_15: and s_1477_7 s_1477_14
        let s_1477_15: u64 = ((s_1477_7) & (s_1477_14));
        // D s_1477_16: select s_1477_11 s_1477_13 s_1477_15
        let s_1477_16: u64 = if s_1477_11 { s_1477_13 } else { s_1477_15 };
        // D s_1477_17: cast trunc s_1477_16 -> u8
        let s_1477_17: bool = ((s_1477_16) != 0);
        // D s_1477_18: cast zx s_1477_17 -> bv
        let s_1477_18: Bits = Bits::new(s_1477_17 as u128, 1u16);
        // C s_1477_19: const #0u : u8
        let s_1477_19: bool = false;
        // C s_1477_20: cast zx s_1477_19 -> bv
        let s_1477_20: Bits = Bits::new(s_1477_19 as u128, 1u16);
        // D s_1477_21: cmp-ne s_1477_18 s_1477_20
        let s_1477_21: bool = ((s_1477_18) != (s_1477_20));
        // D s_1477_22: write-var gs#403751 <= s_1477_21
        fn_state.gs_403751 = s_1477_21;
        // N s_1477_23: jump b1478
        return block_1478(state, tracer, fn_state);
    }
    fn block_1478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1478_0: read-var gs#403751:u8
        let s_1478_0: bool = fn_state.gs_403751;
        // N s_1478_1: branch s_1478_0 b1486 b1479
        if s_1478_0 {
            return block_1486(state, tracer, fn_state);
        } else {
            return block_1479(state, tracer, fn_state);
        };
    }
    fn block_1479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1479_0: const #2s : i
        let s_1479_0: i128 = 2;
        // D s_1479_1: read-var u#32313:u32
        let s_1479_1: u32 = fn_state.u_32313;
        // D s_1479_2: cast zx s_1479_1 -> bv
        let s_1479_2: Bits = Bits::new(s_1479_1 as u128, 32u16);
        // C s_1479_3: const #1u : u64
        let s_1479_3: u64 = 1;
        // D s_1479_4: bit-extract s_1479_2 s_1479_0 s_1479_3
        let s_1479_4: Bits = (Bits::new(
            ((s_1479_2) >> (s_1479_0)).value(),
            u16::try_from(s_1479_3).unwrap(),
        ));
        // D s_1479_5: cast reint s_1479_4 -> u8
        let s_1479_5: bool = ((s_1479_4.value()) != 0);
        // C s_1479_6: const #0s : i
        let s_1479_6: i128 = 0;
        // C s_1479_7: const #0u : u64
        let s_1479_7: u64 = 0;
        // D s_1479_8: cast zx s_1479_5 -> u64
        let s_1479_8: u64 = (s_1479_5 as u64);
        // C s_1479_9: const #1u : u64
        let s_1479_9: u64 = 1;
        // D s_1479_10: and s_1479_8 s_1479_9
        let s_1479_10: u64 = ((s_1479_8) & (s_1479_9));
        // D s_1479_11: cmp-eq s_1479_10 s_1479_9
        let s_1479_11: bool = ((s_1479_10) == (s_1479_9));
        // D s_1479_12: lsl s_1479_8 s_1479_6
        let s_1479_12: u64 = s_1479_8 << s_1479_6;
        // D s_1479_13: or s_1479_7 s_1479_12
        let s_1479_13: u64 = ((s_1479_7) | (s_1479_12));
        // D s_1479_14: cmpl s_1479_12
        let s_1479_14: u64 = !s_1479_12;
        // D s_1479_15: and s_1479_7 s_1479_14
        let s_1479_15: u64 = ((s_1479_7) & (s_1479_14));
        // D s_1479_16: select s_1479_11 s_1479_13 s_1479_15
        let s_1479_16: u64 = if s_1479_11 { s_1479_13 } else { s_1479_15 };
        // D s_1479_17: cast trunc s_1479_16 -> u8
        let s_1479_17: bool = ((s_1479_16) != 0);
        // D s_1479_18: cast zx s_1479_17 -> bv
        let s_1479_18: Bits = Bits::new(s_1479_17 as u128, 1u16);
        // C s_1479_19: const #0u : u8
        let s_1479_19: bool = false;
        // C s_1479_20: cast zx s_1479_19 -> bv
        let s_1479_20: Bits = Bits::new(s_1479_19 as u128, 1u16);
        // D s_1479_21: cmp-ne s_1479_18 s_1479_20
        let s_1479_21: bool = ((s_1479_18) != (s_1479_20));
        // D s_1479_22: write-var gs#403754 <= s_1479_21
        fn_state.gs_403754 = s_1479_21;
        // N s_1479_23: jump b1480
        return block_1480(state, tracer, fn_state);
    }
    fn block_1480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1480_0: read-var gs#403754:u8
        let s_1480_0: bool = fn_state.gs_403754;
        // N s_1480_1: branch s_1480_0 b1485 b1481
        if s_1480_0 {
            return block_1485(state, tracer, fn_state);
        } else {
            return block_1481(state, tracer, fn_state);
        };
    }
    fn block_1481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1481_0: const #3s : i
        let s_1481_0: i128 = 3;
        // D s_1481_1: read-var u#32313:u32
        let s_1481_1: u32 = fn_state.u_32313;
        // D s_1481_2: cast zx s_1481_1 -> bv
        let s_1481_2: Bits = Bits::new(s_1481_1 as u128, 32u16);
        // C s_1481_3: const #1u : u64
        let s_1481_3: u64 = 1;
        // D s_1481_4: bit-extract s_1481_2 s_1481_0 s_1481_3
        let s_1481_4: Bits = (Bits::new(
            ((s_1481_2) >> (s_1481_0)).value(),
            u16::try_from(s_1481_3).unwrap(),
        ));
        // D s_1481_5: cast reint s_1481_4 -> u8
        let s_1481_5: bool = ((s_1481_4.value()) != 0);
        // C s_1481_6: const #0s : i
        let s_1481_6: i128 = 0;
        // C s_1481_7: const #0u : u64
        let s_1481_7: u64 = 0;
        // D s_1481_8: cast zx s_1481_5 -> u64
        let s_1481_8: u64 = (s_1481_5 as u64);
        // C s_1481_9: const #1u : u64
        let s_1481_9: u64 = 1;
        // D s_1481_10: and s_1481_8 s_1481_9
        let s_1481_10: u64 = ((s_1481_8) & (s_1481_9));
        // D s_1481_11: cmp-eq s_1481_10 s_1481_9
        let s_1481_11: bool = ((s_1481_10) == (s_1481_9));
        // D s_1481_12: lsl s_1481_8 s_1481_6
        let s_1481_12: u64 = s_1481_8 << s_1481_6;
        // D s_1481_13: or s_1481_7 s_1481_12
        let s_1481_13: u64 = ((s_1481_7) | (s_1481_12));
        // D s_1481_14: cmpl s_1481_12
        let s_1481_14: u64 = !s_1481_12;
        // D s_1481_15: and s_1481_7 s_1481_14
        let s_1481_15: u64 = ((s_1481_7) & (s_1481_14));
        // D s_1481_16: select s_1481_11 s_1481_13 s_1481_15
        let s_1481_16: u64 = if s_1481_11 { s_1481_13 } else { s_1481_15 };
        // D s_1481_17: cast trunc s_1481_16 -> u8
        let s_1481_17: bool = ((s_1481_16) != 0);
        // D s_1481_18: cast zx s_1481_17 -> bv
        let s_1481_18: Bits = Bits::new(s_1481_17 as u128, 1u16);
        // C s_1481_19: const #0u : u8
        let s_1481_19: bool = false;
        // C s_1481_20: cast zx s_1481_19 -> bv
        let s_1481_20: Bits = Bits::new(s_1481_19 as u128, 1u16);
        // D s_1481_21: cmp-ne s_1481_18 s_1481_20
        let s_1481_21: bool = ((s_1481_18) != (s_1481_20));
        // D s_1481_22: write-var gs#403757 <= s_1481_21
        fn_state.gs_403757 = s_1481_21;
        // N s_1481_23: jump b1482
        return block_1482(state, tracer, fn_state);
    }
    fn block_1482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1482_0: read-var gs#403757:u8
        let s_1482_0: bool = fn_state.gs_403757;
        // N s_1482_1: branch s_1482_0 b1484 b1483
        if s_1482_0 {
            return block_1484(state, tracer, fn_state);
        } else {
            return block_1483(state, tracer, fn_state);
        };
    }
    fn block_1483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1483_0: read-var imm1:u8
        let s_1483_0: bool = fn_state.imm1;
        // D s_1483_1: call decode_aarch32_instrs_SETPAN_A1enc_A_txt(s_1483_0)
        let s_1483_1: () = decode_aarch32_instrs_SETPAN_A1enc_A_txt(
            state,
            tracer,
            s_1483_0,
        );
        // N s_1483_2: return
        return;
    }
    fn block_1484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1484_0: panic
        panic!("{:?}", ());
        // N s_1484_1: return
        return;
    }
    fn block_1485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1485_0: const #1u : u8
        let s_1485_0: bool = true;
        // D s_1485_1: write-var gs#403757 <= s_1485_0
        fn_state.gs_403757 = s_1485_0;
        // N s_1485_2: jump b1482
        return block_1482(state, tracer, fn_state);
    }
    fn block_1486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1486_0: const #1u : u8
        let s_1486_0: bool = true;
        // D s_1486_1: write-var gs#403754 <= s_1486_0
        fn_state.gs_403754 = s_1486_0;
        // N s_1486_2: jump b1480
        return block_1480(state, tracer, fn_state);
    }
    fn block_1487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1487_0: const #1u : u8
        let s_1487_0: bool = true;
        // D s_1487_1: write-var gs#403751 <= s_1487_0
        fn_state.gs_403751 = s_1487_0;
        // N s_1487_2: jump b1478
        return block_1478(state, tracer, fn_state);
    }
    fn block_1488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1488_0: const #1u : u8
        let s_1488_0: bool = true;
        // D s_1488_1: write-var gs#403748 <= s_1488_0
        fn_state.gs_403748 = s_1488_0;
        // N s_1488_2: jump b1476
        return block_1476(state, tracer, fn_state);
    }
    fn block_1489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1489_0: const #1u : u8
        let s_1489_0: bool = true;
        // D s_1489_1: write-var gs#403745 <= s_1489_0
        fn_state.gs_403745 = s_1489_0;
        // N s_1489_2: jump b1474
        return block_1474(state, tracer, fn_state);
    }
    fn block_1490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1490_0: const #1u : u8
        let s_1490_0: bool = true;
        // D s_1490_1: write-var gs#403742 <= s_1490_0
        fn_state.gs_403742 = s_1490_0;
        // N s_1490_2: jump b1472
        return block_1472(state, tracer, fn_state);
    }
    fn block_1491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1491_0: const #1u : u8
        let s_1491_0: bool = true;
        // D s_1491_1: write-var gs#403739 <= s_1491_0
        fn_state.gs_403739 = s_1491_0;
        // N s_1491_2: jump b1470
        return block_1470(state, tracer, fn_state);
    }
    fn block_1492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1492_0: const #1u : u8
        let s_1492_0: bool = true;
        // D s_1492_1: write-var gs#403736 <= s_1492_0
        fn_state.gs_403736 = s_1492_0;
        // N s_1492_2: jump b1468
        return block_1468(state, tracer, fn_state);
    }
    fn block_1493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1493_0: const #1u : u8
        let s_1493_0: bool = true;
        // D s_1493_1: write-var gs#403733 <= s_1493_0
        fn_state.gs_403733 = s_1493_0;
        // N s_1493_2: jump b1466
        return block_1466(state, tracer, fn_state);
    }
    fn block_1494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1494_0: const #1u : u8
        let s_1494_0: bool = true;
        // D s_1494_1: write-var gs#403730 <= s_1494_0
        fn_state.gs_403730 = s_1494_0;
        // N s_1494_2: jump b1464
        return block_1464(state, tracer, fn_state);
    }
    fn block_1495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1495_0: const #1u : u8
        let s_1495_0: bool = true;
        // D s_1495_1: write-var gs#403727 <= s_1495_0
        fn_state.gs_403727 = s_1495_0;
        // N s_1495_2: jump b1462
        return block_1462(state, tracer, fn_state);
    }
    fn block_1496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1496_0: const #1u : u8
        let s_1496_0: bool = true;
        // D s_1496_1: write-var gs#403724 <= s_1496_0
        fn_state.gs_403724 = s_1496_0;
        // N s_1496_2: jump b1460
        return block_1460(state, tracer, fn_state);
    }
    fn block_1497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1497_0: const #1u : u8
        let s_1497_0: bool = true;
        // D s_1497_1: write-var gs#403721 <= s_1497_0
        fn_state.gs_403721 = s_1497_0;
        // N s_1497_2: jump b1458
        return block_1458(state, tracer, fn_state);
    }
    fn block_1498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1498_0: const #1u : u8
        let s_1498_0: bool = true;
        // D s_1498_1: write-var gs#403718 <= s_1498_0
        fn_state.gs_403718 = s_1498_0;
        // N s_1498_2: jump b1456
        return block_1456(state, tracer, fn_state);
    }
    fn block_1499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1499_0: read-var merge#var.1:struct
        let s_1499_0: u32 = fn_state.merge_var._1;
        // D s_1499_1: write-var u#32315 <= s_1499_0
        fn_state.u_32315 = s_1499_0;
        // D s_1499_2: read-var u#32315:u32
        let s_1499_2: u32 = fn_state.u_32315;
        // D s_1499_3: cast zx s_1499_2 -> bv
        let s_1499_3: Bits = Bits::new(s_1499_2 as u128, 32u16);
        // C s_1499_4: const #4118802496u : u32
        let s_1499_4: u32 = 4118802496;
        // C s_1499_5: cast zx s_1499_4 -> bv
        let s_1499_5: Bits = Bits::new(s_1499_4 as u128, 32u16);
        // D s_1499_6: cmp-eq s_1499_3 s_1499_5
        let s_1499_6: bool = ((s_1499_3) == (s_1499_5));
        // N s_1499_7: branch s_1499_6 b1593 b1500
        if s_1499_6 {
            return block_1593(state, tracer, fn_state);
        } else {
            return block_1500(state, tracer, fn_state);
        };
    }
    fn block_1500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1500_0: const #0u : u8
        let s_1500_0: bool = false;
        // D s_1500_1: write-var gs#403760 <= s_1500_0
        fn_state.gs_403760 = s_1500_0;
        // N s_1500_2: jump b1501
        return block_1501(state, tracer, fn_state);
    }
    fn block_1501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1501_0: read-var gs#403760:u8
        let s_1501_0: bool = fn_state.gs_403760;
        // D s_1501_1: not s_1501_0
        let s_1501_1: bool = !s_1501_0;
        // N s_1501_2: branch s_1501_1 b1538 b1502
        if s_1501_1 {
            return block_1538(state, tracer, fn_state);
        } else {
            return block_1502(state, tracer, fn_state);
        };
    }
    fn block_1502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1502_0: const #3896s : i
        let s_1502_0: i128 = 3896;
        // C s_1502_1: const #14696u : u32
        let s_1502_1: u32 = 14696;
        // N s_1502_2: write-reg s_1502_1 <= s_1502_0
        let s_1502_2: () = {
            state.write_register::<i128>(s_1502_1 as isize, s_1502_0);
            tracer.write_register(s_1502_1 as isize, s_1502_0);
        };
        // C s_1502_3: const #16s : i
        let s_1502_3: i128 = 16;
        // D s_1502_4: read-var u#32315:u32
        let s_1502_4: u32 = fn_state.u_32315;
        // D s_1502_5: cast zx s_1502_4 -> bv
        let s_1502_5: Bits = Bits::new(s_1502_4 as u128, 32u16);
        // C s_1502_6: const #1u : u64
        let s_1502_6: u64 = 1;
        // D s_1502_7: bit-extract s_1502_5 s_1502_3 s_1502_6
        let s_1502_7: Bits = (Bits::new(
            ((s_1502_5) >> (s_1502_3)).value(),
            u16::try_from(s_1502_6).unwrap(),
        ));
        // D s_1502_8: cast reint s_1502_7 -> u8
        let s_1502_8: bool = ((s_1502_7.value()) != 0);
        // C s_1502_9: const #0s : i
        let s_1502_9: i128 = 0;
        // C s_1502_10: const #0u : u64
        let s_1502_10: u64 = 0;
        // D s_1502_11: cast zx s_1502_8 -> u64
        let s_1502_11: u64 = (s_1502_8 as u64);
        // C s_1502_12: const #1u : u64
        let s_1502_12: u64 = 1;
        // D s_1502_13: and s_1502_11 s_1502_12
        let s_1502_13: u64 = ((s_1502_11) & (s_1502_12));
        // D s_1502_14: cmp-eq s_1502_13 s_1502_12
        let s_1502_14: bool = ((s_1502_13) == (s_1502_12));
        // D s_1502_15: lsl s_1502_11 s_1502_9
        let s_1502_15: u64 = s_1502_11 << s_1502_9;
        // D s_1502_16: or s_1502_10 s_1502_15
        let s_1502_16: u64 = ((s_1502_10) | (s_1502_15));
        // D s_1502_17: cmpl s_1502_15
        let s_1502_17: u64 = !s_1502_15;
        // D s_1502_18: and s_1502_10 s_1502_17
        let s_1502_18: u64 = ((s_1502_10) & (s_1502_17));
        // D s_1502_19: select s_1502_14 s_1502_16 s_1502_18
        let s_1502_19: u64 = if s_1502_14 { s_1502_16 } else { s_1502_18 };
        // D s_1502_20: cast trunc s_1502_19 -> u8
        let s_1502_20: bool = ((s_1502_19) != 0);
        // D s_1502_21: cast zx s_1502_20 -> bv
        let s_1502_21: Bits = Bits::new(s_1502_20 as u128, 1u16);
        // C s_1502_22: const #1u : u8
        let s_1502_22: bool = true;
        // C s_1502_23: cast zx s_1502_22 -> bv
        let s_1502_23: Bits = Bits::new(s_1502_22 as u128, 1u16);
        // D s_1502_24: cmp-ne s_1502_21 s_1502_23
        let s_1502_24: bool = ((s_1502_21) != (s_1502_23));
        // N s_1502_25: branch s_1502_24 b1537 b1503
        if s_1502_24 {
            return block_1537(state, tracer, fn_state);
        } else {
            return block_1503(state, tracer, fn_state);
        };
    }
    fn block_1503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1503_0: const #17s : i
        let s_1503_0: i128 = 17;
        // D s_1503_1: read-var u#32315:u32
        let s_1503_1: u32 = fn_state.u_32315;
        // D s_1503_2: cast zx s_1503_1 -> bv
        let s_1503_2: Bits = Bits::new(s_1503_1 as u128, 32u16);
        // C s_1503_3: const #1u : u64
        let s_1503_3: u64 = 1;
        // D s_1503_4: bit-extract s_1503_2 s_1503_0 s_1503_3
        let s_1503_4: Bits = (Bits::new(
            ((s_1503_2) >> (s_1503_0)).value(),
            u16::try_from(s_1503_3).unwrap(),
        ));
        // D s_1503_5: cast reint s_1503_4 -> u8
        let s_1503_5: bool = ((s_1503_4.value()) != 0);
        // C s_1503_6: const #0s : i
        let s_1503_6: i128 = 0;
        // C s_1503_7: const #0u : u64
        let s_1503_7: u64 = 0;
        // D s_1503_8: cast zx s_1503_5 -> u64
        let s_1503_8: u64 = (s_1503_5 as u64);
        // C s_1503_9: const #1u : u64
        let s_1503_9: u64 = 1;
        // D s_1503_10: and s_1503_8 s_1503_9
        let s_1503_10: u64 = ((s_1503_8) & (s_1503_9));
        // D s_1503_11: cmp-eq s_1503_10 s_1503_9
        let s_1503_11: bool = ((s_1503_10) == (s_1503_9));
        // D s_1503_12: lsl s_1503_8 s_1503_6
        let s_1503_12: u64 = s_1503_8 << s_1503_6;
        // D s_1503_13: or s_1503_7 s_1503_12
        let s_1503_13: u64 = ((s_1503_7) | (s_1503_12));
        // D s_1503_14: cmpl s_1503_12
        let s_1503_14: u64 = !s_1503_12;
        // D s_1503_15: and s_1503_7 s_1503_14
        let s_1503_15: u64 = ((s_1503_7) & (s_1503_14));
        // D s_1503_16: select s_1503_11 s_1503_13 s_1503_15
        let s_1503_16: u64 = if s_1503_11 { s_1503_13 } else { s_1503_15 };
        // D s_1503_17: cast trunc s_1503_16 -> u8
        let s_1503_17: bool = ((s_1503_16) != 0);
        // D s_1503_18: cast zx s_1503_17 -> bv
        let s_1503_18: Bits = Bits::new(s_1503_17 as u128, 1u16);
        // C s_1503_19: const #1u : u8
        let s_1503_19: bool = true;
        // C s_1503_20: cast zx s_1503_19 -> bv
        let s_1503_20: Bits = Bits::new(s_1503_19 as u128, 1u16);
        // D s_1503_21: cmp-ne s_1503_18 s_1503_20
        let s_1503_21: bool = ((s_1503_18) != (s_1503_20));
        // D s_1503_22: write-var gs#403767 <= s_1503_21
        fn_state.gs_403767 = s_1503_21;
        // N s_1503_23: jump b1504
        return block_1504(state, tracer, fn_state);
    }
    fn block_1504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1504_0: read-var gs#403767:u8
        let s_1504_0: bool = fn_state.gs_403767;
        // N s_1504_1: branch s_1504_0 b1536 b1505
        if s_1504_0 {
            return block_1536(state, tracer, fn_state);
        } else {
            return block_1505(state, tracer, fn_state);
        };
    }
    fn block_1505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1505_0: const #18s : i
        let s_1505_0: i128 = 18;
        // D s_1505_1: read-var u#32315:u32
        let s_1505_1: u32 = fn_state.u_32315;
        // D s_1505_2: cast zx s_1505_1 -> bv
        let s_1505_2: Bits = Bits::new(s_1505_1 as u128, 32u16);
        // C s_1505_3: const #1u : u64
        let s_1505_3: u64 = 1;
        // D s_1505_4: bit-extract s_1505_2 s_1505_0 s_1505_3
        let s_1505_4: Bits = (Bits::new(
            ((s_1505_2) >> (s_1505_0)).value(),
            u16::try_from(s_1505_3).unwrap(),
        ));
        // D s_1505_5: cast reint s_1505_4 -> u8
        let s_1505_5: bool = ((s_1505_4.value()) != 0);
        // C s_1505_6: const #0s : i
        let s_1505_6: i128 = 0;
        // C s_1505_7: const #0u : u64
        let s_1505_7: u64 = 0;
        // D s_1505_8: cast zx s_1505_5 -> u64
        let s_1505_8: u64 = (s_1505_5 as u64);
        // C s_1505_9: const #1u : u64
        let s_1505_9: u64 = 1;
        // D s_1505_10: and s_1505_8 s_1505_9
        let s_1505_10: u64 = ((s_1505_8) & (s_1505_9));
        // D s_1505_11: cmp-eq s_1505_10 s_1505_9
        let s_1505_11: bool = ((s_1505_10) == (s_1505_9));
        // D s_1505_12: lsl s_1505_8 s_1505_6
        let s_1505_12: u64 = s_1505_8 << s_1505_6;
        // D s_1505_13: or s_1505_7 s_1505_12
        let s_1505_13: u64 = ((s_1505_7) | (s_1505_12));
        // D s_1505_14: cmpl s_1505_12
        let s_1505_14: u64 = !s_1505_12;
        // D s_1505_15: and s_1505_7 s_1505_14
        let s_1505_15: u64 = ((s_1505_7) & (s_1505_14));
        // D s_1505_16: select s_1505_11 s_1505_13 s_1505_15
        let s_1505_16: u64 = if s_1505_11 { s_1505_13 } else { s_1505_15 };
        // D s_1505_17: cast trunc s_1505_16 -> u8
        let s_1505_17: bool = ((s_1505_16) != 0);
        // D s_1505_18: cast zx s_1505_17 -> bv
        let s_1505_18: Bits = Bits::new(s_1505_17 as u128, 1u16);
        // C s_1505_19: const #1u : u8
        let s_1505_19: bool = true;
        // C s_1505_20: cast zx s_1505_19 -> bv
        let s_1505_20: Bits = Bits::new(s_1505_19 as u128, 1u16);
        // D s_1505_21: cmp-ne s_1505_18 s_1505_20
        let s_1505_21: bool = ((s_1505_18) != (s_1505_20));
        // D s_1505_22: write-var gs#403770 <= s_1505_21
        fn_state.gs_403770 = s_1505_21;
        // N s_1505_23: jump b1506
        return block_1506(state, tracer, fn_state);
    }
    fn block_1506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1506_0: read-var gs#403770:u8
        let s_1506_0: bool = fn_state.gs_403770;
        // N s_1506_1: branch s_1506_0 b1535 b1507
        if s_1506_0 {
            return block_1535(state, tracer, fn_state);
        } else {
            return block_1507(state, tracer, fn_state);
        };
    }
    fn block_1507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1507_0: const #19s : i
        let s_1507_0: i128 = 19;
        // D s_1507_1: read-var u#32315:u32
        let s_1507_1: u32 = fn_state.u_32315;
        // D s_1507_2: cast zx s_1507_1 -> bv
        let s_1507_2: Bits = Bits::new(s_1507_1 as u128, 32u16);
        // C s_1507_3: const #1u : u64
        let s_1507_3: u64 = 1;
        // D s_1507_4: bit-extract s_1507_2 s_1507_0 s_1507_3
        let s_1507_4: Bits = (Bits::new(
            ((s_1507_2) >> (s_1507_0)).value(),
            u16::try_from(s_1507_3).unwrap(),
        ));
        // D s_1507_5: cast reint s_1507_4 -> u8
        let s_1507_5: bool = ((s_1507_4.value()) != 0);
        // C s_1507_6: const #0s : i
        let s_1507_6: i128 = 0;
        // C s_1507_7: const #0u : u64
        let s_1507_7: u64 = 0;
        // D s_1507_8: cast zx s_1507_5 -> u64
        let s_1507_8: u64 = (s_1507_5 as u64);
        // C s_1507_9: const #1u : u64
        let s_1507_9: u64 = 1;
        // D s_1507_10: and s_1507_8 s_1507_9
        let s_1507_10: u64 = ((s_1507_8) & (s_1507_9));
        // D s_1507_11: cmp-eq s_1507_10 s_1507_9
        let s_1507_11: bool = ((s_1507_10) == (s_1507_9));
        // D s_1507_12: lsl s_1507_8 s_1507_6
        let s_1507_12: u64 = s_1507_8 << s_1507_6;
        // D s_1507_13: or s_1507_7 s_1507_12
        let s_1507_13: u64 = ((s_1507_7) | (s_1507_12));
        // D s_1507_14: cmpl s_1507_12
        let s_1507_14: u64 = !s_1507_12;
        // D s_1507_15: and s_1507_7 s_1507_14
        let s_1507_15: u64 = ((s_1507_7) & (s_1507_14));
        // D s_1507_16: select s_1507_11 s_1507_13 s_1507_15
        let s_1507_16: u64 = if s_1507_11 { s_1507_13 } else { s_1507_15 };
        // D s_1507_17: cast trunc s_1507_16 -> u8
        let s_1507_17: bool = ((s_1507_16) != 0);
        // D s_1507_18: cast zx s_1507_17 -> bv
        let s_1507_18: Bits = Bits::new(s_1507_17 as u128, 1u16);
        // C s_1507_19: const #1u : u8
        let s_1507_19: bool = true;
        // C s_1507_20: cast zx s_1507_19 -> bv
        let s_1507_20: Bits = Bits::new(s_1507_19 as u128, 1u16);
        // D s_1507_21: cmp-ne s_1507_18 s_1507_20
        let s_1507_21: bool = ((s_1507_18) != (s_1507_20));
        // D s_1507_22: write-var gs#403773 <= s_1507_21
        fn_state.gs_403773 = s_1507_21;
        // N s_1507_23: jump b1508
        return block_1508(state, tracer, fn_state);
    }
    fn block_1508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1508_0: read-var gs#403773:u8
        let s_1508_0: bool = fn_state.gs_403773;
        // N s_1508_1: branch s_1508_0 b1534 b1509
        if s_1508_0 {
            return block_1534(state, tracer, fn_state);
        } else {
            return block_1509(state, tracer, fn_state);
        };
    }
    fn block_1509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1509_0: const #12s : i
        let s_1509_0: i128 = 12;
        // D s_1509_1: read-var u#32315:u32
        let s_1509_1: u32 = fn_state.u_32315;
        // D s_1509_2: cast zx s_1509_1 -> bv
        let s_1509_2: Bits = Bits::new(s_1509_1 as u128, 32u16);
        // C s_1509_3: const #1u : u64
        let s_1509_3: u64 = 1;
        // D s_1509_4: bit-extract s_1509_2 s_1509_0 s_1509_3
        let s_1509_4: Bits = (Bits::new(
            ((s_1509_2) >> (s_1509_0)).value(),
            u16::try_from(s_1509_3).unwrap(),
        ));
        // D s_1509_5: cast reint s_1509_4 -> u8
        let s_1509_5: bool = ((s_1509_4.value()) != 0);
        // C s_1509_6: const #0s : i
        let s_1509_6: i128 = 0;
        // C s_1509_7: const #0u : u64
        let s_1509_7: u64 = 0;
        // D s_1509_8: cast zx s_1509_5 -> u64
        let s_1509_8: u64 = (s_1509_5 as u64);
        // C s_1509_9: const #1u : u64
        let s_1509_9: u64 = 1;
        // D s_1509_10: and s_1509_8 s_1509_9
        let s_1509_10: u64 = ((s_1509_8) & (s_1509_9));
        // D s_1509_11: cmp-eq s_1509_10 s_1509_9
        let s_1509_11: bool = ((s_1509_10) == (s_1509_9));
        // D s_1509_12: lsl s_1509_8 s_1509_6
        let s_1509_12: u64 = s_1509_8 << s_1509_6;
        // D s_1509_13: or s_1509_7 s_1509_12
        let s_1509_13: u64 = ((s_1509_7) | (s_1509_12));
        // D s_1509_14: cmpl s_1509_12
        let s_1509_14: u64 = !s_1509_12;
        // D s_1509_15: and s_1509_7 s_1509_14
        let s_1509_15: u64 = ((s_1509_7) & (s_1509_14));
        // D s_1509_16: select s_1509_11 s_1509_13 s_1509_15
        let s_1509_16: u64 = if s_1509_11 { s_1509_13 } else { s_1509_15 };
        // D s_1509_17: cast trunc s_1509_16 -> u8
        let s_1509_17: bool = ((s_1509_16) != 0);
        // D s_1509_18: cast zx s_1509_17 -> bv
        let s_1509_18: Bits = Bits::new(s_1509_17 as u128, 1u16);
        // C s_1509_19: const #1u : u8
        let s_1509_19: bool = true;
        // C s_1509_20: cast zx s_1509_19 -> bv
        let s_1509_20: Bits = Bits::new(s_1509_19 as u128, 1u16);
        // D s_1509_21: cmp-ne s_1509_18 s_1509_20
        let s_1509_21: bool = ((s_1509_18) != (s_1509_20));
        // D s_1509_22: write-var gs#403776 <= s_1509_21
        fn_state.gs_403776 = s_1509_21;
        // N s_1509_23: jump b1510
        return block_1510(state, tracer, fn_state);
    }
    fn block_1510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1510_0: read-var gs#403776:u8
        let s_1510_0: bool = fn_state.gs_403776;
        // N s_1510_1: branch s_1510_0 b1533 b1511
        if s_1510_0 {
            return block_1533(state, tracer, fn_state);
        } else {
            return block_1511(state, tracer, fn_state);
        };
    }
    fn block_1511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1511_0: const #13s : i
        let s_1511_0: i128 = 13;
        // D s_1511_1: read-var u#32315:u32
        let s_1511_1: u32 = fn_state.u_32315;
        // D s_1511_2: cast zx s_1511_1 -> bv
        let s_1511_2: Bits = Bits::new(s_1511_1 as u128, 32u16);
        // C s_1511_3: const #1u : u64
        let s_1511_3: u64 = 1;
        // D s_1511_4: bit-extract s_1511_2 s_1511_0 s_1511_3
        let s_1511_4: Bits = (Bits::new(
            ((s_1511_2) >> (s_1511_0)).value(),
            u16::try_from(s_1511_3).unwrap(),
        ));
        // D s_1511_5: cast reint s_1511_4 -> u8
        let s_1511_5: bool = ((s_1511_4.value()) != 0);
        // C s_1511_6: const #0s : i
        let s_1511_6: i128 = 0;
        // C s_1511_7: const #0u : u64
        let s_1511_7: u64 = 0;
        // D s_1511_8: cast zx s_1511_5 -> u64
        let s_1511_8: u64 = (s_1511_5 as u64);
        // C s_1511_9: const #1u : u64
        let s_1511_9: u64 = 1;
        // D s_1511_10: and s_1511_8 s_1511_9
        let s_1511_10: u64 = ((s_1511_8) & (s_1511_9));
        // D s_1511_11: cmp-eq s_1511_10 s_1511_9
        let s_1511_11: bool = ((s_1511_10) == (s_1511_9));
        // D s_1511_12: lsl s_1511_8 s_1511_6
        let s_1511_12: u64 = s_1511_8 << s_1511_6;
        // D s_1511_13: or s_1511_7 s_1511_12
        let s_1511_13: u64 = ((s_1511_7) | (s_1511_12));
        // D s_1511_14: cmpl s_1511_12
        let s_1511_14: u64 = !s_1511_12;
        // D s_1511_15: and s_1511_7 s_1511_14
        let s_1511_15: u64 = ((s_1511_7) & (s_1511_14));
        // D s_1511_16: select s_1511_11 s_1511_13 s_1511_15
        let s_1511_16: u64 = if s_1511_11 { s_1511_13 } else { s_1511_15 };
        // D s_1511_17: cast trunc s_1511_16 -> u8
        let s_1511_17: bool = ((s_1511_16) != 0);
        // D s_1511_18: cast zx s_1511_17 -> bv
        let s_1511_18: Bits = Bits::new(s_1511_17 as u128, 1u16);
        // C s_1511_19: const #1u : u8
        let s_1511_19: bool = true;
        // C s_1511_20: cast zx s_1511_19 -> bv
        let s_1511_20: Bits = Bits::new(s_1511_19 as u128, 1u16);
        // D s_1511_21: cmp-ne s_1511_18 s_1511_20
        let s_1511_21: bool = ((s_1511_18) != (s_1511_20));
        // D s_1511_22: write-var gs#403779 <= s_1511_21
        fn_state.gs_403779 = s_1511_21;
        // N s_1511_23: jump b1512
        return block_1512(state, tracer, fn_state);
    }
    fn block_1512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1512_0: read-var gs#403779:u8
        let s_1512_0: bool = fn_state.gs_403779;
        // N s_1512_1: branch s_1512_0 b1532 b1513
        if s_1512_0 {
            return block_1532(state, tracer, fn_state);
        } else {
            return block_1513(state, tracer, fn_state);
        };
    }
    fn block_1513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1513_0: const #14s : i
        let s_1513_0: i128 = 14;
        // D s_1513_1: read-var u#32315:u32
        let s_1513_1: u32 = fn_state.u_32315;
        // D s_1513_2: cast zx s_1513_1 -> bv
        let s_1513_2: Bits = Bits::new(s_1513_1 as u128, 32u16);
        // C s_1513_3: const #1u : u64
        let s_1513_3: u64 = 1;
        // D s_1513_4: bit-extract s_1513_2 s_1513_0 s_1513_3
        let s_1513_4: Bits = (Bits::new(
            ((s_1513_2) >> (s_1513_0)).value(),
            u16::try_from(s_1513_3).unwrap(),
        ));
        // D s_1513_5: cast reint s_1513_4 -> u8
        let s_1513_5: bool = ((s_1513_4.value()) != 0);
        // C s_1513_6: const #0s : i
        let s_1513_6: i128 = 0;
        // C s_1513_7: const #0u : u64
        let s_1513_7: u64 = 0;
        // D s_1513_8: cast zx s_1513_5 -> u64
        let s_1513_8: u64 = (s_1513_5 as u64);
        // C s_1513_9: const #1u : u64
        let s_1513_9: u64 = 1;
        // D s_1513_10: and s_1513_8 s_1513_9
        let s_1513_10: u64 = ((s_1513_8) & (s_1513_9));
        // D s_1513_11: cmp-eq s_1513_10 s_1513_9
        let s_1513_11: bool = ((s_1513_10) == (s_1513_9));
        // D s_1513_12: lsl s_1513_8 s_1513_6
        let s_1513_12: u64 = s_1513_8 << s_1513_6;
        // D s_1513_13: or s_1513_7 s_1513_12
        let s_1513_13: u64 = ((s_1513_7) | (s_1513_12));
        // D s_1513_14: cmpl s_1513_12
        let s_1513_14: u64 = !s_1513_12;
        // D s_1513_15: and s_1513_7 s_1513_14
        let s_1513_15: u64 = ((s_1513_7) & (s_1513_14));
        // D s_1513_16: select s_1513_11 s_1513_13 s_1513_15
        let s_1513_16: u64 = if s_1513_11 { s_1513_13 } else { s_1513_15 };
        // D s_1513_17: cast trunc s_1513_16 -> u8
        let s_1513_17: bool = ((s_1513_16) != 0);
        // D s_1513_18: cast zx s_1513_17 -> bv
        let s_1513_18: Bits = Bits::new(s_1513_17 as u128, 1u16);
        // C s_1513_19: const #1u : u8
        let s_1513_19: bool = true;
        // C s_1513_20: cast zx s_1513_19 -> bv
        let s_1513_20: Bits = Bits::new(s_1513_19 as u128, 1u16);
        // D s_1513_21: cmp-ne s_1513_18 s_1513_20
        let s_1513_21: bool = ((s_1513_18) != (s_1513_20));
        // D s_1513_22: write-var gs#403782 <= s_1513_21
        fn_state.gs_403782 = s_1513_21;
        // N s_1513_23: jump b1514
        return block_1514(state, tracer, fn_state);
    }
    fn block_1514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1514_0: read-var gs#403782:u8
        let s_1514_0: bool = fn_state.gs_403782;
        // N s_1514_1: branch s_1514_0 b1531 b1515
        if s_1514_0 {
            return block_1531(state, tracer, fn_state);
        } else {
            return block_1515(state, tracer, fn_state);
        };
    }
    fn block_1515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1515_0: const #15s : i
        let s_1515_0: i128 = 15;
        // D s_1515_1: read-var u#32315:u32
        let s_1515_1: u32 = fn_state.u_32315;
        // D s_1515_2: cast zx s_1515_1 -> bv
        let s_1515_2: Bits = Bits::new(s_1515_1 as u128, 32u16);
        // C s_1515_3: const #1u : u64
        let s_1515_3: u64 = 1;
        // D s_1515_4: bit-extract s_1515_2 s_1515_0 s_1515_3
        let s_1515_4: Bits = (Bits::new(
            ((s_1515_2) >> (s_1515_0)).value(),
            u16::try_from(s_1515_3).unwrap(),
        ));
        // D s_1515_5: cast reint s_1515_4 -> u8
        let s_1515_5: bool = ((s_1515_4.value()) != 0);
        // C s_1515_6: const #0s : i
        let s_1515_6: i128 = 0;
        // C s_1515_7: const #0u : u64
        let s_1515_7: u64 = 0;
        // D s_1515_8: cast zx s_1515_5 -> u64
        let s_1515_8: u64 = (s_1515_5 as u64);
        // C s_1515_9: const #1u : u64
        let s_1515_9: u64 = 1;
        // D s_1515_10: and s_1515_8 s_1515_9
        let s_1515_10: u64 = ((s_1515_8) & (s_1515_9));
        // D s_1515_11: cmp-eq s_1515_10 s_1515_9
        let s_1515_11: bool = ((s_1515_10) == (s_1515_9));
        // D s_1515_12: lsl s_1515_8 s_1515_6
        let s_1515_12: u64 = s_1515_8 << s_1515_6;
        // D s_1515_13: or s_1515_7 s_1515_12
        let s_1515_13: u64 = ((s_1515_7) | (s_1515_12));
        // D s_1515_14: cmpl s_1515_12
        let s_1515_14: u64 = !s_1515_12;
        // D s_1515_15: and s_1515_7 s_1515_14
        let s_1515_15: u64 = ((s_1515_7) & (s_1515_14));
        // D s_1515_16: select s_1515_11 s_1515_13 s_1515_15
        let s_1515_16: u64 = if s_1515_11 { s_1515_13 } else { s_1515_15 };
        // D s_1515_17: cast trunc s_1515_16 -> u8
        let s_1515_17: bool = ((s_1515_16) != 0);
        // D s_1515_18: cast zx s_1515_17 -> bv
        let s_1515_18: Bits = Bits::new(s_1515_17 as u128, 1u16);
        // C s_1515_19: const #1u : u8
        let s_1515_19: bool = true;
        // C s_1515_20: cast zx s_1515_19 -> bv
        let s_1515_20: Bits = Bits::new(s_1515_19 as u128, 1u16);
        // D s_1515_21: cmp-ne s_1515_18 s_1515_20
        let s_1515_21: bool = ((s_1515_18) != (s_1515_20));
        // D s_1515_22: write-var gs#403785 <= s_1515_21
        fn_state.gs_403785 = s_1515_21;
        // N s_1515_23: jump b1516
        return block_1516(state, tracer, fn_state);
    }
    fn block_1516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1516_0: read-var gs#403785:u8
        let s_1516_0: bool = fn_state.gs_403785;
        // N s_1516_1: branch s_1516_0 b1530 b1517
        if s_1516_0 {
            return block_1530(state, tracer, fn_state);
        } else {
            return block_1517(state, tracer, fn_state);
        };
    }
    fn block_1517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1517_0: const #8s : i
        let s_1517_0: i128 = 8;
        // D s_1517_1: read-var u#32315:u32
        let s_1517_1: u32 = fn_state.u_32315;
        // D s_1517_2: cast zx s_1517_1 -> bv
        let s_1517_2: Bits = Bits::new(s_1517_1 as u128, 32u16);
        // C s_1517_3: const #1u : u64
        let s_1517_3: u64 = 1;
        // D s_1517_4: bit-extract s_1517_2 s_1517_0 s_1517_3
        let s_1517_4: Bits = (Bits::new(
            ((s_1517_2) >> (s_1517_0)).value(),
            u16::try_from(s_1517_3).unwrap(),
        ));
        // D s_1517_5: cast reint s_1517_4 -> u8
        let s_1517_5: bool = ((s_1517_4.value()) != 0);
        // C s_1517_6: const #0s : i
        let s_1517_6: i128 = 0;
        // C s_1517_7: const #0u : u64
        let s_1517_7: u64 = 0;
        // D s_1517_8: cast zx s_1517_5 -> u64
        let s_1517_8: u64 = (s_1517_5 as u64);
        // C s_1517_9: const #1u : u64
        let s_1517_9: u64 = 1;
        // D s_1517_10: and s_1517_8 s_1517_9
        let s_1517_10: u64 = ((s_1517_8) & (s_1517_9));
        // D s_1517_11: cmp-eq s_1517_10 s_1517_9
        let s_1517_11: bool = ((s_1517_10) == (s_1517_9));
        // D s_1517_12: lsl s_1517_8 s_1517_6
        let s_1517_12: u64 = s_1517_8 << s_1517_6;
        // D s_1517_13: or s_1517_7 s_1517_12
        let s_1517_13: u64 = ((s_1517_7) | (s_1517_12));
        // D s_1517_14: cmpl s_1517_12
        let s_1517_14: u64 = !s_1517_12;
        // D s_1517_15: and s_1517_7 s_1517_14
        let s_1517_15: u64 = ((s_1517_7) & (s_1517_14));
        // D s_1517_16: select s_1517_11 s_1517_13 s_1517_15
        let s_1517_16: u64 = if s_1517_11 { s_1517_13 } else { s_1517_15 };
        // D s_1517_17: cast trunc s_1517_16 -> u8
        let s_1517_17: bool = ((s_1517_16) != 0);
        // D s_1517_18: cast zx s_1517_17 -> bv
        let s_1517_18: Bits = Bits::new(s_1517_17 as u128, 1u16);
        // C s_1517_19: const #0u : u8
        let s_1517_19: bool = false;
        // C s_1517_20: cast zx s_1517_19 -> bv
        let s_1517_20: Bits = Bits::new(s_1517_19 as u128, 1u16);
        // D s_1517_21: cmp-ne s_1517_18 s_1517_20
        let s_1517_21: bool = ((s_1517_18) != (s_1517_20));
        // D s_1517_22: write-var gs#403788 <= s_1517_21
        fn_state.gs_403788 = s_1517_21;
        // N s_1517_23: jump b1518
        return block_1518(state, tracer, fn_state);
    }
    fn block_1518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1518_0: read-var gs#403788:u8
        let s_1518_0: bool = fn_state.gs_403788;
        // N s_1518_1: branch s_1518_0 b1529 b1519
        if s_1518_0 {
            return block_1529(state, tracer, fn_state);
        } else {
            return block_1519(state, tracer, fn_state);
        };
    }
    fn block_1519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1519_0: const #9s : i
        let s_1519_0: i128 = 9;
        // D s_1519_1: read-var u#32315:u32
        let s_1519_1: u32 = fn_state.u_32315;
        // D s_1519_2: cast zx s_1519_1 -> bv
        let s_1519_2: Bits = Bits::new(s_1519_1 as u128, 32u16);
        // C s_1519_3: const #1u : u64
        let s_1519_3: u64 = 1;
        // D s_1519_4: bit-extract s_1519_2 s_1519_0 s_1519_3
        let s_1519_4: Bits = (Bits::new(
            ((s_1519_2) >> (s_1519_0)).value(),
            u16::try_from(s_1519_3).unwrap(),
        ));
        // D s_1519_5: cast reint s_1519_4 -> u8
        let s_1519_5: bool = ((s_1519_4.value()) != 0);
        // C s_1519_6: const #0s : i
        let s_1519_6: i128 = 0;
        // C s_1519_7: const #0u : u64
        let s_1519_7: u64 = 0;
        // D s_1519_8: cast zx s_1519_5 -> u64
        let s_1519_8: u64 = (s_1519_5 as u64);
        // C s_1519_9: const #1u : u64
        let s_1519_9: u64 = 1;
        // D s_1519_10: and s_1519_8 s_1519_9
        let s_1519_10: u64 = ((s_1519_8) & (s_1519_9));
        // D s_1519_11: cmp-eq s_1519_10 s_1519_9
        let s_1519_11: bool = ((s_1519_10) == (s_1519_9));
        // D s_1519_12: lsl s_1519_8 s_1519_6
        let s_1519_12: u64 = s_1519_8 << s_1519_6;
        // D s_1519_13: or s_1519_7 s_1519_12
        let s_1519_13: u64 = ((s_1519_7) | (s_1519_12));
        // D s_1519_14: cmpl s_1519_12
        let s_1519_14: u64 = !s_1519_12;
        // D s_1519_15: and s_1519_7 s_1519_14
        let s_1519_15: u64 = ((s_1519_7) & (s_1519_14));
        // D s_1519_16: select s_1519_11 s_1519_13 s_1519_15
        let s_1519_16: u64 = if s_1519_11 { s_1519_13 } else { s_1519_15 };
        // D s_1519_17: cast trunc s_1519_16 -> u8
        let s_1519_17: bool = ((s_1519_16) != 0);
        // D s_1519_18: cast zx s_1519_17 -> bv
        let s_1519_18: Bits = Bits::new(s_1519_17 as u128, 1u16);
        // C s_1519_19: const #0u : u8
        let s_1519_19: bool = false;
        // C s_1519_20: cast zx s_1519_19 -> bv
        let s_1519_20: Bits = Bits::new(s_1519_19 as u128, 1u16);
        // D s_1519_21: cmp-ne s_1519_18 s_1519_20
        let s_1519_21: bool = ((s_1519_18) != (s_1519_20));
        // D s_1519_22: write-var gs#403791 <= s_1519_21
        fn_state.gs_403791 = s_1519_21;
        // N s_1519_23: jump b1520
        return block_1520(state, tracer, fn_state);
    }
    fn block_1520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1520_0: read-var gs#403791:u8
        let s_1520_0: bool = fn_state.gs_403791;
        // N s_1520_1: branch s_1520_0 b1528 b1521
        if s_1520_0 {
            return block_1528(state, tracer, fn_state);
        } else {
            return block_1521(state, tracer, fn_state);
        };
    }
    fn block_1521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1521_0: const #10s : i
        let s_1521_0: i128 = 10;
        // D s_1521_1: read-var u#32315:u32
        let s_1521_1: u32 = fn_state.u_32315;
        // D s_1521_2: cast zx s_1521_1 -> bv
        let s_1521_2: Bits = Bits::new(s_1521_1 as u128, 32u16);
        // C s_1521_3: const #1u : u64
        let s_1521_3: u64 = 1;
        // D s_1521_4: bit-extract s_1521_2 s_1521_0 s_1521_3
        let s_1521_4: Bits = (Bits::new(
            ((s_1521_2) >> (s_1521_0)).value(),
            u16::try_from(s_1521_3).unwrap(),
        ));
        // D s_1521_5: cast reint s_1521_4 -> u8
        let s_1521_5: bool = ((s_1521_4.value()) != 0);
        // C s_1521_6: const #0s : i
        let s_1521_6: i128 = 0;
        // C s_1521_7: const #0u : u64
        let s_1521_7: u64 = 0;
        // D s_1521_8: cast zx s_1521_5 -> u64
        let s_1521_8: u64 = (s_1521_5 as u64);
        // C s_1521_9: const #1u : u64
        let s_1521_9: u64 = 1;
        // D s_1521_10: and s_1521_8 s_1521_9
        let s_1521_10: u64 = ((s_1521_8) & (s_1521_9));
        // D s_1521_11: cmp-eq s_1521_10 s_1521_9
        let s_1521_11: bool = ((s_1521_10) == (s_1521_9));
        // D s_1521_12: lsl s_1521_8 s_1521_6
        let s_1521_12: u64 = s_1521_8 << s_1521_6;
        // D s_1521_13: or s_1521_7 s_1521_12
        let s_1521_13: u64 = ((s_1521_7) | (s_1521_12));
        // D s_1521_14: cmpl s_1521_12
        let s_1521_14: u64 = !s_1521_12;
        // D s_1521_15: and s_1521_7 s_1521_14
        let s_1521_15: u64 = ((s_1521_7) & (s_1521_14));
        // D s_1521_16: select s_1521_11 s_1521_13 s_1521_15
        let s_1521_16: u64 = if s_1521_11 { s_1521_13 } else { s_1521_15 };
        // D s_1521_17: cast trunc s_1521_16 -> u8
        let s_1521_17: bool = ((s_1521_16) != 0);
        // D s_1521_18: cast zx s_1521_17 -> bv
        let s_1521_18: Bits = Bits::new(s_1521_17 as u128, 1u16);
        // C s_1521_19: const #0u : u8
        let s_1521_19: bool = false;
        // C s_1521_20: cast zx s_1521_19 -> bv
        let s_1521_20: Bits = Bits::new(s_1521_19 as u128, 1u16);
        // D s_1521_21: cmp-ne s_1521_18 s_1521_20
        let s_1521_21: bool = ((s_1521_18) != (s_1521_20));
        // D s_1521_22: write-var gs#403794 <= s_1521_21
        fn_state.gs_403794 = s_1521_21;
        // N s_1521_23: jump b1522
        return block_1522(state, tracer, fn_state);
    }
    fn block_1522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1522_0: read-var gs#403794:u8
        let s_1522_0: bool = fn_state.gs_403794;
        // N s_1522_1: branch s_1522_0 b1527 b1523
        if s_1522_0 {
            return block_1527(state, tracer, fn_state);
        } else {
            return block_1523(state, tracer, fn_state);
        };
    }
    fn block_1523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1523_0: const #11s : i
        let s_1523_0: i128 = 11;
        // D s_1523_1: read-var u#32315:u32
        let s_1523_1: u32 = fn_state.u_32315;
        // D s_1523_2: cast zx s_1523_1 -> bv
        let s_1523_2: Bits = Bits::new(s_1523_1 as u128, 32u16);
        // C s_1523_3: const #1u : u64
        let s_1523_3: u64 = 1;
        // D s_1523_4: bit-extract s_1523_2 s_1523_0 s_1523_3
        let s_1523_4: Bits = (Bits::new(
            ((s_1523_2) >> (s_1523_0)).value(),
            u16::try_from(s_1523_3).unwrap(),
        ));
        // D s_1523_5: cast reint s_1523_4 -> u8
        let s_1523_5: bool = ((s_1523_4.value()) != 0);
        // C s_1523_6: const #0s : i
        let s_1523_6: i128 = 0;
        // C s_1523_7: const #0u : u64
        let s_1523_7: u64 = 0;
        // D s_1523_8: cast zx s_1523_5 -> u64
        let s_1523_8: u64 = (s_1523_5 as u64);
        // C s_1523_9: const #1u : u64
        let s_1523_9: u64 = 1;
        // D s_1523_10: and s_1523_8 s_1523_9
        let s_1523_10: u64 = ((s_1523_8) & (s_1523_9));
        // D s_1523_11: cmp-eq s_1523_10 s_1523_9
        let s_1523_11: bool = ((s_1523_10) == (s_1523_9));
        // D s_1523_12: lsl s_1523_8 s_1523_6
        let s_1523_12: u64 = s_1523_8 << s_1523_6;
        // D s_1523_13: or s_1523_7 s_1523_12
        let s_1523_13: u64 = ((s_1523_7) | (s_1523_12));
        // D s_1523_14: cmpl s_1523_12
        let s_1523_14: u64 = !s_1523_12;
        // D s_1523_15: and s_1523_7 s_1523_14
        let s_1523_15: u64 = ((s_1523_7) & (s_1523_14));
        // D s_1523_16: select s_1523_11 s_1523_13 s_1523_15
        let s_1523_16: u64 = if s_1523_11 { s_1523_13 } else { s_1523_15 };
        // D s_1523_17: cast trunc s_1523_16 -> u8
        let s_1523_17: bool = ((s_1523_16) != 0);
        // D s_1523_18: cast zx s_1523_17 -> bv
        let s_1523_18: Bits = Bits::new(s_1523_17 as u128, 1u16);
        // C s_1523_19: const #0u : u8
        let s_1523_19: bool = false;
        // C s_1523_20: cast zx s_1523_19 -> bv
        let s_1523_20: Bits = Bits::new(s_1523_19 as u128, 1u16);
        // D s_1523_21: cmp-ne s_1523_18 s_1523_20
        let s_1523_21: bool = ((s_1523_18) != (s_1523_20));
        // D s_1523_22: write-var gs#403797 <= s_1523_21
        fn_state.gs_403797 = s_1523_21;
        // N s_1523_23: jump b1524
        return block_1524(state, tracer, fn_state);
    }
    fn block_1524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1524_0: read-var gs#403797:u8
        let s_1524_0: bool = fn_state.gs_403797;
        // N s_1524_1: branch s_1524_0 b1526 b1525
        if s_1524_0 {
            return block_1526(state, tracer, fn_state);
        } else {
            return block_1525(state, tracer, fn_state);
        };
    }
    fn block_1525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1525_0: const #() : ()
        let s_1525_0: () = ();
        // S s_1525_1: call decode_aarch32_instrs_SSBB_A1enc_A_txt(s_1525_0)
        let s_1525_1: () = decode_aarch32_instrs_SSBB_A1enc_A_txt(
            state,
            tracer,
            s_1525_0,
        );
        // N s_1525_2: return
        return;
    }
    fn block_1526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1526_0: panic
        panic!("{:?}", ());
        // N s_1526_1: return
        return;
    }
    fn block_1527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1527_0: const #1u : u8
        let s_1527_0: bool = true;
        // D s_1527_1: write-var gs#403797 <= s_1527_0
        fn_state.gs_403797 = s_1527_0;
        // N s_1527_2: jump b1524
        return block_1524(state, tracer, fn_state);
    }
    fn block_1528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1528_0: const #1u : u8
        let s_1528_0: bool = true;
        // D s_1528_1: write-var gs#403794 <= s_1528_0
        fn_state.gs_403794 = s_1528_0;
        // N s_1528_2: jump b1522
        return block_1522(state, tracer, fn_state);
    }
    fn block_1529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1529_0: const #1u : u8
        let s_1529_0: bool = true;
        // D s_1529_1: write-var gs#403791 <= s_1529_0
        fn_state.gs_403791 = s_1529_0;
        // N s_1529_2: jump b1520
        return block_1520(state, tracer, fn_state);
    }
    fn block_1530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1530_0: const #1u : u8
        let s_1530_0: bool = true;
        // D s_1530_1: write-var gs#403788 <= s_1530_0
        fn_state.gs_403788 = s_1530_0;
        // N s_1530_2: jump b1518
        return block_1518(state, tracer, fn_state);
    }
    fn block_1531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1531_0: const #1u : u8
        let s_1531_0: bool = true;
        // D s_1531_1: write-var gs#403785 <= s_1531_0
        fn_state.gs_403785 = s_1531_0;
        // N s_1531_2: jump b1516
        return block_1516(state, tracer, fn_state);
    }
    fn block_1532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1532_0: const #1u : u8
        let s_1532_0: bool = true;
        // D s_1532_1: write-var gs#403782 <= s_1532_0
        fn_state.gs_403782 = s_1532_0;
        // N s_1532_2: jump b1514
        return block_1514(state, tracer, fn_state);
    }
    fn block_1533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1533_0: const #1u : u8
        let s_1533_0: bool = true;
        // D s_1533_1: write-var gs#403779 <= s_1533_0
        fn_state.gs_403779 = s_1533_0;
        // N s_1533_2: jump b1512
        return block_1512(state, tracer, fn_state);
    }
    fn block_1534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1534_0: const #1u : u8
        let s_1534_0: bool = true;
        // D s_1534_1: write-var gs#403776 <= s_1534_0
        fn_state.gs_403776 = s_1534_0;
        // N s_1534_2: jump b1510
        return block_1510(state, tracer, fn_state);
    }
    fn block_1535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1535_0: const #1u : u8
        let s_1535_0: bool = true;
        // D s_1535_1: write-var gs#403773 <= s_1535_0
        fn_state.gs_403773 = s_1535_0;
        // N s_1535_2: jump b1508
        return block_1508(state, tracer, fn_state);
    }
    fn block_1536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1536_0: const #1u : u8
        let s_1536_0: bool = true;
        // D s_1536_1: write-var gs#403770 <= s_1536_0
        fn_state.gs_403770 = s_1536_0;
        // N s_1536_2: jump b1506
        return block_1506(state, tracer, fn_state);
    }
    fn block_1537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1537_0: const #1u : u8
        let s_1537_0: bool = true;
        // D s_1537_1: write-var gs#403767 <= s_1537_0
        fn_state.gs_403767 = s_1537_0;
        // N s_1537_2: jump b1504
        return block_1504(state, tracer, fn_state);
    }
    fn block_1538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1538_0: read-var merge#var.1:struct
        let s_1538_0: u32 = fn_state.merge_var._1;
        // D s_1538_1: write-var u#32317 <= s_1538_0
        fn_state.u_32317 = s_1538_0;
        // D s_1538_2: read-var u#32317:u32
        let s_1538_2: u32 = fn_state.u_32317;
        // D s_1538_3: cast zx s_1538_2 -> bv
        let s_1538_3: Bits = Bits::new(s_1538_2 as u128, 32u16);
        // C s_1538_4: const #4118802500u : u32
        let s_1538_4: u32 = 4118802500;
        // C s_1538_5: cast zx s_1538_4 -> bv
        let s_1538_5: Bits = Bits::new(s_1538_4 as u128, 32u16);
        // D s_1538_6: cmp-eq s_1538_3 s_1538_5
        let s_1538_6: bool = ((s_1538_3) == (s_1538_5));
        // N s_1538_7: branch s_1538_6 b1592 b1539
        if s_1538_6 {
            return block_1592(state, tracer, fn_state);
        } else {
            return block_1539(state, tracer, fn_state);
        };
    }
    fn block_1539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1539_0: const #0u : u8
        let s_1539_0: bool = false;
        // D s_1539_1: write-var gs#403800 <= s_1539_0
        fn_state.gs_403800 = s_1539_0;
        // N s_1539_2: jump b1540
        return block_1540(state, tracer, fn_state);
    }
    fn block_1540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1540_0: read-var gs#403800:u8
        let s_1540_0: bool = fn_state.gs_403800;
        // D s_1540_1: not s_1540_0
        let s_1540_1: bool = !s_1540_0;
        // N s_1540_2: branch s_1540_1 b1577 b1541
        if s_1540_1 {
            return block_1577(state, tracer, fn_state);
        } else {
            return block_1541(state, tracer, fn_state);
        };
    }
    fn block_1541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1541_0: const #3898s : i
        let s_1541_0: i128 = 3898;
        // C s_1541_1: const #14696u : u32
        let s_1541_1: u32 = 14696;
        // N s_1541_2: write-reg s_1541_1 <= s_1541_0
        let s_1541_2: () = {
            state.write_register::<i128>(s_1541_1 as isize, s_1541_0);
            tracer.write_register(s_1541_1 as isize, s_1541_0);
        };
        // C s_1541_3: const #16s : i
        let s_1541_3: i128 = 16;
        // D s_1541_4: read-var u#32317:u32
        let s_1541_4: u32 = fn_state.u_32317;
        // D s_1541_5: cast zx s_1541_4 -> bv
        let s_1541_5: Bits = Bits::new(s_1541_4 as u128, 32u16);
        // C s_1541_6: const #1u : u64
        let s_1541_6: u64 = 1;
        // D s_1541_7: bit-extract s_1541_5 s_1541_3 s_1541_6
        let s_1541_7: Bits = (Bits::new(
            ((s_1541_5) >> (s_1541_3)).value(),
            u16::try_from(s_1541_6).unwrap(),
        ));
        // D s_1541_8: cast reint s_1541_7 -> u8
        let s_1541_8: bool = ((s_1541_7.value()) != 0);
        // C s_1541_9: const #0s : i
        let s_1541_9: i128 = 0;
        // C s_1541_10: const #0u : u64
        let s_1541_10: u64 = 0;
        // D s_1541_11: cast zx s_1541_8 -> u64
        let s_1541_11: u64 = (s_1541_8 as u64);
        // C s_1541_12: const #1u : u64
        let s_1541_12: u64 = 1;
        // D s_1541_13: and s_1541_11 s_1541_12
        let s_1541_13: u64 = ((s_1541_11) & (s_1541_12));
        // D s_1541_14: cmp-eq s_1541_13 s_1541_12
        let s_1541_14: bool = ((s_1541_13) == (s_1541_12));
        // D s_1541_15: lsl s_1541_11 s_1541_9
        let s_1541_15: u64 = s_1541_11 << s_1541_9;
        // D s_1541_16: or s_1541_10 s_1541_15
        let s_1541_16: u64 = ((s_1541_10) | (s_1541_15));
        // D s_1541_17: cmpl s_1541_15
        let s_1541_17: u64 = !s_1541_15;
        // D s_1541_18: and s_1541_10 s_1541_17
        let s_1541_18: u64 = ((s_1541_10) & (s_1541_17));
        // D s_1541_19: select s_1541_14 s_1541_16 s_1541_18
        let s_1541_19: u64 = if s_1541_14 { s_1541_16 } else { s_1541_18 };
        // D s_1541_20: cast trunc s_1541_19 -> u8
        let s_1541_20: bool = ((s_1541_19) != 0);
        // D s_1541_21: cast zx s_1541_20 -> bv
        let s_1541_21: Bits = Bits::new(s_1541_20 as u128, 1u16);
        // C s_1541_22: const #1u : u8
        let s_1541_22: bool = true;
        // C s_1541_23: cast zx s_1541_22 -> bv
        let s_1541_23: Bits = Bits::new(s_1541_22 as u128, 1u16);
        // D s_1541_24: cmp-ne s_1541_21 s_1541_23
        let s_1541_24: bool = ((s_1541_21) != (s_1541_23));
        // N s_1541_25: branch s_1541_24 b1576 b1542
        if s_1541_24 {
            return block_1576(state, tracer, fn_state);
        } else {
            return block_1542(state, tracer, fn_state);
        };
    }
    fn block_1542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1542_0: const #17s : i
        let s_1542_0: i128 = 17;
        // D s_1542_1: read-var u#32317:u32
        let s_1542_1: u32 = fn_state.u_32317;
        // D s_1542_2: cast zx s_1542_1 -> bv
        let s_1542_2: Bits = Bits::new(s_1542_1 as u128, 32u16);
        // C s_1542_3: const #1u : u64
        let s_1542_3: u64 = 1;
        // D s_1542_4: bit-extract s_1542_2 s_1542_0 s_1542_3
        let s_1542_4: Bits = (Bits::new(
            ((s_1542_2) >> (s_1542_0)).value(),
            u16::try_from(s_1542_3).unwrap(),
        ));
        // D s_1542_5: cast reint s_1542_4 -> u8
        let s_1542_5: bool = ((s_1542_4.value()) != 0);
        // C s_1542_6: const #0s : i
        let s_1542_6: i128 = 0;
        // C s_1542_7: const #0u : u64
        let s_1542_7: u64 = 0;
        // D s_1542_8: cast zx s_1542_5 -> u64
        let s_1542_8: u64 = (s_1542_5 as u64);
        // C s_1542_9: const #1u : u64
        let s_1542_9: u64 = 1;
        // D s_1542_10: and s_1542_8 s_1542_9
        let s_1542_10: u64 = ((s_1542_8) & (s_1542_9));
        // D s_1542_11: cmp-eq s_1542_10 s_1542_9
        let s_1542_11: bool = ((s_1542_10) == (s_1542_9));
        // D s_1542_12: lsl s_1542_8 s_1542_6
        let s_1542_12: u64 = s_1542_8 << s_1542_6;
        // D s_1542_13: or s_1542_7 s_1542_12
        let s_1542_13: u64 = ((s_1542_7) | (s_1542_12));
        // D s_1542_14: cmpl s_1542_12
        let s_1542_14: u64 = !s_1542_12;
        // D s_1542_15: and s_1542_7 s_1542_14
        let s_1542_15: u64 = ((s_1542_7) & (s_1542_14));
        // D s_1542_16: select s_1542_11 s_1542_13 s_1542_15
        let s_1542_16: u64 = if s_1542_11 { s_1542_13 } else { s_1542_15 };
        // D s_1542_17: cast trunc s_1542_16 -> u8
        let s_1542_17: bool = ((s_1542_16) != 0);
        // D s_1542_18: cast zx s_1542_17 -> bv
        let s_1542_18: Bits = Bits::new(s_1542_17 as u128, 1u16);
        // C s_1542_19: const #1u : u8
        let s_1542_19: bool = true;
        // C s_1542_20: cast zx s_1542_19 -> bv
        let s_1542_20: Bits = Bits::new(s_1542_19 as u128, 1u16);
        // D s_1542_21: cmp-ne s_1542_18 s_1542_20
        let s_1542_21: bool = ((s_1542_18) != (s_1542_20));
        // D s_1542_22: write-var gs#403807 <= s_1542_21
        fn_state.gs_403807 = s_1542_21;
        // N s_1542_23: jump b1543
        return block_1543(state, tracer, fn_state);
    }
    fn block_1543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1543_0: read-var gs#403807:u8
        let s_1543_0: bool = fn_state.gs_403807;
        // N s_1543_1: branch s_1543_0 b1575 b1544
        if s_1543_0 {
            return block_1575(state, tracer, fn_state);
        } else {
            return block_1544(state, tracer, fn_state);
        };
    }
    fn block_1544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1544_0: const #18s : i
        let s_1544_0: i128 = 18;
        // D s_1544_1: read-var u#32317:u32
        let s_1544_1: u32 = fn_state.u_32317;
        // D s_1544_2: cast zx s_1544_1 -> bv
        let s_1544_2: Bits = Bits::new(s_1544_1 as u128, 32u16);
        // C s_1544_3: const #1u : u64
        let s_1544_3: u64 = 1;
        // D s_1544_4: bit-extract s_1544_2 s_1544_0 s_1544_3
        let s_1544_4: Bits = (Bits::new(
            ((s_1544_2) >> (s_1544_0)).value(),
            u16::try_from(s_1544_3).unwrap(),
        ));
        // D s_1544_5: cast reint s_1544_4 -> u8
        let s_1544_5: bool = ((s_1544_4.value()) != 0);
        // C s_1544_6: const #0s : i
        let s_1544_6: i128 = 0;
        // C s_1544_7: const #0u : u64
        let s_1544_7: u64 = 0;
        // D s_1544_8: cast zx s_1544_5 -> u64
        let s_1544_8: u64 = (s_1544_5 as u64);
        // C s_1544_9: const #1u : u64
        let s_1544_9: u64 = 1;
        // D s_1544_10: and s_1544_8 s_1544_9
        let s_1544_10: u64 = ((s_1544_8) & (s_1544_9));
        // D s_1544_11: cmp-eq s_1544_10 s_1544_9
        let s_1544_11: bool = ((s_1544_10) == (s_1544_9));
        // D s_1544_12: lsl s_1544_8 s_1544_6
        let s_1544_12: u64 = s_1544_8 << s_1544_6;
        // D s_1544_13: or s_1544_7 s_1544_12
        let s_1544_13: u64 = ((s_1544_7) | (s_1544_12));
        // D s_1544_14: cmpl s_1544_12
        let s_1544_14: u64 = !s_1544_12;
        // D s_1544_15: and s_1544_7 s_1544_14
        let s_1544_15: u64 = ((s_1544_7) & (s_1544_14));
        // D s_1544_16: select s_1544_11 s_1544_13 s_1544_15
        let s_1544_16: u64 = if s_1544_11 { s_1544_13 } else { s_1544_15 };
        // D s_1544_17: cast trunc s_1544_16 -> u8
        let s_1544_17: bool = ((s_1544_16) != 0);
        // D s_1544_18: cast zx s_1544_17 -> bv
        let s_1544_18: Bits = Bits::new(s_1544_17 as u128, 1u16);
        // C s_1544_19: const #1u : u8
        let s_1544_19: bool = true;
        // C s_1544_20: cast zx s_1544_19 -> bv
        let s_1544_20: Bits = Bits::new(s_1544_19 as u128, 1u16);
        // D s_1544_21: cmp-ne s_1544_18 s_1544_20
        let s_1544_21: bool = ((s_1544_18) != (s_1544_20));
        // D s_1544_22: write-var gs#403810 <= s_1544_21
        fn_state.gs_403810 = s_1544_21;
        // N s_1544_23: jump b1545
        return block_1545(state, tracer, fn_state);
    }
    fn block_1545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1545_0: read-var gs#403810:u8
        let s_1545_0: bool = fn_state.gs_403810;
        // N s_1545_1: branch s_1545_0 b1574 b1546
        if s_1545_0 {
            return block_1574(state, tracer, fn_state);
        } else {
            return block_1546(state, tracer, fn_state);
        };
    }
    fn block_1546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1546_0: const #19s : i
        let s_1546_0: i128 = 19;
        // D s_1546_1: read-var u#32317:u32
        let s_1546_1: u32 = fn_state.u_32317;
        // D s_1546_2: cast zx s_1546_1 -> bv
        let s_1546_2: Bits = Bits::new(s_1546_1 as u128, 32u16);
        // C s_1546_3: const #1u : u64
        let s_1546_3: u64 = 1;
        // D s_1546_4: bit-extract s_1546_2 s_1546_0 s_1546_3
        let s_1546_4: Bits = (Bits::new(
            ((s_1546_2) >> (s_1546_0)).value(),
            u16::try_from(s_1546_3).unwrap(),
        ));
        // D s_1546_5: cast reint s_1546_4 -> u8
        let s_1546_5: bool = ((s_1546_4.value()) != 0);
        // C s_1546_6: const #0s : i
        let s_1546_6: i128 = 0;
        // C s_1546_7: const #0u : u64
        let s_1546_7: u64 = 0;
        // D s_1546_8: cast zx s_1546_5 -> u64
        let s_1546_8: u64 = (s_1546_5 as u64);
        // C s_1546_9: const #1u : u64
        let s_1546_9: u64 = 1;
        // D s_1546_10: and s_1546_8 s_1546_9
        let s_1546_10: u64 = ((s_1546_8) & (s_1546_9));
        // D s_1546_11: cmp-eq s_1546_10 s_1546_9
        let s_1546_11: bool = ((s_1546_10) == (s_1546_9));
        // D s_1546_12: lsl s_1546_8 s_1546_6
        let s_1546_12: u64 = s_1546_8 << s_1546_6;
        // D s_1546_13: or s_1546_7 s_1546_12
        let s_1546_13: u64 = ((s_1546_7) | (s_1546_12));
        // D s_1546_14: cmpl s_1546_12
        let s_1546_14: u64 = !s_1546_12;
        // D s_1546_15: and s_1546_7 s_1546_14
        let s_1546_15: u64 = ((s_1546_7) & (s_1546_14));
        // D s_1546_16: select s_1546_11 s_1546_13 s_1546_15
        let s_1546_16: u64 = if s_1546_11 { s_1546_13 } else { s_1546_15 };
        // D s_1546_17: cast trunc s_1546_16 -> u8
        let s_1546_17: bool = ((s_1546_16) != 0);
        // D s_1546_18: cast zx s_1546_17 -> bv
        let s_1546_18: Bits = Bits::new(s_1546_17 as u128, 1u16);
        // C s_1546_19: const #1u : u8
        let s_1546_19: bool = true;
        // C s_1546_20: cast zx s_1546_19 -> bv
        let s_1546_20: Bits = Bits::new(s_1546_19 as u128, 1u16);
        // D s_1546_21: cmp-ne s_1546_18 s_1546_20
        let s_1546_21: bool = ((s_1546_18) != (s_1546_20));
        // D s_1546_22: write-var gs#403813 <= s_1546_21
        fn_state.gs_403813 = s_1546_21;
        // N s_1546_23: jump b1547
        return block_1547(state, tracer, fn_state);
    }
    fn block_1547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1547_0: read-var gs#403813:u8
        let s_1547_0: bool = fn_state.gs_403813;
        // N s_1547_1: branch s_1547_0 b1573 b1548
        if s_1547_0 {
            return block_1573(state, tracer, fn_state);
        } else {
            return block_1548(state, tracer, fn_state);
        };
    }
    fn block_1548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1548_0: const #12s : i
        let s_1548_0: i128 = 12;
        // D s_1548_1: read-var u#32317:u32
        let s_1548_1: u32 = fn_state.u_32317;
        // D s_1548_2: cast zx s_1548_1 -> bv
        let s_1548_2: Bits = Bits::new(s_1548_1 as u128, 32u16);
        // C s_1548_3: const #1u : u64
        let s_1548_3: u64 = 1;
        // D s_1548_4: bit-extract s_1548_2 s_1548_0 s_1548_3
        let s_1548_4: Bits = (Bits::new(
            ((s_1548_2) >> (s_1548_0)).value(),
            u16::try_from(s_1548_3).unwrap(),
        ));
        // D s_1548_5: cast reint s_1548_4 -> u8
        let s_1548_5: bool = ((s_1548_4.value()) != 0);
        // C s_1548_6: const #0s : i
        let s_1548_6: i128 = 0;
        // C s_1548_7: const #0u : u64
        let s_1548_7: u64 = 0;
        // D s_1548_8: cast zx s_1548_5 -> u64
        let s_1548_8: u64 = (s_1548_5 as u64);
        // C s_1548_9: const #1u : u64
        let s_1548_9: u64 = 1;
        // D s_1548_10: and s_1548_8 s_1548_9
        let s_1548_10: u64 = ((s_1548_8) & (s_1548_9));
        // D s_1548_11: cmp-eq s_1548_10 s_1548_9
        let s_1548_11: bool = ((s_1548_10) == (s_1548_9));
        // D s_1548_12: lsl s_1548_8 s_1548_6
        let s_1548_12: u64 = s_1548_8 << s_1548_6;
        // D s_1548_13: or s_1548_7 s_1548_12
        let s_1548_13: u64 = ((s_1548_7) | (s_1548_12));
        // D s_1548_14: cmpl s_1548_12
        let s_1548_14: u64 = !s_1548_12;
        // D s_1548_15: and s_1548_7 s_1548_14
        let s_1548_15: u64 = ((s_1548_7) & (s_1548_14));
        // D s_1548_16: select s_1548_11 s_1548_13 s_1548_15
        let s_1548_16: u64 = if s_1548_11 { s_1548_13 } else { s_1548_15 };
        // D s_1548_17: cast trunc s_1548_16 -> u8
        let s_1548_17: bool = ((s_1548_16) != 0);
        // D s_1548_18: cast zx s_1548_17 -> bv
        let s_1548_18: Bits = Bits::new(s_1548_17 as u128, 1u16);
        // C s_1548_19: const #1u : u8
        let s_1548_19: bool = true;
        // C s_1548_20: cast zx s_1548_19 -> bv
        let s_1548_20: Bits = Bits::new(s_1548_19 as u128, 1u16);
        // D s_1548_21: cmp-ne s_1548_18 s_1548_20
        let s_1548_21: bool = ((s_1548_18) != (s_1548_20));
        // D s_1548_22: write-var gs#403816 <= s_1548_21
        fn_state.gs_403816 = s_1548_21;
        // N s_1548_23: jump b1549
        return block_1549(state, tracer, fn_state);
    }
    fn block_1549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1549_0: read-var gs#403816:u8
        let s_1549_0: bool = fn_state.gs_403816;
        // N s_1549_1: branch s_1549_0 b1572 b1550
        if s_1549_0 {
            return block_1572(state, tracer, fn_state);
        } else {
            return block_1550(state, tracer, fn_state);
        };
    }
    fn block_1550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1550_0: const #13s : i
        let s_1550_0: i128 = 13;
        // D s_1550_1: read-var u#32317:u32
        let s_1550_1: u32 = fn_state.u_32317;
        // D s_1550_2: cast zx s_1550_1 -> bv
        let s_1550_2: Bits = Bits::new(s_1550_1 as u128, 32u16);
        // C s_1550_3: const #1u : u64
        let s_1550_3: u64 = 1;
        // D s_1550_4: bit-extract s_1550_2 s_1550_0 s_1550_3
        let s_1550_4: Bits = (Bits::new(
            ((s_1550_2) >> (s_1550_0)).value(),
            u16::try_from(s_1550_3).unwrap(),
        ));
        // D s_1550_5: cast reint s_1550_4 -> u8
        let s_1550_5: bool = ((s_1550_4.value()) != 0);
        // C s_1550_6: const #0s : i
        let s_1550_6: i128 = 0;
        // C s_1550_7: const #0u : u64
        let s_1550_7: u64 = 0;
        // D s_1550_8: cast zx s_1550_5 -> u64
        let s_1550_8: u64 = (s_1550_5 as u64);
        // C s_1550_9: const #1u : u64
        let s_1550_9: u64 = 1;
        // D s_1550_10: and s_1550_8 s_1550_9
        let s_1550_10: u64 = ((s_1550_8) & (s_1550_9));
        // D s_1550_11: cmp-eq s_1550_10 s_1550_9
        let s_1550_11: bool = ((s_1550_10) == (s_1550_9));
        // D s_1550_12: lsl s_1550_8 s_1550_6
        let s_1550_12: u64 = s_1550_8 << s_1550_6;
        // D s_1550_13: or s_1550_7 s_1550_12
        let s_1550_13: u64 = ((s_1550_7) | (s_1550_12));
        // D s_1550_14: cmpl s_1550_12
        let s_1550_14: u64 = !s_1550_12;
        // D s_1550_15: and s_1550_7 s_1550_14
        let s_1550_15: u64 = ((s_1550_7) & (s_1550_14));
        // D s_1550_16: select s_1550_11 s_1550_13 s_1550_15
        let s_1550_16: u64 = if s_1550_11 { s_1550_13 } else { s_1550_15 };
        // D s_1550_17: cast trunc s_1550_16 -> u8
        let s_1550_17: bool = ((s_1550_16) != 0);
        // D s_1550_18: cast zx s_1550_17 -> bv
        let s_1550_18: Bits = Bits::new(s_1550_17 as u128, 1u16);
        // C s_1550_19: const #1u : u8
        let s_1550_19: bool = true;
        // C s_1550_20: cast zx s_1550_19 -> bv
        let s_1550_20: Bits = Bits::new(s_1550_19 as u128, 1u16);
        // D s_1550_21: cmp-ne s_1550_18 s_1550_20
        let s_1550_21: bool = ((s_1550_18) != (s_1550_20));
        // D s_1550_22: write-var gs#403819 <= s_1550_21
        fn_state.gs_403819 = s_1550_21;
        // N s_1550_23: jump b1551
        return block_1551(state, tracer, fn_state);
    }
    fn block_1551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1551_0: read-var gs#403819:u8
        let s_1551_0: bool = fn_state.gs_403819;
        // N s_1551_1: branch s_1551_0 b1571 b1552
        if s_1551_0 {
            return block_1571(state, tracer, fn_state);
        } else {
            return block_1552(state, tracer, fn_state);
        };
    }
    fn block_1552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1552_0: const #14s : i
        let s_1552_0: i128 = 14;
        // D s_1552_1: read-var u#32317:u32
        let s_1552_1: u32 = fn_state.u_32317;
        // D s_1552_2: cast zx s_1552_1 -> bv
        let s_1552_2: Bits = Bits::new(s_1552_1 as u128, 32u16);
        // C s_1552_3: const #1u : u64
        let s_1552_3: u64 = 1;
        // D s_1552_4: bit-extract s_1552_2 s_1552_0 s_1552_3
        let s_1552_4: Bits = (Bits::new(
            ((s_1552_2) >> (s_1552_0)).value(),
            u16::try_from(s_1552_3).unwrap(),
        ));
        // D s_1552_5: cast reint s_1552_4 -> u8
        let s_1552_5: bool = ((s_1552_4.value()) != 0);
        // C s_1552_6: const #0s : i
        let s_1552_6: i128 = 0;
        // C s_1552_7: const #0u : u64
        let s_1552_7: u64 = 0;
        // D s_1552_8: cast zx s_1552_5 -> u64
        let s_1552_8: u64 = (s_1552_5 as u64);
        // C s_1552_9: const #1u : u64
        let s_1552_9: u64 = 1;
        // D s_1552_10: and s_1552_8 s_1552_9
        let s_1552_10: u64 = ((s_1552_8) & (s_1552_9));
        // D s_1552_11: cmp-eq s_1552_10 s_1552_9
        let s_1552_11: bool = ((s_1552_10) == (s_1552_9));
        // D s_1552_12: lsl s_1552_8 s_1552_6
        let s_1552_12: u64 = s_1552_8 << s_1552_6;
        // D s_1552_13: or s_1552_7 s_1552_12
        let s_1552_13: u64 = ((s_1552_7) | (s_1552_12));
        // D s_1552_14: cmpl s_1552_12
        let s_1552_14: u64 = !s_1552_12;
        // D s_1552_15: and s_1552_7 s_1552_14
        let s_1552_15: u64 = ((s_1552_7) & (s_1552_14));
        // D s_1552_16: select s_1552_11 s_1552_13 s_1552_15
        let s_1552_16: u64 = if s_1552_11 { s_1552_13 } else { s_1552_15 };
        // D s_1552_17: cast trunc s_1552_16 -> u8
        let s_1552_17: bool = ((s_1552_16) != 0);
        // D s_1552_18: cast zx s_1552_17 -> bv
        let s_1552_18: Bits = Bits::new(s_1552_17 as u128, 1u16);
        // C s_1552_19: const #1u : u8
        let s_1552_19: bool = true;
        // C s_1552_20: cast zx s_1552_19 -> bv
        let s_1552_20: Bits = Bits::new(s_1552_19 as u128, 1u16);
        // D s_1552_21: cmp-ne s_1552_18 s_1552_20
        let s_1552_21: bool = ((s_1552_18) != (s_1552_20));
        // D s_1552_22: write-var gs#403822 <= s_1552_21
        fn_state.gs_403822 = s_1552_21;
        // N s_1552_23: jump b1553
        return block_1553(state, tracer, fn_state);
    }
    fn block_1553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1553_0: read-var gs#403822:u8
        let s_1553_0: bool = fn_state.gs_403822;
        // N s_1553_1: branch s_1553_0 b1570 b1554
        if s_1553_0 {
            return block_1570(state, tracer, fn_state);
        } else {
            return block_1554(state, tracer, fn_state);
        };
    }
    fn block_1554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1554_0: const #15s : i
        let s_1554_0: i128 = 15;
        // D s_1554_1: read-var u#32317:u32
        let s_1554_1: u32 = fn_state.u_32317;
        // D s_1554_2: cast zx s_1554_1 -> bv
        let s_1554_2: Bits = Bits::new(s_1554_1 as u128, 32u16);
        // C s_1554_3: const #1u : u64
        let s_1554_3: u64 = 1;
        // D s_1554_4: bit-extract s_1554_2 s_1554_0 s_1554_3
        let s_1554_4: Bits = (Bits::new(
            ((s_1554_2) >> (s_1554_0)).value(),
            u16::try_from(s_1554_3).unwrap(),
        ));
        // D s_1554_5: cast reint s_1554_4 -> u8
        let s_1554_5: bool = ((s_1554_4.value()) != 0);
        // C s_1554_6: const #0s : i
        let s_1554_6: i128 = 0;
        // C s_1554_7: const #0u : u64
        let s_1554_7: u64 = 0;
        // D s_1554_8: cast zx s_1554_5 -> u64
        let s_1554_8: u64 = (s_1554_5 as u64);
        // C s_1554_9: const #1u : u64
        let s_1554_9: u64 = 1;
        // D s_1554_10: and s_1554_8 s_1554_9
        let s_1554_10: u64 = ((s_1554_8) & (s_1554_9));
        // D s_1554_11: cmp-eq s_1554_10 s_1554_9
        let s_1554_11: bool = ((s_1554_10) == (s_1554_9));
        // D s_1554_12: lsl s_1554_8 s_1554_6
        let s_1554_12: u64 = s_1554_8 << s_1554_6;
        // D s_1554_13: or s_1554_7 s_1554_12
        let s_1554_13: u64 = ((s_1554_7) | (s_1554_12));
        // D s_1554_14: cmpl s_1554_12
        let s_1554_14: u64 = !s_1554_12;
        // D s_1554_15: and s_1554_7 s_1554_14
        let s_1554_15: u64 = ((s_1554_7) & (s_1554_14));
        // D s_1554_16: select s_1554_11 s_1554_13 s_1554_15
        let s_1554_16: u64 = if s_1554_11 { s_1554_13 } else { s_1554_15 };
        // D s_1554_17: cast trunc s_1554_16 -> u8
        let s_1554_17: bool = ((s_1554_16) != 0);
        // D s_1554_18: cast zx s_1554_17 -> bv
        let s_1554_18: Bits = Bits::new(s_1554_17 as u128, 1u16);
        // C s_1554_19: const #1u : u8
        let s_1554_19: bool = true;
        // C s_1554_20: cast zx s_1554_19 -> bv
        let s_1554_20: Bits = Bits::new(s_1554_19 as u128, 1u16);
        // D s_1554_21: cmp-ne s_1554_18 s_1554_20
        let s_1554_21: bool = ((s_1554_18) != (s_1554_20));
        // D s_1554_22: write-var gs#403825 <= s_1554_21
        fn_state.gs_403825 = s_1554_21;
        // N s_1554_23: jump b1555
        return block_1555(state, tracer, fn_state);
    }
    fn block_1555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1555_0: read-var gs#403825:u8
        let s_1555_0: bool = fn_state.gs_403825;
        // N s_1555_1: branch s_1555_0 b1569 b1556
        if s_1555_0 {
            return block_1569(state, tracer, fn_state);
        } else {
            return block_1556(state, tracer, fn_state);
        };
    }
    fn block_1556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1556_0: const #8s : i
        let s_1556_0: i128 = 8;
        // D s_1556_1: read-var u#32317:u32
        let s_1556_1: u32 = fn_state.u_32317;
        // D s_1556_2: cast zx s_1556_1 -> bv
        let s_1556_2: Bits = Bits::new(s_1556_1 as u128, 32u16);
        // C s_1556_3: const #1u : u64
        let s_1556_3: u64 = 1;
        // D s_1556_4: bit-extract s_1556_2 s_1556_0 s_1556_3
        let s_1556_4: Bits = (Bits::new(
            ((s_1556_2) >> (s_1556_0)).value(),
            u16::try_from(s_1556_3).unwrap(),
        ));
        // D s_1556_5: cast reint s_1556_4 -> u8
        let s_1556_5: bool = ((s_1556_4.value()) != 0);
        // C s_1556_6: const #0s : i
        let s_1556_6: i128 = 0;
        // C s_1556_7: const #0u : u64
        let s_1556_7: u64 = 0;
        // D s_1556_8: cast zx s_1556_5 -> u64
        let s_1556_8: u64 = (s_1556_5 as u64);
        // C s_1556_9: const #1u : u64
        let s_1556_9: u64 = 1;
        // D s_1556_10: and s_1556_8 s_1556_9
        let s_1556_10: u64 = ((s_1556_8) & (s_1556_9));
        // D s_1556_11: cmp-eq s_1556_10 s_1556_9
        let s_1556_11: bool = ((s_1556_10) == (s_1556_9));
        // D s_1556_12: lsl s_1556_8 s_1556_6
        let s_1556_12: u64 = s_1556_8 << s_1556_6;
        // D s_1556_13: or s_1556_7 s_1556_12
        let s_1556_13: u64 = ((s_1556_7) | (s_1556_12));
        // D s_1556_14: cmpl s_1556_12
        let s_1556_14: u64 = !s_1556_12;
        // D s_1556_15: and s_1556_7 s_1556_14
        let s_1556_15: u64 = ((s_1556_7) & (s_1556_14));
        // D s_1556_16: select s_1556_11 s_1556_13 s_1556_15
        let s_1556_16: u64 = if s_1556_11 { s_1556_13 } else { s_1556_15 };
        // D s_1556_17: cast trunc s_1556_16 -> u8
        let s_1556_17: bool = ((s_1556_16) != 0);
        // D s_1556_18: cast zx s_1556_17 -> bv
        let s_1556_18: Bits = Bits::new(s_1556_17 as u128, 1u16);
        // C s_1556_19: const #0u : u8
        let s_1556_19: bool = false;
        // C s_1556_20: cast zx s_1556_19 -> bv
        let s_1556_20: Bits = Bits::new(s_1556_19 as u128, 1u16);
        // D s_1556_21: cmp-ne s_1556_18 s_1556_20
        let s_1556_21: bool = ((s_1556_18) != (s_1556_20));
        // D s_1556_22: write-var gs#403828 <= s_1556_21
        fn_state.gs_403828 = s_1556_21;
        // N s_1556_23: jump b1557
        return block_1557(state, tracer, fn_state);
    }
    fn block_1557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1557_0: read-var gs#403828:u8
        let s_1557_0: bool = fn_state.gs_403828;
        // N s_1557_1: branch s_1557_0 b1568 b1558
        if s_1557_0 {
            return block_1568(state, tracer, fn_state);
        } else {
            return block_1558(state, tracer, fn_state);
        };
    }
    fn block_1558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1558_0: const #9s : i
        let s_1558_0: i128 = 9;
        // D s_1558_1: read-var u#32317:u32
        let s_1558_1: u32 = fn_state.u_32317;
        // D s_1558_2: cast zx s_1558_1 -> bv
        let s_1558_2: Bits = Bits::new(s_1558_1 as u128, 32u16);
        // C s_1558_3: const #1u : u64
        let s_1558_3: u64 = 1;
        // D s_1558_4: bit-extract s_1558_2 s_1558_0 s_1558_3
        let s_1558_4: Bits = (Bits::new(
            ((s_1558_2) >> (s_1558_0)).value(),
            u16::try_from(s_1558_3).unwrap(),
        ));
        // D s_1558_5: cast reint s_1558_4 -> u8
        let s_1558_5: bool = ((s_1558_4.value()) != 0);
        // C s_1558_6: const #0s : i
        let s_1558_6: i128 = 0;
        // C s_1558_7: const #0u : u64
        let s_1558_7: u64 = 0;
        // D s_1558_8: cast zx s_1558_5 -> u64
        let s_1558_8: u64 = (s_1558_5 as u64);
        // C s_1558_9: const #1u : u64
        let s_1558_9: u64 = 1;
        // D s_1558_10: and s_1558_8 s_1558_9
        let s_1558_10: u64 = ((s_1558_8) & (s_1558_9));
        // D s_1558_11: cmp-eq s_1558_10 s_1558_9
        let s_1558_11: bool = ((s_1558_10) == (s_1558_9));
        // D s_1558_12: lsl s_1558_8 s_1558_6
        let s_1558_12: u64 = s_1558_8 << s_1558_6;
        // D s_1558_13: or s_1558_7 s_1558_12
        let s_1558_13: u64 = ((s_1558_7) | (s_1558_12));
        // D s_1558_14: cmpl s_1558_12
        let s_1558_14: u64 = !s_1558_12;
        // D s_1558_15: and s_1558_7 s_1558_14
        let s_1558_15: u64 = ((s_1558_7) & (s_1558_14));
        // D s_1558_16: select s_1558_11 s_1558_13 s_1558_15
        let s_1558_16: u64 = if s_1558_11 { s_1558_13 } else { s_1558_15 };
        // D s_1558_17: cast trunc s_1558_16 -> u8
        let s_1558_17: bool = ((s_1558_16) != 0);
        // D s_1558_18: cast zx s_1558_17 -> bv
        let s_1558_18: Bits = Bits::new(s_1558_17 as u128, 1u16);
        // C s_1558_19: const #0u : u8
        let s_1558_19: bool = false;
        // C s_1558_20: cast zx s_1558_19 -> bv
        let s_1558_20: Bits = Bits::new(s_1558_19 as u128, 1u16);
        // D s_1558_21: cmp-ne s_1558_18 s_1558_20
        let s_1558_21: bool = ((s_1558_18) != (s_1558_20));
        // D s_1558_22: write-var gs#403831 <= s_1558_21
        fn_state.gs_403831 = s_1558_21;
        // N s_1558_23: jump b1559
        return block_1559(state, tracer, fn_state);
    }
    fn block_1559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1559_0: read-var gs#403831:u8
        let s_1559_0: bool = fn_state.gs_403831;
        // N s_1559_1: branch s_1559_0 b1567 b1560
        if s_1559_0 {
            return block_1567(state, tracer, fn_state);
        } else {
            return block_1560(state, tracer, fn_state);
        };
    }
    fn block_1560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1560_0: const #10s : i
        let s_1560_0: i128 = 10;
        // D s_1560_1: read-var u#32317:u32
        let s_1560_1: u32 = fn_state.u_32317;
        // D s_1560_2: cast zx s_1560_1 -> bv
        let s_1560_2: Bits = Bits::new(s_1560_1 as u128, 32u16);
        // C s_1560_3: const #1u : u64
        let s_1560_3: u64 = 1;
        // D s_1560_4: bit-extract s_1560_2 s_1560_0 s_1560_3
        let s_1560_4: Bits = (Bits::new(
            ((s_1560_2) >> (s_1560_0)).value(),
            u16::try_from(s_1560_3).unwrap(),
        ));
        // D s_1560_5: cast reint s_1560_4 -> u8
        let s_1560_5: bool = ((s_1560_4.value()) != 0);
        // C s_1560_6: const #0s : i
        let s_1560_6: i128 = 0;
        // C s_1560_7: const #0u : u64
        let s_1560_7: u64 = 0;
        // D s_1560_8: cast zx s_1560_5 -> u64
        let s_1560_8: u64 = (s_1560_5 as u64);
        // C s_1560_9: const #1u : u64
        let s_1560_9: u64 = 1;
        // D s_1560_10: and s_1560_8 s_1560_9
        let s_1560_10: u64 = ((s_1560_8) & (s_1560_9));
        // D s_1560_11: cmp-eq s_1560_10 s_1560_9
        let s_1560_11: bool = ((s_1560_10) == (s_1560_9));
        // D s_1560_12: lsl s_1560_8 s_1560_6
        let s_1560_12: u64 = s_1560_8 << s_1560_6;
        // D s_1560_13: or s_1560_7 s_1560_12
        let s_1560_13: u64 = ((s_1560_7) | (s_1560_12));
        // D s_1560_14: cmpl s_1560_12
        let s_1560_14: u64 = !s_1560_12;
        // D s_1560_15: and s_1560_7 s_1560_14
        let s_1560_15: u64 = ((s_1560_7) & (s_1560_14));
        // D s_1560_16: select s_1560_11 s_1560_13 s_1560_15
        let s_1560_16: u64 = if s_1560_11 { s_1560_13 } else { s_1560_15 };
        // D s_1560_17: cast trunc s_1560_16 -> u8
        let s_1560_17: bool = ((s_1560_16) != 0);
        // D s_1560_18: cast zx s_1560_17 -> bv
        let s_1560_18: Bits = Bits::new(s_1560_17 as u128, 1u16);
        // C s_1560_19: const #0u : u8
        let s_1560_19: bool = false;
        // C s_1560_20: cast zx s_1560_19 -> bv
        let s_1560_20: Bits = Bits::new(s_1560_19 as u128, 1u16);
        // D s_1560_21: cmp-ne s_1560_18 s_1560_20
        let s_1560_21: bool = ((s_1560_18) != (s_1560_20));
        // D s_1560_22: write-var gs#403834 <= s_1560_21
        fn_state.gs_403834 = s_1560_21;
        // N s_1560_23: jump b1561
        return block_1561(state, tracer, fn_state);
    }
    fn block_1561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1561_0: read-var gs#403834:u8
        let s_1561_0: bool = fn_state.gs_403834;
        // N s_1561_1: branch s_1561_0 b1566 b1562
        if s_1561_0 {
            return block_1566(state, tracer, fn_state);
        } else {
            return block_1562(state, tracer, fn_state);
        };
    }
    fn block_1562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1562_0: const #11s : i
        let s_1562_0: i128 = 11;
        // D s_1562_1: read-var u#32317:u32
        let s_1562_1: u32 = fn_state.u_32317;
        // D s_1562_2: cast zx s_1562_1 -> bv
        let s_1562_2: Bits = Bits::new(s_1562_1 as u128, 32u16);
        // C s_1562_3: const #1u : u64
        let s_1562_3: u64 = 1;
        // D s_1562_4: bit-extract s_1562_2 s_1562_0 s_1562_3
        let s_1562_4: Bits = (Bits::new(
            ((s_1562_2) >> (s_1562_0)).value(),
            u16::try_from(s_1562_3).unwrap(),
        ));
        // D s_1562_5: cast reint s_1562_4 -> u8
        let s_1562_5: bool = ((s_1562_4.value()) != 0);
        // C s_1562_6: const #0s : i
        let s_1562_6: i128 = 0;
        // C s_1562_7: const #0u : u64
        let s_1562_7: u64 = 0;
        // D s_1562_8: cast zx s_1562_5 -> u64
        let s_1562_8: u64 = (s_1562_5 as u64);
        // C s_1562_9: const #1u : u64
        let s_1562_9: u64 = 1;
        // D s_1562_10: and s_1562_8 s_1562_9
        let s_1562_10: u64 = ((s_1562_8) & (s_1562_9));
        // D s_1562_11: cmp-eq s_1562_10 s_1562_9
        let s_1562_11: bool = ((s_1562_10) == (s_1562_9));
        // D s_1562_12: lsl s_1562_8 s_1562_6
        let s_1562_12: u64 = s_1562_8 << s_1562_6;
        // D s_1562_13: or s_1562_7 s_1562_12
        let s_1562_13: u64 = ((s_1562_7) | (s_1562_12));
        // D s_1562_14: cmpl s_1562_12
        let s_1562_14: u64 = !s_1562_12;
        // D s_1562_15: and s_1562_7 s_1562_14
        let s_1562_15: u64 = ((s_1562_7) & (s_1562_14));
        // D s_1562_16: select s_1562_11 s_1562_13 s_1562_15
        let s_1562_16: u64 = if s_1562_11 { s_1562_13 } else { s_1562_15 };
        // D s_1562_17: cast trunc s_1562_16 -> u8
        let s_1562_17: bool = ((s_1562_16) != 0);
        // D s_1562_18: cast zx s_1562_17 -> bv
        let s_1562_18: Bits = Bits::new(s_1562_17 as u128, 1u16);
        // C s_1562_19: const #0u : u8
        let s_1562_19: bool = false;
        // C s_1562_20: cast zx s_1562_19 -> bv
        let s_1562_20: Bits = Bits::new(s_1562_19 as u128, 1u16);
        // D s_1562_21: cmp-ne s_1562_18 s_1562_20
        let s_1562_21: bool = ((s_1562_18) != (s_1562_20));
        // D s_1562_22: write-var gs#403837 <= s_1562_21
        fn_state.gs_403837 = s_1562_21;
        // N s_1562_23: jump b1563
        return block_1563(state, tracer, fn_state);
    }
    fn block_1563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1563_0: read-var gs#403837:u8
        let s_1563_0: bool = fn_state.gs_403837;
        // N s_1563_1: branch s_1563_0 b1565 b1564
        if s_1563_0 {
            return block_1565(state, tracer, fn_state);
        } else {
            return block_1564(state, tracer, fn_state);
        };
    }
    fn block_1564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1564_0: const #() : ()
        let s_1564_0: () = ();
        // S s_1564_1: call decode_aarch32_instrs_PSSBB_A1enc_A_txt(s_1564_0)
        let s_1564_1: () = decode_aarch32_instrs_PSSBB_A1enc_A_txt(
            state,
            tracer,
            s_1564_0,
        );
        // N s_1564_2: return
        return;
    }
    fn block_1565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1565_0: panic
        panic!("{:?}", ());
        // N s_1565_1: return
        return;
    }
    fn block_1566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1566_0: const #1u : u8
        let s_1566_0: bool = true;
        // D s_1566_1: write-var gs#403837 <= s_1566_0
        fn_state.gs_403837 = s_1566_0;
        // N s_1566_2: jump b1563
        return block_1563(state, tracer, fn_state);
    }
    fn block_1567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1567_0: const #1u : u8
        let s_1567_0: bool = true;
        // D s_1567_1: write-var gs#403834 <= s_1567_0
        fn_state.gs_403834 = s_1567_0;
        // N s_1567_2: jump b1561
        return block_1561(state, tracer, fn_state);
    }
    fn block_1568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1568_0: const #1u : u8
        let s_1568_0: bool = true;
        // D s_1568_1: write-var gs#403831 <= s_1568_0
        fn_state.gs_403831 = s_1568_0;
        // N s_1568_2: jump b1559
        return block_1559(state, tracer, fn_state);
    }
    fn block_1569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1569_0: const #1u : u8
        let s_1569_0: bool = true;
        // D s_1569_1: write-var gs#403828 <= s_1569_0
        fn_state.gs_403828 = s_1569_0;
        // N s_1569_2: jump b1557
        return block_1557(state, tracer, fn_state);
    }
    fn block_1570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1570_0: const #1u : u8
        let s_1570_0: bool = true;
        // D s_1570_1: write-var gs#403825 <= s_1570_0
        fn_state.gs_403825 = s_1570_0;
        // N s_1570_2: jump b1555
        return block_1555(state, tracer, fn_state);
    }
    fn block_1571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1571_0: const #1u : u8
        let s_1571_0: bool = true;
        // D s_1571_1: write-var gs#403822 <= s_1571_0
        fn_state.gs_403822 = s_1571_0;
        // N s_1571_2: jump b1553
        return block_1553(state, tracer, fn_state);
    }
    fn block_1572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1572_0: const #1u : u8
        let s_1572_0: bool = true;
        // D s_1572_1: write-var gs#403819 <= s_1572_0
        fn_state.gs_403819 = s_1572_0;
        // N s_1572_2: jump b1551
        return block_1551(state, tracer, fn_state);
    }
    fn block_1573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1573_0: const #1u : u8
        let s_1573_0: bool = true;
        // D s_1573_1: write-var gs#403816 <= s_1573_0
        fn_state.gs_403816 = s_1573_0;
        // N s_1573_2: jump b1549
        return block_1549(state, tracer, fn_state);
    }
    fn block_1574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1574_0: const #1u : u8
        let s_1574_0: bool = true;
        // D s_1574_1: write-var gs#403813 <= s_1574_0
        fn_state.gs_403813 = s_1574_0;
        // N s_1574_2: jump b1547
        return block_1547(state, tracer, fn_state);
    }
    fn block_1575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1575_0: const #1u : u8
        let s_1575_0: bool = true;
        // D s_1575_1: write-var gs#403810 <= s_1575_0
        fn_state.gs_403810 = s_1575_0;
        // N s_1575_2: jump b1545
        return block_1545(state, tracer, fn_state);
    }
    fn block_1576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1576_0: const #1u : u8
        let s_1576_0: bool = true;
        // D s_1576_1: write-var gs#403807 <= s_1576_0
        fn_state.gs_403807 = s_1576_0;
        // N s_1576_2: jump b1543
        return block_1543(state, tracer, fn_state);
    }
    fn block_1577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1577_0: read-var merge#var.1:struct
        let s_1577_0: u32 = fn_state.merge_var._1;
        // D s_1577_1: write-var u#32319 <= s_1577_0
        fn_state.u_32319 = s_1577_0;
        // C s_1577_2: const #23s : i
        let s_1577_2: i128 = 23;
        // D s_1577_3: read-var u#32319:u32
        let s_1577_3: u32 = fn_state.u_32319;
        // D s_1577_4: cast zx s_1577_3 -> bv
        let s_1577_4: Bits = Bits::new(s_1577_3 as u128, 32u16);
        // C s_1577_5: const #1s : i64
        let s_1577_5: i64 = 1;
        // C s_1577_6: cast zx s_1577_5 -> i
        let s_1577_6: i128 = (i128::try_from(s_1577_5).unwrap());
        // C s_1577_7: const #8s : i
        let s_1577_7: i128 = 8;
        // C s_1577_8: add s_1577_7 s_1577_6
        let s_1577_8: i128 = (s_1577_7 + s_1577_6);
        // D s_1577_9: bit-extract s_1577_4 s_1577_2 s_1577_8
        let s_1577_9: Bits = (Bits::new(
            ((s_1577_4) >> (s_1577_2)).value(),
            u16::try_from(s_1577_8).unwrap(),
        ));
        // D s_1577_10: cast reint s_1577_9 -> u9
        let s_1577_10: u16 = (s_1577_9.value() as u16);
        // D s_1577_11: cast zx s_1577_10 -> bv
        let s_1577_11: Bits = Bits::new(s_1577_10 as u128, 9u16);
        // C s_1577_12: const #487u : u9
        let s_1577_12: u16 = 487;
        // C s_1577_13: cast zx s_1577_12 -> bv
        let s_1577_13: Bits = Bits::new(s_1577_12 as u128, 9u16);
        // D s_1577_14: cmp-eq s_1577_11 s_1577_13
        let s_1577_14: bool = ((s_1577_11) == (s_1577_13));
        // N s_1577_15: branch s_1577_14 b1585 b1578
        if s_1577_14 {
            return block_1585(state, tracer, fn_state);
        } else {
            return block_1578(state, tracer, fn_state);
        };
    }
    fn block_1578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1578_0: const #0u : u8
        let s_1578_0: bool = false;
        // D s_1578_1: write-var gs#403849 <= s_1578_0
        fn_state.gs_403849 = s_1578_0;
        // N s_1578_2: jump b1579
        return block_1579(state, tracer, fn_state);
    }
    fn block_1579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1579_0: read-var gs#403849:u8
        let s_1579_0: bool = fn_state.gs_403849;
        // N s_1579_1: branch s_1579_0 b1584 b1580
        if s_1579_0 {
            return block_1584(state, tracer, fn_state);
        } else {
            return block_1580(state, tracer, fn_state);
        };
    }
    fn block_1580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1580_0: const #0u : u8
        let s_1580_0: bool = false;
        // D s_1580_1: write-var gs#403851 <= s_1580_0
        fn_state.gs_403851 = s_1580_0;
        // N s_1580_2: jump b1581
        return block_1581(state, tracer, fn_state);
    }
    fn block_1581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1581_0: read-var gs#403851:u8
        let s_1581_0: bool = fn_state.gs_403851;
        // D s_1581_1: not s_1581_0
        let s_1581_1: bool = !s_1581_0;
        // N s_1581_2: branch s_1581_1 b1583 b1582
        if s_1581_1 {
            return block_1583(state, tracer, fn_state);
        } else {
            return block_1582(state, tracer, fn_state);
        };
    }
    fn block_1582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1582_0: const #3922s : i
        let s_1582_0: i128 = 3922;
        // C s_1582_1: const #14696u : u32
        let s_1582_1: u32 = 14696;
        // N s_1582_2: write-reg s_1582_1 <= s_1582_0
        let s_1582_2: () = {
            state.write_register::<i128>(s_1582_1 as isize, s_1582_0);
            tracer.write_register(s_1582_1 as isize, s_1582_0);
        };
        // C s_1582_3: const #22s : i
        let s_1582_3: i128 = 22;
        // C s_1582_4: const #1s : i
        let s_1582_4: i128 = 1;
        // D s_1582_5: read-var u#32319:u32
        let s_1582_5: u32 = fn_state.u_32319;
        // D s_1582_6: cast zx s_1582_5 -> bv
        let s_1582_6: Bits = Bits::new(s_1582_5 as u128, 32u16);
        // D s_1582_7: bit-extract s_1582_6 s_1582_3 s_1582_4
        let s_1582_7: Bits = (Bits::new(
            ((s_1582_6) >> (s_1582_3)).value(),
            u16::try_from(s_1582_4).unwrap(),
        ));
        // D s_1582_8: cast reint s_1582_7 -> u8
        let s_1582_8: bool = ((s_1582_7.value()) != 0);
        // C s_1582_9: const #12s : i
        let s_1582_9: i128 = 12;
        // C s_1582_10: const #4s : i
        let s_1582_10: i128 = 4;
        // D s_1582_11: read-var u#32319:u32
        let s_1582_11: u32 = fn_state.u_32319;
        // D s_1582_12: cast zx s_1582_11 -> bv
        let s_1582_12: Bits = Bits::new(s_1582_11 as u128, 32u16);
        // D s_1582_13: bit-extract s_1582_12 s_1582_9 s_1582_10
        let s_1582_13: Bits = (Bits::new(
            ((s_1582_12) >> (s_1582_9)).value(),
            u16::try_from(s_1582_10).unwrap(),
        ));
        // D s_1582_14: cast reint s_1582_13 -> u8
        let s_1582_14: u8 = (s_1582_13.value() as u8);
        // C s_1582_15: const #5s : i
        let s_1582_15: i128 = 5;
        // C s_1582_16: const #1s : i
        let s_1582_16: i128 = 1;
        // D s_1582_17: read-var u#32319:u32
        let s_1582_17: u32 = fn_state.u_32319;
        // D s_1582_18: cast zx s_1582_17 -> bv
        let s_1582_18: Bits = Bits::new(s_1582_17 as u128, 32u16);
        // D s_1582_19: bit-extract s_1582_18 s_1582_15 s_1582_16
        let s_1582_19: Bits = (Bits::new(
            ((s_1582_18) >> (s_1582_15)).value(),
            u16::try_from(s_1582_16).unwrap(),
        ));
        // D s_1582_20: cast reint s_1582_19 -> u8
        let s_1582_20: bool = ((s_1582_19.value()) != 0);
        // C s_1582_21: const #0s : i
        let s_1582_21: i128 = 0;
        // C s_1582_22: const #4s : i
        let s_1582_22: i128 = 4;
        // D s_1582_23: read-var u#32319:u32
        let s_1582_23: u32 = fn_state.u_32319;
        // D s_1582_24: cast zx s_1582_23 -> bv
        let s_1582_24: Bits = Bits::new(s_1582_23 as u128, 32u16);
        // D s_1582_25: bit-extract s_1582_24 s_1582_21 s_1582_22
        let s_1582_25: Bits = (Bits::new(
            ((s_1582_24) >> (s_1582_21)).value(),
            u16::try_from(s_1582_22).unwrap(),
        ));
        // D s_1582_26: cast reint s_1582_25 -> u8
        let s_1582_26: u8 = (s_1582_25.value() as u8);
        // D s_1582_27: call decode_aarch32_instrs_VCVT_A1enc_A_txt(s_1582_8, s_1582_14, s_1582_20, s_1582_26)
        let s_1582_27: () = decode_aarch32_instrs_VCVT_A1enc_A_txt(
            state,
            tracer,
            s_1582_8,
            s_1582_14,
            s_1582_20,
            s_1582_26,
        );
        // N s_1582_28: return
        return;
    }
    fn block_1583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1583_0: panic
        panic!("{:?}", ());
        // N s_1583_1: return
        return;
    }
    fn block_1584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1584_0: const #3922s : i
        let s_1584_0: i128 = 3922;
        // C s_1584_1: const #14696u : u32
        let s_1584_1: u32 = 14696;
        // D s_1584_2: read-reg s_1584_1:i
        let s_1584_2: i128 = {
            let value = state.read_register::<i128>(s_1584_1 as isize);
            tracer.read_register(s_1584_1 as isize, value);
            value
        };
        // D s_1584_3: cmp-lt s_1584_2 s_1584_0
        let s_1584_3: bool = ((s_1584_2) < (s_1584_0));
        // D s_1584_4: write-var gs#403851 <= s_1584_3
        fn_state.gs_403851 = s_1584_3;
        // N s_1584_5: jump b1581
        return block_1581(state, tracer, fn_state);
    }
    fn block_1585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1585_0: const #16s : i
        let s_1585_0: i128 = 16;
        // D s_1585_1: read-var u#32319:u32
        let s_1585_1: u32 = fn_state.u_32319;
        // D s_1585_2: cast zx s_1585_1 -> bv
        let s_1585_2: Bits = Bits::new(s_1585_1 as u128, 32u16);
        // C s_1585_3: const #1s : i64
        let s_1585_3: i64 = 1;
        // C s_1585_4: cast zx s_1585_3 -> i
        let s_1585_4: i128 = (i128::try_from(s_1585_3).unwrap());
        // C s_1585_5: const #5s : i
        let s_1585_5: i128 = 5;
        // C s_1585_6: add s_1585_5 s_1585_4
        let s_1585_6: i128 = (s_1585_5 + s_1585_4);
        // D s_1585_7: bit-extract s_1585_2 s_1585_0 s_1585_6
        let s_1585_7: Bits = (Bits::new(
            ((s_1585_2) >> (s_1585_0)).value(),
            u16::try_from(s_1585_6).unwrap(),
        ));
        // D s_1585_8: cast reint s_1585_7 -> u8
        let s_1585_8: u8 = (s_1585_7.value() as u8);
        // D s_1585_9: cast zx s_1585_8 -> bv
        let s_1585_9: Bits = Bits::new(s_1585_8 as u128, 6u16);
        // C s_1585_10: const #54u : u8
        let s_1585_10: u8 = 54;
        // C s_1585_11: cast zx s_1585_10 -> bv
        let s_1585_11: Bits = Bits::new(s_1585_10 as u128, 6u16);
        // D s_1585_12: cmp-eq s_1585_9 s_1585_11
        let s_1585_12: bool = ((s_1585_9) == (s_1585_11));
        // N s_1585_13: branch s_1585_12 b1588 b1586
        if s_1585_12 {
            return block_1588(state, tracer, fn_state);
        } else {
            return block_1586(state, tracer, fn_state);
        };
    }
    fn block_1586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1586_0: const #0u : u8
        let s_1586_0: bool = false;
        // D s_1586_1: write-var gs#403848 <= s_1586_0
        fn_state.gs_403848 = s_1586_0;
        // N s_1586_2: jump b1587
        return block_1587(state, tracer, fn_state);
    }
    fn block_1587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1587_0: read-var gs#403848:u8
        let s_1587_0: bool = fn_state.gs_403848;
        // D s_1587_1: write-var gs#403849 <= s_1587_0
        fn_state.gs_403849 = s_1587_0;
        // N s_1587_2: jump b1579
        return block_1579(state, tracer, fn_state);
    }
    fn block_1588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1588_0: const #6s : i
        let s_1588_0: i128 = 6;
        // D s_1588_1: read-var u#32319:u32
        let s_1588_1: u32 = fn_state.u_32319;
        // D s_1588_2: cast zx s_1588_1 -> bv
        let s_1588_2: Bits = Bits::new(s_1588_1 as u128, 32u16);
        // C s_1588_3: const #1s : i64
        let s_1588_3: i64 = 1;
        // C s_1588_4: cast zx s_1588_3 -> i
        let s_1588_4: i128 = (i128::try_from(s_1588_3).unwrap());
        // C s_1588_5: const #5s : i
        let s_1588_5: i128 = 5;
        // C s_1588_6: add s_1588_5 s_1588_4
        let s_1588_6: i128 = (s_1588_5 + s_1588_4);
        // D s_1588_7: bit-extract s_1588_2 s_1588_0 s_1588_6
        let s_1588_7: Bits = (Bits::new(
            ((s_1588_2) >> (s_1588_0)).value(),
            u16::try_from(s_1588_6).unwrap(),
        ));
        // D s_1588_8: cast reint s_1588_7 -> u8
        let s_1588_8: u8 = (s_1588_7.value() as u8);
        // D s_1588_9: cast zx s_1588_8 -> bv
        let s_1588_9: Bits = Bits::new(s_1588_8 as u128, 6u16);
        // C s_1588_10: const #25u : u8
        let s_1588_10: u8 = 25;
        // C s_1588_11: cast zx s_1588_10 -> bv
        let s_1588_11: Bits = Bits::new(s_1588_10 as u128, 6u16);
        // D s_1588_12: cmp-eq s_1588_9 s_1588_11
        let s_1588_12: bool = ((s_1588_9) == (s_1588_11));
        // N s_1588_13: branch s_1588_12 b1591 b1589
        if s_1588_12 {
            return block_1591(state, tracer, fn_state);
        } else {
            return block_1589(state, tracer, fn_state);
        };
    }
    fn block_1589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1589_0: const #0u : u8
        let s_1589_0: bool = false;
        // D s_1589_1: write-var gs#403847 <= s_1589_0
        fn_state.gs_403847 = s_1589_0;
        // N s_1589_2: jump b1590
        return block_1590(state, tracer, fn_state);
    }
    fn block_1590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1590_0: read-var gs#403847:u8
        let s_1590_0: bool = fn_state.gs_403847;
        // D s_1590_1: write-var gs#403848 <= s_1590_0
        fn_state.gs_403848 = s_1590_0;
        // N s_1590_2: jump b1587
        return block_1587(state, tracer, fn_state);
    }
    fn block_1591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1591_0: const #4s : i
        let s_1591_0: i128 = 4;
        // D s_1591_1: read-var u#32319:u32
        let s_1591_1: u32 = fn_state.u_32319;
        // D s_1591_2: cast zx s_1591_1 -> bv
        let s_1591_2: Bits = Bits::new(s_1591_1 as u128, 32u16);
        // C s_1591_3: const #1s : i64
        let s_1591_3: i64 = 1;
        // C s_1591_4: cast zx s_1591_3 -> i
        let s_1591_4: i128 = (i128::try_from(s_1591_3).unwrap());
        // C s_1591_5: const #0s : i
        let s_1591_5: i128 = 0;
        // C s_1591_6: add s_1591_5 s_1591_4
        let s_1591_6: i128 = (s_1591_5 + s_1591_4);
        // D s_1591_7: bit-extract s_1591_2 s_1591_0 s_1591_6
        let s_1591_7: Bits = (Bits::new(
            ((s_1591_2) >> (s_1591_0)).value(),
            u16::try_from(s_1591_6).unwrap(),
        ));
        // D s_1591_8: cast reint s_1591_7 -> u8
        let s_1591_8: bool = ((s_1591_7.value()) != 0);
        // D s_1591_9: cast zx s_1591_8 -> bv
        let s_1591_9: Bits = Bits::new(s_1591_8 as u128, 1u16);
        // C s_1591_10: const #0u : u8
        let s_1591_10: bool = false;
        // C s_1591_11: cast zx s_1591_10 -> bv
        let s_1591_11: Bits = Bits::new(s_1591_10 as u128, 1u16);
        // D s_1591_12: cmp-eq s_1591_9 s_1591_11
        let s_1591_12: bool = ((s_1591_9) == (s_1591_11));
        // D s_1591_13: write-var gs#403847 <= s_1591_12
        fn_state.gs_403847 = s_1591_12;
        // N s_1591_14: jump b1590
        return block_1590(state, tracer, fn_state);
    }
    fn block_1592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1592_0: const #3898s : i
        let s_1592_0: i128 = 3898;
        // C s_1592_1: const #14696u : u32
        let s_1592_1: u32 = 14696;
        // D s_1592_2: read-reg s_1592_1:i
        let s_1592_2: i128 = {
            let value = state.read_register::<i128>(s_1592_1 as isize);
            tracer.read_register(s_1592_1 as isize, value);
            value
        };
        // D s_1592_3: cmp-lt s_1592_2 s_1592_0
        let s_1592_3: bool = ((s_1592_2) < (s_1592_0));
        // D s_1592_4: write-var gs#403800 <= s_1592_3
        fn_state.gs_403800 = s_1592_3;
        // N s_1592_5: jump b1540
        return block_1540(state, tracer, fn_state);
    }
    fn block_1593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1593_0: const #3896s : i
        let s_1593_0: i128 = 3896;
        // C s_1593_1: const #14696u : u32
        let s_1593_1: u32 = 14696;
        // D s_1593_2: read-reg s_1593_1:i
        let s_1593_2: i128 = {
            let value = state.read_register::<i128>(s_1593_1 as isize);
            tracer.read_register(s_1593_1 as isize, value);
            value
        };
        // D s_1593_3: cmp-lt s_1593_2 s_1593_0
        let s_1593_3: bool = ((s_1593_2) < (s_1593_0));
        // D s_1593_4: write-var gs#403760 <= s_1593_3
        fn_state.gs_403760 = s_1593_3;
        // N s_1593_5: jump b1501
        return block_1501(state, tracer, fn_state);
    }
    fn block_1594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1594_0: const #3888s : i
        let s_1594_0: i128 = 3888;
        // C s_1594_1: const #14696u : u32
        let s_1594_1: u32 = 14696;
        // D s_1594_2: read-reg s_1594_1:i
        let s_1594_2: i128 = {
            let value = state.read_register::<i128>(s_1594_1 as isize);
            tracer.read_register(s_1594_1 as isize, value);
            value
        };
        // D s_1594_3: cmp-lt s_1594_2 s_1594_0
        let s_1594_3: bool = ((s_1594_2) < (s_1594_0));
        // D s_1594_4: write-var gs#403709 <= s_1594_3
        fn_state.gs_403709 = s_1594_3;
        // N s_1594_5: jump b1453
        return block_1453(state, tracer, fn_state);
    }
    fn block_1595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1595_0: const #0s : i
        let s_1595_0: i128 = 0;
        // D s_1595_1: read-var u#32313:u32
        let s_1595_1: u32 = fn_state.u_32313;
        // D s_1595_2: cast zx s_1595_1 -> bv
        let s_1595_2: Bits = Bits::new(s_1595_1 as u128, 32u16);
        // C s_1595_3: const #1s : i64
        let s_1595_3: i64 = 1;
        // C s_1595_4: cast zx s_1595_3 -> i
        let s_1595_4: i128 = (i128::try_from(s_1595_3).unwrap());
        // C s_1595_5: const #8s : i
        let s_1595_5: i128 = 8;
        // C s_1595_6: add s_1595_5 s_1595_4
        let s_1595_6: i128 = (s_1595_5 + s_1595_4);
        // D s_1595_7: bit-extract s_1595_2 s_1595_0 s_1595_6
        let s_1595_7: Bits = (Bits::new(
            ((s_1595_2) >> (s_1595_0)).value(),
            u16::try_from(s_1595_6).unwrap(),
        ));
        // D s_1595_8: cast reint s_1595_7 -> u9
        let s_1595_8: u16 = (s_1595_7.value() as u16);
        // D s_1595_9: cast zx s_1595_8 -> bv
        let s_1595_9: Bits = Bits::new(s_1595_8 as u128, 9u16);
        // C s_1595_10: const #0u : u9
        let s_1595_10: u16 = 0;
        // C s_1595_11: cast zx s_1595_10 -> bv
        let s_1595_11: Bits = Bits::new(s_1595_10 as u128, 9u16);
        // D s_1595_12: cmp-eq s_1595_9 s_1595_11
        let s_1595_12: bool = ((s_1595_9) == (s_1595_11));
        // D s_1595_13: write-var gs#403707 <= s_1595_12
        fn_state.gs_403707 = s_1595_12;
        // N s_1595_14: jump b1451
        return block_1451(state, tracer, fn_state);
    }
    fn block_1596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1596_0: const #3882s : i
        let s_1596_0: i128 = 3882;
        // C s_1596_1: const #14696u : u32
        let s_1596_1: u32 = 14696;
        // D s_1596_2: read-reg s_1596_1:i
        let s_1596_2: i128 = {
            let value = state.read_register::<i128>(s_1596_1 as isize);
            tracer.read_register(s_1596_1 as isize, value);
            value
        };
        // D s_1596_3: cmp-lt s_1596_2 s_1596_0
        let s_1596_3: bool = ((s_1596_2) < (s_1596_0));
        // D s_1596_4: write-var gs#403687 <= s_1596_3
        fn_state.gs_403687 = s_1596_3;
        // N s_1596_5: jump b1447
        return block_1447(state, tracer, fn_state);
    }
    fn block_1597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1597_0: const #20s : i
        let s_1597_0: i128 = 20;
        // D s_1597_1: read-var u#32305:u32
        let s_1597_1: u32 = fn_state.u_32305;
        // D s_1597_2: cast zx s_1597_1 -> bv
        let s_1597_2: Bits = Bits::new(s_1597_1 as u128, 32u16);
        // C s_1597_3: const #1s : i64
        let s_1597_3: i64 = 1;
        // C s_1597_4: cast zx s_1597_3 -> i
        let s_1597_4: i128 = (i128::try_from(s_1597_3).unwrap());
        // C s_1597_5: const #1s : i
        let s_1597_5: i128 = 1;
        // C s_1597_6: add s_1597_5 s_1597_4
        let s_1597_6: i128 = (s_1597_5 + s_1597_4);
        // D s_1597_7: bit-extract s_1597_2 s_1597_0 s_1597_6
        let s_1597_7: Bits = (Bits::new(
            ((s_1597_2) >> (s_1597_0)).value(),
            u16::try_from(s_1597_6).unwrap(),
        ));
        // D s_1597_8: cast reint s_1597_7 -> u8
        let s_1597_8: u8 = (s_1597_7.value() as u8);
        // D s_1597_9: cast zx s_1597_8 -> bv
        let s_1597_9: Bits = Bits::new(s_1597_8 as u128, 2u16);
        // C s_1597_10: const #3u : u8
        let s_1597_10: u8 = 3;
        // C s_1597_11: cast zx s_1597_10 -> bv
        let s_1597_11: Bits = Bits::new(s_1597_10 as u128, 2u16);
        // D s_1597_12: cmp-eq s_1597_9 s_1597_11
        let s_1597_12: bool = ((s_1597_9) == (s_1597_11));
        // N s_1597_13: branch s_1597_12 b1600 b1598
        if s_1597_12 {
            return block_1600(state, tracer, fn_state);
        } else {
            return block_1598(state, tracer, fn_state);
        };
    }
    fn block_1598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1598_0: const #0u : u8
        let s_1598_0: bool = false;
        // D s_1598_1: write-var gs#403684 <= s_1598_0
        fn_state.gs_403684 = s_1598_0;
        // N s_1598_2: jump b1599
        return block_1599(state, tracer, fn_state);
    }
    fn block_1599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1599_0: read-var gs#403684:u8
        let s_1599_0: bool = fn_state.gs_403684;
        // D s_1599_1: write-var gs#403685 <= s_1599_0
        fn_state.gs_403685 = s_1599_0;
        // N s_1599_2: jump b1445
        return block_1445(state, tracer, fn_state);
    }
    fn block_1600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1600_0: const #16s : i
        let s_1600_0: i128 = 16;
        // D s_1600_1: read-var u#32305:u32
        let s_1600_1: u32 = fn_state.u_32305;
        // D s_1600_2: cast zx s_1600_1 -> bv
        let s_1600_2: Bits = Bits::new(s_1600_1 as u128, 32u16);
        // C s_1600_3: const #1s : i64
        let s_1600_3: i64 = 1;
        // C s_1600_4: cast zx s_1600_3 -> i
        let s_1600_4: i128 = (i128::try_from(s_1600_3).unwrap());
        // C s_1600_5: const #1s : i
        let s_1600_5: i128 = 1;
        // C s_1600_6: add s_1600_5 s_1600_4
        let s_1600_6: i128 = (s_1600_5 + s_1600_4);
        // D s_1600_7: bit-extract s_1600_2 s_1600_0 s_1600_6
        let s_1600_7: Bits = (Bits::new(
            ((s_1600_2) >> (s_1600_0)).value(),
            u16::try_from(s_1600_6).unwrap(),
        ));
        // D s_1600_8: cast reint s_1600_7 -> u8
        let s_1600_8: u8 = (s_1600_7.value() as u8);
        // D s_1600_9: cast zx s_1600_8 -> bv
        let s_1600_9: Bits = Bits::new(s_1600_8 as u128, 2u16);
        // C s_1600_10: const #2u : u8
        let s_1600_10: u8 = 2;
        // C s_1600_11: cast zx s_1600_10 -> bv
        let s_1600_11: Bits = Bits::new(s_1600_10 as u128, 2u16);
        // D s_1600_12: cmp-eq s_1600_9 s_1600_11
        let s_1600_12: bool = ((s_1600_9) == (s_1600_11));
        // N s_1600_13: branch s_1600_12 b1603 b1601
        if s_1600_12 {
            return block_1603(state, tracer, fn_state);
        } else {
            return block_1601(state, tracer, fn_state);
        };
    }
    fn block_1601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1601_0: const #0u : u8
        let s_1601_0: bool = false;
        // D s_1601_1: write-var gs#403683 <= s_1601_0
        fn_state.gs_403683 = s_1601_0;
        // N s_1601_2: jump b1602
        return block_1602(state, tracer, fn_state);
    }
    fn block_1602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1602_0: read-var gs#403683:u8
        let s_1602_0: bool = fn_state.gs_403683;
        // D s_1602_1: write-var gs#403684 <= s_1602_0
        fn_state.gs_403684 = s_1602_0;
        // N s_1602_2: jump b1599
        return block_1599(state, tracer, fn_state);
    }
    fn block_1603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1603_0: const #7s : i
        let s_1603_0: i128 = 7;
        // D s_1603_1: read-var u#32305:u32
        let s_1603_1: u32 = fn_state.u_32305;
        // D s_1603_2: cast zx s_1603_1 -> bv
        let s_1603_2: Bits = Bits::new(s_1603_1 as u128, 32u16);
        // C s_1603_3: const #1s : i64
        let s_1603_3: i64 = 1;
        // C s_1603_4: cast zx s_1603_3 -> i
        let s_1603_4: i128 = (i128::try_from(s_1603_3).unwrap());
        // C s_1603_5: const #4s : i
        let s_1603_5: i128 = 4;
        // C s_1603_6: add s_1603_5 s_1603_4
        let s_1603_6: i128 = (s_1603_5 + s_1603_4);
        // D s_1603_7: bit-extract s_1603_2 s_1603_0 s_1603_6
        let s_1603_7: Bits = (Bits::new(
            ((s_1603_2) >> (s_1603_0)).value(),
            u16::try_from(s_1603_6).unwrap(),
        ));
        // D s_1603_8: cast reint s_1603_7 -> u8
        let s_1603_8: u8 = (s_1603_7.value() as u8);
        // D s_1603_9: cast zx s_1603_8 -> bv
        let s_1603_9: Bits = Bits::new(s_1603_8 as u128, 5u16);
        // C s_1603_10: const #11u : u8
        let s_1603_10: u8 = 11;
        // C s_1603_11: cast zx s_1603_10 -> bv
        let s_1603_11: Bits = Bits::new(s_1603_10 as u128, 5u16);
        // D s_1603_12: cmp-eq s_1603_9 s_1603_11
        let s_1603_12: bool = ((s_1603_9) == (s_1603_11));
        // N s_1603_13: branch s_1603_12 b1606 b1604
        if s_1603_12 {
            return block_1606(state, tracer, fn_state);
        } else {
            return block_1604(state, tracer, fn_state);
        };
    }
    fn block_1604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1604_0: const #0u : u8
        let s_1604_0: bool = false;
        // D s_1604_1: write-var gs#403682 <= s_1604_0
        fn_state.gs_403682 = s_1604_0;
        // N s_1604_2: jump b1605
        return block_1605(state, tracer, fn_state);
    }
    fn block_1605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1605_0: read-var gs#403682:u8
        let s_1605_0: bool = fn_state.gs_403682;
        // D s_1605_1: write-var gs#403683 <= s_1605_0
        fn_state.gs_403683 = s_1605_0;
        // N s_1605_2: jump b1602
        return block_1602(state, tracer, fn_state);
    }
    fn block_1606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1606_0: const #4s : i
        let s_1606_0: i128 = 4;
        // D s_1606_1: read-var u#32305:u32
        let s_1606_1: u32 = fn_state.u_32305;
        // D s_1606_2: cast zx s_1606_1 -> bv
        let s_1606_2: Bits = Bits::new(s_1606_1 as u128, 32u16);
        // C s_1606_3: const #1s : i64
        let s_1606_3: i64 = 1;
        // C s_1606_4: cast zx s_1606_3 -> i
        let s_1606_4: i128 = (i128::try_from(s_1606_3).unwrap());
        // C s_1606_5: const #0s : i
        let s_1606_5: i128 = 0;
        // C s_1606_6: add s_1606_5 s_1606_4
        let s_1606_6: i128 = (s_1606_5 + s_1606_4);
        // D s_1606_7: bit-extract s_1606_2 s_1606_0 s_1606_6
        let s_1606_7: Bits = (Bits::new(
            ((s_1606_2) >> (s_1606_0)).value(),
            u16::try_from(s_1606_6).unwrap(),
        ));
        // D s_1606_8: cast reint s_1606_7 -> u8
        let s_1606_8: bool = ((s_1606_7.value()) != 0);
        // D s_1606_9: cast zx s_1606_8 -> bv
        let s_1606_9: Bits = Bits::new(s_1606_8 as u128, 1u16);
        // C s_1606_10: const #0u : u8
        let s_1606_10: bool = false;
        // C s_1606_11: cast zx s_1606_10 -> bv
        let s_1606_11: Bits = Bits::new(s_1606_10 as u128, 1u16);
        // D s_1606_12: cmp-eq s_1606_9 s_1606_11
        let s_1606_12: bool = ((s_1606_9) == (s_1606_11));
        // D s_1606_13: write-var gs#403682 <= s_1606_12
        fn_state.gs_403682 = s_1606_12;
        // N s_1606_14: jump b1605
        return block_1605(state, tracer, fn_state);
    }
    fn block_1607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1607_0: const #3878s : i
        let s_1607_0: i128 = 3878;
        // C s_1607_1: const #14696u : u32
        let s_1607_1: u32 = 14696;
        // D s_1607_2: read-reg s_1607_1:i
        let s_1607_2: i128 = {
            let value = state.read_register::<i128>(s_1607_1 as isize);
            tracer.read_register(s_1607_1 as isize, value);
            value
        };
        // D s_1607_3: cmp-lt s_1607_2 s_1607_0
        let s_1607_3: bool = ((s_1607_2) < (s_1607_0));
        // D s_1607_4: write-var gs#403656 <= s_1607_3
        fn_state.gs_403656 = s_1607_3;
        // N s_1607_5: jump b1441
        return block_1441(state, tracer, fn_state);
    }
    fn block_1608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1608_0: const #20s : i
        let s_1608_0: i128 = 20;
        // D s_1608_1: read-var u#32297:u32
        let s_1608_1: u32 = fn_state.u_32297;
        // D s_1608_2: cast zx s_1608_1 -> bv
        let s_1608_2: Bits = Bits::new(s_1608_1 as u128, 32u16);
        // C s_1608_3: const #1s : i64
        let s_1608_3: i64 = 1;
        // C s_1608_4: cast zx s_1608_3 -> i
        let s_1608_4: i128 = (i128::try_from(s_1608_3).unwrap());
        // C s_1608_5: const #1s : i
        let s_1608_5: i128 = 1;
        // C s_1608_6: add s_1608_5 s_1608_4
        let s_1608_6: i128 = (s_1608_5 + s_1608_4);
        // D s_1608_7: bit-extract s_1608_2 s_1608_0 s_1608_6
        let s_1608_7: Bits = (Bits::new(
            ((s_1608_2) >> (s_1608_0)).value(),
            u16::try_from(s_1608_6).unwrap(),
        ));
        // D s_1608_8: cast reint s_1608_7 -> u8
        let s_1608_8: u8 = (s_1608_7.value() as u8);
        // D s_1608_9: cast zx s_1608_8 -> bv
        let s_1608_9: Bits = Bits::new(s_1608_8 as u128, 2u16);
        // C s_1608_10: const #3u : u8
        let s_1608_10: u8 = 3;
        // C s_1608_11: cast zx s_1608_10 -> bv
        let s_1608_11: Bits = Bits::new(s_1608_10 as u128, 2u16);
        // D s_1608_12: cmp-eq s_1608_9 s_1608_11
        let s_1608_12: bool = ((s_1608_9) == (s_1608_11));
        // N s_1608_13: branch s_1608_12 b1611 b1609
        if s_1608_12 {
            return block_1611(state, tracer, fn_state);
        } else {
            return block_1609(state, tracer, fn_state);
        };
    }
    fn block_1609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1609_0: const #0u : u8
        let s_1609_0: bool = false;
        // D s_1609_1: write-var gs#403653 <= s_1609_0
        fn_state.gs_403653 = s_1609_0;
        // N s_1609_2: jump b1610
        return block_1610(state, tracer, fn_state);
    }
    fn block_1610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1610_0: read-var gs#403653:u8
        let s_1610_0: bool = fn_state.gs_403653;
        // D s_1610_1: write-var gs#403654 <= s_1610_0
        fn_state.gs_403654 = s_1610_0;
        // N s_1610_2: jump b1439
        return block_1439(state, tracer, fn_state);
    }
    fn block_1611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1611_0: const #16s : i
        let s_1611_0: i128 = 16;
        // D s_1611_1: read-var u#32297:u32
        let s_1611_1: u32 = fn_state.u_32297;
        // D s_1611_2: cast zx s_1611_1 -> bv
        let s_1611_2: Bits = Bits::new(s_1611_1 as u128, 32u16);
        // C s_1611_3: const #1s : i64
        let s_1611_3: i64 = 1;
        // C s_1611_4: cast zx s_1611_3 -> i
        let s_1611_4: i128 = (i128::try_from(s_1611_3).unwrap());
        // C s_1611_5: const #1s : i
        let s_1611_5: i128 = 1;
        // C s_1611_6: add s_1611_5 s_1611_4
        let s_1611_6: i128 = (s_1611_5 + s_1611_4);
        // D s_1611_7: bit-extract s_1611_2 s_1611_0 s_1611_6
        let s_1611_7: Bits = (Bits::new(
            ((s_1611_2) >> (s_1611_0)).value(),
            u16::try_from(s_1611_6).unwrap(),
        ));
        // D s_1611_8: cast reint s_1611_7 -> u8
        let s_1611_8: u8 = (s_1611_7.value() as u8);
        // D s_1611_9: cast zx s_1611_8 -> bv
        let s_1611_9: Bits = Bits::new(s_1611_8 as u128, 2u16);
        // C s_1611_10: const #2u : u8
        let s_1611_10: u8 = 2;
        // C s_1611_11: cast zx s_1611_10 -> bv
        let s_1611_11: Bits = Bits::new(s_1611_10 as u128, 2u16);
        // D s_1611_12: cmp-eq s_1611_9 s_1611_11
        let s_1611_12: bool = ((s_1611_9) == (s_1611_11));
        // N s_1611_13: branch s_1611_12 b1614 b1612
        if s_1611_12 {
            return block_1614(state, tracer, fn_state);
        } else {
            return block_1612(state, tracer, fn_state);
        };
    }
    fn block_1612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1612_0: const #0u : u8
        let s_1612_0: bool = false;
        // D s_1612_1: write-var gs#403652 <= s_1612_0
        fn_state.gs_403652 = s_1612_0;
        // N s_1612_2: jump b1613
        return block_1613(state, tracer, fn_state);
    }
    fn block_1613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1613_0: read-var gs#403652:u8
        let s_1613_0: bool = fn_state.gs_403652;
        // D s_1613_1: write-var gs#403653 <= s_1613_0
        fn_state.gs_403653 = s_1613_0;
        // N s_1613_2: jump b1610
        return block_1610(state, tracer, fn_state);
    }
    fn block_1614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1614_0: const #7s : i
        let s_1614_0: i128 = 7;
        // D s_1614_1: read-var u#32297:u32
        let s_1614_1: u32 = fn_state.u_32297;
        // D s_1614_2: cast zx s_1614_1 -> bv
        let s_1614_2: Bits = Bits::new(s_1614_1 as u128, 32u16);
        // C s_1614_3: const #1s : i64
        let s_1614_3: i64 = 1;
        // C s_1614_4: cast zx s_1614_3 -> i
        let s_1614_4: i128 = (i128::try_from(s_1614_3).unwrap());
        // C s_1614_5: const #4s : i
        let s_1614_5: i128 = 4;
        // C s_1614_6: add s_1614_5 s_1614_4
        let s_1614_6: i128 = (s_1614_5 + s_1614_4);
        // D s_1614_7: bit-extract s_1614_2 s_1614_0 s_1614_6
        let s_1614_7: Bits = (Bits::new(
            ((s_1614_2) >> (s_1614_0)).value(),
            u16::try_from(s_1614_6).unwrap(),
        ));
        // D s_1614_8: cast reint s_1614_7 -> u8
        let s_1614_8: u8 = (s_1614_7.value() as u8);
        // D s_1614_9: cast zx s_1614_8 -> bv
        let s_1614_9: Bits = Bits::new(s_1614_8 as u128, 5u16);
        // C s_1614_10: const #9u : u8
        let s_1614_10: u8 = 9;
        // C s_1614_11: cast zx s_1614_10 -> bv
        let s_1614_11: Bits = Bits::new(s_1614_10 as u128, 5u16);
        // D s_1614_12: cmp-eq s_1614_9 s_1614_11
        let s_1614_12: bool = ((s_1614_9) == (s_1614_11));
        // N s_1614_13: branch s_1614_12 b1617 b1615
        if s_1614_12 {
            return block_1617(state, tracer, fn_state);
        } else {
            return block_1615(state, tracer, fn_state);
        };
    }
    fn block_1615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1615_0: const #0u : u8
        let s_1615_0: bool = false;
        // D s_1615_1: write-var gs#403651 <= s_1615_0
        fn_state.gs_403651 = s_1615_0;
        // N s_1615_2: jump b1616
        return block_1616(state, tracer, fn_state);
    }
    fn block_1616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1616_0: read-var gs#403651:u8
        let s_1616_0: bool = fn_state.gs_403651;
        // D s_1616_1: write-var gs#403652 <= s_1616_0
        fn_state.gs_403652 = s_1616_0;
        // N s_1616_2: jump b1613
        return block_1613(state, tracer, fn_state);
    }
    fn block_1617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1617_0: const #4s : i
        let s_1617_0: i128 = 4;
        // D s_1617_1: read-var u#32297:u32
        let s_1617_1: u32 = fn_state.u_32297;
        // D s_1617_2: cast zx s_1617_1 -> bv
        let s_1617_2: Bits = Bits::new(s_1617_1 as u128, 32u16);
        // C s_1617_3: const #1s : i64
        let s_1617_3: i64 = 1;
        // C s_1617_4: cast zx s_1617_3 -> i
        let s_1617_4: i128 = (i128::try_from(s_1617_3).unwrap());
        // C s_1617_5: const #0s : i
        let s_1617_5: i128 = 0;
        // C s_1617_6: add s_1617_5 s_1617_4
        let s_1617_6: i128 = (s_1617_5 + s_1617_4);
        // D s_1617_7: bit-extract s_1617_2 s_1617_0 s_1617_6
        let s_1617_7: Bits = (Bits::new(
            ((s_1617_2) >> (s_1617_0)).value(),
            u16::try_from(s_1617_6).unwrap(),
        ));
        // D s_1617_8: cast reint s_1617_7 -> u8
        let s_1617_8: bool = ((s_1617_7.value()) != 0);
        // D s_1617_9: cast zx s_1617_8 -> bv
        let s_1617_9: Bits = Bits::new(s_1617_8 as u128, 1u16);
        // C s_1617_10: const #0u : u8
        let s_1617_10: bool = false;
        // C s_1617_11: cast zx s_1617_10 -> bv
        let s_1617_11: Bits = Bits::new(s_1617_10 as u128, 1u16);
        // D s_1617_12: cmp-eq s_1617_9 s_1617_11
        let s_1617_12: bool = ((s_1617_9) == (s_1617_11));
        // D s_1617_13: write-var gs#403651 <= s_1617_12
        fn_state.gs_403651 = s_1617_12;
        // N s_1617_14: jump b1616
        return block_1616(state, tracer, fn_state);
    }
    fn block_1618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1618_0: const #3874s : i
        let s_1618_0: i128 = 3874;
        // C s_1618_1: const #14696u : u32
        let s_1618_1: u32 = 14696;
        // D s_1618_2: read-reg s_1618_1:i
        let s_1618_2: i128 = {
            let value = state.read_register::<i128>(s_1618_1 as isize);
            tracer.read_register(s_1618_1 as isize, value);
            value
        };
        // D s_1618_3: cmp-lt s_1618_2 s_1618_0
        let s_1618_3: bool = ((s_1618_2) < (s_1618_0));
        // D s_1618_4: write-var gs#403623 <= s_1618_3
        fn_state.gs_403623 = s_1618_3;
        // N s_1618_5: jump b1435
        return block_1435(state, tracer, fn_state);
    }
    fn block_1619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1619_0: const #20s : i
        let s_1619_0: i128 = 20;
        // D s_1619_1: read-var u#32288:u32
        let s_1619_1: u32 = fn_state.u_32288;
        // D s_1619_2: cast zx s_1619_1 -> bv
        let s_1619_2: Bits = Bits::new(s_1619_1 as u128, 32u16);
        // C s_1619_3: const #1s : i64
        let s_1619_3: i64 = 1;
        // C s_1619_4: cast zx s_1619_3 -> i
        let s_1619_4: i128 = (i128::try_from(s_1619_3).unwrap());
        // C s_1619_5: const #1s : i
        let s_1619_5: i128 = 1;
        // C s_1619_6: add s_1619_5 s_1619_4
        let s_1619_6: i128 = (s_1619_5 + s_1619_4);
        // D s_1619_7: bit-extract s_1619_2 s_1619_0 s_1619_6
        let s_1619_7: Bits = (Bits::new(
            ((s_1619_2) >> (s_1619_0)).value(),
            u16::try_from(s_1619_6).unwrap(),
        ));
        // D s_1619_8: cast reint s_1619_7 -> u8
        let s_1619_8: u8 = (s_1619_7.value() as u8);
        // D s_1619_9: cast zx s_1619_8 -> bv
        let s_1619_9: Bits = Bits::new(s_1619_8 as u128, 2u16);
        // C s_1619_10: const #3u : u8
        let s_1619_10: u8 = 3;
        // C s_1619_11: cast zx s_1619_10 -> bv
        let s_1619_11: Bits = Bits::new(s_1619_10 as u128, 2u16);
        // D s_1619_12: cmp-eq s_1619_9 s_1619_11
        let s_1619_12: bool = ((s_1619_9) == (s_1619_11));
        // N s_1619_13: branch s_1619_12 b1622 b1620
        if s_1619_12 {
            return block_1622(state, tracer, fn_state);
        } else {
            return block_1620(state, tracer, fn_state);
        };
    }
    fn block_1620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1620_0: const #0u : u8
        let s_1620_0: bool = false;
        // D s_1620_1: write-var gs#403620 <= s_1620_0
        fn_state.gs_403620 = s_1620_0;
        // N s_1620_2: jump b1621
        return block_1621(state, tracer, fn_state);
    }
    fn block_1621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1621_0: read-var gs#403620:u8
        let s_1621_0: bool = fn_state.gs_403620;
        // D s_1621_1: write-var gs#403621 <= s_1621_0
        fn_state.gs_403621 = s_1621_0;
        // N s_1621_2: jump b1433
        return block_1433(state, tracer, fn_state);
    }
    fn block_1622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1622_0: const #16s : i
        let s_1622_0: i128 = 16;
        // D s_1622_1: read-var u#32288:u32
        let s_1622_1: u32 = fn_state.u_32288;
        // D s_1622_2: cast zx s_1622_1 -> bv
        let s_1622_2: Bits = Bits::new(s_1622_1 as u128, 32u16);
        // C s_1622_3: const #1s : i64
        let s_1622_3: i64 = 1;
        // C s_1622_4: cast zx s_1622_3 -> i
        let s_1622_4: i128 = (i128::try_from(s_1622_3).unwrap());
        // C s_1622_5: const #1s : i
        let s_1622_5: i128 = 1;
        // C s_1622_6: add s_1622_5 s_1622_4
        let s_1622_6: i128 = (s_1622_5 + s_1622_4);
        // D s_1622_7: bit-extract s_1622_2 s_1622_0 s_1622_6
        let s_1622_7: Bits = (Bits::new(
            ((s_1622_2) >> (s_1622_0)).value(),
            u16::try_from(s_1622_6).unwrap(),
        ));
        // D s_1622_8: cast reint s_1622_7 -> u8
        let s_1622_8: u8 = (s_1622_7.value() as u8);
        // D s_1622_9: cast zx s_1622_8 -> bv
        let s_1622_9: Bits = Bits::new(s_1622_8 as u128, 2u16);
        // C s_1622_10: const #2u : u8
        let s_1622_10: u8 = 2;
        // C s_1622_11: cast zx s_1622_10 -> bv
        let s_1622_11: Bits = Bits::new(s_1622_10 as u128, 2u16);
        // D s_1622_12: cmp-eq s_1622_9 s_1622_11
        let s_1622_12: bool = ((s_1622_9) == (s_1622_11));
        // N s_1622_13: branch s_1622_12 b1625 b1623
        if s_1622_12 {
            return block_1625(state, tracer, fn_state);
        } else {
            return block_1623(state, tracer, fn_state);
        };
    }
    fn block_1623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1623_0: const #0u : u8
        let s_1623_0: bool = false;
        // D s_1623_1: write-var gs#403619 <= s_1623_0
        fn_state.gs_403619 = s_1623_0;
        // N s_1623_2: jump b1624
        return block_1624(state, tracer, fn_state);
    }
    fn block_1624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1624_0: read-var gs#403619:u8
        let s_1624_0: bool = fn_state.gs_403619;
        // D s_1624_1: write-var gs#403620 <= s_1624_0
        fn_state.gs_403620 = s_1624_0;
        // N s_1624_2: jump b1621
        return block_1621(state, tracer, fn_state);
    }
    fn block_1625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1625_0: const #10s : i
        let s_1625_0: i128 = 10;
        // D s_1625_1: read-var u#32288:u32
        let s_1625_1: u32 = fn_state.u_32288;
        // D s_1625_2: cast zx s_1625_1 -> bv
        let s_1625_2: Bits = Bits::new(s_1625_1 as u128, 32u16);
        // C s_1625_3: const #1s : i64
        let s_1625_3: i64 = 1;
        // C s_1625_4: cast zx s_1625_3 -> i
        let s_1625_4: i128 = (i128::try_from(s_1625_3).unwrap());
        // C s_1625_5: const #1s : i
        let s_1625_5: i128 = 1;
        // C s_1625_6: add s_1625_5 s_1625_4
        let s_1625_6: i128 = (s_1625_5 + s_1625_4);
        // D s_1625_7: bit-extract s_1625_2 s_1625_0 s_1625_6
        let s_1625_7: Bits = (Bits::new(
            ((s_1625_2) >> (s_1625_0)).value(),
            u16::try_from(s_1625_6).unwrap(),
        ));
        // D s_1625_8: cast reint s_1625_7 -> u8
        let s_1625_8: u8 = (s_1625_7.value() as u8);
        // D s_1625_9: cast zx s_1625_8 -> bv
        let s_1625_9: Bits = Bits::new(s_1625_8 as u128, 2u16);
        // C s_1625_10: const #1u : u8
        let s_1625_10: u8 = 1;
        // C s_1625_11: cast zx s_1625_10 -> bv
        let s_1625_11: Bits = Bits::new(s_1625_10 as u128, 2u16);
        // D s_1625_12: cmp-eq s_1625_9 s_1625_11
        let s_1625_12: bool = ((s_1625_9) == (s_1625_11));
        // N s_1625_13: branch s_1625_12 b1628 b1626
        if s_1625_12 {
            return block_1628(state, tracer, fn_state);
        } else {
            return block_1626(state, tracer, fn_state);
        };
    }
    fn block_1626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1626_0: const #0u : u8
        let s_1626_0: bool = false;
        // D s_1626_1: write-var gs#403618 <= s_1626_0
        fn_state.gs_403618 = s_1626_0;
        // N s_1626_2: jump b1627
        return block_1627(state, tracer, fn_state);
    }
    fn block_1627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1627_0: read-var gs#403618:u8
        let s_1627_0: bool = fn_state.gs_403618;
        // D s_1627_1: write-var gs#403619 <= s_1627_0
        fn_state.gs_403619 = s_1627_0;
        // N s_1627_2: jump b1624
        return block_1624(state, tracer, fn_state);
    }
    fn block_1628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1628_0: const #4s : i
        let s_1628_0: i128 = 4;
        // D s_1628_1: read-var u#32288:u32
        let s_1628_1: u32 = fn_state.u_32288;
        // D s_1628_2: cast zx s_1628_1 -> bv
        let s_1628_2: Bits = Bits::new(s_1628_1 as u128, 32u16);
        // C s_1628_3: const #1s : i64
        let s_1628_3: i64 = 1;
        // C s_1628_4: cast zx s_1628_3 -> i
        let s_1628_4: i128 = (i128::try_from(s_1628_3).unwrap());
        // C s_1628_5: const #0s : i
        let s_1628_5: i128 = 0;
        // C s_1628_6: add s_1628_5 s_1628_4
        let s_1628_6: i128 = (s_1628_5 + s_1628_4);
        // D s_1628_7: bit-extract s_1628_2 s_1628_0 s_1628_6
        let s_1628_7: Bits = (Bits::new(
            ((s_1628_2) >> (s_1628_0)).value(),
            u16::try_from(s_1628_6).unwrap(),
        ));
        // D s_1628_8: cast reint s_1628_7 -> u8
        let s_1628_8: bool = ((s_1628_7.value()) != 0);
        // D s_1628_9: cast zx s_1628_8 -> bv
        let s_1628_9: Bits = Bits::new(s_1628_8 as u128, 1u16);
        // C s_1628_10: const #0u : u8
        let s_1628_10: bool = false;
        // C s_1628_11: cast zx s_1628_10 -> bv
        let s_1628_11: Bits = Bits::new(s_1628_10 as u128, 1u16);
        // D s_1628_12: cmp-eq s_1628_9 s_1628_11
        let s_1628_12: bool = ((s_1628_9) == (s_1628_11));
        // D s_1628_13: write-var gs#403618 <= s_1628_12
        fn_state.gs_403618 = s_1628_12;
        // N s_1628_14: jump b1627
        return block_1627(state, tracer, fn_state);
    }
    fn block_1629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1629_0: const #3870s : i
        let s_1629_0: i128 = 3870;
        // C s_1629_1: const #14696u : u32
        let s_1629_1: u32 = 14696;
        // D s_1629_2: read-reg s_1629_1:i
        let s_1629_2: i128 = {
            let value = state.read_register::<i128>(s_1629_1 as isize);
            tracer.read_register(s_1629_1 as isize, value);
            value
        };
        // D s_1629_3: cmp-lt s_1629_2 s_1629_0
        let s_1629_3: bool = ((s_1629_2) < (s_1629_0));
        // D s_1629_4: write-var gs#403586 <= s_1629_3
        fn_state.gs_403586 = s_1629_3;
        // N s_1629_5: jump b1429
        return block_1429(state, tracer, fn_state);
    }
    fn block_1630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1630_0: const #8s : i
        let s_1630_0: i128 = 8;
        // D s_1630_1: read-var u#32277:u32
        let s_1630_1: u32 = fn_state.u_32277;
        // D s_1630_2: cast zx s_1630_1 -> bv
        let s_1630_2: Bits = Bits::new(s_1630_1 as u128, 32u16);
        // C s_1630_3: const #1s : i64
        let s_1630_3: i64 = 1;
        // C s_1630_4: cast zx s_1630_3 -> i
        let s_1630_4: i128 = (i128::try_from(s_1630_3).unwrap());
        // C s_1630_5: const #3s : i
        let s_1630_5: i128 = 3;
        // C s_1630_6: add s_1630_5 s_1630_4
        let s_1630_6: i128 = (s_1630_5 + s_1630_4);
        // D s_1630_7: bit-extract s_1630_2 s_1630_0 s_1630_6
        let s_1630_7: Bits = (Bits::new(
            ((s_1630_2) >> (s_1630_0)).value(),
            u16::try_from(s_1630_6).unwrap(),
        ));
        // D s_1630_8: cast reint s_1630_7 -> u8
        let s_1630_8: u8 = (s_1630_7.value() as u8);
        // D s_1630_9: cast zx s_1630_8 -> bv
        let s_1630_9: Bits = Bits::new(s_1630_8 as u128, 4u16);
        // C s_1630_10: const #15u : u8
        let s_1630_10: u8 = 15;
        // C s_1630_11: cast zx s_1630_10 -> bv
        let s_1630_11: Bits = Bits::new(s_1630_10 as u128, 4u16);
        // D s_1630_12: cmp-eq s_1630_9 s_1630_11
        let s_1630_12: bool = ((s_1630_9) == (s_1630_11));
        // N s_1630_13: branch s_1630_12 b1633 b1631
        if s_1630_12 {
            return block_1633(state, tracer, fn_state);
        } else {
            return block_1631(state, tracer, fn_state);
        };
    }
    fn block_1631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1631_0: const #0u : u8
        let s_1631_0: bool = false;
        // D s_1631_1: write-var gs#403583 <= s_1631_0
        fn_state.gs_403583 = s_1631_0;
        // N s_1631_2: jump b1632
        return block_1632(state, tracer, fn_state);
    }
    fn block_1632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1632_0: read-var gs#403583:u8
        let s_1632_0: bool = fn_state.gs_403583;
        // D s_1632_1: write-var gs#403584 <= s_1632_0
        fn_state.gs_403584 = s_1632_0;
        // N s_1632_2: jump b1427
        return block_1427(state, tracer, fn_state);
    }
    fn block_1633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1633_0: const #4s : i
        let s_1633_0: i128 = 4;
        // D s_1633_1: read-var u#32277:u32
        let s_1633_1: u32 = fn_state.u_32277;
        // D s_1633_2: cast zx s_1633_1 -> bv
        let s_1633_2: Bits = Bits::new(s_1633_1 as u128, 32u16);
        // C s_1633_3: const #1s : i64
        let s_1633_3: i64 = 1;
        // C s_1633_4: cast zx s_1633_3 -> i
        let s_1633_4: i128 = (i128::try_from(s_1633_3).unwrap());
        // C s_1633_5: const #0s : i
        let s_1633_5: i128 = 0;
        // C s_1633_6: add s_1633_5 s_1633_4
        let s_1633_6: i128 = (s_1633_5 + s_1633_4);
        // D s_1633_7: bit-extract s_1633_2 s_1633_0 s_1633_6
        let s_1633_7: Bits = (Bits::new(
            ((s_1633_2) >> (s_1633_0)).value(),
            u16::try_from(s_1633_6).unwrap(),
        ));
        // D s_1633_8: cast reint s_1633_7 -> u8
        let s_1633_8: bool = ((s_1633_7.value()) != 0);
        // D s_1633_9: cast zx s_1633_8 -> bv
        let s_1633_9: Bits = Bits::new(s_1633_8 as u128, 1u16);
        // C s_1633_10: const #1u : u8
        let s_1633_10: bool = true;
        // C s_1633_11: cast zx s_1633_10 -> bv
        let s_1633_11: Bits = Bits::new(s_1633_10 as u128, 1u16);
        // D s_1633_12: cmp-eq s_1633_9 s_1633_11
        let s_1633_12: bool = ((s_1633_9) == (s_1633_11));
        // D s_1633_13: write-var gs#403583 <= s_1633_12
        fn_state.gs_403583 = s_1633_12;
        // N s_1633_14: jump b1632
        return block_1632(state, tracer, fn_state);
    }
    fn block_1634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1634_0: const #3866s : i
        let s_1634_0: i128 = 3866;
        // C s_1634_1: const #14696u : u32
        let s_1634_1: u32 = 14696;
        // D s_1634_2: read-reg s_1634_1:i
        let s_1634_2: i128 = {
            let value = state.read_register::<i128>(s_1634_1 as isize);
            tracer.read_register(s_1634_1 as isize, value);
            value
        };
        // D s_1634_3: cmp-lt s_1634_2 s_1634_0
        let s_1634_3: bool = ((s_1634_2) < (s_1634_0));
        // D s_1634_4: write-var gs#403557 <= s_1634_3
        fn_state.gs_403557 = s_1634_3;
        // N s_1634_5: jump b1423
        return block_1423(state, tracer, fn_state);
    }
    fn block_1635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1635_0: const #20s : i
        let s_1635_0: i128 = 20;
        // D s_1635_1: read-var u#32268:u32
        let s_1635_1: u32 = fn_state.u_32268;
        // D s_1635_2: cast zx s_1635_1 -> bv
        let s_1635_2: Bits = Bits::new(s_1635_1 as u128, 32u16);
        // C s_1635_3: const #1s : i64
        let s_1635_3: i64 = 1;
        // C s_1635_4: cast zx s_1635_3 -> i
        let s_1635_4: i128 = (i128::try_from(s_1635_3).unwrap());
        // C s_1635_5: const #1s : i
        let s_1635_5: i128 = 1;
        // C s_1635_6: add s_1635_5 s_1635_4
        let s_1635_6: i128 = (s_1635_5 + s_1635_4);
        // D s_1635_7: bit-extract s_1635_2 s_1635_0 s_1635_6
        let s_1635_7: Bits = (Bits::new(
            ((s_1635_2) >> (s_1635_0)).value(),
            u16::try_from(s_1635_6).unwrap(),
        ));
        // D s_1635_8: cast reint s_1635_7 -> u8
        let s_1635_8: u8 = (s_1635_7.value() as u8);
        // D s_1635_9: cast zx s_1635_8 -> bv
        let s_1635_9: Bits = Bits::new(s_1635_8 as u128, 2u16);
        // C s_1635_10: const #3u : u8
        let s_1635_10: u8 = 3;
        // C s_1635_11: cast zx s_1635_10 -> bv
        let s_1635_11: Bits = Bits::new(s_1635_10 as u128, 2u16);
        // D s_1635_12: cmp-eq s_1635_9 s_1635_11
        let s_1635_12: bool = ((s_1635_9) == (s_1635_11));
        // N s_1635_13: branch s_1635_12 b1638 b1636
        if s_1635_12 {
            return block_1638(state, tracer, fn_state);
        } else {
            return block_1636(state, tracer, fn_state);
        };
    }
    fn block_1636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1636_0: const #0u : u8
        let s_1636_0: bool = false;
        // D s_1636_1: write-var gs#403554 <= s_1636_0
        fn_state.gs_403554 = s_1636_0;
        // N s_1636_2: jump b1637
        return block_1637(state, tracer, fn_state);
    }
    fn block_1637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1637_0: read-var gs#403554:u8
        let s_1637_0: bool = fn_state.gs_403554;
        // D s_1637_1: write-var gs#403555 <= s_1637_0
        fn_state.gs_403555 = s_1637_0;
        // N s_1637_2: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_1638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1638_0: const #16s : i
        let s_1638_0: i128 = 16;
        // D s_1638_1: read-var u#32268:u32
        let s_1638_1: u32 = fn_state.u_32268;
        // D s_1638_2: cast zx s_1638_1 -> bv
        let s_1638_2: Bits = Bits::new(s_1638_1 as u128, 32u16);
        // C s_1638_3: const #1s : i64
        let s_1638_3: i64 = 1;
        // C s_1638_4: cast zx s_1638_3 -> i
        let s_1638_4: i128 = (i128::try_from(s_1638_3).unwrap());
        // C s_1638_5: const #1s : i
        let s_1638_5: i128 = 1;
        // C s_1638_6: add s_1638_5 s_1638_4
        let s_1638_6: i128 = (s_1638_5 + s_1638_4);
        // D s_1638_7: bit-extract s_1638_2 s_1638_0 s_1638_6
        let s_1638_7: Bits = (Bits::new(
            ((s_1638_2) >> (s_1638_0)).value(),
            u16::try_from(s_1638_6).unwrap(),
        ));
        // D s_1638_8: cast reint s_1638_7 -> u8
        let s_1638_8: u8 = (s_1638_7.value() as u8);
        // D s_1638_9: cast zx s_1638_8 -> bv
        let s_1638_9: Bits = Bits::new(s_1638_8 as u128, 2u16);
        // C s_1638_10: const #3u : u8
        let s_1638_10: u8 = 3;
        // C s_1638_11: cast zx s_1638_10 -> bv
        let s_1638_11: Bits = Bits::new(s_1638_10 as u128, 2u16);
        // D s_1638_12: cmp-eq s_1638_9 s_1638_11
        let s_1638_12: bool = ((s_1638_9) == (s_1638_11));
        // N s_1638_13: branch s_1638_12 b1641 b1639
        if s_1638_12 {
            return block_1641(state, tracer, fn_state);
        } else {
            return block_1639(state, tracer, fn_state);
        };
    }
    fn block_1639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1639_0: const #0u : u8
        let s_1639_0: bool = false;
        // D s_1639_1: write-var gs#403553 <= s_1639_0
        fn_state.gs_403553 = s_1639_0;
        // N s_1639_2: jump b1640
        return block_1640(state, tracer, fn_state);
    }
    fn block_1640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1640_0: read-var gs#403553:u8
        let s_1640_0: bool = fn_state.gs_403553;
        // D s_1640_1: write-var gs#403554 <= s_1640_0
        fn_state.gs_403554 = s_1640_0;
        // N s_1640_2: jump b1637
        return block_1637(state, tracer, fn_state);
    }
    fn block_1641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1641_0: const #10s : i
        let s_1641_0: i128 = 10;
        // D s_1641_1: read-var u#32268:u32
        let s_1641_1: u32 = fn_state.u_32268;
        // D s_1641_2: cast zx s_1641_1 -> bv
        let s_1641_2: Bits = Bits::new(s_1641_1 as u128, 32u16);
        // C s_1641_3: const #1s : i64
        let s_1641_3: i64 = 1;
        // C s_1641_4: cast zx s_1641_3 -> i
        let s_1641_4: i128 = (i128::try_from(s_1641_3).unwrap());
        // C s_1641_5: const #1s : i
        let s_1641_5: i128 = 1;
        // C s_1641_6: add s_1641_5 s_1641_4
        let s_1641_6: i128 = (s_1641_5 + s_1641_4);
        // D s_1641_7: bit-extract s_1641_2 s_1641_0 s_1641_6
        let s_1641_7: Bits = (Bits::new(
            ((s_1641_2) >> (s_1641_0)).value(),
            u16::try_from(s_1641_6).unwrap(),
        ));
        // D s_1641_8: cast reint s_1641_7 -> u8
        let s_1641_8: u8 = (s_1641_7.value() as u8);
        // D s_1641_9: cast zx s_1641_8 -> bv
        let s_1641_9: Bits = Bits::new(s_1641_8 as u128, 2u16);
        // C s_1641_10: const #0u : u8
        let s_1641_10: u8 = 0;
        // C s_1641_11: cast zx s_1641_10 -> bv
        let s_1641_11: Bits = Bits::new(s_1641_10 as u128, 2u16);
        // D s_1641_12: cmp-eq s_1641_9 s_1641_11
        let s_1641_12: bool = ((s_1641_9) == (s_1641_11));
        // N s_1641_13: branch s_1641_12 b1644 b1642
        if s_1641_12 {
            return block_1644(state, tracer, fn_state);
        } else {
            return block_1642(state, tracer, fn_state);
        };
    }
    fn block_1642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1642_0: const #0u : u8
        let s_1642_0: bool = false;
        // D s_1642_1: write-var gs#403552 <= s_1642_0
        fn_state.gs_403552 = s_1642_0;
        // N s_1642_2: jump b1643
        return block_1643(state, tracer, fn_state);
    }
    fn block_1643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1643_0: read-var gs#403552:u8
        let s_1643_0: bool = fn_state.gs_403552;
        // D s_1643_1: write-var gs#403553 <= s_1643_0
        fn_state.gs_403553 = s_1643_0;
        // N s_1643_2: jump b1640
        return block_1640(state, tracer, fn_state);
    }
    fn block_1644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1644_0: const #4s : i
        let s_1644_0: i128 = 4;
        // D s_1644_1: read-var u#32268:u32
        let s_1644_1: u32 = fn_state.u_32268;
        // D s_1644_2: cast zx s_1644_1 -> bv
        let s_1644_2: Bits = Bits::new(s_1644_1 as u128, 32u16);
        // C s_1644_3: const #1s : i64
        let s_1644_3: i64 = 1;
        // C s_1644_4: cast zx s_1644_3 -> i
        let s_1644_4: i128 = (i128::try_from(s_1644_3).unwrap());
        // C s_1644_5: const #0s : i
        let s_1644_5: i128 = 0;
        // C s_1644_6: add s_1644_5 s_1644_4
        let s_1644_6: i128 = (s_1644_5 + s_1644_4);
        // D s_1644_7: bit-extract s_1644_2 s_1644_0 s_1644_6
        let s_1644_7: Bits = (Bits::new(
            ((s_1644_2) >> (s_1644_0)).value(),
            u16::try_from(s_1644_6).unwrap(),
        ));
        // D s_1644_8: cast reint s_1644_7 -> u8
        let s_1644_8: bool = ((s_1644_7.value()) != 0);
        // D s_1644_9: cast zx s_1644_8 -> bv
        let s_1644_9: Bits = Bits::new(s_1644_8 as u128, 1u16);
        // C s_1644_10: const #0u : u8
        let s_1644_10: bool = false;
        // C s_1644_11: cast zx s_1644_10 -> bv
        let s_1644_11: Bits = Bits::new(s_1644_10 as u128, 1u16);
        // D s_1644_12: cmp-eq s_1644_9 s_1644_11
        let s_1644_12: bool = ((s_1644_9) == (s_1644_11));
        // D s_1644_13: write-var gs#403552 <= s_1644_12
        fn_state.gs_403552 = s_1644_12;
        // N s_1644_14: jump b1643
        return block_1643(state, tracer, fn_state);
    }
    fn block_1645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1645_0: const #3850s : i
        let s_1645_0: i128 = 3850;
        // C s_1645_1: const #14696u : u32
        let s_1645_1: u32 = 14696;
        // D s_1645_2: read-reg s_1645_1:i
        let s_1645_2: i128 = {
            let value = state.read_register::<i128>(s_1645_1 as isize);
            tracer.read_register(s_1645_1 as isize, value);
            value
        };
        // D s_1645_3: cmp-lt s_1645_2 s_1645_0
        let s_1645_3: bool = ((s_1645_2) < (s_1645_0));
        // D s_1645_4: write-var gs#403524 <= s_1645_3
        fn_state.gs_403524 = s_1645_3;
        // N s_1645_5: jump b1417
        return block_1417(state, tracer, fn_state);
    }
    fn block_1646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1646_0: const #20s : i
        let s_1646_0: i128 = 20;
        // D s_1646_1: read-var u#32259:u32
        let s_1646_1: u32 = fn_state.u_32259;
        // D s_1646_2: cast zx s_1646_1 -> bv
        let s_1646_2: Bits = Bits::new(s_1646_1 as u128, 32u16);
        // C s_1646_3: const #1s : i64
        let s_1646_3: i64 = 1;
        // C s_1646_4: cast zx s_1646_3 -> i
        let s_1646_4: i128 = (i128::try_from(s_1646_3).unwrap());
        // C s_1646_5: const #1s : i
        let s_1646_5: i128 = 1;
        // C s_1646_6: add s_1646_5 s_1646_4
        let s_1646_6: i128 = (s_1646_5 + s_1646_4);
        // D s_1646_7: bit-extract s_1646_2 s_1646_0 s_1646_6
        let s_1646_7: Bits = (Bits::new(
            ((s_1646_2) >> (s_1646_0)).value(),
            u16::try_from(s_1646_6).unwrap(),
        ));
        // D s_1646_8: cast reint s_1646_7 -> u8
        let s_1646_8: u8 = (s_1646_7.value() as u8);
        // D s_1646_9: cast zx s_1646_8 -> bv
        let s_1646_9: Bits = Bits::new(s_1646_8 as u128, 2u16);
        // C s_1646_10: const #2u : u8
        let s_1646_10: u8 = 2;
        // C s_1646_11: cast zx s_1646_10 -> bv
        let s_1646_11: Bits = Bits::new(s_1646_10 as u128, 2u16);
        // D s_1646_12: cmp-eq s_1646_9 s_1646_11
        let s_1646_12: bool = ((s_1646_9) == (s_1646_11));
        // N s_1646_13: branch s_1646_12 b1649 b1647
        if s_1646_12 {
            return block_1649(state, tracer, fn_state);
        } else {
            return block_1647(state, tracer, fn_state);
        };
    }
    fn block_1647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1647_0: const #0u : u8
        let s_1647_0: bool = false;
        // D s_1647_1: write-var gs#403521 <= s_1647_0
        fn_state.gs_403521 = s_1647_0;
        // N s_1647_2: jump b1648
        return block_1648(state, tracer, fn_state);
    }
    fn block_1648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1648_0: read-var gs#403521:u8
        let s_1648_0: bool = fn_state.gs_403521;
        // D s_1648_1: write-var gs#403522 <= s_1648_0
        fn_state.gs_403522 = s_1648_0;
        // N s_1648_2: jump b1415
        return block_1415(state, tracer, fn_state);
    }
    fn block_1649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1649_0: const #8s : i
        let s_1649_0: i128 = 8;
        // D s_1649_1: read-var u#32259:u32
        let s_1649_1: u32 = fn_state.u_32259;
        // D s_1649_2: cast zx s_1649_1 -> bv
        let s_1649_2: Bits = Bits::new(s_1649_1 as u128, 32u16);
        // C s_1649_3: const #1s : i64
        let s_1649_3: i64 = 1;
        // C s_1649_4: cast zx s_1649_3 -> i
        let s_1649_4: i128 = (i128::try_from(s_1649_3).unwrap());
        // C s_1649_5: const #3s : i
        let s_1649_5: i128 = 3;
        // C s_1649_6: add s_1649_5 s_1649_4
        let s_1649_6: i128 = (s_1649_5 + s_1649_4);
        // D s_1649_7: bit-extract s_1649_2 s_1649_0 s_1649_6
        let s_1649_7: Bits = (Bits::new(
            ((s_1649_2) >> (s_1649_0)).value(),
            u16::try_from(s_1649_6).unwrap(),
        ));
        // D s_1649_8: cast reint s_1649_7 -> u8
        let s_1649_8: u8 = (s_1649_7.value() as u8);
        // D s_1649_9: cast zx s_1649_8 -> bv
        let s_1649_9: Bits = Bits::new(s_1649_8 as u128, 4u16);
        // C s_1649_10: const #12u : u8
        let s_1649_10: u8 = 12;
        // C s_1649_11: cast zx s_1649_10 -> bv
        let s_1649_11: Bits = Bits::new(s_1649_10 as u128, 4u16);
        // D s_1649_12: cmp-eq s_1649_9 s_1649_11
        let s_1649_12: bool = ((s_1649_9) == (s_1649_11));
        // N s_1649_13: branch s_1649_12 b1652 b1650
        if s_1649_12 {
            return block_1652(state, tracer, fn_state);
        } else {
            return block_1650(state, tracer, fn_state);
        };
    }
    fn block_1650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1650_0: const #0u : u8
        let s_1650_0: bool = false;
        // D s_1650_1: write-var gs#403520 <= s_1650_0
        fn_state.gs_403520 = s_1650_0;
        // N s_1650_2: jump b1651
        return block_1651(state, tracer, fn_state);
    }
    fn block_1651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1651_0: read-var gs#403520:u8
        let s_1651_0: bool = fn_state.gs_403520;
        // D s_1651_1: write-var gs#403521 <= s_1651_0
        fn_state.gs_403521 = s_1651_0;
        // N s_1651_2: jump b1648
        return block_1648(state, tracer, fn_state);
    }
    fn block_1652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1652_0: const #4s : i
        let s_1652_0: i128 = 4;
        // D s_1652_1: read-var u#32259:u32
        let s_1652_1: u32 = fn_state.u_32259;
        // D s_1652_2: cast zx s_1652_1 -> bv
        let s_1652_2: Bits = Bits::new(s_1652_1 as u128, 32u16);
        // C s_1652_3: const #1s : i64
        let s_1652_3: i64 = 1;
        // C s_1652_4: cast zx s_1652_3 -> i
        let s_1652_4: i128 = (i128::try_from(s_1652_3).unwrap());
        // C s_1652_5: const #0s : i
        let s_1652_5: i128 = 0;
        // C s_1652_6: add s_1652_5 s_1652_4
        let s_1652_6: i128 = (s_1652_5 + s_1652_4);
        // D s_1652_7: bit-extract s_1652_2 s_1652_0 s_1652_6
        let s_1652_7: Bits = (Bits::new(
            ((s_1652_2) >> (s_1652_0)).value(),
            u16::try_from(s_1652_6).unwrap(),
        ));
        // D s_1652_8: cast reint s_1652_7 -> u8
        let s_1652_8: bool = ((s_1652_7.value()) != 0);
        // D s_1652_9: cast zx s_1652_8 -> bv
        let s_1652_9: Bits = Bits::new(s_1652_8 as u128, 1u16);
        // C s_1652_10: const #0u : u8
        let s_1652_10: bool = false;
        // C s_1652_11: cast zx s_1652_10 -> bv
        let s_1652_11: Bits = Bits::new(s_1652_10 as u128, 1u16);
        // D s_1652_12: cmp-eq s_1652_9 s_1652_11
        let s_1652_12: bool = ((s_1652_9) == (s_1652_11));
        // D s_1652_13: write-var gs#403520 <= s_1652_12
        fn_state.gs_403520 = s_1652_12;
        // N s_1652_14: jump b1651
        return block_1651(state, tracer, fn_state);
    }
    fn block_1653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1653_0: const #3848s : i
        let s_1653_0: i128 = 3848;
        // C s_1653_1: const #14696u : u32
        let s_1653_1: u32 = 14696;
        // D s_1653_2: read-reg s_1653_1:i
        let s_1653_2: i128 = {
            let value = state.read_register::<i128>(s_1653_1 as isize);
            tracer.read_register(s_1653_1 as isize, value);
            value
        };
        // D s_1653_3: cmp-lt s_1653_2 s_1653_0
        let s_1653_3: bool = ((s_1653_2) < (s_1653_0));
        // D s_1653_4: write-var gs#403498 <= s_1653_3
        fn_state.gs_403498 = s_1653_3;
        // N s_1653_5: jump b1411
        return block_1411(state, tracer, fn_state);
    }
    fn block_1654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1654_0: const #20s : i
        let s_1654_0: i128 = 20;
        // D s_1654_1: read-var u#32252:u32
        let s_1654_1: u32 = fn_state.u_32252;
        // D s_1654_2: cast zx s_1654_1 -> bv
        let s_1654_2: Bits = Bits::new(s_1654_1 as u128, 32u16);
        // C s_1654_3: const #1s : i64
        let s_1654_3: i64 = 1;
        // C s_1654_4: cast zx s_1654_3 -> i
        let s_1654_4: i128 = (i128::try_from(s_1654_3).unwrap());
        // C s_1654_5: const #1s : i
        let s_1654_5: i128 = 1;
        // C s_1654_6: add s_1654_5 s_1654_4
        let s_1654_6: i128 = (s_1654_5 + s_1654_4);
        // D s_1654_7: bit-extract s_1654_2 s_1654_0 s_1654_6
        let s_1654_7: Bits = (Bits::new(
            ((s_1654_2) >> (s_1654_0)).value(),
            u16::try_from(s_1654_6).unwrap(),
        ));
        // D s_1654_8: cast reint s_1654_7 -> u8
        let s_1654_8: u8 = (s_1654_7.value() as u8);
        // D s_1654_9: cast zx s_1654_8 -> bv
        let s_1654_9: Bits = Bits::new(s_1654_8 as u128, 2u16);
        // C s_1654_10: const #3u : u8
        let s_1654_10: u8 = 3;
        // C s_1654_11: cast zx s_1654_10 -> bv
        let s_1654_11: Bits = Bits::new(s_1654_10 as u128, 2u16);
        // D s_1654_12: cmp-eq s_1654_9 s_1654_11
        let s_1654_12: bool = ((s_1654_9) == (s_1654_11));
        // N s_1654_13: branch s_1654_12 b1657 b1655
        if s_1654_12 {
            return block_1657(state, tracer, fn_state);
        } else {
            return block_1655(state, tracer, fn_state);
        };
    }
    fn block_1655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1655_0: const #0u : u8
        let s_1655_0: bool = false;
        // D s_1655_1: write-var gs#403495 <= s_1655_0
        fn_state.gs_403495 = s_1655_0;
        // N s_1655_2: jump b1656
        return block_1656(state, tracer, fn_state);
    }
    fn block_1656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1656_0: read-var gs#403495:u8
        let s_1656_0: bool = fn_state.gs_403495;
        // D s_1656_1: write-var gs#403496 <= s_1656_0
        fn_state.gs_403496 = s_1656_0;
        // N s_1656_2: jump b1409
        return block_1409(state, tracer, fn_state);
    }
    fn block_1657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1657_0: const #16s : i
        let s_1657_0: i128 = 16;
        // D s_1657_1: read-var u#32252:u32
        let s_1657_1: u32 = fn_state.u_32252;
        // D s_1657_2: cast zx s_1657_1 -> bv
        let s_1657_2: Bits = Bits::new(s_1657_1 as u128, 32u16);
        // C s_1657_3: const #1s : i64
        let s_1657_3: i64 = 1;
        // C s_1657_4: cast zx s_1657_3 -> i
        let s_1657_4: i128 = (i128::try_from(s_1657_3).unwrap());
        // C s_1657_5: const #1s : i
        let s_1657_5: i128 = 1;
        // C s_1657_6: add s_1657_5 s_1657_4
        let s_1657_6: i128 = (s_1657_5 + s_1657_4);
        // D s_1657_7: bit-extract s_1657_2 s_1657_0 s_1657_6
        let s_1657_7: Bits = (Bits::new(
            ((s_1657_2) >> (s_1657_0)).value(),
            u16::try_from(s_1657_6).unwrap(),
        ));
        // D s_1657_8: cast reint s_1657_7 -> u8
        let s_1657_8: u8 = (s_1657_7.value() as u8);
        // D s_1657_9: cast zx s_1657_8 -> bv
        let s_1657_9: Bits = Bits::new(s_1657_8 as u128, 2u16);
        // C s_1657_10: const #2u : u8
        let s_1657_10: u8 = 2;
        // C s_1657_11: cast zx s_1657_10 -> bv
        let s_1657_11: Bits = Bits::new(s_1657_10 as u128, 2u16);
        // D s_1657_12: cmp-eq s_1657_9 s_1657_11
        let s_1657_12: bool = ((s_1657_9) == (s_1657_11));
        // N s_1657_13: branch s_1657_12 b1660 b1658
        if s_1657_12 {
            return block_1660(state, tracer, fn_state);
        } else {
            return block_1658(state, tracer, fn_state);
        };
    }
    fn block_1658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1658_0: const #0u : u8
        let s_1658_0: bool = false;
        // D s_1658_1: write-var gs#403494 <= s_1658_0
        fn_state.gs_403494 = s_1658_0;
        // N s_1658_2: jump b1659
        return block_1659(state, tracer, fn_state);
    }
    fn block_1659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1659_0: read-var gs#403494:u8
        let s_1659_0: bool = fn_state.gs_403494;
        // D s_1659_1: write-var gs#403495 <= s_1659_0
        fn_state.gs_403495 = s_1659_0;
        // N s_1659_2: jump b1656
        return block_1656(state, tracer, fn_state);
    }
    fn block_1660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1660_0: const #6s : i
        let s_1660_0: i128 = 6;
        // D s_1660_1: read-var u#32252:u32
        let s_1660_1: u32 = fn_state.u_32252;
        // D s_1660_2: cast zx s_1660_1 -> bv
        let s_1660_2: Bits = Bits::new(s_1660_1 as u128, 32u16);
        // C s_1660_3: const #1s : i64
        let s_1660_3: i64 = 1;
        // C s_1660_4: cast zx s_1660_3 -> i
        let s_1660_4: i128 = (i128::try_from(s_1660_3).unwrap());
        // C s_1660_5: const #5s : i
        let s_1660_5: i128 = 5;
        // C s_1660_6: add s_1660_5 s_1660_4
        let s_1660_6: i128 = (s_1660_5 + s_1660_4);
        // D s_1660_7: bit-extract s_1660_2 s_1660_0 s_1660_6
        let s_1660_7: Bits = (Bits::new(
            ((s_1660_2) >> (s_1660_0)).value(),
            u16::try_from(s_1660_6).unwrap(),
        ));
        // D s_1660_8: cast reint s_1660_7 -> u8
        let s_1660_8: u8 = (s_1660_7.value() as u8);
        // D s_1660_9: cast zx s_1660_8 -> bv
        let s_1660_9: Bits = Bits::new(s_1660_8 as u128, 6u16);
        // C s_1660_10: const #15u : u8
        let s_1660_10: u8 = 15;
        // C s_1660_11: cast zx s_1660_10 -> bv
        let s_1660_11: Bits = Bits::new(s_1660_10 as u128, 6u16);
        // D s_1660_12: cmp-eq s_1660_9 s_1660_11
        let s_1660_12: bool = ((s_1660_9) == (s_1660_11));
        // N s_1660_13: branch s_1660_12 b1663 b1661
        if s_1660_12 {
            return block_1663(state, tracer, fn_state);
        } else {
            return block_1661(state, tracer, fn_state);
        };
    }
    fn block_1661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1661_0: const #0u : u8
        let s_1661_0: bool = false;
        // D s_1661_1: write-var gs#403493 <= s_1661_0
        fn_state.gs_403493 = s_1661_0;
        // N s_1661_2: jump b1662
        return block_1662(state, tracer, fn_state);
    }
    fn block_1662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1662_0: read-var gs#403493:u8
        let s_1662_0: bool = fn_state.gs_403493;
        // D s_1662_1: write-var gs#403494 <= s_1662_0
        fn_state.gs_403494 = s_1662_0;
        // N s_1662_2: jump b1659
        return block_1659(state, tracer, fn_state);
    }
    fn block_1663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1663_0: const #4s : i
        let s_1663_0: i128 = 4;
        // D s_1663_1: read-var u#32252:u32
        let s_1663_1: u32 = fn_state.u_32252;
        // D s_1663_2: cast zx s_1663_1 -> bv
        let s_1663_2: Bits = Bits::new(s_1663_1 as u128, 32u16);
        // C s_1663_3: const #1s : i64
        let s_1663_3: i64 = 1;
        // C s_1663_4: cast zx s_1663_3 -> i
        let s_1663_4: i128 = (i128::try_from(s_1663_3).unwrap());
        // C s_1663_5: const #0s : i
        let s_1663_5: i128 = 0;
        // C s_1663_6: add s_1663_5 s_1663_4
        let s_1663_6: i128 = (s_1663_5 + s_1663_4);
        // D s_1663_7: bit-extract s_1663_2 s_1663_0 s_1663_6
        let s_1663_7: Bits = (Bits::new(
            ((s_1663_2) >> (s_1663_0)).value(),
            u16::try_from(s_1663_6).unwrap(),
        ));
        // D s_1663_8: cast reint s_1663_7 -> u8
        let s_1663_8: bool = ((s_1663_7.value()) != 0);
        // D s_1663_9: cast zx s_1663_8 -> bv
        let s_1663_9: Bits = Bits::new(s_1663_8 as u128, 1u16);
        // C s_1663_10: const #0u : u8
        let s_1663_10: bool = false;
        // C s_1663_11: cast zx s_1663_10 -> bv
        let s_1663_11: Bits = Bits::new(s_1663_10 as u128, 1u16);
        // D s_1663_12: cmp-eq s_1663_9 s_1663_11
        let s_1663_12: bool = ((s_1663_9) == (s_1663_11));
        // D s_1663_13: write-var gs#403493 <= s_1663_12
        fn_state.gs_403493 = s_1663_12;
        // N s_1663_14: jump b1662
        return block_1662(state, tracer, fn_state);
    }
    fn block_1664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1664_0: const #3846s : i
        let s_1664_0: i128 = 3846;
        // C s_1664_1: const #14696u : u32
        let s_1664_1: u32 = 14696;
        // D s_1664_2: read-reg s_1664_1:i
        let s_1664_2: i128 = {
            let value = state.read_register::<i128>(s_1664_1 as isize);
            tracer.read_register(s_1664_1 as isize, value);
            value
        };
        // D s_1664_3: cmp-lt s_1664_2 s_1664_0
        let s_1664_3: bool = ((s_1664_2) < (s_1664_0));
        // D s_1664_4: write-var gs#403465 <= s_1664_3
        fn_state.gs_403465 = s_1664_3;
        // N s_1664_5: jump b1405
        return block_1405(state, tracer, fn_state);
    }
    fn block_1665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1665_0: const #20s : i
        let s_1665_0: i128 = 20;
        // D s_1665_1: read-var u#32243:u32
        let s_1665_1: u32 = fn_state.u_32243;
        // D s_1665_2: cast zx s_1665_1 -> bv
        let s_1665_2: Bits = Bits::new(s_1665_1 as u128, 32u16);
        // C s_1665_3: const #1s : i64
        let s_1665_3: i64 = 1;
        // C s_1665_4: cast zx s_1665_3 -> i
        let s_1665_4: i128 = (i128::try_from(s_1665_3).unwrap());
        // C s_1665_5: const #1s : i
        let s_1665_5: i128 = 1;
        // C s_1665_6: add s_1665_5 s_1665_4
        let s_1665_6: i128 = (s_1665_5 + s_1665_4);
        // D s_1665_7: bit-extract s_1665_2 s_1665_0 s_1665_6
        let s_1665_7: Bits = (Bits::new(
            ((s_1665_2) >> (s_1665_0)).value(),
            u16::try_from(s_1665_6).unwrap(),
        ));
        // D s_1665_8: cast reint s_1665_7 -> u8
        let s_1665_8: u8 = (s_1665_7.value() as u8);
        // D s_1665_9: cast zx s_1665_8 -> bv
        let s_1665_9: Bits = Bits::new(s_1665_8 as u128, 2u16);
        // C s_1665_10: const #1u : u8
        let s_1665_10: u8 = 1;
        // C s_1665_11: cast zx s_1665_10 -> bv
        let s_1665_11: Bits = Bits::new(s_1665_10 as u128, 2u16);
        // D s_1665_12: cmp-eq s_1665_9 s_1665_11
        let s_1665_12: bool = ((s_1665_9) == (s_1665_11));
        // N s_1665_13: branch s_1665_12 b1668 b1666
        if s_1665_12 {
            return block_1668(state, tracer, fn_state);
        } else {
            return block_1666(state, tracer, fn_state);
        };
    }
    fn block_1666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1666_0: const #0u : u8
        let s_1666_0: bool = false;
        // D s_1666_1: write-var gs#403462 <= s_1666_0
        fn_state.gs_403462 = s_1666_0;
        // N s_1666_2: jump b1667
        return block_1667(state, tracer, fn_state);
    }
    fn block_1667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1667_0: read-var gs#403462:u8
        let s_1667_0: bool = fn_state.gs_403462;
        // D s_1667_1: write-var gs#403463 <= s_1667_0
        fn_state.gs_403463 = s_1667_0;
        // N s_1667_2: jump b1403
        return block_1403(state, tracer, fn_state);
    }
    fn block_1668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1668_0: const #8s : i
        let s_1668_0: i128 = 8;
        // D s_1668_1: read-var u#32243:u32
        let s_1668_1: u32 = fn_state.u_32243;
        // D s_1668_2: cast zx s_1668_1 -> bv
        let s_1668_2: Bits = Bits::new(s_1668_1 as u128, 32u16);
        // C s_1668_3: const #1s : i64
        let s_1668_3: i64 = 1;
        // C s_1668_4: cast zx s_1668_3 -> i
        let s_1668_4: i128 = (i128::try_from(s_1668_3).unwrap());
        // C s_1668_5: const #3s : i
        let s_1668_5: i128 = 3;
        // C s_1668_6: add s_1668_5 s_1668_4
        let s_1668_6: i128 = (s_1668_5 + s_1668_4);
        // D s_1668_7: bit-extract s_1668_2 s_1668_0 s_1668_6
        let s_1668_7: Bits = (Bits::new(
            ((s_1668_2) >> (s_1668_0)).value(),
            u16::try_from(s_1668_6).unwrap(),
        ));
        // D s_1668_8: cast reint s_1668_7 -> u8
        let s_1668_8: u8 = (s_1668_7.value() as u8);
        // D s_1668_9: cast zx s_1668_8 -> bv
        let s_1668_9: Bits = Bits::new(s_1668_8 as u128, 4u16);
        // C s_1668_10: const #12u : u8
        let s_1668_10: u8 = 12;
        // C s_1668_11: cast zx s_1668_10 -> bv
        let s_1668_11: Bits = Bits::new(s_1668_10 as u128, 4u16);
        // D s_1668_12: cmp-eq s_1668_9 s_1668_11
        let s_1668_12: bool = ((s_1668_9) == (s_1668_11));
        // N s_1668_13: branch s_1668_12 b1671 b1669
        if s_1668_12 {
            return block_1671(state, tracer, fn_state);
        } else {
            return block_1669(state, tracer, fn_state);
        };
    }
    fn block_1669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1669_0: const #0u : u8
        let s_1669_0: bool = false;
        // D s_1669_1: write-var gs#403461 <= s_1669_0
        fn_state.gs_403461 = s_1669_0;
        // N s_1669_2: jump b1670
        return block_1670(state, tracer, fn_state);
    }
    fn block_1670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1670_0: read-var gs#403461:u8
        let s_1670_0: bool = fn_state.gs_403461;
        // D s_1670_1: write-var gs#403462 <= s_1670_0
        fn_state.gs_403462 = s_1670_0;
        // N s_1670_2: jump b1667
        return block_1667(state, tracer, fn_state);
    }
    fn block_1671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1671_0: const #4s : i
        let s_1671_0: i128 = 4;
        // D s_1671_1: read-var u#32243:u32
        let s_1671_1: u32 = fn_state.u_32243;
        // D s_1671_2: cast zx s_1671_1 -> bv
        let s_1671_2: Bits = Bits::new(s_1671_1 as u128, 32u16);
        // C s_1671_3: const #1s : i64
        let s_1671_3: i64 = 1;
        // C s_1671_4: cast zx s_1671_3 -> i
        let s_1671_4: i128 = (i128::try_from(s_1671_3).unwrap());
        // C s_1671_5: const #0s : i
        let s_1671_5: i128 = 0;
        // C s_1671_6: add s_1671_5 s_1671_4
        let s_1671_6: i128 = (s_1671_5 + s_1671_4);
        // D s_1671_7: bit-extract s_1671_2 s_1671_0 s_1671_6
        let s_1671_7: Bits = (Bits::new(
            ((s_1671_2) >> (s_1671_0)).value(),
            u16::try_from(s_1671_6).unwrap(),
        ));
        // D s_1671_8: cast reint s_1671_7 -> u8
        let s_1671_8: bool = ((s_1671_7.value()) != 0);
        // D s_1671_9: cast zx s_1671_8 -> bv
        let s_1671_9: Bits = Bits::new(s_1671_8 as u128, 1u16);
        // C s_1671_10: const #0u : u8
        let s_1671_10: bool = false;
        // C s_1671_11: cast zx s_1671_10 -> bv
        let s_1671_11: Bits = Bits::new(s_1671_10 as u128, 1u16);
        // D s_1671_12: cmp-eq s_1671_9 s_1671_11
        let s_1671_12: bool = ((s_1671_9) == (s_1671_11));
        // D s_1671_13: write-var gs#403461 <= s_1671_12
        fn_state.gs_403461 = s_1671_12;
        // N s_1671_14: jump b1670
        return block_1670(state, tracer, fn_state);
    }
    fn block_1672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1672_0: const #3844s : i
        let s_1672_0: i128 = 3844;
        // C s_1672_1: const #14696u : u32
        let s_1672_1: u32 = 14696;
        // D s_1672_2: read-reg s_1672_1:i
        let s_1672_2: i128 = {
            let value = state.read_register::<i128>(s_1672_1 as isize);
            tracer.read_register(s_1672_1 as isize, value);
            value
        };
        // D s_1672_3: cmp-lt s_1672_2 s_1672_0
        let s_1672_3: bool = ((s_1672_2) < (s_1672_0));
        // D s_1672_4: write-var gs#403435 <= s_1672_3
        fn_state.gs_403435 = s_1672_3;
        // N s_1672_5: jump b1399
        return block_1399(state, tracer, fn_state);
    }
    fn block_1673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1673_0: const #20s : i
        let s_1673_0: i128 = 20;
        // D s_1673_1: read-var u#32234:u32
        let s_1673_1: u32 = fn_state.u_32234;
        // D s_1673_2: cast zx s_1673_1 -> bv
        let s_1673_2: Bits = Bits::new(s_1673_1 as u128, 32u16);
        // C s_1673_3: const #1s : i64
        let s_1673_3: i64 = 1;
        // C s_1673_4: cast zx s_1673_3 -> i
        let s_1673_4: i128 = (i128::try_from(s_1673_3).unwrap());
        // C s_1673_5: const #1s : i
        let s_1673_5: i128 = 1;
        // C s_1673_6: add s_1673_5 s_1673_4
        let s_1673_6: i128 = (s_1673_5 + s_1673_4);
        // D s_1673_7: bit-extract s_1673_2 s_1673_0 s_1673_6
        let s_1673_7: Bits = (Bits::new(
            ((s_1673_2) >> (s_1673_0)).value(),
            u16::try_from(s_1673_6).unwrap(),
        ));
        // D s_1673_8: cast reint s_1673_7 -> u8
        let s_1673_8: u8 = (s_1673_7.value() as u8);
        // D s_1673_9: cast zx s_1673_8 -> bv
        let s_1673_9: Bits = Bits::new(s_1673_8 as u128, 2u16);
        // C s_1673_10: const #0u : u8
        let s_1673_10: u8 = 0;
        // C s_1673_11: cast zx s_1673_10 -> bv
        let s_1673_11: Bits = Bits::new(s_1673_10 as u128, 2u16);
        // D s_1673_12: cmp-eq s_1673_9 s_1673_11
        let s_1673_12: bool = ((s_1673_9) == (s_1673_11));
        // N s_1673_13: branch s_1673_12 b1676 b1674
        if s_1673_12 {
            return block_1676(state, tracer, fn_state);
        } else {
            return block_1674(state, tracer, fn_state);
        };
    }
    fn block_1674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1674_0: const #0u : u8
        let s_1674_0: bool = false;
        // D s_1674_1: write-var gs#403432 <= s_1674_0
        fn_state.gs_403432 = s_1674_0;
        // N s_1674_2: jump b1675
        return block_1675(state, tracer, fn_state);
    }
    fn block_1675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1675_0: read-var gs#403432:u8
        let s_1675_0: bool = fn_state.gs_403432;
        // D s_1675_1: write-var gs#403433 <= s_1675_0
        fn_state.gs_403433 = s_1675_0;
        // N s_1675_2: jump b1397
        return block_1397(state, tracer, fn_state);
    }
    fn block_1676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1676_0: const #8s : i
        let s_1676_0: i128 = 8;
        // D s_1676_1: read-var u#32234:u32
        let s_1676_1: u32 = fn_state.u_32234;
        // D s_1676_2: cast zx s_1676_1 -> bv
        let s_1676_2: Bits = Bits::new(s_1676_1 as u128, 32u16);
        // C s_1676_3: const #1s : i64
        let s_1676_3: i64 = 1;
        // C s_1676_4: cast zx s_1676_3 -> i
        let s_1676_4: i128 = (i128::try_from(s_1676_3).unwrap());
        // C s_1676_5: const #3s : i
        let s_1676_5: i128 = 3;
        // C s_1676_6: add s_1676_5 s_1676_4
        let s_1676_6: i128 = (s_1676_5 + s_1676_4);
        // D s_1676_7: bit-extract s_1676_2 s_1676_0 s_1676_6
        let s_1676_7: Bits = (Bits::new(
            ((s_1676_2) >> (s_1676_0)).value(),
            u16::try_from(s_1676_6).unwrap(),
        ));
        // D s_1676_8: cast reint s_1676_7 -> u8
        let s_1676_8: u8 = (s_1676_7.value() as u8);
        // D s_1676_9: cast zx s_1676_8 -> bv
        let s_1676_9: Bits = Bits::new(s_1676_8 as u128, 4u16);
        // C s_1676_10: const #12u : u8
        let s_1676_10: u8 = 12;
        // C s_1676_11: cast zx s_1676_10 -> bv
        let s_1676_11: Bits = Bits::new(s_1676_10 as u128, 4u16);
        // D s_1676_12: cmp-eq s_1676_9 s_1676_11
        let s_1676_12: bool = ((s_1676_9) == (s_1676_11));
        // N s_1676_13: branch s_1676_12 b1679 b1677
        if s_1676_12 {
            return block_1679(state, tracer, fn_state);
        } else {
            return block_1677(state, tracer, fn_state);
        };
    }
    fn block_1677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1677_0: const #0u : u8
        let s_1677_0: bool = false;
        // D s_1677_1: write-var gs#403431 <= s_1677_0
        fn_state.gs_403431 = s_1677_0;
        // N s_1677_2: jump b1678
        return block_1678(state, tracer, fn_state);
    }
    fn block_1678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1678_0: read-var gs#403431:u8
        let s_1678_0: bool = fn_state.gs_403431;
        // D s_1678_1: write-var gs#403432 <= s_1678_0
        fn_state.gs_403432 = s_1678_0;
        // N s_1678_2: jump b1675
        return block_1675(state, tracer, fn_state);
    }
    fn block_1679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1679_0: const #4s : i
        let s_1679_0: i128 = 4;
        // D s_1679_1: read-var u#32234:u32
        let s_1679_1: u32 = fn_state.u_32234;
        // D s_1679_2: cast zx s_1679_1 -> bv
        let s_1679_2: Bits = Bits::new(s_1679_1 as u128, 32u16);
        // C s_1679_3: const #1s : i64
        let s_1679_3: i64 = 1;
        // C s_1679_4: cast zx s_1679_3 -> i
        let s_1679_4: i128 = (i128::try_from(s_1679_3).unwrap());
        // C s_1679_5: const #0s : i
        let s_1679_5: i128 = 0;
        // C s_1679_6: add s_1679_5 s_1679_4
        let s_1679_6: i128 = (s_1679_5 + s_1679_4);
        // D s_1679_7: bit-extract s_1679_2 s_1679_0 s_1679_6
        let s_1679_7: Bits = (Bits::new(
            ((s_1679_2) >> (s_1679_0)).value(),
            u16::try_from(s_1679_6).unwrap(),
        ));
        // D s_1679_8: cast reint s_1679_7 -> u8
        let s_1679_8: bool = ((s_1679_7.value()) != 0);
        // D s_1679_9: cast zx s_1679_8 -> bv
        let s_1679_9: Bits = Bits::new(s_1679_8 as u128, 1u16);
        // C s_1679_10: const #0u : u8
        let s_1679_10: bool = false;
        // C s_1679_11: cast zx s_1679_10 -> bv
        let s_1679_11: Bits = Bits::new(s_1679_10 as u128, 1u16);
        // D s_1679_12: cmp-eq s_1679_9 s_1679_11
        let s_1679_12: bool = ((s_1679_9) == (s_1679_11));
        // D s_1679_13: write-var gs#403431 <= s_1679_12
        fn_state.gs_403431 = s_1679_12;
        // N s_1679_14: jump b1678
        return block_1678(state, tracer, fn_state);
    }
    fn block_1680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1680_0: const #3842s : i
        let s_1680_0: i128 = 3842;
        // C s_1680_1: const #14696u : u32
        let s_1680_1: u32 = 14696;
        // D s_1680_2: read-reg s_1680_1:i
        let s_1680_2: i128 = {
            let value = state.read_register::<i128>(s_1680_1 as isize);
            tracer.read_register(s_1680_1 as isize, value);
            value
        };
        // D s_1680_3: cmp-lt s_1680_2 s_1680_0
        let s_1680_3: bool = ((s_1680_2) < (s_1680_0));
        // D s_1680_4: write-var gs#403409 <= s_1680_3
        fn_state.gs_403409 = s_1680_3;
        // N s_1680_5: jump b1393
        return block_1393(state, tracer, fn_state);
    }
    fn block_1681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1681_0: const #20s : i
        let s_1681_0: i128 = 20;
        // D s_1681_1: read-var u#32227:u32
        let s_1681_1: u32 = fn_state.u_32227;
        // D s_1681_2: cast zx s_1681_1 -> bv
        let s_1681_2: Bits = Bits::new(s_1681_1 as u128, 32u16);
        // C s_1681_3: const #1s : i64
        let s_1681_3: i64 = 1;
        // C s_1681_4: cast zx s_1681_3 -> i
        let s_1681_4: i128 = (i128::try_from(s_1681_3).unwrap());
        // C s_1681_5: const #1s : i
        let s_1681_5: i128 = 1;
        // C s_1681_6: add s_1681_5 s_1681_4
        let s_1681_6: i128 = (s_1681_5 + s_1681_4);
        // D s_1681_7: bit-extract s_1681_2 s_1681_0 s_1681_6
        let s_1681_7: Bits = (Bits::new(
            ((s_1681_2) >> (s_1681_0)).value(),
            u16::try_from(s_1681_6).unwrap(),
        ));
        // D s_1681_8: cast reint s_1681_7 -> u8
        let s_1681_8: u8 = (s_1681_7.value() as u8);
        // D s_1681_9: cast zx s_1681_8 -> bv
        let s_1681_9: Bits = Bits::new(s_1681_8 as u128, 2u16);
        // C s_1681_10: const #3u : u8
        let s_1681_10: u8 = 3;
        // C s_1681_11: cast zx s_1681_10 -> bv
        let s_1681_11: Bits = Bits::new(s_1681_10 as u128, 2u16);
        // D s_1681_12: cmp-eq s_1681_9 s_1681_11
        let s_1681_12: bool = ((s_1681_9) == (s_1681_11));
        // N s_1681_13: branch s_1681_12 b1684 b1682
        if s_1681_12 {
            return block_1684(state, tracer, fn_state);
        } else {
            return block_1682(state, tracer, fn_state);
        };
    }
    fn block_1682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1682_0: const #0u : u8
        let s_1682_0: bool = false;
        // D s_1682_1: write-var gs#403406 <= s_1682_0
        fn_state.gs_403406 = s_1682_0;
        // N s_1682_2: jump b1683
        return block_1683(state, tracer, fn_state);
    }
    fn block_1683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1683_0: read-var gs#403406:u8
        let s_1683_0: bool = fn_state.gs_403406;
        // D s_1683_1: write-var gs#403407 <= s_1683_0
        fn_state.gs_403407 = s_1683_0;
        // N s_1683_2: jump b1391
        return block_1391(state, tracer, fn_state);
    }
    fn block_1684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1684_0: const #16s : i
        let s_1684_0: i128 = 16;
        // D s_1684_1: read-var u#32227:u32
        let s_1684_1: u32 = fn_state.u_32227;
        // D s_1684_2: cast zx s_1684_1 -> bv
        let s_1684_2: Bits = Bits::new(s_1684_1 as u128, 32u16);
        // C s_1684_3: const #1s : i64
        let s_1684_3: i64 = 1;
        // C s_1684_4: cast zx s_1684_3 -> i
        let s_1684_4: i128 = (i128::try_from(s_1684_3).unwrap());
        // C s_1684_5: const #1s : i
        let s_1684_5: i128 = 1;
        // C s_1684_6: add s_1684_5 s_1684_4
        let s_1684_6: i128 = (s_1684_5 + s_1684_4);
        // D s_1684_7: bit-extract s_1684_2 s_1684_0 s_1684_6
        let s_1684_7: Bits = (Bits::new(
            ((s_1684_2) >> (s_1684_0)).value(),
            u16::try_from(s_1684_6).unwrap(),
        ));
        // D s_1684_8: cast reint s_1684_7 -> u8
        let s_1684_8: u8 = (s_1684_7.value() as u8);
        // D s_1684_9: cast zx s_1684_8 -> bv
        let s_1684_9: Bits = Bits::new(s_1684_8 as u128, 2u16);
        // C s_1684_10: const #2u : u8
        let s_1684_10: u8 = 2;
        // C s_1684_11: cast zx s_1684_10 -> bv
        let s_1684_11: Bits = Bits::new(s_1684_10 as u128, 2u16);
        // D s_1684_12: cmp-eq s_1684_9 s_1684_11
        let s_1684_12: bool = ((s_1684_9) == (s_1684_11));
        // N s_1684_13: branch s_1684_12 b1687 b1685
        if s_1684_12 {
            return block_1687(state, tracer, fn_state);
        } else {
            return block_1685(state, tracer, fn_state);
        };
    }
    fn block_1685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1685_0: const #0u : u8
        let s_1685_0: bool = false;
        // D s_1685_1: write-var gs#403405 <= s_1685_0
        fn_state.gs_403405 = s_1685_0;
        // N s_1685_2: jump b1686
        return block_1686(state, tracer, fn_state);
    }
    fn block_1686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1686_0: read-var gs#403405:u8
        let s_1686_0: bool = fn_state.gs_403405;
        // D s_1686_1: write-var gs#403406 <= s_1686_0
        fn_state.gs_403406 = s_1686_0;
        // N s_1686_2: jump b1683
        return block_1683(state, tracer, fn_state);
    }
    fn block_1687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1687_0: const #6s : i
        let s_1687_0: i128 = 6;
        // D s_1687_1: read-var u#32227:u32
        let s_1687_1: u32 = fn_state.u_32227;
        // D s_1687_2: cast zx s_1687_1 -> bv
        let s_1687_2: Bits = Bits::new(s_1687_1 as u128, 32u16);
        // C s_1687_3: const #1s : i64
        let s_1687_3: i64 = 1;
        // C s_1687_4: cast zx s_1687_3 -> i
        let s_1687_4: i128 = (i128::try_from(s_1687_3).unwrap());
        // C s_1687_5: const #5s : i
        let s_1687_5: i128 = 5;
        // C s_1687_6: add s_1687_5 s_1687_4
        let s_1687_6: i128 = (s_1687_5 + s_1687_4);
        // D s_1687_7: bit-extract s_1687_2 s_1687_0 s_1687_6
        let s_1687_7: Bits = (Bits::new(
            ((s_1687_2) >> (s_1687_0)).value(),
            u16::try_from(s_1687_6).unwrap(),
        ));
        // D s_1687_8: cast reint s_1687_7 -> u8
        let s_1687_8: u8 = (s_1687_7.value() as u8);
        // D s_1687_9: cast zx s_1687_8 -> bv
        let s_1687_9: Bits = Bits::new(s_1687_8 as u128, 6u16);
        // C s_1687_10: const #14u : u8
        let s_1687_10: u8 = 14;
        // C s_1687_11: cast zx s_1687_10 -> bv
        let s_1687_11: Bits = Bits::new(s_1687_10 as u128, 6u16);
        // D s_1687_12: cmp-eq s_1687_9 s_1687_11
        let s_1687_12: bool = ((s_1687_9) == (s_1687_11));
        // N s_1687_13: branch s_1687_12 b1690 b1688
        if s_1687_12 {
            return block_1690(state, tracer, fn_state);
        } else {
            return block_1688(state, tracer, fn_state);
        };
    }
    fn block_1688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1688_0: const #0u : u8
        let s_1688_0: bool = false;
        // D s_1688_1: write-var gs#403404 <= s_1688_0
        fn_state.gs_403404 = s_1688_0;
        // N s_1688_2: jump b1689
        return block_1689(state, tracer, fn_state);
    }
    fn block_1689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1689_0: read-var gs#403404:u8
        let s_1689_0: bool = fn_state.gs_403404;
        // D s_1689_1: write-var gs#403405 <= s_1689_0
        fn_state.gs_403405 = s_1689_0;
        // N s_1689_2: jump b1686
        return block_1686(state, tracer, fn_state);
    }
    fn block_1690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1690_0: const #4s : i
        let s_1690_0: i128 = 4;
        // D s_1690_1: read-var u#32227:u32
        let s_1690_1: u32 = fn_state.u_32227;
        // D s_1690_2: cast zx s_1690_1 -> bv
        let s_1690_2: Bits = Bits::new(s_1690_1 as u128, 32u16);
        // C s_1690_3: const #1s : i64
        let s_1690_3: i64 = 1;
        // C s_1690_4: cast zx s_1690_3 -> i
        let s_1690_4: i128 = (i128::try_from(s_1690_3).unwrap());
        // C s_1690_5: const #0s : i
        let s_1690_5: i128 = 0;
        // C s_1690_6: add s_1690_5 s_1690_4
        let s_1690_6: i128 = (s_1690_5 + s_1690_4);
        // D s_1690_7: bit-extract s_1690_2 s_1690_0 s_1690_6
        let s_1690_7: Bits = (Bits::new(
            ((s_1690_2) >> (s_1690_0)).value(),
            u16::try_from(s_1690_6).unwrap(),
        ));
        // D s_1690_8: cast reint s_1690_7 -> u8
        let s_1690_8: bool = ((s_1690_7.value()) != 0);
        // D s_1690_9: cast zx s_1690_8 -> bv
        let s_1690_9: Bits = Bits::new(s_1690_8 as u128, 1u16);
        // C s_1690_10: const #0u : u8
        let s_1690_10: bool = false;
        // C s_1690_11: cast zx s_1690_10 -> bv
        let s_1690_11: Bits = Bits::new(s_1690_10 as u128, 1u16);
        // D s_1690_12: cmp-eq s_1690_9 s_1690_11
        let s_1690_12: bool = ((s_1690_9) == (s_1690_11));
        // D s_1690_13: write-var gs#403404 <= s_1690_12
        fn_state.gs_403404 = s_1690_12;
        // N s_1690_14: jump b1689
        return block_1689(state, tracer, fn_state);
    }
    fn block_1691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1691_0: const #3840s : i
        let s_1691_0: i128 = 3840;
        // C s_1691_1: const #14696u : u32
        let s_1691_1: u32 = 14696;
        // D s_1691_2: read-reg s_1691_1:i
        let s_1691_2: i128 = {
            let value = state.read_register::<i128>(s_1691_1 as isize);
            tracer.read_register(s_1691_1 as isize, value);
            value
        };
        // D s_1691_3: cmp-lt s_1691_2 s_1691_0
        let s_1691_3: bool = ((s_1691_2) < (s_1691_0));
        // D s_1691_4: write-var gs#403376 <= s_1691_3
        fn_state.gs_403376 = s_1691_3;
        // N s_1691_5: jump b1387
        return block_1387(state, tracer, fn_state);
    }
    fn block_1692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1692_0: const #20s : i
        let s_1692_0: i128 = 20;
        // D s_1692_1: read-var u#32218:u32
        let s_1692_1: u32 = fn_state.u_32218;
        // D s_1692_2: cast zx s_1692_1 -> bv
        let s_1692_2: Bits = Bits::new(s_1692_1 as u128, 32u16);
        // C s_1692_3: const #1s : i64
        let s_1692_3: i64 = 1;
        // C s_1692_4: cast zx s_1692_3 -> i
        let s_1692_4: i128 = (i128::try_from(s_1692_3).unwrap());
        // C s_1692_5: const #1s : i
        let s_1692_5: i128 = 1;
        // C s_1692_6: add s_1692_5 s_1692_4
        let s_1692_6: i128 = (s_1692_5 + s_1692_4);
        // D s_1692_7: bit-extract s_1692_2 s_1692_0 s_1692_6
        let s_1692_7: Bits = (Bits::new(
            ((s_1692_2) >> (s_1692_0)).value(),
            u16::try_from(s_1692_6).unwrap(),
        ));
        // D s_1692_8: cast reint s_1692_7 -> u8
        let s_1692_8: u8 = (s_1692_7.value() as u8);
        // D s_1692_9: cast zx s_1692_8 -> bv
        let s_1692_9: Bits = Bits::new(s_1692_8 as u128, 2u16);
        // C s_1692_10: const #3u : u8
        let s_1692_10: u8 = 3;
        // C s_1692_11: cast zx s_1692_10 -> bv
        let s_1692_11: Bits = Bits::new(s_1692_10 as u128, 2u16);
        // D s_1692_12: cmp-eq s_1692_9 s_1692_11
        let s_1692_12: bool = ((s_1692_9) == (s_1692_11));
        // N s_1692_13: branch s_1692_12 b1695 b1693
        if s_1692_12 {
            return block_1695(state, tracer, fn_state);
        } else {
            return block_1693(state, tracer, fn_state);
        };
    }
    fn block_1693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1693_0: const #0u : u8
        let s_1693_0: bool = false;
        // D s_1693_1: write-var gs#403373 <= s_1693_0
        fn_state.gs_403373 = s_1693_0;
        // N s_1693_2: jump b1694
        return block_1694(state, tracer, fn_state);
    }
    fn block_1694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1694_0: read-var gs#403373:u8
        let s_1694_0: bool = fn_state.gs_403373;
        // D s_1694_1: write-var gs#403374 <= s_1694_0
        fn_state.gs_403374 = s_1694_0;
        // N s_1694_2: jump b1385
        return block_1385(state, tracer, fn_state);
    }
    fn block_1695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1695_0: const #8s : i
        let s_1695_0: i128 = 8;
        // D s_1695_1: read-var u#32218:u32
        let s_1695_1: u32 = fn_state.u_32218;
        // D s_1695_2: cast zx s_1695_1 -> bv
        let s_1695_2: Bits = Bits::new(s_1695_1 as u128, 32u16);
        // C s_1695_3: const #1s : i64
        let s_1695_3: i64 = 1;
        // C s_1695_4: cast zx s_1695_3 -> i
        let s_1695_4: i128 = (i128::try_from(s_1695_3).unwrap());
        // C s_1695_5: const #3s : i
        let s_1695_5: i128 = 3;
        // C s_1695_6: add s_1695_5 s_1695_4
        let s_1695_6: i128 = (s_1695_5 + s_1695_4);
        // D s_1695_7: bit-extract s_1695_2 s_1695_0 s_1695_6
        let s_1695_7: Bits = (Bits::new(
            ((s_1695_2) >> (s_1695_0)).value(),
            u16::try_from(s_1695_6).unwrap(),
        ));
        // D s_1695_8: cast reint s_1695_7 -> u8
        let s_1695_8: u8 = (s_1695_7.value() as u8);
        // D s_1695_9: cast zx s_1695_8 -> bv
        let s_1695_9: Bits = Bits::new(s_1695_8 as u128, 4u16);
        // C s_1695_10: const #12u : u8
        let s_1695_10: u8 = 12;
        // C s_1695_11: cast zx s_1695_10 -> bv
        let s_1695_11: Bits = Bits::new(s_1695_10 as u128, 4u16);
        // D s_1695_12: cmp-eq s_1695_9 s_1695_11
        let s_1695_12: bool = ((s_1695_9) == (s_1695_11));
        // N s_1695_13: branch s_1695_12 b1698 b1696
        if s_1695_12 {
            return block_1698(state, tracer, fn_state);
        } else {
            return block_1696(state, tracer, fn_state);
        };
    }
    fn block_1696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1696_0: const #0u : u8
        let s_1696_0: bool = false;
        // D s_1696_1: write-var gs#403372 <= s_1696_0
        fn_state.gs_403372 = s_1696_0;
        // N s_1696_2: jump b1697
        return block_1697(state, tracer, fn_state);
    }
    fn block_1697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1697_0: read-var gs#403372:u8
        let s_1697_0: bool = fn_state.gs_403372;
        // D s_1697_1: write-var gs#403373 <= s_1697_0
        fn_state.gs_403373 = s_1697_0;
        // N s_1697_2: jump b1694
        return block_1694(state, tracer, fn_state);
    }
    fn block_1698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1698_0: const #4s : i
        let s_1698_0: i128 = 4;
        // D s_1698_1: read-var u#32218:u32
        let s_1698_1: u32 = fn_state.u_32218;
        // D s_1698_2: cast zx s_1698_1 -> bv
        let s_1698_2: Bits = Bits::new(s_1698_1 as u128, 32u16);
        // C s_1698_3: const #1s : i64
        let s_1698_3: i64 = 1;
        // C s_1698_4: cast zx s_1698_3 -> i
        let s_1698_4: i128 = (i128::try_from(s_1698_3).unwrap());
        // C s_1698_5: const #0s : i
        let s_1698_5: i128 = 0;
        // C s_1698_6: add s_1698_5 s_1698_4
        let s_1698_6: i128 = (s_1698_5 + s_1698_4);
        // D s_1698_7: bit-extract s_1698_2 s_1698_0 s_1698_6
        let s_1698_7: Bits = (Bits::new(
            ((s_1698_2) >> (s_1698_0)).value(),
            u16::try_from(s_1698_6).unwrap(),
        ));
        // D s_1698_8: cast reint s_1698_7 -> u8
        let s_1698_8: bool = ((s_1698_7.value()) != 0);
        // D s_1698_9: cast zx s_1698_8 -> bv
        let s_1698_9: Bits = Bits::new(s_1698_8 as u128, 1u16);
        // C s_1698_10: const #0u : u8
        let s_1698_10: bool = false;
        // C s_1698_11: cast zx s_1698_10 -> bv
        let s_1698_11: Bits = Bits::new(s_1698_10 as u128, 1u16);
        // D s_1698_12: cmp-eq s_1698_9 s_1698_11
        let s_1698_12: bool = ((s_1698_9) == (s_1698_11));
        // D s_1698_13: write-var gs#403372 <= s_1698_12
        fn_state.gs_403372 = s_1698_12;
        // N s_1698_14: jump b1697
        return block_1697(state, tracer, fn_state);
    }
    fn block_1699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1699_0: const #3838s : i
        let s_1699_0: i128 = 3838;
        // C s_1699_1: const #14696u : u32
        let s_1699_1: u32 = 14696;
        // D s_1699_2: read-reg s_1699_1:i
        let s_1699_2: i128 = {
            let value = state.read_register::<i128>(s_1699_1 as isize);
            tracer.read_register(s_1699_1 as isize, value);
            value
        };
        // D s_1699_3: cmp-lt s_1699_2 s_1699_0
        let s_1699_3: bool = ((s_1699_2) < (s_1699_0));
        // D s_1699_4: write-var gs#403346 <= s_1699_3
        fn_state.gs_403346 = s_1699_3;
        // N s_1699_5: jump b1381
        return block_1381(state, tracer, fn_state);
    }
    fn block_1700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1700_0: const #20s : i
        let s_1700_0: i128 = 20;
        // D s_1700_1: read-var u#32209:u32
        let s_1700_1: u32 = fn_state.u_32209;
        // D s_1700_2: cast zx s_1700_1 -> bv
        let s_1700_2: Bits = Bits::new(s_1700_1 as u128, 32u16);
        // C s_1700_3: const #1s : i64
        let s_1700_3: i64 = 1;
        // C s_1700_4: cast zx s_1700_3 -> i
        let s_1700_4: i128 = (i128::try_from(s_1700_3).unwrap());
        // C s_1700_5: const #1s : i
        let s_1700_5: i128 = 1;
        // C s_1700_6: add s_1700_5 s_1700_4
        let s_1700_6: i128 = (s_1700_5 + s_1700_4);
        // D s_1700_7: bit-extract s_1700_2 s_1700_0 s_1700_6
        let s_1700_7: Bits = (Bits::new(
            ((s_1700_2) >> (s_1700_0)).value(),
            u16::try_from(s_1700_6).unwrap(),
        ));
        // D s_1700_8: cast reint s_1700_7 -> u8
        let s_1700_8: u8 = (s_1700_7.value() as u8);
        // D s_1700_9: cast zx s_1700_8 -> bv
        let s_1700_9: Bits = Bits::new(s_1700_8 as u128, 2u16);
        // C s_1700_10: const #1u : u8
        let s_1700_10: u8 = 1;
        // C s_1700_11: cast zx s_1700_10 -> bv
        let s_1700_11: Bits = Bits::new(s_1700_10 as u128, 2u16);
        // D s_1700_12: cmp-eq s_1700_9 s_1700_11
        let s_1700_12: bool = ((s_1700_9) == (s_1700_11));
        // N s_1700_13: branch s_1700_12 b1703 b1701
        if s_1700_12 {
            return block_1703(state, tracer, fn_state);
        } else {
            return block_1701(state, tracer, fn_state);
        };
    }
    fn block_1701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1701_0: const #0u : u8
        let s_1701_0: bool = false;
        // D s_1701_1: write-var gs#403343 <= s_1701_0
        fn_state.gs_403343 = s_1701_0;
        // N s_1701_2: jump b1702
        return block_1702(state, tracer, fn_state);
    }
    fn block_1702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1702_0: read-var gs#403343:u8
        let s_1702_0: bool = fn_state.gs_403343;
        // D s_1702_1: write-var gs#403344 <= s_1702_0
        fn_state.gs_403344 = s_1702_0;
        // N s_1702_2: jump b1379
        return block_1379(state, tracer, fn_state);
    }
    fn block_1703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1703_0: const #8s : i
        let s_1703_0: i128 = 8;
        // D s_1703_1: read-var u#32209:u32
        let s_1703_1: u32 = fn_state.u_32209;
        // D s_1703_2: cast zx s_1703_1 -> bv
        let s_1703_2: Bits = Bits::new(s_1703_1 as u128, 32u16);
        // C s_1703_3: const #1s : i64
        let s_1703_3: i64 = 1;
        // C s_1703_4: cast zx s_1703_3 -> i
        let s_1703_4: i128 = (i128::try_from(s_1703_3).unwrap());
        // C s_1703_5: const #3s : i
        let s_1703_5: i128 = 3;
        // C s_1703_6: add s_1703_5 s_1703_4
        let s_1703_6: i128 = (s_1703_5 + s_1703_4);
        // D s_1703_7: bit-extract s_1703_2 s_1703_0 s_1703_6
        let s_1703_7: Bits = (Bits::new(
            ((s_1703_2) >> (s_1703_0)).value(),
            u16::try_from(s_1703_6).unwrap(),
        ));
        // D s_1703_8: cast reint s_1703_7 -> u8
        let s_1703_8: u8 = (s_1703_7.value() as u8);
        // D s_1703_9: cast zx s_1703_8 -> bv
        let s_1703_9: Bits = Bits::new(s_1703_8 as u128, 4u16);
        // C s_1703_10: const #12u : u8
        let s_1703_10: u8 = 12;
        // C s_1703_11: cast zx s_1703_10 -> bv
        let s_1703_11: Bits = Bits::new(s_1703_10 as u128, 4u16);
        // D s_1703_12: cmp-eq s_1703_9 s_1703_11
        let s_1703_12: bool = ((s_1703_9) == (s_1703_11));
        // N s_1703_13: branch s_1703_12 b1706 b1704
        if s_1703_12 {
            return block_1706(state, tracer, fn_state);
        } else {
            return block_1704(state, tracer, fn_state);
        };
    }
    fn block_1704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1704_0: const #0u : u8
        let s_1704_0: bool = false;
        // D s_1704_1: write-var gs#403342 <= s_1704_0
        fn_state.gs_403342 = s_1704_0;
        // N s_1704_2: jump b1705
        return block_1705(state, tracer, fn_state);
    }
    fn block_1705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1705_0: read-var gs#403342:u8
        let s_1705_0: bool = fn_state.gs_403342;
        // D s_1705_1: write-var gs#403343 <= s_1705_0
        fn_state.gs_403343 = s_1705_0;
        // N s_1705_2: jump b1702
        return block_1702(state, tracer, fn_state);
    }
    fn block_1706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1706_0: const #4s : i
        let s_1706_0: i128 = 4;
        // D s_1706_1: read-var u#32209:u32
        let s_1706_1: u32 = fn_state.u_32209;
        // D s_1706_2: cast zx s_1706_1 -> bv
        let s_1706_2: Bits = Bits::new(s_1706_1 as u128, 32u16);
        // C s_1706_3: const #1s : i64
        let s_1706_3: i64 = 1;
        // C s_1706_4: cast zx s_1706_3 -> i
        let s_1706_4: i128 = (i128::try_from(s_1706_3).unwrap());
        // C s_1706_5: const #0s : i
        let s_1706_5: i128 = 0;
        // C s_1706_6: add s_1706_5 s_1706_4
        let s_1706_6: i128 = (s_1706_5 + s_1706_4);
        // D s_1706_7: bit-extract s_1706_2 s_1706_0 s_1706_6
        let s_1706_7: Bits = (Bits::new(
            ((s_1706_2) >> (s_1706_0)).value(),
            u16::try_from(s_1706_6).unwrap(),
        ));
        // D s_1706_8: cast reint s_1706_7 -> u8
        let s_1706_8: bool = ((s_1706_7.value()) != 0);
        // D s_1706_9: cast zx s_1706_8 -> bv
        let s_1706_9: Bits = Bits::new(s_1706_8 as u128, 1u16);
        // C s_1706_10: const #0u : u8
        let s_1706_10: bool = false;
        // C s_1706_11: cast zx s_1706_10 -> bv
        let s_1706_11: Bits = Bits::new(s_1706_10 as u128, 1u16);
        // D s_1706_12: cmp-eq s_1706_9 s_1706_11
        let s_1706_12: bool = ((s_1706_9) == (s_1706_11));
        // D s_1706_13: write-var gs#403342 <= s_1706_12
        fn_state.gs_403342 = s_1706_12;
        // N s_1706_14: jump b1705
        return block_1705(state, tracer, fn_state);
    }
    fn block_1707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1707_0: const #3836s : i
        let s_1707_0: i128 = 3836;
        // C s_1707_1: const #14696u : u32
        let s_1707_1: u32 = 14696;
        // D s_1707_2: read-reg s_1707_1:i
        let s_1707_2: i128 = {
            let value = state.read_register::<i128>(s_1707_1 as isize);
            tracer.read_register(s_1707_1 as isize, value);
            value
        };
        // D s_1707_3: cmp-lt s_1707_2 s_1707_0
        let s_1707_3: bool = ((s_1707_2) < (s_1707_0));
        // D s_1707_4: write-var gs#403316 <= s_1707_3
        fn_state.gs_403316 = s_1707_3;
        // N s_1707_5: jump b1375
        return block_1375(state, tracer, fn_state);
    }
    fn block_1708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1708_0: const #20s : i
        let s_1708_0: i128 = 20;
        // D s_1708_1: read-var u#32200:u32
        let s_1708_1: u32 = fn_state.u_32200;
        // D s_1708_2: cast zx s_1708_1 -> bv
        let s_1708_2: Bits = Bits::new(s_1708_1 as u128, 32u16);
        // C s_1708_3: const #1s : i64
        let s_1708_3: i64 = 1;
        // C s_1708_4: cast zx s_1708_3 -> i
        let s_1708_4: i128 = (i128::try_from(s_1708_3).unwrap());
        // C s_1708_5: const #1s : i
        let s_1708_5: i128 = 1;
        // C s_1708_6: add s_1708_5 s_1708_4
        let s_1708_6: i128 = (s_1708_5 + s_1708_4);
        // D s_1708_7: bit-extract s_1708_2 s_1708_0 s_1708_6
        let s_1708_7: Bits = (Bits::new(
            ((s_1708_2) >> (s_1708_0)).value(),
            u16::try_from(s_1708_6).unwrap(),
        ));
        // D s_1708_8: cast reint s_1708_7 -> u8
        let s_1708_8: u8 = (s_1708_7.value() as u8);
        // D s_1708_9: cast zx s_1708_8 -> bv
        let s_1708_9: Bits = Bits::new(s_1708_8 as u128, 2u16);
        // C s_1708_10: const #2u : u8
        let s_1708_10: u8 = 2;
        // C s_1708_11: cast zx s_1708_10 -> bv
        let s_1708_11: Bits = Bits::new(s_1708_10 as u128, 2u16);
        // D s_1708_12: cmp-eq s_1708_9 s_1708_11
        let s_1708_12: bool = ((s_1708_9) == (s_1708_11));
        // N s_1708_13: branch s_1708_12 b1711 b1709
        if s_1708_12 {
            return block_1711(state, tracer, fn_state);
        } else {
            return block_1709(state, tracer, fn_state);
        };
    }
    fn block_1709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1709_0: const #0u : u8
        let s_1709_0: bool = false;
        // D s_1709_1: write-var gs#403313 <= s_1709_0
        fn_state.gs_403313 = s_1709_0;
        // N s_1709_2: jump b1710
        return block_1710(state, tracer, fn_state);
    }
    fn block_1710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1710_0: read-var gs#403313:u8
        let s_1710_0: bool = fn_state.gs_403313;
        // D s_1710_1: write-var gs#403314 <= s_1710_0
        fn_state.gs_403314 = s_1710_0;
        // N s_1710_2: jump b1373
        return block_1373(state, tracer, fn_state);
    }
    fn block_1711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1711_0: const #8s : i
        let s_1711_0: i128 = 8;
        // D s_1711_1: read-var u#32200:u32
        let s_1711_1: u32 = fn_state.u_32200;
        // D s_1711_2: cast zx s_1711_1 -> bv
        let s_1711_2: Bits = Bits::new(s_1711_1 as u128, 32u16);
        // C s_1711_3: const #1s : i64
        let s_1711_3: i64 = 1;
        // C s_1711_4: cast zx s_1711_3 -> i
        let s_1711_4: i128 = (i128::try_from(s_1711_3).unwrap());
        // C s_1711_5: const #3s : i
        let s_1711_5: i128 = 3;
        // C s_1711_6: add s_1711_5 s_1711_4
        let s_1711_6: i128 = (s_1711_5 + s_1711_4);
        // D s_1711_7: bit-extract s_1711_2 s_1711_0 s_1711_6
        let s_1711_7: Bits = (Bits::new(
            ((s_1711_2) >> (s_1711_0)).value(),
            u16::try_from(s_1711_6).unwrap(),
        ));
        // D s_1711_8: cast reint s_1711_7 -> u8
        let s_1711_8: u8 = (s_1711_7.value() as u8);
        // D s_1711_9: cast zx s_1711_8 -> bv
        let s_1711_9: Bits = Bits::new(s_1711_8 as u128, 4u16);
        // C s_1711_10: const #12u : u8
        let s_1711_10: u8 = 12;
        // C s_1711_11: cast zx s_1711_10 -> bv
        let s_1711_11: Bits = Bits::new(s_1711_10 as u128, 4u16);
        // D s_1711_12: cmp-eq s_1711_9 s_1711_11
        let s_1711_12: bool = ((s_1711_9) == (s_1711_11));
        // N s_1711_13: branch s_1711_12 b1714 b1712
        if s_1711_12 {
            return block_1714(state, tracer, fn_state);
        } else {
            return block_1712(state, tracer, fn_state);
        };
    }
    fn block_1712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1712_0: const #0u : u8
        let s_1712_0: bool = false;
        // D s_1712_1: write-var gs#403312 <= s_1712_0
        fn_state.gs_403312 = s_1712_0;
        // N s_1712_2: jump b1713
        return block_1713(state, tracer, fn_state);
    }
    fn block_1713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1713_0: read-var gs#403312:u8
        let s_1713_0: bool = fn_state.gs_403312;
        // D s_1713_1: write-var gs#403313 <= s_1713_0
        fn_state.gs_403313 = s_1713_0;
        // N s_1713_2: jump b1710
        return block_1710(state, tracer, fn_state);
    }
    fn block_1714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1714_0: const #4s : i
        let s_1714_0: i128 = 4;
        // D s_1714_1: read-var u#32200:u32
        let s_1714_1: u32 = fn_state.u_32200;
        // D s_1714_2: cast zx s_1714_1 -> bv
        let s_1714_2: Bits = Bits::new(s_1714_1 as u128, 32u16);
        // C s_1714_3: const #1s : i64
        let s_1714_3: i64 = 1;
        // C s_1714_4: cast zx s_1714_3 -> i
        let s_1714_4: i128 = (i128::try_from(s_1714_3).unwrap());
        // C s_1714_5: const #0s : i
        let s_1714_5: i128 = 0;
        // C s_1714_6: add s_1714_5 s_1714_4
        let s_1714_6: i128 = (s_1714_5 + s_1714_4);
        // D s_1714_7: bit-extract s_1714_2 s_1714_0 s_1714_6
        let s_1714_7: Bits = (Bits::new(
            ((s_1714_2) >> (s_1714_0)).value(),
            u16::try_from(s_1714_6).unwrap(),
        ));
        // D s_1714_8: cast reint s_1714_7 -> u8
        let s_1714_8: bool = ((s_1714_7.value()) != 0);
        // D s_1714_9: cast zx s_1714_8 -> bv
        let s_1714_9: Bits = Bits::new(s_1714_8 as u128, 1u16);
        // C s_1714_10: const #0u : u8
        let s_1714_10: bool = false;
        // C s_1714_11: cast zx s_1714_10 -> bv
        let s_1714_11: Bits = Bits::new(s_1714_10 as u128, 1u16);
        // D s_1714_12: cmp-eq s_1714_9 s_1714_11
        let s_1714_12: bool = ((s_1714_9) == (s_1714_11));
        // D s_1714_13: write-var gs#403312 <= s_1714_12
        fn_state.gs_403312 = s_1714_12;
        // N s_1714_14: jump b1713
        return block_1713(state, tracer, fn_state);
    }
    fn block_1715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1715_0: const #3834s : i
        let s_1715_0: i128 = 3834;
        // C s_1715_1: const #14696u : u32
        let s_1715_1: u32 = 14696;
        // D s_1715_2: read-reg s_1715_1:i
        let s_1715_2: i128 = {
            let value = state.read_register::<i128>(s_1715_1 as isize);
            tracer.read_register(s_1715_1 as isize, value);
            value
        };
        // D s_1715_3: cmp-lt s_1715_2 s_1715_0
        let s_1715_3: bool = ((s_1715_2) < (s_1715_0));
        // D s_1715_4: write-var gs#403290 <= s_1715_3
        fn_state.gs_403290 = s_1715_3;
        // N s_1715_5: jump b1369
        return block_1369(state, tracer, fn_state);
    }
    fn block_1716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1716_0: const #20s : i
        let s_1716_0: i128 = 20;
        // D s_1716_1: read-var u#32193:u32
        let s_1716_1: u32 = fn_state.u_32193;
        // D s_1716_2: cast zx s_1716_1 -> bv
        let s_1716_2: Bits = Bits::new(s_1716_1 as u128, 32u16);
        // C s_1716_3: const #1s : i64
        let s_1716_3: i64 = 1;
        // C s_1716_4: cast zx s_1716_3 -> i
        let s_1716_4: i128 = (i128::try_from(s_1716_3).unwrap());
        // C s_1716_5: const #1s : i
        let s_1716_5: i128 = 1;
        // C s_1716_6: add s_1716_5 s_1716_4
        let s_1716_6: i128 = (s_1716_5 + s_1716_4);
        // D s_1716_7: bit-extract s_1716_2 s_1716_0 s_1716_6
        let s_1716_7: Bits = (Bits::new(
            ((s_1716_2) >> (s_1716_0)).value(),
            u16::try_from(s_1716_6).unwrap(),
        ));
        // D s_1716_8: cast reint s_1716_7 -> u8
        let s_1716_8: u8 = (s_1716_7.value() as u8);
        // D s_1716_9: cast zx s_1716_8 -> bv
        let s_1716_9: Bits = Bits::new(s_1716_8 as u128, 2u16);
        // C s_1716_10: const #3u : u8
        let s_1716_10: u8 = 3;
        // C s_1716_11: cast zx s_1716_10 -> bv
        let s_1716_11: Bits = Bits::new(s_1716_10 as u128, 2u16);
        // D s_1716_12: cmp-eq s_1716_9 s_1716_11
        let s_1716_12: bool = ((s_1716_9) == (s_1716_11));
        // N s_1716_13: branch s_1716_12 b1719 b1717
        if s_1716_12 {
            return block_1719(state, tracer, fn_state);
        } else {
            return block_1717(state, tracer, fn_state);
        };
    }
    fn block_1717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1717_0: const #0u : u8
        let s_1717_0: bool = false;
        // D s_1717_1: write-var gs#403287 <= s_1717_0
        fn_state.gs_403287 = s_1717_0;
        // N s_1717_2: jump b1718
        return block_1718(state, tracer, fn_state);
    }
    fn block_1718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1718_0: read-var gs#403287:u8
        let s_1718_0: bool = fn_state.gs_403287;
        // D s_1718_1: write-var gs#403288 <= s_1718_0
        fn_state.gs_403288 = s_1718_0;
        // N s_1718_2: jump b1367
        return block_1367(state, tracer, fn_state);
    }
    fn block_1719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1719_0: const #16s : i
        let s_1719_0: i128 = 16;
        // D s_1719_1: read-var u#32193:u32
        let s_1719_1: u32 = fn_state.u_32193;
        // D s_1719_2: cast zx s_1719_1 -> bv
        let s_1719_2: Bits = Bits::new(s_1719_1 as u128, 32u16);
        // C s_1719_3: const #1s : i64
        let s_1719_3: i64 = 1;
        // C s_1719_4: cast zx s_1719_3 -> i
        let s_1719_4: i128 = (i128::try_from(s_1719_3).unwrap());
        // C s_1719_5: const #1s : i
        let s_1719_5: i128 = 1;
        // C s_1719_6: add s_1719_5 s_1719_4
        let s_1719_6: i128 = (s_1719_5 + s_1719_4);
        // D s_1719_7: bit-extract s_1719_2 s_1719_0 s_1719_6
        let s_1719_7: Bits = (Bits::new(
            ((s_1719_2) >> (s_1719_0)).value(),
            u16::try_from(s_1719_6).unwrap(),
        ));
        // D s_1719_8: cast reint s_1719_7 -> u8
        let s_1719_8: u8 = (s_1719_7.value() as u8);
        // D s_1719_9: cast zx s_1719_8 -> bv
        let s_1719_9: Bits = Bits::new(s_1719_8 as u128, 2u16);
        // C s_1719_10: const #1u : u8
        let s_1719_10: u8 = 1;
        // C s_1719_11: cast zx s_1719_10 -> bv
        let s_1719_11: Bits = Bits::new(s_1719_10 as u128, 2u16);
        // D s_1719_12: cmp-eq s_1719_9 s_1719_11
        let s_1719_12: bool = ((s_1719_9) == (s_1719_11));
        // N s_1719_13: branch s_1719_12 b1722 b1720
        if s_1719_12 {
            return block_1722(state, tracer, fn_state);
        } else {
            return block_1720(state, tracer, fn_state);
        };
    }
    fn block_1720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1720_0: const #0u : u8
        let s_1720_0: bool = false;
        // D s_1720_1: write-var gs#403286 <= s_1720_0
        fn_state.gs_403286 = s_1720_0;
        // N s_1720_2: jump b1721
        return block_1721(state, tracer, fn_state);
    }
    fn block_1721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1721_0: read-var gs#403286:u8
        let s_1721_0: bool = fn_state.gs_403286;
        // D s_1721_1: write-var gs#403287 <= s_1721_0
        fn_state.gs_403287 = s_1721_0;
        // N s_1721_2: jump b1718
        return block_1718(state, tracer, fn_state);
    }
    fn block_1722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1722_0: const #6s : i
        let s_1722_0: i128 = 6;
        // D s_1722_1: read-var u#32193:u32
        let s_1722_1: u32 = fn_state.u_32193;
        // D s_1722_2: cast zx s_1722_1 -> bv
        let s_1722_2: Bits = Bits::new(s_1722_1 as u128, 32u16);
        // C s_1722_3: const #1s : i64
        let s_1722_3: i64 = 1;
        // C s_1722_4: cast zx s_1722_3 -> i
        let s_1722_4: i128 = (i128::try_from(s_1722_3).unwrap());
        // C s_1722_5: const #5s : i
        let s_1722_5: i128 = 5;
        // C s_1722_6: add s_1722_5 s_1722_4
        let s_1722_6: i128 = (s_1722_5 + s_1722_4);
        // D s_1722_7: bit-extract s_1722_2 s_1722_0 s_1722_6
        let s_1722_7: Bits = (Bits::new(
            ((s_1722_2) >> (s_1722_0)).value(),
            u16::try_from(s_1722_6).unwrap(),
        ));
        // D s_1722_8: cast reint s_1722_7 -> u8
        let s_1722_8: u8 = (s_1722_7.value() as u8);
        // D s_1722_9: cast zx s_1722_8 -> bv
        let s_1722_9: Bits = Bits::new(s_1722_8 as u128, 6u16);
        // C s_1722_10: const #11u : u8
        let s_1722_10: u8 = 11;
        // C s_1722_11: cast zx s_1722_10 -> bv
        let s_1722_11: Bits = Bits::new(s_1722_10 as u128, 6u16);
        // D s_1722_12: cmp-eq s_1722_9 s_1722_11
        let s_1722_12: bool = ((s_1722_9) == (s_1722_11));
        // N s_1722_13: branch s_1722_12 b1725 b1723
        if s_1722_12 {
            return block_1725(state, tracer, fn_state);
        } else {
            return block_1723(state, tracer, fn_state);
        };
    }
    fn block_1723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1723_0: const #0u : u8
        let s_1723_0: bool = false;
        // D s_1723_1: write-var gs#403285 <= s_1723_0
        fn_state.gs_403285 = s_1723_0;
        // N s_1723_2: jump b1724
        return block_1724(state, tracer, fn_state);
    }
    fn block_1724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1724_0: read-var gs#403285:u8
        let s_1724_0: bool = fn_state.gs_403285;
        // D s_1724_1: write-var gs#403286 <= s_1724_0
        fn_state.gs_403286 = s_1724_0;
        // N s_1724_2: jump b1721
        return block_1721(state, tracer, fn_state);
    }
    fn block_1725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1725_0: const #4s : i
        let s_1725_0: i128 = 4;
        // D s_1725_1: read-var u#32193:u32
        let s_1725_1: u32 = fn_state.u_32193;
        // D s_1725_2: cast zx s_1725_1 -> bv
        let s_1725_2: Bits = Bits::new(s_1725_1 as u128, 32u16);
        // C s_1725_3: const #1s : i64
        let s_1725_3: i64 = 1;
        // C s_1725_4: cast zx s_1725_3 -> i
        let s_1725_4: i128 = (i128::try_from(s_1725_3).unwrap());
        // C s_1725_5: const #0s : i
        let s_1725_5: i128 = 0;
        // C s_1725_6: add s_1725_5 s_1725_4
        let s_1725_6: i128 = (s_1725_5 + s_1725_4);
        // D s_1725_7: bit-extract s_1725_2 s_1725_0 s_1725_6
        let s_1725_7: Bits = (Bits::new(
            ((s_1725_2) >> (s_1725_0)).value(),
            u16::try_from(s_1725_6).unwrap(),
        ));
        // D s_1725_8: cast reint s_1725_7 -> u8
        let s_1725_8: bool = ((s_1725_7.value()) != 0);
        // D s_1725_9: cast zx s_1725_8 -> bv
        let s_1725_9: Bits = Bits::new(s_1725_8 as u128, 1u16);
        // C s_1725_10: const #0u : u8
        let s_1725_10: bool = false;
        // C s_1725_11: cast zx s_1725_10 -> bv
        let s_1725_11: Bits = Bits::new(s_1725_10 as u128, 1u16);
        // D s_1725_12: cmp-eq s_1725_9 s_1725_11
        let s_1725_12: bool = ((s_1725_9) == (s_1725_11));
        // D s_1725_13: write-var gs#403285 <= s_1725_12
        fn_state.gs_403285 = s_1725_12;
        // N s_1725_14: jump b1724
        return block_1724(state, tracer, fn_state);
    }
    fn block_1726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1726_0: const #3832s : i
        let s_1726_0: i128 = 3832;
        // C s_1726_1: const #14696u : u32
        let s_1726_1: u32 = 14696;
        // D s_1726_2: read-reg s_1726_1:i
        let s_1726_2: i128 = {
            let value = state.read_register::<i128>(s_1726_1 as isize);
            tracer.read_register(s_1726_1 as isize, value);
            value
        };
        // D s_1726_3: cmp-lt s_1726_2 s_1726_0
        let s_1726_3: bool = ((s_1726_2) < (s_1726_0));
        // D s_1726_4: write-var gs#403257 <= s_1726_3
        fn_state.gs_403257 = s_1726_3;
        // N s_1726_5: jump b1363
        return block_1363(state, tracer, fn_state);
    }
    fn block_1727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1727_0: const #20s : i
        let s_1727_0: i128 = 20;
        // D s_1727_1: read-var u#32184:u32
        let s_1727_1: u32 = fn_state.u_32184;
        // D s_1727_2: cast zx s_1727_1 -> bv
        let s_1727_2: Bits = Bits::new(s_1727_1 as u128, 32u16);
        // C s_1727_3: const #1s : i64
        let s_1727_3: i64 = 1;
        // C s_1727_4: cast zx s_1727_3 -> i
        let s_1727_4: i128 = (i128::try_from(s_1727_3).unwrap());
        // C s_1727_5: const #1s : i
        let s_1727_5: i128 = 1;
        // C s_1727_6: add s_1727_5 s_1727_4
        let s_1727_6: i128 = (s_1727_5 + s_1727_4);
        // D s_1727_7: bit-extract s_1727_2 s_1727_0 s_1727_6
        let s_1727_7: Bits = (Bits::new(
            ((s_1727_2) >> (s_1727_0)).value(),
            u16::try_from(s_1727_6).unwrap(),
        ));
        // D s_1727_8: cast reint s_1727_7 -> u8
        let s_1727_8: u8 = (s_1727_7.value() as u8);
        // D s_1727_9: cast zx s_1727_8 -> bv
        let s_1727_9: Bits = Bits::new(s_1727_8 as u128, 2u16);
        // C s_1727_10: const #0u : u8
        let s_1727_10: u8 = 0;
        // C s_1727_11: cast zx s_1727_10 -> bv
        let s_1727_11: Bits = Bits::new(s_1727_10 as u128, 2u16);
        // D s_1727_12: cmp-eq s_1727_9 s_1727_11
        let s_1727_12: bool = ((s_1727_9) == (s_1727_11));
        // N s_1727_13: branch s_1727_12 b1730 b1728
        if s_1727_12 {
            return block_1730(state, tracer, fn_state);
        } else {
            return block_1728(state, tracer, fn_state);
        };
    }
    fn block_1728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1728_0: const #0u : u8
        let s_1728_0: bool = false;
        // D s_1728_1: write-var gs#403254 <= s_1728_0
        fn_state.gs_403254 = s_1728_0;
        // N s_1728_2: jump b1729
        return block_1729(state, tracer, fn_state);
    }
    fn block_1729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1729_0: read-var gs#403254:u8
        let s_1729_0: bool = fn_state.gs_403254;
        // D s_1729_1: write-var gs#403255 <= s_1729_0
        fn_state.gs_403255 = s_1729_0;
        // N s_1729_2: jump b1361
        return block_1361(state, tracer, fn_state);
    }
    fn block_1730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1730_0: const #8s : i
        let s_1730_0: i128 = 8;
        // D s_1730_1: read-var u#32184:u32
        let s_1730_1: u32 = fn_state.u_32184;
        // D s_1730_2: cast zx s_1730_1 -> bv
        let s_1730_2: Bits = Bits::new(s_1730_1 as u128, 32u16);
        // C s_1730_3: const #1s : i64
        let s_1730_3: i64 = 1;
        // C s_1730_4: cast zx s_1730_3 -> i
        let s_1730_4: i128 = (i128::try_from(s_1730_3).unwrap());
        // C s_1730_5: const #3s : i
        let s_1730_5: i128 = 3;
        // C s_1730_6: add s_1730_5 s_1730_4
        let s_1730_6: i128 = (s_1730_5 + s_1730_4);
        // D s_1730_7: bit-extract s_1730_2 s_1730_0 s_1730_6
        let s_1730_7: Bits = (Bits::new(
            ((s_1730_2) >> (s_1730_0)).value(),
            u16::try_from(s_1730_6).unwrap(),
        ));
        // D s_1730_8: cast reint s_1730_7 -> u8
        let s_1730_8: u8 = (s_1730_7.value() as u8);
        // D s_1730_9: cast zx s_1730_8 -> bv
        let s_1730_9: Bits = Bits::new(s_1730_8 as u128, 4u16);
        // C s_1730_10: const #12u : u8
        let s_1730_10: u8 = 12;
        // C s_1730_11: cast zx s_1730_10 -> bv
        let s_1730_11: Bits = Bits::new(s_1730_10 as u128, 4u16);
        // D s_1730_12: cmp-eq s_1730_9 s_1730_11
        let s_1730_12: bool = ((s_1730_9) == (s_1730_11));
        // N s_1730_13: branch s_1730_12 b1733 b1731
        if s_1730_12 {
            return block_1733(state, tracer, fn_state);
        } else {
            return block_1731(state, tracer, fn_state);
        };
    }
    fn block_1731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1731_0: const #0u : u8
        let s_1731_0: bool = false;
        // D s_1731_1: write-var gs#403253 <= s_1731_0
        fn_state.gs_403253 = s_1731_0;
        // N s_1731_2: jump b1732
        return block_1732(state, tracer, fn_state);
    }
    fn block_1732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1732_0: read-var gs#403253:u8
        let s_1732_0: bool = fn_state.gs_403253;
        // D s_1732_1: write-var gs#403254 <= s_1732_0
        fn_state.gs_403254 = s_1732_0;
        // N s_1732_2: jump b1729
        return block_1729(state, tracer, fn_state);
    }
    fn block_1733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1733_0: const #4s : i
        let s_1733_0: i128 = 4;
        // D s_1733_1: read-var u#32184:u32
        let s_1733_1: u32 = fn_state.u_32184;
        // D s_1733_2: cast zx s_1733_1 -> bv
        let s_1733_2: Bits = Bits::new(s_1733_1 as u128, 32u16);
        // C s_1733_3: const #1s : i64
        let s_1733_3: i64 = 1;
        // C s_1733_4: cast zx s_1733_3 -> i
        let s_1733_4: i128 = (i128::try_from(s_1733_3).unwrap());
        // C s_1733_5: const #0s : i
        let s_1733_5: i128 = 0;
        // C s_1733_6: add s_1733_5 s_1733_4
        let s_1733_6: i128 = (s_1733_5 + s_1733_4);
        // D s_1733_7: bit-extract s_1733_2 s_1733_0 s_1733_6
        let s_1733_7: Bits = (Bits::new(
            ((s_1733_2) >> (s_1733_0)).value(),
            u16::try_from(s_1733_6).unwrap(),
        ));
        // D s_1733_8: cast reint s_1733_7 -> u8
        let s_1733_8: bool = ((s_1733_7.value()) != 0);
        // D s_1733_9: cast zx s_1733_8 -> bv
        let s_1733_9: Bits = Bits::new(s_1733_8 as u128, 1u16);
        // C s_1733_10: const #0u : u8
        let s_1733_10: bool = false;
        // C s_1733_11: cast zx s_1733_10 -> bv
        let s_1733_11: Bits = Bits::new(s_1733_10 as u128, 1u16);
        // D s_1733_12: cmp-eq s_1733_9 s_1733_11
        let s_1733_12: bool = ((s_1733_9) == (s_1733_11));
        // D s_1733_13: write-var gs#403253 <= s_1733_12
        fn_state.gs_403253 = s_1733_12;
        // N s_1733_14: jump b1732
        return block_1732(state, tracer, fn_state);
    }
    fn block_1734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1734_0: const #3806s : i
        let s_1734_0: i128 = 3806;
        // C s_1734_1: const #14696u : u32
        let s_1734_1: u32 = 14696;
        // D s_1734_2: read-reg s_1734_1:i
        let s_1734_2: i128 = {
            let value = state.read_register::<i128>(s_1734_1 as isize);
            tracer.read_register(s_1734_1 as isize, value);
            value
        };
        // D s_1734_3: cmp-lt s_1734_2 s_1734_0
        let s_1734_3: bool = ((s_1734_2) < (s_1734_0));
        // D s_1734_4: write-var gs#403231 <= s_1734_3
        fn_state.gs_403231 = s_1734_3;
        // N s_1734_5: jump b1357
        return block_1357(state, tracer, fn_state);
    }
    fn block_1735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1735_0: const #20s : i
        let s_1735_0: i128 = 20;
        // D s_1735_1: read-var u#32177:u32
        let s_1735_1: u32 = fn_state.u_32177;
        // D s_1735_2: cast zx s_1735_1 -> bv
        let s_1735_2: Bits = Bits::new(s_1735_1 as u128, 32u16);
        // C s_1735_3: const #1s : i64
        let s_1735_3: i64 = 1;
        // C s_1735_4: cast zx s_1735_3 -> i
        let s_1735_4: i128 = (i128::try_from(s_1735_3).unwrap());
        // C s_1735_5: const #1s : i
        let s_1735_5: i128 = 1;
        // C s_1735_6: add s_1735_5 s_1735_4
        let s_1735_6: i128 = (s_1735_5 + s_1735_4);
        // D s_1735_7: bit-extract s_1735_2 s_1735_0 s_1735_6
        let s_1735_7: Bits = (Bits::new(
            ((s_1735_2) >> (s_1735_0)).value(),
            u16::try_from(s_1735_6).unwrap(),
        ));
        // D s_1735_8: cast reint s_1735_7 -> u8
        let s_1735_8: u8 = (s_1735_7.value() as u8);
        // D s_1735_9: cast zx s_1735_8 -> bv
        let s_1735_9: Bits = Bits::new(s_1735_8 as u128, 2u16);
        // C s_1735_10: const #3u : u8
        let s_1735_10: u8 = 3;
        // C s_1735_11: cast zx s_1735_10 -> bv
        let s_1735_11: Bits = Bits::new(s_1735_10 as u128, 2u16);
        // D s_1735_12: cmp-eq s_1735_9 s_1735_11
        let s_1735_12: bool = ((s_1735_9) == (s_1735_11));
        // N s_1735_13: branch s_1735_12 b1738 b1736
        if s_1735_12 {
            return block_1738(state, tracer, fn_state);
        } else {
            return block_1736(state, tracer, fn_state);
        };
    }
    fn block_1736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1736_0: const #0u : u8
        let s_1736_0: bool = false;
        // D s_1736_1: write-var gs#403228 <= s_1736_0
        fn_state.gs_403228 = s_1736_0;
        // N s_1736_2: jump b1737
        return block_1737(state, tracer, fn_state);
    }
    fn block_1737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1737_0: read-var gs#403228:u8
        let s_1737_0: bool = fn_state.gs_403228;
        // D s_1737_1: write-var gs#403229 <= s_1737_0
        fn_state.gs_403229 = s_1737_0;
        // N s_1737_2: jump b1355
        return block_1355(state, tracer, fn_state);
    }
    fn block_1738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1738_0: const #16s : i
        let s_1738_0: i128 = 16;
        // D s_1738_1: read-var u#32177:u32
        let s_1738_1: u32 = fn_state.u_32177;
        // D s_1738_2: cast zx s_1738_1 -> bv
        let s_1738_2: Bits = Bits::new(s_1738_1 as u128, 32u16);
        // C s_1738_3: const #1s : i64
        let s_1738_3: i64 = 1;
        // C s_1738_4: cast zx s_1738_3 -> i
        let s_1738_4: i128 = (i128::try_from(s_1738_3).unwrap());
        // C s_1738_5: const #1s : i
        let s_1738_5: i128 = 1;
        // C s_1738_6: add s_1738_5 s_1738_4
        let s_1738_6: i128 = (s_1738_5 + s_1738_4);
        // D s_1738_7: bit-extract s_1738_2 s_1738_0 s_1738_6
        let s_1738_7: Bits = (Bits::new(
            ((s_1738_2) >> (s_1738_0)).value(),
            u16::try_from(s_1738_6).unwrap(),
        ));
        // D s_1738_8: cast reint s_1738_7 -> u8
        let s_1738_8: u8 = (s_1738_7.value() as u8);
        // D s_1738_9: cast zx s_1738_8 -> bv
        let s_1738_9: Bits = Bits::new(s_1738_8 as u128, 2u16);
        // C s_1738_10: const #0u : u8
        let s_1738_10: u8 = 0;
        // C s_1738_11: cast zx s_1738_10 -> bv
        let s_1738_11: Bits = Bits::new(s_1738_10 as u128, 2u16);
        // D s_1738_12: cmp-eq s_1738_9 s_1738_11
        let s_1738_12: bool = ((s_1738_9) == (s_1738_11));
        // N s_1738_13: branch s_1738_12 b1741 b1739
        if s_1738_12 {
            return block_1741(state, tracer, fn_state);
        } else {
            return block_1739(state, tracer, fn_state);
        };
    }
    fn block_1739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1739_0: const #0u : u8
        let s_1739_0: bool = false;
        // D s_1739_1: write-var gs#403227 <= s_1739_0
        fn_state.gs_403227 = s_1739_0;
        // N s_1739_2: jump b1740
        return block_1740(state, tracer, fn_state);
    }
    fn block_1740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1740_0: read-var gs#403227:u8
        let s_1740_0: bool = fn_state.gs_403227;
        // D s_1740_1: write-var gs#403228 <= s_1740_0
        fn_state.gs_403228 = s_1740_0;
        // N s_1740_2: jump b1737
        return block_1737(state, tracer, fn_state);
    }
    fn block_1741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1741_0: const #6s : i
        let s_1741_0: i128 = 6;
        // D s_1741_1: read-var u#32177:u32
        let s_1741_1: u32 = fn_state.u_32177;
        // D s_1741_2: cast zx s_1741_1 -> bv
        let s_1741_2: Bits = Bits::new(s_1741_1 as u128, 32u16);
        // C s_1741_3: const #1s : i64
        let s_1741_3: i64 = 1;
        // C s_1741_4: cast zx s_1741_3 -> i
        let s_1741_4: i128 = (i128::try_from(s_1741_3).unwrap());
        // C s_1741_5: const #5s : i
        let s_1741_5: i128 = 5;
        // C s_1741_6: add s_1741_5 s_1741_4
        let s_1741_6: i128 = (s_1741_5 + s_1741_4);
        // D s_1741_7: bit-extract s_1741_2 s_1741_0 s_1741_6
        let s_1741_7: Bits = (Bits::new(
            ((s_1741_2) >> (s_1741_0)).value(),
            u16::try_from(s_1741_6).unwrap(),
        ));
        // D s_1741_8: cast reint s_1741_7 -> u8
        let s_1741_8: u8 = (s_1741_7.value() as u8);
        // D s_1741_9: cast zx s_1741_8 -> bv
        let s_1741_9: Bits = Bits::new(s_1741_8 as u128, 6u16);
        // C s_1741_10: const #14u : u8
        let s_1741_10: u8 = 14;
        // C s_1741_11: cast zx s_1741_10 -> bv
        let s_1741_11: Bits = Bits::new(s_1741_10 as u128, 6u16);
        // D s_1741_12: cmp-eq s_1741_9 s_1741_11
        let s_1741_12: bool = ((s_1741_9) == (s_1741_11));
        // N s_1741_13: branch s_1741_12 b1744 b1742
        if s_1741_12 {
            return block_1744(state, tracer, fn_state);
        } else {
            return block_1742(state, tracer, fn_state);
        };
    }
    fn block_1742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1742_0: const #0u : u8
        let s_1742_0: bool = false;
        // D s_1742_1: write-var gs#403226 <= s_1742_0
        fn_state.gs_403226 = s_1742_0;
        // N s_1742_2: jump b1743
        return block_1743(state, tracer, fn_state);
    }
    fn block_1743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1743_0: read-var gs#403226:u8
        let s_1743_0: bool = fn_state.gs_403226;
        // D s_1743_1: write-var gs#403227 <= s_1743_0
        fn_state.gs_403227 = s_1743_0;
        // N s_1743_2: jump b1740
        return block_1740(state, tracer, fn_state);
    }
    fn block_1744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1744_0: const #4s : i
        let s_1744_0: i128 = 4;
        // D s_1744_1: read-var u#32177:u32
        let s_1744_1: u32 = fn_state.u_32177;
        // D s_1744_2: cast zx s_1744_1 -> bv
        let s_1744_2: Bits = Bits::new(s_1744_1 as u128, 32u16);
        // C s_1744_3: const #1s : i64
        let s_1744_3: i64 = 1;
        // C s_1744_4: cast zx s_1744_3 -> i
        let s_1744_4: i128 = (i128::try_from(s_1744_3).unwrap());
        // C s_1744_5: const #0s : i
        let s_1744_5: i128 = 0;
        // C s_1744_6: add s_1744_5 s_1744_4
        let s_1744_6: i128 = (s_1744_5 + s_1744_4);
        // D s_1744_7: bit-extract s_1744_2 s_1744_0 s_1744_6
        let s_1744_7: Bits = (Bits::new(
            ((s_1744_2) >> (s_1744_0)).value(),
            u16::try_from(s_1744_6).unwrap(),
        ));
        // D s_1744_8: cast reint s_1744_7 -> u8
        let s_1744_8: bool = ((s_1744_7.value()) != 0);
        // D s_1744_9: cast zx s_1744_8 -> bv
        let s_1744_9: Bits = Bits::new(s_1744_8 as u128, 1u16);
        // C s_1744_10: const #0u : u8
        let s_1744_10: bool = false;
        // C s_1744_11: cast zx s_1744_10 -> bv
        let s_1744_11: Bits = Bits::new(s_1744_10 as u128, 1u16);
        // D s_1744_12: cmp-eq s_1744_9 s_1744_11
        let s_1744_12: bool = ((s_1744_9) == (s_1744_11));
        // D s_1744_13: write-var gs#403226 <= s_1744_12
        fn_state.gs_403226 = s_1744_12;
        // N s_1744_14: jump b1743
        return block_1743(state, tracer, fn_state);
    }
    fn block_1745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1745_0: const #3804s : i
        let s_1745_0: i128 = 3804;
        // C s_1745_1: const #14696u : u32
        let s_1745_1: u32 = 14696;
        // D s_1745_2: read-reg s_1745_1:i
        let s_1745_2: i128 = {
            let value = state.read_register::<i128>(s_1745_1 as isize);
            tracer.read_register(s_1745_1 as isize, value);
            value
        };
        // D s_1745_3: cmp-lt s_1745_2 s_1745_0
        let s_1745_3: bool = ((s_1745_2) < (s_1745_0));
        // D s_1745_4: write-var gs#403202 <= s_1745_3
        fn_state.gs_403202 = s_1745_3;
        // N s_1745_5: jump b1351
        return block_1351(state, tracer, fn_state);
    }
    fn block_1746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1746_0: const #20s : i
        let s_1746_0: i128 = 20;
        // D s_1746_1: read-var u#32170:u32
        let s_1746_1: u32 = fn_state.u_32170;
        // D s_1746_2: cast zx s_1746_1 -> bv
        let s_1746_2: Bits = Bits::new(s_1746_1 as u128, 32u16);
        // C s_1746_3: const #1s : i64
        let s_1746_3: i64 = 1;
        // C s_1746_4: cast zx s_1746_3 -> i
        let s_1746_4: i128 = (i128::try_from(s_1746_3).unwrap());
        // C s_1746_5: const #1s : i
        let s_1746_5: i128 = 1;
        // C s_1746_6: add s_1746_5 s_1746_4
        let s_1746_6: i128 = (s_1746_5 + s_1746_4);
        // D s_1746_7: bit-extract s_1746_2 s_1746_0 s_1746_6
        let s_1746_7: Bits = (Bits::new(
            ((s_1746_2) >> (s_1746_0)).value(),
            u16::try_from(s_1746_6).unwrap(),
        ));
        // D s_1746_8: cast reint s_1746_7 -> u8
        let s_1746_8: u8 = (s_1746_7.value() as u8);
        // D s_1746_9: cast zx s_1746_8 -> bv
        let s_1746_9: Bits = Bits::new(s_1746_8 as u128, 2u16);
        // C s_1746_10: const #3u : u8
        let s_1746_10: u8 = 3;
        // C s_1746_11: cast zx s_1746_10 -> bv
        let s_1746_11: Bits = Bits::new(s_1746_10 as u128, 2u16);
        // D s_1746_12: cmp-eq s_1746_9 s_1746_11
        let s_1746_12: bool = ((s_1746_9) == (s_1746_11));
        // N s_1746_13: branch s_1746_12 b1749 b1747
        if s_1746_12 {
            return block_1749(state, tracer, fn_state);
        } else {
            return block_1747(state, tracer, fn_state);
        };
    }
    fn block_1747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1747_0: const #0u : u8
        let s_1747_0: bool = false;
        // D s_1747_1: write-var gs#403199 <= s_1747_0
        fn_state.gs_403199 = s_1747_0;
        // N s_1747_2: jump b1748
        return block_1748(state, tracer, fn_state);
    }
    fn block_1748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1748_0: read-var gs#403199:u8
        let s_1748_0: bool = fn_state.gs_403199;
        // D s_1748_1: write-var gs#403200 <= s_1748_0
        fn_state.gs_403200 = s_1748_0;
        // N s_1748_2: jump b1349
        return block_1349(state, tracer, fn_state);
    }
    fn block_1749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1749_0: const #16s : i
        let s_1749_0: i128 = 16;
        // D s_1749_1: read-var u#32170:u32
        let s_1749_1: u32 = fn_state.u_32170;
        // D s_1749_2: cast zx s_1749_1 -> bv
        let s_1749_2: Bits = Bits::new(s_1749_1 as u128, 32u16);
        // C s_1749_3: const #1s : i64
        let s_1749_3: i64 = 1;
        // C s_1749_4: cast zx s_1749_3 -> i
        let s_1749_4: i128 = (i128::try_from(s_1749_3).unwrap());
        // C s_1749_5: const #1s : i
        let s_1749_5: i128 = 1;
        // C s_1749_6: add s_1749_5 s_1749_4
        let s_1749_6: i128 = (s_1749_5 + s_1749_4);
        // D s_1749_7: bit-extract s_1749_2 s_1749_0 s_1749_6
        let s_1749_7: Bits = (Bits::new(
            ((s_1749_2) >> (s_1749_0)).value(),
            u16::try_from(s_1749_6).unwrap(),
        ));
        // D s_1749_8: cast reint s_1749_7 -> u8
        let s_1749_8: u8 = (s_1749_7.value() as u8);
        // D s_1749_9: cast zx s_1749_8 -> bv
        let s_1749_9: Bits = Bits::new(s_1749_8 as u128, 2u16);
        // C s_1749_10: const #0u : u8
        let s_1749_10: u8 = 0;
        // C s_1749_11: cast zx s_1749_10 -> bv
        let s_1749_11: Bits = Bits::new(s_1749_10 as u128, 2u16);
        // D s_1749_12: cmp-eq s_1749_9 s_1749_11
        let s_1749_12: bool = ((s_1749_9) == (s_1749_11));
        // N s_1749_13: branch s_1749_12 b1752 b1750
        if s_1749_12 {
            return block_1752(state, tracer, fn_state);
        } else {
            return block_1750(state, tracer, fn_state);
        };
    }
    fn block_1750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1750_0: const #0u : u8
        let s_1750_0: bool = false;
        // D s_1750_1: write-var gs#403198 <= s_1750_0
        fn_state.gs_403198 = s_1750_0;
        // N s_1750_2: jump b1751
        return block_1751(state, tracer, fn_state);
    }
    fn block_1751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1751_0: read-var gs#403198:u8
        let s_1751_0: bool = fn_state.gs_403198;
        // D s_1751_1: write-var gs#403199 <= s_1751_0
        fn_state.gs_403199 = s_1751_0;
        // N s_1751_2: jump b1748
        return block_1748(state, tracer, fn_state);
    }
    fn block_1752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1752_0: const #6s : i
        let s_1752_0: i128 = 6;
        // D s_1752_1: read-var u#32170:u32
        let s_1752_1: u32 = fn_state.u_32170;
        // D s_1752_2: cast zx s_1752_1 -> bv
        let s_1752_2: Bits = Bits::new(s_1752_1 as u128, 32u16);
        // C s_1752_3: const #1s : i64
        let s_1752_3: i64 = 1;
        // C s_1752_4: cast zx s_1752_3 -> i
        let s_1752_4: i128 = (i128::try_from(s_1752_3).unwrap());
        // C s_1752_5: const #5s : i
        let s_1752_5: i128 = 5;
        // C s_1752_6: add s_1752_5 s_1752_4
        let s_1752_6: i128 = (s_1752_5 + s_1752_4);
        // D s_1752_7: bit-extract s_1752_2 s_1752_0 s_1752_6
        let s_1752_7: Bits = (Bits::new(
            ((s_1752_2) >> (s_1752_0)).value(),
            u16::try_from(s_1752_6).unwrap(),
        ));
        // D s_1752_8: cast reint s_1752_7 -> u8
        let s_1752_8: u8 = (s_1752_7.value() as u8);
        // D s_1752_9: cast zx s_1752_8 -> bv
        let s_1752_9: Bits = Bits::new(s_1752_8 as u128, 6u16);
        // C s_1752_10: const #15u : u8
        let s_1752_10: u8 = 15;
        // C s_1752_11: cast zx s_1752_10 -> bv
        let s_1752_11: Bits = Bits::new(s_1752_10 as u128, 6u16);
        // D s_1752_12: cmp-eq s_1752_9 s_1752_11
        let s_1752_12: bool = ((s_1752_9) == (s_1752_11));
        // N s_1752_13: branch s_1752_12 b1755 b1753
        if s_1752_12 {
            return block_1755(state, tracer, fn_state);
        } else {
            return block_1753(state, tracer, fn_state);
        };
    }
    fn block_1753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1753_0: const #0u : u8
        let s_1753_0: bool = false;
        // D s_1753_1: write-var gs#403197 <= s_1753_0
        fn_state.gs_403197 = s_1753_0;
        // N s_1753_2: jump b1754
        return block_1754(state, tracer, fn_state);
    }
    fn block_1754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1754_0: read-var gs#403197:u8
        let s_1754_0: bool = fn_state.gs_403197;
        // D s_1754_1: write-var gs#403198 <= s_1754_0
        fn_state.gs_403198 = s_1754_0;
        // N s_1754_2: jump b1751
        return block_1751(state, tracer, fn_state);
    }
    fn block_1755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1755_0: const #4s : i
        let s_1755_0: i128 = 4;
        // D s_1755_1: read-var u#32170:u32
        let s_1755_1: u32 = fn_state.u_32170;
        // D s_1755_2: cast zx s_1755_1 -> bv
        let s_1755_2: Bits = Bits::new(s_1755_1 as u128, 32u16);
        // C s_1755_3: const #1s : i64
        let s_1755_3: i64 = 1;
        // C s_1755_4: cast zx s_1755_3 -> i
        let s_1755_4: i128 = (i128::try_from(s_1755_3).unwrap());
        // C s_1755_5: const #0s : i
        let s_1755_5: i128 = 0;
        // C s_1755_6: add s_1755_5 s_1755_4
        let s_1755_6: i128 = (s_1755_5 + s_1755_4);
        // D s_1755_7: bit-extract s_1755_2 s_1755_0 s_1755_6
        let s_1755_7: Bits = (Bits::new(
            ((s_1755_2) >> (s_1755_0)).value(),
            u16::try_from(s_1755_6).unwrap(),
        ));
        // D s_1755_8: cast reint s_1755_7 -> u8
        let s_1755_8: bool = ((s_1755_7.value()) != 0);
        // D s_1755_9: cast zx s_1755_8 -> bv
        let s_1755_9: Bits = Bits::new(s_1755_8 as u128, 1u16);
        // C s_1755_10: const #0u : u8
        let s_1755_10: bool = false;
        // C s_1755_11: cast zx s_1755_10 -> bv
        let s_1755_11: Bits = Bits::new(s_1755_10 as u128, 1u16);
        // D s_1755_12: cmp-eq s_1755_9 s_1755_11
        let s_1755_12: bool = ((s_1755_9) == (s_1755_11));
        // D s_1755_13: write-var gs#403197 <= s_1755_12
        fn_state.gs_403197 = s_1755_12;
        // N s_1755_14: jump b1754
        return block_1754(state, tracer, fn_state);
    }
    fn block_1756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1756_0: const #3802s : i
        let s_1756_0: i128 = 3802;
        // C s_1756_1: const #14696u : u32
        let s_1756_1: u32 = 14696;
        // D s_1756_2: read-reg s_1756_1:i
        let s_1756_2: i128 = {
            let value = state.read_register::<i128>(s_1756_1 as isize);
            tracer.read_register(s_1756_1 as isize, value);
            value
        };
        // D s_1756_3: cmp-lt s_1756_2 s_1756_0
        let s_1756_3: bool = ((s_1756_2) < (s_1756_0));
        // D s_1756_4: write-var gs#403173 <= s_1756_3
        fn_state.gs_403173 = s_1756_3;
        // N s_1756_5: jump b1345
        return block_1345(state, tracer, fn_state);
    }
    fn block_1757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1757_0: const #20s : i
        let s_1757_0: i128 = 20;
        // D s_1757_1: read-var u#32163:u32
        let s_1757_1: u32 = fn_state.u_32163;
        // D s_1757_2: cast zx s_1757_1 -> bv
        let s_1757_2: Bits = Bits::new(s_1757_1 as u128, 32u16);
        // C s_1757_3: const #1s : i64
        let s_1757_3: i64 = 1;
        // C s_1757_4: cast zx s_1757_3 -> i
        let s_1757_4: i128 = (i128::try_from(s_1757_3).unwrap());
        // C s_1757_5: const #1s : i
        let s_1757_5: i128 = 1;
        // C s_1757_6: add s_1757_5 s_1757_4
        let s_1757_6: i128 = (s_1757_5 + s_1757_4);
        // D s_1757_7: bit-extract s_1757_2 s_1757_0 s_1757_6
        let s_1757_7: Bits = (Bits::new(
            ((s_1757_2) >> (s_1757_0)).value(),
            u16::try_from(s_1757_6).unwrap(),
        ));
        // D s_1757_8: cast reint s_1757_7 -> u8
        let s_1757_8: u8 = (s_1757_7.value() as u8);
        // D s_1757_9: cast zx s_1757_8 -> bv
        let s_1757_9: Bits = Bits::new(s_1757_8 as u128, 2u16);
        // C s_1757_10: const #3u : u8
        let s_1757_10: u8 = 3;
        // C s_1757_11: cast zx s_1757_10 -> bv
        let s_1757_11: Bits = Bits::new(s_1757_10 as u128, 2u16);
        // D s_1757_12: cmp-eq s_1757_9 s_1757_11
        let s_1757_12: bool = ((s_1757_9) == (s_1757_11));
        // N s_1757_13: branch s_1757_12 b1760 b1758
        if s_1757_12 {
            return block_1760(state, tracer, fn_state);
        } else {
            return block_1758(state, tracer, fn_state);
        };
    }
    fn block_1758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1758_0: const #0u : u8
        let s_1758_0: bool = false;
        // D s_1758_1: write-var gs#403170 <= s_1758_0
        fn_state.gs_403170 = s_1758_0;
        // N s_1758_2: jump b1759
        return block_1759(state, tracer, fn_state);
    }
    fn block_1759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1759_0: read-var gs#403170:u8
        let s_1759_0: bool = fn_state.gs_403170;
        // D s_1759_1: write-var gs#403171 <= s_1759_0
        fn_state.gs_403171 = s_1759_0;
        // N s_1759_2: jump b1343
        return block_1343(state, tracer, fn_state);
    }
    fn block_1760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1760_0: const #16s : i
        let s_1760_0: i128 = 16;
        // D s_1760_1: read-var u#32163:u32
        let s_1760_1: u32 = fn_state.u_32163;
        // D s_1760_2: cast zx s_1760_1 -> bv
        let s_1760_2: Bits = Bits::new(s_1760_1 as u128, 32u16);
        // C s_1760_3: const #1s : i64
        let s_1760_3: i64 = 1;
        // C s_1760_4: cast zx s_1760_3 -> i
        let s_1760_4: i128 = (i128::try_from(s_1760_3).unwrap());
        // C s_1760_5: const #1s : i
        let s_1760_5: i128 = 1;
        // C s_1760_6: add s_1760_5 s_1760_4
        let s_1760_6: i128 = (s_1760_5 + s_1760_4);
        // D s_1760_7: bit-extract s_1760_2 s_1760_0 s_1760_6
        let s_1760_7: Bits = (Bits::new(
            ((s_1760_2) >> (s_1760_0)).value(),
            u16::try_from(s_1760_6).unwrap(),
        ));
        // D s_1760_8: cast reint s_1760_7 -> u8
        let s_1760_8: u8 = (s_1760_7.value() as u8);
        // D s_1760_9: cast zx s_1760_8 -> bv
        let s_1760_9: Bits = Bits::new(s_1760_8 as u128, 2u16);
        // C s_1760_10: const #0u : u8
        let s_1760_10: u8 = 0;
        // C s_1760_11: cast zx s_1760_10 -> bv
        let s_1760_11: Bits = Bits::new(s_1760_10 as u128, 2u16);
        // D s_1760_12: cmp-eq s_1760_9 s_1760_11
        let s_1760_12: bool = ((s_1760_9) == (s_1760_11));
        // N s_1760_13: branch s_1760_12 b1763 b1761
        if s_1760_12 {
            return block_1763(state, tracer, fn_state);
        } else {
            return block_1761(state, tracer, fn_state);
        };
    }
    fn block_1761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1761_0: const #0u : u8
        let s_1761_0: bool = false;
        // D s_1761_1: write-var gs#403169 <= s_1761_0
        fn_state.gs_403169 = s_1761_0;
        // N s_1761_2: jump b1762
        return block_1762(state, tracer, fn_state);
    }
    fn block_1762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1762_0: read-var gs#403169:u8
        let s_1762_0: bool = fn_state.gs_403169;
        // D s_1762_1: write-var gs#403170 <= s_1762_0
        fn_state.gs_403170 = s_1762_0;
        // N s_1762_2: jump b1759
        return block_1759(state, tracer, fn_state);
    }
    fn block_1763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1763_0: const #6s : i
        let s_1763_0: i128 = 6;
        // D s_1763_1: read-var u#32163:u32
        let s_1763_1: u32 = fn_state.u_32163;
        // D s_1763_2: cast zx s_1763_1 -> bv
        let s_1763_2: Bits = Bits::new(s_1763_1 as u128, 32u16);
        // C s_1763_3: const #1s : i64
        let s_1763_3: i64 = 1;
        // C s_1763_4: cast zx s_1763_3 -> i
        let s_1763_4: i128 = (i128::try_from(s_1763_3).unwrap());
        // C s_1763_5: const #5s : i
        let s_1763_5: i128 = 5;
        // C s_1763_6: add s_1763_5 s_1763_4
        let s_1763_6: i128 = (s_1763_5 + s_1763_4);
        // D s_1763_7: bit-extract s_1763_2 s_1763_0 s_1763_6
        let s_1763_7: Bits = (Bits::new(
            ((s_1763_2) >> (s_1763_0)).value(),
            u16::try_from(s_1763_6).unwrap(),
        ));
        // D s_1763_8: cast reint s_1763_7 -> u8
        let s_1763_8: u8 = (s_1763_7.value() as u8);
        // D s_1763_9: cast zx s_1763_8 -> bv
        let s_1763_9: Bits = Bits::new(s_1763_8 as u128, 6u16);
        // C s_1763_10: const #12u : u8
        let s_1763_10: u8 = 12;
        // C s_1763_11: cast zx s_1763_10 -> bv
        let s_1763_11: Bits = Bits::new(s_1763_10 as u128, 6u16);
        // D s_1763_12: cmp-eq s_1763_9 s_1763_11
        let s_1763_12: bool = ((s_1763_9) == (s_1763_11));
        // N s_1763_13: branch s_1763_12 b1766 b1764
        if s_1763_12 {
            return block_1766(state, tracer, fn_state);
        } else {
            return block_1764(state, tracer, fn_state);
        };
    }
    fn block_1764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1764_0: const #0u : u8
        let s_1764_0: bool = false;
        // D s_1764_1: write-var gs#403168 <= s_1764_0
        fn_state.gs_403168 = s_1764_0;
        // N s_1764_2: jump b1765
        return block_1765(state, tracer, fn_state);
    }
    fn block_1765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1765_0: read-var gs#403168:u8
        let s_1765_0: bool = fn_state.gs_403168;
        // D s_1765_1: write-var gs#403169 <= s_1765_0
        fn_state.gs_403169 = s_1765_0;
        // N s_1765_2: jump b1762
        return block_1762(state, tracer, fn_state);
    }
    fn block_1766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1766_0: const #4s : i
        let s_1766_0: i128 = 4;
        // D s_1766_1: read-var u#32163:u32
        let s_1766_1: u32 = fn_state.u_32163;
        // D s_1766_2: cast zx s_1766_1 -> bv
        let s_1766_2: Bits = Bits::new(s_1766_1 as u128, 32u16);
        // C s_1766_3: const #1s : i64
        let s_1766_3: i64 = 1;
        // C s_1766_4: cast zx s_1766_3 -> i
        let s_1766_4: i128 = (i128::try_from(s_1766_3).unwrap());
        // C s_1766_5: const #0s : i
        let s_1766_5: i128 = 0;
        // C s_1766_6: add s_1766_5 s_1766_4
        let s_1766_6: i128 = (s_1766_5 + s_1766_4);
        // D s_1766_7: bit-extract s_1766_2 s_1766_0 s_1766_6
        let s_1766_7: Bits = (Bits::new(
            ((s_1766_2) >> (s_1766_0)).value(),
            u16::try_from(s_1766_6).unwrap(),
        ));
        // D s_1766_8: cast reint s_1766_7 -> u8
        let s_1766_8: bool = ((s_1766_7.value()) != 0);
        // D s_1766_9: cast zx s_1766_8 -> bv
        let s_1766_9: Bits = Bits::new(s_1766_8 as u128, 1u16);
        // C s_1766_10: const #0u : u8
        let s_1766_10: bool = false;
        // C s_1766_11: cast zx s_1766_10 -> bv
        let s_1766_11: Bits = Bits::new(s_1766_10 as u128, 1u16);
        // D s_1766_12: cmp-eq s_1766_9 s_1766_11
        let s_1766_12: bool = ((s_1766_9) == (s_1766_11));
        // D s_1766_13: write-var gs#403168 <= s_1766_12
        fn_state.gs_403168 = s_1766_12;
        // N s_1766_14: jump b1765
        return block_1765(state, tracer, fn_state);
    }
    fn block_1767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1767_0: const #3800s : i
        let s_1767_0: i128 = 3800;
        // C s_1767_1: const #14696u : u32
        let s_1767_1: u32 = 14696;
        // D s_1767_2: read-reg s_1767_1:i
        let s_1767_2: i128 = {
            let value = state.read_register::<i128>(s_1767_1 as isize);
            tracer.read_register(s_1767_1 as isize, value);
            value
        };
        // D s_1767_3: cmp-lt s_1767_2 s_1767_0
        let s_1767_3: bool = ((s_1767_2) < (s_1767_0));
        // D s_1767_4: write-var gs#403144 <= s_1767_3
        fn_state.gs_403144 = s_1767_3;
        // N s_1767_5: jump b1339
        return block_1339(state, tracer, fn_state);
    }
    fn block_1768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1768_0: const #20s : i
        let s_1768_0: i128 = 20;
        // D s_1768_1: read-var u#32156:u32
        let s_1768_1: u32 = fn_state.u_32156;
        // D s_1768_2: cast zx s_1768_1 -> bv
        let s_1768_2: Bits = Bits::new(s_1768_1 as u128, 32u16);
        // C s_1768_3: const #1s : i64
        let s_1768_3: i64 = 1;
        // C s_1768_4: cast zx s_1768_3 -> i
        let s_1768_4: i128 = (i128::try_from(s_1768_3).unwrap());
        // C s_1768_5: const #1s : i
        let s_1768_5: i128 = 1;
        // C s_1768_6: add s_1768_5 s_1768_4
        let s_1768_6: i128 = (s_1768_5 + s_1768_4);
        // D s_1768_7: bit-extract s_1768_2 s_1768_0 s_1768_6
        let s_1768_7: Bits = (Bits::new(
            ((s_1768_2) >> (s_1768_0)).value(),
            u16::try_from(s_1768_6).unwrap(),
        ));
        // D s_1768_8: cast reint s_1768_7 -> u8
        let s_1768_8: u8 = (s_1768_7.value() as u8);
        // D s_1768_9: cast zx s_1768_8 -> bv
        let s_1768_9: Bits = Bits::new(s_1768_8 as u128, 2u16);
        // C s_1768_10: const #3u : u8
        let s_1768_10: u8 = 3;
        // C s_1768_11: cast zx s_1768_10 -> bv
        let s_1768_11: Bits = Bits::new(s_1768_10 as u128, 2u16);
        // D s_1768_12: cmp-eq s_1768_9 s_1768_11
        let s_1768_12: bool = ((s_1768_9) == (s_1768_11));
        // N s_1768_13: branch s_1768_12 b1771 b1769
        if s_1768_12 {
            return block_1771(state, tracer, fn_state);
        } else {
            return block_1769(state, tracer, fn_state);
        };
    }
    fn block_1769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1769_0: const #0u : u8
        let s_1769_0: bool = false;
        // D s_1769_1: write-var gs#403141 <= s_1769_0
        fn_state.gs_403141 = s_1769_0;
        // N s_1769_2: jump b1770
        return block_1770(state, tracer, fn_state);
    }
    fn block_1770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1770_0: read-var gs#403141:u8
        let s_1770_0: bool = fn_state.gs_403141;
        // D s_1770_1: write-var gs#403142 <= s_1770_0
        fn_state.gs_403142 = s_1770_0;
        // N s_1770_2: jump b1337
        return block_1337(state, tracer, fn_state);
    }
    fn block_1771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1771_0: const #16s : i
        let s_1771_0: i128 = 16;
        // D s_1771_1: read-var u#32156:u32
        let s_1771_1: u32 = fn_state.u_32156;
        // D s_1771_2: cast zx s_1771_1 -> bv
        let s_1771_2: Bits = Bits::new(s_1771_1 as u128, 32u16);
        // C s_1771_3: const #1s : i64
        let s_1771_3: i64 = 1;
        // C s_1771_4: cast zx s_1771_3 -> i
        let s_1771_4: i128 = (i128::try_from(s_1771_3).unwrap());
        // C s_1771_5: const #1s : i
        let s_1771_5: i128 = 1;
        // C s_1771_6: add s_1771_5 s_1771_4
        let s_1771_6: i128 = (s_1771_5 + s_1771_4);
        // D s_1771_7: bit-extract s_1771_2 s_1771_0 s_1771_6
        let s_1771_7: Bits = (Bits::new(
            ((s_1771_2) >> (s_1771_0)).value(),
            u16::try_from(s_1771_6).unwrap(),
        ));
        // D s_1771_8: cast reint s_1771_7 -> u8
        let s_1771_8: u8 = (s_1771_7.value() as u8);
        // D s_1771_9: cast zx s_1771_8 -> bv
        let s_1771_9: Bits = Bits::new(s_1771_8 as u128, 2u16);
        // C s_1771_10: const #0u : u8
        let s_1771_10: u8 = 0;
        // C s_1771_11: cast zx s_1771_10 -> bv
        let s_1771_11: Bits = Bits::new(s_1771_10 as u128, 2u16);
        // D s_1771_12: cmp-eq s_1771_9 s_1771_11
        let s_1771_12: bool = ((s_1771_9) == (s_1771_11));
        // N s_1771_13: branch s_1771_12 b1774 b1772
        if s_1771_12 {
            return block_1774(state, tracer, fn_state);
        } else {
            return block_1772(state, tracer, fn_state);
        };
    }
    fn block_1772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1772_0: const #0u : u8
        let s_1772_0: bool = false;
        // D s_1772_1: write-var gs#403140 <= s_1772_0
        fn_state.gs_403140 = s_1772_0;
        // N s_1772_2: jump b1773
        return block_1773(state, tracer, fn_state);
    }
    fn block_1773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1773_0: read-var gs#403140:u8
        let s_1773_0: bool = fn_state.gs_403140;
        // D s_1773_1: write-var gs#403141 <= s_1773_0
        fn_state.gs_403141 = s_1773_0;
        // N s_1773_2: jump b1770
        return block_1770(state, tracer, fn_state);
    }
    fn block_1774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1774_0: const #6s : i
        let s_1774_0: i128 = 6;
        // D s_1774_1: read-var u#32156:u32
        let s_1774_1: u32 = fn_state.u_32156;
        // D s_1774_2: cast zx s_1774_1 -> bv
        let s_1774_2: Bits = Bits::new(s_1774_1 as u128, 32u16);
        // C s_1774_3: const #1s : i64
        let s_1774_3: i64 = 1;
        // C s_1774_4: cast zx s_1774_3 -> i
        let s_1774_4: i128 = (i128::try_from(s_1774_3).unwrap());
        // C s_1774_5: const #5s : i
        let s_1774_5: i128 = 5;
        // C s_1774_6: add s_1774_5 s_1774_4
        let s_1774_6: i128 = (s_1774_5 + s_1774_4);
        // D s_1774_7: bit-extract s_1774_2 s_1774_0 s_1774_6
        let s_1774_7: Bits = (Bits::new(
            ((s_1774_2) >> (s_1774_0)).value(),
            u16::try_from(s_1774_6).unwrap(),
        ));
        // D s_1774_8: cast reint s_1774_7 -> u8
        let s_1774_8: u8 = (s_1774_7.value() as u8);
        // D s_1774_9: cast zx s_1774_8 -> bv
        let s_1774_9: Bits = Bits::new(s_1774_8 as u128, 6u16);
        // C s_1774_10: const #13u : u8
        let s_1774_10: u8 = 13;
        // C s_1774_11: cast zx s_1774_10 -> bv
        let s_1774_11: Bits = Bits::new(s_1774_10 as u128, 6u16);
        // D s_1774_12: cmp-eq s_1774_9 s_1774_11
        let s_1774_12: bool = ((s_1774_9) == (s_1774_11));
        // N s_1774_13: branch s_1774_12 b1777 b1775
        if s_1774_12 {
            return block_1777(state, tracer, fn_state);
        } else {
            return block_1775(state, tracer, fn_state);
        };
    }
    fn block_1775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1775_0: const #0u : u8
        let s_1775_0: bool = false;
        // D s_1775_1: write-var gs#403139 <= s_1775_0
        fn_state.gs_403139 = s_1775_0;
        // N s_1775_2: jump b1776
        return block_1776(state, tracer, fn_state);
    }
    fn block_1776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1776_0: read-var gs#403139:u8
        let s_1776_0: bool = fn_state.gs_403139;
        // D s_1776_1: write-var gs#403140 <= s_1776_0
        fn_state.gs_403140 = s_1776_0;
        // N s_1776_2: jump b1773
        return block_1773(state, tracer, fn_state);
    }
    fn block_1777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1777_0: const #4s : i
        let s_1777_0: i128 = 4;
        // D s_1777_1: read-var u#32156:u32
        let s_1777_1: u32 = fn_state.u_32156;
        // D s_1777_2: cast zx s_1777_1 -> bv
        let s_1777_2: Bits = Bits::new(s_1777_1 as u128, 32u16);
        // C s_1777_3: const #1s : i64
        let s_1777_3: i64 = 1;
        // C s_1777_4: cast zx s_1777_3 -> i
        let s_1777_4: i128 = (i128::try_from(s_1777_3).unwrap());
        // C s_1777_5: const #0s : i
        let s_1777_5: i128 = 0;
        // C s_1777_6: add s_1777_5 s_1777_4
        let s_1777_6: i128 = (s_1777_5 + s_1777_4);
        // D s_1777_7: bit-extract s_1777_2 s_1777_0 s_1777_6
        let s_1777_7: Bits = (Bits::new(
            ((s_1777_2) >> (s_1777_0)).value(),
            u16::try_from(s_1777_6).unwrap(),
        ));
        // D s_1777_8: cast reint s_1777_7 -> u8
        let s_1777_8: bool = ((s_1777_7.value()) != 0);
        // D s_1777_9: cast zx s_1777_8 -> bv
        let s_1777_9: Bits = Bits::new(s_1777_8 as u128, 1u16);
        // C s_1777_10: const #0u : u8
        let s_1777_10: bool = false;
        // C s_1777_11: cast zx s_1777_10 -> bv
        let s_1777_11: Bits = Bits::new(s_1777_10 as u128, 1u16);
        // D s_1777_12: cmp-eq s_1777_9 s_1777_11
        let s_1777_12: bool = ((s_1777_9) == (s_1777_11));
        // D s_1777_13: write-var gs#403139 <= s_1777_12
        fn_state.gs_403139 = s_1777_12;
        // N s_1777_14: jump b1776
        return block_1776(state, tracer, fn_state);
    }
    fn block_1778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1778_0: const #3769s : i
        let s_1778_0: i128 = 3769;
        // C s_1778_1: const #14696u : u32
        let s_1778_1: u32 = 14696;
        // D s_1778_2: read-reg s_1778_1:i
        let s_1778_2: i128 = {
            let value = state.read_register::<i128>(s_1778_1 as isize);
            tracer.read_register(s_1778_1 as isize, value);
            value
        };
        // D s_1778_3: cmp-lt s_1778_2 s_1778_0
        let s_1778_3: bool = ((s_1778_2) < (s_1778_0));
        // D s_1778_4: write-var gs#403093 <= s_1778_3
        fn_state.gs_403093 = s_1778_3;
        // N s_1778_5: jump b1313
        return block_1313(state, tracer, fn_state);
    }
    fn block_1779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1779_0: const #9s : i
        let s_1779_0: i128 = 9;
        // D s_1779_1: read-var u#32152:u32
        let s_1779_1: u32 = fn_state.u_32152;
        // D s_1779_2: cast zx s_1779_1 -> bv
        let s_1779_2: Bits = Bits::new(s_1779_1 as u128, 32u16);
        // C s_1779_3: const #1s : i64
        let s_1779_3: i64 = 1;
        // C s_1779_4: cast zx s_1779_3 -> i
        let s_1779_4: i128 = (i128::try_from(s_1779_3).unwrap());
        // C s_1779_5: const #7s : i
        let s_1779_5: i128 = 7;
        // C s_1779_6: add s_1779_5 s_1779_4
        let s_1779_6: i128 = (s_1779_5 + s_1779_4);
        // D s_1779_7: bit-extract s_1779_2 s_1779_0 s_1779_6
        let s_1779_7: Bits = (Bits::new(
            ((s_1779_2) >> (s_1779_0)).value(),
            u16::try_from(s_1779_6).unwrap(),
        ));
        // D s_1779_8: cast reint s_1779_7 -> u8
        let s_1779_8: u8 = (s_1779_7.value() as u8);
        // D s_1779_9: cast zx s_1779_8 -> bv
        let s_1779_9: Bits = Bits::new(s_1779_8 as u128, 8u16);
        // C s_1779_10: const #0u : u8
        let s_1779_10: u8 = 0;
        // C s_1779_11: cast zx s_1779_10 -> bv
        let s_1779_11: Bits = Bits::new(s_1779_10 as u128, 8u16);
        // D s_1779_12: cmp-eq s_1779_9 s_1779_11
        let s_1779_12: bool = ((s_1779_9) == (s_1779_11));
        // N s_1779_13: branch s_1779_12 b1782 b1780
        if s_1779_12 {
            return block_1782(state, tracer, fn_state);
        } else {
            return block_1780(state, tracer, fn_state);
        };
    }
    fn block_1780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1780_0: const #0u : u8
        let s_1780_0: bool = false;
        // D s_1780_1: write-var gs#403090 <= s_1780_0
        fn_state.gs_403090 = s_1780_0;
        // N s_1780_2: jump b1781
        return block_1781(state, tracer, fn_state);
    }
    fn block_1781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1781_0: read-var gs#403090:u8
        let s_1781_0: bool = fn_state.gs_403090;
        // D s_1781_1: write-var gs#403091 <= s_1781_0
        fn_state.gs_403091 = s_1781_0;
        // N s_1781_2: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_1782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1782_0: const #5s : i
        let s_1782_0: i128 = 5;
        // D s_1782_1: read-var u#32152:u32
        let s_1782_1: u32 = fn_state.u_32152;
        // D s_1782_2: cast zx s_1782_1 -> bv
        let s_1782_2: Bits = Bits::new(s_1782_1 as u128, 32u16);
        // C s_1782_3: const #1s : i64
        let s_1782_3: i64 = 1;
        // C s_1782_4: cast zx s_1782_3 -> i
        let s_1782_4: i128 = (i128::try_from(s_1782_3).unwrap());
        // C s_1782_5: const #0s : i
        let s_1782_5: i128 = 0;
        // C s_1782_6: add s_1782_5 s_1782_4
        let s_1782_6: i128 = (s_1782_5 + s_1782_4);
        // D s_1782_7: bit-extract s_1782_2 s_1782_0 s_1782_6
        let s_1782_7: Bits = (Bits::new(
            ((s_1782_2) >> (s_1782_0)).value(),
            u16::try_from(s_1782_6).unwrap(),
        ));
        // D s_1782_8: cast reint s_1782_7 -> u8
        let s_1782_8: bool = ((s_1782_7.value()) != 0);
        // D s_1782_9: cast zx s_1782_8 -> bv
        let s_1782_9: Bits = Bits::new(s_1782_8 as u128, 1u16);
        // C s_1782_10: const #0u : u8
        let s_1782_10: bool = false;
        // C s_1782_11: cast zx s_1782_10 -> bv
        let s_1782_11: Bits = Bits::new(s_1782_10 as u128, 1u16);
        // D s_1782_12: cmp-eq s_1782_9 s_1782_11
        let s_1782_12: bool = ((s_1782_9) == (s_1782_11));
        // D s_1782_13: write-var gs#403090 <= s_1782_12
        fn_state.gs_403090 = s_1782_12;
        // N s_1782_14: jump b1781
        return block_1781(state, tracer, fn_state);
    }
    fn block_1783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1783_0: const #3758s : i
        let s_1783_0: i128 = 3758;
        // C s_1783_1: const #14696u : u32
        let s_1783_1: u32 = 14696;
        // D s_1783_2: read-reg s_1783_1:i
        let s_1783_2: i128 = {
            let value = state.read_register::<i128>(s_1783_1 as isize);
            tracer.read_register(s_1783_1 as isize, value);
            value
        };
        // D s_1783_3: cmp-lt s_1783_2 s_1783_0
        let s_1783_3: bool = ((s_1783_2) < (s_1783_0));
        // D s_1783_4: write-var gs#403068 <= s_1783_3
        fn_state.gs_403068 = s_1783_3;
        // N s_1783_5: jump b1307
        return block_1307(state, tracer, fn_state);
    }
    fn block_1784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1784_0: const #20s : i
        let s_1784_0: i128 = 20;
        // D s_1784_1: read-var u#32144:u32
        let s_1784_1: u32 = fn_state.u_32144;
        // D s_1784_2: cast zx s_1784_1 -> bv
        let s_1784_2: Bits = Bits::new(s_1784_1 as u128, 32u16);
        // C s_1784_3: const #1s : i64
        let s_1784_3: i64 = 1;
        // C s_1784_4: cast zx s_1784_3 -> i
        let s_1784_4: i128 = (i128::try_from(s_1784_3).unwrap());
        // C s_1784_5: const #1s : i
        let s_1784_5: i128 = 1;
        // C s_1784_6: add s_1784_5 s_1784_4
        let s_1784_6: i128 = (s_1784_5 + s_1784_4);
        // D s_1784_7: bit-extract s_1784_2 s_1784_0 s_1784_6
        let s_1784_7: Bits = (Bits::new(
            ((s_1784_2) >> (s_1784_0)).value(),
            u16::try_from(s_1784_6).unwrap(),
        ));
        // D s_1784_8: cast reint s_1784_7 -> u8
        let s_1784_8: u8 = (s_1784_7.value() as u8);
        // D s_1784_9: cast zx s_1784_8 -> bv
        let s_1784_9: Bits = Bits::new(s_1784_8 as u128, 2u16);
        // C s_1784_10: const #3u : u8
        let s_1784_10: u8 = 3;
        // C s_1784_11: cast zx s_1784_10 -> bv
        let s_1784_11: Bits = Bits::new(s_1784_10 as u128, 2u16);
        // D s_1784_12: cmp-eq s_1784_9 s_1784_11
        let s_1784_12: bool = ((s_1784_9) == (s_1784_11));
        // N s_1784_13: branch s_1784_12 b1787 b1785
        if s_1784_12 {
            return block_1787(state, tracer, fn_state);
        } else {
            return block_1785(state, tracer, fn_state);
        };
    }
    fn block_1785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1785_0: const #0u : u8
        let s_1785_0: bool = false;
        // D s_1785_1: write-var gs#403065 <= s_1785_0
        fn_state.gs_403065 = s_1785_0;
        // N s_1785_2: jump b1786
        return block_1786(state, tracer, fn_state);
    }
    fn block_1786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1786_0: read-var gs#403065:u8
        let s_1786_0: bool = fn_state.gs_403065;
        // D s_1786_1: write-var gs#403066 <= s_1786_0
        fn_state.gs_403066 = s_1786_0;
        // N s_1786_2: jump b1305
        return block_1305(state, tracer, fn_state);
    }
    fn block_1787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1787_0: const #16s : i
        let s_1787_0: i128 = 16;
        // D s_1787_1: read-var u#32144:u32
        let s_1787_1: u32 = fn_state.u_32144;
        // D s_1787_2: cast zx s_1787_1 -> bv
        let s_1787_2: Bits = Bits::new(s_1787_1 as u128, 32u16);
        // C s_1787_3: const #1s : i64
        let s_1787_3: i64 = 1;
        // C s_1787_4: cast zx s_1787_3 -> i
        let s_1787_4: i128 = (i128::try_from(s_1787_3).unwrap());
        // C s_1787_5: const #1s : i
        let s_1787_5: i128 = 1;
        // C s_1787_6: add s_1787_5 s_1787_4
        let s_1787_6: i128 = (s_1787_5 + s_1787_4);
        // D s_1787_7: bit-extract s_1787_2 s_1787_0 s_1787_6
        let s_1787_7: Bits = (Bits::new(
            ((s_1787_2) >> (s_1787_0)).value(),
            u16::try_from(s_1787_6).unwrap(),
        ));
        // D s_1787_8: cast reint s_1787_7 -> u8
        let s_1787_8: u8 = (s_1787_7.value() as u8);
        // D s_1787_9: cast zx s_1787_8 -> bv
        let s_1787_9: Bits = Bits::new(s_1787_8 as u128, 2u16);
        // C s_1787_10: const #2u : u8
        let s_1787_10: u8 = 2;
        // C s_1787_11: cast zx s_1787_10 -> bv
        let s_1787_11: Bits = Bits::new(s_1787_10 as u128, 2u16);
        // D s_1787_12: cmp-eq s_1787_9 s_1787_11
        let s_1787_12: bool = ((s_1787_9) == (s_1787_11));
        // N s_1787_13: branch s_1787_12 b1790 b1788
        if s_1787_12 {
            return block_1790(state, tracer, fn_state);
        } else {
            return block_1788(state, tracer, fn_state);
        };
    }
    fn block_1788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1788_0: const #0u : u8
        let s_1788_0: bool = false;
        // D s_1788_1: write-var gs#403064 <= s_1788_0
        fn_state.gs_403064 = s_1788_0;
        // N s_1788_2: jump b1789
        return block_1789(state, tracer, fn_state);
    }
    fn block_1789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1789_0: read-var gs#403064:u8
        let s_1789_0: bool = fn_state.gs_403064;
        // D s_1789_1: write-var gs#403065 <= s_1789_0
        fn_state.gs_403065 = s_1789_0;
        // N s_1789_2: jump b1786
        return block_1786(state, tracer, fn_state);
    }
    fn block_1790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1790_0: const #7s : i
        let s_1790_0: i128 = 7;
        // D s_1790_1: read-var u#32144:u32
        let s_1790_1: u32 = fn_state.u_32144;
        // D s_1790_2: cast zx s_1790_1 -> bv
        let s_1790_2: Bits = Bits::new(s_1790_1 as u128, 32u16);
        // C s_1790_3: const #1s : i64
        let s_1790_3: i64 = 1;
        // C s_1790_4: cast zx s_1790_3 -> i
        let s_1790_4: i128 = (i128::try_from(s_1790_3).unwrap());
        // C s_1790_5: const #4s : i
        let s_1790_5: i128 = 4;
        // C s_1790_6: add s_1790_5 s_1790_4
        let s_1790_6: i128 = (s_1790_5 + s_1790_4);
        // D s_1790_7: bit-extract s_1790_2 s_1790_0 s_1790_6
        let s_1790_7: Bits = (Bits::new(
            ((s_1790_2) >> (s_1790_0)).value(),
            u16::try_from(s_1790_6).unwrap(),
        ));
        // D s_1790_8: cast reint s_1790_7 -> u8
        let s_1790_8: u8 = (s_1790_7.value() as u8);
        // D s_1790_9: cast zx s_1790_8 -> bv
        let s_1790_9: Bits = Bits::new(s_1790_8 as u128, 5u16);
        // C s_1790_10: const #3u : u8
        let s_1790_10: u8 = 3;
        // C s_1790_11: cast zx s_1790_10 -> bv
        let s_1790_11: Bits = Bits::new(s_1790_10 as u128, 5u16);
        // D s_1790_12: cmp-eq s_1790_9 s_1790_11
        let s_1790_12: bool = ((s_1790_9) == (s_1790_11));
        // N s_1790_13: branch s_1790_12 b1793 b1791
        if s_1790_12 {
            return block_1793(state, tracer, fn_state);
        } else {
            return block_1791(state, tracer, fn_state);
        };
    }
    fn block_1791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1791_0: const #0u : u8
        let s_1791_0: bool = false;
        // D s_1791_1: write-var gs#403063 <= s_1791_0
        fn_state.gs_403063 = s_1791_0;
        // N s_1791_2: jump b1792
        return block_1792(state, tracer, fn_state);
    }
    fn block_1792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1792_0: read-var gs#403063:u8
        let s_1792_0: bool = fn_state.gs_403063;
        // D s_1792_1: write-var gs#403064 <= s_1792_0
        fn_state.gs_403064 = s_1792_0;
        // N s_1792_2: jump b1789
        return block_1789(state, tracer, fn_state);
    }
    fn block_1793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1793_0: const #4s : i
        let s_1793_0: i128 = 4;
        // D s_1793_1: read-var u#32144:u32
        let s_1793_1: u32 = fn_state.u_32144;
        // D s_1793_2: cast zx s_1793_1 -> bv
        let s_1793_2: Bits = Bits::new(s_1793_1 as u128, 32u16);
        // C s_1793_3: const #1s : i64
        let s_1793_3: i64 = 1;
        // C s_1793_4: cast zx s_1793_3 -> i
        let s_1793_4: i128 = (i128::try_from(s_1793_3).unwrap());
        // C s_1793_5: const #0s : i
        let s_1793_5: i128 = 0;
        // C s_1793_6: add s_1793_5 s_1793_4
        let s_1793_6: i128 = (s_1793_5 + s_1793_4);
        // D s_1793_7: bit-extract s_1793_2 s_1793_0 s_1793_6
        let s_1793_7: Bits = (Bits::new(
            ((s_1793_2) >> (s_1793_0)).value(),
            u16::try_from(s_1793_6).unwrap(),
        ));
        // D s_1793_8: cast reint s_1793_7 -> u8
        let s_1793_8: bool = ((s_1793_7.value()) != 0);
        // D s_1793_9: cast zx s_1793_8 -> bv
        let s_1793_9: Bits = Bits::new(s_1793_8 as u128, 1u16);
        // C s_1793_10: const #0u : u8
        let s_1793_10: bool = false;
        // C s_1793_11: cast zx s_1793_10 -> bv
        let s_1793_11: Bits = Bits::new(s_1793_10 as u128, 1u16);
        // D s_1793_12: cmp-eq s_1793_9 s_1793_11
        let s_1793_12: bool = ((s_1793_9) == (s_1793_11));
        // D s_1793_13: write-var gs#403063 <= s_1793_12
        fn_state.gs_403063 = s_1793_12;
        // N s_1793_14: jump b1792
        return block_1792(state, tracer, fn_state);
    }
    fn block_1794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1794_0: const #3756s : i
        let s_1794_0: i128 = 3756;
        // C s_1794_1: const #14696u : u32
        let s_1794_1: u32 = 14696;
        // D s_1794_2: read-reg s_1794_1:i
        let s_1794_2: i128 = {
            let value = state.read_register::<i128>(s_1794_1 as isize);
            tracer.read_register(s_1794_1 as isize, value);
            value
        };
        // D s_1794_3: cmp-lt s_1794_2 s_1794_0
        let s_1794_3: bool = ((s_1794_2) < (s_1794_0));
        // D s_1794_4: write-var gs#403037 <= s_1794_3
        fn_state.gs_403037 = s_1794_3;
        // N s_1794_5: jump b1301
        return block_1301(state, tracer, fn_state);
    }
    fn block_1795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1795_0: const #20s : i
        let s_1795_0: i128 = 20;
        // D s_1795_1: read-var u#32136:u32
        let s_1795_1: u32 = fn_state.u_32136;
        // D s_1795_2: cast zx s_1795_1 -> bv
        let s_1795_2: Bits = Bits::new(s_1795_1 as u128, 32u16);
        // C s_1795_3: const #1s : i64
        let s_1795_3: i64 = 1;
        // C s_1795_4: cast zx s_1795_3 -> i
        let s_1795_4: i128 = (i128::try_from(s_1795_3).unwrap());
        // C s_1795_5: const #1s : i
        let s_1795_5: i128 = 1;
        // C s_1795_6: add s_1795_5 s_1795_4
        let s_1795_6: i128 = (s_1795_5 + s_1795_4);
        // D s_1795_7: bit-extract s_1795_2 s_1795_0 s_1795_6
        let s_1795_7: Bits = (Bits::new(
            ((s_1795_2) >> (s_1795_0)).value(),
            u16::try_from(s_1795_6).unwrap(),
        ));
        // D s_1795_8: cast reint s_1795_7 -> u8
        let s_1795_8: u8 = (s_1795_7.value() as u8);
        // D s_1795_9: cast zx s_1795_8 -> bv
        let s_1795_9: Bits = Bits::new(s_1795_8 as u128, 2u16);
        // C s_1795_10: const #3u : u8
        let s_1795_10: u8 = 3;
        // C s_1795_11: cast zx s_1795_10 -> bv
        let s_1795_11: Bits = Bits::new(s_1795_10 as u128, 2u16);
        // D s_1795_12: cmp-eq s_1795_9 s_1795_11
        let s_1795_12: bool = ((s_1795_9) == (s_1795_11));
        // N s_1795_13: branch s_1795_12 b1798 b1796
        if s_1795_12 {
            return block_1798(state, tracer, fn_state);
        } else {
            return block_1796(state, tracer, fn_state);
        };
    }
    fn block_1796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1796_0: const #0u : u8
        let s_1796_0: bool = false;
        // D s_1796_1: write-var gs#403034 <= s_1796_0
        fn_state.gs_403034 = s_1796_0;
        // N s_1796_2: jump b1797
        return block_1797(state, tracer, fn_state);
    }
    fn block_1797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1797_0: read-var gs#403034:u8
        let s_1797_0: bool = fn_state.gs_403034;
        // D s_1797_1: write-var gs#403035 <= s_1797_0
        fn_state.gs_403035 = s_1797_0;
        // N s_1797_2: jump b1299
        return block_1299(state, tracer, fn_state);
    }
    fn block_1798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1798_0: const #16s : i
        let s_1798_0: i128 = 16;
        // D s_1798_1: read-var u#32136:u32
        let s_1798_1: u32 = fn_state.u_32136;
        // D s_1798_2: cast zx s_1798_1 -> bv
        let s_1798_2: Bits = Bits::new(s_1798_1 as u128, 32u16);
        // C s_1798_3: const #1s : i64
        let s_1798_3: i64 = 1;
        // C s_1798_4: cast zx s_1798_3 -> i
        let s_1798_4: i128 = (i128::try_from(s_1798_3).unwrap());
        // C s_1798_5: const #1s : i
        let s_1798_5: i128 = 1;
        // C s_1798_6: add s_1798_5 s_1798_4
        let s_1798_6: i128 = (s_1798_5 + s_1798_4);
        // D s_1798_7: bit-extract s_1798_2 s_1798_0 s_1798_6
        let s_1798_7: Bits = (Bits::new(
            ((s_1798_2) >> (s_1798_0)).value(),
            u16::try_from(s_1798_6).unwrap(),
        ));
        // D s_1798_8: cast reint s_1798_7 -> u8
        let s_1798_8: u8 = (s_1798_7.value() as u8);
        // D s_1798_9: cast zx s_1798_8 -> bv
        let s_1798_9: Bits = Bits::new(s_1798_8 as u128, 2u16);
        // C s_1798_10: const #2u : u8
        let s_1798_10: u8 = 2;
        // C s_1798_11: cast zx s_1798_10 -> bv
        let s_1798_11: Bits = Bits::new(s_1798_10 as u128, 2u16);
        // D s_1798_12: cmp-eq s_1798_9 s_1798_11
        let s_1798_12: bool = ((s_1798_9) == (s_1798_11));
        // N s_1798_13: branch s_1798_12 b1801 b1799
        if s_1798_12 {
            return block_1801(state, tracer, fn_state);
        } else {
            return block_1799(state, tracer, fn_state);
        };
    }
    fn block_1799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1799_0: const #0u : u8
        let s_1799_0: bool = false;
        // D s_1799_1: write-var gs#403033 <= s_1799_0
        fn_state.gs_403033 = s_1799_0;
        // N s_1799_2: jump b1800
        return block_1800(state, tracer, fn_state);
    }
    fn block_1800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1800_0: read-var gs#403033:u8
        let s_1800_0: bool = fn_state.gs_403033;
        // D s_1800_1: write-var gs#403034 <= s_1800_0
        fn_state.gs_403034 = s_1800_0;
        // N s_1800_2: jump b1797
        return block_1797(state, tracer, fn_state);
    }
    fn block_1801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1801_0: const #7s : i
        let s_1801_0: i128 = 7;
        // D s_1801_1: read-var u#32136:u32
        let s_1801_1: u32 = fn_state.u_32136;
        // D s_1801_2: cast zx s_1801_1 -> bv
        let s_1801_2: Bits = Bits::new(s_1801_1 as u128, 32u16);
        // C s_1801_3: const #1s : i64
        let s_1801_3: i64 = 1;
        // C s_1801_4: cast zx s_1801_3 -> i
        let s_1801_4: i128 = (i128::try_from(s_1801_3).unwrap());
        // C s_1801_5: const #4s : i
        let s_1801_5: i128 = 4;
        // C s_1801_6: add s_1801_5 s_1801_4
        let s_1801_6: i128 = (s_1801_5 + s_1801_4);
        // D s_1801_7: bit-extract s_1801_2 s_1801_0 s_1801_6
        let s_1801_7: Bits = (Bits::new(
            ((s_1801_2) >> (s_1801_0)).value(),
            u16::try_from(s_1801_6).unwrap(),
        ));
        // D s_1801_8: cast reint s_1801_7 -> u8
        let s_1801_8: u8 = (s_1801_7.value() as u8);
        // D s_1801_9: cast zx s_1801_8 -> bv
        let s_1801_9: Bits = Bits::new(s_1801_8 as u128, 5u16);
        // C s_1801_10: const #2u : u8
        let s_1801_10: u8 = 2;
        // C s_1801_11: cast zx s_1801_10 -> bv
        let s_1801_11: Bits = Bits::new(s_1801_10 as u128, 5u16);
        // D s_1801_12: cmp-eq s_1801_9 s_1801_11
        let s_1801_12: bool = ((s_1801_9) == (s_1801_11));
        // N s_1801_13: branch s_1801_12 b1804 b1802
        if s_1801_12 {
            return block_1804(state, tracer, fn_state);
        } else {
            return block_1802(state, tracer, fn_state);
        };
    }
    fn block_1802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1802_0: const #0u : u8
        let s_1802_0: bool = false;
        // D s_1802_1: write-var gs#403032 <= s_1802_0
        fn_state.gs_403032 = s_1802_0;
        // N s_1802_2: jump b1803
        return block_1803(state, tracer, fn_state);
    }
    fn block_1803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1803_0: read-var gs#403032:u8
        let s_1803_0: bool = fn_state.gs_403032;
        // D s_1803_1: write-var gs#403033 <= s_1803_0
        fn_state.gs_403033 = s_1803_0;
        // N s_1803_2: jump b1800
        return block_1800(state, tracer, fn_state);
    }
    fn block_1804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1804_0: const #4s : i
        let s_1804_0: i128 = 4;
        // D s_1804_1: read-var u#32136:u32
        let s_1804_1: u32 = fn_state.u_32136;
        // D s_1804_2: cast zx s_1804_1 -> bv
        let s_1804_2: Bits = Bits::new(s_1804_1 as u128, 32u16);
        // C s_1804_3: const #1s : i64
        let s_1804_3: i64 = 1;
        // C s_1804_4: cast zx s_1804_3 -> i
        let s_1804_4: i128 = (i128::try_from(s_1804_3).unwrap());
        // C s_1804_5: const #0s : i
        let s_1804_5: i128 = 0;
        // C s_1804_6: add s_1804_5 s_1804_4
        let s_1804_6: i128 = (s_1804_5 + s_1804_4);
        // D s_1804_7: bit-extract s_1804_2 s_1804_0 s_1804_6
        let s_1804_7: Bits = (Bits::new(
            ((s_1804_2) >> (s_1804_0)).value(),
            u16::try_from(s_1804_6).unwrap(),
        ));
        // D s_1804_8: cast reint s_1804_7 -> u8
        let s_1804_8: bool = ((s_1804_7.value()) != 0);
        // D s_1804_9: cast zx s_1804_8 -> bv
        let s_1804_9: Bits = Bits::new(s_1804_8 as u128, 1u16);
        // C s_1804_10: const #0u : u8
        let s_1804_10: bool = false;
        // C s_1804_11: cast zx s_1804_10 -> bv
        let s_1804_11: Bits = Bits::new(s_1804_10 as u128, 1u16);
        // D s_1804_12: cmp-eq s_1804_9 s_1804_11
        let s_1804_12: bool = ((s_1804_9) == (s_1804_11));
        // D s_1804_13: write-var gs#403032 <= s_1804_12
        fn_state.gs_403032 = s_1804_12;
        // N s_1804_14: jump b1803
        return block_1803(state, tracer, fn_state);
    }
    fn block_1805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1805_0: const #3754s : i
        let s_1805_0: i128 = 3754;
        // C s_1805_1: const #14696u : u32
        let s_1805_1: u32 = 14696;
        // D s_1805_2: read-reg s_1805_1:i
        let s_1805_2: i128 = {
            let value = state.read_register::<i128>(s_1805_1 as isize);
            tracer.read_register(s_1805_1 as isize, value);
            value
        };
        // D s_1805_3: cmp-lt s_1805_2 s_1805_0
        let s_1805_3: bool = ((s_1805_2) < (s_1805_0));
        // D s_1805_4: write-var gs#403002 <= s_1805_3
        fn_state.gs_403002 = s_1805_3;
        // N s_1805_5: jump b1295
        return block_1295(state, tracer, fn_state);
    }
    fn block_1806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1806_0: const #8s : i
        let s_1806_0: i128 = 8;
        // D s_1806_1: read-var u#32126:u32
        let s_1806_1: u32 = fn_state.u_32126;
        // D s_1806_2: cast zx s_1806_1 -> bv
        let s_1806_2: Bits = Bits::new(s_1806_1 as u128, 32u16);
        // C s_1806_3: const #1s : i64
        let s_1806_3: i64 = 1;
        // C s_1806_4: cast zx s_1806_3 -> i
        let s_1806_4: i128 = (i128::try_from(s_1806_3).unwrap());
        // C s_1806_5: const #3s : i
        let s_1806_5: i128 = 3;
        // C s_1806_6: add s_1806_5 s_1806_4
        let s_1806_6: i128 = (s_1806_5 + s_1806_4);
        // D s_1806_7: bit-extract s_1806_2 s_1806_0 s_1806_6
        let s_1806_7: Bits = (Bits::new(
            ((s_1806_2) >> (s_1806_0)).value(),
            u16::try_from(s_1806_6).unwrap(),
        ));
        // D s_1806_8: cast reint s_1806_7 -> u8
        let s_1806_8: u8 = (s_1806_7.value() as u8);
        // D s_1806_9: cast zx s_1806_8 -> bv
        let s_1806_9: Bits = Bits::new(s_1806_8 as u128, 4u16);
        // C s_1806_10: const #8u : u8
        let s_1806_10: u8 = 8;
        // C s_1806_11: cast zx s_1806_10 -> bv
        let s_1806_11: Bits = Bits::new(s_1806_10 as u128, 4u16);
        // D s_1806_12: cmp-eq s_1806_9 s_1806_11
        let s_1806_12: bool = ((s_1806_9) == (s_1806_11));
        // N s_1806_13: branch s_1806_12 b1809 b1807
        if s_1806_12 {
            return block_1809(state, tracer, fn_state);
        } else {
            return block_1807(state, tracer, fn_state);
        };
    }
    fn block_1807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1807_0: const #0u : u8
        let s_1807_0: bool = false;
        // D s_1807_1: write-var gs#402999 <= s_1807_0
        fn_state.gs_402999 = s_1807_0;
        // N s_1807_2: jump b1808
        return block_1808(state, tracer, fn_state);
    }
    fn block_1808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1808_0: read-var gs#402999:u8
        let s_1808_0: bool = fn_state.gs_402999;
        // D s_1808_1: write-var gs#403000 <= s_1808_0
        fn_state.gs_403000 = s_1808_0;
        // N s_1808_2: jump b1293
        return block_1293(state, tracer, fn_state);
    }
    fn block_1809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1809_0: const #4s : i
        let s_1809_0: i128 = 4;
        // D s_1809_1: read-var u#32126:u32
        let s_1809_1: u32 = fn_state.u_32126;
        // D s_1809_2: cast zx s_1809_1 -> bv
        let s_1809_2: Bits = Bits::new(s_1809_1 as u128, 32u16);
        // C s_1809_3: const #1s : i64
        let s_1809_3: i64 = 1;
        // C s_1809_4: cast zx s_1809_3 -> i
        let s_1809_4: i128 = (i128::try_from(s_1809_3).unwrap());
        // C s_1809_5: const #0s : i
        let s_1809_5: i128 = 0;
        // C s_1809_6: add s_1809_5 s_1809_4
        let s_1809_6: i128 = (s_1809_5 + s_1809_4);
        // D s_1809_7: bit-extract s_1809_2 s_1809_0 s_1809_6
        let s_1809_7: Bits = (Bits::new(
            ((s_1809_2) >> (s_1809_0)).value(),
            u16::try_from(s_1809_6).unwrap(),
        ));
        // D s_1809_8: cast reint s_1809_7 -> u8
        let s_1809_8: bool = ((s_1809_7.value()) != 0);
        // D s_1809_9: cast zx s_1809_8 -> bv
        let s_1809_9: Bits = Bits::new(s_1809_8 as u128, 1u16);
        // C s_1809_10: const #1u : u8
        let s_1809_10: bool = true;
        // C s_1809_11: cast zx s_1809_10 -> bv
        let s_1809_11: Bits = Bits::new(s_1809_10 as u128, 1u16);
        // D s_1809_12: cmp-eq s_1809_9 s_1809_11
        let s_1809_12: bool = ((s_1809_9) == (s_1809_11));
        // D s_1809_13: write-var gs#402999 <= s_1809_12
        fn_state.gs_402999 = s_1809_12;
        // N s_1809_14: jump b1808
        return block_1808(state, tracer, fn_state);
    }
    fn block_1810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1810_0: const #3752s : i
        let s_1810_0: i128 = 3752;
        // C s_1810_1: const #14696u : u32
        let s_1810_1: u32 = 14696;
        // D s_1810_2: read-reg s_1810_1:i
        let s_1810_2: i128 = {
            let value = state.read_register::<i128>(s_1810_1 as isize);
            tracer.read_register(s_1810_1 as isize, value);
            value
        };
        // D s_1810_3: cmp-lt s_1810_2 s_1810_0
        let s_1810_3: bool = ((s_1810_2) < (s_1810_0));
        // D s_1810_4: write-var gs#402977 <= s_1810_3
        fn_state.gs_402977 = s_1810_3;
        // N s_1810_5: jump b1289
        return block_1289(state, tracer, fn_state);
    }
    fn block_1811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1811_0: const #20s : i
        let s_1811_0: i128 = 20;
        // D s_1811_1: read-var u#32118:u32
        let s_1811_1: u32 = fn_state.u_32118;
        // D s_1811_2: cast zx s_1811_1 -> bv
        let s_1811_2: Bits = Bits::new(s_1811_1 as u128, 32u16);
        // C s_1811_3: const #1s : i64
        let s_1811_3: i64 = 1;
        // C s_1811_4: cast zx s_1811_3 -> i
        let s_1811_4: i128 = (i128::try_from(s_1811_3).unwrap());
        // C s_1811_5: const #1s : i
        let s_1811_5: i128 = 1;
        // C s_1811_6: add s_1811_5 s_1811_4
        let s_1811_6: i128 = (s_1811_5 + s_1811_4);
        // D s_1811_7: bit-extract s_1811_2 s_1811_0 s_1811_6
        let s_1811_7: Bits = (Bits::new(
            ((s_1811_2) >> (s_1811_0)).value(),
            u16::try_from(s_1811_6).unwrap(),
        ));
        // D s_1811_8: cast reint s_1811_7 -> u8
        let s_1811_8: u8 = (s_1811_7.value() as u8);
        // D s_1811_9: cast zx s_1811_8 -> bv
        let s_1811_9: Bits = Bits::new(s_1811_8 as u128, 2u16);
        // C s_1811_10: const #3u : u8
        let s_1811_10: u8 = 3;
        // C s_1811_11: cast zx s_1811_10 -> bv
        let s_1811_11: Bits = Bits::new(s_1811_10 as u128, 2u16);
        // D s_1811_12: cmp-eq s_1811_9 s_1811_11
        let s_1811_12: bool = ((s_1811_9) == (s_1811_11));
        // N s_1811_13: branch s_1811_12 b1814 b1812
        if s_1811_12 {
            return block_1814(state, tracer, fn_state);
        } else {
            return block_1812(state, tracer, fn_state);
        };
    }
    fn block_1812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1812_0: const #0u : u8
        let s_1812_0: bool = false;
        // D s_1812_1: write-var gs#402974 <= s_1812_0
        fn_state.gs_402974 = s_1812_0;
        // N s_1812_2: jump b1813
        return block_1813(state, tracer, fn_state);
    }
    fn block_1813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1813_0: read-var gs#402974:u8
        let s_1813_0: bool = fn_state.gs_402974;
        // D s_1813_1: write-var gs#402975 <= s_1813_0
        fn_state.gs_402975 = s_1813_0;
        // N s_1813_2: jump b1287
        return block_1287(state, tracer, fn_state);
    }
    fn block_1814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1814_0: const #16s : i
        let s_1814_0: i128 = 16;
        // D s_1814_1: read-var u#32118:u32
        let s_1814_1: u32 = fn_state.u_32118;
        // D s_1814_2: cast zx s_1814_1 -> bv
        let s_1814_2: Bits = Bits::new(s_1814_1 as u128, 32u16);
        // C s_1814_3: const #1s : i64
        let s_1814_3: i64 = 1;
        // C s_1814_4: cast zx s_1814_3 -> i
        let s_1814_4: i128 = (i128::try_from(s_1814_3).unwrap());
        // C s_1814_5: const #1s : i
        let s_1814_5: i128 = 1;
        // C s_1814_6: add s_1814_5 s_1814_4
        let s_1814_6: i128 = (s_1814_5 + s_1814_4);
        // D s_1814_7: bit-extract s_1814_2 s_1814_0 s_1814_6
        let s_1814_7: Bits = (Bits::new(
            ((s_1814_2) >> (s_1814_0)).value(),
            u16::try_from(s_1814_6).unwrap(),
        ));
        // D s_1814_8: cast reint s_1814_7 -> u8
        let s_1814_8: u8 = (s_1814_7.value() as u8);
        // D s_1814_9: cast zx s_1814_8 -> bv
        let s_1814_9: Bits = Bits::new(s_1814_8 as u128, 2u16);
        // C s_1814_10: const #2u : u8
        let s_1814_10: u8 = 2;
        // C s_1814_11: cast zx s_1814_10 -> bv
        let s_1814_11: Bits = Bits::new(s_1814_10 as u128, 2u16);
        // D s_1814_12: cmp-eq s_1814_9 s_1814_11
        let s_1814_12: bool = ((s_1814_9) == (s_1814_11));
        // N s_1814_13: branch s_1814_12 b1817 b1815
        if s_1814_12 {
            return block_1817(state, tracer, fn_state);
        } else {
            return block_1815(state, tracer, fn_state);
        };
    }
    fn block_1815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1815_0: const #0u : u8
        let s_1815_0: bool = false;
        // D s_1815_1: write-var gs#402973 <= s_1815_0
        fn_state.gs_402973 = s_1815_0;
        // N s_1815_2: jump b1816
        return block_1816(state, tracer, fn_state);
    }
    fn block_1816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1816_0: read-var gs#402973:u8
        let s_1816_0: bool = fn_state.gs_402973;
        // D s_1816_1: write-var gs#402974 <= s_1816_0
        fn_state.gs_402974 = s_1816_0;
        // N s_1816_2: jump b1813
        return block_1813(state, tracer, fn_state);
    }
    fn block_1817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1817_0: const #7s : i
        let s_1817_0: i128 = 7;
        // D s_1817_1: read-var u#32118:u32
        let s_1817_1: u32 = fn_state.u_32118;
        // D s_1817_2: cast zx s_1817_1 -> bv
        let s_1817_2: Bits = Bits::new(s_1817_1 as u128, 32u16);
        // C s_1817_3: const #1s : i64
        let s_1817_3: i64 = 1;
        // C s_1817_4: cast zx s_1817_3 -> i
        let s_1817_4: i128 = (i128::try_from(s_1817_3).unwrap());
        // C s_1817_5: const #4s : i
        let s_1817_5: i128 = 4;
        // C s_1817_6: add s_1817_5 s_1817_4
        let s_1817_6: i128 = (s_1817_5 + s_1817_4);
        // D s_1817_7: bit-extract s_1817_2 s_1817_0 s_1817_6
        let s_1817_7: Bits = (Bits::new(
            ((s_1817_2) >> (s_1817_0)).value(),
            u16::try_from(s_1817_6).unwrap(),
        ));
        // D s_1817_8: cast reint s_1817_7 -> u8
        let s_1817_8: u8 = (s_1817_7.value() as u8);
        // D s_1817_9: cast zx s_1817_8 -> bv
        let s_1817_9: Bits = Bits::new(s_1817_8 as u128, 5u16);
        // C s_1817_10: const #1u : u8
        let s_1817_10: u8 = 1;
        // C s_1817_11: cast zx s_1817_10 -> bv
        let s_1817_11: Bits = Bits::new(s_1817_10 as u128, 5u16);
        // D s_1817_12: cmp-eq s_1817_9 s_1817_11
        let s_1817_12: bool = ((s_1817_9) == (s_1817_11));
        // N s_1817_13: branch s_1817_12 b1820 b1818
        if s_1817_12 {
            return block_1820(state, tracer, fn_state);
        } else {
            return block_1818(state, tracer, fn_state);
        };
    }
    fn block_1818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1818_0: const #0u : u8
        let s_1818_0: bool = false;
        // D s_1818_1: write-var gs#402972 <= s_1818_0
        fn_state.gs_402972 = s_1818_0;
        // N s_1818_2: jump b1819
        return block_1819(state, tracer, fn_state);
    }
    fn block_1819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1819_0: read-var gs#402972:u8
        let s_1819_0: bool = fn_state.gs_402972;
        // D s_1819_1: write-var gs#402973 <= s_1819_0
        fn_state.gs_402973 = s_1819_0;
        // N s_1819_2: jump b1816
        return block_1816(state, tracer, fn_state);
    }
    fn block_1820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1820_0: const #4s : i
        let s_1820_0: i128 = 4;
        // D s_1820_1: read-var u#32118:u32
        let s_1820_1: u32 = fn_state.u_32118;
        // D s_1820_2: cast zx s_1820_1 -> bv
        let s_1820_2: Bits = Bits::new(s_1820_1 as u128, 32u16);
        // C s_1820_3: const #1s : i64
        let s_1820_3: i64 = 1;
        // C s_1820_4: cast zx s_1820_3 -> i
        let s_1820_4: i128 = (i128::try_from(s_1820_3).unwrap());
        // C s_1820_5: const #0s : i
        let s_1820_5: i128 = 0;
        // C s_1820_6: add s_1820_5 s_1820_4
        let s_1820_6: i128 = (s_1820_5 + s_1820_4);
        // D s_1820_7: bit-extract s_1820_2 s_1820_0 s_1820_6
        let s_1820_7: Bits = (Bits::new(
            ((s_1820_2) >> (s_1820_0)).value(),
            u16::try_from(s_1820_6).unwrap(),
        ));
        // D s_1820_8: cast reint s_1820_7 -> u8
        let s_1820_8: bool = ((s_1820_7.value()) != 0);
        // D s_1820_9: cast zx s_1820_8 -> bv
        let s_1820_9: Bits = Bits::new(s_1820_8 as u128, 1u16);
        // C s_1820_10: const #0u : u8
        let s_1820_10: bool = false;
        // C s_1820_11: cast zx s_1820_10 -> bv
        let s_1820_11: Bits = Bits::new(s_1820_10 as u128, 1u16);
        // D s_1820_12: cmp-eq s_1820_9 s_1820_11
        let s_1820_12: bool = ((s_1820_9) == (s_1820_11));
        // D s_1820_13: write-var gs#402972 <= s_1820_12
        fn_state.gs_402972 = s_1820_12;
        // N s_1820_14: jump b1819
        return block_1819(state, tracer, fn_state);
    }
    fn block_1821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1821_0: const #3750s : i
        let s_1821_0: i128 = 3750;
        // C s_1821_1: const #14696u : u32
        let s_1821_1: u32 = 14696;
        // D s_1821_2: read-reg s_1821_1:i
        let s_1821_2: i128 = {
            let value = state.read_register::<i128>(s_1821_1 as isize);
            tracer.read_register(s_1821_1 as isize, value);
            value
        };
        // D s_1821_3: cmp-lt s_1821_2 s_1821_0
        let s_1821_3: bool = ((s_1821_2) < (s_1821_0));
        // D s_1821_4: write-var gs#402942 <= s_1821_3
        fn_state.gs_402942 = s_1821_3;
        // N s_1821_5: jump b1283
        return block_1283(state, tracer, fn_state);
    }
    fn block_1822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1822_0: const #20s : i
        let s_1822_0: i128 = 20;
        // D s_1822_1: read-var u#32109:u32
        let s_1822_1: u32 = fn_state.u_32109;
        // D s_1822_2: cast zx s_1822_1 -> bv
        let s_1822_2: Bits = Bits::new(s_1822_1 as u128, 32u16);
        // C s_1822_3: const #1s : i64
        let s_1822_3: i64 = 1;
        // C s_1822_4: cast zx s_1822_3 -> i
        let s_1822_4: i128 = (i128::try_from(s_1822_3).unwrap());
        // C s_1822_5: const #1s : i
        let s_1822_5: i128 = 1;
        // C s_1822_6: add s_1822_5 s_1822_4
        let s_1822_6: i128 = (s_1822_5 + s_1822_4);
        // D s_1822_7: bit-extract s_1822_2 s_1822_0 s_1822_6
        let s_1822_7: Bits = (Bits::new(
            ((s_1822_2) >> (s_1822_0)).value(),
            u16::try_from(s_1822_6).unwrap(),
        ));
        // D s_1822_8: cast reint s_1822_7 -> u8
        let s_1822_8: u8 = (s_1822_7.value() as u8);
        // D s_1822_9: cast zx s_1822_8 -> bv
        let s_1822_9: Bits = Bits::new(s_1822_8 as u128, 2u16);
        // C s_1822_10: const #3u : u8
        let s_1822_10: u8 = 3;
        // C s_1822_11: cast zx s_1822_10 -> bv
        let s_1822_11: Bits = Bits::new(s_1822_10 as u128, 2u16);
        // D s_1822_12: cmp-eq s_1822_9 s_1822_11
        let s_1822_12: bool = ((s_1822_9) == (s_1822_11));
        // N s_1822_13: branch s_1822_12 b1825 b1823
        if s_1822_12 {
            return block_1825(state, tracer, fn_state);
        } else {
            return block_1823(state, tracer, fn_state);
        };
    }
    fn block_1823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1823_0: const #0u : u8
        let s_1823_0: bool = false;
        // D s_1823_1: write-var gs#402939 <= s_1823_0
        fn_state.gs_402939 = s_1823_0;
        // N s_1823_2: jump b1824
        return block_1824(state, tracer, fn_state);
    }
    fn block_1824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1824_0: read-var gs#402939:u8
        let s_1824_0: bool = fn_state.gs_402939;
        // D s_1824_1: write-var gs#402940 <= s_1824_0
        fn_state.gs_402940 = s_1824_0;
        // N s_1824_2: jump b1281
        return block_1281(state, tracer, fn_state);
    }
    fn block_1825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1825_0: const #10s : i
        let s_1825_0: i128 = 10;
        // D s_1825_1: read-var u#32109:u32
        let s_1825_1: u32 = fn_state.u_32109;
        // D s_1825_2: cast zx s_1825_1 -> bv
        let s_1825_2: Bits = Bits::new(s_1825_1 as u128, 32u16);
        // C s_1825_3: const #1s : i64
        let s_1825_3: i64 = 1;
        // C s_1825_4: cast zx s_1825_3 -> i
        let s_1825_4: i128 = (i128::try_from(s_1825_3).unwrap());
        // C s_1825_5: const #1s : i
        let s_1825_5: i128 = 1;
        // C s_1825_6: add s_1825_5 s_1825_4
        let s_1825_6: i128 = (s_1825_5 + s_1825_4);
        // D s_1825_7: bit-extract s_1825_2 s_1825_0 s_1825_6
        let s_1825_7: Bits = (Bits::new(
            ((s_1825_2) >> (s_1825_0)).value(),
            u16::try_from(s_1825_6).unwrap(),
        ));
        // D s_1825_8: cast reint s_1825_7 -> u8
        let s_1825_8: u8 = (s_1825_7.value() as u8);
        // D s_1825_9: cast zx s_1825_8 -> bv
        let s_1825_9: Bits = Bits::new(s_1825_8 as u128, 2u16);
        // C s_1825_10: const #2u : u8
        let s_1825_10: u8 = 2;
        // C s_1825_11: cast zx s_1825_10 -> bv
        let s_1825_11: Bits = Bits::new(s_1825_10 as u128, 2u16);
        // D s_1825_12: cmp-eq s_1825_9 s_1825_11
        let s_1825_12: bool = ((s_1825_9) == (s_1825_11));
        // N s_1825_13: branch s_1825_12 b1828 b1826
        if s_1825_12 {
            return block_1828(state, tracer, fn_state);
        } else {
            return block_1826(state, tracer, fn_state);
        };
    }
    fn block_1826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1826_0: const #0u : u8
        let s_1826_0: bool = false;
        // D s_1826_1: write-var gs#402938 <= s_1826_0
        fn_state.gs_402938 = s_1826_0;
        // N s_1826_2: jump b1827
        return block_1827(state, tracer, fn_state);
    }
    fn block_1827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1827_0: read-var gs#402938:u8
        let s_1827_0: bool = fn_state.gs_402938;
        // D s_1827_1: write-var gs#402939 <= s_1827_0
        fn_state.gs_402939 = s_1827_0;
        // N s_1827_2: jump b1824
        return block_1824(state, tracer, fn_state);
    }
    fn block_1828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1828_0: const #4s : i
        let s_1828_0: i128 = 4;
        // D s_1828_1: read-var u#32109:u32
        let s_1828_1: u32 = fn_state.u_32109;
        // D s_1828_2: cast zx s_1828_1 -> bv
        let s_1828_2: Bits = Bits::new(s_1828_1 as u128, 32u16);
        // C s_1828_3: const #1s : i64
        let s_1828_3: i64 = 1;
        // C s_1828_4: cast zx s_1828_3 -> i
        let s_1828_4: i128 = (i128::try_from(s_1828_3).unwrap());
        // C s_1828_5: const #0s : i
        let s_1828_5: i128 = 0;
        // C s_1828_6: add s_1828_5 s_1828_4
        let s_1828_6: i128 = (s_1828_5 + s_1828_4);
        // D s_1828_7: bit-extract s_1828_2 s_1828_0 s_1828_6
        let s_1828_7: Bits = (Bits::new(
            ((s_1828_2) >> (s_1828_0)).value(),
            u16::try_from(s_1828_6).unwrap(),
        ));
        // D s_1828_8: cast reint s_1828_7 -> u8
        let s_1828_8: bool = ((s_1828_7.value()) != 0);
        // D s_1828_9: cast zx s_1828_8 -> bv
        let s_1828_9: Bits = Bits::new(s_1828_8 as u128, 1u16);
        // C s_1828_10: const #0u : u8
        let s_1828_10: bool = false;
        // C s_1828_11: cast zx s_1828_10 -> bv
        let s_1828_11: Bits = Bits::new(s_1828_10 as u128, 1u16);
        // D s_1828_12: cmp-eq s_1828_9 s_1828_11
        let s_1828_12: bool = ((s_1828_9) == (s_1828_11));
        // D s_1828_13: write-var gs#402938 <= s_1828_12
        fn_state.gs_402938 = s_1828_12;
        // N s_1828_14: jump b1827
        return block_1827(state, tracer, fn_state);
    }
    fn block_1829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1829_0: const #3748s : i
        let s_1829_0: i128 = 3748;
        // C s_1829_1: const #14696u : u32
        let s_1829_1: u32 = 14696;
        // D s_1829_2: read-reg s_1829_1:i
        let s_1829_2: i128 = {
            let value = state.read_register::<i128>(s_1829_1 as isize);
            tracer.read_register(s_1829_1 as isize, value);
            value
        };
        // D s_1829_3: cmp-lt s_1829_2 s_1829_0
        let s_1829_3: bool = ((s_1829_2) < (s_1829_0));
        // D s_1829_4: write-var gs#402914 <= s_1829_3
        fn_state.gs_402914 = s_1829_3;
        // N s_1829_5: jump b1277
        return block_1277(state, tracer, fn_state);
    }
    fn block_1830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1830_0: const #20s : i
        let s_1830_0: i128 = 20;
        // D s_1830_1: read-var u#32101:u32
        let s_1830_1: u32 = fn_state.u_32101;
        // D s_1830_2: cast zx s_1830_1 -> bv
        let s_1830_2: Bits = Bits::new(s_1830_1 as u128, 32u16);
        // C s_1830_3: const #1s : i64
        let s_1830_3: i64 = 1;
        // C s_1830_4: cast zx s_1830_3 -> i
        let s_1830_4: i128 = (i128::try_from(s_1830_3).unwrap());
        // C s_1830_5: const #1s : i
        let s_1830_5: i128 = 1;
        // C s_1830_6: add s_1830_5 s_1830_4
        let s_1830_6: i128 = (s_1830_5 + s_1830_4);
        // D s_1830_7: bit-extract s_1830_2 s_1830_0 s_1830_6
        let s_1830_7: Bits = (Bits::new(
            ((s_1830_2) >> (s_1830_0)).value(),
            u16::try_from(s_1830_6).unwrap(),
        ));
        // D s_1830_8: cast reint s_1830_7 -> u8
        let s_1830_8: u8 = (s_1830_7.value() as u8);
        // D s_1830_9: cast zx s_1830_8 -> bv
        let s_1830_9: Bits = Bits::new(s_1830_8 as u128, 2u16);
        // C s_1830_10: const #3u : u8
        let s_1830_10: u8 = 3;
        // C s_1830_11: cast zx s_1830_10 -> bv
        let s_1830_11: Bits = Bits::new(s_1830_10 as u128, 2u16);
        // D s_1830_12: cmp-eq s_1830_9 s_1830_11
        let s_1830_12: bool = ((s_1830_9) == (s_1830_11));
        // N s_1830_13: branch s_1830_12 b1833 b1831
        if s_1830_12 {
            return block_1833(state, tracer, fn_state);
        } else {
            return block_1831(state, tracer, fn_state);
        };
    }
    fn block_1831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1831_0: const #0u : u8
        let s_1831_0: bool = false;
        // D s_1831_1: write-var gs#402911 <= s_1831_0
        fn_state.gs_402911 = s_1831_0;
        // N s_1831_2: jump b1832
        return block_1832(state, tracer, fn_state);
    }
    fn block_1832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1832_0: read-var gs#402911:u8
        let s_1832_0: bool = fn_state.gs_402911;
        // D s_1832_1: write-var gs#402912 <= s_1832_0
        fn_state.gs_402912 = s_1832_0;
        // N s_1832_2: jump b1275
        return block_1275(state, tracer, fn_state);
    }
    fn block_1833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1833_0: const #16s : i
        let s_1833_0: i128 = 16;
        // D s_1833_1: read-var u#32101:u32
        let s_1833_1: u32 = fn_state.u_32101;
        // D s_1833_2: cast zx s_1833_1 -> bv
        let s_1833_2: Bits = Bits::new(s_1833_1 as u128, 32u16);
        // C s_1833_3: const #1s : i64
        let s_1833_3: i64 = 1;
        // C s_1833_4: cast zx s_1833_3 -> i
        let s_1833_4: i128 = (i128::try_from(s_1833_3).unwrap());
        // C s_1833_5: const #1s : i
        let s_1833_5: i128 = 1;
        // C s_1833_6: add s_1833_5 s_1833_4
        let s_1833_6: i128 = (s_1833_5 + s_1833_4);
        // D s_1833_7: bit-extract s_1833_2 s_1833_0 s_1833_6
        let s_1833_7: Bits = (Bits::new(
            ((s_1833_2) >> (s_1833_0)).value(),
            u16::try_from(s_1833_6).unwrap(),
        ));
        // D s_1833_8: cast reint s_1833_7 -> u8
        let s_1833_8: u8 = (s_1833_7.value() as u8);
        // D s_1833_9: cast zx s_1833_8 -> bv
        let s_1833_9: Bits = Bits::new(s_1833_8 as u128, 2u16);
        // C s_1833_10: const #2u : u8
        let s_1833_10: u8 = 2;
        // C s_1833_11: cast zx s_1833_10 -> bv
        let s_1833_11: Bits = Bits::new(s_1833_10 as u128, 2u16);
        // D s_1833_12: cmp-eq s_1833_9 s_1833_11
        let s_1833_12: bool = ((s_1833_9) == (s_1833_11));
        // N s_1833_13: branch s_1833_12 b1836 b1834
        if s_1833_12 {
            return block_1836(state, tracer, fn_state);
        } else {
            return block_1834(state, tracer, fn_state);
        };
    }
    fn block_1834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1834_0: const #0u : u8
        let s_1834_0: bool = false;
        // D s_1834_1: write-var gs#402910 <= s_1834_0
        fn_state.gs_402910 = s_1834_0;
        // N s_1834_2: jump b1835
        return block_1835(state, tracer, fn_state);
    }
    fn block_1835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1835_0: read-var gs#402910:u8
        let s_1835_0: bool = fn_state.gs_402910;
        // D s_1835_1: write-var gs#402911 <= s_1835_0
        fn_state.gs_402911 = s_1835_0;
        // N s_1835_2: jump b1832
        return block_1832(state, tracer, fn_state);
    }
    fn block_1836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1836_0: const #7s : i
        let s_1836_0: i128 = 7;
        // D s_1836_1: read-var u#32101:u32
        let s_1836_1: u32 = fn_state.u_32101;
        // D s_1836_2: cast zx s_1836_1 -> bv
        let s_1836_2: Bits = Bits::new(s_1836_1 as u128, 32u16);
        // C s_1836_3: const #1s : i64
        let s_1836_3: i64 = 1;
        // C s_1836_4: cast zx s_1836_3 -> i
        let s_1836_4: i128 = (i128::try_from(s_1836_3).unwrap());
        // C s_1836_5: const #4s : i
        let s_1836_5: i128 = 4;
        // C s_1836_6: add s_1836_5 s_1836_4
        let s_1836_6: i128 = (s_1836_5 + s_1836_4);
        // D s_1836_7: bit-extract s_1836_2 s_1836_0 s_1836_6
        let s_1836_7: Bits = (Bits::new(
            ((s_1836_2) >> (s_1836_0)).value(),
            u16::try_from(s_1836_6).unwrap(),
        ));
        // D s_1836_8: cast reint s_1836_7 -> u8
        let s_1836_8: u8 = (s_1836_7.value() as u8);
        // D s_1836_9: cast zx s_1836_8 -> bv
        let s_1836_9: Bits = Bits::new(s_1836_8 as u128, 5u16);
        // C s_1836_10: const #0u : u8
        let s_1836_10: u8 = 0;
        // C s_1836_11: cast zx s_1836_10 -> bv
        let s_1836_11: Bits = Bits::new(s_1836_10 as u128, 5u16);
        // D s_1836_12: cmp-eq s_1836_9 s_1836_11
        let s_1836_12: bool = ((s_1836_9) == (s_1836_11));
        // N s_1836_13: branch s_1836_12 b1839 b1837
        if s_1836_12 {
            return block_1839(state, tracer, fn_state);
        } else {
            return block_1837(state, tracer, fn_state);
        };
    }
    fn block_1837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1837_0: const #0u : u8
        let s_1837_0: bool = false;
        // D s_1837_1: write-var gs#402909 <= s_1837_0
        fn_state.gs_402909 = s_1837_0;
        // N s_1837_2: jump b1838
        return block_1838(state, tracer, fn_state);
    }
    fn block_1838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1838_0: read-var gs#402909:u8
        let s_1838_0: bool = fn_state.gs_402909;
        // D s_1838_1: write-var gs#402910 <= s_1838_0
        fn_state.gs_402910 = s_1838_0;
        // N s_1838_2: jump b1835
        return block_1835(state, tracer, fn_state);
    }
    fn block_1839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1839_0: const #4s : i
        let s_1839_0: i128 = 4;
        // D s_1839_1: read-var u#32101:u32
        let s_1839_1: u32 = fn_state.u_32101;
        // D s_1839_2: cast zx s_1839_1 -> bv
        let s_1839_2: Bits = Bits::new(s_1839_1 as u128, 32u16);
        // C s_1839_3: const #1s : i64
        let s_1839_3: i64 = 1;
        // C s_1839_4: cast zx s_1839_3 -> i
        let s_1839_4: i128 = (i128::try_from(s_1839_3).unwrap());
        // C s_1839_5: const #0s : i
        let s_1839_5: i128 = 0;
        // C s_1839_6: add s_1839_5 s_1839_4
        let s_1839_6: i128 = (s_1839_5 + s_1839_4);
        // D s_1839_7: bit-extract s_1839_2 s_1839_0 s_1839_6
        let s_1839_7: Bits = (Bits::new(
            ((s_1839_2) >> (s_1839_0)).value(),
            u16::try_from(s_1839_6).unwrap(),
        ));
        // D s_1839_8: cast reint s_1839_7 -> u8
        let s_1839_8: bool = ((s_1839_7.value()) != 0);
        // D s_1839_9: cast zx s_1839_8 -> bv
        let s_1839_9: Bits = Bits::new(s_1839_8 as u128, 1u16);
        // C s_1839_10: const #0u : u8
        let s_1839_10: bool = false;
        // C s_1839_11: cast zx s_1839_10 -> bv
        let s_1839_11: Bits = Bits::new(s_1839_10 as u128, 1u16);
        // D s_1839_12: cmp-eq s_1839_9 s_1839_11
        let s_1839_12: bool = ((s_1839_9) == (s_1839_11));
        // D s_1839_13: write-var gs#402909 <= s_1839_12
        fn_state.gs_402909 = s_1839_12;
        // N s_1839_14: jump b1838
        return block_1838(state, tracer, fn_state);
    }
    fn block_1840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1840_0: const #3746s : i
        let s_1840_0: i128 = 3746;
        // C s_1840_1: const #14696u : u32
        let s_1840_1: u32 = 14696;
        // D s_1840_2: read-reg s_1840_1:i
        let s_1840_2: i128 = {
            let value = state.read_register::<i128>(s_1840_1 as isize);
            tracer.read_register(s_1840_1 as isize, value);
            value
        };
        // D s_1840_3: cmp-lt s_1840_2 s_1840_0
        let s_1840_3: bool = ((s_1840_2) < (s_1840_0));
        // D s_1840_4: write-var gs#402877 <= s_1840_3
        fn_state.gs_402877 = s_1840_3;
        // N s_1840_5: jump b1271
        return block_1271(state, tracer, fn_state);
    }
    fn block_1841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1841_0: const #23s : i
        let s_1841_0: i128 = 23;
        // D s_1841_1: read-var u#32090:u32
        let s_1841_1: u32 = fn_state.u_32090;
        // D s_1841_2: cast zx s_1841_1 -> bv
        let s_1841_2: Bits = Bits::new(s_1841_1 as u128, 32u16);
        // C s_1841_3: const #1s : i64
        let s_1841_3: i64 = 1;
        // C s_1841_4: cast zx s_1841_3 -> i
        let s_1841_4: i128 = (i128::try_from(s_1841_3).unwrap());
        // C s_1841_5: const #0s : i
        let s_1841_5: i128 = 0;
        // C s_1841_6: add s_1841_5 s_1841_4
        let s_1841_6: i128 = (s_1841_5 + s_1841_4);
        // D s_1841_7: bit-extract s_1841_2 s_1841_0 s_1841_6
        let s_1841_7: Bits = (Bits::new(
            ((s_1841_2) >> (s_1841_0)).value(),
            u16::try_from(s_1841_6).unwrap(),
        ));
        // D s_1841_8: cast reint s_1841_7 -> u8
        let s_1841_8: bool = ((s_1841_7.value()) != 0);
        // D s_1841_9: cast zx s_1841_8 -> bv
        let s_1841_9: Bits = Bits::new(s_1841_8 as u128, 1u16);
        // C s_1841_10: const #1u : u8
        let s_1841_10: bool = true;
        // C s_1841_11: cast zx s_1841_10 -> bv
        let s_1841_11: Bits = Bits::new(s_1841_10 as u128, 1u16);
        // D s_1841_12: cmp-eq s_1841_9 s_1841_11
        let s_1841_12: bool = ((s_1841_9) == (s_1841_11));
        // N s_1841_13: branch s_1841_12 b1844 b1842
        if s_1841_12 {
            return block_1844(state, tracer, fn_state);
        } else {
            return block_1842(state, tracer, fn_state);
        };
    }
    fn block_1842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1842_0: const #0u : u8
        let s_1842_0: bool = false;
        // D s_1842_1: write-var gs#402874 <= s_1842_0
        fn_state.gs_402874 = s_1842_0;
        // N s_1842_2: jump b1843
        return block_1843(state, tracer, fn_state);
    }
    fn block_1843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1843_0: read-var gs#402874:u8
        let s_1843_0: bool = fn_state.gs_402874;
        // D s_1843_1: write-var gs#402875 <= s_1843_0
        fn_state.gs_402875 = s_1843_0;
        // N s_1843_2: jump b1269
        return block_1269(state, tracer, fn_state);
    }
    fn block_1844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1844_0: const #9s : i
        let s_1844_0: i128 = 9;
        // D s_1844_1: read-var u#32090:u32
        let s_1844_1: u32 = fn_state.u_32090;
        // D s_1844_2: cast zx s_1844_1 -> bv
        let s_1844_2: Bits = Bits::new(s_1844_1 as u128, 32u16);
        // C s_1844_3: const #1s : i64
        let s_1844_3: i64 = 1;
        // C s_1844_4: cast zx s_1844_3 -> i
        let s_1844_4: i128 = (i128::try_from(s_1844_3).unwrap());
        // C s_1844_5: const #2s : i
        let s_1844_5: i128 = 2;
        // C s_1844_6: add s_1844_5 s_1844_4
        let s_1844_6: i128 = (s_1844_5 + s_1844_4);
        // D s_1844_7: bit-extract s_1844_2 s_1844_0 s_1844_6
        let s_1844_7: Bits = (Bits::new(
            ((s_1844_2) >> (s_1844_0)).value(),
            u16::try_from(s_1844_6).unwrap(),
        ));
        // D s_1844_8: cast reint s_1844_7 -> u8
        let s_1844_8: u8 = (s_1844_7.value() as u8);
        // D s_1844_9: cast zx s_1844_8 -> bv
        let s_1844_9: Bits = Bits::new(s_1844_8 as u128, 3u16);
        // C s_1844_10: const #1u : u8
        let s_1844_10: u8 = 1;
        // C s_1844_11: cast zx s_1844_10 -> bv
        let s_1844_11: Bits = Bits::new(s_1844_10 as u128, 3u16);
        // D s_1844_12: cmp-eq s_1844_9 s_1844_11
        let s_1844_12: bool = ((s_1844_9) == (s_1844_11));
        // N s_1844_13: branch s_1844_12 b1847 b1845
        if s_1844_12 {
            return block_1847(state, tracer, fn_state);
        } else {
            return block_1845(state, tracer, fn_state);
        };
    }
    fn block_1845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1845_0: const #0u : u8
        let s_1845_0: bool = false;
        // D s_1845_1: write-var gs#402873 <= s_1845_0
        fn_state.gs_402873 = s_1845_0;
        // N s_1845_2: jump b1846
        return block_1846(state, tracer, fn_state);
    }
    fn block_1846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1846_0: read-var gs#402873:u8
        let s_1846_0: bool = fn_state.gs_402873;
        // D s_1846_1: write-var gs#402874 <= s_1846_0
        fn_state.gs_402874 = s_1846_0;
        // N s_1846_2: jump b1843
        return block_1843(state, tracer, fn_state);
    }
    fn block_1847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1847_0: const #6s : i
        let s_1847_0: i128 = 6;
        // D s_1847_1: read-var u#32090:u32
        let s_1847_1: u32 = fn_state.u_32090;
        // D s_1847_2: cast zx s_1847_1 -> bv
        let s_1847_2: Bits = Bits::new(s_1847_1 as u128, 32u16);
        // C s_1847_3: const #1s : i64
        let s_1847_3: i64 = 1;
        // C s_1847_4: cast zx s_1847_3 -> i
        let s_1847_4: i128 = (i128::try_from(s_1847_3).unwrap());
        // C s_1847_5: const #0s : i
        let s_1847_5: i128 = 0;
        // C s_1847_6: add s_1847_5 s_1847_4
        let s_1847_6: i128 = (s_1847_5 + s_1847_4);
        // D s_1847_7: bit-extract s_1847_2 s_1847_0 s_1847_6
        let s_1847_7: Bits = (Bits::new(
            ((s_1847_2) >> (s_1847_0)).value(),
            u16::try_from(s_1847_6).unwrap(),
        ));
        // D s_1847_8: cast reint s_1847_7 -> u8
        let s_1847_8: bool = ((s_1847_7.value()) != 0);
        // D s_1847_9: cast zx s_1847_8 -> bv
        let s_1847_9: Bits = Bits::new(s_1847_8 as u128, 1u16);
        // C s_1847_10: const #0u : u8
        let s_1847_10: bool = false;
        // C s_1847_11: cast zx s_1847_10 -> bv
        let s_1847_11: Bits = Bits::new(s_1847_10 as u128, 1u16);
        // D s_1847_12: cmp-eq s_1847_9 s_1847_11
        let s_1847_12: bool = ((s_1847_9) == (s_1847_11));
        // N s_1847_13: branch s_1847_12 b1850 b1848
        if s_1847_12 {
            return block_1850(state, tracer, fn_state);
        } else {
            return block_1848(state, tracer, fn_state);
        };
    }
    fn block_1848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1848_0: const #0u : u8
        let s_1848_0: bool = false;
        // D s_1848_1: write-var gs#402872 <= s_1848_0
        fn_state.gs_402872 = s_1848_0;
        // N s_1848_2: jump b1849
        return block_1849(state, tracer, fn_state);
    }
    fn block_1849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1849_0: read-var gs#402872:u8
        let s_1849_0: bool = fn_state.gs_402872;
        // D s_1849_1: write-var gs#402873 <= s_1849_0
        fn_state.gs_402873 = s_1849_0;
        // N s_1849_2: jump b1846
        return block_1846(state, tracer, fn_state);
    }
    fn block_1850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1850_0: const #4s : i
        let s_1850_0: i128 = 4;
        // D s_1850_1: read-var u#32090:u32
        let s_1850_1: u32 = fn_state.u_32090;
        // D s_1850_2: cast zx s_1850_1 -> bv
        let s_1850_2: Bits = Bits::new(s_1850_1 as u128, 32u16);
        // C s_1850_3: const #1s : i64
        let s_1850_3: i64 = 1;
        // C s_1850_4: cast zx s_1850_3 -> i
        let s_1850_4: i128 = (i128::try_from(s_1850_3).unwrap());
        // C s_1850_5: const #0s : i
        let s_1850_5: i128 = 0;
        // C s_1850_6: add s_1850_5 s_1850_4
        let s_1850_6: i128 = (s_1850_5 + s_1850_4);
        // D s_1850_7: bit-extract s_1850_2 s_1850_0 s_1850_6
        let s_1850_7: Bits = (Bits::new(
            ((s_1850_2) >> (s_1850_0)).value(),
            u16::try_from(s_1850_6).unwrap(),
        ));
        // D s_1850_8: cast reint s_1850_7 -> u8
        let s_1850_8: bool = ((s_1850_7.value()) != 0);
        // D s_1850_9: cast zx s_1850_8 -> bv
        let s_1850_9: Bits = Bits::new(s_1850_8 as u128, 1u16);
        // C s_1850_10: const #0u : u8
        let s_1850_10: bool = false;
        // C s_1850_11: cast zx s_1850_10 -> bv
        let s_1850_11: Bits = Bits::new(s_1850_10 as u128, 1u16);
        // D s_1850_12: cmp-eq s_1850_9 s_1850_11
        let s_1850_12: bool = ((s_1850_9) == (s_1850_11));
        // D s_1850_13: write-var gs#402872 <= s_1850_12
        fn_state.gs_402872 = s_1850_12;
        // N s_1850_14: jump b1849
        return block_1849(state, tracer, fn_state);
    }
    fn block_1851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1851_0: const #3744s : i
        let s_1851_0: i128 = 3744;
        // C s_1851_1: const #14696u : u32
        let s_1851_1: u32 = 14696;
        // D s_1851_2: read-reg s_1851_1:i
        let s_1851_2: i128 = {
            let value = state.read_register::<i128>(s_1851_1 as isize);
            tracer.read_register(s_1851_1 as isize, value);
            value
        };
        // D s_1851_3: cmp-lt s_1851_2 s_1851_0
        let s_1851_3: bool = ((s_1851_2) < (s_1851_0));
        // D s_1851_4: write-var gs#402842 <= s_1851_3
        fn_state.gs_402842 = s_1851_3;
        // N s_1851_5: jump b1265
        return block_1265(state, tracer, fn_state);
    }
    fn block_1852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1852_0: const #8s : i
        let s_1852_0: i128 = 8;
        // D s_1852_1: read-var u#32080:u32
        let s_1852_1: u32 = fn_state.u_32080;
        // D s_1852_2: cast zx s_1852_1 -> bv
        let s_1852_2: Bits = Bits::new(s_1852_1 as u128, 32u16);
        // C s_1852_3: const #1s : i64
        let s_1852_3: i64 = 1;
        // C s_1852_4: cast zx s_1852_3 -> i
        let s_1852_4: i128 = (i128::try_from(s_1852_3).unwrap());
        // C s_1852_5: const #3s : i
        let s_1852_5: i128 = 3;
        // C s_1852_6: add s_1852_5 s_1852_4
        let s_1852_6: i128 = (s_1852_5 + s_1852_4);
        // D s_1852_7: bit-extract s_1852_2 s_1852_0 s_1852_6
        let s_1852_7: Bits = (Bits::new(
            ((s_1852_2) >> (s_1852_0)).value(),
            u16::try_from(s_1852_6).unwrap(),
        ));
        // D s_1852_8: cast reint s_1852_7 -> u8
        let s_1852_8: u8 = (s_1852_7.value() as u8);
        // D s_1852_9: cast zx s_1852_8 -> bv
        let s_1852_9: Bits = Bits::new(s_1852_8 as u128, 4u16);
        // C s_1852_10: const #8u : u8
        let s_1852_10: u8 = 8;
        // C s_1852_11: cast zx s_1852_10 -> bv
        let s_1852_11: Bits = Bits::new(s_1852_10 as u128, 4u16);
        // D s_1852_12: cmp-eq s_1852_9 s_1852_11
        let s_1852_12: bool = ((s_1852_9) == (s_1852_11));
        // N s_1852_13: branch s_1852_12 b1855 b1853
        if s_1852_12 {
            return block_1855(state, tracer, fn_state);
        } else {
            return block_1853(state, tracer, fn_state);
        };
    }
    fn block_1853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1853_0: const #0u : u8
        let s_1853_0: bool = false;
        // D s_1853_1: write-var gs#402839 <= s_1853_0
        fn_state.gs_402839 = s_1853_0;
        // N s_1853_2: jump b1854
        return block_1854(state, tracer, fn_state);
    }
    fn block_1854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1854_0: read-var gs#402839:u8
        let s_1854_0: bool = fn_state.gs_402839;
        // D s_1854_1: write-var gs#402840 <= s_1854_0
        fn_state.gs_402840 = s_1854_0;
        // N s_1854_2: jump b1263
        return block_1263(state, tracer, fn_state);
    }
    fn block_1855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1855_0: const #4s : i
        let s_1855_0: i128 = 4;
        // D s_1855_1: read-var u#32080:u32
        let s_1855_1: u32 = fn_state.u_32080;
        // D s_1855_2: cast zx s_1855_1 -> bv
        let s_1855_2: Bits = Bits::new(s_1855_1 as u128, 32u16);
        // C s_1855_3: const #1s : i64
        let s_1855_3: i64 = 1;
        // C s_1855_4: cast zx s_1855_3 -> i
        let s_1855_4: i128 = (i128::try_from(s_1855_3).unwrap());
        // C s_1855_5: const #0s : i
        let s_1855_5: i128 = 0;
        // C s_1855_6: add s_1855_5 s_1855_4
        let s_1855_6: i128 = (s_1855_5 + s_1855_4);
        // D s_1855_7: bit-extract s_1855_2 s_1855_0 s_1855_6
        let s_1855_7: Bits = (Bits::new(
            ((s_1855_2) >> (s_1855_0)).value(),
            u16::try_from(s_1855_6).unwrap(),
        ));
        // D s_1855_8: cast reint s_1855_7 -> u8
        let s_1855_8: bool = ((s_1855_7.value()) != 0);
        // D s_1855_9: cast zx s_1855_8 -> bv
        let s_1855_9: Bits = Bits::new(s_1855_8 as u128, 1u16);
        // C s_1855_10: const #0u : u8
        let s_1855_10: bool = false;
        // C s_1855_11: cast zx s_1855_10 -> bv
        let s_1855_11: Bits = Bits::new(s_1855_10 as u128, 1u16);
        // D s_1855_12: cmp-eq s_1855_9 s_1855_11
        let s_1855_12: bool = ((s_1855_9) == (s_1855_11));
        // D s_1855_13: write-var gs#402839 <= s_1855_12
        fn_state.gs_402839 = s_1855_12;
        // N s_1855_14: jump b1854
        return block_1854(state, tracer, fn_state);
    }
    fn block_1856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1856_0: const #3742s : i
        let s_1856_0: i128 = 3742;
        // C s_1856_1: const #14696u : u32
        let s_1856_1: u32 = 14696;
        // D s_1856_2: read-reg s_1856_1:i
        let s_1856_2: i128 = {
            let value = state.read_register::<i128>(s_1856_1 as isize);
            tracer.read_register(s_1856_1 as isize, value);
            value
        };
        // D s_1856_3: cmp-lt s_1856_2 s_1856_0
        let s_1856_3: bool = ((s_1856_2) < (s_1856_0));
        // D s_1856_4: write-var gs#402815 <= s_1856_3
        fn_state.gs_402815 = s_1856_3;
        // N s_1856_5: jump b1259
        return block_1259(state, tracer, fn_state);
    }
    fn block_1857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1857_0: const #8s : i
        let s_1857_0: i128 = 8;
        // D s_1857_1: read-var u#32071:u32
        let s_1857_1: u32 = fn_state.u_32071;
        // D s_1857_2: cast zx s_1857_1 -> bv
        let s_1857_2: Bits = Bits::new(s_1857_1 as u128, 32u16);
        // C s_1857_3: const #1s : i64
        let s_1857_3: i64 = 1;
        // C s_1857_4: cast zx s_1857_3 -> i
        let s_1857_4: i128 = (i128::try_from(s_1857_3).unwrap());
        // C s_1857_5: const #3s : i
        let s_1857_5: i128 = 3;
        // C s_1857_6: add s_1857_5 s_1857_4
        let s_1857_6: i128 = (s_1857_5 + s_1857_4);
        // D s_1857_7: bit-extract s_1857_2 s_1857_0 s_1857_6
        let s_1857_7: Bits = (Bits::new(
            ((s_1857_2) >> (s_1857_0)).value(),
            u16::try_from(s_1857_6).unwrap(),
        ));
        // D s_1857_8: cast reint s_1857_7 -> u8
        let s_1857_8: u8 = (s_1857_7.value() as u8);
        // D s_1857_9: cast zx s_1857_8 -> bv
        let s_1857_9: Bits = Bits::new(s_1857_8 as u128, 4u16);
        // C s_1857_10: const #6u : u8
        let s_1857_10: u8 = 6;
        // C s_1857_11: cast zx s_1857_10 -> bv
        let s_1857_11: Bits = Bits::new(s_1857_10 as u128, 4u16);
        // D s_1857_12: cmp-eq s_1857_9 s_1857_11
        let s_1857_12: bool = ((s_1857_9) == (s_1857_11));
        // N s_1857_13: branch s_1857_12 b1860 b1858
        if s_1857_12 {
            return block_1860(state, tracer, fn_state);
        } else {
            return block_1858(state, tracer, fn_state);
        };
    }
    fn block_1858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1858_0: const #0u : u8
        let s_1858_0: bool = false;
        // D s_1858_1: write-var gs#402812 <= s_1858_0
        fn_state.gs_402812 = s_1858_0;
        // N s_1858_2: jump b1859
        return block_1859(state, tracer, fn_state);
    }
    fn block_1859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1859_0: read-var gs#402812:u8
        let s_1859_0: bool = fn_state.gs_402812;
        // D s_1859_1: write-var gs#402813 <= s_1859_0
        fn_state.gs_402813 = s_1859_0;
        // N s_1859_2: jump b1257
        return block_1257(state, tracer, fn_state);
    }
    fn block_1860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1860_0: const #6s : i
        let s_1860_0: i128 = 6;
        // D s_1860_1: read-var u#32071:u32
        let s_1860_1: u32 = fn_state.u_32071;
        // D s_1860_2: cast zx s_1860_1 -> bv
        let s_1860_2: Bits = Bits::new(s_1860_1 as u128, 32u16);
        // C s_1860_3: const #1s : i64
        let s_1860_3: i64 = 1;
        // C s_1860_4: cast zx s_1860_3 -> i
        let s_1860_4: i128 = (i128::try_from(s_1860_3).unwrap());
        // C s_1860_5: const #0s : i
        let s_1860_5: i128 = 0;
        // C s_1860_6: add s_1860_5 s_1860_4
        let s_1860_6: i128 = (s_1860_5 + s_1860_4);
        // D s_1860_7: bit-extract s_1860_2 s_1860_0 s_1860_6
        let s_1860_7: Bits = (Bits::new(
            ((s_1860_2) >> (s_1860_0)).value(),
            u16::try_from(s_1860_6).unwrap(),
        ));
        // D s_1860_8: cast reint s_1860_7 -> u8
        let s_1860_8: bool = ((s_1860_7.value()) != 0);
        // D s_1860_9: cast zx s_1860_8 -> bv
        let s_1860_9: Bits = Bits::new(s_1860_8 as u128, 1u16);
        // C s_1860_10: const #0u : u8
        let s_1860_10: bool = false;
        // C s_1860_11: cast zx s_1860_10 -> bv
        let s_1860_11: Bits = Bits::new(s_1860_10 as u128, 1u16);
        // D s_1860_12: cmp-eq s_1860_9 s_1860_11
        let s_1860_12: bool = ((s_1860_9) == (s_1860_11));
        // N s_1860_13: branch s_1860_12 b1863 b1861
        if s_1860_12 {
            return block_1863(state, tracer, fn_state);
        } else {
            return block_1861(state, tracer, fn_state);
        };
    }
    fn block_1861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1861_0: const #0u : u8
        let s_1861_0: bool = false;
        // D s_1861_1: write-var gs#402811 <= s_1861_0
        fn_state.gs_402811 = s_1861_0;
        // N s_1861_2: jump b1862
        return block_1862(state, tracer, fn_state);
    }
    fn block_1862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1862_0: read-var gs#402811:u8
        let s_1862_0: bool = fn_state.gs_402811;
        // D s_1862_1: write-var gs#402812 <= s_1862_0
        fn_state.gs_402812 = s_1862_0;
        // N s_1862_2: jump b1859
        return block_1859(state, tracer, fn_state);
    }
    fn block_1863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1863_0: const #4s : i
        let s_1863_0: i128 = 4;
        // D s_1863_1: read-var u#32071:u32
        let s_1863_1: u32 = fn_state.u_32071;
        // D s_1863_2: cast zx s_1863_1 -> bv
        let s_1863_2: Bits = Bits::new(s_1863_1 as u128, 32u16);
        // C s_1863_3: const #1s : i64
        let s_1863_3: i64 = 1;
        // C s_1863_4: cast zx s_1863_3 -> i
        let s_1863_4: i128 = (i128::try_from(s_1863_3).unwrap());
        // C s_1863_5: const #0s : i
        let s_1863_5: i128 = 0;
        // C s_1863_6: add s_1863_5 s_1863_4
        let s_1863_6: i128 = (s_1863_5 + s_1863_4);
        // D s_1863_7: bit-extract s_1863_2 s_1863_0 s_1863_6
        let s_1863_7: Bits = (Bits::new(
            ((s_1863_2) >> (s_1863_0)).value(),
            u16::try_from(s_1863_6).unwrap(),
        ));
        // D s_1863_8: cast reint s_1863_7 -> u8
        let s_1863_8: bool = ((s_1863_7.value()) != 0);
        // D s_1863_9: cast zx s_1863_8 -> bv
        let s_1863_9: Bits = Bits::new(s_1863_8 as u128, 1u16);
        // C s_1863_10: const #0u : u8
        let s_1863_10: bool = false;
        // C s_1863_11: cast zx s_1863_10 -> bv
        let s_1863_11: Bits = Bits::new(s_1863_10 as u128, 1u16);
        // D s_1863_12: cmp-eq s_1863_9 s_1863_11
        let s_1863_12: bool = ((s_1863_9) == (s_1863_11));
        // D s_1863_13: write-var gs#402811 <= s_1863_12
        fn_state.gs_402811 = s_1863_12;
        // N s_1863_14: jump b1862
        return block_1862(state, tracer, fn_state);
    }
    fn block_1864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1864_0: const #3738s : i
        let s_1864_0: i128 = 3738;
        // C s_1864_1: const #14696u : u32
        let s_1864_1: u32 = 14696;
        // D s_1864_2: read-reg s_1864_1:i
        let s_1864_2: i128 = {
            let value = state.read_register::<i128>(s_1864_1 as isize);
            tracer.read_register(s_1864_1 as isize, value);
            value
        };
        // D s_1864_3: cmp-lt s_1864_2 s_1864_0
        let s_1864_3: bool = ((s_1864_2) < (s_1864_0));
        // D s_1864_4: write-var gs#402783 <= s_1864_3
        fn_state.gs_402783 = s_1864_3;
        // N s_1864_5: jump b1253
        return block_1253(state, tracer, fn_state);
    }
    fn block_1865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1865_0: const #21s : i
        let s_1865_0: i128 = 21;
        // D s_1865_1: read-var u#32061:u32
        let s_1865_1: u32 = fn_state.u_32061;
        // D s_1865_2: cast zx s_1865_1 -> bv
        let s_1865_2: Bits = Bits::new(s_1865_1 as u128, 32u16);
        // C s_1865_3: const #1s : i64
        let s_1865_3: i64 = 1;
        // C s_1865_4: cast zx s_1865_3 -> i
        let s_1865_4: i128 = (i128::try_from(s_1865_3).unwrap());
        // C s_1865_5: const #0s : i
        let s_1865_5: i128 = 0;
        // C s_1865_6: add s_1865_5 s_1865_4
        let s_1865_6: i128 = (s_1865_5 + s_1865_4);
        // D s_1865_7: bit-extract s_1865_2 s_1865_0 s_1865_6
        let s_1865_7: Bits = (Bits::new(
            ((s_1865_2) >> (s_1865_0)).value(),
            u16::try_from(s_1865_6).unwrap(),
        ));
        // D s_1865_8: cast reint s_1865_7 -> u8
        let s_1865_8: bool = ((s_1865_7.value()) != 0);
        // D s_1865_9: cast zx s_1865_8 -> bv
        let s_1865_9: Bits = Bits::new(s_1865_8 as u128, 1u16);
        // C s_1865_10: const #1u : u8
        let s_1865_10: bool = true;
        // C s_1865_11: cast zx s_1865_10 -> bv
        let s_1865_11: Bits = Bits::new(s_1865_10 as u128, 1u16);
        // D s_1865_12: cmp-eq s_1865_9 s_1865_11
        let s_1865_12: bool = ((s_1865_9) == (s_1865_11));
        // N s_1865_13: branch s_1865_12 b1868 b1866
        if s_1865_12 {
            return block_1868(state, tracer, fn_state);
        } else {
            return block_1866(state, tracer, fn_state);
        };
    }
    fn block_1866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1866_0: const #0u : u8
        let s_1866_0: bool = false;
        // D s_1866_1: write-var gs#402780 <= s_1866_0
        fn_state.gs_402780 = s_1866_0;
        // N s_1866_2: jump b1867
        return block_1867(state, tracer, fn_state);
    }
    fn block_1867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1867_0: read-var gs#402780:u8
        let s_1867_0: bool = fn_state.gs_402780;
        // D s_1867_1: write-var gs#402781 <= s_1867_0
        fn_state.gs_402781 = s_1867_0;
        // N s_1867_2: jump b1251
        return block_1251(state, tracer, fn_state);
    }
    fn block_1868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1868_0: const #8s : i
        let s_1868_0: i128 = 8;
        // D s_1868_1: read-var u#32061:u32
        let s_1868_1: u32 = fn_state.u_32061;
        // D s_1868_2: cast zx s_1868_1 -> bv
        let s_1868_2: Bits = Bits::new(s_1868_1 as u128, 32u16);
        // C s_1868_3: const #1s : i64
        let s_1868_3: i64 = 1;
        // C s_1868_4: cast zx s_1868_3 -> i
        let s_1868_4: i128 = (i128::try_from(s_1868_3).unwrap());
        // C s_1868_5: const #3s : i
        let s_1868_5: i128 = 3;
        // C s_1868_6: add s_1868_5 s_1868_4
        let s_1868_6: i128 = (s_1868_5 + s_1868_4);
        // D s_1868_7: bit-extract s_1868_2 s_1868_0 s_1868_6
        let s_1868_7: Bits = (Bits::new(
            ((s_1868_2) >> (s_1868_0)).value(),
            u16::try_from(s_1868_6).unwrap(),
        ));
        // D s_1868_8: cast reint s_1868_7 -> u8
        let s_1868_8: u8 = (s_1868_7.value() as u8);
        // D s_1868_9: cast zx s_1868_8 -> bv
        let s_1868_9: Bits = Bits::new(s_1868_8 as u128, 4u16);
        // C s_1868_10: const #13u : u8
        let s_1868_10: u8 = 13;
        // C s_1868_11: cast zx s_1868_10 -> bv
        let s_1868_11: Bits = Bits::new(s_1868_10 as u128, 4u16);
        // D s_1868_12: cmp-eq s_1868_9 s_1868_11
        let s_1868_12: bool = ((s_1868_9) == (s_1868_11));
        // N s_1868_13: branch s_1868_12 b1871 b1869
        if s_1868_12 {
            return block_1871(state, tracer, fn_state);
        } else {
            return block_1869(state, tracer, fn_state);
        };
    }
    fn block_1869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1869_0: const #0u : u8
        let s_1869_0: bool = false;
        // D s_1869_1: write-var gs#402779 <= s_1869_0
        fn_state.gs_402779 = s_1869_0;
        // N s_1869_2: jump b1870
        return block_1870(state, tracer, fn_state);
    }
    fn block_1870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1870_0: read-var gs#402779:u8
        let s_1870_0: bool = fn_state.gs_402779;
        // D s_1870_1: write-var gs#402780 <= s_1870_0
        fn_state.gs_402780 = s_1870_0;
        // N s_1870_2: jump b1867
        return block_1867(state, tracer, fn_state);
    }
    fn block_1871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1871_0: const #4s : i
        let s_1871_0: i128 = 4;
        // D s_1871_1: read-var u#32061:u32
        let s_1871_1: u32 = fn_state.u_32061;
        // D s_1871_2: cast zx s_1871_1 -> bv
        let s_1871_2: Bits = Bits::new(s_1871_1 as u128, 32u16);
        // C s_1871_3: const #1s : i64
        let s_1871_3: i64 = 1;
        // C s_1871_4: cast zx s_1871_3 -> i
        let s_1871_4: i128 = (i128::try_from(s_1871_3).unwrap());
        // C s_1871_5: const #0s : i
        let s_1871_5: i128 = 0;
        // C s_1871_6: add s_1871_5 s_1871_4
        let s_1871_6: i128 = (s_1871_5 + s_1871_4);
        // D s_1871_7: bit-extract s_1871_2 s_1871_0 s_1871_6
        let s_1871_7: Bits = (Bits::new(
            ((s_1871_2) >> (s_1871_0)).value(),
            u16::try_from(s_1871_6).unwrap(),
        ));
        // D s_1871_8: cast reint s_1871_7 -> u8
        let s_1871_8: bool = ((s_1871_7.value()) != 0);
        // D s_1871_9: cast zx s_1871_8 -> bv
        let s_1871_9: Bits = Bits::new(s_1871_8 as u128, 1u16);
        // C s_1871_10: const #0u : u8
        let s_1871_10: bool = false;
        // C s_1871_11: cast zx s_1871_10 -> bv
        let s_1871_11: Bits = Bits::new(s_1871_10 as u128, 1u16);
        // D s_1871_12: cmp-eq s_1871_9 s_1871_11
        let s_1871_12: bool = ((s_1871_9) == (s_1871_11));
        // D s_1871_13: write-var gs#402779 <= s_1871_12
        fn_state.gs_402779 = s_1871_12;
        // N s_1871_14: jump b1870
        return block_1870(state, tracer, fn_state);
    }
    fn block_1872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1872_0: const #3730s : i
        let s_1872_0: i128 = 3730;
        // C s_1872_1: const #14696u : u32
        let s_1872_1: u32 = 14696;
        // D s_1872_2: read-reg s_1872_1:i
        let s_1872_2: i128 = {
            let value = state.read_register::<i128>(s_1872_1 as isize);
            tracer.read_register(s_1872_1 as isize, value);
            value
        };
        // D s_1872_3: cmp-lt s_1872_2 s_1872_0
        let s_1872_3: bool = ((s_1872_2) < (s_1872_0));
        // D s_1872_4: write-var gs#402753 <= s_1872_3
        fn_state.gs_402753 = s_1872_3;
        // N s_1872_5: jump b1247
        return block_1247(state, tracer, fn_state);
    }
    fn block_1873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1873_0: const #20s : i
        let s_1873_0: i128 = 20;
        // D s_1873_1: read-var u#32052:u32
        let s_1873_1: u32 = fn_state.u_32052;
        // D s_1873_2: cast zx s_1873_1 -> bv
        let s_1873_2: Bits = Bits::new(s_1873_1 as u128, 32u16);
        // C s_1873_3: const #1s : i64
        let s_1873_3: i64 = 1;
        // C s_1873_4: cast zx s_1873_3 -> i
        let s_1873_4: i128 = (i128::try_from(s_1873_3).unwrap());
        // C s_1873_5: const #1s : i
        let s_1873_5: i128 = 1;
        // C s_1873_6: add s_1873_5 s_1873_4
        let s_1873_6: i128 = (s_1873_5 + s_1873_4);
        // D s_1873_7: bit-extract s_1873_2 s_1873_0 s_1873_6
        let s_1873_7: Bits = (Bits::new(
            ((s_1873_2) >> (s_1873_0)).value(),
            u16::try_from(s_1873_6).unwrap(),
        ));
        // D s_1873_8: cast reint s_1873_7 -> u8
        let s_1873_8: u8 = (s_1873_7.value() as u8);
        // D s_1873_9: cast zx s_1873_8 -> bv
        let s_1873_9: Bits = Bits::new(s_1873_8 as u128, 2u16);
        // C s_1873_10: const #0u : u8
        let s_1873_10: u8 = 0;
        // C s_1873_11: cast zx s_1873_10 -> bv
        let s_1873_11: Bits = Bits::new(s_1873_10 as u128, 2u16);
        // D s_1873_12: cmp-eq s_1873_9 s_1873_11
        let s_1873_12: bool = ((s_1873_9) == (s_1873_11));
        // N s_1873_13: branch s_1873_12 b1876 b1874
        if s_1873_12 {
            return block_1876(state, tracer, fn_state);
        } else {
            return block_1874(state, tracer, fn_state);
        };
    }
    fn block_1874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1874_0: const #0u : u8
        let s_1874_0: bool = false;
        // D s_1874_1: write-var gs#402750 <= s_1874_0
        fn_state.gs_402750 = s_1874_0;
        // N s_1874_2: jump b1875
        return block_1875(state, tracer, fn_state);
    }
    fn block_1875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1875_0: read-var gs#402750:u8
        let s_1875_0: bool = fn_state.gs_402750;
        // D s_1875_1: write-var gs#402751 <= s_1875_0
        fn_state.gs_402751 = s_1875_0;
        // N s_1875_2: jump b1245
        return block_1245(state, tracer, fn_state);
    }
    fn block_1876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1876_0: const #9s : i
        let s_1876_0: i128 = 9;
        // D s_1876_1: read-var u#32052:u32
        let s_1876_1: u32 = fn_state.u_32052;
        // D s_1876_2: cast zx s_1876_1 -> bv
        let s_1876_2: Bits = Bits::new(s_1876_1 as u128, 32u16);
        // C s_1876_3: const #1s : i64
        let s_1876_3: i64 = 1;
        // C s_1876_4: cast zx s_1876_3 -> i
        let s_1876_4: i128 = (i128::try_from(s_1876_3).unwrap());
        // C s_1876_5: const #2s : i
        let s_1876_5: i128 = 2;
        // C s_1876_6: add s_1876_5 s_1876_4
        let s_1876_6: i128 = (s_1876_5 + s_1876_4);
        // D s_1876_7: bit-extract s_1876_2 s_1876_0 s_1876_6
        let s_1876_7: Bits = (Bits::new(
            ((s_1876_2) >> (s_1876_0)).value(),
            u16::try_from(s_1876_6).unwrap(),
        ));
        // D s_1876_8: cast reint s_1876_7 -> u8
        let s_1876_8: u8 = (s_1876_7.value() as u8);
        // D s_1876_9: cast zx s_1876_8 -> bv
        let s_1876_9: Bits = Bits::new(s_1876_8 as u128, 3u16);
        // C s_1876_10: const #0u : u8
        let s_1876_10: u8 = 0;
        // C s_1876_11: cast zx s_1876_10 -> bv
        let s_1876_11: Bits = Bits::new(s_1876_10 as u128, 3u16);
        // D s_1876_12: cmp-eq s_1876_9 s_1876_11
        let s_1876_12: bool = ((s_1876_9) == (s_1876_11));
        // D s_1876_13: write-var gs#402750 <= s_1876_12
        fn_state.gs_402750 = s_1876_12;
        // N s_1876_14: jump b1875
        return block_1875(state, tracer, fn_state);
    }
    fn block_1877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1877_0: const #3726s : i
        let s_1877_0: i128 = 3726;
        // C s_1877_1: const #14696u : u32
        let s_1877_1: u32 = 14696;
        // D s_1877_2: read-reg s_1877_1:i
        let s_1877_2: i128 = {
            let value = state.read_register::<i128>(s_1877_1 as isize);
            tracer.read_register(s_1877_1 as isize, value);
            value
        };
        // D s_1877_3: cmp-lt s_1877_2 s_1877_0
        let s_1877_3: bool = ((s_1877_2) < (s_1877_0));
        // D s_1877_4: write-var gs#402728 <= s_1877_3
        fn_state.gs_402728 = s_1877_3;
        // N s_1877_5: jump b1241
        return block_1241(state, tracer, fn_state);
    }
    fn block_1878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1878_0: const #20s : i
        let s_1878_0: i128 = 20;
        // D s_1878_1: read-var u#32044:u32
        let s_1878_1: u32 = fn_state.u_32044;
        // D s_1878_2: cast zx s_1878_1 -> bv
        let s_1878_2: Bits = Bits::new(s_1878_1 as u128, 32u16);
        // C s_1878_3: const #1s : i64
        let s_1878_3: i64 = 1;
        // C s_1878_4: cast zx s_1878_3 -> i
        let s_1878_4: i128 = (i128::try_from(s_1878_3).unwrap());
        // C s_1878_5: const #1s : i
        let s_1878_5: i128 = 1;
        // C s_1878_6: add s_1878_5 s_1878_4
        let s_1878_6: i128 = (s_1878_5 + s_1878_4);
        // D s_1878_7: bit-extract s_1878_2 s_1878_0 s_1878_6
        let s_1878_7: Bits = (Bits::new(
            ((s_1878_2) >> (s_1878_0)).value(),
            u16::try_from(s_1878_6).unwrap(),
        ));
        // D s_1878_8: cast reint s_1878_7 -> u8
        let s_1878_8: u8 = (s_1878_7.value() as u8);
        // D s_1878_9: cast zx s_1878_8 -> bv
        let s_1878_9: Bits = Bits::new(s_1878_8 as u128, 2u16);
        // C s_1878_10: const #0u : u8
        let s_1878_10: u8 = 0;
        // C s_1878_11: cast zx s_1878_10 -> bv
        let s_1878_11: Bits = Bits::new(s_1878_10 as u128, 2u16);
        // D s_1878_12: cmp-eq s_1878_9 s_1878_11
        let s_1878_12: bool = ((s_1878_9) == (s_1878_11));
        // N s_1878_13: branch s_1878_12 b1881 b1879
        if s_1878_12 {
            return block_1881(state, tracer, fn_state);
        } else {
            return block_1879(state, tracer, fn_state);
        };
    }
    fn block_1879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1879_0: const #0u : u8
        let s_1879_0: bool = false;
        // D s_1879_1: write-var gs#402725 <= s_1879_0
        fn_state.gs_402725 = s_1879_0;
        // N s_1879_2: jump b1880
        return block_1880(state, tracer, fn_state);
    }
    fn block_1880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1880_0: read-var gs#402725:u8
        let s_1880_0: bool = fn_state.gs_402725;
        // D s_1880_1: write-var gs#402726 <= s_1880_0
        fn_state.gs_402726 = s_1880_0;
        // N s_1880_2: jump b1239
        return block_1239(state, tracer, fn_state);
    }
    fn block_1881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1881_0: const #8s : i
        let s_1881_0: i128 = 8;
        // D s_1881_1: read-var u#32044:u32
        let s_1881_1: u32 = fn_state.u_32044;
        // D s_1881_2: cast zx s_1881_1 -> bv
        let s_1881_2: Bits = Bits::new(s_1881_1 as u128, 32u16);
        // C s_1881_3: const #1s : i64
        let s_1881_3: i64 = 1;
        // C s_1881_4: cast zx s_1881_3 -> i
        let s_1881_4: i128 = (i128::try_from(s_1881_3).unwrap());
        // C s_1881_5: const #3s : i
        let s_1881_5: i128 = 3;
        // C s_1881_6: add s_1881_5 s_1881_4
        let s_1881_6: i128 = (s_1881_5 + s_1881_4);
        // D s_1881_7: bit-extract s_1881_2 s_1881_0 s_1881_6
        let s_1881_7: Bits = (Bits::new(
            ((s_1881_2) >> (s_1881_0)).value(),
            u16::try_from(s_1881_6).unwrap(),
        ));
        // D s_1881_8: cast reint s_1881_7 -> u8
        let s_1881_8: u8 = (s_1881_7.value() as u8);
        // D s_1881_9: cast zx s_1881_8 -> bv
        let s_1881_9: Bits = Bits::new(s_1881_8 as u128, 4u16);
        // C s_1881_10: const #11u : u8
        let s_1881_10: u8 = 11;
        // C s_1881_11: cast zx s_1881_10 -> bv
        let s_1881_11: Bits = Bits::new(s_1881_10 as u128, 4u16);
        // D s_1881_12: cmp-eq s_1881_9 s_1881_11
        let s_1881_12: bool = ((s_1881_9) == (s_1881_11));
        // D s_1881_13: write-var gs#402725 <= s_1881_12
        fn_state.gs_402725 = s_1881_12;
        // N s_1881_14: jump b1880
        return block_1880(state, tracer, fn_state);
    }
    fn block_1882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1882_0: const #3725s : i
        let s_1882_0: i128 = 3725;
        // C s_1882_1: const #14696u : u32
        let s_1882_1: u32 = 14696;
        // D s_1882_2: read-reg s_1882_1:i
        let s_1882_2: i128 = {
            let value = state.read_register::<i128>(s_1882_1 as isize);
            tracer.read_register(s_1882_1 as isize, value);
            value
        };
        // D s_1882_3: cmp-lt s_1882_2 s_1882_0
        let s_1882_3: bool = ((s_1882_2) < (s_1882_0));
        // D s_1882_4: write-var gs#402703 <= s_1882_3
        fn_state.gs_402703 = s_1882_3;
        // N s_1882_5: jump b1235
        return block_1235(state, tracer, fn_state);
    }
    fn block_1883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1883_0: const #20s : i
        let s_1883_0: i128 = 20;
        // D s_1883_1: read-var u#32036:u32
        let s_1883_1: u32 = fn_state.u_32036;
        // D s_1883_2: cast zx s_1883_1 -> bv
        let s_1883_2: Bits = Bits::new(s_1883_1 as u128, 32u16);
        // C s_1883_3: const #1s : i64
        let s_1883_3: i64 = 1;
        // C s_1883_4: cast zx s_1883_3 -> i
        let s_1883_4: i128 = (i128::try_from(s_1883_3).unwrap());
        // C s_1883_5: const #1s : i
        let s_1883_5: i128 = 1;
        // C s_1883_6: add s_1883_5 s_1883_4
        let s_1883_6: i128 = (s_1883_5 + s_1883_4);
        // D s_1883_7: bit-extract s_1883_2 s_1883_0 s_1883_6
        let s_1883_7: Bits = (Bits::new(
            ((s_1883_2) >> (s_1883_0)).value(),
            u16::try_from(s_1883_6).unwrap(),
        ));
        // D s_1883_8: cast reint s_1883_7 -> u8
        let s_1883_8: u8 = (s_1883_7.value() as u8);
        // D s_1883_9: cast zx s_1883_8 -> bv
        let s_1883_9: Bits = Bits::new(s_1883_8 as u128, 2u16);
        // C s_1883_10: const #0u : u8
        let s_1883_10: u8 = 0;
        // C s_1883_11: cast zx s_1883_10 -> bv
        let s_1883_11: Bits = Bits::new(s_1883_10 as u128, 2u16);
        // D s_1883_12: cmp-eq s_1883_9 s_1883_11
        let s_1883_12: bool = ((s_1883_9) == (s_1883_11));
        // N s_1883_13: branch s_1883_12 b1886 b1884
        if s_1883_12 {
            return block_1886(state, tracer, fn_state);
        } else {
            return block_1884(state, tracer, fn_state);
        };
    }
    fn block_1884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1884_0: const #0u : u8
        let s_1884_0: bool = false;
        // D s_1884_1: write-var gs#402700 <= s_1884_0
        fn_state.gs_402700 = s_1884_0;
        // N s_1884_2: jump b1885
        return block_1885(state, tracer, fn_state);
    }
    fn block_1885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1885_0: read-var gs#402700:u8
        let s_1885_0: bool = fn_state.gs_402700;
        // D s_1885_1: write-var gs#402701 <= s_1885_0
        fn_state.gs_402701 = s_1885_0;
        // N s_1885_2: jump b1233
        return block_1233(state, tracer, fn_state);
    }
    fn block_1886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1886_0: const #8s : i
        let s_1886_0: i128 = 8;
        // D s_1886_1: read-var u#32036:u32
        let s_1886_1: u32 = fn_state.u_32036;
        // D s_1886_2: cast zx s_1886_1 -> bv
        let s_1886_2: Bits = Bits::new(s_1886_1 as u128, 32u16);
        // C s_1886_3: const #1s : i64
        let s_1886_3: i64 = 1;
        // C s_1886_4: cast zx s_1886_3 -> i
        let s_1886_4: i128 = (i128::try_from(s_1886_3).unwrap());
        // C s_1886_5: const #3s : i
        let s_1886_5: i128 = 3;
        // C s_1886_6: add s_1886_5 s_1886_4
        let s_1886_6: i128 = (s_1886_5 + s_1886_4);
        // D s_1886_7: bit-extract s_1886_2 s_1886_0 s_1886_6
        let s_1886_7: Bits = (Bits::new(
            ((s_1886_2) >> (s_1886_0)).value(),
            u16::try_from(s_1886_6).unwrap(),
        ));
        // D s_1886_8: cast reint s_1886_7 -> u8
        let s_1886_8: u8 = (s_1886_7.value() as u8);
        // D s_1886_9: cast zx s_1886_8 -> bv
        let s_1886_9: Bits = Bits::new(s_1886_8 as u128, 4u16);
        // C s_1886_10: const #7u : u8
        let s_1886_10: u8 = 7;
        // C s_1886_11: cast zx s_1886_10 -> bv
        let s_1886_11: Bits = Bits::new(s_1886_10 as u128, 4u16);
        // D s_1886_12: cmp-eq s_1886_9 s_1886_11
        let s_1886_12: bool = ((s_1886_9) == (s_1886_11));
        // D s_1886_13: write-var gs#402700 <= s_1886_12
        fn_state.gs_402700 = s_1886_12;
        // N s_1886_14: jump b1885
        return block_1885(state, tracer, fn_state);
    }
    fn block_1887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1887_0: const #3724s : i
        let s_1887_0: i128 = 3724;
        // C s_1887_1: const #14696u : u32
        let s_1887_1: u32 = 14696;
        // D s_1887_2: read-reg s_1887_1:i
        let s_1887_2: i128 = {
            let value = state.read_register::<i128>(s_1887_1 as isize);
            tracer.read_register(s_1887_1 as isize, value);
            value
        };
        // D s_1887_3: cmp-lt s_1887_2 s_1887_0
        let s_1887_3: bool = ((s_1887_2) < (s_1887_0));
        // D s_1887_4: write-var gs#402678 <= s_1887_3
        fn_state.gs_402678 = s_1887_3;
        // N s_1887_5: jump b1229
        return block_1229(state, tracer, fn_state);
    }
    fn block_1888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1888_0: const #20s : i
        let s_1888_0: i128 = 20;
        // D s_1888_1: read-var u#32028:u32
        let s_1888_1: u32 = fn_state.u_32028;
        // D s_1888_2: cast zx s_1888_1 -> bv
        let s_1888_2: Bits = Bits::new(s_1888_1 as u128, 32u16);
        // C s_1888_3: const #1s : i64
        let s_1888_3: i64 = 1;
        // C s_1888_4: cast zx s_1888_3 -> i
        let s_1888_4: i128 = (i128::try_from(s_1888_3).unwrap());
        // C s_1888_5: const #1s : i
        let s_1888_5: i128 = 1;
        // C s_1888_6: add s_1888_5 s_1888_4
        let s_1888_6: i128 = (s_1888_5 + s_1888_4);
        // D s_1888_7: bit-extract s_1888_2 s_1888_0 s_1888_6
        let s_1888_7: Bits = (Bits::new(
            ((s_1888_2) >> (s_1888_0)).value(),
            u16::try_from(s_1888_6).unwrap(),
        ));
        // D s_1888_8: cast reint s_1888_7 -> u8
        let s_1888_8: u8 = (s_1888_7.value() as u8);
        // D s_1888_9: cast zx s_1888_8 -> bv
        let s_1888_9: Bits = Bits::new(s_1888_8 as u128, 2u16);
        // C s_1888_10: const #0u : u8
        let s_1888_10: u8 = 0;
        // C s_1888_11: cast zx s_1888_10 -> bv
        let s_1888_11: Bits = Bits::new(s_1888_10 as u128, 2u16);
        // D s_1888_12: cmp-eq s_1888_9 s_1888_11
        let s_1888_12: bool = ((s_1888_9) == (s_1888_11));
        // N s_1888_13: branch s_1888_12 b1891 b1889
        if s_1888_12 {
            return block_1891(state, tracer, fn_state);
        } else {
            return block_1889(state, tracer, fn_state);
        };
    }
    fn block_1889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1889_0: const #0u : u8
        let s_1889_0: bool = false;
        // D s_1889_1: write-var gs#402675 <= s_1889_0
        fn_state.gs_402675 = s_1889_0;
        // N s_1889_2: jump b1890
        return block_1890(state, tracer, fn_state);
    }
    fn block_1890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1890_0: read-var gs#402675:u8
        let s_1890_0: bool = fn_state.gs_402675;
        // D s_1890_1: write-var gs#402676 <= s_1890_0
        fn_state.gs_402676 = s_1890_0;
        // N s_1890_2: jump b1227
        return block_1227(state, tracer, fn_state);
    }
    fn block_1891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1891_0: const #8s : i
        let s_1891_0: i128 = 8;
        // D s_1891_1: read-var u#32028:u32
        let s_1891_1: u32 = fn_state.u_32028;
        // D s_1891_2: cast zx s_1891_1 -> bv
        let s_1891_2: Bits = Bits::new(s_1891_1 as u128, 32u16);
        // C s_1891_3: const #1s : i64
        let s_1891_3: i64 = 1;
        // C s_1891_4: cast zx s_1891_3 -> i
        let s_1891_4: i128 = (i128::try_from(s_1891_3).unwrap());
        // C s_1891_5: const #3s : i
        let s_1891_5: i128 = 3;
        // C s_1891_6: add s_1891_5 s_1891_4
        let s_1891_6: i128 = (s_1891_5 + s_1891_4);
        // D s_1891_7: bit-extract s_1891_2 s_1891_0 s_1891_6
        let s_1891_7: Bits = (Bits::new(
            ((s_1891_2) >> (s_1891_0)).value(),
            u16::try_from(s_1891_6).unwrap(),
        ));
        // D s_1891_8: cast reint s_1891_7 -> u8
        let s_1891_8: u8 = (s_1891_7.value() as u8);
        // D s_1891_9: cast zx s_1891_8 -> bv
        let s_1891_9: Bits = Bits::new(s_1891_8 as u128, 4u16);
        // C s_1891_10: const #3u : u8
        let s_1891_10: u8 = 3;
        // C s_1891_11: cast zx s_1891_10 -> bv
        let s_1891_11: Bits = Bits::new(s_1891_10 as u128, 4u16);
        // D s_1891_12: cmp-eq s_1891_9 s_1891_11
        let s_1891_12: bool = ((s_1891_9) == (s_1891_11));
        // D s_1891_13: write-var gs#402675 <= s_1891_12
        fn_state.gs_402675 = s_1891_12;
        // N s_1891_14: jump b1890
        return block_1890(state, tracer, fn_state);
    }
    fn block_1892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1892_0: const #3722s : i
        let s_1892_0: i128 = 3722;
        // C s_1892_1: const #14696u : u32
        let s_1892_1: u32 = 14696;
        // D s_1892_2: read-reg s_1892_1:i
        let s_1892_2: i128 = {
            let value = state.read_register::<i128>(s_1892_1 as isize);
            tracer.read_register(s_1892_1 as isize, value);
            value
        };
        // D s_1892_3: cmp-lt s_1892_2 s_1892_0
        let s_1892_3: bool = ((s_1892_2) < (s_1892_0));
        // D s_1892_4: write-var gs#402651 <= s_1892_3
        fn_state.gs_402651 = s_1892_3;
        // N s_1892_5: jump b1223
        return block_1223(state, tracer, fn_state);
    }
    fn block_1893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1893_0: const #20s : i
        let s_1893_0: i128 = 20;
        // D s_1893_1: read-var u#32019:u32
        let s_1893_1: u32 = fn_state.u_32019;
        // D s_1893_2: cast zx s_1893_1 -> bv
        let s_1893_2: Bits = Bits::new(s_1893_1 as u128, 32u16);
        // C s_1893_3: const #1s : i64
        let s_1893_3: i64 = 1;
        // C s_1893_4: cast zx s_1893_3 -> i
        let s_1893_4: i128 = (i128::try_from(s_1893_3).unwrap());
        // C s_1893_5: const #1s : i
        let s_1893_5: i128 = 1;
        // C s_1893_6: add s_1893_5 s_1893_4
        let s_1893_6: i128 = (s_1893_5 + s_1893_4);
        // D s_1893_7: bit-extract s_1893_2 s_1893_0 s_1893_6
        let s_1893_7: Bits = (Bits::new(
            ((s_1893_2) >> (s_1893_0)).value(),
            u16::try_from(s_1893_6).unwrap(),
        ));
        // D s_1893_8: cast reint s_1893_7 -> u8
        let s_1893_8: u8 = (s_1893_7.value() as u8);
        // D s_1893_9: cast zx s_1893_8 -> bv
        let s_1893_9: Bits = Bits::new(s_1893_8 as u128, 2u16);
        // C s_1893_10: const #0u : u8
        let s_1893_10: u8 = 0;
        // C s_1893_11: cast zx s_1893_10 -> bv
        let s_1893_11: Bits = Bits::new(s_1893_10 as u128, 2u16);
        // D s_1893_12: cmp-eq s_1893_9 s_1893_11
        let s_1893_12: bool = ((s_1893_9) == (s_1893_11));
        // N s_1893_13: branch s_1893_12 b1896 b1894
        if s_1893_12 {
            return block_1896(state, tracer, fn_state);
        } else {
            return block_1894(state, tracer, fn_state);
        };
    }
    fn block_1894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1894_0: const #0u : u8
        let s_1894_0: bool = false;
        // D s_1894_1: write-var gs#402648 <= s_1894_0
        fn_state.gs_402648 = s_1894_0;
        // N s_1894_2: jump b1895
        return block_1895(state, tracer, fn_state);
    }
    fn block_1895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1895_0: read-var gs#402648:u8
        let s_1895_0: bool = fn_state.gs_402648;
        // D s_1895_1: write-var gs#402649 <= s_1895_0
        fn_state.gs_402649 = s_1895_0;
        // N s_1895_2: jump b1221
        return block_1221(state, tracer, fn_state);
    }
    fn block_1896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1896_0: const #9s : i
        let s_1896_0: i128 = 9;
        // D s_1896_1: read-var u#32019:u32
        let s_1896_1: u32 = fn_state.u_32019;
        // D s_1896_2: cast zx s_1896_1 -> bv
        let s_1896_2: Bits = Bits::new(s_1896_1 as u128, 32u16);
        // C s_1896_3: const #1s : i64
        let s_1896_3: i64 = 1;
        // C s_1896_4: cast zx s_1896_3 -> i
        let s_1896_4: i128 = (i128::try_from(s_1896_3).unwrap());
        // C s_1896_5: const #2s : i
        let s_1896_5: i128 = 2;
        // C s_1896_6: add s_1896_5 s_1896_4
        let s_1896_6: i128 = (s_1896_5 + s_1896_4);
        // D s_1896_7: bit-extract s_1896_2 s_1896_0 s_1896_6
        let s_1896_7: Bits = (Bits::new(
            ((s_1896_2) >> (s_1896_0)).value(),
            u16::try_from(s_1896_6).unwrap(),
        ));
        // D s_1896_8: cast reint s_1896_7 -> u8
        let s_1896_8: u8 = (s_1896_7.value() as u8);
        // D s_1896_9: cast zx s_1896_8 -> bv
        let s_1896_9: Bits = Bits::new(s_1896_8 as u128, 3u16);
        // C s_1896_10: const #2u : u8
        let s_1896_10: u8 = 2;
        // C s_1896_11: cast zx s_1896_10 -> bv
        let s_1896_11: Bits = Bits::new(s_1896_10 as u128, 3u16);
        // D s_1896_12: cmp-eq s_1896_9 s_1896_11
        let s_1896_12: bool = ((s_1896_9) == (s_1896_11));
        // D s_1896_13: write-var gs#402648 <= s_1896_12
        fn_state.gs_402648 = s_1896_12;
        // N s_1896_14: jump b1895
        return block_1895(state, tracer, fn_state);
    }
    fn block_1897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1897_0: const #3718s : i
        let s_1897_0: i128 = 3718;
        // C s_1897_1: const #14696u : u32
        let s_1897_1: u32 = 14696;
        // D s_1897_2: read-reg s_1897_1:i
        let s_1897_2: i128 = {
            let value = state.read_register::<i128>(s_1897_1 as isize);
            tracer.read_register(s_1897_1 as isize, value);
            value
        };
        // D s_1897_3: cmp-lt s_1897_2 s_1897_0
        let s_1897_3: bool = ((s_1897_2) < (s_1897_0));
        // D s_1897_4: write-var gs#402626 <= s_1897_3
        fn_state.gs_402626 = s_1897_3;
        // N s_1897_5: jump b1217
        return block_1217(state, tracer, fn_state);
    }
    fn block_1898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1898_0: const #20s : i
        let s_1898_0: i128 = 20;
        // D s_1898_1: read-var u#32011:u32
        let s_1898_1: u32 = fn_state.u_32011;
        // D s_1898_2: cast zx s_1898_1 -> bv
        let s_1898_2: Bits = Bits::new(s_1898_1 as u128, 32u16);
        // C s_1898_3: const #1s : i64
        let s_1898_3: i64 = 1;
        // C s_1898_4: cast zx s_1898_3 -> i
        let s_1898_4: i128 = (i128::try_from(s_1898_3).unwrap());
        // C s_1898_5: const #1s : i
        let s_1898_5: i128 = 1;
        // C s_1898_6: add s_1898_5 s_1898_4
        let s_1898_6: i128 = (s_1898_5 + s_1898_4);
        // D s_1898_7: bit-extract s_1898_2 s_1898_0 s_1898_6
        let s_1898_7: Bits = (Bits::new(
            ((s_1898_2) >> (s_1898_0)).value(),
            u16::try_from(s_1898_6).unwrap(),
        ));
        // D s_1898_8: cast reint s_1898_7 -> u8
        let s_1898_8: u8 = (s_1898_7.value() as u8);
        // D s_1898_9: cast zx s_1898_8 -> bv
        let s_1898_9: Bits = Bits::new(s_1898_8 as u128, 2u16);
        // C s_1898_10: const #0u : u8
        let s_1898_10: u8 = 0;
        // C s_1898_11: cast zx s_1898_10 -> bv
        let s_1898_11: Bits = Bits::new(s_1898_10 as u128, 2u16);
        // D s_1898_12: cmp-eq s_1898_9 s_1898_11
        let s_1898_12: bool = ((s_1898_9) == (s_1898_11));
        // N s_1898_13: branch s_1898_12 b1901 b1899
        if s_1898_12 {
            return block_1901(state, tracer, fn_state);
        } else {
            return block_1899(state, tracer, fn_state);
        };
    }
    fn block_1899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1899_0: const #0u : u8
        let s_1899_0: bool = false;
        // D s_1899_1: write-var gs#402623 <= s_1899_0
        fn_state.gs_402623 = s_1899_0;
        // N s_1899_2: jump b1900
        return block_1900(state, tracer, fn_state);
    }
    fn block_1900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1900_0: read-var gs#402623:u8
        let s_1900_0: bool = fn_state.gs_402623;
        // D s_1900_1: write-var gs#402624 <= s_1900_0
        fn_state.gs_402624 = s_1900_0;
        // N s_1900_2: jump b1215
        return block_1215(state, tracer, fn_state);
    }
    fn block_1901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1901_0: const #8s : i
        let s_1901_0: i128 = 8;
        // D s_1901_1: read-var u#32011:u32
        let s_1901_1: u32 = fn_state.u_32011;
        // D s_1901_2: cast zx s_1901_1 -> bv
        let s_1901_2: Bits = Bits::new(s_1901_1 as u128, 32u16);
        // C s_1901_3: const #1s : i64
        let s_1901_3: i64 = 1;
        // C s_1901_4: cast zx s_1901_3 -> i
        let s_1901_4: i128 = (i128::try_from(s_1901_3).unwrap());
        // C s_1901_5: const #3s : i
        let s_1901_5: i128 = 3;
        // C s_1901_6: add s_1901_5 s_1901_4
        let s_1901_6: i128 = (s_1901_5 + s_1901_4);
        // D s_1901_7: bit-extract s_1901_2 s_1901_0 s_1901_6
        let s_1901_7: Bits = (Bits::new(
            ((s_1901_2) >> (s_1901_0)).value(),
            u16::try_from(s_1901_6).unwrap(),
        ));
        // D s_1901_8: cast reint s_1901_7 -> u8
        let s_1901_8: u8 = (s_1901_7.value() as u8);
        // D s_1901_9: cast zx s_1901_8 -> bv
        let s_1901_9: Bits = Bits::new(s_1901_8 as u128, 4u16);
        // C s_1901_10: const #10u : u8
        let s_1901_10: u8 = 10;
        // C s_1901_11: cast zx s_1901_10 -> bv
        let s_1901_11: Bits = Bits::new(s_1901_10 as u128, 4u16);
        // D s_1901_12: cmp-eq s_1901_9 s_1901_11
        let s_1901_12: bool = ((s_1901_9) == (s_1901_11));
        // D s_1901_13: write-var gs#402623 <= s_1901_12
        fn_state.gs_402623 = s_1901_12;
        // N s_1901_14: jump b1900
        return block_1900(state, tracer, fn_state);
    }
    fn block_1902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1902_0: const #3717s : i
        let s_1902_0: i128 = 3717;
        // C s_1902_1: const #14696u : u32
        let s_1902_1: u32 = 14696;
        // D s_1902_2: read-reg s_1902_1:i
        let s_1902_2: i128 = {
            let value = state.read_register::<i128>(s_1902_1 as isize);
            tracer.read_register(s_1902_1 as isize, value);
            value
        };
        // D s_1902_3: cmp-lt s_1902_2 s_1902_0
        let s_1902_3: bool = ((s_1902_2) < (s_1902_0));
        // D s_1902_4: write-var gs#402601 <= s_1902_3
        fn_state.gs_402601 = s_1902_3;
        // N s_1902_5: jump b1211
        return block_1211(state, tracer, fn_state);
    }
    fn block_1903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1903_0: const #20s : i
        let s_1903_0: i128 = 20;
        // D s_1903_1: read-var u#32003:u32
        let s_1903_1: u32 = fn_state.u_32003;
        // D s_1903_2: cast zx s_1903_1 -> bv
        let s_1903_2: Bits = Bits::new(s_1903_1 as u128, 32u16);
        // C s_1903_3: const #1s : i64
        let s_1903_3: i64 = 1;
        // C s_1903_4: cast zx s_1903_3 -> i
        let s_1903_4: i128 = (i128::try_from(s_1903_3).unwrap());
        // C s_1903_5: const #1s : i
        let s_1903_5: i128 = 1;
        // C s_1903_6: add s_1903_5 s_1903_4
        let s_1903_6: i128 = (s_1903_5 + s_1903_4);
        // D s_1903_7: bit-extract s_1903_2 s_1903_0 s_1903_6
        let s_1903_7: Bits = (Bits::new(
            ((s_1903_2) >> (s_1903_0)).value(),
            u16::try_from(s_1903_6).unwrap(),
        ));
        // D s_1903_8: cast reint s_1903_7 -> u8
        let s_1903_8: u8 = (s_1903_7.value() as u8);
        // D s_1903_9: cast zx s_1903_8 -> bv
        let s_1903_9: Bits = Bits::new(s_1903_8 as u128, 2u16);
        // C s_1903_10: const #0u : u8
        let s_1903_10: u8 = 0;
        // C s_1903_11: cast zx s_1903_10 -> bv
        let s_1903_11: Bits = Bits::new(s_1903_10 as u128, 2u16);
        // D s_1903_12: cmp-eq s_1903_9 s_1903_11
        let s_1903_12: bool = ((s_1903_9) == (s_1903_11));
        // N s_1903_13: branch s_1903_12 b1906 b1904
        if s_1903_12 {
            return block_1906(state, tracer, fn_state);
        } else {
            return block_1904(state, tracer, fn_state);
        };
    }
    fn block_1904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1904_0: const #0u : u8
        let s_1904_0: bool = false;
        // D s_1904_1: write-var gs#402598 <= s_1904_0
        fn_state.gs_402598 = s_1904_0;
        // N s_1904_2: jump b1905
        return block_1905(state, tracer, fn_state);
    }
    fn block_1905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1905_0: read-var gs#402598:u8
        let s_1905_0: bool = fn_state.gs_402598;
        // D s_1905_1: write-var gs#402599 <= s_1905_0
        fn_state.gs_402599 = s_1905_0;
        // N s_1905_2: jump b1209
        return block_1209(state, tracer, fn_state);
    }
    fn block_1906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1906_0: const #8s : i
        let s_1906_0: i128 = 8;
        // D s_1906_1: read-var u#32003:u32
        let s_1906_1: u32 = fn_state.u_32003;
        // D s_1906_2: cast zx s_1906_1 -> bv
        let s_1906_2: Bits = Bits::new(s_1906_1 as u128, 32u16);
        // C s_1906_3: const #1s : i64
        let s_1906_3: i64 = 1;
        // C s_1906_4: cast zx s_1906_3 -> i
        let s_1906_4: i128 = (i128::try_from(s_1906_3).unwrap());
        // C s_1906_5: const #3s : i
        let s_1906_5: i128 = 3;
        // C s_1906_6: add s_1906_5 s_1906_4
        let s_1906_6: i128 = (s_1906_5 + s_1906_4);
        // D s_1906_7: bit-extract s_1906_2 s_1906_0 s_1906_6
        let s_1906_7: Bits = (Bits::new(
            ((s_1906_2) >> (s_1906_0)).value(),
            u16::try_from(s_1906_6).unwrap(),
        ));
        // D s_1906_8: cast reint s_1906_7 -> u8
        let s_1906_8: u8 = (s_1906_7.value() as u8);
        // D s_1906_9: cast zx s_1906_8 -> bv
        let s_1906_9: Bits = Bits::new(s_1906_8 as u128, 4u16);
        // C s_1906_10: const #6u : u8
        let s_1906_10: u8 = 6;
        // C s_1906_11: cast zx s_1906_10 -> bv
        let s_1906_11: Bits = Bits::new(s_1906_10 as u128, 4u16);
        // D s_1906_12: cmp-eq s_1906_9 s_1906_11
        let s_1906_12: bool = ((s_1906_9) == (s_1906_11));
        // D s_1906_13: write-var gs#402598 <= s_1906_12
        fn_state.gs_402598 = s_1906_12;
        // N s_1906_14: jump b1905
        return block_1905(state, tracer, fn_state);
    }
    fn block_1907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1907_0: const #3716s : i
        let s_1907_0: i128 = 3716;
        // C s_1907_1: const #14696u : u32
        let s_1907_1: u32 = 14696;
        // D s_1907_2: read-reg s_1907_1:i
        let s_1907_2: i128 = {
            let value = state.read_register::<i128>(s_1907_1 as isize);
            tracer.read_register(s_1907_1 as isize, value);
            value
        };
        // D s_1907_3: cmp-lt s_1907_2 s_1907_0
        let s_1907_3: bool = ((s_1907_2) < (s_1907_0));
        // D s_1907_4: write-var gs#402576 <= s_1907_3
        fn_state.gs_402576 = s_1907_3;
        // N s_1907_5: jump b1205
        return block_1205(state, tracer, fn_state);
    }
    fn block_1908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1908_0: const #20s : i
        let s_1908_0: i128 = 20;
        // D s_1908_1: read-var u#31995:u32
        let s_1908_1: u32 = fn_state.u_31995;
        // D s_1908_2: cast zx s_1908_1 -> bv
        let s_1908_2: Bits = Bits::new(s_1908_1 as u128, 32u16);
        // C s_1908_3: const #1s : i64
        let s_1908_3: i64 = 1;
        // C s_1908_4: cast zx s_1908_3 -> i
        let s_1908_4: i128 = (i128::try_from(s_1908_3).unwrap());
        // C s_1908_5: const #1s : i
        let s_1908_5: i128 = 1;
        // C s_1908_6: add s_1908_5 s_1908_4
        let s_1908_6: i128 = (s_1908_5 + s_1908_4);
        // D s_1908_7: bit-extract s_1908_2 s_1908_0 s_1908_6
        let s_1908_7: Bits = (Bits::new(
            ((s_1908_2) >> (s_1908_0)).value(),
            u16::try_from(s_1908_6).unwrap(),
        ));
        // D s_1908_8: cast reint s_1908_7 -> u8
        let s_1908_8: u8 = (s_1908_7.value() as u8);
        // D s_1908_9: cast zx s_1908_8 -> bv
        let s_1908_9: Bits = Bits::new(s_1908_8 as u128, 2u16);
        // C s_1908_10: const #0u : u8
        let s_1908_10: u8 = 0;
        // C s_1908_11: cast zx s_1908_10 -> bv
        let s_1908_11: Bits = Bits::new(s_1908_10 as u128, 2u16);
        // D s_1908_12: cmp-eq s_1908_9 s_1908_11
        let s_1908_12: bool = ((s_1908_9) == (s_1908_11));
        // N s_1908_13: branch s_1908_12 b1911 b1909
        if s_1908_12 {
            return block_1911(state, tracer, fn_state);
        } else {
            return block_1909(state, tracer, fn_state);
        };
    }
    fn block_1909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1909_0: const #0u : u8
        let s_1909_0: bool = false;
        // D s_1909_1: write-var gs#402573 <= s_1909_0
        fn_state.gs_402573 = s_1909_0;
        // N s_1909_2: jump b1910
        return block_1910(state, tracer, fn_state);
    }
    fn block_1910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1910_0: read-var gs#402573:u8
        let s_1910_0: bool = fn_state.gs_402573;
        // D s_1910_1: write-var gs#402574 <= s_1910_0
        fn_state.gs_402574 = s_1910_0;
        // N s_1910_2: jump b1203
        return block_1203(state, tracer, fn_state);
    }
    fn block_1911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1911_0: const #8s : i
        let s_1911_0: i128 = 8;
        // D s_1911_1: read-var u#31995:u32
        let s_1911_1: u32 = fn_state.u_31995;
        // D s_1911_2: cast zx s_1911_1 -> bv
        let s_1911_2: Bits = Bits::new(s_1911_1 as u128, 32u16);
        // C s_1911_3: const #1s : i64
        let s_1911_3: i64 = 1;
        // C s_1911_4: cast zx s_1911_3 -> i
        let s_1911_4: i128 = (i128::try_from(s_1911_3).unwrap());
        // C s_1911_5: const #3s : i
        let s_1911_5: i128 = 3;
        // C s_1911_6: add s_1911_5 s_1911_4
        let s_1911_6: i128 = (s_1911_5 + s_1911_4);
        // D s_1911_7: bit-extract s_1911_2 s_1911_0 s_1911_6
        let s_1911_7: Bits = (Bits::new(
            ((s_1911_2) >> (s_1911_0)).value(),
            u16::try_from(s_1911_6).unwrap(),
        ));
        // D s_1911_8: cast reint s_1911_7 -> u8
        let s_1911_8: u8 = (s_1911_7.value() as u8);
        // D s_1911_9: cast zx s_1911_8 -> bv
        let s_1911_9: Bits = Bits::new(s_1911_8 as u128, 4u16);
        // C s_1911_10: const #2u : u8
        let s_1911_10: u8 = 2;
        // C s_1911_11: cast zx s_1911_10 -> bv
        let s_1911_11: Bits = Bits::new(s_1911_10 as u128, 4u16);
        // D s_1911_12: cmp-eq s_1911_9 s_1911_11
        let s_1911_12: bool = ((s_1911_9) == (s_1911_11));
        // D s_1911_13: write-var gs#402573 <= s_1911_12
        fn_state.gs_402573 = s_1911_12;
        // N s_1911_14: jump b1910
        return block_1910(state, tracer, fn_state);
    }
    fn block_1912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1912_0: const #3713s : i
        let s_1912_0: i128 = 3713;
        // C s_1912_1: const #14696u : u32
        let s_1912_1: u32 = 14696;
        // D s_1912_2: read-reg s_1912_1:i
        let s_1912_2: i128 = {
            let value = state.read_register::<i128>(s_1912_1 as isize);
            tracer.read_register(s_1912_1 as isize, value);
            value
        };
        // D s_1912_3: cmp-lt s_1912_2 s_1912_0
        let s_1912_3: bool = ((s_1912_2) < (s_1912_0));
        // D s_1912_4: write-var gs#402549 <= s_1912_3
        fn_state.gs_402549 = s_1912_3;
        // N s_1912_5: jump b1199
        return block_1199(state, tracer, fn_state);
    }
    fn block_1913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1913_0: const #20s : i
        let s_1913_0: i128 = 20;
        // D s_1913_1: read-var u#31986:u32
        let s_1913_1: u32 = fn_state.u_31986;
        // D s_1913_2: cast zx s_1913_1 -> bv
        let s_1913_2: Bits = Bits::new(s_1913_1 as u128, 32u16);
        // C s_1913_3: const #1s : i64
        let s_1913_3: i64 = 1;
        // C s_1913_4: cast zx s_1913_3 -> i
        let s_1913_4: i128 = (i128::try_from(s_1913_3).unwrap());
        // C s_1913_5: const #1s : i
        let s_1913_5: i128 = 1;
        // C s_1913_6: add s_1913_5 s_1913_4
        let s_1913_6: i128 = (s_1913_5 + s_1913_4);
        // D s_1913_7: bit-extract s_1913_2 s_1913_0 s_1913_6
        let s_1913_7: Bits = (Bits::new(
            ((s_1913_2) >> (s_1913_0)).value(),
            u16::try_from(s_1913_6).unwrap(),
        ));
        // D s_1913_8: cast reint s_1913_7 -> u8
        let s_1913_8: u8 = (s_1913_7.value() as u8);
        // D s_1913_9: cast zx s_1913_8 -> bv
        let s_1913_9: Bits = Bits::new(s_1913_8 as u128, 2u16);
        // C s_1913_10: const #0u : u8
        let s_1913_10: u8 = 0;
        // C s_1913_11: cast zx s_1913_10 -> bv
        let s_1913_11: Bits = Bits::new(s_1913_10 as u128, 2u16);
        // D s_1913_12: cmp-eq s_1913_9 s_1913_11
        let s_1913_12: bool = ((s_1913_9) == (s_1913_11));
        // N s_1913_13: branch s_1913_12 b1916 b1914
        if s_1913_12 {
            return block_1916(state, tracer, fn_state);
        } else {
            return block_1914(state, tracer, fn_state);
        };
    }
    fn block_1914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1914_0: const #0u : u8
        let s_1914_0: bool = false;
        // D s_1914_1: write-var gs#402546 <= s_1914_0
        fn_state.gs_402546 = s_1914_0;
        // N s_1914_2: jump b1915
        return block_1915(state, tracer, fn_state);
    }
    fn block_1915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1915_0: read-var gs#402546:u8
        let s_1915_0: bool = fn_state.gs_402546;
        // D s_1915_1: write-var gs#402547 <= s_1915_0
        fn_state.gs_402547 = s_1915_0;
        // N s_1915_2: jump b1197
        return block_1197(state, tracer, fn_state);
    }
    fn block_1916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1916_0: const #8s : i
        let s_1916_0: i128 = 8;
        // D s_1916_1: read-var u#31986:u32
        let s_1916_1: u32 = fn_state.u_31986;
        // D s_1916_2: cast zx s_1916_1 -> bv
        let s_1916_2: Bits = Bits::new(s_1916_1 as u128, 32u16);
        // C s_1916_3: const #1s : i64
        let s_1916_3: i64 = 1;
        // C s_1916_4: cast zx s_1916_3 -> i
        let s_1916_4: i128 = (i128::try_from(s_1916_3).unwrap());
        // C s_1916_5: const #3s : i
        let s_1916_5: i128 = 3;
        // C s_1916_6: add s_1916_5 s_1916_4
        let s_1916_6: i128 = (s_1916_5 + s_1916_4);
        // D s_1916_7: bit-extract s_1916_2 s_1916_0 s_1916_6
        let s_1916_7: Bits = (Bits::new(
            ((s_1916_2) >> (s_1916_0)).value(),
            u16::try_from(s_1916_6).unwrap(),
        ));
        // D s_1916_8: cast reint s_1916_7 -> u8
        let s_1916_8: u8 = (s_1916_7.value() as u8);
        // D s_1916_9: cast zx s_1916_8 -> bv
        let s_1916_9: Bits = Bits::new(s_1916_8 as u128, 4u16);
        // C s_1916_10: const #3u : u8
        let s_1916_10: u8 = 3;
        // C s_1916_11: cast zx s_1916_10 -> bv
        let s_1916_11: Bits = Bits::new(s_1916_10 as u128, 4u16);
        // D s_1916_12: cmp-eq s_1916_9 s_1916_11
        let s_1916_12: bool = ((s_1916_9) == (s_1916_11));
        // D s_1916_13: write-var gs#402546 <= s_1916_12
        fn_state.gs_402546 = s_1916_12;
        // N s_1916_14: jump b1915
        return block_1915(state, tracer, fn_state);
    }
    fn block_1917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1917_0: const #3712s : i
        let s_1917_0: i128 = 3712;
        // C s_1917_1: const #14696u : u32
        let s_1917_1: u32 = 14696;
        // D s_1917_2: read-reg s_1917_1:i
        let s_1917_2: i128 = {
            let value = state.read_register::<i128>(s_1917_1 as isize);
            tracer.read_register(s_1917_1 as isize, value);
            value
        };
        // D s_1917_3: cmp-lt s_1917_2 s_1917_0
        let s_1917_3: bool = ((s_1917_2) < (s_1917_0));
        // D s_1917_4: write-var gs#402522 <= s_1917_3
        fn_state.gs_402522 = s_1917_3;
        // N s_1917_5: jump b1193
        return block_1193(state, tracer, fn_state);
    }
    fn block_1918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1918_0: const #20s : i
        let s_1918_0: i128 = 20;
        // D s_1918_1: read-var u#31977:u32
        let s_1918_1: u32 = fn_state.u_31977;
        // D s_1918_2: cast zx s_1918_1 -> bv
        let s_1918_2: Bits = Bits::new(s_1918_1 as u128, 32u16);
        // C s_1918_3: const #1s : i64
        let s_1918_3: i64 = 1;
        // C s_1918_4: cast zx s_1918_3 -> i
        let s_1918_4: i128 = (i128::try_from(s_1918_3).unwrap());
        // C s_1918_5: const #1s : i
        let s_1918_5: i128 = 1;
        // C s_1918_6: add s_1918_5 s_1918_4
        let s_1918_6: i128 = (s_1918_5 + s_1918_4);
        // D s_1918_7: bit-extract s_1918_2 s_1918_0 s_1918_6
        let s_1918_7: Bits = (Bits::new(
            ((s_1918_2) >> (s_1918_0)).value(),
            u16::try_from(s_1918_6).unwrap(),
        ));
        // D s_1918_8: cast reint s_1918_7 -> u8
        let s_1918_8: u8 = (s_1918_7.value() as u8);
        // D s_1918_9: cast zx s_1918_8 -> bv
        let s_1918_9: Bits = Bits::new(s_1918_8 as u128, 2u16);
        // C s_1918_10: const #0u : u8
        let s_1918_10: u8 = 0;
        // C s_1918_11: cast zx s_1918_10 -> bv
        let s_1918_11: Bits = Bits::new(s_1918_10 as u128, 2u16);
        // D s_1918_12: cmp-eq s_1918_9 s_1918_11
        let s_1918_12: bool = ((s_1918_9) == (s_1918_11));
        // N s_1918_13: branch s_1918_12 b1921 b1919
        if s_1918_12 {
            return block_1921(state, tracer, fn_state);
        } else {
            return block_1919(state, tracer, fn_state);
        };
    }
    fn block_1919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1919_0: const #0u : u8
        let s_1919_0: bool = false;
        // D s_1919_1: write-var gs#402519 <= s_1919_0
        fn_state.gs_402519 = s_1919_0;
        // N s_1919_2: jump b1920
        return block_1920(state, tracer, fn_state);
    }
    fn block_1920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1920_0: read-var gs#402519:u8
        let s_1920_0: bool = fn_state.gs_402519;
        // D s_1920_1: write-var gs#402520 <= s_1920_0
        fn_state.gs_402520 = s_1920_0;
        // N s_1920_2: jump b1191
        return block_1191(state, tracer, fn_state);
    }
    fn block_1921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1921_0: const #9s : i
        let s_1921_0: i128 = 9;
        // D s_1921_1: read-var u#31977:u32
        let s_1921_1: u32 = fn_state.u_31977;
        // D s_1921_2: cast zx s_1921_1 -> bv
        let s_1921_2: Bits = Bits::new(s_1921_1 as u128, 32u16);
        // C s_1921_3: const #1s : i64
        let s_1921_3: i64 = 1;
        // C s_1921_4: cast zx s_1921_3 -> i
        let s_1921_4: i128 = (i128::try_from(s_1921_3).unwrap());
        // C s_1921_5: const #2s : i
        let s_1921_5: i128 = 2;
        // C s_1921_6: add s_1921_5 s_1921_4
        let s_1921_6: i128 = (s_1921_5 + s_1921_4);
        // D s_1921_7: bit-extract s_1921_2 s_1921_0 s_1921_6
        let s_1921_7: Bits = (Bits::new(
            ((s_1921_2) >> (s_1921_0)).value(),
            u16::try_from(s_1921_6).unwrap(),
        ));
        // D s_1921_8: cast reint s_1921_7 -> u8
        let s_1921_8: u8 = (s_1921_7.value() as u8);
        // D s_1921_9: cast zx s_1921_8 -> bv
        let s_1921_9: Bits = Bits::new(s_1921_8 as u128, 3u16);
        // C s_1921_10: const #4u : u8
        let s_1921_10: u8 = 4;
        // C s_1921_11: cast zx s_1921_10 -> bv
        let s_1921_11: Bits = Bits::new(s_1921_10 as u128, 3u16);
        // D s_1921_12: cmp-eq s_1921_9 s_1921_11
        let s_1921_12: bool = ((s_1921_9) == (s_1921_11));
        // D s_1921_13: write-var gs#402519 <= s_1921_12
        fn_state.gs_402519 = s_1921_12;
        // N s_1921_14: jump b1920
        return block_1920(state, tracer, fn_state);
    }
    fn block_1922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1922_0: const #3708s : i
        let s_1922_0: i128 = 3708;
        // C s_1922_1: const #14696u : u32
        let s_1922_1: u32 = 14696;
        // D s_1922_2: read-reg s_1922_1:i
        let s_1922_2: i128 = {
            let value = state.read_register::<i128>(s_1922_1 as isize);
            tracer.read_register(s_1922_1 as isize, value);
            value
        };
        // D s_1922_3: cmp-lt s_1922_2 s_1922_0
        let s_1922_3: bool = ((s_1922_2) < (s_1922_0));
        // D s_1922_4: write-var gs#402497 <= s_1922_3
        fn_state.gs_402497 = s_1922_3;
        // N s_1922_5: jump b1187
        return block_1187(state, tracer, fn_state);
    }
    fn block_1923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1923_0: const #20s : i
        let s_1923_0: i128 = 20;
        // D s_1923_1: read-var u#31969:u32
        let s_1923_1: u32 = fn_state.u_31969;
        // D s_1923_2: cast zx s_1923_1 -> bv
        let s_1923_2: Bits = Bits::new(s_1923_1 as u128, 32u16);
        // C s_1923_3: const #1s : i64
        let s_1923_3: i64 = 1;
        // C s_1923_4: cast zx s_1923_3 -> i
        let s_1923_4: i128 = (i128::try_from(s_1923_3).unwrap());
        // C s_1923_5: const #1s : i
        let s_1923_5: i128 = 1;
        // C s_1923_6: add s_1923_5 s_1923_4
        let s_1923_6: i128 = (s_1923_5 + s_1923_4);
        // D s_1923_7: bit-extract s_1923_2 s_1923_0 s_1923_6
        let s_1923_7: Bits = (Bits::new(
            ((s_1923_2) >> (s_1923_0)).value(),
            u16::try_from(s_1923_6).unwrap(),
        ));
        // D s_1923_8: cast reint s_1923_7 -> u8
        let s_1923_8: u8 = (s_1923_7.value() as u8);
        // D s_1923_9: cast zx s_1923_8 -> bv
        let s_1923_9: Bits = Bits::new(s_1923_8 as u128, 2u16);
        // C s_1923_10: const #0u : u8
        let s_1923_10: u8 = 0;
        // C s_1923_11: cast zx s_1923_10 -> bv
        let s_1923_11: Bits = Bits::new(s_1923_10 as u128, 2u16);
        // D s_1923_12: cmp-eq s_1923_9 s_1923_11
        let s_1923_12: bool = ((s_1923_9) == (s_1923_11));
        // N s_1923_13: branch s_1923_12 b1926 b1924
        if s_1923_12 {
            return block_1926(state, tracer, fn_state);
        } else {
            return block_1924(state, tracer, fn_state);
        };
    }
    fn block_1924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1924_0: const #0u : u8
        let s_1924_0: bool = false;
        // D s_1924_1: write-var gs#402494 <= s_1924_0
        fn_state.gs_402494 = s_1924_0;
        // N s_1924_2: jump b1925
        return block_1925(state, tracer, fn_state);
    }
    fn block_1925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1925_0: read-var gs#402494:u8
        let s_1925_0: bool = fn_state.gs_402494;
        // D s_1925_1: write-var gs#402495 <= s_1925_0
        fn_state.gs_402495 = s_1925_0;
        // N s_1925_2: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_1926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1926_0: const #8s : i
        let s_1926_0: i128 = 8;
        // D s_1926_1: read-var u#31969:u32
        let s_1926_1: u32 = fn_state.u_31969;
        // D s_1926_2: cast zx s_1926_1 -> bv
        let s_1926_2: Bits = Bits::new(s_1926_1 as u128, 32u16);
        // C s_1926_3: const #1s : i64
        let s_1926_3: i64 = 1;
        // C s_1926_4: cast zx s_1926_3 -> i
        let s_1926_4: i128 = (i128::try_from(s_1926_3).unwrap());
        // C s_1926_5: const #3s : i
        let s_1926_5: i128 = 3;
        // C s_1926_6: add s_1926_5 s_1926_4
        let s_1926_6: i128 = (s_1926_5 + s_1926_4);
        // D s_1926_7: bit-extract s_1926_2 s_1926_0 s_1926_6
        let s_1926_7: Bits = (Bits::new(
            ((s_1926_2) >> (s_1926_0)).value(),
            u16::try_from(s_1926_6).unwrap(),
        ));
        // D s_1926_8: cast reint s_1926_7 -> u8
        let s_1926_8: u8 = (s_1926_7.value() as u8);
        // D s_1926_9: cast zx s_1926_8 -> bv
        let s_1926_9: Bits = Bits::new(s_1926_8 as u128, 4u16);
        // C s_1926_10: const #9u : u8
        let s_1926_10: u8 = 9;
        // C s_1926_11: cast zx s_1926_10 -> bv
        let s_1926_11: Bits = Bits::new(s_1926_10 as u128, 4u16);
        // D s_1926_12: cmp-eq s_1926_9 s_1926_11
        let s_1926_12: bool = ((s_1926_9) == (s_1926_11));
        // D s_1926_13: write-var gs#402494 <= s_1926_12
        fn_state.gs_402494 = s_1926_12;
        // N s_1926_14: jump b1925
        return block_1925(state, tracer, fn_state);
    }
    fn block_1927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1927_0: const #3707s : i
        let s_1927_0: i128 = 3707;
        // C s_1927_1: const #14696u : u32
        let s_1927_1: u32 = 14696;
        // D s_1927_2: read-reg s_1927_1:i
        let s_1927_2: i128 = {
            let value = state.read_register::<i128>(s_1927_1 as isize);
            tracer.read_register(s_1927_1 as isize, value);
            value
        };
        // D s_1927_3: cmp-lt s_1927_2 s_1927_0
        let s_1927_3: bool = ((s_1927_2) < (s_1927_0));
        // D s_1927_4: write-var gs#402472 <= s_1927_3
        fn_state.gs_402472 = s_1927_3;
        // N s_1927_5: jump b1181
        return block_1181(state, tracer, fn_state);
    }
    fn block_1928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1928_0: const #20s : i
        let s_1928_0: i128 = 20;
        // D s_1928_1: read-var u#31961:u32
        let s_1928_1: u32 = fn_state.u_31961;
        // D s_1928_2: cast zx s_1928_1 -> bv
        let s_1928_2: Bits = Bits::new(s_1928_1 as u128, 32u16);
        // C s_1928_3: const #1s : i64
        let s_1928_3: i64 = 1;
        // C s_1928_4: cast zx s_1928_3 -> i
        let s_1928_4: i128 = (i128::try_from(s_1928_3).unwrap());
        // C s_1928_5: const #1s : i
        let s_1928_5: i128 = 1;
        // C s_1928_6: add s_1928_5 s_1928_4
        let s_1928_6: i128 = (s_1928_5 + s_1928_4);
        // D s_1928_7: bit-extract s_1928_2 s_1928_0 s_1928_6
        let s_1928_7: Bits = (Bits::new(
            ((s_1928_2) >> (s_1928_0)).value(),
            u16::try_from(s_1928_6).unwrap(),
        ));
        // D s_1928_8: cast reint s_1928_7 -> u8
        let s_1928_8: u8 = (s_1928_7.value() as u8);
        // D s_1928_9: cast zx s_1928_8 -> bv
        let s_1928_9: Bits = Bits::new(s_1928_8 as u128, 2u16);
        // C s_1928_10: const #0u : u8
        let s_1928_10: u8 = 0;
        // C s_1928_11: cast zx s_1928_10 -> bv
        let s_1928_11: Bits = Bits::new(s_1928_10 as u128, 2u16);
        // D s_1928_12: cmp-eq s_1928_9 s_1928_11
        let s_1928_12: bool = ((s_1928_9) == (s_1928_11));
        // N s_1928_13: branch s_1928_12 b1931 b1929
        if s_1928_12 {
            return block_1931(state, tracer, fn_state);
        } else {
            return block_1929(state, tracer, fn_state);
        };
    }
    fn block_1929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1929_0: const #0u : u8
        let s_1929_0: bool = false;
        // D s_1929_1: write-var gs#402469 <= s_1929_0
        fn_state.gs_402469 = s_1929_0;
        // N s_1929_2: jump b1930
        return block_1930(state, tracer, fn_state);
    }
    fn block_1930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1930_0: read-var gs#402469:u8
        let s_1930_0: bool = fn_state.gs_402469;
        // D s_1930_1: write-var gs#402470 <= s_1930_0
        fn_state.gs_402470 = s_1930_0;
        // N s_1930_2: jump b1179
        return block_1179(state, tracer, fn_state);
    }
    fn block_1931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1931_0: const #8s : i
        let s_1931_0: i128 = 8;
        // D s_1931_1: read-var u#31961:u32
        let s_1931_1: u32 = fn_state.u_31961;
        // D s_1931_2: cast zx s_1931_1 -> bv
        let s_1931_2: Bits = Bits::new(s_1931_1 as u128, 32u16);
        // C s_1931_3: const #1s : i64
        let s_1931_3: i64 = 1;
        // C s_1931_4: cast zx s_1931_3 -> i
        let s_1931_4: i128 = (i128::try_from(s_1931_3).unwrap());
        // C s_1931_5: const #3s : i
        let s_1931_5: i128 = 3;
        // C s_1931_6: add s_1931_5 s_1931_4
        let s_1931_6: i128 = (s_1931_5 + s_1931_4);
        // D s_1931_7: bit-extract s_1931_2 s_1931_0 s_1931_6
        let s_1931_7: Bits = (Bits::new(
            ((s_1931_2) >> (s_1931_0)).value(),
            u16::try_from(s_1931_6).unwrap(),
        ));
        // D s_1931_8: cast reint s_1931_7 -> u8
        let s_1931_8: u8 = (s_1931_7.value() as u8);
        // D s_1931_9: cast zx s_1931_8 -> bv
        let s_1931_9: Bits = Bits::new(s_1931_8 as u128, 4u16);
        // C s_1931_10: const #5u : u8
        let s_1931_10: u8 = 5;
        // C s_1931_11: cast zx s_1931_10 -> bv
        let s_1931_11: Bits = Bits::new(s_1931_10 as u128, 4u16);
        // D s_1931_12: cmp-eq s_1931_9 s_1931_11
        let s_1931_12: bool = ((s_1931_9) == (s_1931_11));
        // D s_1931_13: write-var gs#402469 <= s_1931_12
        fn_state.gs_402469 = s_1931_12;
        // N s_1931_14: jump b1930
        return block_1930(state, tracer, fn_state);
    }
    fn block_1932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1932_0: const #3706s : i
        let s_1932_0: i128 = 3706;
        // C s_1932_1: const #14696u : u32
        let s_1932_1: u32 = 14696;
        // D s_1932_2: read-reg s_1932_1:i
        let s_1932_2: i128 = {
            let value = state.read_register::<i128>(s_1932_1 as isize);
            tracer.read_register(s_1932_1 as isize, value);
            value
        };
        // D s_1932_3: cmp-lt s_1932_2 s_1932_0
        let s_1932_3: bool = ((s_1932_2) < (s_1932_0));
        // D s_1932_4: write-var gs#402447 <= s_1932_3
        fn_state.gs_402447 = s_1932_3;
        // N s_1932_5: jump b1175
        return block_1175(state, tracer, fn_state);
    }
    fn block_1933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1933_0: const #20s : i
        let s_1933_0: i128 = 20;
        // D s_1933_1: read-var u#31953:u32
        let s_1933_1: u32 = fn_state.u_31953;
        // D s_1933_2: cast zx s_1933_1 -> bv
        let s_1933_2: Bits = Bits::new(s_1933_1 as u128, 32u16);
        // C s_1933_3: const #1s : i64
        let s_1933_3: i64 = 1;
        // C s_1933_4: cast zx s_1933_3 -> i
        let s_1933_4: i128 = (i128::try_from(s_1933_3).unwrap());
        // C s_1933_5: const #1s : i
        let s_1933_5: i128 = 1;
        // C s_1933_6: add s_1933_5 s_1933_4
        let s_1933_6: i128 = (s_1933_5 + s_1933_4);
        // D s_1933_7: bit-extract s_1933_2 s_1933_0 s_1933_6
        let s_1933_7: Bits = (Bits::new(
            ((s_1933_2) >> (s_1933_0)).value(),
            u16::try_from(s_1933_6).unwrap(),
        ));
        // D s_1933_8: cast reint s_1933_7 -> u8
        let s_1933_8: u8 = (s_1933_7.value() as u8);
        // D s_1933_9: cast zx s_1933_8 -> bv
        let s_1933_9: Bits = Bits::new(s_1933_8 as u128, 2u16);
        // C s_1933_10: const #0u : u8
        let s_1933_10: u8 = 0;
        // C s_1933_11: cast zx s_1933_10 -> bv
        let s_1933_11: Bits = Bits::new(s_1933_10 as u128, 2u16);
        // D s_1933_12: cmp-eq s_1933_9 s_1933_11
        let s_1933_12: bool = ((s_1933_9) == (s_1933_11));
        // N s_1933_13: branch s_1933_12 b1936 b1934
        if s_1933_12 {
            return block_1936(state, tracer, fn_state);
        } else {
            return block_1934(state, tracer, fn_state);
        };
    }
    fn block_1934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1934_0: const #0u : u8
        let s_1934_0: bool = false;
        // D s_1934_1: write-var gs#402444 <= s_1934_0
        fn_state.gs_402444 = s_1934_0;
        // N s_1934_2: jump b1935
        return block_1935(state, tracer, fn_state);
    }
    fn block_1935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1935_0: read-var gs#402444:u8
        let s_1935_0: bool = fn_state.gs_402444;
        // D s_1935_1: write-var gs#402445 <= s_1935_0
        fn_state.gs_402445 = s_1935_0;
        // N s_1935_2: jump b1173
        return block_1173(state, tracer, fn_state);
    }
    fn block_1936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1936_0: const #8s : i
        let s_1936_0: i128 = 8;
        // D s_1936_1: read-var u#31953:u32
        let s_1936_1: u32 = fn_state.u_31953;
        // D s_1936_2: cast zx s_1936_1 -> bv
        let s_1936_2: Bits = Bits::new(s_1936_1 as u128, 32u16);
        // C s_1936_3: const #1s : i64
        let s_1936_3: i64 = 1;
        // C s_1936_4: cast zx s_1936_3 -> i
        let s_1936_4: i128 = (i128::try_from(s_1936_3).unwrap());
        // C s_1936_5: const #3s : i
        let s_1936_5: i128 = 3;
        // C s_1936_6: add s_1936_5 s_1936_4
        let s_1936_6: i128 = (s_1936_5 + s_1936_4);
        // D s_1936_7: bit-extract s_1936_2 s_1936_0 s_1936_6
        let s_1936_7: Bits = (Bits::new(
            ((s_1936_2) >> (s_1936_0)).value(),
            u16::try_from(s_1936_6).unwrap(),
        ));
        // D s_1936_8: cast reint s_1936_7 -> u8
        let s_1936_8: u8 = (s_1936_7.value() as u8);
        // D s_1936_9: cast zx s_1936_8 -> bv
        let s_1936_9: Bits = Bits::new(s_1936_8 as u128, 4u16);
        // C s_1936_10: const #1u : u8
        let s_1936_10: u8 = 1;
        // C s_1936_11: cast zx s_1936_10 -> bv
        let s_1936_11: Bits = Bits::new(s_1936_10 as u128, 4u16);
        // D s_1936_12: cmp-eq s_1936_9 s_1936_11
        let s_1936_12: bool = ((s_1936_9) == (s_1936_11));
        // D s_1936_13: write-var gs#402444 <= s_1936_12
        fn_state.gs_402444 = s_1936_12;
        // N s_1936_14: jump b1935
        return block_1935(state, tracer, fn_state);
    }
    fn block_1937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1937_0: const #3701s : i
        let s_1937_0: i128 = 3701;
        // C s_1937_1: const #14696u : u32
        let s_1937_1: u32 = 14696;
        // D s_1937_2: read-reg s_1937_1:i
        let s_1937_2: i128 = {
            let value = state.read_register::<i128>(s_1937_1 as isize);
            tracer.read_register(s_1937_1 as isize, value);
            value
        };
        // D s_1937_3: cmp-lt s_1937_2 s_1937_0
        let s_1937_3: bool = ((s_1937_2) < (s_1937_0));
        // D s_1937_4: write-var gs#402420 <= s_1937_3
        fn_state.gs_402420 = s_1937_3;
        // N s_1937_5: jump b1169
        return block_1169(state, tracer, fn_state);
    }
    fn block_1938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1938_0: const #20s : i
        let s_1938_0: i128 = 20;
        // D s_1938_1: read-var u#31944:u32
        let s_1938_1: u32 = fn_state.u_31944;
        // D s_1938_2: cast zx s_1938_1 -> bv
        let s_1938_2: Bits = Bits::new(s_1938_1 as u128, 32u16);
        // C s_1938_3: const #1s : i64
        let s_1938_3: i64 = 1;
        // C s_1938_4: cast zx s_1938_3 -> i
        let s_1938_4: i128 = (i128::try_from(s_1938_3).unwrap());
        // C s_1938_5: const #1s : i
        let s_1938_5: i128 = 1;
        // C s_1938_6: add s_1938_5 s_1938_4
        let s_1938_6: i128 = (s_1938_5 + s_1938_4);
        // D s_1938_7: bit-extract s_1938_2 s_1938_0 s_1938_6
        let s_1938_7: Bits = (Bits::new(
            ((s_1938_2) >> (s_1938_0)).value(),
            u16::try_from(s_1938_6).unwrap(),
        ));
        // D s_1938_8: cast reint s_1938_7 -> u8
        let s_1938_8: u8 = (s_1938_7.value() as u8);
        // D s_1938_9: cast zx s_1938_8 -> bv
        let s_1938_9: Bits = Bits::new(s_1938_8 as u128, 2u16);
        // C s_1938_10: const #0u : u8
        let s_1938_10: u8 = 0;
        // C s_1938_11: cast zx s_1938_10 -> bv
        let s_1938_11: Bits = Bits::new(s_1938_10 as u128, 2u16);
        // D s_1938_12: cmp-eq s_1938_9 s_1938_11
        let s_1938_12: bool = ((s_1938_9) == (s_1938_11));
        // N s_1938_13: branch s_1938_12 b1941 b1939
        if s_1938_12 {
            return block_1941(state, tracer, fn_state);
        } else {
            return block_1939(state, tracer, fn_state);
        };
    }
    fn block_1939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1939_0: const #0u : u8
        let s_1939_0: bool = false;
        // D s_1939_1: write-var gs#402417 <= s_1939_0
        fn_state.gs_402417 = s_1939_0;
        // N s_1939_2: jump b1940
        return block_1940(state, tracer, fn_state);
    }
    fn block_1940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1940_0: read-var gs#402417:u8
        let s_1940_0: bool = fn_state.gs_402417;
        // D s_1940_1: write-var gs#402418 <= s_1940_0
        fn_state.gs_402418 = s_1940_0;
        // N s_1940_2: jump b1167
        return block_1167(state, tracer, fn_state);
    }
    fn block_1941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1941_0: const #8s : i
        let s_1941_0: i128 = 8;
        // D s_1941_1: read-var u#31944:u32
        let s_1941_1: u32 = fn_state.u_31944;
        // D s_1941_2: cast zx s_1941_1 -> bv
        let s_1941_2: Bits = Bits::new(s_1941_1 as u128, 32u16);
        // C s_1941_3: const #1s : i64
        let s_1941_3: i64 = 1;
        // C s_1941_4: cast zx s_1941_3 -> i
        let s_1941_4: i128 = (i128::try_from(s_1941_3).unwrap());
        // C s_1941_5: const #3s : i
        let s_1941_5: i128 = 3;
        // C s_1941_6: add s_1941_5 s_1941_4
        let s_1941_6: i128 = (s_1941_5 + s_1941_4);
        // D s_1941_7: bit-extract s_1941_2 s_1941_0 s_1941_6
        let s_1941_7: Bits = (Bits::new(
            ((s_1941_2) >> (s_1941_0)).value(),
            u16::try_from(s_1941_6).unwrap(),
        ));
        // D s_1941_8: cast reint s_1941_7 -> u8
        let s_1941_8: u8 = (s_1941_7.value() as u8);
        // D s_1941_9: cast zx s_1941_8 -> bv
        let s_1941_9: Bits = Bits::new(s_1941_8 as u128, 4u16);
        // C s_1941_10: const #2u : u8
        let s_1941_10: u8 = 2;
        // C s_1941_11: cast zx s_1941_10 -> bv
        let s_1941_11: Bits = Bits::new(s_1941_10 as u128, 4u16);
        // D s_1941_12: cmp-eq s_1941_9 s_1941_11
        let s_1941_12: bool = ((s_1941_9) == (s_1941_11));
        // D s_1941_13: write-var gs#402417 <= s_1941_12
        fn_state.gs_402417 = s_1941_12;
        // N s_1941_14: jump b1940
        return block_1940(state, tracer, fn_state);
    }
    fn block_1942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1942_0: const #3700s : i
        let s_1942_0: i128 = 3700;
        // C s_1942_1: const #14696u : u32
        let s_1942_1: u32 = 14696;
        // D s_1942_2: read-reg s_1942_1:i
        let s_1942_2: i128 = {
            let value = state.read_register::<i128>(s_1942_1 as isize);
            tracer.read_register(s_1942_1 as isize, value);
            value
        };
        // D s_1942_3: cmp-lt s_1942_2 s_1942_0
        let s_1942_3: bool = ((s_1942_2) < (s_1942_0));
        // D s_1942_4: write-var gs#402393 <= s_1942_3
        fn_state.gs_402393 = s_1942_3;
        // N s_1942_5: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_1943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1943_0: const #20s : i
        let s_1943_0: i128 = 20;
        // D s_1943_1: read-var u#31935:u32
        let s_1943_1: u32 = fn_state.u_31935;
        // D s_1943_2: cast zx s_1943_1 -> bv
        let s_1943_2: Bits = Bits::new(s_1943_1 as u128, 32u16);
        // C s_1943_3: const #1s : i64
        let s_1943_3: i64 = 1;
        // C s_1943_4: cast zx s_1943_3 -> i
        let s_1943_4: i128 = (i128::try_from(s_1943_3).unwrap());
        // C s_1943_5: const #1s : i
        let s_1943_5: i128 = 1;
        // C s_1943_6: add s_1943_5 s_1943_4
        let s_1943_6: i128 = (s_1943_5 + s_1943_4);
        // D s_1943_7: bit-extract s_1943_2 s_1943_0 s_1943_6
        let s_1943_7: Bits = (Bits::new(
            ((s_1943_2) >> (s_1943_0)).value(),
            u16::try_from(s_1943_6).unwrap(),
        ));
        // D s_1943_8: cast reint s_1943_7 -> u8
        let s_1943_8: u8 = (s_1943_7.value() as u8);
        // D s_1943_9: cast zx s_1943_8 -> bv
        let s_1943_9: Bits = Bits::new(s_1943_8 as u128, 2u16);
        // C s_1943_10: const #0u : u8
        let s_1943_10: u8 = 0;
        // C s_1943_11: cast zx s_1943_10 -> bv
        let s_1943_11: Bits = Bits::new(s_1943_10 as u128, 2u16);
        // D s_1943_12: cmp-eq s_1943_9 s_1943_11
        let s_1943_12: bool = ((s_1943_9) == (s_1943_11));
        // N s_1943_13: branch s_1943_12 b1946 b1944
        if s_1943_12 {
            return block_1946(state, tracer, fn_state);
        } else {
            return block_1944(state, tracer, fn_state);
        };
    }
    fn block_1944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1944_0: const #0u : u8
        let s_1944_0: bool = false;
        // D s_1944_1: write-var gs#402390 <= s_1944_0
        fn_state.gs_402390 = s_1944_0;
        // N s_1944_2: jump b1945
        return block_1945(state, tracer, fn_state);
    }
    fn block_1945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1945_0: read-var gs#402390:u8
        let s_1945_0: bool = fn_state.gs_402390;
        // D s_1945_1: write-var gs#402391 <= s_1945_0
        fn_state.gs_402391 = s_1945_0;
        // N s_1945_2: jump b1161
        return block_1161(state, tracer, fn_state);
    }
    fn block_1946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1946_0: const #8s : i
        let s_1946_0: i128 = 8;
        // D s_1946_1: read-var u#31935:u32
        let s_1946_1: u32 = fn_state.u_31935;
        // D s_1946_2: cast zx s_1946_1 -> bv
        let s_1946_2: Bits = Bits::new(s_1946_1 as u128, 32u16);
        // C s_1946_3: const #1s : i64
        let s_1946_3: i64 = 1;
        // C s_1946_4: cast zx s_1946_3 -> i
        let s_1946_4: i128 = (i128::try_from(s_1946_3).unwrap());
        // C s_1946_5: const #3s : i
        let s_1946_5: i128 = 3;
        // C s_1946_6: add s_1946_5 s_1946_4
        let s_1946_6: i128 = (s_1946_5 + s_1946_4);
        // D s_1946_7: bit-extract s_1946_2 s_1946_0 s_1946_6
        let s_1946_7: Bits = (Bits::new(
            ((s_1946_2) >> (s_1946_0)).value(),
            u16::try_from(s_1946_6).unwrap(),
        ));
        // D s_1946_8: cast reint s_1946_7 -> u8
        let s_1946_8: u8 = (s_1946_7.value() as u8);
        // D s_1946_9: cast zx s_1946_8 -> bv
        let s_1946_9: Bits = Bits::new(s_1946_8 as u128, 4u16);
        // C s_1946_10: const #6u : u8
        let s_1946_10: u8 = 6;
        // C s_1946_11: cast zx s_1946_10 -> bv
        let s_1946_11: Bits = Bits::new(s_1946_10 as u128, 4u16);
        // D s_1946_12: cmp-eq s_1946_9 s_1946_11
        let s_1946_12: bool = ((s_1946_9) == (s_1946_11));
        // D s_1946_13: write-var gs#402390 <= s_1946_12
        fn_state.gs_402390 = s_1946_12;
        // N s_1946_14: jump b1945
        return block_1945(state, tracer, fn_state);
    }
    fn block_1947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1947_0: const #3699s : i
        let s_1947_0: i128 = 3699;
        // C s_1947_1: const #14696u : u32
        let s_1947_1: u32 = 14696;
        // D s_1947_2: read-reg s_1947_1:i
        let s_1947_2: i128 = {
            let value = state.read_register::<i128>(s_1947_1 as isize);
            tracer.read_register(s_1947_1 as isize, value);
            value
        };
        // D s_1947_3: cmp-lt s_1947_2 s_1947_0
        let s_1947_3: bool = ((s_1947_2) < (s_1947_0));
        // D s_1947_4: write-var gs#402366 <= s_1947_3
        fn_state.gs_402366 = s_1947_3;
        // N s_1947_5: jump b1157
        return block_1157(state, tracer, fn_state);
    }
    fn block_1948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1948_0: const #20s : i
        let s_1948_0: i128 = 20;
        // D s_1948_1: read-var u#31926:u32
        let s_1948_1: u32 = fn_state.u_31926;
        // D s_1948_2: cast zx s_1948_1 -> bv
        let s_1948_2: Bits = Bits::new(s_1948_1 as u128, 32u16);
        // C s_1948_3: const #1s : i64
        let s_1948_3: i64 = 1;
        // C s_1948_4: cast zx s_1948_3 -> i
        let s_1948_4: i128 = (i128::try_from(s_1948_3).unwrap());
        // C s_1948_5: const #1s : i
        let s_1948_5: i128 = 1;
        // C s_1948_6: add s_1948_5 s_1948_4
        let s_1948_6: i128 = (s_1948_5 + s_1948_4);
        // D s_1948_7: bit-extract s_1948_2 s_1948_0 s_1948_6
        let s_1948_7: Bits = (Bits::new(
            ((s_1948_2) >> (s_1948_0)).value(),
            u16::try_from(s_1948_6).unwrap(),
        ));
        // D s_1948_8: cast reint s_1948_7 -> u8
        let s_1948_8: u8 = (s_1948_7.value() as u8);
        // D s_1948_9: cast zx s_1948_8 -> bv
        let s_1948_9: Bits = Bits::new(s_1948_8 as u128, 2u16);
        // C s_1948_10: const #0u : u8
        let s_1948_10: u8 = 0;
        // C s_1948_11: cast zx s_1948_10 -> bv
        let s_1948_11: Bits = Bits::new(s_1948_10 as u128, 2u16);
        // D s_1948_12: cmp-eq s_1948_9 s_1948_11
        let s_1948_12: bool = ((s_1948_9) == (s_1948_11));
        // N s_1948_13: branch s_1948_12 b1951 b1949
        if s_1948_12 {
            return block_1951(state, tracer, fn_state);
        } else {
            return block_1949(state, tracer, fn_state);
        };
    }
    fn block_1949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1949_0: const #0u : u8
        let s_1949_0: bool = false;
        // D s_1949_1: write-var gs#402363 <= s_1949_0
        fn_state.gs_402363 = s_1949_0;
        // N s_1949_2: jump b1950
        return block_1950(state, tracer, fn_state);
    }
    fn block_1950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1950_0: read-var gs#402363:u8
        let s_1950_0: bool = fn_state.gs_402363;
        // D s_1950_1: write-var gs#402364 <= s_1950_0
        fn_state.gs_402364 = s_1950_0;
        // N s_1950_2: jump b1155
        return block_1155(state, tracer, fn_state);
    }
    fn block_1951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1951_0: const #8s : i
        let s_1951_0: i128 = 8;
        // D s_1951_1: read-var u#31926:u32
        let s_1951_1: u32 = fn_state.u_31926;
        // D s_1951_2: cast zx s_1951_1 -> bv
        let s_1951_2: Bits = Bits::new(s_1951_1 as u128, 32u16);
        // C s_1951_3: const #1s : i64
        let s_1951_3: i64 = 1;
        // C s_1951_4: cast zx s_1951_3 -> i
        let s_1951_4: i128 = (i128::try_from(s_1951_3).unwrap());
        // C s_1951_5: const #3s : i
        let s_1951_5: i128 = 3;
        // C s_1951_6: add s_1951_5 s_1951_4
        let s_1951_6: i128 = (s_1951_5 + s_1951_4);
        // D s_1951_7: bit-extract s_1951_2 s_1951_0 s_1951_6
        let s_1951_7: Bits = (Bits::new(
            ((s_1951_2) >> (s_1951_0)).value(),
            u16::try_from(s_1951_6).unwrap(),
        ));
        // D s_1951_8: cast reint s_1951_7 -> u8
        let s_1951_8: u8 = (s_1951_7.value() as u8);
        // D s_1951_9: cast zx s_1951_8 -> bv
        let s_1951_9: Bits = Bits::new(s_1951_8 as u128, 4u16);
        // C s_1951_10: const #10u : u8
        let s_1951_10: u8 = 10;
        // C s_1951_11: cast zx s_1951_10 -> bv
        let s_1951_11: Bits = Bits::new(s_1951_10 as u128, 4u16);
        // D s_1951_12: cmp-eq s_1951_9 s_1951_11
        let s_1951_12: bool = ((s_1951_9) == (s_1951_11));
        // D s_1951_13: write-var gs#402363 <= s_1951_12
        fn_state.gs_402363 = s_1951_12;
        // N s_1951_14: jump b1950
        return block_1950(state, tracer, fn_state);
    }
    fn block_1952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1952_0: const #3698s : i
        let s_1952_0: i128 = 3698;
        // C s_1952_1: const #14696u : u32
        let s_1952_1: u32 = 14696;
        // D s_1952_2: read-reg s_1952_1:i
        let s_1952_2: i128 = {
            let value = state.read_register::<i128>(s_1952_1 as isize);
            tracer.read_register(s_1952_1 as isize, value);
            value
        };
        // D s_1952_3: cmp-lt s_1952_2 s_1952_0
        let s_1952_3: bool = ((s_1952_2) < (s_1952_0));
        // D s_1952_4: write-var gs#402339 <= s_1952_3
        fn_state.gs_402339 = s_1952_3;
        // N s_1952_5: jump b1151
        return block_1151(state, tracer, fn_state);
    }
    fn block_1953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1953_0: const #20s : i
        let s_1953_0: i128 = 20;
        // D s_1953_1: read-var u#31917:u32
        let s_1953_1: u32 = fn_state.u_31917;
        // D s_1953_2: cast zx s_1953_1 -> bv
        let s_1953_2: Bits = Bits::new(s_1953_1 as u128, 32u16);
        // C s_1953_3: const #1s : i64
        let s_1953_3: i64 = 1;
        // C s_1953_4: cast zx s_1953_3 -> i
        let s_1953_4: i128 = (i128::try_from(s_1953_3).unwrap());
        // C s_1953_5: const #1s : i
        let s_1953_5: i128 = 1;
        // C s_1953_6: add s_1953_5 s_1953_4
        let s_1953_6: i128 = (s_1953_5 + s_1953_4);
        // D s_1953_7: bit-extract s_1953_2 s_1953_0 s_1953_6
        let s_1953_7: Bits = (Bits::new(
            ((s_1953_2) >> (s_1953_0)).value(),
            u16::try_from(s_1953_6).unwrap(),
        ));
        // D s_1953_8: cast reint s_1953_7 -> u8
        let s_1953_8: u8 = (s_1953_7.value() as u8);
        // D s_1953_9: cast zx s_1953_8 -> bv
        let s_1953_9: Bits = Bits::new(s_1953_8 as u128, 2u16);
        // C s_1953_10: const #0u : u8
        let s_1953_10: u8 = 0;
        // C s_1953_11: cast zx s_1953_10 -> bv
        let s_1953_11: Bits = Bits::new(s_1953_10 as u128, 2u16);
        // D s_1953_12: cmp-eq s_1953_9 s_1953_11
        let s_1953_12: bool = ((s_1953_9) == (s_1953_11));
        // N s_1953_13: branch s_1953_12 b1956 b1954
        if s_1953_12 {
            return block_1956(state, tracer, fn_state);
        } else {
            return block_1954(state, tracer, fn_state);
        };
    }
    fn block_1954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1954_0: const #0u : u8
        let s_1954_0: bool = false;
        // D s_1954_1: write-var gs#402336 <= s_1954_0
        fn_state.gs_402336 = s_1954_0;
        // N s_1954_2: jump b1955
        return block_1955(state, tracer, fn_state);
    }
    fn block_1955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1955_0: read-var gs#402336:u8
        let s_1955_0: bool = fn_state.gs_402336;
        // D s_1955_1: write-var gs#402337 <= s_1955_0
        fn_state.gs_402337 = s_1955_0;
        // N s_1955_2: jump b1149
        return block_1149(state, tracer, fn_state);
    }
    fn block_1956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1956_0: const #8s : i
        let s_1956_0: i128 = 8;
        // D s_1956_1: read-var u#31917:u32
        let s_1956_1: u32 = fn_state.u_31917;
        // D s_1956_2: cast zx s_1956_1 -> bv
        let s_1956_2: Bits = Bits::new(s_1956_1 as u128, 32u16);
        // C s_1956_3: const #1s : i64
        let s_1956_3: i64 = 1;
        // C s_1956_4: cast zx s_1956_3 -> i
        let s_1956_4: i128 = (i128::try_from(s_1956_3).unwrap());
        // C s_1956_5: const #3s : i
        let s_1956_5: i128 = 3;
        // C s_1956_6: add s_1956_5 s_1956_4
        let s_1956_6: i128 = (s_1956_5 + s_1956_4);
        // D s_1956_7: bit-extract s_1956_2 s_1956_0 s_1956_6
        let s_1956_7: Bits = (Bits::new(
            ((s_1956_2) >> (s_1956_0)).value(),
            u16::try_from(s_1956_6).unwrap(),
        ));
        // D s_1956_8: cast reint s_1956_7 -> u8
        let s_1956_8: u8 = (s_1956_7.value() as u8);
        // D s_1956_9: cast zx s_1956_8 -> bv
        let s_1956_9: Bits = Bits::new(s_1956_8 as u128, 4u16);
        // C s_1956_10: const #7u : u8
        let s_1956_10: u8 = 7;
        // C s_1956_11: cast zx s_1956_10 -> bv
        let s_1956_11: Bits = Bits::new(s_1956_10 as u128, 4u16);
        // D s_1956_12: cmp-eq s_1956_9 s_1956_11
        let s_1956_12: bool = ((s_1956_9) == (s_1956_11));
        // D s_1956_13: write-var gs#402336 <= s_1956_12
        fn_state.gs_402336 = s_1956_12;
        // N s_1956_14: jump b1955
        return block_1955(state, tracer, fn_state);
    }
    fn block_1957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1957_0: const #3694s : i
        let s_1957_0: i128 = 3694;
        // C s_1957_1: const #14696u : u32
        let s_1957_1: u32 = 14696;
        // D s_1957_2: read-reg s_1957_1:i
        let s_1957_2: i128 = {
            let value = state.read_register::<i128>(s_1957_1 as isize);
            tracer.read_register(s_1957_1 as isize, value);
            value
        };
        // D s_1957_3: cmp-lt s_1957_2 s_1957_0
        let s_1957_3: bool = ((s_1957_2) < (s_1957_0));
        // D s_1957_4: write-var gs#402314 <= s_1957_3
        fn_state.gs_402314 = s_1957_3;
        // N s_1957_5: jump b1145
        return block_1145(state, tracer, fn_state);
    }
    fn block_1958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1958_0: const #20s : i
        let s_1958_0: i128 = 20;
        // D s_1958_1: read-var u#31909:u32
        let s_1958_1: u32 = fn_state.u_31909;
        // D s_1958_2: cast zx s_1958_1 -> bv
        let s_1958_2: Bits = Bits::new(s_1958_1 as u128, 32u16);
        // C s_1958_3: const #1s : i64
        let s_1958_3: i64 = 1;
        // C s_1958_4: cast zx s_1958_3 -> i
        let s_1958_4: i128 = (i128::try_from(s_1958_3).unwrap());
        // C s_1958_5: const #1s : i
        let s_1958_5: i128 = 1;
        // C s_1958_6: add s_1958_5 s_1958_4
        let s_1958_6: i128 = (s_1958_5 + s_1958_4);
        // D s_1958_7: bit-extract s_1958_2 s_1958_0 s_1958_6
        let s_1958_7: Bits = (Bits::new(
            ((s_1958_2) >> (s_1958_0)).value(),
            u16::try_from(s_1958_6).unwrap(),
        ));
        // D s_1958_8: cast reint s_1958_7 -> u8
        let s_1958_8: u8 = (s_1958_7.value() as u8);
        // D s_1958_9: cast zx s_1958_8 -> bv
        let s_1958_9: Bits = Bits::new(s_1958_8 as u128, 2u16);
        // C s_1958_10: const #0u : u8
        let s_1958_10: u8 = 0;
        // C s_1958_11: cast zx s_1958_10 -> bv
        let s_1958_11: Bits = Bits::new(s_1958_10 as u128, 2u16);
        // D s_1958_12: cmp-eq s_1958_9 s_1958_11
        let s_1958_12: bool = ((s_1958_9) == (s_1958_11));
        // N s_1958_13: branch s_1958_12 b1961 b1959
        if s_1958_12 {
            return block_1961(state, tracer, fn_state);
        } else {
            return block_1959(state, tracer, fn_state);
        };
    }
    fn block_1959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1959_0: const #0u : u8
        let s_1959_0: bool = false;
        // D s_1959_1: write-var gs#402311 <= s_1959_0
        fn_state.gs_402311 = s_1959_0;
        // N s_1959_2: jump b1960
        return block_1960(state, tracer, fn_state);
    }
    fn block_1960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1960_0: read-var gs#402311:u8
        let s_1960_0: bool = fn_state.gs_402311;
        // D s_1960_1: write-var gs#402312 <= s_1960_0
        fn_state.gs_402312 = s_1960_0;
        // N s_1960_2: jump b1143
        return block_1143(state, tracer, fn_state);
    }
    fn block_1961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1961_0: const #8s : i
        let s_1961_0: i128 = 8;
        // D s_1961_1: read-var u#31909:u32
        let s_1961_1: u32 = fn_state.u_31909;
        // D s_1961_2: cast zx s_1961_1 -> bv
        let s_1961_2: Bits = Bits::new(s_1961_1 as u128, 32u16);
        // C s_1961_3: const #1s : i64
        let s_1961_3: i64 = 1;
        // C s_1961_4: cast zx s_1961_3 -> i
        let s_1961_4: i128 = (i128::try_from(s_1961_3).unwrap());
        // C s_1961_5: const #3s : i
        let s_1961_5: i128 = 3;
        // C s_1961_6: add s_1961_5 s_1961_4
        let s_1961_6: i128 = (s_1961_5 + s_1961_4);
        // D s_1961_7: bit-extract s_1961_2 s_1961_0 s_1961_6
        let s_1961_7: Bits = (Bits::new(
            ((s_1961_2) >> (s_1961_0)).value(),
            u16::try_from(s_1961_6).unwrap(),
        ));
        // D s_1961_8: cast reint s_1961_7 -> u8
        let s_1961_8: u8 = (s_1961_7.value() as u8);
        // D s_1961_9: cast zx s_1961_8 -> bv
        let s_1961_9: Bits = Bits::new(s_1961_8 as u128, 4u16);
        // C s_1961_10: const #8u : u8
        let s_1961_10: u8 = 8;
        // C s_1961_11: cast zx s_1961_10 -> bv
        let s_1961_11: Bits = Bits::new(s_1961_10 as u128, 4u16);
        // D s_1961_12: cmp-eq s_1961_9 s_1961_11
        let s_1961_12: bool = ((s_1961_9) == (s_1961_11));
        // D s_1961_13: write-var gs#402311 <= s_1961_12
        fn_state.gs_402311 = s_1961_12;
        // N s_1961_14: jump b1960
        return block_1960(state, tracer, fn_state);
    }
    fn block_1962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1962_0: const #3693s : i
        let s_1962_0: i128 = 3693;
        // C s_1962_1: const #14696u : u32
        let s_1962_1: u32 = 14696;
        // D s_1962_2: read-reg s_1962_1:i
        let s_1962_2: i128 = {
            let value = state.read_register::<i128>(s_1962_1 as isize);
            tracer.read_register(s_1962_1 as isize, value);
            value
        };
        // D s_1962_3: cmp-lt s_1962_2 s_1962_0
        let s_1962_3: bool = ((s_1962_2) < (s_1962_0));
        // D s_1962_4: write-var gs#402289 <= s_1962_3
        fn_state.gs_402289 = s_1962_3;
        // N s_1962_5: jump b1139
        return block_1139(state, tracer, fn_state);
    }
    fn block_1963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1963_0: const #20s : i
        let s_1963_0: i128 = 20;
        // D s_1963_1: read-var u#31901:u32
        let s_1963_1: u32 = fn_state.u_31901;
        // D s_1963_2: cast zx s_1963_1 -> bv
        let s_1963_2: Bits = Bits::new(s_1963_1 as u128, 32u16);
        // C s_1963_3: const #1s : i64
        let s_1963_3: i64 = 1;
        // C s_1963_4: cast zx s_1963_3 -> i
        let s_1963_4: i128 = (i128::try_from(s_1963_3).unwrap());
        // C s_1963_5: const #1s : i
        let s_1963_5: i128 = 1;
        // C s_1963_6: add s_1963_5 s_1963_4
        let s_1963_6: i128 = (s_1963_5 + s_1963_4);
        // D s_1963_7: bit-extract s_1963_2 s_1963_0 s_1963_6
        let s_1963_7: Bits = (Bits::new(
            ((s_1963_2) >> (s_1963_0)).value(),
            u16::try_from(s_1963_6).unwrap(),
        ));
        // D s_1963_8: cast reint s_1963_7 -> u8
        let s_1963_8: u8 = (s_1963_7.value() as u8);
        // D s_1963_9: cast zx s_1963_8 -> bv
        let s_1963_9: Bits = Bits::new(s_1963_8 as u128, 2u16);
        // C s_1963_10: const #0u : u8
        let s_1963_10: u8 = 0;
        // C s_1963_11: cast zx s_1963_10 -> bv
        let s_1963_11: Bits = Bits::new(s_1963_10 as u128, 2u16);
        // D s_1963_12: cmp-eq s_1963_9 s_1963_11
        let s_1963_12: bool = ((s_1963_9) == (s_1963_11));
        // N s_1963_13: branch s_1963_12 b1966 b1964
        if s_1963_12 {
            return block_1966(state, tracer, fn_state);
        } else {
            return block_1964(state, tracer, fn_state);
        };
    }
    fn block_1964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1964_0: const #0u : u8
        let s_1964_0: bool = false;
        // D s_1964_1: write-var gs#402286 <= s_1964_0
        fn_state.gs_402286 = s_1964_0;
        // N s_1964_2: jump b1965
        return block_1965(state, tracer, fn_state);
    }
    fn block_1965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1965_0: read-var gs#402286:u8
        let s_1965_0: bool = fn_state.gs_402286;
        // D s_1965_1: write-var gs#402287 <= s_1965_0
        fn_state.gs_402287 = s_1965_0;
        // N s_1965_2: jump b1137
        return block_1137(state, tracer, fn_state);
    }
    fn block_1966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1966_0: const #8s : i
        let s_1966_0: i128 = 8;
        // D s_1966_1: read-var u#31901:u32
        let s_1966_1: u32 = fn_state.u_31901;
        // D s_1966_2: cast zx s_1966_1 -> bv
        let s_1966_2: Bits = Bits::new(s_1966_1 as u128, 32u16);
        // C s_1966_3: const #1s : i64
        let s_1966_3: i64 = 1;
        // C s_1966_4: cast zx s_1966_3 -> i
        let s_1966_4: i128 = (i128::try_from(s_1966_3).unwrap());
        // C s_1966_5: const #3s : i
        let s_1966_5: i128 = 3;
        // C s_1966_6: add s_1966_5 s_1966_4
        let s_1966_6: i128 = (s_1966_5 + s_1966_4);
        // D s_1966_7: bit-extract s_1966_2 s_1966_0 s_1966_6
        let s_1966_7: Bits = (Bits::new(
            ((s_1966_2) >> (s_1966_0)).value(),
            u16::try_from(s_1966_6).unwrap(),
        ));
        // D s_1966_8: cast reint s_1966_7 -> u8
        let s_1966_8: u8 = (s_1966_7.value() as u8);
        // D s_1966_9: cast zx s_1966_8 -> bv
        let s_1966_9: Bits = Bits::new(s_1966_8 as u128, 4u16);
        // C s_1966_10: const #4u : u8
        let s_1966_10: u8 = 4;
        // C s_1966_11: cast zx s_1966_10 -> bv
        let s_1966_11: Bits = Bits::new(s_1966_10 as u128, 4u16);
        // D s_1966_12: cmp-eq s_1966_9 s_1966_11
        let s_1966_12: bool = ((s_1966_9) == (s_1966_11));
        // D s_1966_13: write-var gs#402286 <= s_1966_12
        fn_state.gs_402286 = s_1966_12;
        // N s_1966_14: jump b1965
        return block_1965(state, tracer, fn_state);
    }
    fn block_1967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1967_0: const #3692s : i
        let s_1967_0: i128 = 3692;
        // C s_1967_1: const #14696u : u32
        let s_1967_1: u32 = 14696;
        // D s_1967_2: read-reg s_1967_1:i
        let s_1967_2: i128 = {
            let value = state.read_register::<i128>(s_1967_1 as isize);
            tracer.read_register(s_1967_1 as isize, value);
            value
        };
        // D s_1967_3: cmp-lt s_1967_2 s_1967_0
        let s_1967_3: bool = ((s_1967_2) < (s_1967_0));
        // D s_1967_4: write-var gs#402264 <= s_1967_3
        fn_state.gs_402264 = s_1967_3;
        // N s_1967_5: jump b1133
        return block_1133(state, tracer, fn_state);
    }
    fn block_1968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1968_0: const #20s : i
        let s_1968_0: i128 = 20;
        // D s_1968_1: read-var u#31893:u32
        let s_1968_1: u32 = fn_state.u_31893;
        // D s_1968_2: cast zx s_1968_1 -> bv
        let s_1968_2: Bits = Bits::new(s_1968_1 as u128, 32u16);
        // C s_1968_3: const #1s : i64
        let s_1968_3: i64 = 1;
        // C s_1968_4: cast zx s_1968_3 -> i
        let s_1968_4: i128 = (i128::try_from(s_1968_3).unwrap());
        // C s_1968_5: const #1s : i
        let s_1968_5: i128 = 1;
        // C s_1968_6: add s_1968_5 s_1968_4
        let s_1968_6: i128 = (s_1968_5 + s_1968_4);
        // D s_1968_7: bit-extract s_1968_2 s_1968_0 s_1968_6
        let s_1968_7: Bits = (Bits::new(
            ((s_1968_2) >> (s_1968_0)).value(),
            u16::try_from(s_1968_6).unwrap(),
        ));
        // D s_1968_8: cast reint s_1968_7 -> u8
        let s_1968_8: u8 = (s_1968_7.value() as u8);
        // D s_1968_9: cast zx s_1968_8 -> bv
        let s_1968_9: Bits = Bits::new(s_1968_8 as u128, 2u16);
        // C s_1968_10: const #0u : u8
        let s_1968_10: u8 = 0;
        // C s_1968_11: cast zx s_1968_10 -> bv
        let s_1968_11: Bits = Bits::new(s_1968_10 as u128, 2u16);
        // D s_1968_12: cmp-eq s_1968_9 s_1968_11
        let s_1968_12: bool = ((s_1968_9) == (s_1968_11));
        // N s_1968_13: branch s_1968_12 b1971 b1969
        if s_1968_12 {
            return block_1971(state, tracer, fn_state);
        } else {
            return block_1969(state, tracer, fn_state);
        };
    }
    fn block_1969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1969_0: const #0u : u8
        let s_1969_0: bool = false;
        // D s_1969_1: write-var gs#402261 <= s_1969_0
        fn_state.gs_402261 = s_1969_0;
        // N s_1969_2: jump b1970
        return block_1970(state, tracer, fn_state);
    }
    fn block_1970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1970_0: read-var gs#402261:u8
        let s_1970_0: bool = fn_state.gs_402261;
        // D s_1970_1: write-var gs#402262 <= s_1970_0
        fn_state.gs_402262 = s_1970_0;
        // N s_1970_2: jump b1131
        return block_1131(state, tracer, fn_state);
    }
    fn block_1971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1971_0: const #8s : i
        let s_1971_0: i128 = 8;
        // D s_1971_1: read-var u#31893:u32
        let s_1971_1: u32 = fn_state.u_31893;
        // D s_1971_2: cast zx s_1971_1 -> bv
        let s_1971_2: Bits = Bits::new(s_1971_1 as u128, 32u16);
        // C s_1971_3: const #1s : i64
        let s_1971_3: i64 = 1;
        // C s_1971_4: cast zx s_1971_3 -> i
        let s_1971_4: i128 = (i128::try_from(s_1971_3).unwrap());
        // C s_1971_5: const #3s : i
        let s_1971_5: i128 = 3;
        // C s_1971_6: add s_1971_5 s_1971_4
        let s_1971_6: i128 = (s_1971_5 + s_1971_4);
        // D s_1971_7: bit-extract s_1971_2 s_1971_0 s_1971_6
        let s_1971_7: Bits = (Bits::new(
            ((s_1971_2) >> (s_1971_0)).value(),
            u16::try_from(s_1971_6).unwrap(),
        ));
        // D s_1971_8: cast reint s_1971_7 -> u8
        let s_1971_8: u8 = (s_1971_7.value() as u8);
        // D s_1971_9: cast zx s_1971_8 -> bv
        let s_1971_9: Bits = Bits::new(s_1971_8 as u128, 4u16);
        // C s_1971_10: const #0u : u8
        let s_1971_10: u8 = 0;
        // C s_1971_11: cast zx s_1971_10 -> bv
        let s_1971_11: Bits = Bits::new(s_1971_10 as u128, 4u16);
        // D s_1971_12: cmp-eq s_1971_9 s_1971_11
        let s_1971_12: bool = ((s_1971_9) == (s_1971_11));
        // D s_1971_13: write-var gs#402261 <= s_1971_12
        fn_state.gs_402261 = s_1971_12;
        // N s_1971_14: jump b1970
        return block_1970(state, tracer, fn_state);
    }
    fn block_1972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1972_0: const #3690s : i
        let s_1972_0: i128 = 3690;
        // C s_1972_1: const #14696u : u32
        let s_1972_1: u32 = 14696;
        // D s_1972_2: read-reg s_1972_1:i
        let s_1972_2: i128 = {
            let value = state.read_register::<i128>(s_1972_1 as isize);
            tracer.read_register(s_1972_1 as isize, value);
            value
        };
        // D s_1972_3: cmp-lt s_1972_2 s_1972_0
        let s_1972_3: bool = ((s_1972_2) < (s_1972_0));
        // D s_1972_4: write-var gs#402237 <= s_1972_3
        fn_state.gs_402237 = s_1972_3;
        // N s_1972_5: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_1973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1973_0: const #8s : i
        let s_1973_0: i128 = 8;
        // D s_1973_1: read-var u#31884:u32
        let s_1973_1: u32 = fn_state.u_31884;
        // D s_1973_2: cast zx s_1973_1 -> bv
        let s_1973_2: Bits = Bits::new(s_1973_1 as u128, 32u16);
        // C s_1973_3: const #1s : i64
        let s_1973_3: i64 = 1;
        // C s_1973_4: cast zx s_1973_3 -> i
        let s_1973_4: i128 = (i128::try_from(s_1973_3).unwrap());
        // C s_1973_5: const #3s : i
        let s_1973_5: i128 = 3;
        // C s_1973_6: add s_1973_5 s_1973_4
        let s_1973_6: i128 = (s_1973_5 + s_1973_4);
        // D s_1973_7: bit-extract s_1973_2 s_1973_0 s_1973_6
        let s_1973_7: Bits = (Bits::new(
            ((s_1973_2) >> (s_1973_0)).value(),
            u16::try_from(s_1973_6).unwrap(),
        ));
        // D s_1973_8: cast reint s_1973_7 -> u8
        let s_1973_8: u8 = (s_1973_7.value() as u8);
        // D s_1973_9: cast zx s_1973_8 -> bv
        let s_1973_9: Bits = Bits::new(s_1973_8 as u128, 4u16);
        // C s_1973_10: const #4u : u8
        let s_1973_10: u8 = 4;
        // C s_1973_11: cast zx s_1973_10 -> bv
        let s_1973_11: Bits = Bits::new(s_1973_10 as u128, 4u16);
        // D s_1973_12: cmp-eq s_1973_9 s_1973_11
        let s_1973_12: bool = ((s_1973_9) == (s_1973_11));
        // N s_1973_13: branch s_1973_12 b1976 b1974
        if s_1973_12 {
            return block_1976(state, tracer, fn_state);
        } else {
            return block_1974(state, tracer, fn_state);
        };
    }
    fn block_1974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1974_0: const #0u : u8
        let s_1974_0: bool = false;
        // D s_1974_1: write-var gs#402234 <= s_1974_0
        fn_state.gs_402234 = s_1974_0;
        // N s_1974_2: jump b1975
        return block_1975(state, tracer, fn_state);
    }
    fn block_1975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1975_0: read-var gs#402234:u8
        let s_1975_0: bool = fn_state.gs_402234;
        // D s_1975_1: write-var gs#402235 <= s_1975_0
        fn_state.gs_402235 = s_1975_0;
        // N s_1975_2: jump b1125
        return block_1125(state, tracer, fn_state);
    }
    fn block_1976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1976_0: const #4s : i
        let s_1976_0: i128 = 4;
        // D s_1976_1: read-var u#31884:u32
        let s_1976_1: u32 = fn_state.u_31884;
        // D s_1976_2: cast zx s_1976_1 -> bv
        let s_1976_2: Bits = Bits::new(s_1976_1 as u128, 32u16);
        // C s_1976_3: const #1s : i64
        let s_1976_3: i64 = 1;
        // C s_1976_4: cast zx s_1976_3 -> i
        let s_1976_4: i128 = (i128::try_from(s_1976_3).unwrap());
        // C s_1976_5: const #0s : i
        let s_1976_5: i128 = 0;
        // C s_1976_6: add s_1976_5 s_1976_4
        let s_1976_6: i128 = (s_1976_5 + s_1976_4);
        // D s_1976_7: bit-extract s_1976_2 s_1976_0 s_1976_6
        let s_1976_7: Bits = (Bits::new(
            ((s_1976_2) >> (s_1976_0)).value(),
            u16::try_from(s_1976_6).unwrap(),
        ));
        // D s_1976_8: cast reint s_1976_7 -> u8
        let s_1976_8: bool = ((s_1976_7.value()) != 0);
        // D s_1976_9: cast zx s_1976_8 -> bv
        let s_1976_9: Bits = Bits::new(s_1976_8 as u128, 1u16);
        // C s_1976_10: const #1u : u8
        let s_1976_10: bool = true;
        // C s_1976_11: cast zx s_1976_10 -> bv
        let s_1976_11: Bits = Bits::new(s_1976_10 as u128, 1u16);
        // D s_1976_12: cmp-eq s_1976_9 s_1976_11
        let s_1976_12: bool = ((s_1976_9) == (s_1976_11));
        // D s_1976_13: write-var gs#402234 <= s_1976_12
        fn_state.gs_402234 = s_1976_12;
        // N s_1976_14: jump b1975
        return block_1975(state, tracer, fn_state);
    }
    fn block_1977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1977_0: const #3688s : i
        let s_1977_0: i128 = 3688;
        // C s_1977_1: const #14696u : u32
        let s_1977_1: u32 = 14696;
        // D s_1977_2: read-reg s_1977_1:i
        let s_1977_2: i128 = {
            let value = state.read_register::<i128>(s_1977_1 as isize);
            tracer.read_register(s_1977_1 as isize, value);
            value
        };
        // D s_1977_3: cmp-lt s_1977_2 s_1977_0
        let s_1977_3: bool = ((s_1977_2) < (s_1977_0));
        // D s_1977_4: write-var gs#402208 <= s_1977_3
        fn_state.gs_402208 = s_1977_3;
        // N s_1977_5: jump b1121
        return block_1121(state, tracer, fn_state);
    }
    fn block_1978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1978_0: const #23s : i
        let s_1978_0: i128 = 23;
        // D s_1978_1: read-var u#31874:u32
        let s_1978_1: u32 = fn_state.u_31874;
        // D s_1978_2: cast zx s_1978_1 -> bv
        let s_1978_2: Bits = Bits::new(s_1978_1 as u128, 32u16);
        // C s_1978_3: const #1s : i64
        let s_1978_3: i64 = 1;
        // C s_1978_4: cast zx s_1978_3 -> i
        let s_1978_4: i128 = (i128::try_from(s_1978_3).unwrap());
        // C s_1978_5: const #0s : i
        let s_1978_5: i128 = 0;
        // C s_1978_6: add s_1978_5 s_1978_4
        let s_1978_6: i128 = (s_1978_5 + s_1978_4);
        // D s_1978_7: bit-extract s_1978_2 s_1978_0 s_1978_6
        let s_1978_7: Bits = (Bits::new(
            ((s_1978_2) >> (s_1978_0)).value(),
            u16::try_from(s_1978_6).unwrap(),
        ));
        // D s_1978_8: cast reint s_1978_7 -> u8
        let s_1978_8: bool = ((s_1978_7.value()) != 0);
        // D s_1978_9: cast zx s_1978_8 -> bv
        let s_1978_9: Bits = Bits::new(s_1978_8 as u128, 1u16);
        // C s_1978_10: const #1u : u8
        let s_1978_10: bool = true;
        // C s_1978_11: cast zx s_1978_10 -> bv
        let s_1978_11: Bits = Bits::new(s_1978_10 as u128, 1u16);
        // D s_1978_12: cmp-eq s_1978_9 s_1978_11
        let s_1978_12: bool = ((s_1978_9) == (s_1978_11));
        // N s_1978_13: branch s_1978_12 b1981 b1979
        if s_1978_12 {
            return block_1981(state, tracer, fn_state);
        } else {
            return block_1979(state, tracer, fn_state);
        };
    }
    fn block_1979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1979_0: const #0u : u8
        let s_1979_0: bool = false;
        // D s_1979_1: write-var gs#402205 <= s_1979_0
        fn_state.gs_402205 = s_1979_0;
        // N s_1979_2: jump b1980
        return block_1980(state, tracer, fn_state);
    }
    fn block_1980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1980_0: read-var gs#402205:u8
        let s_1980_0: bool = fn_state.gs_402205;
        // D s_1980_1: write-var gs#402206 <= s_1980_0
        fn_state.gs_402206 = s_1980_0;
        // N s_1980_2: jump b1119
        return block_1119(state, tracer, fn_state);
    }
    fn block_1981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1981_0: const #8s : i
        let s_1981_0: i128 = 8;
        // D s_1981_1: read-var u#31874:u32
        let s_1981_1: u32 = fn_state.u_31874;
        // D s_1981_2: cast zx s_1981_1 -> bv
        let s_1981_2: Bits = Bits::new(s_1981_1 as u128, 32u16);
        // C s_1981_3: const #1s : i64
        let s_1981_3: i64 = 1;
        // C s_1981_4: cast zx s_1981_3 -> i
        let s_1981_4: i128 = (i128::try_from(s_1981_3).unwrap());
        // C s_1981_5: const #3s : i
        let s_1981_5: i128 = 3;
        // C s_1981_6: add s_1981_5 s_1981_4
        let s_1981_6: i128 = (s_1981_5 + s_1981_4);
        // D s_1981_7: bit-extract s_1981_2 s_1981_0 s_1981_6
        let s_1981_7: Bits = (Bits::new(
            ((s_1981_2) >> (s_1981_0)).value(),
            u16::try_from(s_1981_6).unwrap(),
        ));
        // D s_1981_8: cast reint s_1981_7 -> u8
        let s_1981_8: u8 = (s_1981_7.value() as u8);
        // D s_1981_9: cast zx s_1981_8 -> bv
        let s_1981_9: Bits = Bits::new(s_1981_8 as u128, 4u16);
        // C s_1981_10: const #1u : u8
        let s_1981_10: u8 = 1;
        // C s_1981_11: cast zx s_1981_10 -> bv
        let s_1981_11: Bits = Bits::new(s_1981_10 as u128, 4u16);
        // D s_1981_12: cmp-eq s_1981_9 s_1981_11
        let s_1981_12: bool = ((s_1981_9) == (s_1981_11));
        // N s_1981_13: branch s_1981_12 b1984 b1982
        if s_1981_12 {
            return block_1984(state, tracer, fn_state);
        } else {
            return block_1982(state, tracer, fn_state);
        };
    }
    fn block_1982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1982_0: const #0u : u8
        let s_1982_0: bool = false;
        // D s_1982_1: write-var gs#402204 <= s_1982_0
        fn_state.gs_402204 = s_1982_0;
        // N s_1982_2: jump b1983
        return block_1983(state, tracer, fn_state);
    }
    fn block_1983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1983_0: read-var gs#402204:u8
        let s_1983_0: bool = fn_state.gs_402204;
        // D s_1983_1: write-var gs#402205 <= s_1983_0
        fn_state.gs_402205 = s_1983_0;
        // N s_1983_2: jump b1980
        return block_1980(state, tracer, fn_state);
    }
    fn block_1984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1984_0: const #4s : i
        let s_1984_0: i128 = 4;
        // D s_1984_1: read-var u#31874:u32
        let s_1984_1: u32 = fn_state.u_31874;
        // D s_1984_2: cast zx s_1984_1 -> bv
        let s_1984_2: Bits = Bits::new(s_1984_1 as u128, 32u16);
        // C s_1984_3: const #1s : i64
        let s_1984_3: i64 = 1;
        // C s_1984_4: cast zx s_1984_3 -> i
        let s_1984_4: i128 = (i128::try_from(s_1984_3).unwrap());
        // C s_1984_5: const #0s : i
        let s_1984_5: i128 = 0;
        // C s_1984_6: add s_1984_5 s_1984_4
        let s_1984_6: i128 = (s_1984_5 + s_1984_4);
        // D s_1984_7: bit-extract s_1984_2 s_1984_0 s_1984_6
        let s_1984_7: Bits = (Bits::new(
            ((s_1984_2) >> (s_1984_0)).value(),
            u16::try_from(s_1984_6).unwrap(),
        ));
        // D s_1984_8: cast reint s_1984_7 -> u8
        let s_1984_8: bool = ((s_1984_7.value()) != 0);
        // D s_1984_9: cast zx s_1984_8 -> bv
        let s_1984_9: Bits = Bits::new(s_1984_8 as u128, 1u16);
        // C s_1984_10: const #1u : u8
        let s_1984_10: bool = true;
        // C s_1984_11: cast zx s_1984_10 -> bv
        let s_1984_11: Bits = Bits::new(s_1984_10 as u128, 1u16);
        // D s_1984_12: cmp-eq s_1984_9 s_1984_11
        let s_1984_12: bool = ((s_1984_9) == (s_1984_11));
        // D s_1984_13: write-var gs#402204 <= s_1984_12
        fn_state.gs_402204 = s_1984_12;
        // N s_1984_14: jump b1983
        return block_1983(state, tracer, fn_state);
    }
    fn block_1985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1985_0: const #3684s : i
        let s_1985_0: i128 = 3684;
        // C s_1985_1: const #14696u : u32
        let s_1985_1: u32 = 14696;
        // D s_1985_2: read-reg s_1985_1:i
        let s_1985_2: i128 = {
            let value = state.read_register::<i128>(s_1985_1 as isize);
            tracer.read_register(s_1985_1 as isize, value);
            value
        };
        // D s_1985_3: cmp-lt s_1985_2 s_1985_0
        let s_1985_3: bool = ((s_1985_2) < (s_1985_0));
        // D s_1985_4: write-var gs#402178 <= s_1985_3
        fn_state.gs_402178 = s_1985_3;
        // N s_1985_5: jump b1115
        return block_1115(state, tracer, fn_state);
    }
    fn block_1986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1986_0: const #8s : i
        let s_1986_0: i128 = 8;
        // D s_1986_1: read-var u#31865:u32
        let s_1986_1: u32 = fn_state.u_31865;
        // D s_1986_2: cast zx s_1986_1 -> bv
        let s_1986_2: Bits = Bits::new(s_1986_1 as u128, 32u16);
        // C s_1986_3: const #1s : i64
        let s_1986_3: i64 = 1;
        // C s_1986_4: cast zx s_1986_3 -> i
        let s_1986_4: i128 = (i128::try_from(s_1986_3).unwrap());
        // C s_1986_5: const #3s : i
        let s_1986_5: i128 = 3;
        // C s_1986_6: add s_1986_5 s_1986_4
        let s_1986_6: i128 = (s_1986_5 + s_1986_4);
        // D s_1986_7: bit-extract s_1986_2 s_1986_0 s_1986_6
        let s_1986_7: Bits = (Bits::new(
            ((s_1986_2) >> (s_1986_0)).value(),
            u16::try_from(s_1986_6).unwrap(),
        ));
        // D s_1986_8: cast reint s_1986_7 -> u8
        let s_1986_8: u8 = (s_1986_7.value() as u8);
        // D s_1986_9: cast zx s_1986_8 -> bv
        let s_1986_9: Bits = Bits::new(s_1986_8 as u128, 4u16);
        // C s_1986_10: const #5u : u8
        let s_1986_10: u8 = 5;
        // C s_1986_11: cast zx s_1986_10 -> bv
        let s_1986_11: Bits = Bits::new(s_1986_10 as u128, 4u16);
        // D s_1986_12: cmp-eq s_1986_9 s_1986_11
        let s_1986_12: bool = ((s_1986_9) == (s_1986_11));
        // N s_1986_13: branch s_1986_12 b1989 b1987
        if s_1986_12 {
            return block_1989(state, tracer, fn_state);
        } else {
            return block_1987(state, tracer, fn_state);
        };
    }
    fn block_1987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1987_0: const #0u : u8
        let s_1987_0: bool = false;
        // D s_1987_1: write-var gs#402175 <= s_1987_0
        fn_state.gs_402175 = s_1987_0;
        // N s_1987_2: jump b1988
        return block_1988(state, tracer, fn_state);
    }
    fn block_1988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1988_0: read-var gs#402175:u8
        let s_1988_0: bool = fn_state.gs_402175;
        // D s_1988_1: write-var gs#402176 <= s_1988_0
        fn_state.gs_402176 = s_1988_0;
        // N s_1988_2: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_1989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1989_0: const #4s : i
        let s_1989_0: i128 = 4;
        // D s_1989_1: read-var u#31865:u32
        let s_1989_1: u32 = fn_state.u_31865;
        // D s_1989_2: cast zx s_1989_1 -> bv
        let s_1989_2: Bits = Bits::new(s_1989_1 as u128, 32u16);
        // C s_1989_3: const #1s : i64
        let s_1989_3: i64 = 1;
        // C s_1989_4: cast zx s_1989_3 -> i
        let s_1989_4: i128 = (i128::try_from(s_1989_3).unwrap());
        // C s_1989_5: const #0s : i
        let s_1989_5: i128 = 0;
        // C s_1989_6: add s_1989_5 s_1989_4
        let s_1989_6: i128 = (s_1989_5 + s_1989_4);
        // D s_1989_7: bit-extract s_1989_2 s_1989_0 s_1989_6
        let s_1989_7: Bits = (Bits::new(
            ((s_1989_2) >> (s_1989_0)).value(),
            u16::try_from(s_1989_6).unwrap(),
        ));
        // D s_1989_8: cast reint s_1989_7 -> u8
        let s_1989_8: bool = ((s_1989_7.value()) != 0);
        // D s_1989_9: cast zx s_1989_8 -> bv
        let s_1989_9: Bits = Bits::new(s_1989_8 as u128, 1u16);
        // C s_1989_10: const #1u : u8
        let s_1989_10: bool = true;
        // C s_1989_11: cast zx s_1989_10 -> bv
        let s_1989_11: Bits = Bits::new(s_1989_10 as u128, 1u16);
        // D s_1989_12: cmp-eq s_1989_9 s_1989_11
        let s_1989_12: bool = ((s_1989_9) == (s_1989_11));
        // D s_1989_13: write-var gs#402175 <= s_1989_12
        fn_state.gs_402175 = s_1989_12;
        // N s_1989_14: jump b1988
        return block_1988(state, tracer, fn_state);
    }
    fn block_1990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1990_0: const #3682s : i
        let s_1990_0: i128 = 3682;
        // C s_1990_1: const #14696u : u32
        let s_1990_1: u32 = 14696;
        // D s_1990_2: read-reg s_1990_1:i
        let s_1990_2: i128 = {
            let value = state.read_register::<i128>(s_1990_1 as isize);
            tracer.read_register(s_1990_1 as isize, value);
            value
        };
        // D s_1990_3: cmp-lt s_1990_2 s_1990_0
        let s_1990_3: bool = ((s_1990_2) < (s_1990_0));
        // D s_1990_4: write-var gs#402155 <= s_1990_3
        fn_state.gs_402155 = s_1990_3;
        // N s_1990_5: jump b1109
        return block_1109(state, tracer, fn_state);
    }
    fn block_1991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1991_0: const #6s : i
        let s_1991_0: i128 = 6;
        // D s_1991_1: read-var u#31858:u32
        let s_1991_1: u32 = fn_state.u_31858;
        // D s_1991_2: cast zx s_1991_1 -> bv
        let s_1991_2: Bits = Bits::new(s_1991_1 as u128, 32u16);
        // C s_1991_3: const #1s : i64
        let s_1991_3: i64 = 1;
        // C s_1991_4: cast zx s_1991_3 -> i
        let s_1991_4: i128 = (i128::try_from(s_1991_3).unwrap());
        // C s_1991_5: const #5s : i
        let s_1991_5: i128 = 5;
        // C s_1991_6: add s_1991_5 s_1991_4
        let s_1991_6: i128 = (s_1991_5 + s_1991_4);
        // D s_1991_7: bit-extract s_1991_2 s_1991_0 s_1991_6
        let s_1991_7: Bits = (Bits::new(
            ((s_1991_2) >> (s_1991_0)).value(),
            u16::try_from(s_1991_6).unwrap(),
        ));
        // D s_1991_8: cast reint s_1991_7 -> u8
        let s_1991_8: u8 = (s_1991_7.value() as u8);
        // D s_1991_9: cast zx s_1991_8 -> bv
        let s_1991_9: Bits = Bits::new(s_1991_8 as u128, 6u16);
        // C s_1991_10: const #32u : u8
        let s_1991_10: u8 = 32;
        // C s_1991_11: cast zx s_1991_10 -> bv
        let s_1991_11: Bits = Bits::new(s_1991_10 as u128, 6u16);
        // D s_1991_12: cmp-eq s_1991_9 s_1991_11
        let s_1991_12: bool = ((s_1991_9) == (s_1991_11));
        // N s_1991_13: branch s_1991_12 b1994 b1992
        if s_1991_12 {
            return block_1994(state, tracer, fn_state);
        } else {
            return block_1992(state, tracer, fn_state);
        };
    }
    fn block_1992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1992_0: const #0u : u8
        let s_1992_0: bool = false;
        // D s_1992_1: write-var gs#402152 <= s_1992_0
        fn_state.gs_402152 = s_1992_0;
        // N s_1992_2: jump b1993
        return block_1993(state, tracer, fn_state);
    }
    fn block_1993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1993_0: read-var gs#402152:u8
        let s_1993_0: bool = fn_state.gs_402152;
        // D s_1993_1: write-var gs#402153 <= s_1993_0
        fn_state.gs_402153 = s_1993_0;
        // N s_1993_2: jump b1107
        return block_1107(state, tracer, fn_state);
    }
    fn block_1994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1994_0: const #4s : i
        let s_1994_0: i128 = 4;
        // D s_1994_1: read-var u#31858:u32
        let s_1994_1: u32 = fn_state.u_31858;
        // D s_1994_2: cast zx s_1994_1 -> bv
        let s_1994_2: Bits = Bits::new(s_1994_1 as u128, 32u16);
        // C s_1994_3: const #1s : i64
        let s_1994_3: i64 = 1;
        // C s_1994_4: cast zx s_1994_3 -> i
        let s_1994_4: i128 = (i128::try_from(s_1994_3).unwrap());
        // C s_1994_5: const #0s : i
        let s_1994_5: i128 = 0;
        // C s_1994_6: add s_1994_5 s_1994_4
        let s_1994_6: i128 = (s_1994_5 + s_1994_4);
        // D s_1994_7: bit-extract s_1994_2 s_1994_0 s_1994_6
        let s_1994_7: Bits = (Bits::new(
            ((s_1994_2) >> (s_1994_0)).value(),
            u16::try_from(s_1994_6).unwrap(),
        ));
        // D s_1994_8: cast reint s_1994_7 -> u8
        let s_1994_8: bool = ((s_1994_7.value()) != 0);
        // D s_1994_9: cast zx s_1994_8 -> bv
        let s_1994_9: Bits = Bits::new(s_1994_8 as u128, 1u16);
        // C s_1994_10: const #1u : u8
        let s_1994_10: bool = true;
        // C s_1994_11: cast zx s_1994_10 -> bv
        let s_1994_11: Bits = Bits::new(s_1994_10 as u128, 1u16);
        // D s_1994_12: cmp-eq s_1994_9 s_1994_11
        let s_1994_12: bool = ((s_1994_9) == (s_1994_11));
        // D s_1994_13: write-var gs#402152 <= s_1994_12
        fn_state.gs_402152 = s_1994_12;
        // N s_1994_14: jump b1993
        return block_1993(state, tracer, fn_state);
    }
    fn block_1995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1995_0: const #3680s : i
        let s_1995_0: i128 = 3680;
        // C s_1995_1: const #14696u : u32
        let s_1995_1: u32 = 14696;
        // D s_1995_2: read-reg s_1995_1:i
        let s_1995_2: i128 = {
            let value = state.read_register::<i128>(s_1995_1 as isize);
            tracer.read_register(s_1995_1 as isize, value);
            value
        };
        // D s_1995_3: cmp-lt s_1995_2 s_1995_0
        let s_1995_3: bool = ((s_1995_2) < (s_1995_0));
        // D s_1995_4: write-var gs#402126 <= s_1995_3
        fn_state.gs_402126 = s_1995_3;
        // N s_1995_5: jump b1103
        return block_1103(state, tracer, fn_state);
    }
    fn block_1996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1996_0: const #23s : i
        let s_1996_0: i128 = 23;
        // D s_1996_1: read-var u#31848:u32
        let s_1996_1: u32 = fn_state.u_31848;
        // D s_1996_2: cast zx s_1996_1 -> bv
        let s_1996_2: Bits = Bits::new(s_1996_1 as u128, 32u16);
        // C s_1996_3: const #1s : i64
        let s_1996_3: i64 = 1;
        // C s_1996_4: cast zx s_1996_3 -> i
        let s_1996_4: i128 = (i128::try_from(s_1996_3).unwrap());
        // C s_1996_5: const #0s : i
        let s_1996_5: i128 = 0;
        // C s_1996_6: add s_1996_5 s_1996_4
        let s_1996_6: i128 = (s_1996_5 + s_1996_4);
        // D s_1996_7: bit-extract s_1996_2 s_1996_0 s_1996_6
        let s_1996_7: Bits = (Bits::new(
            ((s_1996_2) >> (s_1996_0)).value(),
            u16::try_from(s_1996_6).unwrap(),
        ));
        // D s_1996_8: cast reint s_1996_7 -> u8
        let s_1996_8: bool = ((s_1996_7.value()) != 0);
        // D s_1996_9: cast zx s_1996_8 -> bv
        let s_1996_9: Bits = Bits::new(s_1996_8 as u128, 1u16);
        // C s_1996_10: const #1u : u8
        let s_1996_10: bool = true;
        // C s_1996_11: cast zx s_1996_10 -> bv
        let s_1996_11: Bits = Bits::new(s_1996_10 as u128, 1u16);
        // D s_1996_12: cmp-eq s_1996_9 s_1996_11
        let s_1996_12: bool = ((s_1996_9) == (s_1996_11));
        // N s_1996_13: branch s_1996_12 b1999 b1997
        if s_1996_12 {
            return block_1999(state, tracer, fn_state);
        } else {
            return block_1997(state, tracer, fn_state);
        };
    }
    fn block_1997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1997_0: const #0u : u8
        let s_1997_0: bool = false;
        // D s_1997_1: write-var gs#402123 <= s_1997_0
        fn_state.gs_402123 = s_1997_0;
        // N s_1997_2: jump b1998
        return block_1998(state, tracer, fn_state);
    }
    fn block_1998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1998_0: read-var gs#402123:u8
        let s_1998_0: bool = fn_state.gs_402123;
        // D s_1998_1: write-var gs#402124 <= s_1998_0
        fn_state.gs_402124 = s_1998_0;
        // N s_1998_2: jump b1101
        return block_1101(state, tracer, fn_state);
    }
    fn block_1999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1999_0: const #8s : i
        let s_1999_0: i128 = 8;
        // D s_1999_1: read-var u#31848:u32
        let s_1999_1: u32 = fn_state.u_31848;
        // D s_1999_2: cast zx s_1999_1 -> bv
        let s_1999_2: Bits = Bits::new(s_1999_1 as u128, 32u16);
        // C s_1999_3: const #1s : i64
        let s_1999_3: i64 = 1;
        // C s_1999_4: cast zx s_1999_3 -> i
        let s_1999_4: i128 = (i128::try_from(s_1999_3).unwrap());
        // C s_1999_5: const #3s : i
        let s_1999_5: i128 = 3;
        // C s_1999_6: add s_1999_5 s_1999_4
        let s_1999_6: i128 = (s_1999_5 + s_1999_4);
        // D s_1999_7: bit-extract s_1999_2 s_1999_0 s_1999_6
        let s_1999_7: Bits = (Bits::new(
            ((s_1999_2) >> (s_1999_0)).value(),
            u16::try_from(s_1999_6).unwrap(),
        ));
        // D s_1999_8: cast reint s_1999_7 -> u8
        let s_1999_8: u8 = (s_1999_7.value() as u8);
        // D s_1999_9: cast zx s_1999_8 -> bv
        let s_1999_9: Bits = Bits::new(s_1999_8 as u128, 4u16);
        // C s_1999_10: const #0u : u8
        let s_1999_10: u8 = 0;
        // C s_1999_11: cast zx s_1999_10 -> bv
        let s_1999_11: Bits = Bits::new(s_1999_10 as u128, 4u16);
        // D s_1999_12: cmp-eq s_1999_9 s_1999_11
        let s_1999_12: bool = ((s_1999_9) == (s_1999_11));
        // N s_1999_13: branch s_1999_12 b2002 b2000
        if s_1999_12 {
            return block_2002(state, tracer, fn_state);
        } else {
            return block_2000(state, tracer, fn_state);
        };
    }
    fn block_2000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2000_0: const #0u : u8
        let s_2000_0: bool = false;
        // D s_2000_1: write-var gs#402122 <= s_2000_0
        fn_state.gs_402122 = s_2000_0;
        // N s_2000_2: jump b2001
        return block_2001(state, tracer, fn_state);
    }
    fn block_2001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2001_0: read-var gs#402122:u8
        let s_2001_0: bool = fn_state.gs_402122;
        // D s_2001_1: write-var gs#402123 <= s_2001_0
        fn_state.gs_402123 = s_2001_0;
        // N s_2001_2: jump b1998
        return block_1998(state, tracer, fn_state);
    }
    fn block_2002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2002_0: const #4s : i
        let s_2002_0: i128 = 4;
        // D s_2002_1: read-var u#31848:u32
        let s_2002_1: u32 = fn_state.u_31848;
        // D s_2002_2: cast zx s_2002_1 -> bv
        let s_2002_2: Bits = Bits::new(s_2002_1 as u128, 32u16);
        // C s_2002_3: const #1s : i64
        let s_2002_3: i64 = 1;
        // C s_2002_4: cast zx s_2002_3 -> i
        let s_2002_4: i128 = (i128::try_from(s_2002_3).unwrap());
        // C s_2002_5: const #0s : i
        let s_2002_5: i128 = 0;
        // C s_2002_6: add s_2002_5 s_2002_4
        let s_2002_6: i128 = (s_2002_5 + s_2002_4);
        // D s_2002_7: bit-extract s_2002_2 s_2002_0 s_2002_6
        let s_2002_7: Bits = (Bits::new(
            ((s_2002_2) >> (s_2002_0)).value(),
            u16::try_from(s_2002_6).unwrap(),
        ));
        // D s_2002_8: cast reint s_2002_7 -> u8
        let s_2002_8: bool = ((s_2002_7.value()) != 0);
        // D s_2002_9: cast zx s_2002_8 -> bv
        let s_2002_9: Bits = Bits::new(s_2002_8 as u128, 1u16);
        // C s_2002_10: const #1u : u8
        let s_2002_10: bool = true;
        // C s_2002_11: cast zx s_2002_10 -> bv
        let s_2002_11: Bits = Bits::new(s_2002_10 as u128, 1u16);
        // D s_2002_12: cmp-eq s_2002_9 s_2002_11
        let s_2002_12: bool = ((s_2002_9) == (s_2002_11));
        // D s_2002_13: write-var gs#402122 <= s_2002_12
        fn_state.gs_402122 = s_2002_12;
        // N s_2002_14: jump b2001
        return block_2001(state, tracer, fn_state);
    }
    fn block_2003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2003_0: const #3678s : i
        let s_2003_0: i128 = 3678;
        // C s_2003_1: const #14696u : u32
        let s_2003_1: u32 = 14696;
        // D s_2003_2: read-reg s_2003_1:i
        let s_2003_2: i128 = {
            let value = state.read_register::<i128>(s_2003_1 as isize);
            tracer.read_register(s_2003_1 as isize, value);
            value
        };
        // D s_2003_3: cmp-lt s_2003_2 s_2003_0
        let s_2003_3: bool = ((s_2003_2) < (s_2003_0));
        // D s_2003_4: write-var gs#402092 <= s_2003_3
        fn_state.gs_402092 = s_2003_3;
        // N s_2003_5: jump b1097
        return block_1097(state, tracer, fn_state);
    }
    fn block_2004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2004_0: const #23s : i
        let s_2004_0: i128 = 23;
        // D s_2004_1: read-var u#31837:u32
        let s_2004_1: u32 = fn_state.u_31837;
        // D s_2004_2: cast zx s_2004_1 -> bv
        let s_2004_2: Bits = Bits::new(s_2004_1 as u128, 32u16);
        // C s_2004_3: const #1s : i64
        let s_2004_3: i64 = 1;
        // C s_2004_4: cast zx s_2004_3 -> i
        let s_2004_4: i128 = (i128::try_from(s_2004_3).unwrap());
        // C s_2004_5: const #0s : i
        let s_2004_5: i128 = 0;
        // C s_2004_6: add s_2004_5 s_2004_4
        let s_2004_6: i128 = (s_2004_5 + s_2004_4);
        // D s_2004_7: bit-extract s_2004_2 s_2004_0 s_2004_6
        let s_2004_7: Bits = (Bits::new(
            ((s_2004_2) >> (s_2004_0)).value(),
            u16::try_from(s_2004_6).unwrap(),
        ));
        // D s_2004_8: cast reint s_2004_7 -> u8
        let s_2004_8: bool = ((s_2004_7.value()) != 0);
        // D s_2004_9: cast zx s_2004_8 -> bv
        let s_2004_9: Bits = Bits::new(s_2004_8 as u128, 1u16);
        // C s_2004_10: const #0u : u8
        let s_2004_10: bool = false;
        // C s_2004_11: cast zx s_2004_10 -> bv
        let s_2004_11: Bits = Bits::new(s_2004_10 as u128, 1u16);
        // D s_2004_12: cmp-eq s_2004_9 s_2004_11
        let s_2004_12: bool = ((s_2004_9) == (s_2004_11));
        // N s_2004_13: branch s_2004_12 b2007 b2005
        if s_2004_12 {
            return block_2007(state, tracer, fn_state);
        } else {
            return block_2005(state, tracer, fn_state);
        };
    }
    fn block_2005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2005_0: const #0u : u8
        let s_2005_0: bool = false;
        // D s_2005_1: write-var gs#402089 <= s_2005_0
        fn_state.gs_402089 = s_2005_0;
        // N s_2005_2: jump b2006
        return block_2006(state, tracer, fn_state);
    }
    fn block_2006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2006_0: read-var gs#402089:u8
        let s_2006_0: bool = fn_state.gs_402089;
        // D s_2006_1: write-var gs#402090 <= s_2006_0
        fn_state.gs_402090 = s_2006_0;
        // N s_2006_2: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_2007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2007_0: const #8s : i
        let s_2007_0: i128 = 8;
        // D s_2007_1: read-var u#31837:u32
        let s_2007_1: u32 = fn_state.u_31837;
        // D s_2007_2: cast zx s_2007_1 -> bv
        let s_2007_2: Bits = Bits::new(s_2007_1 as u128, 32u16);
        // C s_2007_3: const #1s : i64
        let s_2007_3: i64 = 1;
        // C s_2007_4: cast zx s_2007_3 -> i
        let s_2007_4: i128 = (i128::try_from(s_2007_3).unwrap());
        // C s_2007_5: const #3s : i
        let s_2007_5: i128 = 3;
        // C s_2007_6: add s_2007_5 s_2007_4
        let s_2007_6: i128 = (s_2007_5 + s_2007_4);
        // D s_2007_7: bit-extract s_2007_2 s_2007_0 s_2007_6
        let s_2007_7: Bits = (Bits::new(
            ((s_2007_2) >> (s_2007_0)).value(),
            u16::try_from(s_2007_6).unwrap(),
        ));
        // D s_2007_8: cast reint s_2007_7 -> u8
        let s_2007_8: u8 = (s_2007_7.value() as u8);
        // D s_2007_9: cast zx s_2007_8 -> bv
        let s_2007_9: Bits = Bits::new(s_2007_8 as u128, 4u16);
        // C s_2007_10: const #4u : u8
        let s_2007_10: u8 = 4;
        // C s_2007_11: cast zx s_2007_10 -> bv
        let s_2007_11: Bits = Bits::new(s_2007_10 as u128, 4u16);
        // D s_2007_12: cmp-eq s_2007_9 s_2007_11
        let s_2007_12: bool = ((s_2007_9) == (s_2007_11));
        // N s_2007_13: branch s_2007_12 b2010 b2008
        if s_2007_12 {
            return block_2010(state, tracer, fn_state);
        } else {
            return block_2008(state, tracer, fn_state);
        };
    }
    fn block_2008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2008_0: const #0u : u8
        let s_2008_0: bool = false;
        // D s_2008_1: write-var gs#402088 <= s_2008_0
        fn_state.gs_402088 = s_2008_0;
        // N s_2008_2: jump b2009
        return block_2009(state, tracer, fn_state);
    }
    fn block_2009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2009_0: read-var gs#402088:u8
        let s_2009_0: bool = fn_state.gs_402088;
        // D s_2009_1: write-var gs#402089 <= s_2009_0
        fn_state.gs_402089 = s_2009_0;
        // N s_2009_2: jump b2006
        return block_2006(state, tracer, fn_state);
    }
    fn block_2010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2010_0: const #4s : i
        let s_2010_0: i128 = 4;
        // D s_2010_1: read-var u#31837:u32
        let s_2010_1: u32 = fn_state.u_31837;
        // D s_2010_2: cast zx s_2010_1 -> bv
        let s_2010_2: Bits = Bits::new(s_2010_1 as u128, 32u16);
        // C s_2010_3: const #1s : i64
        let s_2010_3: i64 = 1;
        // C s_2010_4: cast zx s_2010_3 -> i
        let s_2010_4: i128 = (i128::try_from(s_2010_3).unwrap());
        // C s_2010_5: const #0s : i
        let s_2010_5: i128 = 0;
        // C s_2010_6: add s_2010_5 s_2010_4
        let s_2010_6: i128 = (s_2010_5 + s_2010_4);
        // D s_2010_7: bit-extract s_2010_2 s_2010_0 s_2010_6
        let s_2010_7: Bits = (Bits::new(
            ((s_2010_2) >> (s_2010_0)).value(),
            u16::try_from(s_2010_6).unwrap(),
        ));
        // D s_2010_8: cast reint s_2010_7 -> u8
        let s_2010_8: bool = ((s_2010_7.value()) != 0);
        // D s_2010_9: cast zx s_2010_8 -> bv
        let s_2010_9: Bits = Bits::new(s_2010_8 as u128, 1u16);
        // C s_2010_10: const #0u : u8
        let s_2010_10: bool = false;
        // C s_2010_11: cast zx s_2010_10 -> bv
        let s_2010_11: Bits = Bits::new(s_2010_10 as u128, 1u16);
        // D s_2010_12: cmp-eq s_2010_9 s_2010_11
        let s_2010_12: bool = ((s_2010_9) == (s_2010_11));
        // D s_2010_13: write-var gs#402088 <= s_2010_12
        fn_state.gs_402088 = s_2010_12;
        // N s_2010_14: jump b2009
        return block_2009(state, tracer, fn_state);
    }
    fn block_2011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2011_0: const #3675s : i
        let s_2011_0: i128 = 3675;
        // C s_2011_1: const #14696u : u32
        let s_2011_1: u32 = 14696;
        // D s_2011_2: read-reg s_2011_1:i
        let s_2011_2: i128 = {
            let value = state.read_register::<i128>(s_2011_1 as isize);
            tracer.read_register(s_2011_1 as isize, value);
            value
        };
        // D s_2011_3: cmp-lt s_2011_2 s_2011_0
        let s_2011_3: bool = ((s_2011_2) < (s_2011_0));
        // D s_2011_4: write-var gs#402066 <= s_2011_3
        fn_state.gs_402066 = s_2011_3;
        // N s_2011_5: jump b1091
        return block_1091(state, tracer, fn_state);
    }
    fn block_2012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2012_0: const #20s : i
        let s_2012_0: i128 = 20;
        // D s_2012_1: read-var u#31830:u32
        let s_2012_1: u32 = fn_state.u_31830;
        // D s_2012_2: cast zx s_2012_1 -> bv
        let s_2012_2: Bits = Bits::new(s_2012_1 as u128, 32u16);
        // C s_2012_3: const #1s : i64
        let s_2012_3: i64 = 1;
        // C s_2012_4: cast zx s_2012_3 -> i
        let s_2012_4: i128 = (i128::try_from(s_2012_3).unwrap());
        // C s_2012_5: const #1s : i
        let s_2012_5: i128 = 1;
        // C s_2012_6: add s_2012_5 s_2012_4
        let s_2012_6: i128 = (s_2012_5 + s_2012_4);
        // D s_2012_7: bit-extract s_2012_2 s_2012_0 s_2012_6
        let s_2012_7: Bits = (Bits::new(
            ((s_2012_2) >> (s_2012_0)).value(),
            u16::try_from(s_2012_6).unwrap(),
        ));
        // D s_2012_8: cast reint s_2012_7 -> u8
        let s_2012_8: u8 = (s_2012_7.value() as u8);
        // D s_2012_9: cast zx s_2012_8 -> bv
        let s_2012_9: Bits = Bits::new(s_2012_8 as u128, 2u16);
        // C s_2012_10: const #3u : u8
        let s_2012_10: u8 = 3;
        // C s_2012_11: cast zx s_2012_10 -> bv
        let s_2012_11: Bits = Bits::new(s_2012_10 as u128, 2u16);
        // D s_2012_12: cmp-eq s_2012_9 s_2012_11
        let s_2012_12: bool = ((s_2012_9) == (s_2012_11));
        // N s_2012_13: branch s_2012_12 b2015 b2013
        if s_2012_12 {
            return block_2015(state, tracer, fn_state);
        } else {
            return block_2013(state, tracer, fn_state);
        };
    }
    fn block_2013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2013_0: const #0u : u8
        let s_2013_0: bool = false;
        // D s_2013_1: write-var gs#402063 <= s_2013_0
        fn_state.gs_402063 = s_2013_0;
        // N s_2013_2: jump b2014
        return block_2014(state, tracer, fn_state);
    }
    fn block_2014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2014_0: read-var gs#402063:u8
        let s_2014_0: bool = fn_state.gs_402063;
        // D s_2014_1: write-var gs#402064 <= s_2014_0
        fn_state.gs_402064 = s_2014_0;
        // N s_2014_2: jump b1089
        return block_1089(state, tracer, fn_state);
    }
    fn block_2015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2015_0: const #16s : i
        let s_2015_0: i128 = 16;
        // D s_2015_1: read-var u#31830:u32
        let s_2015_1: u32 = fn_state.u_31830;
        // D s_2015_2: cast zx s_2015_1 -> bv
        let s_2015_2: Bits = Bits::new(s_2015_1 as u128, 32u16);
        // C s_2015_3: const #1s : i64
        let s_2015_3: i64 = 1;
        // C s_2015_4: cast zx s_2015_3 -> i
        let s_2015_4: i128 = (i128::try_from(s_2015_3).unwrap());
        // C s_2015_5: const #1s : i
        let s_2015_5: i128 = 1;
        // C s_2015_6: add s_2015_5 s_2015_4
        let s_2015_6: i128 = (s_2015_5 + s_2015_4);
        // D s_2015_7: bit-extract s_2015_2 s_2015_0 s_2015_6
        let s_2015_7: Bits = (Bits::new(
            ((s_2015_2) >> (s_2015_0)).value(),
            u16::try_from(s_2015_6).unwrap(),
        ));
        // D s_2015_8: cast reint s_2015_7 -> u8
        let s_2015_8: u8 = (s_2015_7.value() as u8);
        // D s_2015_9: cast zx s_2015_8 -> bv
        let s_2015_9: Bits = Bits::new(s_2015_8 as u128, 2u16);
        // C s_2015_10: const #2u : u8
        let s_2015_10: u8 = 2;
        // C s_2015_11: cast zx s_2015_10 -> bv
        let s_2015_11: Bits = Bits::new(s_2015_10 as u128, 2u16);
        // D s_2015_12: cmp-eq s_2015_9 s_2015_11
        let s_2015_12: bool = ((s_2015_9) == (s_2015_11));
        // N s_2015_13: branch s_2015_12 b2018 b2016
        if s_2015_12 {
            return block_2018(state, tracer, fn_state);
        } else {
            return block_2016(state, tracer, fn_state);
        };
    }
    fn block_2016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2016_0: const #0u : u8
        let s_2016_0: bool = false;
        // D s_2016_1: write-var gs#402062 <= s_2016_0
        fn_state.gs_402062 = s_2016_0;
        // N s_2016_2: jump b2017
        return block_2017(state, tracer, fn_state);
    }
    fn block_2017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2017_0: read-var gs#402062:u8
        let s_2017_0: bool = fn_state.gs_402062;
        // D s_2017_1: write-var gs#402063 <= s_2017_0
        fn_state.gs_402063 = s_2017_0;
        // N s_2017_2: jump b2014
        return block_2014(state, tracer, fn_state);
    }
    fn block_2018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2018_0: const #6s : i
        let s_2018_0: i128 = 6;
        // D s_2018_1: read-var u#31830:u32
        let s_2018_1: u32 = fn_state.u_31830;
        // D s_2018_2: cast zx s_2018_1 -> bv
        let s_2018_2: Bits = Bits::new(s_2018_1 as u128, 32u16);
        // C s_2018_3: const #1s : i64
        let s_2018_3: i64 = 1;
        // C s_2018_4: cast zx s_2018_3 -> i
        let s_2018_4: i128 = (i128::try_from(s_2018_3).unwrap());
        // C s_2018_5: const #5s : i
        let s_2018_5: i128 = 5;
        // C s_2018_6: add s_2018_5 s_2018_4
        let s_2018_6: i128 = (s_2018_5 + s_2018_4);
        // D s_2018_7: bit-extract s_2018_2 s_2018_0 s_2018_6
        let s_2018_7: Bits = (Bits::new(
            ((s_2018_2) >> (s_2018_0)).value(),
            u16::try_from(s_2018_6).unwrap(),
        ));
        // D s_2018_8: cast reint s_2018_7 -> u8
        let s_2018_8: u8 = (s_2018_7.value() as u8);
        // D s_2018_9: cast zx s_2018_8 -> bv
        let s_2018_9: Bits = Bits::new(s_2018_8 as u128, 6u16);
        // C s_2018_10: const #12u : u8
        let s_2018_10: u8 = 12;
        // C s_2018_11: cast zx s_2018_10 -> bv
        let s_2018_11: Bits = Bits::new(s_2018_10 as u128, 6u16);
        // D s_2018_12: cmp-eq s_2018_9 s_2018_11
        let s_2018_12: bool = ((s_2018_9) == (s_2018_11));
        // N s_2018_13: branch s_2018_12 b2021 b2019
        if s_2018_12 {
            return block_2021(state, tracer, fn_state);
        } else {
            return block_2019(state, tracer, fn_state);
        };
    }
    fn block_2019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2019_0: const #0u : u8
        let s_2019_0: bool = false;
        // D s_2019_1: write-var gs#402061 <= s_2019_0
        fn_state.gs_402061 = s_2019_0;
        // N s_2019_2: jump b2020
        return block_2020(state, tracer, fn_state);
    }
    fn block_2020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2020_0: read-var gs#402061:u8
        let s_2020_0: bool = fn_state.gs_402061;
        // D s_2020_1: write-var gs#402062 <= s_2020_0
        fn_state.gs_402062 = s_2020_0;
        // N s_2020_2: jump b2017
        return block_2017(state, tracer, fn_state);
    }
    fn block_2021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2021_0: const #4s : i
        let s_2021_0: i128 = 4;
        // D s_2021_1: read-var u#31830:u32
        let s_2021_1: u32 = fn_state.u_31830;
        // D s_2021_2: cast zx s_2021_1 -> bv
        let s_2021_2: Bits = Bits::new(s_2021_1 as u128, 32u16);
        // C s_2021_3: const #1s : i64
        let s_2021_3: i64 = 1;
        // C s_2021_4: cast zx s_2021_3 -> i
        let s_2021_4: i128 = (i128::try_from(s_2021_3).unwrap());
        // C s_2021_5: const #0s : i
        let s_2021_5: i128 = 0;
        // C s_2021_6: add s_2021_5 s_2021_4
        let s_2021_6: i128 = (s_2021_5 + s_2021_4);
        // D s_2021_7: bit-extract s_2021_2 s_2021_0 s_2021_6
        let s_2021_7: Bits = (Bits::new(
            ((s_2021_2) >> (s_2021_0)).value(),
            u16::try_from(s_2021_6).unwrap(),
        ));
        // D s_2021_8: cast reint s_2021_7 -> u8
        let s_2021_8: bool = ((s_2021_7.value()) != 0);
        // D s_2021_9: cast zx s_2021_8 -> bv
        let s_2021_9: Bits = Bits::new(s_2021_8 as u128, 1u16);
        // C s_2021_10: const #0u : u8
        let s_2021_10: bool = false;
        // C s_2021_11: cast zx s_2021_10 -> bv
        let s_2021_11: Bits = Bits::new(s_2021_10 as u128, 1u16);
        // D s_2021_12: cmp-eq s_2021_9 s_2021_11
        let s_2021_12: bool = ((s_2021_9) == (s_2021_11));
        // D s_2021_13: write-var gs#402061 <= s_2021_12
        fn_state.gs_402061 = s_2021_12;
        // N s_2021_14: jump b2020
        return block_2020(state, tracer, fn_state);
    }
    fn block_2022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2022_0: const #3674s : i
        let s_2022_0: i128 = 3674;
        // C s_2022_1: const #14696u : u32
        let s_2022_1: u32 = 14696;
        // D s_2022_2: read-reg s_2022_1:i
        let s_2022_2: i128 = {
            let value = state.read_register::<i128>(s_2022_1 as isize);
            tracer.read_register(s_2022_1 as isize, value);
            value
        };
        // D s_2022_3: cmp-lt s_2022_2 s_2022_0
        let s_2022_3: bool = ((s_2022_2) < (s_2022_0));
        // D s_2022_4: write-var gs#402035 <= s_2022_3
        fn_state.gs_402035 = s_2022_3;
        // N s_2022_5: jump b1085
        return block_1085(state, tracer, fn_state);
    }
    fn block_2023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2023_0: const #23s : i
        let s_2023_0: i128 = 23;
        // D s_2023_1: read-var u#31822:u32
        let s_2023_1: u32 = fn_state.u_31822;
        // D s_2023_2: cast zx s_2023_1 -> bv
        let s_2023_2: Bits = Bits::new(s_2023_1 as u128, 32u16);
        // C s_2023_3: const #1s : i64
        let s_2023_3: i64 = 1;
        // C s_2023_4: cast zx s_2023_3 -> i
        let s_2023_4: i128 = (i128::try_from(s_2023_3).unwrap());
        // C s_2023_5: const #0s : i
        let s_2023_5: i128 = 0;
        // C s_2023_6: add s_2023_5 s_2023_4
        let s_2023_6: i128 = (s_2023_5 + s_2023_4);
        // D s_2023_7: bit-extract s_2023_2 s_2023_0 s_2023_6
        let s_2023_7: Bits = (Bits::new(
            ((s_2023_2) >> (s_2023_0)).value(),
            u16::try_from(s_2023_6).unwrap(),
        ));
        // D s_2023_8: cast reint s_2023_7 -> u8
        let s_2023_8: bool = ((s_2023_7.value()) != 0);
        // D s_2023_9: cast zx s_2023_8 -> bv
        let s_2023_9: Bits = Bits::new(s_2023_8 as u128, 1u16);
        // C s_2023_10: const #1u : u8
        let s_2023_10: bool = true;
        // C s_2023_11: cast zx s_2023_10 -> bv
        let s_2023_11: Bits = Bits::new(s_2023_10 as u128, 1u16);
        // D s_2023_12: cmp-eq s_2023_9 s_2023_11
        let s_2023_12: bool = ((s_2023_9) == (s_2023_11));
        // N s_2023_13: branch s_2023_12 b2026 b2024
        if s_2023_12 {
            return block_2026(state, tracer, fn_state);
        } else {
            return block_2024(state, tracer, fn_state);
        };
    }
    fn block_2024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2024_0: const #0u : u8
        let s_2024_0: bool = false;
        // D s_2024_1: write-var gs#402032 <= s_2024_0
        fn_state.gs_402032 = s_2024_0;
        // N s_2024_2: jump b2025
        return block_2025(state, tracer, fn_state);
    }
    fn block_2025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2025_0: read-var gs#402032:u8
        let s_2025_0: bool = fn_state.gs_402032;
        // D s_2025_1: write-var gs#402033 <= s_2025_0
        fn_state.gs_402033 = s_2025_0;
        // N s_2025_2: jump b1083
        return block_1083(state, tracer, fn_state);
    }
    fn block_2026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2026_0: const #6s : i
        let s_2026_0: i128 = 6;
        // D s_2026_1: read-var u#31822:u32
        let s_2026_1: u32 = fn_state.u_31822;
        // D s_2026_2: cast zx s_2026_1 -> bv
        let s_2026_2: Bits = Bits::new(s_2026_1 as u128, 32u16);
        // C s_2026_3: const #1s : i64
        let s_2026_3: i64 = 1;
        // C s_2026_4: cast zx s_2026_3 -> i
        let s_2026_4: i128 = (i128::try_from(s_2026_3).unwrap());
        // C s_2026_5: const #5s : i
        let s_2026_5: i128 = 5;
        // C s_2026_6: add s_2026_5 s_2026_4
        let s_2026_6: i128 = (s_2026_5 + s_2026_4);
        // D s_2026_7: bit-extract s_2026_2 s_2026_0 s_2026_6
        let s_2026_7: Bits = (Bits::new(
            ((s_2026_2) >> (s_2026_0)).value(),
            u16::try_from(s_2026_6).unwrap(),
        ));
        // D s_2026_8: cast reint s_2026_7 -> u8
        let s_2026_8: u8 = (s_2026_7.value() as u8);
        // D s_2026_9: cast zx s_2026_8 -> bv
        let s_2026_9: Bits = Bits::new(s_2026_8 as u128, 6u16);
        // C s_2026_10: const #40u : u8
        let s_2026_10: u8 = 40;
        // C s_2026_11: cast zx s_2026_10 -> bv
        let s_2026_11: Bits = Bits::new(s_2026_10 as u128, 6u16);
        // D s_2026_12: cmp-eq s_2026_9 s_2026_11
        let s_2026_12: bool = ((s_2026_9) == (s_2026_11));
        // N s_2026_13: branch s_2026_12 b2029 b2027
        if s_2026_12 {
            return block_2029(state, tracer, fn_state);
        } else {
            return block_2027(state, tracer, fn_state);
        };
    }
    fn block_2027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2027_0: const #0u : u8
        let s_2027_0: bool = false;
        // D s_2027_1: write-var gs#402031 <= s_2027_0
        fn_state.gs_402031 = s_2027_0;
        // N s_2027_2: jump b2028
        return block_2028(state, tracer, fn_state);
    }
    fn block_2028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2028_0: read-var gs#402031:u8
        let s_2028_0: bool = fn_state.gs_402031;
        // D s_2028_1: write-var gs#402032 <= s_2028_0
        fn_state.gs_402032 = s_2028_0;
        // N s_2028_2: jump b2025
        return block_2025(state, tracer, fn_state);
    }
    fn block_2029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2029_0: const #4s : i
        let s_2029_0: i128 = 4;
        // D s_2029_1: read-var u#31822:u32
        let s_2029_1: u32 = fn_state.u_31822;
        // D s_2029_2: cast zx s_2029_1 -> bv
        let s_2029_2: Bits = Bits::new(s_2029_1 as u128, 32u16);
        // C s_2029_3: const #1s : i64
        let s_2029_3: i64 = 1;
        // C s_2029_4: cast zx s_2029_3 -> i
        let s_2029_4: i128 = (i128::try_from(s_2029_3).unwrap());
        // C s_2029_5: const #0s : i
        let s_2029_5: i128 = 0;
        // C s_2029_6: add s_2029_5 s_2029_4
        let s_2029_6: i128 = (s_2029_5 + s_2029_4);
        // D s_2029_7: bit-extract s_2029_2 s_2029_0 s_2029_6
        let s_2029_7: Bits = (Bits::new(
            ((s_2029_2) >> (s_2029_0)).value(),
            u16::try_from(s_2029_6).unwrap(),
        ));
        // D s_2029_8: cast reint s_2029_7 -> u8
        let s_2029_8: bool = ((s_2029_7.value()) != 0);
        // D s_2029_9: cast zx s_2029_8 -> bv
        let s_2029_9: Bits = Bits::new(s_2029_8 as u128, 1u16);
        // C s_2029_10: const #1u : u8
        let s_2029_10: bool = true;
        // C s_2029_11: cast zx s_2029_10 -> bv
        let s_2029_11: Bits = Bits::new(s_2029_10 as u128, 1u16);
        // D s_2029_12: cmp-eq s_2029_9 s_2029_11
        let s_2029_12: bool = ((s_2029_9) == (s_2029_11));
        // D s_2029_13: write-var gs#402031 <= s_2029_12
        fn_state.gs_402031 = s_2029_12;
        // N s_2029_14: jump b2028
        return block_2028(state, tracer, fn_state);
    }
    fn block_2030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2030_0: const #3672s : i
        let s_2030_0: i128 = 3672;
        // C s_2030_1: const #14696u : u32
        let s_2030_1: u32 = 14696;
        // D s_2030_2: read-reg s_2030_1:i
        let s_2030_2: i128 = {
            let value = state.read_register::<i128>(s_2030_1 as isize);
            tracer.read_register(s_2030_1 as isize, value);
            value
        };
        // D s_2030_3: cmp-lt s_2030_2 s_2030_0
        let s_2030_3: bool = ((s_2030_2) < (s_2030_0));
        // D s_2030_4: write-var gs#402005 <= s_2030_3
        fn_state.gs_402005 = s_2030_3;
        // N s_2030_5: jump b1079
        return block_1079(state, tracer, fn_state);
    }
    fn block_2031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2031_0: const #8s : i
        let s_2031_0: i128 = 8;
        // D s_2031_1: read-var u#31813:u32
        let s_2031_1: u32 = fn_state.u_31813;
        // D s_2031_2: cast zx s_2031_1 -> bv
        let s_2031_2: Bits = Bits::new(s_2031_1 as u128, 32u16);
        // C s_2031_3: const #1s : i64
        let s_2031_3: i64 = 1;
        // C s_2031_4: cast zx s_2031_3 -> i
        let s_2031_4: i128 = (i128::try_from(s_2031_3).unwrap());
        // C s_2031_5: const #3s : i
        let s_2031_5: i128 = 3;
        // C s_2031_6: add s_2031_5 s_2031_4
        let s_2031_6: i128 = (s_2031_5 + s_2031_4);
        // D s_2031_7: bit-extract s_2031_2 s_2031_0 s_2031_6
        let s_2031_7: Bits = (Bits::new(
            ((s_2031_2) >> (s_2031_0)).value(),
            u16::try_from(s_2031_6).unwrap(),
        ));
        // D s_2031_8: cast reint s_2031_7 -> u8
        let s_2031_8: u8 = (s_2031_7.value() as u8);
        // D s_2031_9: cast zx s_2031_8 -> bv
        let s_2031_9: Bits = Bits::new(s_2031_8 as u128, 4u16);
        // C s_2031_10: const #5u : u8
        let s_2031_10: u8 = 5;
        // C s_2031_11: cast zx s_2031_10 -> bv
        let s_2031_11: Bits = Bits::new(s_2031_10 as u128, 4u16);
        // D s_2031_12: cmp-eq s_2031_9 s_2031_11
        let s_2031_12: bool = ((s_2031_9) == (s_2031_11));
        // N s_2031_13: branch s_2031_12 b2034 b2032
        if s_2031_12 {
            return block_2034(state, tracer, fn_state);
        } else {
            return block_2032(state, tracer, fn_state);
        };
    }
    fn block_2032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2032_0: const #0u : u8
        let s_2032_0: bool = false;
        // D s_2032_1: write-var gs#402002 <= s_2032_0
        fn_state.gs_402002 = s_2032_0;
        // N s_2032_2: jump b2033
        return block_2033(state, tracer, fn_state);
    }
    fn block_2033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2033_0: read-var gs#402002:u8
        let s_2033_0: bool = fn_state.gs_402002;
        // D s_2033_1: write-var gs#402003 <= s_2033_0
        fn_state.gs_402003 = s_2033_0;
        // N s_2033_2: jump b1077
        return block_1077(state, tracer, fn_state);
    }
    fn block_2034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2034_0: const #4s : i
        let s_2034_0: i128 = 4;
        // D s_2034_1: read-var u#31813:u32
        let s_2034_1: u32 = fn_state.u_31813;
        // D s_2034_2: cast zx s_2034_1 -> bv
        let s_2034_2: Bits = Bits::new(s_2034_1 as u128, 32u16);
        // C s_2034_3: const #1s : i64
        let s_2034_3: i64 = 1;
        // C s_2034_4: cast zx s_2034_3 -> i
        let s_2034_4: i128 = (i128::try_from(s_2034_3).unwrap());
        // C s_2034_5: const #0s : i
        let s_2034_5: i128 = 0;
        // C s_2034_6: add s_2034_5 s_2034_4
        let s_2034_6: i128 = (s_2034_5 + s_2034_4);
        // D s_2034_7: bit-extract s_2034_2 s_2034_0 s_2034_6
        let s_2034_7: Bits = (Bits::new(
            ((s_2034_2) >> (s_2034_0)).value(),
            u16::try_from(s_2034_6).unwrap(),
        ));
        // D s_2034_8: cast reint s_2034_7 -> u8
        let s_2034_8: bool = ((s_2034_7.value()) != 0);
        // D s_2034_9: cast zx s_2034_8 -> bv
        let s_2034_9: Bits = Bits::new(s_2034_8 as u128, 1u16);
        // C s_2034_10: const #1u : u8
        let s_2034_10: bool = true;
        // C s_2034_11: cast zx s_2034_10 -> bv
        let s_2034_11: Bits = Bits::new(s_2034_10 as u128, 1u16);
        // D s_2034_12: cmp-eq s_2034_9 s_2034_11
        let s_2034_12: bool = ((s_2034_9) == (s_2034_11));
        // D s_2034_13: write-var gs#402002 <= s_2034_12
        fn_state.gs_402002 = s_2034_12;
        // N s_2034_14: jump b2033
        return block_2033(state, tracer, fn_state);
    }
    fn block_2035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2035_0: const #3670s : i
        let s_2035_0: i128 = 3670;
        // C s_2035_1: const #14696u : u32
        let s_2035_1: u32 = 14696;
        // D s_2035_2: read-reg s_2035_1:i
        let s_2035_2: i128 = {
            let value = state.read_register::<i128>(s_2035_1 as isize);
            tracer.read_register(s_2035_1 as isize, value);
            value
        };
        // D s_2035_3: cmp-lt s_2035_2 s_2035_0
        let s_2035_3: bool = ((s_2035_2) < (s_2035_0));
        // D s_2035_4: write-var gs#401978 <= s_2035_3
        fn_state.gs_401978 = s_2035_3;
        // N s_2035_5: jump b1073
        return block_1073(state, tracer, fn_state);
    }
    fn block_2036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2036_0: const #8s : i
        let s_2036_0: i128 = 8;
        // D s_2036_1: read-var u#31804:u32
        let s_2036_1: u32 = fn_state.u_31804;
        // D s_2036_2: cast zx s_2036_1 -> bv
        let s_2036_2: Bits = Bits::new(s_2036_1 as u128, 32u16);
        // C s_2036_3: const #1s : i64
        let s_2036_3: i64 = 1;
        // C s_2036_4: cast zx s_2036_3 -> i
        let s_2036_4: i128 = (i128::try_from(s_2036_3).unwrap());
        // C s_2036_5: const #3s : i
        let s_2036_5: i128 = 3;
        // C s_2036_6: add s_2036_5 s_2036_4
        let s_2036_6: i128 = (s_2036_5 + s_2036_4);
        // D s_2036_7: bit-extract s_2036_2 s_2036_0 s_2036_6
        let s_2036_7: Bits = (Bits::new(
            ((s_2036_2) >> (s_2036_0)).value(),
            u16::try_from(s_2036_6).unwrap(),
        ));
        // D s_2036_8: cast reint s_2036_7 -> u8
        let s_2036_8: u8 = (s_2036_7.value() as u8);
        // D s_2036_9: cast zx s_2036_8 -> bv
        let s_2036_9: Bits = Bits::new(s_2036_8 as u128, 4u16);
        // C s_2036_10: const #6u : u8
        let s_2036_10: u8 = 6;
        // C s_2036_11: cast zx s_2036_10 -> bv
        let s_2036_11: Bits = Bits::new(s_2036_10 as u128, 4u16);
        // D s_2036_12: cmp-eq s_2036_9 s_2036_11
        let s_2036_12: bool = ((s_2036_9) == (s_2036_11));
        // N s_2036_13: branch s_2036_12 b2039 b2037
        if s_2036_12 {
            return block_2039(state, tracer, fn_state);
        } else {
            return block_2037(state, tracer, fn_state);
        };
    }
    fn block_2037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2037_0: const #0u : u8
        let s_2037_0: bool = false;
        // D s_2037_1: write-var gs#401975 <= s_2037_0
        fn_state.gs_401975 = s_2037_0;
        // N s_2037_2: jump b2038
        return block_2038(state, tracer, fn_state);
    }
    fn block_2038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2038_0: read-var gs#401975:u8
        let s_2038_0: bool = fn_state.gs_401975;
        // D s_2038_1: write-var gs#401976 <= s_2038_0
        fn_state.gs_401976 = s_2038_0;
        // N s_2038_2: jump b1071
        return block_1071(state, tracer, fn_state);
    }
    fn block_2039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2039_0: const #6s : i
        let s_2039_0: i128 = 6;
        // D s_2039_1: read-var u#31804:u32
        let s_2039_1: u32 = fn_state.u_31804;
        // D s_2039_2: cast zx s_2039_1 -> bv
        let s_2039_2: Bits = Bits::new(s_2039_1 as u128, 32u16);
        // C s_2039_3: const #1s : i64
        let s_2039_3: i64 = 1;
        // C s_2039_4: cast zx s_2039_3 -> i
        let s_2039_4: i128 = (i128::try_from(s_2039_3).unwrap());
        // C s_2039_5: const #0s : i
        let s_2039_5: i128 = 0;
        // C s_2039_6: add s_2039_5 s_2039_4
        let s_2039_6: i128 = (s_2039_5 + s_2039_4);
        // D s_2039_7: bit-extract s_2039_2 s_2039_0 s_2039_6
        let s_2039_7: Bits = (Bits::new(
            ((s_2039_2) >> (s_2039_0)).value(),
            u16::try_from(s_2039_6).unwrap(),
        ));
        // D s_2039_8: cast reint s_2039_7 -> u8
        let s_2039_8: bool = ((s_2039_7.value()) != 0);
        // D s_2039_9: cast zx s_2039_8 -> bv
        let s_2039_9: Bits = Bits::new(s_2039_8 as u128, 1u16);
        // C s_2039_10: const #0u : u8
        let s_2039_10: bool = false;
        // C s_2039_11: cast zx s_2039_10 -> bv
        let s_2039_11: Bits = Bits::new(s_2039_10 as u128, 1u16);
        // D s_2039_12: cmp-eq s_2039_9 s_2039_11
        let s_2039_12: bool = ((s_2039_9) == (s_2039_11));
        // N s_2039_13: branch s_2039_12 b2042 b2040
        if s_2039_12 {
            return block_2042(state, tracer, fn_state);
        } else {
            return block_2040(state, tracer, fn_state);
        };
    }
    fn block_2040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2040_0: const #0u : u8
        let s_2040_0: bool = false;
        // D s_2040_1: write-var gs#401974 <= s_2040_0
        fn_state.gs_401974 = s_2040_0;
        // N s_2040_2: jump b2041
        return block_2041(state, tracer, fn_state);
    }
    fn block_2041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2041_0: read-var gs#401974:u8
        let s_2041_0: bool = fn_state.gs_401974;
        // D s_2041_1: write-var gs#401975 <= s_2041_0
        fn_state.gs_401975 = s_2041_0;
        // N s_2041_2: jump b2038
        return block_2038(state, tracer, fn_state);
    }
    fn block_2042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2042_0: const #4s : i
        let s_2042_0: i128 = 4;
        // D s_2042_1: read-var u#31804:u32
        let s_2042_1: u32 = fn_state.u_31804;
        // D s_2042_2: cast zx s_2042_1 -> bv
        let s_2042_2: Bits = Bits::new(s_2042_1 as u128, 32u16);
        // C s_2042_3: const #1s : i64
        let s_2042_3: i64 = 1;
        // C s_2042_4: cast zx s_2042_3 -> i
        let s_2042_4: i128 = (i128::try_from(s_2042_3).unwrap());
        // C s_2042_5: const #0s : i
        let s_2042_5: i128 = 0;
        // C s_2042_6: add s_2042_5 s_2042_4
        let s_2042_6: i128 = (s_2042_5 + s_2042_4);
        // D s_2042_7: bit-extract s_2042_2 s_2042_0 s_2042_6
        let s_2042_7: Bits = (Bits::new(
            ((s_2042_2) >> (s_2042_0)).value(),
            u16::try_from(s_2042_6).unwrap(),
        ));
        // D s_2042_8: cast reint s_2042_7 -> u8
        let s_2042_8: bool = ((s_2042_7.value()) != 0);
        // D s_2042_9: cast zx s_2042_8 -> bv
        let s_2042_9: Bits = Bits::new(s_2042_8 as u128, 1u16);
        // C s_2042_10: const #0u : u8
        let s_2042_10: bool = false;
        // C s_2042_11: cast zx s_2042_10 -> bv
        let s_2042_11: Bits = Bits::new(s_2042_10 as u128, 1u16);
        // D s_2042_12: cmp-eq s_2042_9 s_2042_11
        let s_2042_12: bool = ((s_2042_9) == (s_2042_11));
        // D s_2042_13: write-var gs#401974 <= s_2042_12
        fn_state.gs_401974 = s_2042_12;
        // N s_2042_14: jump b2041
        return block_2041(state, tracer, fn_state);
    }
    fn block_2043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2043_0: const #3668s : i
        let s_2043_0: i128 = 3668;
        // C s_2043_1: const #14696u : u32
        let s_2043_1: u32 = 14696;
        // D s_2043_2: read-reg s_2043_1:i
        let s_2043_2: i128 = {
            let value = state.read_register::<i128>(s_2043_1 as isize);
            tracer.read_register(s_2043_1 as isize, value);
            value
        };
        // D s_2043_3: cmp-lt s_2043_2 s_2043_0
        let s_2043_3: bool = ((s_2043_2) < (s_2043_0));
        // D s_2043_4: write-var gs#401946 <= s_2043_3
        fn_state.gs_401946 = s_2043_3;
        // N s_2043_5: jump b1067
        return block_1067(state, tracer, fn_state);
    }
    fn block_2044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2044_0: const #23s : i
        let s_2044_0: i128 = 23;
        // D s_2044_1: read-var u#31794:u32
        let s_2044_1: u32 = fn_state.u_31794;
        // D s_2044_2: cast zx s_2044_1 -> bv
        let s_2044_2: Bits = Bits::new(s_2044_1 as u128, 32u16);
        // C s_2044_3: const #1s : i64
        let s_2044_3: i64 = 1;
        // C s_2044_4: cast zx s_2044_3 -> i
        let s_2044_4: i128 = (i128::try_from(s_2044_3).unwrap());
        // C s_2044_5: const #0s : i
        let s_2044_5: i128 = 0;
        // C s_2044_6: add s_2044_5 s_2044_4
        let s_2044_6: i128 = (s_2044_5 + s_2044_4);
        // D s_2044_7: bit-extract s_2044_2 s_2044_0 s_2044_6
        let s_2044_7: Bits = (Bits::new(
            ((s_2044_2) >> (s_2044_0)).value(),
            u16::try_from(s_2044_6).unwrap(),
        ));
        // D s_2044_8: cast reint s_2044_7 -> u8
        let s_2044_8: bool = ((s_2044_7.value()) != 0);
        // D s_2044_9: cast zx s_2044_8 -> bv
        let s_2044_9: Bits = Bits::new(s_2044_8 as u128, 1u16);
        // C s_2044_10: const #1u : u8
        let s_2044_10: bool = true;
        // C s_2044_11: cast zx s_2044_10 -> bv
        let s_2044_11: Bits = Bits::new(s_2044_10 as u128, 1u16);
        // D s_2044_12: cmp-eq s_2044_9 s_2044_11
        let s_2044_12: bool = ((s_2044_9) == (s_2044_11));
        // N s_2044_13: branch s_2044_12 b2047 b2045
        if s_2044_12 {
            return block_2047(state, tracer, fn_state);
        } else {
            return block_2045(state, tracer, fn_state);
        };
    }
    fn block_2045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2045_0: const #0u : u8
        let s_2045_0: bool = false;
        // D s_2045_1: write-var gs#401943 <= s_2045_0
        fn_state.gs_401943 = s_2045_0;
        // N s_2045_2: jump b2046
        return block_2046(state, tracer, fn_state);
    }
    fn block_2046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2046_0: read-var gs#401943:u8
        let s_2046_0: bool = fn_state.gs_401943;
        // D s_2046_1: write-var gs#401944 <= s_2046_0
        fn_state.gs_401944 = s_2046_0;
        // N s_2046_2: jump b1065
        return block_1065(state, tracer, fn_state);
    }
    fn block_2047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2047_0: const #8s : i
        let s_2047_0: i128 = 8;
        // D s_2047_1: read-var u#31794:u32
        let s_2047_1: u32 = fn_state.u_31794;
        // D s_2047_2: cast zx s_2047_1 -> bv
        let s_2047_2: Bits = Bits::new(s_2047_1 as u128, 32u16);
        // C s_2047_3: const #1s : i64
        let s_2047_3: i64 = 1;
        // C s_2047_4: cast zx s_2047_3 -> i
        let s_2047_4: i128 = (i128::try_from(s_2047_3).unwrap());
        // C s_2047_5: const #3s : i
        let s_2047_5: i128 = 3;
        // C s_2047_6: add s_2047_5 s_2047_4
        let s_2047_6: i128 = (s_2047_5 + s_2047_4);
        // D s_2047_7: bit-extract s_2047_2 s_2047_0 s_2047_6
        let s_2047_7: Bits = (Bits::new(
            ((s_2047_2) >> (s_2047_0)).value(),
            u16::try_from(s_2047_6).unwrap(),
        ));
        // D s_2047_8: cast reint s_2047_7 -> u8
        let s_2047_8: u8 = (s_2047_7.value() as u8);
        // D s_2047_9: cast zx s_2047_8 -> bv
        let s_2047_9: Bits = Bits::new(s_2047_8 as u128, 4u16);
        // C s_2047_10: const #3u : u8
        let s_2047_10: u8 = 3;
        // C s_2047_11: cast zx s_2047_10 -> bv
        let s_2047_11: Bits = Bits::new(s_2047_10 as u128, 4u16);
        // D s_2047_12: cmp-eq s_2047_9 s_2047_11
        let s_2047_12: bool = ((s_2047_9) == (s_2047_11));
        // N s_2047_13: branch s_2047_12 b2050 b2048
        if s_2047_12 {
            return block_2050(state, tracer, fn_state);
        } else {
            return block_2048(state, tracer, fn_state);
        };
    }
    fn block_2048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2048_0: const #0u : u8
        let s_2048_0: bool = false;
        // D s_2048_1: write-var gs#401942 <= s_2048_0
        fn_state.gs_401942 = s_2048_0;
        // N s_2048_2: jump b2049
        return block_2049(state, tracer, fn_state);
    }
    fn block_2049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2049_0: read-var gs#401942:u8
        let s_2049_0: bool = fn_state.gs_401942;
        // D s_2049_1: write-var gs#401943 <= s_2049_0
        fn_state.gs_401943 = s_2049_0;
        // N s_2049_2: jump b2046
        return block_2046(state, tracer, fn_state);
    }
    fn block_2050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2050_0: const #4s : i
        let s_2050_0: i128 = 4;
        // D s_2050_1: read-var u#31794:u32
        let s_2050_1: u32 = fn_state.u_31794;
        // D s_2050_2: cast zx s_2050_1 -> bv
        let s_2050_2: Bits = Bits::new(s_2050_1 as u128, 32u16);
        // C s_2050_3: const #1s : i64
        let s_2050_3: i64 = 1;
        // C s_2050_4: cast zx s_2050_3 -> i
        let s_2050_4: i128 = (i128::try_from(s_2050_3).unwrap());
        // C s_2050_5: const #0s : i
        let s_2050_5: i128 = 0;
        // C s_2050_6: add s_2050_5 s_2050_4
        let s_2050_6: i128 = (s_2050_5 + s_2050_4);
        // D s_2050_7: bit-extract s_2050_2 s_2050_0 s_2050_6
        let s_2050_7: Bits = (Bits::new(
            ((s_2050_2) >> (s_2050_0)).value(),
            u16::try_from(s_2050_6).unwrap(),
        ));
        // D s_2050_8: cast reint s_2050_7 -> u8
        let s_2050_8: bool = ((s_2050_7.value()) != 0);
        // D s_2050_9: cast zx s_2050_8 -> bv
        let s_2050_9: Bits = Bits::new(s_2050_8 as u128, 1u16);
        // C s_2050_10: const #1u : u8
        let s_2050_10: bool = true;
        // C s_2050_11: cast zx s_2050_10 -> bv
        let s_2050_11: Bits = Bits::new(s_2050_10 as u128, 1u16);
        // D s_2050_12: cmp-eq s_2050_9 s_2050_11
        let s_2050_12: bool = ((s_2050_9) == (s_2050_11));
        // D s_2050_13: write-var gs#401942 <= s_2050_12
        fn_state.gs_401942 = s_2050_12;
        // N s_2050_14: jump b2049
        return block_2049(state, tracer, fn_state);
    }
    fn block_2051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2051_0: const #3666s : i
        let s_2051_0: i128 = 3666;
        // C s_2051_1: const #14696u : u32
        let s_2051_1: u32 = 14696;
        // D s_2051_2: read-reg s_2051_1:i
        let s_2051_2: i128 = {
            let value = state.read_register::<i128>(s_2051_1 as isize);
            tracer.read_register(s_2051_1 as isize, value);
            value
        };
        // D s_2051_3: cmp-lt s_2051_2 s_2051_0
        let s_2051_3: bool = ((s_2051_2) < (s_2051_0));
        // D s_2051_4: write-var gs#401914 <= s_2051_3
        fn_state.gs_401914 = s_2051_3;
        // N s_2051_5: jump b1061
        return block_1061(state, tracer, fn_state);
    }
    fn block_2052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2052_0: const #21s : i
        let s_2052_0: i128 = 21;
        // D s_2052_1: read-var u#31784:u32
        let s_2052_1: u32 = fn_state.u_31784;
        // D s_2052_2: cast zx s_2052_1 -> bv
        let s_2052_2: Bits = Bits::new(s_2052_1 as u128, 32u16);
        // C s_2052_3: const #1s : i64
        let s_2052_3: i64 = 1;
        // C s_2052_4: cast zx s_2052_3 -> i
        let s_2052_4: i128 = (i128::try_from(s_2052_3).unwrap());
        // C s_2052_5: const #0s : i
        let s_2052_5: i128 = 0;
        // C s_2052_6: add s_2052_5 s_2052_4
        let s_2052_6: i128 = (s_2052_5 + s_2052_4);
        // D s_2052_7: bit-extract s_2052_2 s_2052_0 s_2052_6
        let s_2052_7: Bits = (Bits::new(
            ((s_2052_2) >> (s_2052_0)).value(),
            u16::try_from(s_2052_6).unwrap(),
        ));
        // D s_2052_8: cast reint s_2052_7 -> u8
        let s_2052_8: bool = ((s_2052_7.value()) != 0);
        // D s_2052_9: cast zx s_2052_8 -> bv
        let s_2052_9: Bits = Bits::new(s_2052_8 as u128, 1u16);
        // C s_2052_10: const #1u : u8
        let s_2052_10: bool = true;
        // C s_2052_11: cast zx s_2052_10 -> bv
        let s_2052_11: Bits = Bits::new(s_2052_10 as u128, 1u16);
        // D s_2052_12: cmp-eq s_2052_9 s_2052_11
        let s_2052_12: bool = ((s_2052_9) == (s_2052_11));
        // N s_2052_13: branch s_2052_12 b2055 b2053
        if s_2052_12 {
            return block_2055(state, tracer, fn_state);
        } else {
            return block_2053(state, tracer, fn_state);
        };
    }
    fn block_2053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2053_0: const #0u : u8
        let s_2053_0: bool = false;
        // D s_2053_1: write-var gs#401911 <= s_2053_0
        fn_state.gs_401911 = s_2053_0;
        // N s_2053_2: jump b2054
        return block_2054(state, tracer, fn_state);
    }
    fn block_2054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2054_0: read-var gs#401911:u8
        let s_2054_0: bool = fn_state.gs_401911;
        // D s_2054_1: write-var gs#401912 <= s_2054_0
        fn_state.gs_401912 = s_2054_0;
        // N s_2054_2: jump b1059
        return block_1059(state, tracer, fn_state);
    }
    fn block_2055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2055_0: const #8s : i
        let s_2055_0: i128 = 8;
        // D s_2055_1: read-var u#31784:u32
        let s_2055_1: u32 = fn_state.u_31784;
        // D s_2055_2: cast zx s_2055_1 -> bv
        let s_2055_2: Bits = Bits::new(s_2055_1 as u128, 32u16);
        // C s_2055_3: const #1s : i64
        let s_2055_3: i64 = 1;
        // C s_2055_4: cast zx s_2055_3 -> i
        let s_2055_4: i128 = (i128::try_from(s_2055_3).unwrap());
        // C s_2055_5: const #3s : i
        let s_2055_5: i128 = 3;
        // C s_2055_6: add s_2055_5 s_2055_4
        let s_2055_6: i128 = (s_2055_5 + s_2055_4);
        // D s_2055_7: bit-extract s_2055_2 s_2055_0 s_2055_6
        let s_2055_7: Bits = (Bits::new(
            ((s_2055_2) >> (s_2055_0)).value(),
            u16::try_from(s_2055_6).unwrap(),
        ));
        // D s_2055_8: cast reint s_2055_7 -> u8
        let s_2055_8: u8 = (s_2055_7.value() as u8);
        // D s_2055_9: cast zx s_2055_8 -> bv
        let s_2055_9: Bits = Bits::new(s_2055_8 as u128, 4u16);
        // C s_2055_10: const #15u : u8
        let s_2055_10: u8 = 15;
        // C s_2055_11: cast zx s_2055_10 -> bv
        let s_2055_11: Bits = Bits::new(s_2055_10 as u128, 4u16);
        // D s_2055_12: cmp-eq s_2055_9 s_2055_11
        let s_2055_12: bool = ((s_2055_9) == (s_2055_11));
        // N s_2055_13: branch s_2055_12 b2058 b2056
        if s_2055_12 {
            return block_2058(state, tracer, fn_state);
        } else {
            return block_2056(state, tracer, fn_state);
        };
    }
    fn block_2056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2056_0: const #0u : u8
        let s_2056_0: bool = false;
        // D s_2056_1: write-var gs#401910 <= s_2056_0
        fn_state.gs_401910 = s_2056_0;
        // N s_2056_2: jump b2057
        return block_2057(state, tracer, fn_state);
    }
    fn block_2057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2057_0: read-var gs#401910:u8
        let s_2057_0: bool = fn_state.gs_401910;
        // D s_2057_1: write-var gs#401911 <= s_2057_0
        fn_state.gs_401911 = s_2057_0;
        // N s_2057_2: jump b2054
        return block_2054(state, tracer, fn_state);
    }
    fn block_2058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2058_0: const #4s : i
        let s_2058_0: i128 = 4;
        // D s_2058_1: read-var u#31784:u32
        let s_2058_1: u32 = fn_state.u_31784;
        // D s_2058_2: cast zx s_2058_1 -> bv
        let s_2058_2: Bits = Bits::new(s_2058_1 as u128, 32u16);
        // C s_2058_3: const #1s : i64
        let s_2058_3: i64 = 1;
        // C s_2058_4: cast zx s_2058_3 -> i
        let s_2058_4: i128 = (i128::try_from(s_2058_3).unwrap());
        // C s_2058_5: const #0s : i
        let s_2058_5: i128 = 0;
        // C s_2058_6: add s_2058_5 s_2058_4
        let s_2058_6: i128 = (s_2058_5 + s_2058_4);
        // D s_2058_7: bit-extract s_2058_2 s_2058_0 s_2058_6
        let s_2058_7: Bits = (Bits::new(
            ((s_2058_2) >> (s_2058_0)).value(),
            u16::try_from(s_2058_6).unwrap(),
        ));
        // D s_2058_8: cast reint s_2058_7 -> u8
        let s_2058_8: bool = ((s_2058_7.value()) != 0);
        // D s_2058_9: cast zx s_2058_8 -> bv
        let s_2058_9: Bits = Bits::new(s_2058_8 as u128, 1u16);
        // C s_2058_10: const #1u : u8
        let s_2058_10: bool = true;
        // C s_2058_11: cast zx s_2058_10 -> bv
        let s_2058_11: Bits = Bits::new(s_2058_10 as u128, 1u16);
        // D s_2058_12: cmp-eq s_2058_9 s_2058_11
        let s_2058_12: bool = ((s_2058_9) == (s_2058_11));
        // D s_2058_13: write-var gs#401910 <= s_2058_12
        fn_state.gs_401910 = s_2058_12;
        // N s_2058_14: jump b2057
        return block_2057(state, tracer, fn_state);
    }
    fn block_2059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2059_0: const #3664s : i
        let s_2059_0: i128 = 3664;
        // C s_2059_1: const #14696u : u32
        let s_2059_1: u32 = 14696;
        // D s_2059_2: read-reg s_2059_1:i
        let s_2059_2: i128 = {
            let value = state.read_register::<i128>(s_2059_1 as isize);
            tracer.read_register(s_2059_1 as isize, value);
            value
        };
        // D s_2059_3: cmp-lt s_2059_2 s_2059_0
        let s_2059_3: bool = ((s_2059_2) < (s_2059_0));
        // D s_2059_4: write-var gs#401884 <= s_2059_3
        fn_state.gs_401884 = s_2059_3;
        // N s_2059_5: jump b1055
        return block_1055(state, tracer, fn_state);
    }
    fn block_2060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2060_0: const #20s : i
        let s_2060_0: i128 = 20;
        // D s_2060_1: read-var u#31775:u32
        let s_2060_1: u32 = fn_state.u_31775;
        // D s_2060_2: cast zx s_2060_1 -> bv
        let s_2060_2: Bits = Bits::new(s_2060_1 as u128, 32u16);
        // C s_2060_3: const #1s : i64
        let s_2060_3: i64 = 1;
        // C s_2060_4: cast zx s_2060_3 -> i
        let s_2060_4: i128 = (i128::try_from(s_2060_3).unwrap());
        // C s_2060_5: const #1s : i
        let s_2060_5: i128 = 1;
        // C s_2060_6: add s_2060_5 s_2060_4
        let s_2060_6: i128 = (s_2060_5 + s_2060_4);
        // D s_2060_7: bit-extract s_2060_2 s_2060_0 s_2060_6
        let s_2060_7: Bits = (Bits::new(
            ((s_2060_2) >> (s_2060_0)).value(),
            u16::try_from(s_2060_6).unwrap(),
        ));
        // D s_2060_8: cast reint s_2060_7 -> u8
        let s_2060_8: u8 = (s_2060_7.value() as u8);
        // D s_2060_9: cast zx s_2060_8 -> bv
        let s_2060_9: Bits = Bits::new(s_2060_8 as u128, 2u16);
        // C s_2060_10: const #3u : u8
        let s_2060_10: u8 = 3;
        // C s_2060_11: cast zx s_2060_10 -> bv
        let s_2060_11: Bits = Bits::new(s_2060_10 as u128, 2u16);
        // D s_2060_12: cmp-eq s_2060_9 s_2060_11
        let s_2060_12: bool = ((s_2060_9) == (s_2060_11));
        // N s_2060_13: branch s_2060_12 b2063 b2061
        if s_2060_12 {
            return block_2063(state, tracer, fn_state);
        } else {
            return block_2061(state, tracer, fn_state);
        };
    }
    fn block_2061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2061_0: const #0u : u8
        let s_2061_0: bool = false;
        // D s_2061_1: write-var gs#401881 <= s_2061_0
        fn_state.gs_401881 = s_2061_0;
        // N s_2061_2: jump b2062
        return block_2062(state, tracer, fn_state);
    }
    fn block_2062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2062_0: read-var gs#401881:u8
        let s_2062_0: bool = fn_state.gs_401881;
        // D s_2062_1: write-var gs#401882 <= s_2062_0
        fn_state.gs_401882 = s_2062_0;
        // N s_2062_2: jump b1053
        return block_1053(state, tracer, fn_state);
    }
    fn block_2063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2063_0: const #16s : i
        let s_2063_0: i128 = 16;
        // D s_2063_1: read-var u#31775:u32
        let s_2063_1: u32 = fn_state.u_31775;
        // D s_2063_2: cast zx s_2063_1 -> bv
        let s_2063_2: Bits = Bits::new(s_2063_1 as u128, 32u16);
        // C s_2063_3: const #1s : i64
        let s_2063_3: i64 = 1;
        // C s_2063_4: cast zx s_2063_3 -> i
        let s_2063_4: i128 = (i128::try_from(s_2063_3).unwrap());
        // C s_2063_5: const #1s : i
        let s_2063_5: i128 = 1;
        // C s_2063_6: add s_2063_5 s_2063_4
        let s_2063_6: i128 = (s_2063_5 + s_2063_4);
        // D s_2063_7: bit-extract s_2063_2 s_2063_0 s_2063_6
        let s_2063_7: Bits = (Bits::new(
            ((s_2063_2) >> (s_2063_0)).value(),
            u16::try_from(s_2063_6).unwrap(),
        ));
        // D s_2063_8: cast reint s_2063_7 -> u8
        let s_2063_8: u8 = (s_2063_7.value() as u8);
        // D s_2063_9: cast zx s_2063_8 -> bv
        let s_2063_9: Bits = Bits::new(s_2063_8 as u128, 2u16);
        // C s_2063_10: const #3u : u8
        let s_2063_10: u8 = 3;
        // C s_2063_11: cast zx s_2063_10 -> bv
        let s_2063_11: Bits = Bits::new(s_2063_10 as u128, 2u16);
        // D s_2063_12: cmp-eq s_2063_9 s_2063_11
        let s_2063_12: bool = ((s_2063_9) == (s_2063_11));
        // N s_2063_13: branch s_2063_12 b2066 b2064
        if s_2063_12 {
            return block_2066(state, tracer, fn_state);
        } else {
            return block_2064(state, tracer, fn_state);
        };
    }
    fn block_2064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2064_0: const #0u : u8
        let s_2064_0: bool = false;
        // D s_2064_1: write-var gs#401880 <= s_2064_0
        fn_state.gs_401880 = s_2064_0;
        // N s_2064_2: jump b2065
        return block_2065(state, tracer, fn_state);
    }
    fn block_2065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2065_0: read-var gs#401880:u8
        let s_2065_0: bool = fn_state.gs_401880;
        // D s_2065_1: write-var gs#401881 <= s_2065_0
        fn_state.gs_401881 = s_2065_0;
        // N s_2065_2: jump b2062
        return block_2062(state, tracer, fn_state);
    }
    fn block_2066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2066_0: const #9s : i
        let s_2066_0: i128 = 9;
        // D s_2066_1: read-var u#31775:u32
        let s_2066_1: u32 = fn_state.u_31775;
        // D s_2066_2: cast zx s_2066_1 -> bv
        let s_2066_2: Bits = Bits::new(s_2066_1 as u128, 32u16);
        // C s_2066_3: const #1s : i64
        let s_2066_3: i64 = 1;
        // C s_2066_4: cast zx s_2066_3 -> i
        let s_2066_4: i128 = (i128::try_from(s_2066_3).unwrap());
        // C s_2066_5: const #2s : i
        let s_2066_5: i128 = 2;
        // C s_2066_6: add s_2066_5 s_2066_4
        let s_2066_6: i128 = (s_2066_5 + s_2066_4);
        // D s_2066_7: bit-extract s_2066_2 s_2066_0 s_2066_6
        let s_2066_7: Bits = (Bits::new(
            ((s_2066_2) >> (s_2066_0)).value(),
            u16::try_from(s_2066_6).unwrap(),
        ));
        // D s_2066_8: cast reint s_2066_7 -> u8
        let s_2066_8: u8 = (s_2066_7.value() as u8);
        // D s_2066_9: cast zx s_2066_8 -> bv
        let s_2066_9: Bits = Bits::new(s_2066_8 as u128, 3u16);
        // C s_2066_10: const #2u : u8
        let s_2066_10: u8 = 2;
        // C s_2066_11: cast zx s_2066_10 -> bv
        let s_2066_11: Bits = Bits::new(s_2066_10 as u128, 3u16);
        // D s_2066_12: cmp-eq s_2066_9 s_2066_11
        let s_2066_12: bool = ((s_2066_9) == (s_2066_11));
        // N s_2066_13: branch s_2066_12 b2069 b2067
        if s_2066_12 {
            return block_2069(state, tracer, fn_state);
        } else {
            return block_2067(state, tracer, fn_state);
        };
    }
    fn block_2067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2067_0: const #0u : u8
        let s_2067_0: bool = false;
        // D s_2067_1: write-var gs#401879 <= s_2067_0
        fn_state.gs_401879 = s_2067_0;
        // N s_2067_2: jump b2068
        return block_2068(state, tracer, fn_state);
    }
    fn block_2068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2068_0: read-var gs#401879:u8
        let s_2068_0: bool = fn_state.gs_401879;
        // D s_2068_1: write-var gs#401880 <= s_2068_0
        fn_state.gs_401880 = s_2068_0;
        // N s_2068_2: jump b2065
        return block_2065(state, tracer, fn_state);
    }
    fn block_2069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2069_0: const #7s : i
        let s_2069_0: i128 = 7;
        // D s_2069_1: read-var u#31775:u32
        let s_2069_1: u32 = fn_state.u_31775;
        // D s_2069_2: cast zx s_2069_1 -> bv
        let s_2069_2: Bits = Bits::new(s_2069_1 as u128, 32u16);
        // C s_2069_3: const #1s : i64
        let s_2069_3: i64 = 1;
        // C s_2069_4: cast zx s_2069_3 -> i
        let s_2069_4: i128 = (i128::try_from(s_2069_3).unwrap());
        // C s_2069_5: const #0s : i
        let s_2069_5: i128 = 0;
        // C s_2069_6: add s_2069_5 s_2069_4
        let s_2069_6: i128 = (s_2069_5 + s_2069_4);
        // D s_2069_7: bit-extract s_2069_2 s_2069_0 s_2069_6
        let s_2069_7: Bits = (Bits::new(
            ((s_2069_2) >> (s_2069_0)).value(),
            u16::try_from(s_2069_6).unwrap(),
        ));
        // D s_2069_8: cast reint s_2069_7 -> u8
        let s_2069_8: bool = ((s_2069_7.value()) != 0);
        // D s_2069_9: cast zx s_2069_8 -> bv
        let s_2069_9: Bits = Bits::new(s_2069_8 as u128, 1u16);
        // C s_2069_10: const #1u : u8
        let s_2069_10: bool = true;
        // C s_2069_11: cast zx s_2069_10 -> bv
        let s_2069_11: Bits = Bits::new(s_2069_10 as u128, 1u16);
        // D s_2069_12: cmp-eq s_2069_9 s_2069_11
        let s_2069_12: bool = ((s_2069_9) == (s_2069_11));
        // N s_2069_13: branch s_2069_12 b2072 b2070
        if s_2069_12 {
            return block_2072(state, tracer, fn_state);
        } else {
            return block_2070(state, tracer, fn_state);
        };
    }
    fn block_2070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2070_0: const #0u : u8
        let s_2070_0: bool = false;
        // D s_2070_1: write-var gs#401878 <= s_2070_0
        fn_state.gs_401878 = s_2070_0;
        // N s_2070_2: jump b2071
        return block_2071(state, tracer, fn_state);
    }
    fn block_2071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2071_0: read-var gs#401878:u8
        let s_2071_0: bool = fn_state.gs_401878;
        // D s_2071_1: write-var gs#401879 <= s_2071_0
        fn_state.gs_401879 = s_2071_0;
        // N s_2071_2: jump b2068
        return block_2068(state, tracer, fn_state);
    }
    fn block_2072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2072_0: const #4s : i
        let s_2072_0: i128 = 4;
        // D s_2072_1: read-var u#31775:u32
        let s_2072_1: u32 = fn_state.u_31775;
        // D s_2072_2: cast zx s_2072_1 -> bv
        let s_2072_2: Bits = Bits::new(s_2072_1 as u128, 32u16);
        // C s_2072_3: const #1s : i64
        let s_2072_3: i64 = 1;
        // C s_2072_4: cast zx s_2072_3 -> i
        let s_2072_4: i128 = (i128::try_from(s_2072_3).unwrap());
        // C s_2072_5: const #0s : i
        let s_2072_5: i128 = 0;
        // C s_2072_6: add s_2072_5 s_2072_4
        let s_2072_6: i128 = (s_2072_5 + s_2072_4);
        // D s_2072_7: bit-extract s_2072_2 s_2072_0 s_2072_6
        let s_2072_7: Bits = (Bits::new(
            ((s_2072_2) >> (s_2072_0)).value(),
            u16::try_from(s_2072_6).unwrap(),
        ));
        // D s_2072_8: cast reint s_2072_7 -> u8
        let s_2072_8: bool = ((s_2072_7.value()) != 0);
        // D s_2072_9: cast zx s_2072_8 -> bv
        let s_2072_9: Bits = Bits::new(s_2072_8 as u128, 1u16);
        // C s_2072_10: const #0u : u8
        let s_2072_10: bool = false;
        // C s_2072_11: cast zx s_2072_10 -> bv
        let s_2072_11: Bits = Bits::new(s_2072_10 as u128, 1u16);
        // D s_2072_12: cmp-eq s_2072_9 s_2072_11
        let s_2072_12: bool = ((s_2072_9) == (s_2072_11));
        // D s_2072_13: write-var gs#401878 <= s_2072_12
        fn_state.gs_401878 = s_2072_12;
        // N s_2072_14: jump b2071
        return block_2071(state, tracer, fn_state);
    }
    fn block_2073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2073_0: const #3662s : i
        let s_2073_0: i128 = 3662;
        // C s_2073_1: const #14696u : u32
        let s_2073_1: u32 = 14696;
        // D s_2073_2: read-reg s_2073_1:i
        let s_2073_2: i128 = {
            let value = state.read_register::<i128>(s_2073_1 as isize);
            tracer.read_register(s_2073_1 as isize, value);
            value
        };
        // D s_2073_3: cmp-lt s_2073_2 s_2073_0
        let s_2073_3: bool = ((s_2073_2) < (s_2073_0));
        // D s_2073_4: write-var gs#401852 <= s_2073_3
        fn_state.gs_401852 = s_2073_3;
        // N s_2073_5: jump b1049
        return block_1049(state, tracer, fn_state);
    }
    fn block_2074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2074_0: const #6s : i
        let s_2074_0: i128 = 6;
        // D s_2074_1: read-var u#31768:u32
        let s_2074_1: u32 = fn_state.u_31768;
        // D s_2074_2: cast zx s_2074_1 -> bv
        let s_2074_2: Bits = Bits::new(s_2074_1 as u128, 32u16);
        // C s_2074_3: const #1s : i64
        let s_2074_3: i64 = 1;
        // C s_2074_4: cast zx s_2074_3 -> i
        let s_2074_4: i128 = (i128::try_from(s_2074_3).unwrap());
        // C s_2074_5: const #5s : i
        let s_2074_5: i128 = 5;
        // C s_2074_6: add s_2074_5 s_2074_4
        let s_2074_6: i128 = (s_2074_5 + s_2074_4);
        // D s_2074_7: bit-extract s_2074_2 s_2074_0 s_2074_6
        let s_2074_7: Bits = (Bits::new(
            ((s_2074_2) >> (s_2074_0)).value(),
            u16::try_from(s_2074_6).unwrap(),
        ));
        // D s_2074_8: cast reint s_2074_7 -> u8
        let s_2074_8: u8 = (s_2074_7.value() as u8);
        // D s_2074_9: cast zx s_2074_8 -> bv
        let s_2074_9: Bits = Bits::new(s_2074_8 as u128, 6u16);
        // C s_2074_10: const #33u : u8
        let s_2074_10: u8 = 33;
        // C s_2074_11: cast zx s_2074_10 -> bv
        let s_2074_11: Bits = Bits::new(s_2074_10 as u128, 6u16);
        // D s_2074_12: cmp-eq s_2074_9 s_2074_11
        let s_2074_12: bool = ((s_2074_9) == (s_2074_11));
        // N s_2074_13: branch s_2074_12 b2077 b2075
        if s_2074_12 {
            return block_2077(state, tracer, fn_state);
        } else {
            return block_2075(state, tracer, fn_state);
        };
    }
    fn block_2075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2075_0: const #0u : u8
        let s_2075_0: bool = false;
        // D s_2075_1: write-var gs#401849 <= s_2075_0
        fn_state.gs_401849 = s_2075_0;
        // N s_2075_2: jump b2076
        return block_2076(state, tracer, fn_state);
    }
    fn block_2076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2076_0: read-var gs#401849:u8
        let s_2076_0: bool = fn_state.gs_401849;
        // D s_2076_1: write-var gs#401850 <= s_2076_0
        fn_state.gs_401850 = s_2076_0;
        // N s_2076_2: jump b1047
        return block_1047(state, tracer, fn_state);
    }
    fn block_2077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2077_0: const #4s : i
        let s_2077_0: i128 = 4;
        // D s_2077_1: read-var u#31768:u32
        let s_2077_1: u32 = fn_state.u_31768;
        // D s_2077_2: cast zx s_2077_1 -> bv
        let s_2077_2: Bits = Bits::new(s_2077_1 as u128, 32u16);
        // C s_2077_3: const #1s : i64
        let s_2077_3: i64 = 1;
        // C s_2077_4: cast zx s_2077_3 -> i
        let s_2077_4: i128 = (i128::try_from(s_2077_3).unwrap());
        // C s_2077_5: const #0s : i
        let s_2077_5: i128 = 0;
        // C s_2077_6: add s_2077_5 s_2077_4
        let s_2077_6: i128 = (s_2077_5 + s_2077_4);
        // D s_2077_7: bit-extract s_2077_2 s_2077_0 s_2077_6
        let s_2077_7: Bits = (Bits::new(
            ((s_2077_2) >> (s_2077_0)).value(),
            u16::try_from(s_2077_6).unwrap(),
        ));
        // D s_2077_8: cast reint s_2077_7 -> u8
        let s_2077_8: bool = ((s_2077_7.value()) != 0);
        // D s_2077_9: cast zx s_2077_8 -> bv
        let s_2077_9: Bits = Bits::new(s_2077_8 as u128, 1u16);
        // C s_2077_10: const #1u : u8
        let s_2077_10: bool = true;
        // C s_2077_11: cast zx s_2077_10 -> bv
        let s_2077_11: Bits = Bits::new(s_2077_10 as u128, 1u16);
        // D s_2077_12: cmp-eq s_2077_9 s_2077_11
        let s_2077_12: bool = ((s_2077_9) == (s_2077_11));
        // D s_2077_13: write-var gs#401849 <= s_2077_12
        fn_state.gs_401849 = s_2077_12;
        // N s_2077_14: jump b2076
        return block_2076(state, tracer, fn_state);
    }
    fn block_2078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2078_0: const #3660s : i
        let s_2078_0: i128 = 3660;
        // C s_2078_1: const #14696u : u32
        let s_2078_1: u32 = 14696;
        // D s_2078_2: read-reg s_2078_1:i
        let s_2078_2: i128 = {
            let value = state.read_register::<i128>(s_2078_1 as isize);
            tracer.read_register(s_2078_1 as isize, value);
            value
        };
        // D s_2078_3: cmp-lt s_2078_2 s_2078_0
        let s_2078_3: bool = ((s_2078_2) < (s_2078_0));
        // D s_2078_4: write-var gs#401823 <= s_2078_3
        fn_state.gs_401823 = s_2078_3;
        // N s_2078_5: jump b1043
        return block_1043(state, tracer, fn_state);
    }
    fn block_2079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2079_0: const #23s : i
        let s_2079_0: i128 = 23;
        // D s_2079_1: read-var u#31758:u32
        let s_2079_1: u32 = fn_state.u_31758;
        // D s_2079_2: cast zx s_2079_1 -> bv
        let s_2079_2: Bits = Bits::new(s_2079_1 as u128, 32u16);
        // C s_2079_3: const #1s : i64
        let s_2079_3: i64 = 1;
        // C s_2079_4: cast zx s_2079_3 -> i
        let s_2079_4: i128 = (i128::try_from(s_2079_3).unwrap());
        // C s_2079_5: const #0s : i
        let s_2079_5: i128 = 0;
        // C s_2079_6: add s_2079_5 s_2079_4
        let s_2079_6: i128 = (s_2079_5 + s_2079_4);
        // D s_2079_7: bit-extract s_2079_2 s_2079_0 s_2079_6
        let s_2079_7: Bits = (Bits::new(
            ((s_2079_2) >> (s_2079_0)).value(),
            u16::try_from(s_2079_6).unwrap(),
        ));
        // D s_2079_8: cast reint s_2079_7 -> u8
        let s_2079_8: bool = ((s_2079_7.value()) != 0);
        // D s_2079_9: cast zx s_2079_8 -> bv
        let s_2079_9: Bits = Bits::new(s_2079_8 as u128, 1u16);
        // C s_2079_10: const #1u : u8
        let s_2079_10: bool = true;
        // C s_2079_11: cast zx s_2079_10 -> bv
        let s_2079_11: Bits = Bits::new(s_2079_10 as u128, 1u16);
        // D s_2079_12: cmp-eq s_2079_9 s_2079_11
        let s_2079_12: bool = ((s_2079_9) == (s_2079_11));
        // N s_2079_13: branch s_2079_12 b2082 b2080
        if s_2079_12 {
            return block_2082(state, tracer, fn_state);
        } else {
            return block_2080(state, tracer, fn_state);
        };
    }
    fn block_2080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2080_0: const #0u : u8
        let s_2080_0: bool = false;
        // D s_2080_1: write-var gs#401820 <= s_2080_0
        fn_state.gs_401820 = s_2080_0;
        // N s_2080_2: jump b2081
        return block_2081(state, tracer, fn_state);
    }
    fn block_2081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2081_0: read-var gs#401820:u8
        let s_2081_0: bool = fn_state.gs_401820;
        // D s_2081_1: write-var gs#401821 <= s_2081_0
        fn_state.gs_401821 = s_2081_0;
        // N s_2081_2: jump b1041
        return block_1041(state, tracer, fn_state);
    }
    fn block_2082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2082_0: const #8s : i
        let s_2082_0: i128 = 8;
        // D s_2082_1: read-var u#31758:u32
        let s_2082_1: u32 = fn_state.u_31758;
        // D s_2082_2: cast zx s_2082_1 -> bv
        let s_2082_2: Bits = Bits::new(s_2082_1 as u128, 32u16);
        // C s_2082_3: const #1s : i64
        let s_2082_3: i64 = 1;
        // C s_2082_4: cast zx s_2082_3 -> i
        let s_2082_4: i128 = (i128::try_from(s_2082_3).unwrap());
        // C s_2082_5: const #3s : i
        let s_2082_5: i128 = 3;
        // C s_2082_6: add s_2082_5 s_2082_4
        let s_2082_6: i128 = (s_2082_5 + s_2082_4);
        // D s_2082_7: bit-extract s_2082_2 s_2082_0 s_2082_6
        let s_2082_7: Bits = (Bits::new(
            ((s_2082_2) >> (s_2082_0)).value(),
            u16::try_from(s_2082_6).unwrap(),
        ));
        // D s_2082_8: cast reint s_2082_7 -> u8
        let s_2082_8: u8 = (s_2082_7.value() as u8);
        // D s_2082_9: cast zx s_2082_8 -> bv
        let s_2082_9: Bits = Bits::new(s_2082_8 as u128, 4u16);
        // C s_2082_10: const #2u : u8
        let s_2082_10: u8 = 2;
        // C s_2082_11: cast zx s_2082_10 -> bv
        let s_2082_11: Bits = Bits::new(s_2082_10 as u128, 4u16);
        // D s_2082_12: cmp-eq s_2082_9 s_2082_11
        let s_2082_12: bool = ((s_2082_9) == (s_2082_11));
        // N s_2082_13: branch s_2082_12 b2085 b2083
        if s_2082_12 {
            return block_2085(state, tracer, fn_state);
        } else {
            return block_2083(state, tracer, fn_state);
        };
    }
    fn block_2083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2083_0: const #0u : u8
        let s_2083_0: bool = false;
        // D s_2083_1: write-var gs#401819 <= s_2083_0
        fn_state.gs_401819 = s_2083_0;
        // N s_2083_2: jump b2084
        return block_2084(state, tracer, fn_state);
    }
    fn block_2084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2084_0: read-var gs#401819:u8
        let s_2084_0: bool = fn_state.gs_401819;
        // D s_2084_1: write-var gs#401820 <= s_2084_0
        fn_state.gs_401820 = s_2084_0;
        // N s_2084_2: jump b2081
        return block_2081(state, tracer, fn_state);
    }
    fn block_2085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2085_0: const #4s : i
        let s_2085_0: i128 = 4;
        // D s_2085_1: read-var u#31758:u32
        let s_2085_1: u32 = fn_state.u_31758;
        // D s_2085_2: cast zx s_2085_1 -> bv
        let s_2085_2: Bits = Bits::new(s_2085_1 as u128, 32u16);
        // C s_2085_3: const #1s : i64
        let s_2085_3: i64 = 1;
        // C s_2085_4: cast zx s_2085_3 -> i
        let s_2085_4: i128 = (i128::try_from(s_2085_3).unwrap());
        // C s_2085_5: const #0s : i
        let s_2085_5: i128 = 0;
        // C s_2085_6: add s_2085_5 s_2085_4
        let s_2085_6: i128 = (s_2085_5 + s_2085_4);
        // D s_2085_7: bit-extract s_2085_2 s_2085_0 s_2085_6
        let s_2085_7: Bits = (Bits::new(
            ((s_2085_2) >> (s_2085_0)).value(),
            u16::try_from(s_2085_6).unwrap(),
        ));
        // D s_2085_8: cast reint s_2085_7 -> u8
        let s_2085_8: bool = ((s_2085_7.value()) != 0);
        // D s_2085_9: cast zx s_2085_8 -> bv
        let s_2085_9: Bits = Bits::new(s_2085_8 as u128, 1u16);
        // C s_2085_10: const #1u : u8
        let s_2085_10: bool = true;
        // C s_2085_11: cast zx s_2085_10 -> bv
        let s_2085_11: Bits = Bits::new(s_2085_10 as u128, 1u16);
        // D s_2085_12: cmp-eq s_2085_9 s_2085_11
        let s_2085_12: bool = ((s_2085_9) == (s_2085_11));
        // D s_2085_13: write-var gs#401819 <= s_2085_12
        fn_state.gs_401819 = s_2085_12;
        // N s_2085_14: jump b2084
        return block_2084(state, tracer, fn_state);
    }
    fn block_2086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2086_0: const #3658s : i
        let s_2086_0: i128 = 3658;
        // C s_2086_1: const #14696u : u32
        let s_2086_1: u32 = 14696;
        // D s_2086_2: read-reg s_2086_1:i
        let s_2086_2: i128 = {
            let value = state.read_register::<i128>(s_2086_1 as isize);
            tracer.read_register(s_2086_1 as isize, value);
            value
        };
        // D s_2086_3: cmp-lt s_2086_2 s_2086_0
        let s_2086_3: bool = ((s_2086_2) < (s_2086_0));
        // D s_2086_4: write-var gs#401789 <= s_2086_3
        fn_state.gs_401789 = s_2086_3;
        // N s_2086_5: jump b1037
        return block_1037(state, tracer, fn_state);
    }
    fn block_2087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2087_0: const #23s : i
        let s_2087_0: i128 = 23;
        // D s_2087_1: read-var u#31747:u32
        let s_2087_1: u32 = fn_state.u_31747;
        // D s_2087_2: cast zx s_2087_1 -> bv
        let s_2087_2: Bits = Bits::new(s_2087_1 as u128, 32u16);
        // C s_2087_3: const #1s : i64
        let s_2087_3: i64 = 1;
        // C s_2087_4: cast zx s_2087_3 -> i
        let s_2087_4: i128 = (i128::try_from(s_2087_3).unwrap());
        // C s_2087_5: const #0s : i
        let s_2087_5: i128 = 0;
        // C s_2087_6: add s_2087_5 s_2087_4
        let s_2087_6: i128 = (s_2087_5 + s_2087_4);
        // D s_2087_7: bit-extract s_2087_2 s_2087_0 s_2087_6
        let s_2087_7: Bits = (Bits::new(
            ((s_2087_2) >> (s_2087_0)).value(),
            u16::try_from(s_2087_6).unwrap(),
        ));
        // D s_2087_8: cast reint s_2087_7 -> u8
        let s_2087_8: bool = ((s_2087_7.value()) != 0);
        // D s_2087_9: cast zx s_2087_8 -> bv
        let s_2087_9: Bits = Bits::new(s_2087_8 as u128, 1u16);
        // C s_2087_10: const #0u : u8
        let s_2087_10: bool = false;
        // C s_2087_11: cast zx s_2087_10 -> bv
        let s_2087_11: Bits = Bits::new(s_2087_10 as u128, 1u16);
        // D s_2087_12: cmp-eq s_2087_9 s_2087_11
        let s_2087_12: bool = ((s_2087_9) == (s_2087_11));
        // N s_2087_13: branch s_2087_12 b2090 b2088
        if s_2087_12 {
            return block_2090(state, tracer, fn_state);
        } else {
            return block_2088(state, tracer, fn_state);
        };
    }
    fn block_2088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2088_0: const #0u : u8
        let s_2088_0: bool = false;
        // D s_2088_1: write-var gs#401786 <= s_2088_0
        fn_state.gs_401786 = s_2088_0;
        // N s_2088_2: jump b2089
        return block_2089(state, tracer, fn_state);
    }
    fn block_2089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2089_0: read-var gs#401786:u8
        let s_2089_0: bool = fn_state.gs_401786;
        // D s_2089_1: write-var gs#401787 <= s_2089_0
        fn_state.gs_401787 = s_2089_0;
        // N s_2089_2: jump b1035
        return block_1035(state, tracer, fn_state);
    }
    fn block_2090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2090_0: const #8s : i
        let s_2090_0: i128 = 8;
        // D s_2090_1: read-var u#31747:u32
        let s_2090_1: u32 = fn_state.u_31747;
        // D s_2090_2: cast zx s_2090_1 -> bv
        let s_2090_2: Bits = Bits::new(s_2090_1 as u128, 32u16);
        // C s_2090_3: const #1s : i64
        let s_2090_3: i64 = 1;
        // C s_2090_4: cast zx s_2090_3 -> i
        let s_2090_4: i128 = (i128::try_from(s_2090_3).unwrap());
        // C s_2090_5: const #3s : i
        let s_2090_5: i128 = 3;
        // C s_2090_6: add s_2090_5 s_2090_4
        let s_2090_6: i128 = (s_2090_5 + s_2090_4);
        // D s_2090_7: bit-extract s_2090_2 s_2090_0 s_2090_6
        let s_2090_7: Bits = (Bits::new(
            ((s_2090_2) >> (s_2090_0)).value(),
            u16::try_from(s_2090_6).unwrap(),
        ));
        // D s_2090_8: cast reint s_2090_7 -> u8
        let s_2090_8: u8 = (s_2090_7.value() as u8);
        // D s_2090_9: cast zx s_2090_8 -> bv
        let s_2090_9: Bits = Bits::new(s_2090_8 as u128, 4u16);
        // C s_2090_10: const #5u : u8
        let s_2090_10: u8 = 5;
        // C s_2090_11: cast zx s_2090_10 -> bv
        let s_2090_11: Bits = Bits::new(s_2090_10 as u128, 4u16);
        // D s_2090_12: cmp-eq s_2090_9 s_2090_11
        let s_2090_12: bool = ((s_2090_9) == (s_2090_11));
        // N s_2090_13: branch s_2090_12 b2093 b2091
        if s_2090_12 {
            return block_2093(state, tracer, fn_state);
        } else {
            return block_2091(state, tracer, fn_state);
        };
    }
    fn block_2091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2091_0: const #0u : u8
        let s_2091_0: bool = false;
        // D s_2091_1: write-var gs#401785 <= s_2091_0
        fn_state.gs_401785 = s_2091_0;
        // N s_2091_2: jump b2092
        return block_2092(state, tracer, fn_state);
    }
    fn block_2092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2092_0: read-var gs#401785:u8
        let s_2092_0: bool = fn_state.gs_401785;
        // D s_2092_1: write-var gs#401786 <= s_2092_0
        fn_state.gs_401786 = s_2092_0;
        // N s_2092_2: jump b2089
        return block_2089(state, tracer, fn_state);
    }
    fn block_2093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2093_0: const #4s : i
        let s_2093_0: i128 = 4;
        // D s_2093_1: read-var u#31747:u32
        let s_2093_1: u32 = fn_state.u_31747;
        // D s_2093_2: cast zx s_2093_1 -> bv
        let s_2093_2: Bits = Bits::new(s_2093_1 as u128, 32u16);
        // C s_2093_3: const #1s : i64
        let s_2093_3: i64 = 1;
        // C s_2093_4: cast zx s_2093_3 -> i
        let s_2093_4: i128 = (i128::try_from(s_2093_3).unwrap());
        // C s_2093_5: const #0s : i
        let s_2093_5: i128 = 0;
        // C s_2093_6: add s_2093_5 s_2093_4
        let s_2093_6: i128 = (s_2093_5 + s_2093_4);
        // D s_2093_7: bit-extract s_2093_2 s_2093_0 s_2093_6
        let s_2093_7: Bits = (Bits::new(
            ((s_2093_2) >> (s_2093_0)).value(),
            u16::try_from(s_2093_6).unwrap(),
        ));
        // D s_2093_8: cast reint s_2093_7 -> u8
        let s_2093_8: bool = ((s_2093_7.value()) != 0);
        // D s_2093_9: cast zx s_2093_8 -> bv
        let s_2093_9: Bits = Bits::new(s_2093_8 as u128, 1u16);
        // C s_2093_10: const #0u : u8
        let s_2093_10: bool = false;
        // C s_2093_11: cast zx s_2093_10 -> bv
        let s_2093_11: Bits = Bits::new(s_2093_10 as u128, 1u16);
        // D s_2093_12: cmp-eq s_2093_9 s_2093_11
        let s_2093_12: bool = ((s_2093_9) == (s_2093_11));
        // D s_2093_13: write-var gs#401785 <= s_2093_12
        fn_state.gs_401785 = s_2093_12;
        // N s_2093_14: jump b2092
        return block_2092(state, tracer, fn_state);
    }
    fn block_2094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2094_0: const #3656s : i
        let s_2094_0: i128 = 3656;
        // C s_2094_1: const #14696u : u32
        let s_2094_1: u32 = 14696;
        // D s_2094_2: read-reg s_2094_1:i
        let s_2094_2: i128 = {
            let value = state.read_register::<i128>(s_2094_1 as isize);
            tracer.read_register(s_2094_1 as isize, value);
            value
        };
        // D s_2094_3: cmp-lt s_2094_2 s_2094_0
        let s_2094_3: bool = ((s_2094_2) < (s_2094_0));
        // D s_2094_4: write-var gs#401755 <= s_2094_3
        fn_state.gs_401755 = s_2094_3;
        // N s_2094_5: jump b1031
        return block_1031(state, tracer, fn_state);
    }
    fn block_2095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2095_0: const #23s : i
        let s_2095_0: i128 = 23;
        // D s_2095_1: read-var u#31736:u32
        let s_2095_1: u32 = fn_state.u_31736;
        // D s_2095_2: cast zx s_2095_1 -> bv
        let s_2095_2: Bits = Bits::new(s_2095_1 as u128, 32u16);
        // C s_2095_3: const #1s : i64
        let s_2095_3: i64 = 1;
        // C s_2095_4: cast zx s_2095_3 -> i
        let s_2095_4: i128 = (i128::try_from(s_2095_3).unwrap());
        // C s_2095_5: const #0s : i
        let s_2095_5: i128 = 0;
        // C s_2095_6: add s_2095_5 s_2095_4
        let s_2095_6: i128 = (s_2095_5 + s_2095_4);
        // D s_2095_7: bit-extract s_2095_2 s_2095_0 s_2095_6
        let s_2095_7: Bits = (Bits::new(
            ((s_2095_2) >> (s_2095_0)).value(),
            u16::try_from(s_2095_6).unwrap(),
        ));
        // D s_2095_8: cast reint s_2095_7 -> u8
        let s_2095_8: bool = ((s_2095_7.value()) != 0);
        // D s_2095_9: cast zx s_2095_8 -> bv
        let s_2095_9: Bits = Bits::new(s_2095_8 as u128, 1u16);
        // C s_2095_10: const #0u : u8
        let s_2095_10: bool = false;
        // C s_2095_11: cast zx s_2095_10 -> bv
        let s_2095_11: Bits = Bits::new(s_2095_10 as u128, 1u16);
        // D s_2095_12: cmp-eq s_2095_9 s_2095_11
        let s_2095_12: bool = ((s_2095_9) == (s_2095_11));
        // N s_2095_13: branch s_2095_12 b2098 b2096
        if s_2095_12 {
            return block_2098(state, tracer, fn_state);
        } else {
            return block_2096(state, tracer, fn_state);
        };
    }
    fn block_2096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2096_0: const #0u : u8
        let s_2096_0: bool = false;
        // D s_2096_1: write-var gs#401752 <= s_2096_0
        fn_state.gs_401752 = s_2096_0;
        // N s_2096_2: jump b2097
        return block_2097(state, tracer, fn_state);
    }
    fn block_2097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2097_0: read-var gs#401752:u8
        let s_2097_0: bool = fn_state.gs_401752;
        // D s_2097_1: write-var gs#401753 <= s_2097_0
        fn_state.gs_401753 = s_2097_0;
        // N s_2097_2: jump b1029
        return block_1029(state, tracer, fn_state);
    }
    fn block_2098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2098_0: const #8s : i
        let s_2098_0: i128 = 8;
        // D s_2098_1: read-var u#31736:u32
        let s_2098_1: u32 = fn_state.u_31736;
        // D s_2098_2: cast zx s_2098_1 -> bv
        let s_2098_2: Bits = Bits::new(s_2098_1 as u128, 32u16);
        // C s_2098_3: const #1s : i64
        let s_2098_3: i64 = 1;
        // C s_2098_4: cast zx s_2098_3 -> i
        let s_2098_4: i128 = (i128::try_from(s_2098_3).unwrap());
        // C s_2098_5: const #3s : i
        let s_2098_5: i128 = 3;
        // C s_2098_6: add s_2098_5 s_2098_4
        let s_2098_6: i128 = (s_2098_5 + s_2098_4);
        // D s_2098_7: bit-extract s_2098_2 s_2098_0 s_2098_6
        let s_2098_7: Bits = (Bits::new(
            ((s_2098_2) >> (s_2098_0)).value(),
            u16::try_from(s_2098_6).unwrap(),
        ));
        // D s_2098_8: cast reint s_2098_7 -> u8
        let s_2098_8: u8 = (s_2098_7.value() as u8);
        // D s_2098_9: cast zx s_2098_8 -> bv
        let s_2098_9: Bits = Bits::new(s_2098_8 as u128, 4u16);
        // C s_2098_10: const #1u : u8
        let s_2098_10: u8 = 1;
        // C s_2098_11: cast zx s_2098_10 -> bv
        let s_2098_11: Bits = Bits::new(s_2098_10 as u128, 4u16);
        // D s_2098_12: cmp-eq s_2098_9 s_2098_11
        let s_2098_12: bool = ((s_2098_9) == (s_2098_11));
        // N s_2098_13: branch s_2098_12 b2101 b2099
        if s_2098_12 {
            return block_2101(state, tracer, fn_state);
        } else {
            return block_2099(state, tracer, fn_state);
        };
    }
    fn block_2099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2099_0: const #0u : u8
        let s_2099_0: bool = false;
        // D s_2099_1: write-var gs#401751 <= s_2099_0
        fn_state.gs_401751 = s_2099_0;
        // N s_2099_2: jump b2100
        return block_2100(state, tracer, fn_state);
    }
    fn block_2100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2100_0: read-var gs#401751:u8
        let s_2100_0: bool = fn_state.gs_401751;
        // D s_2100_1: write-var gs#401752 <= s_2100_0
        fn_state.gs_401752 = s_2100_0;
        // N s_2100_2: jump b2097
        return block_2097(state, tracer, fn_state);
    }
    fn block_2101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2101_0: const #4s : i
        let s_2101_0: i128 = 4;
        // D s_2101_1: read-var u#31736:u32
        let s_2101_1: u32 = fn_state.u_31736;
        // D s_2101_2: cast zx s_2101_1 -> bv
        let s_2101_2: Bits = Bits::new(s_2101_1 as u128, 32u16);
        // C s_2101_3: const #1s : i64
        let s_2101_3: i64 = 1;
        // C s_2101_4: cast zx s_2101_3 -> i
        let s_2101_4: i128 = (i128::try_from(s_2101_3).unwrap());
        // C s_2101_5: const #0s : i
        let s_2101_5: i128 = 0;
        // C s_2101_6: add s_2101_5 s_2101_4
        let s_2101_6: i128 = (s_2101_5 + s_2101_4);
        // D s_2101_7: bit-extract s_2101_2 s_2101_0 s_2101_6
        let s_2101_7: Bits = (Bits::new(
            ((s_2101_2) >> (s_2101_0)).value(),
            u16::try_from(s_2101_6).unwrap(),
        ));
        // D s_2101_8: cast reint s_2101_7 -> u8
        let s_2101_8: bool = ((s_2101_7.value()) != 0);
        // D s_2101_9: cast zx s_2101_8 -> bv
        let s_2101_9: Bits = Bits::new(s_2101_8 as u128, 1u16);
        // C s_2101_10: const #0u : u8
        let s_2101_10: bool = false;
        // C s_2101_11: cast zx s_2101_10 -> bv
        let s_2101_11: Bits = Bits::new(s_2101_10 as u128, 1u16);
        // D s_2101_12: cmp-eq s_2101_9 s_2101_11
        let s_2101_12: bool = ((s_2101_9) == (s_2101_11));
        // D s_2101_13: write-var gs#401751 <= s_2101_12
        fn_state.gs_401751 = s_2101_12;
        // N s_2101_14: jump b2100
        return block_2100(state, tracer, fn_state);
    }
    fn block_2102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2102_0: const #3654s : i
        let s_2102_0: i128 = 3654;
        // C s_2102_1: const #14696u : u32
        let s_2102_1: u32 = 14696;
        // D s_2102_2: read-reg s_2102_1:i
        let s_2102_2: i128 = {
            let value = state.read_register::<i128>(s_2102_1 as isize);
            tracer.read_register(s_2102_1 as isize, value);
            value
        };
        // D s_2102_3: cmp-lt s_2102_2 s_2102_0
        let s_2102_3: bool = ((s_2102_2) < (s_2102_0));
        // D s_2102_4: write-var gs#401725 <= s_2102_3
        fn_state.gs_401725 = s_2102_3;
        // N s_2102_5: jump b1025
        return block_1025(state, tracer, fn_state);
    }
    fn block_2103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2103_0: const #20s : i
        let s_2103_0: i128 = 20;
        // D s_2103_1: read-var u#31727:u32
        let s_2103_1: u32 = fn_state.u_31727;
        // D s_2103_2: cast zx s_2103_1 -> bv
        let s_2103_2: Bits = Bits::new(s_2103_1 as u128, 32u16);
        // C s_2103_3: const #1s : i64
        let s_2103_3: i64 = 1;
        // C s_2103_4: cast zx s_2103_3 -> i
        let s_2103_4: i128 = (i128::try_from(s_2103_3).unwrap());
        // C s_2103_5: const #1s : i
        let s_2103_5: i128 = 1;
        // C s_2103_6: add s_2103_5 s_2103_4
        let s_2103_6: i128 = (s_2103_5 + s_2103_4);
        // D s_2103_7: bit-extract s_2103_2 s_2103_0 s_2103_6
        let s_2103_7: Bits = (Bits::new(
            ((s_2103_2) >> (s_2103_0)).value(),
            u16::try_from(s_2103_6).unwrap(),
        ));
        // D s_2103_8: cast reint s_2103_7 -> u8
        let s_2103_8: u8 = (s_2103_7.value() as u8);
        // D s_2103_9: cast zx s_2103_8 -> bv
        let s_2103_9: Bits = Bits::new(s_2103_8 as u128, 2u16);
        // C s_2103_10: const #3u : u8
        let s_2103_10: u8 = 3;
        // C s_2103_11: cast zx s_2103_10 -> bv
        let s_2103_11: Bits = Bits::new(s_2103_10 as u128, 2u16);
        // D s_2103_12: cmp-eq s_2103_9 s_2103_11
        let s_2103_12: bool = ((s_2103_9) == (s_2103_11));
        // N s_2103_13: branch s_2103_12 b2106 b2104
        if s_2103_12 {
            return block_2106(state, tracer, fn_state);
        } else {
            return block_2104(state, tracer, fn_state);
        };
    }
    fn block_2104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2104_0: const #0u : u8
        let s_2104_0: bool = false;
        // D s_2104_1: write-var gs#401722 <= s_2104_0
        fn_state.gs_401722 = s_2104_0;
        // N s_2104_2: jump b2105
        return block_2105(state, tracer, fn_state);
    }
    fn block_2105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2105_0: read-var gs#401722:u8
        let s_2105_0: bool = fn_state.gs_401722;
        // D s_2105_1: write-var gs#401723 <= s_2105_0
        fn_state.gs_401723 = s_2105_0;
        // N s_2105_2: jump b1023
        return block_1023(state, tracer, fn_state);
    }
    fn block_2106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2106_0: const #16s : i
        let s_2106_0: i128 = 16;
        // D s_2106_1: read-var u#31727:u32
        let s_2106_1: u32 = fn_state.u_31727;
        // D s_2106_2: cast zx s_2106_1 -> bv
        let s_2106_2: Bits = Bits::new(s_2106_1 as u128, 32u16);
        // C s_2106_3: const #1s : i64
        let s_2106_3: i64 = 1;
        // C s_2106_4: cast zx s_2106_3 -> i
        let s_2106_4: i128 = (i128::try_from(s_2106_3).unwrap());
        // C s_2106_5: const #1s : i
        let s_2106_5: i128 = 1;
        // C s_2106_6: add s_2106_5 s_2106_4
        let s_2106_6: i128 = (s_2106_5 + s_2106_4);
        // D s_2106_7: bit-extract s_2106_2 s_2106_0 s_2106_6
        let s_2106_7: Bits = (Bits::new(
            ((s_2106_2) >> (s_2106_0)).value(),
            u16::try_from(s_2106_6).unwrap(),
        ));
        // D s_2106_8: cast reint s_2106_7 -> u8
        let s_2106_8: u8 = (s_2106_7.value() as u8);
        // D s_2106_9: cast zx s_2106_8 -> bv
        let s_2106_9: Bits = Bits::new(s_2106_8 as u128, 2u16);
        // C s_2106_10: const #0u : u8
        let s_2106_10: u8 = 0;
        // C s_2106_11: cast zx s_2106_10 -> bv
        let s_2106_11: Bits = Bits::new(s_2106_10 as u128, 2u16);
        // D s_2106_12: cmp-eq s_2106_9 s_2106_11
        let s_2106_12: bool = ((s_2106_9) == (s_2106_11));
        // N s_2106_13: branch s_2106_12 b2109 b2107
        if s_2106_12 {
            return block_2109(state, tracer, fn_state);
        } else {
            return block_2107(state, tracer, fn_state);
        };
    }
    fn block_2107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2107_0: const #0u : u8
        let s_2107_0: bool = false;
        // D s_2107_1: write-var gs#401721 <= s_2107_0
        fn_state.gs_401721 = s_2107_0;
        // N s_2107_2: jump b2108
        return block_2108(state, tracer, fn_state);
    }
    fn block_2108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2108_0: read-var gs#401721:u8
        let s_2108_0: bool = fn_state.gs_401721;
        // D s_2108_1: write-var gs#401722 <= s_2108_0
        fn_state.gs_401722 = s_2108_0;
        // N s_2108_2: jump b2105
        return block_2105(state, tracer, fn_state);
    }
    fn block_2109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2109_0: const #9s : i
        let s_2109_0: i128 = 9;
        // D s_2109_1: read-var u#31727:u32
        let s_2109_1: u32 = fn_state.u_31727;
        // D s_2109_2: cast zx s_2109_1 -> bv
        let s_2109_2: Bits = Bits::new(s_2109_1 as u128, 32u16);
        // C s_2109_3: const #1s : i64
        let s_2109_3: i64 = 1;
        // C s_2109_4: cast zx s_2109_3 -> i
        let s_2109_4: i128 = (i128::try_from(s_2109_3).unwrap());
        // C s_2109_5: const #2s : i
        let s_2109_5: i128 = 2;
        // C s_2109_6: add s_2109_5 s_2109_4
        let s_2109_6: i128 = (s_2109_5 + s_2109_4);
        // D s_2109_7: bit-extract s_2109_2 s_2109_0 s_2109_6
        let s_2109_7: Bits = (Bits::new(
            ((s_2109_2) >> (s_2109_0)).value(),
            u16::try_from(s_2109_6).unwrap(),
        ));
        // D s_2109_8: cast reint s_2109_7 -> u8
        let s_2109_8: u8 = (s_2109_7.value() as u8);
        // D s_2109_9: cast zx s_2109_8 -> bv
        let s_2109_9: Bits = Bits::new(s_2109_8 as u128, 3u16);
        // C s_2109_10: const #0u : u8
        let s_2109_10: u8 = 0;
        // C s_2109_11: cast zx s_2109_10 -> bv
        let s_2109_11: Bits = Bits::new(s_2109_10 as u128, 3u16);
        // D s_2109_12: cmp-eq s_2109_9 s_2109_11
        let s_2109_12: bool = ((s_2109_9) == (s_2109_11));
        // N s_2109_13: branch s_2109_12 b2112 b2110
        if s_2109_12 {
            return block_2112(state, tracer, fn_state);
        } else {
            return block_2110(state, tracer, fn_state);
        };
    }
    fn block_2110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2110_0: const #0u : u8
        let s_2110_0: bool = false;
        // D s_2110_1: write-var gs#401720 <= s_2110_0
        fn_state.gs_401720 = s_2110_0;
        // N s_2110_2: jump b2111
        return block_2111(state, tracer, fn_state);
    }
    fn block_2111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2111_0: read-var gs#401720:u8
        let s_2111_0: bool = fn_state.gs_401720;
        // D s_2111_1: write-var gs#401721 <= s_2111_0
        fn_state.gs_401721 = s_2111_0;
        // N s_2111_2: jump b2108
        return block_2108(state, tracer, fn_state);
    }
    fn block_2112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2112_0: const #4s : i
        let s_2112_0: i128 = 4;
        // D s_2112_1: read-var u#31727:u32
        let s_2112_1: u32 = fn_state.u_31727;
        // D s_2112_2: cast zx s_2112_1 -> bv
        let s_2112_2: Bits = Bits::new(s_2112_1 as u128, 32u16);
        // C s_2112_3: const #1s : i64
        let s_2112_3: i64 = 1;
        // C s_2112_4: cast zx s_2112_3 -> i
        let s_2112_4: i128 = (i128::try_from(s_2112_3).unwrap());
        // C s_2112_5: const #0s : i
        let s_2112_5: i128 = 0;
        // C s_2112_6: add s_2112_5 s_2112_4
        let s_2112_6: i128 = (s_2112_5 + s_2112_4);
        // D s_2112_7: bit-extract s_2112_2 s_2112_0 s_2112_6
        let s_2112_7: Bits = (Bits::new(
            ((s_2112_2) >> (s_2112_0)).value(),
            u16::try_from(s_2112_6).unwrap(),
        ));
        // D s_2112_8: cast reint s_2112_7 -> u8
        let s_2112_8: bool = ((s_2112_7.value()) != 0);
        // D s_2112_9: cast zx s_2112_8 -> bv
        let s_2112_9: Bits = Bits::new(s_2112_8 as u128, 1u16);
        // C s_2112_10: const #0u : u8
        let s_2112_10: bool = false;
        // C s_2112_11: cast zx s_2112_10 -> bv
        let s_2112_11: Bits = Bits::new(s_2112_10 as u128, 1u16);
        // D s_2112_12: cmp-eq s_2112_9 s_2112_11
        let s_2112_12: bool = ((s_2112_9) == (s_2112_11));
        // D s_2112_13: write-var gs#401720 <= s_2112_12
        fn_state.gs_401720 = s_2112_12;
        // N s_2112_14: jump b2111
        return block_2111(state, tracer, fn_state);
    }
    fn block_2113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2113_0: const #3652s : i
        let s_2113_0: i128 = 3652;
        // C s_2113_1: const #14696u : u32
        let s_2113_1: u32 = 14696;
        // D s_2113_2: read-reg s_2113_1:i
        let s_2113_2: i128 = {
            let value = state.read_register::<i128>(s_2113_1 as isize);
            tracer.read_register(s_2113_1 as isize, value);
            value
        };
        // D s_2113_3: cmp-lt s_2113_2 s_2113_0
        let s_2113_3: bool = ((s_2113_2) < (s_2113_0));
        // D s_2113_4: write-var gs#401690 <= s_2113_3
        fn_state.gs_401690 = s_2113_3;
        // N s_2113_5: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_2114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2114_0: const #21s : i
        let s_2114_0: i128 = 21;
        // D s_2114_1: read-var u#31717:u32
        let s_2114_1: u32 = fn_state.u_31717;
        // D s_2114_2: cast zx s_2114_1 -> bv
        let s_2114_2: Bits = Bits::new(s_2114_1 as u128, 32u16);
        // C s_2114_3: const #1s : i64
        let s_2114_3: i64 = 1;
        // C s_2114_4: cast zx s_2114_3 -> i
        let s_2114_4: i128 = (i128::try_from(s_2114_3).unwrap());
        // C s_2114_5: const #0s : i
        let s_2114_5: i128 = 0;
        // C s_2114_6: add s_2114_5 s_2114_4
        let s_2114_6: i128 = (s_2114_5 + s_2114_4);
        // D s_2114_7: bit-extract s_2114_2 s_2114_0 s_2114_6
        let s_2114_7: Bits = (Bits::new(
            ((s_2114_2) >> (s_2114_0)).value(),
            u16::try_from(s_2114_6).unwrap(),
        ));
        // D s_2114_8: cast reint s_2114_7 -> u8
        let s_2114_8: bool = ((s_2114_7.value()) != 0);
        // D s_2114_9: cast zx s_2114_8 -> bv
        let s_2114_9: Bits = Bits::new(s_2114_8 as u128, 1u16);
        // C s_2114_10: const #0u : u8
        let s_2114_10: bool = false;
        // C s_2114_11: cast zx s_2114_10 -> bv
        let s_2114_11: Bits = Bits::new(s_2114_10 as u128, 1u16);
        // D s_2114_12: cmp-eq s_2114_9 s_2114_11
        let s_2114_12: bool = ((s_2114_9) == (s_2114_11));
        // N s_2114_13: branch s_2114_12 b2117 b2115
        if s_2114_12 {
            return block_2117(state, tracer, fn_state);
        } else {
            return block_2115(state, tracer, fn_state);
        };
    }
    fn block_2115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2115_0: const #0u : u8
        let s_2115_0: bool = false;
        // D s_2115_1: write-var gs#401687 <= s_2115_0
        fn_state.gs_401687 = s_2115_0;
        // N s_2115_2: jump b2116
        return block_2116(state, tracer, fn_state);
    }
    fn block_2116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2116_0: read-var gs#401687:u8
        let s_2116_0: bool = fn_state.gs_401687;
        // D s_2116_1: write-var gs#401688 <= s_2116_0
        fn_state.gs_401688 = s_2116_0;
        // N s_2116_2: jump b1017
        return block_1017(state, tracer, fn_state);
    }
    fn block_2117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2117_0: const #8s : i
        let s_2117_0: i128 = 8;
        // D s_2117_1: read-var u#31717:u32
        let s_2117_1: u32 = fn_state.u_31717;
        // D s_2117_2: cast zx s_2117_1 -> bv
        let s_2117_2: Bits = Bits::new(s_2117_1 as u128, 32u16);
        // C s_2117_3: const #1s : i64
        let s_2117_3: i64 = 1;
        // C s_2117_4: cast zx s_2117_3 -> i
        let s_2117_4: i128 = (i128::try_from(s_2117_3).unwrap());
        // C s_2117_5: const #3s : i
        let s_2117_5: i128 = 3;
        // C s_2117_6: add s_2117_5 s_2117_4
        let s_2117_6: i128 = (s_2117_5 + s_2117_4);
        // D s_2117_7: bit-extract s_2117_2 s_2117_0 s_2117_6
        let s_2117_7: Bits = (Bits::new(
            ((s_2117_2) >> (s_2117_0)).value(),
            u16::try_from(s_2117_6).unwrap(),
        ));
        // D s_2117_8: cast reint s_2117_7 -> u8
        let s_2117_8: u8 = (s_2117_7.value() as u8);
        // D s_2117_9: cast zx s_2117_8 -> bv
        let s_2117_9: Bits = Bits::new(s_2117_8 as u128, 4u16);
        // C s_2117_10: const #15u : u8
        let s_2117_10: u8 = 15;
        // C s_2117_11: cast zx s_2117_10 -> bv
        let s_2117_11: Bits = Bits::new(s_2117_10 as u128, 4u16);
        // D s_2117_12: cmp-eq s_2117_9 s_2117_11
        let s_2117_12: bool = ((s_2117_9) == (s_2117_11));
        // N s_2117_13: branch s_2117_12 b2120 b2118
        if s_2117_12 {
            return block_2120(state, tracer, fn_state);
        } else {
            return block_2118(state, tracer, fn_state);
        };
    }
    fn block_2118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2118_0: const #0u : u8
        let s_2118_0: bool = false;
        // D s_2118_1: write-var gs#401686 <= s_2118_0
        fn_state.gs_401686 = s_2118_0;
        // N s_2118_2: jump b2119
        return block_2119(state, tracer, fn_state);
    }
    fn block_2119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2119_0: read-var gs#401686:u8
        let s_2119_0: bool = fn_state.gs_401686;
        // D s_2119_1: write-var gs#401687 <= s_2119_0
        fn_state.gs_401687 = s_2119_0;
        // N s_2119_2: jump b2116
        return block_2116(state, tracer, fn_state);
    }
    fn block_2120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2120_0: const #4s : i
        let s_2120_0: i128 = 4;
        // D s_2120_1: read-var u#31717:u32
        let s_2120_1: u32 = fn_state.u_31717;
        // D s_2120_2: cast zx s_2120_1 -> bv
        let s_2120_2: Bits = Bits::new(s_2120_1 as u128, 32u16);
        // C s_2120_3: const #1s : i64
        let s_2120_3: i64 = 1;
        // C s_2120_4: cast zx s_2120_3 -> i
        let s_2120_4: i128 = (i128::try_from(s_2120_3).unwrap());
        // C s_2120_5: const #0s : i
        let s_2120_5: i128 = 0;
        // C s_2120_6: add s_2120_5 s_2120_4
        let s_2120_6: i128 = (s_2120_5 + s_2120_4);
        // D s_2120_7: bit-extract s_2120_2 s_2120_0 s_2120_6
        let s_2120_7: Bits = (Bits::new(
            ((s_2120_2) >> (s_2120_0)).value(),
            u16::try_from(s_2120_6).unwrap(),
        ));
        // D s_2120_8: cast reint s_2120_7 -> u8
        let s_2120_8: bool = ((s_2120_7.value()) != 0);
        // D s_2120_9: cast zx s_2120_8 -> bv
        let s_2120_9: Bits = Bits::new(s_2120_8 as u128, 1u16);
        // C s_2120_10: const #1u : u8
        let s_2120_10: bool = true;
        // C s_2120_11: cast zx s_2120_10 -> bv
        let s_2120_11: Bits = Bits::new(s_2120_10 as u128, 1u16);
        // D s_2120_12: cmp-eq s_2120_9 s_2120_11
        let s_2120_12: bool = ((s_2120_9) == (s_2120_11));
        // D s_2120_13: write-var gs#401686 <= s_2120_12
        fn_state.gs_401686 = s_2120_12;
        // N s_2120_14: jump b2119
        return block_2119(state, tracer, fn_state);
    }
    fn block_2121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2121_0: const #3650s : i
        let s_2121_0: i128 = 3650;
        // C s_2121_1: const #14696u : u32
        let s_2121_1: u32 = 14696;
        // D s_2121_2: read-reg s_2121_1:i
        let s_2121_2: i128 = {
            let value = state.read_register::<i128>(s_2121_1 as isize);
            tracer.read_register(s_2121_1 as isize, value);
            value
        };
        // D s_2121_3: cmp-lt s_2121_2 s_2121_0
        let s_2121_3: bool = ((s_2121_2) < (s_2121_0));
        // D s_2121_4: write-var gs#401660 <= s_2121_3
        fn_state.gs_401660 = s_2121_3;
        // N s_2121_5: jump b1013
        return block_1013(state, tracer, fn_state);
    }
    fn block_2122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2122_0: const #20s : i
        let s_2122_0: i128 = 20;
        // D s_2122_1: read-var u#31708:u32
        let s_2122_1: u32 = fn_state.u_31708;
        // D s_2122_2: cast zx s_2122_1 -> bv
        let s_2122_2: Bits = Bits::new(s_2122_1 as u128, 32u16);
        // C s_2122_3: const #1s : i64
        let s_2122_3: i64 = 1;
        // C s_2122_4: cast zx s_2122_3 -> i
        let s_2122_4: i128 = (i128::try_from(s_2122_3).unwrap());
        // C s_2122_5: const #1s : i
        let s_2122_5: i128 = 1;
        // C s_2122_6: add s_2122_5 s_2122_4
        let s_2122_6: i128 = (s_2122_5 + s_2122_4);
        // D s_2122_7: bit-extract s_2122_2 s_2122_0 s_2122_6
        let s_2122_7: Bits = (Bits::new(
            ((s_2122_2) >> (s_2122_0)).value(),
            u16::try_from(s_2122_6).unwrap(),
        ));
        // D s_2122_8: cast reint s_2122_7 -> u8
        let s_2122_8: u8 = (s_2122_7.value() as u8);
        // D s_2122_9: cast zx s_2122_8 -> bv
        let s_2122_9: Bits = Bits::new(s_2122_8 as u128, 2u16);
        // C s_2122_10: const #3u : u8
        let s_2122_10: u8 = 3;
        // C s_2122_11: cast zx s_2122_10 -> bv
        let s_2122_11: Bits = Bits::new(s_2122_10 as u128, 2u16);
        // D s_2122_12: cmp-eq s_2122_9 s_2122_11
        let s_2122_12: bool = ((s_2122_9) == (s_2122_11));
        // N s_2122_13: branch s_2122_12 b2125 b2123
        if s_2122_12 {
            return block_2125(state, tracer, fn_state);
        } else {
            return block_2123(state, tracer, fn_state);
        };
    }
    fn block_2123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2123_0: const #0u : u8
        let s_2123_0: bool = false;
        // D s_2123_1: write-var gs#401657 <= s_2123_0
        fn_state.gs_401657 = s_2123_0;
        // N s_2123_2: jump b2124
        return block_2124(state, tracer, fn_state);
    }
    fn block_2124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2124_0: read-var gs#401657:u8
        let s_2124_0: bool = fn_state.gs_401657;
        // D s_2124_1: write-var gs#401658 <= s_2124_0
        fn_state.gs_401658 = s_2124_0;
        // N s_2124_2: jump b1011
        return block_1011(state, tracer, fn_state);
    }
    fn block_2125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2125_0: const #16s : i
        let s_2125_0: i128 = 16;
        // D s_2125_1: read-var u#31708:u32
        let s_2125_1: u32 = fn_state.u_31708;
        // D s_2125_2: cast zx s_2125_1 -> bv
        let s_2125_2: Bits = Bits::new(s_2125_1 as u128, 32u16);
        // C s_2125_3: const #1s : i64
        let s_2125_3: i64 = 1;
        // C s_2125_4: cast zx s_2125_3 -> i
        let s_2125_4: i128 = (i128::try_from(s_2125_3).unwrap());
        // C s_2125_5: const #1s : i
        let s_2125_5: i128 = 1;
        // C s_2125_6: add s_2125_5 s_2125_4
        let s_2125_6: i128 = (s_2125_5 + s_2125_4);
        // D s_2125_7: bit-extract s_2125_2 s_2125_0 s_2125_6
        let s_2125_7: Bits = (Bits::new(
            ((s_2125_2) >> (s_2125_0)).value(),
            u16::try_from(s_2125_6).unwrap(),
        ));
        // D s_2125_8: cast reint s_2125_7 -> u8
        let s_2125_8: u8 = (s_2125_7.value() as u8);
        // D s_2125_9: cast zx s_2125_8 -> bv
        let s_2125_9: Bits = Bits::new(s_2125_8 as u128, 2u16);
        // C s_2125_10: const #3u : u8
        let s_2125_10: u8 = 3;
        // C s_2125_11: cast zx s_2125_10 -> bv
        let s_2125_11: Bits = Bits::new(s_2125_10 as u128, 2u16);
        // D s_2125_12: cmp-eq s_2125_9 s_2125_11
        let s_2125_12: bool = ((s_2125_9) == (s_2125_11));
        // N s_2125_13: branch s_2125_12 b2128 b2126
        if s_2125_12 {
            return block_2128(state, tracer, fn_state);
        } else {
            return block_2126(state, tracer, fn_state);
        };
    }
    fn block_2126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2126_0: const #0u : u8
        let s_2126_0: bool = false;
        // D s_2126_1: write-var gs#401656 <= s_2126_0
        fn_state.gs_401656 = s_2126_0;
        // N s_2126_2: jump b2127
        return block_2127(state, tracer, fn_state);
    }
    fn block_2127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2127_0: read-var gs#401656:u8
        let s_2127_0: bool = fn_state.gs_401656;
        // D s_2127_1: write-var gs#401657 <= s_2127_0
        fn_state.gs_401657 = s_2127_0;
        // N s_2127_2: jump b2124
        return block_2124(state, tracer, fn_state);
    }
    fn block_2128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2128_0: const #9s : i
        let s_2128_0: i128 = 9;
        // D s_2128_1: read-var u#31708:u32
        let s_2128_1: u32 = fn_state.u_31708;
        // D s_2128_2: cast zx s_2128_1 -> bv
        let s_2128_2: Bits = Bits::new(s_2128_1 as u128, 32u16);
        // C s_2128_3: const #1s : i64
        let s_2128_3: i64 = 1;
        // C s_2128_4: cast zx s_2128_3 -> i
        let s_2128_4: i128 = (i128::try_from(s_2128_3).unwrap());
        // C s_2128_5: const #2s : i
        let s_2128_5: i128 = 2;
        // C s_2128_6: add s_2128_5 s_2128_4
        let s_2128_6: i128 = (s_2128_5 + s_2128_4);
        // D s_2128_7: bit-extract s_2128_2 s_2128_0 s_2128_6
        let s_2128_7: Bits = (Bits::new(
            ((s_2128_2) >> (s_2128_0)).value(),
            u16::try_from(s_2128_6).unwrap(),
        ));
        // D s_2128_8: cast reint s_2128_7 -> u8
        let s_2128_8: u8 = (s_2128_7.value() as u8);
        // D s_2128_9: cast zx s_2128_8 -> bv
        let s_2128_9: Bits = Bits::new(s_2128_8 as u128, 3u16);
        // C s_2128_10: const #2u : u8
        let s_2128_10: u8 = 2;
        // C s_2128_11: cast zx s_2128_10 -> bv
        let s_2128_11: Bits = Bits::new(s_2128_10 as u128, 3u16);
        // D s_2128_12: cmp-eq s_2128_9 s_2128_11
        let s_2128_12: bool = ((s_2128_9) == (s_2128_11));
        // N s_2128_13: branch s_2128_12 b2131 b2129
        if s_2128_12 {
            return block_2131(state, tracer, fn_state);
        } else {
            return block_2129(state, tracer, fn_state);
        };
    }
    fn block_2129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2129_0: const #0u : u8
        let s_2129_0: bool = false;
        // D s_2129_1: write-var gs#401655 <= s_2129_0
        fn_state.gs_401655 = s_2129_0;
        // N s_2129_2: jump b2130
        return block_2130(state, tracer, fn_state);
    }
    fn block_2130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2130_0: read-var gs#401655:u8
        let s_2130_0: bool = fn_state.gs_401655;
        // D s_2130_1: write-var gs#401656 <= s_2130_0
        fn_state.gs_401656 = s_2130_0;
        // N s_2130_2: jump b2127
        return block_2127(state, tracer, fn_state);
    }
    fn block_2131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2131_0: const #7s : i
        let s_2131_0: i128 = 7;
        // D s_2131_1: read-var u#31708:u32
        let s_2131_1: u32 = fn_state.u_31708;
        // D s_2131_2: cast zx s_2131_1 -> bv
        let s_2131_2: Bits = Bits::new(s_2131_1 as u128, 32u16);
        // C s_2131_3: const #1s : i64
        let s_2131_3: i64 = 1;
        // C s_2131_4: cast zx s_2131_3 -> i
        let s_2131_4: i128 = (i128::try_from(s_2131_3).unwrap());
        // C s_2131_5: const #0s : i
        let s_2131_5: i128 = 0;
        // C s_2131_6: add s_2131_5 s_2131_4
        let s_2131_6: i128 = (s_2131_5 + s_2131_4);
        // D s_2131_7: bit-extract s_2131_2 s_2131_0 s_2131_6
        let s_2131_7: Bits = (Bits::new(
            ((s_2131_2) >> (s_2131_0)).value(),
            u16::try_from(s_2131_6).unwrap(),
        ));
        // D s_2131_8: cast reint s_2131_7 -> u8
        let s_2131_8: bool = ((s_2131_7.value()) != 0);
        // D s_2131_9: cast zx s_2131_8 -> bv
        let s_2131_9: Bits = Bits::new(s_2131_8 as u128, 1u16);
        // C s_2131_10: const #0u : u8
        let s_2131_10: bool = false;
        // C s_2131_11: cast zx s_2131_10 -> bv
        let s_2131_11: Bits = Bits::new(s_2131_10 as u128, 1u16);
        // D s_2131_12: cmp-eq s_2131_9 s_2131_11
        let s_2131_12: bool = ((s_2131_9) == (s_2131_11));
        // N s_2131_13: branch s_2131_12 b2134 b2132
        if s_2131_12 {
            return block_2134(state, tracer, fn_state);
        } else {
            return block_2132(state, tracer, fn_state);
        };
    }
    fn block_2132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2132_0: const #0u : u8
        let s_2132_0: bool = false;
        // D s_2132_1: write-var gs#401654 <= s_2132_0
        fn_state.gs_401654 = s_2132_0;
        // N s_2132_2: jump b2133
        return block_2133(state, tracer, fn_state);
    }
    fn block_2133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2133_0: read-var gs#401654:u8
        let s_2133_0: bool = fn_state.gs_401654;
        // D s_2133_1: write-var gs#401655 <= s_2133_0
        fn_state.gs_401655 = s_2133_0;
        // N s_2133_2: jump b2130
        return block_2130(state, tracer, fn_state);
    }
    fn block_2134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2134_0: const #4s : i
        let s_2134_0: i128 = 4;
        // D s_2134_1: read-var u#31708:u32
        let s_2134_1: u32 = fn_state.u_31708;
        // D s_2134_2: cast zx s_2134_1 -> bv
        let s_2134_2: Bits = Bits::new(s_2134_1 as u128, 32u16);
        // C s_2134_3: const #1s : i64
        let s_2134_3: i64 = 1;
        // C s_2134_4: cast zx s_2134_3 -> i
        let s_2134_4: i128 = (i128::try_from(s_2134_3).unwrap());
        // C s_2134_5: const #0s : i
        let s_2134_5: i128 = 0;
        // C s_2134_6: add s_2134_5 s_2134_4
        let s_2134_6: i128 = (s_2134_5 + s_2134_4);
        // D s_2134_7: bit-extract s_2134_2 s_2134_0 s_2134_6
        let s_2134_7: Bits = (Bits::new(
            ((s_2134_2) >> (s_2134_0)).value(),
            u16::try_from(s_2134_6).unwrap(),
        ));
        // D s_2134_8: cast reint s_2134_7 -> u8
        let s_2134_8: bool = ((s_2134_7.value()) != 0);
        // D s_2134_9: cast zx s_2134_8 -> bv
        let s_2134_9: Bits = Bits::new(s_2134_8 as u128, 1u16);
        // C s_2134_10: const #0u : u8
        let s_2134_10: bool = false;
        // C s_2134_11: cast zx s_2134_10 -> bv
        let s_2134_11: Bits = Bits::new(s_2134_10 as u128, 1u16);
        // D s_2134_12: cmp-eq s_2134_9 s_2134_11
        let s_2134_12: bool = ((s_2134_9) == (s_2134_11));
        // D s_2134_13: write-var gs#401654 <= s_2134_12
        fn_state.gs_401654 = s_2134_12;
        // N s_2134_14: jump b2133
        return block_2133(state, tracer, fn_state);
    }
    fn block_2135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2135_0: const #3648s : i
        let s_2135_0: i128 = 3648;
        // C s_2135_1: const #14696u : u32
        let s_2135_1: u32 = 14696;
        // D s_2135_2: read-reg s_2135_1:i
        let s_2135_2: i128 = {
            let value = state.read_register::<i128>(s_2135_1 as isize);
            tracer.read_register(s_2135_1 as isize, value);
            value
        };
        // D s_2135_3: cmp-lt s_2135_2 s_2135_0
        let s_2135_3: bool = ((s_2135_2) < (s_2135_0));
        // D s_2135_4: write-var gs#401624 <= s_2135_3
        fn_state.gs_401624 = s_2135_3;
        // N s_2135_5: jump b1007
        return block_1007(state, tracer, fn_state);
    }
    fn block_2136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2136_0: const #8s : i
        let s_2136_0: i128 = 8;
        // D s_2136_1: read-var u#31699:u32
        let s_2136_1: u32 = fn_state.u_31699;
        // D s_2136_2: cast zx s_2136_1 -> bv
        let s_2136_2: Bits = Bits::new(s_2136_1 as u128, 32u16);
        // C s_2136_3: const #1s : i64
        let s_2136_3: i64 = 1;
        // C s_2136_4: cast zx s_2136_3 -> i
        let s_2136_4: i128 = (i128::try_from(s_2136_3).unwrap());
        // C s_2136_5: const #3s : i
        let s_2136_5: i128 = 3;
        // C s_2136_6: add s_2136_5 s_2136_4
        let s_2136_6: i128 = (s_2136_5 + s_2136_4);
        // D s_2136_7: bit-extract s_2136_2 s_2136_0 s_2136_6
        let s_2136_7: Bits = (Bits::new(
            ((s_2136_2) >> (s_2136_0)).value(),
            u16::try_from(s_2136_6).unwrap(),
        ));
        // D s_2136_8: cast reint s_2136_7 -> u8
        let s_2136_8: u8 = (s_2136_7.value() as u8);
        // D s_2136_9: cast zx s_2136_8 -> bv
        let s_2136_9: Bits = Bits::new(s_2136_8 as u128, 4u16);
        // C s_2136_10: const #4u : u8
        let s_2136_10: u8 = 4;
        // C s_2136_11: cast zx s_2136_10 -> bv
        let s_2136_11: Bits = Bits::new(s_2136_10 as u128, 4u16);
        // D s_2136_12: cmp-eq s_2136_9 s_2136_11
        let s_2136_12: bool = ((s_2136_9) == (s_2136_11));
        // N s_2136_13: branch s_2136_12 b2139 b2137
        if s_2136_12 {
            return block_2139(state, tracer, fn_state);
        } else {
            return block_2137(state, tracer, fn_state);
        };
    }
    fn block_2137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2137_0: const #0u : u8
        let s_2137_0: bool = false;
        // D s_2137_1: write-var gs#401621 <= s_2137_0
        fn_state.gs_401621 = s_2137_0;
        // N s_2137_2: jump b2138
        return block_2138(state, tracer, fn_state);
    }
    fn block_2138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2138_0: read-var gs#401621:u8
        let s_2138_0: bool = fn_state.gs_401621;
        // D s_2138_1: write-var gs#401622 <= s_2138_0
        fn_state.gs_401622 = s_2138_0;
        // N s_2138_2: jump b1005
        return block_1005(state, tracer, fn_state);
    }
    fn block_2139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2139_0: const #6s : i
        let s_2139_0: i128 = 6;
        // D s_2139_1: read-var u#31699:u32
        let s_2139_1: u32 = fn_state.u_31699;
        // D s_2139_2: cast zx s_2139_1 -> bv
        let s_2139_2: Bits = Bits::new(s_2139_1 as u128, 32u16);
        // C s_2139_3: const #1s : i64
        let s_2139_3: i64 = 1;
        // C s_2139_4: cast zx s_2139_3 -> i
        let s_2139_4: i128 = (i128::try_from(s_2139_3).unwrap());
        // C s_2139_5: const #0s : i
        let s_2139_5: i128 = 0;
        // C s_2139_6: add s_2139_5 s_2139_4
        let s_2139_6: i128 = (s_2139_5 + s_2139_4);
        // D s_2139_7: bit-extract s_2139_2 s_2139_0 s_2139_6
        let s_2139_7: Bits = (Bits::new(
            ((s_2139_2) >> (s_2139_0)).value(),
            u16::try_from(s_2139_6).unwrap(),
        ));
        // D s_2139_8: cast reint s_2139_7 -> u8
        let s_2139_8: bool = ((s_2139_7.value()) != 0);
        // D s_2139_9: cast zx s_2139_8 -> bv
        let s_2139_9: Bits = Bits::new(s_2139_8 as u128, 1u16);
        // C s_2139_10: const #0u : u8
        let s_2139_10: bool = false;
        // C s_2139_11: cast zx s_2139_10 -> bv
        let s_2139_11: Bits = Bits::new(s_2139_10 as u128, 1u16);
        // D s_2139_12: cmp-eq s_2139_9 s_2139_11
        let s_2139_12: bool = ((s_2139_9) == (s_2139_11));
        // N s_2139_13: branch s_2139_12 b2142 b2140
        if s_2139_12 {
            return block_2142(state, tracer, fn_state);
        } else {
            return block_2140(state, tracer, fn_state);
        };
    }
    fn block_2140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2140_0: const #0u : u8
        let s_2140_0: bool = false;
        // D s_2140_1: write-var gs#401620 <= s_2140_0
        fn_state.gs_401620 = s_2140_0;
        // N s_2140_2: jump b2141
        return block_2141(state, tracer, fn_state);
    }
    fn block_2141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2141_0: read-var gs#401620:u8
        let s_2141_0: bool = fn_state.gs_401620;
        // D s_2141_1: write-var gs#401621 <= s_2141_0
        fn_state.gs_401621 = s_2141_0;
        // N s_2141_2: jump b2138
        return block_2138(state, tracer, fn_state);
    }
    fn block_2142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2142_0: const #4s : i
        let s_2142_0: i128 = 4;
        // D s_2142_1: read-var u#31699:u32
        let s_2142_1: u32 = fn_state.u_31699;
        // D s_2142_2: cast zx s_2142_1 -> bv
        let s_2142_2: Bits = Bits::new(s_2142_1 as u128, 32u16);
        // C s_2142_3: const #1s : i64
        let s_2142_3: i64 = 1;
        // C s_2142_4: cast zx s_2142_3 -> i
        let s_2142_4: i128 = (i128::try_from(s_2142_3).unwrap());
        // C s_2142_5: const #0s : i
        let s_2142_5: i128 = 0;
        // C s_2142_6: add s_2142_5 s_2142_4
        let s_2142_6: i128 = (s_2142_5 + s_2142_4);
        // D s_2142_7: bit-extract s_2142_2 s_2142_0 s_2142_6
        let s_2142_7: Bits = (Bits::new(
            ((s_2142_2) >> (s_2142_0)).value(),
            u16::try_from(s_2142_6).unwrap(),
        ));
        // D s_2142_8: cast reint s_2142_7 -> u8
        let s_2142_8: bool = ((s_2142_7.value()) != 0);
        // D s_2142_9: cast zx s_2142_8 -> bv
        let s_2142_9: Bits = Bits::new(s_2142_8 as u128, 1u16);
        // C s_2142_10: const #0u : u8
        let s_2142_10: bool = false;
        // C s_2142_11: cast zx s_2142_10 -> bv
        let s_2142_11: Bits = Bits::new(s_2142_10 as u128, 1u16);
        // D s_2142_12: cmp-eq s_2142_9 s_2142_11
        let s_2142_12: bool = ((s_2142_9) == (s_2142_11));
        // D s_2142_13: write-var gs#401620 <= s_2142_12
        fn_state.gs_401620 = s_2142_12;
        // N s_2142_14: jump b2141
        return block_2141(state, tracer, fn_state);
    }
    fn block_2143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2143_0: const #3646s : i
        let s_2143_0: i128 = 3646;
        // C s_2143_1: const #14696u : u32
        let s_2143_1: u32 = 14696;
        // D s_2143_2: read-reg s_2143_1:i
        let s_2143_2: i128 = {
            let value = state.read_register::<i128>(s_2143_1 as isize);
            tracer.read_register(s_2143_1 as isize, value);
            value
        };
        // D s_2143_3: cmp-lt s_2143_2 s_2143_0
        let s_2143_3: bool = ((s_2143_2) < (s_2143_0));
        // D s_2143_4: write-var gs#401590 <= s_2143_3
        fn_state.gs_401590 = s_2143_3;
        // N s_2143_5: jump b1001
        return block_1001(state, tracer, fn_state);
    }
    fn block_2144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2144_0: const #23s : i
        let s_2144_0: i128 = 23;
        // D s_2144_1: read-var u#31688:u32
        let s_2144_1: u32 = fn_state.u_31688;
        // D s_2144_2: cast zx s_2144_1 -> bv
        let s_2144_2: Bits = Bits::new(s_2144_1 as u128, 32u16);
        // C s_2144_3: const #1s : i64
        let s_2144_3: i64 = 1;
        // C s_2144_4: cast zx s_2144_3 -> i
        let s_2144_4: i128 = (i128::try_from(s_2144_3).unwrap());
        // C s_2144_5: const #0s : i
        let s_2144_5: i128 = 0;
        // C s_2144_6: add s_2144_5 s_2144_4
        let s_2144_6: i128 = (s_2144_5 + s_2144_4);
        // D s_2144_7: bit-extract s_2144_2 s_2144_0 s_2144_6
        let s_2144_7: Bits = (Bits::new(
            ((s_2144_2) >> (s_2144_0)).value(),
            u16::try_from(s_2144_6).unwrap(),
        ));
        // D s_2144_8: cast reint s_2144_7 -> u8
        let s_2144_8: bool = ((s_2144_7.value()) != 0);
        // D s_2144_9: cast zx s_2144_8 -> bv
        let s_2144_9: Bits = Bits::new(s_2144_8 as u128, 1u16);
        // C s_2144_10: const #0u : u8
        let s_2144_10: bool = false;
        // C s_2144_11: cast zx s_2144_10 -> bv
        let s_2144_11: Bits = Bits::new(s_2144_10 as u128, 1u16);
        // D s_2144_12: cmp-eq s_2144_9 s_2144_11
        let s_2144_12: bool = ((s_2144_9) == (s_2144_11));
        // N s_2144_13: branch s_2144_12 b2147 b2145
        if s_2144_12 {
            return block_2147(state, tracer, fn_state);
        } else {
            return block_2145(state, tracer, fn_state);
        };
    }
    fn block_2145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2145_0: const #0u : u8
        let s_2145_0: bool = false;
        // D s_2145_1: write-var gs#401587 <= s_2145_0
        fn_state.gs_401587 = s_2145_0;
        // N s_2145_2: jump b2146
        return block_2146(state, tracer, fn_state);
    }
    fn block_2146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2146_0: read-var gs#401587:u8
        let s_2146_0: bool = fn_state.gs_401587;
        // D s_2146_1: write-var gs#401588 <= s_2146_0
        fn_state.gs_401588 = s_2146_0;
        // N s_2146_2: jump b999
        return block_999(state, tracer, fn_state);
    }
    fn block_2147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2147_0: const #8s : i
        let s_2147_0: i128 = 8;
        // D s_2147_1: read-var u#31688:u32
        let s_2147_1: u32 = fn_state.u_31688;
        // D s_2147_2: cast zx s_2147_1 -> bv
        let s_2147_2: Bits = Bits::new(s_2147_1 as u128, 32u16);
        // C s_2147_3: const #1s : i64
        let s_2147_3: i64 = 1;
        // C s_2147_4: cast zx s_2147_3 -> i
        let s_2147_4: i128 = (i128::try_from(s_2147_3).unwrap());
        // C s_2147_5: const #3s : i
        let s_2147_5: i128 = 3;
        // C s_2147_6: add s_2147_5 s_2147_4
        let s_2147_6: i128 = (s_2147_5 + s_2147_4);
        // D s_2147_7: bit-extract s_2147_2 s_2147_0 s_2147_6
        let s_2147_7: Bits = (Bits::new(
            ((s_2147_2) >> (s_2147_0)).value(),
            u16::try_from(s_2147_6).unwrap(),
        ));
        // D s_2147_8: cast reint s_2147_7 -> u8
        let s_2147_8: u8 = (s_2147_7.value() as u8);
        // D s_2147_9: cast zx s_2147_8 -> bv
        let s_2147_9: Bits = Bits::new(s_2147_8 as u128, 4u16);
        // C s_2147_10: const #2u : u8
        let s_2147_10: u8 = 2;
        // C s_2147_11: cast zx s_2147_10 -> bv
        let s_2147_11: Bits = Bits::new(s_2147_10 as u128, 4u16);
        // D s_2147_12: cmp-eq s_2147_9 s_2147_11
        let s_2147_12: bool = ((s_2147_9) == (s_2147_11));
        // N s_2147_13: branch s_2147_12 b2150 b2148
        if s_2147_12 {
            return block_2150(state, tracer, fn_state);
        } else {
            return block_2148(state, tracer, fn_state);
        };
    }
    fn block_2148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2148_0: const #0u : u8
        let s_2148_0: bool = false;
        // D s_2148_1: write-var gs#401586 <= s_2148_0
        fn_state.gs_401586 = s_2148_0;
        // N s_2148_2: jump b2149
        return block_2149(state, tracer, fn_state);
    }
    fn block_2149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2149_0: read-var gs#401586:u8
        let s_2149_0: bool = fn_state.gs_401586;
        // D s_2149_1: write-var gs#401587 <= s_2149_0
        fn_state.gs_401587 = s_2149_0;
        // N s_2149_2: jump b2146
        return block_2146(state, tracer, fn_state);
    }
    fn block_2150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2150_0: const #4s : i
        let s_2150_0: i128 = 4;
        // D s_2150_1: read-var u#31688:u32
        let s_2150_1: u32 = fn_state.u_31688;
        // D s_2150_2: cast zx s_2150_1 -> bv
        let s_2150_2: Bits = Bits::new(s_2150_1 as u128, 32u16);
        // C s_2150_3: const #1s : i64
        let s_2150_3: i64 = 1;
        // C s_2150_4: cast zx s_2150_3 -> i
        let s_2150_4: i128 = (i128::try_from(s_2150_3).unwrap());
        // C s_2150_5: const #0s : i
        let s_2150_5: i128 = 0;
        // C s_2150_6: add s_2150_5 s_2150_4
        let s_2150_6: i128 = (s_2150_5 + s_2150_4);
        // D s_2150_7: bit-extract s_2150_2 s_2150_0 s_2150_6
        let s_2150_7: Bits = (Bits::new(
            ((s_2150_2) >> (s_2150_0)).value(),
            u16::try_from(s_2150_6).unwrap(),
        ));
        // D s_2150_8: cast reint s_2150_7 -> u8
        let s_2150_8: bool = ((s_2150_7.value()) != 0);
        // D s_2150_9: cast zx s_2150_8 -> bv
        let s_2150_9: Bits = Bits::new(s_2150_8 as u128, 1u16);
        // C s_2150_10: const #1u : u8
        let s_2150_10: bool = true;
        // C s_2150_11: cast zx s_2150_10 -> bv
        let s_2150_11: Bits = Bits::new(s_2150_10 as u128, 1u16);
        // D s_2150_12: cmp-eq s_2150_9 s_2150_11
        let s_2150_12: bool = ((s_2150_9) == (s_2150_11));
        // D s_2150_13: write-var gs#401586 <= s_2150_12
        fn_state.gs_401586 = s_2150_12;
        // N s_2150_14: jump b2149
        return block_2149(state, tracer, fn_state);
    }
    fn block_2151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2151_0: const #3644s : i
        let s_2151_0: i128 = 3644;
        // C s_2151_1: const #14696u : u32
        let s_2151_1: u32 = 14696;
        // D s_2151_2: read-reg s_2151_1:i
        let s_2151_2: i128 = {
            let value = state.read_register::<i128>(s_2151_1 as isize);
            tracer.read_register(s_2151_1 as isize, value);
            value
        };
        // D s_2151_3: cmp-lt s_2151_2 s_2151_0
        let s_2151_3: bool = ((s_2151_2) < (s_2151_0));
        // D s_2151_4: write-var gs#401560 <= s_2151_3
        fn_state.gs_401560 = s_2151_3;
        // N s_2151_5: jump b995
        return block_995(state, tracer, fn_state);
    }
    fn block_2152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2152_0: const #23s : i
        let s_2152_0: i128 = 23;
        // D s_2152_1: read-var u#31679:u32
        let s_2152_1: u32 = fn_state.u_31679;
        // D s_2152_2: cast zx s_2152_1 -> bv
        let s_2152_2: Bits = Bits::new(s_2152_1 as u128, 32u16);
        // C s_2152_3: const #1s : i64
        let s_2152_3: i64 = 1;
        // C s_2152_4: cast zx s_2152_3 -> i
        let s_2152_4: i128 = (i128::try_from(s_2152_3).unwrap());
        // C s_2152_5: const #0s : i
        let s_2152_5: i128 = 0;
        // C s_2152_6: add s_2152_5 s_2152_4
        let s_2152_6: i128 = (s_2152_5 + s_2152_4);
        // D s_2152_7: bit-extract s_2152_2 s_2152_0 s_2152_6
        let s_2152_7: Bits = (Bits::new(
            ((s_2152_2) >> (s_2152_0)).value(),
            u16::try_from(s_2152_6).unwrap(),
        ));
        // D s_2152_8: cast reint s_2152_7 -> u8
        let s_2152_8: bool = ((s_2152_7.value()) != 0);
        // D s_2152_9: cast zx s_2152_8 -> bv
        let s_2152_9: Bits = Bits::new(s_2152_8 as u128, 1u16);
        // C s_2152_10: const #1u : u8
        let s_2152_10: bool = true;
        // C s_2152_11: cast zx s_2152_10 -> bv
        let s_2152_11: Bits = Bits::new(s_2152_10 as u128, 1u16);
        // D s_2152_12: cmp-eq s_2152_9 s_2152_11
        let s_2152_12: bool = ((s_2152_9) == (s_2152_11));
        // N s_2152_13: branch s_2152_12 b2155 b2153
        if s_2152_12 {
            return block_2155(state, tracer, fn_state);
        } else {
            return block_2153(state, tracer, fn_state);
        };
    }
    fn block_2153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2153_0: const #0u : u8
        let s_2153_0: bool = false;
        // D s_2153_1: write-var gs#401557 <= s_2153_0
        fn_state.gs_401557 = s_2153_0;
        // N s_2153_2: jump b2154
        return block_2154(state, tracer, fn_state);
    }
    fn block_2154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2154_0: read-var gs#401557:u8
        let s_2154_0: bool = fn_state.gs_401557;
        // D s_2154_1: write-var gs#401558 <= s_2154_0
        fn_state.gs_401558 = s_2154_0;
        // N s_2154_2: jump b993
        return block_993(state, tracer, fn_state);
    }
    fn block_2155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2155_0: const #9s : i
        let s_2155_0: i128 = 9;
        // D s_2155_1: read-var u#31679:u32
        let s_2155_1: u32 = fn_state.u_31679;
        // D s_2155_2: cast zx s_2155_1 -> bv
        let s_2155_2: Bits = Bits::new(s_2155_1 as u128, 32u16);
        // C s_2155_3: const #1s : i64
        let s_2155_3: i64 = 1;
        // C s_2155_4: cast zx s_2155_3 -> i
        let s_2155_4: i128 = (i128::try_from(s_2155_3).unwrap());
        // C s_2155_5: const #2s : i
        let s_2155_5: i128 = 2;
        // C s_2155_6: add s_2155_5 s_2155_4
        let s_2155_6: i128 = (s_2155_5 + s_2155_4);
        // D s_2155_7: bit-extract s_2155_2 s_2155_0 s_2155_6
        let s_2155_7: Bits = (Bits::new(
            ((s_2155_2) >> (s_2155_0)).value(),
            u16::try_from(s_2155_6).unwrap(),
        ));
        // D s_2155_8: cast reint s_2155_7 -> u8
        let s_2155_8: u8 = (s_2155_7.value() as u8);
        // D s_2155_9: cast zx s_2155_8 -> bv
        let s_2155_9: Bits = Bits::new(s_2155_8 as u128, 3u16);
        // C s_2155_10: const #4u : u8
        let s_2155_10: u8 = 4;
        // C s_2155_11: cast zx s_2155_10 -> bv
        let s_2155_11: Bits = Bits::new(s_2155_10 as u128, 3u16);
        // D s_2155_12: cmp-eq s_2155_9 s_2155_11
        let s_2155_12: bool = ((s_2155_9) == (s_2155_11));
        // N s_2155_13: branch s_2155_12 b2158 b2156
        if s_2155_12 {
            return block_2158(state, tracer, fn_state);
        } else {
            return block_2156(state, tracer, fn_state);
        };
    }
    fn block_2156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2156_0: const #0u : u8
        let s_2156_0: bool = false;
        // D s_2156_1: write-var gs#401556 <= s_2156_0
        fn_state.gs_401556 = s_2156_0;
        // N s_2156_2: jump b2157
        return block_2157(state, tracer, fn_state);
    }
    fn block_2157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2157_0: read-var gs#401556:u8
        let s_2157_0: bool = fn_state.gs_401556;
        // D s_2157_1: write-var gs#401557 <= s_2157_0
        fn_state.gs_401557 = s_2157_0;
        // N s_2157_2: jump b2154
        return block_2154(state, tracer, fn_state);
    }
    fn block_2158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2158_0: const #6s : i
        let s_2158_0: i128 = 6;
        // D s_2158_1: read-var u#31679:u32
        let s_2158_1: u32 = fn_state.u_31679;
        // D s_2158_2: cast zx s_2158_1 -> bv
        let s_2158_2: Bits = Bits::new(s_2158_1 as u128, 32u16);
        // C s_2158_3: const #1s : i64
        let s_2158_3: i64 = 1;
        // C s_2158_4: cast zx s_2158_3 -> i
        let s_2158_4: i128 = (i128::try_from(s_2158_3).unwrap());
        // C s_2158_5: const #1s : i
        let s_2158_5: i128 = 1;
        // C s_2158_6: add s_2158_5 s_2158_4
        let s_2158_6: i128 = (s_2158_5 + s_2158_4);
        // D s_2158_7: bit-extract s_2158_2 s_2158_0 s_2158_6
        let s_2158_7: Bits = (Bits::new(
            ((s_2158_2) >> (s_2158_0)).value(),
            u16::try_from(s_2158_6).unwrap(),
        ));
        // D s_2158_8: cast reint s_2158_7 -> u8
        let s_2158_8: u8 = (s_2158_7.value() as u8);
        // D s_2158_9: cast zx s_2158_8 -> bv
        let s_2158_9: Bits = Bits::new(s_2158_8 as u128, 2u16);
        // C s_2158_10: const #0u : u8
        let s_2158_10: u8 = 0;
        // C s_2158_11: cast zx s_2158_10 -> bv
        let s_2158_11: Bits = Bits::new(s_2158_10 as u128, 2u16);
        // D s_2158_12: cmp-eq s_2158_9 s_2158_11
        let s_2158_12: bool = ((s_2158_9) == (s_2158_11));
        // N s_2158_13: branch s_2158_12 b2161 b2159
        if s_2158_12 {
            return block_2161(state, tracer, fn_state);
        } else {
            return block_2159(state, tracer, fn_state);
        };
    }
    fn block_2159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2159_0: const #0u : u8
        let s_2159_0: bool = false;
        // D s_2159_1: write-var gs#401555 <= s_2159_0
        fn_state.gs_401555 = s_2159_0;
        // N s_2159_2: jump b2160
        return block_2160(state, tracer, fn_state);
    }
    fn block_2160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2160_0: read-var gs#401555:u8
        let s_2160_0: bool = fn_state.gs_401555;
        // D s_2160_1: write-var gs#401556 <= s_2160_0
        fn_state.gs_401556 = s_2160_0;
        // N s_2160_2: jump b2157
        return block_2157(state, tracer, fn_state);
    }
    fn block_2161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2161_0: const #4s : i
        let s_2161_0: i128 = 4;
        // D s_2161_1: read-var u#31679:u32
        let s_2161_1: u32 = fn_state.u_31679;
        // D s_2161_2: cast zx s_2161_1 -> bv
        let s_2161_2: Bits = Bits::new(s_2161_1 as u128, 32u16);
        // C s_2161_3: const #1s : i64
        let s_2161_3: i64 = 1;
        // C s_2161_4: cast zx s_2161_3 -> i
        let s_2161_4: i128 = (i128::try_from(s_2161_3).unwrap());
        // C s_2161_5: const #0s : i
        let s_2161_5: i128 = 0;
        // C s_2161_6: add s_2161_5 s_2161_4
        let s_2161_6: i128 = (s_2161_5 + s_2161_4);
        // D s_2161_7: bit-extract s_2161_2 s_2161_0 s_2161_6
        let s_2161_7: Bits = (Bits::new(
            ((s_2161_2) >> (s_2161_0)).value(),
            u16::try_from(s_2161_6).unwrap(),
        ));
        // D s_2161_8: cast reint s_2161_7 -> u8
        let s_2161_8: bool = ((s_2161_7.value()) != 0);
        // D s_2161_9: cast zx s_2161_8 -> bv
        let s_2161_9: Bits = Bits::new(s_2161_8 as u128, 1u16);
        // C s_2161_10: const #1u : u8
        let s_2161_10: bool = true;
        // C s_2161_11: cast zx s_2161_10 -> bv
        let s_2161_11: Bits = Bits::new(s_2161_10 as u128, 1u16);
        // D s_2161_12: cmp-eq s_2161_9 s_2161_11
        let s_2161_12: bool = ((s_2161_9) == (s_2161_11));
        // D s_2161_13: write-var gs#401555 <= s_2161_12
        fn_state.gs_401555 = s_2161_12;
        // N s_2161_14: jump b2160
        return block_2160(state, tracer, fn_state);
    }
    fn block_2162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2162_0: const #3642s : i
        let s_2162_0: i128 = 3642;
        // C s_2162_1: const #14696u : u32
        let s_2162_1: u32 = 14696;
        // D s_2162_2: read-reg s_2162_1:i
        let s_2162_2: i128 = {
            let value = state.read_register::<i128>(s_2162_1 as isize);
            tracer.read_register(s_2162_1 as isize, value);
            value
        };
        // D s_2162_3: cmp-lt s_2162_2 s_2162_0
        let s_2162_3: bool = ((s_2162_2) < (s_2162_0));
        // D s_2162_4: write-var gs#401523 <= s_2162_3
        fn_state.gs_401523 = s_2162_3;
        // N s_2162_5: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_2163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2163_0: const #23s : i
        let s_2163_0: i128 = 23;
        // D s_2163_1: read-var u#31668:u32
        let s_2163_1: u32 = fn_state.u_31668;
        // D s_2163_2: cast zx s_2163_1 -> bv
        let s_2163_2: Bits = Bits::new(s_2163_1 as u128, 32u16);
        // C s_2163_3: const #1s : i64
        let s_2163_3: i64 = 1;
        // C s_2163_4: cast zx s_2163_3 -> i
        let s_2163_4: i128 = (i128::try_from(s_2163_3).unwrap());
        // C s_2163_5: const #0s : i
        let s_2163_5: i128 = 0;
        // C s_2163_6: add s_2163_5 s_2163_4
        let s_2163_6: i128 = (s_2163_5 + s_2163_4);
        // D s_2163_7: bit-extract s_2163_2 s_2163_0 s_2163_6
        let s_2163_7: Bits = (Bits::new(
            ((s_2163_2) >> (s_2163_0)).value(),
            u16::try_from(s_2163_6).unwrap(),
        ));
        // D s_2163_8: cast reint s_2163_7 -> u8
        let s_2163_8: bool = ((s_2163_7.value()) != 0);
        // D s_2163_9: cast zx s_2163_8 -> bv
        let s_2163_9: Bits = Bits::new(s_2163_8 as u128, 1u16);
        // C s_2163_10: const #0u : u8
        let s_2163_10: bool = false;
        // C s_2163_11: cast zx s_2163_10 -> bv
        let s_2163_11: Bits = Bits::new(s_2163_10 as u128, 1u16);
        // D s_2163_12: cmp-eq s_2163_9 s_2163_11
        let s_2163_12: bool = ((s_2163_9) == (s_2163_11));
        // N s_2163_13: branch s_2163_12 b2166 b2164
        if s_2163_12 {
            return block_2166(state, tracer, fn_state);
        } else {
            return block_2164(state, tracer, fn_state);
        };
    }
    fn block_2164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2164_0: const #0u : u8
        let s_2164_0: bool = false;
        // D s_2164_1: write-var gs#401520 <= s_2164_0
        fn_state.gs_401520 = s_2164_0;
        // N s_2164_2: jump b2165
        return block_2165(state, tracer, fn_state);
    }
    fn block_2165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2165_0: read-var gs#401520:u8
        let s_2165_0: bool = fn_state.gs_401520;
        // D s_2165_1: write-var gs#401521 <= s_2165_0
        fn_state.gs_401521 = s_2165_0;
        // N s_2165_2: jump b987
        return block_987(state, tracer, fn_state);
    }
    fn block_2166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2166_0: const #8s : i
        let s_2166_0: i128 = 8;
        // D s_2166_1: read-var u#31668:u32
        let s_2166_1: u32 = fn_state.u_31668;
        // D s_2166_2: cast zx s_2166_1 -> bv
        let s_2166_2: Bits = Bits::new(s_2166_1 as u128, 32u16);
        // C s_2166_3: const #1s : i64
        let s_2166_3: i64 = 1;
        // C s_2166_4: cast zx s_2166_3 -> i
        let s_2166_4: i128 = (i128::try_from(s_2166_3).unwrap());
        // C s_2166_5: const #3s : i
        let s_2166_5: i128 = 3;
        // C s_2166_6: add s_2166_5 s_2166_4
        let s_2166_6: i128 = (s_2166_5 + s_2166_4);
        // D s_2166_7: bit-extract s_2166_2 s_2166_0 s_2166_6
        let s_2166_7: Bits = (Bits::new(
            ((s_2166_2) >> (s_2166_0)).value(),
            u16::try_from(s_2166_6).unwrap(),
        ));
        // D s_2166_8: cast reint s_2166_7 -> u8
        let s_2166_8: u8 = (s_2166_7.value() as u8);
        // D s_2166_9: cast zx s_2166_8 -> bv
        let s_2166_9: Bits = Bits::new(s_2166_8 as u128, 4u16);
        // C s_2166_10: const #4u : u8
        let s_2166_10: u8 = 4;
        // C s_2166_11: cast zx s_2166_10 -> bv
        let s_2166_11: Bits = Bits::new(s_2166_10 as u128, 4u16);
        // D s_2166_12: cmp-eq s_2166_9 s_2166_11
        let s_2166_12: bool = ((s_2166_9) == (s_2166_11));
        // N s_2166_13: branch s_2166_12 b2169 b2167
        if s_2166_12 {
            return block_2169(state, tracer, fn_state);
        } else {
            return block_2167(state, tracer, fn_state);
        };
    }
    fn block_2167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2167_0: const #0u : u8
        let s_2167_0: bool = false;
        // D s_2167_1: write-var gs#401519 <= s_2167_0
        fn_state.gs_401519 = s_2167_0;
        // N s_2167_2: jump b2168
        return block_2168(state, tracer, fn_state);
    }
    fn block_2168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2168_0: read-var gs#401519:u8
        let s_2168_0: bool = fn_state.gs_401519;
        // D s_2168_1: write-var gs#401520 <= s_2168_0
        fn_state.gs_401520 = s_2168_0;
        // N s_2168_2: jump b2165
        return block_2165(state, tracer, fn_state);
    }
    fn block_2169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2169_0: const #4s : i
        let s_2169_0: i128 = 4;
        // D s_2169_1: read-var u#31668:u32
        let s_2169_1: u32 = fn_state.u_31668;
        // D s_2169_2: cast zx s_2169_1 -> bv
        let s_2169_2: Bits = Bits::new(s_2169_1 as u128, 32u16);
        // C s_2169_3: const #1s : i64
        let s_2169_3: i64 = 1;
        // C s_2169_4: cast zx s_2169_3 -> i
        let s_2169_4: i128 = (i128::try_from(s_2169_3).unwrap());
        // C s_2169_5: const #0s : i
        let s_2169_5: i128 = 0;
        // C s_2169_6: add s_2169_5 s_2169_4
        let s_2169_6: i128 = (s_2169_5 + s_2169_4);
        // D s_2169_7: bit-extract s_2169_2 s_2169_0 s_2169_6
        let s_2169_7: Bits = (Bits::new(
            ((s_2169_2) >> (s_2169_0)).value(),
            u16::try_from(s_2169_6).unwrap(),
        ));
        // D s_2169_8: cast reint s_2169_7 -> u8
        let s_2169_8: bool = ((s_2169_7.value()) != 0);
        // D s_2169_9: cast zx s_2169_8 -> bv
        let s_2169_9: Bits = Bits::new(s_2169_8 as u128, 1u16);
        // C s_2169_10: const #1u : u8
        let s_2169_10: bool = true;
        // C s_2169_11: cast zx s_2169_10 -> bv
        let s_2169_11: Bits = Bits::new(s_2169_10 as u128, 1u16);
        // D s_2169_12: cmp-eq s_2169_9 s_2169_11
        let s_2169_12: bool = ((s_2169_9) == (s_2169_11));
        // D s_2169_13: write-var gs#401519 <= s_2169_12
        fn_state.gs_401519 = s_2169_12;
        // N s_2169_14: jump b2168
        return block_2168(state, tracer, fn_state);
    }
    fn block_2170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2170_0: const #3640s : i
        let s_2170_0: i128 = 3640;
        // C s_2170_1: const #14696u : u32
        let s_2170_1: u32 = 14696;
        // D s_2170_2: read-reg s_2170_1:i
        let s_2170_2: i128 = {
            let value = state.read_register::<i128>(s_2170_1 as isize);
            tracer.read_register(s_2170_1 as isize, value);
            value
        };
        // D s_2170_3: cmp-lt s_2170_2 s_2170_0
        let s_2170_3: bool = ((s_2170_2) < (s_2170_0));
        // D s_2170_4: write-var gs#401489 <= s_2170_3
        fn_state.gs_401489 = s_2170_3;
        // N s_2170_5: jump b983
        return block_983(state, tracer, fn_state);
    }
    fn block_2171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2171_0: const #23s : i
        let s_2171_0: i128 = 23;
        // D s_2171_1: read-var u#31658:u32
        let s_2171_1: u32 = fn_state.u_31658;
        // D s_2171_2: cast zx s_2171_1 -> bv
        let s_2171_2: Bits = Bits::new(s_2171_1 as u128, 32u16);
        // C s_2171_3: const #1s : i64
        let s_2171_3: i64 = 1;
        // C s_2171_4: cast zx s_2171_3 -> i
        let s_2171_4: i128 = (i128::try_from(s_2171_3).unwrap());
        // C s_2171_5: const #0s : i
        let s_2171_5: i128 = 0;
        // C s_2171_6: add s_2171_5 s_2171_4
        let s_2171_6: i128 = (s_2171_5 + s_2171_4);
        // D s_2171_7: bit-extract s_2171_2 s_2171_0 s_2171_6
        let s_2171_7: Bits = (Bits::new(
            ((s_2171_2) >> (s_2171_0)).value(),
            u16::try_from(s_2171_6).unwrap(),
        ));
        // D s_2171_8: cast reint s_2171_7 -> u8
        let s_2171_8: bool = ((s_2171_7.value()) != 0);
        // D s_2171_9: cast zx s_2171_8 -> bv
        let s_2171_9: Bits = Bits::new(s_2171_8 as u128, 1u16);
        // C s_2171_10: const #1u : u8
        let s_2171_10: bool = true;
        // C s_2171_11: cast zx s_2171_10 -> bv
        let s_2171_11: Bits = Bits::new(s_2171_10 as u128, 1u16);
        // D s_2171_12: cmp-eq s_2171_9 s_2171_11
        let s_2171_12: bool = ((s_2171_9) == (s_2171_11));
        // N s_2171_13: branch s_2171_12 b2174 b2172
        if s_2171_12 {
            return block_2174(state, tracer, fn_state);
        } else {
            return block_2172(state, tracer, fn_state);
        };
    }
    fn block_2172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2172_0: const #0u : u8
        let s_2172_0: bool = false;
        // D s_2172_1: write-var gs#401486 <= s_2172_0
        fn_state.gs_401486 = s_2172_0;
        // N s_2172_2: jump b2173
        return block_2173(state, tracer, fn_state);
    }
    fn block_2173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2173_0: read-var gs#401486:u8
        let s_2173_0: bool = fn_state.gs_401486;
        // D s_2173_1: write-var gs#401487 <= s_2173_0
        fn_state.gs_401487 = s_2173_0;
        // N s_2173_2: jump b981
        return block_981(state, tracer, fn_state);
    }
    fn block_2174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2174_0: const #9s : i
        let s_2174_0: i128 = 9;
        // D s_2174_1: read-var u#31658:u32
        let s_2174_1: u32 = fn_state.u_31658;
        // D s_2174_2: cast zx s_2174_1 -> bv
        let s_2174_2: Bits = Bits::new(s_2174_1 as u128, 32u16);
        // C s_2174_3: const #1s : i64
        let s_2174_3: i64 = 1;
        // C s_2174_4: cast zx s_2174_3 -> i
        let s_2174_4: i128 = (i128::try_from(s_2174_3).unwrap());
        // C s_2174_5: const #2s : i
        let s_2174_5: i128 = 2;
        // C s_2174_6: add s_2174_5 s_2174_4
        let s_2174_6: i128 = (s_2174_5 + s_2174_4);
        // D s_2174_7: bit-extract s_2174_2 s_2174_0 s_2174_6
        let s_2174_7: Bits = (Bits::new(
            ((s_2174_2) >> (s_2174_0)).value(),
            u16::try_from(s_2174_6).unwrap(),
        ));
        // D s_2174_8: cast reint s_2174_7 -> u8
        let s_2174_8: u8 = (s_2174_7.value() as u8);
        // D s_2174_9: cast zx s_2174_8 -> bv
        let s_2174_9: Bits = Bits::new(s_2174_8 as u128, 3u16);
        // C s_2174_10: const #3u : u8
        let s_2174_10: u8 = 3;
        // C s_2174_11: cast zx s_2174_10 -> bv
        let s_2174_11: Bits = Bits::new(s_2174_10 as u128, 3u16);
        // D s_2174_12: cmp-eq s_2174_9 s_2174_11
        let s_2174_12: bool = ((s_2174_9) == (s_2174_11));
        // N s_2174_13: branch s_2174_12 b2177 b2175
        if s_2174_12 {
            return block_2177(state, tracer, fn_state);
        } else {
            return block_2175(state, tracer, fn_state);
        };
    }
    fn block_2175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2175_0: const #0u : u8
        let s_2175_0: bool = false;
        // D s_2175_1: write-var gs#401485 <= s_2175_0
        fn_state.gs_401485 = s_2175_0;
        // N s_2175_2: jump b2176
        return block_2176(state, tracer, fn_state);
    }
    fn block_2176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2176_0: read-var gs#401485:u8
        let s_2176_0: bool = fn_state.gs_401485;
        // D s_2176_1: write-var gs#401486 <= s_2176_0
        fn_state.gs_401486 = s_2176_0;
        // N s_2176_2: jump b2173
        return block_2173(state, tracer, fn_state);
    }
    fn block_2177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2177_0: const #4s : i
        let s_2177_0: i128 = 4;
        // D s_2177_1: read-var u#31658:u32
        let s_2177_1: u32 = fn_state.u_31658;
        // D s_2177_2: cast zx s_2177_1 -> bv
        let s_2177_2: Bits = Bits::new(s_2177_1 as u128, 32u16);
        // C s_2177_3: const #1s : i64
        let s_2177_3: i64 = 1;
        // C s_2177_4: cast zx s_2177_3 -> i
        let s_2177_4: i128 = (i128::try_from(s_2177_3).unwrap());
        // C s_2177_5: const #0s : i
        let s_2177_5: i128 = 0;
        // C s_2177_6: add s_2177_5 s_2177_4
        let s_2177_6: i128 = (s_2177_5 + s_2177_4);
        // D s_2177_7: bit-extract s_2177_2 s_2177_0 s_2177_6
        let s_2177_7: Bits = (Bits::new(
            ((s_2177_2) >> (s_2177_0)).value(),
            u16::try_from(s_2177_6).unwrap(),
        ));
        // D s_2177_8: cast reint s_2177_7 -> u8
        let s_2177_8: bool = ((s_2177_7.value()) != 0);
        // D s_2177_9: cast zx s_2177_8 -> bv
        let s_2177_9: Bits = Bits::new(s_2177_8 as u128, 1u16);
        // C s_2177_10: const #1u : u8
        let s_2177_10: bool = true;
        // C s_2177_11: cast zx s_2177_10 -> bv
        let s_2177_11: Bits = Bits::new(s_2177_10 as u128, 1u16);
        // D s_2177_12: cmp-eq s_2177_9 s_2177_11
        let s_2177_12: bool = ((s_2177_9) == (s_2177_11));
        // D s_2177_13: write-var gs#401485 <= s_2177_12
        fn_state.gs_401485 = s_2177_12;
        // N s_2177_14: jump b2176
        return block_2176(state, tracer, fn_state);
    }
    fn block_2178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2178_0: const #3638s : i
        let s_2178_0: i128 = 3638;
        // C s_2178_1: const #14696u : u32
        let s_2178_1: u32 = 14696;
        // D s_2178_2: read-reg s_2178_1:i
        let s_2178_2: i128 = {
            let value = state.read_register::<i128>(s_2178_1 as isize);
            tracer.read_register(s_2178_1 as isize, value);
            value
        };
        // D s_2178_3: cmp-lt s_2178_2 s_2178_0
        let s_2178_3: bool = ((s_2178_2) < (s_2178_0));
        // D s_2178_4: write-var gs#401459 <= s_2178_3
        fn_state.gs_401459 = s_2178_3;
        // N s_2178_5: jump b977
        return block_977(state, tracer, fn_state);
    }
    fn block_2179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2179_0: const #23s : i
        let s_2179_0: i128 = 23;
        // D s_2179_1: read-var u#31649:u32
        let s_2179_1: u32 = fn_state.u_31649;
        // D s_2179_2: cast zx s_2179_1 -> bv
        let s_2179_2: Bits = Bits::new(s_2179_1 as u128, 32u16);
        // C s_2179_3: const #1s : i64
        let s_2179_3: i64 = 1;
        // C s_2179_4: cast zx s_2179_3 -> i
        let s_2179_4: i128 = (i128::try_from(s_2179_3).unwrap());
        // C s_2179_5: const #0s : i
        let s_2179_5: i128 = 0;
        // C s_2179_6: add s_2179_5 s_2179_4
        let s_2179_6: i128 = (s_2179_5 + s_2179_4);
        // D s_2179_7: bit-extract s_2179_2 s_2179_0 s_2179_6
        let s_2179_7: Bits = (Bits::new(
            ((s_2179_2) >> (s_2179_0)).value(),
            u16::try_from(s_2179_6).unwrap(),
        ));
        // D s_2179_8: cast reint s_2179_7 -> u8
        let s_2179_8: bool = ((s_2179_7.value()) != 0);
        // D s_2179_9: cast zx s_2179_8 -> bv
        let s_2179_9: Bits = Bits::new(s_2179_8 as u128, 1u16);
        // C s_2179_10: const #1u : u8
        let s_2179_10: bool = true;
        // C s_2179_11: cast zx s_2179_10 -> bv
        let s_2179_11: Bits = Bits::new(s_2179_10 as u128, 1u16);
        // D s_2179_12: cmp-eq s_2179_9 s_2179_11
        let s_2179_12: bool = ((s_2179_9) == (s_2179_11));
        // N s_2179_13: branch s_2179_12 b2182 b2180
        if s_2179_12 {
            return block_2182(state, tracer, fn_state);
        } else {
            return block_2180(state, tracer, fn_state);
        };
    }
    fn block_2180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2180_0: const #0u : u8
        let s_2180_0: bool = false;
        // D s_2180_1: write-var gs#401456 <= s_2180_0
        fn_state.gs_401456 = s_2180_0;
        // N s_2180_2: jump b2181
        return block_2181(state, tracer, fn_state);
    }
    fn block_2181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2181_0: read-var gs#401456:u8
        let s_2181_0: bool = fn_state.gs_401456;
        // D s_2181_1: write-var gs#401457 <= s_2181_0
        fn_state.gs_401457 = s_2181_0;
        // N s_2181_2: jump b975
        return block_975(state, tracer, fn_state);
    }
    fn block_2182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2182_0: const #9s : i
        let s_2182_0: i128 = 9;
        // D s_2182_1: read-var u#31649:u32
        let s_2182_1: u32 = fn_state.u_31649;
        // D s_2182_2: cast zx s_2182_1 -> bv
        let s_2182_2: Bits = Bits::new(s_2182_1 as u128, 32u16);
        // C s_2182_3: const #1s : i64
        let s_2182_3: i64 = 1;
        // C s_2182_4: cast zx s_2182_3 -> i
        let s_2182_4: i128 = (i128::try_from(s_2182_3).unwrap());
        // C s_2182_5: const #2s : i
        let s_2182_5: i128 = 2;
        // C s_2182_6: add s_2182_5 s_2182_4
        let s_2182_6: i128 = (s_2182_5 + s_2182_4);
        // D s_2182_7: bit-extract s_2182_2 s_2182_0 s_2182_6
        let s_2182_7: Bits = (Bits::new(
            ((s_2182_2) >> (s_2182_0)).value(),
            u16::try_from(s_2182_6).unwrap(),
        ));
        // D s_2182_8: cast reint s_2182_7 -> u8
        let s_2182_8: u8 = (s_2182_7.value() as u8);
        // D s_2182_9: cast zx s_2182_8 -> bv
        let s_2182_9: Bits = Bits::new(s_2182_8 as u128, 3u16);
        // C s_2182_10: const #4u : u8
        let s_2182_10: u8 = 4;
        // C s_2182_11: cast zx s_2182_10 -> bv
        let s_2182_11: Bits = Bits::new(s_2182_10 as u128, 3u16);
        // D s_2182_12: cmp-eq s_2182_9 s_2182_11
        let s_2182_12: bool = ((s_2182_9) == (s_2182_11));
        // N s_2182_13: branch s_2182_12 b2185 b2183
        if s_2182_12 {
            return block_2185(state, tracer, fn_state);
        } else {
            return block_2183(state, tracer, fn_state);
        };
    }
    fn block_2183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2183_0: const #0u : u8
        let s_2183_0: bool = false;
        // D s_2183_1: write-var gs#401455 <= s_2183_0
        fn_state.gs_401455 = s_2183_0;
        // N s_2183_2: jump b2184
        return block_2184(state, tracer, fn_state);
    }
    fn block_2184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2184_0: read-var gs#401455:u8
        let s_2184_0: bool = fn_state.gs_401455;
        // D s_2184_1: write-var gs#401456 <= s_2184_0
        fn_state.gs_401456 = s_2184_0;
        // N s_2184_2: jump b2181
        return block_2181(state, tracer, fn_state);
    }
    fn block_2185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2185_0: const #6s : i
        let s_2185_0: i128 = 6;
        // D s_2185_1: read-var u#31649:u32
        let s_2185_1: u32 = fn_state.u_31649;
        // D s_2185_2: cast zx s_2185_1 -> bv
        let s_2185_2: Bits = Bits::new(s_2185_1 as u128, 32u16);
        // C s_2185_3: const #1s : i64
        let s_2185_3: i64 = 1;
        // C s_2185_4: cast zx s_2185_3 -> i
        let s_2185_4: i128 = (i128::try_from(s_2185_3).unwrap());
        // C s_2185_5: const #1s : i
        let s_2185_5: i128 = 1;
        // C s_2185_6: add s_2185_5 s_2185_4
        let s_2185_6: i128 = (s_2185_5 + s_2185_4);
        // D s_2185_7: bit-extract s_2185_2 s_2185_0 s_2185_6
        let s_2185_7: Bits = (Bits::new(
            ((s_2185_2) >> (s_2185_0)).value(),
            u16::try_from(s_2185_6).unwrap(),
        ));
        // D s_2185_8: cast reint s_2185_7 -> u8
        let s_2185_8: u8 = (s_2185_7.value() as u8);
        // D s_2185_9: cast zx s_2185_8 -> bv
        let s_2185_9: Bits = Bits::new(s_2185_8 as u128, 2u16);
        // C s_2185_10: const #1u : u8
        let s_2185_10: u8 = 1;
        // C s_2185_11: cast zx s_2185_10 -> bv
        let s_2185_11: Bits = Bits::new(s_2185_10 as u128, 2u16);
        // D s_2185_12: cmp-eq s_2185_9 s_2185_11
        let s_2185_12: bool = ((s_2185_9) == (s_2185_11));
        // N s_2185_13: branch s_2185_12 b2188 b2186
        if s_2185_12 {
            return block_2188(state, tracer, fn_state);
        } else {
            return block_2186(state, tracer, fn_state);
        };
    }
    fn block_2186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2186_0: const #0u : u8
        let s_2186_0: bool = false;
        // D s_2186_1: write-var gs#401454 <= s_2186_0
        fn_state.gs_401454 = s_2186_0;
        // N s_2186_2: jump b2187
        return block_2187(state, tracer, fn_state);
    }
    fn block_2187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2187_0: read-var gs#401454:u8
        let s_2187_0: bool = fn_state.gs_401454;
        // D s_2187_1: write-var gs#401455 <= s_2187_0
        fn_state.gs_401455 = s_2187_0;
        // N s_2187_2: jump b2184
        return block_2184(state, tracer, fn_state);
    }
    fn block_2188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2188_0: const #4s : i
        let s_2188_0: i128 = 4;
        // D s_2188_1: read-var u#31649:u32
        let s_2188_1: u32 = fn_state.u_31649;
        // D s_2188_2: cast zx s_2188_1 -> bv
        let s_2188_2: Bits = Bits::new(s_2188_1 as u128, 32u16);
        // C s_2188_3: const #1s : i64
        let s_2188_3: i64 = 1;
        // C s_2188_4: cast zx s_2188_3 -> i
        let s_2188_4: i128 = (i128::try_from(s_2188_3).unwrap());
        // C s_2188_5: const #0s : i
        let s_2188_5: i128 = 0;
        // C s_2188_6: add s_2188_5 s_2188_4
        let s_2188_6: i128 = (s_2188_5 + s_2188_4);
        // D s_2188_7: bit-extract s_2188_2 s_2188_0 s_2188_6
        let s_2188_7: Bits = (Bits::new(
            ((s_2188_2) >> (s_2188_0)).value(),
            u16::try_from(s_2188_6).unwrap(),
        ));
        // D s_2188_8: cast reint s_2188_7 -> u8
        let s_2188_8: bool = ((s_2188_7.value()) != 0);
        // D s_2188_9: cast zx s_2188_8 -> bv
        let s_2188_9: Bits = Bits::new(s_2188_8 as u128, 1u16);
        // C s_2188_10: const #1u : u8
        let s_2188_10: bool = true;
        // C s_2188_11: cast zx s_2188_10 -> bv
        let s_2188_11: Bits = Bits::new(s_2188_10 as u128, 1u16);
        // D s_2188_12: cmp-eq s_2188_9 s_2188_11
        let s_2188_12: bool = ((s_2188_9) == (s_2188_11));
        // D s_2188_13: write-var gs#401454 <= s_2188_12
        fn_state.gs_401454 = s_2188_12;
        // N s_2188_14: jump b2187
        return block_2187(state, tracer, fn_state);
    }
    fn block_2189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2189_0: const #3636s : i
        let s_2189_0: i128 = 3636;
        // C s_2189_1: const #14696u : u32
        let s_2189_1: u32 = 14696;
        // D s_2189_2: read-reg s_2189_1:i
        let s_2189_2: i128 = {
            let value = state.read_register::<i128>(s_2189_1 as isize);
            tracer.read_register(s_2189_1 as isize, value);
            value
        };
        // D s_2189_3: cmp-lt s_2189_2 s_2189_0
        let s_2189_3: bool = ((s_2189_2) < (s_2189_0));
        // D s_2189_4: write-var gs#401422 <= s_2189_3
        fn_state.gs_401422 = s_2189_3;
        // N s_2189_5: jump b971
        return block_971(state, tracer, fn_state);
    }
    fn block_2190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2190_0: const #23s : i
        let s_2190_0: i128 = 23;
        // D s_2190_1: read-var u#31638:u32
        let s_2190_1: u32 = fn_state.u_31638;
        // D s_2190_2: cast zx s_2190_1 -> bv
        let s_2190_2: Bits = Bits::new(s_2190_1 as u128, 32u16);
        // C s_2190_3: const #1s : i64
        let s_2190_3: i64 = 1;
        // C s_2190_4: cast zx s_2190_3 -> i
        let s_2190_4: i128 = (i128::try_from(s_2190_3).unwrap());
        // C s_2190_5: const #0s : i
        let s_2190_5: i128 = 0;
        // C s_2190_6: add s_2190_5 s_2190_4
        let s_2190_6: i128 = (s_2190_5 + s_2190_4);
        // D s_2190_7: bit-extract s_2190_2 s_2190_0 s_2190_6
        let s_2190_7: Bits = (Bits::new(
            ((s_2190_2) >> (s_2190_0)).value(),
            u16::try_from(s_2190_6).unwrap(),
        ));
        // D s_2190_8: cast reint s_2190_7 -> u8
        let s_2190_8: bool = ((s_2190_7.value()) != 0);
        // D s_2190_9: cast zx s_2190_8 -> bv
        let s_2190_9: Bits = Bits::new(s_2190_8 as u128, 1u16);
        // C s_2190_10: const #0u : u8
        let s_2190_10: bool = false;
        // C s_2190_11: cast zx s_2190_10 -> bv
        let s_2190_11: Bits = Bits::new(s_2190_10 as u128, 1u16);
        // D s_2190_12: cmp-eq s_2190_9 s_2190_11
        let s_2190_12: bool = ((s_2190_9) == (s_2190_11));
        // N s_2190_13: branch s_2190_12 b2193 b2191
        if s_2190_12 {
            return block_2193(state, tracer, fn_state);
        } else {
            return block_2191(state, tracer, fn_state);
        };
    }
    fn block_2191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2191_0: const #0u : u8
        let s_2191_0: bool = false;
        // D s_2191_1: write-var gs#401419 <= s_2191_0
        fn_state.gs_401419 = s_2191_0;
        // N s_2191_2: jump b2192
        return block_2192(state, tracer, fn_state);
    }
    fn block_2192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2192_0: read-var gs#401419:u8
        let s_2192_0: bool = fn_state.gs_401419;
        // D s_2192_1: write-var gs#401420 <= s_2192_0
        fn_state.gs_401420 = s_2192_0;
        // N s_2192_2: jump b969
        return block_969(state, tracer, fn_state);
    }
    fn block_2193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2193_0: const #8s : i
        let s_2193_0: i128 = 8;
        // D s_2193_1: read-var u#31638:u32
        let s_2193_1: u32 = fn_state.u_31638;
        // D s_2193_2: cast zx s_2193_1 -> bv
        let s_2193_2: Bits = Bits::new(s_2193_1 as u128, 32u16);
        // C s_2193_3: const #1s : i64
        let s_2193_3: i64 = 1;
        // C s_2193_4: cast zx s_2193_3 -> i
        let s_2193_4: i128 = (i128::try_from(s_2193_3).unwrap());
        // C s_2193_5: const #3s : i
        let s_2193_5: i128 = 3;
        // C s_2193_6: add s_2193_5 s_2193_4
        let s_2193_6: i128 = (s_2193_5 + s_2193_4);
        // D s_2193_7: bit-extract s_2193_2 s_2193_0 s_2193_6
        let s_2193_7: Bits = (Bits::new(
            ((s_2193_2) >> (s_2193_0)).value(),
            u16::try_from(s_2193_6).unwrap(),
        ));
        // D s_2193_8: cast reint s_2193_7 -> u8
        let s_2193_8: u8 = (s_2193_7.value() as u8);
        // D s_2193_9: cast zx s_2193_8 -> bv
        let s_2193_9: Bits = Bits::new(s_2193_8 as u128, 4u16);
        // C s_2193_10: const #5u : u8
        let s_2193_10: u8 = 5;
        // C s_2193_11: cast zx s_2193_10 -> bv
        let s_2193_11: Bits = Bits::new(s_2193_10 as u128, 4u16);
        // D s_2193_12: cmp-eq s_2193_9 s_2193_11
        let s_2193_12: bool = ((s_2193_9) == (s_2193_11));
        // N s_2193_13: branch s_2193_12 b2196 b2194
        if s_2193_12 {
            return block_2196(state, tracer, fn_state);
        } else {
            return block_2194(state, tracer, fn_state);
        };
    }
    fn block_2194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2194_0: const #0u : u8
        let s_2194_0: bool = false;
        // D s_2194_1: write-var gs#401418 <= s_2194_0
        fn_state.gs_401418 = s_2194_0;
        // N s_2194_2: jump b2195
        return block_2195(state, tracer, fn_state);
    }
    fn block_2195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2195_0: read-var gs#401418:u8
        let s_2195_0: bool = fn_state.gs_401418;
        // D s_2195_1: write-var gs#401419 <= s_2195_0
        fn_state.gs_401419 = s_2195_0;
        // N s_2195_2: jump b2192
        return block_2192(state, tracer, fn_state);
    }
    fn block_2196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2196_0: const #4s : i
        let s_2196_0: i128 = 4;
        // D s_2196_1: read-var u#31638:u32
        let s_2196_1: u32 = fn_state.u_31638;
        // D s_2196_2: cast zx s_2196_1 -> bv
        let s_2196_2: Bits = Bits::new(s_2196_1 as u128, 32u16);
        // C s_2196_3: const #1s : i64
        let s_2196_3: i64 = 1;
        // C s_2196_4: cast zx s_2196_3 -> i
        let s_2196_4: i128 = (i128::try_from(s_2196_3).unwrap());
        // C s_2196_5: const #0s : i
        let s_2196_5: i128 = 0;
        // C s_2196_6: add s_2196_5 s_2196_4
        let s_2196_6: i128 = (s_2196_5 + s_2196_4);
        // D s_2196_7: bit-extract s_2196_2 s_2196_0 s_2196_6
        let s_2196_7: Bits = (Bits::new(
            ((s_2196_2) >> (s_2196_0)).value(),
            u16::try_from(s_2196_6).unwrap(),
        ));
        // D s_2196_8: cast reint s_2196_7 -> u8
        let s_2196_8: bool = ((s_2196_7.value()) != 0);
        // D s_2196_9: cast zx s_2196_8 -> bv
        let s_2196_9: Bits = Bits::new(s_2196_8 as u128, 1u16);
        // C s_2196_10: const #1u : u8
        let s_2196_10: bool = true;
        // C s_2196_11: cast zx s_2196_10 -> bv
        let s_2196_11: Bits = Bits::new(s_2196_10 as u128, 1u16);
        // D s_2196_12: cmp-eq s_2196_9 s_2196_11
        let s_2196_12: bool = ((s_2196_9) == (s_2196_11));
        // D s_2196_13: write-var gs#401418 <= s_2196_12
        fn_state.gs_401418 = s_2196_12;
        // N s_2196_14: jump b2195
        return block_2195(state, tracer, fn_state);
    }
    fn block_2197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2197_0: const #3633s : i
        let s_2197_0: i128 = 3633;
        // C s_2197_1: const #14696u : u32
        let s_2197_1: u32 = 14696;
        // D s_2197_2: read-reg s_2197_1:i
        let s_2197_2: i128 = {
            let value = state.read_register::<i128>(s_2197_1 as isize);
            tracer.read_register(s_2197_1 as isize, value);
            value
        };
        // D s_2197_3: cmp-lt s_2197_2 s_2197_0
        let s_2197_3: bool = ((s_2197_2) < (s_2197_0));
        // D s_2197_4: write-var gs#401390 <= s_2197_3
        fn_state.gs_401390 = s_2197_3;
        // N s_2197_5: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_2198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2198_0: const #23s : i
        let s_2198_0: i128 = 23;
        // D s_2198_1: read-var u#31628:u32
        let s_2198_1: u32 = fn_state.u_31628;
        // D s_2198_2: cast zx s_2198_1 -> bv
        let s_2198_2: Bits = Bits::new(s_2198_1 as u128, 32u16);
        // C s_2198_3: const #1s : i64
        let s_2198_3: i64 = 1;
        // C s_2198_4: cast zx s_2198_3 -> i
        let s_2198_4: i128 = (i128::try_from(s_2198_3).unwrap());
        // C s_2198_5: const #0s : i
        let s_2198_5: i128 = 0;
        // C s_2198_6: add s_2198_5 s_2198_4
        let s_2198_6: i128 = (s_2198_5 + s_2198_4);
        // D s_2198_7: bit-extract s_2198_2 s_2198_0 s_2198_6
        let s_2198_7: Bits = (Bits::new(
            ((s_2198_2) >> (s_2198_0)).value(),
            u16::try_from(s_2198_6).unwrap(),
        ));
        // D s_2198_8: cast reint s_2198_7 -> u8
        let s_2198_8: bool = ((s_2198_7.value()) != 0);
        // D s_2198_9: cast zx s_2198_8 -> bv
        let s_2198_9: Bits = Bits::new(s_2198_8 as u128, 1u16);
        // C s_2198_10: const #1u : u8
        let s_2198_10: bool = true;
        // C s_2198_11: cast zx s_2198_10 -> bv
        let s_2198_11: Bits = Bits::new(s_2198_10 as u128, 1u16);
        // D s_2198_12: cmp-eq s_2198_9 s_2198_11
        let s_2198_12: bool = ((s_2198_9) == (s_2198_11));
        // N s_2198_13: branch s_2198_12 b2201 b2199
        if s_2198_12 {
            return block_2201(state, tracer, fn_state);
        } else {
            return block_2199(state, tracer, fn_state);
        };
    }
    fn block_2199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2199_0: const #0u : u8
        let s_2199_0: bool = false;
        // D s_2199_1: write-var gs#401387 <= s_2199_0
        fn_state.gs_401387 = s_2199_0;
        // N s_2199_2: jump b2200
        return block_2200(state, tracer, fn_state);
    }
    fn block_2200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2200_0: read-var gs#401387:u8
        let s_2200_0: bool = fn_state.gs_401387;
        // D s_2200_1: write-var gs#401388 <= s_2200_0
        fn_state.gs_401388 = s_2200_0;
        // N s_2200_2: jump b963
        return block_963(state, tracer, fn_state);
    }
    fn block_2201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2201_0: const #8s : i
        let s_2201_0: i128 = 8;
        // D s_2201_1: read-var u#31628:u32
        let s_2201_1: u32 = fn_state.u_31628;
        // D s_2201_2: cast zx s_2201_1 -> bv
        let s_2201_2: Bits = Bits::new(s_2201_1 as u128, 32u16);
        // C s_2201_3: const #1s : i64
        let s_2201_3: i64 = 1;
        // C s_2201_4: cast zx s_2201_3 -> i
        let s_2201_4: i128 = (i128::try_from(s_2201_3).unwrap());
        // C s_2201_5: const #3s : i
        let s_2201_5: i128 = 3;
        // C s_2201_6: add s_2201_5 s_2201_4
        let s_2201_6: i128 = (s_2201_5 + s_2201_4);
        // D s_2201_7: bit-extract s_2201_2 s_2201_0 s_2201_6
        let s_2201_7: Bits = (Bits::new(
            ((s_2201_2) >> (s_2201_0)).value(),
            u16::try_from(s_2201_6).unwrap(),
        ));
        // D s_2201_8: cast reint s_2201_7 -> u8
        let s_2201_8: u8 = (s_2201_7.value() as u8);
        // D s_2201_9: cast zx s_2201_8 -> bv
        let s_2201_9: Bits = Bits::new(s_2201_8 as u128, 4u16);
        // C s_2201_10: const #15u : u8
        let s_2201_10: u8 = 15;
        // C s_2201_11: cast zx s_2201_10 -> bv
        let s_2201_11: Bits = Bits::new(s_2201_10 as u128, 4u16);
        // D s_2201_12: cmp-eq s_2201_9 s_2201_11
        let s_2201_12: bool = ((s_2201_9) == (s_2201_11));
        // N s_2201_13: branch s_2201_12 b2204 b2202
        if s_2201_12 {
            return block_2204(state, tracer, fn_state);
        } else {
            return block_2202(state, tracer, fn_state);
        };
    }
    fn block_2202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2202_0: const #0u : u8
        let s_2202_0: bool = false;
        // D s_2202_1: write-var gs#401386 <= s_2202_0
        fn_state.gs_401386 = s_2202_0;
        // N s_2202_2: jump b2203
        return block_2203(state, tracer, fn_state);
    }
    fn block_2203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2203_0: read-var gs#401386:u8
        let s_2203_0: bool = fn_state.gs_401386;
        // D s_2203_1: write-var gs#401387 <= s_2203_0
        fn_state.gs_401387 = s_2203_0;
        // N s_2203_2: jump b2200
        return block_2200(state, tracer, fn_state);
    }
    fn block_2204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2204_0: const #6s : i
        let s_2204_0: i128 = 6;
        // D s_2204_1: read-var u#31628:u32
        let s_2204_1: u32 = fn_state.u_31628;
        // D s_2204_2: cast zx s_2204_1 -> bv
        let s_2204_2: Bits = Bits::new(s_2204_1 as u128, 32u16);
        // C s_2204_3: const #1s : i64
        let s_2204_3: i64 = 1;
        // C s_2204_4: cast zx s_2204_3 -> i
        let s_2204_4: i128 = (i128::try_from(s_2204_3).unwrap());
        // C s_2204_5: const #0s : i
        let s_2204_5: i128 = 0;
        // C s_2204_6: add s_2204_5 s_2204_4
        let s_2204_6: i128 = (s_2204_5 + s_2204_4);
        // D s_2204_7: bit-extract s_2204_2 s_2204_0 s_2204_6
        let s_2204_7: Bits = (Bits::new(
            ((s_2204_2) >> (s_2204_0)).value(),
            u16::try_from(s_2204_6).unwrap(),
        ));
        // D s_2204_8: cast reint s_2204_7 -> u8
        let s_2204_8: bool = ((s_2204_7.value()) != 0);
        // D s_2204_9: cast zx s_2204_8 -> bv
        let s_2204_9: Bits = Bits::new(s_2204_8 as u128, 1u16);
        // C s_2204_10: const #1u : u8
        let s_2204_10: bool = true;
        // C s_2204_11: cast zx s_2204_10 -> bv
        let s_2204_11: Bits = Bits::new(s_2204_10 as u128, 1u16);
        // D s_2204_12: cmp-eq s_2204_9 s_2204_11
        let s_2204_12: bool = ((s_2204_9) == (s_2204_11));
        // N s_2204_13: branch s_2204_12 b2207 b2205
        if s_2204_12 {
            return block_2207(state, tracer, fn_state);
        } else {
            return block_2205(state, tracer, fn_state);
        };
    }
    fn block_2205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2205_0: const #0u : u8
        let s_2205_0: bool = false;
        // D s_2205_1: write-var gs#401385 <= s_2205_0
        fn_state.gs_401385 = s_2205_0;
        // N s_2205_2: jump b2206
        return block_2206(state, tracer, fn_state);
    }
    fn block_2206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2206_0: read-var gs#401385:u8
        let s_2206_0: bool = fn_state.gs_401385;
        // D s_2206_1: write-var gs#401386 <= s_2206_0
        fn_state.gs_401386 = s_2206_0;
        // N s_2206_2: jump b2203
        return block_2203(state, tracer, fn_state);
    }
    fn block_2207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2207_0: const #4s : i
        let s_2207_0: i128 = 4;
        // D s_2207_1: read-var u#31628:u32
        let s_2207_1: u32 = fn_state.u_31628;
        // D s_2207_2: cast zx s_2207_1 -> bv
        let s_2207_2: Bits = Bits::new(s_2207_1 as u128, 32u16);
        // C s_2207_3: const #1s : i64
        let s_2207_3: i64 = 1;
        // C s_2207_4: cast zx s_2207_3 -> i
        let s_2207_4: i128 = (i128::try_from(s_2207_3).unwrap());
        // C s_2207_5: const #0s : i
        let s_2207_5: i128 = 0;
        // C s_2207_6: add s_2207_5 s_2207_4
        let s_2207_6: i128 = (s_2207_5 + s_2207_4);
        // D s_2207_7: bit-extract s_2207_2 s_2207_0 s_2207_6
        let s_2207_7: Bits = (Bits::new(
            ((s_2207_2) >> (s_2207_0)).value(),
            u16::try_from(s_2207_6).unwrap(),
        ));
        // D s_2207_8: cast reint s_2207_7 -> u8
        let s_2207_8: bool = ((s_2207_7.value()) != 0);
        // D s_2207_9: cast zx s_2207_8 -> bv
        let s_2207_9: Bits = Bits::new(s_2207_8 as u128, 1u16);
        // C s_2207_10: const #0u : u8
        let s_2207_10: bool = false;
        // C s_2207_11: cast zx s_2207_10 -> bv
        let s_2207_11: Bits = Bits::new(s_2207_10 as u128, 1u16);
        // D s_2207_12: cmp-eq s_2207_9 s_2207_11
        let s_2207_12: bool = ((s_2207_9) == (s_2207_11));
        // D s_2207_13: write-var gs#401385 <= s_2207_12
        fn_state.gs_401385 = s_2207_12;
        // N s_2207_14: jump b2206
        return block_2206(state, tracer, fn_state);
    }
    fn block_2208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2208_0: const #3632s : i
        let s_2208_0: i128 = 3632;
        // C s_2208_1: const #14696u : u32
        let s_2208_1: u32 = 14696;
        // D s_2208_2: read-reg s_2208_1:i
        let s_2208_2: i128 = {
            let value = state.read_register::<i128>(s_2208_1 as isize);
            tracer.read_register(s_2208_1 as isize, value);
            value
        };
        // D s_2208_3: cmp-lt s_2208_2 s_2208_0
        let s_2208_3: bool = ((s_2208_2) < (s_2208_0));
        // D s_2208_4: write-var gs#401355 <= s_2208_3
        fn_state.gs_401355 = s_2208_3;
        // N s_2208_5: jump b959
        return block_959(state, tracer, fn_state);
    }
    fn block_2209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2209_0: const #8s : i
        let s_2209_0: i128 = 8;
        // D s_2209_1: read-var u#31618:u32
        let s_2209_1: u32 = fn_state.u_31618;
        // D s_2209_2: cast zx s_2209_1 -> bv
        let s_2209_2: Bits = Bits::new(s_2209_1 as u128, 32u16);
        // C s_2209_3: const #1s : i64
        let s_2209_3: i64 = 1;
        // C s_2209_4: cast zx s_2209_3 -> i
        let s_2209_4: i128 = (i128::try_from(s_2209_3).unwrap());
        // C s_2209_5: const #3s : i
        let s_2209_5: i128 = 3;
        // C s_2209_6: add s_2209_5 s_2209_4
        let s_2209_6: i128 = (s_2209_5 + s_2209_4);
        // D s_2209_7: bit-extract s_2209_2 s_2209_0 s_2209_6
        let s_2209_7: Bits = (Bits::new(
            ((s_2209_2) >> (s_2209_0)).value(),
            u16::try_from(s_2209_6).unwrap(),
        ));
        // D s_2209_8: cast reint s_2209_7 -> u8
        let s_2209_8: u8 = (s_2209_7.value() as u8);
        // D s_2209_9: cast zx s_2209_8 -> bv
        let s_2209_9: Bits = Bits::new(s_2209_8 as u128, 4u16);
        // C s_2209_10: const #12u : u8
        let s_2209_10: u8 = 12;
        // C s_2209_11: cast zx s_2209_10 -> bv
        let s_2209_11: Bits = Bits::new(s_2209_10 as u128, 4u16);
        // D s_2209_12: cmp-eq s_2209_9 s_2209_11
        let s_2209_12: bool = ((s_2209_9) == (s_2209_11));
        // N s_2209_13: branch s_2209_12 b2212 b2210
        if s_2209_12 {
            return block_2212(state, tracer, fn_state);
        } else {
            return block_2210(state, tracer, fn_state);
        };
    }
    fn block_2210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2210_0: const #0u : u8
        let s_2210_0: bool = false;
        // D s_2210_1: write-var gs#401352 <= s_2210_0
        fn_state.gs_401352 = s_2210_0;
        // N s_2210_2: jump b2211
        return block_2211(state, tracer, fn_state);
    }
    fn block_2211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2211_0: read-var gs#401352:u8
        let s_2211_0: bool = fn_state.gs_401352;
        // D s_2211_1: write-var gs#401353 <= s_2211_0
        fn_state.gs_401353 = s_2211_0;
        // N s_2211_2: jump b957
        return block_957(state, tracer, fn_state);
    }
    fn block_2212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2212_0: const #4s : i
        let s_2212_0: i128 = 4;
        // D s_2212_1: read-var u#31618:u32
        let s_2212_1: u32 = fn_state.u_31618;
        // D s_2212_2: cast zx s_2212_1 -> bv
        let s_2212_2: Bits = Bits::new(s_2212_1 as u128, 32u16);
        // C s_2212_3: const #1s : i64
        let s_2212_3: i64 = 1;
        // C s_2212_4: cast zx s_2212_3 -> i
        let s_2212_4: i128 = (i128::try_from(s_2212_3).unwrap());
        // C s_2212_5: const #0s : i
        let s_2212_5: i128 = 0;
        // C s_2212_6: add s_2212_5 s_2212_4
        let s_2212_6: i128 = (s_2212_5 + s_2212_4);
        // D s_2212_7: bit-extract s_2212_2 s_2212_0 s_2212_6
        let s_2212_7: Bits = (Bits::new(
            ((s_2212_2) >> (s_2212_0)).value(),
            u16::try_from(s_2212_6).unwrap(),
        ));
        // D s_2212_8: cast reint s_2212_7 -> u8
        let s_2212_8: bool = ((s_2212_7.value()) != 0);
        // D s_2212_9: cast zx s_2212_8 -> bv
        let s_2212_9: Bits = Bits::new(s_2212_8 as u128, 1u16);
        // C s_2212_10: const #1u : u8
        let s_2212_10: bool = true;
        // C s_2212_11: cast zx s_2212_10 -> bv
        let s_2212_11: Bits = Bits::new(s_2212_10 as u128, 1u16);
        // D s_2212_12: cmp-eq s_2212_9 s_2212_11
        let s_2212_12: bool = ((s_2212_9) == (s_2212_11));
        // D s_2212_13: write-var gs#401352 <= s_2212_12
        fn_state.gs_401352 = s_2212_12;
        // N s_2212_14: jump b2211
        return block_2211(state, tracer, fn_state);
    }
    fn block_2213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2213_0: const #3629s : i
        let s_2213_0: i128 = 3629;
        // C s_2213_1: const #14696u : u32
        let s_2213_1: u32 = 14696;
        // D s_2213_2: read-reg s_2213_1:i
        let s_2213_2: i128 = {
            let value = state.read_register::<i128>(s_2213_1 as isize);
            tracer.read_register(s_2213_1 as isize, value);
            value
        };
        // D s_2213_3: cmp-lt s_2213_2 s_2213_0
        let s_2213_3: bool = ((s_2213_2) < (s_2213_0));
        // D s_2213_4: write-var gs#401326 <= s_2213_3
        fn_state.gs_401326 = s_2213_3;
        // N s_2213_5: jump b953
        return block_953(state, tracer, fn_state);
    }
    fn block_2214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2214_0: const #23s : i
        let s_2214_0: i128 = 23;
        // D s_2214_1: read-var u#31608:u32
        let s_2214_1: u32 = fn_state.u_31608;
        // D s_2214_2: cast zx s_2214_1 -> bv
        let s_2214_2: Bits = Bits::new(s_2214_1 as u128, 32u16);
        // C s_2214_3: const #1s : i64
        let s_2214_3: i64 = 1;
        // C s_2214_4: cast zx s_2214_3 -> i
        let s_2214_4: i128 = (i128::try_from(s_2214_3).unwrap());
        // C s_2214_5: const #0s : i
        let s_2214_5: i128 = 0;
        // C s_2214_6: add s_2214_5 s_2214_4
        let s_2214_6: i128 = (s_2214_5 + s_2214_4);
        // D s_2214_7: bit-extract s_2214_2 s_2214_0 s_2214_6
        let s_2214_7: Bits = (Bits::new(
            ((s_2214_2) >> (s_2214_0)).value(),
            u16::try_from(s_2214_6).unwrap(),
        ));
        // D s_2214_8: cast reint s_2214_7 -> u8
        let s_2214_8: bool = ((s_2214_7.value()) != 0);
        // D s_2214_9: cast zx s_2214_8 -> bv
        let s_2214_9: Bits = Bits::new(s_2214_8 as u128, 1u16);
        // C s_2214_10: const #1u : u8
        let s_2214_10: bool = true;
        // C s_2214_11: cast zx s_2214_10 -> bv
        let s_2214_11: Bits = Bits::new(s_2214_10 as u128, 1u16);
        // D s_2214_12: cmp-eq s_2214_9 s_2214_11
        let s_2214_12: bool = ((s_2214_9) == (s_2214_11));
        // N s_2214_13: branch s_2214_12 b2217 b2215
        if s_2214_12 {
            return block_2217(state, tracer, fn_state);
        } else {
            return block_2215(state, tracer, fn_state);
        };
    }
    fn block_2215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2215_0: const #0u : u8
        let s_2215_0: bool = false;
        // D s_2215_1: write-var gs#401323 <= s_2215_0
        fn_state.gs_401323 = s_2215_0;
        // N s_2215_2: jump b2216
        return block_2216(state, tracer, fn_state);
    }
    fn block_2216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2216_0: read-var gs#401323:u8
        let s_2216_0: bool = fn_state.gs_401323;
        // D s_2216_1: write-var gs#401324 <= s_2216_0
        fn_state.gs_401324 = s_2216_0;
        // N s_2216_2: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_2217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2217_0: const #8s : i
        let s_2217_0: i128 = 8;
        // D s_2217_1: read-var u#31608:u32
        let s_2217_1: u32 = fn_state.u_31608;
        // D s_2217_2: cast zx s_2217_1 -> bv
        let s_2217_2: Bits = Bits::new(s_2217_1 as u128, 32u16);
        // C s_2217_3: const #1s : i64
        let s_2217_3: i64 = 1;
        // C s_2217_4: cast zx s_2217_3 -> i
        let s_2217_4: i128 = (i128::try_from(s_2217_3).unwrap());
        // C s_2217_5: const #3s : i
        let s_2217_5: i128 = 3;
        // C s_2217_6: add s_2217_5 s_2217_4
        let s_2217_6: i128 = (s_2217_5 + s_2217_4);
        // D s_2217_7: bit-extract s_2217_2 s_2217_0 s_2217_6
        let s_2217_7: Bits = (Bits::new(
            ((s_2217_2) >> (s_2217_0)).value(),
            u16::try_from(s_2217_6).unwrap(),
        ));
        // D s_2217_8: cast reint s_2217_7 -> u8
        let s_2217_8: u8 = (s_2217_7.value() as u8);
        // D s_2217_9: cast zx s_2217_8 -> bv
        let s_2217_9: Bits = Bits::new(s_2217_8 as u128, 4u16);
        // C s_2217_10: const #14u : u8
        let s_2217_10: u8 = 14;
        // C s_2217_11: cast zx s_2217_10 -> bv
        let s_2217_11: Bits = Bits::new(s_2217_10 as u128, 4u16);
        // D s_2217_12: cmp-eq s_2217_9 s_2217_11
        let s_2217_12: bool = ((s_2217_9) == (s_2217_11));
        // N s_2217_13: branch s_2217_12 b2220 b2218
        if s_2217_12 {
            return block_2220(state, tracer, fn_state);
        } else {
            return block_2218(state, tracer, fn_state);
        };
    }
    fn block_2218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2218_0: const #0u : u8
        let s_2218_0: bool = false;
        // D s_2218_1: write-var gs#401322 <= s_2218_0
        fn_state.gs_401322 = s_2218_0;
        // N s_2218_2: jump b2219
        return block_2219(state, tracer, fn_state);
    }
    fn block_2219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2219_0: read-var gs#401322:u8
        let s_2219_0: bool = fn_state.gs_401322;
        // D s_2219_1: write-var gs#401323 <= s_2219_0
        fn_state.gs_401323 = s_2219_0;
        // N s_2219_2: jump b2216
        return block_2216(state, tracer, fn_state);
    }
    fn block_2220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2220_0: const #6s : i
        let s_2220_0: i128 = 6;
        // D s_2220_1: read-var u#31608:u32
        let s_2220_1: u32 = fn_state.u_31608;
        // D s_2220_2: cast zx s_2220_1 -> bv
        let s_2220_2: Bits = Bits::new(s_2220_1 as u128, 32u16);
        // C s_2220_3: const #1s : i64
        let s_2220_3: i64 = 1;
        // C s_2220_4: cast zx s_2220_3 -> i
        let s_2220_4: i128 = (i128::try_from(s_2220_3).unwrap());
        // C s_2220_5: const #0s : i
        let s_2220_5: i128 = 0;
        // C s_2220_6: add s_2220_5 s_2220_4
        let s_2220_6: i128 = (s_2220_5 + s_2220_4);
        // D s_2220_7: bit-extract s_2220_2 s_2220_0 s_2220_6
        let s_2220_7: Bits = (Bits::new(
            ((s_2220_2) >> (s_2220_0)).value(),
            u16::try_from(s_2220_6).unwrap(),
        ));
        // D s_2220_8: cast reint s_2220_7 -> u8
        let s_2220_8: bool = ((s_2220_7.value()) != 0);
        // D s_2220_9: cast zx s_2220_8 -> bv
        let s_2220_9: Bits = Bits::new(s_2220_8 as u128, 1u16);
        // C s_2220_10: const #1u : u8
        let s_2220_10: bool = true;
        // C s_2220_11: cast zx s_2220_10 -> bv
        let s_2220_11: Bits = Bits::new(s_2220_10 as u128, 1u16);
        // D s_2220_12: cmp-eq s_2220_9 s_2220_11
        let s_2220_12: bool = ((s_2220_9) == (s_2220_11));
        // N s_2220_13: branch s_2220_12 b2223 b2221
        if s_2220_12 {
            return block_2223(state, tracer, fn_state);
        } else {
            return block_2221(state, tracer, fn_state);
        };
    }
    fn block_2221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2221_0: const #0u : u8
        let s_2221_0: bool = false;
        // D s_2221_1: write-var gs#401321 <= s_2221_0
        fn_state.gs_401321 = s_2221_0;
        // N s_2221_2: jump b2222
        return block_2222(state, tracer, fn_state);
    }
    fn block_2222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2222_0: read-var gs#401321:u8
        let s_2222_0: bool = fn_state.gs_401321;
        // D s_2222_1: write-var gs#401322 <= s_2222_0
        fn_state.gs_401322 = s_2222_0;
        // N s_2222_2: jump b2219
        return block_2219(state, tracer, fn_state);
    }
    fn block_2223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2223_0: const #4s : i
        let s_2223_0: i128 = 4;
        // D s_2223_1: read-var u#31608:u32
        let s_2223_1: u32 = fn_state.u_31608;
        // D s_2223_2: cast zx s_2223_1 -> bv
        let s_2223_2: Bits = Bits::new(s_2223_1 as u128, 32u16);
        // C s_2223_3: const #1s : i64
        let s_2223_3: i64 = 1;
        // C s_2223_4: cast zx s_2223_3 -> i
        let s_2223_4: i128 = (i128::try_from(s_2223_3).unwrap());
        // C s_2223_5: const #0s : i
        let s_2223_5: i128 = 0;
        // C s_2223_6: add s_2223_5 s_2223_4
        let s_2223_6: i128 = (s_2223_5 + s_2223_4);
        // D s_2223_7: bit-extract s_2223_2 s_2223_0 s_2223_6
        let s_2223_7: Bits = (Bits::new(
            ((s_2223_2) >> (s_2223_0)).value(),
            u16::try_from(s_2223_6).unwrap(),
        ));
        // D s_2223_8: cast reint s_2223_7 -> u8
        let s_2223_8: bool = ((s_2223_7.value()) != 0);
        // D s_2223_9: cast zx s_2223_8 -> bv
        let s_2223_9: Bits = Bits::new(s_2223_8 as u128, 1u16);
        // C s_2223_10: const #0u : u8
        let s_2223_10: bool = false;
        // C s_2223_11: cast zx s_2223_10 -> bv
        let s_2223_11: Bits = Bits::new(s_2223_10 as u128, 1u16);
        // D s_2223_12: cmp-eq s_2223_9 s_2223_11
        let s_2223_12: bool = ((s_2223_9) == (s_2223_11));
        // D s_2223_13: write-var gs#401321 <= s_2223_12
        fn_state.gs_401321 = s_2223_12;
        // N s_2223_14: jump b2222
        return block_2222(state, tracer, fn_state);
    }
    fn block_2224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2224_0: const #3628s : i
        let s_2224_0: i128 = 3628;
        // C s_2224_1: const #14696u : u32
        let s_2224_1: u32 = 14696;
        // D s_2224_2: read-reg s_2224_1:i
        let s_2224_2: i128 = {
            let value = state.read_register::<i128>(s_2224_1 as isize);
            tracer.read_register(s_2224_1 as isize, value);
            value
        };
        // D s_2224_3: cmp-lt s_2224_2 s_2224_0
        let s_2224_3: bool = ((s_2224_2) < (s_2224_0));
        // D s_2224_4: write-var gs#401291 <= s_2224_3
        fn_state.gs_401291 = s_2224_3;
        // N s_2224_5: jump b947
        return block_947(state, tracer, fn_state);
    }
    fn block_2225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2225_0: const #8s : i
        let s_2225_0: i128 = 8;
        // D s_2225_1: read-var u#31598:u32
        let s_2225_1: u32 = fn_state.u_31598;
        // D s_2225_2: cast zx s_2225_1 -> bv
        let s_2225_2: Bits = Bits::new(s_2225_1 as u128, 32u16);
        // C s_2225_3: const #1s : i64
        let s_2225_3: i64 = 1;
        // C s_2225_4: cast zx s_2225_3 -> i
        let s_2225_4: i128 = (i128::try_from(s_2225_3).unwrap());
        // C s_2225_5: const #3s : i
        let s_2225_5: i128 = 3;
        // C s_2225_6: add s_2225_5 s_2225_4
        let s_2225_6: i128 = (s_2225_5 + s_2225_4);
        // D s_2225_7: bit-extract s_2225_2 s_2225_0 s_2225_6
        let s_2225_7: Bits = (Bits::new(
            ((s_2225_2) >> (s_2225_0)).value(),
            u16::try_from(s_2225_6).unwrap(),
        ));
        // D s_2225_8: cast reint s_2225_7 -> u8
        let s_2225_8: u8 = (s_2225_7.value() as u8);
        // D s_2225_9: cast zx s_2225_8 -> bv
        let s_2225_9: Bits = Bits::new(s_2225_8 as u128, 4u16);
        // C s_2225_10: const #11u : u8
        let s_2225_10: u8 = 11;
        // C s_2225_11: cast zx s_2225_10 -> bv
        let s_2225_11: Bits = Bits::new(s_2225_10 as u128, 4u16);
        // D s_2225_12: cmp-eq s_2225_9 s_2225_11
        let s_2225_12: bool = ((s_2225_9) == (s_2225_11));
        // N s_2225_13: branch s_2225_12 b2228 b2226
        if s_2225_12 {
            return block_2228(state, tracer, fn_state);
        } else {
            return block_2226(state, tracer, fn_state);
        };
    }
    fn block_2226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2226_0: const #0u : u8
        let s_2226_0: bool = false;
        // D s_2226_1: write-var gs#401288 <= s_2226_0
        fn_state.gs_401288 = s_2226_0;
        // N s_2226_2: jump b2227
        return block_2227(state, tracer, fn_state);
    }
    fn block_2227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2227_0: read-var gs#401288:u8
        let s_2227_0: bool = fn_state.gs_401288;
        // D s_2227_1: write-var gs#401289 <= s_2227_0
        fn_state.gs_401289 = s_2227_0;
        // N s_2227_2: jump b945
        return block_945(state, tracer, fn_state);
    }
    fn block_2228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2228_0: const #4s : i
        let s_2228_0: i128 = 4;
        // D s_2228_1: read-var u#31598:u32
        let s_2228_1: u32 = fn_state.u_31598;
        // D s_2228_2: cast zx s_2228_1 -> bv
        let s_2228_2: Bits = Bits::new(s_2228_1 as u128, 32u16);
        // C s_2228_3: const #1s : i64
        let s_2228_3: i64 = 1;
        // C s_2228_4: cast zx s_2228_3 -> i
        let s_2228_4: i128 = (i128::try_from(s_2228_3).unwrap());
        // C s_2228_5: const #0s : i
        let s_2228_5: i128 = 0;
        // C s_2228_6: add s_2228_5 s_2228_4
        let s_2228_6: i128 = (s_2228_5 + s_2228_4);
        // D s_2228_7: bit-extract s_2228_2 s_2228_0 s_2228_6
        let s_2228_7: Bits = (Bits::new(
            ((s_2228_2) >> (s_2228_0)).value(),
            u16::try_from(s_2228_6).unwrap(),
        ));
        // D s_2228_8: cast reint s_2228_7 -> u8
        let s_2228_8: bool = ((s_2228_7.value()) != 0);
        // D s_2228_9: cast zx s_2228_8 -> bv
        let s_2228_9: Bits = Bits::new(s_2228_8 as u128, 1u16);
        // C s_2228_10: const #1u : u8
        let s_2228_10: bool = true;
        // C s_2228_11: cast zx s_2228_10 -> bv
        let s_2228_11: Bits = Bits::new(s_2228_10 as u128, 1u16);
        // D s_2228_12: cmp-eq s_2228_9 s_2228_11
        let s_2228_12: bool = ((s_2228_9) == (s_2228_11));
        // D s_2228_13: write-var gs#401288 <= s_2228_12
        fn_state.gs_401288 = s_2228_12;
        // N s_2228_14: jump b2227
        return block_2227(state, tracer, fn_state);
    }
    fn block_2229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2229_0: const #3625s : i
        let s_2229_0: i128 = 3625;
        // C s_2229_1: const #14696u : u32
        let s_2229_1: u32 = 14696;
        // D s_2229_2: read-reg s_2229_1:i
        let s_2229_2: i128 = {
            let value = state.read_register::<i128>(s_2229_1 as isize);
            tracer.read_register(s_2229_1 as isize, value);
            value
        };
        // D s_2229_3: cmp-lt s_2229_2 s_2229_0
        let s_2229_3: bool = ((s_2229_2) < (s_2229_0));
        // D s_2229_4: write-var gs#401262 <= s_2229_3
        fn_state.gs_401262 = s_2229_3;
        // N s_2229_5: jump b941
        return block_941(state, tracer, fn_state);
    }
    fn block_2230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2230_0: const #23s : i
        let s_2230_0: i128 = 23;
        // D s_2230_1: read-var u#31588:u32
        let s_2230_1: u32 = fn_state.u_31588;
        // D s_2230_2: cast zx s_2230_1 -> bv
        let s_2230_2: Bits = Bits::new(s_2230_1 as u128, 32u16);
        // C s_2230_3: const #1s : i64
        let s_2230_3: i64 = 1;
        // C s_2230_4: cast zx s_2230_3 -> i
        let s_2230_4: i128 = (i128::try_from(s_2230_3).unwrap());
        // C s_2230_5: const #0s : i
        let s_2230_5: i128 = 0;
        // C s_2230_6: add s_2230_5 s_2230_4
        let s_2230_6: i128 = (s_2230_5 + s_2230_4);
        // D s_2230_7: bit-extract s_2230_2 s_2230_0 s_2230_6
        let s_2230_7: Bits = (Bits::new(
            ((s_2230_2) >> (s_2230_0)).value(),
            u16::try_from(s_2230_6).unwrap(),
        ));
        // D s_2230_8: cast reint s_2230_7 -> u8
        let s_2230_8: bool = ((s_2230_7.value()) != 0);
        // D s_2230_9: cast zx s_2230_8 -> bv
        let s_2230_9: Bits = Bits::new(s_2230_8 as u128, 1u16);
        // C s_2230_10: const #1u : u8
        let s_2230_10: bool = true;
        // C s_2230_11: cast zx s_2230_10 -> bv
        let s_2230_11: Bits = Bits::new(s_2230_10 as u128, 1u16);
        // D s_2230_12: cmp-eq s_2230_9 s_2230_11
        let s_2230_12: bool = ((s_2230_9) == (s_2230_11));
        // N s_2230_13: branch s_2230_12 b2233 b2231
        if s_2230_12 {
            return block_2233(state, tracer, fn_state);
        } else {
            return block_2231(state, tracer, fn_state);
        };
    }
    fn block_2231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2231_0: const #0u : u8
        let s_2231_0: bool = false;
        // D s_2231_1: write-var gs#401259 <= s_2231_0
        fn_state.gs_401259 = s_2231_0;
        // N s_2231_2: jump b2232
        return block_2232(state, tracer, fn_state);
    }
    fn block_2232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2232_0: read-var gs#401259:u8
        let s_2232_0: bool = fn_state.gs_401259;
        // D s_2232_1: write-var gs#401260 <= s_2232_0
        fn_state.gs_401260 = s_2232_0;
        // N s_2232_2: jump b939
        return block_939(state, tracer, fn_state);
    }
    fn block_2233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2233_0: const #8s : i
        let s_2233_0: i128 = 8;
        // D s_2233_1: read-var u#31588:u32
        let s_2233_1: u32 = fn_state.u_31588;
        // D s_2233_2: cast zx s_2233_1 -> bv
        let s_2233_2: Bits = Bits::new(s_2233_1 as u128, 32u16);
        // C s_2233_3: const #1s : i64
        let s_2233_3: i64 = 1;
        // C s_2233_4: cast zx s_2233_3 -> i
        let s_2233_4: i128 = (i128::try_from(s_2233_3).unwrap());
        // C s_2233_5: const #3s : i
        let s_2233_5: i128 = 3;
        // C s_2233_6: add s_2233_5 s_2233_4
        let s_2233_6: i128 = (s_2233_5 + s_2233_4);
        // D s_2233_7: bit-extract s_2233_2 s_2233_0 s_2233_6
        let s_2233_7: Bits = (Bits::new(
            ((s_2233_2) >> (s_2233_0)).value(),
            u16::try_from(s_2233_6).unwrap(),
        ));
        // D s_2233_8: cast reint s_2233_7 -> u8
        let s_2233_8: u8 = (s_2233_7.value() as u8);
        // D s_2233_9: cast zx s_2233_8 -> bv
        let s_2233_9: Bits = Bits::new(s_2233_8 as u128, 4u16);
        // C s_2233_10: const #13u : u8
        let s_2233_10: u8 = 13;
        // C s_2233_11: cast zx s_2233_10 -> bv
        let s_2233_11: Bits = Bits::new(s_2233_10 as u128, 4u16);
        // D s_2233_12: cmp-eq s_2233_9 s_2233_11
        let s_2233_12: bool = ((s_2233_9) == (s_2233_11));
        // N s_2233_13: branch s_2233_12 b2236 b2234
        if s_2233_12 {
            return block_2236(state, tracer, fn_state);
        } else {
            return block_2234(state, tracer, fn_state);
        };
    }
    fn block_2234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2234_0: const #0u : u8
        let s_2234_0: bool = false;
        // D s_2234_1: write-var gs#401258 <= s_2234_0
        fn_state.gs_401258 = s_2234_0;
        // N s_2234_2: jump b2235
        return block_2235(state, tracer, fn_state);
    }
    fn block_2235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2235_0: read-var gs#401258:u8
        let s_2235_0: bool = fn_state.gs_401258;
        // D s_2235_1: write-var gs#401259 <= s_2235_0
        fn_state.gs_401259 = s_2235_0;
        // N s_2235_2: jump b2232
        return block_2232(state, tracer, fn_state);
    }
    fn block_2236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2236_0: const #6s : i
        let s_2236_0: i128 = 6;
        // D s_2236_1: read-var u#31588:u32
        let s_2236_1: u32 = fn_state.u_31588;
        // D s_2236_2: cast zx s_2236_1 -> bv
        let s_2236_2: Bits = Bits::new(s_2236_1 as u128, 32u16);
        // C s_2236_3: const #1s : i64
        let s_2236_3: i64 = 1;
        // C s_2236_4: cast zx s_2236_3 -> i
        let s_2236_4: i128 = (i128::try_from(s_2236_3).unwrap());
        // C s_2236_5: const #0s : i
        let s_2236_5: i128 = 0;
        // C s_2236_6: add s_2236_5 s_2236_4
        let s_2236_6: i128 = (s_2236_5 + s_2236_4);
        // D s_2236_7: bit-extract s_2236_2 s_2236_0 s_2236_6
        let s_2236_7: Bits = (Bits::new(
            ((s_2236_2) >> (s_2236_0)).value(),
            u16::try_from(s_2236_6).unwrap(),
        ));
        // D s_2236_8: cast reint s_2236_7 -> u8
        let s_2236_8: bool = ((s_2236_7.value()) != 0);
        // D s_2236_9: cast zx s_2236_8 -> bv
        let s_2236_9: Bits = Bits::new(s_2236_8 as u128, 1u16);
        // C s_2236_10: const #1u : u8
        let s_2236_10: bool = true;
        // C s_2236_11: cast zx s_2236_10 -> bv
        let s_2236_11: Bits = Bits::new(s_2236_10 as u128, 1u16);
        // D s_2236_12: cmp-eq s_2236_9 s_2236_11
        let s_2236_12: bool = ((s_2236_9) == (s_2236_11));
        // N s_2236_13: branch s_2236_12 b2239 b2237
        if s_2236_12 {
            return block_2239(state, tracer, fn_state);
        } else {
            return block_2237(state, tracer, fn_state);
        };
    }
    fn block_2237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2237_0: const #0u : u8
        let s_2237_0: bool = false;
        // D s_2237_1: write-var gs#401257 <= s_2237_0
        fn_state.gs_401257 = s_2237_0;
        // N s_2237_2: jump b2238
        return block_2238(state, tracer, fn_state);
    }
    fn block_2238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2238_0: read-var gs#401257:u8
        let s_2238_0: bool = fn_state.gs_401257;
        // D s_2238_1: write-var gs#401258 <= s_2238_0
        fn_state.gs_401258 = s_2238_0;
        // N s_2238_2: jump b2235
        return block_2235(state, tracer, fn_state);
    }
    fn block_2239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2239_0: const #4s : i
        let s_2239_0: i128 = 4;
        // D s_2239_1: read-var u#31588:u32
        let s_2239_1: u32 = fn_state.u_31588;
        // D s_2239_2: cast zx s_2239_1 -> bv
        let s_2239_2: Bits = Bits::new(s_2239_1 as u128, 32u16);
        // C s_2239_3: const #1s : i64
        let s_2239_3: i64 = 1;
        // C s_2239_4: cast zx s_2239_3 -> i
        let s_2239_4: i128 = (i128::try_from(s_2239_3).unwrap());
        // C s_2239_5: const #0s : i
        let s_2239_5: i128 = 0;
        // C s_2239_6: add s_2239_5 s_2239_4
        let s_2239_6: i128 = (s_2239_5 + s_2239_4);
        // D s_2239_7: bit-extract s_2239_2 s_2239_0 s_2239_6
        let s_2239_7: Bits = (Bits::new(
            ((s_2239_2) >> (s_2239_0)).value(),
            u16::try_from(s_2239_6).unwrap(),
        ));
        // D s_2239_8: cast reint s_2239_7 -> u8
        let s_2239_8: bool = ((s_2239_7.value()) != 0);
        // D s_2239_9: cast zx s_2239_8 -> bv
        let s_2239_9: Bits = Bits::new(s_2239_8 as u128, 1u16);
        // C s_2239_10: const #0u : u8
        let s_2239_10: bool = false;
        // C s_2239_11: cast zx s_2239_10 -> bv
        let s_2239_11: Bits = Bits::new(s_2239_10 as u128, 1u16);
        // D s_2239_12: cmp-eq s_2239_9 s_2239_11
        let s_2239_12: bool = ((s_2239_9) == (s_2239_11));
        // D s_2239_13: write-var gs#401257 <= s_2239_12
        fn_state.gs_401257 = s_2239_12;
        // N s_2239_14: jump b2238
        return block_2238(state, tracer, fn_state);
    }
    fn block_2240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2240_0: const #3624s : i
        let s_2240_0: i128 = 3624;
        // C s_2240_1: const #14696u : u32
        let s_2240_1: u32 = 14696;
        // D s_2240_2: read-reg s_2240_1:i
        let s_2240_2: i128 = {
            let value = state.read_register::<i128>(s_2240_1 as isize);
            tracer.read_register(s_2240_1 as isize, value);
            value
        };
        // D s_2240_3: cmp-lt s_2240_2 s_2240_0
        let s_2240_3: bool = ((s_2240_2) < (s_2240_0));
        // D s_2240_4: write-var gs#401227 <= s_2240_3
        fn_state.gs_401227 = s_2240_3;
        // N s_2240_5: jump b935
        return block_935(state, tracer, fn_state);
    }
    fn block_2241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2241_0: const #8s : i
        let s_2241_0: i128 = 8;
        // D s_2241_1: read-var u#31578:u32
        let s_2241_1: u32 = fn_state.u_31578;
        // D s_2241_2: cast zx s_2241_1 -> bv
        let s_2241_2: Bits = Bits::new(s_2241_1 as u128, 32u16);
        // C s_2241_3: const #1s : i64
        let s_2241_3: i64 = 1;
        // C s_2241_4: cast zx s_2241_3 -> i
        let s_2241_4: i128 = (i128::try_from(s_2241_3).unwrap());
        // C s_2241_5: const #3s : i
        let s_2241_5: i128 = 3;
        // C s_2241_6: add s_2241_5 s_2241_4
        let s_2241_6: i128 = (s_2241_5 + s_2241_4);
        // D s_2241_7: bit-extract s_2241_2 s_2241_0 s_2241_6
        let s_2241_7: Bits = (Bits::new(
            ((s_2241_2) >> (s_2241_0)).value(),
            u16::try_from(s_2241_6).unwrap(),
        ));
        // D s_2241_8: cast reint s_2241_7 -> u8
        let s_2241_8: u8 = (s_2241_7.value() as u8);
        // D s_2241_9: cast zx s_2241_8 -> bv
        let s_2241_9: Bits = Bits::new(s_2241_8 as u128, 4u16);
        // C s_2241_10: const #11u : u8
        let s_2241_10: u8 = 11;
        // C s_2241_11: cast zx s_2241_10 -> bv
        let s_2241_11: Bits = Bits::new(s_2241_10 as u128, 4u16);
        // D s_2241_12: cmp-eq s_2241_9 s_2241_11
        let s_2241_12: bool = ((s_2241_9) == (s_2241_11));
        // N s_2241_13: branch s_2241_12 b2244 b2242
        if s_2241_12 {
            return block_2244(state, tracer, fn_state);
        } else {
            return block_2242(state, tracer, fn_state);
        };
    }
    fn block_2242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2242_0: const #0u : u8
        let s_2242_0: bool = false;
        // D s_2242_1: write-var gs#401224 <= s_2242_0
        fn_state.gs_401224 = s_2242_0;
        // N s_2242_2: jump b2243
        return block_2243(state, tracer, fn_state);
    }
    fn block_2243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2243_0: read-var gs#401224:u8
        let s_2243_0: bool = fn_state.gs_401224;
        // D s_2243_1: write-var gs#401225 <= s_2243_0
        fn_state.gs_401225 = s_2243_0;
        // N s_2243_2: jump b933
        return block_933(state, tracer, fn_state);
    }
    fn block_2244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2244_0: const #4s : i
        let s_2244_0: i128 = 4;
        // D s_2244_1: read-var u#31578:u32
        let s_2244_1: u32 = fn_state.u_31578;
        // D s_2244_2: cast zx s_2244_1 -> bv
        let s_2244_2: Bits = Bits::new(s_2244_1 as u128, 32u16);
        // C s_2244_3: const #1s : i64
        let s_2244_3: i64 = 1;
        // C s_2244_4: cast zx s_2244_3 -> i
        let s_2244_4: i128 = (i128::try_from(s_2244_3).unwrap());
        // C s_2244_5: const #0s : i
        let s_2244_5: i128 = 0;
        // C s_2244_6: add s_2244_5 s_2244_4
        let s_2244_6: i128 = (s_2244_5 + s_2244_4);
        // D s_2244_7: bit-extract s_2244_2 s_2244_0 s_2244_6
        let s_2244_7: Bits = (Bits::new(
            ((s_2244_2) >> (s_2244_0)).value(),
            u16::try_from(s_2244_6).unwrap(),
        ));
        // D s_2244_8: cast reint s_2244_7 -> u8
        let s_2244_8: bool = ((s_2244_7.value()) != 0);
        // D s_2244_9: cast zx s_2244_8 -> bv
        let s_2244_9: Bits = Bits::new(s_2244_8 as u128, 1u16);
        // C s_2244_10: const #0u : u8
        let s_2244_10: bool = false;
        // C s_2244_11: cast zx s_2244_10 -> bv
        let s_2244_11: Bits = Bits::new(s_2244_10 as u128, 1u16);
        // D s_2244_12: cmp-eq s_2244_9 s_2244_11
        let s_2244_12: bool = ((s_2244_9) == (s_2244_11));
        // D s_2244_13: write-var gs#401224 <= s_2244_12
        fn_state.gs_401224 = s_2244_12;
        // N s_2244_14: jump b2243
        return block_2243(state, tracer, fn_state);
    }
    fn block_2245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2245_0: const #3622s : i
        let s_2245_0: i128 = 3622;
        // C s_2245_1: const #14696u : u32
        let s_2245_1: u32 = 14696;
        // D s_2245_2: read-reg s_2245_1:i
        let s_2245_2: i128 = {
            let value = state.read_register::<i128>(s_2245_1 as isize);
            tracer.read_register(s_2245_1 as isize, value);
            value
        };
        // D s_2245_3: cmp-lt s_2245_2 s_2245_0
        let s_2245_3: bool = ((s_2245_2) < (s_2245_0));
        // D s_2245_4: write-var gs#401202 <= s_2245_3
        fn_state.gs_401202 = s_2245_3;
        // N s_2245_5: jump b929
        return block_929(state, tracer, fn_state);
    }
    fn block_2246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2246_0: const #20s : i
        let s_2246_0: i128 = 20;
        // D s_2246_1: read-var u#31570:u32
        let s_2246_1: u32 = fn_state.u_31570;
        // D s_2246_2: cast zx s_2246_1 -> bv
        let s_2246_2: Bits = Bits::new(s_2246_1 as u128, 32u16);
        // C s_2246_3: const #1s : i64
        let s_2246_3: i64 = 1;
        // C s_2246_4: cast zx s_2246_3 -> i
        let s_2246_4: i128 = (i128::try_from(s_2246_3).unwrap());
        // C s_2246_5: const #1s : i
        let s_2246_5: i128 = 1;
        // C s_2246_6: add s_2246_5 s_2246_4
        let s_2246_6: i128 = (s_2246_5 + s_2246_4);
        // D s_2246_7: bit-extract s_2246_2 s_2246_0 s_2246_6
        let s_2246_7: Bits = (Bits::new(
            ((s_2246_2) >> (s_2246_0)).value(),
            u16::try_from(s_2246_6).unwrap(),
        ));
        // D s_2246_8: cast reint s_2246_7 -> u8
        let s_2246_8: u8 = (s_2246_7.value() as u8);
        // D s_2246_9: cast zx s_2246_8 -> bv
        let s_2246_9: Bits = Bits::new(s_2246_8 as u128, 2u16);
        // C s_2246_10: const #3u : u8
        let s_2246_10: u8 = 3;
        // C s_2246_11: cast zx s_2246_10 -> bv
        let s_2246_11: Bits = Bits::new(s_2246_10 as u128, 2u16);
        // D s_2246_12: cmp-eq s_2246_9 s_2246_11
        let s_2246_12: bool = ((s_2246_9) == (s_2246_11));
        // N s_2246_13: branch s_2246_12 b2249 b2247
        if s_2246_12 {
            return block_2249(state, tracer, fn_state);
        } else {
            return block_2247(state, tracer, fn_state);
        };
    }
    fn block_2247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2247_0: const #0u : u8
        let s_2247_0: bool = false;
        // D s_2247_1: write-var gs#401199 <= s_2247_0
        fn_state.gs_401199 = s_2247_0;
        // N s_2247_2: jump b2248
        return block_2248(state, tracer, fn_state);
    }
    fn block_2248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2248_0: read-var gs#401199:u8
        let s_2248_0: bool = fn_state.gs_401199;
        // D s_2248_1: write-var gs#401200 <= s_2248_0
        fn_state.gs_401200 = s_2248_0;
        // N s_2248_2: jump b927
        return block_927(state, tracer, fn_state);
    }
    fn block_2249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2249_0: const #16s : i
        let s_2249_0: i128 = 16;
        // D s_2249_1: read-var u#31570:u32
        let s_2249_1: u32 = fn_state.u_31570;
        // D s_2249_2: cast zx s_2249_1 -> bv
        let s_2249_2: Bits = Bits::new(s_2249_1 as u128, 32u16);
        // C s_2249_3: const #1s : i64
        let s_2249_3: i64 = 1;
        // C s_2249_4: cast zx s_2249_3 -> i
        let s_2249_4: i128 = (i128::try_from(s_2249_3).unwrap());
        // C s_2249_5: const #1s : i
        let s_2249_5: i128 = 1;
        // C s_2249_6: add s_2249_5 s_2249_4
        let s_2249_6: i128 = (s_2249_5 + s_2249_4);
        // D s_2249_7: bit-extract s_2249_2 s_2249_0 s_2249_6
        let s_2249_7: Bits = (Bits::new(
            ((s_2249_2) >> (s_2249_0)).value(),
            u16::try_from(s_2249_6).unwrap(),
        ));
        // D s_2249_8: cast reint s_2249_7 -> u8
        let s_2249_8: u8 = (s_2249_7.value() as u8);
        // D s_2249_9: cast zx s_2249_8 -> bv
        let s_2249_9: Bits = Bits::new(s_2249_8 as u128, 2u16);
        // C s_2249_10: const #0u : u8
        let s_2249_10: u8 = 0;
        // C s_2249_11: cast zx s_2249_10 -> bv
        let s_2249_11: Bits = Bits::new(s_2249_10 as u128, 2u16);
        // D s_2249_12: cmp-eq s_2249_9 s_2249_11
        let s_2249_12: bool = ((s_2249_9) == (s_2249_11));
        // N s_2249_13: branch s_2249_12 b2252 b2250
        if s_2249_12 {
            return block_2252(state, tracer, fn_state);
        } else {
            return block_2250(state, tracer, fn_state);
        };
    }
    fn block_2250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2250_0: const #0u : u8
        let s_2250_0: bool = false;
        // D s_2250_1: write-var gs#401198 <= s_2250_0
        fn_state.gs_401198 = s_2250_0;
        // N s_2250_2: jump b2251
        return block_2251(state, tracer, fn_state);
    }
    fn block_2251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2251_0: read-var gs#401198:u8
        let s_2251_0: bool = fn_state.gs_401198;
        // D s_2251_1: write-var gs#401199 <= s_2251_0
        fn_state.gs_401199 = s_2251_0;
        // N s_2251_2: jump b2248
        return block_2248(state, tracer, fn_state);
    }
    fn block_2252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2252_0: const #7s : i
        let s_2252_0: i128 = 7;
        // D s_2252_1: read-var u#31570:u32
        let s_2252_1: u32 = fn_state.u_31570;
        // D s_2252_2: cast zx s_2252_1 -> bv
        let s_2252_2: Bits = Bits::new(s_2252_1 as u128, 32u16);
        // C s_2252_3: const #1s : i64
        let s_2252_3: i64 = 1;
        // C s_2252_4: cast zx s_2252_3 -> i
        let s_2252_4: i128 = (i128::try_from(s_2252_3).unwrap());
        // C s_2252_5: const #4s : i
        let s_2252_5: i128 = 4;
        // C s_2252_6: add s_2252_5 s_2252_4
        let s_2252_6: i128 = (s_2252_5 + s_2252_4);
        // D s_2252_7: bit-extract s_2252_2 s_2252_0 s_2252_6
        let s_2252_7: Bits = (Bits::new(
            ((s_2252_2) >> (s_2252_0)).value(),
            u16::try_from(s_2252_6).unwrap(),
        ));
        // D s_2252_8: cast reint s_2252_7 -> u8
        let s_2252_8: u8 = (s_2252_7.value() as u8);
        // D s_2252_9: cast zx s_2252_8 -> bv
        let s_2252_9: Bits = Bits::new(s_2252_8 as u128, 5u16);
        // C s_2252_10: const #15u : u8
        let s_2252_10: u8 = 15;
        // C s_2252_11: cast zx s_2252_10 -> bv
        let s_2252_11: Bits = Bits::new(s_2252_10 as u128, 5u16);
        // D s_2252_12: cmp-eq s_2252_9 s_2252_11
        let s_2252_12: bool = ((s_2252_9) == (s_2252_11));
        // N s_2252_13: branch s_2252_12 b2255 b2253
        if s_2252_12 {
            return block_2255(state, tracer, fn_state);
        } else {
            return block_2253(state, tracer, fn_state);
        };
    }
    fn block_2253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2253_0: const #0u : u8
        let s_2253_0: bool = false;
        // D s_2253_1: write-var gs#401197 <= s_2253_0
        fn_state.gs_401197 = s_2253_0;
        // N s_2253_2: jump b2254
        return block_2254(state, tracer, fn_state);
    }
    fn block_2254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2254_0: read-var gs#401197:u8
        let s_2254_0: bool = fn_state.gs_401197;
        // D s_2254_1: write-var gs#401198 <= s_2254_0
        fn_state.gs_401198 = s_2254_0;
        // N s_2254_2: jump b2251
        return block_2251(state, tracer, fn_state);
    }
    fn block_2255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2255_0: const #4s : i
        let s_2255_0: i128 = 4;
        // D s_2255_1: read-var u#31570:u32
        let s_2255_1: u32 = fn_state.u_31570;
        // D s_2255_2: cast zx s_2255_1 -> bv
        let s_2255_2: Bits = Bits::new(s_2255_1 as u128, 32u16);
        // C s_2255_3: const #1s : i64
        let s_2255_3: i64 = 1;
        // C s_2255_4: cast zx s_2255_3 -> i
        let s_2255_4: i128 = (i128::try_from(s_2255_3).unwrap());
        // C s_2255_5: const #0s : i
        let s_2255_5: i128 = 0;
        // C s_2255_6: add s_2255_5 s_2255_4
        let s_2255_6: i128 = (s_2255_5 + s_2255_4);
        // D s_2255_7: bit-extract s_2255_2 s_2255_0 s_2255_6
        let s_2255_7: Bits = (Bits::new(
            ((s_2255_2) >> (s_2255_0)).value(),
            u16::try_from(s_2255_6).unwrap(),
        ));
        // D s_2255_8: cast reint s_2255_7 -> u8
        let s_2255_8: bool = ((s_2255_7.value()) != 0);
        // D s_2255_9: cast zx s_2255_8 -> bv
        let s_2255_9: Bits = Bits::new(s_2255_8 as u128, 1u16);
        // C s_2255_10: const #0u : u8
        let s_2255_10: bool = false;
        // C s_2255_11: cast zx s_2255_10 -> bv
        let s_2255_11: Bits = Bits::new(s_2255_10 as u128, 1u16);
        // D s_2255_12: cmp-eq s_2255_9 s_2255_11
        let s_2255_12: bool = ((s_2255_9) == (s_2255_11));
        // D s_2255_13: write-var gs#401197 <= s_2255_12
        fn_state.gs_401197 = s_2255_12;
        // N s_2255_14: jump b2254
        return block_2254(state, tracer, fn_state);
    }
    fn block_2256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2256_0: const #3620s : i
        let s_2256_0: i128 = 3620;
        // C s_2256_1: const #14696u : u32
        let s_2256_1: u32 = 14696;
        // D s_2256_2: read-reg s_2256_1:i
        let s_2256_2: i128 = {
            let value = state.read_register::<i128>(s_2256_1 as isize);
            tracer.read_register(s_2256_1 as isize, value);
            value
        };
        // D s_2256_3: cmp-lt s_2256_2 s_2256_0
        let s_2256_3: bool = ((s_2256_2) < (s_2256_0));
        // D s_2256_4: write-var gs#401171 <= s_2256_3
        fn_state.gs_401171 = s_2256_3;
        // N s_2256_5: jump b923
        return block_923(state, tracer, fn_state);
    }
    fn block_2257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2257_0: const #20s : i
        let s_2257_0: i128 = 20;
        // D s_2257_1: read-var u#31562:u32
        let s_2257_1: u32 = fn_state.u_31562;
        // D s_2257_2: cast zx s_2257_1 -> bv
        let s_2257_2: Bits = Bits::new(s_2257_1 as u128, 32u16);
        // C s_2257_3: const #1s : i64
        let s_2257_3: i64 = 1;
        // C s_2257_4: cast zx s_2257_3 -> i
        let s_2257_4: i128 = (i128::try_from(s_2257_3).unwrap());
        // C s_2257_5: const #1s : i
        let s_2257_5: i128 = 1;
        // C s_2257_6: add s_2257_5 s_2257_4
        let s_2257_6: i128 = (s_2257_5 + s_2257_4);
        // D s_2257_7: bit-extract s_2257_2 s_2257_0 s_2257_6
        let s_2257_7: Bits = (Bits::new(
            ((s_2257_2) >> (s_2257_0)).value(),
            u16::try_from(s_2257_6).unwrap(),
        ));
        // D s_2257_8: cast reint s_2257_7 -> u8
        let s_2257_8: u8 = (s_2257_7.value() as u8);
        // D s_2257_9: cast zx s_2257_8 -> bv
        let s_2257_9: Bits = Bits::new(s_2257_8 as u128, 2u16);
        // C s_2257_10: const #3u : u8
        let s_2257_10: u8 = 3;
        // C s_2257_11: cast zx s_2257_10 -> bv
        let s_2257_11: Bits = Bits::new(s_2257_10 as u128, 2u16);
        // D s_2257_12: cmp-eq s_2257_9 s_2257_11
        let s_2257_12: bool = ((s_2257_9) == (s_2257_11));
        // N s_2257_13: branch s_2257_12 b2260 b2258
        if s_2257_12 {
            return block_2260(state, tracer, fn_state);
        } else {
            return block_2258(state, tracer, fn_state);
        };
    }
    fn block_2258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2258_0: const #0u : u8
        let s_2258_0: bool = false;
        // D s_2258_1: write-var gs#401168 <= s_2258_0
        fn_state.gs_401168 = s_2258_0;
        // N s_2258_2: jump b2259
        return block_2259(state, tracer, fn_state);
    }
    fn block_2259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2259_0: read-var gs#401168:u8
        let s_2259_0: bool = fn_state.gs_401168;
        // D s_2259_1: write-var gs#401169 <= s_2259_0
        fn_state.gs_401169 = s_2259_0;
        // N s_2259_2: jump b921
        return block_921(state, tracer, fn_state);
    }
    fn block_2260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2260_0: const #16s : i
        let s_2260_0: i128 = 16;
        // D s_2260_1: read-var u#31562:u32
        let s_2260_1: u32 = fn_state.u_31562;
        // D s_2260_2: cast zx s_2260_1 -> bv
        let s_2260_2: Bits = Bits::new(s_2260_1 as u128, 32u16);
        // C s_2260_3: const #1s : i64
        let s_2260_3: i64 = 1;
        // C s_2260_4: cast zx s_2260_3 -> i
        let s_2260_4: i128 = (i128::try_from(s_2260_3).unwrap());
        // C s_2260_5: const #1s : i
        let s_2260_5: i128 = 1;
        // C s_2260_6: add s_2260_5 s_2260_4
        let s_2260_6: i128 = (s_2260_5 + s_2260_4);
        // D s_2260_7: bit-extract s_2260_2 s_2260_0 s_2260_6
        let s_2260_7: Bits = (Bits::new(
            ((s_2260_2) >> (s_2260_0)).value(),
            u16::try_from(s_2260_6).unwrap(),
        ));
        // D s_2260_8: cast reint s_2260_7 -> u8
        let s_2260_8: u8 = (s_2260_7.value() as u8);
        // D s_2260_9: cast zx s_2260_8 -> bv
        let s_2260_9: Bits = Bits::new(s_2260_8 as u128, 2u16);
        // C s_2260_10: const #2u : u8
        let s_2260_10: u8 = 2;
        // C s_2260_11: cast zx s_2260_10 -> bv
        let s_2260_11: Bits = Bits::new(s_2260_10 as u128, 2u16);
        // D s_2260_12: cmp-eq s_2260_9 s_2260_11
        let s_2260_12: bool = ((s_2260_9) == (s_2260_11));
        // N s_2260_13: branch s_2260_12 b2263 b2261
        if s_2260_12 {
            return block_2263(state, tracer, fn_state);
        } else {
            return block_2261(state, tracer, fn_state);
        };
    }
    fn block_2261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2261_0: const #0u : u8
        let s_2261_0: bool = false;
        // D s_2261_1: write-var gs#401167 <= s_2261_0
        fn_state.gs_401167 = s_2261_0;
        // N s_2261_2: jump b2262
        return block_2262(state, tracer, fn_state);
    }
    fn block_2262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2262_0: read-var gs#401167:u8
        let s_2262_0: bool = fn_state.gs_401167;
        // D s_2262_1: write-var gs#401168 <= s_2262_0
        fn_state.gs_401168 = s_2262_0;
        // N s_2262_2: jump b2259
        return block_2259(state, tracer, fn_state);
    }
    fn block_2263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2263_0: const #8s : i
        let s_2263_0: i128 = 8;
        // D s_2263_1: read-var u#31562:u32
        let s_2263_1: u32 = fn_state.u_31562;
        // D s_2263_2: cast zx s_2263_1 -> bv
        let s_2263_2: Bits = Bits::new(s_2263_1 as u128, 32u16);
        // C s_2263_3: const #1s : i64
        let s_2263_3: i64 = 1;
        // C s_2263_4: cast zx s_2263_3 -> i
        let s_2263_4: i128 = (i128::try_from(s_2263_3).unwrap());
        // C s_2263_5: const #3s : i
        let s_2263_5: i128 = 3;
        // C s_2263_6: add s_2263_5 s_2263_4
        let s_2263_6: i128 = (s_2263_5 + s_2263_4);
        // D s_2263_7: bit-extract s_2263_2 s_2263_0 s_2263_6
        let s_2263_7: Bits = (Bits::new(
            ((s_2263_2) >> (s_2263_0)).value(),
            u16::try_from(s_2263_6).unwrap(),
        ));
        // D s_2263_8: cast reint s_2263_7 -> u8
        let s_2263_8: u8 = (s_2263_7.value() as u8);
        // D s_2263_9: cast zx s_2263_8 -> bv
        let s_2263_9: Bits = Bits::new(s_2263_8 as u128, 4u16);
        // C s_2263_10: const #2u : u8
        let s_2263_10: u8 = 2;
        // C s_2263_11: cast zx s_2263_10 -> bv
        let s_2263_11: Bits = Bits::new(s_2263_10 as u128, 4u16);
        // D s_2263_12: cmp-eq s_2263_9 s_2263_11
        let s_2263_12: bool = ((s_2263_9) == (s_2263_11));
        // N s_2263_13: branch s_2263_12 b2266 b2264
        if s_2263_12 {
            return block_2266(state, tracer, fn_state);
        } else {
            return block_2264(state, tracer, fn_state);
        };
    }
    fn block_2264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2264_0: const #0u : u8
        let s_2264_0: bool = false;
        // D s_2264_1: write-var gs#401166 <= s_2264_0
        fn_state.gs_401166 = s_2264_0;
        // N s_2264_2: jump b2265
        return block_2265(state, tracer, fn_state);
    }
    fn block_2265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2265_0: read-var gs#401166:u8
        let s_2265_0: bool = fn_state.gs_401166;
        // D s_2265_1: write-var gs#401167 <= s_2265_0
        fn_state.gs_401167 = s_2265_0;
        // N s_2265_2: jump b2262
        return block_2262(state, tracer, fn_state);
    }
    fn block_2266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2266_0: const #4s : i
        let s_2266_0: i128 = 4;
        // D s_2266_1: read-var u#31562:u32
        let s_2266_1: u32 = fn_state.u_31562;
        // D s_2266_2: cast zx s_2266_1 -> bv
        let s_2266_2: Bits = Bits::new(s_2266_1 as u128, 32u16);
        // C s_2266_3: const #1s : i64
        let s_2266_3: i64 = 1;
        // C s_2266_4: cast zx s_2266_3 -> i
        let s_2266_4: i128 = (i128::try_from(s_2266_3).unwrap());
        // C s_2266_5: const #0s : i
        let s_2266_5: i128 = 0;
        // C s_2266_6: add s_2266_5 s_2266_4
        let s_2266_6: i128 = (s_2266_5 + s_2266_4);
        // D s_2266_7: bit-extract s_2266_2 s_2266_0 s_2266_6
        let s_2266_7: Bits = (Bits::new(
            ((s_2266_2) >> (s_2266_0)).value(),
            u16::try_from(s_2266_6).unwrap(),
        ));
        // D s_2266_8: cast reint s_2266_7 -> u8
        let s_2266_8: bool = ((s_2266_7.value()) != 0);
        // D s_2266_9: cast zx s_2266_8 -> bv
        let s_2266_9: Bits = Bits::new(s_2266_8 as u128, 1u16);
        // C s_2266_10: const #0u : u8
        let s_2266_10: bool = false;
        // C s_2266_11: cast zx s_2266_10 -> bv
        let s_2266_11: Bits = Bits::new(s_2266_10 as u128, 1u16);
        // D s_2266_12: cmp-eq s_2266_9 s_2266_11
        let s_2266_12: bool = ((s_2266_9) == (s_2266_11));
        // D s_2266_13: write-var gs#401166 <= s_2266_12
        fn_state.gs_401166 = s_2266_12;
        // N s_2266_14: jump b2265
        return block_2265(state, tracer, fn_state);
    }
    fn block_2267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2267_0: const #3617s : i
        let s_2267_0: i128 = 3617;
        // C s_2267_1: const #14696u : u32
        let s_2267_1: u32 = 14696;
        // D s_2267_2: read-reg s_2267_1:i
        let s_2267_2: i128 = {
            let value = state.read_register::<i128>(s_2267_1 as isize);
            tracer.read_register(s_2267_1 as isize, value);
            value
        };
        // D s_2267_3: cmp-lt s_2267_2 s_2267_0
        let s_2267_3: bool = ((s_2267_2) < (s_2267_0));
        // D s_2267_4: write-var gs#401138 <= s_2267_3
        fn_state.gs_401138 = s_2267_3;
        // N s_2267_5: jump b917
        return block_917(state, tracer, fn_state);
    }
    fn block_2268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2268_0: const #8s : i
        let s_2268_0: i128 = 8;
        // D s_2268_1: read-var u#31553:u32
        let s_2268_1: u32 = fn_state.u_31553;
        // D s_2268_2: cast zx s_2268_1 -> bv
        let s_2268_2: Bits = Bits::new(s_2268_1 as u128, 32u16);
        // C s_2268_3: const #1s : i64
        let s_2268_3: i64 = 1;
        // C s_2268_4: cast zx s_2268_3 -> i
        let s_2268_4: i128 = (i128::try_from(s_2268_3).unwrap());
        // C s_2268_5: const #3s : i
        let s_2268_5: i128 = 3;
        // C s_2268_6: add s_2268_5 s_2268_4
        let s_2268_6: i128 = (s_2268_5 + s_2268_4);
        // D s_2268_7: bit-extract s_2268_2 s_2268_0 s_2268_6
        let s_2268_7: Bits = (Bits::new(
            ((s_2268_2) >> (s_2268_0)).value(),
            u16::try_from(s_2268_6).unwrap(),
        ));
        // D s_2268_8: cast reint s_2268_7 -> u8
        let s_2268_8: u8 = (s_2268_7.value() as u8);
        // D s_2268_9: cast zx s_2268_8 -> bv
        let s_2268_9: Bits = Bits::new(s_2268_8 as u128, 4u16);
        // C s_2268_10: const #11u : u8
        let s_2268_10: u8 = 11;
        // C s_2268_11: cast zx s_2268_10 -> bv
        let s_2268_11: Bits = Bits::new(s_2268_10 as u128, 4u16);
        // D s_2268_12: cmp-eq s_2268_9 s_2268_11
        let s_2268_12: bool = ((s_2268_9) == (s_2268_11));
        // N s_2268_13: branch s_2268_12 b2271 b2269
        if s_2268_12 {
            return block_2271(state, tracer, fn_state);
        } else {
            return block_2269(state, tracer, fn_state);
        };
    }
    fn block_2269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2269_0: const #0u : u8
        let s_2269_0: bool = false;
        // D s_2269_1: write-var gs#401135 <= s_2269_0
        fn_state.gs_401135 = s_2269_0;
        // N s_2269_2: jump b2270
        return block_2270(state, tracer, fn_state);
    }
    fn block_2270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2270_0: read-var gs#401135:u8
        let s_2270_0: bool = fn_state.gs_401135;
        // D s_2270_1: write-var gs#401136 <= s_2270_0
        fn_state.gs_401136 = s_2270_0;
        // N s_2270_2: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_2271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2271_0: const #6s : i
        let s_2271_0: i128 = 6;
        // D s_2271_1: read-var u#31553:u32
        let s_2271_1: u32 = fn_state.u_31553;
        // D s_2271_2: cast zx s_2271_1 -> bv
        let s_2271_2: Bits = Bits::new(s_2271_1 as u128, 32u16);
        // C s_2271_3: const #1s : i64
        let s_2271_3: i64 = 1;
        // C s_2271_4: cast zx s_2271_3 -> i
        let s_2271_4: i128 = (i128::try_from(s_2271_3).unwrap());
        // C s_2271_5: const #0s : i
        let s_2271_5: i128 = 0;
        // C s_2271_6: add s_2271_5 s_2271_4
        let s_2271_6: i128 = (s_2271_5 + s_2271_4);
        // D s_2271_7: bit-extract s_2271_2 s_2271_0 s_2271_6
        let s_2271_7: Bits = (Bits::new(
            ((s_2271_2) >> (s_2271_0)).value(),
            u16::try_from(s_2271_6).unwrap(),
        ));
        // D s_2271_8: cast reint s_2271_7 -> u8
        let s_2271_8: bool = ((s_2271_7.value()) != 0);
        // D s_2271_9: cast zx s_2271_8 -> bv
        let s_2271_9: Bits = Bits::new(s_2271_8 as u128, 1u16);
        // C s_2271_10: const #1u : u8
        let s_2271_10: bool = true;
        // C s_2271_11: cast zx s_2271_10 -> bv
        let s_2271_11: Bits = Bits::new(s_2271_10 as u128, 1u16);
        // D s_2271_12: cmp-eq s_2271_9 s_2271_11
        let s_2271_12: bool = ((s_2271_9) == (s_2271_11));
        // N s_2271_13: branch s_2271_12 b2274 b2272
        if s_2271_12 {
            return block_2274(state, tracer, fn_state);
        } else {
            return block_2272(state, tracer, fn_state);
        };
    }
    fn block_2272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2272_0: const #0u : u8
        let s_2272_0: bool = false;
        // D s_2272_1: write-var gs#401134 <= s_2272_0
        fn_state.gs_401134 = s_2272_0;
        // N s_2272_2: jump b2273
        return block_2273(state, tracer, fn_state);
    }
    fn block_2273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2273_0: read-var gs#401134:u8
        let s_2273_0: bool = fn_state.gs_401134;
        // D s_2273_1: write-var gs#401135 <= s_2273_0
        fn_state.gs_401135 = s_2273_0;
        // N s_2273_2: jump b2270
        return block_2270(state, tracer, fn_state);
    }
    fn block_2274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2274_0: const #4s : i
        let s_2274_0: i128 = 4;
        // D s_2274_1: read-var u#31553:u32
        let s_2274_1: u32 = fn_state.u_31553;
        // D s_2274_2: cast zx s_2274_1 -> bv
        let s_2274_2: Bits = Bits::new(s_2274_1 as u128, 32u16);
        // C s_2274_3: const #1s : i64
        let s_2274_3: i64 = 1;
        // C s_2274_4: cast zx s_2274_3 -> i
        let s_2274_4: i128 = (i128::try_from(s_2274_3).unwrap());
        // C s_2274_5: const #0s : i
        let s_2274_5: i128 = 0;
        // C s_2274_6: add s_2274_5 s_2274_4
        let s_2274_6: i128 = (s_2274_5 + s_2274_4);
        // D s_2274_7: bit-extract s_2274_2 s_2274_0 s_2274_6
        let s_2274_7: Bits = (Bits::new(
            ((s_2274_2) >> (s_2274_0)).value(),
            u16::try_from(s_2274_6).unwrap(),
        ));
        // D s_2274_8: cast reint s_2274_7 -> u8
        let s_2274_8: bool = ((s_2274_7.value()) != 0);
        // D s_2274_9: cast zx s_2274_8 -> bv
        let s_2274_9: Bits = Bits::new(s_2274_8 as u128, 1u16);
        // C s_2274_10: const #0u : u8
        let s_2274_10: bool = false;
        // C s_2274_11: cast zx s_2274_10 -> bv
        let s_2274_11: Bits = Bits::new(s_2274_10 as u128, 1u16);
        // D s_2274_12: cmp-eq s_2274_9 s_2274_11
        let s_2274_12: bool = ((s_2274_9) == (s_2274_11));
        // D s_2274_13: write-var gs#401134 <= s_2274_12
        fn_state.gs_401134 = s_2274_12;
        // N s_2274_14: jump b2273
        return block_2273(state, tracer, fn_state);
    }
    fn block_2275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2275_0: const #3616s : i
        let s_2275_0: i128 = 3616;
        // C s_2275_1: const #14696u : u32
        let s_2275_1: u32 = 14696;
        // D s_2275_2: read-reg s_2275_1:i
        let s_2275_2: i128 = {
            let value = state.read_register::<i128>(s_2275_1 as isize);
            tracer.read_register(s_2275_1 as isize, value);
            value
        };
        // D s_2275_3: cmp-lt s_2275_2 s_2275_0
        let s_2275_3: bool = ((s_2275_2) < (s_2275_0));
        // D s_2275_4: write-var gs#401108 <= s_2275_3
        fn_state.gs_401108 = s_2275_3;
        // N s_2275_5: jump b911
        return block_911(state, tracer, fn_state);
    }
    fn block_2276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2276_0: const #8s : i
        let s_2276_0: i128 = 8;
        // D s_2276_1: read-var u#31544:u32
        let s_2276_1: u32 = fn_state.u_31544;
        // D s_2276_2: cast zx s_2276_1 -> bv
        let s_2276_2: Bits = Bits::new(s_2276_1 as u128, 32u16);
        // C s_2276_3: const #1s : i64
        let s_2276_3: i64 = 1;
        // C s_2276_4: cast zx s_2276_3 -> i
        let s_2276_4: i128 = (i128::try_from(s_2276_3).unwrap());
        // C s_2276_5: const #3s : i
        let s_2276_5: i128 = 3;
        // C s_2276_6: add s_2276_5 s_2276_4
        let s_2276_6: i128 = (s_2276_5 + s_2276_4);
        // D s_2276_7: bit-extract s_2276_2 s_2276_0 s_2276_6
        let s_2276_7: Bits = (Bits::new(
            ((s_2276_2) >> (s_2276_0)).value(),
            u16::try_from(s_2276_6).unwrap(),
        ));
        // D s_2276_8: cast reint s_2276_7 -> u8
        let s_2276_8: u8 = (s_2276_7.value() as u8);
        // D s_2276_9: cast zx s_2276_8 -> bv
        let s_2276_9: Bits = Bits::new(s_2276_8 as u128, 4u16);
        // C s_2276_10: const #13u : u8
        let s_2276_10: u8 = 13;
        // C s_2276_11: cast zx s_2276_10 -> bv
        let s_2276_11: Bits = Bits::new(s_2276_10 as u128, 4u16);
        // D s_2276_12: cmp-eq s_2276_9 s_2276_11
        let s_2276_12: bool = ((s_2276_9) == (s_2276_11));
        // N s_2276_13: branch s_2276_12 b2279 b2277
        if s_2276_12 {
            return block_2279(state, tracer, fn_state);
        } else {
            return block_2277(state, tracer, fn_state);
        };
    }
    fn block_2277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2277_0: const #0u : u8
        let s_2277_0: bool = false;
        // D s_2277_1: write-var gs#401105 <= s_2277_0
        fn_state.gs_401105 = s_2277_0;
        // N s_2277_2: jump b2278
        return block_2278(state, tracer, fn_state);
    }
    fn block_2278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2278_0: read-var gs#401105:u8
        let s_2278_0: bool = fn_state.gs_401105;
        // D s_2278_1: write-var gs#401106 <= s_2278_0
        fn_state.gs_401106 = s_2278_0;
        // N s_2278_2: jump b909
        return block_909(state, tracer, fn_state);
    }
    fn block_2279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2279_0: const #6s : i
        let s_2279_0: i128 = 6;
        // D s_2279_1: read-var u#31544:u32
        let s_2279_1: u32 = fn_state.u_31544;
        // D s_2279_2: cast zx s_2279_1 -> bv
        let s_2279_2: Bits = Bits::new(s_2279_1 as u128, 32u16);
        // C s_2279_3: const #1s : i64
        let s_2279_3: i64 = 1;
        // C s_2279_4: cast zx s_2279_3 -> i
        let s_2279_4: i128 = (i128::try_from(s_2279_3).unwrap());
        // C s_2279_5: const #0s : i
        let s_2279_5: i128 = 0;
        // C s_2279_6: add s_2279_5 s_2279_4
        let s_2279_6: i128 = (s_2279_5 + s_2279_4);
        // D s_2279_7: bit-extract s_2279_2 s_2279_0 s_2279_6
        let s_2279_7: Bits = (Bits::new(
            ((s_2279_2) >> (s_2279_0)).value(),
            u16::try_from(s_2279_6).unwrap(),
        ));
        // D s_2279_8: cast reint s_2279_7 -> u8
        let s_2279_8: bool = ((s_2279_7.value()) != 0);
        // D s_2279_9: cast zx s_2279_8 -> bv
        let s_2279_9: Bits = Bits::new(s_2279_8 as u128, 1u16);
        // C s_2279_10: const #0u : u8
        let s_2279_10: bool = false;
        // C s_2279_11: cast zx s_2279_10 -> bv
        let s_2279_11: Bits = Bits::new(s_2279_10 as u128, 1u16);
        // D s_2279_12: cmp-eq s_2279_9 s_2279_11
        let s_2279_12: bool = ((s_2279_9) == (s_2279_11));
        // N s_2279_13: branch s_2279_12 b2282 b2280
        if s_2279_12 {
            return block_2282(state, tracer, fn_state);
        } else {
            return block_2280(state, tracer, fn_state);
        };
    }
    fn block_2280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2280_0: const #0u : u8
        let s_2280_0: bool = false;
        // D s_2280_1: write-var gs#401104 <= s_2280_0
        fn_state.gs_401104 = s_2280_0;
        // N s_2280_2: jump b2281
        return block_2281(state, tracer, fn_state);
    }
    fn block_2281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2281_0: read-var gs#401104:u8
        let s_2281_0: bool = fn_state.gs_401104;
        // D s_2281_1: write-var gs#401105 <= s_2281_0
        fn_state.gs_401105 = s_2281_0;
        // N s_2281_2: jump b2278
        return block_2278(state, tracer, fn_state);
    }
    fn block_2282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2282_0: const #4s : i
        let s_2282_0: i128 = 4;
        // D s_2282_1: read-var u#31544:u32
        let s_2282_1: u32 = fn_state.u_31544;
        // D s_2282_2: cast zx s_2282_1 -> bv
        let s_2282_2: Bits = Bits::new(s_2282_1 as u128, 32u16);
        // C s_2282_3: const #1s : i64
        let s_2282_3: i64 = 1;
        // C s_2282_4: cast zx s_2282_3 -> i
        let s_2282_4: i128 = (i128::try_from(s_2282_3).unwrap());
        // C s_2282_5: const #0s : i
        let s_2282_5: i128 = 0;
        // C s_2282_6: add s_2282_5 s_2282_4
        let s_2282_6: i128 = (s_2282_5 + s_2282_4);
        // D s_2282_7: bit-extract s_2282_2 s_2282_0 s_2282_6
        let s_2282_7: Bits = (Bits::new(
            ((s_2282_2) >> (s_2282_0)).value(),
            u16::try_from(s_2282_6).unwrap(),
        ));
        // D s_2282_8: cast reint s_2282_7 -> u8
        let s_2282_8: bool = ((s_2282_7.value()) != 0);
        // D s_2282_9: cast zx s_2282_8 -> bv
        let s_2282_9: Bits = Bits::new(s_2282_8 as u128, 1u16);
        // C s_2282_10: const #0u : u8
        let s_2282_10: bool = false;
        // C s_2282_11: cast zx s_2282_10 -> bv
        let s_2282_11: Bits = Bits::new(s_2282_10 as u128, 1u16);
        // D s_2282_12: cmp-eq s_2282_9 s_2282_11
        let s_2282_12: bool = ((s_2282_9) == (s_2282_11));
        // D s_2282_13: write-var gs#401104 <= s_2282_12
        fn_state.gs_401104 = s_2282_12;
        // N s_2282_14: jump b2281
        return block_2281(state, tracer, fn_state);
    }
    fn block_2283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2283_0: const #3613s : i
        let s_2283_0: i128 = 3613;
        // C s_2283_1: const #14696u : u32
        let s_2283_1: u32 = 14696;
        // D s_2283_2: read-reg s_2283_1:i
        let s_2283_2: i128 = {
            let value = state.read_register::<i128>(s_2283_1 as isize);
            tracer.read_register(s_2283_1 as isize, value);
            value
        };
        // D s_2283_3: cmp-lt s_2283_2 s_2283_0
        let s_2283_3: bool = ((s_2283_2) < (s_2283_0));
        // D s_2283_4: write-var gs#401076 <= s_2283_3
        fn_state.gs_401076 = s_2283_3;
        // N s_2283_5: jump b905
        return block_905(state, tracer, fn_state);
    }
    fn block_2284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2284_0: const #23s : i
        let s_2284_0: i128 = 23;
        // D s_2284_1: read-var u#31534:u32
        let s_2284_1: u32 = fn_state.u_31534;
        // D s_2284_2: cast zx s_2284_1 -> bv
        let s_2284_2: Bits = Bits::new(s_2284_1 as u128, 32u16);
        // C s_2284_3: const #1s : i64
        let s_2284_3: i64 = 1;
        // C s_2284_4: cast zx s_2284_3 -> i
        let s_2284_4: i128 = (i128::try_from(s_2284_3).unwrap());
        // C s_2284_5: const #0s : i
        let s_2284_5: i128 = 0;
        // C s_2284_6: add s_2284_5 s_2284_4
        let s_2284_6: i128 = (s_2284_5 + s_2284_4);
        // D s_2284_7: bit-extract s_2284_2 s_2284_0 s_2284_6
        let s_2284_7: Bits = (Bits::new(
            ((s_2284_2) >> (s_2284_0)).value(),
            u16::try_from(s_2284_6).unwrap(),
        ));
        // D s_2284_8: cast reint s_2284_7 -> u8
        let s_2284_8: bool = ((s_2284_7.value()) != 0);
        // D s_2284_9: cast zx s_2284_8 -> bv
        let s_2284_9: Bits = Bits::new(s_2284_8 as u128, 1u16);
        // C s_2284_10: const #1u : u8
        let s_2284_10: bool = true;
        // C s_2284_11: cast zx s_2284_10 -> bv
        let s_2284_11: Bits = Bits::new(s_2284_10 as u128, 1u16);
        // D s_2284_12: cmp-eq s_2284_9 s_2284_11
        let s_2284_12: bool = ((s_2284_9) == (s_2284_11));
        // N s_2284_13: branch s_2284_12 b2287 b2285
        if s_2284_12 {
            return block_2287(state, tracer, fn_state);
        } else {
            return block_2285(state, tracer, fn_state);
        };
    }
    fn block_2285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2285_0: const #0u : u8
        let s_2285_0: bool = false;
        // D s_2285_1: write-var gs#401073 <= s_2285_0
        fn_state.gs_401073 = s_2285_0;
        // N s_2285_2: jump b2286
        return block_2286(state, tracer, fn_state);
    }
    fn block_2286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2286_0: read-var gs#401073:u8
        let s_2286_0: bool = fn_state.gs_401073;
        // D s_2286_1: write-var gs#401074 <= s_2286_0
        fn_state.gs_401074 = s_2286_0;
        // N s_2286_2: jump b903
        return block_903(state, tracer, fn_state);
    }
    fn block_2287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2287_0: const #8s : i
        let s_2287_0: i128 = 8;
        // D s_2287_1: read-var u#31534:u32
        let s_2287_1: u32 = fn_state.u_31534;
        // D s_2287_2: cast zx s_2287_1 -> bv
        let s_2287_2: Bits = Bits::new(s_2287_1 as u128, 32u16);
        // C s_2287_3: const #1s : i64
        let s_2287_3: i64 = 1;
        // C s_2287_4: cast zx s_2287_3 -> i
        let s_2287_4: i128 = (i128::try_from(s_2287_3).unwrap());
        // C s_2287_5: const #3s : i
        let s_2287_5: i128 = 3;
        // C s_2287_6: add s_2287_5 s_2287_4
        let s_2287_6: i128 = (s_2287_5 + s_2287_4);
        // D s_2287_7: bit-extract s_2287_2 s_2287_0 s_2287_6
        let s_2287_7: Bits = (Bits::new(
            ((s_2287_2) >> (s_2287_0)).value(),
            u16::try_from(s_2287_6).unwrap(),
        ));
        // D s_2287_8: cast reint s_2287_7 -> u8
        let s_2287_8: u8 = (s_2287_7.value() as u8);
        // D s_2287_9: cast zx s_2287_8 -> bv
        let s_2287_9: Bits = Bits::new(s_2287_8 as u128, 4u16);
        // C s_2287_10: const #12u : u8
        let s_2287_10: u8 = 12;
        // C s_2287_11: cast zx s_2287_10 -> bv
        let s_2287_11: Bits = Bits::new(s_2287_10 as u128, 4u16);
        // D s_2287_12: cmp-eq s_2287_9 s_2287_11
        let s_2287_12: bool = ((s_2287_9) == (s_2287_11));
        // N s_2287_13: branch s_2287_12 b2290 b2288
        if s_2287_12 {
            return block_2290(state, tracer, fn_state);
        } else {
            return block_2288(state, tracer, fn_state);
        };
    }
    fn block_2288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2288_0: const #0u : u8
        let s_2288_0: bool = false;
        // D s_2288_1: write-var gs#401072 <= s_2288_0
        fn_state.gs_401072 = s_2288_0;
        // N s_2288_2: jump b2289
        return block_2289(state, tracer, fn_state);
    }
    fn block_2289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2289_0: read-var gs#401072:u8
        let s_2289_0: bool = fn_state.gs_401072;
        // D s_2289_1: write-var gs#401073 <= s_2289_0
        fn_state.gs_401073 = s_2289_0;
        // N s_2289_2: jump b2286
        return block_2286(state, tracer, fn_state);
    }
    fn block_2290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2290_0: const #6s : i
        let s_2290_0: i128 = 6;
        // D s_2290_1: read-var u#31534:u32
        let s_2290_1: u32 = fn_state.u_31534;
        // D s_2290_2: cast zx s_2290_1 -> bv
        let s_2290_2: Bits = Bits::new(s_2290_1 as u128, 32u16);
        // C s_2290_3: const #1s : i64
        let s_2290_3: i64 = 1;
        // C s_2290_4: cast zx s_2290_3 -> i
        let s_2290_4: i128 = (i128::try_from(s_2290_3).unwrap());
        // C s_2290_5: const #0s : i
        let s_2290_5: i128 = 0;
        // C s_2290_6: add s_2290_5 s_2290_4
        let s_2290_6: i128 = (s_2290_5 + s_2290_4);
        // D s_2290_7: bit-extract s_2290_2 s_2290_0 s_2290_6
        let s_2290_7: Bits = (Bits::new(
            ((s_2290_2) >> (s_2290_0)).value(),
            u16::try_from(s_2290_6).unwrap(),
        ));
        // D s_2290_8: cast reint s_2290_7 -> u8
        let s_2290_8: bool = ((s_2290_7.value()) != 0);
        // D s_2290_9: cast zx s_2290_8 -> bv
        let s_2290_9: Bits = Bits::new(s_2290_8 as u128, 1u16);
        // C s_2290_10: const #1u : u8
        let s_2290_10: bool = true;
        // C s_2290_11: cast zx s_2290_10 -> bv
        let s_2290_11: Bits = Bits::new(s_2290_10 as u128, 1u16);
        // D s_2290_12: cmp-eq s_2290_9 s_2290_11
        let s_2290_12: bool = ((s_2290_9) == (s_2290_11));
        // N s_2290_13: branch s_2290_12 b2293 b2291
        if s_2290_12 {
            return block_2293(state, tracer, fn_state);
        } else {
            return block_2291(state, tracer, fn_state);
        };
    }
    fn block_2291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2291_0: const #0u : u8
        let s_2291_0: bool = false;
        // D s_2291_1: write-var gs#401071 <= s_2291_0
        fn_state.gs_401071 = s_2291_0;
        // N s_2291_2: jump b2292
        return block_2292(state, tracer, fn_state);
    }
    fn block_2292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2292_0: read-var gs#401071:u8
        let s_2292_0: bool = fn_state.gs_401071;
        // D s_2292_1: write-var gs#401072 <= s_2292_0
        fn_state.gs_401072 = s_2292_0;
        // N s_2292_2: jump b2289
        return block_2289(state, tracer, fn_state);
    }
    fn block_2293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2293_0: const #4s : i
        let s_2293_0: i128 = 4;
        // D s_2293_1: read-var u#31534:u32
        let s_2293_1: u32 = fn_state.u_31534;
        // D s_2293_2: cast zx s_2293_1 -> bv
        let s_2293_2: Bits = Bits::new(s_2293_1 as u128, 32u16);
        // C s_2293_3: const #1s : i64
        let s_2293_3: i64 = 1;
        // C s_2293_4: cast zx s_2293_3 -> i
        let s_2293_4: i128 = (i128::try_from(s_2293_3).unwrap());
        // C s_2293_5: const #0s : i
        let s_2293_5: i128 = 0;
        // C s_2293_6: add s_2293_5 s_2293_4
        let s_2293_6: i128 = (s_2293_5 + s_2293_4);
        // D s_2293_7: bit-extract s_2293_2 s_2293_0 s_2293_6
        let s_2293_7: Bits = (Bits::new(
            ((s_2293_2) >> (s_2293_0)).value(),
            u16::try_from(s_2293_6).unwrap(),
        ));
        // D s_2293_8: cast reint s_2293_7 -> u8
        let s_2293_8: bool = ((s_2293_7.value()) != 0);
        // D s_2293_9: cast zx s_2293_8 -> bv
        let s_2293_9: Bits = Bits::new(s_2293_8 as u128, 1u16);
        // C s_2293_10: const #0u : u8
        let s_2293_10: bool = false;
        // C s_2293_11: cast zx s_2293_10 -> bv
        let s_2293_11: Bits = Bits::new(s_2293_10 as u128, 1u16);
        // D s_2293_12: cmp-eq s_2293_9 s_2293_11
        let s_2293_12: bool = ((s_2293_9) == (s_2293_11));
        // D s_2293_13: write-var gs#401071 <= s_2293_12
        fn_state.gs_401071 = s_2293_12;
        // N s_2293_14: jump b2292
        return block_2292(state, tracer, fn_state);
    }
    fn block_2294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2294_0: const #3612s : i
        let s_2294_0: i128 = 3612;
        // C s_2294_1: const #14696u : u32
        let s_2294_1: u32 = 14696;
        // D s_2294_2: read-reg s_2294_1:i
        let s_2294_2: i128 = {
            let value = state.read_register::<i128>(s_2294_1 as isize);
            tracer.read_register(s_2294_1 as isize, value);
            value
        };
        // D s_2294_3: cmp-lt s_2294_2 s_2294_0
        let s_2294_3: bool = ((s_2294_2) < (s_2294_0));
        // D s_2294_4: write-var gs#401041 <= s_2294_3
        fn_state.gs_401041 = s_2294_3;
        // N s_2294_5: jump b899
        return block_899(state, tracer, fn_state);
    }
    fn block_2295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2295_0: const #8s : i
        let s_2295_0: i128 = 8;
        // D s_2295_1: read-var u#31524:u32
        let s_2295_1: u32 = fn_state.u_31524;
        // D s_2295_2: cast zx s_2295_1 -> bv
        let s_2295_2: Bits = Bits::new(s_2295_1 as u128, 32u16);
        // C s_2295_3: const #1s : i64
        let s_2295_3: i64 = 1;
        // C s_2295_4: cast zx s_2295_3 -> i
        let s_2295_4: i128 = (i128::try_from(s_2295_3).unwrap());
        // C s_2295_5: const #3s : i
        let s_2295_5: i128 = 3;
        // C s_2295_6: add s_2295_5 s_2295_4
        let s_2295_6: i128 = (s_2295_5 + s_2295_4);
        // D s_2295_7: bit-extract s_2295_2 s_2295_0 s_2295_6
        let s_2295_7: Bits = (Bits::new(
            ((s_2295_2) >> (s_2295_0)).value(),
            u16::try_from(s_2295_6).unwrap(),
        ));
        // D s_2295_8: cast reint s_2295_7 -> u8
        let s_2295_8: u8 = (s_2295_7.value() as u8);
        // D s_2295_9: cast zx s_2295_8 -> bv
        let s_2295_9: Bits = Bits::new(s_2295_8 as u128, 4u16);
        // C s_2295_10: const #11u : u8
        let s_2295_10: u8 = 11;
        // C s_2295_11: cast zx s_2295_10 -> bv
        let s_2295_11: Bits = Bits::new(s_2295_10 as u128, 4u16);
        // D s_2295_12: cmp-eq s_2295_9 s_2295_11
        let s_2295_12: bool = ((s_2295_9) == (s_2295_11));
        // N s_2295_13: branch s_2295_12 b2298 b2296
        if s_2295_12 {
            return block_2298(state, tracer, fn_state);
        } else {
            return block_2296(state, tracer, fn_state);
        };
    }
    fn block_2296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2296_0: const #0u : u8
        let s_2296_0: bool = false;
        // D s_2296_1: write-var gs#401038 <= s_2296_0
        fn_state.gs_401038 = s_2296_0;
        // N s_2296_2: jump b2297
        return block_2297(state, tracer, fn_state);
    }
    fn block_2297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2297_0: read-var gs#401038:u8
        let s_2297_0: bool = fn_state.gs_401038;
        // D s_2297_1: write-var gs#401039 <= s_2297_0
        fn_state.gs_401039 = s_2297_0;
        // N s_2297_2: jump b897
        return block_897(state, tracer, fn_state);
    }
    fn block_2298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2298_0: const #4s : i
        let s_2298_0: i128 = 4;
        // D s_2298_1: read-var u#31524:u32
        let s_2298_1: u32 = fn_state.u_31524;
        // D s_2298_2: cast zx s_2298_1 -> bv
        let s_2298_2: Bits = Bits::new(s_2298_1 as u128, 32u16);
        // C s_2298_3: const #1s : i64
        let s_2298_3: i64 = 1;
        // C s_2298_4: cast zx s_2298_3 -> i
        let s_2298_4: i128 = (i128::try_from(s_2298_3).unwrap());
        // C s_2298_5: const #0s : i
        let s_2298_5: i128 = 0;
        // C s_2298_6: add s_2298_5 s_2298_4
        let s_2298_6: i128 = (s_2298_5 + s_2298_4);
        // D s_2298_7: bit-extract s_2298_2 s_2298_0 s_2298_6
        let s_2298_7: Bits = (Bits::new(
            ((s_2298_2) >> (s_2298_0)).value(),
            u16::try_from(s_2298_6).unwrap(),
        ));
        // D s_2298_8: cast reint s_2298_7 -> u8
        let s_2298_8: bool = ((s_2298_7.value()) != 0);
        // D s_2298_9: cast zx s_2298_8 -> bv
        let s_2298_9: Bits = Bits::new(s_2298_8 as u128, 1u16);
        // C s_2298_10: const #0u : u8
        let s_2298_10: bool = false;
        // C s_2298_11: cast zx s_2298_10 -> bv
        let s_2298_11: Bits = Bits::new(s_2298_10 as u128, 1u16);
        // D s_2298_12: cmp-eq s_2298_9 s_2298_11
        let s_2298_12: bool = ((s_2298_9) == (s_2298_11));
        // D s_2298_13: write-var gs#401038 <= s_2298_12
        fn_state.gs_401038 = s_2298_12;
        // N s_2298_14: jump b2297
        return block_2297(state, tracer, fn_state);
    }
    fn block_2299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2299_0: const #3609s : i
        let s_2299_0: i128 = 3609;
        // C s_2299_1: const #14696u : u32
        let s_2299_1: u32 = 14696;
        // D s_2299_2: read-reg s_2299_1:i
        let s_2299_2: i128 = {
            let value = state.read_register::<i128>(s_2299_1 as isize);
            tracer.read_register(s_2299_1 as isize, value);
            value
        };
        // D s_2299_3: cmp-lt s_2299_2 s_2299_0
        let s_2299_3: bool = ((s_2299_2) < (s_2299_0));
        // D s_2299_4: write-var gs#401012 <= s_2299_3
        fn_state.gs_401012 = s_2299_3;
        // N s_2299_5: jump b893
        return block_893(state, tracer, fn_state);
    }
    fn block_2300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2300_0: const #8s : i
        let s_2300_0: i128 = 8;
        // D s_2300_1: read-var u#31514:u32
        let s_2300_1: u32 = fn_state.u_31514;
        // D s_2300_2: cast zx s_2300_1 -> bv
        let s_2300_2: Bits = Bits::new(s_2300_1 as u128, 32u16);
        // C s_2300_3: const #1s : i64
        let s_2300_3: i64 = 1;
        // C s_2300_4: cast zx s_2300_3 -> i
        let s_2300_4: i128 = (i128::try_from(s_2300_3).unwrap());
        // C s_2300_5: const #3s : i
        let s_2300_5: i128 = 3;
        // C s_2300_6: add s_2300_5 s_2300_4
        let s_2300_6: i128 = (s_2300_5 + s_2300_4);
        // D s_2300_7: bit-extract s_2300_2 s_2300_0 s_2300_6
        let s_2300_7: Bits = (Bits::new(
            ((s_2300_2) >> (s_2300_0)).value(),
            u16::try_from(s_2300_6).unwrap(),
        ));
        // D s_2300_8: cast reint s_2300_7 -> u8
        let s_2300_8: u8 = (s_2300_7.value() as u8);
        // D s_2300_9: cast zx s_2300_8 -> bv
        let s_2300_9: Bits = Bits::new(s_2300_8 as u128, 4u16);
        // C s_2300_10: const #7u : u8
        let s_2300_10: u8 = 7;
        // C s_2300_11: cast zx s_2300_10 -> bv
        let s_2300_11: Bits = Bits::new(s_2300_10 as u128, 4u16);
        // D s_2300_12: cmp-eq s_2300_9 s_2300_11
        let s_2300_12: bool = ((s_2300_9) == (s_2300_11));
        // N s_2300_13: branch s_2300_12 b2303 b2301
        if s_2300_12 {
            return block_2303(state, tracer, fn_state);
        } else {
            return block_2301(state, tracer, fn_state);
        };
    }
    fn block_2301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2301_0: const #0u : u8
        let s_2301_0: bool = false;
        // D s_2301_1: write-var gs#401009 <= s_2301_0
        fn_state.gs_401009 = s_2301_0;
        // N s_2301_2: jump b2302
        return block_2302(state, tracer, fn_state);
    }
    fn block_2302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2302_0: read-var gs#401009:u8
        let s_2302_0: bool = fn_state.gs_401009;
        // D s_2302_1: write-var gs#401010 <= s_2302_0
        fn_state.gs_401010 = s_2302_0;
        // N s_2302_2: jump b891
        return block_891(state, tracer, fn_state);
    }
    fn block_2303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2303_0: const #6s : i
        let s_2303_0: i128 = 6;
        // D s_2303_1: read-var u#31514:u32
        let s_2303_1: u32 = fn_state.u_31514;
        // D s_2303_2: cast zx s_2303_1 -> bv
        let s_2303_2: Bits = Bits::new(s_2303_1 as u128, 32u16);
        // C s_2303_3: const #1s : i64
        let s_2303_3: i64 = 1;
        // C s_2303_4: cast zx s_2303_3 -> i
        let s_2303_4: i128 = (i128::try_from(s_2303_3).unwrap());
        // C s_2303_5: const #0s : i
        let s_2303_5: i128 = 0;
        // C s_2303_6: add s_2303_5 s_2303_4
        let s_2303_6: i128 = (s_2303_5 + s_2303_4);
        // D s_2303_7: bit-extract s_2303_2 s_2303_0 s_2303_6
        let s_2303_7: Bits = (Bits::new(
            ((s_2303_2) >> (s_2303_0)).value(),
            u16::try_from(s_2303_6).unwrap(),
        ));
        // D s_2303_8: cast reint s_2303_7 -> u8
        let s_2303_8: bool = ((s_2303_7.value()) != 0);
        // D s_2303_9: cast zx s_2303_8 -> bv
        let s_2303_9: Bits = Bits::new(s_2303_8 as u128, 1u16);
        // C s_2303_10: const #1u : u8
        let s_2303_10: bool = true;
        // C s_2303_11: cast zx s_2303_10 -> bv
        let s_2303_11: Bits = Bits::new(s_2303_10 as u128, 1u16);
        // D s_2303_12: cmp-eq s_2303_9 s_2303_11
        let s_2303_12: bool = ((s_2303_9) == (s_2303_11));
        // N s_2303_13: branch s_2303_12 b2306 b2304
        if s_2303_12 {
            return block_2306(state, tracer, fn_state);
        } else {
            return block_2304(state, tracer, fn_state);
        };
    }
    fn block_2304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2304_0: const #0u : u8
        let s_2304_0: bool = false;
        // D s_2304_1: write-var gs#401008 <= s_2304_0
        fn_state.gs_401008 = s_2304_0;
        // N s_2304_2: jump b2305
        return block_2305(state, tracer, fn_state);
    }
    fn block_2305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2305_0: read-var gs#401008:u8
        let s_2305_0: bool = fn_state.gs_401008;
        // D s_2305_1: write-var gs#401009 <= s_2305_0
        fn_state.gs_401009 = s_2305_0;
        // N s_2305_2: jump b2302
        return block_2302(state, tracer, fn_state);
    }
    fn block_2306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2306_0: const #4s : i
        let s_2306_0: i128 = 4;
        // D s_2306_1: read-var u#31514:u32
        let s_2306_1: u32 = fn_state.u_31514;
        // D s_2306_2: cast zx s_2306_1 -> bv
        let s_2306_2: Bits = Bits::new(s_2306_1 as u128, 32u16);
        // C s_2306_3: const #1s : i64
        let s_2306_3: i64 = 1;
        // C s_2306_4: cast zx s_2306_3 -> i
        let s_2306_4: i128 = (i128::try_from(s_2306_3).unwrap());
        // C s_2306_5: const #0s : i
        let s_2306_5: i128 = 0;
        // C s_2306_6: add s_2306_5 s_2306_4
        let s_2306_6: i128 = (s_2306_5 + s_2306_4);
        // D s_2306_7: bit-extract s_2306_2 s_2306_0 s_2306_6
        let s_2306_7: Bits = (Bits::new(
            ((s_2306_2) >> (s_2306_0)).value(),
            u16::try_from(s_2306_6).unwrap(),
        ));
        // D s_2306_8: cast reint s_2306_7 -> u8
        let s_2306_8: bool = ((s_2306_7.value()) != 0);
        // D s_2306_9: cast zx s_2306_8 -> bv
        let s_2306_9: Bits = Bits::new(s_2306_8 as u128, 1u16);
        // C s_2306_10: const #0u : u8
        let s_2306_10: bool = false;
        // C s_2306_11: cast zx s_2306_10 -> bv
        let s_2306_11: Bits = Bits::new(s_2306_10 as u128, 1u16);
        // D s_2306_12: cmp-eq s_2306_9 s_2306_11
        let s_2306_12: bool = ((s_2306_9) == (s_2306_11));
        // D s_2306_13: write-var gs#401008 <= s_2306_12
        fn_state.gs_401008 = s_2306_12;
        // N s_2306_14: jump b2305
        return block_2305(state, tracer, fn_state);
    }
    fn block_2307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2307_0: const #3608s : i
        let s_2307_0: i128 = 3608;
        // C s_2307_1: const #14696u : u32
        let s_2307_1: u32 = 14696;
        // D s_2307_2: read-reg s_2307_1:i
        let s_2307_2: i128 = {
            let value = state.read_register::<i128>(s_2307_1 as isize);
            tracer.read_register(s_2307_1 as isize, value);
            value
        };
        // D s_2307_3: cmp-lt s_2307_2 s_2307_0
        let s_2307_3: bool = ((s_2307_2) < (s_2307_0));
        // D s_2307_4: write-var gs#400980 <= s_2307_3
        fn_state.gs_400980 = s_2307_3;
        // N s_2307_5: jump b887
        return block_887(state, tracer, fn_state);
    }
    fn block_2308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2308_0: const #8s : i
        let s_2308_0: i128 = 8;
        // D s_2308_1: read-var u#31504:u32
        let s_2308_1: u32 = fn_state.u_31504;
        // D s_2308_2: cast zx s_2308_1 -> bv
        let s_2308_2: Bits = Bits::new(s_2308_1 as u128, 32u16);
        // C s_2308_3: const #1s : i64
        let s_2308_3: i64 = 1;
        // C s_2308_4: cast zx s_2308_3 -> i
        let s_2308_4: i128 = (i128::try_from(s_2308_3).unwrap());
        // C s_2308_5: const #3s : i
        let s_2308_5: i128 = 3;
        // C s_2308_6: add s_2308_5 s_2308_4
        let s_2308_6: i128 = (s_2308_5 + s_2308_4);
        // D s_2308_7: bit-extract s_2308_2 s_2308_0 s_2308_6
        let s_2308_7: Bits = (Bits::new(
            ((s_2308_2) >> (s_2308_0)).value(),
            u16::try_from(s_2308_6).unwrap(),
        ));
        // D s_2308_8: cast reint s_2308_7 -> u8
        let s_2308_8: u8 = (s_2308_7.value() as u8);
        // D s_2308_9: cast zx s_2308_8 -> bv
        let s_2308_9: Bits = Bits::new(s_2308_8 as u128, 4u16);
        // C s_2308_10: const #11u : u8
        let s_2308_10: u8 = 11;
        // C s_2308_11: cast zx s_2308_10 -> bv
        let s_2308_11: Bits = Bits::new(s_2308_10 as u128, 4u16);
        // D s_2308_12: cmp-eq s_2308_9 s_2308_11
        let s_2308_12: bool = ((s_2308_9) == (s_2308_11));
        // N s_2308_13: branch s_2308_12 b2311 b2309
        if s_2308_12 {
            return block_2311(state, tracer, fn_state);
        } else {
            return block_2309(state, tracer, fn_state);
        };
    }
    fn block_2309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2309_0: const #0u : u8
        let s_2309_0: bool = false;
        // D s_2309_1: write-var gs#400977 <= s_2309_0
        fn_state.gs_400977 = s_2309_0;
        // N s_2309_2: jump b2310
        return block_2310(state, tracer, fn_state);
    }
    fn block_2310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2310_0: read-var gs#400977:u8
        let s_2310_0: bool = fn_state.gs_400977;
        // D s_2310_1: write-var gs#400978 <= s_2310_0
        fn_state.gs_400978 = s_2310_0;
        // N s_2310_2: jump b885
        return block_885(state, tracer, fn_state);
    }
    fn block_2311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2311_0: const #6s : i
        let s_2311_0: i128 = 6;
        // D s_2311_1: read-var u#31504:u32
        let s_2311_1: u32 = fn_state.u_31504;
        // D s_2311_2: cast zx s_2311_1 -> bv
        let s_2311_2: Bits = Bits::new(s_2311_1 as u128, 32u16);
        // C s_2311_3: const #1s : i64
        let s_2311_3: i64 = 1;
        // C s_2311_4: cast zx s_2311_3 -> i
        let s_2311_4: i128 = (i128::try_from(s_2311_3).unwrap());
        // C s_2311_5: const #0s : i
        let s_2311_5: i128 = 0;
        // C s_2311_6: add s_2311_5 s_2311_4
        let s_2311_6: i128 = (s_2311_5 + s_2311_4);
        // D s_2311_7: bit-extract s_2311_2 s_2311_0 s_2311_6
        let s_2311_7: Bits = (Bits::new(
            ((s_2311_2) >> (s_2311_0)).value(),
            u16::try_from(s_2311_6).unwrap(),
        ));
        // D s_2311_8: cast reint s_2311_7 -> u8
        let s_2311_8: bool = ((s_2311_7.value()) != 0);
        // D s_2311_9: cast zx s_2311_8 -> bv
        let s_2311_9: Bits = Bits::new(s_2311_8 as u128, 1u16);
        // C s_2311_10: const #0u : u8
        let s_2311_10: bool = false;
        // C s_2311_11: cast zx s_2311_10 -> bv
        let s_2311_11: Bits = Bits::new(s_2311_10 as u128, 1u16);
        // D s_2311_12: cmp-eq s_2311_9 s_2311_11
        let s_2311_12: bool = ((s_2311_9) == (s_2311_11));
        // N s_2311_13: branch s_2311_12 b2314 b2312
        if s_2311_12 {
            return block_2314(state, tracer, fn_state);
        } else {
            return block_2312(state, tracer, fn_state);
        };
    }
    fn block_2312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2312_0: const #0u : u8
        let s_2312_0: bool = false;
        // D s_2312_1: write-var gs#400976 <= s_2312_0
        fn_state.gs_400976 = s_2312_0;
        // N s_2312_2: jump b2313
        return block_2313(state, tracer, fn_state);
    }
    fn block_2313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2313_0: read-var gs#400976:u8
        let s_2313_0: bool = fn_state.gs_400976;
        // D s_2313_1: write-var gs#400977 <= s_2313_0
        fn_state.gs_400977 = s_2313_0;
        // N s_2313_2: jump b2310
        return block_2310(state, tracer, fn_state);
    }
    fn block_2314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2314_0: const #4s : i
        let s_2314_0: i128 = 4;
        // D s_2314_1: read-var u#31504:u32
        let s_2314_1: u32 = fn_state.u_31504;
        // D s_2314_2: cast zx s_2314_1 -> bv
        let s_2314_2: Bits = Bits::new(s_2314_1 as u128, 32u16);
        // C s_2314_3: const #1s : i64
        let s_2314_3: i64 = 1;
        // C s_2314_4: cast zx s_2314_3 -> i
        let s_2314_4: i128 = (i128::try_from(s_2314_3).unwrap());
        // C s_2314_5: const #0s : i
        let s_2314_5: i128 = 0;
        // C s_2314_6: add s_2314_5 s_2314_4
        let s_2314_6: i128 = (s_2314_5 + s_2314_4);
        // D s_2314_7: bit-extract s_2314_2 s_2314_0 s_2314_6
        let s_2314_7: Bits = (Bits::new(
            ((s_2314_2) >> (s_2314_0)).value(),
            u16::try_from(s_2314_6).unwrap(),
        ));
        // D s_2314_8: cast reint s_2314_7 -> u8
        let s_2314_8: bool = ((s_2314_7.value()) != 0);
        // D s_2314_9: cast zx s_2314_8 -> bv
        let s_2314_9: Bits = Bits::new(s_2314_8 as u128, 1u16);
        // C s_2314_10: const #0u : u8
        let s_2314_10: bool = false;
        // C s_2314_11: cast zx s_2314_10 -> bv
        let s_2314_11: Bits = Bits::new(s_2314_10 as u128, 1u16);
        // D s_2314_12: cmp-eq s_2314_9 s_2314_11
        let s_2314_12: bool = ((s_2314_9) == (s_2314_11));
        // D s_2314_13: write-var gs#400976 <= s_2314_12
        fn_state.gs_400976 = s_2314_12;
        // N s_2314_14: jump b2313
        return block_2313(state, tracer, fn_state);
    }
    fn block_2315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2315_0: const #3605s : i
        let s_2315_0: i128 = 3605;
        // C s_2315_1: const #14696u : u32
        let s_2315_1: u32 = 14696;
        // D s_2315_2: read-reg s_2315_1:i
        let s_2315_2: i128 = {
            let value = state.read_register::<i128>(s_2315_1 as isize);
            tracer.read_register(s_2315_1 as isize, value);
            value
        };
        // D s_2315_3: cmp-lt s_2315_2 s_2315_0
        let s_2315_3: bool = ((s_2315_2) < (s_2315_0));
        // D s_2315_4: write-var gs#400948 <= s_2315_3
        fn_state.gs_400948 = s_2315_3;
        // N s_2315_5: jump b881
        return block_881(state, tracer, fn_state);
    }
    fn block_2316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2316_0: const #8s : i
        let s_2316_0: i128 = 8;
        // D s_2316_1: read-var u#31494:u32
        let s_2316_1: u32 = fn_state.u_31494;
        // D s_2316_2: cast zx s_2316_1 -> bv
        let s_2316_2: Bits = Bits::new(s_2316_1 as u128, 32u16);
        // C s_2316_3: const #1s : i64
        let s_2316_3: i64 = 1;
        // C s_2316_4: cast zx s_2316_3 -> i
        let s_2316_4: i128 = (i128::try_from(s_2316_3).unwrap());
        // C s_2316_5: const #3s : i
        let s_2316_5: i128 = 3;
        // C s_2316_6: add s_2316_5 s_2316_4
        let s_2316_6: i128 = (s_2316_5 + s_2316_4);
        // D s_2316_7: bit-extract s_2316_2 s_2316_0 s_2316_6
        let s_2316_7: Bits = (Bits::new(
            ((s_2316_2) >> (s_2316_0)).value(),
            u16::try_from(s_2316_6).unwrap(),
        ));
        // D s_2316_8: cast reint s_2316_7 -> u8
        let s_2316_8: u8 = (s_2316_7.value() as u8);
        // D s_2316_9: cast zx s_2316_8 -> bv
        let s_2316_9: Bits = Bits::new(s_2316_8 as u128, 4u16);
        // C s_2316_10: const #3u : u8
        let s_2316_10: u8 = 3;
        // C s_2316_11: cast zx s_2316_10 -> bv
        let s_2316_11: Bits = Bits::new(s_2316_10 as u128, 4u16);
        // D s_2316_12: cmp-eq s_2316_9 s_2316_11
        let s_2316_12: bool = ((s_2316_9) == (s_2316_11));
        // N s_2316_13: branch s_2316_12 b2319 b2317
        if s_2316_12 {
            return block_2319(state, tracer, fn_state);
        } else {
            return block_2317(state, tracer, fn_state);
        };
    }
    fn block_2317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2317_0: const #0u : u8
        let s_2317_0: bool = false;
        // D s_2317_1: write-var gs#400945 <= s_2317_0
        fn_state.gs_400945 = s_2317_0;
        // N s_2317_2: jump b2318
        return block_2318(state, tracer, fn_state);
    }
    fn block_2318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2318_0: read-var gs#400945:u8
        let s_2318_0: bool = fn_state.gs_400945;
        // D s_2318_1: write-var gs#400946 <= s_2318_0
        fn_state.gs_400946 = s_2318_0;
        // N s_2318_2: jump b879
        return block_879(state, tracer, fn_state);
    }
    fn block_2319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2319_0: const #6s : i
        let s_2319_0: i128 = 6;
        // D s_2319_1: read-var u#31494:u32
        let s_2319_1: u32 = fn_state.u_31494;
        // D s_2319_2: cast zx s_2319_1 -> bv
        let s_2319_2: Bits = Bits::new(s_2319_1 as u128, 32u16);
        // C s_2319_3: const #1s : i64
        let s_2319_3: i64 = 1;
        // C s_2319_4: cast zx s_2319_3 -> i
        let s_2319_4: i128 = (i128::try_from(s_2319_3).unwrap());
        // C s_2319_5: const #0s : i
        let s_2319_5: i128 = 0;
        // C s_2319_6: add s_2319_5 s_2319_4
        let s_2319_6: i128 = (s_2319_5 + s_2319_4);
        // D s_2319_7: bit-extract s_2319_2 s_2319_0 s_2319_6
        let s_2319_7: Bits = (Bits::new(
            ((s_2319_2) >> (s_2319_0)).value(),
            u16::try_from(s_2319_6).unwrap(),
        ));
        // D s_2319_8: cast reint s_2319_7 -> u8
        let s_2319_8: bool = ((s_2319_7.value()) != 0);
        // D s_2319_9: cast zx s_2319_8 -> bv
        let s_2319_9: Bits = Bits::new(s_2319_8 as u128, 1u16);
        // C s_2319_10: const #1u : u8
        let s_2319_10: bool = true;
        // C s_2319_11: cast zx s_2319_10 -> bv
        let s_2319_11: Bits = Bits::new(s_2319_10 as u128, 1u16);
        // D s_2319_12: cmp-eq s_2319_9 s_2319_11
        let s_2319_12: bool = ((s_2319_9) == (s_2319_11));
        // N s_2319_13: branch s_2319_12 b2322 b2320
        if s_2319_12 {
            return block_2322(state, tracer, fn_state);
        } else {
            return block_2320(state, tracer, fn_state);
        };
    }
    fn block_2320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2320_0: const #0u : u8
        let s_2320_0: bool = false;
        // D s_2320_1: write-var gs#400944 <= s_2320_0
        fn_state.gs_400944 = s_2320_0;
        // N s_2320_2: jump b2321
        return block_2321(state, tracer, fn_state);
    }
    fn block_2321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2321_0: read-var gs#400944:u8
        let s_2321_0: bool = fn_state.gs_400944;
        // D s_2321_1: write-var gs#400945 <= s_2321_0
        fn_state.gs_400945 = s_2321_0;
        // N s_2321_2: jump b2318
        return block_2318(state, tracer, fn_state);
    }
    fn block_2322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2322_0: const #4s : i
        let s_2322_0: i128 = 4;
        // D s_2322_1: read-var u#31494:u32
        let s_2322_1: u32 = fn_state.u_31494;
        // D s_2322_2: cast zx s_2322_1 -> bv
        let s_2322_2: Bits = Bits::new(s_2322_1 as u128, 32u16);
        // C s_2322_3: const #1s : i64
        let s_2322_3: i64 = 1;
        // C s_2322_4: cast zx s_2322_3 -> i
        let s_2322_4: i128 = (i128::try_from(s_2322_3).unwrap());
        // C s_2322_5: const #0s : i
        let s_2322_5: i128 = 0;
        // C s_2322_6: add s_2322_5 s_2322_4
        let s_2322_6: i128 = (s_2322_5 + s_2322_4);
        // D s_2322_7: bit-extract s_2322_2 s_2322_0 s_2322_6
        let s_2322_7: Bits = (Bits::new(
            ((s_2322_2) >> (s_2322_0)).value(),
            u16::try_from(s_2322_6).unwrap(),
        ));
        // D s_2322_8: cast reint s_2322_7 -> u8
        let s_2322_8: bool = ((s_2322_7.value()) != 0);
        // D s_2322_9: cast zx s_2322_8 -> bv
        let s_2322_9: Bits = Bits::new(s_2322_8 as u128, 1u16);
        // C s_2322_10: const #0u : u8
        let s_2322_10: bool = false;
        // C s_2322_11: cast zx s_2322_10 -> bv
        let s_2322_11: Bits = Bits::new(s_2322_10 as u128, 1u16);
        // D s_2322_12: cmp-eq s_2322_9 s_2322_11
        let s_2322_12: bool = ((s_2322_9) == (s_2322_11));
        // D s_2322_13: write-var gs#400944 <= s_2322_12
        fn_state.gs_400944 = s_2322_12;
        // N s_2322_14: jump b2321
        return block_2321(state, tracer, fn_state);
    }
    fn block_2323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2323_0: const #3604s : i
        let s_2323_0: i128 = 3604;
        // C s_2323_1: const #14696u : u32
        let s_2323_1: u32 = 14696;
        // D s_2323_2: read-reg s_2323_1:i
        let s_2323_2: i128 = {
            let value = state.read_register::<i128>(s_2323_1 as isize);
            tracer.read_register(s_2323_1 as isize, value);
            value
        };
        // D s_2323_3: cmp-lt s_2323_2 s_2323_0
        let s_2323_3: bool = ((s_2323_2) < (s_2323_0));
        // D s_2323_4: write-var gs#400916 <= s_2323_3
        fn_state.gs_400916 = s_2323_3;
        // N s_2323_5: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_2324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2324_0: const #8s : i
        let s_2324_0: i128 = 8;
        // D s_2324_1: read-var u#31484:u32
        let s_2324_1: u32 = fn_state.u_31484;
        // D s_2324_2: cast zx s_2324_1 -> bv
        let s_2324_2: Bits = Bits::new(s_2324_1 as u128, 32u16);
        // C s_2324_3: const #1s : i64
        let s_2324_3: i64 = 1;
        // C s_2324_4: cast zx s_2324_3 -> i
        let s_2324_4: i128 = (i128::try_from(s_2324_3).unwrap());
        // C s_2324_5: const #3s : i
        let s_2324_5: i128 = 3;
        // C s_2324_6: add s_2324_5 s_2324_4
        let s_2324_6: i128 = (s_2324_5 + s_2324_4);
        // D s_2324_7: bit-extract s_2324_2 s_2324_0 s_2324_6
        let s_2324_7: Bits = (Bits::new(
            ((s_2324_2) >> (s_2324_0)).value(),
            u16::try_from(s_2324_6).unwrap(),
        ));
        // D s_2324_8: cast reint s_2324_7 -> u8
        let s_2324_8: u8 = (s_2324_7.value() as u8);
        // D s_2324_9: cast zx s_2324_8 -> bv
        let s_2324_9: Bits = Bits::new(s_2324_8 as u128, 4u16);
        // C s_2324_10: const #9u : u8
        let s_2324_10: u8 = 9;
        // C s_2324_11: cast zx s_2324_10 -> bv
        let s_2324_11: Bits = Bits::new(s_2324_10 as u128, 4u16);
        // D s_2324_12: cmp-eq s_2324_9 s_2324_11
        let s_2324_12: bool = ((s_2324_9) == (s_2324_11));
        // N s_2324_13: branch s_2324_12 b2327 b2325
        if s_2324_12 {
            return block_2327(state, tracer, fn_state);
        } else {
            return block_2325(state, tracer, fn_state);
        };
    }
    fn block_2325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2325_0: const #0u : u8
        let s_2325_0: bool = false;
        // D s_2325_1: write-var gs#400913 <= s_2325_0
        fn_state.gs_400913 = s_2325_0;
        // N s_2325_2: jump b2326
        return block_2326(state, tracer, fn_state);
    }
    fn block_2326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2326_0: read-var gs#400913:u8
        let s_2326_0: bool = fn_state.gs_400913;
        // D s_2326_1: write-var gs#400914 <= s_2326_0
        fn_state.gs_400914 = s_2326_0;
        // N s_2326_2: jump b873
        return block_873(state, tracer, fn_state);
    }
    fn block_2327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2327_0: const #6s : i
        let s_2327_0: i128 = 6;
        // D s_2327_1: read-var u#31484:u32
        let s_2327_1: u32 = fn_state.u_31484;
        // D s_2327_2: cast zx s_2327_1 -> bv
        let s_2327_2: Bits = Bits::new(s_2327_1 as u128, 32u16);
        // C s_2327_3: const #1s : i64
        let s_2327_3: i64 = 1;
        // C s_2327_4: cast zx s_2327_3 -> i
        let s_2327_4: i128 = (i128::try_from(s_2327_3).unwrap());
        // C s_2327_5: const #0s : i
        let s_2327_5: i128 = 0;
        // C s_2327_6: add s_2327_5 s_2327_4
        let s_2327_6: i128 = (s_2327_5 + s_2327_4);
        // D s_2327_7: bit-extract s_2327_2 s_2327_0 s_2327_6
        let s_2327_7: Bits = (Bits::new(
            ((s_2327_2) >> (s_2327_0)).value(),
            u16::try_from(s_2327_6).unwrap(),
        ));
        // D s_2327_8: cast reint s_2327_7 -> u8
        let s_2327_8: bool = ((s_2327_7.value()) != 0);
        // D s_2327_9: cast zx s_2327_8 -> bv
        let s_2327_9: Bits = Bits::new(s_2327_8 as u128, 1u16);
        // C s_2327_10: const #0u : u8
        let s_2327_10: bool = false;
        // C s_2327_11: cast zx s_2327_10 -> bv
        let s_2327_11: Bits = Bits::new(s_2327_10 as u128, 1u16);
        // D s_2327_12: cmp-eq s_2327_9 s_2327_11
        let s_2327_12: bool = ((s_2327_9) == (s_2327_11));
        // N s_2327_13: branch s_2327_12 b2330 b2328
        if s_2327_12 {
            return block_2330(state, tracer, fn_state);
        } else {
            return block_2328(state, tracer, fn_state);
        };
    }
    fn block_2328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2328_0: const #0u : u8
        let s_2328_0: bool = false;
        // D s_2328_1: write-var gs#400912 <= s_2328_0
        fn_state.gs_400912 = s_2328_0;
        // N s_2328_2: jump b2329
        return block_2329(state, tracer, fn_state);
    }
    fn block_2329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2329_0: read-var gs#400912:u8
        let s_2329_0: bool = fn_state.gs_400912;
        // D s_2329_1: write-var gs#400913 <= s_2329_0
        fn_state.gs_400913 = s_2329_0;
        // N s_2329_2: jump b2326
        return block_2326(state, tracer, fn_state);
    }
    fn block_2330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2330_0: const #4s : i
        let s_2330_0: i128 = 4;
        // D s_2330_1: read-var u#31484:u32
        let s_2330_1: u32 = fn_state.u_31484;
        // D s_2330_2: cast zx s_2330_1 -> bv
        let s_2330_2: Bits = Bits::new(s_2330_1 as u128, 32u16);
        // C s_2330_3: const #1s : i64
        let s_2330_3: i64 = 1;
        // C s_2330_4: cast zx s_2330_3 -> i
        let s_2330_4: i128 = (i128::try_from(s_2330_3).unwrap());
        // C s_2330_5: const #0s : i
        let s_2330_5: i128 = 0;
        // C s_2330_6: add s_2330_5 s_2330_4
        let s_2330_6: i128 = (s_2330_5 + s_2330_4);
        // D s_2330_7: bit-extract s_2330_2 s_2330_0 s_2330_6
        let s_2330_7: Bits = (Bits::new(
            ((s_2330_2) >> (s_2330_0)).value(),
            u16::try_from(s_2330_6).unwrap(),
        ));
        // D s_2330_8: cast reint s_2330_7 -> u8
        let s_2330_8: bool = ((s_2330_7.value()) != 0);
        // D s_2330_9: cast zx s_2330_8 -> bv
        let s_2330_9: Bits = Bits::new(s_2330_8 as u128, 1u16);
        // C s_2330_10: const #0u : u8
        let s_2330_10: bool = false;
        // C s_2330_11: cast zx s_2330_10 -> bv
        let s_2330_11: Bits = Bits::new(s_2330_10 as u128, 1u16);
        // D s_2330_12: cmp-eq s_2330_9 s_2330_11
        let s_2330_12: bool = ((s_2330_9) == (s_2330_11));
        // D s_2330_13: write-var gs#400912 <= s_2330_12
        fn_state.gs_400912 = s_2330_12;
        // N s_2330_14: jump b2329
        return block_2329(state, tracer, fn_state);
    }
    fn block_2331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2331_0: const #3602s : i
        let s_2331_0: i128 = 3602;
        // C s_2331_1: const #14696u : u32
        let s_2331_1: u32 = 14696;
        // D s_2331_2: read-reg s_2331_1:i
        let s_2331_2: i128 = {
            let value = state.read_register::<i128>(s_2331_1 as isize);
            tracer.read_register(s_2331_1 as isize, value);
            value
        };
        // D s_2331_3: cmp-lt s_2331_2 s_2331_0
        let s_2331_3: bool = ((s_2331_2) < (s_2331_0));
        // D s_2331_4: write-var gs#400882 <= s_2331_3
        fn_state.gs_400882 = s_2331_3;
        // N s_2331_5: jump b869
        return block_869(state, tracer, fn_state);
    }
    fn block_2332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2332_0: const #23s : i
        let s_2332_0: i128 = 23;
        // D s_2332_1: read-var u#31473:u32
        let s_2332_1: u32 = fn_state.u_31473;
        // D s_2332_2: cast zx s_2332_1 -> bv
        let s_2332_2: Bits = Bits::new(s_2332_1 as u128, 32u16);
        // C s_2332_3: const #1s : i64
        let s_2332_3: i64 = 1;
        // C s_2332_4: cast zx s_2332_3 -> i
        let s_2332_4: i128 = (i128::try_from(s_2332_3).unwrap());
        // C s_2332_5: const #0s : i
        let s_2332_5: i128 = 0;
        // C s_2332_6: add s_2332_5 s_2332_4
        let s_2332_6: i128 = (s_2332_5 + s_2332_4);
        // D s_2332_7: bit-extract s_2332_2 s_2332_0 s_2332_6
        let s_2332_7: Bits = (Bits::new(
            ((s_2332_2) >> (s_2332_0)).value(),
            u16::try_from(s_2332_6).unwrap(),
        ));
        // D s_2332_8: cast reint s_2332_7 -> u8
        let s_2332_8: bool = ((s_2332_7.value()) != 0);
        // D s_2332_9: cast zx s_2332_8 -> bv
        let s_2332_9: Bits = Bits::new(s_2332_8 as u128, 1u16);
        // C s_2332_10: const #0u : u8
        let s_2332_10: bool = false;
        // C s_2332_11: cast zx s_2332_10 -> bv
        let s_2332_11: Bits = Bits::new(s_2332_10 as u128, 1u16);
        // D s_2332_12: cmp-eq s_2332_9 s_2332_11
        let s_2332_12: bool = ((s_2332_9) == (s_2332_11));
        // N s_2332_13: branch s_2332_12 b2335 b2333
        if s_2332_12 {
            return block_2335(state, tracer, fn_state);
        } else {
            return block_2333(state, tracer, fn_state);
        };
    }
    fn block_2333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2333_0: const #0u : u8
        let s_2333_0: bool = false;
        // D s_2333_1: write-var gs#400879 <= s_2333_0
        fn_state.gs_400879 = s_2333_0;
        // N s_2333_2: jump b2334
        return block_2334(state, tracer, fn_state);
    }
    fn block_2334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2334_0: read-var gs#400879:u8
        let s_2334_0: bool = fn_state.gs_400879;
        // D s_2334_1: write-var gs#400880 <= s_2334_0
        fn_state.gs_400880 = s_2334_0;
        // N s_2334_2: jump b867
        return block_867(state, tracer, fn_state);
    }
    fn block_2335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2335_0: const #8s : i
        let s_2335_0: i128 = 8;
        // D s_2335_1: read-var u#31473:u32
        let s_2335_1: u32 = fn_state.u_31473;
        // D s_2335_2: cast zx s_2335_1 -> bv
        let s_2335_2: Bits = Bits::new(s_2335_1 as u128, 32u16);
        // C s_2335_3: const #1s : i64
        let s_2335_3: i64 = 1;
        // C s_2335_4: cast zx s_2335_3 -> i
        let s_2335_4: i128 = (i128::try_from(s_2335_3).unwrap());
        // C s_2335_5: const #3s : i
        let s_2335_5: i128 = 3;
        // C s_2335_6: add s_2335_5 s_2335_4
        let s_2335_6: i128 = (s_2335_5 + s_2335_4);
        // D s_2335_7: bit-extract s_2335_2 s_2335_0 s_2335_6
        let s_2335_7: Bits = (Bits::new(
            ((s_2335_2) >> (s_2335_0)).value(),
            u16::try_from(s_2335_6).unwrap(),
        ));
        // D s_2335_8: cast reint s_2335_7 -> u8
        let s_2335_8: u8 = (s_2335_7.value() as u8);
        // D s_2335_9: cast zx s_2335_8 -> bv
        let s_2335_9: Bits = Bits::new(s_2335_8 as u128, 4u16);
        // C s_2335_10: const #0u : u8
        let s_2335_10: u8 = 0;
        // C s_2335_11: cast zx s_2335_10 -> bv
        let s_2335_11: Bits = Bits::new(s_2335_10 as u128, 4u16);
        // D s_2335_12: cmp-eq s_2335_9 s_2335_11
        let s_2335_12: bool = ((s_2335_9) == (s_2335_11));
        // N s_2335_13: branch s_2335_12 b2338 b2336
        if s_2335_12 {
            return block_2338(state, tracer, fn_state);
        } else {
            return block_2336(state, tracer, fn_state);
        };
    }
    fn block_2336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2336_0: const #0u : u8
        let s_2336_0: bool = false;
        // D s_2336_1: write-var gs#400878 <= s_2336_0
        fn_state.gs_400878 = s_2336_0;
        // N s_2336_2: jump b2337
        return block_2337(state, tracer, fn_state);
    }
    fn block_2337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2337_0: read-var gs#400878:u8
        let s_2337_0: bool = fn_state.gs_400878;
        // D s_2337_1: write-var gs#400879 <= s_2337_0
        fn_state.gs_400879 = s_2337_0;
        // N s_2337_2: jump b2334
        return block_2334(state, tracer, fn_state);
    }
    fn block_2338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2338_0: const #4s : i
        let s_2338_0: i128 = 4;
        // D s_2338_1: read-var u#31473:u32
        let s_2338_1: u32 = fn_state.u_31473;
        // D s_2338_2: cast zx s_2338_1 -> bv
        let s_2338_2: Bits = Bits::new(s_2338_1 as u128, 32u16);
        // C s_2338_3: const #1s : i64
        let s_2338_3: i64 = 1;
        // C s_2338_4: cast zx s_2338_3 -> i
        let s_2338_4: i128 = (i128::try_from(s_2338_3).unwrap());
        // C s_2338_5: const #0s : i
        let s_2338_5: i128 = 0;
        // C s_2338_6: add s_2338_5 s_2338_4
        let s_2338_6: i128 = (s_2338_5 + s_2338_4);
        // D s_2338_7: bit-extract s_2338_2 s_2338_0 s_2338_6
        let s_2338_7: Bits = (Bits::new(
            ((s_2338_2) >> (s_2338_0)).value(),
            u16::try_from(s_2338_6).unwrap(),
        ));
        // D s_2338_8: cast reint s_2338_7 -> u8
        let s_2338_8: bool = ((s_2338_7.value()) != 0);
        // D s_2338_9: cast zx s_2338_8 -> bv
        let s_2338_9: Bits = Bits::new(s_2338_8 as u128, 1u16);
        // C s_2338_10: const #1u : u8
        let s_2338_10: bool = true;
        // C s_2338_11: cast zx s_2338_10 -> bv
        let s_2338_11: Bits = Bits::new(s_2338_10 as u128, 1u16);
        // D s_2338_12: cmp-eq s_2338_9 s_2338_11
        let s_2338_12: bool = ((s_2338_9) == (s_2338_11));
        // D s_2338_13: write-var gs#400878 <= s_2338_12
        fn_state.gs_400878 = s_2338_12;
        // N s_2338_14: jump b2337
        return block_2337(state, tracer, fn_state);
    }
    fn block_2339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2339_0: const #3600s : i
        let s_2339_0: i128 = 3600;
        // C s_2339_1: const #14696u : u32
        let s_2339_1: u32 = 14696;
        // D s_2339_2: read-reg s_2339_1:i
        let s_2339_2: i128 = {
            let value = state.read_register::<i128>(s_2339_1 as isize);
            tracer.read_register(s_2339_1 as isize, value);
            value
        };
        // D s_2339_3: cmp-lt s_2339_2 s_2339_0
        let s_2339_3: bool = ((s_2339_2) < (s_2339_0));
        // D s_2339_4: write-var gs#400854 <= s_2339_3
        fn_state.gs_400854 = s_2339_3;
        // N s_2339_5: jump b863
        return block_863(state, tracer, fn_state);
    }
    fn block_2340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2340_0: const #20s : i
        let s_2340_0: i128 = 20;
        // D s_2340_1: read-var u#31465:u32
        let s_2340_1: u32 = fn_state.u_31465;
        // D s_2340_2: cast zx s_2340_1 -> bv
        let s_2340_2: Bits = Bits::new(s_2340_1 as u128, 32u16);
        // C s_2340_3: const #1s : i64
        let s_2340_3: i64 = 1;
        // C s_2340_4: cast zx s_2340_3 -> i
        let s_2340_4: i128 = (i128::try_from(s_2340_3).unwrap());
        // C s_2340_5: const #1s : i
        let s_2340_5: i128 = 1;
        // C s_2340_6: add s_2340_5 s_2340_4
        let s_2340_6: i128 = (s_2340_5 + s_2340_4);
        // D s_2340_7: bit-extract s_2340_2 s_2340_0 s_2340_6
        let s_2340_7: Bits = (Bits::new(
            ((s_2340_2) >> (s_2340_0)).value(),
            u16::try_from(s_2340_6).unwrap(),
        ));
        // D s_2340_8: cast reint s_2340_7 -> u8
        let s_2340_8: u8 = (s_2340_7.value() as u8);
        // D s_2340_9: cast zx s_2340_8 -> bv
        let s_2340_9: Bits = Bits::new(s_2340_8 as u128, 2u16);
        // C s_2340_10: const #3u : u8
        let s_2340_10: u8 = 3;
        // C s_2340_11: cast zx s_2340_10 -> bv
        let s_2340_11: Bits = Bits::new(s_2340_10 as u128, 2u16);
        // D s_2340_12: cmp-eq s_2340_9 s_2340_11
        let s_2340_12: bool = ((s_2340_9) == (s_2340_11));
        // N s_2340_13: branch s_2340_12 b2343 b2341
        if s_2340_12 {
            return block_2343(state, tracer, fn_state);
        } else {
            return block_2341(state, tracer, fn_state);
        };
    }
    fn block_2341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2341_0: const #0u : u8
        let s_2341_0: bool = false;
        // D s_2341_1: write-var gs#400851 <= s_2341_0
        fn_state.gs_400851 = s_2341_0;
        // N s_2341_2: jump b2342
        return block_2342(state, tracer, fn_state);
    }
    fn block_2342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2342_0: read-var gs#400851:u8
        let s_2342_0: bool = fn_state.gs_400851;
        // D s_2342_1: write-var gs#400852 <= s_2342_0
        fn_state.gs_400852 = s_2342_0;
        // N s_2342_2: jump b861
        return block_861(state, tracer, fn_state);
    }
    fn block_2343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2343_0: const #16s : i
        let s_2343_0: i128 = 16;
        // D s_2343_1: read-var u#31465:u32
        let s_2343_1: u32 = fn_state.u_31465;
        // D s_2343_2: cast zx s_2343_1 -> bv
        let s_2343_2: Bits = Bits::new(s_2343_1 as u128, 32u16);
        // C s_2343_3: const #1s : i64
        let s_2343_3: i64 = 1;
        // C s_2343_4: cast zx s_2343_3 -> i
        let s_2343_4: i128 = (i128::try_from(s_2343_3).unwrap());
        // C s_2343_5: const #1s : i
        let s_2343_5: i128 = 1;
        // C s_2343_6: add s_2343_5 s_2343_4
        let s_2343_6: i128 = (s_2343_5 + s_2343_4);
        // D s_2343_7: bit-extract s_2343_2 s_2343_0 s_2343_6
        let s_2343_7: Bits = (Bits::new(
            ((s_2343_2) >> (s_2343_0)).value(),
            u16::try_from(s_2343_6).unwrap(),
        ));
        // D s_2343_8: cast reint s_2343_7 -> u8
        let s_2343_8: u8 = (s_2343_7.value() as u8);
        // D s_2343_9: cast zx s_2343_8 -> bv
        let s_2343_9: Bits = Bits::new(s_2343_8 as u128, 2u16);
        // C s_2343_10: const #0u : u8
        let s_2343_10: u8 = 0;
        // C s_2343_11: cast zx s_2343_10 -> bv
        let s_2343_11: Bits = Bits::new(s_2343_10 as u128, 2u16);
        // D s_2343_12: cmp-eq s_2343_9 s_2343_11
        let s_2343_12: bool = ((s_2343_9) == (s_2343_11));
        // N s_2343_13: branch s_2343_12 b2346 b2344
        if s_2343_12 {
            return block_2346(state, tracer, fn_state);
        } else {
            return block_2344(state, tracer, fn_state);
        };
    }
    fn block_2344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2344_0: const #0u : u8
        let s_2344_0: bool = false;
        // D s_2344_1: write-var gs#400850 <= s_2344_0
        fn_state.gs_400850 = s_2344_0;
        // N s_2344_2: jump b2345
        return block_2345(state, tracer, fn_state);
    }
    fn block_2345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2345_0: read-var gs#400850:u8
        let s_2345_0: bool = fn_state.gs_400850;
        // D s_2345_1: write-var gs#400851 <= s_2345_0
        fn_state.gs_400851 = s_2345_0;
        // N s_2345_2: jump b2342
        return block_2342(state, tracer, fn_state);
    }
    fn block_2346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2346_0: const #7s : i
        let s_2346_0: i128 = 7;
        // D s_2346_1: read-var u#31465:u32
        let s_2346_1: u32 = fn_state.u_31465;
        // D s_2346_2: cast zx s_2346_1 -> bv
        let s_2346_2: Bits = Bits::new(s_2346_1 as u128, 32u16);
        // C s_2346_3: const #1s : i64
        let s_2346_3: i64 = 1;
        // C s_2346_4: cast zx s_2346_3 -> i
        let s_2346_4: i128 = (i128::try_from(s_2346_3).unwrap());
        // C s_2346_5: const #4s : i
        let s_2346_5: i128 = 4;
        // C s_2346_6: add s_2346_5 s_2346_4
        let s_2346_6: i128 = (s_2346_5 + s_2346_4);
        // D s_2346_7: bit-extract s_2346_2 s_2346_0 s_2346_6
        let s_2346_7: Bits = (Bits::new(
            ((s_2346_2) >> (s_2346_0)).value(),
            u16::try_from(s_2346_6).unwrap(),
        ));
        // D s_2346_8: cast reint s_2346_7 -> u8
        let s_2346_8: u8 = (s_2346_7.value() as u8);
        // D s_2346_9: cast zx s_2346_8 -> bv
        let s_2346_9: Bits = Bits::new(s_2346_8 as u128, 5u16);
        // C s_2346_10: const #14u : u8
        let s_2346_10: u8 = 14;
        // C s_2346_11: cast zx s_2346_10 -> bv
        let s_2346_11: Bits = Bits::new(s_2346_10 as u128, 5u16);
        // D s_2346_12: cmp-eq s_2346_9 s_2346_11
        let s_2346_12: bool = ((s_2346_9) == (s_2346_11));
        // N s_2346_13: branch s_2346_12 b2349 b2347
        if s_2346_12 {
            return block_2349(state, tracer, fn_state);
        } else {
            return block_2347(state, tracer, fn_state);
        };
    }
    fn block_2347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2347_0: const #0u : u8
        let s_2347_0: bool = false;
        // D s_2347_1: write-var gs#400849 <= s_2347_0
        fn_state.gs_400849 = s_2347_0;
        // N s_2347_2: jump b2348
        return block_2348(state, tracer, fn_state);
    }
    fn block_2348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2348_0: read-var gs#400849:u8
        let s_2348_0: bool = fn_state.gs_400849;
        // D s_2348_1: write-var gs#400850 <= s_2348_0
        fn_state.gs_400850 = s_2348_0;
        // N s_2348_2: jump b2345
        return block_2345(state, tracer, fn_state);
    }
    fn block_2349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2349_0: const #4s : i
        let s_2349_0: i128 = 4;
        // D s_2349_1: read-var u#31465:u32
        let s_2349_1: u32 = fn_state.u_31465;
        // D s_2349_2: cast zx s_2349_1 -> bv
        let s_2349_2: Bits = Bits::new(s_2349_1 as u128, 32u16);
        // C s_2349_3: const #1s : i64
        let s_2349_3: i64 = 1;
        // C s_2349_4: cast zx s_2349_3 -> i
        let s_2349_4: i128 = (i128::try_from(s_2349_3).unwrap());
        // C s_2349_5: const #0s : i
        let s_2349_5: i128 = 0;
        // C s_2349_6: add s_2349_5 s_2349_4
        let s_2349_6: i128 = (s_2349_5 + s_2349_4);
        // D s_2349_7: bit-extract s_2349_2 s_2349_0 s_2349_6
        let s_2349_7: Bits = (Bits::new(
            ((s_2349_2) >> (s_2349_0)).value(),
            u16::try_from(s_2349_6).unwrap(),
        ));
        // D s_2349_8: cast reint s_2349_7 -> u8
        let s_2349_8: bool = ((s_2349_7.value()) != 0);
        // D s_2349_9: cast zx s_2349_8 -> bv
        let s_2349_9: Bits = Bits::new(s_2349_8 as u128, 1u16);
        // C s_2349_10: const #0u : u8
        let s_2349_10: bool = false;
        // C s_2349_11: cast zx s_2349_10 -> bv
        let s_2349_11: Bits = Bits::new(s_2349_10 as u128, 1u16);
        // D s_2349_12: cmp-eq s_2349_9 s_2349_11
        let s_2349_12: bool = ((s_2349_9) == (s_2349_11));
        // D s_2349_13: write-var gs#400849 <= s_2349_12
        fn_state.gs_400849 = s_2349_12;
        // N s_2349_14: jump b2348
        return block_2348(state, tracer, fn_state);
    }
    fn block_2350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2350_0: const #3598s : i
        let s_2350_0: i128 = 3598;
        // C s_2350_1: const #14696u : u32
        let s_2350_1: u32 = 14696;
        // D s_2350_2: read-reg s_2350_1:i
        let s_2350_2: i128 = {
            let value = state.read_register::<i128>(s_2350_1 as isize);
            tracer.read_register(s_2350_1 as isize, value);
            value
        };
        // D s_2350_3: cmp-lt s_2350_2 s_2350_0
        let s_2350_3: bool = ((s_2350_2) < (s_2350_0));
        // D s_2350_4: write-var gs#400817 <= s_2350_3
        fn_state.gs_400817 = s_2350_3;
        // N s_2350_5: jump b857
        return block_857(state, tracer, fn_state);
    }
    fn block_2351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2351_0: const #23s : i
        let s_2351_0: i128 = 23;
        // D s_2351_1: read-var u#31454:u32
        let s_2351_1: u32 = fn_state.u_31454;
        // D s_2351_2: cast zx s_2351_1 -> bv
        let s_2351_2: Bits = Bits::new(s_2351_1 as u128, 32u16);
        // C s_2351_3: const #1s : i64
        let s_2351_3: i64 = 1;
        // C s_2351_4: cast zx s_2351_3 -> i
        let s_2351_4: i128 = (i128::try_from(s_2351_3).unwrap());
        // C s_2351_5: const #0s : i
        let s_2351_5: i128 = 0;
        // C s_2351_6: add s_2351_5 s_2351_4
        let s_2351_6: i128 = (s_2351_5 + s_2351_4);
        // D s_2351_7: bit-extract s_2351_2 s_2351_0 s_2351_6
        let s_2351_7: Bits = (Bits::new(
            ((s_2351_2) >> (s_2351_0)).value(),
            u16::try_from(s_2351_6).unwrap(),
        ));
        // D s_2351_8: cast reint s_2351_7 -> u8
        let s_2351_8: bool = ((s_2351_7.value()) != 0);
        // D s_2351_9: cast zx s_2351_8 -> bv
        let s_2351_9: Bits = Bits::new(s_2351_8 as u128, 1u16);
        // C s_2351_10: const #0u : u8
        let s_2351_10: bool = false;
        // C s_2351_11: cast zx s_2351_10 -> bv
        let s_2351_11: Bits = Bits::new(s_2351_10 as u128, 1u16);
        // D s_2351_12: cmp-eq s_2351_9 s_2351_11
        let s_2351_12: bool = ((s_2351_9) == (s_2351_11));
        // N s_2351_13: branch s_2351_12 b2354 b2352
        if s_2351_12 {
            return block_2354(state, tracer, fn_state);
        } else {
            return block_2352(state, tracer, fn_state);
        };
    }
    fn block_2352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2352_0: const #0u : u8
        let s_2352_0: bool = false;
        // D s_2352_1: write-var gs#400814 <= s_2352_0
        fn_state.gs_400814 = s_2352_0;
        // N s_2352_2: jump b2353
        return block_2353(state, tracer, fn_state);
    }
    fn block_2353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2353_0: read-var gs#400814:u8
        let s_2353_0: bool = fn_state.gs_400814;
        // D s_2353_1: write-var gs#400815 <= s_2353_0
        fn_state.gs_400815 = s_2353_0;
        // N s_2353_2: jump b855
        return block_855(state, tracer, fn_state);
    }
    fn block_2354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2354_0: const #8s : i
        let s_2354_0: i128 = 8;
        // D s_2354_1: read-var u#31454:u32
        let s_2354_1: u32 = fn_state.u_31454;
        // D s_2354_2: cast zx s_2354_1 -> bv
        let s_2354_2: Bits = Bits::new(s_2354_1 as u128, 32u16);
        // C s_2354_3: const #1s : i64
        let s_2354_3: i64 = 1;
        // C s_2354_4: cast zx s_2354_3 -> i
        let s_2354_4: i128 = (i128::try_from(s_2354_3).unwrap());
        // C s_2354_5: const #3s : i
        let s_2354_5: i128 = 3;
        // C s_2354_6: add s_2354_5 s_2354_4
        let s_2354_6: i128 = (s_2354_5 + s_2354_4);
        // D s_2354_7: bit-extract s_2354_2 s_2354_0 s_2354_6
        let s_2354_7: Bits = (Bits::new(
            ((s_2354_2) >> (s_2354_0)).value(),
            u16::try_from(s_2354_6).unwrap(),
        ));
        // D s_2354_8: cast reint s_2354_7 -> u8
        let s_2354_8: u8 = (s_2354_7.value() as u8);
        // D s_2354_9: cast zx s_2354_8 -> bv
        let s_2354_9: Bits = Bits::new(s_2354_8 as u128, 4u16);
        // C s_2354_10: const #10u : u8
        let s_2354_10: u8 = 10;
        // C s_2354_11: cast zx s_2354_10 -> bv
        let s_2354_11: Bits = Bits::new(s_2354_10 as u128, 4u16);
        // D s_2354_12: cmp-eq s_2354_9 s_2354_11
        let s_2354_12: bool = ((s_2354_9) == (s_2354_11));
        // N s_2354_13: branch s_2354_12 b2357 b2355
        if s_2354_12 {
            return block_2357(state, tracer, fn_state);
        } else {
            return block_2355(state, tracer, fn_state);
        };
    }
    fn block_2355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2355_0: const #0u : u8
        let s_2355_0: bool = false;
        // D s_2355_1: write-var gs#400813 <= s_2355_0
        fn_state.gs_400813 = s_2355_0;
        // N s_2355_2: jump b2356
        return block_2356(state, tracer, fn_state);
    }
    fn block_2356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2356_0: read-var gs#400813:u8
        let s_2356_0: bool = fn_state.gs_400813;
        // D s_2356_1: write-var gs#400814 <= s_2356_0
        fn_state.gs_400814 = s_2356_0;
        // N s_2356_2: jump b2353
        return block_2353(state, tracer, fn_state);
    }
    fn block_2357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2357_0: const #6s : i
        let s_2357_0: i128 = 6;
        // D s_2357_1: read-var u#31454:u32
        let s_2357_1: u32 = fn_state.u_31454;
        // D s_2357_2: cast zx s_2357_1 -> bv
        let s_2357_2: Bits = Bits::new(s_2357_1 as u128, 32u16);
        // C s_2357_3: const #1s : i64
        let s_2357_3: i64 = 1;
        // C s_2357_4: cast zx s_2357_3 -> i
        let s_2357_4: i128 = (i128::try_from(s_2357_3).unwrap());
        // C s_2357_5: const #0s : i
        let s_2357_5: i128 = 0;
        // C s_2357_6: add s_2357_5 s_2357_4
        let s_2357_6: i128 = (s_2357_5 + s_2357_4);
        // D s_2357_7: bit-extract s_2357_2 s_2357_0 s_2357_6
        let s_2357_7: Bits = (Bits::new(
            ((s_2357_2) >> (s_2357_0)).value(),
            u16::try_from(s_2357_6).unwrap(),
        ));
        // D s_2357_8: cast reint s_2357_7 -> u8
        let s_2357_8: bool = ((s_2357_7.value()) != 0);
        // D s_2357_9: cast zx s_2357_8 -> bv
        let s_2357_9: Bits = Bits::new(s_2357_8 as u128, 1u16);
        // C s_2357_10: const #0u : u8
        let s_2357_10: bool = false;
        // C s_2357_11: cast zx s_2357_10 -> bv
        let s_2357_11: Bits = Bits::new(s_2357_10 as u128, 1u16);
        // D s_2357_12: cmp-eq s_2357_9 s_2357_11
        let s_2357_12: bool = ((s_2357_9) == (s_2357_11));
        // D s_2357_13: write-var gs#400813 <= s_2357_12
        fn_state.gs_400813 = s_2357_12;
        // N s_2357_14: jump b2356
        return block_2356(state, tracer, fn_state);
    }
    fn block_2358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2358_0: const #3596s : i
        let s_2358_0: i128 = 3596;
        // C s_2358_1: const #14696u : u32
        let s_2358_1: u32 = 14696;
        // D s_2358_2: read-reg s_2358_1:i
        let s_2358_2: i128 = {
            let value = state.read_register::<i128>(s_2358_1 as isize);
            tracer.read_register(s_2358_1 as isize, value);
            value
        };
        // D s_2358_3: cmp-lt s_2358_2 s_2358_0
        let s_2358_3: bool = ((s_2358_2) < (s_2358_0));
        // D s_2358_4: write-var gs#400785 <= s_2358_3
        fn_state.gs_400785 = s_2358_3;
        // N s_2358_5: jump b851
        return block_851(state, tracer, fn_state);
    }
    fn block_2359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2359_0: const #8s : i
        let s_2359_0: i128 = 8;
        // D s_2359_1: read-var u#31444:u32
        let s_2359_1: u32 = fn_state.u_31444;
        // D s_2359_2: cast zx s_2359_1 -> bv
        let s_2359_2: Bits = Bits::new(s_2359_1 as u128, 32u16);
        // C s_2359_3: const #1s : i64
        let s_2359_3: i64 = 1;
        // C s_2359_4: cast zx s_2359_3 -> i
        let s_2359_4: i128 = (i128::try_from(s_2359_3).unwrap());
        // C s_2359_5: const #3s : i
        let s_2359_5: i128 = 3;
        // C s_2359_6: add s_2359_5 s_2359_4
        let s_2359_6: i128 = (s_2359_5 + s_2359_4);
        // D s_2359_7: bit-extract s_2359_2 s_2359_0 s_2359_6
        let s_2359_7: Bits = (Bits::new(
            ((s_2359_2) >> (s_2359_0)).value(),
            u16::try_from(s_2359_6).unwrap(),
        ));
        // D s_2359_8: cast reint s_2359_7 -> u8
        let s_2359_8: u8 = (s_2359_7.value() as u8);
        // D s_2359_9: cast zx s_2359_8 -> bv
        let s_2359_9: Bits = Bits::new(s_2359_8 as u128, 4u16);
        // C s_2359_10: const #15u : u8
        let s_2359_10: u8 = 15;
        // C s_2359_11: cast zx s_2359_10 -> bv
        let s_2359_11: Bits = Bits::new(s_2359_10 as u128, 4u16);
        // D s_2359_12: cmp-eq s_2359_9 s_2359_11
        let s_2359_12: bool = ((s_2359_9) == (s_2359_11));
        // N s_2359_13: branch s_2359_12 b2362 b2360
        if s_2359_12 {
            return block_2362(state, tracer, fn_state);
        } else {
            return block_2360(state, tracer, fn_state);
        };
    }
    fn block_2360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2360_0: const #0u : u8
        let s_2360_0: bool = false;
        // D s_2360_1: write-var gs#400782 <= s_2360_0
        fn_state.gs_400782 = s_2360_0;
        // N s_2360_2: jump b2361
        return block_2361(state, tracer, fn_state);
    }
    fn block_2361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2361_0: read-var gs#400782:u8
        let s_2361_0: bool = fn_state.gs_400782;
        // D s_2361_1: write-var gs#400783 <= s_2361_0
        fn_state.gs_400783 = s_2361_0;
        // N s_2361_2: jump b849
        return block_849(state, tracer, fn_state);
    }
    fn block_2362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2362_0: const #6s : i
        let s_2362_0: i128 = 6;
        // D s_2362_1: read-var u#31444:u32
        let s_2362_1: u32 = fn_state.u_31444;
        // D s_2362_2: cast zx s_2362_1 -> bv
        let s_2362_2: Bits = Bits::new(s_2362_1 as u128, 32u16);
        // C s_2362_3: const #1s : i64
        let s_2362_3: i64 = 1;
        // C s_2362_4: cast zx s_2362_3 -> i
        let s_2362_4: i128 = (i128::try_from(s_2362_3).unwrap());
        // C s_2362_5: const #0s : i
        let s_2362_5: i128 = 0;
        // C s_2362_6: add s_2362_5 s_2362_4
        let s_2362_6: i128 = (s_2362_5 + s_2362_4);
        // D s_2362_7: bit-extract s_2362_2 s_2362_0 s_2362_6
        let s_2362_7: Bits = (Bits::new(
            ((s_2362_2) >> (s_2362_0)).value(),
            u16::try_from(s_2362_6).unwrap(),
        ));
        // D s_2362_8: cast reint s_2362_7 -> u8
        let s_2362_8: bool = ((s_2362_7.value()) != 0);
        // D s_2362_9: cast zx s_2362_8 -> bv
        let s_2362_9: Bits = Bits::new(s_2362_8 as u128, 1u16);
        // C s_2362_10: const #0u : u8
        let s_2362_10: bool = false;
        // C s_2362_11: cast zx s_2362_10 -> bv
        let s_2362_11: Bits = Bits::new(s_2362_10 as u128, 1u16);
        // D s_2362_12: cmp-eq s_2362_9 s_2362_11
        let s_2362_12: bool = ((s_2362_9) == (s_2362_11));
        // N s_2362_13: branch s_2362_12 b2365 b2363
        if s_2362_12 {
            return block_2365(state, tracer, fn_state);
        } else {
            return block_2363(state, tracer, fn_state);
        };
    }
    fn block_2363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2363_0: const #0u : u8
        let s_2363_0: bool = false;
        // D s_2363_1: write-var gs#400781 <= s_2363_0
        fn_state.gs_400781 = s_2363_0;
        // N s_2363_2: jump b2364
        return block_2364(state, tracer, fn_state);
    }
    fn block_2364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2364_0: read-var gs#400781:u8
        let s_2364_0: bool = fn_state.gs_400781;
        // D s_2364_1: write-var gs#400782 <= s_2364_0
        fn_state.gs_400782 = s_2364_0;
        // N s_2364_2: jump b2361
        return block_2361(state, tracer, fn_state);
    }
    fn block_2365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2365_0: const #4s : i
        let s_2365_0: i128 = 4;
        // D s_2365_1: read-var u#31444:u32
        let s_2365_1: u32 = fn_state.u_31444;
        // D s_2365_2: cast zx s_2365_1 -> bv
        let s_2365_2: Bits = Bits::new(s_2365_1 as u128, 32u16);
        // C s_2365_3: const #1s : i64
        let s_2365_3: i64 = 1;
        // C s_2365_4: cast zx s_2365_3 -> i
        let s_2365_4: i128 = (i128::try_from(s_2365_3).unwrap());
        // C s_2365_5: const #0s : i
        let s_2365_5: i128 = 0;
        // C s_2365_6: add s_2365_5 s_2365_4
        let s_2365_6: i128 = (s_2365_5 + s_2365_4);
        // D s_2365_7: bit-extract s_2365_2 s_2365_0 s_2365_6
        let s_2365_7: Bits = (Bits::new(
            ((s_2365_2) >> (s_2365_0)).value(),
            u16::try_from(s_2365_6).unwrap(),
        ));
        // D s_2365_8: cast reint s_2365_7 -> u8
        let s_2365_8: bool = ((s_2365_7.value()) != 0);
        // D s_2365_9: cast zx s_2365_8 -> bv
        let s_2365_9: Bits = Bits::new(s_2365_8 as u128, 1u16);
        // C s_2365_10: const #0u : u8
        let s_2365_10: bool = false;
        // C s_2365_11: cast zx s_2365_10 -> bv
        let s_2365_11: Bits = Bits::new(s_2365_10 as u128, 1u16);
        // D s_2365_12: cmp-eq s_2365_9 s_2365_11
        let s_2365_12: bool = ((s_2365_9) == (s_2365_11));
        // D s_2365_13: write-var gs#400781 <= s_2365_12
        fn_state.gs_400781 = s_2365_12;
        // N s_2365_14: jump b2364
        return block_2364(state, tracer, fn_state);
    }
    fn block_2366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2366_0: const #3594s : i
        let s_2366_0: i128 = 3594;
        // C s_2366_1: const #14696u : u32
        let s_2366_1: u32 = 14696;
        // D s_2366_2: read-reg s_2366_1:i
        let s_2366_2: i128 = {
            let value = state.read_register::<i128>(s_2366_1 as isize);
            tracer.read_register(s_2366_1 as isize, value);
            value
        };
        // D s_2366_3: cmp-lt s_2366_2 s_2366_0
        let s_2366_3: bool = ((s_2366_2) < (s_2366_0));
        // D s_2366_4: write-var gs#400755 <= s_2366_3
        fn_state.gs_400755 = s_2366_3;
        // N s_2366_5: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_2367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2367_0: const #20s : i
        let s_2367_0: i128 = 20;
        // D s_2367_1: read-var u#31435:u32
        let s_2367_1: u32 = fn_state.u_31435;
        // D s_2367_2: cast zx s_2367_1 -> bv
        let s_2367_2: Bits = Bits::new(s_2367_1 as u128, 32u16);
        // C s_2367_3: const #1s : i64
        let s_2367_3: i64 = 1;
        // C s_2367_4: cast zx s_2367_3 -> i
        let s_2367_4: i128 = (i128::try_from(s_2367_3).unwrap());
        // C s_2367_5: const #1s : i
        let s_2367_5: i128 = 1;
        // C s_2367_6: add s_2367_5 s_2367_4
        let s_2367_6: i128 = (s_2367_5 + s_2367_4);
        // D s_2367_7: bit-extract s_2367_2 s_2367_0 s_2367_6
        let s_2367_7: Bits = (Bits::new(
            ((s_2367_2) >> (s_2367_0)).value(),
            u16::try_from(s_2367_6).unwrap(),
        ));
        // D s_2367_8: cast reint s_2367_7 -> u8
        let s_2367_8: u8 = (s_2367_7.value() as u8);
        // D s_2367_9: cast zx s_2367_8 -> bv
        let s_2367_9: Bits = Bits::new(s_2367_8 as u128, 2u16);
        // C s_2367_10: const #3u : u8
        let s_2367_10: u8 = 3;
        // C s_2367_11: cast zx s_2367_10 -> bv
        let s_2367_11: Bits = Bits::new(s_2367_10 as u128, 2u16);
        // D s_2367_12: cmp-eq s_2367_9 s_2367_11
        let s_2367_12: bool = ((s_2367_9) == (s_2367_11));
        // N s_2367_13: branch s_2367_12 b2370 b2368
        if s_2367_12 {
            return block_2370(state, tracer, fn_state);
        } else {
            return block_2368(state, tracer, fn_state);
        };
    }
    fn block_2368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2368_0: const #0u : u8
        let s_2368_0: bool = false;
        // D s_2368_1: write-var gs#400752 <= s_2368_0
        fn_state.gs_400752 = s_2368_0;
        // N s_2368_2: jump b2369
        return block_2369(state, tracer, fn_state);
    }
    fn block_2369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2369_0: read-var gs#400752:u8
        let s_2369_0: bool = fn_state.gs_400752;
        // D s_2369_1: write-var gs#400753 <= s_2369_0
        fn_state.gs_400753 = s_2369_0;
        // N s_2369_2: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_2370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2370_0: const #16s : i
        let s_2370_0: i128 = 16;
        // D s_2370_1: read-var u#31435:u32
        let s_2370_1: u32 = fn_state.u_31435;
        // D s_2370_2: cast zx s_2370_1 -> bv
        let s_2370_2: Bits = Bits::new(s_2370_1 as u128, 32u16);
        // C s_2370_3: const #1s : i64
        let s_2370_3: i64 = 1;
        // C s_2370_4: cast zx s_2370_3 -> i
        let s_2370_4: i128 = (i128::try_from(s_2370_3).unwrap());
        // C s_2370_5: const #1s : i
        let s_2370_5: i128 = 1;
        // C s_2370_6: add s_2370_5 s_2370_4
        let s_2370_6: i128 = (s_2370_5 + s_2370_4);
        // D s_2370_7: bit-extract s_2370_2 s_2370_0 s_2370_6
        let s_2370_7: Bits = (Bits::new(
            ((s_2370_2) >> (s_2370_0)).value(),
            u16::try_from(s_2370_6).unwrap(),
        ));
        // D s_2370_8: cast reint s_2370_7 -> u8
        let s_2370_8: u8 = (s_2370_7.value() as u8);
        // D s_2370_9: cast zx s_2370_8 -> bv
        let s_2370_9: Bits = Bits::new(s_2370_8 as u128, 2u16);
        // C s_2370_10: const #0u : u8
        let s_2370_10: u8 = 0;
        // C s_2370_11: cast zx s_2370_10 -> bv
        let s_2370_11: Bits = Bits::new(s_2370_10 as u128, 2u16);
        // D s_2370_12: cmp-eq s_2370_9 s_2370_11
        let s_2370_12: bool = ((s_2370_9) == (s_2370_11));
        // N s_2370_13: branch s_2370_12 b2373 b2371
        if s_2370_12 {
            return block_2373(state, tracer, fn_state);
        } else {
            return block_2371(state, tracer, fn_state);
        };
    }
    fn block_2371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2371_0: const #0u : u8
        let s_2371_0: bool = false;
        // D s_2371_1: write-var gs#400751 <= s_2371_0
        fn_state.gs_400751 = s_2371_0;
        // N s_2371_2: jump b2372
        return block_2372(state, tracer, fn_state);
    }
    fn block_2372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2372_0: read-var gs#400751:u8
        let s_2372_0: bool = fn_state.gs_400751;
        // D s_2372_1: write-var gs#400752 <= s_2372_0
        fn_state.gs_400752 = s_2372_0;
        // N s_2372_2: jump b2369
        return block_2369(state, tracer, fn_state);
    }
    fn block_2373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2373_0: const #8s : i
        let s_2373_0: i128 = 8;
        // D s_2373_1: read-var u#31435:u32
        let s_2373_1: u32 = fn_state.u_31435;
        // D s_2373_2: cast zx s_2373_1 -> bv
        let s_2373_2: Bits = Bits::new(s_2373_1 as u128, 32u16);
        // C s_2373_3: const #1s : i64
        let s_2373_3: i64 = 1;
        // C s_2373_4: cast zx s_2373_3 -> i
        let s_2373_4: i128 = (i128::try_from(s_2373_3).unwrap());
        // C s_2373_5: const #3s : i
        let s_2373_5: i128 = 3;
        // C s_2373_6: add s_2373_5 s_2373_4
        let s_2373_6: i128 = (s_2373_5 + s_2373_4);
        // D s_2373_7: bit-extract s_2373_2 s_2373_0 s_2373_6
        let s_2373_7: Bits = (Bits::new(
            ((s_2373_2) >> (s_2373_0)).value(),
            u16::try_from(s_2373_6).unwrap(),
        ));
        // D s_2373_8: cast reint s_2373_7 -> u8
        let s_2373_8: u8 = (s_2373_7.value() as u8);
        // D s_2373_9: cast zx s_2373_8 -> bv
        let s_2373_9: Bits = Bits::new(s_2373_8 as u128, 4u16);
        // C s_2373_10: const #2u : u8
        let s_2373_10: u8 = 2;
        // C s_2373_11: cast zx s_2373_10 -> bv
        let s_2373_11: Bits = Bits::new(s_2373_10 as u128, 4u16);
        // D s_2373_12: cmp-eq s_2373_9 s_2373_11
        let s_2373_12: bool = ((s_2373_9) == (s_2373_11));
        // N s_2373_13: branch s_2373_12 b2376 b2374
        if s_2373_12 {
            return block_2376(state, tracer, fn_state);
        } else {
            return block_2374(state, tracer, fn_state);
        };
    }
    fn block_2374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2374_0: const #0u : u8
        let s_2374_0: bool = false;
        // D s_2374_1: write-var gs#400750 <= s_2374_0
        fn_state.gs_400750 = s_2374_0;
        // N s_2374_2: jump b2375
        return block_2375(state, tracer, fn_state);
    }
    fn block_2375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2375_0: read-var gs#400750:u8
        let s_2375_0: bool = fn_state.gs_400750;
        // D s_2375_1: write-var gs#400751 <= s_2375_0
        fn_state.gs_400751 = s_2375_0;
        // N s_2375_2: jump b2372
        return block_2372(state, tracer, fn_state);
    }
    fn block_2376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2376_0: const #4s : i
        let s_2376_0: i128 = 4;
        // D s_2376_1: read-var u#31435:u32
        let s_2376_1: u32 = fn_state.u_31435;
        // D s_2376_2: cast zx s_2376_1 -> bv
        let s_2376_2: Bits = Bits::new(s_2376_1 as u128, 32u16);
        // C s_2376_3: const #1s : i64
        let s_2376_3: i64 = 1;
        // C s_2376_4: cast zx s_2376_3 -> i
        let s_2376_4: i128 = (i128::try_from(s_2376_3).unwrap());
        // C s_2376_5: const #0s : i
        let s_2376_5: i128 = 0;
        // C s_2376_6: add s_2376_5 s_2376_4
        let s_2376_6: i128 = (s_2376_5 + s_2376_4);
        // D s_2376_7: bit-extract s_2376_2 s_2376_0 s_2376_6
        let s_2376_7: Bits = (Bits::new(
            ((s_2376_2) >> (s_2376_0)).value(),
            u16::try_from(s_2376_6).unwrap(),
        ));
        // D s_2376_8: cast reint s_2376_7 -> u8
        let s_2376_8: bool = ((s_2376_7.value()) != 0);
        // D s_2376_9: cast zx s_2376_8 -> bv
        let s_2376_9: Bits = Bits::new(s_2376_8 as u128, 1u16);
        // C s_2376_10: const #0u : u8
        let s_2376_10: bool = false;
        // C s_2376_11: cast zx s_2376_10 -> bv
        let s_2376_11: Bits = Bits::new(s_2376_10 as u128, 1u16);
        // D s_2376_12: cmp-eq s_2376_9 s_2376_11
        let s_2376_12: bool = ((s_2376_9) == (s_2376_11));
        // D s_2376_13: write-var gs#400750 <= s_2376_12
        fn_state.gs_400750 = s_2376_12;
        // N s_2376_14: jump b2375
        return block_2375(state, tracer, fn_state);
    }
    fn block_2377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2377_0: const #3592s : i
        let s_2377_0: i128 = 3592;
        // C s_2377_1: const #14696u : u32
        let s_2377_1: u32 = 14696;
        // D s_2377_2: read-reg s_2377_1:i
        let s_2377_2: i128 = {
            let value = state.read_register::<i128>(s_2377_1 as isize);
            tracer.read_register(s_2377_1 as isize, value);
            value
        };
        // D s_2377_3: cmp-lt s_2377_2 s_2377_0
        let s_2377_3: bool = ((s_2377_2) < (s_2377_0));
        // D s_2377_4: write-var gs#400720 <= s_2377_3
        fn_state.gs_400720 = s_2377_3;
        // N s_2377_5: jump b839
        return block_839(state, tracer, fn_state);
    }
    fn block_2378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2378_0: const #8s : i
        let s_2378_0: i128 = 8;
        // D s_2378_1: read-var u#31425:u32
        let s_2378_1: u32 = fn_state.u_31425;
        // D s_2378_2: cast zx s_2378_1 -> bv
        let s_2378_2: Bits = Bits::new(s_2378_1 as u128, 32u16);
        // C s_2378_3: const #1s : i64
        let s_2378_3: i64 = 1;
        // C s_2378_4: cast zx s_2378_3 -> i
        let s_2378_4: i128 = (i128::try_from(s_2378_3).unwrap());
        // C s_2378_5: const #3s : i
        let s_2378_5: i128 = 3;
        // C s_2378_6: add s_2378_5 s_2378_4
        let s_2378_6: i128 = (s_2378_5 + s_2378_4);
        // D s_2378_7: bit-extract s_2378_2 s_2378_0 s_2378_6
        let s_2378_7: Bits = (Bits::new(
            ((s_2378_2) >> (s_2378_0)).value(),
            u16::try_from(s_2378_6).unwrap(),
        ));
        // D s_2378_8: cast reint s_2378_7 -> u8
        let s_2378_8: u8 = (s_2378_7.value() as u8);
        // D s_2378_9: cast zx s_2378_8 -> bv
        let s_2378_9: Bits = Bits::new(s_2378_8 as u128, 4u16);
        // C s_2378_10: const #11u : u8
        let s_2378_10: u8 = 11;
        // C s_2378_11: cast zx s_2378_10 -> bv
        let s_2378_11: Bits = Bits::new(s_2378_10 as u128, 4u16);
        // D s_2378_12: cmp-eq s_2378_9 s_2378_11
        let s_2378_12: bool = ((s_2378_9) == (s_2378_11));
        // N s_2378_13: branch s_2378_12 b2381 b2379
        if s_2378_12 {
            return block_2381(state, tracer, fn_state);
        } else {
            return block_2379(state, tracer, fn_state);
        };
    }
    fn block_2379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2379_0: const #0u : u8
        let s_2379_0: bool = false;
        // D s_2379_1: write-var gs#400717 <= s_2379_0
        fn_state.gs_400717 = s_2379_0;
        // N s_2379_2: jump b2380
        return block_2380(state, tracer, fn_state);
    }
    fn block_2380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2380_0: read-var gs#400717:u8
        let s_2380_0: bool = fn_state.gs_400717;
        // D s_2380_1: write-var gs#400718 <= s_2380_0
        fn_state.gs_400718 = s_2380_0;
        // N s_2380_2: jump b837
        return block_837(state, tracer, fn_state);
    }
    fn block_2381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2381_0: const #4s : i
        let s_2381_0: i128 = 4;
        // D s_2381_1: read-var u#31425:u32
        let s_2381_1: u32 = fn_state.u_31425;
        // D s_2381_2: cast zx s_2381_1 -> bv
        let s_2381_2: Bits = Bits::new(s_2381_1 as u128, 32u16);
        // C s_2381_3: const #1s : i64
        let s_2381_3: i64 = 1;
        // C s_2381_4: cast zx s_2381_3 -> i
        let s_2381_4: i128 = (i128::try_from(s_2381_3).unwrap());
        // C s_2381_5: const #0s : i
        let s_2381_5: i128 = 0;
        // C s_2381_6: add s_2381_5 s_2381_4
        let s_2381_6: i128 = (s_2381_5 + s_2381_4);
        // D s_2381_7: bit-extract s_2381_2 s_2381_0 s_2381_6
        let s_2381_7: Bits = (Bits::new(
            ((s_2381_2) >> (s_2381_0)).value(),
            u16::try_from(s_2381_6).unwrap(),
        ));
        // D s_2381_8: cast reint s_2381_7 -> u8
        let s_2381_8: bool = ((s_2381_7.value()) != 0);
        // D s_2381_9: cast zx s_2381_8 -> bv
        let s_2381_9: Bits = Bits::new(s_2381_8 as u128, 1u16);
        // C s_2381_10: const #1u : u8
        let s_2381_10: bool = true;
        // C s_2381_11: cast zx s_2381_10 -> bv
        let s_2381_11: Bits = Bits::new(s_2381_10 as u128, 1u16);
        // D s_2381_12: cmp-eq s_2381_9 s_2381_11
        let s_2381_12: bool = ((s_2381_9) == (s_2381_11));
        // D s_2381_13: write-var gs#400717 <= s_2381_12
        fn_state.gs_400717 = s_2381_12;
        // N s_2381_14: jump b2380
        return block_2380(state, tracer, fn_state);
    }
    fn block_2382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2382_0: const #3590s : i
        let s_2382_0: i128 = 3590;
        // C s_2382_1: const #14696u : u32
        let s_2382_1: u32 = 14696;
        // D s_2382_2: read-reg s_2382_1:i
        let s_2382_2: i128 = {
            let value = state.read_register::<i128>(s_2382_1 as isize);
            tracer.read_register(s_2382_1 as isize, value);
            value
        };
        // D s_2382_3: cmp-lt s_2382_2 s_2382_0
        let s_2382_3: bool = ((s_2382_2) < (s_2382_0));
        // D s_2382_4: write-var gs#400691 <= s_2382_3
        fn_state.gs_400691 = s_2382_3;
        // N s_2382_5: jump b833
        return block_833(state, tracer, fn_state);
    }
    fn block_2383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2383_0: const #21s : i
        let s_2383_0: i128 = 21;
        // D s_2383_1: read-var u#31415:u32
        let s_2383_1: u32 = fn_state.u_31415;
        // D s_2383_2: cast zx s_2383_1 -> bv
        let s_2383_2: Bits = Bits::new(s_2383_1 as u128, 32u16);
        // C s_2383_3: const #1s : i64
        let s_2383_3: i64 = 1;
        // C s_2383_4: cast zx s_2383_3 -> i
        let s_2383_4: i128 = (i128::try_from(s_2383_3).unwrap());
        // C s_2383_5: const #0s : i
        let s_2383_5: i128 = 0;
        // C s_2383_6: add s_2383_5 s_2383_4
        let s_2383_6: i128 = (s_2383_5 + s_2383_4);
        // D s_2383_7: bit-extract s_2383_2 s_2383_0 s_2383_6
        let s_2383_7: Bits = (Bits::new(
            ((s_2383_2) >> (s_2383_0)).value(),
            u16::try_from(s_2383_6).unwrap(),
        ));
        // D s_2383_8: cast reint s_2383_7 -> u8
        let s_2383_8: bool = ((s_2383_7.value()) != 0);
        // D s_2383_9: cast zx s_2383_8 -> bv
        let s_2383_9: Bits = Bits::new(s_2383_8 as u128, 1u16);
        // C s_2383_10: const #0u : u8
        let s_2383_10: bool = false;
        // C s_2383_11: cast zx s_2383_10 -> bv
        let s_2383_11: Bits = Bits::new(s_2383_10 as u128, 1u16);
        // D s_2383_12: cmp-eq s_2383_9 s_2383_11
        let s_2383_12: bool = ((s_2383_9) == (s_2383_11));
        // N s_2383_13: branch s_2383_12 b2386 b2384
        if s_2383_12 {
            return block_2386(state, tracer, fn_state);
        } else {
            return block_2384(state, tracer, fn_state);
        };
    }
    fn block_2384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2384_0: const #0u : u8
        let s_2384_0: bool = false;
        // D s_2384_1: write-var gs#400688 <= s_2384_0
        fn_state.gs_400688 = s_2384_0;
        // N s_2384_2: jump b2385
        return block_2385(state, tracer, fn_state);
    }
    fn block_2385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2385_0: read-var gs#400688:u8
        let s_2385_0: bool = fn_state.gs_400688;
        // D s_2385_1: write-var gs#400689 <= s_2385_0
        fn_state.gs_400689 = s_2385_0;
        // N s_2385_2: jump b831
        return block_831(state, tracer, fn_state);
    }
    fn block_2386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2386_0: const #8s : i
        let s_2386_0: i128 = 8;
        // D s_2386_1: read-var u#31415:u32
        let s_2386_1: u32 = fn_state.u_31415;
        // D s_2386_2: cast zx s_2386_1 -> bv
        let s_2386_2: Bits = Bits::new(s_2386_1 as u128, 32u16);
        // C s_2386_3: const #1s : i64
        let s_2386_3: i64 = 1;
        // C s_2386_4: cast zx s_2386_3 -> i
        let s_2386_4: i128 = (i128::try_from(s_2386_3).unwrap());
        // C s_2386_5: const #3s : i
        let s_2386_5: i128 = 3;
        // C s_2386_6: add s_2386_5 s_2386_4
        let s_2386_6: i128 = (s_2386_5 + s_2386_4);
        // D s_2386_7: bit-extract s_2386_2 s_2386_0 s_2386_6
        let s_2386_7: Bits = (Bits::new(
            ((s_2386_2) >> (s_2386_0)).value(),
            u16::try_from(s_2386_6).unwrap(),
        ));
        // D s_2386_8: cast reint s_2386_7 -> u8
        let s_2386_8: u8 = (s_2386_7.value() as u8);
        // D s_2386_9: cast zx s_2386_8 -> bv
        let s_2386_9: Bits = Bits::new(s_2386_8 as u128, 4u16);
        // C s_2386_10: const #13u : u8
        let s_2386_10: u8 = 13;
        // C s_2386_11: cast zx s_2386_10 -> bv
        let s_2386_11: Bits = Bits::new(s_2386_10 as u128, 4u16);
        // D s_2386_12: cmp-eq s_2386_9 s_2386_11
        let s_2386_12: bool = ((s_2386_9) == (s_2386_11));
        // N s_2386_13: branch s_2386_12 b2389 b2387
        if s_2386_12 {
            return block_2389(state, tracer, fn_state);
        } else {
            return block_2387(state, tracer, fn_state);
        };
    }
    fn block_2387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2387_0: const #0u : u8
        let s_2387_0: bool = false;
        // D s_2387_1: write-var gs#400687 <= s_2387_0
        fn_state.gs_400687 = s_2387_0;
        // N s_2387_2: jump b2388
        return block_2388(state, tracer, fn_state);
    }
    fn block_2388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2388_0: read-var gs#400687:u8
        let s_2388_0: bool = fn_state.gs_400687;
        // D s_2388_1: write-var gs#400688 <= s_2388_0
        fn_state.gs_400688 = s_2388_0;
        // N s_2388_2: jump b2385
        return block_2385(state, tracer, fn_state);
    }
    fn block_2389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2389_0: const #4s : i
        let s_2389_0: i128 = 4;
        // D s_2389_1: read-var u#31415:u32
        let s_2389_1: u32 = fn_state.u_31415;
        // D s_2389_2: cast zx s_2389_1 -> bv
        let s_2389_2: Bits = Bits::new(s_2389_1 as u128, 32u16);
        // C s_2389_3: const #1s : i64
        let s_2389_3: i64 = 1;
        // C s_2389_4: cast zx s_2389_3 -> i
        let s_2389_4: i128 = (i128::try_from(s_2389_3).unwrap());
        // C s_2389_5: const #0s : i
        let s_2389_5: i128 = 0;
        // C s_2389_6: add s_2389_5 s_2389_4
        let s_2389_6: i128 = (s_2389_5 + s_2389_4);
        // D s_2389_7: bit-extract s_2389_2 s_2389_0 s_2389_6
        let s_2389_7: Bits = (Bits::new(
            ((s_2389_2) >> (s_2389_0)).value(),
            u16::try_from(s_2389_6).unwrap(),
        ));
        // D s_2389_8: cast reint s_2389_7 -> u8
        let s_2389_8: bool = ((s_2389_7.value()) != 0);
        // D s_2389_9: cast zx s_2389_8 -> bv
        let s_2389_9: Bits = Bits::new(s_2389_8 as u128, 1u16);
        // C s_2389_10: const #0u : u8
        let s_2389_10: bool = false;
        // C s_2389_11: cast zx s_2389_10 -> bv
        let s_2389_11: Bits = Bits::new(s_2389_10 as u128, 1u16);
        // D s_2389_12: cmp-eq s_2389_9 s_2389_11
        let s_2389_12: bool = ((s_2389_9) == (s_2389_11));
        // D s_2389_13: write-var gs#400687 <= s_2389_12
        fn_state.gs_400687 = s_2389_12;
        // N s_2389_14: jump b2388
        return block_2388(state, tracer, fn_state);
    }
    fn block_2390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2390_0: const #3588s : i
        let s_2390_0: i128 = 3588;
        // C s_2390_1: const #14696u : u32
        let s_2390_1: u32 = 14696;
        // D s_2390_2: read-reg s_2390_1:i
        let s_2390_2: i128 = {
            let value = state.read_register::<i128>(s_2390_1 as isize);
            tracer.read_register(s_2390_1 as isize, value);
            value
        };
        // D s_2390_3: cmp-lt s_2390_2 s_2390_0
        let s_2390_3: bool = ((s_2390_2) < (s_2390_0));
        // D s_2390_4: write-var gs#400661 <= s_2390_3
        fn_state.gs_400661 = s_2390_3;
        // N s_2390_5: jump b827
        return block_827(state, tracer, fn_state);
    }
    fn block_2391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2391_0: const #20s : i
        let s_2391_0: i128 = 20;
        // D s_2391_1: read-var u#31406:u32
        let s_2391_1: u32 = fn_state.u_31406;
        // D s_2391_2: cast zx s_2391_1 -> bv
        let s_2391_2: Bits = Bits::new(s_2391_1 as u128, 32u16);
        // C s_2391_3: const #1s : i64
        let s_2391_3: i64 = 1;
        // C s_2391_4: cast zx s_2391_3 -> i
        let s_2391_4: i128 = (i128::try_from(s_2391_3).unwrap());
        // C s_2391_5: const #1s : i
        let s_2391_5: i128 = 1;
        // C s_2391_6: add s_2391_5 s_2391_4
        let s_2391_6: i128 = (s_2391_5 + s_2391_4);
        // D s_2391_7: bit-extract s_2391_2 s_2391_0 s_2391_6
        let s_2391_7: Bits = (Bits::new(
            ((s_2391_2) >> (s_2391_0)).value(),
            u16::try_from(s_2391_6).unwrap(),
        ));
        // D s_2391_8: cast reint s_2391_7 -> u8
        let s_2391_8: u8 = (s_2391_7.value() as u8);
        // D s_2391_9: cast zx s_2391_8 -> bv
        let s_2391_9: Bits = Bits::new(s_2391_8 as u128, 2u16);
        // C s_2391_10: const #3u : u8
        let s_2391_10: u8 = 3;
        // C s_2391_11: cast zx s_2391_10 -> bv
        let s_2391_11: Bits = Bits::new(s_2391_10 as u128, 2u16);
        // D s_2391_12: cmp-eq s_2391_9 s_2391_11
        let s_2391_12: bool = ((s_2391_9) == (s_2391_11));
        // N s_2391_13: branch s_2391_12 b2394 b2392
        if s_2391_12 {
            return block_2394(state, tracer, fn_state);
        } else {
            return block_2392(state, tracer, fn_state);
        };
    }
    fn block_2392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2392_0: const #0u : u8
        let s_2392_0: bool = false;
        // D s_2392_1: write-var gs#400658 <= s_2392_0
        fn_state.gs_400658 = s_2392_0;
        // N s_2392_2: jump b2393
        return block_2393(state, tracer, fn_state);
    }
    fn block_2393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2393_0: read-var gs#400658:u8
        let s_2393_0: bool = fn_state.gs_400658;
        // D s_2393_1: write-var gs#400659 <= s_2393_0
        fn_state.gs_400659 = s_2393_0;
        // N s_2393_2: jump b825
        return block_825(state, tracer, fn_state);
    }
    fn block_2394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2394_0: const #16s : i
        let s_2394_0: i128 = 16;
        // D s_2394_1: read-var u#31406:u32
        let s_2394_1: u32 = fn_state.u_31406;
        // D s_2394_2: cast zx s_2394_1 -> bv
        let s_2394_2: Bits = Bits::new(s_2394_1 as u128, 32u16);
        // C s_2394_3: const #1s : i64
        let s_2394_3: i64 = 1;
        // C s_2394_4: cast zx s_2394_3 -> i
        let s_2394_4: i128 = (i128::try_from(s_2394_3).unwrap());
        // C s_2394_5: const #1s : i
        let s_2394_5: i128 = 1;
        // C s_2394_6: add s_2394_5 s_2394_4
        let s_2394_6: i128 = (s_2394_5 + s_2394_4);
        // D s_2394_7: bit-extract s_2394_2 s_2394_0 s_2394_6
        let s_2394_7: Bits = (Bits::new(
            ((s_2394_2) >> (s_2394_0)).value(),
            u16::try_from(s_2394_6).unwrap(),
        ));
        // D s_2394_8: cast reint s_2394_7 -> u8
        let s_2394_8: u8 = (s_2394_7.value() as u8);
        // D s_2394_9: cast zx s_2394_8 -> bv
        let s_2394_9: Bits = Bits::new(s_2394_8 as u128, 2u16);
        // C s_2394_10: const #0u : u8
        let s_2394_10: u8 = 0;
        // C s_2394_11: cast zx s_2394_10 -> bv
        let s_2394_11: Bits = Bits::new(s_2394_10 as u128, 2u16);
        // D s_2394_12: cmp-eq s_2394_9 s_2394_11
        let s_2394_12: bool = ((s_2394_9) == (s_2394_11));
        // N s_2394_13: branch s_2394_12 b2397 b2395
        if s_2394_12 {
            return block_2397(state, tracer, fn_state);
        } else {
            return block_2395(state, tracer, fn_state);
        };
    }
    fn block_2395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2395_0: const #0u : u8
        let s_2395_0: bool = false;
        // D s_2395_1: write-var gs#400657 <= s_2395_0
        fn_state.gs_400657 = s_2395_0;
        // N s_2395_2: jump b2396
        return block_2396(state, tracer, fn_state);
    }
    fn block_2396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2396_0: read-var gs#400657:u8
        let s_2396_0: bool = fn_state.gs_400657;
        // D s_2396_1: write-var gs#400658 <= s_2396_0
        fn_state.gs_400658 = s_2396_0;
        // N s_2396_2: jump b2393
        return block_2393(state, tracer, fn_state);
    }
    fn block_2397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2397_0: const #8s : i
        let s_2397_0: i128 = 8;
        // D s_2397_1: read-var u#31406:u32
        let s_2397_1: u32 = fn_state.u_31406;
        // D s_2397_2: cast zx s_2397_1 -> bv
        let s_2397_2: Bits = Bits::new(s_2397_1 as u128, 32u16);
        // C s_2397_3: const #1s : i64
        let s_2397_3: i64 = 1;
        // C s_2397_4: cast zx s_2397_3 -> i
        let s_2397_4: i128 = (i128::try_from(s_2397_3).unwrap());
        // C s_2397_5: const #3s : i
        let s_2397_5: i128 = 3;
        // C s_2397_6: add s_2397_5 s_2397_4
        let s_2397_6: i128 = (s_2397_5 + s_2397_4);
        // D s_2397_7: bit-extract s_2397_2 s_2397_0 s_2397_6
        let s_2397_7: Bits = (Bits::new(
            ((s_2397_2) >> (s_2397_0)).value(),
            u16::try_from(s_2397_6).unwrap(),
        ));
        // D s_2397_8: cast reint s_2397_7 -> u8
        let s_2397_8: u8 = (s_2397_7.value() as u8);
        // D s_2397_9: cast zx s_2397_8 -> bv
        let s_2397_9: Bits = Bits::new(s_2397_8 as u128, 4u16);
        // C s_2397_10: const #6u : u8
        let s_2397_10: u8 = 6;
        // C s_2397_11: cast zx s_2397_10 -> bv
        let s_2397_11: Bits = Bits::new(s_2397_10 as u128, 4u16);
        // D s_2397_12: cmp-eq s_2397_9 s_2397_11
        let s_2397_12: bool = ((s_2397_9) == (s_2397_11));
        // N s_2397_13: branch s_2397_12 b2400 b2398
        if s_2397_12 {
            return block_2400(state, tracer, fn_state);
        } else {
            return block_2398(state, tracer, fn_state);
        };
    }
    fn block_2398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2398_0: const #0u : u8
        let s_2398_0: bool = false;
        // D s_2398_1: write-var gs#400656 <= s_2398_0
        fn_state.gs_400656 = s_2398_0;
        // N s_2398_2: jump b2399
        return block_2399(state, tracer, fn_state);
    }
    fn block_2399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2399_0: read-var gs#400656:u8
        let s_2399_0: bool = fn_state.gs_400656;
        // D s_2399_1: write-var gs#400657 <= s_2399_0
        fn_state.gs_400657 = s_2399_0;
        // N s_2399_2: jump b2396
        return block_2396(state, tracer, fn_state);
    }
    fn block_2400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2400_0: const #4s : i
        let s_2400_0: i128 = 4;
        // D s_2400_1: read-var u#31406:u32
        let s_2400_1: u32 = fn_state.u_31406;
        // D s_2400_2: cast zx s_2400_1 -> bv
        let s_2400_2: Bits = Bits::new(s_2400_1 as u128, 32u16);
        // C s_2400_3: const #1s : i64
        let s_2400_3: i64 = 1;
        // C s_2400_4: cast zx s_2400_3 -> i
        let s_2400_4: i128 = (i128::try_from(s_2400_3).unwrap());
        // C s_2400_5: const #0s : i
        let s_2400_5: i128 = 0;
        // C s_2400_6: add s_2400_5 s_2400_4
        let s_2400_6: i128 = (s_2400_5 + s_2400_4);
        // D s_2400_7: bit-extract s_2400_2 s_2400_0 s_2400_6
        let s_2400_7: Bits = (Bits::new(
            ((s_2400_2) >> (s_2400_0)).value(),
            u16::try_from(s_2400_6).unwrap(),
        ));
        // D s_2400_8: cast reint s_2400_7 -> u8
        let s_2400_8: bool = ((s_2400_7.value()) != 0);
        // D s_2400_9: cast zx s_2400_8 -> bv
        let s_2400_9: Bits = Bits::new(s_2400_8 as u128, 1u16);
        // C s_2400_10: const #0u : u8
        let s_2400_10: bool = false;
        // C s_2400_11: cast zx s_2400_10 -> bv
        let s_2400_11: Bits = Bits::new(s_2400_10 as u128, 1u16);
        // D s_2400_12: cmp-eq s_2400_9 s_2400_11
        let s_2400_12: bool = ((s_2400_9) == (s_2400_11));
        // D s_2400_13: write-var gs#400656 <= s_2400_12
        fn_state.gs_400656 = s_2400_12;
        // N s_2400_14: jump b2399
        return block_2399(state, tracer, fn_state);
    }
    fn block_2401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2401_0: const #3586s : i
        let s_2401_0: i128 = 3586;
        // C s_2401_1: const #14696u : u32
        let s_2401_1: u32 = 14696;
        // D s_2401_2: read-reg s_2401_1:i
        let s_2401_2: i128 = {
            let value = state.read_register::<i128>(s_2401_1 as isize);
            tracer.read_register(s_2401_1 as isize, value);
            value
        };
        // D s_2401_3: cmp-lt s_2401_2 s_2401_0
        let s_2401_3: bool = ((s_2401_2) < (s_2401_0));
        // D s_2401_4: write-var gs#400628 <= s_2401_3
        fn_state.gs_400628 = s_2401_3;
        // N s_2401_5: jump b821
        return block_821(state, tracer, fn_state);
    }
    fn block_2402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2402_0: const #20s : i
        let s_2402_0: i128 = 20;
        // D s_2402_1: read-var u#31397:u32
        let s_2402_1: u32 = fn_state.u_31397;
        // D s_2402_2: cast zx s_2402_1 -> bv
        let s_2402_2: Bits = Bits::new(s_2402_1 as u128, 32u16);
        // C s_2402_3: const #1s : i64
        let s_2402_3: i64 = 1;
        // C s_2402_4: cast zx s_2402_3 -> i
        let s_2402_4: i128 = (i128::try_from(s_2402_3).unwrap());
        // C s_2402_5: const #1s : i
        let s_2402_5: i128 = 1;
        // C s_2402_6: add s_2402_5 s_2402_4
        let s_2402_6: i128 = (s_2402_5 + s_2402_4);
        // D s_2402_7: bit-extract s_2402_2 s_2402_0 s_2402_6
        let s_2402_7: Bits = (Bits::new(
            ((s_2402_2) >> (s_2402_0)).value(),
            u16::try_from(s_2402_6).unwrap(),
        ));
        // D s_2402_8: cast reint s_2402_7 -> u8
        let s_2402_8: u8 = (s_2402_7.value() as u8);
        // D s_2402_9: cast zx s_2402_8 -> bv
        let s_2402_9: Bits = Bits::new(s_2402_8 as u128, 2u16);
        // C s_2402_10: const #2u : u8
        let s_2402_10: u8 = 2;
        // C s_2402_11: cast zx s_2402_10 -> bv
        let s_2402_11: Bits = Bits::new(s_2402_10 as u128, 2u16);
        // D s_2402_12: cmp-eq s_2402_9 s_2402_11
        let s_2402_12: bool = ((s_2402_9) == (s_2402_11));
        // N s_2402_13: branch s_2402_12 b2405 b2403
        if s_2402_12 {
            return block_2405(state, tracer, fn_state);
        } else {
            return block_2403(state, tracer, fn_state);
        };
    }
    fn block_2403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2403_0: const #0u : u8
        let s_2403_0: bool = false;
        // D s_2403_1: write-var gs#400625 <= s_2403_0
        fn_state.gs_400625 = s_2403_0;
        // N s_2403_2: jump b2404
        return block_2404(state, tracer, fn_state);
    }
    fn block_2404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2404_0: read-var gs#400625:u8
        let s_2404_0: bool = fn_state.gs_400625;
        // D s_2404_1: write-var gs#400626 <= s_2404_0
        fn_state.gs_400626 = s_2404_0;
        // N s_2404_2: jump b819
        return block_819(state, tracer, fn_state);
    }
    fn block_2405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2405_0: const #8s : i
        let s_2405_0: i128 = 8;
        // D s_2405_1: read-var u#31397:u32
        let s_2405_1: u32 = fn_state.u_31397;
        // D s_2405_2: cast zx s_2405_1 -> bv
        let s_2405_2: Bits = Bits::new(s_2405_1 as u128, 32u16);
        // C s_2405_3: const #1s : i64
        let s_2405_3: i64 = 1;
        // C s_2405_4: cast zx s_2405_3 -> i
        let s_2405_4: i128 = (i128::try_from(s_2405_3).unwrap());
        // C s_2405_5: const #3s : i
        let s_2405_5: i128 = 3;
        // C s_2405_6: add s_2405_5 s_2405_4
        let s_2405_6: i128 = (s_2405_5 + s_2405_4);
        // D s_2405_7: bit-extract s_2405_2 s_2405_0 s_2405_6
        let s_2405_7: Bits = (Bits::new(
            ((s_2405_2) >> (s_2405_0)).value(),
            u16::try_from(s_2405_6).unwrap(),
        ));
        // D s_2405_8: cast reint s_2405_7 -> u8
        let s_2405_8: u8 = (s_2405_7.value() as u8);
        // D s_2405_9: cast zx s_2405_8 -> bv
        let s_2405_9: Bits = Bits::new(s_2405_8 as u128, 4u16);
        // C s_2405_10: const #1u : u8
        let s_2405_10: u8 = 1;
        // C s_2405_11: cast zx s_2405_10 -> bv
        let s_2405_11: Bits = Bits::new(s_2405_10 as u128, 4u16);
        // D s_2405_12: cmp-eq s_2405_9 s_2405_11
        let s_2405_12: bool = ((s_2405_9) == (s_2405_11));
        // N s_2405_13: branch s_2405_12 b2408 b2406
        if s_2405_12 {
            return block_2408(state, tracer, fn_state);
        } else {
            return block_2406(state, tracer, fn_state);
        };
    }
    fn block_2406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2406_0: const #0u : u8
        let s_2406_0: bool = false;
        // D s_2406_1: write-var gs#400624 <= s_2406_0
        fn_state.gs_400624 = s_2406_0;
        // N s_2406_2: jump b2407
        return block_2407(state, tracer, fn_state);
    }
    fn block_2407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2407_0: read-var gs#400624:u8
        let s_2407_0: bool = fn_state.gs_400624;
        // D s_2407_1: write-var gs#400625 <= s_2407_0
        fn_state.gs_400625 = s_2407_0;
        // N s_2407_2: jump b2404
        return block_2404(state, tracer, fn_state);
    }
    fn block_2408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2408_0: const #4s : i
        let s_2408_0: i128 = 4;
        // D s_2408_1: read-var u#31397:u32
        let s_2408_1: u32 = fn_state.u_31397;
        // D s_2408_2: cast zx s_2408_1 -> bv
        let s_2408_2: Bits = Bits::new(s_2408_1 as u128, 32u16);
        // C s_2408_3: const #1s : i64
        let s_2408_3: i64 = 1;
        // C s_2408_4: cast zx s_2408_3 -> i
        let s_2408_4: i128 = (i128::try_from(s_2408_3).unwrap());
        // C s_2408_5: const #0s : i
        let s_2408_5: i128 = 0;
        // C s_2408_6: add s_2408_5 s_2408_4
        let s_2408_6: i128 = (s_2408_5 + s_2408_4);
        // D s_2408_7: bit-extract s_2408_2 s_2408_0 s_2408_6
        let s_2408_7: Bits = (Bits::new(
            ((s_2408_2) >> (s_2408_0)).value(),
            u16::try_from(s_2408_6).unwrap(),
        ));
        // D s_2408_8: cast reint s_2408_7 -> u8
        let s_2408_8: bool = ((s_2408_7.value()) != 0);
        // D s_2408_9: cast zx s_2408_8 -> bv
        let s_2408_9: Bits = Bits::new(s_2408_8 as u128, 1u16);
        // C s_2408_10: const #1u : u8
        let s_2408_10: bool = true;
        // C s_2408_11: cast zx s_2408_10 -> bv
        let s_2408_11: Bits = Bits::new(s_2408_10 as u128, 1u16);
        // D s_2408_12: cmp-eq s_2408_9 s_2408_11
        let s_2408_12: bool = ((s_2408_9) == (s_2408_11));
        // D s_2408_13: write-var gs#400624 <= s_2408_12
        fn_state.gs_400624 = s_2408_12;
        // N s_2408_14: jump b2407
        return block_2407(state, tracer, fn_state);
    }
    fn block_2409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2409_0: const #3583s : i
        let s_2409_0: i128 = 3583;
        // C s_2409_1: const #14696u : u32
        let s_2409_1: u32 = 14696;
        // D s_2409_2: read-reg s_2409_1:i
        let s_2409_2: i128 = {
            let value = state.read_register::<i128>(s_2409_1 as isize);
            tracer.read_register(s_2409_1 as isize, value);
            value
        };
        // D s_2409_3: cmp-lt s_2409_2 s_2409_0
        let s_2409_3: bool = ((s_2409_2) < (s_2409_0));
        // D s_2409_4: write-var gs#400598 <= s_2409_3
        fn_state.gs_400598 = s_2409_3;
        // N s_2409_5: jump b815
        return block_815(state, tracer, fn_state);
    }
    fn block_2410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2410_0: const #23s : i
        let s_2410_0: i128 = 23;
        // D s_2410_1: read-var u#31388:u32
        let s_2410_1: u32 = fn_state.u_31388;
        // D s_2410_2: cast zx s_2410_1 -> bv
        let s_2410_2: Bits = Bits::new(s_2410_1 as u128, 32u16);
        // C s_2410_3: const #1s : i64
        let s_2410_3: i64 = 1;
        // C s_2410_4: cast zx s_2410_3 -> i
        let s_2410_4: i128 = (i128::try_from(s_2410_3).unwrap());
        // C s_2410_5: const #0s : i
        let s_2410_5: i128 = 0;
        // C s_2410_6: add s_2410_5 s_2410_4
        let s_2410_6: i128 = (s_2410_5 + s_2410_4);
        // D s_2410_7: bit-extract s_2410_2 s_2410_0 s_2410_6
        let s_2410_7: Bits = (Bits::new(
            ((s_2410_2) >> (s_2410_0)).value(),
            u16::try_from(s_2410_6).unwrap(),
        ));
        // D s_2410_8: cast reint s_2410_7 -> u8
        let s_2410_8: bool = ((s_2410_7.value()) != 0);
        // D s_2410_9: cast zx s_2410_8 -> bv
        let s_2410_9: Bits = Bits::new(s_2410_8 as u128, 1u16);
        // C s_2410_10: const #1u : u8
        let s_2410_10: bool = true;
        // C s_2410_11: cast zx s_2410_10 -> bv
        let s_2410_11: Bits = Bits::new(s_2410_10 as u128, 1u16);
        // D s_2410_12: cmp-eq s_2410_9 s_2410_11
        let s_2410_12: bool = ((s_2410_9) == (s_2410_11));
        // N s_2410_13: branch s_2410_12 b2413 b2411
        if s_2410_12 {
            return block_2413(state, tracer, fn_state);
        } else {
            return block_2411(state, tracer, fn_state);
        };
    }
    fn block_2411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2411_0: const #0u : u8
        let s_2411_0: bool = false;
        // D s_2411_1: write-var gs#400595 <= s_2411_0
        fn_state.gs_400595 = s_2411_0;
        // N s_2411_2: jump b2412
        return block_2412(state, tracer, fn_state);
    }
    fn block_2412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2412_0: read-var gs#400595:u8
        let s_2412_0: bool = fn_state.gs_400595;
        // D s_2412_1: write-var gs#400596 <= s_2412_0
        fn_state.gs_400596 = s_2412_0;
        // N s_2412_2: jump b813
        return block_813(state, tracer, fn_state);
    }
    fn block_2413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2413_0: const #19s : i
        let s_2413_0: i128 = 19;
        // D s_2413_1: read-var u#31388:u32
        let s_2413_1: u32 = fn_state.u_31388;
        // D s_2413_2: cast zx s_2413_1 -> bv
        let s_2413_2: Bits = Bits::new(s_2413_1 as u128, 32u16);
        // C s_2413_3: const #1s : i64
        let s_2413_3: i64 = 1;
        // C s_2413_4: cast zx s_2413_3 -> i
        let s_2413_4: i128 = (i128::try_from(s_2413_3).unwrap());
        // C s_2413_5: const #2s : i
        let s_2413_5: i128 = 2;
        // C s_2413_6: add s_2413_5 s_2413_4
        let s_2413_6: i128 = (s_2413_5 + s_2413_4);
        // D s_2413_7: bit-extract s_2413_2 s_2413_0 s_2413_6
        let s_2413_7: Bits = (Bits::new(
            ((s_2413_2) >> (s_2413_0)).value(),
            u16::try_from(s_2413_6).unwrap(),
        ));
        // D s_2413_8: cast reint s_2413_7 -> u8
        let s_2413_8: u8 = (s_2413_7.value() as u8);
        // D s_2413_9: cast zx s_2413_8 -> bv
        let s_2413_9: Bits = Bits::new(s_2413_8 as u128, 3u16);
        // C s_2413_10: const #0u : u8
        let s_2413_10: u8 = 0;
        // C s_2413_11: cast zx s_2413_10 -> bv
        let s_2413_11: Bits = Bits::new(s_2413_10 as u128, 3u16);
        // D s_2413_12: cmp-eq s_2413_9 s_2413_11
        let s_2413_12: bool = ((s_2413_9) == (s_2413_11));
        // N s_2413_13: branch s_2413_12 b2416 b2414
        if s_2413_12 {
            return block_2416(state, tracer, fn_state);
        } else {
            return block_2414(state, tracer, fn_state);
        };
    }
    fn block_2414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2414_0: const #0u : u8
        let s_2414_0: bool = false;
        // D s_2414_1: write-var gs#400594 <= s_2414_0
        fn_state.gs_400594 = s_2414_0;
        // N s_2414_2: jump b2415
        return block_2415(state, tracer, fn_state);
    }
    fn block_2415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2415_0: read-var gs#400594:u8
        let s_2415_0: bool = fn_state.gs_400594;
        // D s_2415_1: write-var gs#400595 <= s_2415_0
        fn_state.gs_400595 = s_2415_0;
        // N s_2415_2: jump b2412
        return block_2412(state, tracer, fn_state);
    }
    fn block_2416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2416_0: const #10s : i
        let s_2416_0: i128 = 10;
        // D s_2416_1: read-var u#31388:u32
        let s_2416_1: u32 = fn_state.u_31388;
        // D s_2416_2: cast zx s_2416_1 -> bv
        let s_2416_2: Bits = Bits::new(s_2416_1 as u128, 32u16);
        // C s_2416_3: const #1s : i64
        let s_2416_3: i64 = 1;
        // C s_2416_4: cast zx s_2416_3 -> i
        let s_2416_4: i128 = (i128::try_from(s_2416_3).unwrap());
        // C s_2416_5: const #1s : i
        let s_2416_5: i128 = 1;
        // C s_2416_6: add s_2416_5 s_2416_4
        let s_2416_6: i128 = (s_2416_5 + s_2416_4);
        // D s_2416_7: bit-extract s_2416_2 s_2416_0 s_2416_6
        let s_2416_7: Bits = (Bits::new(
            ((s_2416_2) >> (s_2416_0)).value(),
            u16::try_from(s_2416_6).unwrap(),
        ));
        // D s_2416_8: cast reint s_2416_7 -> u8
        let s_2416_8: u8 = (s_2416_7.value() as u8);
        // D s_2416_9: cast zx s_2416_8 -> bv
        let s_2416_9: Bits = Bits::new(s_2416_8 as u128, 2u16);
        // C s_2416_10: const #2u : u8
        let s_2416_10: u8 = 2;
        // C s_2416_11: cast zx s_2416_10 -> bv
        let s_2416_11: Bits = Bits::new(s_2416_10 as u128, 2u16);
        // D s_2416_12: cmp-eq s_2416_9 s_2416_11
        let s_2416_12: bool = ((s_2416_9) == (s_2416_11));
        // N s_2416_13: branch s_2416_12 b2419 b2417
        if s_2416_12 {
            return block_2419(state, tracer, fn_state);
        } else {
            return block_2417(state, tracer, fn_state);
        };
    }
    fn block_2417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2417_0: const #0u : u8
        let s_2417_0: bool = false;
        // D s_2417_1: write-var gs#400593 <= s_2417_0
        fn_state.gs_400593 = s_2417_0;
        // N s_2417_2: jump b2418
        return block_2418(state, tracer, fn_state);
    }
    fn block_2418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2418_0: read-var gs#400593:u8
        let s_2418_0: bool = fn_state.gs_400593;
        // D s_2418_1: write-var gs#400594 <= s_2418_0
        fn_state.gs_400594 = s_2418_0;
        // N s_2418_2: jump b2415
        return block_2415(state, tracer, fn_state);
    }
    fn block_2419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2419_0: const #7s : i
        let s_2419_0: i128 = 7;
        // D s_2419_1: read-var u#31388:u32
        let s_2419_1: u32 = fn_state.u_31388;
        // D s_2419_2: cast zx s_2419_1 -> bv
        let s_2419_2: Bits = Bits::new(s_2419_1 as u128, 32u16);
        // C s_2419_3: const #1s : i64
        let s_2419_3: i64 = 1;
        // C s_2419_4: cast zx s_2419_3 -> i
        let s_2419_4: i128 = (i128::try_from(s_2419_3).unwrap());
        // C s_2419_5: const #1s : i
        let s_2419_5: i128 = 1;
        // C s_2419_6: add s_2419_5 s_2419_4
        let s_2419_6: i128 = (s_2419_5 + s_2419_4);
        // D s_2419_7: bit-extract s_2419_2 s_2419_0 s_2419_6
        let s_2419_7: Bits = (Bits::new(
            ((s_2419_2) >> (s_2419_0)).value(),
            u16::try_from(s_2419_6).unwrap(),
        ));
        // D s_2419_8: cast reint s_2419_7 -> u8
        let s_2419_8: u8 = (s_2419_7.value() as u8);
        // D s_2419_9: cast zx s_2419_8 -> bv
        let s_2419_9: Bits = Bits::new(s_2419_8 as u128, 2u16);
        // C s_2419_10: const #2u : u8
        let s_2419_10: u8 = 2;
        // C s_2419_11: cast zx s_2419_10 -> bv
        let s_2419_11: Bits = Bits::new(s_2419_10 as u128, 2u16);
        // D s_2419_12: cmp-eq s_2419_9 s_2419_11
        let s_2419_12: bool = ((s_2419_9) == (s_2419_11));
        // N s_2419_13: branch s_2419_12 b2422 b2420
        if s_2419_12 {
            return block_2422(state, tracer, fn_state);
        } else {
            return block_2420(state, tracer, fn_state);
        };
    }
    fn block_2420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2420_0: const #0u : u8
        let s_2420_0: bool = false;
        // D s_2420_1: write-var gs#400592 <= s_2420_0
        fn_state.gs_400592 = s_2420_0;
        // N s_2420_2: jump b2421
        return block_2421(state, tracer, fn_state);
    }
    fn block_2421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2421_0: read-var gs#400592:u8
        let s_2421_0: bool = fn_state.gs_400592;
        // D s_2421_1: write-var gs#400593 <= s_2421_0
        fn_state.gs_400593 = s_2421_0;
        // N s_2421_2: jump b2418
        return block_2418(state, tracer, fn_state);
    }
    fn block_2422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2422_0: const #4s : i
        let s_2422_0: i128 = 4;
        // D s_2422_1: read-var u#31388:u32
        let s_2422_1: u32 = fn_state.u_31388;
        // D s_2422_2: cast zx s_2422_1 -> bv
        let s_2422_2: Bits = Bits::new(s_2422_1 as u128, 32u16);
        // C s_2422_3: const #1s : i64
        let s_2422_3: i64 = 1;
        // C s_2422_4: cast zx s_2422_3 -> i
        let s_2422_4: i128 = (i128::try_from(s_2422_3).unwrap());
        // C s_2422_5: const #1s : i
        let s_2422_5: i128 = 1;
        // C s_2422_6: add s_2422_5 s_2422_4
        let s_2422_6: i128 = (s_2422_5 + s_2422_4);
        // D s_2422_7: bit-extract s_2422_2 s_2422_0 s_2422_6
        let s_2422_7: Bits = (Bits::new(
            ((s_2422_2) >> (s_2422_0)).value(),
            u16::try_from(s_2422_6).unwrap(),
        ));
        // D s_2422_8: cast reint s_2422_7 -> u8
        let s_2422_8: u8 = (s_2422_7.value() as u8);
        // D s_2422_9: cast zx s_2422_8 -> bv
        let s_2422_9: Bits = Bits::new(s_2422_8 as u128, 2u16);
        // C s_2422_10: const #1u : u8
        let s_2422_10: u8 = 1;
        // C s_2422_11: cast zx s_2422_10 -> bv
        let s_2422_11: Bits = Bits::new(s_2422_10 as u128, 2u16);
        // D s_2422_12: cmp-eq s_2422_9 s_2422_11
        let s_2422_12: bool = ((s_2422_9) == (s_2422_11));
        // D s_2422_13: write-var gs#400592 <= s_2422_12
        fn_state.gs_400592 = s_2422_12;
        // N s_2422_14: jump b2421
        return block_2421(state, tracer, fn_state);
    }
    fn block_2423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2423_0: const #3582s : i
        let s_2423_0: i128 = 3582;
        // C s_2423_1: const #14696u : u32
        let s_2423_1: u32 = 14696;
        // D s_2423_2: read-reg s_2423_1:i
        let s_2423_2: i128 = {
            let value = state.read_register::<i128>(s_2423_1 as isize);
            tracer.read_register(s_2423_1 as isize, value);
            value
        };
        // D s_2423_3: cmp-lt s_2423_2 s_2423_0
        let s_2423_3: bool = ((s_2423_2) < (s_2423_0));
        // D s_2423_4: write-var gs#400562 <= s_2423_3
        fn_state.gs_400562 = s_2423_3;
        // N s_2423_5: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_2424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2424_0: const #23s : i
        let s_2424_0: i128 = 23;
        // D s_2424_1: read-var u#31379:u32
        let s_2424_1: u32 = fn_state.u_31379;
        // D s_2424_2: cast zx s_2424_1 -> bv
        let s_2424_2: Bits = Bits::new(s_2424_1 as u128, 32u16);
        // C s_2424_3: const #1s : i64
        let s_2424_3: i64 = 1;
        // C s_2424_4: cast zx s_2424_3 -> i
        let s_2424_4: i128 = (i128::try_from(s_2424_3).unwrap());
        // C s_2424_5: const #0s : i
        let s_2424_5: i128 = 0;
        // C s_2424_6: add s_2424_5 s_2424_4
        let s_2424_6: i128 = (s_2424_5 + s_2424_4);
        // D s_2424_7: bit-extract s_2424_2 s_2424_0 s_2424_6
        let s_2424_7: Bits = (Bits::new(
            ((s_2424_2) >> (s_2424_0)).value(),
            u16::try_from(s_2424_6).unwrap(),
        ));
        // D s_2424_8: cast reint s_2424_7 -> u8
        let s_2424_8: bool = ((s_2424_7.value()) != 0);
        // D s_2424_9: cast zx s_2424_8 -> bv
        let s_2424_9: Bits = Bits::new(s_2424_8 as u128, 1u16);
        // C s_2424_10: const #1u : u8
        let s_2424_10: bool = true;
        // C s_2424_11: cast zx s_2424_10 -> bv
        let s_2424_11: Bits = Bits::new(s_2424_10 as u128, 1u16);
        // D s_2424_12: cmp-eq s_2424_9 s_2424_11
        let s_2424_12: bool = ((s_2424_9) == (s_2424_11));
        // N s_2424_13: branch s_2424_12 b2427 b2425
        if s_2424_12 {
            return block_2427(state, tracer, fn_state);
        } else {
            return block_2425(state, tracer, fn_state);
        };
    }
    fn block_2425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2425_0: const #0u : u8
        let s_2425_0: bool = false;
        // D s_2425_1: write-var gs#400559 <= s_2425_0
        fn_state.gs_400559 = s_2425_0;
        // N s_2425_2: jump b2426
        return block_2426(state, tracer, fn_state);
    }
    fn block_2426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2426_0: read-var gs#400559:u8
        let s_2426_0: bool = fn_state.gs_400559;
        // D s_2426_1: write-var gs#400560 <= s_2426_0
        fn_state.gs_400560 = s_2426_0;
        // N s_2426_2: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_2427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2427_0: const #19s : i
        let s_2427_0: i128 = 19;
        // D s_2427_1: read-var u#31379:u32
        let s_2427_1: u32 = fn_state.u_31379;
        // D s_2427_2: cast zx s_2427_1 -> bv
        let s_2427_2: Bits = Bits::new(s_2427_1 as u128, 32u16);
        // C s_2427_3: const #1s : i64
        let s_2427_3: i64 = 1;
        // C s_2427_4: cast zx s_2427_3 -> i
        let s_2427_4: i128 = (i128::try_from(s_2427_3).unwrap());
        // C s_2427_5: const #2s : i
        let s_2427_5: i128 = 2;
        // C s_2427_6: add s_2427_5 s_2427_4
        let s_2427_6: i128 = (s_2427_5 + s_2427_4);
        // D s_2427_7: bit-extract s_2427_2 s_2427_0 s_2427_6
        let s_2427_7: Bits = (Bits::new(
            ((s_2427_2) >> (s_2427_0)).value(),
            u16::try_from(s_2427_6).unwrap(),
        ));
        // D s_2427_8: cast reint s_2427_7 -> u8
        let s_2427_8: u8 = (s_2427_7.value() as u8);
        // D s_2427_9: cast zx s_2427_8 -> bv
        let s_2427_9: Bits = Bits::new(s_2427_8 as u128, 3u16);
        // C s_2427_10: const #0u : u8
        let s_2427_10: u8 = 0;
        // C s_2427_11: cast zx s_2427_10 -> bv
        let s_2427_11: Bits = Bits::new(s_2427_10 as u128, 3u16);
        // D s_2427_12: cmp-eq s_2427_9 s_2427_11
        let s_2427_12: bool = ((s_2427_9) == (s_2427_11));
        // N s_2427_13: branch s_2427_12 b2430 b2428
        if s_2427_12 {
            return block_2430(state, tracer, fn_state);
        } else {
            return block_2428(state, tracer, fn_state);
        };
    }
    fn block_2428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2428_0: const #0u : u8
        let s_2428_0: bool = false;
        // D s_2428_1: write-var gs#400558 <= s_2428_0
        fn_state.gs_400558 = s_2428_0;
        // N s_2428_2: jump b2429
        return block_2429(state, tracer, fn_state);
    }
    fn block_2429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2429_0: read-var gs#400558:u8
        let s_2429_0: bool = fn_state.gs_400558;
        // D s_2429_1: write-var gs#400559 <= s_2429_0
        fn_state.gs_400559 = s_2429_0;
        // N s_2429_2: jump b2426
        return block_2426(state, tracer, fn_state);
    }
    fn block_2430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2430_0: const #11s : i
        let s_2430_0: i128 = 11;
        // D s_2430_1: read-var u#31379:u32
        let s_2430_1: u32 = fn_state.u_31379;
        // D s_2430_2: cast zx s_2430_1 -> bv
        let s_2430_2: Bits = Bits::new(s_2430_1 as u128, 32u16);
        // C s_2430_3: const #1s : i64
        let s_2430_3: i64 = 1;
        // C s_2430_4: cast zx s_2430_3 -> i
        let s_2430_4: i128 = (i128::try_from(s_2430_3).unwrap());
        // C s_2430_5: const #0s : i
        let s_2430_5: i128 = 0;
        // C s_2430_6: add s_2430_5 s_2430_4
        let s_2430_6: i128 = (s_2430_5 + s_2430_4);
        // D s_2430_7: bit-extract s_2430_2 s_2430_0 s_2430_6
        let s_2430_7: Bits = (Bits::new(
            ((s_2430_2) >> (s_2430_0)).value(),
            u16::try_from(s_2430_6).unwrap(),
        ));
        // D s_2430_8: cast reint s_2430_7 -> u8
        let s_2430_8: bool = ((s_2430_7.value()) != 0);
        // D s_2430_9: cast zx s_2430_8 -> bv
        let s_2430_9: Bits = Bits::new(s_2430_8 as u128, 1u16);
        // C s_2430_10: const #0u : u8
        let s_2430_10: bool = false;
        // C s_2430_11: cast zx s_2430_10 -> bv
        let s_2430_11: Bits = Bits::new(s_2430_10 as u128, 1u16);
        // D s_2430_12: cmp-eq s_2430_9 s_2430_11
        let s_2430_12: bool = ((s_2430_9) == (s_2430_11));
        // N s_2430_13: branch s_2430_12 b2433 b2431
        if s_2430_12 {
            return block_2433(state, tracer, fn_state);
        } else {
            return block_2431(state, tracer, fn_state);
        };
    }
    fn block_2431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2431_0: const #0u : u8
        let s_2431_0: bool = false;
        // D s_2431_1: write-var gs#400557 <= s_2431_0
        fn_state.gs_400557 = s_2431_0;
        // N s_2431_2: jump b2432
        return block_2432(state, tracer, fn_state);
    }
    fn block_2432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2432_0: read-var gs#400557:u8
        let s_2432_0: bool = fn_state.gs_400557;
        // D s_2432_1: write-var gs#400558 <= s_2432_0
        fn_state.gs_400558 = s_2432_0;
        // N s_2432_2: jump b2429
        return block_2429(state, tracer, fn_state);
    }
    fn block_2433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2433_0: const #7s : i
        let s_2433_0: i128 = 7;
        // D s_2433_1: read-var u#31379:u32
        let s_2433_1: u32 = fn_state.u_31379;
        // D s_2433_2: cast zx s_2433_1 -> bv
        let s_2433_2: Bits = Bits::new(s_2433_1 as u128, 32u16);
        // C s_2433_3: const #1s : i64
        let s_2433_3: i64 = 1;
        // C s_2433_4: cast zx s_2433_3 -> i
        let s_2433_4: i128 = (i128::try_from(s_2433_3).unwrap());
        // C s_2433_5: const #1s : i
        let s_2433_5: i128 = 1;
        // C s_2433_6: add s_2433_5 s_2433_4
        let s_2433_6: i128 = (s_2433_5 + s_2433_4);
        // D s_2433_7: bit-extract s_2433_2 s_2433_0 s_2433_6
        let s_2433_7: Bits = (Bits::new(
            ((s_2433_2) >> (s_2433_0)).value(),
            u16::try_from(s_2433_6).unwrap(),
        ));
        // D s_2433_8: cast reint s_2433_7 -> u8
        let s_2433_8: u8 = (s_2433_7.value() as u8);
        // D s_2433_9: cast zx s_2433_8 -> bv
        let s_2433_9: Bits = Bits::new(s_2433_8 as u128, 2u16);
        // C s_2433_10: const #2u : u8
        let s_2433_10: u8 = 2;
        // C s_2433_11: cast zx s_2433_10 -> bv
        let s_2433_11: Bits = Bits::new(s_2433_10 as u128, 2u16);
        // D s_2433_12: cmp-eq s_2433_9 s_2433_11
        let s_2433_12: bool = ((s_2433_9) == (s_2433_11));
        // N s_2433_13: branch s_2433_12 b2436 b2434
        if s_2433_12 {
            return block_2436(state, tracer, fn_state);
        } else {
            return block_2434(state, tracer, fn_state);
        };
    }
    fn block_2434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2434_0: const #0u : u8
        let s_2434_0: bool = false;
        // D s_2434_1: write-var gs#400556 <= s_2434_0
        fn_state.gs_400556 = s_2434_0;
        // N s_2434_2: jump b2435
        return block_2435(state, tracer, fn_state);
    }
    fn block_2435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2435_0: read-var gs#400556:u8
        let s_2435_0: bool = fn_state.gs_400556;
        // D s_2435_1: write-var gs#400557 <= s_2435_0
        fn_state.gs_400557 = s_2435_0;
        // N s_2435_2: jump b2432
        return block_2432(state, tracer, fn_state);
    }
    fn block_2436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2436_0: const #4s : i
        let s_2436_0: i128 = 4;
        // D s_2436_1: read-var u#31379:u32
        let s_2436_1: u32 = fn_state.u_31379;
        // D s_2436_2: cast zx s_2436_1 -> bv
        let s_2436_2: Bits = Bits::new(s_2436_1 as u128, 32u16);
        // C s_2436_3: const #1s : i64
        let s_2436_3: i64 = 1;
        // C s_2436_4: cast zx s_2436_3 -> i
        let s_2436_4: i128 = (i128::try_from(s_2436_3).unwrap());
        // C s_2436_5: const #1s : i
        let s_2436_5: i128 = 1;
        // C s_2436_6: add s_2436_5 s_2436_4
        let s_2436_6: i128 = (s_2436_5 + s_2436_4);
        // D s_2436_7: bit-extract s_2436_2 s_2436_0 s_2436_6
        let s_2436_7: Bits = (Bits::new(
            ((s_2436_2) >> (s_2436_0)).value(),
            u16::try_from(s_2436_6).unwrap(),
        ));
        // D s_2436_8: cast reint s_2436_7 -> u8
        let s_2436_8: u8 = (s_2436_7.value() as u8);
        // D s_2436_9: cast zx s_2436_8 -> bv
        let s_2436_9: Bits = Bits::new(s_2436_8 as u128, 2u16);
        // C s_2436_10: const #1u : u8
        let s_2436_10: u8 = 1;
        // C s_2436_11: cast zx s_2436_10 -> bv
        let s_2436_11: Bits = Bits::new(s_2436_10 as u128, 2u16);
        // D s_2436_12: cmp-eq s_2436_9 s_2436_11
        let s_2436_12: bool = ((s_2436_9) == (s_2436_11));
        // D s_2436_13: write-var gs#400556 <= s_2436_12
        fn_state.gs_400556 = s_2436_12;
        // N s_2436_14: jump b2435
        return block_2435(state, tracer, fn_state);
    }
    fn block_2437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2437_0: const #3580s : i
        let s_2437_0: i128 = 3580;
        // C s_2437_1: const #14696u : u32
        let s_2437_1: u32 = 14696;
        // D s_2437_2: read-reg s_2437_1:i
        let s_2437_2: i128 = {
            let value = state.read_register::<i128>(s_2437_1 as isize);
            tracer.read_register(s_2437_1 as isize, value);
            value
        };
        // D s_2437_3: cmp-lt s_2437_2 s_2437_0
        let s_2437_3: bool = ((s_2437_2) < (s_2437_0));
        // D s_2437_4: write-var gs#400526 <= s_2437_3
        fn_state.gs_400526 = s_2437_3;
        // N s_2437_5: jump b803
        return block_803(state, tracer, fn_state);
    }
    fn block_2438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2438_0: const #20s : i
        let s_2438_0: i128 = 20;
        // D s_2438_1: read-var u#31370:u32
        let s_2438_1: u32 = fn_state.u_31370;
        // D s_2438_2: cast zx s_2438_1 -> bv
        let s_2438_2: Bits = Bits::new(s_2438_1 as u128, 32u16);
        // C s_2438_3: const #1s : i64
        let s_2438_3: i64 = 1;
        // C s_2438_4: cast zx s_2438_3 -> i
        let s_2438_4: i128 = (i128::try_from(s_2438_3).unwrap());
        // C s_2438_5: const #1s : i
        let s_2438_5: i128 = 1;
        // C s_2438_6: add s_2438_5 s_2438_4
        let s_2438_6: i128 = (s_2438_5 + s_2438_4);
        // D s_2438_7: bit-extract s_2438_2 s_2438_0 s_2438_6
        let s_2438_7: Bits = (Bits::new(
            ((s_2438_2) >> (s_2438_0)).value(),
            u16::try_from(s_2438_6).unwrap(),
        ));
        // D s_2438_8: cast reint s_2438_7 -> u8
        let s_2438_8: u8 = (s_2438_7.value() as u8);
        // D s_2438_9: cast zx s_2438_8 -> bv
        let s_2438_9: Bits = Bits::new(s_2438_8 as u128, 2u16);
        // C s_2438_10: const #3u : u8
        let s_2438_10: u8 = 3;
        // C s_2438_11: cast zx s_2438_10 -> bv
        let s_2438_11: Bits = Bits::new(s_2438_10 as u128, 2u16);
        // D s_2438_12: cmp-eq s_2438_9 s_2438_11
        let s_2438_12: bool = ((s_2438_9) == (s_2438_11));
        // N s_2438_13: branch s_2438_12 b2441 b2439
        if s_2438_12 {
            return block_2441(state, tracer, fn_state);
        } else {
            return block_2439(state, tracer, fn_state);
        };
    }
    fn block_2439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2439_0: const #0u : u8
        let s_2439_0: bool = false;
        // D s_2439_1: write-var gs#400523 <= s_2439_0
        fn_state.gs_400523 = s_2439_0;
        // N s_2439_2: jump b2440
        return block_2440(state, tracer, fn_state);
    }
    fn block_2440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2440_0: read-var gs#400523:u8
        let s_2440_0: bool = fn_state.gs_400523;
        // D s_2440_1: write-var gs#400524 <= s_2440_0
        fn_state.gs_400524 = s_2440_0;
        // N s_2440_2: jump b801
        return block_801(state, tracer, fn_state);
    }
    fn block_2441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2441_0: const #8s : i
        let s_2441_0: i128 = 8;
        // D s_2441_1: read-var u#31370:u32
        let s_2441_1: u32 = fn_state.u_31370;
        // D s_2441_2: cast zx s_2441_1 -> bv
        let s_2441_2: Bits = Bits::new(s_2441_1 as u128, 32u16);
        // C s_2441_3: const #1s : i64
        let s_2441_3: i64 = 1;
        // C s_2441_4: cast zx s_2441_3 -> i
        let s_2441_4: i128 = (i128::try_from(s_2441_3).unwrap());
        // C s_2441_5: const #3s : i
        let s_2441_5: i128 = 3;
        // C s_2441_6: add s_2441_5 s_2441_4
        let s_2441_6: i128 = (s_2441_5 + s_2441_4);
        // D s_2441_7: bit-extract s_2441_2 s_2441_0 s_2441_6
        let s_2441_7: Bits = (Bits::new(
            ((s_2441_2) >> (s_2441_0)).value(),
            u16::try_from(s_2441_6).unwrap(),
        ));
        // D s_2441_8: cast reint s_2441_7 -> u8
        let s_2441_8: u8 = (s_2441_7.value() as u8);
        // D s_2441_9: cast zx s_2441_8 -> bv
        let s_2441_9: Bits = Bits::new(s_2441_8 as u128, 4u16);
        // C s_2441_10: const #1u : u8
        let s_2441_10: u8 = 1;
        // C s_2441_11: cast zx s_2441_10 -> bv
        let s_2441_11: Bits = Bits::new(s_2441_10 as u128, 4u16);
        // D s_2441_12: cmp-eq s_2441_9 s_2441_11
        let s_2441_12: bool = ((s_2441_9) == (s_2441_11));
        // N s_2441_13: branch s_2441_12 b2444 b2442
        if s_2441_12 {
            return block_2444(state, tracer, fn_state);
        } else {
            return block_2442(state, tracer, fn_state);
        };
    }
    fn block_2442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2442_0: const #0u : u8
        let s_2442_0: bool = false;
        // D s_2442_1: write-var gs#400522 <= s_2442_0
        fn_state.gs_400522 = s_2442_0;
        // N s_2442_2: jump b2443
        return block_2443(state, tracer, fn_state);
    }
    fn block_2443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2443_0: read-var gs#400522:u8
        let s_2443_0: bool = fn_state.gs_400522;
        // D s_2443_1: write-var gs#400523 <= s_2443_0
        fn_state.gs_400523 = s_2443_0;
        // N s_2443_2: jump b2440
        return block_2440(state, tracer, fn_state);
    }
    fn block_2444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2444_0: const #4s : i
        let s_2444_0: i128 = 4;
        // D s_2444_1: read-var u#31370:u32
        let s_2444_1: u32 = fn_state.u_31370;
        // D s_2444_2: cast zx s_2444_1 -> bv
        let s_2444_2: Bits = Bits::new(s_2444_1 as u128, 32u16);
        // C s_2444_3: const #1s : i64
        let s_2444_3: i64 = 1;
        // C s_2444_4: cast zx s_2444_3 -> i
        let s_2444_4: i128 = (i128::try_from(s_2444_3).unwrap());
        // C s_2444_5: const #0s : i
        let s_2444_5: i128 = 0;
        // C s_2444_6: add s_2444_5 s_2444_4
        let s_2444_6: i128 = (s_2444_5 + s_2444_4);
        // D s_2444_7: bit-extract s_2444_2 s_2444_0 s_2444_6
        let s_2444_7: Bits = (Bits::new(
            ((s_2444_2) >> (s_2444_0)).value(),
            u16::try_from(s_2444_6).unwrap(),
        ));
        // D s_2444_8: cast reint s_2444_7 -> u8
        let s_2444_8: bool = ((s_2444_7.value()) != 0);
        // D s_2444_9: cast zx s_2444_8 -> bv
        let s_2444_9: Bits = Bits::new(s_2444_8 as u128, 1u16);
        // C s_2444_10: const #1u : u8
        let s_2444_10: bool = true;
        // C s_2444_11: cast zx s_2444_10 -> bv
        let s_2444_11: Bits = Bits::new(s_2444_10 as u128, 1u16);
        // D s_2444_12: cmp-eq s_2444_9 s_2444_11
        let s_2444_12: bool = ((s_2444_9) == (s_2444_11));
        // D s_2444_13: write-var gs#400522 <= s_2444_12
        fn_state.gs_400522 = s_2444_12;
        // N s_2444_14: jump b2443
        return block_2443(state, tracer, fn_state);
    }
    fn block_2445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2445_0: const #3572s : i
        let s_2445_0: i128 = 3572;
        // C s_2445_1: const #14696u : u32
        let s_2445_1: u32 = 14696;
        // D s_2445_2: read-reg s_2445_1:i
        let s_2445_2: i128 = {
            let value = state.read_register::<i128>(s_2445_1 as isize);
            tracer.read_register(s_2445_1 as isize, value);
            value
        };
        // D s_2445_3: cmp-lt s_2445_2 s_2445_0
        let s_2445_3: bool = ((s_2445_2) < (s_2445_0));
        // D s_2445_4: write-var gs#400496 <= s_2445_3
        fn_state.gs_400496 = s_2445_3;
        // N s_2445_5: jump b797
        return block_797(state, tracer, fn_state);
    }
    fn block_2446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2446_0: const #20s : i
        let s_2446_0: i128 = 20;
        // D s_2446_1: read-var u#31361:u32
        let s_2446_1: u32 = fn_state.u_31361;
        // D s_2446_2: cast zx s_2446_1 -> bv
        let s_2446_2: Bits = Bits::new(s_2446_1 as u128, 32u16);
        // C s_2446_3: const #1s : i64
        let s_2446_3: i64 = 1;
        // C s_2446_4: cast zx s_2446_3 -> i
        let s_2446_4: i128 = (i128::try_from(s_2446_3).unwrap());
        // C s_2446_5: const #1s : i
        let s_2446_5: i128 = 1;
        // C s_2446_6: add s_2446_5 s_2446_4
        let s_2446_6: i128 = (s_2446_5 + s_2446_4);
        // D s_2446_7: bit-extract s_2446_2 s_2446_0 s_2446_6
        let s_2446_7: Bits = (Bits::new(
            ((s_2446_2) >> (s_2446_0)).value(),
            u16::try_from(s_2446_6).unwrap(),
        ));
        // D s_2446_8: cast reint s_2446_7 -> u8
        let s_2446_8: u8 = (s_2446_7.value() as u8);
        // D s_2446_9: cast zx s_2446_8 -> bv
        let s_2446_9: Bits = Bits::new(s_2446_8 as u128, 2u16);
        // C s_2446_10: const #3u : u8
        let s_2446_10: u8 = 3;
        // C s_2446_11: cast zx s_2446_10 -> bv
        let s_2446_11: Bits = Bits::new(s_2446_10 as u128, 2u16);
        // D s_2446_12: cmp-eq s_2446_9 s_2446_11
        let s_2446_12: bool = ((s_2446_9) == (s_2446_11));
        // N s_2446_13: branch s_2446_12 b2449 b2447
        if s_2446_12 {
            return block_2449(state, tracer, fn_state);
        } else {
            return block_2447(state, tracer, fn_state);
        };
    }
    fn block_2447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2447_0: const #0u : u8
        let s_2447_0: bool = false;
        // D s_2447_1: write-var gs#400493 <= s_2447_0
        fn_state.gs_400493 = s_2447_0;
        // N s_2447_2: jump b2448
        return block_2448(state, tracer, fn_state);
    }
    fn block_2448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2448_0: read-var gs#400493:u8
        let s_2448_0: bool = fn_state.gs_400493;
        // D s_2448_1: write-var gs#400494 <= s_2448_0
        fn_state.gs_400494 = s_2448_0;
        // N s_2448_2: jump b795
        return block_795(state, tracer, fn_state);
    }
    fn block_2449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2449_0: const #16s : i
        let s_2449_0: i128 = 16;
        // D s_2449_1: read-var u#31361:u32
        let s_2449_1: u32 = fn_state.u_31361;
        // D s_2449_2: cast zx s_2449_1 -> bv
        let s_2449_2: Bits = Bits::new(s_2449_1 as u128, 32u16);
        // C s_2449_3: const #1s : i64
        let s_2449_3: i64 = 1;
        // C s_2449_4: cast zx s_2449_3 -> i
        let s_2449_4: i128 = (i128::try_from(s_2449_3).unwrap());
        // C s_2449_5: const #1s : i
        let s_2449_5: i128 = 1;
        // C s_2449_6: add s_2449_5 s_2449_4
        let s_2449_6: i128 = (s_2449_5 + s_2449_4);
        // D s_2449_7: bit-extract s_2449_2 s_2449_0 s_2449_6
        let s_2449_7: Bits = (Bits::new(
            ((s_2449_2) >> (s_2449_0)).value(),
            u16::try_from(s_2449_6).unwrap(),
        ));
        // D s_2449_8: cast reint s_2449_7 -> u8
        let s_2449_8: u8 = (s_2449_7.value() as u8);
        // D s_2449_9: cast zx s_2449_8 -> bv
        let s_2449_9: Bits = Bits::new(s_2449_8 as u128, 2u16);
        // C s_2449_10: const #1u : u8
        let s_2449_10: u8 = 1;
        // C s_2449_11: cast zx s_2449_10 -> bv
        let s_2449_11: Bits = Bits::new(s_2449_10 as u128, 2u16);
        // D s_2449_12: cmp-eq s_2449_9 s_2449_11
        let s_2449_12: bool = ((s_2449_9) == (s_2449_11));
        // N s_2449_13: branch s_2449_12 b2452 b2450
        if s_2449_12 {
            return block_2452(state, tracer, fn_state);
        } else {
            return block_2450(state, tracer, fn_state);
        };
    }
    fn block_2450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2450_0: const #0u : u8
        let s_2450_0: bool = false;
        // D s_2450_1: write-var gs#400492 <= s_2450_0
        fn_state.gs_400492 = s_2450_0;
        // N s_2450_2: jump b2451
        return block_2451(state, tracer, fn_state);
    }
    fn block_2451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2451_0: read-var gs#400492:u8
        let s_2451_0: bool = fn_state.gs_400492;
        // D s_2451_1: write-var gs#400493 <= s_2451_0
        fn_state.gs_400493 = s_2451_0;
        // N s_2451_2: jump b2448
        return block_2448(state, tracer, fn_state);
    }
    fn block_2452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2452_0: const #11s : i
        let s_2452_0: i128 = 11;
        // D s_2452_1: read-var u#31361:u32
        let s_2452_1: u32 = fn_state.u_31361;
        // D s_2452_2: cast zx s_2452_1 -> bv
        let s_2452_2: Bits = Bits::new(s_2452_1 as u128, 32u16);
        // C s_2452_3: const #1s : i64
        let s_2452_3: i64 = 1;
        // C s_2452_4: cast zx s_2452_3 -> i
        let s_2452_4: i128 = (i128::try_from(s_2452_3).unwrap());
        // C s_2452_5: const #0s : i
        let s_2452_5: i128 = 0;
        // C s_2452_6: add s_2452_5 s_2452_4
        let s_2452_6: i128 = (s_2452_5 + s_2452_4);
        // D s_2452_7: bit-extract s_2452_2 s_2452_0 s_2452_6
        let s_2452_7: Bits = (Bits::new(
            ((s_2452_2) >> (s_2452_0)).value(),
            u16::try_from(s_2452_6).unwrap(),
        ));
        // D s_2452_8: cast reint s_2452_7 -> u8
        let s_2452_8: bool = ((s_2452_7.value()) != 0);
        // D s_2452_9: cast zx s_2452_8 -> bv
        let s_2452_9: Bits = Bits::new(s_2452_8 as u128, 1u16);
        // C s_2452_10: const #0u : u8
        let s_2452_10: bool = false;
        // C s_2452_11: cast zx s_2452_10 -> bv
        let s_2452_11: Bits = Bits::new(s_2452_10 as u128, 1u16);
        // D s_2452_12: cmp-eq s_2452_9 s_2452_11
        let s_2452_12: bool = ((s_2452_9) == (s_2452_11));
        // N s_2452_13: branch s_2452_12 b2455 b2453
        if s_2452_12 {
            return block_2455(state, tracer, fn_state);
        } else {
            return block_2453(state, tracer, fn_state);
        };
    }
    fn block_2453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2453_0: const #0u : u8
        let s_2453_0: bool = false;
        // D s_2453_1: write-var gs#400491 <= s_2453_0
        fn_state.gs_400491 = s_2453_0;
        // N s_2453_2: jump b2454
        return block_2454(state, tracer, fn_state);
    }
    fn block_2454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2454_0: read-var gs#400491:u8
        let s_2454_0: bool = fn_state.gs_400491;
        // D s_2454_1: write-var gs#400492 <= s_2454_0
        fn_state.gs_400492 = s_2454_0;
        // N s_2454_2: jump b2451
        return block_2451(state, tracer, fn_state);
    }
    fn block_2455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2455_0: const #7s : i
        let s_2455_0: i128 = 7;
        // D s_2455_1: read-var u#31361:u32
        let s_2455_1: u32 = fn_state.u_31361;
        // D s_2455_2: cast zx s_2455_1 -> bv
        let s_2455_2: Bits = Bits::new(s_2455_1 as u128, 32u16);
        // C s_2455_3: const #1s : i64
        let s_2455_3: i64 = 1;
        // C s_2455_4: cast zx s_2455_3 -> i
        let s_2455_4: i128 = (i128::try_from(s_2455_3).unwrap());
        // C s_2455_5: const #2s : i
        let s_2455_5: i128 = 2;
        // C s_2455_6: add s_2455_5 s_2455_4
        let s_2455_6: i128 = (s_2455_5 + s_2455_4);
        // D s_2455_7: bit-extract s_2455_2 s_2455_0 s_2455_6
        let s_2455_7: Bits = (Bits::new(
            ((s_2455_2) >> (s_2455_0)).value(),
            u16::try_from(s_2455_6).unwrap(),
        ));
        // D s_2455_8: cast reint s_2455_7 -> u8
        let s_2455_8: u8 = (s_2455_7.value() as u8);
        // D s_2455_9: cast zx s_2455_8 -> bv
        let s_2455_9: Bits = Bits::new(s_2455_8 as u128, 3u16);
        // C s_2455_10: const #7u : u8
        let s_2455_10: u8 = 7;
        // C s_2455_11: cast zx s_2455_10 -> bv
        let s_2455_11: Bits = Bits::new(s_2455_10 as u128, 3u16);
        // D s_2455_12: cmp-eq s_2455_9 s_2455_11
        let s_2455_12: bool = ((s_2455_9) == (s_2455_11));
        // N s_2455_13: branch s_2455_12 b2458 b2456
        if s_2455_12 {
            return block_2458(state, tracer, fn_state);
        } else {
            return block_2456(state, tracer, fn_state);
        };
    }
    fn block_2456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2456_0: const #0u : u8
        let s_2456_0: bool = false;
        // D s_2456_1: write-var gs#400490 <= s_2456_0
        fn_state.gs_400490 = s_2456_0;
        // N s_2456_2: jump b2457
        return block_2457(state, tracer, fn_state);
    }
    fn block_2457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2457_0: read-var gs#400490:u8
        let s_2457_0: bool = fn_state.gs_400490;
        // D s_2457_1: write-var gs#400491 <= s_2457_0
        fn_state.gs_400491 = s_2457_0;
        // N s_2457_2: jump b2454
        return block_2454(state, tracer, fn_state);
    }
    fn block_2458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2458_0: const #4s : i
        let s_2458_0: i128 = 4;
        // D s_2458_1: read-var u#31361:u32
        let s_2458_1: u32 = fn_state.u_31361;
        // D s_2458_2: cast zx s_2458_1 -> bv
        let s_2458_2: Bits = Bits::new(s_2458_1 as u128, 32u16);
        // C s_2458_3: const #1s : i64
        let s_2458_3: i64 = 1;
        // C s_2458_4: cast zx s_2458_3 -> i
        let s_2458_4: i128 = (i128::try_from(s_2458_3).unwrap());
        // C s_2458_5: const #0s : i
        let s_2458_5: i128 = 0;
        // C s_2458_6: add s_2458_5 s_2458_4
        let s_2458_6: i128 = (s_2458_5 + s_2458_4);
        // D s_2458_7: bit-extract s_2458_2 s_2458_0 s_2458_6
        let s_2458_7: Bits = (Bits::new(
            ((s_2458_2) >> (s_2458_0)).value(),
            u16::try_from(s_2458_6).unwrap(),
        ));
        // D s_2458_8: cast reint s_2458_7 -> u8
        let s_2458_8: bool = ((s_2458_7.value()) != 0);
        // D s_2458_9: cast zx s_2458_8 -> bv
        let s_2458_9: Bits = Bits::new(s_2458_8 as u128, 1u16);
        // C s_2458_10: const #0u : u8
        let s_2458_10: bool = false;
        // C s_2458_11: cast zx s_2458_10 -> bv
        let s_2458_11: Bits = Bits::new(s_2458_10 as u128, 1u16);
        // D s_2458_12: cmp-eq s_2458_9 s_2458_11
        let s_2458_12: bool = ((s_2458_9) == (s_2458_11));
        // D s_2458_13: write-var gs#400490 <= s_2458_12
        fn_state.gs_400490 = s_2458_12;
        // N s_2458_14: jump b2457
        return block_2457(state, tracer, fn_state);
    }
    fn block_2459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2459_0: const #3570s : i
        let s_2459_0: i128 = 3570;
        // C s_2459_1: const #14696u : u32
        let s_2459_1: u32 = 14696;
        // D s_2459_2: read-reg s_2459_1:i
        let s_2459_2: i128 = {
            let value = state.read_register::<i128>(s_2459_1 as isize);
            tracer.read_register(s_2459_1 as isize, value);
            value
        };
        // D s_2459_3: cmp-lt s_2459_2 s_2459_0
        let s_2459_3: bool = ((s_2459_2) < (s_2459_0));
        // D s_2459_4: write-var gs#400462 <= s_2459_3
        fn_state.gs_400462 = s_2459_3;
        // N s_2459_5: jump b791
        return block_791(state, tracer, fn_state);
    }
    fn block_2460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2460_0: const #20s : i
        let s_2460_0: i128 = 20;
        // D s_2460_1: read-var u#31353:u32
        let s_2460_1: u32 = fn_state.u_31353;
        // D s_2460_2: cast zx s_2460_1 -> bv
        let s_2460_2: Bits = Bits::new(s_2460_1 as u128, 32u16);
        // C s_2460_3: const #1s : i64
        let s_2460_3: i64 = 1;
        // C s_2460_4: cast zx s_2460_3 -> i
        let s_2460_4: i128 = (i128::try_from(s_2460_3).unwrap());
        // C s_2460_5: const #1s : i
        let s_2460_5: i128 = 1;
        // C s_2460_6: add s_2460_5 s_2460_4
        let s_2460_6: i128 = (s_2460_5 + s_2460_4);
        // D s_2460_7: bit-extract s_2460_2 s_2460_0 s_2460_6
        let s_2460_7: Bits = (Bits::new(
            ((s_2460_2) >> (s_2460_0)).value(),
            u16::try_from(s_2460_6).unwrap(),
        ));
        // D s_2460_8: cast reint s_2460_7 -> u8
        let s_2460_8: u8 = (s_2460_7.value() as u8);
        // D s_2460_9: cast zx s_2460_8 -> bv
        let s_2460_9: Bits = Bits::new(s_2460_8 as u128, 2u16);
        // C s_2460_10: const #3u : u8
        let s_2460_10: u8 = 3;
        // C s_2460_11: cast zx s_2460_10 -> bv
        let s_2460_11: Bits = Bits::new(s_2460_10 as u128, 2u16);
        // D s_2460_12: cmp-eq s_2460_9 s_2460_11
        let s_2460_12: bool = ((s_2460_9) == (s_2460_11));
        // N s_2460_13: branch s_2460_12 b2463 b2461
        if s_2460_12 {
            return block_2463(state, tracer, fn_state);
        } else {
            return block_2461(state, tracer, fn_state);
        };
    }
    fn block_2461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2461_0: const #0u : u8
        let s_2461_0: bool = false;
        // D s_2461_1: write-var gs#400459 <= s_2461_0
        fn_state.gs_400459 = s_2461_0;
        // N s_2461_2: jump b2462
        return block_2462(state, tracer, fn_state);
    }
    fn block_2462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2462_0: read-var gs#400459:u8
        let s_2462_0: bool = fn_state.gs_400459;
        // D s_2462_1: write-var gs#400460 <= s_2462_0
        fn_state.gs_400460 = s_2462_0;
        // N s_2462_2: jump b789
        return block_789(state, tracer, fn_state);
    }
    fn block_2463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2463_0: const #16s : i
        let s_2463_0: i128 = 16;
        // D s_2463_1: read-var u#31353:u32
        let s_2463_1: u32 = fn_state.u_31353;
        // D s_2463_2: cast zx s_2463_1 -> bv
        let s_2463_2: Bits = Bits::new(s_2463_1 as u128, 32u16);
        // C s_2463_3: const #1s : i64
        let s_2463_3: i64 = 1;
        // C s_2463_4: cast zx s_2463_3 -> i
        let s_2463_4: i128 = (i128::try_from(s_2463_3).unwrap());
        // C s_2463_5: const #1s : i
        let s_2463_5: i128 = 1;
        // C s_2463_6: add s_2463_5 s_2463_4
        let s_2463_6: i128 = (s_2463_5 + s_2463_4);
        // D s_2463_7: bit-extract s_2463_2 s_2463_0 s_2463_6
        let s_2463_7: Bits = (Bits::new(
            ((s_2463_2) >> (s_2463_0)).value(),
            u16::try_from(s_2463_6).unwrap(),
        ));
        // D s_2463_8: cast reint s_2463_7 -> u8
        let s_2463_8: u8 = (s_2463_7.value() as u8);
        // D s_2463_9: cast zx s_2463_8 -> bv
        let s_2463_9: Bits = Bits::new(s_2463_8 as u128, 2u16);
        // C s_2463_10: const #0u : u8
        let s_2463_10: u8 = 0;
        // C s_2463_11: cast zx s_2463_10 -> bv
        let s_2463_11: Bits = Bits::new(s_2463_10 as u128, 2u16);
        // D s_2463_12: cmp-eq s_2463_9 s_2463_11
        let s_2463_12: bool = ((s_2463_9) == (s_2463_11));
        // N s_2463_13: branch s_2463_12 b2466 b2464
        if s_2463_12 {
            return block_2466(state, tracer, fn_state);
        } else {
            return block_2464(state, tracer, fn_state);
        };
    }
    fn block_2464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2464_0: const #0u : u8
        let s_2464_0: bool = false;
        // D s_2464_1: write-var gs#400458 <= s_2464_0
        fn_state.gs_400458 = s_2464_0;
        // N s_2464_2: jump b2465
        return block_2465(state, tracer, fn_state);
    }
    fn block_2465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2465_0: read-var gs#400458:u8
        let s_2465_0: bool = fn_state.gs_400458;
        // D s_2465_1: write-var gs#400459 <= s_2465_0
        fn_state.gs_400459 = s_2465_0;
        // N s_2465_2: jump b2462
        return block_2462(state, tracer, fn_state);
    }
    fn block_2466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2466_0: const #7s : i
        let s_2466_0: i128 = 7;
        // D s_2466_1: read-var u#31353:u32
        let s_2466_1: u32 = fn_state.u_31353;
        // D s_2466_2: cast zx s_2466_1 -> bv
        let s_2466_2: Bits = Bits::new(s_2466_1 as u128, 32u16);
        // C s_2466_3: const #1s : i64
        let s_2466_3: i64 = 1;
        // C s_2466_4: cast zx s_2466_3 -> i
        let s_2466_4: i128 = (i128::try_from(s_2466_3).unwrap());
        // C s_2466_5: const #4s : i
        let s_2466_5: i128 = 4;
        // C s_2466_6: add s_2466_5 s_2466_4
        let s_2466_6: i128 = (s_2466_5 + s_2466_4);
        // D s_2466_7: bit-extract s_2466_2 s_2466_0 s_2466_6
        let s_2466_7: Bits = (Bits::new(
            ((s_2466_2) >> (s_2466_0)).value(),
            u16::try_from(s_2466_6).unwrap(),
        ));
        // D s_2466_8: cast reint s_2466_7 -> u8
        let s_2466_8: u8 = (s_2466_7.value() as u8);
        // D s_2466_9: cast zx s_2466_8 -> bv
        let s_2466_9: Bits = Bits::new(s_2466_8 as u128, 5u16);
        // C s_2466_10: const #11u : u8
        let s_2466_10: u8 = 11;
        // C s_2466_11: cast zx s_2466_10 -> bv
        let s_2466_11: Bits = Bits::new(s_2466_10 as u128, 5u16);
        // D s_2466_12: cmp-eq s_2466_9 s_2466_11
        let s_2466_12: bool = ((s_2466_9) == (s_2466_11));
        // N s_2466_13: branch s_2466_12 b2469 b2467
        if s_2466_12 {
            return block_2469(state, tracer, fn_state);
        } else {
            return block_2467(state, tracer, fn_state);
        };
    }
    fn block_2467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2467_0: const #0u : u8
        let s_2467_0: bool = false;
        // D s_2467_1: write-var gs#400457 <= s_2467_0
        fn_state.gs_400457 = s_2467_0;
        // N s_2467_2: jump b2468
        return block_2468(state, tracer, fn_state);
    }
    fn block_2468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2468_0: read-var gs#400457:u8
        let s_2468_0: bool = fn_state.gs_400457;
        // D s_2468_1: write-var gs#400458 <= s_2468_0
        fn_state.gs_400458 = s_2468_0;
        // N s_2468_2: jump b2465
        return block_2465(state, tracer, fn_state);
    }
    fn block_2469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2469_0: const #4s : i
        let s_2469_0: i128 = 4;
        // D s_2469_1: read-var u#31353:u32
        let s_2469_1: u32 = fn_state.u_31353;
        // D s_2469_2: cast zx s_2469_1 -> bv
        let s_2469_2: Bits = Bits::new(s_2469_1 as u128, 32u16);
        // C s_2469_3: const #1s : i64
        let s_2469_3: i64 = 1;
        // C s_2469_4: cast zx s_2469_3 -> i
        let s_2469_4: i128 = (i128::try_from(s_2469_3).unwrap());
        // C s_2469_5: const #0s : i
        let s_2469_5: i128 = 0;
        // C s_2469_6: add s_2469_5 s_2469_4
        let s_2469_6: i128 = (s_2469_5 + s_2469_4);
        // D s_2469_7: bit-extract s_2469_2 s_2469_0 s_2469_6
        let s_2469_7: Bits = (Bits::new(
            ((s_2469_2) >> (s_2469_0)).value(),
            u16::try_from(s_2469_6).unwrap(),
        ));
        // D s_2469_8: cast reint s_2469_7 -> u8
        let s_2469_8: bool = ((s_2469_7.value()) != 0);
        // D s_2469_9: cast zx s_2469_8 -> bv
        let s_2469_9: Bits = Bits::new(s_2469_8 as u128, 1u16);
        // C s_2469_10: const #0u : u8
        let s_2469_10: bool = false;
        // C s_2469_11: cast zx s_2469_10 -> bv
        let s_2469_11: Bits = Bits::new(s_2469_10 as u128, 1u16);
        // D s_2469_12: cmp-eq s_2469_9 s_2469_11
        let s_2469_12: bool = ((s_2469_9) == (s_2469_11));
        // D s_2469_13: write-var gs#400457 <= s_2469_12
        fn_state.gs_400457 = s_2469_12;
        // N s_2469_14: jump b2468
        return block_2468(state, tracer, fn_state);
    }
    fn block_2470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2470_0: const #3566s : i
        let s_2470_0: i128 = 3566;
        // C s_2470_1: const #14696u : u32
        let s_2470_1: u32 = 14696;
        // D s_2470_2: read-reg s_2470_1:i
        let s_2470_2: i128 = {
            let value = state.read_register::<i128>(s_2470_1 as isize);
            tracer.read_register(s_2470_1 as isize, value);
            value
        };
        // D s_2470_3: cmp-lt s_2470_2 s_2470_0
        let s_2470_3: bool = ((s_2470_2) < (s_2470_0));
        // D s_2470_4: write-var gs#400429 <= s_2470_3
        fn_state.gs_400429 = s_2470_3;
        // N s_2470_5: jump b785
        return block_785(state, tracer, fn_state);
    }
    fn block_2471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2471_0: const #23s : i
        let s_2471_0: i128 = 23;
        // D s_2471_1: read-var u#31344:u32
        let s_2471_1: u32 = fn_state.u_31344;
        // D s_2471_2: cast zx s_2471_1 -> bv
        let s_2471_2: Bits = Bits::new(s_2471_1 as u128, 32u16);
        // C s_2471_3: const #1s : i64
        let s_2471_3: i64 = 1;
        // C s_2471_4: cast zx s_2471_3 -> i
        let s_2471_4: i128 = (i128::try_from(s_2471_3).unwrap());
        // C s_2471_5: const #0s : i
        let s_2471_5: i128 = 0;
        // C s_2471_6: add s_2471_5 s_2471_4
        let s_2471_6: i128 = (s_2471_5 + s_2471_4);
        // D s_2471_7: bit-extract s_2471_2 s_2471_0 s_2471_6
        let s_2471_7: Bits = (Bits::new(
            ((s_2471_2) >> (s_2471_0)).value(),
            u16::try_from(s_2471_6).unwrap(),
        ));
        // D s_2471_8: cast reint s_2471_7 -> u8
        let s_2471_8: bool = ((s_2471_7.value()) != 0);
        // D s_2471_9: cast zx s_2471_8 -> bv
        let s_2471_9: Bits = Bits::new(s_2471_8 as u128, 1u16);
        // C s_2471_10: const #1u : u8
        let s_2471_10: bool = true;
        // C s_2471_11: cast zx s_2471_10 -> bv
        let s_2471_11: Bits = Bits::new(s_2471_10 as u128, 1u16);
        // D s_2471_12: cmp-eq s_2471_9 s_2471_11
        let s_2471_12: bool = ((s_2471_9) == (s_2471_11));
        // N s_2471_13: branch s_2471_12 b2474 b2472
        if s_2471_12 {
            return block_2474(state, tracer, fn_state);
        } else {
            return block_2472(state, tracer, fn_state);
        };
    }
    fn block_2472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2472_0: const #0u : u8
        let s_2472_0: bool = false;
        // D s_2472_1: write-var gs#400426 <= s_2472_0
        fn_state.gs_400426 = s_2472_0;
        // N s_2472_2: jump b2473
        return block_2473(state, tracer, fn_state);
    }
    fn block_2473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2473_0: read-var gs#400426:u8
        let s_2473_0: bool = fn_state.gs_400426;
        // D s_2473_1: write-var gs#400427 <= s_2473_0
        fn_state.gs_400427 = s_2473_0;
        // N s_2473_2: jump b783
        return block_783(state, tracer, fn_state);
    }
    fn block_2474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2474_0: const #19s : i
        let s_2474_0: i128 = 19;
        // D s_2474_1: read-var u#31344:u32
        let s_2474_1: u32 = fn_state.u_31344;
        // D s_2474_2: cast zx s_2474_1 -> bv
        let s_2474_2: Bits = Bits::new(s_2474_1 as u128, 32u16);
        // C s_2474_3: const #1s : i64
        let s_2474_3: i64 = 1;
        // C s_2474_4: cast zx s_2474_3 -> i
        let s_2474_4: i128 = (i128::try_from(s_2474_3).unwrap());
        // C s_2474_5: const #2s : i
        let s_2474_5: i128 = 2;
        // C s_2474_6: add s_2474_5 s_2474_4
        let s_2474_6: i128 = (s_2474_5 + s_2474_4);
        // D s_2474_7: bit-extract s_2474_2 s_2474_0 s_2474_6
        let s_2474_7: Bits = (Bits::new(
            ((s_2474_2) >> (s_2474_0)).value(),
            u16::try_from(s_2474_6).unwrap(),
        ));
        // D s_2474_8: cast reint s_2474_7 -> u8
        let s_2474_8: u8 = (s_2474_7.value() as u8);
        // D s_2474_9: cast zx s_2474_8 -> bv
        let s_2474_9: Bits = Bits::new(s_2474_8 as u128, 3u16);
        // C s_2474_10: const #0u : u8
        let s_2474_10: u8 = 0;
        // C s_2474_11: cast zx s_2474_10 -> bv
        let s_2474_11: Bits = Bits::new(s_2474_10 as u128, 3u16);
        // D s_2474_12: cmp-eq s_2474_9 s_2474_11
        let s_2474_12: bool = ((s_2474_9) == (s_2474_11));
        // N s_2474_13: branch s_2474_12 b2477 b2475
        if s_2474_12 {
            return block_2477(state, tracer, fn_state);
        } else {
            return block_2475(state, tracer, fn_state);
        };
    }
    fn block_2475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2475_0: const #0u : u8
        let s_2475_0: bool = false;
        // D s_2475_1: write-var gs#400425 <= s_2475_0
        fn_state.gs_400425 = s_2475_0;
        // N s_2475_2: jump b2476
        return block_2476(state, tracer, fn_state);
    }
    fn block_2476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2476_0: read-var gs#400425:u8
        let s_2476_0: bool = fn_state.gs_400425;
        // D s_2476_1: write-var gs#400426 <= s_2476_0
        fn_state.gs_400426 = s_2476_0;
        // N s_2476_2: jump b2473
        return block_2473(state, tracer, fn_state);
    }
    fn block_2477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2477_0: const #9s : i
        let s_2477_0: i128 = 9;
        // D s_2477_1: read-var u#31344:u32
        let s_2477_1: u32 = fn_state.u_31344;
        // D s_2477_2: cast zx s_2477_1 -> bv
        let s_2477_2: Bits = Bits::new(s_2477_1 as u128, 32u16);
        // C s_2477_3: const #1s : i64
        let s_2477_3: i64 = 1;
        // C s_2477_4: cast zx s_2477_3 -> i
        let s_2477_4: i128 = (i128::try_from(s_2477_3).unwrap());
        // C s_2477_5: const #2s : i
        let s_2477_5: i128 = 2;
        // C s_2477_6: add s_2477_5 s_2477_4
        let s_2477_6: i128 = (s_2477_5 + s_2477_4);
        // D s_2477_7: bit-extract s_2477_2 s_2477_0 s_2477_6
        let s_2477_7: Bits = (Bits::new(
            ((s_2477_2) >> (s_2477_0)).value(),
            u16::try_from(s_2477_6).unwrap(),
        ));
        // D s_2477_8: cast reint s_2477_7 -> u8
        let s_2477_8: u8 = (s_2477_7.value() as u8);
        // D s_2477_9: cast zx s_2477_8 -> bv
        let s_2477_9: Bits = Bits::new(s_2477_8 as u128, 3u16);
        // C s_2477_10: const #6u : u8
        let s_2477_10: u8 = 6;
        // C s_2477_11: cast zx s_2477_10 -> bv
        let s_2477_11: Bits = Bits::new(s_2477_10 as u128, 3u16);
        // D s_2477_12: cmp-eq s_2477_9 s_2477_11
        let s_2477_12: bool = ((s_2477_9) == (s_2477_11));
        // N s_2477_13: branch s_2477_12 b2480 b2478
        if s_2477_12 {
            return block_2480(state, tracer, fn_state);
        } else {
            return block_2478(state, tracer, fn_state);
        };
    }
    fn block_2478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2478_0: const #0u : u8
        let s_2478_0: bool = false;
        // D s_2478_1: write-var gs#400424 <= s_2478_0
        fn_state.gs_400424 = s_2478_0;
        // N s_2478_2: jump b2479
        return block_2479(state, tracer, fn_state);
    }
    fn block_2479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2479_0: read-var gs#400424:u8
        let s_2479_0: bool = fn_state.gs_400424;
        // D s_2479_1: write-var gs#400425 <= s_2479_0
        fn_state.gs_400425 = s_2479_0;
        // N s_2479_2: jump b2476
        return block_2476(state, tracer, fn_state);
    }
    fn block_2480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2480_0: const #7s : i
        let s_2480_0: i128 = 7;
        // D s_2480_1: read-var u#31344:u32
        let s_2480_1: u32 = fn_state.u_31344;
        // D s_2480_2: cast zx s_2480_1 -> bv
        let s_2480_2: Bits = Bits::new(s_2480_1 as u128, 32u16);
        // C s_2480_3: const #1s : i64
        let s_2480_3: i64 = 1;
        // C s_2480_4: cast zx s_2480_3 -> i
        let s_2480_4: i128 = (i128::try_from(s_2480_3).unwrap());
        // C s_2480_5: const #0s : i
        let s_2480_5: i128 = 0;
        // C s_2480_6: add s_2480_5 s_2480_4
        let s_2480_6: i128 = (s_2480_5 + s_2480_4);
        // D s_2480_7: bit-extract s_2480_2 s_2480_0 s_2480_6
        let s_2480_7: Bits = (Bits::new(
            ((s_2480_2) >> (s_2480_0)).value(),
            u16::try_from(s_2480_6).unwrap(),
        ));
        // D s_2480_8: cast reint s_2480_7 -> u8
        let s_2480_8: bool = ((s_2480_7.value()) != 0);
        // D s_2480_9: cast zx s_2480_8 -> bv
        let s_2480_9: Bits = Bits::new(s_2480_8 as u128, 1u16);
        // C s_2480_10: const #0u : u8
        let s_2480_10: bool = false;
        // C s_2480_11: cast zx s_2480_10 -> bv
        let s_2480_11: Bits = Bits::new(s_2480_10 as u128, 1u16);
        // D s_2480_12: cmp-eq s_2480_9 s_2480_11
        let s_2480_12: bool = ((s_2480_9) == (s_2480_11));
        // N s_2480_13: branch s_2480_12 b2483 b2481
        if s_2480_12 {
            return block_2483(state, tracer, fn_state);
        } else {
            return block_2481(state, tracer, fn_state);
        };
    }
    fn block_2481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2481_0: const #0u : u8
        let s_2481_0: bool = false;
        // D s_2481_1: write-var gs#400423 <= s_2481_0
        fn_state.gs_400423 = s_2481_0;
        // N s_2481_2: jump b2482
        return block_2482(state, tracer, fn_state);
    }
    fn block_2482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2482_0: read-var gs#400423:u8
        let s_2482_0: bool = fn_state.gs_400423;
        // D s_2482_1: write-var gs#400424 <= s_2482_0
        fn_state.gs_400424 = s_2482_0;
        // N s_2482_2: jump b2479
        return block_2479(state, tracer, fn_state);
    }
    fn block_2483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2483_0: const #4s : i
        let s_2483_0: i128 = 4;
        // D s_2483_1: read-var u#31344:u32
        let s_2483_1: u32 = fn_state.u_31344;
        // D s_2483_2: cast zx s_2483_1 -> bv
        let s_2483_2: Bits = Bits::new(s_2483_1 as u128, 32u16);
        // C s_2483_3: const #1s : i64
        let s_2483_3: i64 = 1;
        // C s_2483_4: cast zx s_2483_3 -> i
        let s_2483_4: i128 = (i128::try_from(s_2483_3).unwrap());
        // C s_2483_5: const #1s : i
        let s_2483_5: i128 = 1;
        // C s_2483_6: add s_2483_5 s_2483_4
        let s_2483_6: i128 = (s_2483_5 + s_2483_4);
        // D s_2483_7: bit-extract s_2483_2 s_2483_0 s_2483_6
        let s_2483_7: Bits = (Bits::new(
            ((s_2483_2) >> (s_2483_0)).value(),
            u16::try_from(s_2483_6).unwrap(),
        ));
        // D s_2483_8: cast reint s_2483_7 -> u8
        let s_2483_8: u8 = (s_2483_7.value() as u8);
        // D s_2483_9: cast zx s_2483_8 -> bv
        let s_2483_9: Bits = Bits::new(s_2483_8 as u128, 2u16);
        // C s_2483_10: const #3u : u8
        let s_2483_10: u8 = 3;
        // C s_2483_11: cast zx s_2483_10 -> bv
        let s_2483_11: Bits = Bits::new(s_2483_10 as u128, 2u16);
        // D s_2483_12: cmp-eq s_2483_9 s_2483_11
        let s_2483_12: bool = ((s_2483_9) == (s_2483_11));
        // D s_2483_13: write-var gs#400423 <= s_2483_12
        fn_state.gs_400423 = s_2483_12;
        // N s_2483_14: jump b2482
        return block_2482(state, tracer, fn_state);
    }
    fn block_2484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2484_0: const #3565s : i
        let s_2484_0: i128 = 3565;
        // C s_2484_1: const #14696u : u32
        let s_2484_1: u32 = 14696;
        // D s_2484_2: read-reg s_2484_1:i
        let s_2484_2: i128 = {
            let value = state.read_register::<i128>(s_2484_1 as isize);
            tracer.read_register(s_2484_1 as isize, value);
            value
        };
        // D s_2484_3: cmp-lt s_2484_2 s_2484_0
        let s_2484_3: bool = ((s_2484_2) < (s_2484_0));
        // D s_2484_4: write-var gs#400393 <= s_2484_3
        fn_state.gs_400393 = s_2484_3;
        // N s_2484_5: jump b779
        return block_779(state, tracer, fn_state);
    }
    fn block_2485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2485_0: const #23s : i
        let s_2485_0: i128 = 23;
        // D s_2485_1: read-var u#31335:u32
        let s_2485_1: u32 = fn_state.u_31335;
        // D s_2485_2: cast zx s_2485_1 -> bv
        let s_2485_2: Bits = Bits::new(s_2485_1 as u128, 32u16);
        // C s_2485_3: const #1s : i64
        let s_2485_3: i64 = 1;
        // C s_2485_4: cast zx s_2485_3 -> i
        let s_2485_4: i128 = (i128::try_from(s_2485_3).unwrap());
        // C s_2485_5: const #0s : i
        let s_2485_5: i128 = 0;
        // C s_2485_6: add s_2485_5 s_2485_4
        let s_2485_6: i128 = (s_2485_5 + s_2485_4);
        // D s_2485_7: bit-extract s_2485_2 s_2485_0 s_2485_6
        let s_2485_7: Bits = (Bits::new(
            ((s_2485_2) >> (s_2485_0)).value(),
            u16::try_from(s_2485_6).unwrap(),
        ));
        // D s_2485_8: cast reint s_2485_7 -> u8
        let s_2485_8: bool = ((s_2485_7.value()) != 0);
        // D s_2485_9: cast zx s_2485_8 -> bv
        let s_2485_9: Bits = Bits::new(s_2485_8 as u128, 1u16);
        // C s_2485_10: const #1u : u8
        let s_2485_10: bool = true;
        // C s_2485_11: cast zx s_2485_10 -> bv
        let s_2485_11: Bits = Bits::new(s_2485_10 as u128, 1u16);
        // D s_2485_12: cmp-eq s_2485_9 s_2485_11
        let s_2485_12: bool = ((s_2485_9) == (s_2485_11));
        // N s_2485_13: branch s_2485_12 b2488 b2486
        if s_2485_12 {
            return block_2488(state, tracer, fn_state);
        } else {
            return block_2486(state, tracer, fn_state);
        };
    }
    fn block_2486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2486_0: const #0u : u8
        let s_2486_0: bool = false;
        // D s_2486_1: write-var gs#400390 <= s_2486_0
        fn_state.gs_400390 = s_2486_0;
        // N s_2486_2: jump b2487
        return block_2487(state, tracer, fn_state);
    }
    fn block_2487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2487_0: read-var gs#400390:u8
        let s_2487_0: bool = fn_state.gs_400390;
        // D s_2487_1: write-var gs#400391 <= s_2487_0
        fn_state.gs_400391 = s_2487_0;
        // N s_2487_2: jump b777
        return block_777(state, tracer, fn_state);
    }
    fn block_2488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2488_0: const #19s : i
        let s_2488_0: i128 = 19;
        // D s_2488_1: read-var u#31335:u32
        let s_2488_1: u32 = fn_state.u_31335;
        // D s_2488_2: cast zx s_2488_1 -> bv
        let s_2488_2: Bits = Bits::new(s_2488_1 as u128, 32u16);
        // C s_2488_3: const #1s : i64
        let s_2488_3: i64 = 1;
        // C s_2488_4: cast zx s_2488_3 -> i
        let s_2488_4: i128 = (i128::try_from(s_2488_3).unwrap());
        // C s_2488_5: const #2s : i
        let s_2488_5: i128 = 2;
        // C s_2488_6: add s_2488_5 s_2488_4
        let s_2488_6: i128 = (s_2488_5 + s_2488_4);
        // D s_2488_7: bit-extract s_2488_2 s_2488_0 s_2488_6
        let s_2488_7: Bits = (Bits::new(
            ((s_2488_2) >> (s_2488_0)).value(),
            u16::try_from(s_2488_6).unwrap(),
        ));
        // D s_2488_8: cast reint s_2488_7 -> u8
        let s_2488_8: u8 = (s_2488_7.value() as u8);
        // D s_2488_9: cast zx s_2488_8 -> bv
        let s_2488_9: Bits = Bits::new(s_2488_8 as u128, 3u16);
        // C s_2488_10: const #0u : u8
        let s_2488_10: u8 = 0;
        // C s_2488_11: cast zx s_2488_10 -> bv
        let s_2488_11: Bits = Bits::new(s_2488_10 as u128, 3u16);
        // D s_2488_12: cmp-eq s_2488_9 s_2488_11
        let s_2488_12: bool = ((s_2488_9) == (s_2488_11));
        // N s_2488_13: branch s_2488_12 b2491 b2489
        if s_2488_12 {
            return block_2491(state, tracer, fn_state);
        } else {
            return block_2489(state, tracer, fn_state);
        };
    }
    fn block_2489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2489_0: const #0u : u8
        let s_2489_0: bool = false;
        // D s_2489_1: write-var gs#400389 <= s_2489_0
        fn_state.gs_400389 = s_2489_0;
        // N s_2489_2: jump b2490
        return block_2490(state, tracer, fn_state);
    }
    fn block_2490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2490_0: read-var gs#400389:u8
        let s_2490_0: bool = fn_state.gs_400389;
        // D s_2490_1: write-var gs#400390 <= s_2490_0
        fn_state.gs_400390 = s_2490_0;
        // N s_2490_2: jump b2487
        return block_2487(state, tracer, fn_state);
    }
    fn block_2491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2491_0: const #10s : i
        let s_2491_0: i128 = 10;
        // D s_2491_1: read-var u#31335:u32
        let s_2491_1: u32 = fn_state.u_31335;
        // D s_2491_2: cast zx s_2491_1 -> bv
        let s_2491_2: Bits = Bits::new(s_2491_1 as u128, 32u16);
        // C s_2491_3: const #1s : i64
        let s_2491_3: i64 = 1;
        // C s_2491_4: cast zx s_2491_3 -> i
        let s_2491_4: i128 = (i128::try_from(s_2491_3).unwrap());
        // C s_2491_5: const #1s : i
        let s_2491_5: i128 = 1;
        // C s_2491_6: add s_2491_5 s_2491_4
        let s_2491_6: i128 = (s_2491_5 + s_2491_4);
        // D s_2491_7: bit-extract s_2491_2 s_2491_0 s_2491_6
        let s_2491_7: Bits = (Bits::new(
            ((s_2491_2) >> (s_2491_0)).value(),
            u16::try_from(s_2491_6).unwrap(),
        ));
        // D s_2491_8: cast reint s_2491_7 -> u8
        let s_2491_8: u8 = (s_2491_7.value() as u8);
        // D s_2491_9: cast zx s_2491_8 -> bv
        let s_2491_9: Bits = Bits::new(s_2491_8 as u128, 2u16);
        // C s_2491_10: const #2u : u8
        let s_2491_10: u8 = 2;
        // C s_2491_11: cast zx s_2491_10 -> bv
        let s_2491_11: Bits = Bits::new(s_2491_10 as u128, 2u16);
        // D s_2491_12: cmp-eq s_2491_9 s_2491_11
        let s_2491_12: bool = ((s_2491_9) == (s_2491_11));
        // N s_2491_13: branch s_2491_12 b2494 b2492
        if s_2491_12 {
            return block_2494(state, tracer, fn_state);
        } else {
            return block_2492(state, tracer, fn_state);
        };
    }
    fn block_2492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2492_0: const #0u : u8
        let s_2492_0: bool = false;
        // D s_2492_1: write-var gs#400388 <= s_2492_0
        fn_state.gs_400388 = s_2492_0;
        // N s_2492_2: jump b2493
        return block_2493(state, tracer, fn_state);
    }
    fn block_2493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2493_0: read-var gs#400388:u8
        let s_2493_0: bool = fn_state.gs_400388;
        // D s_2493_1: write-var gs#400389 <= s_2493_0
        fn_state.gs_400389 = s_2493_0;
        // N s_2493_2: jump b2490
        return block_2490(state, tracer, fn_state);
    }
    fn block_2494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2494_0: const #7s : i
        let s_2494_0: i128 = 7;
        // D s_2494_1: read-var u#31335:u32
        let s_2494_1: u32 = fn_state.u_31335;
        // D s_2494_2: cast zx s_2494_1 -> bv
        let s_2494_2: Bits = Bits::new(s_2494_1 as u128, 32u16);
        // C s_2494_3: const #1s : i64
        let s_2494_3: i64 = 1;
        // C s_2494_4: cast zx s_2494_3 -> i
        let s_2494_4: i128 = (i128::try_from(s_2494_3).unwrap());
        // C s_2494_5: const #1s : i
        let s_2494_5: i128 = 1;
        // C s_2494_6: add s_2494_5 s_2494_4
        let s_2494_6: i128 = (s_2494_5 + s_2494_4);
        // D s_2494_7: bit-extract s_2494_2 s_2494_0 s_2494_6
        let s_2494_7: Bits = (Bits::new(
            ((s_2494_2) >> (s_2494_0)).value(),
            u16::try_from(s_2494_6).unwrap(),
        ));
        // D s_2494_8: cast reint s_2494_7 -> u8
        let s_2494_8: u8 = (s_2494_7.value() as u8);
        // D s_2494_9: cast zx s_2494_8 -> bv
        let s_2494_9: Bits = Bits::new(s_2494_8 as u128, 2u16);
        // C s_2494_10: const #0u : u8
        let s_2494_10: u8 = 0;
        // C s_2494_11: cast zx s_2494_10 -> bv
        let s_2494_11: Bits = Bits::new(s_2494_10 as u128, 2u16);
        // D s_2494_12: cmp-eq s_2494_9 s_2494_11
        let s_2494_12: bool = ((s_2494_9) == (s_2494_11));
        // N s_2494_13: branch s_2494_12 b2497 b2495
        if s_2494_12 {
            return block_2497(state, tracer, fn_state);
        } else {
            return block_2495(state, tracer, fn_state);
        };
    }
    fn block_2495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2495_0: const #0u : u8
        let s_2495_0: bool = false;
        // D s_2495_1: write-var gs#400387 <= s_2495_0
        fn_state.gs_400387 = s_2495_0;
        // N s_2495_2: jump b2496
        return block_2496(state, tracer, fn_state);
    }
    fn block_2496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2496_0: read-var gs#400387:u8
        let s_2496_0: bool = fn_state.gs_400387;
        // D s_2496_1: write-var gs#400388 <= s_2496_0
        fn_state.gs_400388 = s_2496_0;
        // N s_2496_2: jump b2493
        return block_2493(state, tracer, fn_state);
    }
    fn block_2497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2497_0: const #4s : i
        let s_2497_0: i128 = 4;
        // D s_2497_1: read-var u#31335:u32
        let s_2497_1: u32 = fn_state.u_31335;
        // D s_2497_2: cast zx s_2497_1 -> bv
        let s_2497_2: Bits = Bits::new(s_2497_1 as u128, 32u16);
        // C s_2497_3: const #1s : i64
        let s_2497_3: i64 = 1;
        // C s_2497_4: cast zx s_2497_3 -> i
        let s_2497_4: i128 = (i128::try_from(s_2497_3).unwrap());
        // C s_2497_5: const #1s : i
        let s_2497_5: i128 = 1;
        // C s_2497_6: add s_2497_5 s_2497_4
        let s_2497_6: i128 = (s_2497_5 + s_2497_4);
        // D s_2497_7: bit-extract s_2497_2 s_2497_0 s_2497_6
        let s_2497_7: Bits = (Bits::new(
            ((s_2497_2) >> (s_2497_0)).value(),
            u16::try_from(s_2497_6).unwrap(),
        ));
        // D s_2497_8: cast reint s_2497_7 -> u8
        let s_2497_8: u8 = (s_2497_7.value() as u8);
        // D s_2497_9: cast zx s_2497_8 -> bv
        let s_2497_9: Bits = Bits::new(s_2497_8 as u128, 2u16);
        // C s_2497_10: const #3u : u8
        let s_2497_10: u8 = 3;
        // C s_2497_11: cast zx s_2497_10 -> bv
        let s_2497_11: Bits = Bits::new(s_2497_10 as u128, 2u16);
        // D s_2497_12: cmp-eq s_2497_9 s_2497_11
        let s_2497_12: bool = ((s_2497_9) == (s_2497_11));
        // D s_2497_13: write-var gs#400387 <= s_2497_12
        fn_state.gs_400387 = s_2497_12;
        // N s_2497_14: jump b2496
        return block_2496(state, tracer, fn_state);
    }
    fn block_2498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2498_0: const #3564s : i
        let s_2498_0: i128 = 3564;
        // C s_2498_1: const #14696u : u32
        let s_2498_1: u32 = 14696;
        // D s_2498_2: read-reg s_2498_1:i
        let s_2498_2: i128 = {
            let value = state.read_register::<i128>(s_2498_1 as isize);
            tracer.read_register(s_2498_1 as isize, value);
            value
        };
        // D s_2498_3: cmp-lt s_2498_2 s_2498_0
        let s_2498_3: bool = ((s_2498_2) < (s_2498_0));
        // D s_2498_4: write-var gs#400357 <= s_2498_3
        fn_state.gs_400357 = s_2498_3;
        // N s_2498_5: jump b773
        return block_773(state, tracer, fn_state);
    }
    fn block_2499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2499_0: const #23s : i
        let s_2499_0: i128 = 23;
        // D s_2499_1: read-var u#31326:u32
        let s_2499_1: u32 = fn_state.u_31326;
        // D s_2499_2: cast zx s_2499_1 -> bv
        let s_2499_2: Bits = Bits::new(s_2499_1 as u128, 32u16);
        // C s_2499_3: const #1s : i64
        let s_2499_3: i64 = 1;
        // C s_2499_4: cast zx s_2499_3 -> i
        let s_2499_4: i128 = (i128::try_from(s_2499_3).unwrap());
        // C s_2499_5: const #0s : i
        let s_2499_5: i128 = 0;
        // C s_2499_6: add s_2499_5 s_2499_4
        let s_2499_6: i128 = (s_2499_5 + s_2499_4);
        // D s_2499_7: bit-extract s_2499_2 s_2499_0 s_2499_6
        let s_2499_7: Bits = (Bits::new(
            ((s_2499_2) >> (s_2499_0)).value(),
            u16::try_from(s_2499_6).unwrap(),
        ));
        // D s_2499_8: cast reint s_2499_7 -> u8
        let s_2499_8: bool = ((s_2499_7.value()) != 0);
        // D s_2499_9: cast zx s_2499_8 -> bv
        let s_2499_9: Bits = Bits::new(s_2499_8 as u128, 1u16);
        // C s_2499_10: const #1u : u8
        let s_2499_10: bool = true;
        // C s_2499_11: cast zx s_2499_10 -> bv
        let s_2499_11: Bits = Bits::new(s_2499_10 as u128, 1u16);
        // D s_2499_12: cmp-eq s_2499_9 s_2499_11
        let s_2499_12: bool = ((s_2499_9) == (s_2499_11));
        // N s_2499_13: branch s_2499_12 b2502 b2500
        if s_2499_12 {
            return block_2502(state, tracer, fn_state);
        } else {
            return block_2500(state, tracer, fn_state);
        };
    }
    fn block_2500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2500_0: const #0u : u8
        let s_2500_0: bool = false;
        // D s_2500_1: write-var gs#400354 <= s_2500_0
        fn_state.gs_400354 = s_2500_0;
        // N s_2500_2: jump b2501
        return block_2501(state, tracer, fn_state);
    }
    fn block_2501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2501_0: read-var gs#400354:u8
        let s_2501_0: bool = fn_state.gs_400354;
        // D s_2501_1: write-var gs#400355 <= s_2501_0
        fn_state.gs_400355 = s_2501_0;
        // N s_2501_2: jump b771
        return block_771(state, tracer, fn_state);
    }
    fn block_2502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2502_0: const #19s : i
        let s_2502_0: i128 = 19;
        // D s_2502_1: read-var u#31326:u32
        let s_2502_1: u32 = fn_state.u_31326;
        // D s_2502_2: cast zx s_2502_1 -> bv
        let s_2502_2: Bits = Bits::new(s_2502_1 as u128, 32u16);
        // C s_2502_3: const #1s : i64
        let s_2502_3: i64 = 1;
        // C s_2502_4: cast zx s_2502_3 -> i
        let s_2502_4: i128 = (i128::try_from(s_2502_3).unwrap());
        // C s_2502_5: const #2s : i
        let s_2502_5: i128 = 2;
        // C s_2502_6: add s_2502_5 s_2502_4
        let s_2502_6: i128 = (s_2502_5 + s_2502_4);
        // D s_2502_7: bit-extract s_2502_2 s_2502_0 s_2502_6
        let s_2502_7: Bits = (Bits::new(
            ((s_2502_2) >> (s_2502_0)).value(),
            u16::try_from(s_2502_6).unwrap(),
        ));
        // D s_2502_8: cast reint s_2502_7 -> u8
        let s_2502_8: u8 = (s_2502_7.value() as u8);
        // D s_2502_9: cast zx s_2502_8 -> bv
        let s_2502_9: Bits = Bits::new(s_2502_8 as u128, 3u16);
        // C s_2502_10: const #0u : u8
        let s_2502_10: u8 = 0;
        // C s_2502_11: cast zx s_2502_10 -> bv
        let s_2502_11: Bits = Bits::new(s_2502_10 as u128, 3u16);
        // D s_2502_12: cmp-eq s_2502_9 s_2502_11
        let s_2502_12: bool = ((s_2502_9) == (s_2502_11));
        // N s_2502_13: branch s_2502_12 b2505 b2503
        if s_2502_12 {
            return block_2505(state, tracer, fn_state);
        } else {
            return block_2503(state, tracer, fn_state);
        };
    }
    fn block_2503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2503_0: const #0u : u8
        let s_2503_0: bool = false;
        // D s_2503_1: write-var gs#400353 <= s_2503_0
        fn_state.gs_400353 = s_2503_0;
        // N s_2503_2: jump b2504
        return block_2504(state, tracer, fn_state);
    }
    fn block_2504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2504_0: read-var gs#400353:u8
        let s_2504_0: bool = fn_state.gs_400353;
        // D s_2504_1: write-var gs#400354 <= s_2504_0
        fn_state.gs_400354 = s_2504_0;
        // N s_2504_2: jump b2501
        return block_2501(state, tracer, fn_state);
    }
    fn block_2505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2505_0: const #11s : i
        let s_2505_0: i128 = 11;
        // D s_2505_1: read-var u#31326:u32
        let s_2505_1: u32 = fn_state.u_31326;
        // D s_2505_2: cast zx s_2505_1 -> bv
        let s_2505_2: Bits = Bits::new(s_2505_1 as u128, 32u16);
        // C s_2505_3: const #1s : i64
        let s_2505_3: i64 = 1;
        // C s_2505_4: cast zx s_2505_3 -> i
        let s_2505_4: i128 = (i128::try_from(s_2505_3).unwrap());
        // C s_2505_5: const #0s : i
        let s_2505_5: i128 = 0;
        // C s_2505_6: add s_2505_5 s_2505_4
        let s_2505_6: i128 = (s_2505_5 + s_2505_4);
        // D s_2505_7: bit-extract s_2505_2 s_2505_0 s_2505_6
        let s_2505_7: Bits = (Bits::new(
            ((s_2505_2) >> (s_2505_0)).value(),
            u16::try_from(s_2505_6).unwrap(),
        ));
        // D s_2505_8: cast reint s_2505_7 -> u8
        let s_2505_8: bool = ((s_2505_7.value()) != 0);
        // D s_2505_9: cast zx s_2505_8 -> bv
        let s_2505_9: Bits = Bits::new(s_2505_8 as u128, 1u16);
        // C s_2505_10: const #0u : u8
        let s_2505_10: bool = false;
        // C s_2505_11: cast zx s_2505_10 -> bv
        let s_2505_11: Bits = Bits::new(s_2505_10 as u128, 1u16);
        // D s_2505_12: cmp-eq s_2505_9 s_2505_11
        let s_2505_12: bool = ((s_2505_9) == (s_2505_11));
        // N s_2505_13: branch s_2505_12 b2508 b2506
        if s_2505_12 {
            return block_2508(state, tracer, fn_state);
        } else {
            return block_2506(state, tracer, fn_state);
        };
    }
    fn block_2506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2506_0: const #0u : u8
        let s_2506_0: bool = false;
        // D s_2506_1: write-var gs#400352 <= s_2506_0
        fn_state.gs_400352 = s_2506_0;
        // N s_2506_2: jump b2507
        return block_2507(state, tracer, fn_state);
    }
    fn block_2507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2507_0: read-var gs#400352:u8
        let s_2507_0: bool = fn_state.gs_400352;
        // D s_2507_1: write-var gs#400353 <= s_2507_0
        fn_state.gs_400353 = s_2507_0;
        // N s_2507_2: jump b2504
        return block_2504(state, tracer, fn_state);
    }
    fn block_2508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2508_0: const #7s : i
        let s_2508_0: i128 = 7;
        // D s_2508_1: read-var u#31326:u32
        let s_2508_1: u32 = fn_state.u_31326;
        // D s_2508_2: cast zx s_2508_1 -> bv
        let s_2508_2: Bits = Bits::new(s_2508_1 as u128, 32u16);
        // C s_2508_3: const #1s : i64
        let s_2508_3: i64 = 1;
        // C s_2508_4: cast zx s_2508_3 -> i
        let s_2508_4: i128 = (i128::try_from(s_2508_3).unwrap());
        // C s_2508_5: const #1s : i
        let s_2508_5: i128 = 1;
        // C s_2508_6: add s_2508_5 s_2508_4
        let s_2508_6: i128 = (s_2508_5 + s_2508_4);
        // D s_2508_7: bit-extract s_2508_2 s_2508_0 s_2508_6
        let s_2508_7: Bits = (Bits::new(
            ((s_2508_2) >> (s_2508_0)).value(),
            u16::try_from(s_2508_6).unwrap(),
        ));
        // D s_2508_8: cast reint s_2508_7 -> u8
        let s_2508_8: u8 = (s_2508_7.value() as u8);
        // D s_2508_9: cast zx s_2508_8 -> bv
        let s_2508_9: Bits = Bits::new(s_2508_8 as u128, 2u16);
        // C s_2508_10: const #0u : u8
        let s_2508_10: u8 = 0;
        // C s_2508_11: cast zx s_2508_10 -> bv
        let s_2508_11: Bits = Bits::new(s_2508_10 as u128, 2u16);
        // D s_2508_12: cmp-eq s_2508_9 s_2508_11
        let s_2508_12: bool = ((s_2508_9) == (s_2508_11));
        // N s_2508_13: branch s_2508_12 b2511 b2509
        if s_2508_12 {
            return block_2511(state, tracer, fn_state);
        } else {
            return block_2509(state, tracer, fn_state);
        };
    }
    fn block_2509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2509_0: const #0u : u8
        let s_2509_0: bool = false;
        // D s_2509_1: write-var gs#400351 <= s_2509_0
        fn_state.gs_400351 = s_2509_0;
        // N s_2509_2: jump b2510
        return block_2510(state, tracer, fn_state);
    }
    fn block_2510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2510_0: read-var gs#400351:u8
        let s_2510_0: bool = fn_state.gs_400351;
        // D s_2510_1: write-var gs#400352 <= s_2510_0
        fn_state.gs_400352 = s_2510_0;
        // N s_2510_2: jump b2507
        return block_2507(state, tracer, fn_state);
    }
    fn block_2511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2511_0: const #4s : i
        let s_2511_0: i128 = 4;
        // D s_2511_1: read-var u#31326:u32
        let s_2511_1: u32 = fn_state.u_31326;
        // D s_2511_2: cast zx s_2511_1 -> bv
        let s_2511_2: Bits = Bits::new(s_2511_1 as u128, 32u16);
        // C s_2511_3: const #1s : i64
        let s_2511_3: i64 = 1;
        // C s_2511_4: cast zx s_2511_3 -> i
        let s_2511_4: i128 = (i128::try_from(s_2511_3).unwrap());
        // C s_2511_5: const #1s : i
        let s_2511_5: i128 = 1;
        // C s_2511_6: add s_2511_5 s_2511_4
        let s_2511_6: i128 = (s_2511_5 + s_2511_4);
        // D s_2511_7: bit-extract s_2511_2 s_2511_0 s_2511_6
        let s_2511_7: Bits = (Bits::new(
            ((s_2511_2) >> (s_2511_0)).value(),
            u16::try_from(s_2511_6).unwrap(),
        ));
        // D s_2511_8: cast reint s_2511_7 -> u8
        let s_2511_8: u8 = (s_2511_7.value() as u8);
        // D s_2511_9: cast zx s_2511_8 -> bv
        let s_2511_9: Bits = Bits::new(s_2511_8 as u128, 2u16);
        // C s_2511_10: const #3u : u8
        let s_2511_10: u8 = 3;
        // C s_2511_11: cast zx s_2511_10 -> bv
        let s_2511_11: Bits = Bits::new(s_2511_10 as u128, 2u16);
        // D s_2511_12: cmp-eq s_2511_9 s_2511_11
        let s_2511_12: bool = ((s_2511_9) == (s_2511_11));
        // D s_2511_13: write-var gs#400351 <= s_2511_12
        fn_state.gs_400351 = s_2511_12;
        // N s_2511_14: jump b2510
        return block_2510(state, tracer, fn_state);
    }
    fn block_2512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2512_0: const #3561s : i
        let s_2512_0: i128 = 3561;
        // C s_2512_1: const #14696u : u32
        let s_2512_1: u32 = 14696;
        // D s_2512_2: read-reg s_2512_1:i
        let s_2512_2: i128 = {
            let value = state.read_register::<i128>(s_2512_1 as isize);
            tracer.read_register(s_2512_1 as isize, value);
            value
        };
        // D s_2512_3: cmp-lt s_2512_2 s_2512_0
        let s_2512_3: bool = ((s_2512_2) < (s_2512_0));
        // D s_2512_4: write-var gs#400319 <= s_2512_3
        fn_state.gs_400319 = s_2512_3;
        // N s_2512_5: jump b767
        return block_767(state, tracer, fn_state);
    }
    fn block_2513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2513_0: const #23s : i
        let s_2513_0: i128 = 23;
        // D s_2513_1: read-var u#31316:u32
        let s_2513_1: u32 = fn_state.u_31316;
        // D s_2513_2: cast zx s_2513_1 -> bv
        let s_2513_2: Bits = Bits::new(s_2513_1 as u128, 32u16);
        // C s_2513_3: const #1s : i64
        let s_2513_3: i64 = 1;
        // C s_2513_4: cast zx s_2513_3 -> i
        let s_2513_4: i128 = (i128::try_from(s_2513_3).unwrap());
        // C s_2513_5: const #0s : i
        let s_2513_5: i128 = 0;
        // C s_2513_6: add s_2513_5 s_2513_4
        let s_2513_6: i128 = (s_2513_5 + s_2513_4);
        // D s_2513_7: bit-extract s_2513_2 s_2513_0 s_2513_6
        let s_2513_7: Bits = (Bits::new(
            ((s_2513_2) >> (s_2513_0)).value(),
            u16::try_from(s_2513_6).unwrap(),
        ));
        // D s_2513_8: cast reint s_2513_7 -> u8
        let s_2513_8: bool = ((s_2513_7.value()) != 0);
        // D s_2513_9: cast zx s_2513_8 -> bv
        let s_2513_9: Bits = Bits::new(s_2513_8 as u128, 1u16);
        // C s_2513_10: const #1u : u8
        let s_2513_10: bool = true;
        // C s_2513_11: cast zx s_2513_10 -> bv
        let s_2513_11: Bits = Bits::new(s_2513_10 as u128, 1u16);
        // D s_2513_12: cmp-eq s_2513_9 s_2513_11
        let s_2513_12: bool = ((s_2513_9) == (s_2513_11));
        // N s_2513_13: branch s_2513_12 b2516 b2514
        if s_2513_12 {
            return block_2516(state, tracer, fn_state);
        } else {
            return block_2514(state, tracer, fn_state);
        };
    }
    fn block_2514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2514_0: const #0u : u8
        let s_2514_0: bool = false;
        // D s_2514_1: write-var gs#400316 <= s_2514_0
        fn_state.gs_400316 = s_2514_0;
        // N s_2514_2: jump b2515
        return block_2515(state, tracer, fn_state);
    }
    fn block_2515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2515_0: read-var gs#400316:u8
        let s_2515_0: bool = fn_state.gs_400316;
        // D s_2515_1: write-var gs#400317 <= s_2515_0
        fn_state.gs_400317 = s_2515_0;
        // N s_2515_2: jump b765
        return block_765(state, tracer, fn_state);
    }
    fn block_2516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2516_0: const #8s : i
        let s_2516_0: i128 = 8;
        // D s_2516_1: read-var u#31316:u32
        let s_2516_1: u32 = fn_state.u_31316;
        // D s_2516_2: cast zx s_2516_1 -> bv
        let s_2516_2: Bits = Bits::new(s_2516_1 as u128, 32u16);
        // C s_2516_3: const #1s : i64
        let s_2516_3: i64 = 1;
        // C s_2516_4: cast zx s_2516_3 -> i
        let s_2516_4: i128 = (i128::try_from(s_2516_3).unwrap());
        // C s_2516_5: const #3s : i
        let s_2516_5: i128 = 3;
        // C s_2516_6: add s_2516_5 s_2516_4
        let s_2516_6: i128 = (s_2516_5 + s_2516_4);
        // D s_2516_7: bit-extract s_2516_2 s_2516_0 s_2516_6
        let s_2516_7: Bits = (Bits::new(
            ((s_2516_2) >> (s_2516_0)).value(),
            u16::try_from(s_2516_6).unwrap(),
        ));
        // D s_2516_8: cast reint s_2516_7 -> u8
        let s_2516_8: u8 = (s_2516_7.value() as u8);
        // D s_2516_9: cast zx s_2516_8 -> bv
        let s_2516_9: Bits = Bits::new(s_2516_8 as u128, 4u16);
        // C s_2516_10: const #10u : u8
        let s_2516_10: u8 = 10;
        // C s_2516_11: cast zx s_2516_10 -> bv
        let s_2516_11: Bits = Bits::new(s_2516_10 as u128, 4u16);
        // D s_2516_12: cmp-eq s_2516_9 s_2516_11
        let s_2516_12: bool = ((s_2516_9) == (s_2516_11));
        // N s_2516_13: branch s_2516_12 b2519 b2517
        if s_2516_12 {
            return block_2519(state, tracer, fn_state);
        } else {
            return block_2517(state, tracer, fn_state);
        };
    }
    fn block_2517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2517_0: const #0u : u8
        let s_2517_0: bool = false;
        // D s_2517_1: write-var gs#400315 <= s_2517_0
        fn_state.gs_400315 = s_2517_0;
        // N s_2517_2: jump b2518
        return block_2518(state, tracer, fn_state);
    }
    fn block_2518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2518_0: read-var gs#400315:u8
        let s_2518_0: bool = fn_state.gs_400315;
        // D s_2518_1: write-var gs#400316 <= s_2518_0
        fn_state.gs_400316 = s_2518_0;
        // N s_2518_2: jump b2515
        return block_2515(state, tracer, fn_state);
    }
    fn block_2519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2519_0: const #6s : i
        let s_2519_0: i128 = 6;
        // D s_2519_1: read-var u#31316:u32
        let s_2519_1: u32 = fn_state.u_31316;
        // D s_2519_2: cast zx s_2519_1 -> bv
        let s_2519_2: Bits = Bits::new(s_2519_1 as u128, 32u16);
        // C s_2519_3: const #1s : i64
        let s_2519_3: i64 = 1;
        // C s_2519_4: cast zx s_2519_3 -> i
        let s_2519_4: i128 = (i128::try_from(s_2519_3).unwrap());
        // C s_2519_5: const #0s : i
        let s_2519_5: i128 = 0;
        // C s_2519_6: add s_2519_5 s_2519_4
        let s_2519_6: i128 = (s_2519_5 + s_2519_4);
        // D s_2519_7: bit-extract s_2519_2 s_2519_0 s_2519_6
        let s_2519_7: Bits = (Bits::new(
            ((s_2519_2) >> (s_2519_0)).value(),
            u16::try_from(s_2519_6).unwrap(),
        ));
        // D s_2519_8: cast reint s_2519_7 -> u8
        let s_2519_8: bool = ((s_2519_7.value()) != 0);
        // D s_2519_9: cast zx s_2519_8 -> bv
        let s_2519_9: Bits = Bits::new(s_2519_8 as u128, 1u16);
        // C s_2519_10: const #1u : u8
        let s_2519_10: bool = true;
        // C s_2519_11: cast zx s_2519_10 -> bv
        let s_2519_11: Bits = Bits::new(s_2519_10 as u128, 1u16);
        // D s_2519_12: cmp-eq s_2519_9 s_2519_11
        let s_2519_12: bool = ((s_2519_9) == (s_2519_11));
        // N s_2519_13: branch s_2519_12 b2522 b2520
        if s_2519_12 {
            return block_2522(state, tracer, fn_state);
        } else {
            return block_2520(state, tracer, fn_state);
        };
    }
    fn block_2520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2520_0: const #0u : u8
        let s_2520_0: bool = false;
        // D s_2520_1: write-var gs#400314 <= s_2520_0
        fn_state.gs_400314 = s_2520_0;
        // N s_2520_2: jump b2521
        return block_2521(state, tracer, fn_state);
    }
    fn block_2521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2521_0: read-var gs#400314:u8
        let s_2521_0: bool = fn_state.gs_400314;
        // D s_2521_1: write-var gs#400315 <= s_2521_0
        fn_state.gs_400315 = s_2521_0;
        // N s_2521_2: jump b2518
        return block_2518(state, tracer, fn_state);
    }
    fn block_2522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2522_0: const #4s : i
        let s_2522_0: i128 = 4;
        // D s_2522_1: read-var u#31316:u32
        let s_2522_1: u32 = fn_state.u_31316;
        // D s_2522_2: cast zx s_2522_1 -> bv
        let s_2522_2: Bits = Bits::new(s_2522_1 as u128, 32u16);
        // C s_2522_3: const #1s : i64
        let s_2522_3: i64 = 1;
        // C s_2522_4: cast zx s_2522_3 -> i
        let s_2522_4: i128 = (i128::try_from(s_2522_3).unwrap());
        // C s_2522_5: const #0s : i
        let s_2522_5: i128 = 0;
        // C s_2522_6: add s_2522_5 s_2522_4
        let s_2522_6: i128 = (s_2522_5 + s_2522_4);
        // D s_2522_7: bit-extract s_2522_2 s_2522_0 s_2522_6
        let s_2522_7: Bits = (Bits::new(
            ((s_2522_2) >> (s_2522_0)).value(),
            u16::try_from(s_2522_6).unwrap(),
        ));
        // D s_2522_8: cast reint s_2522_7 -> u8
        let s_2522_8: bool = ((s_2522_7.value()) != 0);
        // D s_2522_9: cast zx s_2522_8 -> bv
        let s_2522_9: Bits = Bits::new(s_2522_8 as u128, 1u16);
        // C s_2522_10: const #0u : u8
        let s_2522_10: bool = false;
        // C s_2522_11: cast zx s_2522_10 -> bv
        let s_2522_11: Bits = Bits::new(s_2522_10 as u128, 1u16);
        // D s_2522_12: cmp-eq s_2522_9 s_2522_11
        let s_2522_12: bool = ((s_2522_9) == (s_2522_11));
        // D s_2522_13: write-var gs#400314 <= s_2522_12
        fn_state.gs_400314 = s_2522_12;
        // N s_2522_14: jump b2521
        return block_2521(state, tracer, fn_state);
    }
    fn block_2523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2523_0: const #3560s : i
        let s_2523_0: i128 = 3560;
        // C s_2523_1: const #14696u : u32
        let s_2523_1: u32 = 14696;
        // D s_2523_2: read-reg s_2523_1:i
        let s_2523_2: i128 = {
            let value = state.read_register::<i128>(s_2523_1 as isize);
            tracer.read_register(s_2523_1 as isize, value);
            value
        };
        // D s_2523_3: cmp-lt s_2523_2 s_2523_0
        let s_2523_3: bool = ((s_2523_2) < (s_2523_0));
        // D s_2523_4: write-var gs#400282 <= s_2523_3
        fn_state.gs_400282 = s_2523_3;
        // N s_2523_5: jump b761
        return block_761(state, tracer, fn_state);
    }
    fn block_2524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2524_0: const #23s : i
        let s_2524_0: i128 = 23;
        // D s_2524_1: read-var u#31305:u32
        let s_2524_1: u32 = fn_state.u_31305;
        // D s_2524_2: cast zx s_2524_1 -> bv
        let s_2524_2: Bits = Bits::new(s_2524_1 as u128, 32u16);
        // C s_2524_3: const #1s : i64
        let s_2524_3: i64 = 1;
        // C s_2524_4: cast zx s_2524_3 -> i
        let s_2524_4: i128 = (i128::try_from(s_2524_3).unwrap());
        // C s_2524_5: const #0s : i
        let s_2524_5: i128 = 0;
        // C s_2524_6: add s_2524_5 s_2524_4
        let s_2524_6: i128 = (s_2524_5 + s_2524_4);
        // D s_2524_7: bit-extract s_2524_2 s_2524_0 s_2524_6
        let s_2524_7: Bits = (Bits::new(
            ((s_2524_2) >> (s_2524_0)).value(),
            u16::try_from(s_2524_6).unwrap(),
        ));
        // D s_2524_8: cast reint s_2524_7 -> u8
        let s_2524_8: bool = ((s_2524_7.value()) != 0);
        // D s_2524_9: cast zx s_2524_8 -> bv
        let s_2524_9: Bits = Bits::new(s_2524_8 as u128, 1u16);
        // C s_2524_10: const #1u : u8
        let s_2524_10: bool = true;
        // C s_2524_11: cast zx s_2524_10 -> bv
        let s_2524_11: Bits = Bits::new(s_2524_10 as u128, 1u16);
        // D s_2524_12: cmp-eq s_2524_9 s_2524_11
        let s_2524_12: bool = ((s_2524_9) == (s_2524_11));
        // N s_2524_13: branch s_2524_12 b2527 b2525
        if s_2524_12 {
            return block_2527(state, tracer, fn_state);
        } else {
            return block_2525(state, tracer, fn_state);
        };
    }
    fn block_2525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2525_0: const #0u : u8
        let s_2525_0: bool = false;
        // D s_2525_1: write-var gs#400279 <= s_2525_0
        fn_state.gs_400279 = s_2525_0;
        // N s_2525_2: jump b2526
        return block_2526(state, tracer, fn_state);
    }
    fn block_2526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2526_0: read-var gs#400279:u8
        let s_2526_0: bool = fn_state.gs_400279;
        // D s_2526_1: write-var gs#400280 <= s_2526_0
        fn_state.gs_400280 = s_2526_0;
        // N s_2526_2: jump b759
        return block_759(state, tracer, fn_state);
    }
    fn block_2527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2527_0: const #9s : i
        let s_2527_0: i128 = 9;
        // D s_2527_1: read-var u#31305:u32
        let s_2527_1: u32 = fn_state.u_31305;
        // D s_2527_2: cast zx s_2527_1 -> bv
        let s_2527_2: Bits = Bits::new(s_2527_1 as u128, 32u16);
        // C s_2527_3: const #1s : i64
        let s_2527_3: i64 = 1;
        // C s_2527_4: cast zx s_2527_3 -> i
        let s_2527_4: i128 = (i128::try_from(s_2527_3).unwrap());
        // C s_2527_5: const #2s : i
        let s_2527_5: i128 = 2;
        // C s_2527_6: add s_2527_5 s_2527_4
        let s_2527_6: i128 = (s_2527_5 + s_2527_4);
        // D s_2527_7: bit-extract s_2527_2 s_2527_0 s_2527_6
        let s_2527_7: Bits = (Bits::new(
            ((s_2527_2) >> (s_2527_0)).value(),
            u16::try_from(s_2527_6).unwrap(),
        ));
        // D s_2527_8: cast reint s_2527_7 -> u8
        let s_2527_8: u8 = (s_2527_7.value() as u8);
        // D s_2527_9: cast zx s_2527_8 -> bv
        let s_2527_9: Bits = Bits::new(s_2527_8 as u128, 3u16);
        // C s_2527_10: const #4u : u8
        let s_2527_10: u8 = 4;
        // C s_2527_11: cast zx s_2527_10 -> bv
        let s_2527_11: Bits = Bits::new(s_2527_10 as u128, 3u16);
        // D s_2527_12: cmp-eq s_2527_9 s_2527_11
        let s_2527_12: bool = ((s_2527_9) == (s_2527_11));
        // N s_2527_13: branch s_2527_12 b2530 b2528
        if s_2527_12 {
            return block_2530(state, tracer, fn_state);
        } else {
            return block_2528(state, tracer, fn_state);
        };
    }
    fn block_2528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2528_0: const #0u : u8
        let s_2528_0: bool = false;
        // D s_2528_1: write-var gs#400278 <= s_2528_0
        fn_state.gs_400278 = s_2528_0;
        // N s_2528_2: jump b2529
        return block_2529(state, tracer, fn_state);
    }
    fn block_2529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2529_0: read-var gs#400278:u8
        let s_2529_0: bool = fn_state.gs_400278;
        // D s_2529_1: write-var gs#400279 <= s_2529_0
        fn_state.gs_400279 = s_2529_0;
        // N s_2529_2: jump b2526
        return block_2526(state, tracer, fn_state);
    }
    fn block_2530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2530_0: const #6s : i
        let s_2530_0: i128 = 6;
        // D s_2530_1: read-var u#31305:u32
        let s_2530_1: u32 = fn_state.u_31305;
        // D s_2530_2: cast zx s_2530_1 -> bv
        let s_2530_2: Bits = Bits::new(s_2530_1 as u128, 32u16);
        // C s_2530_3: const #1s : i64
        let s_2530_3: i64 = 1;
        // C s_2530_4: cast zx s_2530_3 -> i
        let s_2530_4: i128 = (i128::try_from(s_2530_3).unwrap());
        // C s_2530_5: const #0s : i
        let s_2530_5: i128 = 0;
        // C s_2530_6: add s_2530_5 s_2530_4
        let s_2530_6: i128 = (s_2530_5 + s_2530_4);
        // D s_2530_7: bit-extract s_2530_2 s_2530_0 s_2530_6
        let s_2530_7: Bits = (Bits::new(
            ((s_2530_2) >> (s_2530_0)).value(),
            u16::try_from(s_2530_6).unwrap(),
        ));
        // D s_2530_8: cast reint s_2530_7 -> u8
        let s_2530_8: bool = ((s_2530_7.value()) != 0);
        // D s_2530_9: cast zx s_2530_8 -> bv
        let s_2530_9: Bits = Bits::new(s_2530_8 as u128, 1u16);
        // C s_2530_10: const #1u : u8
        let s_2530_10: bool = true;
        // C s_2530_11: cast zx s_2530_10 -> bv
        let s_2530_11: Bits = Bits::new(s_2530_10 as u128, 1u16);
        // D s_2530_12: cmp-eq s_2530_9 s_2530_11
        let s_2530_12: bool = ((s_2530_9) == (s_2530_11));
        // N s_2530_13: branch s_2530_12 b2533 b2531
        if s_2530_12 {
            return block_2533(state, tracer, fn_state);
        } else {
            return block_2531(state, tracer, fn_state);
        };
    }
    fn block_2531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2531_0: const #0u : u8
        let s_2531_0: bool = false;
        // D s_2531_1: write-var gs#400277 <= s_2531_0
        fn_state.gs_400277 = s_2531_0;
        // N s_2531_2: jump b2532
        return block_2532(state, tracer, fn_state);
    }
    fn block_2532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2532_0: read-var gs#400277:u8
        let s_2532_0: bool = fn_state.gs_400277;
        // D s_2532_1: write-var gs#400278 <= s_2532_0
        fn_state.gs_400278 = s_2532_0;
        // N s_2532_2: jump b2529
        return block_2529(state, tracer, fn_state);
    }
    fn block_2533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2533_0: const #4s : i
        let s_2533_0: i128 = 4;
        // D s_2533_1: read-var u#31305:u32
        let s_2533_1: u32 = fn_state.u_31305;
        // D s_2533_2: cast zx s_2533_1 -> bv
        let s_2533_2: Bits = Bits::new(s_2533_1 as u128, 32u16);
        // C s_2533_3: const #1s : i64
        let s_2533_3: i64 = 1;
        // C s_2533_4: cast zx s_2533_3 -> i
        let s_2533_4: i128 = (i128::try_from(s_2533_3).unwrap());
        // C s_2533_5: const #0s : i
        let s_2533_5: i128 = 0;
        // C s_2533_6: add s_2533_5 s_2533_4
        let s_2533_6: i128 = (s_2533_5 + s_2533_4);
        // D s_2533_7: bit-extract s_2533_2 s_2533_0 s_2533_6
        let s_2533_7: Bits = (Bits::new(
            ((s_2533_2) >> (s_2533_0)).value(),
            u16::try_from(s_2533_6).unwrap(),
        ));
        // D s_2533_8: cast reint s_2533_7 -> u8
        let s_2533_8: bool = ((s_2533_7.value()) != 0);
        // D s_2533_9: cast zx s_2533_8 -> bv
        let s_2533_9: Bits = Bits::new(s_2533_8 as u128, 1u16);
        // C s_2533_10: const #0u : u8
        let s_2533_10: bool = false;
        // C s_2533_11: cast zx s_2533_10 -> bv
        let s_2533_11: Bits = Bits::new(s_2533_10 as u128, 1u16);
        // D s_2533_12: cmp-eq s_2533_9 s_2533_11
        let s_2533_12: bool = ((s_2533_9) == (s_2533_11));
        // D s_2533_13: write-var gs#400277 <= s_2533_12
        fn_state.gs_400277 = s_2533_12;
        // N s_2533_14: jump b2532
        return block_2532(state, tracer, fn_state);
    }
    fn block_2534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2534_0: const #3557s : i
        let s_2534_0: i128 = 3557;
        // C s_2534_1: const #14696u : u32
        let s_2534_1: u32 = 14696;
        // D s_2534_2: read-reg s_2534_1:i
        let s_2534_2: i128 = {
            let value = state.read_register::<i128>(s_2534_1 as isize);
            tracer.read_register(s_2534_1 as isize, value);
            value
        };
        // D s_2534_3: cmp-lt s_2534_2 s_2534_0
        let s_2534_3: bool = ((s_2534_2) < (s_2534_0));
        // D s_2534_4: write-var gs#400245 <= s_2534_3
        fn_state.gs_400245 = s_2534_3;
        // N s_2534_5: jump b755
        return block_755(state, tracer, fn_state);
    }
    fn block_2535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2535_0: const #23s : i
        let s_2535_0: i128 = 23;
        // D s_2535_1: read-var u#31294:u32
        let s_2535_1: u32 = fn_state.u_31294;
        // D s_2535_2: cast zx s_2535_1 -> bv
        let s_2535_2: Bits = Bits::new(s_2535_1 as u128, 32u16);
        // C s_2535_3: const #1s : i64
        let s_2535_3: i64 = 1;
        // C s_2535_4: cast zx s_2535_3 -> i
        let s_2535_4: i128 = (i128::try_from(s_2535_3).unwrap());
        // C s_2535_5: const #0s : i
        let s_2535_5: i128 = 0;
        // C s_2535_6: add s_2535_5 s_2535_4
        let s_2535_6: i128 = (s_2535_5 + s_2535_4);
        // D s_2535_7: bit-extract s_2535_2 s_2535_0 s_2535_6
        let s_2535_7: Bits = (Bits::new(
            ((s_2535_2) >> (s_2535_0)).value(),
            u16::try_from(s_2535_6).unwrap(),
        ));
        // D s_2535_8: cast reint s_2535_7 -> u8
        let s_2535_8: bool = ((s_2535_7.value()) != 0);
        // D s_2535_9: cast zx s_2535_8 -> bv
        let s_2535_9: Bits = Bits::new(s_2535_8 as u128, 1u16);
        // C s_2535_10: const #1u : u8
        let s_2535_10: bool = true;
        // C s_2535_11: cast zx s_2535_10 -> bv
        let s_2535_11: Bits = Bits::new(s_2535_10 as u128, 1u16);
        // D s_2535_12: cmp-eq s_2535_9 s_2535_11
        let s_2535_12: bool = ((s_2535_9) == (s_2535_11));
        // N s_2535_13: branch s_2535_12 b2538 b2536
        if s_2535_12 {
            return block_2538(state, tracer, fn_state);
        } else {
            return block_2536(state, tracer, fn_state);
        };
    }
    fn block_2536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2536_0: const #0u : u8
        let s_2536_0: bool = false;
        // D s_2536_1: write-var gs#400242 <= s_2536_0
        fn_state.gs_400242 = s_2536_0;
        // N s_2536_2: jump b2537
        return block_2537(state, tracer, fn_state);
    }
    fn block_2537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2537_0: read-var gs#400242:u8
        let s_2537_0: bool = fn_state.gs_400242;
        // D s_2537_1: write-var gs#400243 <= s_2537_0
        fn_state.gs_400243 = s_2537_0;
        // N s_2537_2: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_2538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2538_0: const #10s : i
        let s_2538_0: i128 = 10;
        // D s_2538_1: read-var u#31294:u32
        let s_2538_1: u32 = fn_state.u_31294;
        // D s_2538_2: cast zx s_2538_1 -> bv
        let s_2538_2: Bits = Bits::new(s_2538_1 as u128, 32u16);
        // C s_2538_3: const #1s : i64
        let s_2538_3: i64 = 1;
        // C s_2538_4: cast zx s_2538_3 -> i
        let s_2538_4: i128 = (i128::try_from(s_2538_3).unwrap());
        // C s_2538_5: const #1s : i
        let s_2538_5: i128 = 1;
        // C s_2538_6: add s_2538_5 s_2538_4
        let s_2538_6: i128 = (s_2538_5 + s_2538_4);
        // D s_2538_7: bit-extract s_2538_2 s_2538_0 s_2538_6
        let s_2538_7: Bits = (Bits::new(
            ((s_2538_2) >> (s_2538_0)).value(),
            u16::try_from(s_2538_6).unwrap(),
        ));
        // D s_2538_8: cast reint s_2538_7 -> u8
        let s_2538_8: u8 = (s_2538_7.value() as u8);
        // D s_2538_9: cast zx s_2538_8 -> bv
        let s_2538_9: Bits = Bits::new(s_2538_8 as u128, 2u16);
        // C s_2538_10: const #3u : u8
        let s_2538_10: u8 = 3;
        // C s_2538_11: cast zx s_2538_10 -> bv
        let s_2538_11: Bits = Bits::new(s_2538_10 as u128, 2u16);
        // D s_2538_12: cmp-eq s_2538_9 s_2538_11
        let s_2538_12: bool = ((s_2538_9) == (s_2538_11));
        // N s_2538_13: branch s_2538_12 b2541 b2539
        if s_2538_12 {
            return block_2541(state, tracer, fn_state);
        } else {
            return block_2539(state, tracer, fn_state);
        };
    }
    fn block_2539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2539_0: const #0u : u8
        let s_2539_0: bool = false;
        // D s_2539_1: write-var gs#400241 <= s_2539_0
        fn_state.gs_400241 = s_2539_0;
        // N s_2539_2: jump b2540
        return block_2540(state, tracer, fn_state);
    }
    fn block_2540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2540_0: read-var gs#400241:u8
        let s_2540_0: bool = fn_state.gs_400241;
        // D s_2540_1: write-var gs#400242 <= s_2540_0
        fn_state.gs_400242 = s_2540_0;
        // N s_2540_2: jump b2537
        return block_2537(state, tracer, fn_state);
    }
    fn block_2541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2541_0: const #8s : i
        let s_2541_0: i128 = 8;
        // D s_2541_1: read-var u#31294:u32
        let s_2541_1: u32 = fn_state.u_31294;
        // D s_2541_2: cast zx s_2541_1 -> bv
        let s_2541_2: Bits = Bits::new(s_2541_1 as u128, 32u16);
        // C s_2541_3: const #1s : i64
        let s_2541_3: i64 = 1;
        // C s_2541_4: cast zx s_2541_3 -> i
        let s_2541_4: i128 = (i128::try_from(s_2541_3).unwrap());
        // C s_2541_5: const #0s : i
        let s_2541_5: i128 = 0;
        // C s_2541_6: add s_2541_5 s_2541_4
        let s_2541_6: i128 = (s_2541_5 + s_2541_4);
        // D s_2541_7: bit-extract s_2541_2 s_2541_0 s_2541_6
        let s_2541_7: Bits = (Bits::new(
            ((s_2541_2) >> (s_2541_0)).value(),
            u16::try_from(s_2541_6).unwrap(),
        ));
        // D s_2541_8: cast reint s_2541_7 -> u8
        let s_2541_8: bool = ((s_2541_7.value()) != 0);
        // D s_2541_9: cast zx s_2541_8 -> bv
        let s_2541_9: Bits = Bits::new(s_2541_8 as u128, 1u16);
        // C s_2541_10: const #0u : u8
        let s_2541_10: bool = false;
        // C s_2541_11: cast zx s_2541_10 -> bv
        let s_2541_11: Bits = Bits::new(s_2541_10 as u128, 1u16);
        // D s_2541_12: cmp-eq s_2541_9 s_2541_11
        let s_2541_12: bool = ((s_2541_9) == (s_2541_11));
        // N s_2541_13: branch s_2541_12 b2544 b2542
        if s_2541_12 {
            return block_2544(state, tracer, fn_state);
        } else {
            return block_2542(state, tracer, fn_state);
        };
    }
    fn block_2542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2542_0: const #0u : u8
        let s_2542_0: bool = false;
        // D s_2542_1: write-var gs#400240 <= s_2542_0
        fn_state.gs_400240 = s_2542_0;
        // N s_2542_2: jump b2543
        return block_2543(state, tracer, fn_state);
    }
    fn block_2543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2543_0: read-var gs#400240:u8
        let s_2543_0: bool = fn_state.gs_400240;
        // D s_2543_1: write-var gs#400241 <= s_2543_0
        fn_state.gs_400241 = s_2543_0;
        // N s_2543_2: jump b2540
        return block_2540(state, tracer, fn_state);
    }
    fn block_2544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2544_0: const #6s : i
        let s_2544_0: i128 = 6;
        // D s_2544_1: read-var u#31294:u32
        let s_2544_1: u32 = fn_state.u_31294;
        // D s_2544_2: cast zx s_2544_1 -> bv
        let s_2544_2: Bits = Bits::new(s_2544_1 as u128, 32u16);
        // C s_2544_3: const #1s : i64
        let s_2544_3: i64 = 1;
        // C s_2544_4: cast zx s_2544_3 -> i
        let s_2544_4: i128 = (i128::try_from(s_2544_3).unwrap());
        // C s_2544_5: const #0s : i
        let s_2544_5: i128 = 0;
        // C s_2544_6: add s_2544_5 s_2544_4
        let s_2544_6: i128 = (s_2544_5 + s_2544_4);
        // D s_2544_7: bit-extract s_2544_2 s_2544_0 s_2544_6
        let s_2544_7: Bits = (Bits::new(
            ((s_2544_2) >> (s_2544_0)).value(),
            u16::try_from(s_2544_6).unwrap(),
        ));
        // D s_2544_8: cast reint s_2544_7 -> u8
        let s_2544_8: bool = ((s_2544_7.value()) != 0);
        // D s_2544_9: cast zx s_2544_8 -> bv
        let s_2544_9: Bits = Bits::new(s_2544_8 as u128, 1u16);
        // C s_2544_10: const #0u : u8
        let s_2544_10: bool = false;
        // C s_2544_11: cast zx s_2544_10 -> bv
        let s_2544_11: Bits = Bits::new(s_2544_10 as u128, 1u16);
        // D s_2544_12: cmp-eq s_2544_9 s_2544_11
        let s_2544_12: bool = ((s_2544_9) == (s_2544_11));
        // N s_2544_13: branch s_2544_12 b2547 b2545
        if s_2544_12 {
            return block_2547(state, tracer, fn_state);
        } else {
            return block_2545(state, tracer, fn_state);
        };
    }
    fn block_2545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2545_0: const #0u : u8
        let s_2545_0: bool = false;
        // D s_2545_1: write-var gs#400239 <= s_2545_0
        fn_state.gs_400239 = s_2545_0;
        // N s_2545_2: jump b2546
        return block_2546(state, tracer, fn_state);
    }
    fn block_2546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2546_0: read-var gs#400239:u8
        let s_2546_0: bool = fn_state.gs_400239;
        // D s_2546_1: write-var gs#400240 <= s_2546_0
        fn_state.gs_400240 = s_2546_0;
        // N s_2546_2: jump b2543
        return block_2543(state, tracer, fn_state);
    }
    fn block_2547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2547_0: const #4s : i
        let s_2547_0: i128 = 4;
        // D s_2547_1: read-var u#31294:u32
        let s_2547_1: u32 = fn_state.u_31294;
        // D s_2547_2: cast zx s_2547_1 -> bv
        let s_2547_2: Bits = Bits::new(s_2547_1 as u128, 32u16);
        // C s_2547_3: const #1s : i64
        let s_2547_3: i64 = 1;
        // C s_2547_4: cast zx s_2547_3 -> i
        let s_2547_4: i128 = (i128::try_from(s_2547_3).unwrap());
        // C s_2547_5: const #0s : i
        let s_2547_5: i128 = 0;
        // C s_2547_6: add s_2547_5 s_2547_4
        let s_2547_6: i128 = (s_2547_5 + s_2547_4);
        // D s_2547_7: bit-extract s_2547_2 s_2547_0 s_2547_6
        let s_2547_7: Bits = (Bits::new(
            ((s_2547_2) >> (s_2547_0)).value(),
            u16::try_from(s_2547_6).unwrap(),
        ));
        // D s_2547_8: cast reint s_2547_7 -> u8
        let s_2547_8: bool = ((s_2547_7.value()) != 0);
        // D s_2547_9: cast zx s_2547_8 -> bv
        let s_2547_9: Bits = Bits::new(s_2547_8 as u128, 1u16);
        // C s_2547_10: const #0u : u8
        let s_2547_10: bool = false;
        // C s_2547_11: cast zx s_2547_10 -> bv
        let s_2547_11: Bits = Bits::new(s_2547_10 as u128, 1u16);
        // D s_2547_12: cmp-eq s_2547_9 s_2547_11
        let s_2547_12: bool = ((s_2547_9) == (s_2547_11));
        // D s_2547_13: write-var gs#400239 <= s_2547_12
        fn_state.gs_400239 = s_2547_12;
        // N s_2547_14: jump b2546
        return block_2546(state, tracer, fn_state);
    }
    fn block_2548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2548_0: const #3556s : i
        let s_2548_0: i128 = 3556;
        // C s_2548_1: const #14696u : u32
        let s_2548_1: u32 = 14696;
        // D s_2548_2: read-reg s_2548_1:i
        let s_2548_2: i128 = {
            let value = state.read_register::<i128>(s_2548_1 as isize);
            tracer.read_register(s_2548_1 as isize, value);
            value
        };
        // D s_2548_3: cmp-lt s_2548_2 s_2548_0
        let s_2548_3: bool = ((s_2548_2) < (s_2548_0));
        // D s_2548_4: write-var gs#400205 <= s_2548_3
        fn_state.gs_400205 = s_2548_3;
        // N s_2548_5: jump b749
        return block_749(state, tracer, fn_state);
    }
    fn block_2549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2549_0: const #23s : i
        let s_2549_0: i128 = 23;
        // D s_2549_1: read-var u#31283:u32
        let s_2549_1: u32 = fn_state.u_31283;
        // D s_2549_2: cast zx s_2549_1 -> bv
        let s_2549_2: Bits = Bits::new(s_2549_1 as u128, 32u16);
        // C s_2549_3: const #1s : i64
        let s_2549_3: i64 = 1;
        // C s_2549_4: cast zx s_2549_3 -> i
        let s_2549_4: i128 = (i128::try_from(s_2549_3).unwrap());
        // C s_2549_5: const #0s : i
        let s_2549_5: i128 = 0;
        // C s_2549_6: add s_2549_5 s_2549_4
        let s_2549_6: i128 = (s_2549_5 + s_2549_4);
        // D s_2549_7: bit-extract s_2549_2 s_2549_0 s_2549_6
        let s_2549_7: Bits = (Bits::new(
            ((s_2549_2) >> (s_2549_0)).value(),
            u16::try_from(s_2549_6).unwrap(),
        ));
        // D s_2549_8: cast reint s_2549_7 -> u8
        let s_2549_8: bool = ((s_2549_7.value()) != 0);
        // D s_2549_9: cast zx s_2549_8 -> bv
        let s_2549_9: Bits = Bits::new(s_2549_8 as u128, 1u16);
        // C s_2549_10: const #0u : u8
        let s_2549_10: bool = false;
        // C s_2549_11: cast zx s_2549_10 -> bv
        let s_2549_11: Bits = Bits::new(s_2549_10 as u128, 1u16);
        // D s_2549_12: cmp-eq s_2549_9 s_2549_11
        let s_2549_12: bool = ((s_2549_9) == (s_2549_11));
        // N s_2549_13: branch s_2549_12 b2552 b2550
        if s_2549_12 {
            return block_2552(state, tracer, fn_state);
        } else {
            return block_2550(state, tracer, fn_state);
        };
    }
    fn block_2550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2550_0: const #0u : u8
        let s_2550_0: bool = false;
        // D s_2550_1: write-var gs#400202 <= s_2550_0
        fn_state.gs_400202 = s_2550_0;
        // N s_2550_2: jump b2551
        return block_2551(state, tracer, fn_state);
    }
    fn block_2551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2551_0: read-var gs#400202:u8
        let s_2551_0: bool = fn_state.gs_400202;
        // D s_2551_1: write-var gs#400203 <= s_2551_0
        fn_state.gs_400203 = s_2551_0;
        // N s_2551_2: jump b747
        return block_747(state, tracer, fn_state);
    }
    fn block_2552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2552_0: const #8s : i
        let s_2552_0: i128 = 8;
        // D s_2552_1: read-var u#31283:u32
        let s_2552_1: u32 = fn_state.u_31283;
        // D s_2552_2: cast zx s_2552_1 -> bv
        let s_2552_2: Bits = Bits::new(s_2552_1 as u128, 32u16);
        // C s_2552_3: const #1s : i64
        let s_2552_3: i64 = 1;
        // C s_2552_4: cast zx s_2552_3 -> i
        let s_2552_4: i128 = (i128::try_from(s_2552_3).unwrap());
        // C s_2552_5: const #3s : i
        let s_2552_5: i128 = 3;
        // C s_2552_6: add s_2552_5 s_2552_4
        let s_2552_6: i128 = (s_2552_5 + s_2552_4);
        // D s_2552_7: bit-extract s_2552_2 s_2552_0 s_2552_6
        let s_2552_7: Bits = (Bits::new(
            ((s_2552_2) >> (s_2552_0)).value(),
            u16::try_from(s_2552_6).unwrap(),
        ));
        // D s_2552_8: cast reint s_2552_7 -> u8
        let s_2552_8: u8 = (s_2552_7.value() as u8);
        // D s_2552_9: cast zx s_2552_8 -> bv
        let s_2552_9: Bits = Bits::new(s_2552_8 as u128, 4u16);
        // C s_2552_10: const #9u : u8
        let s_2552_10: u8 = 9;
        // C s_2552_11: cast zx s_2552_10 -> bv
        let s_2552_11: Bits = Bits::new(s_2552_10 as u128, 4u16);
        // D s_2552_12: cmp-eq s_2552_9 s_2552_11
        let s_2552_12: bool = ((s_2552_9) == (s_2552_11));
        // N s_2552_13: branch s_2552_12 b2555 b2553
        if s_2552_12 {
            return block_2555(state, tracer, fn_state);
        } else {
            return block_2553(state, tracer, fn_state);
        };
    }
    fn block_2553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2553_0: const #0u : u8
        let s_2553_0: bool = false;
        // D s_2553_1: write-var gs#400201 <= s_2553_0
        fn_state.gs_400201 = s_2553_0;
        // N s_2553_2: jump b2554
        return block_2554(state, tracer, fn_state);
    }
    fn block_2554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2554_0: read-var gs#400201:u8
        let s_2554_0: bool = fn_state.gs_400201;
        // D s_2554_1: write-var gs#400202 <= s_2554_0
        fn_state.gs_400202 = s_2554_0;
        // N s_2554_2: jump b2551
        return block_2551(state, tracer, fn_state);
    }
    fn block_2555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2555_0: const #4s : i
        let s_2555_0: i128 = 4;
        // D s_2555_1: read-var u#31283:u32
        let s_2555_1: u32 = fn_state.u_31283;
        // D s_2555_2: cast zx s_2555_1 -> bv
        let s_2555_2: Bits = Bits::new(s_2555_1 as u128, 32u16);
        // C s_2555_3: const #1s : i64
        let s_2555_3: i64 = 1;
        // C s_2555_4: cast zx s_2555_3 -> i
        let s_2555_4: i128 = (i128::try_from(s_2555_3).unwrap());
        // C s_2555_5: const #0s : i
        let s_2555_5: i128 = 0;
        // C s_2555_6: add s_2555_5 s_2555_4
        let s_2555_6: i128 = (s_2555_5 + s_2555_4);
        // D s_2555_7: bit-extract s_2555_2 s_2555_0 s_2555_6
        let s_2555_7: Bits = (Bits::new(
            ((s_2555_2) >> (s_2555_0)).value(),
            u16::try_from(s_2555_6).unwrap(),
        ));
        // D s_2555_8: cast reint s_2555_7 -> u8
        let s_2555_8: bool = ((s_2555_7.value()) != 0);
        // D s_2555_9: cast zx s_2555_8 -> bv
        let s_2555_9: Bits = Bits::new(s_2555_8 as u128, 1u16);
        // C s_2555_10: const #1u : u8
        let s_2555_10: bool = true;
        // C s_2555_11: cast zx s_2555_10 -> bv
        let s_2555_11: Bits = Bits::new(s_2555_10 as u128, 1u16);
        // D s_2555_12: cmp-eq s_2555_9 s_2555_11
        let s_2555_12: bool = ((s_2555_9) == (s_2555_11));
        // D s_2555_13: write-var gs#400201 <= s_2555_12
        fn_state.gs_400201 = s_2555_12;
        // N s_2555_14: jump b2554
        return block_2554(state, tracer, fn_state);
    }
    fn block_2556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2556_0: const #3552s : i
        let s_2556_0: i128 = 3552;
        // C s_2556_1: const #14696u : u32
        let s_2556_1: u32 = 14696;
        // D s_2556_2: read-reg s_2556_1:i
        let s_2556_2: i128 = {
            let value = state.read_register::<i128>(s_2556_1 as isize);
            tracer.read_register(s_2556_1 as isize, value);
            value
        };
        // D s_2556_3: cmp-lt s_2556_2 s_2556_0
        let s_2556_3: bool = ((s_2556_2) < (s_2556_0));
        // D s_2556_4: write-var gs#400173 <= s_2556_3
        fn_state.gs_400173 = s_2556_3;
        // N s_2556_5: jump b743
        return block_743(state, tracer, fn_state);
    }
    fn block_2557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2557_0: const #21s : i
        let s_2557_0: i128 = 21;
        // D s_2557_1: read-var u#31273:u32
        let s_2557_1: u32 = fn_state.u_31273;
        // D s_2557_2: cast zx s_2557_1 -> bv
        let s_2557_2: Bits = Bits::new(s_2557_1 as u128, 32u16);
        // C s_2557_3: const #1s : i64
        let s_2557_3: i64 = 1;
        // C s_2557_4: cast zx s_2557_3 -> i
        let s_2557_4: i128 = (i128::try_from(s_2557_3).unwrap());
        // C s_2557_5: const #0s : i
        let s_2557_5: i128 = 0;
        // C s_2557_6: add s_2557_5 s_2557_4
        let s_2557_6: i128 = (s_2557_5 + s_2557_4);
        // D s_2557_7: bit-extract s_2557_2 s_2557_0 s_2557_6
        let s_2557_7: Bits = (Bits::new(
            ((s_2557_2) >> (s_2557_0)).value(),
            u16::try_from(s_2557_6).unwrap(),
        ));
        // D s_2557_8: cast reint s_2557_7 -> u8
        let s_2557_8: bool = ((s_2557_7.value()) != 0);
        // D s_2557_9: cast zx s_2557_8 -> bv
        let s_2557_9: Bits = Bits::new(s_2557_8 as u128, 1u16);
        // C s_2557_10: const #0u : u8
        let s_2557_10: bool = false;
        // C s_2557_11: cast zx s_2557_10 -> bv
        let s_2557_11: Bits = Bits::new(s_2557_10 as u128, 1u16);
        // D s_2557_12: cmp-eq s_2557_9 s_2557_11
        let s_2557_12: bool = ((s_2557_9) == (s_2557_11));
        // N s_2557_13: branch s_2557_12 b2560 b2558
        if s_2557_12 {
            return block_2560(state, tracer, fn_state);
        } else {
            return block_2558(state, tracer, fn_state);
        };
    }
    fn block_2558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2558_0: const #0u : u8
        let s_2558_0: bool = false;
        // D s_2558_1: write-var gs#400170 <= s_2558_0
        fn_state.gs_400170 = s_2558_0;
        // N s_2558_2: jump b2559
        return block_2559(state, tracer, fn_state);
    }
    fn block_2559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2559_0: read-var gs#400170:u8
        let s_2559_0: bool = fn_state.gs_400170;
        // D s_2559_1: write-var gs#400171 <= s_2559_0
        fn_state.gs_400171 = s_2559_0;
        // N s_2559_2: jump b741
        return block_741(state, tracer, fn_state);
    }
    fn block_2560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2560_0: const #8s : i
        let s_2560_0: i128 = 8;
        // D s_2560_1: read-var u#31273:u32
        let s_2560_1: u32 = fn_state.u_31273;
        // D s_2560_2: cast zx s_2560_1 -> bv
        let s_2560_2: Bits = Bits::new(s_2560_1 as u128, 32u16);
        // C s_2560_3: const #1s : i64
        let s_2560_3: i64 = 1;
        // C s_2560_4: cast zx s_2560_3 -> i
        let s_2560_4: i128 = (i128::try_from(s_2560_3).unwrap());
        // C s_2560_5: const #3s : i
        let s_2560_5: i128 = 3;
        // C s_2560_6: add s_2560_5 s_2560_4
        let s_2560_6: i128 = (s_2560_5 + s_2560_4);
        // D s_2560_7: bit-extract s_2560_2 s_2560_0 s_2560_6
        let s_2560_7: Bits = (Bits::new(
            ((s_2560_2) >> (s_2560_0)).value(),
            u16::try_from(s_2560_6).unwrap(),
        ));
        // D s_2560_8: cast reint s_2560_7 -> u8
        let s_2560_8: u8 = (s_2560_7.value() as u8);
        // D s_2560_9: cast zx s_2560_8 -> bv
        let s_2560_9: Bits = Bits::new(s_2560_8 as u128, 4u16);
        // C s_2560_10: const #13u : u8
        let s_2560_10: u8 = 13;
        // C s_2560_11: cast zx s_2560_10 -> bv
        let s_2560_11: Bits = Bits::new(s_2560_10 as u128, 4u16);
        // D s_2560_12: cmp-eq s_2560_9 s_2560_11
        let s_2560_12: bool = ((s_2560_9) == (s_2560_11));
        // N s_2560_13: branch s_2560_12 b2563 b2561
        if s_2560_12 {
            return block_2563(state, tracer, fn_state);
        } else {
            return block_2561(state, tracer, fn_state);
        };
    }
    fn block_2561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2561_0: const #0u : u8
        let s_2561_0: bool = false;
        // D s_2561_1: write-var gs#400169 <= s_2561_0
        fn_state.gs_400169 = s_2561_0;
        // N s_2561_2: jump b2562
        return block_2562(state, tracer, fn_state);
    }
    fn block_2562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2562_0: read-var gs#400169:u8
        let s_2562_0: bool = fn_state.gs_400169;
        // D s_2562_1: write-var gs#400170 <= s_2562_0
        fn_state.gs_400170 = s_2562_0;
        // N s_2562_2: jump b2559
        return block_2559(state, tracer, fn_state);
    }
    fn block_2563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2563_0: const #4s : i
        let s_2563_0: i128 = 4;
        // D s_2563_1: read-var u#31273:u32
        let s_2563_1: u32 = fn_state.u_31273;
        // D s_2563_2: cast zx s_2563_1 -> bv
        let s_2563_2: Bits = Bits::new(s_2563_1 as u128, 32u16);
        // C s_2563_3: const #1s : i64
        let s_2563_3: i64 = 1;
        // C s_2563_4: cast zx s_2563_3 -> i
        let s_2563_4: i128 = (i128::try_from(s_2563_3).unwrap());
        // C s_2563_5: const #0s : i
        let s_2563_5: i128 = 0;
        // C s_2563_6: add s_2563_5 s_2563_4
        let s_2563_6: i128 = (s_2563_5 + s_2563_4);
        // D s_2563_7: bit-extract s_2563_2 s_2563_0 s_2563_6
        let s_2563_7: Bits = (Bits::new(
            ((s_2563_2) >> (s_2563_0)).value(),
            u16::try_from(s_2563_6).unwrap(),
        ));
        // D s_2563_8: cast reint s_2563_7 -> u8
        let s_2563_8: bool = ((s_2563_7.value()) != 0);
        // D s_2563_9: cast zx s_2563_8 -> bv
        let s_2563_9: Bits = Bits::new(s_2563_8 as u128, 1u16);
        // C s_2563_10: const #1u : u8
        let s_2563_10: bool = true;
        // C s_2563_11: cast zx s_2563_10 -> bv
        let s_2563_11: Bits = Bits::new(s_2563_10 as u128, 1u16);
        // D s_2563_12: cmp-eq s_2563_9 s_2563_11
        let s_2563_12: bool = ((s_2563_9) == (s_2563_11));
        // D s_2563_13: write-var gs#400169 <= s_2563_12
        fn_state.gs_400169 = s_2563_12;
        // N s_2563_14: jump b2562
        return block_2562(state, tracer, fn_state);
    }
    fn block_2564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2564_0: const #3538s : i
        let s_2564_0: i128 = 3538;
        // C s_2564_1: const #14696u : u32
        let s_2564_1: u32 = 14696;
        // D s_2564_2: read-reg s_2564_1:i
        let s_2564_2: i128 = {
            let value = state.read_register::<i128>(s_2564_1 as isize);
            tracer.read_register(s_2564_1 as isize, value);
            value
        };
        // D s_2564_3: cmp-lt s_2564_2 s_2564_0
        let s_2564_3: bool = ((s_2564_2) < (s_2564_0));
        // D s_2564_4: write-var gs#400147 <= s_2564_3
        fn_state.gs_400147 = s_2564_3;
        // N s_2564_5: jump b737
        return block_737(state, tracer, fn_state);
    }
    fn block_2565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2565_0: const #20s : i
        let s_2565_0: i128 = 20;
        // D s_2565_1: read-var u#31266:u32
        let s_2565_1: u32 = fn_state.u_31266;
        // D s_2565_2: cast zx s_2565_1 -> bv
        let s_2565_2: Bits = Bits::new(s_2565_1 as u128, 32u16);
        // C s_2565_3: const #1s : i64
        let s_2565_3: i64 = 1;
        // C s_2565_4: cast zx s_2565_3 -> i
        let s_2565_4: i128 = (i128::try_from(s_2565_3).unwrap());
        // C s_2565_5: const #1s : i
        let s_2565_5: i128 = 1;
        // C s_2565_6: add s_2565_5 s_2565_4
        let s_2565_6: i128 = (s_2565_5 + s_2565_4);
        // D s_2565_7: bit-extract s_2565_2 s_2565_0 s_2565_6
        let s_2565_7: Bits = (Bits::new(
            ((s_2565_2) >> (s_2565_0)).value(),
            u16::try_from(s_2565_6).unwrap(),
        ));
        // D s_2565_8: cast reint s_2565_7 -> u8
        let s_2565_8: u8 = (s_2565_7.value() as u8);
        // D s_2565_9: cast zx s_2565_8 -> bv
        let s_2565_9: Bits = Bits::new(s_2565_8 as u128, 2u16);
        // C s_2565_10: const #3u : u8
        let s_2565_10: u8 = 3;
        // C s_2565_11: cast zx s_2565_10 -> bv
        let s_2565_11: Bits = Bits::new(s_2565_10 as u128, 2u16);
        // D s_2565_12: cmp-eq s_2565_9 s_2565_11
        let s_2565_12: bool = ((s_2565_9) == (s_2565_11));
        // N s_2565_13: branch s_2565_12 b2568 b2566
        if s_2565_12 {
            return block_2568(state, tracer, fn_state);
        } else {
            return block_2566(state, tracer, fn_state);
        };
    }
    fn block_2566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2566_0: const #0u : u8
        let s_2566_0: bool = false;
        // D s_2566_1: write-var gs#400144 <= s_2566_0
        fn_state.gs_400144 = s_2566_0;
        // N s_2566_2: jump b2567
        return block_2567(state, tracer, fn_state);
    }
    fn block_2567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2567_0: read-var gs#400144:u8
        let s_2567_0: bool = fn_state.gs_400144;
        // D s_2567_1: write-var gs#400145 <= s_2567_0
        fn_state.gs_400145 = s_2567_0;
        // N s_2567_2: jump b735
        return block_735(state, tracer, fn_state);
    }
    fn block_2568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2568_0: const #16s : i
        let s_2568_0: i128 = 16;
        // D s_2568_1: read-var u#31266:u32
        let s_2568_1: u32 = fn_state.u_31266;
        // D s_2568_2: cast zx s_2568_1 -> bv
        let s_2568_2: Bits = Bits::new(s_2568_1 as u128, 32u16);
        // C s_2568_3: const #1s : i64
        let s_2568_3: i64 = 1;
        // C s_2568_4: cast zx s_2568_3 -> i
        let s_2568_4: i128 = (i128::try_from(s_2568_3).unwrap());
        // C s_2568_5: const #1s : i
        let s_2568_5: i128 = 1;
        // C s_2568_6: add s_2568_5 s_2568_4
        let s_2568_6: i128 = (s_2568_5 + s_2568_4);
        // D s_2568_7: bit-extract s_2568_2 s_2568_0 s_2568_6
        let s_2568_7: Bits = (Bits::new(
            ((s_2568_2) >> (s_2568_0)).value(),
            u16::try_from(s_2568_6).unwrap(),
        ));
        // D s_2568_8: cast reint s_2568_7 -> u8
        let s_2568_8: u8 = (s_2568_7.value() as u8);
        // D s_2568_9: cast zx s_2568_8 -> bv
        let s_2568_9: Bits = Bits::new(s_2568_8 as u128, 2u16);
        // C s_2568_10: const #2u : u8
        let s_2568_10: u8 = 2;
        // C s_2568_11: cast zx s_2568_10 -> bv
        let s_2568_11: Bits = Bits::new(s_2568_10 as u128, 2u16);
        // D s_2568_12: cmp-eq s_2568_9 s_2568_11
        let s_2568_12: bool = ((s_2568_9) == (s_2568_11));
        // N s_2568_13: branch s_2568_12 b2571 b2569
        if s_2568_12 {
            return block_2571(state, tracer, fn_state);
        } else {
            return block_2569(state, tracer, fn_state);
        };
    }
    fn block_2569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2569_0: const #0u : u8
        let s_2569_0: bool = false;
        // D s_2569_1: write-var gs#400143 <= s_2569_0
        fn_state.gs_400143 = s_2569_0;
        // N s_2569_2: jump b2570
        return block_2570(state, tracer, fn_state);
    }
    fn block_2570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2570_0: read-var gs#400143:u8
        let s_2570_0: bool = fn_state.gs_400143;
        // D s_2570_1: write-var gs#400144 <= s_2570_0
        fn_state.gs_400144 = s_2570_0;
        // N s_2570_2: jump b2567
        return block_2567(state, tracer, fn_state);
    }
    fn block_2571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2571_0: const #6s : i
        let s_2571_0: i128 = 6;
        // D s_2571_1: read-var u#31266:u32
        let s_2571_1: u32 = fn_state.u_31266;
        // D s_2571_2: cast zx s_2571_1 -> bv
        let s_2571_2: Bits = Bits::new(s_2571_1 as u128, 32u16);
        // C s_2571_3: const #1s : i64
        let s_2571_3: i64 = 1;
        // C s_2571_4: cast zx s_2571_3 -> i
        let s_2571_4: i128 = (i128::try_from(s_2571_3).unwrap());
        // C s_2571_5: const #5s : i
        let s_2571_5: i128 = 5;
        // C s_2571_6: add s_2571_5 s_2571_4
        let s_2571_6: i128 = (s_2571_5 + s_2571_4);
        // D s_2571_7: bit-extract s_2571_2 s_2571_0 s_2571_6
        let s_2571_7: Bits = (Bits::new(
            ((s_2571_2) >> (s_2571_0)).value(),
            u16::try_from(s_2571_6).unwrap(),
        ));
        // D s_2571_8: cast reint s_2571_7 -> u8
        let s_2571_8: u8 = (s_2571_7.value() as u8);
        // D s_2571_9: cast zx s_2571_8 -> bv
        let s_2571_9: Bits = Bits::new(s_2571_8 as u128, 6u16);
        // C s_2571_10: const #8u : u8
        let s_2571_10: u8 = 8;
        // C s_2571_11: cast zx s_2571_10 -> bv
        let s_2571_11: Bits = Bits::new(s_2571_10 as u128, 6u16);
        // D s_2571_12: cmp-eq s_2571_9 s_2571_11
        let s_2571_12: bool = ((s_2571_9) == (s_2571_11));
        // N s_2571_13: branch s_2571_12 b2574 b2572
        if s_2571_12 {
            return block_2574(state, tracer, fn_state);
        } else {
            return block_2572(state, tracer, fn_state);
        };
    }
    fn block_2572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2572_0: const #0u : u8
        let s_2572_0: bool = false;
        // D s_2572_1: write-var gs#400142 <= s_2572_0
        fn_state.gs_400142 = s_2572_0;
        // N s_2572_2: jump b2573
        return block_2573(state, tracer, fn_state);
    }
    fn block_2573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2573_0: read-var gs#400142:u8
        let s_2573_0: bool = fn_state.gs_400142;
        // D s_2573_1: write-var gs#400143 <= s_2573_0
        fn_state.gs_400143 = s_2573_0;
        // N s_2573_2: jump b2570
        return block_2570(state, tracer, fn_state);
    }
    fn block_2574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2574_0: const #4s : i
        let s_2574_0: i128 = 4;
        // D s_2574_1: read-var u#31266:u32
        let s_2574_1: u32 = fn_state.u_31266;
        // D s_2574_2: cast zx s_2574_1 -> bv
        let s_2574_2: Bits = Bits::new(s_2574_1 as u128, 32u16);
        // C s_2574_3: const #1s : i64
        let s_2574_3: i64 = 1;
        // C s_2574_4: cast zx s_2574_3 -> i
        let s_2574_4: i128 = (i128::try_from(s_2574_3).unwrap());
        // C s_2574_5: const #0s : i
        let s_2574_5: i128 = 0;
        // C s_2574_6: add s_2574_5 s_2574_4
        let s_2574_6: i128 = (s_2574_5 + s_2574_4);
        // D s_2574_7: bit-extract s_2574_2 s_2574_0 s_2574_6
        let s_2574_7: Bits = (Bits::new(
            ((s_2574_2) >> (s_2574_0)).value(),
            u16::try_from(s_2574_6).unwrap(),
        ));
        // D s_2574_8: cast reint s_2574_7 -> u8
        let s_2574_8: bool = ((s_2574_7.value()) != 0);
        // D s_2574_9: cast zx s_2574_8 -> bv
        let s_2574_9: Bits = Bits::new(s_2574_8 as u128, 1u16);
        // C s_2574_10: const #0u : u8
        let s_2574_10: bool = false;
        // C s_2574_11: cast zx s_2574_10 -> bv
        let s_2574_11: Bits = Bits::new(s_2574_10 as u128, 1u16);
        // D s_2574_12: cmp-eq s_2574_9 s_2574_11
        let s_2574_12: bool = ((s_2574_9) == (s_2574_11));
        // D s_2574_13: write-var gs#400142 <= s_2574_12
        fn_state.gs_400142 = s_2574_12;
        // N s_2574_14: jump b2573
        return block_2573(state, tracer, fn_state);
    }
    fn block_2575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2575_0: const #3536s : i
        let s_2575_0: i128 = 3536;
        // C s_2575_1: const #14696u : u32
        let s_2575_1: u32 = 14696;
        // D s_2575_2: read-reg s_2575_1:i
        let s_2575_2: i128 = {
            let value = state.read_register::<i128>(s_2575_1 as isize);
            tracer.read_register(s_2575_1 as isize, value);
            value
        };
        // D s_2575_3: cmp-lt s_2575_2 s_2575_0
        let s_2575_3: bool = ((s_2575_2) < (s_2575_0));
        // D s_2575_4: write-var gs#400116 <= s_2575_3
        fn_state.gs_400116 = s_2575_3;
        // N s_2575_5: jump b731
        return block_731(state, tracer, fn_state);
    }
    fn block_2576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2576_0: const #23s : i
        let s_2576_0: i128 = 23;
        // D s_2576_1: read-var u#31259:u32
        let s_2576_1: u32 = fn_state.u_31259;
        // D s_2576_2: cast zx s_2576_1 -> bv
        let s_2576_2: Bits = Bits::new(s_2576_1 as u128, 32u16);
        // C s_2576_3: const #1s : i64
        let s_2576_3: i64 = 1;
        // C s_2576_4: cast zx s_2576_3 -> i
        let s_2576_4: i128 = (i128::try_from(s_2576_3).unwrap());
        // C s_2576_5: const #0s : i
        let s_2576_5: i128 = 0;
        // C s_2576_6: add s_2576_5 s_2576_4
        let s_2576_6: i128 = (s_2576_5 + s_2576_4);
        // D s_2576_7: bit-extract s_2576_2 s_2576_0 s_2576_6
        let s_2576_7: Bits = (Bits::new(
            ((s_2576_2) >> (s_2576_0)).value(),
            u16::try_from(s_2576_6).unwrap(),
        ));
        // D s_2576_8: cast reint s_2576_7 -> u8
        let s_2576_8: bool = ((s_2576_7.value()) != 0);
        // D s_2576_9: cast zx s_2576_8 -> bv
        let s_2576_9: Bits = Bits::new(s_2576_8 as u128, 1u16);
        // C s_2576_10: const #1u : u8
        let s_2576_10: bool = true;
        // C s_2576_11: cast zx s_2576_10 -> bv
        let s_2576_11: Bits = Bits::new(s_2576_10 as u128, 1u16);
        // D s_2576_12: cmp-eq s_2576_9 s_2576_11
        let s_2576_12: bool = ((s_2576_9) == (s_2576_11));
        // N s_2576_13: branch s_2576_12 b2579 b2577
        if s_2576_12 {
            return block_2579(state, tracer, fn_state);
        } else {
            return block_2577(state, tracer, fn_state);
        };
    }
    fn block_2577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2577_0: const #0u : u8
        let s_2577_0: bool = false;
        // D s_2577_1: write-var gs#400113 <= s_2577_0
        fn_state.gs_400113 = s_2577_0;
        // N s_2577_2: jump b2578
        return block_2578(state, tracer, fn_state);
    }
    fn block_2578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2578_0: read-var gs#400113:u8
        let s_2578_0: bool = fn_state.gs_400113;
        // D s_2578_1: write-var gs#400114 <= s_2578_0
        fn_state.gs_400114 = s_2578_0;
        // N s_2578_2: jump b729
        return block_729(state, tracer, fn_state);
    }
    fn block_2579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2579_0: const #16s : i
        let s_2579_0: i128 = 16;
        // D s_2579_1: read-var u#31259:u32
        let s_2579_1: u32 = fn_state.u_31259;
        // D s_2579_2: cast zx s_2579_1 -> bv
        let s_2579_2: Bits = Bits::new(s_2579_1 as u128, 32u16);
        // C s_2579_3: const #1s : i64
        let s_2579_3: i64 = 1;
        // C s_2579_4: cast zx s_2579_3 -> i
        let s_2579_4: i128 = (i128::try_from(s_2579_3).unwrap());
        // C s_2579_5: const #2s : i
        let s_2579_5: i128 = 2;
        // C s_2579_6: add s_2579_5 s_2579_4
        let s_2579_6: i128 = (s_2579_5 + s_2579_4);
        // D s_2579_7: bit-extract s_2579_2 s_2579_0 s_2579_6
        let s_2579_7: Bits = (Bits::new(
            ((s_2579_2) >> (s_2579_0)).value(),
            u16::try_from(s_2579_6).unwrap(),
        ));
        // D s_2579_8: cast reint s_2579_7 -> u8
        let s_2579_8: u8 = (s_2579_7.value() as u8);
        // D s_2579_9: cast zx s_2579_8 -> bv
        let s_2579_9: Bits = Bits::new(s_2579_8 as u128, 3u16);
        // C s_2579_10: const #0u : u8
        let s_2579_10: u8 = 0;
        // C s_2579_11: cast zx s_2579_10 -> bv
        let s_2579_11: Bits = Bits::new(s_2579_10 as u128, 3u16);
        // D s_2579_12: cmp-eq s_2579_9 s_2579_11
        let s_2579_12: bool = ((s_2579_9) == (s_2579_11));
        // N s_2579_13: branch s_2579_12 b2582 b2580
        if s_2579_12 {
            return block_2582(state, tracer, fn_state);
        } else {
            return block_2580(state, tracer, fn_state);
        };
    }
    fn block_2580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2580_0: const #0u : u8
        let s_2580_0: bool = false;
        // D s_2580_1: write-var gs#400112 <= s_2580_0
        fn_state.gs_400112 = s_2580_0;
        // N s_2580_2: jump b2581
        return block_2581(state, tracer, fn_state);
    }
    fn block_2581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2581_0: read-var gs#400112:u8
        let s_2581_0: bool = fn_state.gs_400112;
        // D s_2581_1: write-var gs#400113 <= s_2581_0
        fn_state.gs_400113 = s_2581_0;
        // N s_2581_2: jump b2578
        return block_2578(state, tracer, fn_state);
    }
    fn block_2582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2582_0: const #6s : i
        let s_2582_0: i128 = 6;
        // D s_2582_1: read-var u#31259:u32
        let s_2582_1: u32 = fn_state.u_31259;
        // D s_2582_2: cast zx s_2582_1 -> bv
        let s_2582_2: Bits = Bits::new(s_2582_1 as u128, 32u16);
        // C s_2582_3: const #1s : i64
        let s_2582_3: i64 = 1;
        // C s_2582_4: cast zx s_2582_3 -> i
        let s_2582_4: i128 = (i128::try_from(s_2582_3).unwrap());
        // C s_2582_5: const #5s : i
        let s_2582_5: i128 = 5;
        // C s_2582_6: add s_2582_5 s_2582_4
        let s_2582_6: i128 = (s_2582_5 + s_2582_4);
        // D s_2582_7: bit-extract s_2582_2 s_2582_0 s_2582_6
        let s_2582_7: Bits = (Bits::new(
            ((s_2582_2) >> (s_2582_0)).value(),
            u16::try_from(s_2582_6).unwrap(),
        ));
        // D s_2582_8: cast reint s_2582_7 -> u8
        let s_2582_8: u8 = (s_2582_7.value() as u8);
        // D s_2582_9: cast zx s_2582_8 -> bv
        let s_2582_9: Bits = Bits::new(s_2582_8 as u128, 6u16);
        // C s_2582_10: const #40u : u8
        let s_2582_10: u8 = 40;
        // C s_2582_11: cast zx s_2582_10 -> bv
        let s_2582_11: Bits = Bits::new(s_2582_10 as u128, 6u16);
        // D s_2582_12: cmp-eq s_2582_9 s_2582_11
        let s_2582_12: bool = ((s_2582_9) == (s_2582_11));
        // N s_2582_13: branch s_2582_12 b2585 b2583
        if s_2582_12 {
            return block_2585(state, tracer, fn_state);
        } else {
            return block_2583(state, tracer, fn_state);
        };
    }
    fn block_2583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2583_0: const #0u : u8
        let s_2583_0: bool = false;
        // D s_2583_1: write-var gs#400111 <= s_2583_0
        fn_state.gs_400111 = s_2583_0;
        // N s_2583_2: jump b2584
        return block_2584(state, tracer, fn_state);
    }
    fn block_2584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2584_0: read-var gs#400111:u8
        let s_2584_0: bool = fn_state.gs_400111;
        // D s_2584_1: write-var gs#400112 <= s_2584_0
        fn_state.gs_400112 = s_2584_0;
        // N s_2584_2: jump b2581
        return block_2581(state, tracer, fn_state);
    }
    fn block_2585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2585_0: const #4s : i
        let s_2585_0: i128 = 4;
        // D s_2585_1: read-var u#31259:u32
        let s_2585_1: u32 = fn_state.u_31259;
        // D s_2585_2: cast zx s_2585_1 -> bv
        let s_2585_2: Bits = Bits::new(s_2585_1 as u128, 32u16);
        // C s_2585_3: const #1s : i64
        let s_2585_3: i64 = 1;
        // C s_2585_4: cast zx s_2585_3 -> i
        let s_2585_4: i128 = (i128::try_from(s_2585_3).unwrap());
        // C s_2585_5: const #0s : i
        let s_2585_5: i128 = 0;
        // C s_2585_6: add s_2585_5 s_2585_4
        let s_2585_6: i128 = (s_2585_5 + s_2585_4);
        // D s_2585_7: bit-extract s_2585_2 s_2585_0 s_2585_6
        let s_2585_7: Bits = (Bits::new(
            ((s_2585_2) >> (s_2585_0)).value(),
            u16::try_from(s_2585_6).unwrap(),
        ));
        // D s_2585_8: cast reint s_2585_7 -> u8
        let s_2585_8: bool = ((s_2585_7.value()) != 0);
        // D s_2585_9: cast zx s_2585_8 -> bv
        let s_2585_9: Bits = Bits::new(s_2585_8 as u128, 1u16);
        // C s_2585_10: const #1u : u8
        let s_2585_10: bool = true;
        // C s_2585_11: cast zx s_2585_10 -> bv
        let s_2585_11: Bits = Bits::new(s_2585_10 as u128, 1u16);
        // D s_2585_12: cmp-eq s_2585_9 s_2585_11
        let s_2585_12: bool = ((s_2585_9) == (s_2585_11));
        // D s_2585_13: write-var gs#400111 <= s_2585_12
        fn_state.gs_400111 = s_2585_12;
        // N s_2585_14: jump b2584
        return block_2584(state, tracer, fn_state);
    }
    fn block_2586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2586_0: const #3530s : i
        let s_2586_0: i128 = 3530;
        // C s_2586_1: const #14696u : u32
        let s_2586_1: u32 = 14696;
        // D s_2586_2: read-reg s_2586_1:i
        let s_2586_2: i128 = {
            let value = state.read_register::<i128>(s_2586_1 as isize);
            tracer.read_register(s_2586_1 as isize, value);
            value
        };
        // D s_2586_3: cmp-lt s_2586_2 s_2586_0
        let s_2586_3: bool = ((s_2586_2) < (s_2586_0));
        // D s_2586_4: write-var gs#400081 <= s_2586_3
        fn_state.gs_400081 = s_2586_3;
        // N s_2586_5: jump b725
        return block_725(state, tracer, fn_state);
    }
    fn block_2587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2587_0: const #23s : i
        let s_2587_0: i128 = 23;
        // D s_2587_1: read-var u#31249:u32
        let s_2587_1: u32 = fn_state.u_31249;
        // D s_2587_2: cast zx s_2587_1 -> bv
        let s_2587_2: Bits = Bits::new(s_2587_1 as u128, 32u16);
        // C s_2587_3: const #1s : i64
        let s_2587_3: i64 = 1;
        // C s_2587_4: cast zx s_2587_3 -> i
        let s_2587_4: i128 = (i128::try_from(s_2587_3).unwrap());
        // C s_2587_5: const #0s : i
        let s_2587_5: i128 = 0;
        // C s_2587_6: add s_2587_5 s_2587_4
        let s_2587_6: i128 = (s_2587_5 + s_2587_4);
        // D s_2587_7: bit-extract s_2587_2 s_2587_0 s_2587_6
        let s_2587_7: Bits = (Bits::new(
            ((s_2587_2) >> (s_2587_0)).value(),
            u16::try_from(s_2587_6).unwrap(),
        ));
        // D s_2587_8: cast reint s_2587_7 -> u8
        let s_2587_8: bool = ((s_2587_7.value()) != 0);
        // D s_2587_9: cast zx s_2587_8 -> bv
        let s_2587_9: Bits = Bits::new(s_2587_8 as u128, 1u16);
        // C s_2587_10: const #1u : u8
        let s_2587_10: bool = true;
        // C s_2587_11: cast zx s_2587_10 -> bv
        let s_2587_11: Bits = Bits::new(s_2587_10 as u128, 1u16);
        // D s_2587_12: cmp-eq s_2587_9 s_2587_11
        let s_2587_12: bool = ((s_2587_9) == (s_2587_11));
        // N s_2587_13: branch s_2587_12 b2590 b2588
        if s_2587_12 {
            return block_2590(state, tracer, fn_state);
        } else {
            return block_2588(state, tracer, fn_state);
        };
    }
    fn block_2588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2588_0: const #0u : u8
        let s_2588_0: bool = false;
        // D s_2588_1: write-var gs#400078 <= s_2588_0
        fn_state.gs_400078 = s_2588_0;
        // N s_2588_2: jump b2589
        return block_2589(state, tracer, fn_state);
    }
    fn block_2589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2589_0: read-var gs#400078:u8
        let s_2589_0: bool = fn_state.gs_400078;
        // D s_2589_1: write-var gs#400079 <= s_2589_0
        fn_state.gs_400079 = s_2589_0;
        // N s_2589_2: jump b723
        return block_723(state, tracer, fn_state);
    }
    fn block_2590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2590_0: const #19s : i
        let s_2590_0: i128 = 19;
        // D s_2590_1: read-var u#31249:u32
        let s_2590_1: u32 = fn_state.u_31249;
        // D s_2590_2: cast zx s_2590_1 -> bv
        let s_2590_2: Bits = Bits::new(s_2590_1 as u128, 32u16);
        // C s_2590_3: const #1s : i64
        let s_2590_3: i64 = 1;
        // C s_2590_4: cast zx s_2590_3 -> i
        let s_2590_4: i128 = (i128::try_from(s_2590_3).unwrap());
        // C s_2590_5: const #2s : i
        let s_2590_5: i128 = 2;
        // C s_2590_6: add s_2590_5 s_2590_4
        let s_2590_6: i128 = (s_2590_5 + s_2590_4);
        // D s_2590_7: bit-extract s_2590_2 s_2590_0 s_2590_6
        let s_2590_7: Bits = (Bits::new(
            ((s_2590_2) >> (s_2590_0)).value(),
            u16::try_from(s_2590_6).unwrap(),
        ));
        // D s_2590_8: cast reint s_2590_7 -> u8
        let s_2590_8: u8 = (s_2590_7.value() as u8);
        // D s_2590_9: cast zx s_2590_8 -> bv
        let s_2590_9: Bits = Bits::new(s_2590_8 as u128, 3u16);
        // C s_2590_10: const #0u : u8
        let s_2590_10: u8 = 0;
        // C s_2590_11: cast zx s_2590_10 -> bv
        let s_2590_11: Bits = Bits::new(s_2590_10 as u128, 3u16);
        // D s_2590_12: cmp-eq s_2590_9 s_2590_11
        let s_2590_12: bool = ((s_2590_9) == (s_2590_11));
        // N s_2590_13: branch s_2590_12 b2593 b2591
        if s_2590_12 {
            return block_2593(state, tracer, fn_state);
        } else {
            return block_2591(state, tracer, fn_state);
        };
    }
    fn block_2591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2591_0: const #0u : u8
        let s_2591_0: bool = false;
        // D s_2591_1: write-var gs#400077 <= s_2591_0
        fn_state.gs_400077 = s_2591_0;
        // N s_2591_2: jump b2592
        return block_2592(state, tracer, fn_state);
    }
    fn block_2592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2592_0: read-var gs#400077:u8
        let s_2592_0: bool = fn_state.gs_400077;
        // D s_2592_1: write-var gs#400078 <= s_2592_0
        fn_state.gs_400078 = s_2592_0;
        // N s_2592_2: jump b2589
        return block_2589(state, tracer, fn_state);
    }
    fn block_2593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2593_0: const #7s : i
        let s_2593_0: i128 = 7;
        // D s_2593_1: read-var u#31249:u32
        let s_2593_1: u32 = fn_state.u_31249;
        // D s_2593_2: cast zx s_2593_1 -> bv
        let s_2593_2: Bits = Bits::new(s_2593_1 as u128, 32u16);
        // C s_2593_3: const #1s : i64
        let s_2593_3: i64 = 1;
        // C s_2593_4: cast zx s_2593_3 -> i
        let s_2593_4: i128 = (i128::try_from(s_2593_3).unwrap());
        // C s_2593_5: const #4s : i
        let s_2593_5: i128 = 4;
        // C s_2593_6: add s_2593_5 s_2593_4
        let s_2593_6: i128 = (s_2593_5 + s_2593_4);
        // D s_2593_7: bit-extract s_2593_2 s_2593_0 s_2593_6
        let s_2593_7: Bits = (Bits::new(
            ((s_2593_2) >> (s_2593_0)).value(),
            u16::try_from(s_2593_6).unwrap(),
        ));
        // D s_2593_8: cast reint s_2593_7 -> u8
        let s_2593_8: u8 = (s_2593_7.value() as u8);
        // D s_2593_9: cast zx s_2593_8 -> bv
        let s_2593_9: Bits = Bits::new(s_2593_8 as u128, 5u16);
        // C s_2593_10: const #28u : u8
        let s_2593_10: u8 = 28;
        // C s_2593_11: cast zx s_2593_10 -> bv
        let s_2593_11: Bits = Bits::new(s_2593_10 as u128, 5u16);
        // D s_2593_12: cmp-eq s_2593_9 s_2593_11
        let s_2593_12: bool = ((s_2593_9) == (s_2593_11));
        // N s_2593_13: branch s_2593_12 b2596 b2594
        if s_2593_12 {
            return block_2596(state, tracer, fn_state);
        } else {
            return block_2594(state, tracer, fn_state);
        };
    }
    fn block_2594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2594_0: const #0u : u8
        let s_2594_0: bool = false;
        // D s_2594_1: write-var gs#400076 <= s_2594_0
        fn_state.gs_400076 = s_2594_0;
        // N s_2594_2: jump b2595
        return block_2595(state, tracer, fn_state);
    }
    fn block_2595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2595_0: read-var gs#400076:u8
        let s_2595_0: bool = fn_state.gs_400076;
        // D s_2595_1: write-var gs#400077 <= s_2595_0
        fn_state.gs_400077 = s_2595_0;
        // N s_2595_2: jump b2592
        return block_2592(state, tracer, fn_state);
    }
    fn block_2596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2596_0: const #4s : i
        let s_2596_0: i128 = 4;
        // D s_2596_1: read-var u#31249:u32
        let s_2596_1: u32 = fn_state.u_31249;
        // D s_2596_2: cast zx s_2596_1 -> bv
        let s_2596_2: Bits = Bits::new(s_2596_1 as u128, 32u16);
        // C s_2596_3: const #1s : i64
        let s_2596_3: i64 = 1;
        // C s_2596_4: cast zx s_2596_3 -> i
        let s_2596_4: i128 = (i128::try_from(s_2596_3).unwrap());
        // C s_2596_5: const #1s : i
        let s_2596_5: i128 = 1;
        // C s_2596_6: add s_2596_5 s_2596_4
        let s_2596_6: i128 = (s_2596_5 + s_2596_4);
        // D s_2596_7: bit-extract s_2596_2 s_2596_0 s_2596_6
        let s_2596_7: Bits = (Bits::new(
            ((s_2596_2) >> (s_2596_0)).value(),
            u16::try_from(s_2596_6).unwrap(),
        ));
        // D s_2596_8: cast reint s_2596_7 -> u8
        let s_2596_8: u8 = (s_2596_7.value() as u8);
        // D s_2596_9: cast zx s_2596_8 -> bv
        let s_2596_9: Bits = Bits::new(s_2596_8 as u128, 2u16);
        // C s_2596_10: const #3u : u8
        let s_2596_10: u8 = 3;
        // C s_2596_11: cast zx s_2596_10 -> bv
        let s_2596_11: Bits = Bits::new(s_2596_10 as u128, 2u16);
        // D s_2596_12: cmp-eq s_2596_9 s_2596_11
        let s_2596_12: bool = ((s_2596_9) == (s_2596_11));
        // D s_2596_13: write-var gs#400076 <= s_2596_12
        fn_state.gs_400076 = s_2596_12;
        // N s_2596_14: jump b2595
        return block_2595(state, tracer, fn_state);
    }
    fn block_2597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2597_0: const #3529s : i
        let s_2597_0: i128 = 3529;
        // C s_2597_1: const #14696u : u32
        let s_2597_1: u32 = 14696;
        // D s_2597_2: read-reg s_2597_1:i
        let s_2597_2: i128 = {
            let value = state.read_register::<i128>(s_2597_1 as isize);
            tracer.read_register(s_2597_1 as isize, value);
            value
        };
        // D s_2597_3: cmp-lt s_2597_2 s_2597_0
        let s_2597_3: bool = ((s_2597_2) < (s_2597_0));
        // D s_2597_4: write-var gs#400046 <= s_2597_3
        fn_state.gs_400046 = s_2597_3;
        // N s_2597_5: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_2598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2598_0: const #23s : i
        let s_2598_0: i128 = 23;
        // D s_2598_1: read-var u#31239:u32
        let s_2598_1: u32 = fn_state.u_31239;
        // D s_2598_2: cast zx s_2598_1 -> bv
        let s_2598_2: Bits = Bits::new(s_2598_1 as u128, 32u16);
        // C s_2598_3: const #1s : i64
        let s_2598_3: i64 = 1;
        // C s_2598_4: cast zx s_2598_3 -> i
        let s_2598_4: i128 = (i128::try_from(s_2598_3).unwrap());
        // C s_2598_5: const #0s : i
        let s_2598_5: i128 = 0;
        // C s_2598_6: add s_2598_5 s_2598_4
        let s_2598_6: i128 = (s_2598_5 + s_2598_4);
        // D s_2598_7: bit-extract s_2598_2 s_2598_0 s_2598_6
        let s_2598_7: Bits = (Bits::new(
            ((s_2598_2) >> (s_2598_0)).value(),
            u16::try_from(s_2598_6).unwrap(),
        ));
        // D s_2598_8: cast reint s_2598_7 -> u8
        let s_2598_8: bool = ((s_2598_7.value()) != 0);
        // D s_2598_9: cast zx s_2598_8 -> bv
        let s_2598_9: Bits = Bits::new(s_2598_8 as u128, 1u16);
        // C s_2598_10: const #1u : u8
        let s_2598_10: bool = true;
        // C s_2598_11: cast zx s_2598_10 -> bv
        let s_2598_11: Bits = Bits::new(s_2598_10 as u128, 1u16);
        // D s_2598_12: cmp-eq s_2598_9 s_2598_11
        let s_2598_12: bool = ((s_2598_9) == (s_2598_11));
        // N s_2598_13: branch s_2598_12 b2601 b2599
        if s_2598_12 {
            return block_2601(state, tracer, fn_state);
        } else {
            return block_2599(state, tracer, fn_state);
        };
    }
    fn block_2599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2599_0: const #0u : u8
        let s_2599_0: bool = false;
        // D s_2599_1: write-var gs#400043 <= s_2599_0
        fn_state.gs_400043 = s_2599_0;
        // N s_2599_2: jump b2600
        return block_2600(state, tracer, fn_state);
    }
    fn block_2600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2600_0: read-var gs#400043:u8
        let s_2600_0: bool = fn_state.gs_400043;
        // D s_2600_1: write-var gs#400044 <= s_2600_0
        fn_state.gs_400044 = s_2600_0;
        // N s_2600_2: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_2601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2601_0: const #19s : i
        let s_2601_0: i128 = 19;
        // D s_2601_1: read-var u#31239:u32
        let s_2601_1: u32 = fn_state.u_31239;
        // D s_2601_2: cast zx s_2601_1 -> bv
        let s_2601_2: Bits = Bits::new(s_2601_1 as u128, 32u16);
        // C s_2601_3: const #1s : i64
        let s_2601_3: i64 = 1;
        // C s_2601_4: cast zx s_2601_3 -> i
        let s_2601_4: i128 = (i128::try_from(s_2601_3).unwrap());
        // C s_2601_5: const #2s : i
        let s_2601_5: i128 = 2;
        // C s_2601_6: add s_2601_5 s_2601_4
        let s_2601_6: i128 = (s_2601_5 + s_2601_4);
        // D s_2601_7: bit-extract s_2601_2 s_2601_0 s_2601_6
        let s_2601_7: Bits = (Bits::new(
            ((s_2601_2) >> (s_2601_0)).value(),
            u16::try_from(s_2601_6).unwrap(),
        ));
        // D s_2601_8: cast reint s_2601_7 -> u8
        let s_2601_8: u8 = (s_2601_7.value() as u8);
        // D s_2601_9: cast zx s_2601_8 -> bv
        let s_2601_9: Bits = Bits::new(s_2601_8 as u128, 3u16);
        // C s_2601_10: const #0u : u8
        let s_2601_10: u8 = 0;
        // C s_2601_11: cast zx s_2601_10 -> bv
        let s_2601_11: Bits = Bits::new(s_2601_10 as u128, 3u16);
        // D s_2601_12: cmp-eq s_2601_9 s_2601_11
        let s_2601_12: bool = ((s_2601_9) == (s_2601_11));
        // N s_2601_13: branch s_2601_12 b2604 b2602
        if s_2601_12 {
            return block_2604(state, tracer, fn_state);
        } else {
            return block_2602(state, tracer, fn_state);
        };
    }
    fn block_2602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2602_0: const #0u : u8
        let s_2602_0: bool = false;
        // D s_2602_1: write-var gs#400042 <= s_2602_0
        fn_state.gs_400042 = s_2602_0;
        // N s_2602_2: jump b2603
        return block_2603(state, tracer, fn_state);
    }
    fn block_2603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2603_0: read-var gs#400042:u8
        let s_2603_0: bool = fn_state.gs_400042;
        // D s_2603_1: write-var gs#400043 <= s_2603_0
        fn_state.gs_400043 = s_2603_0;
        // N s_2603_2: jump b2600
        return block_2600(state, tracer, fn_state);
    }
    fn block_2604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2604_0: const #10s : i
        let s_2604_0: i128 = 10;
        // D s_2604_1: read-var u#31239:u32
        let s_2604_1: u32 = fn_state.u_31239;
        // D s_2604_2: cast zx s_2604_1 -> bv
        let s_2604_2: Bits = Bits::new(s_2604_1 as u128, 32u16);
        // C s_2604_3: const #1s : i64
        let s_2604_3: i64 = 1;
        // C s_2604_4: cast zx s_2604_3 -> i
        let s_2604_4: i128 = (i128::try_from(s_2604_3).unwrap());
        // C s_2604_5: const #1s : i
        let s_2604_5: i128 = 1;
        // C s_2604_6: add s_2604_5 s_2604_4
        let s_2604_6: i128 = (s_2604_5 + s_2604_4);
        // D s_2604_7: bit-extract s_2604_2 s_2604_0 s_2604_6
        let s_2604_7: Bits = (Bits::new(
            ((s_2604_2) >> (s_2604_0)).value(),
            u16::try_from(s_2604_6).unwrap(),
        ));
        // D s_2604_8: cast reint s_2604_7 -> u8
        let s_2604_8: u8 = (s_2604_7.value() as u8);
        // D s_2604_9: cast zx s_2604_8 -> bv
        let s_2604_9: Bits = Bits::new(s_2604_8 as u128, 2u16);
        // C s_2604_10: const #3u : u8
        let s_2604_10: u8 = 3;
        // C s_2604_11: cast zx s_2604_10 -> bv
        let s_2604_11: Bits = Bits::new(s_2604_10 as u128, 2u16);
        // D s_2604_12: cmp-eq s_2604_9 s_2604_11
        let s_2604_12: bool = ((s_2604_9) == (s_2604_11));
        // N s_2604_13: branch s_2604_12 b2607 b2605
        if s_2604_12 {
            return block_2607(state, tracer, fn_state);
        } else {
            return block_2605(state, tracer, fn_state);
        };
    }
    fn block_2605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2605_0: const #0u : u8
        let s_2605_0: bool = false;
        // D s_2605_1: write-var gs#400041 <= s_2605_0
        fn_state.gs_400041 = s_2605_0;
        // N s_2605_2: jump b2606
        return block_2606(state, tracer, fn_state);
    }
    fn block_2606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2606_0: read-var gs#400041:u8
        let s_2606_0: bool = fn_state.gs_400041;
        // D s_2606_1: write-var gs#400042 <= s_2606_0
        fn_state.gs_400042 = s_2606_0;
        // N s_2606_2: jump b2603
        return block_2603(state, tracer, fn_state);
    }
    fn block_2607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2607_0: const #7s : i
        let s_2607_0: i128 = 7;
        // D s_2607_1: read-var u#31239:u32
        let s_2607_1: u32 = fn_state.u_31239;
        // D s_2607_2: cast zx s_2607_1 -> bv
        let s_2607_2: Bits = Bits::new(s_2607_1 as u128, 32u16);
        // C s_2607_3: const #1s : i64
        let s_2607_3: i64 = 1;
        // C s_2607_4: cast zx s_2607_3 -> i
        let s_2607_4: i128 = (i128::try_from(s_2607_3).unwrap());
        // C s_2607_5: const #0s : i
        let s_2607_5: i128 = 0;
        // C s_2607_6: add s_2607_5 s_2607_4
        let s_2607_6: i128 = (s_2607_5 + s_2607_4);
        // D s_2607_7: bit-extract s_2607_2 s_2607_0 s_2607_6
        let s_2607_7: Bits = (Bits::new(
            ((s_2607_2) >> (s_2607_0)).value(),
            u16::try_from(s_2607_6).unwrap(),
        ));
        // D s_2607_8: cast reint s_2607_7 -> u8
        let s_2607_8: bool = ((s_2607_7.value()) != 0);
        // D s_2607_9: cast zx s_2607_8 -> bv
        let s_2607_9: Bits = Bits::new(s_2607_8 as u128, 1u16);
        // C s_2607_10: const #0u : u8
        let s_2607_10: bool = false;
        // C s_2607_11: cast zx s_2607_10 -> bv
        let s_2607_11: Bits = Bits::new(s_2607_10 as u128, 1u16);
        // D s_2607_12: cmp-eq s_2607_9 s_2607_11
        let s_2607_12: bool = ((s_2607_9) == (s_2607_11));
        // N s_2607_13: branch s_2607_12 b2610 b2608
        if s_2607_12 {
            return block_2610(state, tracer, fn_state);
        } else {
            return block_2608(state, tracer, fn_state);
        };
    }
    fn block_2608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2608_0: const #0u : u8
        let s_2608_0: bool = false;
        // D s_2608_1: write-var gs#400040 <= s_2608_0
        fn_state.gs_400040 = s_2608_0;
        // N s_2608_2: jump b2609
        return block_2609(state, tracer, fn_state);
    }
    fn block_2609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2609_0: read-var gs#400040:u8
        let s_2609_0: bool = fn_state.gs_400040;
        // D s_2609_1: write-var gs#400041 <= s_2609_0
        fn_state.gs_400041 = s_2609_0;
        // N s_2609_2: jump b2606
        return block_2606(state, tracer, fn_state);
    }
    fn block_2610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2610_0: const #4s : i
        let s_2610_0: i128 = 4;
        // D s_2610_1: read-var u#31239:u32
        let s_2610_1: u32 = fn_state.u_31239;
        // D s_2610_2: cast zx s_2610_1 -> bv
        let s_2610_2: Bits = Bits::new(s_2610_1 as u128, 32u16);
        // C s_2610_3: const #1s : i64
        let s_2610_3: i64 = 1;
        // C s_2610_4: cast zx s_2610_3 -> i
        let s_2610_4: i128 = (i128::try_from(s_2610_3).unwrap());
        // C s_2610_5: const #1s : i
        let s_2610_5: i128 = 1;
        // C s_2610_6: add s_2610_5 s_2610_4
        let s_2610_6: i128 = (s_2610_5 + s_2610_4);
        // D s_2610_7: bit-extract s_2610_2 s_2610_0 s_2610_6
        let s_2610_7: Bits = (Bits::new(
            ((s_2610_2) >> (s_2610_0)).value(),
            u16::try_from(s_2610_6).unwrap(),
        ));
        // D s_2610_8: cast reint s_2610_7 -> u8
        let s_2610_8: u8 = (s_2610_7.value() as u8);
        // D s_2610_9: cast zx s_2610_8 -> bv
        let s_2610_9: Bits = Bits::new(s_2610_8 as u128, 2u16);
        // C s_2610_10: const #1u : u8
        let s_2610_10: u8 = 1;
        // C s_2610_11: cast zx s_2610_10 -> bv
        let s_2610_11: Bits = Bits::new(s_2610_10 as u128, 2u16);
        // D s_2610_12: cmp-eq s_2610_9 s_2610_11
        let s_2610_12: bool = ((s_2610_9) == (s_2610_11));
        // D s_2610_13: write-var gs#400040 <= s_2610_12
        fn_state.gs_400040 = s_2610_12;
        // N s_2610_14: jump b2609
        return block_2609(state, tracer, fn_state);
    }
    fn block_2611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2611_0: const #3528s : i
        let s_2611_0: i128 = 3528;
        // C s_2611_1: const #14696u : u32
        let s_2611_1: u32 = 14696;
        // D s_2611_2: read-reg s_2611_1:i
        let s_2611_2: i128 = {
            let value = state.read_register::<i128>(s_2611_1 as isize);
            tracer.read_register(s_2611_1 as isize, value);
            value
        };
        // D s_2611_3: cmp-lt s_2611_2 s_2611_0
        let s_2611_3: bool = ((s_2611_2) < (s_2611_0));
        // D s_2611_4: write-var gs#400008 <= s_2611_3
        fn_state.gs_400008 = s_2611_3;
        // N s_2611_5: jump b713
        return block_713(state, tracer, fn_state);
    }
    fn block_2612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2612_0: const #23s : i
        let s_2612_0: i128 = 23;
        // D s_2612_1: read-var u#31229:u32
        let s_2612_1: u32 = fn_state.u_31229;
        // D s_2612_2: cast zx s_2612_1 -> bv
        let s_2612_2: Bits = Bits::new(s_2612_1 as u128, 32u16);
        // C s_2612_3: const #1s : i64
        let s_2612_3: i64 = 1;
        // C s_2612_4: cast zx s_2612_3 -> i
        let s_2612_4: i128 = (i128::try_from(s_2612_3).unwrap());
        // C s_2612_5: const #0s : i
        let s_2612_5: i128 = 0;
        // C s_2612_6: add s_2612_5 s_2612_4
        let s_2612_6: i128 = (s_2612_5 + s_2612_4);
        // D s_2612_7: bit-extract s_2612_2 s_2612_0 s_2612_6
        let s_2612_7: Bits = (Bits::new(
            ((s_2612_2) >> (s_2612_0)).value(),
            u16::try_from(s_2612_6).unwrap(),
        ));
        // D s_2612_8: cast reint s_2612_7 -> u8
        let s_2612_8: bool = ((s_2612_7.value()) != 0);
        // D s_2612_9: cast zx s_2612_8 -> bv
        let s_2612_9: Bits = Bits::new(s_2612_8 as u128, 1u16);
        // C s_2612_10: const #1u : u8
        let s_2612_10: bool = true;
        // C s_2612_11: cast zx s_2612_10 -> bv
        let s_2612_11: Bits = Bits::new(s_2612_10 as u128, 1u16);
        // D s_2612_12: cmp-eq s_2612_9 s_2612_11
        let s_2612_12: bool = ((s_2612_9) == (s_2612_11));
        // N s_2612_13: branch s_2612_12 b2615 b2613
        if s_2612_12 {
            return block_2615(state, tracer, fn_state);
        } else {
            return block_2613(state, tracer, fn_state);
        };
    }
    fn block_2613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2613_0: const #0u : u8
        let s_2613_0: bool = false;
        // D s_2613_1: write-var gs#400005 <= s_2613_0
        fn_state.gs_400005 = s_2613_0;
        // N s_2613_2: jump b2614
        return block_2614(state, tracer, fn_state);
    }
    fn block_2614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2614_0: read-var gs#400005:u8
        let s_2614_0: bool = fn_state.gs_400005;
        // D s_2614_1: write-var gs#400006 <= s_2614_0
        fn_state.gs_400006 = s_2614_0;
        // N s_2614_2: jump b711
        return block_711(state, tracer, fn_state);
    }
    fn block_2615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2615_0: const #19s : i
        let s_2615_0: i128 = 19;
        // D s_2615_1: read-var u#31229:u32
        let s_2615_1: u32 = fn_state.u_31229;
        // D s_2615_2: cast zx s_2615_1 -> bv
        let s_2615_2: Bits = Bits::new(s_2615_1 as u128, 32u16);
        // C s_2615_3: const #1s : i64
        let s_2615_3: i64 = 1;
        // C s_2615_4: cast zx s_2615_3 -> i
        let s_2615_4: i128 = (i128::try_from(s_2615_3).unwrap());
        // C s_2615_5: const #2s : i
        let s_2615_5: i128 = 2;
        // C s_2615_6: add s_2615_5 s_2615_4
        let s_2615_6: i128 = (s_2615_5 + s_2615_4);
        // D s_2615_7: bit-extract s_2615_2 s_2615_0 s_2615_6
        let s_2615_7: Bits = (Bits::new(
            ((s_2615_2) >> (s_2615_0)).value(),
            u16::try_from(s_2615_6).unwrap(),
        ));
        // D s_2615_8: cast reint s_2615_7 -> u8
        let s_2615_8: u8 = (s_2615_7.value() as u8);
        // D s_2615_9: cast zx s_2615_8 -> bv
        let s_2615_9: Bits = Bits::new(s_2615_8 as u128, 3u16);
        // C s_2615_10: const #0u : u8
        let s_2615_10: u8 = 0;
        // C s_2615_11: cast zx s_2615_10 -> bv
        let s_2615_11: Bits = Bits::new(s_2615_10 as u128, 3u16);
        // D s_2615_12: cmp-eq s_2615_9 s_2615_11
        let s_2615_12: bool = ((s_2615_9) == (s_2615_11));
        // N s_2615_13: branch s_2615_12 b2618 b2616
        if s_2615_12 {
            return block_2618(state, tracer, fn_state);
        } else {
            return block_2616(state, tracer, fn_state);
        };
    }
    fn block_2616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2616_0: const #0u : u8
        let s_2616_0: bool = false;
        // D s_2616_1: write-var gs#400004 <= s_2616_0
        fn_state.gs_400004 = s_2616_0;
        // N s_2616_2: jump b2617
        return block_2617(state, tracer, fn_state);
    }
    fn block_2617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2617_0: read-var gs#400004:u8
        let s_2617_0: bool = fn_state.gs_400004;
        // D s_2617_1: write-var gs#400005 <= s_2617_0
        fn_state.gs_400005 = s_2617_0;
        // N s_2617_2: jump b2614
        return block_2614(state, tracer, fn_state);
    }
    fn block_2618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2618_0: const #10s : i
        let s_2618_0: i128 = 10;
        // D s_2618_1: read-var u#31229:u32
        let s_2618_1: u32 = fn_state.u_31229;
        // D s_2618_2: cast zx s_2618_1 -> bv
        let s_2618_2: Bits = Bits::new(s_2618_1 as u128, 32u16);
        // C s_2618_3: const #1s : i64
        let s_2618_3: i64 = 1;
        // C s_2618_4: cast zx s_2618_3 -> i
        let s_2618_4: i128 = (i128::try_from(s_2618_3).unwrap());
        // C s_2618_5: const #1s : i
        let s_2618_5: i128 = 1;
        // C s_2618_6: add s_2618_5 s_2618_4
        let s_2618_6: i128 = (s_2618_5 + s_2618_4);
        // D s_2618_7: bit-extract s_2618_2 s_2618_0 s_2618_6
        let s_2618_7: Bits = (Bits::new(
            ((s_2618_2) >> (s_2618_0)).value(),
            u16::try_from(s_2618_6).unwrap(),
        ));
        // D s_2618_8: cast reint s_2618_7 -> u8
        let s_2618_8: u8 = (s_2618_7.value() as u8);
        // D s_2618_9: cast zx s_2618_8 -> bv
        let s_2618_9: Bits = Bits::new(s_2618_8 as u128, 2u16);
        // C s_2618_10: const #2u : u8
        let s_2618_10: u8 = 2;
        // C s_2618_11: cast zx s_2618_10 -> bv
        let s_2618_11: Bits = Bits::new(s_2618_10 as u128, 2u16);
        // D s_2618_12: cmp-eq s_2618_9 s_2618_11
        let s_2618_12: bool = ((s_2618_9) == (s_2618_11));
        // N s_2618_13: branch s_2618_12 b2621 b2619
        if s_2618_12 {
            return block_2621(state, tracer, fn_state);
        } else {
            return block_2619(state, tracer, fn_state);
        };
    }
    fn block_2619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2619_0: const #0u : u8
        let s_2619_0: bool = false;
        // D s_2619_1: write-var gs#400003 <= s_2619_0
        fn_state.gs_400003 = s_2619_0;
        // N s_2619_2: jump b2620
        return block_2620(state, tracer, fn_state);
    }
    fn block_2620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2620_0: read-var gs#400003:u8
        let s_2620_0: bool = fn_state.gs_400003;
        // D s_2620_1: write-var gs#400004 <= s_2620_0
        fn_state.gs_400004 = s_2620_0;
        // N s_2620_2: jump b2617
        return block_2617(state, tracer, fn_state);
    }
    fn block_2621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2621_0: const #7s : i
        let s_2621_0: i128 = 7;
        // D s_2621_1: read-var u#31229:u32
        let s_2621_1: u32 = fn_state.u_31229;
        // D s_2621_2: cast zx s_2621_1 -> bv
        let s_2621_2: Bits = Bits::new(s_2621_1 as u128, 32u16);
        // C s_2621_3: const #1s : i64
        let s_2621_3: i64 = 1;
        // C s_2621_4: cast zx s_2621_3 -> i
        let s_2621_4: i128 = (i128::try_from(s_2621_3).unwrap());
        // C s_2621_5: const #1s : i
        let s_2621_5: i128 = 1;
        // C s_2621_6: add s_2621_5 s_2621_4
        let s_2621_6: i128 = (s_2621_5 + s_2621_4);
        // D s_2621_7: bit-extract s_2621_2 s_2621_0 s_2621_6
        let s_2621_7: Bits = (Bits::new(
            ((s_2621_2) >> (s_2621_0)).value(),
            u16::try_from(s_2621_6).unwrap(),
        ));
        // D s_2621_8: cast reint s_2621_7 -> u8
        let s_2621_8: u8 = (s_2621_7.value() as u8);
        // D s_2621_9: cast zx s_2621_8 -> bv
        let s_2621_9: Bits = Bits::new(s_2621_8 as u128, 2u16);
        // C s_2621_10: const #0u : u8
        let s_2621_10: u8 = 0;
        // C s_2621_11: cast zx s_2621_10 -> bv
        let s_2621_11: Bits = Bits::new(s_2621_10 as u128, 2u16);
        // D s_2621_12: cmp-eq s_2621_9 s_2621_11
        let s_2621_12: bool = ((s_2621_9) == (s_2621_11));
        // N s_2621_13: branch s_2621_12 b2624 b2622
        if s_2621_12 {
            return block_2624(state, tracer, fn_state);
        } else {
            return block_2622(state, tracer, fn_state);
        };
    }
    fn block_2622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2622_0: const #0u : u8
        let s_2622_0: bool = false;
        // D s_2622_1: write-var gs#400002 <= s_2622_0
        fn_state.gs_400002 = s_2622_0;
        // N s_2622_2: jump b2623
        return block_2623(state, tracer, fn_state);
    }
    fn block_2623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2623_0: read-var gs#400002:u8
        let s_2623_0: bool = fn_state.gs_400002;
        // D s_2623_1: write-var gs#400003 <= s_2623_0
        fn_state.gs_400003 = s_2623_0;
        // N s_2623_2: jump b2620
        return block_2620(state, tracer, fn_state);
    }
    fn block_2624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2624_0: const #4s : i
        let s_2624_0: i128 = 4;
        // D s_2624_1: read-var u#31229:u32
        let s_2624_1: u32 = fn_state.u_31229;
        // D s_2624_2: cast zx s_2624_1 -> bv
        let s_2624_2: Bits = Bits::new(s_2624_1 as u128, 32u16);
        // C s_2624_3: const #1s : i64
        let s_2624_3: i64 = 1;
        // C s_2624_4: cast zx s_2624_3 -> i
        let s_2624_4: i128 = (i128::try_from(s_2624_3).unwrap());
        // C s_2624_5: const #1s : i
        let s_2624_5: i128 = 1;
        // C s_2624_6: add s_2624_5 s_2624_4
        let s_2624_6: i128 = (s_2624_5 + s_2624_4);
        // D s_2624_7: bit-extract s_2624_2 s_2624_0 s_2624_6
        let s_2624_7: Bits = (Bits::new(
            ((s_2624_2) >> (s_2624_0)).value(),
            u16::try_from(s_2624_6).unwrap(),
        ));
        // D s_2624_8: cast reint s_2624_7 -> u8
        let s_2624_8: u8 = (s_2624_7.value() as u8);
        // D s_2624_9: cast zx s_2624_8 -> bv
        let s_2624_9: Bits = Bits::new(s_2624_8 as u128, 2u16);
        // C s_2624_10: const #1u : u8
        let s_2624_10: u8 = 1;
        // C s_2624_11: cast zx s_2624_10 -> bv
        let s_2624_11: Bits = Bits::new(s_2624_10 as u128, 2u16);
        // D s_2624_12: cmp-eq s_2624_9 s_2624_11
        let s_2624_12: bool = ((s_2624_9) == (s_2624_11));
        // D s_2624_13: write-var gs#400002 <= s_2624_12
        fn_state.gs_400002 = s_2624_12;
        // N s_2624_14: jump b2623
        return block_2623(state, tracer, fn_state);
    }
    fn block_2625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2625_0: const #3526s : i
        let s_2625_0: i128 = 3526;
        // C s_2625_1: const #14696u : u32
        let s_2625_1: u32 = 14696;
        // D s_2625_2: read-reg s_2625_1:i
        let s_2625_2: i128 = {
            let value = state.read_register::<i128>(s_2625_1 as isize);
            tracer.read_register(s_2625_1 as isize, value);
            value
        };
        // D s_2625_3: cmp-lt s_2625_2 s_2625_0
        let s_2625_3: bool = ((s_2625_2) < (s_2625_0));
        // D s_2625_4: write-var gs#399970 <= s_2625_3
        fn_state.gs_399970 = s_2625_3;
        // N s_2625_5: jump b707
        return block_707(state, tracer, fn_state);
    }
    fn block_2626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2626_0: const #23s : i
        let s_2626_0: i128 = 23;
        // D s_2626_1: read-var u#31219:u32
        let s_2626_1: u32 = fn_state.u_31219;
        // D s_2626_2: cast zx s_2626_1 -> bv
        let s_2626_2: Bits = Bits::new(s_2626_1 as u128, 32u16);
        // C s_2626_3: const #1s : i64
        let s_2626_3: i64 = 1;
        // C s_2626_4: cast zx s_2626_3 -> i
        let s_2626_4: i128 = (i128::try_from(s_2626_3).unwrap());
        // C s_2626_5: const #0s : i
        let s_2626_5: i128 = 0;
        // C s_2626_6: add s_2626_5 s_2626_4
        let s_2626_6: i128 = (s_2626_5 + s_2626_4);
        // D s_2626_7: bit-extract s_2626_2 s_2626_0 s_2626_6
        let s_2626_7: Bits = (Bits::new(
            ((s_2626_2) >> (s_2626_0)).value(),
            u16::try_from(s_2626_6).unwrap(),
        ));
        // D s_2626_8: cast reint s_2626_7 -> u8
        let s_2626_8: bool = ((s_2626_7.value()) != 0);
        // D s_2626_9: cast zx s_2626_8 -> bv
        let s_2626_9: Bits = Bits::new(s_2626_8 as u128, 1u16);
        // C s_2626_10: const #1u : u8
        let s_2626_10: bool = true;
        // C s_2626_11: cast zx s_2626_10 -> bv
        let s_2626_11: Bits = Bits::new(s_2626_10 as u128, 1u16);
        // D s_2626_12: cmp-eq s_2626_9 s_2626_11
        let s_2626_12: bool = ((s_2626_9) == (s_2626_11));
        // N s_2626_13: branch s_2626_12 b2629 b2627
        if s_2626_12 {
            return block_2629(state, tracer, fn_state);
        } else {
            return block_2627(state, tracer, fn_state);
        };
    }
    fn block_2627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2627_0: const #0u : u8
        let s_2627_0: bool = false;
        // D s_2627_1: write-var gs#399967 <= s_2627_0
        fn_state.gs_399967 = s_2627_0;
        // N s_2627_2: jump b2628
        return block_2628(state, tracer, fn_state);
    }
    fn block_2628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2628_0: read-var gs#399967:u8
        let s_2628_0: bool = fn_state.gs_399967;
        // D s_2628_1: write-var gs#399968 <= s_2628_0
        fn_state.gs_399968 = s_2628_0;
        // N s_2628_2: jump b705
        return block_705(state, tracer, fn_state);
    }
    fn block_2629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2629_0: const #19s : i
        let s_2629_0: i128 = 19;
        // D s_2629_1: read-var u#31219:u32
        let s_2629_1: u32 = fn_state.u_31219;
        // D s_2629_2: cast zx s_2629_1 -> bv
        let s_2629_2: Bits = Bits::new(s_2629_1 as u128, 32u16);
        // C s_2629_3: const #1s : i64
        let s_2629_3: i64 = 1;
        // C s_2629_4: cast zx s_2629_3 -> i
        let s_2629_4: i128 = (i128::try_from(s_2629_3).unwrap());
        // C s_2629_5: const #2s : i
        let s_2629_5: i128 = 2;
        // C s_2629_6: add s_2629_5 s_2629_4
        let s_2629_6: i128 = (s_2629_5 + s_2629_4);
        // D s_2629_7: bit-extract s_2629_2 s_2629_0 s_2629_6
        let s_2629_7: Bits = (Bits::new(
            ((s_2629_2) >> (s_2629_0)).value(),
            u16::try_from(s_2629_6).unwrap(),
        ));
        // D s_2629_8: cast reint s_2629_7 -> u8
        let s_2629_8: u8 = (s_2629_7.value() as u8);
        // D s_2629_9: cast zx s_2629_8 -> bv
        let s_2629_9: Bits = Bits::new(s_2629_8 as u128, 3u16);
        // C s_2629_10: const #0u : u8
        let s_2629_10: u8 = 0;
        // C s_2629_11: cast zx s_2629_10 -> bv
        let s_2629_11: Bits = Bits::new(s_2629_10 as u128, 3u16);
        // D s_2629_12: cmp-eq s_2629_9 s_2629_11
        let s_2629_12: bool = ((s_2629_9) == (s_2629_11));
        // N s_2629_13: branch s_2629_12 b2632 b2630
        if s_2629_12 {
            return block_2632(state, tracer, fn_state);
        } else {
            return block_2630(state, tracer, fn_state);
        };
    }
    fn block_2630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2630_0: const #0u : u8
        let s_2630_0: bool = false;
        // D s_2630_1: write-var gs#399966 <= s_2630_0
        fn_state.gs_399966 = s_2630_0;
        // N s_2630_2: jump b2631
        return block_2631(state, tracer, fn_state);
    }
    fn block_2631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2631_0: read-var gs#399966:u8
        let s_2631_0: bool = fn_state.gs_399966;
        // D s_2631_1: write-var gs#399967 <= s_2631_0
        fn_state.gs_399967 = s_2631_0;
        // N s_2631_2: jump b2628
        return block_2628(state, tracer, fn_state);
    }
    fn block_2632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2632_0: const #11s : i
        let s_2632_0: i128 = 11;
        // D s_2632_1: read-var u#31219:u32
        let s_2632_1: u32 = fn_state.u_31219;
        // D s_2632_2: cast zx s_2632_1 -> bv
        let s_2632_2: Bits = Bits::new(s_2632_1 as u128, 32u16);
        // C s_2632_3: const #1s : i64
        let s_2632_3: i64 = 1;
        // C s_2632_4: cast zx s_2632_3 -> i
        let s_2632_4: i128 = (i128::try_from(s_2632_3).unwrap());
        // C s_2632_5: const #0s : i
        let s_2632_5: i128 = 0;
        // C s_2632_6: add s_2632_5 s_2632_4
        let s_2632_6: i128 = (s_2632_5 + s_2632_4);
        // D s_2632_7: bit-extract s_2632_2 s_2632_0 s_2632_6
        let s_2632_7: Bits = (Bits::new(
            ((s_2632_2) >> (s_2632_0)).value(),
            u16::try_from(s_2632_6).unwrap(),
        ));
        // D s_2632_8: cast reint s_2632_7 -> u8
        let s_2632_8: bool = ((s_2632_7.value()) != 0);
        // D s_2632_9: cast zx s_2632_8 -> bv
        let s_2632_9: Bits = Bits::new(s_2632_8 as u128, 1u16);
        // C s_2632_10: const #0u : u8
        let s_2632_10: bool = false;
        // C s_2632_11: cast zx s_2632_10 -> bv
        let s_2632_11: Bits = Bits::new(s_2632_10 as u128, 1u16);
        // D s_2632_12: cmp-eq s_2632_9 s_2632_11
        let s_2632_12: bool = ((s_2632_9) == (s_2632_11));
        // N s_2632_13: branch s_2632_12 b2635 b2633
        if s_2632_12 {
            return block_2635(state, tracer, fn_state);
        } else {
            return block_2633(state, tracer, fn_state);
        };
    }
    fn block_2633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2633_0: const #0u : u8
        let s_2633_0: bool = false;
        // D s_2633_1: write-var gs#399965 <= s_2633_0
        fn_state.gs_399965 = s_2633_0;
        // N s_2633_2: jump b2634
        return block_2634(state, tracer, fn_state);
    }
    fn block_2634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2634_0: read-var gs#399965:u8
        let s_2634_0: bool = fn_state.gs_399965;
        // D s_2634_1: write-var gs#399966 <= s_2634_0
        fn_state.gs_399966 = s_2634_0;
        // N s_2634_2: jump b2631
        return block_2631(state, tracer, fn_state);
    }
    fn block_2635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2635_0: const #7s : i
        let s_2635_0: i128 = 7;
        // D s_2635_1: read-var u#31219:u32
        let s_2635_1: u32 = fn_state.u_31219;
        // D s_2635_2: cast zx s_2635_1 -> bv
        let s_2635_2: Bits = Bits::new(s_2635_1 as u128, 32u16);
        // C s_2635_3: const #1s : i64
        let s_2635_3: i64 = 1;
        // C s_2635_4: cast zx s_2635_3 -> i
        let s_2635_4: i128 = (i128::try_from(s_2635_3).unwrap());
        // C s_2635_5: const #1s : i
        let s_2635_5: i128 = 1;
        // C s_2635_6: add s_2635_5 s_2635_4
        let s_2635_6: i128 = (s_2635_5 + s_2635_4);
        // D s_2635_7: bit-extract s_2635_2 s_2635_0 s_2635_6
        let s_2635_7: Bits = (Bits::new(
            ((s_2635_2) >> (s_2635_0)).value(),
            u16::try_from(s_2635_6).unwrap(),
        ));
        // D s_2635_8: cast reint s_2635_7 -> u8
        let s_2635_8: u8 = (s_2635_7.value() as u8);
        // D s_2635_9: cast zx s_2635_8 -> bv
        let s_2635_9: Bits = Bits::new(s_2635_8 as u128, 2u16);
        // C s_2635_10: const #0u : u8
        let s_2635_10: u8 = 0;
        // C s_2635_11: cast zx s_2635_10 -> bv
        let s_2635_11: Bits = Bits::new(s_2635_10 as u128, 2u16);
        // D s_2635_12: cmp-eq s_2635_9 s_2635_11
        let s_2635_12: bool = ((s_2635_9) == (s_2635_11));
        // N s_2635_13: branch s_2635_12 b2638 b2636
        if s_2635_12 {
            return block_2638(state, tracer, fn_state);
        } else {
            return block_2636(state, tracer, fn_state);
        };
    }
    fn block_2636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2636_0: const #0u : u8
        let s_2636_0: bool = false;
        // D s_2636_1: write-var gs#399964 <= s_2636_0
        fn_state.gs_399964 = s_2636_0;
        // N s_2636_2: jump b2637
        return block_2637(state, tracer, fn_state);
    }
    fn block_2637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2637_0: read-var gs#399964:u8
        let s_2637_0: bool = fn_state.gs_399964;
        // D s_2637_1: write-var gs#399965 <= s_2637_0
        fn_state.gs_399965 = s_2637_0;
        // N s_2637_2: jump b2634
        return block_2634(state, tracer, fn_state);
    }
    fn block_2638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2638_0: const #4s : i
        let s_2638_0: i128 = 4;
        // D s_2638_1: read-var u#31219:u32
        let s_2638_1: u32 = fn_state.u_31219;
        // D s_2638_2: cast zx s_2638_1 -> bv
        let s_2638_2: Bits = Bits::new(s_2638_1 as u128, 32u16);
        // C s_2638_3: const #1s : i64
        let s_2638_3: i64 = 1;
        // C s_2638_4: cast zx s_2638_3 -> i
        let s_2638_4: i128 = (i128::try_from(s_2638_3).unwrap());
        // C s_2638_5: const #1s : i
        let s_2638_5: i128 = 1;
        // C s_2638_6: add s_2638_5 s_2638_4
        let s_2638_6: i128 = (s_2638_5 + s_2638_4);
        // D s_2638_7: bit-extract s_2638_2 s_2638_0 s_2638_6
        let s_2638_7: Bits = (Bits::new(
            ((s_2638_2) >> (s_2638_0)).value(),
            u16::try_from(s_2638_6).unwrap(),
        ));
        // D s_2638_8: cast reint s_2638_7 -> u8
        let s_2638_8: u8 = (s_2638_7.value() as u8);
        // D s_2638_9: cast zx s_2638_8 -> bv
        let s_2638_9: Bits = Bits::new(s_2638_8 as u128, 2u16);
        // C s_2638_10: const #1u : u8
        let s_2638_10: u8 = 1;
        // C s_2638_11: cast zx s_2638_10 -> bv
        let s_2638_11: Bits = Bits::new(s_2638_10 as u128, 2u16);
        // D s_2638_12: cmp-eq s_2638_9 s_2638_11
        let s_2638_12: bool = ((s_2638_9) == (s_2638_11));
        // D s_2638_13: write-var gs#399964 <= s_2638_12
        fn_state.gs_399964 = s_2638_12;
        // N s_2638_14: jump b2637
        return block_2637(state, tracer, fn_state);
    }
    fn block_2639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2639_0: const #3517s : i
        let s_2639_0: i128 = 3517;
        // C s_2639_1: const #14696u : u32
        let s_2639_1: u32 = 14696;
        // D s_2639_2: read-reg s_2639_1:i
        let s_2639_2: i128 = {
            let value = state.read_register::<i128>(s_2639_1 as isize);
            tracer.read_register(s_2639_1 as isize, value);
            value
        };
        // D s_2639_3: cmp-lt s_2639_2 s_2639_0
        let s_2639_3: bool = ((s_2639_2) < (s_2639_0));
        // D s_2639_4: write-var gs#399930 <= s_2639_3
        fn_state.gs_399930 = s_2639_3;
        // N s_2639_5: jump b701
        return block_701(state, tracer, fn_state);
    }
    fn block_2640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2640_0: const #23s : i
        let s_2640_0: i128 = 23;
        // D s_2640_1: read-var u#31208:u32
        let s_2640_1: u32 = fn_state.u_31208;
        // D s_2640_2: cast zx s_2640_1 -> bv
        let s_2640_2: Bits = Bits::new(s_2640_1 as u128, 32u16);
        // C s_2640_3: const #1s : i64
        let s_2640_3: i64 = 1;
        // C s_2640_4: cast zx s_2640_3 -> i
        let s_2640_4: i128 = (i128::try_from(s_2640_3).unwrap());
        // C s_2640_5: const #0s : i
        let s_2640_5: i128 = 0;
        // C s_2640_6: add s_2640_5 s_2640_4
        let s_2640_6: i128 = (s_2640_5 + s_2640_4);
        // D s_2640_7: bit-extract s_2640_2 s_2640_0 s_2640_6
        let s_2640_7: Bits = (Bits::new(
            ((s_2640_2) >> (s_2640_0)).value(),
            u16::try_from(s_2640_6).unwrap(),
        ));
        // D s_2640_8: cast reint s_2640_7 -> u8
        let s_2640_8: bool = ((s_2640_7.value()) != 0);
        // D s_2640_9: cast zx s_2640_8 -> bv
        let s_2640_9: Bits = Bits::new(s_2640_8 as u128, 1u16);
        // C s_2640_10: const #1u : u8
        let s_2640_10: bool = true;
        // C s_2640_11: cast zx s_2640_10 -> bv
        let s_2640_11: Bits = Bits::new(s_2640_10 as u128, 1u16);
        // D s_2640_12: cmp-eq s_2640_9 s_2640_11
        let s_2640_12: bool = ((s_2640_9) == (s_2640_11));
        // N s_2640_13: branch s_2640_12 b2643 b2641
        if s_2640_12 {
            return block_2643(state, tracer, fn_state);
        } else {
            return block_2641(state, tracer, fn_state);
        };
    }
    fn block_2641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2641_0: const #0u : u8
        let s_2641_0: bool = false;
        // D s_2641_1: write-var gs#399927 <= s_2641_0
        fn_state.gs_399927 = s_2641_0;
        // N s_2641_2: jump b2642
        return block_2642(state, tracer, fn_state);
    }
    fn block_2642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2642_0: read-var gs#399927:u8
        let s_2642_0: bool = fn_state.gs_399927;
        // D s_2642_1: write-var gs#399928 <= s_2642_0
        fn_state.gs_399928 = s_2642_0;
        // N s_2642_2: jump b699
        return block_699(state, tracer, fn_state);
    }
    fn block_2643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2643_0: const #11s : i
        let s_2643_0: i128 = 11;
        // D s_2643_1: read-var u#31208:u32
        let s_2643_1: u32 = fn_state.u_31208;
        // D s_2643_2: cast zx s_2643_1 -> bv
        let s_2643_2: Bits = Bits::new(s_2643_1 as u128, 32u16);
        // C s_2643_3: const #1s : i64
        let s_2643_3: i64 = 1;
        // C s_2643_4: cast zx s_2643_3 -> i
        let s_2643_4: i128 = (i128::try_from(s_2643_3).unwrap());
        // C s_2643_5: const #0s : i
        let s_2643_5: i128 = 0;
        // C s_2643_6: add s_2643_5 s_2643_4
        let s_2643_6: i128 = (s_2643_5 + s_2643_4);
        // D s_2643_7: bit-extract s_2643_2 s_2643_0 s_2643_6
        let s_2643_7: Bits = (Bits::new(
            ((s_2643_2) >> (s_2643_0)).value(),
            u16::try_from(s_2643_6).unwrap(),
        ));
        // D s_2643_8: cast reint s_2643_7 -> u8
        let s_2643_8: bool = ((s_2643_7.value()) != 0);
        // D s_2643_9: cast zx s_2643_8 -> bv
        let s_2643_9: Bits = Bits::new(s_2643_8 as u128, 1u16);
        // C s_2643_10: const #0u : u8
        let s_2643_10: bool = false;
        // C s_2643_11: cast zx s_2643_10 -> bv
        let s_2643_11: Bits = Bits::new(s_2643_10 as u128, 1u16);
        // D s_2643_12: cmp-eq s_2643_9 s_2643_11
        let s_2643_12: bool = ((s_2643_9) == (s_2643_11));
        // N s_2643_13: branch s_2643_12 b2646 b2644
        if s_2643_12 {
            return block_2646(state, tracer, fn_state);
        } else {
            return block_2644(state, tracer, fn_state);
        };
    }
    fn block_2644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2644_0: const #0u : u8
        let s_2644_0: bool = false;
        // D s_2644_1: write-var gs#399926 <= s_2644_0
        fn_state.gs_399926 = s_2644_0;
        // N s_2644_2: jump b2645
        return block_2645(state, tracer, fn_state);
    }
    fn block_2645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2645_0: read-var gs#399926:u8
        let s_2645_0: bool = fn_state.gs_399926;
        // D s_2645_1: write-var gs#399927 <= s_2645_0
        fn_state.gs_399927 = s_2645_0;
        // N s_2645_2: jump b2642
        return block_2642(state, tracer, fn_state);
    }
    fn block_2646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2646_0: const #8s : i
        let s_2646_0: i128 = 8;
        // D s_2646_1: read-var u#31208:u32
        let s_2646_1: u32 = fn_state.u_31208;
        // D s_2646_2: cast zx s_2646_1 -> bv
        let s_2646_2: Bits = Bits::new(s_2646_1 as u128, 32u16);
        // C s_2646_3: const #1s : i64
        let s_2646_3: i64 = 1;
        // C s_2646_4: cast zx s_2646_3 -> i
        let s_2646_4: i128 = (i128::try_from(s_2646_3).unwrap());
        // C s_2646_5: const #1s : i
        let s_2646_5: i128 = 1;
        // C s_2646_6: add s_2646_5 s_2646_4
        let s_2646_6: i128 = (s_2646_5 + s_2646_4);
        // D s_2646_7: bit-extract s_2646_2 s_2646_0 s_2646_6
        let s_2646_7: Bits = (Bits::new(
            ((s_2646_2) >> (s_2646_0)).value(),
            u16::try_from(s_2646_6).unwrap(),
        ));
        // D s_2646_8: cast reint s_2646_7 -> u8
        let s_2646_8: u8 = (s_2646_7.value() as u8);
        // D s_2646_9: cast zx s_2646_8 -> bv
        let s_2646_9: Bits = Bits::new(s_2646_8 as u128, 2u16);
        // C s_2646_10: const #2u : u8
        let s_2646_10: u8 = 2;
        // C s_2646_11: cast zx s_2646_10 -> bv
        let s_2646_11: Bits = Bits::new(s_2646_10 as u128, 2u16);
        // D s_2646_12: cmp-eq s_2646_9 s_2646_11
        let s_2646_12: bool = ((s_2646_9) == (s_2646_11));
        // N s_2646_13: branch s_2646_12 b2649 b2647
        if s_2646_12 {
            return block_2649(state, tracer, fn_state);
        } else {
            return block_2647(state, tracer, fn_state);
        };
    }
    fn block_2647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2647_0: const #0u : u8
        let s_2647_0: bool = false;
        // D s_2647_1: write-var gs#399925 <= s_2647_0
        fn_state.gs_399925 = s_2647_0;
        // N s_2647_2: jump b2648
        return block_2648(state, tracer, fn_state);
    }
    fn block_2648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2648_0: read-var gs#399925:u8
        let s_2648_0: bool = fn_state.gs_399925;
        // D s_2648_1: write-var gs#399926 <= s_2648_0
        fn_state.gs_399926 = s_2648_0;
        // N s_2648_2: jump b2645
        return block_2645(state, tracer, fn_state);
    }
    fn block_2649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2649_0: const #6s : i
        let s_2649_0: i128 = 6;
        // D s_2649_1: read-var u#31208:u32
        let s_2649_1: u32 = fn_state.u_31208;
        // D s_2649_2: cast zx s_2649_1 -> bv
        let s_2649_2: Bits = Bits::new(s_2649_1 as u128, 32u16);
        // C s_2649_3: const #1s : i64
        let s_2649_3: i64 = 1;
        // C s_2649_4: cast zx s_2649_3 -> i
        let s_2649_4: i128 = (i128::try_from(s_2649_3).unwrap());
        // C s_2649_5: const #0s : i
        let s_2649_5: i128 = 0;
        // C s_2649_6: add s_2649_5 s_2649_4
        let s_2649_6: i128 = (s_2649_5 + s_2649_4);
        // D s_2649_7: bit-extract s_2649_2 s_2649_0 s_2649_6
        let s_2649_7: Bits = (Bits::new(
            ((s_2649_2) >> (s_2649_0)).value(),
            u16::try_from(s_2649_6).unwrap(),
        ));
        // D s_2649_8: cast reint s_2649_7 -> u8
        let s_2649_8: bool = ((s_2649_7.value()) != 0);
        // D s_2649_9: cast zx s_2649_8 -> bv
        let s_2649_9: Bits = Bits::new(s_2649_8 as u128, 1u16);
        // C s_2649_10: const #1u : u8
        let s_2649_10: bool = true;
        // C s_2649_11: cast zx s_2649_10 -> bv
        let s_2649_11: Bits = Bits::new(s_2649_10 as u128, 1u16);
        // D s_2649_12: cmp-eq s_2649_9 s_2649_11
        let s_2649_12: bool = ((s_2649_9) == (s_2649_11));
        // N s_2649_13: branch s_2649_12 b2652 b2650
        if s_2649_12 {
            return block_2652(state, tracer, fn_state);
        } else {
            return block_2650(state, tracer, fn_state);
        };
    }
    fn block_2650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2650_0: const #0u : u8
        let s_2650_0: bool = false;
        // D s_2650_1: write-var gs#399924 <= s_2650_0
        fn_state.gs_399924 = s_2650_0;
        // N s_2650_2: jump b2651
        return block_2651(state, tracer, fn_state);
    }
    fn block_2651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2651_0: read-var gs#399924:u8
        let s_2651_0: bool = fn_state.gs_399924;
        // D s_2651_1: write-var gs#399925 <= s_2651_0
        fn_state.gs_399925 = s_2651_0;
        // N s_2651_2: jump b2648
        return block_2648(state, tracer, fn_state);
    }
    fn block_2652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2652_0: const #4s : i
        let s_2652_0: i128 = 4;
        // D s_2652_1: read-var u#31208:u32
        let s_2652_1: u32 = fn_state.u_31208;
        // D s_2652_2: cast zx s_2652_1 -> bv
        let s_2652_2: Bits = Bits::new(s_2652_1 as u128, 32u16);
        // C s_2652_3: const #1s : i64
        let s_2652_3: i64 = 1;
        // C s_2652_4: cast zx s_2652_3 -> i
        let s_2652_4: i128 = (i128::try_from(s_2652_3).unwrap());
        // C s_2652_5: const #0s : i
        let s_2652_5: i128 = 0;
        // C s_2652_6: add s_2652_5 s_2652_4
        let s_2652_6: i128 = (s_2652_5 + s_2652_4);
        // D s_2652_7: bit-extract s_2652_2 s_2652_0 s_2652_6
        let s_2652_7: Bits = (Bits::new(
            ((s_2652_2) >> (s_2652_0)).value(),
            u16::try_from(s_2652_6).unwrap(),
        ));
        // D s_2652_8: cast reint s_2652_7 -> u8
        let s_2652_8: bool = ((s_2652_7.value()) != 0);
        // D s_2652_9: cast zx s_2652_8 -> bv
        let s_2652_9: Bits = Bits::new(s_2652_8 as u128, 1u16);
        // C s_2652_10: const #0u : u8
        let s_2652_10: bool = false;
        // C s_2652_11: cast zx s_2652_10 -> bv
        let s_2652_11: Bits = Bits::new(s_2652_10 as u128, 1u16);
        // D s_2652_12: cmp-eq s_2652_9 s_2652_11
        let s_2652_12: bool = ((s_2652_9) == (s_2652_11));
        // D s_2652_13: write-var gs#399924 <= s_2652_12
        fn_state.gs_399924 = s_2652_12;
        // N s_2652_14: jump b2651
        return block_2651(state, tracer, fn_state);
    }
    fn block_2653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2653_0: const #3516s : i
        let s_2653_0: i128 = 3516;
        // C s_2653_1: const #14696u : u32
        let s_2653_1: u32 = 14696;
        // D s_2653_2: read-reg s_2653_1:i
        let s_2653_2: i128 = {
            let value = state.read_register::<i128>(s_2653_1 as isize);
            tracer.read_register(s_2653_1 as isize, value);
            value
        };
        // D s_2653_3: cmp-lt s_2653_2 s_2653_0
        let s_2653_3: bool = ((s_2653_2) < (s_2653_0));
        // D s_2653_4: write-var gs#399888 <= s_2653_3
        fn_state.gs_399888 = s_2653_3;
        // N s_2653_5: jump b695
        return block_695(state, tracer, fn_state);
    }
    fn block_2654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2654_0: const #23s : i
        let s_2654_0: i128 = 23;
        // D s_2654_1: read-var u#31196:u32
        let s_2654_1: u32 = fn_state.u_31196;
        // D s_2654_2: cast zx s_2654_1 -> bv
        let s_2654_2: Bits = Bits::new(s_2654_1 as u128, 32u16);
        // C s_2654_3: const #1s : i64
        let s_2654_3: i64 = 1;
        // C s_2654_4: cast zx s_2654_3 -> i
        let s_2654_4: i128 = (i128::try_from(s_2654_3).unwrap());
        // C s_2654_5: const #0s : i
        let s_2654_5: i128 = 0;
        // C s_2654_6: add s_2654_5 s_2654_4
        let s_2654_6: i128 = (s_2654_5 + s_2654_4);
        // D s_2654_7: bit-extract s_2654_2 s_2654_0 s_2654_6
        let s_2654_7: Bits = (Bits::new(
            ((s_2654_2) >> (s_2654_0)).value(),
            u16::try_from(s_2654_6).unwrap(),
        ));
        // D s_2654_8: cast reint s_2654_7 -> u8
        let s_2654_8: bool = ((s_2654_7.value()) != 0);
        // D s_2654_9: cast zx s_2654_8 -> bv
        let s_2654_9: Bits = Bits::new(s_2654_8 as u128, 1u16);
        // C s_2654_10: const #1u : u8
        let s_2654_10: bool = true;
        // C s_2654_11: cast zx s_2654_10 -> bv
        let s_2654_11: Bits = Bits::new(s_2654_10 as u128, 1u16);
        // D s_2654_12: cmp-eq s_2654_9 s_2654_11
        let s_2654_12: bool = ((s_2654_9) == (s_2654_11));
        // N s_2654_13: branch s_2654_12 b2657 b2655
        if s_2654_12 {
            return block_2657(state, tracer, fn_state);
        } else {
            return block_2655(state, tracer, fn_state);
        };
    }
    fn block_2655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2655_0: const #0u : u8
        let s_2655_0: bool = false;
        // D s_2655_1: write-var gs#399885 <= s_2655_0
        fn_state.gs_399885 = s_2655_0;
        // N s_2655_2: jump b2656
        return block_2656(state, tracer, fn_state);
    }
    fn block_2656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2656_0: read-var gs#399885:u8
        let s_2656_0: bool = fn_state.gs_399885;
        // D s_2656_1: write-var gs#399886 <= s_2656_0
        fn_state.gs_399886 = s_2656_0;
        // N s_2656_2: jump b693
        return block_693(state, tracer, fn_state);
    }
    fn block_2657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2657_0: const #11s : i
        let s_2657_0: i128 = 11;
        // D s_2657_1: read-var u#31196:u32
        let s_2657_1: u32 = fn_state.u_31196;
        // D s_2657_2: cast zx s_2657_1 -> bv
        let s_2657_2: Bits = Bits::new(s_2657_1 as u128, 32u16);
        // C s_2657_3: const #1s : i64
        let s_2657_3: i64 = 1;
        // C s_2657_4: cast zx s_2657_3 -> i
        let s_2657_4: i128 = (i128::try_from(s_2657_3).unwrap());
        // C s_2657_5: const #0s : i
        let s_2657_5: i128 = 0;
        // C s_2657_6: add s_2657_5 s_2657_4
        let s_2657_6: i128 = (s_2657_5 + s_2657_4);
        // D s_2657_7: bit-extract s_2657_2 s_2657_0 s_2657_6
        let s_2657_7: Bits = (Bits::new(
            ((s_2657_2) >> (s_2657_0)).value(),
            u16::try_from(s_2657_6).unwrap(),
        ));
        // D s_2657_8: cast reint s_2657_7 -> u8
        let s_2657_8: bool = ((s_2657_7.value()) != 0);
        // D s_2657_9: cast zx s_2657_8 -> bv
        let s_2657_9: Bits = Bits::new(s_2657_8 as u128, 1u16);
        // C s_2657_10: const #0u : u8
        let s_2657_10: bool = false;
        // C s_2657_11: cast zx s_2657_10 -> bv
        let s_2657_11: Bits = Bits::new(s_2657_10 as u128, 1u16);
        // D s_2657_12: cmp-eq s_2657_9 s_2657_11
        let s_2657_12: bool = ((s_2657_9) == (s_2657_11));
        // N s_2657_13: branch s_2657_12 b2660 b2658
        if s_2657_12 {
            return block_2660(state, tracer, fn_state);
        } else {
            return block_2658(state, tracer, fn_state);
        };
    }
    fn block_2658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2658_0: const #0u : u8
        let s_2658_0: bool = false;
        // D s_2658_1: write-var gs#399884 <= s_2658_0
        fn_state.gs_399884 = s_2658_0;
        // N s_2658_2: jump b2659
        return block_2659(state, tracer, fn_state);
    }
    fn block_2659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2659_0: read-var gs#399884:u8
        let s_2659_0: bool = fn_state.gs_399884;
        // D s_2659_1: write-var gs#399885 <= s_2659_0
        fn_state.gs_399885 = s_2659_0;
        // N s_2659_2: jump b2656
        return block_2656(state, tracer, fn_state);
    }
    fn block_2660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2660_0: const #9s : i
        let s_2660_0: i128 = 9;
        // D s_2660_1: read-var u#31196:u32
        let s_2660_1: u32 = fn_state.u_31196;
        // D s_2660_2: cast zx s_2660_1 -> bv
        let s_2660_2: Bits = Bits::new(s_2660_1 as u128, 32u16);
        // C s_2660_3: const #1s : i64
        let s_2660_3: i64 = 1;
        // C s_2660_4: cast zx s_2660_3 -> i
        let s_2660_4: i128 = (i128::try_from(s_2660_3).unwrap());
        // C s_2660_5: const #0s : i
        let s_2660_5: i128 = 0;
        // C s_2660_6: add s_2660_5 s_2660_4
        let s_2660_6: i128 = (s_2660_5 + s_2660_4);
        // D s_2660_7: bit-extract s_2660_2 s_2660_0 s_2660_6
        let s_2660_7: Bits = (Bits::new(
            ((s_2660_2) >> (s_2660_0)).value(),
            u16::try_from(s_2660_6).unwrap(),
        ));
        // D s_2660_8: cast reint s_2660_7 -> u8
        let s_2660_8: bool = ((s_2660_7.value()) != 0);
        // D s_2660_9: cast zx s_2660_8 -> bv
        let s_2660_9: Bits = Bits::new(s_2660_8 as u128, 1u16);
        // C s_2660_10: const #0u : u8
        let s_2660_10: bool = false;
        // C s_2660_11: cast zx s_2660_10 -> bv
        let s_2660_11: Bits = Bits::new(s_2660_10 as u128, 1u16);
        // D s_2660_12: cmp-eq s_2660_9 s_2660_11
        let s_2660_12: bool = ((s_2660_9) == (s_2660_11));
        // N s_2660_13: branch s_2660_12 b2663 b2661
        if s_2660_12 {
            return block_2663(state, tracer, fn_state);
        } else {
            return block_2661(state, tracer, fn_state);
        };
    }
    fn block_2661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2661_0: const #0u : u8
        let s_2661_0: bool = false;
        // D s_2661_1: write-var gs#399883 <= s_2661_0
        fn_state.gs_399883 = s_2661_0;
        // N s_2661_2: jump b2662
        return block_2662(state, tracer, fn_state);
    }
    fn block_2662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2662_0: read-var gs#399883:u8
        let s_2662_0: bool = fn_state.gs_399883;
        // D s_2662_1: write-var gs#399884 <= s_2662_0
        fn_state.gs_399884 = s_2662_0;
        // N s_2662_2: jump b2659
        return block_2659(state, tracer, fn_state);
    }
    fn block_2663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2663_0: const #6s : i
        let s_2663_0: i128 = 6;
        // D s_2663_1: read-var u#31196:u32
        let s_2663_1: u32 = fn_state.u_31196;
        // D s_2663_2: cast zx s_2663_1 -> bv
        let s_2663_2: Bits = Bits::new(s_2663_1 as u128, 32u16);
        // C s_2663_3: const #1s : i64
        let s_2663_3: i64 = 1;
        // C s_2663_4: cast zx s_2663_3 -> i
        let s_2663_4: i128 = (i128::try_from(s_2663_3).unwrap());
        // C s_2663_5: const #0s : i
        let s_2663_5: i128 = 0;
        // C s_2663_6: add s_2663_5 s_2663_4
        let s_2663_6: i128 = (s_2663_5 + s_2663_4);
        // D s_2663_7: bit-extract s_2663_2 s_2663_0 s_2663_6
        let s_2663_7: Bits = (Bits::new(
            ((s_2663_2) >> (s_2663_0)).value(),
            u16::try_from(s_2663_6).unwrap(),
        ));
        // D s_2663_8: cast reint s_2663_7 -> u8
        let s_2663_8: bool = ((s_2663_7.value()) != 0);
        // D s_2663_9: cast zx s_2663_8 -> bv
        let s_2663_9: Bits = Bits::new(s_2663_8 as u128, 1u16);
        // C s_2663_10: const #1u : u8
        let s_2663_10: bool = true;
        // C s_2663_11: cast zx s_2663_10 -> bv
        let s_2663_11: Bits = Bits::new(s_2663_10 as u128, 1u16);
        // D s_2663_12: cmp-eq s_2663_9 s_2663_11
        let s_2663_12: bool = ((s_2663_9) == (s_2663_11));
        // N s_2663_13: branch s_2663_12 b2666 b2664
        if s_2663_12 {
            return block_2666(state, tracer, fn_state);
        } else {
            return block_2664(state, tracer, fn_state);
        };
    }
    fn block_2664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2664_0: const #0u : u8
        let s_2664_0: bool = false;
        // D s_2664_1: write-var gs#399882 <= s_2664_0
        fn_state.gs_399882 = s_2664_0;
        // N s_2664_2: jump b2665
        return block_2665(state, tracer, fn_state);
    }
    fn block_2665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2665_0: read-var gs#399882:u8
        let s_2665_0: bool = fn_state.gs_399882;
        // D s_2665_1: write-var gs#399883 <= s_2665_0
        fn_state.gs_399883 = s_2665_0;
        // N s_2665_2: jump b2662
        return block_2662(state, tracer, fn_state);
    }
    fn block_2666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2666_0: const #4s : i
        let s_2666_0: i128 = 4;
        // D s_2666_1: read-var u#31196:u32
        let s_2666_1: u32 = fn_state.u_31196;
        // D s_2666_2: cast zx s_2666_1 -> bv
        let s_2666_2: Bits = Bits::new(s_2666_1 as u128, 32u16);
        // C s_2666_3: const #1s : i64
        let s_2666_3: i64 = 1;
        // C s_2666_4: cast zx s_2666_3 -> i
        let s_2666_4: i128 = (i128::try_from(s_2666_3).unwrap());
        // C s_2666_5: const #0s : i
        let s_2666_5: i128 = 0;
        // C s_2666_6: add s_2666_5 s_2666_4
        let s_2666_6: i128 = (s_2666_5 + s_2666_4);
        // D s_2666_7: bit-extract s_2666_2 s_2666_0 s_2666_6
        let s_2666_7: Bits = (Bits::new(
            ((s_2666_2) >> (s_2666_0)).value(),
            u16::try_from(s_2666_6).unwrap(),
        ));
        // D s_2666_8: cast reint s_2666_7 -> u8
        let s_2666_8: bool = ((s_2666_7.value()) != 0);
        // D s_2666_9: cast zx s_2666_8 -> bv
        let s_2666_9: Bits = Bits::new(s_2666_8 as u128, 1u16);
        // C s_2666_10: const #0u : u8
        let s_2666_10: bool = false;
        // C s_2666_11: cast zx s_2666_10 -> bv
        let s_2666_11: Bits = Bits::new(s_2666_10 as u128, 1u16);
        // D s_2666_12: cmp-eq s_2666_9 s_2666_11
        let s_2666_12: bool = ((s_2666_9) == (s_2666_11));
        // D s_2666_13: write-var gs#399882 <= s_2666_12
        fn_state.gs_399882 = s_2666_12;
        // N s_2666_14: jump b2665
        return block_2665(state, tracer, fn_state);
    }
    fn block_2667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2667_0: const #3513s : i
        let s_2667_0: i128 = 3513;
        // C s_2667_1: const #14696u : u32
        let s_2667_1: u32 = 14696;
        // D s_2667_2: read-reg s_2667_1:i
        let s_2667_2: i128 = {
            let value = state.read_register::<i128>(s_2667_1 as isize);
            tracer.read_register(s_2667_1 as isize, value);
            value
        };
        // D s_2667_3: cmp-lt s_2667_2 s_2667_0
        let s_2667_3: bool = ((s_2667_2) < (s_2667_0));
        // D s_2667_4: write-var gs#399848 <= s_2667_3
        fn_state.gs_399848 = s_2667_3;
        // N s_2667_5: jump b689
        return block_689(state, tracer, fn_state);
    }
    fn block_2668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2668_0: const #23s : i
        let s_2668_0: i128 = 23;
        // D s_2668_1: read-var u#31185:u32
        let s_2668_1: u32 = fn_state.u_31185;
        // D s_2668_2: cast zx s_2668_1 -> bv
        let s_2668_2: Bits = Bits::new(s_2668_1 as u128, 32u16);
        // C s_2668_3: const #1s : i64
        let s_2668_3: i64 = 1;
        // C s_2668_4: cast zx s_2668_3 -> i
        let s_2668_4: i128 = (i128::try_from(s_2668_3).unwrap());
        // C s_2668_5: const #0s : i
        let s_2668_5: i128 = 0;
        // C s_2668_6: add s_2668_5 s_2668_4
        let s_2668_6: i128 = (s_2668_5 + s_2668_4);
        // D s_2668_7: bit-extract s_2668_2 s_2668_0 s_2668_6
        let s_2668_7: Bits = (Bits::new(
            ((s_2668_2) >> (s_2668_0)).value(),
            u16::try_from(s_2668_6).unwrap(),
        ));
        // D s_2668_8: cast reint s_2668_7 -> u8
        let s_2668_8: bool = ((s_2668_7.value()) != 0);
        // D s_2668_9: cast zx s_2668_8 -> bv
        let s_2668_9: Bits = Bits::new(s_2668_8 as u128, 1u16);
        // C s_2668_10: const #1u : u8
        let s_2668_10: bool = true;
        // C s_2668_11: cast zx s_2668_10 -> bv
        let s_2668_11: Bits = Bits::new(s_2668_10 as u128, 1u16);
        // D s_2668_12: cmp-eq s_2668_9 s_2668_11
        let s_2668_12: bool = ((s_2668_9) == (s_2668_11));
        // N s_2668_13: branch s_2668_12 b2671 b2669
        if s_2668_12 {
            return block_2671(state, tracer, fn_state);
        } else {
            return block_2669(state, tracer, fn_state);
        };
    }
    fn block_2669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2669_0: const #0u : u8
        let s_2669_0: bool = false;
        // D s_2669_1: write-var gs#399845 <= s_2669_0
        fn_state.gs_399845 = s_2669_0;
        // N s_2669_2: jump b2670
        return block_2670(state, tracer, fn_state);
    }
    fn block_2670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2670_0: read-var gs#399845:u8
        let s_2670_0: bool = fn_state.gs_399845;
        // D s_2670_1: write-var gs#399846 <= s_2670_0
        fn_state.gs_399846 = s_2670_0;
        // N s_2670_2: jump b687
        return block_687(state, tracer, fn_state);
    }
    fn block_2671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2671_0: const #10s : i
        let s_2671_0: i128 = 10;
        // D s_2671_1: read-var u#31185:u32
        let s_2671_1: u32 = fn_state.u_31185;
        // D s_2671_2: cast zx s_2671_1 -> bv
        let s_2671_2: Bits = Bits::new(s_2671_1 as u128, 32u16);
        // C s_2671_3: const #1s : i64
        let s_2671_3: i64 = 1;
        // C s_2671_4: cast zx s_2671_3 -> i
        let s_2671_4: i128 = (i128::try_from(s_2671_3).unwrap());
        // C s_2671_5: const #1s : i
        let s_2671_5: i128 = 1;
        // C s_2671_6: add s_2671_5 s_2671_4
        let s_2671_6: i128 = (s_2671_5 + s_2671_4);
        // D s_2671_7: bit-extract s_2671_2 s_2671_0 s_2671_6
        let s_2671_7: Bits = (Bits::new(
            ((s_2671_2) >> (s_2671_0)).value(),
            u16::try_from(s_2671_6).unwrap(),
        ));
        // D s_2671_8: cast reint s_2671_7 -> u8
        let s_2671_8: u8 = (s_2671_7.value() as u8);
        // D s_2671_9: cast zx s_2671_8 -> bv
        let s_2671_9: Bits = Bits::new(s_2671_8 as u128, 2u16);
        // C s_2671_10: const #2u : u8
        let s_2671_10: u8 = 2;
        // C s_2671_11: cast zx s_2671_10 -> bv
        let s_2671_11: Bits = Bits::new(s_2671_10 as u128, 2u16);
        // D s_2671_12: cmp-eq s_2671_9 s_2671_11
        let s_2671_12: bool = ((s_2671_9) == (s_2671_11));
        // N s_2671_13: branch s_2671_12 b2674 b2672
        if s_2671_12 {
            return block_2674(state, tracer, fn_state);
        } else {
            return block_2672(state, tracer, fn_state);
        };
    }
    fn block_2672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2672_0: const #0u : u8
        let s_2672_0: bool = false;
        // D s_2672_1: write-var gs#399844 <= s_2672_0
        fn_state.gs_399844 = s_2672_0;
        // N s_2672_2: jump b2673
        return block_2673(state, tracer, fn_state);
    }
    fn block_2673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2673_0: read-var gs#399844:u8
        let s_2673_0: bool = fn_state.gs_399844;
        // D s_2673_1: write-var gs#399845 <= s_2673_0
        fn_state.gs_399845 = s_2673_0;
        // N s_2673_2: jump b2670
        return block_2670(state, tracer, fn_state);
    }
    fn block_2674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2674_0: const #8s : i
        let s_2674_0: i128 = 8;
        // D s_2674_1: read-var u#31185:u32
        let s_2674_1: u32 = fn_state.u_31185;
        // D s_2674_2: cast zx s_2674_1 -> bv
        let s_2674_2: Bits = Bits::new(s_2674_1 as u128, 32u16);
        // C s_2674_3: const #1s : i64
        let s_2674_3: i64 = 1;
        // C s_2674_4: cast zx s_2674_3 -> i
        let s_2674_4: i128 = (i128::try_from(s_2674_3).unwrap());
        // C s_2674_5: const #0s : i
        let s_2674_5: i128 = 0;
        // C s_2674_6: add s_2674_5 s_2674_4
        let s_2674_6: i128 = (s_2674_5 + s_2674_4);
        // D s_2674_7: bit-extract s_2674_2 s_2674_0 s_2674_6
        let s_2674_7: Bits = (Bits::new(
            ((s_2674_2) >> (s_2674_0)).value(),
            u16::try_from(s_2674_6).unwrap(),
        ));
        // D s_2674_8: cast reint s_2674_7 -> u8
        let s_2674_8: bool = ((s_2674_7.value()) != 0);
        // D s_2674_9: cast zx s_2674_8 -> bv
        let s_2674_9: Bits = Bits::new(s_2674_8 as u128, 1u16);
        // C s_2674_10: const #0u : u8
        let s_2674_10: bool = false;
        // C s_2674_11: cast zx s_2674_10 -> bv
        let s_2674_11: Bits = Bits::new(s_2674_10 as u128, 1u16);
        // D s_2674_12: cmp-eq s_2674_9 s_2674_11
        let s_2674_12: bool = ((s_2674_9) == (s_2674_11));
        // N s_2674_13: branch s_2674_12 b2677 b2675
        if s_2674_12 {
            return block_2677(state, tracer, fn_state);
        } else {
            return block_2675(state, tracer, fn_state);
        };
    }
    fn block_2675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2675_0: const #0u : u8
        let s_2675_0: bool = false;
        // D s_2675_1: write-var gs#399843 <= s_2675_0
        fn_state.gs_399843 = s_2675_0;
        // N s_2675_2: jump b2676
        return block_2676(state, tracer, fn_state);
    }
    fn block_2676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2676_0: read-var gs#399843:u8
        let s_2676_0: bool = fn_state.gs_399843;
        // D s_2676_1: write-var gs#399844 <= s_2676_0
        fn_state.gs_399844 = s_2676_0;
        // N s_2676_2: jump b2673
        return block_2673(state, tracer, fn_state);
    }
    fn block_2677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2677_0: const #6s : i
        let s_2677_0: i128 = 6;
        // D s_2677_1: read-var u#31185:u32
        let s_2677_1: u32 = fn_state.u_31185;
        // D s_2677_2: cast zx s_2677_1 -> bv
        let s_2677_2: Bits = Bits::new(s_2677_1 as u128, 32u16);
        // C s_2677_3: const #1s : i64
        let s_2677_3: i64 = 1;
        // C s_2677_4: cast zx s_2677_3 -> i
        let s_2677_4: i128 = (i128::try_from(s_2677_3).unwrap());
        // C s_2677_5: const #0s : i
        let s_2677_5: i128 = 0;
        // C s_2677_6: add s_2677_5 s_2677_4
        let s_2677_6: i128 = (s_2677_5 + s_2677_4);
        // D s_2677_7: bit-extract s_2677_2 s_2677_0 s_2677_6
        let s_2677_7: Bits = (Bits::new(
            ((s_2677_2) >> (s_2677_0)).value(),
            u16::try_from(s_2677_6).unwrap(),
        ));
        // D s_2677_8: cast reint s_2677_7 -> u8
        let s_2677_8: bool = ((s_2677_7.value()) != 0);
        // D s_2677_9: cast zx s_2677_8 -> bv
        let s_2677_9: Bits = Bits::new(s_2677_8 as u128, 1u16);
        // C s_2677_10: const #0u : u8
        let s_2677_10: bool = false;
        // C s_2677_11: cast zx s_2677_10 -> bv
        let s_2677_11: Bits = Bits::new(s_2677_10 as u128, 1u16);
        // D s_2677_12: cmp-eq s_2677_9 s_2677_11
        let s_2677_12: bool = ((s_2677_9) == (s_2677_11));
        // N s_2677_13: branch s_2677_12 b2680 b2678
        if s_2677_12 {
            return block_2680(state, tracer, fn_state);
        } else {
            return block_2678(state, tracer, fn_state);
        };
    }
    fn block_2678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2678_0: const #0u : u8
        let s_2678_0: bool = false;
        // D s_2678_1: write-var gs#399842 <= s_2678_0
        fn_state.gs_399842 = s_2678_0;
        // N s_2678_2: jump b2679
        return block_2679(state, tracer, fn_state);
    }
    fn block_2679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2679_0: read-var gs#399842:u8
        let s_2679_0: bool = fn_state.gs_399842;
        // D s_2679_1: write-var gs#399843 <= s_2679_0
        fn_state.gs_399843 = s_2679_0;
        // N s_2679_2: jump b2676
        return block_2676(state, tracer, fn_state);
    }
    fn block_2680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2680_0: const #4s : i
        let s_2680_0: i128 = 4;
        // D s_2680_1: read-var u#31185:u32
        let s_2680_1: u32 = fn_state.u_31185;
        // D s_2680_2: cast zx s_2680_1 -> bv
        let s_2680_2: Bits = Bits::new(s_2680_1 as u128, 32u16);
        // C s_2680_3: const #1s : i64
        let s_2680_3: i64 = 1;
        // C s_2680_4: cast zx s_2680_3 -> i
        let s_2680_4: i128 = (i128::try_from(s_2680_3).unwrap());
        // C s_2680_5: const #0s : i
        let s_2680_5: i128 = 0;
        // C s_2680_6: add s_2680_5 s_2680_4
        let s_2680_6: i128 = (s_2680_5 + s_2680_4);
        // D s_2680_7: bit-extract s_2680_2 s_2680_0 s_2680_6
        let s_2680_7: Bits = (Bits::new(
            ((s_2680_2) >> (s_2680_0)).value(),
            u16::try_from(s_2680_6).unwrap(),
        ));
        // D s_2680_8: cast reint s_2680_7 -> u8
        let s_2680_8: bool = ((s_2680_7.value()) != 0);
        // D s_2680_9: cast zx s_2680_8 -> bv
        let s_2680_9: Bits = Bits::new(s_2680_8 as u128, 1u16);
        // C s_2680_10: const #0u : u8
        let s_2680_10: bool = false;
        // C s_2680_11: cast zx s_2680_10 -> bv
        let s_2680_11: Bits = Bits::new(s_2680_10 as u128, 1u16);
        // D s_2680_12: cmp-eq s_2680_9 s_2680_11
        let s_2680_12: bool = ((s_2680_9) == (s_2680_11));
        // D s_2680_13: write-var gs#399842 <= s_2680_12
        fn_state.gs_399842 = s_2680_12;
        // N s_2680_14: jump b2679
        return block_2679(state, tracer, fn_state);
    }
    fn block_2681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2681_0: const #3512s : i
        let s_2681_0: i128 = 3512;
        // C s_2681_1: const #14696u : u32
        let s_2681_1: u32 = 14696;
        // D s_2681_2: read-reg s_2681_1:i
        let s_2681_2: i128 = {
            let value = state.read_register::<i128>(s_2681_1 as isize);
            tracer.read_register(s_2681_1 as isize, value);
            value
        };
        // D s_2681_3: cmp-lt s_2681_2 s_2681_0
        let s_2681_3: bool = ((s_2681_2) < (s_2681_0));
        // D s_2681_4: write-var gs#399808 <= s_2681_3
        fn_state.gs_399808 = s_2681_3;
        // N s_2681_5: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_2682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2682_0: const #23s : i
        let s_2682_0: i128 = 23;
        // D s_2682_1: read-var u#31174:u32
        let s_2682_1: u32 = fn_state.u_31174;
        // D s_2682_2: cast zx s_2682_1 -> bv
        let s_2682_2: Bits = Bits::new(s_2682_1 as u128, 32u16);
        // C s_2682_3: const #1s : i64
        let s_2682_3: i64 = 1;
        // C s_2682_4: cast zx s_2682_3 -> i
        let s_2682_4: i128 = (i128::try_from(s_2682_3).unwrap());
        // C s_2682_5: const #0s : i
        let s_2682_5: i128 = 0;
        // C s_2682_6: add s_2682_5 s_2682_4
        let s_2682_6: i128 = (s_2682_5 + s_2682_4);
        // D s_2682_7: bit-extract s_2682_2 s_2682_0 s_2682_6
        let s_2682_7: Bits = (Bits::new(
            ((s_2682_2) >> (s_2682_0)).value(),
            u16::try_from(s_2682_6).unwrap(),
        ));
        // D s_2682_8: cast reint s_2682_7 -> u8
        let s_2682_8: bool = ((s_2682_7.value()) != 0);
        // D s_2682_9: cast zx s_2682_8 -> bv
        let s_2682_9: Bits = Bits::new(s_2682_8 as u128, 1u16);
        // C s_2682_10: const #0u : u8
        let s_2682_10: bool = false;
        // C s_2682_11: cast zx s_2682_10 -> bv
        let s_2682_11: Bits = Bits::new(s_2682_10 as u128, 1u16);
        // D s_2682_12: cmp-eq s_2682_9 s_2682_11
        let s_2682_12: bool = ((s_2682_9) == (s_2682_11));
        // N s_2682_13: branch s_2682_12 b2685 b2683
        if s_2682_12 {
            return block_2685(state, tracer, fn_state);
        } else {
            return block_2683(state, tracer, fn_state);
        };
    }
    fn block_2683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2683_0: const #0u : u8
        let s_2683_0: bool = false;
        // D s_2683_1: write-var gs#399805 <= s_2683_0
        fn_state.gs_399805 = s_2683_0;
        // N s_2683_2: jump b2684
        return block_2684(state, tracer, fn_state);
    }
    fn block_2684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2684_0: read-var gs#399805:u8
        let s_2684_0: bool = fn_state.gs_399805;
        // D s_2684_1: write-var gs#399806 <= s_2684_0
        fn_state.gs_399806 = s_2684_0;
        // N s_2684_2: jump b681
        return block_681(state, tracer, fn_state);
    }
    fn block_2685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2685_0: const #8s : i
        let s_2685_0: i128 = 8;
        // D s_2685_1: read-var u#31174:u32
        let s_2685_1: u32 = fn_state.u_31174;
        // D s_2685_2: cast zx s_2685_1 -> bv
        let s_2685_2: Bits = Bits::new(s_2685_1 as u128, 32u16);
        // C s_2685_3: const #1s : i64
        let s_2685_3: i64 = 1;
        // C s_2685_4: cast zx s_2685_3 -> i
        let s_2685_4: i128 = (i128::try_from(s_2685_3).unwrap());
        // C s_2685_5: const #3s : i
        let s_2685_5: i128 = 3;
        // C s_2685_6: add s_2685_5 s_2685_4
        let s_2685_6: i128 = (s_2685_5 + s_2685_4);
        // D s_2685_7: bit-extract s_2685_2 s_2685_0 s_2685_6
        let s_2685_7: Bits = (Bits::new(
            ((s_2685_2) >> (s_2685_0)).value(),
            u16::try_from(s_2685_6).unwrap(),
        ));
        // D s_2685_8: cast reint s_2685_7 -> u8
        let s_2685_8: u8 = (s_2685_7.value() as u8);
        // D s_2685_9: cast zx s_2685_8 -> bv
        let s_2685_9: Bits = Bits::new(s_2685_8 as u128, 4u16);
        // C s_2685_10: const #9u : u8
        let s_2685_10: u8 = 9;
        // C s_2685_11: cast zx s_2685_10 -> bv
        let s_2685_11: Bits = Bits::new(s_2685_10 as u128, 4u16);
        // D s_2685_12: cmp-eq s_2685_9 s_2685_11
        let s_2685_12: bool = ((s_2685_9) == (s_2685_11));
        // N s_2685_13: branch s_2685_12 b2688 b2686
        if s_2685_12 {
            return block_2688(state, tracer, fn_state);
        } else {
            return block_2686(state, tracer, fn_state);
        };
    }
    fn block_2686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2686_0: const #0u : u8
        let s_2686_0: bool = false;
        // D s_2686_1: write-var gs#399804 <= s_2686_0
        fn_state.gs_399804 = s_2686_0;
        // N s_2686_2: jump b2687
        return block_2687(state, tracer, fn_state);
    }
    fn block_2687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2687_0: read-var gs#399804:u8
        let s_2687_0: bool = fn_state.gs_399804;
        // D s_2687_1: write-var gs#399805 <= s_2687_0
        fn_state.gs_399805 = s_2687_0;
        // N s_2687_2: jump b2684
        return block_2684(state, tracer, fn_state);
    }
    fn block_2688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2688_0: const #4s : i
        let s_2688_0: i128 = 4;
        // D s_2688_1: read-var u#31174:u32
        let s_2688_1: u32 = fn_state.u_31174;
        // D s_2688_2: cast zx s_2688_1 -> bv
        let s_2688_2: Bits = Bits::new(s_2688_1 as u128, 32u16);
        // C s_2688_3: const #1s : i64
        let s_2688_3: i64 = 1;
        // C s_2688_4: cast zx s_2688_3 -> i
        let s_2688_4: i128 = (i128::try_from(s_2688_3).unwrap());
        // C s_2688_5: const #0s : i
        let s_2688_5: i128 = 0;
        // C s_2688_6: add s_2688_5 s_2688_4
        let s_2688_6: i128 = (s_2688_5 + s_2688_4);
        // D s_2688_7: bit-extract s_2688_2 s_2688_0 s_2688_6
        let s_2688_7: Bits = (Bits::new(
            ((s_2688_2) >> (s_2688_0)).value(),
            u16::try_from(s_2688_6).unwrap(),
        ));
        // D s_2688_8: cast reint s_2688_7 -> u8
        let s_2688_8: bool = ((s_2688_7.value()) != 0);
        // D s_2688_9: cast zx s_2688_8 -> bv
        let s_2688_9: Bits = Bits::new(s_2688_8 as u128, 1u16);
        // C s_2688_10: const #0u : u8
        let s_2688_10: bool = false;
        // C s_2688_11: cast zx s_2688_10 -> bv
        let s_2688_11: Bits = Bits::new(s_2688_10 as u128, 1u16);
        // D s_2688_12: cmp-eq s_2688_9 s_2688_11
        let s_2688_12: bool = ((s_2688_9) == (s_2688_11));
        // D s_2688_13: write-var gs#399804 <= s_2688_12
        fn_state.gs_399804 = s_2688_12;
        // N s_2688_14: jump b2687
        return block_2687(state, tracer, fn_state);
    }
    fn block_2689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2689_0: const #3508s : i
        let s_2689_0: i128 = 3508;
        // C s_2689_1: const #14696u : u32
        let s_2689_1: u32 = 14696;
        // D s_2689_2: read-reg s_2689_1:i
        let s_2689_2: i128 = {
            let value = state.read_register::<i128>(s_2689_1 as isize);
            tracer.read_register(s_2689_1 as isize, value);
            value
        };
        // D s_2689_3: cmp-lt s_2689_2 s_2689_0
        let s_2689_3: bool = ((s_2689_2) < (s_2689_0));
        // D s_2689_4: write-var gs#399774 <= s_2689_3
        fn_state.gs_399774 = s_2689_3;
        // N s_2689_5: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_2690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2690_0: const #8s : i
        let s_2690_0: i128 = 8;
        // D s_2690_1: read-var u#31163:u32
        let s_2690_1: u32 = fn_state.u_31163;
        // D s_2690_2: cast zx s_2690_1 -> bv
        let s_2690_2: Bits = Bits::new(s_2690_1 as u128, 32u16);
        // C s_2690_3: const #1s : i64
        let s_2690_3: i64 = 1;
        // C s_2690_4: cast zx s_2690_3 -> i
        let s_2690_4: i128 = (i128::try_from(s_2690_3).unwrap());
        // C s_2690_5: const #3s : i
        let s_2690_5: i128 = 3;
        // C s_2690_6: add s_2690_5 s_2690_4
        let s_2690_6: i128 = (s_2690_5 + s_2690_4);
        // D s_2690_7: bit-extract s_2690_2 s_2690_0 s_2690_6
        let s_2690_7: Bits = (Bits::new(
            ((s_2690_2) >> (s_2690_0)).value(),
            u16::try_from(s_2690_6).unwrap(),
        ));
        // D s_2690_8: cast reint s_2690_7 -> u8
        let s_2690_8: u8 = (s_2690_7.value() as u8);
        // D s_2690_9: cast zx s_2690_8 -> bv
        let s_2690_9: Bits = Bits::new(s_2690_8 as u128, 4u16);
        // C s_2690_10: const #13u : u8
        let s_2690_10: u8 = 13;
        // C s_2690_11: cast zx s_2690_10 -> bv
        let s_2690_11: Bits = Bits::new(s_2690_10 as u128, 4u16);
        // D s_2690_12: cmp-eq s_2690_9 s_2690_11
        let s_2690_12: bool = ((s_2690_9) == (s_2690_11));
        // N s_2690_13: branch s_2690_12 b2693 b2691
        if s_2690_12 {
            return block_2693(state, tracer, fn_state);
        } else {
            return block_2691(state, tracer, fn_state);
        };
    }
    fn block_2691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2691_0: const #0u : u8
        let s_2691_0: bool = false;
        // D s_2691_1: write-var gs#399771 <= s_2691_0
        fn_state.gs_399771 = s_2691_0;
        // N s_2691_2: jump b2692
        return block_2692(state, tracer, fn_state);
    }
    fn block_2692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2692_0: read-var gs#399771:u8
        let s_2692_0: bool = fn_state.gs_399771;
        // D s_2692_1: write-var gs#399772 <= s_2692_0
        fn_state.gs_399772 = s_2692_0;
        // N s_2692_2: jump b675
        return block_675(state, tracer, fn_state);
    }
    fn block_2693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2693_0: const #4s : i
        let s_2693_0: i128 = 4;
        // D s_2693_1: read-var u#31163:u32
        let s_2693_1: u32 = fn_state.u_31163;
        // D s_2693_2: cast zx s_2693_1 -> bv
        let s_2693_2: Bits = Bits::new(s_2693_1 as u128, 32u16);
        // C s_2693_3: const #1s : i64
        let s_2693_3: i64 = 1;
        // C s_2693_4: cast zx s_2693_3 -> i
        let s_2693_4: i128 = (i128::try_from(s_2693_3).unwrap());
        // C s_2693_5: const #0s : i
        let s_2693_5: i128 = 0;
        // C s_2693_6: add s_2693_5 s_2693_4
        let s_2693_6: i128 = (s_2693_5 + s_2693_4);
        // D s_2693_7: bit-extract s_2693_2 s_2693_0 s_2693_6
        let s_2693_7: Bits = (Bits::new(
            ((s_2693_2) >> (s_2693_0)).value(),
            u16::try_from(s_2693_6).unwrap(),
        ));
        // D s_2693_8: cast reint s_2693_7 -> u8
        let s_2693_8: bool = ((s_2693_7.value()) != 0);
        // D s_2693_9: cast zx s_2693_8 -> bv
        let s_2693_9: Bits = Bits::new(s_2693_8 as u128, 1u16);
        // C s_2693_10: const #1u : u8
        let s_2693_10: bool = true;
        // C s_2693_11: cast zx s_2693_10 -> bv
        let s_2693_11: Bits = Bits::new(s_2693_10 as u128, 1u16);
        // D s_2693_12: cmp-eq s_2693_9 s_2693_11
        let s_2693_12: bool = ((s_2693_9) == (s_2693_11));
        // D s_2693_13: write-var gs#399771 <= s_2693_12
        fn_state.gs_399771 = s_2693_12;
        // N s_2693_14: jump b2692
        return block_2692(state, tracer, fn_state);
    }
    fn block_2694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2694_0: const #3506s : i
        let s_2694_0: i128 = 3506;
        // C s_2694_1: const #14696u : u32
        let s_2694_1: u32 = 14696;
        // D s_2694_2: read-reg s_2694_1:i
        let s_2694_2: i128 = {
            let value = state.read_register::<i128>(s_2694_1 as isize);
            tracer.read_register(s_2694_1 as isize, value);
            value
        };
        // D s_2694_3: cmp-lt s_2694_2 s_2694_0
        let s_2694_3: bool = ((s_2694_2) < (s_2694_0));
        // D s_2694_4: write-var gs#399741 <= s_2694_3
        fn_state.gs_399741 = s_2694_3;
        // N s_2694_5: jump b671
        return block_671(state, tracer, fn_state);
    }
    fn block_2695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2695_0: const #23s : i
        let s_2695_0: i128 = 23;
        // D s_2695_1: read-var u#31151:u32
        let s_2695_1: u32 = fn_state.u_31151;
        // D s_2695_2: cast zx s_2695_1 -> bv
        let s_2695_2: Bits = Bits::new(s_2695_1 as u128, 32u16);
        // C s_2695_3: const #1s : i64
        let s_2695_3: i64 = 1;
        // C s_2695_4: cast zx s_2695_3 -> i
        let s_2695_4: i128 = (i128::try_from(s_2695_3).unwrap());
        // C s_2695_5: const #0s : i
        let s_2695_5: i128 = 0;
        // C s_2695_6: add s_2695_5 s_2695_4
        let s_2695_6: i128 = (s_2695_5 + s_2695_4);
        // D s_2695_7: bit-extract s_2695_2 s_2695_0 s_2695_6
        let s_2695_7: Bits = (Bits::new(
            ((s_2695_2) >> (s_2695_0)).value(),
            u16::try_from(s_2695_6).unwrap(),
        ));
        // D s_2695_8: cast reint s_2695_7 -> u8
        let s_2695_8: bool = ((s_2695_7.value()) != 0);
        // D s_2695_9: cast zx s_2695_8 -> bv
        let s_2695_9: Bits = Bits::new(s_2695_8 as u128, 1u16);
        // C s_2695_10: const #0u : u8
        let s_2695_10: bool = false;
        // C s_2695_11: cast zx s_2695_10 -> bv
        let s_2695_11: Bits = Bits::new(s_2695_10 as u128, 1u16);
        // D s_2695_12: cmp-eq s_2695_9 s_2695_11
        let s_2695_12: bool = ((s_2695_9) == (s_2695_11));
        // N s_2695_13: branch s_2695_12 b2698 b2696
        if s_2695_12 {
            return block_2698(state, tracer, fn_state);
        } else {
            return block_2696(state, tracer, fn_state);
        };
    }
    fn block_2696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2696_0: const #0u : u8
        let s_2696_0: bool = false;
        // D s_2696_1: write-var gs#399738 <= s_2696_0
        fn_state.gs_399738 = s_2696_0;
        // N s_2696_2: jump b2697
        return block_2697(state, tracer, fn_state);
    }
    fn block_2697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2697_0: read-var gs#399738:u8
        let s_2697_0: bool = fn_state.gs_399738;
        // D s_2697_1: write-var gs#399739 <= s_2697_0
        fn_state.gs_399739 = s_2697_0;
        // N s_2697_2: jump b669
        return block_669(state, tracer, fn_state);
    }
    fn block_2698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2698_0: const #8s : i
        let s_2698_0: i128 = 8;
        // D s_2698_1: read-var u#31151:u32
        let s_2698_1: u32 = fn_state.u_31151;
        // D s_2698_2: cast zx s_2698_1 -> bv
        let s_2698_2: Bits = Bits::new(s_2698_1 as u128, 32u16);
        // C s_2698_3: const #1s : i64
        let s_2698_3: i64 = 1;
        // C s_2698_4: cast zx s_2698_3 -> i
        let s_2698_4: i128 = (i128::try_from(s_2698_3).unwrap());
        // C s_2698_5: const #3s : i
        let s_2698_5: i128 = 3;
        // C s_2698_6: add s_2698_5 s_2698_4
        let s_2698_6: i128 = (s_2698_5 + s_2698_4);
        // D s_2698_7: bit-extract s_2698_2 s_2698_0 s_2698_6
        let s_2698_7: Bits = (Bits::new(
            ((s_2698_2) >> (s_2698_0)).value(),
            u16::try_from(s_2698_6).unwrap(),
        ));
        // D s_2698_8: cast reint s_2698_7 -> u8
        let s_2698_8: u8 = (s_2698_7.value() as u8);
        // D s_2698_9: cast zx s_2698_8 -> bv
        let s_2698_9: Bits = Bits::new(s_2698_8 as u128, 4u16);
        // C s_2698_10: const #6u : u8
        let s_2698_10: u8 = 6;
        // C s_2698_11: cast zx s_2698_10 -> bv
        let s_2698_11: Bits = Bits::new(s_2698_10 as u128, 4u16);
        // D s_2698_12: cmp-eq s_2698_9 s_2698_11
        let s_2698_12: bool = ((s_2698_9) == (s_2698_11));
        // D s_2698_13: write-var gs#399738 <= s_2698_12
        fn_state.gs_399738 = s_2698_12;
        // N s_2698_14: jump b2697
        return block_2697(state, tracer, fn_state);
    }
    fn block_2699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2699_0: const #3504s : i
        let s_2699_0: i128 = 3504;
        // C s_2699_1: const #14696u : u32
        let s_2699_1: u32 = 14696;
        // D s_2699_2: read-reg s_2699_1:i
        let s_2699_2: i128 = {
            let value = state.read_register::<i128>(s_2699_1 as isize);
            tracer.read_register(s_2699_1 as isize, value);
            value
        };
        // D s_2699_3: cmp-lt s_2699_2 s_2699_0
        let s_2699_3: bool = ((s_2699_2) < (s_2699_0));
        // D s_2699_4: write-var gs#399710 <= s_2699_3
        fn_state.gs_399710 = s_2699_3;
        // N s_2699_5: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_2700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2700_0: const #8s : i
        let s_2700_0: i128 = 8;
        // D s_2700_1: read-var u#31140:u32
        let s_2700_1: u32 = fn_state.u_31140;
        // D s_2700_2: cast zx s_2700_1 -> bv
        let s_2700_2: Bits = Bits::new(s_2700_1 as u128, 32u16);
        // C s_2700_3: const #1s : i64
        let s_2700_3: i64 = 1;
        // C s_2700_4: cast zx s_2700_3 -> i
        let s_2700_4: i128 = (i128::try_from(s_2700_3).unwrap());
        // C s_2700_5: const #3s : i
        let s_2700_5: i128 = 3;
        // C s_2700_6: add s_2700_5 s_2700_4
        let s_2700_6: i128 = (s_2700_5 + s_2700_4);
        // D s_2700_7: bit-extract s_2700_2 s_2700_0 s_2700_6
        let s_2700_7: Bits = (Bits::new(
            ((s_2700_2) >> (s_2700_0)).value(),
            u16::try_from(s_2700_6).unwrap(),
        ));
        // D s_2700_8: cast reint s_2700_7 -> u8
        let s_2700_8: u8 = (s_2700_7.value() as u8);
        // D s_2700_9: cast zx s_2700_8 -> bv
        let s_2700_9: Bits = Bits::new(s_2700_8 as u128, 4u16);
        // C s_2700_10: const #15u : u8
        let s_2700_10: u8 = 15;
        // C s_2700_11: cast zx s_2700_10 -> bv
        let s_2700_11: Bits = Bits::new(s_2700_10 as u128, 4u16);
        // D s_2700_12: cmp-eq s_2700_9 s_2700_11
        let s_2700_12: bool = ((s_2700_9) == (s_2700_11));
        // N s_2700_13: branch s_2700_12 b2703 b2701
        if s_2700_12 {
            return block_2703(state, tracer, fn_state);
        } else {
            return block_2701(state, tracer, fn_state);
        };
    }
    fn block_2701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2701_0: const #0u : u8
        let s_2701_0: bool = false;
        // D s_2701_1: write-var gs#399707 <= s_2701_0
        fn_state.gs_399707 = s_2701_0;
        // N s_2701_2: jump b2702
        return block_2702(state, tracer, fn_state);
    }
    fn block_2702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2702_0: read-var gs#399707:u8
        let s_2702_0: bool = fn_state.gs_399707;
        // D s_2702_1: write-var gs#399708 <= s_2702_0
        fn_state.gs_399708 = s_2702_0;
        // N s_2702_2: jump b663
        return block_663(state, tracer, fn_state);
    }
    fn block_2703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2703_0: const #4s : i
        let s_2703_0: i128 = 4;
        // D s_2703_1: read-var u#31140:u32
        let s_2703_1: u32 = fn_state.u_31140;
        // D s_2703_2: cast zx s_2703_1 -> bv
        let s_2703_2: Bits = Bits::new(s_2703_1 as u128, 32u16);
        // C s_2703_3: const #1s : i64
        let s_2703_3: i64 = 1;
        // C s_2703_4: cast zx s_2703_3 -> i
        let s_2703_4: i128 = (i128::try_from(s_2703_3).unwrap());
        // C s_2703_5: const #0s : i
        let s_2703_5: i128 = 0;
        // C s_2703_6: add s_2703_5 s_2703_4
        let s_2703_6: i128 = (s_2703_5 + s_2703_4);
        // D s_2703_7: bit-extract s_2703_2 s_2703_0 s_2703_6
        let s_2703_7: Bits = (Bits::new(
            ((s_2703_2) >> (s_2703_0)).value(),
            u16::try_from(s_2703_6).unwrap(),
        ));
        // D s_2703_8: cast reint s_2703_7 -> u8
        let s_2703_8: bool = ((s_2703_7.value()) != 0);
        // D s_2703_9: cast zx s_2703_8 -> bv
        let s_2703_9: Bits = Bits::new(s_2703_8 as u128, 1u16);
        // C s_2703_10: const #0u : u8
        let s_2703_10: bool = false;
        // C s_2703_11: cast zx s_2703_10 -> bv
        let s_2703_11: Bits = Bits::new(s_2703_10 as u128, 1u16);
        // D s_2703_12: cmp-eq s_2703_9 s_2703_11
        let s_2703_12: bool = ((s_2703_9) == (s_2703_11));
        // D s_2703_13: write-var gs#399707 <= s_2703_12
        fn_state.gs_399707 = s_2703_12;
        // N s_2703_14: jump b2702
        return block_2702(state, tracer, fn_state);
    }
    fn block_2704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2704_0: const #3496s : i
        let s_2704_0: i128 = 3496;
        // C s_2704_1: const #14696u : u32
        let s_2704_1: u32 = 14696;
        // D s_2704_2: read-reg s_2704_1:i
        let s_2704_2: i128 = {
            let value = state.read_register::<i128>(s_2704_1 as isize);
            tracer.read_register(s_2704_1 as isize, value);
            value
        };
        // D s_2704_3: cmp-lt s_2704_2 s_2704_0
        let s_2704_3: bool = ((s_2704_2) < (s_2704_0));
        // D s_2704_4: write-var gs#399683 <= s_2704_3
        fn_state.gs_399683 = s_2704_3;
        // N s_2704_5: jump b659
        return block_659(state, tracer, fn_state);
    }
    fn block_2705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2705_0: const #20s : i
        let s_2705_0: i128 = 20;
        // D s_2705_1: read-var u#31131:u32
        let s_2705_1: u32 = fn_state.u_31131;
        // D s_2705_2: cast zx s_2705_1 -> bv
        let s_2705_2: Bits = Bits::new(s_2705_1 as u128, 32u16);
        // C s_2705_3: const #1s : i64
        let s_2705_3: i64 = 1;
        // C s_2705_4: cast zx s_2705_3 -> i
        let s_2705_4: i128 = (i128::try_from(s_2705_3).unwrap());
        // C s_2705_5: const #1s : i
        let s_2705_5: i128 = 1;
        // C s_2705_6: add s_2705_5 s_2705_4
        let s_2705_6: i128 = (s_2705_5 + s_2705_4);
        // D s_2705_7: bit-extract s_2705_2 s_2705_0 s_2705_6
        let s_2705_7: Bits = (Bits::new(
            ((s_2705_2) >> (s_2705_0)).value(),
            u16::try_from(s_2705_6).unwrap(),
        ));
        // D s_2705_8: cast reint s_2705_7 -> u8
        let s_2705_8: u8 = (s_2705_7.value() as u8);
        // D s_2705_9: cast zx s_2705_8 -> bv
        let s_2705_9: Bits = Bits::new(s_2705_8 as u128, 2u16);
        // C s_2705_10: const #2u : u8
        let s_2705_10: u8 = 2;
        // C s_2705_11: cast zx s_2705_10 -> bv
        let s_2705_11: Bits = Bits::new(s_2705_10 as u128, 2u16);
        // D s_2705_12: cmp-eq s_2705_9 s_2705_11
        let s_2705_12: bool = ((s_2705_9) == (s_2705_11));
        // N s_2705_13: branch s_2705_12 b2708 b2706
        if s_2705_12 {
            return block_2708(state, tracer, fn_state);
        } else {
            return block_2706(state, tracer, fn_state);
        };
    }
    fn block_2706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2706_0: const #0u : u8
        let s_2706_0: bool = false;
        // D s_2706_1: write-var gs#399680 <= s_2706_0
        fn_state.gs_399680 = s_2706_0;
        // N s_2706_2: jump b2707
        return block_2707(state, tracer, fn_state);
    }
    fn block_2707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2707_0: read-var gs#399680:u8
        let s_2707_0: bool = fn_state.gs_399680;
        // D s_2707_1: write-var gs#399681 <= s_2707_0
        fn_state.gs_399681 = s_2707_0;
        // N s_2707_2: jump b657
        return block_657(state, tracer, fn_state);
    }
    fn block_2708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2708_0: const #9s : i
        let s_2708_0: i128 = 9;
        // D s_2708_1: read-var u#31131:u32
        let s_2708_1: u32 = fn_state.u_31131;
        // D s_2708_2: cast zx s_2708_1 -> bv
        let s_2708_2: Bits = Bits::new(s_2708_1 as u128, 32u16);
        // C s_2708_3: const #1s : i64
        let s_2708_3: i64 = 1;
        // C s_2708_4: cast zx s_2708_3 -> i
        let s_2708_4: i128 = (i128::try_from(s_2708_3).unwrap());
        // C s_2708_5: const #2s : i
        let s_2708_5: i128 = 2;
        // C s_2708_6: add s_2708_5 s_2708_4
        let s_2708_6: i128 = (s_2708_5 + s_2708_4);
        // D s_2708_7: bit-extract s_2708_2 s_2708_0 s_2708_6
        let s_2708_7: Bits = (Bits::new(
            ((s_2708_2) >> (s_2708_0)).value(),
            u16::try_from(s_2708_6).unwrap(),
        ));
        // D s_2708_8: cast reint s_2708_7 -> u8
        let s_2708_8: u8 = (s_2708_7.value() as u8);
        // D s_2708_9: cast zx s_2708_8 -> bv
        let s_2708_9: Bits = Bits::new(s_2708_8 as u128, 3u16);
        // C s_2708_10: const #0u : u8
        let s_2708_10: u8 = 0;
        // C s_2708_11: cast zx s_2708_10 -> bv
        let s_2708_11: Bits = Bits::new(s_2708_10 as u128, 3u16);
        // D s_2708_12: cmp-eq s_2708_9 s_2708_11
        let s_2708_12: bool = ((s_2708_9) == (s_2708_11));
        // D s_2708_13: write-var gs#399680 <= s_2708_12
        fn_state.gs_399680 = s_2708_12;
        // N s_2708_14: jump b2707
        return block_2707(state, tracer, fn_state);
    }
    fn block_2709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2709_0: const #3494s : i
        let s_2709_0: i128 = 3494;
        // C s_2709_1: const #14696u : u32
        let s_2709_1: u32 = 14696;
        // D s_2709_2: read-reg s_2709_1:i
        let s_2709_2: i128 = {
            let value = state.read_register::<i128>(s_2709_1 as isize);
            tracer.read_register(s_2709_1 as isize, value);
            value
        };
        // D s_2709_3: cmp-lt s_2709_2 s_2709_0
        let s_2709_3: bool = ((s_2709_2) < (s_2709_0));
        // D s_2709_4: write-var gs#399656 <= s_2709_3
        fn_state.gs_399656 = s_2709_3;
        // N s_2709_5: jump b653
        return block_653(state, tracer, fn_state);
    }
    fn block_2710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2710_0: const #20s : i
        let s_2710_0: i128 = 20;
        // D s_2710_1: read-var u#31122:u32
        let s_2710_1: u32 = fn_state.u_31122;
        // D s_2710_2: cast zx s_2710_1 -> bv
        let s_2710_2: Bits = Bits::new(s_2710_1 as u128, 32u16);
        // C s_2710_3: const #1s : i64
        let s_2710_3: i64 = 1;
        // C s_2710_4: cast zx s_2710_3 -> i
        let s_2710_4: i128 = (i128::try_from(s_2710_3).unwrap());
        // C s_2710_5: const #1s : i
        let s_2710_5: i128 = 1;
        // C s_2710_6: add s_2710_5 s_2710_4
        let s_2710_6: i128 = (s_2710_5 + s_2710_4);
        // D s_2710_7: bit-extract s_2710_2 s_2710_0 s_2710_6
        let s_2710_7: Bits = (Bits::new(
            ((s_2710_2) >> (s_2710_0)).value(),
            u16::try_from(s_2710_6).unwrap(),
        ));
        // D s_2710_8: cast reint s_2710_7 -> u8
        let s_2710_8: u8 = (s_2710_7.value() as u8);
        // D s_2710_9: cast zx s_2710_8 -> bv
        let s_2710_9: Bits = Bits::new(s_2710_8 as u128, 2u16);
        // C s_2710_10: const #2u : u8
        let s_2710_10: u8 = 2;
        // C s_2710_11: cast zx s_2710_10 -> bv
        let s_2710_11: Bits = Bits::new(s_2710_10 as u128, 2u16);
        // D s_2710_12: cmp-eq s_2710_9 s_2710_11
        let s_2710_12: bool = ((s_2710_9) == (s_2710_11));
        // N s_2710_13: branch s_2710_12 b2713 b2711
        if s_2710_12 {
            return block_2713(state, tracer, fn_state);
        } else {
            return block_2711(state, tracer, fn_state);
        };
    }
    fn block_2711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2711_0: const #0u : u8
        let s_2711_0: bool = false;
        // D s_2711_1: write-var gs#399653 <= s_2711_0
        fn_state.gs_399653 = s_2711_0;
        // N s_2711_2: jump b2712
        return block_2712(state, tracer, fn_state);
    }
    fn block_2712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2712_0: read-var gs#399653:u8
        let s_2712_0: bool = fn_state.gs_399653;
        // D s_2712_1: write-var gs#399654 <= s_2712_0
        fn_state.gs_399654 = s_2712_0;
        // N s_2712_2: jump b651
        return block_651(state, tracer, fn_state);
    }
    fn block_2713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2713_0: const #8s : i
        let s_2713_0: i128 = 8;
        // D s_2713_1: read-var u#31122:u32
        let s_2713_1: u32 = fn_state.u_31122;
        // D s_2713_2: cast zx s_2713_1 -> bv
        let s_2713_2: Bits = Bits::new(s_2713_1 as u128, 32u16);
        // C s_2713_3: const #1s : i64
        let s_2713_3: i64 = 1;
        // C s_2713_4: cast zx s_2713_3 -> i
        let s_2713_4: i128 = (i128::try_from(s_2713_3).unwrap());
        // C s_2713_5: const #3s : i
        let s_2713_5: i128 = 3;
        // C s_2713_6: add s_2713_5 s_2713_4
        let s_2713_6: i128 = (s_2713_5 + s_2713_4);
        // D s_2713_7: bit-extract s_2713_2 s_2713_0 s_2713_6
        let s_2713_7: Bits = (Bits::new(
            ((s_2713_2) >> (s_2713_0)).value(),
            u16::try_from(s_2713_6).unwrap(),
        ));
        // D s_2713_8: cast reint s_2713_7 -> u8
        let s_2713_8: u8 = (s_2713_7.value() as u8);
        // D s_2713_9: cast zx s_2713_8 -> bv
        let s_2713_9: Bits = Bits::new(s_2713_8 as u128, 4u16);
        // C s_2713_10: const #15u : u8
        let s_2713_10: u8 = 15;
        // C s_2713_11: cast zx s_2713_10 -> bv
        let s_2713_11: Bits = Bits::new(s_2713_10 as u128, 4u16);
        // D s_2713_12: cmp-eq s_2713_9 s_2713_11
        let s_2713_12: bool = ((s_2713_9) == (s_2713_11));
        // D s_2713_13: write-var gs#399653 <= s_2713_12
        fn_state.gs_399653 = s_2713_12;
        // N s_2713_14: jump b2712
        return block_2712(state, tracer, fn_state);
    }
    fn block_2714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2714_0: const #3490s : i
        let s_2714_0: i128 = 3490;
        // C s_2714_1: const #14696u : u32
        let s_2714_1: u32 = 14696;
        // D s_2714_2: read-reg s_2714_1:i
        let s_2714_2: i128 = {
            let value = state.read_register::<i128>(s_2714_1 as isize);
            tracer.read_register(s_2714_1 as isize, value);
            value
        };
        // D s_2714_3: cmp-lt s_2714_2 s_2714_0
        let s_2714_3: bool = ((s_2714_2) < (s_2714_0));
        // D s_2714_4: write-var gs#399631 <= s_2714_3
        fn_state.gs_399631 = s_2714_3;
        // N s_2714_5: jump b647
        return block_647(state, tracer, fn_state);
    }
    fn block_2715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2715_0: const #20s : i
        let s_2715_0: i128 = 20;
        // D s_2715_1: read-var u#31114:u32
        let s_2715_1: u32 = fn_state.u_31114;
        // D s_2715_2: cast zx s_2715_1 -> bv
        let s_2715_2: Bits = Bits::new(s_2715_1 as u128, 32u16);
        // C s_2715_3: const #1s : i64
        let s_2715_3: i64 = 1;
        // C s_2715_4: cast zx s_2715_3 -> i
        let s_2715_4: i128 = (i128::try_from(s_2715_3).unwrap());
        // C s_2715_5: const #1s : i
        let s_2715_5: i128 = 1;
        // C s_2715_6: add s_2715_5 s_2715_4
        let s_2715_6: i128 = (s_2715_5 + s_2715_4);
        // D s_2715_7: bit-extract s_2715_2 s_2715_0 s_2715_6
        let s_2715_7: Bits = (Bits::new(
            ((s_2715_2) >> (s_2715_0)).value(),
            u16::try_from(s_2715_6).unwrap(),
        ));
        // D s_2715_8: cast reint s_2715_7 -> u8
        let s_2715_8: u8 = (s_2715_7.value() as u8);
        // D s_2715_9: cast zx s_2715_8 -> bv
        let s_2715_9: Bits = Bits::new(s_2715_8 as u128, 2u16);
        // C s_2715_10: const #2u : u8
        let s_2715_10: u8 = 2;
        // C s_2715_11: cast zx s_2715_10 -> bv
        let s_2715_11: Bits = Bits::new(s_2715_10 as u128, 2u16);
        // D s_2715_12: cmp-eq s_2715_9 s_2715_11
        let s_2715_12: bool = ((s_2715_9) == (s_2715_11));
        // N s_2715_13: branch s_2715_12 b2718 b2716
        if s_2715_12 {
            return block_2718(state, tracer, fn_state);
        } else {
            return block_2716(state, tracer, fn_state);
        };
    }
    fn block_2716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2716_0: const #0u : u8
        let s_2716_0: bool = false;
        // D s_2716_1: write-var gs#399628 <= s_2716_0
        fn_state.gs_399628 = s_2716_0;
        // N s_2716_2: jump b2717
        return block_2717(state, tracer, fn_state);
    }
    fn block_2717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2717_0: read-var gs#399628:u8
        let s_2717_0: bool = fn_state.gs_399628;
        // D s_2717_1: write-var gs#399629 <= s_2717_0
        fn_state.gs_399629 = s_2717_0;
        // N s_2717_2: jump b645
        return block_645(state, tracer, fn_state);
    }
    fn block_2718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2718_0: const #8s : i
        let s_2718_0: i128 = 8;
        // D s_2718_1: read-var u#31114:u32
        let s_2718_1: u32 = fn_state.u_31114;
        // D s_2718_2: cast zx s_2718_1 -> bv
        let s_2718_2: Bits = Bits::new(s_2718_1 as u128, 32u16);
        // C s_2718_3: const #1s : i64
        let s_2718_3: i64 = 1;
        // C s_2718_4: cast zx s_2718_3 -> i
        let s_2718_4: i128 = (i128::try_from(s_2718_3).unwrap());
        // C s_2718_5: const #3s : i
        let s_2718_5: i128 = 3;
        // C s_2718_6: add s_2718_5 s_2718_4
        let s_2718_6: i128 = (s_2718_5 + s_2718_4);
        // D s_2718_7: bit-extract s_2718_2 s_2718_0 s_2718_6
        let s_2718_7: Bits = (Bits::new(
            ((s_2718_2) >> (s_2718_0)).value(),
            u16::try_from(s_2718_6).unwrap(),
        ));
        // D s_2718_8: cast reint s_2718_7 -> u8
        let s_2718_8: u8 = (s_2718_7.value() as u8);
        // D s_2718_9: cast zx s_2718_8 -> bv
        let s_2718_9: Bits = Bits::new(s_2718_8 as u128, 4u16);
        // C s_2718_10: const #11u : u8
        let s_2718_10: u8 = 11;
        // C s_2718_11: cast zx s_2718_10 -> bv
        let s_2718_11: Bits = Bits::new(s_2718_10 as u128, 4u16);
        // D s_2718_12: cmp-eq s_2718_9 s_2718_11
        let s_2718_12: bool = ((s_2718_9) == (s_2718_11));
        // D s_2718_13: write-var gs#399628 <= s_2718_12
        fn_state.gs_399628 = s_2718_12;
        // N s_2718_14: jump b2717
        return block_2717(state, tracer, fn_state);
    }
    fn block_2719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2719_0: const #3489s : i
        let s_2719_0: i128 = 3489;
        // C s_2719_1: const #14696u : u32
        let s_2719_1: u32 = 14696;
        // D s_2719_2: read-reg s_2719_1:i
        let s_2719_2: i128 = {
            let value = state.read_register::<i128>(s_2719_1 as isize);
            tracer.read_register(s_2719_1 as isize, value);
            value
        };
        // D s_2719_3: cmp-lt s_2719_2 s_2719_0
        let s_2719_3: bool = ((s_2719_2) < (s_2719_0));
        // D s_2719_4: write-var gs#399606 <= s_2719_3
        fn_state.gs_399606 = s_2719_3;
        // N s_2719_5: jump b641
        return block_641(state, tracer, fn_state);
    }
    fn block_2720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2720_0: const #20s : i
        let s_2720_0: i128 = 20;
        // D s_2720_1: read-var u#31106:u32
        let s_2720_1: u32 = fn_state.u_31106;
        // D s_2720_2: cast zx s_2720_1 -> bv
        let s_2720_2: Bits = Bits::new(s_2720_1 as u128, 32u16);
        // C s_2720_3: const #1s : i64
        let s_2720_3: i64 = 1;
        // C s_2720_4: cast zx s_2720_3 -> i
        let s_2720_4: i128 = (i128::try_from(s_2720_3).unwrap());
        // C s_2720_5: const #1s : i
        let s_2720_5: i128 = 1;
        // C s_2720_6: add s_2720_5 s_2720_4
        let s_2720_6: i128 = (s_2720_5 + s_2720_4);
        // D s_2720_7: bit-extract s_2720_2 s_2720_0 s_2720_6
        let s_2720_7: Bits = (Bits::new(
            ((s_2720_2) >> (s_2720_0)).value(),
            u16::try_from(s_2720_6).unwrap(),
        ));
        // D s_2720_8: cast reint s_2720_7 -> u8
        let s_2720_8: u8 = (s_2720_7.value() as u8);
        // D s_2720_9: cast zx s_2720_8 -> bv
        let s_2720_9: Bits = Bits::new(s_2720_8 as u128, 2u16);
        // C s_2720_10: const #2u : u8
        let s_2720_10: u8 = 2;
        // C s_2720_11: cast zx s_2720_10 -> bv
        let s_2720_11: Bits = Bits::new(s_2720_10 as u128, 2u16);
        // D s_2720_12: cmp-eq s_2720_9 s_2720_11
        let s_2720_12: bool = ((s_2720_9) == (s_2720_11));
        // N s_2720_13: branch s_2720_12 b2723 b2721
        if s_2720_12 {
            return block_2723(state, tracer, fn_state);
        } else {
            return block_2721(state, tracer, fn_state);
        };
    }
    fn block_2721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2721_0: const #0u : u8
        let s_2721_0: bool = false;
        // D s_2721_1: write-var gs#399603 <= s_2721_0
        fn_state.gs_399603 = s_2721_0;
        // N s_2721_2: jump b2722
        return block_2722(state, tracer, fn_state);
    }
    fn block_2722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2722_0: read-var gs#399603:u8
        let s_2722_0: bool = fn_state.gs_399603;
        // D s_2722_1: write-var gs#399604 <= s_2722_0
        fn_state.gs_399604 = s_2722_0;
        // N s_2722_2: jump b639
        return block_639(state, tracer, fn_state);
    }
    fn block_2723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2723_0: const #8s : i
        let s_2723_0: i128 = 8;
        // D s_2723_1: read-var u#31106:u32
        let s_2723_1: u32 = fn_state.u_31106;
        // D s_2723_2: cast zx s_2723_1 -> bv
        let s_2723_2: Bits = Bits::new(s_2723_1 as u128, 32u16);
        // C s_2723_3: const #1s : i64
        let s_2723_3: i64 = 1;
        // C s_2723_4: cast zx s_2723_3 -> i
        let s_2723_4: i128 = (i128::try_from(s_2723_3).unwrap());
        // C s_2723_5: const #3s : i
        let s_2723_5: i128 = 3;
        // C s_2723_6: add s_2723_5 s_2723_4
        let s_2723_6: i128 = (s_2723_5 + s_2723_4);
        // D s_2723_7: bit-extract s_2723_2 s_2723_0 s_2723_6
        let s_2723_7: Bits = (Bits::new(
            ((s_2723_2) >> (s_2723_0)).value(),
            u16::try_from(s_2723_6).unwrap(),
        ));
        // D s_2723_8: cast reint s_2723_7 -> u8
        let s_2723_8: u8 = (s_2723_7.value() as u8);
        // D s_2723_9: cast zx s_2723_8 -> bv
        let s_2723_9: Bits = Bits::new(s_2723_8 as u128, 4u16);
        // C s_2723_10: const #7u : u8
        let s_2723_10: u8 = 7;
        // C s_2723_11: cast zx s_2723_10 -> bv
        let s_2723_11: Bits = Bits::new(s_2723_10 as u128, 4u16);
        // D s_2723_12: cmp-eq s_2723_9 s_2723_11
        let s_2723_12: bool = ((s_2723_9) == (s_2723_11));
        // D s_2723_13: write-var gs#399603 <= s_2723_12
        fn_state.gs_399603 = s_2723_12;
        // N s_2723_14: jump b2722
        return block_2722(state, tracer, fn_state);
    }
    fn block_2724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2724_0: const #3488s : i
        let s_2724_0: i128 = 3488;
        // C s_2724_1: const #14696u : u32
        let s_2724_1: u32 = 14696;
        // D s_2724_2: read-reg s_2724_1:i
        let s_2724_2: i128 = {
            let value = state.read_register::<i128>(s_2724_1 as isize);
            tracer.read_register(s_2724_1 as isize, value);
            value
        };
        // D s_2724_3: cmp-lt s_2724_2 s_2724_0
        let s_2724_3: bool = ((s_2724_2) < (s_2724_0));
        // D s_2724_4: write-var gs#399581 <= s_2724_3
        fn_state.gs_399581 = s_2724_3;
        // N s_2724_5: jump b635
        return block_635(state, tracer, fn_state);
    }
    fn block_2725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2725_0: const #20s : i
        let s_2725_0: i128 = 20;
        // D s_2725_1: read-var u#31098:u32
        let s_2725_1: u32 = fn_state.u_31098;
        // D s_2725_2: cast zx s_2725_1 -> bv
        let s_2725_2: Bits = Bits::new(s_2725_1 as u128, 32u16);
        // C s_2725_3: const #1s : i64
        let s_2725_3: i64 = 1;
        // C s_2725_4: cast zx s_2725_3 -> i
        let s_2725_4: i128 = (i128::try_from(s_2725_3).unwrap());
        // C s_2725_5: const #1s : i
        let s_2725_5: i128 = 1;
        // C s_2725_6: add s_2725_5 s_2725_4
        let s_2725_6: i128 = (s_2725_5 + s_2725_4);
        // D s_2725_7: bit-extract s_2725_2 s_2725_0 s_2725_6
        let s_2725_7: Bits = (Bits::new(
            ((s_2725_2) >> (s_2725_0)).value(),
            u16::try_from(s_2725_6).unwrap(),
        ));
        // D s_2725_8: cast reint s_2725_7 -> u8
        let s_2725_8: u8 = (s_2725_7.value() as u8);
        // D s_2725_9: cast zx s_2725_8 -> bv
        let s_2725_9: Bits = Bits::new(s_2725_8 as u128, 2u16);
        // C s_2725_10: const #2u : u8
        let s_2725_10: u8 = 2;
        // C s_2725_11: cast zx s_2725_10 -> bv
        let s_2725_11: Bits = Bits::new(s_2725_10 as u128, 2u16);
        // D s_2725_12: cmp-eq s_2725_9 s_2725_11
        let s_2725_12: bool = ((s_2725_9) == (s_2725_11));
        // N s_2725_13: branch s_2725_12 b2728 b2726
        if s_2725_12 {
            return block_2728(state, tracer, fn_state);
        } else {
            return block_2726(state, tracer, fn_state);
        };
    }
    fn block_2726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2726_0: const #0u : u8
        let s_2726_0: bool = false;
        // D s_2726_1: write-var gs#399578 <= s_2726_0
        fn_state.gs_399578 = s_2726_0;
        // N s_2726_2: jump b2727
        return block_2727(state, tracer, fn_state);
    }
    fn block_2727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2727_0: read-var gs#399578:u8
        let s_2727_0: bool = fn_state.gs_399578;
        // D s_2727_1: write-var gs#399579 <= s_2727_0
        fn_state.gs_399579 = s_2727_0;
        // N s_2727_2: jump b633
        return block_633(state, tracer, fn_state);
    }
    fn block_2728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2728_0: const #8s : i
        let s_2728_0: i128 = 8;
        // D s_2728_1: read-var u#31098:u32
        let s_2728_1: u32 = fn_state.u_31098;
        // D s_2728_2: cast zx s_2728_1 -> bv
        let s_2728_2: Bits = Bits::new(s_2728_1 as u128, 32u16);
        // C s_2728_3: const #1s : i64
        let s_2728_3: i64 = 1;
        // C s_2728_4: cast zx s_2728_3 -> i
        let s_2728_4: i128 = (i128::try_from(s_2728_3).unwrap());
        // C s_2728_5: const #3s : i
        let s_2728_5: i128 = 3;
        // C s_2728_6: add s_2728_5 s_2728_4
        let s_2728_6: i128 = (s_2728_5 + s_2728_4);
        // D s_2728_7: bit-extract s_2728_2 s_2728_0 s_2728_6
        let s_2728_7: Bits = (Bits::new(
            ((s_2728_2) >> (s_2728_0)).value(),
            u16::try_from(s_2728_6).unwrap(),
        ));
        // D s_2728_8: cast reint s_2728_7 -> u8
        let s_2728_8: u8 = (s_2728_7.value() as u8);
        // D s_2728_9: cast zx s_2728_8 -> bv
        let s_2728_9: Bits = Bits::new(s_2728_8 as u128, 4u16);
        // C s_2728_10: const #3u : u8
        let s_2728_10: u8 = 3;
        // C s_2728_11: cast zx s_2728_10 -> bv
        let s_2728_11: Bits = Bits::new(s_2728_10 as u128, 4u16);
        // D s_2728_12: cmp-eq s_2728_9 s_2728_11
        let s_2728_12: bool = ((s_2728_9) == (s_2728_11));
        // D s_2728_13: write-var gs#399578 <= s_2728_12
        fn_state.gs_399578 = s_2728_12;
        // N s_2728_14: jump b2727
        return block_2727(state, tracer, fn_state);
    }
    fn block_2729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2729_0: const #3486s : i
        let s_2729_0: i128 = 3486;
        // C s_2729_1: const #14696u : u32
        let s_2729_1: u32 = 14696;
        // D s_2729_2: read-reg s_2729_1:i
        let s_2729_2: i128 = {
            let value = state.read_register::<i128>(s_2729_1 as isize);
            tracer.read_register(s_2729_1 as isize, value);
            value
        };
        // D s_2729_3: cmp-lt s_2729_2 s_2729_0
        let s_2729_3: bool = ((s_2729_2) < (s_2729_0));
        // D s_2729_4: write-var gs#399554 <= s_2729_3
        fn_state.gs_399554 = s_2729_3;
        // N s_2729_5: jump b629
        return block_629(state, tracer, fn_state);
    }
    fn block_2730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2730_0: const #20s : i
        let s_2730_0: i128 = 20;
        // D s_2730_1: read-var u#31089:u32
        let s_2730_1: u32 = fn_state.u_31089;
        // D s_2730_2: cast zx s_2730_1 -> bv
        let s_2730_2: Bits = Bits::new(s_2730_1 as u128, 32u16);
        // C s_2730_3: const #1s : i64
        let s_2730_3: i64 = 1;
        // C s_2730_4: cast zx s_2730_3 -> i
        let s_2730_4: i128 = (i128::try_from(s_2730_3).unwrap());
        // C s_2730_5: const #1s : i
        let s_2730_5: i128 = 1;
        // C s_2730_6: add s_2730_5 s_2730_4
        let s_2730_6: i128 = (s_2730_5 + s_2730_4);
        // D s_2730_7: bit-extract s_2730_2 s_2730_0 s_2730_6
        let s_2730_7: Bits = (Bits::new(
            ((s_2730_2) >> (s_2730_0)).value(),
            u16::try_from(s_2730_6).unwrap(),
        ));
        // D s_2730_8: cast reint s_2730_7 -> u8
        let s_2730_8: u8 = (s_2730_7.value() as u8);
        // D s_2730_9: cast zx s_2730_8 -> bv
        let s_2730_9: Bits = Bits::new(s_2730_8 as u128, 2u16);
        // C s_2730_10: const #2u : u8
        let s_2730_10: u8 = 2;
        // C s_2730_11: cast zx s_2730_10 -> bv
        let s_2730_11: Bits = Bits::new(s_2730_10 as u128, 2u16);
        // D s_2730_12: cmp-eq s_2730_9 s_2730_11
        let s_2730_12: bool = ((s_2730_9) == (s_2730_11));
        // N s_2730_13: branch s_2730_12 b2733 b2731
        if s_2730_12 {
            return block_2733(state, tracer, fn_state);
        } else {
            return block_2731(state, tracer, fn_state);
        };
    }
    fn block_2731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2731_0: const #0u : u8
        let s_2731_0: bool = false;
        // D s_2731_1: write-var gs#399551 <= s_2731_0
        fn_state.gs_399551 = s_2731_0;
        // N s_2731_2: jump b2732
        return block_2732(state, tracer, fn_state);
    }
    fn block_2732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2732_0: read-var gs#399551:u8
        let s_2732_0: bool = fn_state.gs_399551;
        // D s_2732_1: write-var gs#399552 <= s_2732_0
        fn_state.gs_399552 = s_2732_0;
        // N s_2732_2: jump b627
        return block_627(state, tracer, fn_state);
    }
    fn block_2733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2733_0: const #9s : i
        let s_2733_0: i128 = 9;
        // D s_2733_1: read-var u#31089:u32
        let s_2733_1: u32 = fn_state.u_31089;
        // D s_2733_2: cast zx s_2733_1 -> bv
        let s_2733_2: Bits = Bits::new(s_2733_1 as u128, 32u16);
        // C s_2733_3: const #1s : i64
        let s_2733_3: i64 = 1;
        // C s_2733_4: cast zx s_2733_3 -> i
        let s_2733_4: i128 = (i128::try_from(s_2733_3).unwrap());
        // C s_2733_5: const #2s : i
        let s_2733_5: i128 = 2;
        // C s_2733_6: add s_2733_5 s_2733_4
        let s_2733_6: i128 = (s_2733_5 + s_2733_4);
        // D s_2733_7: bit-extract s_2733_2 s_2733_0 s_2733_6
        let s_2733_7: Bits = (Bits::new(
            ((s_2733_2) >> (s_2733_0)).value(),
            u16::try_from(s_2733_6).unwrap(),
        ));
        // D s_2733_8: cast reint s_2733_7 -> u8
        let s_2733_8: u8 = (s_2733_7.value() as u8);
        // D s_2733_9: cast zx s_2733_8 -> bv
        let s_2733_9: Bits = Bits::new(s_2733_8 as u128, 3u16);
        // C s_2733_10: const #2u : u8
        let s_2733_10: u8 = 2;
        // C s_2733_11: cast zx s_2733_10 -> bv
        let s_2733_11: Bits = Bits::new(s_2733_10 as u128, 3u16);
        // D s_2733_12: cmp-eq s_2733_9 s_2733_11
        let s_2733_12: bool = ((s_2733_9) == (s_2733_11));
        // D s_2733_13: write-var gs#399551 <= s_2733_12
        fn_state.gs_399551 = s_2733_12;
        // N s_2733_14: jump b2732
        return block_2732(state, tracer, fn_state);
    }
    fn block_2734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2734_0: const #3484s : i
        let s_2734_0: i128 = 3484;
        // C s_2734_1: const #14696u : u32
        let s_2734_1: u32 = 14696;
        // D s_2734_2: read-reg s_2734_1:i
        let s_2734_2: i128 = {
            let value = state.read_register::<i128>(s_2734_1 as isize);
            tracer.read_register(s_2734_1 as isize, value);
            value
        };
        // D s_2734_3: cmp-lt s_2734_2 s_2734_0
        let s_2734_3: bool = ((s_2734_2) < (s_2734_0));
        // D s_2734_4: write-var gs#399527 <= s_2734_3
        fn_state.gs_399527 = s_2734_3;
        // N s_2734_5: jump b623
        return block_623(state, tracer, fn_state);
    }
    fn block_2735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2735_0: const #20s : i
        let s_2735_0: i128 = 20;
        // D s_2735_1: read-var u#31080:u32
        let s_2735_1: u32 = fn_state.u_31080;
        // D s_2735_2: cast zx s_2735_1 -> bv
        let s_2735_2: Bits = Bits::new(s_2735_1 as u128, 32u16);
        // C s_2735_3: const #1s : i64
        let s_2735_3: i64 = 1;
        // C s_2735_4: cast zx s_2735_3 -> i
        let s_2735_4: i128 = (i128::try_from(s_2735_3).unwrap());
        // C s_2735_5: const #1s : i
        let s_2735_5: i128 = 1;
        // C s_2735_6: add s_2735_5 s_2735_4
        let s_2735_6: i128 = (s_2735_5 + s_2735_4);
        // D s_2735_7: bit-extract s_2735_2 s_2735_0 s_2735_6
        let s_2735_7: Bits = (Bits::new(
            ((s_2735_2) >> (s_2735_0)).value(),
            u16::try_from(s_2735_6).unwrap(),
        ));
        // D s_2735_8: cast reint s_2735_7 -> u8
        let s_2735_8: u8 = (s_2735_7.value() as u8);
        // D s_2735_9: cast zx s_2735_8 -> bv
        let s_2735_9: Bits = Bits::new(s_2735_8 as u128, 2u16);
        // C s_2735_10: const #2u : u8
        let s_2735_10: u8 = 2;
        // C s_2735_11: cast zx s_2735_10 -> bv
        let s_2735_11: Bits = Bits::new(s_2735_10 as u128, 2u16);
        // D s_2735_12: cmp-eq s_2735_9 s_2735_11
        let s_2735_12: bool = ((s_2735_9) == (s_2735_11));
        // N s_2735_13: branch s_2735_12 b2738 b2736
        if s_2735_12 {
            return block_2738(state, tracer, fn_state);
        } else {
            return block_2736(state, tracer, fn_state);
        };
    }
    fn block_2736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2736_0: const #0u : u8
        let s_2736_0: bool = false;
        // D s_2736_1: write-var gs#399524 <= s_2736_0
        fn_state.gs_399524 = s_2736_0;
        // N s_2736_2: jump b2737
        return block_2737(state, tracer, fn_state);
    }
    fn block_2737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2737_0: read-var gs#399524:u8
        let s_2737_0: bool = fn_state.gs_399524;
        // D s_2737_1: write-var gs#399525 <= s_2737_0
        fn_state.gs_399525 = s_2737_0;
        // N s_2737_2: jump b621
        return block_621(state, tracer, fn_state);
    }
    fn block_2738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2738_0: const #8s : i
        let s_2738_0: i128 = 8;
        // D s_2738_1: read-var u#31080:u32
        let s_2738_1: u32 = fn_state.u_31080;
        // D s_2738_2: cast zx s_2738_1 -> bv
        let s_2738_2: Bits = Bits::new(s_2738_1 as u128, 32u16);
        // C s_2738_3: const #1s : i64
        let s_2738_3: i64 = 1;
        // C s_2738_4: cast zx s_2738_3 -> i
        let s_2738_4: i128 = (i128::try_from(s_2738_3).unwrap());
        // C s_2738_5: const #3s : i
        let s_2738_5: i128 = 3;
        // C s_2738_6: add s_2738_5 s_2738_4
        let s_2738_6: i128 = (s_2738_5 + s_2738_4);
        // D s_2738_7: bit-extract s_2738_2 s_2738_0 s_2738_6
        let s_2738_7: Bits = (Bits::new(
            ((s_2738_2) >> (s_2738_0)).value(),
            u16::try_from(s_2738_6).unwrap(),
        ));
        // D s_2738_8: cast reint s_2738_7 -> u8
        let s_2738_8: u8 = (s_2738_7.value() as u8);
        // D s_2738_9: cast zx s_2738_8 -> bv
        let s_2738_9: Bits = Bits::new(s_2738_8 as u128, 4u16);
        // C s_2738_10: const #14u : u8
        let s_2738_10: u8 = 14;
        // C s_2738_11: cast zx s_2738_10 -> bv
        let s_2738_11: Bits = Bits::new(s_2738_10 as u128, 4u16);
        // D s_2738_12: cmp-eq s_2738_9 s_2738_11
        let s_2738_12: bool = ((s_2738_9) == (s_2738_11));
        // D s_2738_13: write-var gs#399524 <= s_2738_12
        fn_state.gs_399524 = s_2738_12;
        // N s_2738_14: jump b2737
        return block_2737(state, tracer, fn_state);
    }
    fn block_2739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2739_0: const #3480s : i
        let s_2739_0: i128 = 3480;
        // C s_2739_1: const #14696u : u32
        let s_2739_1: u32 = 14696;
        // D s_2739_2: read-reg s_2739_1:i
        let s_2739_2: i128 = {
            let value = state.read_register::<i128>(s_2739_1 as isize);
            tracer.read_register(s_2739_1 as isize, value);
            value
        };
        // D s_2739_3: cmp-lt s_2739_2 s_2739_0
        let s_2739_3: bool = ((s_2739_2) < (s_2739_0));
        // D s_2739_4: write-var gs#399502 <= s_2739_3
        fn_state.gs_399502 = s_2739_3;
        // N s_2739_5: jump b617
        return block_617(state, tracer, fn_state);
    }
    fn block_2740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2740_0: const #20s : i
        let s_2740_0: i128 = 20;
        // D s_2740_1: read-var u#31072:u32
        let s_2740_1: u32 = fn_state.u_31072;
        // D s_2740_2: cast zx s_2740_1 -> bv
        let s_2740_2: Bits = Bits::new(s_2740_1 as u128, 32u16);
        // C s_2740_3: const #1s : i64
        let s_2740_3: i64 = 1;
        // C s_2740_4: cast zx s_2740_3 -> i
        let s_2740_4: i128 = (i128::try_from(s_2740_3).unwrap());
        // C s_2740_5: const #1s : i
        let s_2740_5: i128 = 1;
        // C s_2740_6: add s_2740_5 s_2740_4
        let s_2740_6: i128 = (s_2740_5 + s_2740_4);
        // D s_2740_7: bit-extract s_2740_2 s_2740_0 s_2740_6
        let s_2740_7: Bits = (Bits::new(
            ((s_2740_2) >> (s_2740_0)).value(),
            u16::try_from(s_2740_6).unwrap(),
        ));
        // D s_2740_8: cast reint s_2740_7 -> u8
        let s_2740_8: u8 = (s_2740_7.value() as u8);
        // D s_2740_9: cast zx s_2740_8 -> bv
        let s_2740_9: Bits = Bits::new(s_2740_8 as u128, 2u16);
        // C s_2740_10: const #2u : u8
        let s_2740_10: u8 = 2;
        // C s_2740_11: cast zx s_2740_10 -> bv
        let s_2740_11: Bits = Bits::new(s_2740_10 as u128, 2u16);
        // D s_2740_12: cmp-eq s_2740_9 s_2740_11
        let s_2740_12: bool = ((s_2740_9) == (s_2740_11));
        // N s_2740_13: branch s_2740_12 b2743 b2741
        if s_2740_12 {
            return block_2743(state, tracer, fn_state);
        } else {
            return block_2741(state, tracer, fn_state);
        };
    }
    fn block_2741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2741_0: const #0u : u8
        let s_2741_0: bool = false;
        // D s_2741_1: write-var gs#399499 <= s_2741_0
        fn_state.gs_399499 = s_2741_0;
        // N s_2741_2: jump b2742
        return block_2742(state, tracer, fn_state);
    }
    fn block_2742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2742_0: read-var gs#399499:u8
        let s_2742_0: bool = fn_state.gs_399499;
        // D s_2742_1: write-var gs#399500 <= s_2742_0
        fn_state.gs_399500 = s_2742_0;
        // N s_2742_2: jump b615
        return block_615(state, tracer, fn_state);
    }
    fn block_2743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2743_0: const #8s : i
        let s_2743_0: i128 = 8;
        // D s_2743_1: read-var u#31072:u32
        let s_2743_1: u32 = fn_state.u_31072;
        // D s_2743_2: cast zx s_2743_1 -> bv
        let s_2743_2: Bits = Bits::new(s_2743_1 as u128, 32u16);
        // C s_2743_3: const #1s : i64
        let s_2743_3: i64 = 1;
        // C s_2743_4: cast zx s_2743_3 -> i
        let s_2743_4: i128 = (i128::try_from(s_2743_3).unwrap());
        // C s_2743_5: const #3s : i
        let s_2743_5: i128 = 3;
        // C s_2743_6: add s_2743_5 s_2743_4
        let s_2743_6: i128 = (s_2743_5 + s_2743_4);
        // D s_2743_7: bit-extract s_2743_2 s_2743_0 s_2743_6
        let s_2743_7: Bits = (Bits::new(
            ((s_2743_2) >> (s_2743_0)).value(),
            u16::try_from(s_2743_6).unwrap(),
        ));
        // D s_2743_8: cast reint s_2743_7 -> u8
        let s_2743_8: u8 = (s_2743_7.value() as u8);
        // D s_2743_9: cast zx s_2743_8 -> bv
        let s_2743_9: Bits = Bits::new(s_2743_8 as u128, 4u16);
        // C s_2743_10: const #10u : u8
        let s_2743_10: u8 = 10;
        // C s_2743_11: cast zx s_2743_10 -> bv
        let s_2743_11: Bits = Bits::new(s_2743_10 as u128, 4u16);
        // D s_2743_12: cmp-eq s_2743_9 s_2743_11
        let s_2743_12: bool = ((s_2743_9) == (s_2743_11));
        // D s_2743_13: write-var gs#399499 <= s_2743_12
        fn_state.gs_399499 = s_2743_12;
        // N s_2743_14: jump b2742
        return block_2742(state, tracer, fn_state);
    }
    fn block_2744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2744_0: const #3479s : i
        let s_2744_0: i128 = 3479;
        // C s_2744_1: const #14696u : u32
        let s_2744_1: u32 = 14696;
        // D s_2744_2: read-reg s_2744_1:i
        let s_2744_2: i128 = {
            let value = state.read_register::<i128>(s_2744_1 as isize);
            tracer.read_register(s_2744_1 as isize, value);
            value
        };
        // D s_2744_3: cmp-lt s_2744_2 s_2744_0
        let s_2744_3: bool = ((s_2744_2) < (s_2744_0));
        // D s_2744_4: write-var gs#399477 <= s_2744_3
        fn_state.gs_399477 = s_2744_3;
        // N s_2744_5: jump b611
        return block_611(state, tracer, fn_state);
    }
    fn block_2745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2745_0: const #20s : i
        let s_2745_0: i128 = 20;
        // D s_2745_1: read-var u#31064:u32
        let s_2745_1: u32 = fn_state.u_31064;
        // D s_2745_2: cast zx s_2745_1 -> bv
        let s_2745_2: Bits = Bits::new(s_2745_1 as u128, 32u16);
        // C s_2745_3: const #1s : i64
        let s_2745_3: i64 = 1;
        // C s_2745_4: cast zx s_2745_3 -> i
        let s_2745_4: i128 = (i128::try_from(s_2745_3).unwrap());
        // C s_2745_5: const #1s : i
        let s_2745_5: i128 = 1;
        // C s_2745_6: add s_2745_5 s_2745_4
        let s_2745_6: i128 = (s_2745_5 + s_2745_4);
        // D s_2745_7: bit-extract s_2745_2 s_2745_0 s_2745_6
        let s_2745_7: Bits = (Bits::new(
            ((s_2745_2) >> (s_2745_0)).value(),
            u16::try_from(s_2745_6).unwrap(),
        ));
        // D s_2745_8: cast reint s_2745_7 -> u8
        let s_2745_8: u8 = (s_2745_7.value() as u8);
        // D s_2745_9: cast zx s_2745_8 -> bv
        let s_2745_9: Bits = Bits::new(s_2745_8 as u128, 2u16);
        // C s_2745_10: const #2u : u8
        let s_2745_10: u8 = 2;
        // C s_2745_11: cast zx s_2745_10 -> bv
        let s_2745_11: Bits = Bits::new(s_2745_10 as u128, 2u16);
        // D s_2745_12: cmp-eq s_2745_9 s_2745_11
        let s_2745_12: bool = ((s_2745_9) == (s_2745_11));
        // N s_2745_13: branch s_2745_12 b2748 b2746
        if s_2745_12 {
            return block_2748(state, tracer, fn_state);
        } else {
            return block_2746(state, tracer, fn_state);
        };
    }
    fn block_2746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2746_0: const #0u : u8
        let s_2746_0: bool = false;
        // D s_2746_1: write-var gs#399474 <= s_2746_0
        fn_state.gs_399474 = s_2746_0;
        // N s_2746_2: jump b2747
        return block_2747(state, tracer, fn_state);
    }
    fn block_2747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2747_0: read-var gs#399474:u8
        let s_2747_0: bool = fn_state.gs_399474;
        // D s_2747_1: write-var gs#399475 <= s_2747_0
        fn_state.gs_399475 = s_2747_0;
        // N s_2747_2: jump b609
        return block_609(state, tracer, fn_state);
    }
    fn block_2748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2748_0: const #8s : i
        let s_2748_0: i128 = 8;
        // D s_2748_1: read-var u#31064:u32
        let s_2748_1: u32 = fn_state.u_31064;
        // D s_2748_2: cast zx s_2748_1 -> bv
        let s_2748_2: Bits = Bits::new(s_2748_1 as u128, 32u16);
        // C s_2748_3: const #1s : i64
        let s_2748_3: i64 = 1;
        // C s_2748_4: cast zx s_2748_3 -> i
        let s_2748_4: i128 = (i128::try_from(s_2748_3).unwrap());
        // C s_2748_5: const #3s : i
        let s_2748_5: i128 = 3;
        // C s_2748_6: add s_2748_5 s_2748_4
        let s_2748_6: i128 = (s_2748_5 + s_2748_4);
        // D s_2748_7: bit-extract s_2748_2 s_2748_0 s_2748_6
        let s_2748_7: Bits = (Bits::new(
            ((s_2748_2) >> (s_2748_0)).value(),
            u16::try_from(s_2748_6).unwrap(),
        ));
        // D s_2748_8: cast reint s_2748_7 -> u8
        let s_2748_8: u8 = (s_2748_7.value() as u8);
        // D s_2748_9: cast zx s_2748_8 -> bv
        let s_2748_9: Bits = Bits::new(s_2748_8 as u128, 4u16);
        // C s_2748_10: const #6u : u8
        let s_2748_10: u8 = 6;
        // C s_2748_11: cast zx s_2748_10 -> bv
        let s_2748_11: Bits = Bits::new(s_2748_10 as u128, 4u16);
        // D s_2748_12: cmp-eq s_2748_9 s_2748_11
        let s_2748_12: bool = ((s_2748_9) == (s_2748_11));
        // D s_2748_13: write-var gs#399474 <= s_2748_12
        fn_state.gs_399474 = s_2748_12;
        // N s_2748_14: jump b2747
        return block_2747(state, tracer, fn_state);
    }
    fn block_2749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2749_0: const #3478s : i
        let s_2749_0: i128 = 3478;
        // C s_2749_1: const #14696u : u32
        let s_2749_1: u32 = 14696;
        // D s_2749_2: read-reg s_2749_1:i
        let s_2749_2: i128 = {
            let value = state.read_register::<i128>(s_2749_1 as isize);
            tracer.read_register(s_2749_1 as isize, value);
            value
        };
        // D s_2749_3: cmp-lt s_2749_2 s_2749_0
        let s_2749_3: bool = ((s_2749_2) < (s_2749_0));
        // D s_2749_4: write-var gs#399452 <= s_2749_3
        fn_state.gs_399452 = s_2749_3;
        // N s_2749_5: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_2750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2750_0: const #20s : i
        let s_2750_0: i128 = 20;
        // D s_2750_1: read-var u#31056:u32
        let s_2750_1: u32 = fn_state.u_31056;
        // D s_2750_2: cast zx s_2750_1 -> bv
        let s_2750_2: Bits = Bits::new(s_2750_1 as u128, 32u16);
        // C s_2750_3: const #1s : i64
        let s_2750_3: i64 = 1;
        // C s_2750_4: cast zx s_2750_3 -> i
        let s_2750_4: i128 = (i128::try_from(s_2750_3).unwrap());
        // C s_2750_5: const #1s : i
        let s_2750_5: i128 = 1;
        // C s_2750_6: add s_2750_5 s_2750_4
        let s_2750_6: i128 = (s_2750_5 + s_2750_4);
        // D s_2750_7: bit-extract s_2750_2 s_2750_0 s_2750_6
        let s_2750_7: Bits = (Bits::new(
            ((s_2750_2) >> (s_2750_0)).value(),
            u16::try_from(s_2750_6).unwrap(),
        ));
        // D s_2750_8: cast reint s_2750_7 -> u8
        let s_2750_8: u8 = (s_2750_7.value() as u8);
        // D s_2750_9: cast zx s_2750_8 -> bv
        let s_2750_9: Bits = Bits::new(s_2750_8 as u128, 2u16);
        // C s_2750_10: const #2u : u8
        let s_2750_10: u8 = 2;
        // C s_2750_11: cast zx s_2750_10 -> bv
        let s_2750_11: Bits = Bits::new(s_2750_10 as u128, 2u16);
        // D s_2750_12: cmp-eq s_2750_9 s_2750_11
        let s_2750_12: bool = ((s_2750_9) == (s_2750_11));
        // N s_2750_13: branch s_2750_12 b2753 b2751
        if s_2750_12 {
            return block_2753(state, tracer, fn_state);
        } else {
            return block_2751(state, tracer, fn_state);
        };
    }
    fn block_2751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2751_0: const #0u : u8
        let s_2751_0: bool = false;
        // D s_2751_1: write-var gs#399449 <= s_2751_0
        fn_state.gs_399449 = s_2751_0;
        // N s_2751_2: jump b2752
        return block_2752(state, tracer, fn_state);
    }
    fn block_2752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2752_0: read-var gs#399449:u8
        let s_2752_0: bool = fn_state.gs_399449;
        // D s_2752_1: write-var gs#399450 <= s_2752_0
        fn_state.gs_399450 = s_2752_0;
        // N s_2752_2: jump b603
        return block_603(state, tracer, fn_state);
    }
    fn block_2753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2753_0: const #8s : i
        let s_2753_0: i128 = 8;
        // D s_2753_1: read-var u#31056:u32
        let s_2753_1: u32 = fn_state.u_31056;
        // D s_2753_2: cast zx s_2753_1 -> bv
        let s_2753_2: Bits = Bits::new(s_2753_1 as u128, 32u16);
        // C s_2753_3: const #1s : i64
        let s_2753_3: i64 = 1;
        // C s_2753_4: cast zx s_2753_3 -> i
        let s_2753_4: i128 = (i128::try_from(s_2753_3).unwrap());
        // C s_2753_5: const #3s : i
        let s_2753_5: i128 = 3;
        // C s_2753_6: add s_2753_5 s_2753_4
        let s_2753_6: i128 = (s_2753_5 + s_2753_4);
        // D s_2753_7: bit-extract s_2753_2 s_2753_0 s_2753_6
        let s_2753_7: Bits = (Bits::new(
            ((s_2753_2) >> (s_2753_0)).value(),
            u16::try_from(s_2753_6).unwrap(),
        ));
        // D s_2753_8: cast reint s_2753_7 -> u8
        let s_2753_8: u8 = (s_2753_7.value() as u8);
        // D s_2753_9: cast zx s_2753_8 -> bv
        let s_2753_9: Bits = Bits::new(s_2753_8 as u128, 4u16);
        // C s_2753_10: const #2u : u8
        let s_2753_10: u8 = 2;
        // C s_2753_11: cast zx s_2753_10 -> bv
        let s_2753_11: Bits = Bits::new(s_2753_10 as u128, 4u16);
        // D s_2753_12: cmp-eq s_2753_9 s_2753_11
        let s_2753_12: bool = ((s_2753_9) == (s_2753_11));
        // D s_2753_13: write-var gs#399449 <= s_2753_12
        fn_state.gs_399449 = s_2753_12;
        // N s_2753_14: jump b2752
        return block_2752(state, tracer, fn_state);
    }
    fn block_2754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2754_0: const #3475s : i
        let s_2754_0: i128 = 3475;
        // C s_2754_1: const #14696u : u32
        let s_2754_1: u32 = 14696;
        // D s_2754_2: read-reg s_2754_1:i
        let s_2754_2: i128 = {
            let value = state.read_register::<i128>(s_2754_1 as isize);
            tracer.read_register(s_2754_1 as isize, value);
            value
        };
        // D s_2754_3: cmp-lt s_2754_2 s_2754_0
        let s_2754_3: bool = ((s_2754_2) < (s_2754_0));
        // D s_2754_4: write-var gs#399425 <= s_2754_3
        fn_state.gs_399425 = s_2754_3;
        // N s_2754_5: jump b599
        return block_599(state, tracer, fn_state);
    }
    fn block_2755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2755_0: const #20s : i
        let s_2755_0: i128 = 20;
        // D s_2755_1: read-var u#31047:u32
        let s_2755_1: u32 = fn_state.u_31047;
        // D s_2755_2: cast zx s_2755_1 -> bv
        let s_2755_2: Bits = Bits::new(s_2755_1 as u128, 32u16);
        // C s_2755_3: const #1s : i64
        let s_2755_3: i64 = 1;
        // C s_2755_4: cast zx s_2755_3 -> i
        let s_2755_4: i128 = (i128::try_from(s_2755_3).unwrap());
        // C s_2755_5: const #1s : i
        let s_2755_5: i128 = 1;
        // C s_2755_6: add s_2755_5 s_2755_4
        let s_2755_6: i128 = (s_2755_5 + s_2755_4);
        // D s_2755_7: bit-extract s_2755_2 s_2755_0 s_2755_6
        let s_2755_7: Bits = (Bits::new(
            ((s_2755_2) >> (s_2755_0)).value(),
            u16::try_from(s_2755_6).unwrap(),
        ));
        // D s_2755_8: cast reint s_2755_7 -> u8
        let s_2755_8: u8 = (s_2755_7.value() as u8);
        // D s_2755_9: cast zx s_2755_8 -> bv
        let s_2755_9: Bits = Bits::new(s_2755_8 as u128, 2u16);
        // C s_2755_10: const #2u : u8
        let s_2755_10: u8 = 2;
        // C s_2755_11: cast zx s_2755_10 -> bv
        let s_2755_11: Bits = Bits::new(s_2755_10 as u128, 2u16);
        // D s_2755_12: cmp-eq s_2755_9 s_2755_11
        let s_2755_12: bool = ((s_2755_9) == (s_2755_11));
        // N s_2755_13: branch s_2755_12 b2758 b2756
        if s_2755_12 {
            return block_2758(state, tracer, fn_state);
        } else {
            return block_2756(state, tracer, fn_state);
        };
    }
    fn block_2756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2756_0: const #0u : u8
        let s_2756_0: bool = false;
        // D s_2756_1: write-var gs#399422 <= s_2756_0
        fn_state.gs_399422 = s_2756_0;
        // N s_2756_2: jump b2757
        return block_2757(state, tracer, fn_state);
    }
    fn block_2757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2757_0: read-var gs#399422:u8
        let s_2757_0: bool = fn_state.gs_399422;
        // D s_2757_1: write-var gs#399423 <= s_2757_0
        fn_state.gs_399423 = s_2757_0;
        // N s_2757_2: jump b597
        return block_597(state, tracer, fn_state);
    }
    fn block_2758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2758_0: const #8s : i
        let s_2758_0: i128 = 8;
        // D s_2758_1: read-var u#31047:u32
        let s_2758_1: u32 = fn_state.u_31047;
        // D s_2758_2: cast zx s_2758_1 -> bv
        let s_2758_2: Bits = Bits::new(s_2758_1 as u128, 32u16);
        // C s_2758_3: const #1s : i64
        let s_2758_3: i64 = 1;
        // C s_2758_4: cast zx s_2758_3 -> i
        let s_2758_4: i128 = (i128::try_from(s_2758_3).unwrap());
        // C s_2758_5: const #3s : i
        let s_2758_5: i128 = 3;
        // C s_2758_6: add s_2758_5 s_2758_4
        let s_2758_6: i128 = (s_2758_5 + s_2758_4);
        // D s_2758_7: bit-extract s_2758_2 s_2758_0 s_2758_6
        let s_2758_7: Bits = (Bits::new(
            ((s_2758_2) >> (s_2758_0)).value(),
            u16::try_from(s_2758_6).unwrap(),
        ));
        // D s_2758_8: cast reint s_2758_7 -> u8
        let s_2758_8: u8 = (s_2758_7.value() as u8);
        // D s_2758_9: cast zx s_2758_8 -> bv
        let s_2758_9: Bits = Bits::new(s_2758_8 as u128, 4u16);
        // C s_2758_10: const #3u : u8
        let s_2758_10: u8 = 3;
        // C s_2758_11: cast zx s_2758_10 -> bv
        let s_2758_11: Bits = Bits::new(s_2758_10 as u128, 4u16);
        // D s_2758_12: cmp-eq s_2758_9 s_2758_11
        let s_2758_12: bool = ((s_2758_9) == (s_2758_11));
        // D s_2758_13: write-var gs#399422 <= s_2758_12
        fn_state.gs_399422 = s_2758_12;
        // N s_2758_14: jump b2757
        return block_2757(state, tracer, fn_state);
    }
    fn block_2759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2759_0: const #3474s : i
        let s_2759_0: i128 = 3474;
        // C s_2759_1: const #14696u : u32
        let s_2759_1: u32 = 14696;
        // D s_2759_2: read-reg s_2759_1:i
        let s_2759_2: i128 = {
            let value = state.read_register::<i128>(s_2759_1 as isize);
            tracer.read_register(s_2759_1 as isize, value);
            value
        };
        // D s_2759_3: cmp-lt s_2759_2 s_2759_0
        let s_2759_3: bool = ((s_2759_2) < (s_2759_0));
        // D s_2759_4: write-var gs#399398 <= s_2759_3
        fn_state.gs_399398 = s_2759_3;
        // N s_2759_5: jump b593
        return block_593(state, tracer, fn_state);
    }
    fn block_2760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2760_0: const #20s : i
        let s_2760_0: i128 = 20;
        // D s_2760_1: read-var u#31038:u32
        let s_2760_1: u32 = fn_state.u_31038;
        // D s_2760_2: cast zx s_2760_1 -> bv
        let s_2760_2: Bits = Bits::new(s_2760_1 as u128, 32u16);
        // C s_2760_3: const #1s : i64
        let s_2760_3: i64 = 1;
        // C s_2760_4: cast zx s_2760_3 -> i
        let s_2760_4: i128 = (i128::try_from(s_2760_3).unwrap());
        // C s_2760_5: const #1s : i
        let s_2760_5: i128 = 1;
        // C s_2760_6: add s_2760_5 s_2760_4
        let s_2760_6: i128 = (s_2760_5 + s_2760_4);
        // D s_2760_7: bit-extract s_2760_2 s_2760_0 s_2760_6
        let s_2760_7: Bits = (Bits::new(
            ((s_2760_2) >> (s_2760_0)).value(),
            u16::try_from(s_2760_6).unwrap(),
        ));
        // D s_2760_8: cast reint s_2760_7 -> u8
        let s_2760_8: u8 = (s_2760_7.value() as u8);
        // D s_2760_9: cast zx s_2760_8 -> bv
        let s_2760_9: Bits = Bits::new(s_2760_8 as u128, 2u16);
        // C s_2760_10: const #2u : u8
        let s_2760_10: u8 = 2;
        // C s_2760_11: cast zx s_2760_10 -> bv
        let s_2760_11: Bits = Bits::new(s_2760_10 as u128, 2u16);
        // D s_2760_12: cmp-eq s_2760_9 s_2760_11
        let s_2760_12: bool = ((s_2760_9) == (s_2760_11));
        // N s_2760_13: branch s_2760_12 b2763 b2761
        if s_2760_12 {
            return block_2763(state, tracer, fn_state);
        } else {
            return block_2761(state, tracer, fn_state);
        };
    }
    fn block_2761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2761_0: const #0u : u8
        let s_2761_0: bool = false;
        // D s_2761_1: write-var gs#399395 <= s_2761_0
        fn_state.gs_399395 = s_2761_0;
        // N s_2761_2: jump b2762
        return block_2762(state, tracer, fn_state);
    }
    fn block_2762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2762_0: read-var gs#399395:u8
        let s_2762_0: bool = fn_state.gs_399395;
        // D s_2762_1: write-var gs#399396 <= s_2762_0
        fn_state.gs_399396 = s_2762_0;
        // N s_2762_2: jump b591
        return block_591(state, tracer, fn_state);
    }
    fn block_2763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2763_0: const #9s : i
        let s_2763_0: i128 = 9;
        // D s_2763_1: read-var u#31038:u32
        let s_2763_1: u32 = fn_state.u_31038;
        // D s_2763_2: cast zx s_2763_1 -> bv
        let s_2763_2: Bits = Bits::new(s_2763_1 as u128, 32u16);
        // C s_2763_3: const #1s : i64
        let s_2763_3: i64 = 1;
        // C s_2763_4: cast zx s_2763_3 -> i
        let s_2763_4: i128 = (i128::try_from(s_2763_3).unwrap());
        // C s_2763_5: const #2s : i
        let s_2763_5: i128 = 2;
        // C s_2763_6: add s_2763_5 s_2763_4
        let s_2763_6: i128 = (s_2763_5 + s_2763_4);
        // D s_2763_7: bit-extract s_2763_2 s_2763_0 s_2763_6
        let s_2763_7: Bits = (Bits::new(
            ((s_2763_2) >> (s_2763_0)).value(),
            u16::try_from(s_2763_6).unwrap(),
        ));
        // D s_2763_8: cast reint s_2763_7 -> u8
        let s_2763_8: u8 = (s_2763_7.value() as u8);
        // D s_2763_9: cast zx s_2763_8 -> bv
        let s_2763_9: Bits = Bits::new(s_2763_8 as u128, 3u16);
        // C s_2763_10: const #4u : u8
        let s_2763_10: u8 = 4;
        // C s_2763_11: cast zx s_2763_10 -> bv
        let s_2763_11: Bits = Bits::new(s_2763_10 as u128, 3u16);
        // D s_2763_12: cmp-eq s_2763_9 s_2763_11
        let s_2763_12: bool = ((s_2763_9) == (s_2763_11));
        // D s_2763_13: write-var gs#399395 <= s_2763_12
        fn_state.gs_399395 = s_2763_12;
        // N s_2763_14: jump b2762
        return block_2762(state, tracer, fn_state);
    }
    fn block_2764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2764_0: const #3472s : i
        let s_2764_0: i128 = 3472;
        // C s_2764_1: const #14696u : u32
        let s_2764_1: u32 = 14696;
        // D s_2764_2: read-reg s_2764_1:i
        let s_2764_2: i128 = {
            let value = state.read_register::<i128>(s_2764_1 as isize);
            tracer.read_register(s_2764_1 as isize, value);
            value
        };
        // D s_2764_3: cmp-lt s_2764_2 s_2764_0
        let s_2764_3: bool = ((s_2764_2) < (s_2764_0));
        // D s_2764_4: write-var gs#399371 <= s_2764_3
        fn_state.gs_399371 = s_2764_3;
        // N s_2764_5: jump b587
        return block_587(state, tracer, fn_state);
    }
    fn block_2765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2765_0: const #20s : i
        let s_2765_0: i128 = 20;
        // D s_2765_1: read-var u#31029:u32
        let s_2765_1: u32 = fn_state.u_31029;
        // D s_2765_2: cast zx s_2765_1 -> bv
        let s_2765_2: Bits = Bits::new(s_2765_1 as u128, 32u16);
        // C s_2765_3: const #1s : i64
        let s_2765_3: i64 = 1;
        // C s_2765_4: cast zx s_2765_3 -> i
        let s_2765_4: i128 = (i128::try_from(s_2765_3).unwrap());
        // C s_2765_5: const #1s : i
        let s_2765_5: i128 = 1;
        // C s_2765_6: add s_2765_5 s_2765_4
        let s_2765_6: i128 = (s_2765_5 + s_2765_4);
        // D s_2765_7: bit-extract s_2765_2 s_2765_0 s_2765_6
        let s_2765_7: Bits = (Bits::new(
            ((s_2765_2) >> (s_2765_0)).value(),
            u16::try_from(s_2765_6).unwrap(),
        ));
        // D s_2765_8: cast reint s_2765_7 -> u8
        let s_2765_8: u8 = (s_2765_7.value() as u8);
        // D s_2765_9: cast zx s_2765_8 -> bv
        let s_2765_9: Bits = Bits::new(s_2765_8 as u128, 2u16);
        // C s_2765_10: const #2u : u8
        let s_2765_10: u8 = 2;
        // C s_2765_11: cast zx s_2765_10 -> bv
        let s_2765_11: Bits = Bits::new(s_2765_10 as u128, 2u16);
        // D s_2765_12: cmp-eq s_2765_9 s_2765_11
        let s_2765_12: bool = ((s_2765_9) == (s_2765_11));
        // N s_2765_13: branch s_2765_12 b2768 b2766
        if s_2765_12 {
            return block_2768(state, tracer, fn_state);
        } else {
            return block_2766(state, tracer, fn_state);
        };
    }
    fn block_2766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2766_0: const #0u : u8
        let s_2766_0: bool = false;
        // D s_2766_1: write-var gs#399368 <= s_2766_0
        fn_state.gs_399368 = s_2766_0;
        // N s_2766_2: jump b2767
        return block_2767(state, tracer, fn_state);
    }
    fn block_2767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2767_0: read-var gs#399368:u8
        let s_2767_0: bool = fn_state.gs_399368;
        // D s_2767_1: write-var gs#399369 <= s_2767_0
        fn_state.gs_399369 = s_2767_0;
        // N s_2767_2: jump b585
        return block_585(state, tracer, fn_state);
    }
    fn block_2768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2768_0: const #8s : i
        let s_2768_0: i128 = 8;
        // D s_2768_1: read-var u#31029:u32
        let s_2768_1: u32 = fn_state.u_31029;
        // D s_2768_2: cast zx s_2768_1 -> bv
        let s_2768_2: Bits = Bits::new(s_2768_1 as u128, 32u16);
        // C s_2768_3: const #1s : i64
        let s_2768_3: i64 = 1;
        // C s_2768_4: cast zx s_2768_3 -> i
        let s_2768_4: i128 = (i128::try_from(s_2768_3).unwrap());
        // C s_2768_5: const #3s : i
        let s_2768_5: i128 = 3;
        // C s_2768_6: add s_2768_5 s_2768_4
        let s_2768_6: i128 = (s_2768_5 + s_2768_4);
        // D s_2768_7: bit-extract s_2768_2 s_2768_0 s_2768_6
        let s_2768_7: Bits = (Bits::new(
            ((s_2768_2) >> (s_2768_0)).value(),
            u16::try_from(s_2768_6).unwrap(),
        ));
        // D s_2768_8: cast reint s_2768_7 -> u8
        let s_2768_8: u8 = (s_2768_7.value() as u8);
        // D s_2768_9: cast zx s_2768_8 -> bv
        let s_2768_9: Bits = Bits::new(s_2768_8 as u128, 4u16);
        // C s_2768_10: const #13u : u8
        let s_2768_10: u8 = 13;
        // C s_2768_11: cast zx s_2768_10 -> bv
        let s_2768_11: Bits = Bits::new(s_2768_10 as u128, 4u16);
        // D s_2768_12: cmp-eq s_2768_9 s_2768_11
        let s_2768_12: bool = ((s_2768_9) == (s_2768_11));
        // D s_2768_13: write-var gs#399368 <= s_2768_12
        fn_state.gs_399368 = s_2768_12;
        // N s_2768_14: jump b2767
        return block_2767(state, tracer, fn_state);
    }
    fn block_2769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2769_0: const #3468s : i
        let s_2769_0: i128 = 3468;
        // C s_2769_1: const #14696u : u32
        let s_2769_1: u32 = 14696;
        // D s_2769_2: read-reg s_2769_1:i
        let s_2769_2: i128 = {
            let value = state.read_register::<i128>(s_2769_1 as isize);
            tracer.read_register(s_2769_1 as isize, value);
            value
        };
        // D s_2769_3: cmp-lt s_2769_2 s_2769_0
        let s_2769_3: bool = ((s_2769_2) < (s_2769_0));
        // D s_2769_4: write-var gs#399346 <= s_2769_3
        fn_state.gs_399346 = s_2769_3;
        // N s_2769_5: jump b581
        return block_581(state, tracer, fn_state);
    }
    fn block_2770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2770_0: const #20s : i
        let s_2770_0: i128 = 20;
        // D s_2770_1: read-var u#31021:u32
        let s_2770_1: u32 = fn_state.u_31021;
        // D s_2770_2: cast zx s_2770_1 -> bv
        let s_2770_2: Bits = Bits::new(s_2770_1 as u128, 32u16);
        // C s_2770_3: const #1s : i64
        let s_2770_3: i64 = 1;
        // C s_2770_4: cast zx s_2770_3 -> i
        let s_2770_4: i128 = (i128::try_from(s_2770_3).unwrap());
        // C s_2770_5: const #1s : i
        let s_2770_5: i128 = 1;
        // C s_2770_6: add s_2770_5 s_2770_4
        let s_2770_6: i128 = (s_2770_5 + s_2770_4);
        // D s_2770_7: bit-extract s_2770_2 s_2770_0 s_2770_6
        let s_2770_7: Bits = (Bits::new(
            ((s_2770_2) >> (s_2770_0)).value(),
            u16::try_from(s_2770_6).unwrap(),
        ));
        // D s_2770_8: cast reint s_2770_7 -> u8
        let s_2770_8: u8 = (s_2770_7.value() as u8);
        // D s_2770_9: cast zx s_2770_8 -> bv
        let s_2770_9: Bits = Bits::new(s_2770_8 as u128, 2u16);
        // C s_2770_10: const #2u : u8
        let s_2770_10: u8 = 2;
        // C s_2770_11: cast zx s_2770_10 -> bv
        let s_2770_11: Bits = Bits::new(s_2770_10 as u128, 2u16);
        // D s_2770_12: cmp-eq s_2770_9 s_2770_11
        let s_2770_12: bool = ((s_2770_9) == (s_2770_11));
        // N s_2770_13: branch s_2770_12 b2773 b2771
        if s_2770_12 {
            return block_2773(state, tracer, fn_state);
        } else {
            return block_2771(state, tracer, fn_state);
        };
    }
    fn block_2771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2771_0: const #0u : u8
        let s_2771_0: bool = false;
        // D s_2771_1: write-var gs#399343 <= s_2771_0
        fn_state.gs_399343 = s_2771_0;
        // N s_2771_2: jump b2772
        return block_2772(state, tracer, fn_state);
    }
    fn block_2772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2772_0: read-var gs#399343:u8
        let s_2772_0: bool = fn_state.gs_399343;
        // D s_2772_1: write-var gs#399344 <= s_2772_0
        fn_state.gs_399344 = s_2772_0;
        // N s_2772_2: jump b579
        return block_579(state, tracer, fn_state);
    }
    fn block_2773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2773_0: const #8s : i
        let s_2773_0: i128 = 8;
        // D s_2773_1: read-var u#31021:u32
        let s_2773_1: u32 = fn_state.u_31021;
        // D s_2773_2: cast zx s_2773_1 -> bv
        let s_2773_2: Bits = Bits::new(s_2773_1 as u128, 32u16);
        // C s_2773_3: const #1s : i64
        let s_2773_3: i64 = 1;
        // C s_2773_4: cast zx s_2773_3 -> i
        let s_2773_4: i128 = (i128::try_from(s_2773_3).unwrap());
        // C s_2773_5: const #3s : i
        let s_2773_5: i128 = 3;
        // C s_2773_6: add s_2773_5 s_2773_4
        let s_2773_6: i128 = (s_2773_5 + s_2773_4);
        // D s_2773_7: bit-extract s_2773_2 s_2773_0 s_2773_6
        let s_2773_7: Bits = (Bits::new(
            ((s_2773_2) >> (s_2773_0)).value(),
            u16::try_from(s_2773_6).unwrap(),
        ));
        // D s_2773_8: cast reint s_2773_7 -> u8
        let s_2773_8: u8 = (s_2773_7.value() as u8);
        // D s_2773_9: cast zx s_2773_8 -> bv
        let s_2773_9: Bits = Bits::new(s_2773_8 as u128, 4u16);
        // C s_2773_10: const #9u : u8
        let s_2773_10: u8 = 9;
        // C s_2773_11: cast zx s_2773_10 -> bv
        let s_2773_11: Bits = Bits::new(s_2773_10 as u128, 4u16);
        // D s_2773_12: cmp-eq s_2773_9 s_2773_11
        let s_2773_12: bool = ((s_2773_9) == (s_2773_11));
        // D s_2773_13: write-var gs#399343 <= s_2773_12
        fn_state.gs_399343 = s_2773_12;
        // N s_2773_14: jump b2772
        return block_2772(state, tracer, fn_state);
    }
    fn block_2774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2774_0: const #3467s : i
        let s_2774_0: i128 = 3467;
        // C s_2774_1: const #14696u : u32
        let s_2774_1: u32 = 14696;
        // D s_2774_2: read-reg s_2774_1:i
        let s_2774_2: i128 = {
            let value = state.read_register::<i128>(s_2774_1 as isize);
            tracer.read_register(s_2774_1 as isize, value);
            value
        };
        // D s_2774_3: cmp-lt s_2774_2 s_2774_0
        let s_2774_3: bool = ((s_2774_2) < (s_2774_0));
        // D s_2774_4: write-var gs#399321 <= s_2774_3
        fn_state.gs_399321 = s_2774_3;
        // N s_2774_5: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_2775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2775_0: const #20s : i
        let s_2775_0: i128 = 20;
        // D s_2775_1: read-var u#31013:u32
        let s_2775_1: u32 = fn_state.u_31013;
        // D s_2775_2: cast zx s_2775_1 -> bv
        let s_2775_2: Bits = Bits::new(s_2775_1 as u128, 32u16);
        // C s_2775_3: const #1s : i64
        let s_2775_3: i64 = 1;
        // C s_2775_4: cast zx s_2775_3 -> i
        let s_2775_4: i128 = (i128::try_from(s_2775_3).unwrap());
        // C s_2775_5: const #1s : i
        let s_2775_5: i128 = 1;
        // C s_2775_6: add s_2775_5 s_2775_4
        let s_2775_6: i128 = (s_2775_5 + s_2775_4);
        // D s_2775_7: bit-extract s_2775_2 s_2775_0 s_2775_6
        let s_2775_7: Bits = (Bits::new(
            ((s_2775_2) >> (s_2775_0)).value(),
            u16::try_from(s_2775_6).unwrap(),
        ));
        // D s_2775_8: cast reint s_2775_7 -> u8
        let s_2775_8: u8 = (s_2775_7.value() as u8);
        // D s_2775_9: cast zx s_2775_8 -> bv
        let s_2775_9: Bits = Bits::new(s_2775_8 as u128, 2u16);
        // C s_2775_10: const #2u : u8
        let s_2775_10: u8 = 2;
        // C s_2775_11: cast zx s_2775_10 -> bv
        let s_2775_11: Bits = Bits::new(s_2775_10 as u128, 2u16);
        // D s_2775_12: cmp-eq s_2775_9 s_2775_11
        let s_2775_12: bool = ((s_2775_9) == (s_2775_11));
        // N s_2775_13: branch s_2775_12 b2778 b2776
        if s_2775_12 {
            return block_2778(state, tracer, fn_state);
        } else {
            return block_2776(state, tracer, fn_state);
        };
    }
    fn block_2776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2776_0: const #0u : u8
        let s_2776_0: bool = false;
        // D s_2776_1: write-var gs#399318 <= s_2776_0
        fn_state.gs_399318 = s_2776_0;
        // N s_2776_2: jump b2777
        return block_2777(state, tracer, fn_state);
    }
    fn block_2777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2777_0: read-var gs#399318:u8
        let s_2777_0: bool = fn_state.gs_399318;
        // D s_2777_1: write-var gs#399319 <= s_2777_0
        fn_state.gs_399319 = s_2777_0;
        // N s_2777_2: jump b573
        return block_573(state, tracer, fn_state);
    }
    fn block_2778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2778_0: const #8s : i
        let s_2778_0: i128 = 8;
        // D s_2778_1: read-var u#31013:u32
        let s_2778_1: u32 = fn_state.u_31013;
        // D s_2778_2: cast zx s_2778_1 -> bv
        let s_2778_2: Bits = Bits::new(s_2778_1 as u128, 32u16);
        // C s_2778_3: const #1s : i64
        let s_2778_3: i64 = 1;
        // C s_2778_4: cast zx s_2778_3 -> i
        let s_2778_4: i128 = (i128::try_from(s_2778_3).unwrap());
        // C s_2778_5: const #3s : i
        let s_2778_5: i128 = 3;
        // C s_2778_6: add s_2778_5 s_2778_4
        let s_2778_6: i128 = (s_2778_5 + s_2778_4);
        // D s_2778_7: bit-extract s_2778_2 s_2778_0 s_2778_6
        let s_2778_7: Bits = (Bits::new(
            ((s_2778_2) >> (s_2778_0)).value(),
            u16::try_from(s_2778_6).unwrap(),
        ));
        // D s_2778_8: cast reint s_2778_7 -> u8
        let s_2778_8: u8 = (s_2778_7.value() as u8);
        // D s_2778_9: cast zx s_2778_8 -> bv
        let s_2778_9: Bits = Bits::new(s_2778_8 as u128, 4u16);
        // C s_2778_10: const #5u : u8
        let s_2778_10: u8 = 5;
        // C s_2778_11: cast zx s_2778_10 -> bv
        let s_2778_11: Bits = Bits::new(s_2778_10 as u128, 4u16);
        // D s_2778_12: cmp-eq s_2778_9 s_2778_11
        let s_2778_12: bool = ((s_2778_9) == (s_2778_11));
        // D s_2778_13: write-var gs#399318 <= s_2778_12
        fn_state.gs_399318 = s_2778_12;
        // N s_2778_14: jump b2777
        return block_2777(state, tracer, fn_state);
    }
    fn block_2779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2779_0: const #3466s : i
        let s_2779_0: i128 = 3466;
        // C s_2779_1: const #14696u : u32
        let s_2779_1: u32 = 14696;
        // D s_2779_2: read-reg s_2779_1:i
        let s_2779_2: i128 = {
            let value = state.read_register::<i128>(s_2779_1 as isize);
            tracer.read_register(s_2779_1 as isize, value);
            value
        };
        // D s_2779_3: cmp-lt s_2779_2 s_2779_0
        let s_2779_3: bool = ((s_2779_2) < (s_2779_0));
        // D s_2779_4: write-var gs#399296 <= s_2779_3
        fn_state.gs_399296 = s_2779_3;
        // N s_2779_5: jump b569
        return block_569(state, tracer, fn_state);
    }
    fn block_2780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2780_0: const #20s : i
        let s_2780_0: i128 = 20;
        // D s_2780_1: read-var u#31005:u32
        let s_2780_1: u32 = fn_state.u_31005;
        // D s_2780_2: cast zx s_2780_1 -> bv
        let s_2780_2: Bits = Bits::new(s_2780_1 as u128, 32u16);
        // C s_2780_3: const #1s : i64
        let s_2780_3: i64 = 1;
        // C s_2780_4: cast zx s_2780_3 -> i
        let s_2780_4: i128 = (i128::try_from(s_2780_3).unwrap());
        // C s_2780_5: const #1s : i
        let s_2780_5: i128 = 1;
        // C s_2780_6: add s_2780_5 s_2780_4
        let s_2780_6: i128 = (s_2780_5 + s_2780_4);
        // D s_2780_7: bit-extract s_2780_2 s_2780_0 s_2780_6
        let s_2780_7: Bits = (Bits::new(
            ((s_2780_2) >> (s_2780_0)).value(),
            u16::try_from(s_2780_6).unwrap(),
        ));
        // D s_2780_8: cast reint s_2780_7 -> u8
        let s_2780_8: u8 = (s_2780_7.value() as u8);
        // D s_2780_9: cast zx s_2780_8 -> bv
        let s_2780_9: Bits = Bits::new(s_2780_8 as u128, 2u16);
        // C s_2780_10: const #2u : u8
        let s_2780_10: u8 = 2;
        // C s_2780_11: cast zx s_2780_10 -> bv
        let s_2780_11: Bits = Bits::new(s_2780_10 as u128, 2u16);
        // D s_2780_12: cmp-eq s_2780_9 s_2780_11
        let s_2780_12: bool = ((s_2780_9) == (s_2780_11));
        // N s_2780_13: branch s_2780_12 b2783 b2781
        if s_2780_12 {
            return block_2783(state, tracer, fn_state);
        } else {
            return block_2781(state, tracer, fn_state);
        };
    }
    fn block_2781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2781_0: const #0u : u8
        let s_2781_0: bool = false;
        // D s_2781_1: write-var gs#399293 <= s_2781_0
        fn_state.gs_399293 = s_2781_0;
        // N s_2781_2: jump b2782
        return block_2782(state, tracer, fn_state);
    }
    fn block_2782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2782_0: read-var gs#399293:u8
        let s_2782_0: bool = fn_state.gs_399293;
        // D s_2782_1: write-var gs#399294 <= s_2782_0
        fn_state.gs_399294 = s_2782_0;
        // N s_2782_2: jump b567
        return block_567(state, tracer, fn_state);
    }
    fn block_2783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2783_0: const #8s : i
        let s_2783_0: i128 = 8;
        // D s_2783_1: read-var u#31005:u32
        let s_2783_1: u32 = fn_state.u_31005;
        // D s_2783_2: cast zx s_2783_1 -> bv
        let s_2783_2: Bits = Bits::new(s_2783_1 as u128, 32u16);
        // C s_2783_3: const #1s : i64
        let s_2783_3: i64 = 1;
        // C s_2783_4: cast zx s_2783_3 -> i
        let s_2783_4: i128 = (i128::try_from(s_2783_3).unwrap());
        // C s_2783_5: const #3s : i
        let s_2783_5: i128 = 3;
        // C s_2783_6: add s_2783_5 s_2783_4
        let s_2783_6: i128 = (s_2783_5 + s_2783_4);
        // D s_2783_7: bit-extract s_2783_2 s_2783_0 s_2783_6
        let s_2783_7: Bits = (Bits::new(
            ((s_2783_2) >> (s_2783_0)).value(),
            u16::try_from(s_2783_6).unwrap(),
        ));
        // D s_2783_8: cast reint s_2783_7 -> u8
        let s_2783_8: u8 = (s_2783_7.value() as u8);
        // D s_2783_9: cast zx s_2783_8 -> bv
        let s_2783_9: Bits = Bits::new(s_2783_8 as u128, 4u16);
        // C s_2783_10: const #1u : u8
        let s_2783_10: u8 = 1;
        // C s_2783_11: cast zx s_2783_10 -> bv
        let s_2783_11: Bits = Bits::new(s_2783_10 as u128, 4u16);
        // D s_2783_12: cmp-eq s_2783_9 s_2783_11
        let s_2783_12: bool = ((s_2783_9) == (s_2783_11));
        // D s_2783_13: write-var gs#399293 <= s_2783_12
        fn_state.gs_399293 = s_2783_12;
        // N s_2783_14: jump b2782
        return block_2782(state, tracer, fn_state);
    }
    fn block_2784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2784_0: const #3461s : i
        let s_2784_0: i128 = 3461;
        // C s_2784_1: const #14696u : u32
        let s_2784_1: u32 = 14696;
        // D s_2784_2: read-reg s_2784_1:i
        let s_2784_2: i128 = {
            let value = state.read_register::<i128>(s_2784_1 as isize);
            tracer.read_register(s_2784_1 as isize, value);
            value
        };
        // D s_2784_3: cmp-lt s_2784_2 s_2784_0
        let s_2784_3: bool = ((s_2784_2) < (s_2784_0));
        // D s_2784_4: write-var gs#399269 <= s_2784_3
        fn_state.gs_399269 = s_2784_3;
        // N s_2784_5: jump b563
        return block_563(state, tracer, fn_state);
    }
    fn block_2785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2785_0: const #20s : i
        let s_2785_0: i128 = 20;
        // D s_2785_1: read-var u#30996:u32
        let s_2785_1: u32 = fn_state.u_30996;
        // D s_2785_2: cast zx s_2785_1 -> bv
        let s_2785_2: Bits = Bits::new(s_2785_1 as u128, 32u16);
        // C s_2785_3: const #1s : i64
        let s_2785_3: i64 = 1;
        // C s_2785_4: cast zx s_2785_3 -> i
        let s_2785_4: i128 = (i128::try_from(s_2785_3).unwrap());
        // C s_2785_5: const #1s : i
        let s_2785_5: i128 = 1;
        // C s_2785_6: add s_2785_5 s_2785_4
        let s_2785_6: i128 = (s_2785_5 + s_2785_4);
        // D s_2785_7: bit-extract s_2785_2 s_2785_0 s_2785_6
        let s_2785_7: Bits = (Bits::new(
            ((s_2785_2) >> (s_2785_0)).value(),
            u16::try_from(s_2785_6).unwrap(),
        ));
        // D s_2785_8: cast reint s_2785_7 -> u8
        let s_2785_8: u8 = (s_2785_7.value() as u8);
        // D s_2785_9: cast zx s_2785_8 -> bv
        let s_2785_9: Bits = Bits::new(s_2785_8 as u128, 2u16);
        // C s_2785_10: const #2u : u8
        let s_2785_10: u8 = 2;
        // C s_2785_11: cast zx s_2785_10 -> bv
        let s_2785_11: Bits = Bits::new(s_2785_10 as u128, 2u16);
        // D s_2785_12: cmp-eq s_2785_9 s_2785_11
        let s_2785_12: bool = ((s_2785_9) == (s_2785_11));
        // N s_2785_13: branch s_2785_12 b2788 b2786
        if s_2785_12 {
            return block_2788(state, tracer, fn_state);
        } else {
            return block_2786(state, tracer, fn_state);
        };
    }
    fn block_2786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2786_0: const #0u : u8
        let s_2786_0: bool = false;
        // D s_2786_1: write-var gs#399266 <= s_2786_0
        fn_state.gs_399266 = s_2786_0;
        // N s_2786_2: jump b2787
        return block_2787(state, tracer, fn_state);
    }
    fn block_2787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2787_0: read-var gs#399266:u8
        let s_2787_0: bool = fn_state.gs_399266;
        // D s_2787_1: write-var gs#399267 <= s_2787_0
        fn_state.gs_399267 = s_2787_0;
        // N s_2787_2: jump b561
        return block_561(state, tracer, fn_state);
    }
    fn block_2788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2788_0: const #8s : i
        let s_2788_0: i128 = 8;
        // D s_2788_1: read-var u#30996:u32
        let s_2788_1: u32 = fn_state.u_30996;
        // D s_2788_2: cast zx s_2788_1 -> bv
        let s_2788_2: Bits = Bits::new(s_2788_1 as u128, 32u16);
        // C s_2788_3: const #1s : i64
        let s_2788_3: i64 = 1;
        // C s_2788_4: cast zx s_2788_3 -> i
        let s_2788_4: i128 = (i128::try_from(s_2788_3).unwrap());
        // C s_2788_5: const #3s : i
        let s_2788_5: i128 = 3;
        // C s_2788_6: add s_2788_5 s_2788_4
        let s_2788_6: i128 = (s_2788_5 + s_2788_4);
        // D s_2788_7: bit-extract s_2788_2 s_2788_0 s_2788_6
        let s_2788_7: Bits = (Bits::new(
            ((s_2788_2) >> (s_2788_0)).value(),
            u16::try_from(s_2788_6).unwrap(),
        ));
        // D s_2788_8: cast reint s_2788_7 -> u8
        let s_2788_8: u8 = (s_2788_7.value() as u8);
        // D s_2788_9: cast zx s_2788_8 -> bv
        let s_2788_9: Bits = Bits::new(s_2788_8 as u128, 4u16);
        // C s_2788_10: const #2u : u8
        let s_2788_10: u8 = 2;
        // C s_2788_11: cast zx s_2788_10 -> bv
        let s_2788_11: Bits = Bits::new(s_2788_10 as u128, 4u16);
        // D s_2788_12: cmp-eq s_2788_9 s_2788_11
        let s_2788_12: bool = ((s_2788_9) == (s_2788_11));
        // D s_2788_13: write-var gs#399266 <= s_2788_12
        fn_state.gs_399266 = s_2788_12;
        // N s_2788_14: jump b2787
        return block_2787(state, tracer, fn_state);
    }
    fn block_2789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2789_0: const #3460s : i
        let s_2789_0: i128 = 3460;
        // C s_2789_1: const #14696u : u32
        let s_2789_1: u32 = 14696;
        // D s_2789_2: read-reg s_2789_1:i
        let s_2789_2: i128 = {
            let value = state.read_register::<i128>(s_2789_1 as isize);
            tracer.read_register(s_2789_1 as isize, value);
            value
        };
        // D s_2789_3: cmp-lt s_2789_2 s_2789_0
        let s_2789_3: bool = ((s_2789_2) < (s_2789_0));
        // D s_2789_4: write-var gs#399242 <= s_2789_3
        fn_state.gs_399242 = s_2789_3;
        // N s_2789_5: jump b557
        return block_557(state, tracer, fn_state);
    }
    fn block_2790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2790_0: const #20s : i
        let s_2790_0: i128 = 20;
        // D s_2790_1: read-var u#30987:u32
        let s_2790_1: u32 = fn_state.u_30987;
        // D s_2790_2: cast zx s_2790_1 -> bv
        let s_2790_2: Bits = Bits::new(s_2790_1 as u128, 32u16);
        // C s_2790_3: const #1s : i64
        let s_2790_3: i64 = 1;
        // C s_2790_4: cast zx s_2790_3 -> i
        let s_2790_4: i128 = (i128::try_from(s_2790_3).unwrap());
        // C s_2790_5: const #1s : i
        let s_2790_5: i128 = 1;
        // C s_2790_6: add s_2790_5 s_2790_4
        let s_2790_6: i128 = (s_2790_5 + s_2790_4);
        // D s_2790_7: bit-extract s_2790_2 s_2790_0 s_2790_6
        let s_2790_7: Bits = (Bits::new(
            ((s_2790_2) >> (s_2790_0)).value(),
            u16::try_from(s_2790_6).unwrap(),
        ));
        // D s_2790_8: cast reint s_2790_7 -> u8
        let s_2790_8: u8 = (s_2790_7.value() as u8);
        // D s_2790_9: cast zx s_2790_8 -> bv
        let s_2790_9: Bits = Bits::new(s_2790_8 as u128, 2u16);
        // C s_2790_10: const #2u : u8
        let s_2790_10: u8 = 2;
        // C s_2790_11: cast zx s_2790_10 -> bv
        let s_2790_11: Bits = Bits::new(s_2790_10 as u128, 2u16);
        // D s_2790_12: cmp-eq s_2790_9 s_2790_11
        let s_2790_12: bool = ((s_2790_9) == (s_2790_11));
        // N s_2790_13: branch s_2790_12 b2793 b2791
        if s_2790_12 {
            return block_2793(state, tracer, fn_state);
        } else {
            return block_2791(state, tracer, fn_state);
        };
    }
    fn block_2791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2791_0: const #0u : u8
        let s_2791_0: bool = false;
        // D s_2791_1: write-var gs#399239 <= s_2791_0
        fn_state.gs_399239 = s_2791_0;
        // N s_2791_2: jump b2792
        return block_2792(state, tracer, fn_state);
    }
    fn block_2792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2792_0: read-var gs#399239:u8
        let s_2792_0: bool = fn_state.gs_399239;
        // D s_2792_1: write-var gs#399240 <= s_2792_0
        fn_state.gs_399240 = s_2792_0;
        // N s_2792_2: jump b555
        return block_555(state, tracer, fn_state);
    }
    fn block_2793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2793_0: const #8s : i
        let s_2793_0: i128 = 8;
        // D s_2793_1: read-var u#30987:u32
        let s_2793_1: u32 = fn_state.u_30987;
        // D s_2793_2: cast zx s_2793_1 -> bv
        let s_2793_2: Bits = Bits::new(s_2793_1 as u128, 32u16);
        // C s_2793_3: const #1s : i64
        let s_2793_3: i64 = 1;
        // C s_2793_4: cast zx s_2793_3 -> i
        let s_2793_4: i128 = (i128::try_from(s_2793_3).unwrap());
        // C s_2793_5: const #3s : i
        let s_2793_5: i128 = 3;
        // C s_2793_6: add s_2793_5 s_2793_4
        let s_2793_6: i128 = (s_2793_5 + s_2793_4);
        // D s_2793_7: bit-extract s_2793_2 s_2793_0 s_2793_6
        let s_2793_7: Bits = (Bits::new(
            ((s_2793_2) >> (s_2793_0)).value(),
            u16::try_from(s_2793_6).unwrap(),
        ));
        // D s_2793_8: cast reint s_2793_7 -> u8
        let s_2793_8: u8 = (s_2793_7.value() as u8);
        // D s_2793_9: cast zx s_2793_8 -> bv
        let s_2793_9: Bits = Bits::new(s_2793_8 as u128, 4u16);
        // C s_2793_10: const #6u : u8
        let s_2793_10: u8 = 6;
        // C s_2793_11: cast zx s_2793_10 -> bv
        let s_2793_11: Bits = Bits::new(s_2793_10 as u128, 4u16);
        // D s_2793_12: cmp-eq s_2793_9 s_2793_11
        let s_2793_12: bool = ((s_2793_9) == (s_2793_11));
        // D s_2793_13: write-var gs#399239 <= s_2793_12
        fn_state.gs_399239 = s_2793_12;
        // N s_2793_14: jump b2792
        return block_2792(state, tracer, fn_state);
    }
    fn block_2794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2794_0: const #3459s : i
        let s_2794_0: i128 = 3459;
        // C s_2794_1: const #14696u : u32
        let s_2794_1: u32 = 14696;
        // D s_2794_2: read-reg s_2794_1:i
        let s_2794_2: i128 = {
            let value = state.read_register::<i128>(s_2794_1 as isize);
            tracer.read_register(s_2794_1 as isize, value);
            value
        };
        // D s_2794_3: cmp-lt s_2794_2 s_2794_0
        let s_2794_3: bool = ((s_2794_2) < (s_2794_0));
        // D s_2794_4: write-var gs#399215 <= s_2794_3
        fn_state.gs_399215 = s_2794_3;
        // N s_2794_5: jump b551
        return block_551(state, tracer, fn_state);
    }
    fn block_2795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2795_0: const #20s : i
        let s_2795_0: i128 = 20;
        // D s_2795_1: read-var u#30978:u32
        let s_2795_1: u32 = fn_state.u_30978;
        // D s_2795_2: cast zx s_2795_1 -> bv
        let s_2795_2: Bits = Bits::new(s_2795_1 as u128, 32u16);
        // C s_2795_3: const #1s : i64
        let s_2795_3: i64 = 1;
        // C s_2795_4: cast zx s_2795_3 -> i
        let s_2795_4: i128 = (i128::try_from(s_2795_3).unwrap());
        // C s_2795_5: const #1s : i
        let s_2795_5: i128 = 1;
        // C s_2795_6: add s_2795_5 s_2795_4
        let s_2795_6: i128 = (s_2795_5 + s_2795_4);
        // D s_2795_7: bit-extract s_2795_2 s_2795_0 s_2795_6
        let s_2795_7: Bits = (Bits::new(
            ((s_2795_2) >> (s_2795_0)).value(),
            u16::try_from(s_2795_6).unwrap(),
        ));
        // D s_2795_8: cast reint s_2795_7 -> u8
        let s_2795_8: u8 = (s_2795_7.value() as u8);
        // D s_2795_9: cast zx s_2795_8 -> bv
        let s_2795_9: Bits = Bits::new(s_2795_8 as u128, 2u16);
        // C s_2795_10: const #2u : u8
        let s_2795_10: u8 = 2;
        // C s_2795_11: cast zx s_2795_10 -> bv
        let s_2795_11: Bits = Bits::new(s_2795_10 as u128, 2u16);
        // D s_2795_12: cmp-eq s_2795_9 s_2795_11
        let s_2795_12: bool = ((s_2795_9) == (s_2795_11));
        // N s_2795_13: branch s_2795_12 b2798 b2796
        if s_2795_12 {
            return block_2798(state, tracer, fn_state);
        } else {
            return block_2796(state, tracer, fn_state);
        };
    }
    fn block_2796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2796_0: const #0u : u8
        let s_2796_0: bool = false;
        // D s_2796_1: write-var gs#399212 <= s_2796_0
        fn_state.gs_399212 = s_2796_0;
        // N s_2796_2: jump b2797
        return block_2797(state, tracer, fn_state);
    }
    fn block_2797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2797_0: read-var gs#399212:u8
        let s_2797_0: bool = fn_state.gs_399212;
        // D s_2797_1: write-var gs#399213 <= s_2797_0
        fn_state.gs_399213 = s_2797_0;
        // N s_2797_2: jump b549
        return block_549(state, tracer, fn_state);
    }
    fn block_2798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2798_0: const #8s : i
        let s_2798_0: i128 = 8;
        // D s_2798_1: read-var u#30978:u32
        let s_2798_1: u32 = fn_state.u_30978;
        // D s_2798_2: cast zx s_2798_1 -> bv
        let s_2798_2: Bits = Bits::new(s_2798_1 as u128, 32u16);
        // C s_2798_3: const #1s : i64
        let s_2798_3: i64 = 1;
        // C s_2798_4: cast zx s_2798_3 -> i
        let s_2798_4: i128 = (i128::try_from(s_2798_3).unwrap());
        // C s_2798_5: const #3s : i
        let s_2798_5: i128 = 3;
        // C s_2798_6: add s_2798_5 s_2798_4
        let s_2798_6: i128 = (s_2798_5 + s_2798_4);
        // D s_2798_7: bit-extract s_2798_2 s_2798_0 s_2798_6
        let s_2798_7: Bits = (Bits::new(
            ((s_2798_2) >> (s_2798_0)).value(),
            u16::try_from(s_2798_6).unwrap(),
        ));
        // D s_2798_8: cast reint s_2798_7 -> u8
        let s_2798_8: u8 = (s_2798_7.value() as u8);
        // D s_2798_9: cast zx s_2798_8 -> bv
        let s_2798_9: Bits = Bits::new(s_2798_8 as u128, 4u16);
        // C s_2798_10: const #10u : u8
        let s_2798_10: u8 = 10;
        // C s_2798_11: cast zx s_2798_10 -> bv
        let s_2798_11: Bits = Bits::new(s_2798_10 as u128, 4u16);
        // D s_2798_12: cmp-eq s_2798_9 s_2798_11
        let s_2798_12: bool = ((s_2798_9) == (s_2798_11));
        // D s_2798_13: write-var gs#399212 <= s_2798_12
        fn_state.gs_399212 = s_2798_12;
        // N s_2798_14: jump b2797
        return block_2797(state, tracer, fn_state);
    }
    fn block_2799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2799_0: const #3458s : i
        let s_2799_0: i128 = 3458;
        // C s_2799_1: const #14696u : u32
        let s_2799_1: u32 = 14696;
        // D s_2799_2: read-reg s_2799_1:i
        let s_2799_2: i128 = {
            let value = state.read_register::<i128>(s_2799_1 as isize);
            tracer.read_register(s_2799_1 as isize, value);
            value
        };
        // D s_2799_3: cmp-lt s_2799_2 s_2799_0
        let s_2799_3: bool = ((s_2799_2) < (s_2799_0));
        // D s_2799_4: write-var gs#399188 <= s_2799_3
        fn_state.gs_399188 = s_2799_3;
        // N s_2799_5: jump b545
        return block_545(state, tracer, fn_state);
    }
    fn block_2800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2800_0: const #20s : i
        let s_2800_0: i128 = 20;
        // D s_2800_1: read-var u#30971:u32
        let s_2800_1: u32 = fn_state.u_30971;
        // D s_2800_2: cast zx s_2800_1 -> bv
        let s_2800_2: Bits = Bits::new(s_2800_1 as u128, 32u16);
        // C s_2800_3: const #1s : i64
        let s_2800_3: i64 = 1;
        // C s_2800_4: cast zx s_2800_3 -> i
        let s_2800_4: i128 = (i128::try_from(s_2800_3).unwrap());
        // C s_2800_5: const #1s : i
        let s_2800_5: i128 = 1;
        // C s_2800_6: add s_2800_5 s_2800_4
        let s_2800_6: i128 = (s_2800_5 + s_2800_4);
        // D s_2800_7: bit-extract s_2800_2 s_2800_0 s_2800_6
        let s_2800_7: Bits = (Bits::new(
            ((s_2800_2) >> (s_2800_0)).value(),
            u16::try_from(s_2800_6).unwrap(),
        ));
        // D s_2800_8: cast reint s_2800_7 -> u8
        let s_2800_8: u8 = (s_2800_7.value() as u8);
        // D s_2800_9: cast zx s_2800_8 -> bv
        let s_2800_9: Bits = Bits::new(s_2800_8 as u128, 2u16);
        // C s_2800_10: const #2u : u8
        let s_2800_10: u8 = 2;
        // C s_2800_11: cast zx s_2800_10 -> bv
        let s_2800_11: Bits = Bits::new(s_2800_10 as u128, 2u16);
        // D s_2800_12: cmp-eq s_2800_9 s_2800_11
        let s_2800_12: bool = ((s_2800_9) == (s_2800_11));
        // N s_2800_13: branch s_2800_12 b2803 b2801
        if s_2800_12 {
            return block_2803(state, tracer, fn_state);
        } else {
            return block_2801(state, tracer, fn_state);
        };
    }
    fn block_2801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2801_0: const #0u : u8
        let s_2801_0: bool = false;
        // D s_2801_1: write-var gs#399185 <= s_2801_0
        fn_state.gs_399185 = s_2801_0;
        // N s_2801_2: jump b2802
        return block_2802(state, tracer, fn_state);
    }
    fn block_2802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2802_0: read-var gs#399185:u8
        let s_2802_0: bool = fn_state.gs_399185;
        // D s_2802_1: write-var gs#399186 <= s_2802_0
        fn_state.gs_399186 = s_2802_0;
        // N s_2802_2: jump b543
        return block_543(state, tracer, fn_state);
    }
    fn block_2803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2803_0: const #8s : i
        let s_2803_0: i128 = 8;
        // D s_2803_1: read-var u#30971:u32
        let s_2803_1: u32 = fn_state.u_30971;
        // D s_2803_2: cast zx s_2803_1 -> bv
        let s_2803_2: Bits = Bits::new(s_2803_1 as u128, 32u16);
        // C s_2803_3: const #1s : i64
        let s_2803_3: i64 = 1;
        // C s_2803_4: cast zx s_2803_3 -> i
        let s_2803_4: i128 = (i128::try_from(s_2803_3).unwrap());
        // C s_2803_5: const #3s : i
        let s_2803_5: i128 = 3;
        // C s_2803_6: add s_2803_5 s_2803_4
        let s_2803_6: i128 = (s_2803_5 + s_2803_4);
        // D s_2803_7: bit-extract s_2803_2 s_2803_0 s_2803_6
        let s_2803_7: Bits = (Bits::new(
            ((s_2803_2) >> (s_2803_0)).value(),
            u16::try_from(s_2803_6).unwrap(),
        ));
        // D s_2803_8: cast reint s_2803_7 -> u8
        let s_2803_8: u8 = (s_2803_7.value() as u8);
        // D s_2803_9: cast zx s_2803_8 -> bv
        let s_2803_9: Bits = Bits::new(s_2803_8 as u128, 4u16);
        // C s_2803_10: const #7u : u8
        let s_2803_10: u8 = 7;
        // C s_2803_11: cast zx s_2803_10 -> bv
        let s_2803_11: Bits = Bits::new(s_2803_10 as u128, 4u16);
        // D s_2803_12: cmp-eq s_2803_9 s_2803_11
        let s_2803_12: bool = ((s_2803_9) == (s_2803_11));
        // D s_2803_13: write-var gs#399185 <= s_2803_12
        fn_state.gs_399185 = s_2803_12;
        // N s_2803_14: jump b2802
        return block_2802(state, tracer, fn_state);
    }
    fn block_2804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2804_0: const #3456s : i
        let s_2804_0: i128 = 3456;
        // C s_2804_1: const #14696u : u32
        let s_2804_1: u32 = 14696;
        // D s_2804_2: read-reg s_2804_1:i
        let s_2804_2: i128 = {
            let value = state.read_register::<i128>(s_2804_1 as isize);
            tracer.read_register(s_2804_1 as isize, value);
            value
        };
        // D s_2804_3: cmp-lt s_2804_2 s_2804_0
        let s_2804_3: bool = ((s_2804_2) < (s_2804_0));
        // D s_2804_4: write-var gs#399161 <= s_2804_3
        fn_state.gs_399161 = s_2804_3;
        // N s_2804_5: jump b539
        return block_539(state, tracer, fn_state);
    }
    fn block_2805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2805_0: const #20s : i
        let s_2805_0: i128 = 20;
        // D s_2805_1: read-var u#30964:u32
        let s_2805_1: u32 = fn_state.u_30964;
        // D s_2805_2: cast zx s_2805_1 -> bv
        let s_2805_2: Bits = Bits::new(s_2805_1 as u128, 32u16);
        // C s_2805_3: const #1s : i64
        let s_2805_3: i64 = 1;
        // C s_2805_4: cast zx s_2805_3 -> i
        let s_2805_4: i128 = (i128::try_from(s_2805_3).unwrap());
        // C s_2805_5: const #1s : i
        let s_2805_5: i128 = 1;
        // C s_2805_6: add s_2805_5 s_2805_4
        let s_2805_6: i128 = (s_2805_5 + s_2805_4);
        // D s_2805_7: bit-extract s_2805_2 s_2805_0 s_2805_6
        let s_2805_7: Bits = (Bits::new(
            ((s_2805_2) >> (s_2805_0)).value(),
            u16::try_from(s_2805_6).unwrap(),
        ));
        // D s_2805_8: cast reint s_2805_7 -> u8
        let s_2805_8: u8 = (s_2805_7.value() as u8);
        // D s_2805_9: cast zx s_2805_8 -> bv
        let s_2805_9: Bits = Bits::new(s_2805_8 as u128, 2u16);
        // C s_2805_10: const #2u : u8
        let s_2805_10: u8 = 2;
        // C s_2805_11: cast zx s_2805_10 -> bv
        let s_2805_11: Bits = Bits::new(s_2805_10 as u128, 2u16);
        // D s_2805_12: cmp-eq s_2805_9 s_2805_11
        let s_2805_12: bool = ((s_2805_9) == (s_2805_11));
        // N s_2805_13: branch s_2805_12 b2808 b2806
        if s_2805_12 {
            return block_2808(state, tracer, fn_state);
        } else {
            return block_2806(state, tracer, fn_state);
        };
    }
    fn block_2806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2806_0: const #0u : u8
        let s_2806_0: bool = false;
        // D s_2806_1: write-var gs#399158 <= s_2806_0
        fn_state.gs_399158 = s_2806_0;
        // N s_2806_2: jump b2807
        return block_2807(state, tracer, fn_state);
    }
    fn block_2807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2807_0: read-var gs#399158:u8
        let s_2807_0: bool = fn_state.gs_399158;
        // D s_2807_1: write-var gs#399159 <= s_2807_0
        fn_state.gs_399159 = s_2807_0;
        // N s_2807_2: jump b537
        return block_537(state, tracer, fn_state);
    }
    fn block_2808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2808_0: const #8s : i
        let s_2808_0: i128 = 8;
        // D s_2808_1: read-var u#30964:u32
        let s_2808_1: u32 = fn_state.u_30964;
        // D s_2808_2: cast zx s_2808_1 -> bv
        let s_2808_2: Bits = Bits::new(s_2808_1 as u128, 32u16);
        // C s_2808_3: const #1s : i64
        let s_2808_3: i64 = 1;
        // C s_2808_4: cast zx s_2808_3 -> i
        let s_2808_4: i128 = (i128::try_from(s_2808_3).unwrap());
        // C s_2808_5: const #3s : i
        let s_2808_5: i128 = 3;
        // C s_2808_6: add s_2808_5 s_2808_4
        let s_2808_6: i128 = (s_2808_5 + s_2808_4);
        // D s_2808_7: bit-extract s_2808_2 s_2808_0 s_2808_6
        let s_2808_7: Bits = (Bits::new(
            ((s_2808_2) >> (s_2808_0)).value(),
            u16::try_from(s_2808_6).unwrap(),
        ));
        // D s_2808_8: cast reint s_2808_7 -> u8
        let s_2808_8: u8 = (s_2808_7.value() as u8);
        // D s_2808_9: cast zx s_2808_8 -> bv
        let s_2808_9: Bits = Bits::new(s_2808_8 as u128, 4u16);
        // C s_2808_10: const #12u : u8
        let s_2808_10: u8 = 12;
        // C s_2808_11: cast zx s_2808_10 -> bv
        let s_2808_11: Bits = Bits::new(s_2808_10 as u128, 4u16);
        // D s_2808_12: cmp-eq s_2808_9 s_2808_11
        let s_2808_12: bool = ((s_2808_9) == (s_2808_11));
        // D s_2808_13: write-var gs#399158 <= s_2808_12
        fn_state.gs_399158 = s_2808_12;
        // N s_2808_14: jump b2807
        return block_2807(state, tracer, fn_state);
    }
    fn block_2809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2809_0: const #3452s : i
        let s_2809_0: i128 = 3452;
        // C s_2809_1: const #14696u : u32
        let s_2809_1: u32 = 14696;
        // D s_2809_2: read-reg s_2809_1:i
        let s_2809_2: i128 = {
            let value = state.read_register::<i128>(s_2809_1 as isize);
            tracer.read_register(s_2809_1 as isize, value);
            value
        };
        // D s_2809_3: cmp-lt s_2809_2 s_2809_0
        let s_2809_3: bool = ((s_2809_2) < (s_2809_0));
        // D s_2809_4: write-var gs#399136 <= s_2809_3
        fn_state.gs_399136 = s_2809_3;
        // N s_2809_5: jump b533
        return block_533(state, tracer, fn_state);
    }
    fn block_2810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2810_0: const #20s : i
        let s_2810_0: i128 = 20;
        // D s_2810_1: read-var u#30956:u32
        let s_2810_1: u32 = fn_state.u_30956;
        // D s_2810_2: cast zx s_2810_1 -> bv
        let s_2810_2: Bits = Bits::new(s_2810_1 as u128, 32u16);
        // C s_2810_3: const #1s : i64
        let s_2810_3: i64 = 1;
        // C s_2810_4: cast zx s_2810_3 -> i
        let s_2810_4: i128 = (i128::try_from(s_2810_3).unwrap());
        // C s_2810_5: const #1s : i
        let s_2810_5: i128 = 1;
        // C s_2810_6: add s_2810_5 s_2810_4
        let s_2810_6: i128 = (s_2810_5 + s_2810_4);
        // D s_2810_7: bit-extract s_2810_2 s_2810_0 s_2810_6
        let s_2810_7: Bits = (Bits::new(
            ((s_2810_2) >> (s_2810_0)).value(),
            u16::try_from(s_2810_6).unwrap(),
        ));
        // D s_2810_8: cast reint s_2810_7 -> u8
        let s_2810_8: u8 = (s_2810_7.value() as u8);
        // D s_2810_9: cast zx s_2810_8 -> bv
        let s_2810_9: Bits = Bits::new(s_2810_8 as u128, 2u16);
        // C s_2810_10: const #2u : u8
        let s_2810_10: u8 = 2;
        // C s_2810_11: cast zx s_2810_10 -> bv
        let s_2810_11: Bits = Bits::new(s_2810_10 as u128, 2u16);
        // D s_2810_12: cmp-eq s_2810_9 s_2810_11
        let s_2810_12: bool = ((s_2810_9) == (s_2810_11));
        // N s_2810_13: branch s_2810_12 b2813 b2811
        if s_2810_12 {
            return block_2813(state, tracer, fn_state);
        } else {
            return block_2811(state, tracer, fn_state);
        };
    }
    fn block_2811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2811_0: const #0u : u8
        let s_2811_0: bool = false;
        // D s_2811_1: write-var gs#399133 <= s_2811_0
        fn_state.gs_399133 = s_2811_0;
        // N s_2811_2: jump b2812
        return block_2812(state, tracer, fn_state);
    }
    fn block_2812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2812_0: read-var gs#399133:u8
        let s_2812_0: bool = fn_state.gs_399133;
        // D s_2812_1: write-var gs#399134 <= s_2812_0
        fn_state.gs_399134 = s_2812_0;
        // N s_2812_2: jump b531
        return block_531(state, tracer, fn_state);
    }
    fn block_2813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2813_0: const #8s : i
        let s_2813_0: i128 = 8;
        // D s_2813_1: read-var u#30956:u32
        let s_2813_1: u32 = fn_state.u_30956;
        // D s_2813_2: cast zx s_2813_1 -> bv
        let s_2813_2: Bits = Bits::new(s_2813_1 as u128, 32u16);
        // C s_2813_3: const #1s : i64
        let s_2813_3: i64 = 1;
        // C s_2813_4: cast zx s_2813_3 -> i
        let s_2813_4: i128 = (i128::try_from(s_2813_3).unwrap());
        // C s_2813_5: const #3s : i
        let s_2813_5: i128 = 3;
        // C s_2813_6: add s_2813_5 s_2813_4
        let s_2813_6: i128 = (s_2813_5 + s_2813_4);
        // D s_2813_7: bit-extract s_2813_2 s_2813_0 s_2813_6
        let s_2813_7: Bits = (Bits::new(
            ((s_2813_2) >> (s_2813_0)).value(),
            u16::try_from(s_2813_6).unwrap(),
        ));
        // D s_2813_8: cast reint s_2813_7 -> u8
        let s_2813_8: u8 = (s_2813_7.value() as u8);
        // D s_2813_9: cast zx s_2813_8 -> bv
        let s_2813_9: Bits = Bits::new(s_2813_8 as u128, 4u16);
        // C s_2813_10: const #8u : u8
        let s_2813_10: u8 = 8;
        // C s_2813_11: cast zx s_2813_10 -> bv
        let s_2813_11: Bits = Bits::new(s_2813_10 as u128, 4u16);
        // D s_2813_12: cmp-eq s_2813_9 s_2813_11
        let s_2813_12: bool = ((s_2813_9) == (s_2813_11));
        // D s_2813_13: write-var gs#399133 <= s_2813_12
        fn_state.gs_399133 = s_2813_12;
        // N s_2813_14: jump b2812
        return block_2812(state, tracer, fn_state);
    }
    fn block_2814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2814_0: const #3451s : i
        let s_2814_0: i128 = 3451;
        // C s_2814_1: const #14696u : u32
        let s_2814_1: u32 = 14696;
        // D s_2814_2: read-reg s_2814_1:i
        let s_2814_2: i128 = {
            let value = state.read_register::<i128>(s_2814_1 as isize);
            tracer.read_register(s_2814_1 as isize, value);
            value
        };
        // D s_2814_3: cmp-lt s_2814_2 s_2814_0
        let s_2814_3: bool = ((s_2814_2) < (s_2814_0));
        // D s_2814_4: write-var gs#399111 <= s_2814_3
        fn_state.gs_399111 = s_2814_3;
        // N s_2814_5: jump b527
        return block_527(state, tracer, fn_state);
    }
    fn block_2815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2815_0: const #20s : i
        let s_2815_0: i128 = 20;
        // D s_2815_1: read-var u#30948:u32
        let s_2815_1: u32 = fn_state.u_30948;
        // D s_2815_2: cast zx s_2815_1 -> bv
        let s_2815_2: Bits = Bits::new(s_2815_1 as u128, 32u16);
        // C s_2815_3: const #1s : i64
        let s_2815_3: i64 = 1;
        // C s_2815_4: cast zx s_2815_3 -> i
        let s_2815_4: i128 = (i128::try_from(s_2815_3).unwrap());
        // C s_2815_5: const #1s : i
        let s_2815_5: i128 = 1;
        // C s_2815_6: add s_2815_5 s_2815_4
        let s_2815_6: i128 = (s_2815_5 + s_2815_4);
        // D s_2815_7: bit-extract s_2815_2 s_2815_0 s_2815_6
        let s_2815_7: Bits = (Bits::new(
            ((s_2815_2) >> (s_2815_0)).value(),
            u16::try_from(s_2815_6).unwrap(),
        ));
        // D s_2815_8: cast reint s_2815_7 -> u8
        let s_2815_8: u8 = (s_2815_7.value() as u8);
        // D s_2815_9: cast zx s_2815_8 -> bv
        let s_2815_9: Bits = Bits::new(s_2815_8 as u128, 2u16);
        // C s_2815_10: const #2u : u8
        let s_2815_10: u8 = 2;
        // C s_2815_11: cast zx s_2815_10 -> bv
        let s_2815_11: Bits = Bits::new(s_2815_10 as u128, 2u16);
        // D s_2815_12: cmp-eq s_2815_9 s_2815_11
        let s_2815_12: bool = ((s_2815_9) == (s_2815_11));
        // N s_2815_13: branch s_2815_12 b2818 b2816
        if s_2815_12 {
            return block_2818(state, tracer, fn_state);
        } else {
            return block_2816(state, tracer, fn_state);
        };
    }
    fn block_2816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2816_0: const #0u : u8
        let s_2816_0: bool = false;
        // D s_2816_1: write-var gs#399108 <= s_2816_0
        fn_state.gs_399108 = s_2816_0;
        // N s_2816_2: jump b2817
        return block_2817(state, tracer, fn_state);
    }
    fn block_2817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2817_0: read-var gs#399108:u8
        let s_2817_0: bool = fn_state.gs_399108;
        // D s_2817_1: write-var gs#399109 <= s_2817_0
        fn_state.gs_399109 = s_2817_0;
        // N s_2817_2: jump b525
        return block_525(state, tracer, fn_state);
    }
    fn block_2818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2818_0: const #8s : i
        let s_2818_0: i128 = 8;
        // D s_2818_1: read-var u#30948:u32
        let s_2818_1: u32 = fn_state.u_30948;
        // D s_2818_2: cast zx s_2818_1 -> bv
        let s_2818_2: Bits = Bits::new(s_2818_1 as u128, 32u16);
        // C s_2818_3: const #1s : i64
        let s_2818_3: i64 = 1;
        // C s_2818_4: cast zx s_2818_3 -> i
        let s_2818_4: i128 = (i128::try_from(s_2818_3).unwrap());
        // C s_2818_5: const #3s : i
        let s_2818_5: i128 = 3;
        // C s_2818_6: add s_2818_5 s_2818_4
        let s_2818_6: i128 = (s_2818_5 + s_2818_4);
        // D s_2818_7: bit-extract s_2818_2 s_2818_0 s_2818_6
        let s_2818_7: Bits = (Bits::new(
            ((s_2818_2) >> (s_2818_0)).value(),
            u16::try_from(s_2818_6).unwrap(),
        ));
        // D s_2818_8: cast reint s_2818_7 -> u8
        let s_2818_8: u8 = (s_2818_7.value() as u8);
        // D s_2818_9: cast zx s_2818_8 -> bv
        let s_2818_9: Bits = Bits::new(s_2818_8 as u128, 4u16);
        // C s_2818_10: const #4u : u8
        let s_2818_10: u8 = 4;
        // C s_2818_11: cast zx s_2818_10 -> bv
        let s_2818_11: Bits = Bits::new(s_2818_10 as u128, 4u16);
        // D s_2818_12: cmp-eq s_2818_9 s_2818_11
        let s_2818_12: bool = ((s_2818_9) == (s_2818_11));
        // D s_2818_13: write-var gs#399108 <= s_2818_12
        fn_state.gs_399108 = s_2818_12;
        // N s_2818_14: jump b2817
        return block_2817(state, tracer, fn_state);
    }
    fn block_2819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2819_0: const #3450s : i
        let s_2819_0: i128 = 3450;
        // C s_2819_1: const #14696u : u32
        let s_2819_1: u32 = 14696;
        // D s_2819_2: read-reg s_2819_1:i
        let s_2819_2: i128 = {
            let value = state.read_register::<i128>(s_2819_1 as isize);
            tracer.read_register(s_2819_1 as isize, value);
            value
        };
        // D s_2819_3: cmp-lt s_2819_2 s_2819_0
        let s_2819_3: bool = ((s_2819_2) < (s_2819_0));
        // D s_2819_4: write-var gs#399086 <= s_2819_3
        fn_state.gs_399086 = s_2819_3;
        // N s_2819_5: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_2820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2820_0: const #20s : i
        let s_2820_0: i128 = 20;
        // D s_2820_1: read-var u#30941:u32
        let s_2820_1: u32 = fn_state.u_30941;
        // D s_2820_2: cast zx s_2820_1 -> bv
        let s_2820_2: Bits = Bits::new(s_2820_1 as u128, 32u16);
        // C s_2820_3: const #1s : i64
        let s_2820_3: i64 = 1;
        // C s_2820_4: cast zx s_2820_3 -> i
        let s_2820_4: i128 = (i128::try_from(s_2820_3).unwrap());
        // C s_2820_5: const #1s : i
        let s_2820_5: i128 = 1;
        // C s_2820_6: add s_2820_5 s_2820_4
        let s_2820_6: i128 = (s_2820_5 + s_2820_4);
        // D s_2820_7: bit-extract s_2820_2 s_2820_0 s_2820_6
        let s_2820_7: Bits = (Bits::new(
            ((s_2820_2) >> (s_2820_0)).value(),
            u16::try_from(s_2820_6).unwrap(),
        ));
        // D s_2820_8: cast reint s_2820_7 -> u8
        let s_2820_8: u8 = (s_2820_7.value() as u8);
        // D s_2820_9: cast zx s_2820_8 -> bv
        let s_2820_9: Bits = Bits::new(s_2820_8 as u128, 2u16);
        // C s_2820_10: const #2u : u8
        let s_2820_10: u8 = 2;
        // C s_2820_11: cast zx s_2820_10 -> bv
        let s_2820_11: Bits = Bits::new(s_2820_10 as u128, 2u16);
        // D s_2820_12: cmp-eq s_2820_9 s_2820_11
        let s_2820_12: bool = ((s_2820_9) == (s_2820_11));
        // N s_2820_13: branch s_2820_12 b2823 b2821
        if s_2820_12 {
            return block_2823(state, tracer, fn_state);
        } else {
            return block_2821(state, tracer, fn_state);
        };
    }
    fn block_2821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2821_0: const #0u : u8
        let s_2821_0: bool = false;
        // D s_2821_1: write-var gs#399083 <= s_2821_0
        fn_state.gs_399083 = s_2821_0;
        // N s_2821_2: jump b2822
        return block_2822(state, tracer, fn_state);
    }
    fn block_2822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2822_0: read-var gs#399083:u8
        let s_2822_0: bool = fn_state.gs_399083;
        // D s_2822_1: write-var gs#399084 <= s_2822_0
        fn_state.gs_399084 = s_2822_0;
        // N s_2822_2: jump b519
        return block_519(state, tracer, fn_state);
    }
    fn block_2823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2823_0: const #8s : i
        let s_2823_0: i128 = 8;
        // D s_2823_1: read-var u#30941:u32
        let s_2823_1: u32 = fn_state.u_30941;
        // D s_2823_2: cast zx s_2823_1 -> bv
        let s_2823_2: Bits = Bits::new(s_2823_1 as u128, 32u16);
        // C s_2823_3: const #1s : i64
        let s_2823_3: i64 = 1;
        // C s_2823_4: cast zx s_2823_3 -> i
        let s_2823_4: i128 = (i128::try_from(s_2823_3).unwrap());
        // C s_2823_5: const #3s : i
        let s_2823_5: i128 = 3;
        // C s_2823_6: add s_2823_5 s_2823_4
        let s_2823_6: i128 = (s_2823_5 + s_2823_4);
        // D s_2823_7: bit-extract s_2823_2 s_2823_0 s_2823_6
        let s_2823_7: Bits = (Bits::new(
            ((s_2823_2) >> (s_2823_0)).value(),
            u16::try_from(s_2823_6).unwrap(),
        ));
        // D s_2823_8: cast reint s_2823_7 -> u8
        let s_2823_8: u8 = (s_2823_7.value() as u8);
        // D s_2823_9: cast zx s_2823_8 -> bv
        let s_2823_9: Bits = Bits::new(s_2823_8 as u128, 4u16);
        // C s_2823_10: const #0u : u8
        let s_2823_10: u8 = 0;
        // C s_2823_11: cast zx s_2823_10 -> bv
        let s_2823_11: Bits = Bits::new(s_2823_10 as u128, 4u16);
        // D s_2823_12: cmp-eq s_2823_9 s_2823_11
        let s_2823_12: bool = ((s_2823_9) == (s_2823_11));
        // D s_2823_13: write-var gs#399083 <= s_2823_12
        fn_state.gs_399083 = s_2823_12;
        // N s_2823_14: jump b2822
        return block_2822(state, tracer, fn_state);
    }
    fn block_2824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2824_0: const #3448s : i
        let s_2824_0: i128 = 3448;
        // C s_2824_1: const #14696u : u32
        let s_2824_1: u32 = 14696;
        // D s_2824_2: read-reg s_2824_1:i
        let s_2824_2: i128 = {
            let value = state.read_register::<i128>(s_2824_1 as isize);
            tracer.read_register(s_2824_1 as isize, value);
            value
        };
        // D s_2824_3: cmp-lt s_2824_2 s_2824_0
        let s_2824_3: bool = ((s_2824_2) < (s_2824_0));
        // D s_2824_4: write-var gs#399053 <= s_2824_3
        fn_state.gs_399053 = s_2824_3;
        // N s_2824_5: jump b515
        return block_515(state, tracer, fn_state);
    }
    fn block_2825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2825_0: const #23s : i
        let s_2825_0: i128 = 23;
        // D s_2825_1: read-var u#30929:u32
        let s_2825_1: u32 = fn_state.u_30929;
        // D s_2825_2: cast zx s_2825_1 -> bv
        let s_2825_2: Bits = Bits::new(s_2825_1 as u128, 32u16);
        // C s_2825_3: const #1s : i64
        let s_2825_3: i64 = 1;
        // C s_2825_4: cast zx s_2825_3 -> i
        let s_2825_4: i128 = (i128::try_from(s_2825_3).unwrap());
        // C s_2825_5: const #0s : i
        let s_2825_5: i128 = 0;
        // C s_2825_6: add s_2825_5 s_2825_4
        let s_2825_6: i128 = (s_2825_5 + s_2825_4);
        // D s_2825_7: bit-extract s_2825_2 s_2825_0 s_2825_6
        let s_2825_7: Bits = (Bits::new(
            ((s_2825_2) >> (s_2825_0)).value(),
            u16::try_from(s_2825_6).unwrap(),
        ));
        // D s_2825_8: cast reint s_2825_7 -> u8
        let s_2825_8: bool = ((s_2825_7.value()) != 0);
        // D s_2825_9: cast zx s_2825_8 -> bv
        let s_2825_9: Bits = Bits::new(s_2825_8 as u128, 1u16);
        // C s_2825_10: const #0u : u8
        let s_2825_10: bool = false;
        // C s_2825_11: cast zx s_2825_10 -> bv
        let s_2825_11: Bits = Bits::new(s_2825_10 as u128, 1u16);
        // D s_2825_12: cmp-eq s_2825_9 s_2825_11
        let s_2825_12: bool = ((s_2825_9) == (s_2825_11));
        // N s_2825_13: branch s_2825_12 b2828 b2826
        if s_2825_12 {
            return block_2828(state, tracer, fn_state);
        } else {
            return block_2826(state, tracer, fn_state);
        };
    }
    fn block_2826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2826_0: const #0u : u8
        let s_2826_0: bool = false;
        // D s_2826_1: write-var gs#399050 <= s_2826_0
        fn_state.gs_399050 = s_2826_0;
        // N s_2826_2: jump b2827
        return block_2827(state, tracer, fn_state);
    }
    fn block_2827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2827_0: read-var gs#399050:u8
        let s_2827_0: bool = fn_state.gs_399050;
        // D s_2827_1: write-var gs#399051 <= s_2827_0
        fn_state.gs_399051 = s_2827_0;
        // N s_2827_2: jump b513
        return block_513(state, tracer, fn_state);
    }
    fn block_2828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2828_0: const #10s : i
        let s_2828_0: i128 = 10;
        // D s_2828_1: read-var u#30929:u32
        let s_2828_1: u32 = fn_state.u_30929;
        // D s_2828_2: cast zx s_2828_1 -> bv
        let s_2828_2: Bits = Bits::new(s_2828_1 as u128, 32u16);
        // C s_2828_3: const #1s : i64
        let s_2828_3: i64 = 1;
        // C s_2828_4: cast zx s_2828_3 -> i
        let s_2828_4: i128 = (i128::try_from(s_2828_3).unwrap());
        // C s_2828_5: const #1s : i
        let s_2828_5: i128 = 1;
        // C s_2828_6: add s_2828_5 s_2828_4
        let s_2828_6: i128 = (s_2828_5 + s_2828_4);
        // D s_2828_7: bit-extract s_2828_2 s_2828_0 s_2828_6
        let s_2828_7: Bits = (Bits::new(
            ((s_2828_2) >> (s_2828_0)).value(),
            u16::try_from(s_2828_6).unwrap(),
        ));
        // D s_2828_8: cast reint s_2828_7 -> u8
        let s_2828_8: u8 = (s_2828_7.value() as u8);
        // D s_2828_9: cast zx s_2828_8 -> bv
        let s_2828_9: Bits = Bits::new(s_2828_8 as u128, 2u16);
        // C s_2828_10: const #0u : u8
        let s_2828_10: u8 = 0;
        // C s_2828_11: cast zx s_2828_10 -> bv
        let s_2828_11: Bits = Bits::new(s_2828_10 as u128, 2u16);
        // D s_2828_12: cmp-eq s_2828_9 s_2828_11
        let s_2828_12: bool = ((s_2828_9) == (s_2828_11));
        // N s_2828_13: branch s_2828_12 b2831 b2829
        if s_2828_12 {
            return block_2831(state, tracer, fn_state);
        } else {
            return block_2829(state, tracer, fn_state);
        };
    }
    fn block_2829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2829_0: const #0u : u8
        let s_2829_0: bool = false;
        // D s_2829_1: write-var gs#399049 <= s_2829_0
        fn_state.gs_399049 = s_2829_0;
        // N s_2829_2: jump b2830
        return block_2830(state, tracer, fn_state);
    }
    fn block_2830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2830_0: read-var gs#399049:u8
        let s_2830_0: bool = fn_state.gs_399049;
        // D s_2830_1: write-var gs#399050 <= s_2830_0
        fn_state.gs_399050 = s_2830_0;
        // N s_2830_2: jump b2827
        return block_2827(state, tracer, fn_state);
    }
    fn block_2831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2831_0: const #8s : i
        let s_2831_0: i128 = 8;
        // D s_2831_1: read-var u#30929:u32
        let s_2831_1: u32 = fn_state.u_30929;
        // D s_2831_2: cast zx s_2831_1 -> bv
        let s_2831_2: Bits = Bits::new(s_2831_1 as u128, 32u16);
        // C s_2831_3: const #1s : i64
        let s_2831_3: i64 = 1;
        // C s_2831_4: cast zx s_2831_3 -> i
        let s_2831_4: i128 = (i128::try_from(s_2831_3).unwrap());
        // C s_2831_5: const #0s : i
        let s_2831_5: i128 = 0;
        // C s_2831_6: add s_2831_5 s_2831_4
        let s_2831_6: i128 = (s_2831_5 + s_2831_4);
        // D s_2831_7: bit-extract s_2831_2 s_2831_0 s_2831_6
        let s_2831_7: Bits = (Bits::new(
            ((s_2831_2) >> (s_2831_0)).value(),
            u16::try_from(s_2831_6).unwrap(),
        ));
        // D s_2831_8: cast reint s_2831_7 -> u8
        let s_2831_8: bool = ((s_2831_7.value()) != 0);
        // D s_2831_9: cast zx s_2831_8 -> bv
        let s_2831_9: Bits = Bits::new(s_2831_8 as u128, 1u16);
        // C s_2831_10: const #0u : u8
        let s_2831_10: bool = false;
        // C s_2831_11: cast zx s_2831_10 -> bv
        let s_2831_11: Bits = Bits::new(s_2831_10 as u128, 1u16);
        // D s_2831_12: cmp-eq s_2831_9 s_2831_11
        let s_2831_12: bool = ((s_2831_9) == (s_2831_11));
        // N s_2831_13: branch s_2831_12 b2834 b2832
        if s_2831_12 {
            return block_2834(state, tracer, fn_state);
        } else {
            return block_2832(state, tracer, fn_state);
        };
    }
    fn block_2832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2832_0: const #0u : u8
        let s_2832_0: bool = false;
        // D s_2832_1: write-var gs#399048 <= s_2832_0
        fn_state.gs_399048 = s_2832_0;
        // N s_2832_2: jump b2833
        return block_2833(state, tracer, fn_state);
    }
    fn block_2833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2833_0: read-var gs#399048:u8
        let s_2833_0: bool = fn_state.gs_399048;
        // D s_2833_1: write-var gs#399049 <= s_2833_0
        fn_state.gs_399049 = s_2833_0;
        // N s_2833_2: jump b2830
        return block_2830(state, tracer, fn_state);
    }
    fn block_2834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2834_0: const #4s : i
        let s_2834_0: i128 = 4;
        // D s_2834_1: read-var u#30929:u32
        let s_2834_1: u32 = fn_state.u_30929;
        // D s_2834_2: cast zx s_2834_1 -> bv
        let s_2834_2: Bits = Bits::new(s_2834_1 as u128, 32u16);
        // C s_2834_3: const #1s : i64
        let s_2834_3: i64 = 1;
        // C s_2834_4: cast zx s_2834_3 -> i
        let s_2834_4: i128 = (i128::try_from(s_2834_3).unwrap());
        // C s_2834_5: const #0s : i
        let s_2834_5: i128 = 0;
        // C s_2834_6: add s_2834_5 s_2834_4
        let s_2834_6: i128 = (s_2834_5 + s_2834_4);
        // D s_2834_7: bit-extract s_2834_2 s_2834_0 s_2834_6
        let s_2834_7: Bits = (Bits::new(
            ((s_2834_2) >> (s_2834_0)).value(),
            u16::try_from(s_2834_6).unwrap(),
        ));
        // D s_2834_8: cast reint s_2834_7 -> u8
        let s_2834_8: bool = ((s_2834_7.value()) != 0);
        // D s_2834_9: cast zx s_2834_8 -> bv
        let s_2834_9: Bits = Bits::new(s_2834_8 as u128, 1u16);
        // C s_2834_10: const #0u : u8
        let s_2834_10: bool = false;
        // C s_2834_11: cast zx s_2834_10 -> bv
        let s_2834_11: Bits = Bits::new(s_2834_10 as u128, 1u16);
        // D s_2834_12: cmp-eq s_2834_9 s_2834_11
        let s_2834_12: bool = ((s_2834_9) == (s_2834_11));
        // D s_2834_13: write-var gs#399048 <= s_2834_12
        fn_state.gs_399048 = s_2834_12;
        // N s_2834_14: jump b2833
        return block_2833(state, tracer, fn_state);
    }
    fn block_2835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2835_0: const #3442s : i
        let s_2835_0: i128 = 3442;
        // C s_2835_1: const #14696u : u32
        let s_2835_1: u32 = 14696;
        // D s_2835_2: read-reg s_2835_1:i
        let s_2835_2: i128 = {
            let value = state.read_register::<i128>(s_2835_1 as isize);
            tracer.read_register(s_2835_1 as isize, value);
            value
        };
        // D s_2835_3: cmp-lt s_2835_2 s_2835_0
        let s_2835_3: bool = ((s_2835_2) < (s_2835_0));
        // D s_2835_4: write-var gs#399016 <= s_2835_3
        fn_state.gs_399016 = s_2835_3;
        // N s_2835_5: jump b509
        return block_509(state, tracer, fn_state);
    }
    fn block_2836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2836_0: const #8s : i
        let s_2836_0: i128 = 8;
        // D s_2836_1: read-var u#30918:u32
        let s_2836_1: u32 = fn_state.u_30918;
        // D s_2836_2: cast zx s_2836_1 -> bv
        let s_2836_2: Bits = Bits::new(s_2836_1 as u128, 32u16);
        // C s_2836_3: const #1s : i64
        let s_2836_3: i64 = 1;
        // C s_2836_4: cast zx s_2836_3 -> i
        let s_2836_4: i128 = (i128::try_from(s_2836_3).unwrap());
        // C s_2836_5: const #3s : i
        let s_2836_5: i128 = 3;
        // C s_2836_6: add s_2836_5 s_2836_4
        let s_2836_6: i128 = (s_2836_5 + s_2836_4);
        // D s_2836_7: bit-extract s_2836_2 s_2836_0 s_2836_6
        let s_2836_7: Bits = (Bits::new(
            ((s_2836_2) >> (s_2836_0)).value(),
            u16::try_from(s_2836_6).unwrap(),
        ));
        // D s_2836_8: cast reint s_2836_7 -> u8
        let s_2836_8: u8 = (s_2836_7.value() as u8);
        // D s_2836_9: cast zx s_2836_8 -> bv
        let s_2836_9: Bits = Bits::new(s_2836_8 as u128, 4u16);
        // C s_2836_10: const #12u : u8
        let s_2836_10: u8 = 12;
        // C s_2836_11: cast zx s_2836_10 -> bv
        let s_2836_11: Bits = Bits::new(s_2836_10 as u128, 4u16);
        // D s_2836_12: cmp-eq s_2836_9 s_2836_11
        let s_2836_12: bool = ((s_2836_9) == (s_2836_11));
        // N s_2836_13: branch s_2836_12 b2839 b2837
        if s_2836_12 {
            return block_2839(state, tracer, fn_state);
        } else {
            return block_2837(state, tracer, fn_state);
        };
    }
    fn block_2837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2837_0: const #0u : u8
        let s_2837_0: bool = false;
        // D s_2837_1: write-var gs#399013 <= s_2837_0
        fn_state.gs_399013 = s_2837_0;
        // N s_2837_2: jump b2838
        return block_2838(state, tracer, fn_state);
    }
    fn block_2838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2838_0: read-var gs#399013:u8
        let s_2838_0: bool = fn_state.gs_399013;
        // D s_2838_1: write-var gs#399014 <= s_2838_0
        fn_state.gs_399014 = s_2838_0;
        // N s_2838_2: jump b507
        return block_507(state, tracer, fn_state);
    }
    fn block_2839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2839_0: const #4s : i
        let s_2839_0: i128 = 4;
        // D s_2839_1: read-var u#30918:u32
        let s_2839_1: u32 = fn_state.u_30918;
        // D s_2839_2: cast zx s_2839_1 -> bv
        let s_2839_2: Bits = Bits::new(s_2839_1 as u128, 32u16);
        // C s_2839_3: const #1s : i64
        let s_2839_3: i64 = 1;
        // C s_2839_4: cast zx s_2839_3 -> i
        let s_2839_4: i128 = (i128::try_from(s_2839_3).unwrap());
        // C s_2839_5: const #0s : i
        let s_2839_5: i128 = 0;
        // C s_2839_6: add s_2839_5 s_2839_4
        let s_2839_6: i128 = (s_2839_5 + s_2839_4);
        // D s_2839_7: bit-extract s_2839_2 s_2839_0 s_2839_6
        let s_2839_7: Bits = (Bits::new(
            ((s_2839_2) >> (s_2839_0)).value(),
            u16::try_from(s_2839_6).unwrap(),
        ));
        // D s_2839_8: cast reint s_2839_7 -> u8
        let s_2839_8: bool = ((s_2839_7.value()) != 0);
        // D s_2839_9: cast zx s_2839_8 -> bv
        let s_2839_9: Bits = Bits::new(s_2839_8 as u128, 1u16);
        // C s_2839_10: const #1u : u8
        let s_2839_10: bool = true;
        // C s_2839_11: cast zx s_2839_10 -> bv
        let s_2839_11: Bits = Bits::new(s_2839_10 as u128, 1u16);
        // D s_2839_12: cmp-eq s_2839_9 s_2839_11
        let s_2839_12: bool = ((s_2839_9) == (s_2839_11));
        // D s_2839_13: write-var gs#399013 <= s_2839_12
        fn_state.gs_399013 = s_2839_12;
        // N s_2839_14: jump b2838
        return block_2838(state, tracer, fn_state);
    }
    fn block_2840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2840_0: const #3440s : i
        let s_2840_0: i128 = 3440;
        // C s_2840_1: const #14696u : u32
        let s_2840_1: u32 = 14696;
        // D s_2840_2: read-reg s_2840_1:i
        let s_2840_2: i128 = {
            let value = state.read_register::<i128>(s_2840_1 as isize);
            tracer.read_register(s_2840_1 as isize, value);
            value
        };
        // D s_2840_3: cmp-lt s_2840_2 s_2840_0
        let s_2840_3: bool = ((s_2840_2) < (s_2840_0));
        // D s_2840_4: write-var gs#398987 <= s_2840_3
        fn_state.gs_398987 = s_2840_3;
        // N s_2840_5: jump b503
        return block_503(state, tracer, fn_state);
    }
    fn block_2841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2841_0: const #20s : i
        let s_2841_0: i128 = 20;
        // D s_2841_1: read-var u#30908:u32
        let s_2841_1: u32 = fn_state.u_30908;
        // D s_2841_2: cast zx s_2841_1 -> bv
        let s_2841_2: Bits = Bits::new(s_2841_1 as u128, 32u16);
        // C s_2841_3: const #1s : i64
        let s_2841_3: i64 = 1;
        // C s_2841_4: cast zx s_2841_3 -> i
        let s_2841_4: i128 = (i128::try_from(s_2841_3).unwrap());
        // C s_2841_5: const #1s : i
        let s_2841_5: i128 = 1;
        // C s_2841_6: add s_2841_5 s_2841_4
        let s_2841_6: i128 = (s_2841_5 + s_2841_4);
        // D s_2841_7: bit-extract s_2841_2 s_2841_0 s_2841_6
        let s_2841_7: Bits = (Bits::new(
            ((s_2841_2) >> (s_2841_0)).value(),
            u16::try_from(s_2841_6).unwrap(),
        ));
        // D s_2841_8: cast reint s_2841_7 -> u8
        let s_2841_8: u8 = (s_2841_7.value() as u8);
        // D s_2841_9: cast zx s_2841_8 -> bv
        let s_2841_9: Bits = Bits::new(s_2841_8 as u128, 2u16);
        // C s_2841_10: const #3u : u8
        let s_2841_10: u8 = 3;
        // C s_2841_11: cast zx s_2841_10 -> bv
        let s_2841_11: Bits = Bits::new(s_2841_10 as u128, 2u16);
        // D s_2841_12: cmp-eq s_2841_9 s_2841_11
        let s_2841_12: bool = ((s_2841_9) == (s_2841_11));
        // N s_2841_13: branch s_2841_12 b2844 b2842
        if s_2841_12 {
            return block_2844(state, tracer, fn_state);
        } else {
            return block_2842(state, tracer, fn_state);
        };
    }
    fn block_2842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2842_0: const #0u : u8
        let s_2842_0: bool = false;
        // D s_2842_1: write-var gs#398984 <= s_2842_0
        fn_state.gs_398984 = s_2842_0;
        // N s_2842_2: jump b2843
        return block_2843(state, tracer, fn_state);
    }
    fn block_2843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2843_0: read-var gs#398984:u8
        let s_2843_0: bool = fn_state.gs_398984;
        // D s_2843_1: write-var gs#398985 <= s_2843_0
        fn_state.gs_398985 = s_2843_0;
        // N s_2843_2: jump b501
        return block_501(state, tracer, fn_state);
    }
    fn block_2844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2844_0: const #4s : i
        let s_2844_0: i128 = 4;
        // D s_2844_1: read-var u#30908:u32
        let s_2844_1: u32 = fn_state.u_30908;
        // D s_2844_2: cast zx s_2844_1 -> bv
        let s_2844_2: Bits = Bits::new(s_2844_1 as u128, 32u16);
        // C s_2844_3: const #1s : i64
        let s_2844_3: i64 = 1;
        // C s_2844_4: cast zx s_2844_3 -> i
        let s_2844_4: i128 = (i128::try_from(s_2844_3).unwrap());
        // C s_2844_5: const #0s : i
        let s_2844_5: i128 = 0;
        // C s_2844_6: add s_2844_5 s_2844_4
        let s_2844_6: i128 = (s_2844_5 + s_2844_4);
        // D s_2844_7: bit-extract s_2844_2 s_2844_0 s_2844_6
        let s_2844_7: Bits = (Bits::new(
            ((s_2844_2) >> (s_2844_0)).value(),
            u16::try_from(s_2844_6).unwrap(),
        ));
        // D s_2844_8: cast reint s_2844_7 -> u8
        let s_2844_8: bool = ((s_2844_7.value()) != 0);
        // D s_2844_9: cast zx s_2844_8 -> bv
        let s_2844_9: Bits = Bits::new(s_2844_8 as u128, 1u16);
        // C s_2844_10: const #0u : u8
        let s_2844_10: bool = false;
        // C s_2844_11: cast zx s_2844_10 -> bv
        let s_2844_11: Bits = Bits::new(s_2844_10 as u128, 1u16);
        // D s_2844_12: cmp-eq s_2844_9 s_2844_11
        let s_2844_12: bool = ((s_2844_9) == (s_2844_11));
        // D s_2844_13: write-var gs#398984 <= s_2844_12
        fn_state.gs_398984 = s_2844_12;
        // N s_2844_14: jump b2843
        return block_2843(state, tracer, fn_state);
    }
    fn block_2845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2845_0: const #3438s : i
        let s_2845_0: i128 = 3438;
        // C s_2845_1: const #14696u : u32
        let s_2845_1: u32 = 14696;
        // D s_2845_2: read-reg s_2845_1:i
        let s_2845_2: i128 = {
            let value = state.read_register::<i128>(s_2845_1 as isize);
            tracer.read_register(s_2845_1 as isize, value);
            value
        };
        // D s_2845_3: cmp-lt s_2845_2 s_2845_0
        let s_2845_3: bool = ((s_2845_2) < (s_2845_0));
        // D s_2845_4: write-var gs#398960 <= s_2845_3
        fn_state.gs_398960 = s_2845_3;
        // N s_2845_5: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_2846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2846_0: const #20s : i
        let s_2846_0: i128 = 20;
        // D s_2846_1: read-var u#30899:u32
        let s_2846_1: u32 = fn_state.u_30899;
        // D s_2846_2: cast zx s_2846_1 -> bv
        let s_2846_2: Bits = Bits::new(s_2846_1 as u128, 32u16);
        // C s_2846_3: const #1s : i64
        let s_2846_3: i64 = 1;
        // C s_2846_4: cast zx s_2846_3 -> i
        let s_2846_4: i128 = (i128::try_from(s_2846_3).unwrap());
        // C s_2846_5: const #1s : i
        let s_2846_5: i128 = 1;
        // C s_2846_6: add s_2846_5 s_2846_4
        let s_2846_6: i128 = (s_2846_5 + s_2846_4);
        // D s_2846_7: bit-extract s_2846_2 s_2846_0 s_2846_6
        let s_2846_7: Bits = (Bits::new(
            ((s_2846_2) >> (s_2846_0)).value(),
            u16::try_from(s_2846_6).unwrap(),
        ));
        // D s_2846_8: cast reint s_2846_7 -> u8
        let s_2846_8: u8 = (s_2846_7.value() as u8);
        // D s_2846_9: cast zx s_2846_8 -> bv
        let s_2846_9: Bits = Bits::new(s_2846_8 as u128, 2u16);
        // C s_2846_10: const #0u : u8
        let s_2846_10: u8 = 0;
        // C s_2846_11: cast zx s_2846_10 -> bv
        let s_2846_11: Bits = Bits::new(s_2846_10 as u128, 2u16);
        // D s_2846_12: cmp-eq s_2846_9 s_2846_11
        let s_2846_12: bool = ((s_2846_9) == (s_2846_11));
        // N s_2846_13: branch s_2846_12 b2849 b2847
        if s_2846_12 {
            return block_2849(state, tracer, fn_state);
        } else {
            return block_2847(state, tracer, fn_state);
        };
    }
    fn block_2847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2847_0: const #0u : u8
        let s_2847_0: bool = false;
        // D s_2847_1: write-var gs#398957 <= s_2847_0
        fn_state.gs_398957 = s_2847_0;
        // N s_2847_2: jump b2848
        return block_2848(state, tracer, fn_state);
    }
    fn block_2848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2848_0: read-var gs#398957:u8
        let s_2848_0: bool = fn_state.gs_398957;
        // D s_2848_1: write-var gs#398958 <= s_2848_0
        fn_state.gs_398958 = s_2848_0;
        // N s_2848_2: jump b495
        return block_495(state, tracer, fn_state);
    }
    fn block_2849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2849_0: const #8s : i
        let s_2849_0: i128 = 8;
        // D s_2849_1: read-var u#30899:u32
        let s_2849_1: u32 = fn_state.u_30899;
        // D s_2849_2: cast zx s_2849_1 -> bv
        let s_2849_2: Bits = Bits::new(s_2849_1 as u128, 32u16);
        // C s_2849_3: const #1s : i64
        let s_2849_3: i64 = 1;
        // C s_2849_4: cast zx s_2849_3 -> i
        let s_2849_4: i128 = (i128::try_from(s_2849_3).unwrap());
        // C s_2849_5: const #3s : i
        let s_2849_5: i128 = 3;
        // C s_2849_6: add s_2849_5 s_2849_4
        let s_2849_6: i128 = (s_2849_5 + s_2849_4);
        // D s_2849_7: bit-extract s_2849_2 s_2849_0 s_2849_6
        let s_2849_7: Bits = (Bits::new(
            ((s_2849_2) >> (s_2849_0)).value(),
            u16::try_from(s_2849_6).unwrap(),
        ));
        // D s_2849_8: cast reint s_2849_7 -> u8
        let s_2849_8: u8 = (s_2849_7.value() as u8);
        // D s_2849_9: cast zx s_2849_8 -> bv
        let s_2849_9: Bits = Bits::new(s_2849_8 as u128, 4u16);
        // C s_2849_10: const #1u : u8
        let s_2849_10: u8 = 1;
        // C s_2849_11: cast zx s_2849_10 -> bv
        let s_2849_11: Bits = Bits::new(s_2849_10 as u128, 4u16);
        // D s_2849_12: cmp-eq s_2849_9 s_2849_11
        let s_2849_12: bool = ((s_2849_9) == (s_2849_11));
        // N s_2849_13: branch s_2849_12 b2852 b2850
        if s_2849_12 {
            return block_2852(state, tracer, fn_state);
        } else {
            return block_2850(state, tracer, fn_state);
        };
    }
    fn block_2850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2850_0: const #0u : u8
        let s_2850_0: bool = false;
        // D s_2850_1: write-var gs#398956 <= s_2850_0
        fn_state.gs_398956 = s_2850_0;
        // N s_2850_2: jump b2851
        return block_2851(state, tracer, fn_state);
    }
    fn block_2851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2851_0: read-var gs#398956:u8
        let s_2851_0: bool = fn_state.gs_398956;
        // D s_2851_1: write-var gs#398957 <= s_2851_0
        fn_state.gs_398957 = s_2851_0;
        // N s_2851_2: jump b2848
        return block_2848(state, tracer, fn_state);
    }
    fn block_2852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2852_0: const #4s : i
        let s_2852_0: i128 = 4;
        // D s_2852_1: read-var u#30899:u32
        let s_2852_1: u32 = fn_state.u_30899;
        // D s_2852_2: cast zx s_2852_1 -> bv
        let s_2852_2: Bits = Bits::new(s_2852_1 as u128, 32u16);
        // C s_2852_3: const #1s : i64
        let s_2852_3: i64 = 1;
        // C s_2852_4: cast zx s_2852_3 -> i
        let s_2852_4: i128 = (i128::try_from(s_2852_3).unwrap());
        // C s_2852_5: const #0s : i
        let s_2852_5: i128 = 0;
        // C s_2852_6: add s_2852_5 s_2852_4
        let s_2852_6: i128 = (s_2852_5 + s_2852_4);
        // D s_2852_7: bit-extract s_2852_2 s_2852_0 s_2852_6
        let s_2852_7: Bits = (Bits::new(
            ((s_2852_2) >> (s_2852_0)).value(),
            u16::try_from(s_2852_6).unwrap(),
        ));
        // D s_2852_8: cast reint s_2852_7 -> u8
        let s_2852_8: bool = ((s_2852_7.value()) != 0);
        // D s_2852_9: cast zx s_2852_8 -> bv
        let s_2852_9: Bits = Bits::new(s_2852_8 as u128, 1u16);
        // C s_2852_10: const #1u : u8
        let s_2852_10: bool = true;
        // C s_2852_11: cast zx s_2852_10 -> bv
        let s_2852_11: Bits = Bits::new(s_2852_10 as u128, 1u16);
        // D s_2852_12: cmp-eq s_2852_9 s_2852_11
        let s_2852_12: bool = ((s_2852_9) == (s_2852_11));
        // D s_2852_13: write-var gs#398956 <= s_2852_12
        fn_state.gs_398956 = s_2852_12;
        // N s_2852_14: jump b2851
        return block_2851(state, tracer, fn_state);
    }
    fn block_2853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2853_0: const #3436s : i
        let s_2853_0: i128 = 3436;
        // C s_2853_1: const #14696u : u32
        let s_2853_1: u32 = 14696;
        // D s_2853_2: read-reg s_2853_1:i
        let s_2853_2: i128 = {
            let value = state.read_register::<i128>(s_2853_1 as isize);
            tracer.read_register(s_2853_1 as isize, value);
            value
        };
        // D s_2853_3: cmp-lt s_2853_2 s_2853_0
        let s_2853_3: bool = ((s_2853_2) < (s_2853_0));
        // D s_2853_4: write-var gs#398932 <= s_2853_3
        fn_state.gs_398932 = s_2853_3;
        // N s_2853_5: jump b491
        return block_491(state, tracer, fn_state);
    }
    fn block_2854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2854_0: const #20s : i
        let s_2854_0: i128 = 20;
        // D s_2854_1: read-var u#30891:u32
        let s_2854_1: u32 = fn_state.u_30891;
        // D s_2854_2: cast zx s_2854_1 -> bv
        let s_2854_2: Bits = Bits::new(s_2854_1 as u128, 32u16);
        // C s_2854_3: const #1s : i64
        let s_2854_3: i64 = 1;
        // C s_2854_4: cast zx s_2854_3 -> i
        let s_2854_4: i128 = (i128::try_from(s_2854_3).unwrap());
        // C s_2854_5: const #1s : i
        let s_2854_5: i128 = 1;
        // C s_2854_6: add s_2854_5 s_2854_4
        let s_2854_6: i128 = (s_2854_5 + s_2854_4);
        // D s_2854_7: bit-extract s_2854_2 s_2854_0 s_2854_6
        let s_2854_7: Bits = (Bits::new(
            ((s_2854_2) >> (s_2854_0)).value(),
            u16::try_from(s_2854_6).unwrap(),
        ));
        // D s_2854_8: cast reint s_2854_7 -> u8
        let s_2854_8: u8 = (s_2854_7.value() as u8);
        // D s_2854_9: cast zx s_2854_8 -> bv
        let s_2854_9: Bits = Bits::new(s_2854_8 as u128, 2u16);
        // C s_2854_10: const #3u : u8
        let s_2854_10: u8 = 3;
        // C s_2854_11: cast zx s_2854_10 -> bv
        let s_2854_11: Bits = Bits::new(s_2854_10 as u128, 2u16);
        // D s_2854_12: cmp-eq s_2854_9 s_2854_11
        let s_2854_12: bool = ((s_2854_9) == (s_2854_11));
        // N s_2854_13: branch s_2854_12 b2857 b2855
        if s_2854_12 {
            return block_2857(state, tracer, fn_state);
        } else {
            return block_2855(state, tracer, fn_state);
        };
    }
    fn block_2855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2855_0: const #0u : u8
        let s_2855_0: bool = false;
        // D s_2855_1: write-var gs#398929 <= s_2855_0
        fn_state.gs_398929 = s_2855_0;
        // N s_2855_2: jump b2856
        return block_2856(state, tracer, fn_state);
    }
    fn block_2856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2856_0: read-var gs#398929:u8
        let s_2856_0: bool = fn_state.gs_398929;
        // D s_2856_1: write-var gs#398930 <= s_2856_0
        fn_state.gs_398930 = s_2856_0;
        // N s_2856_2: jump b489
        return block_489(state, tracer, fn_state);
    }
    fn block_2857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2857_0: const #7s : i
        let s_2857_0: i128 = 7;
        // D s_2857_1: read-var u#30891:u32
        let s_2857_1: u32 = fn_state.u_30891;
        // D s_2857_2: cast zx s_2857_1 -> bv
        let s_2857_2: Bits = Bits::new(s_2857_1 as u128, 32u16);
        // C s_2857_3: const #1s : i64
        let s_2857_3: i64 = 1;
        // C s_2857_4: cast zx s_2857_3 -> i
        let s_2857_4: i128 = (i128::try_from(s_2857_3).unwrap());
        // C s_2857_5: const #4s : i
        let s_2857_5: i128 = 4;
        // C s_2857_6: add s_2857_5 s_2857_4
        let s_2857_6: i128 = (s_2857_5 + s_2857_4);
        // D s_2857_7: bit-extract s_2857_2 s_2857_0 s_2857_6
        let s_2857_7: Bits = (Bits::new(
            ((s_2857_2) >> (s_2857_0)).value(),
            u16::try_from(s_2857_6).unwrap(),
        ));
        // D s_2857_8: cast reint s_2857_7 -> u8
        let s_2857_8: u8 = (s_2857_7.value() as u8);
        // D s_2857_9: cast zx s_2857_8 -> bv
        let s_2857_9: Bits = Bits::new(s_2857_8 as u128, 5u16);
        // C s_2857_10: const #24u : u8
        let s_2857_10: u8 = 24;
        // C s_2857_11: cast zx s_2857_10 -> bv
        let s_2857_11: Bits = Bits::new(s_2857_10 as u128, 5u16);
        // D s_2857_12: cmp-eq s_2857_9 s_2857_11
        let s_2857_12: bool = ((s_2857_9) == (s_2857_11));
        // N s_2857_13: branch s_2857_12 b2860 b2858
        if s_2857_12 {
            return block_2860(state, tracer, fn_state);
        } else {
            return block_2858(state, tracer, fn_state);
        };
    }
    fn block_2858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2858_0: const #0u : u8
        let s_2858_0: bool = false;
        // D s_2858_1: write-var gs#398928 <= s_2858_0
        fn_state.gs_398928 = s_2858_0;
        // N s_2858_2: jump b2859
        return block_2859(state, tracer, fn_state);
    }
    fn block_2859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2859_0: read-var gs#398928:u8
        let s_2859_0: bool = fn_state.gs_398928;
        // D s_2859_1: write-var gs#398929 <= s_2859_0
        fn_state.gs_398929 = s_2859_0;
        // N s_2859_2: jump b2856
        return block_2856(state, tracer, fn_state);
    }
    fn block_2860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2860_0: const #4s : i
        let s_2860_0: i128 = 4;
        // D s_2860_1: read-var u#30891:u32
        let s_2860_1: u32 = fn_state.u_30891;
        // D s_2860_2: cast zx s_2860_1 -> bv
        let s_2860_2: Bits = Bits::new(s_2860_1 as u128, 32u16);
        // C s_2860_3: const #1s : i64
        let s_2860_3: i64 = 1;
        // C s_2860_4: cast zx s_2860_3 -> i
        let s_2860_4: i128 = (i128::try_from(s_2860_3).unwrap());
        // C s_2860_5: const #0s : i
        let s_2860_5: i128 = 0;
        // C s_2860_6: add s_2860_5 s_2860_4
        let s_2860_6: i128 = (s_2860_5 + s_2860_4);
        // D s_2860_7: bit-extract s_2860_2 s_2860_0 s_2860_6
        let s_2860_7: Bits = (Bits::new(
            ((s_2860_2) >> (s_2860_0)).value(),
            u16::try_from(s_2860_6).unwrap(),
        ));
        // D s_2860_8: cast reint s_2860_7 -> u8
        let s_2860_8: bool = ((s_2860_7.value()) != 0);
        // D s_2860_9: cast zx s_2860_8 -> bv
        let s_2860_9: Bits = Bits::new(s_2860_8 as u128, 1u16);
        // C s_2860_10: const #0u : u8
        let s_2860_10: bool = false;
        // C s_2860_11: cast zx s_2860_10 -> bv
        let s_2860_11: Bits = Bits::new(s_2860_10 as u128, 1u16);
        // D s_2860_12: cmp-eq s_2860_9 s_2860_11
        let s_2860_12: bool = ((s_2860_9) == (s_2860_11));
        // D s_2860_13: write-var gs#398928 <= s_2860_12
        fn_state.gs_398928 = s_2860_12;
        // N s_2860_14: jump b2859
        return block_2859(state, tracer, fn_state);
    }
    fn block_2861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2861_0: const #3428s : i
        let s_2861_0: i128 = 3428;
        // C s_2861_1: const #14696u : u32
        let s_2861_1: u32 = 14696;
        // D s_2861_2: read-reg s_2861_1:i
        let s_2861_2: i128 = {
            let value = state.read_register::<i128>(s_2861_1 as isize);
            tracer.read_register(s_2861_1 as isize, value);
            value
        };
        // D s_2861_3: cmp-lt s_2861_2 s_2861_0
        let s_2861_3: bool = ((s_2861_2) < (s_2861_0));
        // D s_2861_4: write-var gs#398900 <= s_2861_3
        fn_state.gs_398900 = s_2861_3;
        // N s_2861_5: jump b485
        return block_485(state, tracer, fn_state);
    }
    fn block_2862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2862_0: const #23s : i
        let s_2862_0: i128 = 23;
        // D s_2862_1: read-var u#30882:u32
        let s_2862_1: u32 = fn_state.u_30882;
        // D s_2862_2: cast zx s_2862_1 -> bv
        let s_2862_2: Bits = Bits::new(s_2862_1 as u128, 32u16);
        // C s_2862_3: const #1s : i64
        let s_2862_3: i64 = 1;
        // C s_2862_4: cast zx s_2862_3 -> i
        let s_2862_4: i128 = (i128::try_from(s_2862_3).unwrap());
        // C s_2862_5: const #0s : i
        let s_2862_5: i128 = 0;
        // C s_2862_6: add s_2862_5 s_2862_4
        let s_2862_6: i128 = (s_2862_5 + s_2862_4);
        // D s_2862_7: bit-extract s_2862_2 s_2862_0 s_2862_6
        let s_2862_7: Bits = (Bits::new(
            ((s_2862_2) >> (s_2862_0)).value(),
            u16::try_from(s_2862_6).unwrap(),
        ));
        // D s_2862_8: cast reint s_2862_7 -> u8
        let s_2862_8: bool = ((s_2862_7.value()) != 0);
        // D s_2862_9: cast zx s_2862_8 -> bv
        let s_2862_9: Bits = Bits::new(s_2862_8 as u128, 1u16);
        // C s_2862_10: const #1u : u8
        let s_2862_10: bool = true;
        // C s_2862_11: cast zx s_2862_10 -> bv
        let s_2862_11: Bits = Bits::new(s_2862_10 as u128, 1u16);
        // D s_2862_12: cmp-eq s_2862_9 s_2862_11
        let s_2862_12: bool = ((s_2862_9) == (s_2862_11));
        // N s_2862_13: branch s_2862_12 b2865 b2863
        if s_2862_12 {
            return block_2865(state, tracer, fn_state);
        } else {
            return block_2863(state, tracer, fn_state);
        };
    }
    fn block_2863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2863_0: const #0u : u8
        let s_2863_0: bool = false;
        // D s_2863_1: write-var gs#398897 <= s_2863_0
        fn_state.gs_398897 = s_2863_0;
        // N s_2863_2: jump b2864
        return block_2864(state, tracer, fn_state);
    }
    fn block_2864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2864_0: read-var gs#398897:u8
        let s_2864_0: bool = fn_state.gs_398897;
        // D s_2864_1: write-var gs#398898 <= s_2864_0
        fn_state.gs_398898 = s_2864_0;
        // N s_2864_2: jump b483
        return block_483(state, tracer, fn_state);
    }
    fn block_2865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2865_0: const #10s : i
        let s_2865_0: i128 = 10;
        // D s_2865_1: read-var u#30882:u32
        let s_2865_1: u32 = fn_state.u_30882;
        // D s_2865_2: cast zx s_2865_1 -> bv
        let s_2865_2: Bits = Bits::new(s_2865_1 as u128, 32u16);
        // C s_2865_3: const #1s : i64
        let s_2865_3: i64 = 1;
        // C s_2865_4: cast zx s_2865_3 -> i
        let s_2865_4: i128 = (i128::try_from(s_2865_3).unwrap());
        // C s_2865_5: const #1s : i
        let s_2865_5: i128 = 1;
        // C s_2865_6: add s_2865_5 s_2865_4
        let s_2865_6: i128 = (s_2865_5 + s_2865_4);
        // D s_2865_7: bit-extract s_2865_2 s_2865_0 s_2865_6
        let s_2865_7: Bits = (Bits::new(
            ((s_2865_2) >> (s_2865_0)).value(),
            u16::try_from(s_2865_6).unwrap(),
        ));
        // D s_2865_8: cast reint s_2865_7 -> u8
        let s_2865_8: u8 = (s_2865_7.value() as u8);
        // D s_2865_9: cast zx s_2865_8 -> bv
        let s_2865_9: Bits = Bits::new(s_2865_8 as u128, 2u16);
        // C s_2865_10: const #3u : u8
        let s_2865_10: u8 = 3;
        // C s_2865_11: cast zx s_2865_10 -> bv
        let s_2865_11: Bits = Bits::new(s_2865_10 as u128, 2u16);
        // D s_2865_12: cmp-eq s_2865_9 s_2865_11
        let s_2865_12: bool = ((s_2865_9) == (s_2865_11));
        // N s_2865_13: branch s_2865_12 b2868 b2866
        if s_2865_12 {
            return block_2868(state, tracer, fn_state);
        } else {
            return block_2866(state, tracer, fn_state);
        };
    }
    fn block_2866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2866_0: const #0u : u8
        let s_2866_0: bool = false;
        // D s_2866_1: write-var gs#398896 <= s_2866_0
        fn_state.gs_398896 = s_2866_0;
        // N s_2866_2: jump b2867
        return block_2867(state, tracer, fn_state);
    }
    fn block_2867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2867_0: read-var gs#398896:u8
        let s_2867_0: bool = fn_state.gs_398896;
        // D s_2867_1: write-var gs#398897 <= s_2867_0
        fn_state.gs_398897 = s_2867_0;
        // N s_2867_2: jump b2864
        return block_2864(state, tracer, fn_state);
    }
    fn block_2868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2868_0: const #7s : i
        let s_2868_0: i128 = 7;
        // D s_2868_1: read-var u#30882:u32
        let s_2868_1: u32 = fn_state.u_30882;
        // D s_2868_2: cast zx s_2868_1 -> bv
        let s_2868_2: Bits = Bits::new(s_2868_1 as u128, 32u16);
        // C s_2868_3: const #1s : i64
        let s_2868_3: i64 = 1;
        // C s_2868_4: cast zx s_2868_3 -> i
        let s_2868_4: i128 = (i128::try_from(s_2868_3).unwrap());
        // C s_2868_5: const #0s : i
        let s_2868_5: i128 = 0;
        // C s_2868_6: add s_2868_5 s_2868_4
        let s_2868_6: i128 = (s_2868_5 + s_2868_4);
        // D s_2868_7: bit-extract s_2868_2 s_2868_0 s_2868_6
        let s_2868_7: Bits = (Bits::new(
            ((s_2868_2) >> (s_2868_0)).value(),
            u16::try_from(s_2868_6).unwrap(),
        ));
        // D s_2868_8: cast reint s_2868_7 -> u8
        let s_2868_8: bool = ((s_2868_7.value()) != 0);
        // D s_2868_9: cast zx s_2868_8 -> bv
        let s_2868_9: Bits = Bits::new(s_2868_8 as u128, 1u16);
        // C s_2868_10: const #0u : u8
        let s_2868_10: bool = false;
        // C s_2868_11: cast zx s_2868_10 -> bv
        let s_2868_11: Bits = Bits::new(s_2868_10 as u128, 1u16);
        // D s_2868_12: cmp-eq s_2868_9 s_2868_11
        let s_2868_12: bool = ((s_2868_9) == (s_2868_11));
        // N s_2868_13: branch s_2868_12 b2871 b2869
        if s_2868_12 {
            return block_2871(state, tracer, fn_state);
        } else {
            return block_2869(state, tracer, fn_state);
        };
    }
    fn block_2869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2869_0: const #0u : u8
        let s_2869_0: bool = false;
        // D s_2869_1: write-var gs#398895 <= s_2869_0
        fn_state.gs_398895 = s_2869_0;
        // N s_2869_2: jump b2870
        return block_2870(state, tracer, fn_state);
    }
    fn block_2870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2870_0: read-var gs#398895:u8
        let s_2870_0: bool = fn_state.gs_398895;
        // D s_2870_1: write-var gs#398896 <= s_2870_0
        fn_state.gs_398896 = s_2870_0;
        // N s_2870_2: jump b2867
        return block_2867(state, tracer, fn_state);
    }
    fn block_2871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2871_0: const #4s : i
        let s_2871_0: i128 = 4;
        // D s_2871_1: read-var u#30882:u32
        let s_2871_1: u32 = fn_state.u_30882;
        // D s_2871_2: cast zx s_2871_1 -> bv
        let s_2871_2: Bits = Bits::new(s_2871_1 as u128, 32u16);
        // C s_2871_3: const #1s : i64
        let s_2871_3: i64 = 1;
        // C s_2871_4: cast zx s_2871_3 -> i
        let s_2871_4: i128 = (i128::try_from(s_2871_3).unwrap());
        // C s_2871_5: const #0s : i
        let s_2871_5: i128 = 0;
        // C s_2871_6: add s_2871_5 s_2871_4
        let s_2871_6: i128 = (s_2871_5 + s_2871_4);
        // D s_2871_7: bit-extract s_2871_2 s_2871_0 s_2871_6
        let s_2871_7: Bits = (Bits::new(
            ((s_2871_2) >> (s_2871_0)).value(),
            u16::try_from(s_2871_6).unwrap(),
        ));
        // D s_2871_8: cast reint s_2871_7 -> u8
        let s_2871_8: bool = ((s_2871_7.value()) != 0);
        // D s_2871_9: cast zx s_2871_8 -> bv
        let s_2871_9: Bits = Bits::new(s_2871_8 as u128, 1u16);
        // C s_2871_10: const #1u : u8
        let s_2871_10: bool = true;
        // C s_2871_11: cast zx s_2871_10 -> bv
        let s_2871_11: Bits = Bits::new(s_2871_10 as u128, 1u16);
        // D s_2871_12: cmp-eq s_2871_9 s_2871_11
        let s_2871_12: bool = ((s_2871_9) == (s_2871_11));
        // D s_2871_13: write-var gs#398895 <= s_2871_12
        fn_state.gs_398895 = s_2871_12;
        // N s_2871_14: jump b2870
        return block_2870(state, tracer, fn_state);
    }
    fn block_2872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2872_0: const #3424s : i
        let s_2872_0: i128 = 3424;
        // C s_2872_1: const #14696u : u32
        let s_2872_1: u32 = 14696;
        // D s_2872_2: read-reg s_2872_1:i
        let s_2872_2: i128 = {
            let value = state.read_register::<i128>(s_2872_1 as isize);
            tracer.read_register(s_2872_1 as isize, value);
            value
        };
        // D s_2872_3: cmp-lt s_2872_2 s_2872_0
        let s_2872_3: bool = ((s_2872_2) < (s_2872_0));
        // D s_2872_4: write-var gs#398867 <= s_2872_3
        fn_state.gs_398867 = s_2872_3;
        // N s_2872_5: jump b479
        return block_479(state, tracer, fn_state);
    }
    fn block_2873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2873_0: const #20s : i
        let s_2873_0: i128 = 20;
        // D s_2873_1: read-var u#30873:u32
        let s_2873_1: u32 = fn_state.u_30873;
        // D s_2873_2: cast zx s_2873_1 -> bv
        let s_2873_2: Bits = Bits::new(s_2873_1 as u128, 32u16);
        // C s_2873_3: const #1s : i64
        let s_2873_3: i64 = 1;
        // C s_2873_4: cast zx s_2873_3 -> i
        let s_2873_4: i128 = (i128::try_from(s_2873_3).unwrap());
        // C s_2873_5: const #1s : i
        let s_2873_5: i128 = 1;
        // C s_2873_6: add s_2873_5 s_2873_4
        let s_2873_6: i128 = (s_2873_5 + s_2873_4);
        // D s_2873_7: bit-extract s_2873_2 s_2873_0 s_2873_6
        let s_2873_7: Bits = (Bits::new(
            ((s_2873_2) >> (s_2873_0)).value(),
            u16::try_from(s_2873_6).unwrap(),
        ));
        // D s_2873_8: cast reint s_2873_7 -> u8
        let s_2873_8: u8 = (s_2873_7.value() as u8);
        // D s_2873_9: cast zx s_2873_8 -> bv
        let s_2873_9: Bits = Bits::new(s_2873_8 as u128, 2u16);
        // C s_2873_10: const #3u : u8
        let s_2873_10: u8 = 3;
        // C s_2873_11: cast zx s_2873_10 -> bv
        let s_2873_11: Bits = Bits::new(s_2873_10 as u128, 2u16);
        // D s_2873_12: cmp-eq s_2873_9 s_2873_11
        let s_2873_12: bool = ((s_2873_9) == (s_2873_11));
        // N s_2873_13: branch s_2873_12 b2876 b2874
        if s_2873_12 {
            return block_2876(state, tracer, fn_state);
        } else {
            return block_2874(state, tracer, fn_state);
        };
    }
    fn block_2874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2874_0: const #0u : u8
        let s_2874_0: bool = false;
        // D s_2874_1: write-var gs#398864 <= s_2874_0
        fn_state.gs_398864 = s_2874_0;
        // N s_2874_2: jump b2875
        return block_2875(state, tracer, fn_state);
    }
    fn block_2875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2875_0: read-var gs#398864:u8
        let s_2875_0: bool = fn_state.gs_398864;
        // D s_2875_1: write-var gs#398865 <= s_2875_0
        fn_state.gs_398865 = s_2875_0;
        // N s_2875_2: jump b477
        return block_477(state, tracer, fn_state);
    }
    fn block_2876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2876_0: const #16s : i
        let s_2876_0: i128 = 16;
        // D s_2876_1: read-var u#30873:u32
        let s_2876_1: u32 = fn_state.u_30873;
        // D s_2876_2: cast zx s_2876_1 -> bv
        let s_2876_2: Bits = Bits::new(s_2876_1 as u128, 32u16);
        // C s_2876_3: const #1s : i64
        let s_2876_3: i64 = 1;
        // C s_2876_4: cast zx s_2876_3 -> i
        let s_2876_4: i128 = (i128::try_from(s_2876_3).unwrap());
        // C s_2876_5: const #1s : i
        let s_2876_5: i128 = 1;
        // C s_2876_6: add s_2876_5 s_2876_4
        let s_2876_6: i128 = (s_2876_5 + s_2876_4);
        // D s_2876_7: bit-extract s_2876_2 s_2876_0 s_2876_6
        let s_2876_7: Bits = (Bits::new(
            ((s_2876_2) >> (s_2876_0)).value(),
            u16::try_from(s_2876_6).unwrap(),
        ));
        // D s_2876_8: cast reint s_2876_7 -> u8
        let s_2876_8: u8 = (s_2876_7.value() as u8);
        // D s_2876_9: cast zx s_2876_8 -> bv
        let s_2876_9: Bits = Bits::new(s_2876_8 as u128, 2u16);
        // C s_2876_10: const #3u : u8
        let s_2876_10: u8 = 3;
        // C s_2876_11: cast zx s_2876_10 -> bv
        let s_2876_11: Bits = Bits::new(s_2876_10 as u128, 2u16);
        // D s_2876_12: cmp-eq s_2876_9 s_2876_11
        let s_2876_12: bool = ((s_2876_9) == (s_2876_11));
        // N s_2876_13: branch s_2876_12 b2879 b2877
        if s_2876_12 {
            return block_2879(state, tracer, fn_state);
        } else {
            return block_2877(state, tracer, fn_state);
        };
    }
    fn block_2877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2877_0: const #0u : u8
        let s_2877_0: bool = false;
        // D s_2877_1: write-var gs#398863 <= s_2877_0
        fn_state.gs_398863 = s_2877_0;
        // N s_2877_2: jump b2878
        return block_2878(state, tracer, fn_state);
    }
    fn block_2878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2878_0: read-var gs#398863:u8
        let s_2878_0: bool = fn_state.gs_398863;
        // D s_2878_1: write-var gs#398864 <= s_2878_0
        fn_state.gs_398864 = s_2878_0;
        // N s_2878_2: jump b2875
        return block_2875(state, tracer, fn_state);
    }
    fn block_2879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2879_0: const #9s : i
        let s_2879_0: i128 = 9;
        // D s_2879_1: read-var u#30873:u32
        let s_2879_1: u32 = fn_state.u_30873;
        // D s_2879_2: cast zx s_2879_1 -> bv
        let s_2879_2: Bits = Bits::new(s_2879_1 as u128, 32u16);
        // C s_2879_3: const #1s : i64
        let s_2879_3: i64 = 1;
        // C s_2879_4: cast zx s_2879_3 -> i
        let s_2879_4: i128 = (i128::try_from(s_2879_3).unwrap());
        // C s_2879_5: const #2s : i
        let s_2879_5: i128 = 2;
        // C s_2879_6: add s_2879_5 s_2879_4
        let s_2879_6: i128 = (s_2879_5 + s_2879_4);
        // D s_2879_7: bit-extract s_2879_2 s_2879_0 s_2879_6
        let s_2879_7: Bits = (Bits::new(
            ((s_2879_2) >> (s_2879_0)).value(),
            u16::try_from(s_2879_6).unwrap(),
        ));
        // D s_2879_8: cast reint s_2879_7 -> u8
        let s_2879_8: u8 = (s_2879_7.value() as u8);
        // D s_2879_9: cast zx s_2879_8 -> bv
        let s_2879_9: Bits = Bits::new(s_2879_8 as u128, 3u16);
        // C s_2879_10: const #3u : u8
        let s_2879_10: u8 = 3;
        // C s_2879_11: cast zx s_2879_10 -> bv
        let s_2879_11: Bits = Bits::new(s_2879_10 as u128, 3u16);
        // D s_2879_12: cmp-eq s_2879_9 s_2879_11
        let s_2879_12: bool = ((s_2879_9) == (s_2879_11));
        // N s_2879_13: branch s_2879_12 b2882 b2880
        if s_2879_12 {
            return block_2882(state, tracer, fn_state);
        } else {
            return block_2880(state, tracer, fn_state);
        };
    }
    fn block_2880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2880_0: const #0u : u8
        let s_2880_0: bool = false;
        // D s_2880_1: write-var gs#398862 <= s_2880_0
        fn_state.gs_398862 = s_2880_0;
        // N s_2880_2: jump b2881
        return block_2881(state, tracer, fn_state);
    }
    fn block_2881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2881_0: read-var gs#398862:u8
        let s_2881_0: bool = fn_state.gs_398862;
        // D s_2881_1: write-var gs#398863 <= s_2881_0
        fn_state.gs_398863 = s_2881_0;
        // N s_2881_2: jump b2878
        return block_2878(state, tracer, fn_state);
    }
    fn block_2882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2882_0: const #4s : i
        let s_2882_0: i128 = 4;
        // D s_2882_1: read-var u#30873:u32
        let s_2882_1: u32 = fn_state.u_30873;
        // D s_2882_2: cast zx s_2882_1 -> bv
        let s_2882_2: Bits = Bits::new(s_2882_1 as u128, 32u16);
        // C s_2882_3: const #1s : i64
        let s_2882_3: i64 = 1;
        // C s_2882_4: cast zx s_2882_3 -> i
        let s_2882_4: i128 = (i128::try_from(s_2882_3).unwrap());
        // C s_2882_5: const #0s : i
        let s_2882_5: i128 = 0;
        // C s_2882_6: add s_2882_5 s_2882_4
        let s_2882_6: i128 = (s_2882_5 + s_2882_4);
        // D s_2882_7: bit-extract s_2882_2 s_2882_0 s_2882_6
        let s_2882_7: Bits = (Bits::new(
            ((s_2882_2) >> (s_2882_0)).value(),
            u16::try_from(s_2882_6).unwrap(),
        ));
        // D s_2882_8: cast reint s_2882_7 -> u8
        let s_2882_8: bool = ((s_2882_7.value()) != 0);
        // D s_2882_9: cast zx s_2882_8 -> bv
        let s_2882_9: Bits = Bits::new(s_2882_8 as u128, 1u16);
        // C s_2882_10: const #0u : u8
        let s_2882_10: bool = false;
        // C s_2882_11: cast zx s_2882_10 -> bv
        let s_2882_11: Bits = Bits::new(s_2882_10 as u128, 1u16);
        // D s_2882_12: cmp-eq s_2882_9 s_2882_11
        let s_2882_12: bool = ((s_2882_9) == (s_2882_11));
        // D s_2882_13: write-var gs#398862 <= s_2882_12
        fn_state.gs_398862 = s_2882_12;
        // N s_2882_14: jump b2881
        return block_2881(state, tracer, fn_state);
    }
    fn block_2883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2883_0: const #3422s : i
        let s_2883_0: i128 = 3422;
        // C s_2883_1: const #14696u : u32
        let s_2883_1: u32 = 14696;
        // D s_2883_2: read-reg s_2883_1:i
        let s_2883_2: i128 = {
            let value = state.read_register::<i128>(s_2883_1 as isize);
            tracer.read_register(s_2883_1 as isize, value);
            value
        };
        // D s_2883_3: cmp-lt s_2883_2 s_2883_0
        let s_2883_3: bool = ((s_2883_2) < (s_2883_0));
        // D s_2883_4: write-var gs#398836 <= s_2883_3
        fn_state.gs_398836 = s_2883_3;
        // N s_2883_5: jump b473
        return block_473(state, tracer, fn_state);
    }
    fn block_2884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2884_0: const #20s : i
        let s_2884_0: i128 = 20;
        // D s_2884_1: read-var u#30865:u32
        let s_2884_1: u32 = fn_state.u_30865;
        // D s_2884_2: cast zx s_2884_1 -> bv
        let s_2884_2: Bits = Bits::new(s_2884_1 as u128, 32u16);
        // C s_2884_3: const #1s : i64
        let s_2884_3: i64 = 1;
        // C s_2884_4: cast zx s_2884_3 -> i
        let s_2884_4: i128 = (i128::try_from(s_2884_3).unwrap());
        // C s_2884_5: const #1s : i
        let s_2884_5: i128 = 1;
        // C s_2884_6: add s_2884_5 s_2884_4
        let s_2884_6: i128 = (s_2884_5 + s_2884_4);
        // D s_2884_7: bit-extract s_2884_2 s_2884_0 s_2884_6
        let s_2884_7: Bits = (Bits::new(
            ((s_2884_2) >> (s_2884_0)).value(),
            u16::try_from(s_2884_6).unwrap(),
        ));
        // D s_2884_8: cast reint s_2884_7 -> u8
        let s_2884_8: u8 = (s_2884_7.value() as u8);
        // D s_2884_9: cast zx s_2884_8 -> bv
        let s_2884_9: Bits = Bits::new(s_2884_8 as u128, 2u16);
        // C s_2884_10: const #3u : u8
        let s_2884_10: u8 = 3;
        // C s_2884_11: cast zx s_2884_10 -> bv
        let s_2884_11: Bits = Bits::new(s_2884_10 as u128, 2u16);
        // D s_2884_12: cmp-eq s_2884_9 s_2884_11
        let s_2884_12: bool = ((s_2884_9) == (s_2884_11));
        // N s_2884_13: branch s_2884_12 b2887 b2885
        if s_2884_12 {
            return block_2887(state, tracer, fn_state);
        } else {
            return block_2885(state, tracer, fn_state);
        };
    }
    fn block_2885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2885_0: const #0u : u8
        let s_2885_0: bool = false;
        // D s_2885_1: write-var gs#398833 <= s_2885_0
        fn_state.gs_398833 = s_2885_0;
        // N s_2885_2: jump b2886
        return block_2886(state, tracer, fn_state);
    }
    fn block_2886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2886_0: read-var gs#398833:u8
        let s_2886_0: bool = fn_state.gs_398833;
        // D s_2886_1: write-var gs#398834 <= s_2886_0
        fn_state.gs_398834 = s_2886_0;
        // N s_2886_2: jump b471
        return block_471(state, tracer, fn_state);
    }
    fn block_2887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2887_0: const #16s : i
        let s_2887_0: i128 = 16;
        // D s_2887_1: read-var u#30865:u32
        let s_2887_1: u32 = fn_state.u_30865;
        // D s_2887_2: cast zx s_2887_1 -> bv
        let s_2887_2: Bits = Bits::new(s_2887_1 as u128, 32u16);
        // C s_2887_3: const #1s : i64
        let s_2887_3: i64 = 1;
        // C s_2887_4: cast zx s_2887_3 -> i
        let s_2887_4: i128 = (i128::try_from(s_2887_3).unwrap());
        // C s_2887_5: const #1s : i
        let s_2887_5: i128 = 1;
        // C s_2887_6: add s_2887_5 s_2887_4
        let s_2887_6: i128 = (s_2887_5 + s_2887_4);
        // D s_2887_7: bit-extract s_2887_2 s_2887_0 s_2887_6
        let s_2887_7: Bits = (Bits::new(
            ((s_2887_2) >> (s_2887_0)).value(),
            u16::try_from(s_2887_6).unwrap(),
        ));
        // D s_2887_8: cast reint s_2887_7 -> u8
        let s_2887_8: u8 = (s_2887_7.value() as u8);
        // D s_2887_9: cast zx s_2887_8 -> bv
        let s_2887_9: Bits = Bits::new(s_2887_8 as u128, 2u16);
        // C s_2887_10: const #2u : u8
        let s_2887_10: u8 = 2;
        // C s_2887_11: cast zx s_2887_10 -> bv
        let s_2887_11: Bits = Bits::new(s_2887_10 as u128, 2u16);
        // D s_2887_12: cmp-eq s_2887_9 s_2887_11
        let s_2887_12: bool = ((s_2887_9) == (s_2887_11));
        // N s_2887_13: branch s_2887_12 b2890 b2888
        if s_2887_12 {
            return block_2890(state, tracer, fn_state);
        } else {
            return block_2888(state, tracer, fn_state);
        };
    }
    fn block_2888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2888_0: const #0u : u8
        let s_2888_0: bool = false;
        // D s_2888_1: write-var gs#398832 <= s_2888_0
        fn_state.gs_398832 = s_2888_0;
        // N s_2888_2: jump b2889
        return block_2889(state, tracer, fn_state);
    }
    fn block_2889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2889_0: read-var gs#398832:u8
        let s_2889_0: bool = fn_state.gs_398832;
        // D s_2889_1: write-var gs#398833 <= s_2889_0
        fn_state.gs_398833 = s_2889_0;
        // N s_2889_2: jump b2886
        return block_2886(state, tracer, fn_state);
    }
    fn block_2890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2890_0: const #9s : i
        let s_2890_0: i128 = 9;
        // D s_2890_1: read-var u#30865:u32
        let s_2890_1: u32 = fn_state.u_30865;
        // D s_2890_2: cast zx s_2890_1 -> bv
        let s_2890_2: Bits = Bits::new(s_2890_1 as u128, 32u16);
        // C s_2890_3: const #1s : i64
        let s_2890_3: i64 = 1;
        // C s_2890_4: cast zx s_2890_3 -> i
        let s_2890_4: i128 = (i128::try_from(s_2890_3).unwrap());
        // C s_2890_5: const #2s : i
        let s_2890_5: i128 = 2;
        // C s_2890_6: add s_2890_5 s_2890_4
        let s_2890_6: i128 = (s_2890_5 + s_2890_4);
        // D s_2890_7: bit-extract s_2890_2 s_2890_0 s_2890_6
        let s_2890_7: Bits = (Bits::new(
            ((s_2890_2) >> (s_2890_0)).value(),
            u16::try_from(s_2890_6).unwrap(),
        ));
        // D s_2890_8: cast reint s_2890_7 -> u8
        let s_2890_8: u8 = (s_2890_7.value() as u8);
        // D s_2890_9: cast zx s_2890_8 -> bv
        let s_2890_9: Bits = Bits::new(s_2890_8 as u128, 3u16);
        // C s_2890_10: const #3u : u8
        let s_2890_10: u8 = 3;
        // C s_2890_11: cast zx s_2890_10 -> bv
        let s_2890_11: Bits = Bits::new(s_2890_10 as u128, 3u16);
        // D s_2890_12: cmp-eq s_2890_9 s_2890_11
        let s_2890_12: bool = ((s_2890_9) == (s_2890_11));
        // N s_2890_13: branch s_2890_12 b2893 b2891
        if s_2890_12 {
            return block_2893(state, tracer, fn_state);
        } else {
            return block_2891(state, tracer, fn_state);
        };
    }
    fn block_2891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2891_0: const #0u : u8
        let s_2891_0: bool = false;
        // D s_2891_1: write-var gs#398831 <= s_2891_0
        fn_state.gs_398831 = s_2891_0;
        // N s_2891_2: jump b2892
        return block_2892(state, tracer, fn_state);
    }
    fn block_2892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2892_0: read-var gs#398831:u8
        let s_2892_0: bool = fn_state.gs_398831;
        // D s_2892_1: write-var gs#398832 <= s_2892_0
        fn_state.gs_398832 = s_2892_0;
        // N s_2892_2: jump b2889
        return block_2889(state, tracer, fn_state);
    }
    fn block_2893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2893_0: const #6s : i
        let s_2893_0: i128 = 6;
        // D s_2893_1: read-var u#30865:u32
        let s_2893_1: u32 = fn_state.u_30865;
        // D s_2893_2: cast zx s_2893_1 -> bv
        let s_2893_2: Bits = Bits::new(s_2893_1 as u128, 32u16);
        // C s_2893_3: const #1s : i64
        let s_2893_3: i64 = 1;
        // C s_2893_4: cast zx s_2893_3 -> i
        let s_2893_4: i128 = (i128::try_from(s_2893_3).unwrap());
        // C s_2893_5: const #1s : i
        let s_2893_5: i128 = 1;
        // C s_2893_6: add s_2893_5 s_2893_4
        let s_2893_6: i128 = (s_2893_5 + s_2893_4);
        // D s_2893_7: bit-extract s_2893_2 s_2893_0 s_2893_6
        let s_2893_7: Bits = (Bits::new(
            ((s_2893_2) >> (s_2893_0)).value(),
            u16::try_from(s_2893_6).unwrap(),
        ));
        // D s_2893_8: cast reint s_2893_7 -> u8
        let s_2893_8: u8 = (s_2893_7.value() as u8);
        // D s_2893_9: cast zx s_2893_8 -> bv
        let s_2893_9: Bits = Bits::new(s_2893_8 as u128, 2u16);
        // C s_2893_10: const #0u : u8
        let s_2893_10: u8 = 0;
        // C s_2893_11: cast zx s_2893_10 -> bv
        let s_2893_11: Bits = Bits::new(s_2893_10 as u128, 2u16);
        // D s_2893_12: cmp-eq s_2893_9 s_2893_11
        let s_2893_12: bool = ((s_2893_9) == (s_2893_11));
        // N s_2893_13: branch s_2893_12 b2896 b2894
        if s_2893_12 {
            return block_2896(state, tracer, fn_state);
        } else {
            return block_2894(state, tracer, fn_state);
        };
    }
    fn block_2894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2894_0: const #0u : u8
        let s_2894_0: bool = false;
        // D s_2894_1: write-var gs#398830 <= s_2894_0
        fn_state.gs_398830 = s_2894_0;
        // N s_2894_2: jump b2895
        return block_2895(state, tracer, fn_state);
    }
    fn block_2895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2895_0: read-var gs#398830:u8
        let s_2895_0: bool = fn_state.gs_398830;
        // D s_2895_1: write-var gs#398831 <= s_2895_0
        fn_state.gs_398831 = s_2895_0;
        // N s_2895_2: jump b2892
        return block_2892(state, tracer, fn_state);
    }
    fn block_2896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2896_0: const #4s : i
        let s_2896_0: i128 = 4;
        // D s_2896_1: read-var u#30865:u32
        let s_2896_1: u32 = fn_state.u_30865;
        // D s_2896_2: cast zx s_2896_1 -> bv
        let s_2896_2: Bits = Bits::new(s_2896_1 as u128, 32u16);
        // C s_2896_3: const #1s : i64
        let s_2896_3: i64 = 1;
        // C s_2896_4: cast zx s_2896_3 -> i
        let s_2896_4: i128 = (i128::try_from(s_2896_3).unwrap());
        // C s_2896_5: const #0s : i
        let s_2896_5: i128 = 0;
        // C s_2896_6: add s_2896_5 s_2896_4
        let s_2896_6: i128 = (s_2896_5 + s_2896_4);
        // D s_2896_7: bit-extract s_2896_2 s_2896_0 s_2896_6
        let s_2896_7: Bits = (Bits::new(
            ((s_2896_2) >> (s_2896_0)).value(),
            u16::try_from(s_2896_6).unwrap(),
        ));
        // D s_2896_8: cast reint s_2896_7 -> u8
        let s_2896_8: bool = ((s_2896_7.value()) != 0);
        // D s_2896_9: cast zx s_2896_8 -> bv
        let s_2896_9: Bits = Bits::new(s_2896_8 as u128, 1u16);
        // C s_2896_10: const #0u : u8
        let s_2896_10: bool = false;
        // C s_2896_11: cast zx s_2896_10 -> bv
        let s_2896_11: Bits = Bits::new(s_2896_10 as u128, 1u16);
        // D s_2896_12: cmp-eq s_2896_9 s_2896_11
        let s_2896_12: bool = ((s_2896_9) == (s_2896_11));
        // D s_2896_13: write-var gs#398830 <= s_2896_12
        fn_state.gs_398830 = s_2896_12;
        // N s_2896_14: jump b2895
        return block_2895(state, tracer, fn_state);
    }
    fn block_2897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2897_0: const #3416s : i
        let s_2897_0: i128 = 3416;
        // C s_2897_1: const #14696u : u32
        let s_2897_1: u32 = 14696;
        // D s_2897_2: read-reg s_2897_1:i
        let s_2897_2: i128 = {
            let value = state.read_register::<i128>(s_2897_1 as isize);
            tracer.read_register(s_2897_1 as isize, value);
            value
        };
        // D s_2897_3: cmp-lt s_2897_2 s_2897_0
        let s_2897_3: bool = ((s_2897_2) < (s_2897_0));
        // D s_2897_4: write-var gs#398802 <= s_2897_3
        fn_state.gs_398802 = s_2897_3;
        // N s_2897_5: jump b467
        return block_467(state, tracer, fn_state);
    }
    fn block_2898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2898_0: const #20s : i
        let s_2898_0: i128 = 20;
        // D s_2898_1: read-var u#30857:u32
        let s_2898_1: u32 = fn_state.u_30857;
        // D s_2898_2: cast zx s_2898_1 -> bv
        let s_2898_2: Bits = Bits::new(s_2898_1 as u128, 32u16);
        // C s_2898_3: const #1s : i64
        let s_2898_3: i64 = 1;
        // C s_2898_4: cast zx s_2898_3 -> i
        let s_2898_4: i128 = (i128::try_from(s_2898_3).unwrap());
        // C s_2898_5: const #1s : i
        let s_2898_5: i128 = 1;
        // C s_2898_6: add s_2898_5 s_2898_4
        let s_2898_6: i128 = (s_2898_5 + s_2898_4);
        // D s_2898_7: bit-extract s_2898_2 s_2898_0 s_2898_6
        let s_2898_7: Bits = (Bits::new(
            ((s_2898_2) >> (s_2898_0)).value(),
            u16::try_from(s_2898_6).unwrap(),
        ));
        // D s_2898_8: cast reint s_2898_7 -> u8
        let s_2898_8: u8 = (s_2898_7.value() as u8);
        // D s_2898_9: cast zx s_2898_8 -> bv
        let s_2898_9: Bits = Bits::new(s_2898_8 as u128, 2u16);
        // C s_2898_10: const #3u : u8
        let s_2898_10: u8 = 3;
        // C s_2898_11: cast zx s_2898_10 -> bv
        let s_2898_11: Bits = Bits::new(s_2898_10 as u128, 2u16);
        // D s_2898_12: cmp-eq s_2898_9 s_2898_11
        let s_2898_12: bool = ((s_2898_9) == (s_2898_11));
        // N s_2898_13: branch s_2898_12 b2901 b2899
        if s_2898_12 {
            return block_2901(state, tracer, fn_state);
        } else {
            return block_2899(state, tracer, fn_state);
        };
    }
    fn block_2899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2899_0: const #0u : u8
        let s_2899_0: bool = false;
        // D s_2899_1: write-var gs#398799 <= s_2899_0
        fn_state.gs_398799 = s_2899_0;
        // N s_2899_2: jump b2900
        return block_2900(state, tracer, fn_state);
    }
    fn block_2900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2900_0: read-var gs#398799:u8
        let s_2900_0: bool = fn_state.gs_398799;
        // D s_2900_1: write-var gs#398800 <= s_2900_0
        fn_state.gs_398800 = s_2900_0;
        // N s_2900_2: jump b465
        return block_465(state, tracer, fn_state);
    }
    fn block_2901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2901_0: const #16s : i
        let s_2901_0: i128 = 16;
        // D s_2901_1: read-var u#30857:u32
        let s_2901_1: u32 = fn_state.u_30857;
        // D s_2901_2: cast zx s_2901_1 -> bv
        let s_2901_2: Bits = Bits::new(s_2901_1 as u128, 32u16);
        // C s_2901_3: const #1s : i64
        let s_2901_3: i64 = 1;
        // C s_2901_4: cast zx s_2901_3 -> i
        let s_2901_4: i128 = (i128::try_from(s_2901_3).unwrap());
        // C s_2901_5: const #1s : i
        let s_2901_5: i128 = 1;
        // C s_2901_6: add s_2901_5 s_2901_4
        let s_2901_6: i128 = (s_2901_5 + s_2901_4);
        // D s_2901_7: bit-extract s_2901_2 s_2901_0 s_2901_6
        let s_2901_7: Bits = (Bits::new(
            ((s_2901_2) >> (s_2901_0)).value(),
            u16::try_from(s_2901_6).unwrap(),
        ));
        // D s_2901_8: cast reint s_2901_7 -> u8
        let s_2901_8: u8 = (s_2901_7.value() as u8);
        // D s_2901_9: cast zx s_2901_8 -> bv
        let s_2901_9: Bits = Bits::new(s_2901_8 as u128, 2u16);
        // C s_2901_10: const #0u : u8
        let s_2901_10: u8 = 0;
        // C s_2901_11: cast zx s_2901_10 -> bv
        let s_2901_11: Bits = Bits::new(s_2901_10 as u128, 2u16);
        // D s_2901_12: cmp-eq s_2901_9 s_2901_11
        let s_2901_12: bool = ((s_2901_9) == (s_2901_11));
        // N s_2901_13: branch s_2901_12 b2904 b2902
        if s_2901_12 {
            return block_2904(state, tracer, fn_state);
        } else {
            return block_2902(state, tracer, fn_state);
        };
    }
    fn block_2902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2902_0: const #0u : u8
        let s_2902_0: bool = false;
        // D s_2902_1: write-var gs#398798 <= s_2902_0
        fn_state.gs_398798 = s_2902_0;
        // N s_2902_2: jump b2903
        return block_2903(state, tracer, fn_state);
    }
    fn block_2903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2903_0: read-var gs#398798:u8
        let s_2903_0: bool = fn_state.gs_398798;
        // D s_2903_1: write-var gs#398799 <= s_2903_0
        fn_state.gs_398799 = s_2903_0;
        // N s_2903_2: jump b2900
        return block_2900(state, tracer, fn_state);
    }
    fn block_2904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2904_0: const #7s : i
        let s_2904_0: i128 = 7;
        // D s_2904_1: read-var u#30857:u32
        let s_2904_1: u32 = fn_state.u_30857;
        // D s_2904_2: cast zx s_2904_1 -> bv
        let s_2904_2: Bits = Bits::new(s_2904_1 as u128, 32u16);
        // C s_2904_3: const #1s : i64
        let s_2904_3: i64 = 1;
        // C s_2904_4: cast zx s_2904_3 -> i
        let s_2904_4: i128 = (i128::try_from(s_2904_3).unwrap());
        // C s_2904_5: const #4s : i
        let s_2904_5: i128 = 4;
        // C s_2904_6: add s_2904_5 s_2904_4
        let s_2904_6: i128 = (s_2904_5 + s_2904_4);
        // D s_2904_7: bit-extract s_2904_2 s_2904_0 s_2904_6
        let s_2904_7: Bits = (Bits::new(
            ((s_2904_2) >> (s_2904_0)).value(),
            u16::try_from(s_2904_6).unwrap(),
        ));
        // D s_2904_8: cast reint s_2904_7 -> u8
        let s_2904_8: u8 = (s_2904_7.value() as u8);
        // D s_2904_9: cast zx s_2904_8 -> bv
        let s_2904_9: Bits = Bits::new(s_2904_8 as u128, 5u16);
        // C s_2904_10: const #10u : u8
        let s_2904_10: u8 = 10;
        // C s_2904_11: cast zx s_2904_10 -> bv
        let s_2904_11: Bits = Bits::new(s_2904_10 as u128, 5u16);
        // D s_2904_12: cmp-eq s_2904_9 s_2904_11
        let s_2904_12: bool = ((s_2904_9) == (s_2904_11));
        // N s_2904_13: branch s_2904_12 b2907 b2905
        if s_2904_12 {
            return block_2907(state, tracer, fn_state);
        } else {
            return block_2905(state, tracer, fn_state);
        };
    }
    fn block_2905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2905_0: const #0u : u8
        let s_2905_0: bool = false;
        // D s_2905_1: write-var gs#398797 <= s_2905_0
        fn_state.gs_398797 = s_2905_0;
        // N s_2905_2: jump b2906
        return block_2906(state, tracer, fn_state);
    }
    fn block_2906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2906_0: read-var gs#398797:u8
        let s_2906_0: bool = fn_state.gs_398797;
        // D s_2906_1: write-var gs#398798 <= s_2906_0
        fn_state.gs_398798 = s_2906_0;
        // N s_2906_2: jump b2903
        return block_2903(state, tracer, fn_state);
    }
    fn block_2907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2907_0: const #4s : i
        let s_2907_0: i128 = 4;
        // D s_2907_1: read-var u#30857:u32
        let s_2907_1: u32 = fn_state.u_30857;
        // D s_2907_2: cast zx s_2907_1 -> bv
        let s_2907_2: Bits = Bits::new(s_2907_1 as u128, 32u16);
        // C s_2907_3: const #1s : i64
        let s_2907_3: i64 = 1;
        // C s_2907_4: cast zx s_2907_3 -> i
        let s_2907_4: i128 = (i128::try_from(s_2907_3).unwrap());
        // C s_2907_5: const #0s : i
        let s_2907_5: i128 = 0;
        // C s_2907_6: add s_2907_5 s_2907_4
        let s_2907_6: i128 = (s_2907_5 + s_2907_4);
        // D s_2907_7: bit-extract s_2907_2 s_2907_0 s_2907_6
        let s_2907_7: Bits = (Bits::new(
            ((s_2907_2) >> (s_2907_0)).value(),
            u16::try_from(s_2907_6).unwrap(),
        ));
        // D s_2907_8: cast reint s_2907_7 -> u8
        let s_2907_8: bool = ((s_2907_7.value()) != 0);
        // D s_2907_9: cast zx s_2907_8 -> bv
        let s_2907_9: Bits = Bits::new(s_2907_8 as u128, 1u16);
        // C s_2907_10: const #0u : u8
        let s_2907_10: bool = false;
        // C s_2907_11: cast zx s_2907_10 -> bv
        let s_2907_11: Bits = Bits::new(s_2907_10 as u128, 1u16);
        // D s_2907_12: cmp-eq s_2907_9 s_2907_11
        let s_2907_12: bool = ((s_2907_9) == (s_2907_11));
        // D s_2907_13: write-var gs#398797 <= s_2907_12
        fn_state.gs_398797 = s_2907_12;
        // N s_2907_14: jump b2906
        return block_2906(state, tracer, fn_state);
    }
    fn block_2908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2908_0: const #3410s : i
        let s_2908_0: i128 = 3410;
        // C s_2908_1: const #14696u : u32
        let s_2908_1: u32 = 14696;
        // D s_2908_2: read-reg s_2908_1:i
        let s_2908_2: i128 = {
            let value = state.read_register::<i128>(s_2908_1 as isize);
            tracer.read_register(s_2908_1 as isize, value);
            value
        };
        // D s_2908_3: cmp-lt s_2908_2 s_2908_0
        let s_2908_3: bool = ((s_2908_2) < (s_2908_0));
        // D s_2908_4: write-var gs#398771 <= s_2908_3
        fn_state.gs_398771 = s_2908_3;
        // N s_2908_5: jump b461
        return block_461(state, tracer, fn_state);
    }
    fn block_2909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2909_0: const #20s : i
        let s_2909_0: i128 = 20;
        // D s_2909_1: read-var u#30849:u32
        let s_2909_1: u32 = fn_state.u_30849;
        // D s_2909_2: cast zx s_2909_1 -> bv
        let s_2909_2: Bits = Bits::new(s_2909_1 as u128, 32u16);
        // C s_2909_3: const #1s : i64
        let s_2909_3: i64 = 1;
        // C s_2909_4: cast zx s_2909_3 -> i
        let s_2909_4: i128 = (i128::try_from(s_2909_3).unwrap());
        // C s_2909_5: const #1s : i
        let s_2909_5: i128 = 1;
        // C s_2909_6: add s_2909_5 s_2909_4
        let s_2909_6: i128 = (s_2909_5 + s_2909_4);
        // D s_2909_7: bit-extract s_2909_2 s_2909_0 s_2909_6
        let s_2909_7: Bits = (Bits::new(
            ((s_2909_2) >> (s_2909_0)).value(),
            u16::try_from(s_2909_6).unwrap(),
        ));
        // D s_2909_8: cast reint s_2909_7 -> u8
        let s_2909_8: u8 = (s_2909_7.value() as u8);
        // D s_2909_9: cast zx s_2909_8 -> bv
        let s_2909_9: Bits = Bits::new(s_2909_8 as u128, 2u16);
        // C s_2909_10: const #3u : u8
        let s_2909_10: u8 = 3;
        // C s_2909_11: cast zx s_2909_10 -> bv
        let s_2909_11: Bits = Bits::new(s_2909_10 as u128, 2u16);
        // D s_2909_12: cmp-eq s_2909_9 s_2909_11
        let s_2909_12: bool = ((s_2909_9) == (s_2909_11));
        // N s_2909_13: branch s_2909_12 b2912 b2910
        if s_2909_12 {
            return block_2912(state, tracer, fn_state);
        } else {
            return block_2910(state, tracer, fn_state);
        };
    }
    fn block_2910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2910_0: const #0u : u8
        let s_2910_0: bool = false;
        // D s_2910_1: write-var gs#398768 <= s_2910_0
        fn_state.gs_398768 = s_2910_0;
        // N s_2910_2: jump b2911
        return block_2911(state, tracer, fn_state);
    }
    fn block_2911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2911_0: read-var gs#398768:u8
        let s_2911_0: bool = fn_state.gs_398768;
        // D s_2911_1: write-var gs#398769 <= s_2911_0
        fn_state.gs_398769 = s_2911_0;
        // N s_2911_2: jump b459
        return block_459(state, tracer, fn_state);
    }
    fn block_2912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2912_0: const #16s : i
        let s_2912_0: i128 = 16;
        // D s_2912_1: read-var u#30849:u32
        let s_2912_1: u32 = fn_state.u_30849;
        // D s_2912_2: cast zx s_2912_1 -> bv
        let s_2912_2: Bits = Bits::new(s_2912_1 as u128, 32u16);
        // C s_2912_3: const #1s : i64
        let s_2912_3: i64 = 1;
        // C s_2912_4: cast zx s_2912_3 -> i
        let s_2912_4: i128 = (i128::try_from(s_2912_3).unwrap());
        // C s_2912_5: const #1s : i
        let s_2912_5: i128 = 1;
        // C s_2912_6: add s_2912_5 s_2912_4
        let s_2912_6: i128 = (s_2912_5 + s_2912_4);
        // D s_2912_7: bit-extract s_2912_2 s_2912_0 s_2912_6
        let s_2912_7: Bits = (Bits::new(
            ((s_2912_2) >> (s_2912_0)).value(),
            u16::try_from(s_2912_6).unwrap(),
        ));
        // D s_2912_8: cast reint s_2912_7 -> u8
        let s_2912_8: u8 = (s_2912_7.value() as u8);
        // D s_2912_9: cast zx s_2912_8 -> bv
        let s_2912_9: Bits = Bits::new(s_2912_8 as u128, 2u16);
        // C s_2912_10: const #0u : u8
        let s_2912_10: u8 = 0;
        // C s_2912_11: cast zx s_2912_10 -> bv
        let s_2912_11: Bits = Bits::new(s_2912_10 as u128, 2u16);
        // D s_2912_12: cmp-eq s_2912_9 s_2912_11
        let s_2912_12: bool = ((s_2912_9) == (s_2912_11));
        // N s_2912_13: branch s_2912_12 b2915 b2913
        if s_2912_12 {
            return block_2915(state, tracer, fn_state);
        } else {
            return block_2913(state, tracer, fn_state);
        };
    }
    fn block_2913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2913_0: const #0u : u8
        let s_2913_0: bool = false;
        // D s_2913_1: write-var gs#398767 <= s_2913_0
        fn_state.gs_398767 = s_2913_0;
        // N s_2913_2: jump b2914
        return block_2914(state, tracer, fn_state);
    }
    fn block_2914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2914_0: read-var gs#398767:u8
        let s_2914_0: bool = fn_state.gs_398767;
        // D s_2914_1: write-var gs#398768 <= s_2914_0
        fn_state.gs_398768 = s_2914_0;
        // N s_2914_2: jump b2911
        return block_2911(state, tracer, fn_state);
    }
    fn block_2915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2915_0: const #7s : i
        let s_2915_0: i128 = 7;
        // D s_2915_1: read-var u#30849:u32
        let s_2915_1: u32 = fn_state.u_30849;
        // D s_2915_2: cast zx s_2915_1 -> bv
        let s_2915_2: Bits = Bits::new(s_2915_1 as u128, 32u16);
        // C s_2915_3: const #1s : i64
        let s_2915_3: i64 = 1;
        // C s_2915_4: cast zx s_2915_3 -> i
        let s_2915_4: i128 = (i128::try_from(s_2915_3).unwrap());
        // C s_2915_5: const #4s : i
        let s_2915_5: i128 = 4;
        // C s_2915_6: add s_2915_5 s_2915_4
        let s_2915_6: i128 = (s_2915_5 + s_2915_4);
        // D s_2915_7: bit-extract s_2915_2 s_2915_0 s_2915_6
        let s_2915_7: Bits = (Bits::new(
            ((s_2915_2) >> (s_2915_0)).value(),
            u16::try_from(s_2915_6).unwrap(),
        ));
        // D s_2915_8: cast reint s_2915_7 -> u8
        let s_2915_8: u8 = (s_2915_7.value() as u8);
        // D s_2915_9: cast zx s_2915_8 -> bv
        let s_2915_9: Bits = Bits::new(s_2915_8 as u128, 5u16);
        // C s_2915_10: const #9u : u8
        let s_2915_10: u8 = 9;
        // C s_2915_11: cast zx s_2915_10 -> bv
        let s_2915_11: Bits = Bits::new(s_2915_10 as u128, 5u16);
        // D s_2915_12: cmp-eq s_2915_9 s_2915_11
        let s_2915_12: bool = ((s_2915_9) == (s_2915_11));
        // N s_2915_13: branch s_2915_12 b2918 b2916
        if s_2915_12 {
            return block_2918(state, tracer, fn_state);
        } else {
            return block_2916(state, tracer, fn_state);
        };
    }
    fn block_2916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2916_0: const #0u : u8
        let s_2916_0: bool = false;
        // D s_2916_1: write-var gs#398766 <= s_2916_0
        fn_state.gs_398766 = s_2916_0;
        // N s_2916_2: jump b2917
        return block_2917(state, tracer, fn_state);
    }
    fn block_2917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2917_0: read-var gs#398766:u8
        let s_2917_0: bool = fn_state.gs_398766;
        // D s_2917_1: write-var gs#398767 <= s_2917_0
        fn_state.gs_398767 = s_2917_0;
        // N s_2917_2: jump b2914
        return block_2914(state, tracer, fn_state);
    }
    fn block_2918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2918_0: const #4s : i
        let s_2918_0: i128 = 4;
        // D s_2918_1: read-var u#30849:u32
        let s_2918_1: u32 = fn_state.u_30849;
        // D s_2918_2: cast zx s_2918_1 -> bv
        let s_2918_2: Bits = Bits::new(s_2918_1 as u128, 32u16);
        // C s_2918_3: const #1s : i64
        let s_2918_3: i64 = 1;
        // C s_2918_4: cast zx s_2918_3 -> i
        let s_2918_4: i128 = (i128::try_from(s_2918_3).unwrap());
        // C s_2918_5: const #0s : i
        let s_2918_5: i128 = 0;
        // C s_2918_6: add s_2918_5 s_2918_4
        let s_2918_6: i128 = (s_2918_5 + s_2918_4);
        // D s_2918_7: bit-extract s_2918_2 s_2918_0 s_2918_6
        let s_2918_7: Bits = (Bits::new(
            ((s_2918_2) >> (s_2918_0)).value(),
            u16::try_from(s_2918_6).unwrap(),
        ));
        // D s_2918_8: cast reint s_2918_7 -> u8
        let s_2918_8: bool = ((s_2918_7.value()) != 0);
        // D s_2918_9: cast zx s_2918_8 -> bv
        let s_2918_9: Bits = Bits::new(s_2918_8 as u128, 1u16);
        // C s_2918_10: const #0u : u8
        let s_2918_10: bool = false;
        // C s_2918_11: cast zx s_2918_10 -> bv
        let s_2918_11: Bits = Bits::new(s_2918_10 as u128, 1u16);
        // D s_2918_12: cmp-eq s_2918_9 s_2918_11
        let s_2918_12: bool = ((s_2918_9) == (s_2918_11));
        // D s_2918_13: write-var gs#398766 <= s_2918_12
        fn_state.gs_398766 = s_2918_12;
        // N s_2918_14: jump b2917
        return block_2917(state, tracer, fn_state);
    }
    fn block_2919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2919_0: const #3408s : i
        let s_2919_0: i128 = 3408;
        // C s_2919_1: const #14696u : u32
        let s_2919_1: u32 = 14696;
        // D s_2919_2: read-reg s_2919_1:i
        let s_2919_2: i128 = {
            let value = state.read_register::<i128>(s_2919_1 as isize);
            tracer.read_register(s_2919_1 as isize, value);
            value
        };
        // D s_2919_3: cmp-lt s_2919_2 s_2919_0
        let s_2919_3: bool = ((s_2919_2) < (s_2919_0));
        // D s_2919_4: write-var gs#398738 <= s_2919_3
        fn_state.gs_398738 = s_2919_3;
        // N s_2919_5: jump b455
        return block_455(state, tracer, fn_state);
    }
    fn block_2920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2920_0: const #20s : i
        let s_2920_0: i128 = 20;
        // D s_2920_1: read-var u#30840:u32
        let s_2920_1: u32 = fn_state.u_30840;
        // D s_2920_2: cast zx s_2920_1 -> bv
        let s_2920_2: Bits = Bits::new(s_2920_1 as u128, 32u16);
        // C s_2920_3: const #1s : i64
        let s_2920_3: i64 = 1;
        // C s_2920_4: cast zx s_2920_3 -> i
        let s_2920_4: i128 = (i128::try_from(s_2920_3).unwrap());
        // C s_2920_5: const #1s : i
        let s_2920_5: i128 = 1;
        // C s_2920_6: add s_2920_5 s_2920_4
        let s_2920_6: i128 = (s_2920_5 + s_2920_4);
        // D s_2920_7: bit-extract s_2920_2 s_2920_0 s_2920_6
        let s_2920_7: Bits = (Bits::new(
            ((s_2920_2) >> (s_2920_0)).value(),
            u16::try_from(s_2920_6).unwrap(),
        ));
        // D s_2920_8: cast reint s_2920_7 -> u8
        let s_2920_8: u8 = (s_2920_7.value() as u8);
        // D s_2920_9: cast zx s_2920_8 -> bv
        let s_2920_9: Bits = Bits::new(s_2920_8 as u128, 2u16);
        // C s_2920_10: const #3u : u8
        let s_2920_10: u8 = 3;
        // C s_2920_11: cast zx s_2920_10 -> bv
        let s_2920_11: Bits = Bits::new(s_2920_10 as u128, 2u16);
        // D s_2920_12: cmp-eq s_2920_9 s_2920_11
        let s_2920_12: bool = ((s_2920_9) == (s_2920_11));
        // N s_2920_13: branch s_2920_12 b2923 b2921
        if s_2920_12 {
            return block_2923(state, tracer, fn_state);
        } else {
            return block_2921(state, tracer, fn_state);
        };
    }
    fn block_2921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2921_0: const #0u : u8
        let s_2921_0: bool = false;
        // D s_2921_1: write-var gs#398735 <= s_2921_0
        fn_state.gs_398735 = s_2921_0;
        // N s_2921_2: jump b2922
        return block_2922(state, tracer, fn_state);
    }
    fn block_2922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2922_0: read-var gs#398735:u8
        let s_2922_0: bool = fn_state.gs_398735;
        // D s_2922_1: write-var gs#398736 <= s_2922_0
        fn_state.gs_398736 = s_2922_0;
        // N s_2922_2: jump b453
        return block_453(state, tracer, fn_state);
    }
    fn block_2923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2923_0: const #16s : i
        let s_2923_0: i128 = 16;
        // D s_2923_1: read-var u#30840:u32
        let s_2923_1: u32 = fn_state.u_30840;
        // D s_2923_2: cast zx s_2923_1 -> bv
        let s_2923_2: Bits = Bits::new(s_2923_1 as u128, 32u16);
        // C s_2923_3: const #1s : i64
        let s_2923_3: i64 = 1;
        // C s_2923_4: cast zx s_2923_3 -> i
        let s_2923_4: i128 = (i128::try_from(s_2923_3).unwrap());
        // C s_2923_5: const #1s : i
        let s_2923_5: i128 = 1;
        // C s_2923_6: add s_2923_5 s_2923_4
        let s_2923_6: i128 = (s_2923_5 + s_2923_4);
        // D s_2923_7: bit-extract s_2923_2 s_2923_0 s_2923_6
        let s_2923_7: Bits = (Bits::new(
            ((s_2923_2) >> (s_2923_0)).value(),
            u16::try_from(s_2923_6).unwrap(),
        ));
        // D s_2923_8: cast reint s_2923_7 -> u8
        let s_2923_8: u8 = (s_2923_7.value() as u8);
        // D s_2923_9: cast zx s_2923_8 -> bv
        let s_2923_9: Bits = Bits::new(s_2923_8 as u128, 2u16);
        // C s_2923_10: const #1u : u8
        let s_2923_10: u8 = 1;
        // C s_2923_11: cast zx s_2923_10 -> bv
        let s_2923_11: Bits = Bits::new(s_2923_10 as u128, 2u16);
        // D s_2923_12: cmp-eq s_2923_9 s_2923_11
        let s_2923_12: bool = ((s_2923_9) == (s_2923_11));
        // N s_2923_13: branch s_2923_12 b2926 b2924
        if s_2923_12 {
            return block_2926(state, tracer, fn_state);
        } else {
            return block_2924(state, tracer, fn_state);
        };
    }
    fn block_2924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2924_0: const #0u : u8
        let s_2924_0: bool = false;
        // D s_2924_1: write-var gs#398734 <= s_2924_0
        fn_state.gs_398734 = s_2924_0;
        // N s_2924_2: jump b2925
        return block_2925(state, tracer, fn_state);
    }
    fn block_2925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2925_0: read-var gs#398734:u8
        let s_2925_0: bool = fn_state.gs_398734;
        // D s_2925_1: write-var gs#398735 <= s_2925_0
        fn_state.gs_398735 = s_2925_0;
        // N s_2925_2: jump b2922
        return block_2922(state, tracer, fn_state);
    }
    fn block_2926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2926_0: const #11s : i
        let s_2926_0: i128 = 11;
        // D s_2926_1: read-var u#30840:u32
        let s_2926_1: u32 = fn_state.u_30840;
        // D s_2926_2: cast zx s_2926_1 -> bv
        let s_2926_2: Bits = Bits::new(s_2926_1 as u128, 32u16);
        // C s_2926_3: const #1s : i64
        let s_2926_3: i64 = 1;
        // C s_2926_4: cast zx s_2926_3 -> i
        let s_2926_4: i128 = (i128::try_from(s_2926_3).unwrap());
        // C s_2926_5: const #0s : i
        let s_2926_5: i128 = 0;
        // C s_2926_6: add s_2926_5 s_2926_4
        let s_2926_6: i128 = (s_2926_5 + s_2926_4);
        // D s_2926_7: bit-extract s_2926_2 s_2926_0 s_2926_6
        let s_2926_7: Bits = (Bits::new(
            ((s_2926_2) >> (s_2926_0)).value(),
            u16::try_from(s_2926_6).unwrap(),
        ));
        // D s_2926_8: cast reint s_2926_7 -> u8
        let s_2926_8: bool = ((s_2926_7.value()) != 0);
        // D s_2926_9: cast zx s_2926_8 -> bv
        let s_2926_9: Bits = Bits::new(s_2926_8 as u128, 1u16);
        // C s_2926_10: const #0u : u8
        let s_2926_10: bool = false;
        // C s_2926_11: cast zx s_2926_10 -> bv
        let s_2926_11: Bits = Bits::new(s_2926_10 as u128, 1u16);
        // D s_2926_12: cmp-eq s_2926_9 s_2926_11
        let s_2926_12: bool = ((s_2926_9) == (s_2926_11));
        // N s_2926_13: branch s_2926_12 b2929 b2927
        if s_2926_12 {
            return block_2929(state, tracer, fn_state);
        } else {
            return block_2927(state, tracer, fn_state);
        };
    }
    fn block_2927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2927_0: const #0u : u8
        let s_2927_0: bool = false;
        // D s_2927_1: write-var gs#398733 <= s_2927_0
        fn_state.gs_398733 = s_2927_0;
        // N s_2927_2: jump b2928
        return block_2928(state, tracer, fn_state);
    }
    fn block_2928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2928_0: read-var gs#398733:u8
        let s_2928_0: bool = fn_state.gs_398733;
        // D s_2928_1: write-var gs#398734 <= s_2928_0
        fn_state.gs_398734 = s_2928_0;
        // N s_2928_2: jump b2925
        return block_2925(state, tracer, fn_state);
    }
    fn block_2929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2929_0: const #7s : i
        let s_2929_0: i128 = 7;
        // D s_2929_1: read-var u#30840:u32
        let s_2929_1: u32 = fn_state.u_30840;
        // D s_2929_2: cast zx s_2929_1 -> bv
        let s_2929_2: Bits = Bits::new(s_2929_1 as u128, 32u16);
        // C s_2929_3: const #1s : i64
        let s_2929_3: i64 = 1;
        // C s_2929_4: cast zx s_2929_3 -> i
        let s_2929_4: i128 = (i128::try_from(s_2929_3).unwrap());
        // C s_2929_5: const #2s : i
        let s_2929_5: i128 = 2;
        // C s_2929_6: add s_2929_5 s_2929_4
        let s_2929_6: i128 = (s_2929_5 + s_2929_4);
        // D s_2929_7: bit-extract s_2929_2 s_2929_0 s_2929_6
        let s_2929_7: Bits = (Bits::new(
            ((s_2929_2) >> (s_2929_0)).value(),
            u16::try_from(s_2929_6).unwrap(),
        ));
        // D s_2929_8: cast reint s_2929_7 -> u8
        let s_2929_8: u8 = (s_2929_7.value() as u8);
        // D s_2929_9: cast zx s_2929_8 -> bv
        let s_2929_9: Bits = Bits::new(s_2929_8 as u128, 3u16);
        // C s_2929_10: const #4u : u8
        let s_2929_10: u8 = 4;
        // C s_2929_11: cast zx s_2929_10 -> bv
        let s_2929_11: Bits = Bits::new(s_2929_10 as u128, 3u16);
        // D s_2929_12: cmp-eq s_2929_9 s_2929_11
        let s_2929_12: bool = ((s_2929_9) == (s_2929_11));
        // N s_2929_13: branch s_2929_12 b2932 b2930
        if s_2929_12 {
            return block_2932(state, tracer, fn_state);
        } else {
            return block_2930(state, tracer, fn_state);
        };
    }
    fn block_2930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2930_0: const #0u : u8
        let s_2930_0: bool = false;
        // D s_2930_1: write-var gs#398732 <= s_2930_0
        fn_state.gs_398732 = s_2930_0;
        // N s_2930_2: jump b2931
        return block_2931(state, tracer, fn_state);
    }
    fn block_2931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2931_0: read-var gs#398732:u8
        let s_2931_0: bool = fn_state.gs_398732;
        // D s_2931_1: write-var gs#398733 <= s_2931_0
        fn_state.gs_398733 = s_2931_0;
        // N s_2931_2: jump b2928
        return block_2928(state, tracer, fn_state);
    }
    fn block_2932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2932_0: const #4s : i
        let s_2932_0: i128 = 4;
        // D s_2932_1: read-var u#30840:u32
        let s_2932_1: u32 = fn_state.u_30840;
        // D s_2932_2: cast zx s_2932_1 -> bv
        let s_2932_2: Bits = Bits::new(s_2932_1 as u128, 32u16);
        // C s_2932_3: const #1s : i64
        let s_2932_3: i64 = 1;
        // C s_2932_4: cast zx s_2932_3 -> i
        let s_2932_4: i128 = (i128::try_from(s_2932_3).unwrap());
        // C s_2932_5: const #0s : i
        let s_2932_5: i128 = 0;
        // C s_2932_6: add s_2932_5 s_2932_4
        let s_2932_6: i128 = (s_2932_5 + s_2932_4);
        // D s_2932_7: bit-extract s_2932_2 s_2932_0 s_2932_6
        let s_2932_7: Bits = (Bits::new(
            ((s_2932_2) >> (s_2932_0)).value(),
            u16::try_from(s_2932_6).unwrap(),
        ));
        // D s_2932_8: cast reint s_2932_7 -> u8
        let s_2932_8: bool = ((s_2932_7.value()) != 0);
        // D s_2932_9: cast zx s_2932_8 -> bv
        let s_2932_9: Bits = Bits::new(s_2932_8 as u128, 1u16);
        // C s_2932_10: const #0u : u8
        let s_2932_10: bool = false;
        // C s_2932_11: cast zx s_2932_10 -> bv
        let s_2932_11: Bits = Bits::new(s_2932_10 as u128, 1u16);
        // D s_2932_12: cmp-eq s_2932_9 s_2932_11
        let s_2932_12: bool = ((s_2932_9) == (s_2932_11));
        // D s_2932_13: write-var gs#398732 <= s_2932_12
        fn_state.gs_398732 = s_2932_12;
        // N s_2932_14: jump b2931
        return block_2931(state, tracer, fn_state);
    }
    fn block_2933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2933_0: const #3406s : i
        let s_2933_0: i128 = 3406;
        // C s_2933_1: const #14696u : u32
        let s_2933_1: u32 = 14696;
        // D s_2933_2: read-reg s_2933_1:i
        let s_2933_2: i128 = {
            let value = state.read_register::<i128>(s_2933_1 as isize);
            tracer.read_register(s_2933_1 as isize, value);
            value
        };
        // D s_2933_3: cmp-lt s_2933_2 s_2933_0
        let s_2933_3: bool = ((s_2933_2) < (s_2933_0));
        // D s_2933_4: write-var gs#398704 <= s_2933_3
        fn_state.gs_398704 = s_2933_3;
        // N s_2933_5: jump b449
        return block_449(state, tracer, fn_state);
    }
    fn block_2934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2934_0: const #20s : i
        let s_2934_0: i128 = 20;
        // D s_2934_1: read-var u#30832:u32
        let s_2934_1: u32 = fn_state.u_30832;
        // D s_2934_2: cast zx s_2934_1 -> bv
        let s_2934_2: Bits = Bits::new(s_2934_1 as u128, 32u16);
        // C s_2934_3: const #1s : i64
        let s_2934_3: i64 = 1;
        // C s_2934_4: cast zx s_2934_3 -> i
        let s_2934_4: i128 = (i128::try_from(s_2934_3).unwrap());
        // C s_2934_5: const #1s : i
        let s_2934_5: i128 = 1;
        // C s_2934_6: add s_2934_5 s_2934_4
        let s_2934_6: i128 = (s_2934_5 + s_2934_4);
        // D s_2934_7: bit-extract s_2934_2 s_2934_0 s_2934_6
        let s_2934_7: Bits = (Bits::new(
            ((s_2934_2) >> (s_2934_0)).value(),
            u16::try_from(s_2934_6).unwrap(),
        ));
        // D s_2934_8: cast reint s_2934_7 -> u8
        let s_2934_8: u8 = (s_2934_7.value() as u8);
        // D s_2934_9: cast zx s_2934_8 -> bv
        let s_2934_9: Bits = Bits::new(s_2934_8 as u128, 2u16);
        // C s_2934_10: const #3u : u8
        let s_2934_10: u8 = 3;
        // C s_2934_11: cast zx s_2934_10 -> bv
        let s_2934_11: Bits = Bits::new(s_2934_10 as u128, 2u16);
        // D s_2934_12: cmp-eq s_2934_9 s_2934_11
        let s_2934_12: bool = ((s_2934_9) == (s_2934_11));
        // N s_2934_13: branch s_2934_12 b2937 b2935
        if s_2934_12 {
            return block_2937(state, tracer, fn_state);
        } else {
            return block_2935(state, tracer, fn_state);
        };
    }
    fn block_2935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2935_0: const #0u : u8
        let s_2935_0: bool = false;
        // D s_2935_1: write-var gs#398701 <= s_2935_0
        fn_state.gs_398701 = s_2935_0;
        // N s_2935_2: jump b2936
        return block_2936(state, tracer, fn_state);
    }
    fn block_2936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2936_0: read-var gs#398701:u8
        let s_2936_0: bool = fn_state.gs_398701;
        // D s_2936_1: write-var gs#398702 <= s_2936_0
        fn_state.gs_398702 = s_2936_0;
        // N s_2936_2: jump b447
        return block_447(state, tracer, fn_state);
    }
    fn block_2937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2937_0: const #16s : i
        let s_2937_0: i128 = 16;
        // D s_2937_1: read-var u#30832:u32
        let s_2937_1: u32 = fn_state.u_30832;
        // D s_2937_2: cast zx s_2937_1 -> bv
        let s_2937_2: Bits = Bits::new(s_2937_1 as u128, 32u16);
        // C s_2937_3: const #1s : i64
        let s_2937_3: i64 = 1;
        // C s_2937_4: cast zx s_2937_3 -> i
        let s_2937_4: i128 = (i128::try_from(s_2937_3).unwrap());
        // C s_2937_5: const #1s : i
        let s_2937_5: i128 = 1;
        // C s_2937_6: add s_2937_5 s_2937_4
        let s_2937_6: i128 = (s_2937_5 + s_2937_4);
        // D s_2937_7: bit-extract s_2937_2 s_2937_0 s_2937_6
        let s_2937_7: Bits = (Bits::new(
            ((s_2937_2) >> (s_2937_0)).value(),
            u16::try_from(s_2937_6).unwrap(),
        ));
        // D s_2937_8: cast reint s_2937_7 -> u8
        let s_2937_8: u8 = (s_2937_7.value() as u8);
        // D s_2937_9: cast zx s_2937_8 -> bv
        let s_2937_9: Bits = Bits::new(s_2937_8 as u128, 2u16);
        // C s_2937_10: const #0u : u8
        let s_2937_10: u8 = 0;
        // C s_2937_11: cast zx s_2937_10 -> bv
        let s_2937_11: Bits = Bits::new(s_2937_10 as u128, 2u16);
        // D s_2937_12: cmp-eq s_2937_9 s_2937_11
        let s_2937_12: bool = ((s_2937_9) == (s_2937_11));
        // N s_2937_13: branch s_2937_12 b2940 b2938
        if s_2937_12 {
            return block_2940(state, tracer, fn_state);
        } else {
            return block_2938(state, tracer, fn_state);
        };
    }
    fn block_2938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2938_0: const #0u : u8
        let s_2938_0: bool = false;
        // D s_2938_1: write-var gs#398700 <= s_2938_0
        fn_state.gs_398700 = s_2938_0;
        // N s_2938_2: jump b2939
        return block_2939(state, tracer, fn_state);
    }
    fn block_2939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2939_0: read-var gs#398700:u8
        let s_2939_0: bool = fn_state.gs_398700;
        // D s_2939_1: write-var gs#398701 <= s_2939_0
        fn_state.gs_398701 = s_2939_0;
        // N s_2939_2: jump b2936
        return block_2936(state, tracer, fn_state);
    }
    fn block_2940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2940_0: const #7s : i
        let s_2940_0: i128 = 7;
        // D s_2940_1: read-var u#30832:u32
        let s_2940_1: u32 = fn_state.u_30832;
        // D s_2940_2: cast zx s_2940_1 -> bv
        let s_2940_2: Bits = Bits::new(s_2940_1 as u128, 32u16);
        // C s_2940_3: const #1s : i64
        let s_2940_3: i64 = 1;
        // C s_2940_4: cast zx s_2940_3 -> i
        let s_2940_4: i128 = (i128::try_from(s_2940_3).unwrap());
        // C s_2940_5: const #4s : i
        let s_2940_5: i128 = 4;
        // C s_2940_6: add s_2940_5 s_2940_4
        let s_2940_6: i128 = (s_2940_5 + s_2940_4);
        // D s_2940_7: bit-extract s_2940_2 s_2940_0 s_2940_6
        let s_2940_7: Bits = (Bits::new(
            ((s_2940_2) >> (s_2940_0)).value(),
            u16::try_from(s_2940_6).unwrap(),
        ));
        // D s_2940_8: cast reint s_2940_7 -> u8
        let s_2940_8: u8 = (s_2940_7.value() as u8);
        // D s_2940_9: cast zx s_2940_8 -> bv
        let s_2940_9: Bits = Bits::new(s_2940_8 as u128, 5u16);
        // C s_2940_10: const #8u : u8
        let s_2940_10: u8 = 8;
        // C s_2940_11: cast zx s_2940_10 -> bv
        let s_2940_11: Bits = Bits::new(s_2940_10 as u128, 5u16);
        // D s_2940_12: cmp-eq s_2940_9 s_2940_11
        let s_2940_12: bool = ((s_2940_9) == (s_2940_11));
        // N s_2940_13: branch s_2940_12 b2943 b2941
        if s_2940_12 {
            return block_2943(state, tracer, fn_state);
        } else {
            return block_2941(state, tracer, fn_state);
        };
    }
    fn block_2941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2941_0: const #0u : u8
        let s_2941_0: bool = false;
        // D s_2941_1: write-var gs#398699 <= s_2941_0
        fn_state.gs_398699 = s_2941_0;
        // N s_2941_2: jump b2942
        return block_2942(state, tracer, fn_state);
    }
    fn block_2942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2942_0: read-var gs#398699:u8
        let s_2942_0: bool = fn_state.gs_398699;
        // D s_2942_1: write-var gs#398700 <= s_2942_0
        fn_state.gs_398700 = s_2942_0;
        // N s_2942_2: jump b2939
        return block_2939(state, tracer, fn_state);
    }
    fn block_2943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2943_0: const #4s : i
        let s_2943_0: i128 = 4;
        // D s_2943_1: read-var u#30832:u32
        let s_2943_1: u32 = fn_state.u_30832;
        // D s_2943_2: cast zx s_2943_1 -> bv
        let s_2943_2: Bits = Bits::new(s_2943_1 as u128, 32u16);
        // C s_2943_3: const #1s : i64
        let s_2943_3: i64 = 1;
        // C s_2943_4: cast zx s_2943_3 -> i
        let s_2943_4: i128 = (i128::try_from(s_2943_3).unwrap());
        // C s_2943_5: const #0s : i
        let s_2943_5: i128 = 0;
        // C s_2943_6: add s_2943_5 s_2943_4
        let s_2943_6: i128 = (s_2943_5 + s_2943_4);
        // D s_2943_7: bit-extract s_2943_2 s_2943_0 s_2943_6
        let s_2943_7: Bits = (Bits::new(
            ((s_2943_2) >> (s_2943_0)).value(),
            u16::try_from(s_2943_6).unwrap(),
        ));
        // D s_2943_8: cast reint s_2943_7 -> u8
        let s_2943_8: bool = ((s_2943_7.value()) != 0);
        // D s_2943_9: cast zx s_2943_8 -> bv
        let s_2943_9: Bits = Bits::new(s_2943_8 as u128, 1u16);
        // C s_2943_10: const #0u : u8
        let s_2943_10: bool = false;
        // C s_2943_11: cast zx s_2943_10 -> bv
        let s_2943_11: Bits = Bits::new(s_2943_10 as u128, 1u16);
        // D s_2943_12: cmp-eq s_2943_9 s_2943_11
        let s_2943_12: bool = ((s_2943_9) == (s_2943_11));
        // D s_2943_13: write-var gs#398699 <= s_2943_12
        fn_state.gs_398699 = s_2943_12;
        // N s_2943_14: jump b2942
        return block_2942(state, tracer, fn_state);
    }
    fn block_2944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2944_0: const #3404s : i
        let s_2944_0: i128 = 3404;
        // C s_2944_1: const #14696u : u32
        let s_2944_1: u32 = 14696;
        // D s_2944_2: read-reg s_2944_1:i
        let s_2944_2: i128 = {
            let value = state.read_register::<i128>(s_2944_1 as isize);
            tracer.read_register(s_2944_1 as isize, value);
            value
        };
        // D s_2944_3: cmp-lt s_2944_2 s_2944_0
        let s_2944_3: bool = ((s_2944_2) < (s_2944_0));
        // D s_2944_4: write-var gs#398671 <= s_2944_3
        fn_state.gs_398671 = s_2944_3;
        // N s_2944_5: jump b443
        return block_443(state, tracer, fn_state);
    }
    fn block_2945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2945_0: const #20s : i
        let s_2945_0: i128 = 20;
        // D s_2945_1: read-var u#30823:u32
        let s_2945_1: u32 = fn_state.u_30823;
        // D s_2945_2: cast zx s_2945_1 -> bv
        let s_2945_2: Bits = Bits::new(s_2945_1 as u128, 32u16);
        // C s_2945_3: const #1s : i64
        let s_2945_3: i64 = 1;
        // C s_2945_4: cast zx s_2945_3 -> i
        let s_2945_4: i128 = (i128::try_from(s_2945_3).unwrap());
        // C s_2945_5: const #1s : i
        let s_2945_5: i128 = 1;
        // C s_2945_6: add s_2945_5 s_2945_4
        let s_2945_6: i128 = (s_2945_5 + s_2945_4);
        // D s_2945_7: bit-extract s_2945_2 s_2945_0 s_2945_6
        let s_2945_7: Bits = (Bits::new(
            ((s_2945_2) >> (s_2945_0)).value(),
            u16::try_from(s_2945_6).unwrap(),
        ));
        // D s_2945_8: cast reint s_2945_7 -> u8
        let s_2945_8: u8 = (s_2945_7.value() as u8);
        // D s_2945_9: cast zx s_2945_8 -> bv
        let s_2945_9: Bits = Bits::new(s_2945_8 as u128, 2u16);
        // C s_2945_10: const #3u : u8
        let s_2945_10: u8 = 3;
        // C s_2945_11: cast zx s_2945_10 -> bv
        let s_2945_11: Bits = Bits::new(s_2945_10 as u128, 2u16);
        // D s_2945_12: cmp-eq s_2945_9 s_2945_11
        let s_2945_12: bool = ((s_2945_9) == (s_2945_11));
        // N s_2945_13: branch s_2945_12 b2948 b2946
        if s_2945_12 {
            return block_2948(state, tracer, fn_state);
        } else {
            return block_2946(state, tracer, fn_state);
        };
    }
    fn block_2946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2946_0: const #0u : u8
        let s_2946_0: bool = false;
        // D s_2946_1: write-var gs#398668 <= s_2946_0
        fn_state.gs_398668 = s_2946_0;
        // N s_2946_2: jump b2947
        return block_2947(state, tracer, fn_state);
    }
    fn block_2947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2947_0: read-var gs#398668:u8
        let s_2947_0: bool = fn_state.gs_398668;
        // D s_2947_1: write-var gs#398669 <= s_2947_0
        fn_state.gs_398669 = s_2947_0;
        // N s_2947_2: jump b441
        return block_441(state, tracer, fn_state);
    }
    fn block_2948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2948_0: const #16s : i
        let s_2948_0: i128 = 16;
        // D s_2948_1: read-var u#30823:u32
        let s_2948_1: u32 = fn_state.u_30823;
        // D s_2948_2: cast zx s_2948_1 -> bv
        let s_2948_2: Bits = Bits::new(s_2948_1 as u128, 32u16);
        // C s_2948_3: const #1s : i64
        let s_2948_3: i64 = 1;
        // C s_2948_4: cast zx s_2948_3 -> i
        let s_2948_4: i128 = (i128::try_from(s_2948_3).unwrap());
        // C s_2948_5: const #1s : i
        let s_2948_5: i128 = 1;
        // C s_2948_6: add s_2948_5 s_2948_4
        let s_2948_6: i128 = (s_2948_5 + s_2948_4);
        // D s_2948_7: bit-extract s_2948_2 s_2948_0 s_2948_6
        let s_2948_7: Bits = (Bits::new(
            ((s_2948_2) >> (s_2948_0)).value(),
            u16::try_from(s_2948_6).unwrap(),
        ));
        // D s_2948_8: cast reint s_2948_7 -> u8
        let s_2948_8: u8 = (s_2948_7.value() as u8);
        // D s_2948_9: cast zx s_2948_8 -> bv
        let s_2948_9: Bits = Bits::new(s_2948_8 as u128, 2u16);
        // C s_2948_10: const #1u : u8
        let s_2948_10: u8 = 1;
        // C s_2948_11: cast zx s_2948_10 -> bv
        let s_2948_11: Bits = Bits::new(s_2948_10 as u128, 2u16);
        // D s_2948_12: cmp-eq s_2948_9 s_2948_11
        let s_2948_12: bool = ((s_2948_9) == (s_2948_11));
        // N s_2948_13: branch s_2948_12 b2951 b2949
        if s_2948_12 {
            return block_2951(state, tracer, fn_state);
        } else {
            return block_2949(state, tracer, fn_state);
        };
    }
    fn block_2949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2949_0: const #0u : u8
        let s_2949_0: bool = false;
        // D s_2949_1: write-var gs#398667 <= s_2949_0
        fn_state.gs_398667 = s_2949_0;
        // N s_2949_2: jump b2950
        return block_2950(state, tracer, fn_state);
    }
    fn block_2950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2950_0: read-var gs#398667:u8
        let s_2950_0: bool = fn_state.gs_398667;
        // D s_2950_1: write-var gs#398668 <= s_2950_0
        fn_state.gs_398668 = s_2950_0;
        // N s_2950_2: jump b2947
        return block_2947(state, tracer, fn_state);
    }
    fn block_2951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2951_0: const #11s : i
        let s_2951_0: i128 = 11;
        // D s_2951_1: read-var u#30823:u32
        let s_2951_1: u32 = fn_state.u_30823;
        // D s_2951_2: cast zx s_2951_1 -> bv
        let s_2951_2: Bits = Bits::new(s_2951_1 as u128, 32u16);
        // C s_2951_3: const #1s : i64
        let s_2951_3: i64 = 1;
        // C s_2951_4: cast zx s_2951_3 -> i
        let s_2951_4: i128 = (i128::try_from(s_2951_3).unwrap());
        // C s_2951_5: const #0s : i
        let s_2951_5: i128 = 0;
        // C s_2951_6: add s_2951_5 s_2951_4
        let s_2951_6: i128 = (s_2951_5 + s_2951_4);
        // D s_2951_7: bit-extract s_2951_2 s_2951_0 s_2951_6
        let s_2951_7: Bits = (Bits::new(
            ((s_2951_2) >> (s_2951_0)).value(),
            u16::try_from(s_2951_6).unwrap(),
        ));
        // D s_2951_8: cast reint s_2951_7 -> u8
        let s_2951_8: bool = ((s_2951_7.value()) != 0);
        // D s_2951_9: cast zx s_2951_8 -> bv
        let s_2951_9: Bits = Bits::new(s_2951_8 as u128, 1u16);
        // C s_2951_10: const #0u : u8
        let s_2951_10: bool = false;
        // C s_2951_11: cast zx s_2951_10 -> bv
        let s_2951_11: Bits = Bits::new(s_2951_10 as u128, 1u16);
        // D s_2951_12: cmp-eq s_2951_9 s_2951_11
        let s_2951_12: bool = ((s_2951_9) == (s_2951_11));
        // N s_2951_13: branch s_2951_12 b2954 b2952
        if s_2951_12 {
            return block_2954(state, tracer, fn_state);
        } else {
            return block_2952(state, tracer, fn_state);
        };
    }
    fn block_2952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2952_0: const #0u : u8
        let s_2952_0: bool = false;
        // D s_2952_1: write-var gs#398666 <= s_2952_0
        fn_state.gs_398666 = s_2952_0;
        // N s_2952_2: jump b2953
        return block_2953(state, tracer, fn_state);
    }
    fn block_2953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2953_0: read-var gs#398666:u8
        let s_2953_0: bool = fn_state.gs_398666;
        // D s_2953_1: write-var gs#398667 <= s_2953_0
        fn_state.gs_398667 = s_2953_0;
        // N s_2953_2: jump b2950
        return block_2950(state, tracer, fn_state);
    }
    fn block_2954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2954_0: const #7s : i
        let s_2954_0: i128 = 7;
        // D s_2954_1: read-var u#30823:u32
        let s_2954_1: u32 = fn_state.u_30823;
        // D s_2954_2: cast zx s_2954_1 -> bv
        let s_2954_2: Bits = Bits::new(s_2954_1 as u128, 32u16);
        // C s_2954_3: const #1s : i64
        let s_2954_3: i64 = 1;
        // C s_2954_4: cast zx s_2954_3 -> i
        let s_2954_4: i128 = (i128::try_from(s_2954_3).unwrap());
        // C s_2954_5: const #2s : i
        let s_2954_5: i128 = 2;
        // C s_2954_6: add s_2954_5 s_2954_4
        let s_2954_6: i128 = (s_2954_5 + s_2954_4);
        // D s_2954_7: bit-extract s_2954_2 s_2954_0 s_2954_6
        let s_2954_7: Bits = (Bits::new(
            ((s_2954_2) >> (s_2954_0)).value(),
            u16::try_from(s_2954_6).unwrap(),
        ));
        // D s_2954_8: cast reint s_2954_7 -> u8
        let s_2954_8: u8 = (s_2954_7.value() as u8);
        // D s_2954_9: cast zx s_2954_8 -> bv
        let s_2954_9: Bits = Bits::new(s_2954_8 as u128, 3u16);
        // C s_2954_10: const #3u : u8
        let s_2954_10: u8 = 3;
        // C s_2954_11: cast zx s_2954_10 -> bv
        let s_2954_11: Bits = Bits::new(s_2954_10 as u128, 3u16);
        // D s_2954_12: cmp-eq s_2954_9 s_2954_11
        let s_2954_12: bool = ((s_2954_9) == (s_2954_11));
        // N s_2954_13: branch s_2954_12 b2957 b2955
        if s_2954_12 {
            return block_2957(state, tracer, fn_state);
        } else {
            return block_2955(state, tracer, fn_state);
        };
    }
    fn block_2955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2955_0: const #0u : u8
        let s_2955_0: bool = false;
        // D s_2955_1: write-var gs#398665 <= s_2955_0
        fn_state.gs_398665 = s_2955_0;
        // N s_2955_2: jump b2956
        return block_2956(state, tracer, fn_state);
    }
    fn block_2956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2956_0: read-var gs#398665:u8
        let s_2956_0: bool = fn_state.gs_398665;
        // D s_2956_1: write-var gs#398666 <= s_2956_0
        fn_state.gs_398666 = s_2956_0;
        // N s_2956_2: jump b2953
        return block_2953(state, tracer, fn_state);
    }
    fn block_2957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2957_0: const #4s : i
        let s_2957_0: i128 = 4;
        // D s_2957_1: read-var u#30823:u32
        let s_2957_1: u32 = fn_state.u_30823;
        // D s_2957_2: cast zx s_2957_1 -> bv
        let s_2957_2: Bits = Bits::new(s_2957_1 as u128, 32u16);
        // C s_2957_3: const #1s : i64
        let s_2957_3: i64 = 1;
        // C s_2957_4: cast zx s_2957_3 -> i
        let s_2957_4: i128 = (i128::try_from(s_2957_3).unwrap());
        // C s_2957_5: const #0s : i
        let s_2957_5: i128 = 0;
        // C s_2957_6: add s_2957_5 s_2957_4
        let s_2957_6: i128 = (s_2957_5 + s_2957_4);
        // D s_2957_7: bit-extract s_2957_2 s_2957_0 s_2957_6
        let s_2957_7: Bits = (Bits::new(
            ((s_2957_2) >> (s_2957_0)).value(),
            u16::try_from(s_2957_6).unwrap(),
        ));
        // D s_2957_8: cast reint s_2957_7 -> u8
        let s_2957_8: bool = ((s_2957_7.value()) != 0);
        // D s_2957_9: cast zx s_2957_8 -> bv
        let s_2957_9: Bits = Bits::new(s_2957_8 as u128, 1u16);
        // C s_2957_10: const #0u : u8
        let s_2957_10: bool = false;
        // C s_2957_11: cast zx s_2957_10 -> bv
        let s_2957_11: Bits = Bits::new(s_2957_10 as u128, 1u16);
        // D s_2957_12: cmp-eq s_2957_9 s_2957_11
        let s_2957_12: bool = ((s_2957_9) == (s_2957_11));
        // D s_2957_13: write-var gs#398665 <= s_2957_12
        fn_state.gs_398665 = s_2957_12;
        // N s_2957_14: jump b2956
        return block_2956(state, tracer, fn_state);
    }
    fn block_2958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2958_0: const #3401s : i
        let s_2958_0: i128 = 3401;
        // C s_2958_1: const #14696u : u32
        let s_2958_1: u32 = 14696;
        // D s_2958_2: read-reg s_2958_1:i
        let s_2958_2: i128 = {
            let value = state.read_register::<i128>(s_2958_1 as isize);
            tracer.read_register(s_2958_1 as isize, value);
            value
        };
        // D s_2958_3: cmp-lt s_2958_2 s_2958_0
        let s_2958_3: bool = ((s_2958_2) < (s_2958_0));
        // D s_2958_4: write-var gs#398633 <= s_2958_3
        fn_state.gs_398633 = s_2958_3;
        // N s_2958_5: jump b437
        return block_437(state, tracer, fn_state);
    }
    fn block_2959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2959_0: const #21s : i
        let s_2959_0: i128 = 21;
        // D s_2959_1: read-var u#30813:u32
        let s_2959_1: u32 = fn_state.u_30813;
        // D s_2959_2: cast zx s_2959_1 -> bv
        let s_2959_2: Bits = Bits::new(s_2959_1 as u128, 32u16);
        // C s_2959_3: const #1s : i64
        let s_2959_3: i64 = 1;
        // C s_2959_4: cast zx s_2959_3 -> i
        let s_2959_4: i128 = (i128::try_from(s_2959_3).unwrap());
        // C s_2959_5: const #0s : i
        let s_2959_5: i128 = 0;
        // C s_2959_6: add s_2959_5 s_2959_4
        let s_2959_6: i128 = (s_2959_5 + s_2959_4);
        // D s_2959_7: bit-extract s_2959_2 s_2959_0 s_2959_6
        let s_2959_7: Bits = (Bits::new(
            ((s_2959_2) >> (s_2959_0)).value(),
            u16::try_from(s_2959_6).unwrap(),
        ));
        // D s_2959_8: cast reint s_2959_7 -> u8
        let s_2959_8: bool = ((s_2959_7.value()) != 0);
        // D s_2959_9: cast zx s_2959_8 -> bv
        let s_2959_9: Bits = Bits::new(s_2959_8 as u128, 1u16);
        // C s_2959_10: const #1u : u8
        let s_2959_10: bool = true;
        // C s_2959_11: cast zx s_2959_10 -> bv
        let s_2959_11: Bits = Bits::new(s_2959_10 as u128, 1u16);
        // D s_2959_12: cmp-eq s_2959_9 s_2959_11
        let s_2959_12: bool = ((s_2959_9) == (s_2959_11));
        // N s_2959_13: branch s_2959_12 b2962 b2960
        if s_2959_12 {
            return block_2962(state, tracer, fn_state);
        } else {
            return block_2960(state, tracer, fn_state);
        };
    }
    fn block_2960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2960_0: const #0u : u8
        let s_2960_0: bool = false;
        // D s_2960_1: write-var gs#398630 <= s_2960_0
        fn_state.gs_398630 = s_2960_0;
        // N s_2960_2: jump b2961
        return block_2961(state, tracer, fn_state);
    }
    fn block_2961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2961_0: read-var gs#398630:u8
        let s_2961_0: bool = fn_state.gs_398630;
        // D s_2961_1: write-var gs#398631 <= s_2961_0
        fn_state.gs_398631 = s_2961_0;
        // N s_2961_2: jump b435
        return block_435(state, tracer, fn_state);
    }
    fn block_2962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2962_0: const #8s : i
        let s_2962_0: i128 = 8;
        // D s_2962_1: read-var u#30813:u32
        let s_2962_1: u32 = fn_state.u_30813;
        // D s_2962_2: cast zx s_2962_1 -> bv
        let s_2962_2: Bits = Bits::new(s_2962_1 as u128, 32u16);
        // C s_2962_3: const #1s : i64
        let s_2962_3: i64 = 1;
        // C s_2962_4: cast zx s_2962_3 -> i
        let s_2962_4: i128 = (i128::try_from(s_2962_3).unwrap());
        // C s_2962_5: const #3s : i
        let s_2962_5: i128 = 3;
        // C s_2962_6: add s_2962_5 s_2962_4
        let s_2962_6: i128 = (s_2962_5 + s_2962_4);
        // D s_2962_7: bit-extract s_2962_2 s_2962_0 s_2962_6
        let s_2962_7: Bits = (Bits::new(
            ((s_2962_2) >> (s_2962_0)).value(),
            u16::try_from(s_2962_6).unwrap(),
        ));
        // D s_2962_8: cast reint s_2962_7 -> u8
        let s_2962_8: u8 = (s_2962_7.value() as u8);
        // D s_2962_9: cast zx s_2962_8 -> bv
        let s_2962_9: Bits = Bits::new(s_2962_8 as u128, 4u16);
        // C s_2962_10: const #14u : u8
        let s_2962_10: u8 = 14;
        // C s_2962_11: cast zx s_2962_10 -> bv
        let s_2962_11: Bits = Bits::new(s_2962_10 as u128, 4u16);
        // D s_2962_12: cmp-eq s_2962_9 s_2962_11
        let s_2962_12: bool = ((s_2962_9) == (s_2962_11));
        // N s_2962_13: branch s_2962_12 b2965 b2963
        if s_2962_12 {
            return block_2965(state, tracer, fn_state);
        } else {
            return block_2963(state, tracer, fn_state);
        };
    }
    fn block_2963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2963_0: const #0u : u8
        let s_2963_0: bool = false;
        // D s_2963_1: write-var gs#398629 <= s_2963_0
        fn_state.gs_398629 = s_2963_0;
        // N s_2963_2: jump b2964
        return block_2964(state, tracer, fn_state);
    }
    fn block_2964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2964_0: read-var gs#398629:u8
        let s_2964_0: bool = fn_state.gs_398629;
        // D s_2964_1: write-var gs#398630 <= s_2964_0
        fn_state.gs_398630 = s_2964_0;
        // N s_2964_2: jump b2961
        return block_2961(state, tracer, fn_state);
    }
    fn block_2965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2965_0: const #4s : i
        let s_2965_0: i128 = 4;
        // D s_2965_1: read-var u#30813:u32
        let s_2965_1: u32 = fn_state.u_30813;
        // D s_2965_2: cast zx s_2965_1 -> bv
        let s_2965_2: Bits = Bits::new(s_2965_1 as u128, 32u16);
        // C s_2965_3: const #1s : i64
        let s_2965_3: i64 = 1;
        // C s_2965_4: cast zx s_2965_3 -> i
        let s_2965_4: i128 = (i128::try_from(s_2965_3).unwrap());
        // C s_2965_5: const #0s : i
        let s_2965_5: i128 = 0;
        // C s_2965_6: add s_2965_5 s_2965_4
        let s_2965_6: i128 = (s_2965_5 + s_2965_4);
        // D s_2965_7: bit-extract s_2965_2 s_2965_0 s_2965_6
        let s_2965_7: Bits = (Bits::new(
            ((s_2965_2) >> (s_2965_0)).value(),
            u16::try_from(s_2965_6).unwrap(),
        ));
        // D s_2965_8: cast reint s_2965_7 -> u8
        let s_2965_8: bool = ((s_2965_7.value()) != 0);
        // D s_2965_9: cast zx s_2965_8 -> bv
        let s_2965_9: Bits = Bits::new(s_2965_8 as u128, 1u16);
        // C s_2965_10: const #0u : u8
        let s_2965_10: bool = false;
        // C s_2965_11: cast zx s_2965_10 -> bv
        let s_2965_11: Bits = Bits::new(s_2965_10 as u128, 1u16);
        // D s_2965_12: cmp-eq s_2965_9 s_2965_11
        let s_2965_12: bool = ((s_2965_9) == (s_2965_11));
        // D s_2965_13: write-var gs#398629 <= s_2965_12
        fn_state.gs_398629 = s_2965_12;
        // N s_2965_14: jump b2964
        return block_2964(state, tracer, fn_state);
    }
    fn block_2966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2966_0: const #3400s : i
        let s_2966_0: i128 = 3400;
        // C s_2966_1: const #14696u : u32
        let s_2966_1: u32 = 14696;
        // D s_2966_2: read-reg s_2966_1:i
        let s_2966_2: i128 = {
            let value = state.read_register::<i128>(s_2966_1 as isize);
            tracer.read_register(s_2966_1 as isize, value);
            value
        };
        // D s_2966_3: cmp-lt s_2966_2 s_2966_0
        let s_2966_3: bool = ((s_2966_2) < (s_2966_0));
        // D s_2966_4: write-var gs#398599 <= s_2966_3
        fn_state.gs_398599 = s_2966_3;
        // N s_2966_5: jump b431
        return block_431(state, tracer, fn_state);
    }
    fn block_2967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2967_0: const #23s : i
        let s_2967_0: i128 = 23;
        // D s_2967_1: read-var u#30802:u32
        let s_2967_1: u32 = fn_state.u_30802;
        // D s_2967_2: cast zx s_2967_1 -> bv
        let s_2967_2: Bits = Bits::new(s_2967_1 as u128, 32u16);
        // C s_2967_3: const #1s : i64
        let s_2967_3: i64 = 1;
        // C s_2967_4: cast zx s_2967_3 -> i
        let s_2967_4: i128 = (i128::try_from(s_2967_3).unwrap());
        // C s_2967_5: const #0s : i
        let s_2967_5: i128 = 0;
        // C s_2967_6: add s_2967_5 s_2967_4
        let s_2967_6: i128 = (s_2967_5 + s_2967_4);
        // D s_2967_7: bit-extract s_2967_2 s_2967_0 s_2967_6
        let s_2967_7: Bits = (Bits::new(
            ((s_2967_2) >> (s_2967_0)).value(),
            u16::try_from(s_2967_6).unwrap(),
        ));
        // D s_2967_8: cast reint s_2967_7 -> u8
        let s_2967_8: bool = ((s_2967_7.value()) != 0);
        // D s_2967_9: cast zx s_2967_8 -> bv
        let s_2967_9: Bits = Bits::new(s_2967_8 as u128, 1u16);
        // C s_2967_10: const #0u : u8
        let s_2967_10: bool = false;
        // C s_2967_11: cast zx s_2967_10 -> bv
        let s_2967_11: Bits = Bits::new(s_2967_10 as u128, 1u16);
        // D s_2967_12: cmp-eq s_2967_9 s_2967_11
        let s_2967_12: bool = ((s_2967_9) == (s_2967_11));
        // N s_2967_13: branch s_2967_12 b2970 b2968
        if s_2967_12 {
            return block_2970(state, tracer, fn_state);
        } else {
            return block_2968(state, tracer, fn_state);
        };
    }
    fn block_2968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2968_0: const #0u : u8
        let s_2968_0: bool = false;
        // D s_2968_1: write-var gs#398596 <= s_2968_0
        fn_state.gs_398596 = s_2968_0;
        // N s_2968_2: jump b2969
        return block_2969(state, tracer, fn_state);
    }
    fn block_2969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2969_0: read-var gs#398596:u8
        let s_2969_0: bool = fn_state.gs_398596;
        // D s_2969_1: write-var gs#398597 <= s_2969_0
        fn_state.gs_398597 = s_2969_0;
        // N s_2969_2: jump b429
        return block_429(state, tracer, fn_state);
    }
    fn block_2970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2970_0: const #8s : i
        let s_2970_0: i128 = 8;
        // D s_2970_1: read-var u#30802:u32
        let s_2970_1: u32 = fn_state.u_30802;
        // D s_2970_2: cast zx s_2970_1 -> bv
        let s_2970_2: Bits = Bits::new(s_2970_1 as u128, 32u16);
        // C s_2970_3: const #1s : i64
        let s_2970_3: i64 = 1;
        // C s_2970_4: cast zx s_2970_3 -> i
        let s_2970_4: i128 = (i128::try_from(s_2970_3).unwrap());
        // C s_2970_5: const #3s : i
        let s_2970_5: i128 = 3;
        // C s_2970_6: add s_2970_5 s_2970_4
        let s_2970_6: i128 = (s_2970_5 + s_2970_4);
        // D s_2970_7: bit-extract s_2970_2 s_2970_0 s_2970_6
        let s_2970_7: Bits = (Bits::new(
            ((s_2970_2) >> (s_2970_0)).value(),
            u16::try_from(s_2970_6).unwrap(),
        ));
        // D s_2970_8: cast reint s_2970_7 -> u8
        let s_2970_8: u8 = (s_2970_7.value() as u8);
        // D s_2970_9: cast zx s_2970_8 -> bv
        let s_2970_9: Bits = Bits::new(s_2970_8 as u128, 4u16);
        // C s_2970_10: const #3u : u8
        let s_2970_10: u8 = 3;
        // C s_2970_11: cast zx s_2970_10 -> bv
        let s_2970_11: Bits = Bits::new(s_2970_10 as u128, 4u16);
        // D s_2970_12: cmp-eq s_2970_9 s_2970_11
        let s_2970_12: bool = ((s_2970_9) == (s_2970_11));
        // N s_2970_13: branch s_2970_12 b2973 b2971
        if s_2970_12 {
            return block_2973(state, tracer, fn_state);
        } else {
            return block_2971(state, tracer, fn_state);
        };
    }
    fn block_2971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2971_0: const #0u : u8
        let s_2971_0: bool = false;
        // D s_2971_1: write-var gs#398595 <= s_2971_0
        fn_state.gs_398595 = s_2971_0;
        // N s_2971_2: jump b2972
        return block_2972(state, tracer, fn_state);
    }
    fn block_2972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2972_0: read-var gs#398595:u8
        let s_2972_0: bool = fn_state.gs_398595;
        // D s_2972_1: write-var gs#398596 <= s_2972_0
        fn_state.gs_398596 = s_2972_0;
        // N s_2972_2: jump b2969
        return block_2969(state, tracer, fn_state);
    }
    fn block_2973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2973_0: const #4s : i
        let s_2973_0: i128 = 4;
        // D s_2973_1: read-var u#30802:u32
        let s_2973_1: u32 = fn_state.u_30802;
        // D s_2973_2: cast zx s_2973_1 -> bv
        let s_2973_2: Bits = Bits::new(s_2973_1 as u128, 32u16);
        // C s_2973_3: const #1s : i64
        let s_2973_3: i64 = 1;
        // C s_2973_4: cast zx s_2973_3 -> i
        let s_2973_4: i128 = (i128::try_from(s_2973_3).unwrap());
        // C s_2973_5: const #0s : i
        let s_2973_5: i128 = 0;
        // C s_2973_6: add s_2973_5 s_2973_4
        let s_2973_6: i128 = (s_2973_5 + s_2973_4);
        // D s_2973_7: bit-extract s_2973_2 s_2973_0 s_2973_6
        let s_2973_7: Bits = (Bits::new(
            ((s_2973_2) >> (s_2973_0)).value(),
            u16::try_from(s_2973_6).unwrap(),
        ));
        // D s_2973_8: cast reint s_2973_7 -> u8
        let s_2973_8: bool = ((s_2973_7.value()) != 0);
        // D s_2973_9: cast zx s_2973_8 -> bv
        let s_2973_9: Bits = Bits::new(s_2973_8 as u128, 1u16);
        // C s_2973_10: const #0u : u8
        let s_2973_10: bool = false;
        // C s_2973_11: cast zx s_2973_10 -> bv
        let s_2973_11: Bits = Bits::new(s_2973_10 as u128, 1u16);
        // D s_2973_12: cmp-eq s_2973_9 s_2973_11
        let s_2973_12: bool = ((s_2973_9) == (s_2973_11));
        // D s_2973_13: write-var gs#398595 <= s_2973_12
        fn_state.gs_398595 = s_2973_12;
        // N s_2973_14: jump b2972
        return block_2972(state, tracer, fn_state);
    }
    fn block_2974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2974_0: const #3398s : i
        let s_2974_0: i128 = 3398;
        // C s_2974_1: const #14696u : u32
        let s_2974_1: u32 = 14696;
        // D s_2974_2: read-reg s_2974_1:i
        let s_2974_2: i128 = {
            let value = state.read_register::<i128>(s_2974_1 as isize);
            tracer.read_register(s_2974_1 as isize, value);
            value
        };
        // D s_2974_3: cmp-lt s_2974_2 s_2974_0
        let s_2974_3: bool = ((s_2974_2) < (s_2974_0));
        // D s_2974_4: write-var gs#398569 <= s_2974_3
        fn_state.gs_398569 = s_2974_3;
        // N s_2974_5: jump b425
        return block_425(state, tracer, fn_state);
    }
    fn block_2975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2975_0: const #20s : i
        let s_2975_0: i128 = 20;
        // D s_2975_1: read-var u#30793:u32
        let s_2975_1: u32 = fn_state.u_30793;
        // D s_2975_2: cast zx s_2975_1 -> bv
        let s_2975_2: Bits = Bits::new(s_2975_1 as u128, 32u16);
        // C s_2975_3: const #1s : i64
        let s_2975_3: i64 = 1;
        // C s_2975_4: cast zx s_2975_3 -> i
        let s_2975_4: i128 = (i128::try_from(s_2975_3).unwrap());
        // C s_2975_5: const #1s : i
        let s_2975_5: i128 = 1;
        // C s_2975_6: add s_2975_5 s_2975_4
        let s_2975_6: i128 = (s_2975_5 + s_2975_4);
        // D s_2975_7: bit-extract s_2975_2 s_2975_0 s_2975_6
        let s_2975_7: Bits = (Bits::new(
            ((s_2975_2) >> (s_2975_0)).value(),
            u16::try_from(s_2975_6).unwrap(),
        ));
        // D s_2975_8: cast reint s_2975_7 -> u8
        let s_2975_8: u8 = (s_2975_7.value() as u8);
        // D s_2975_9: cast zx s_2975_8 -> bv
        let s_2975_9: Bits = Bits::new(s_2975_8 as u128, 2u16);
        // C s_2975_10: const #3u : u8
        let s_2975_10: u8 = 3;
        // C s_2975_11: cast zx s_2975_10 -> bv
        let s_2975_11: Bits = Bits::new(s_2975_10 as u128, 2u16);
        // D s_2975_12: cmp-eq s_2975_9 s_2975_11
        let s_2975_12: bool = ((s_2975_9) == (s_2975_11));
        // N s_2975_13: branch s_2975_12 b2978 b2976
        if s_2975_12 {
            return block_2978(state, tracer, fn_state);
        } else {
            return block_2976(state, tracer, fn_state);
        };
    }
    fn block_2976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2976_0: const #0u : u8
        let s_2976_0: bool = false;
        // D s_2976_1: write-var gs#398566 <= s_2976_0
        fn_state.gs_398566 = s_2976_0;
        // N s_2976_2: jump b2977
        return block_2977(state, tracer, fn_state);
    }
    fn block_2977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2977_0: read-var gs#398566:u8
        let s_2977_0: bool = fn_state.gs_398566;
        // D s_2977_1: write-var gs#398567 <= s_2977_0
        fn_state.gs_398567 = s_2977_0;
        // N s_2977_2: jump b423
        return block_423(state, tracer, fn_state);
    }
    fn block_2978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2978_0: const #16s : i
        let s_2978_0: i128 = 16;
        // D s_2978_1: read-var u#30793:u32
        let s_2978_1: u32 = fn_state.u_30793;
        // D s_2978_2: cast zx s_2978_1 -> bv
        let s_2978_2: Bits = Bits::new(s_2978_1 as u128, 32u16);
        // C s_2978_3: const #1s : i64
        let s_2978_3: i64 = 1;
        // C s_2978_4: cast zx s_2978_3 -> i
        let s_2978_4: i128 = (i128::try_from(s_2978_3).unwrap());
        // C s_2978_5: const #1s : i
        let s_2978_5: i128 = 1;
        // C s_2978_6: add s_2978_5 s_2978_4
        let s_2978_6: i128 = (s_2978_5 + s_2978_4);
        // D s_2978_7: bit-extract s_2978_2 s_2978_0 s_2978_6
        let s_2978_7: Bits = (Bits::new(
            ((s_2978_2) >> (s_2978_0)).value(),
            u16::try_from(s_2978_6).unwrap(),
        ));
        // D s_2978_8: cast reint s_2978_7 -> u8
        let s_2978_8: u8 = (s_2978_7.value() as u8);
        // D s_2978_9: cast zx s_2978_8 -> bv
        let s_2978_9: Bits = Bits::new(s_2978_8 as u128, 2u16);
        // C s_2978_10: const #1u : u8
        let s_2978_10: u8 = 1;
        // C s_2978_11: cast zx s_2978_10 -> bv
        let s_2978_11: Bits = Bits::new(s_2978_10 as u128, 2u16);
        // D s_2978_12: cmp-eq s_2978_9 s_2978_11
        let s_2978_12: bool = ((s_2978_9) == (s_2978_11));
        // N s_2978_13: branch s_2978_12 b2981 b2979
        if s_2978_12 {
            return block_2981(state, tracer, fn_state);
        } else {
            return block_2979(state, tracer, fn_state);
        };
    }
    fn block_2979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2979_0: const #0u : u8
        let s_2979_0: bool = false;
        // D s_2979_1: write-var gs#398565 <= s_2979_0
        fn_state.gs_398565 = s_2979_0;
        // N s_2979_2: jump b2980
        return block_2980(state, tracer, fn_state);
    }
    fn block_2980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2980_0: read-var gs#398565:u8
        let s_2980_0: bool = fn_state.gs_398565;
        // D s_2980_1: write-var gs#398566 <= s_2980_0
        fn_state.gs_398566 = s_2980_0;
        // N s_2980_2: jump b2977
        return block_2977(state, tracer, fn_state);
    }
    fn block_2981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2981_0: const #11s : i
        let s_2981_0: i128 = 11;
        // D s_2981_1: read-var u#30793:u32
        let s_2981_1: u32 = fn_state.u_30793;
        // D s_2981_2: cast zx s_2981_1 -> bv
        let s_2981_2: Bits = Bits::new(s_2981_1 as u128, 32u16);
        // C s_2981_3: const #1s : i64
        let s_2981_3: i64 = 1;
        // C s_2981_4: cast zx s_2981_3 -> i
        let s_2981_4: i128 = (i128::try_from(s_2981_3).unwrap());
        // C s_2981_5: const #0s : i
        let s_2981_5: i128 = 0;
        // C s_2981_6: add s_2981_5 s_2981_4
        let s_2981_6: i128 = (s_2981_5 + s_2981_4);
        // D s_2981_7: bit-extract s_2981_2 s_2981_0 s_2981_6
        let s_2981_7: Bits = (Bits::new(
            ((s_2981_2) >> (s_2981_0)).value(),
            u16::try_from(s_2981_6).unwrap(),
        ));
        // D s_2981_8: cast reint s_2981_7 -> u8
        let s_2981_8: bool = ((s_2981_7.value()) != 0);
        // D s_2981_9: cast zx s_2981_8 -> bv
        let s_2981_9: Bits = Bits::new(s_2981_8 as u128, 1u16);
        // C s_2981_10: const #0u : u8
        let s_2981_10: bool = false;
        // C s_2981_11: cast zx s_2981_10 -> bv
        let s_2981_11: Bits = Bits::new(s_2981_10 as u128, 1u16);
        // D s_2981_12: cmp-eq s_2981_9 s_2981_11
        let s_2981_12: bool = ((s_2981_9) == (s_2981_11));
        // N s_2981_13: branch s_2981_12 b2984 b2982
        if s_2981_12 {
            return block_2984(state, tracer, fn_state);
        } else {
            return block_2982(state, tracer, fn_state);
        };
    }
    fn block_2982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2982_0: const #0u : u8
        let s_2982_0: bool = false;
        // D s_2982_1: write-var gs#398564 <= s_2982_0
        fn_state.gs_398564 = s_2982_0;
        // N s_2982_2: jump b2983
        return block_2983(state, tracer, fn_state);
    }
    fn block_2983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2983_0: read-var gs#398564:u8
        let s_2983_0: bool = fn_state.gs_398564;
        // D s_2983_1: write-var gs#398565 <= s_2983_0
        fn_state.gs_398565 = s_2983_0;
        // N s_2983_2: jump b2980
        return block_2980(state, tracer, fn_state);
    }
    fn block_2984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2984_0: const #7s : i
        let s_2984_0: i128 = 7;
        // D s_2984_1: read-var u#30793:u32
        let s_2984_1: u32 = fn_state.u_30793;
        // D s_2984_2: cast zx s_2984_1 -> bv
        let s_2984_2: Bits = Bits::new(s_2984_1 as u128, 32u16);
        // C s_2984_3: const #1s : i64
        let s_2984_3: i64 = 1;
        // C s_2984_4: cast zx s_2984_3 -> i
        let s_2984_4: i128 = (i128::try_from(s_2984_3).unwrap());
        // C s_2984_5: const #2s : i
        let s_2984_5: i128 = 2;
        // C s_2984_6: add s_2984_5 s_2984_4
        let s_2984_6: i128 = (s_2984_5 + s_2984_4);
        // D s_2984_7: bit-extract s_2984_2 s_2984_0 s_2984_6
        let s_2984_7: Bits = (Bits::new(
            ((s_2984_2) >> (s_2984_0)).value(),
            u16::try_from(s_2984_6).unwrap(),
        ));
        // D s_2984_8: cast reint s_2984_7 -> u8
        let s_2984_8: u8 = (s_2984_7.value() as u8);
        // D s_2984_9: cast zx s_2984_8 -> bv
        let s_2984_9: Bits = Bits::new(s_2984_8 as u128, 3u16);
        // C s_2984_10: const #0u : u8
        let s_2984_10: u8 = 0;
        // C s_2984_11: cast zx s_2984_10 -> bv
        let s_2984_11: Bits = Bits::new(s_2984_10 as u128, 3u16);
        // D s_2984_12: cmp-eq s_2984_9 s_2984_11
        let s_2984_12: bool = ((s_2984_9) == (s_2984_11));
        // N s_2984_13: branch s_2984_12 b2987 b2985
        if s_2984_12 {
            return block_2987(state, tracer, fn_state);
        } else {
            return block_2985(state, tracer, fn_state);
        };
    }
    fn block_2985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2985_0: const #0u : u8
        let s_2985_0: bool = false;
        // D s_2985_1: write-var gs#398563 <= s_2985_0
        fn_state.gs_398563 = s_2985_0;
        // N s_2985_2: jump b2986
        return block_2986(state, tracer, fn_state);
    }
    fn block_2986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2986_0: read-var gs#398563:u8
        let s_2986_0: bool = fn_state.gs_398563;
        // D s_2986_1: write-var gs#398564 <= s_2986_0
        fn_state.gs_398564 = s_2986_0;
        // N s_2986_2: jump b2983
        return block_2983(state, tracer, fn_state);
    }
    fn block_2987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2987_0: const #4s : i
        let s_2987_0: i128 = 4;
        // D s_2987_1: read-var u#30793:u32
        let s_2987_1: u32 = fn_state.u_30793;
        // D s_2987_2: cast zx s_2987_1 -> bv
        let s_2987_2: Bits = Bits::new(s_2987_1 as u128, 32u16);
        // C s_2987_3: const #1s : i64
        let s_2987_3: i64 = 1;
        // C s_2987_4: cast zx s_2987_3 -> i
        let s_2987_4: i128 = (i128::try_from(s_2987_3).unwrap());
        // C s_2987_5: const #0s : i
        let s_2987_5: i128 = 0;
        // C s_2987_6: add s_2987_5 s_2987_4
        let s_2987_6: i128 = (s_2987_5 + s_2987_4);
        // D s_2987_7: bit-extract s_2987_2 s_2987_0 s_2987_6
        let s_2987_7: Bits = (Bits::new(
            ((s_2987_2) >> (s_2987_0)).value(),
            u16::try_from(s_2987_6).unwrap(),
        ));
        // D s_2987_8: cast reint s_2987_7 -> u8
        let s_2987_8: bool = ((s_2987_7.value()) != 0);
        // D s_2987_9: cast zx s_2987_8 -> bv
        let s_2987_9: Bits = Bits::new(s_2987_8 as u128, 1u16);
        // C s_2987_10: const #0u : u8
        let s_2987_10: bool = false;
        // C s_2987_11: cast zx s_2987_10 -> bv
        let s_2987_11: Bits = Bits::new(s_2987_10 as u128, 1u16);
        // D s_2987_12: cmp-eq s_2987_9 s_2987_11
        let s_2987_12: bool = ((s_2987_9) == (s_2987_11));
        // D s_2987_13: write-var gs#398563 <= s_2987_12
        fn_state.gs_398563 = s_2987_12;
        // N s_2987_14: jump b2986
        return block_2986(state, tracer, fn_state);
    }
    fn block_2988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2988_0: const #3395s : i
        let s_2988_0: i128 = 3395;
        // C s_2988_1: const #14696u : u32
        let s_2988_1: u32 = 14696;
        // D s_2988_2: read-reg s_2988_1:i
        let s_2988_2: i128 = {
            let value = state.read_register::<i128>(s_2988_1 as isize);
            tracer.read_register(s_2988_1 as isize, value);
            value
        };
        // D s_2988_3: cmp-lt s_2988_2 s_2988_0
        let s_2988_3: bool = ((s_2988_2) < (s_2988_0));
        // D s_2988_4: write-var gs#398531 <= s_2988_3
        fn_state.gs_398531 = s_2988_3;
        // N s_2988_5: jump b419
        return block_419(state, tracer, fn_state);
    }
    fn block_2989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2989_0: const #21s : i
        let s_2989_0: i128 = 21;
        // D s_2989_1: read-var u#30783:u32
        let s_2989_1: u32 = fn_state.u_30783;
        // D s_2989_2: cast zx s_2989_1 -> bv
        let s_2989_2: Bits = Bits::new(s_2989_1 as u128, 32u16);
        // C s_2989_3: const #1s : i64
        let s_2989_3: i64 = 1;
        // C s_2989_4: cast zx s_2989_3 -> i
        let s_2989_4: i128 = (i128::try_from(s_2989_3).unwrap());
        // C s_2989_5: const #0s : i
        let s_2989_5: i128 = 0;
        // C s_2989_6: add s_2989_5 s_2989_4
        let s_2989_6: i128 = (s_2989_5 + s_2989_4);
        // D s_2989_7: bit-extract s_2989_2 s_2989_0 s_2989_6
        let s_2989_7: Bits = (Bits::new(
            ((s_2989_2) >> (s_2989_0)).value(),
            u16::try_from(s_2989_6).unwrap(),
        ));
        // D s_2989_8: cast reint s_2989_7 -> u8
        let s_2989_8: bool = ((s_2989_7.value()) != 0);
        // D s_2989_9: cast zx s_2989_8 -> bv
        let s_2989_9: Bits = Bits::new(s_2989_8 as u128, 1u16);
        // C s_2989_10: const #0u : u8
        let s_2989_10: bool = false;
        // C s_2989_11: cast zx s_2989_10 -> bv
        let s_2989_11: Bits = Bits::new(s_2989_10 as u128, 1u16);
        // D s_2989_12: cmp-eq s_2989_9 s_2989_11
        let s_2989_12: bool = ((s_2989_9) == (s_2989_11));
        // N s_2989_13: branch s_2989_12 b2992 b2990
        if s_2989_12 {
            return block_2992(state, tracer, fn_state);
        } else {
            return block_2990(state, tracer, fn_state);
        };
    }
    fn block_2990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2990_0: const #0u : u8
        let s_2990_0: bool = false;
        // D s_2990_1: write-var gs#398528 <= s_2990_0
        fn_state.gs_398528 = s_2990_0;
        // N s_2990_2: jump b2991
        return block_2991(state, tracer, fn_state);
    }
    fn block_2991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2991_0: read-var gs#398528:u8
        let s_2991_0: bool = fn_state.gs_398528;
        // D s_2991_1: write-var gs#398529 <= s_2991_0
        fn_state.gs_398529 = s_2991_0;
        // N s_2991_2: jump b417
        return block_417(state, tracer, fn_state);
    }
    fn block_2992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2992_0: const #8s : i
        let s_2992_0: i128 = 8;
        // D s_2992_1: read-var u#30783:u32
        let s_2992_1: u32 = fn_state.u_30783;
        // D s_2992_2: cast zx s_2992_1 -> bv
        let s_2992_2: Bits = Bits::new(s_2992_1 as u128, 32u16);
        // C s_2992_3: const #1s : i64
        let s_2992_3: i64 = 1;
        // C s_2992_4: cast zx s_2992_3 -> i
        let s_2992_4: i128 = (i128::try_from(s_2992_3).unwrap());
        // C s_2992_5: const #3s : i
        let s_2992_5: i128 = 3;
        // C s_2992_6: add s_2992_5 s_2992_4
        let s_2992_6: i128 = (s_2992_5 + s_2992_4);
        // D s_2992_7: bit-extract s_2992_2 s_2992_0 s_2992_6
        let s_2992_7: Bits = (Bits::new(
            ((s_2992_2) >> (s_2992_0)).value(),
            u16::try_from(s_2992_6).unwrap(),
        ));
        // D s_2992_8: cast reint s_2992_7 -> u8
        let s_2992_8: u8 = (s_2992_7.value() as u8);
        // D s_2992_9: cast zx s_2992_8 -> bv
        let s_2992_9: Bits = Bits::new(s_2992_8 as u128, 4u16);
        // C s_2992_10: const #14u : u8
        let s_2992_10: u8 = 14;
        // C s_2992_11: cast zx s_2992_10 -> bv
        let s_2992_11: Bits = Bits::new(s_2992_10 as u128, 4u16);
        // D s_2992_12: cmp-eq s_2992_9 s_2992_11
        let s_2992_12: bool = ((s_2992_9) == (s_2992_11));
        // N s_2992_13: branch s_2992_12 b2995 b2993
        if s_2992_12 {
            return block_2995(state, tracer, fn_state);
        } else {
            return block_2993(state, tracer, fn_state);
        };
    }
    fn block_2993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2993_0: const #0u : u8
        let s_2993_0: bool = false;
        // D s_2993_1: write-var gs#398527 <= s_2993_0
        fn_state.gs_398527 = s_2993_0;
        // N s_2993_2: jump b2994
        return block_2994(state, tracer, fn_state);
    }
    fn block_2994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2994_0: read-var gs#398527:u8
        let s_2994_0: bool = fn_state.gs_398527;
        // D s_2994_1: write-var gs#398528 <= s_2994_0
        fn_state.gs_398528 = s_2994_0;
        // N s_2994_2: jump b2991
        return block_2991(state, tracer, fn_state);
    }
    fn block_2995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2995_0: const #4s : i
        let s_2995_0: i128 = 4;
        // D s_2995_1: read-var u#30783:u32
        let s_2995_1: u32 = fn_state.u_30783;
        // D s_2995_2: cast zx s_2995_1 -> bv
        let s_2995_2: Bits = Bits::new(s_2995_1 as u128, 32u16);
        // C s_2995_3: const #1s : i64
        let s_2995_3: i64 = 1;
        // C s_2995_4: cast zx s_2995_3 -> i
        let s_2995_4: i128 = (i128::try_from(s_2995_3).unwrap());
        // C s_2995_5: const #0s : i
        let s_2995_5: i128 = 0;
        // C s_2995_6: add s_2995_5 s_2995_4
        let s_2995_6: i128 = (s_2995_5 + s_2995_4);
        // D s_2995_7: bit-extract s_2995_2 s_2995_0 s_2995_6
        let s_2995_7: Bits = (Bits::new(
            ((s_2995_2) >> (s_2995_0)).value(),
            u16::try_from(s_2995_6).unwrap(),
        ));
        // D s_2995_8: cast reint s_2995_7 -> u8
        let s_2995_8: bool = ((s_2995_7.value()) != 0);
        // D s_2995_9: cast zx s_2995_8 -> bv
        let s_2995_9: Bits = Bits::new(s_2995_8 as u128, 1u16);
        // C s_2995_10: const #0u : u8
        let s_2995_10: bool = false;
        // C s_2995_11: cast zx s_2995_10 -> bv
        let s_2995_11: Bits = Bits::new(s_2995_10 as u128, 1u16);
        // D s_2995_12: cmp-eq s_2995_9 s_2995_11
        let s_2995_12: bool = ((s_2995_9) == (s_2995_11));
        // D s_2995_13: write-var gs#398527 <= s_2995_12
        fn_state.gs_398527 = s_2995_12;
        // N s_2995_14: jump b2994
        return block_2994(state, tracer, fn_state);
    }
    fn block_2996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2996_0: const #3394s : i
        let s_2996_0: i128 = 3394;
        // C s_2996_1: const #14696u : u32
        let s_2996_1: u32 = 14696;
        // D s_2996_2: read-reg s_2996_1:i
        let s_2996_2: i128 = {
            let value = state.read_register::<i128>(s_2996_1 as isize);
            tracer.read_register(s_2996_1 as isize, value);
            value
        };
        // D s_2996_3: cmp-lt s_2996_2 s_2996_0
        let s_2996_3: bool = ((s_2996_2) < (s_2996_0));
        // D s_2996_4: write-var gs#398497 <= s_2996_3
        fn_state.gs_398497 = s_2996_3;
        // N s_2996_5: jump b413
        return block_413(state, tracer, fn_state);
    }
    fn block_2997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2997_0: const #23s : i
        let s_2997_0: i128 = 23;
        // D s_2997_1: read-var u#30772:u32
        let s_2997_1: u32 = fn_state.u_30772;
        // D s_2997_2: cast zx s_2997_1 -> bv
        let s_2997_2: Bits = Bits::new(s_2997_1 as u128, 32u16);
        // C s_2997_3: const #1s : i64
        let s_2997_3: i64 = 1;
        // C s_2997_4: cast zx s_2997_3 -> i
        let s_2997_4: i128 = (i128::try_from(s_2997_3).unwrap());
        // C s_2997_5: const #0s : i
        let s_2997_5: i128 = 0;
        // C s_2997_6: add s_2997_5 s_2997_4
        let s_2997_6: i128 = (s_2997_5 + s_2997_4);
        // D s_2997_7: bit-extract s_2997_2 s_2997_0 s_2997_6
        let s_2997_7: Bits = (Bits::new(
            ((s_2997_2) >> (s_2997_0)).value(),
            u16::try_from(s_2997_6).unwrap(),
        ));
        // D s_2997_8: cast reint s_2997_7 -> u8
        let s_2997_8: bool = ((s_2997_7.value()) != 0);
        // D s_2997_9: cast zx s_2997_8 -> bv
        let s_2997_9: Bits = Bits::new(s_2997_8 as u128, 1u16);
        // C s_2997_10: const #0u : u8
        let s_2997_10: bool = false;
        // C s_2997_11: cast zx s_2997_10 -> bv
        let s_2997_11: Bits = Bits::new(s_2997_10 as u128, 1u16);
        // D s_2997_12: cmp-eq s_2997_9 s_2997_11
        let s_2997_12: bool = ((s_2997_9) == (s_2997_11));
        // N s_2997_13: branch s_2997_12 b3000 b2998
        if s_2997_12 {
            return block_3000(state, tracer, fn_state);
        } else {
            return block_2998(state, tracer, fn_state);
        };
    }
    fn block_2998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2998_0: const #0u : u8
        let s_2998_0: bool = false;
        // D s_2998_1: write-var gs#398494 <= s_2998_0
        fn_state.gs_398494 = s_2998_0;
        // N s_2998_2: jump b2999
        return block_2999(state, tracer, fn_state);
    }
    fn block_2999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2999_0: read-var gs#398494:u8
        let s_2999_0: bool = fn_state.gs_398494;
        // D s_2999_1: write-var gs#398495 <= s_2999_0
        fn_state.gs_398495 = s_2999_0;
        // N s_2999_2: jump b411
        return block_411(state, tracer, fn_state);
    }
    fn block_3000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3000_0: const #8s : i
        let s_3000_0: i128 = 8;
        // D s_3000_1: read-var u#30772:u32
        let s_3000_1: u32 = fn_state.u_30772;
        // D s_3000_2: cast zx s_3000_1 -> bv
        let s_3000_2: Bits = Bits::new(s_3000_1 as u128, 32u16);
        // C s_3000_3: const #1s : i64
        let s_3000_3: i64 = 1;
        // C s_3000_4: cast zx s_3000_3 -> i
        let s_3000_4: i128 = (i128::try_from(s_3000_3).unwrap());
        // C s_3000_5: const #3s : i
        let s_3000_5: i128 = 3;
        // C s_3000_6: add s_3000_5 s_3000_4
        let s_3000_6: i128 = (s_3000_5 + s_3000_4);
        // D s_3000_7: bit-extract s_3000_2 s_3000_0 s_3000_6
        let s_3000_7: Bits = (Bits::new(
            ((s_3000_2) >> (s_3000_0)).value(),
            u16::try_from(s_3000_6).unwrap(),
        ));
        // D s_3000_8: cast reint s_3000_7 -> u8
        let s_3000_8: u8 = (s_3000_7.value() as u8);
        // D s_3000_9: cast zx s_3000_8 -> bv
        let s_3000_9: Bits = Bits::new(s_3000_8 as u128, 4u16);
        // C s_3000_10: const #3u : u8
        let s_3000_10: u8 = 3;
        // C s_3000_11: cast zx s_3000_10 -> bv
        let s_3000_11: Bits = Bits::new(s_3000_10 as u128, 4u16);
        // D s_3000_12: cmp-eq s_3000_9 s_3000_11
        let s_3000_12: bool = ((s_3000_9) == (s_3000_11));
        // N s_3000_13: branch s_3000_12 b3003 b3001
        if s_3000_12 {
            return block_3003(state, tracer, fn_state);
        } else {
            return block_3001(state, tracer, fn_state);
        };
    }
    fn block_3001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3001_0: const #0u : u8
        let s_3001_0: bool = false;
        // D s_3001_1: write-var gs#398493 <= s_3001_0
        fn_state.gs_398493 = s_3001_0;
        // N s_3001_2: jump b3002
        return block_3002(state, tracer, fn_state);
    }
    fn block_3002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3002_0: read-var gs#398493:u8
        let s_3002_0: bool = fn_state.gs_398493;
        // D s_3002_1: write-var gs#398494 <= s_3002_0
        fn_state.gs_398494 = s_3002_0;
        // N s_3002_2: jump b2999
        return block_2999(state, tracer, fn_state);
    }
    fn block_3003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3003_0: const #4s : i
        let s_3003_0: i128 = 4;
        // D s_3003_1: read-var u#30772:u32
        let s_3003_1: u32 = fn_state.u_30772;
        // D s_3003_2: cast zx s_3003_1 -> bv
        let s_3003_2: Bits = Bits::new(s_3003_1 as u128, 32u16);
        // C s_3003_3: const #1s : i64
        let s_3003_3: i64 = 1;
        // C s_3003_4: cast zx s_3003_3 -> i
        let s_3003_4: i128 = (i128::try_from(s_3003_3).unwrap());
        // C s_3003_5: const #0s : i
        let s_3003_5: i128 = 0;
        // C s_3003_6: add s_3003_5 s_3003_4
        let s_3003_6: i128 = (s_3003_5 + s_3003_4);
        // D s_3003_7: bit-extract s_3003_2 s_3003_0 s_3003_6
        let s_3003_7: Bits = (Bits::new(
            ((s_3003_2) >> (s_3003_0)).value(),
            u16::try_from(s_3003_6).unwrap(),
        ));
        // D s_3003_8: cast reint s_3003_7 -> u8
        let s_3003_8: bool = ((s_3003_7.value()) != 0);
        // D s_3003_9: cast zx s_3003_8 -> bv
        let s_3003_9: Bits = Bits::new(s_3003_8 as u128, 1u16);
        // C s_3003_10: const #1u : u8
        let s_3003_10: bool = true;
        // C s_3003_11: cast zx s_3003_10 -> bv
        let s_3003_11: Bits = Bits::new(s_3003_10 as u128, 1u16);
        // D s_3003_12: cmp-eq s_3003_9 s_3003_11
        let s_3003_12: bool = ((s_3003_9) == (s_3003_11));
        // D s_3003_13: write-var gs#398493 <= s_3003_12
        fn_state.gs_398493 = s_3003_12;
        // N s_3003_14: jump b3002
        return block_3002(state, tracer, fn_state);
    }
    fn block_3004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3004_0: const #3392s : i
        let s_3004_0: i128 = 3392;
        // C s_3004_1: const #14696u : u32
        let s_3004_1: u32 = 14696;
        // D s_3004_2: read-reg s_3004_1:i
        let s_3004_2: i128 = {
            let value = state.read_register::<i128>(s_3004_1 as isize);
            tracer.read_register(s_3004_1 as isize, value);
            value
        };
        // D s_3004_3: cmp-lt s_3004_2 s_3004_0
        let s_3004_3: bool = ((s_3004_2) < (s_3004_0));
        // D s_3004_4: write-var gs#398467 <= s_3004_3
        fn_state.gs_398467 = s_3004_3;
        // N s_3004_5: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_3005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3005_0: const #20s : i
        let s_3005_0: i128 = 20;
        // D s_3005_1: read-var u#30763:u32
        let s_3005_1: u32 = fn_state.u_30763;
        // D s_3005_2: cast zx s_3005_1 -> bv
        let s_3005_2: Bits = Bits::new(s_3005_1 as u128, 32u16);
        // C s_3005_3: const #1s : i64
        let s_3005_3: i64 = 1;
        // C s_3005_4: cast zx s_3005_3 -> i
        let s_3005_4: i128 = (i128::try_from(s_3005_3).unwrap());
        // C s_3005_5: const #1s : i
        let s_3005_5: i128 = 1;
        // C s_3005_6: add s_3005_5 s_3005_4
        let s_3005_6: i128 = (s_3005_5 + s_3005_4);
        // D s_3005_7: bit-extract s_3005_2 s_3005_0 s_3005_6
        let s_3005_7: Bits = (Bits::new(
            ((s_3005_2) >> (s_3005_0)).value(),
            u16::try_from(s_3005_6).unwrap(),
        ));
        // D s_3005_8: cast reint s_3005_7 -> u8
        let s_3005_8: u8 = (s_3005_7.value() as u8);
        // D s_3005_9: cast zx s_3005_8 -> bv
        let s_3005_9: Bits = Bits::new(s_3005_8 as u128, 2u16);
        // C s_3005_10: const #3u : u8
        let s_3005_10: u8 = 3;
        // C s_3005_11: cast zx s_3005_10 -> bv
        let s_3005_11: Bits = Bits::new(s_3005_10 as u128, 2u16);
        // D s_3005_12: cmp-eq s_3005_9 s_3005_11
        let s_3005_12: bool = ((s_3005_9) == (s_3005_11));
        // N s_3005_13: branch s_3005_12 b3008 b3006
        if s_3005_12 {
            return block_3008(state, tracer, fn_state);
        } else {
            return block_3006(state, tracer, fn_state);
        };
    }
    fn block_3006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3006_0: const #0u : u8
        let s_3006_0: bool = false;
        // D s_3006_1: write-var gs#398464 <= s_3006_0
        fn_state.gs_398464 = s_3006_0;
        // N s_3006_2: jump b3007
        return block_3007(state, tracer, fn_state);
    }
    fn block_3007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3007_0: read-var gs#398464:u8
        let s_3007_0: bool = fn_state.gs_398464;
        // D s_3007_1: write-var gs#398465 <= s_3007_0
        fn_state.gs_398465 = s_3007_0;
        // N s_3007_2: jump b405
        return block_405(state, tracer, fn_state);
    }
    fn block_3008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3008_0: const #16s : i
        let s_3008_0: i128 = 16;
        // D s_3008_1: read-var u#30763:u32
        let s_3008_1: u32 = fn_state.u_30763;
        // D s_3008_2: cast zx s_3008_1 -> bv
        let s_3008_2: Bits = Bits::new(s_3008_1 as u128, 32u16);
        // C s_3008_3: const #1s : i64
        let s_3008_3: i64 = 1;
        // C s_3008_4: cast zx s_3008_3 -> i
        let s_3008_4: i128 = (i128::try_from(s_3008_3).unwrap());
        // C s_3008_5: const #1s : i
        let s_3008_5: i128 = 1;
        // C s_3008_6: add s_3008_5 s_3008_4
        let s_3008_6: i128 = (s_3008_5 + s_3008_4);
        // D s_3008_7: bit-extract s_3008_2 s_3008_0 s_3008_6
        let s_3008_7: Bits = (Bits::new(
            ((s_3008_2) >> (s_3008_0)).value(),
            u16::try_from(s_3008_6).unwrap(),
        ));
        // D s_3008_8: cast reint s_3008_7 -> u8
        let s_3008_8: u8 = (s_3008_7.value() as u8);
        // D s_3008_9: cast zx s_3008_8 -> bv
        let s_3008_9: Bits = Bits::new(s_3008_8 as u128, 2u16);
        // C s_3008_10: const #1u : u8
        let s_3008_10: u8 = 1;
        // C s_3008_11: cast zx s_3008_10 -> bv
        let s_3008_11: Bits = Bits::new(s_3008_10 as u128, 2u16);
        // D s_3008_12: cmp-eq s_3008_9 s_3008_11
        let s_3008_12: bool = ((s_3008_9) == (s_3008_11));
        // N s_3008_13: branch s_3008_12 b3011 b3009
        if s_3008_12 {
            return block_3011(state, tracer, fn_state);
        } else {
            return block_3009(state, tracer, fn_state);
        };
    }
    fn block_3009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3009_0: const #0u : u8
        let s_3009_0: bool = false;
        // D s_3009_1: write-var gs#398463 <= s_3009_0
        fn_state.gs_398463 = s_3009_0;
        // N s_3009_2: jump b3010
        return block_3010(state, tracer, fn_state);
    }
    fn block_3010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3010_0: read-var gs#398463:u8
        let s_3010_0: bool = fn_state.gs_398463;
        // D s_3010_1: write-var gs#398464 <= s_3010_0
        fn_state.gs_398464 = s_3010_0;
        // N s_3010_2: jump b3007
        return block_3007(state, tracer, fn_state);
    }
    fn block_3011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3011_0: const #11s : i
        let s_3011_0: i128 = 11;
        // D s_3011_1: read-var u#30763:u32
        let s_3011_1: u32 = fn_state.u_30763;
        // D s_3011_2: cast zx s_3011_1 -> bv
        let s_3011_2: Bits = Bits::new(s_3011_1 as u128, 32u16);
        // C s_3011_3: const #1s : i64
        let s_3011_3: i64 = 1;
        // C s_3011_4: cast zx s_3011_3 -> i
        let s_3011_4: i128 = (i128::try_from(s_3011_3).unwrap());
        // C s_3011_5: const #0s : i
        let s_3011_5: i128 = 0;
        // C s_3011_6: add s_3011_5 s_3011_4
        let s_3011_6: i128 = (s_3011_5 + s_3011_4);
        // D s_3011_7: bit-extract s_3011_2 s_3011_0 s_3011_6
        let s_3011_7: Bits = (Bits::new(
            ((s_3011_2) >> (s_3011_0)).value(),
            u16::try_from(s_3011_6).unwrap(),
        ));
        // D s_3011_8: cast reint s_3011_7 -> u8
        let s_3011_8: bool = ((s_3011_7.value()) != 0);
        // D s_3011_9: cast zx s_3011_8 -> bv
        let s_3011_9: Bits = Bits::new(s_3011_8 as u128, 1u16);
        // C s_3011_10: const #0u : u8
        let s_3011_10: bool = false;
        // C s_3011_11: cast zx s_3011_10 -> bv
        let s_3011_11: Bits = Bits::new(s_3011_10 as u128, 1u16);
        // D s_3011_12: cmp-eq s_3011_9 s_3011_11
        let s_3011_12: bool = ((s_3011_9) == (s_3011_11));
        // N s_3011_13: branch s_3011_12 b3014 b3012
        if s_3011_12 {
            return block_3014(state, tracer, fn_state);
        } else {
            return block_3012(state, tracer, fn_state);
        };
    }
    fn block_3012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3012_0: const #0u : u8
        let s_3012_0: bool = false;
        // D s_3012_1: write-var gs#398462 <= s_3012_0
        fn_state.gs_398462 = s_3012_0;
        // N s_3012_2: jump b3013
        return block_3013(state, tracer, fn_state);
    }
    fn block_3013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3013_0: read-var gs#398462:u8
        let s_3013_0: bool = fn_state.gs_398462;
        // D s_3013_1: write-var gs#398463 <= s_3013_0
        fn_state.gs_398463 = s_3013_0;
        // N s_3013_2: jump b3010
        return block_3010(state, tracer, fn_state);
    }
    fn block_3014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3014_0: const #7s : i
        let s_3014_0: i128 = 7;
        // D s_3014_1: read-var u#30763:u32
        let s_3014_1: u32 = fn_state.u_30763;
        // D s_3014_2: cast zx s_3014_1 -> bv
        let s_3014_2: Bits = Bits::new(s_3014_1 as u128, 32u16);
        // C s_3014_3: const #1s : i64
        let s_3014_3: i64 = 1;
        // C s_3014_4: cast zx s_3014_3 -> i
        let s_3014_4: i128 = (i128::try_from(s_3014_3).unwrap());
        // C s_3014_5: const #2s : i
        let s_3014_5: i128 = 2;
        // C s_3014_6: add s_3014_5 s_3014_4
        let s_3014_6: i128 = (s_3014_5 + s_3014_4);
        // D s_3014_7: bit-extract s_3014_2 s_3014_0 s_3014_6
        let s_3014_7: Bits = (Bits::new(
            ((s_3014_2) >> (s_3014_0)).value(),
            u16::try_from(s_3014_6).unwrap(),
        ));
        // D s_3014_8: cast reint s_3014_7 -> u8
        let s_3014_8: u8 = (s_3014_7.value() as u8);
        // D s_3014_9: cast zx s_3014_8 -> bv
        let s_3014_9: Bits = Bits::new(s_3014_8 as u128, 3u16);
        // C s_3014_10: const #1u : u8
        let s_3014_10: u8 = 1;
        // C s_3014_11: cast zx s_3014_10 -> bv
        let s_3014_11: Bits = Bits::new(s_3014_10 as u128, 3u16);
        // D s_3014_12: cmp-eq s_3014_9 s_3014_11
        let s_3014_12: bool = ((s_3014_9) == (s_3014_11));
        // N s_3014_13: branch s_3014_12 b3017 b3015
        if s_3014_12 {
            return block_3017(state, tracer, fn_state);
        } else {
            return block_3015(state, tracer, fn_state);
        };
    }
    fn block_3015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3015_0: const #0u : u8
        let s_3015_0: bool = false;
        // D s_3015_1: write-var gs#398461 <= s_3015_0
        fn_state.gs_398461 = s_3015_0;
        // N s_3015_2: jump b3016
        return block_3016(state, tracer, fn_state);
    }
    fn block_3016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3016_0: read-var gs#398461:u8
        let s_3016_0: bool = fn_state.gs_398461;
        // D s_3016_1: write-var gs#398462 <= s_3016_0
        fn_state.gs_398462 = s_3016_0;
        // N s_3016_2: jump b3013
        return block_3013(state, tracer, fn_state);
    }
    fn block_3017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3017_0: const #4s : i
        let s_3017_0: i128 = 4;
        // D s_3017_1: read-var u#30763:u32
        let s_3017_1: u32 = fn_state.u_30763;
        // D s_3017_2: cast zx s_3017_1 -> bv
        let s_3017_2: Bits = Bits::new(s_3017_1 as u128, 32u16);
        // C s_3017_3: const #1s : i64
        let s_3017_3: i64 = 1;
        // C s_3017_4: cast zx s_3017_3 -> i
        let s_3017_4: i128 = (i128::try_from(s_3017_3).unwrap());
        // C s_3017_5: const #0s : i
        let s_3017_5: i128 = 0;
        // C s_3017_6: add s_3017_5 s_3017_4
        let s_3017_6: i128 = (s_3017_5 + s_3017_4);
        // D s_3017_7: bit-extract s_3017_2 s_3017_0 s_3017_6
        let s_3017_7: Bits = (Bits::new(
            ((s_3017_2) >> (s_3017_0)).value(),
            u16::try_from(s_3017_6).unwrap(),
        ));
        // D s_3017_8: cast reint s_3017_7 -> u8
        let s_3017_8: bool = ((s_3017_7.value()) != 0);
        // D s_3017_9: cast zx s_3017_8 -> bv
        let s_3017_9: Bits = Bits::new(s_3017_8 as u128, 1u16);
        // C s_3017_10: const #0u : u8
        let s_3017_10: bool = false;
        // C s_3017_11: cast zx s_3017_10 -> bv
        let s_3017_11: Bits = Bits::new(s_3017_10 as u128, 1u16);
        // D s_3017_12: cmp-eq s_3017_9 s_3017_11
        let s_3017_12: bool = ((s_3017_9) == (s_3017_11));
        // D s_3017_13: write-var gs#398461 <= s_3017_12
        fn_state.gs_398461 = s_3017_12;
        // N s_3017_14: jump b3016
        return block_3016(state, tracer, fn_state);
    }
    fn block_3018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3018_0: const #3389s : i
        let s_3018_0: i128 = 3389;
        // C s_3018_1: const #14696u : u32
        let s_3018_1: u32 = 14696;
        // D s_3018_2: read-reg s_3018_1:i
        let s_3018_2: i128 = {
            let value = state.read_register::<i128>(s_3018_1 as isize);
            tracer.read_register(s_3018_1 as isize, value);
            value
        };
        // D s_3018_3: cmp-lt s_3018_2 s_3018_0
        let s_3018_3: bool = ((s_3018_2) < (s_3018_0));
        // D s_3018_4: write-var gs#398429 <= s_3018_3
        fn_state.gs_398429 = s_3018_3;
        // N s_3018_5: jump b401
        return block_401(state, tracer, fn_state);
    }
    fn block_3019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3019_0: const #21s : i
        let s_3019_0: i128 = 21;
        // D s_3019_1: read-var u#30753:u32
        let s_3019_1: u32 = fn_state.u_30753;
        // D s_3019_2: cast zx s_3019_1 -> bv
        let s_3019_2: Bits = Bits::new(s_3019_1 as u128, 32u16);
        // C s_3019_3: const #1s : i64
        let s_3019_3: i64 = 1;
        // C s_3019_4: cast zx s_3019_3 -> i
        let s_3019_4: i128 = (i128::try_from(s_3019_3).unwrap());
        // C s_3019_5: const #0s : i
        let s_3019_5: i128 = 0;
        // C s_3019_6: add s_3019_5 s_3019_4
        let s_3019_6: i128 = (s_3019_5 + s_3019_4);
        // D s_3019_7: bit-extract s_3019_2 s_3019_0 s_3019_6
        let s_3019_7: Bits = (Bits::new(
            ((s_3019_2) >> (s_3019_0)).value(),
            u16::try_from(s_3019_6).unwrap(),
        ));
        // D s_3019_8: cast reint s_3019_7 -> u8
        let s_3019_8: bool = ((s_3019_7.value()) != 0);
        // D s_3019_9: cast zx s_3019_8 -> bv
        let s_3019_9: Bits = Bits::new(s_3019_8 as u128, 1u16);
        // C s_3019_10: const #0u : u8
        let s_3019_10: bool = false;
        // C s_3019_11: cast zx s_3019_10 -> bv
        let s_3019_11: Bits = Bits::new(s_3019_10 as u128, 1u16);
        // D s_3019_12: cmp-eq s_3019_9 s_3019_11
        let s_3019_12: bool = ((s_3019_9) == (s_3019_11));
        // N s_3019_13: branch s_3019_12 b3022 b3020
        if s_3019_12 {
            return block_3022(state, tracer, fn_state);
        } else {
            return block_3020(state, tracer, fn_state);
        };
    }
    fn block_3020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3020_0: const #0u : u8
        let s_3020_0: bool = false;
        // D s_3020_1: write-var gs#398426 <= s_3020_0
        fn_state.gs_398426 = s_3020_0;
        // N s_3020_2: jump b3021
        return block_3021(state, tracer, fn_state);
    }
    fn block_3021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3021_0: read-var gs#398426:u8
        let s_3021_0: bool = fn_state.gs_398426;
        // D s_3021_1: write-var gs#398427 <= s_3021_0
        fn_state.gs_398427 = s_3021_0;
        // N s_3021_2: jump b399
        return block_399(state, tracer, fn_state);
    }
    fn block_3022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3022_0: const #8s : i
        let s_3022_0: i128 = 8;
        // D s_3022_1: read-var u#30753:u32
        let s_3022_1: u32 = fn_state.u_30753;
        // D s_3022_2: cast zx s_3022_1 -> bv
        let s_3022_2: Bits = Bits::new(s_3022_1 as u128, 32u16);
        // C s_3022_3: const #1s : i64
        let s_3022_3: i64 = 1;
        // C s_3022_4: cast zx s_3022_3 -> i
        let s_3022_4: i128 = (i128::try_from(s_3022_3).unwrap());
        // C s_3022_5: const #3s : i
        let s_3022_5: i128 = 3;
        // C s_3022_6: add s_3022_5 s_3022_4
        let s_3022_6: i128 = (s_3022_5 + s_3022_4);
        // D s_3022_7: bit-extract s_3022_2 s_3022_0 s_3022_6
        let s_3022_7: Bits = (Bits::new(
            ((s_3022_2) >> (s_3022_0)).value(),
            u16::try_from(s_3022_6).unwrap(),
        ));
        // D s_3022_8: cast reint s_3022_7 -> u8
        let s_3022_8: u8 = (s_3022_7.value() as u8);
        // D s_3022_9: cast zx s_3022_8 -> bv
        let s_3022_9: Bits = Bits::new(s_3022_8 as u128, 4u16);
        // C s_3022_10: const #14u : u8
        let s_3022_10: u8 = 14;
        // C s_3022_11: cast zx s_3022_10 -> bv
        let s_3022_11: Bits = Bits::new(s_3022_10 as u128, 4u16);
        // D s_3022_12: cmp-eq s_3022_9 s_3022_11
        let s_3022_12: bool = ((s_3022_9) == (s_3022_11));
        // N s_3022_13: branch s_3022_12 b3025 b3023
        if s_3022_12 {
            return block_3025(state, tracer, fn_state);
        } else {
            return block_3023(state, tracer, fn_state);
        };
    }
    fn block_3023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3023_0: const #0u : u8
        let s_3023_0: bool = false;
        // D s_3023_1: write-var gs#398425 <= s_3023_0
        fn_state.gs_398425 = s_3023_0;
        // N s_3023_2: jump b3024
        return block_3024(state, tracer, fn_state);
    }
    fn block_3024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3024_0: read-var gs#398425:u8
        let s_3024_0: bool = fn_state.gs_398425;
        // D s_3024_1: write-var gs#398426 <= s_3024_0
        fn_state.gs_398426 = s_3024_0;
        // N s_3024_2: jump b3021
        return block_3021(state, tracer, fn_state);
    }
    fn block_3025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3025_0: const #4s : i
        let s_3025_0: i128 = 4;
        // D s_3025_1: read-var u#30753:u32
        let s_3025_1: u32 = fn_state.u_30753;
        // D s_3025_2: cast zx s_3025_1 -> bv
        let s_3025_2: Bits = Bits::new(s_3025_1 as u128, 32u16);
        // C s_3025_3: const #1s : i64
        let s_3025_3: i64 = 1;
        // C s_3025_4: cast zx s_3025_3 -> i
        let s_3025_4: i128 = (i128::try_from(s_3025_3).unwrap());
        // C s_3025_5: const #0s : i
        let s_3025_5: i128 = 0;
        // C s_3025_6: add s_3025_5 s_3025_4
        let s_3025_6: i128 = (s_3025_5 + s_3025_4);
        // D s_3025_7: bit-extract s_3025_2 s_3025_0 s_3025_6
        let s_3025_7: Bits = (Bits::new(
            ((s_3025_2) >> (s_3025_0)).value(),
            u16::try_from(s_3025_6).unwrap(),
        ));
        // D s_3025_8: cast reint s_3025_7 -> u8
        let s_3025_8: bool = ((s_3025_7.value()) != 0);
        // D s_3025_9: cast zx s_3025_8 -> bv
        let s_3025_9: Bits = Bits::new(s_3025_8 as u128, 1u16);
        // C s_3025_10: const #0u : u8
        let s_3025_10: bool = false;
        // C s_3025_11: cast zx s_3025_10 -> bv
        let s_3025_11: Bits = Bits::new(s_3025_10 as u128, 1u16);
        // D s_3025_12: cmp-eq s_3025_9 s_3025_11
        let s_3025_12: bool = ((s_3025_9) == (s_3025_11));
        // D s_3025_13: write-var gs#398425 <= s_3025_12
        fn_state.gs_398425 = s_3025_12;
        // N s_3025_14: jump b3024
        return block_3024(state, tracer, fn_state);
    }
    fn block_3026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3026_0: const #3388s : i
        let s_3026_0: i128 = 3388;
        // C s_3026_1: const #14696u : u32
        let s_3026_1: u32 = 14696;
        // D s_3026_2: read-reg s_3026_1:i
        let s_3026_2: i128 = {
            let value = state.read_register::<i128>(s_3026_1 as isize);
            tracer.read_register(s_3026_1 as isize, value);
            value
        };
        // D s_3026_3: cmp-lt s_3026_2 s_3026_0
        let s_3026_3: bool = ((s_3026_2) < (s_3026_0));
        // D s_3026_4: write-var gs#398397 <= s_3026_3
        fn_state.gs_398397 = s_3026_3;
        // N s_3026_5: jump b395
        return block_395(state, tracer, fn_state);
    }
    fn block_3027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3027_0: const #8s : i
        let s_3027_0: i128 = 8;
        // D s_3027_1: read-var u#30743:u32
        let s_3027_1: u32 = fn_state.u_30743;
        // D s_3027_2: cast zx s_3027_1 -> bv
        let s_3027_2: Bits = Bits::new(s_3027_1 as u128, 32u16);
        // C s_3027_3: const #1s : i64
        let s_3027_3: i64 = 1;
        // C s_3027_4: cast zx s_3027_3 -> i
        let s_3027_4: i128 = (i128::try_from(s_3027_3).unwrap());
        // C s_3027_5: const #3s : i
        let s_3027_5: i128 = 3;
        // C s_3027_6: add s_3027_5 s_3027_4
        let s_3027_6: i128 = (s_3027_5 + s_3027_4);
        // D s_3027_7: bit-extract s_3027_2 s_3027_0 s_3027_6
        let s_3027_7: Bits = (Bits::new(
            ((s_3027_2) >> (s_3027_0)).value(),
            u16::try_from(s_3027_6).unwrap(),
        ));
        // D s_3027_8: cast reint s_3027_7 -> u8
        let s_3027_8: u8 = (s_3027_7.value() as u8);
        // D s_3027_9: cast zx s_3027_8 -> bv
        let s_3027_9: Bits = Bits::new(s_3027_8 as u128, 4u16);
        // C s_3027_10: const #8u : u8
        let s_3027_10: u8 = 8;
        // C s_3027_11: cast zx s_3027_10 -> bv
        let s_3027_11: Bits = Bits::new(s_3027_10 as u128, 4u16);
        // D s_3027_12: cmp-eq s_3027_9 s_3027_11
        let s_3027_12: bool = ((s_3027_9) == (s_3027_11));
        // N s_3027_13: branch s_3027_12 b3030 b3028
        if s_3027_12 {
            return block_3030(state, tracer, fn_state);
        } else {
            return block_3028(state, tracer, fn_state);
        };
    }
    fn block_3028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3028_0: const #0u : u8
        let s_3028_0: bool = false;
        // D s_3028_1: write-var gs#398394 <= s_3028_0
        fn_state.gs_398394 = s_3028_0;
        // N s_3028_2: jump b3029
        return block_3029(state, tracer, fn_state);
    }
    fn block_3029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3029_0: read-var gs#398394:u8
        let s_3029_0: bool = fn_state.gs_398394;
        // D s_3029_1: write-var gs#398395 <= s_3029_0
        fn_state.gs_398395 = s_3029_0;
        // N s_3029_2: jump b393
        return block_393(state, tracer, fn_state);
    }
    fn block_3030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3030_0: const #4s : i
        let s_3030_0: i128 = 4;
        // D s_3030_1: read-var u#30743:u32
        let s_3030_1: u32 = fn_state.u_30743;
        // D s_3030_2: cast zx s_3030_1 -> bv
        let s_3030_2: Bits = Bits::new(s_3030_1 as u128, 32u16);
        // C s_3030_3: const #1s : i64
        let s_3030_3: i64 = 1;
        // C s_3030_4: cast zx s_3030_3 -> i
        let s_3030_4: i128 = (i128::try_from(s_3030_3).unwrap());
        // C s_3030_5: const #0s : i
        let s_3030_5: i128 = 0;
        // C s_3030_6: add s_3030_5 s_3030_4
        let s_3030_6: i128 = (s_3030_5 + s_3030_4);
        // D s_3030_7: bit-extract s_3030_2 s_3030_0 s_3030_6
        let s_3030_7: Bits = (Bits::new(
            ((s_3030_2) >> (s_3030_0)).value(),
            u16::try_from(s_3030_6).unwrap(),
        ));
        // D s_3030_8: cast reint s_3030_7 -> u8
        let s_3030_8: bool = ((s_3030_7.value()) != 0);
        // D s_3030_9: cast zx s_3030_8 -> bv
        let s_3030_9: Bits = Bits::new(s_3030_8 as u128, 1u16);
        // C s_3030_10: const #1u : u8
        let s_3030_10: bool = true;
        // C s_3030_11: cast zx s_3030_10 -> bv
        let s_3030_11: Bits = Bits::new(s_3030_10 as u128, 1u16);
        // D s_3030_12: cmp-eq s_3030_9 s_3030_11
        let s_3030_12: bool = ((s_3030_9) == (s_3030_11));
        // D s_3030_13: write-var gs#398394 <= s_3030_12
        fn_state.gs_398394 = s_3030_12;
        // N s_3030_14: jump b3029
        return block_3029(state, tracer, fn_state);
    }
    fn block_3031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3031_0: const #3386s : i
        let s_3031_0: i128 = 3386;
        // C s_3031_1: const #14696u : u32
        let s_3031_1: u32 = 14696;
        // D s_3031_2: read-reg s_3031_1:i
        let s_3031_2: i128 = {
            let value = state.read_register::<i128>(s_3031_1 as isize);
            tracer.read_register(s_3031_1 as isize, value);
            value
        };
        // D s_3031_3: cmp-lt s_3031_2 s_3031_0
        let s_3031_3: bool = ((s_3031_2) < (s_3031_0));
        // D s_3031_4: write-var gs#398370 <= s_3031_3
        fn_state.gs_398370 = s_3031_3;
        // N s_3031_5: jump b389
        return block_389(state, tracer, fn_state);
    }
    fn block_3032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3032_0: const #20s : i
        let s_3032_0: i128 = 20;
        // D s_3032_1: read-var u#30734:u32
        let s_3032_1: u32 = fn_state.u_30734;
        // D s_3032_2: cast zx s_3032_1 -> bv
        let s_3032_2: Bits = Bits::new(s_3032_1 as u128, 32u16);
        // C s_3032_3: const #1s : i64
        let s_3032_3: i64 = 1;
        // C s_3032_4: cast zx s_3032_3 -> i
        let s_3032_4: i128 = (i128::try_from(s_3032_3).unwrap());
        // C s_3032_5: const #1s : i
        let s_3032_5: i128 = 1;
        // C s_3032_6: add s_3032_5 s_3032_4
        let s_3032_6: i128 = (s_3032_5 + s_3032_4);
        // D s_3032_7: bit-extract s_3032_2 s_3032_0 s_3032_6
        let s_3032_7: Bits = (Bits::new(
            ((s_3032_2) >> (s_3032_0)).value(),
            u16::try_from(s_3032_6).unwrap(),
        ));
        // D s_3032_8: cast reint s_3032_7 -> u8
        let s_3032_8: u8 = (s_3032_7.value() as u8);
        // D s_3032_9: cast zx s_3032_8 -> bv
        let s_3032_9: Bits = Bits::new(s_3032_8 as u128, 2u16);
        // C s_3032_10: const #3u : u8
        let s_3032_10: u8 = 3;
        // C s_3032_11: cast zx s_3032_10 -> bv
        let s_3032_11: Bits = Bits::new(s_3032_10 as u128, 2u16);
        // D s_3032_12: cmp-eq s_3032_9 s_3032_11
        let s_3032_12: bool = ((s_3032_9) == (s_3032_11));
        // N s_3032_13: branch s_3032_12 b3035 b3033
        if s_3032_12 {
            return block_3035(state, tracer, fn_state);
        } else {
            return block_3033(state, tracer, fn_state);
        };
    }
    fn block_3033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3033_0: const #0u : u8
        let s_3033_0: bool = false;
        // D s_3033_1: write-var gs#398367 <= s_3033_0
        fn_state.gs_398367 = s_3033_0;
        // N s_3033_2: jump b3034
        return block_3034(state, tracer, fn_state);
    }
    fn block_3034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3034_0: read-var gs#398367:u8
        let s_3034_0: bool = fn_state.gs_398367;
        // D s_3034_1: write-var gs#398368 <= s_3034_0
        fn_state.gs_398368 = s_3034_0;
        // N s_3034_2: jump b387
        return block_387(state, tracer, fn_state);
    }
    fn block_3035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3035_0: const #16s : i
        let s_3035_0: i128 = 16;
        // D s_3035_1: read-var u#30734:u32
        let s_3035_1: u32 = fn_state.u_30734;
        // D s_3035_2: cast zx s_3035_1 -> bv
        let s_3035_2: Bits = Bits::new(s_3035_1 as u128, 32u16);
        // C s_3035_3: const #1s : i64
        let s_3035_3: i64 = 1;
        // C s_3035_4: cast zx s_3035_3 -> i
        let s_3035_4: i128 = (i128::try_from(s_3035_3).unwrap());
        // C s_3035_5: const #1s : i
        let s_3035_5: i128 = 1;
        // C s_3035_6: add s_3035_5 s_3035_4
        let s_3035_6: i128 = (s_3035_5 + s_3035_4);
        // D s_3035_7: bit-extract s_3035_2 s_3035_0 s_3035_6
        let s_3035_7: Bits = (Bits::new(
            ((s_3035_2) >> (s_3035_0)).value(),
            u16::try_from(s_3035_6).unwrap(),
        ));
        // D s_3035_8: cast reint s_3035_7 -> u8
        let s_3035_8: u8 = (s_3035_7.value() as u8);
        // D s_3035_9: cast zx s_3035_8 -> bv
        let s_3035_9: Bits = Bits::new(s_3035_8 as u128, 2u16);
        // C s_3035_10: const #1u : u8
        let s_3035_10: u8 = 1;
        // C s_3035_11: cast zx s_3035_10 -> bv
        let s_3035_11: Bits = Bits::new(s_3035_10 as u128, 2u16);
        // D s_3035_12: cmp-eq s_3035_9 s_3035_11
        let s_3035_12: bool = ((s_3035_9) == (s_3035_11));
        // N s_3035_13: branch s_3035_12 b3038 b3036
        if s_3035_12 {
            return block_3038(state, tracer, fn_state);
        } else {
            return block_3036(state, tracer, fn_state);
        };
    }
    fn block_3036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3036_0: const #0u : u8
        let s_3036_0: bool = false;
        // D s_3036_1: write-var gs#398366 <= s_3036_0
        fn_state.gs_398366 = s_3036_0;
        // N s_3036_2: jump b3037
        return block_3037(state, tracer, fn_state);
    }
    fn block_3037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3037_0: read-var gs#398366:u8
        let s_3037_0: bool = fn_state.gs_398366;
        // D s_3037_1: write-var gs#398367 <= s_3037_0
        fn_state.gs_398367 = s_3037_0;
        // N s_3037_2: jump b3034
        return block_3034(state, tracer, fn_state);
    }
    fn block_3038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3038_0: const #11s : i
        let s_3038_0: i128 = 11;
        // D s_3038_1: read-var u#30734:u32
        let s_3038_1: u32 = fn_state.u_30734;
        // D s_3038_2: cast zx s_3038_1 -> bv
        let s_3038_2: Bits = Bits::new(s_3038_1 as u128, 32u16);
        // C s_3038_3: const #1s : i64
        let s_3038_3: i64 = 1;
        // C s_3038_4: cast zx s_3038_3 -> i
        let s_3038_4: i128 = (i128::try_from(s_3038_3).unwrap());
        // C s_3038_5: const #0s : i
        let s_3038_5: i128 = 0;
        // C s_3038_6: add s_3038_5 s_3038_4
        let s_3038_6: i128 = (s_3038_5 + s_3038_4);
        // D s_3038_7: bit-extract s_3038_2 s_3038_0 s_3038_6
        let s_3038_7: Bits = (Bits::new(
            ((s_3038_2) >> (s_3038_0)).value(),
            u16::try_from(s_3038_6).unwrap(),
        ));
        // D s_3038_8: cast reint s_3038_7 -> u8
        let s_3038_8: bool = ((s_3038_7.value()) != 0);
        // D s_3038_9: cast zx s_3038_8 -> bv
        let s_3038_9: Bits = Bits::new(s_3038_8 as u128, 1u16);
        // C s_3038_10: const #0u : u8
        let s_3038_10: bool = false;
        // C s_3038_11: cast zx s_3038_10 -> bv
        let s_3038_11: Bits = Bits::new(s_3038_10 as u128, 1u16);
        // D s_3038_12: cmp-eq s_3038_9 s_3038_11
        let s_3038_12: bool = ((s_3038_9) == (s_3038_11));
        // N s_3038_13: branch s_3038_12 b3041 b3039
        if s_3038_12 {
            return block_3041(state, tracer, fn_state);
        } else {
            return block_3039(state, tracer, fn_state);
        };
    }
    fn block_3039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3039_0: const #0u : u8
        let s_3039_0: bool = false;
        // D s_3039_1: write-var gs#398365 <= s_3039_0
        fn_state.gs_398365 = s_3039_0;
        // N s_3039_2: jump b3040
        return block_3040(state, tracer, fn_state);
    }
    fn block_3040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3040_0: read-var gs#398365:u8
        let s_3040_0: bool = fn_state.gs_398365;
        // D s_3040_1: write-var gs#398366 <= s_3040_0
        fn_state.gs_398366 = s_3040_0;
        // N s_3040_2: jump b3037
        return block_3037(state, tracer, fn_state);
    }
    fn block_3041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3041_0: const #7s : i
        let s_3041_0: i128 = 7;
        // D s_3041_1: read-var u#30734:u32
        let s_3041_1: u32 = fn_state.u_30734;
        // D s_3041_2: cast zx s_3041_1 -> bv
        let s_3041_2: Bits = Bits::new(s_3041_1 as u128, 32u16);
        // C s_3041_3: const #1s : i64
        let s_3041_3: i64 = 1;
        // C s_3041_4: cast zx s_3041_3 -> i
        let s_3041_4: i128 = (i128::try_from(s_3041_3).unwrap());
        // C s_3041_5: const #2s : i
        let s_3041_5: i128 = 2;
        // C s_3041_6: add s_3041_5 s_3041_4
        let s_3041_6: i128 = (s_3041_5 + s_3041_4);
        // D s_3041_7: bit-extract s_3041_2 s_3041_0 s_3041_6
        let s_3041_7: Bits = (Bits::new(
            ((s_3041_2) >> (s_3041_0)).value(),
            u16::try_from(s_3041_6).unwrap(),
        ));
        // D s_3041_8: cast reint s_3041_7 -> u8
        let s_3041_8: u8 = (s_3041_7.value() as u8);
        // D s_3041_9: cast zx s_3041_8 -> bv
        let s_3041_9: Bits = Bits::new(s_3041_8 as u128, 3u16);
        // C s_3041_10: const #2u : u8
        let s_3041_10: u8 = 2;
        // C s_3041_11: cast zx s_3041_10 -> bv
        let s_3041_11: Bits = Bits::new(s_3041_10 as u128, 3u16);
        // D s_3041_12: cmp-eq s_3041_9 s_3041_11
        let s_3041_12: bool = ((s_3041_9) == (s_3041_11));
        // N s_3041_13: branch s_3041_12 b3044 b3042
        if s_3041_12 {
            return block_3044(state, tracer, fn_state);
        } else {
            return block_3042(state, tracer, fn_state);
        };
    }
    fn block_3042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3042_0: const #0u : u8
        let s_3042_0: bool = false;
        // D s_3042_1: write-var gs#398364 <= s_3042_0
        fn_state.gs_398364 = s_3042_0;
        // N s_3042_2: jump b3043
        return block_3043(state, tracer, fn_state);
    }
    fn block_3043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3043_0: read-var gs#398364:u8
        let s_3043_0: bool = fn_state.gs_398364;
        // D s_3043_1: write-var gs#398365 <= s_3043_0
        fn_state.gs_398365 = s_3043_0;
        // N s_3043_2: jump b3040
        return block_3040(state, tracer, fn_state);
    }
    fn block_3044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3044_0: const #4s : i
        let s_3044_0: i128 = 4;
        // D s_3044_1: read-var u#30734:u32
        let s_3044_1: u32 = fn_state.u_30734;
        // D s_3044_2: cast zx s_3044_1 -> bv
        let s_3044_2: Bits = Bits::new(s_3044_1 as u128, 32u16);
        // C s_3044_3: const #1s : i64
        let s_3044_3: i64 = 1;
        // C s_3044_4: cast zx s_3044_3 -> i
        let s_3044_4: i128 = (i128::try_from(s_3044_3).unwrap());
        // C s_3044_5: const #0s : i
        let s_3044_5: i128 = 0;
        // C s_3044_6: add s_3044_5 s_3044_4
        let s_3044_6: i128 = (s_3044_5 + s_3044_4);
        // D s_3044_7: bit-extract s_3044_2 s_3044_0 s_3044_6
        let s_3044_7: Bits = (Bits::new(
            ((s_3044_2) >> (s_3044_0)).value(),
            u16::try_from(s_3044_6).unwrap(),
        ));
        // D s_3044_8: cast reint s_3044_7 -> u8
        let s_3044_8: bool = ((s_3044_7.value()) != 0);
        // D s_3044_9: cast zx s_3044_8 -> bv
        let s_3044_9: Bits = Bits::new(s_3044_8 as u128, 1u16);
        // C s_3044_10: const #0u : u8
        let s_3044_10: bool = false;
        // C s_3044_11: cast zx s_3044_10 -> bv
        let s_3044_11: Bits = Bits::new(s_3044_10 as u128, 1u16);
        // D s_3044_12: cmp-eq s_3044_9 s_3044_11
        let s_3044_12: bool = ((s_3044_9) == (s_3044_11));
        // D s_3044_13: write-var gs#398364 <= s_3044_12
        fn_state.gs_398364 = s_3044_12;
        // N s_3044_14: jump b3043
        return block_3043(state, tracer, fn_state);
    }
    fn block_3045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3045_0: const #3384s : i
        let s_3045_0: i128 = 3384;
        // C s_3045_1: const #14696u : u32
        let s_3045_1: u32 = 14696;
        // D s_3045_2: read-reg s_3045_1:i
        let s_3045_2: i128 = {
            let value = state.read_register::<i128>(s_3045_1 as isize);
            tracer.read_register(s_3045_1 as isize, value);
            value
        };
        // D s_3045_3: cmp-lt s_3045_2 s_3045_0
        let s_3045_3: bool = ((s_3045_2) < (s_3045_0));
        // D s_3045_4: write-var gs#398332 <= s_3045_3
        fn_state.gs_398332 = s_3045_3;
        // N s_3045_5: jump b383
        return block_383(state, tracer, fn_state);
    }
    fn block_3046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3046_0: const #8s : i
        let s_3046_0: i128 = 8;
        // D s_3046_1: read-var u#30724:u32
        let s_3046_1: u32 = fn_state.u_30724;
        // D s_3046_2: cast zx s_3046_1 -> bv
        let s_3046_2: Bits = Bits::new(s_3046_1 as u128, 32u16);
        // C s_3046_3: const #1s : i64
        let s_3046_3: i64 = 1;
        // C s_3046_4: cast zx s_3046_3 -> i
        let s_3046_4: i128 = (i128::try_from(s_3046_3).unwrap());
        // C s_3046_5: const #3s : i
        let s_3046_5: i128 = 3;
        // C s_3046_6: add s_3046_5 s_3046_4
        let s_3046_6: i128 = (s_3046_5 + s_3046_4);
        // D s_3046_7: bit-extract s_3046_2 s_3046_0 s_3046_6
        let s_3046_7: Bits = (Bits::new(
            ((s_3046_2) >> (s_3046_0)).value(),
            u16::try_from(s_3046_6).unwrap(),
        ));
        // D s_3046_8: cast reint s_3046_7 -> u8
        let s_3046_8: u8 = (s_3046_7.value() as u8);
        // D s_3046_9: cast zx s_3046_8 -> bv
        let s_3046_9: Bits = Bits::new(s_3046_8 as u128, 4u16);
        // C s_3046_10: const #1u : u8
        let s_3046_10: u8 = 1;
        // C s_3046_11: cast zx s_3046_10 -> bv
        let s_3046_11: Bits = Bits::new(s_3046_10 as u128, 4u16);
        // D s_3046_12: cmp-eq s_3046_9 s_3046_11
        let s_3046_12: bool = ((s_3046_9) == (s_3046_11));
        // N s_3046_13: branch s_3046_12 b3049 b3047
        if s_3046_12 {
            return block_3049(state, tracer, fn_state);
        } else {
            return block_3047(state, tracer, fn_state);
        };
    }
    fn block_3047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3047_0: const #0u : u8
        let s_3047_0: bool = false;
        // D s_3047_1: write-var gs#398329 <= s_3047_0
        fn_state.gs_398329 = s_3047_0;
        // N s_3047_2: jump b3048
        return block_3048(state, tracer, fn_state);
    }
    fn block_3048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3048_0: read-var gs#398329:u8
        let s_3048_0: bool = fn_state.gs_398329;
        // D s_3048_1: write-var gs#398330 <= s_3048_0
        fn_state.gs_398330 = s_3048_0;
        // N s_3048_2: jump b381
        return block_381(state, tracer, fn_state);
    }
    fn block_3049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3049_0: const #4s : i
        let s_3049_0: i128 = 4;
        // D s_3049_1: read-var u#30724:u32
        let s_3049_1: u32 = fn_state.u_30724;
        // D s_3049_2: cast zx s_3049_1 -> bv
        let s_3049_2: Bits = Bits::new(s_3049_1 as u128, 32u16);
        // C s_3049_3: const #1s : i64
        let s_3049_3: i64 = 1;
        // C s_3049_4: cast zx s_3049_3 -> i
        let s_3049_4: i128 = (i128::try_from(s_3049_3).unwrap());
        // C s_3049_5: const #0s : i
        let s_3049_5: i128 = 0;
        // C s_3049_6: add s_3049_5 s_3049_4
        let s_3049_6: i128 = (s_3049_5 + s_3049_4);
        // D s_3049_7: bit-extract s_3049_2 s_3049_0 s_3049_6
        let s_3049_7: Bits = (Bits::new(
            ((s_3049_2) >> (s_3049_0)).value(),
            u16::try_from(s_3049_6).unwrap(),
        ));
        // D s_3049_8: cast reint s_3049_7 -> u8
        let s_3049_8: bool = ((s_3049_7.value()) != 0);
        // D s_3049_9: cast zx s_3049_8 -> bv
        let s_3049_9: Bits = Bits::new(s_3049_8 as u128, 1u16);
        // C s_3049_10: const #1u : u8
        let s_3049_10: bool = true;
        // C s_3049_11: cast zx s_3049_10 -> bv
        let s_3049_11: Bits = Bits::new(s_3049_10 as u128, 1u16);
        // D s_3049_12: cmp-eq s_3049_9 s_3049_11
        let s_3049_12: bool = ((s_3049_9) == (s_3049_11));
        // D s_3049_13: write-var gs#398329 <= s_3049_12
        fn_state.gs_398329 = s_3049_12;
        // N s_3049_14: jump b3048
        return block_3048(state, tracer, fn_state);
    }
    fn block_3050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3050_0: const #3382s : i
        let s_3050_0: i128 = 3382;
        // C s_3050_1: const #14696u : u32
        let s_3050_1: u32 = 14696;
        // D s_3050_2: read-reg s_3050_1:i
        let s_3050_2: i128 = {
            let value = state.read_register::<i128>(s_3050_1 as isize);
            tracer.read_register(s_3050_1 as isize, value);
            value
        };
        // D s_3050_3: cmp-lt s_3050_2 s_3050_0
        let s_3050_3: bool = ((s_3050_2) < (s_3050_0));
        // D s_3050_4: write-var gs#398305 <= s_3050_3
        fn_state.gs_398305 = s_3050_3;
        // N s_3050_5: jump b377
        return block_377(state, tracer, fn_state);
    }
    fn block_3051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3051_0: const #20s : i
        let s_3051_0: i128 = 20;
        // D s_3051_1: read-var u#30715:u32
        let s_3051_1: u32 = fn_state.u_30715;
        // D s_3051_2: cast zx s_3051_1 -> bv
        let s_3051_2: Bits = Bits::new(s_3051_1 as u128, 32u16);
        // C s_3051_3: const #1s : i64
        let s_3051_3: i64 = 1;
        // C s_3051_4: cast zx s_3051_3 -> i
        let s_3051_4: i128 = (i128::try_from(s_3051_3).unwrap());
        // C s_3051_5: const #1s : i
        let s_3051_5: i128 = 1;
        // C s_3051_6: add s_3051_5 s_3051_4
        let s_3051_6: i128 = (s_3051_5 + s_3051_4);
        // D s_3051_7: bit-extract s_3051_2 s_3051_0 s_3051_6
        let s_3051_7: Bits = (Bits::new(
            ((s_3051_2) >> (s_3051_0)).value(),
            u16::try_from(s_3051_6).unwrap(),
        ));
        // D s_3051_8: cast reint s_3051_7 -> u8
        let s_3051_8: u8 = (s_3051_7.value() as u8);
        // D s_3051_9: cast zx s_3051_8 -> bv
        let s_3051_9: Bits = Bits::new(s_3051_8 as u128, 2u16);
        // C s_3051_10: const #1u : u8
        let s_3051_10: u8 = 1;
        // C s_3051_11: cast zx s_3051_10 -> bv
        let s_3051_11: Bits = Bits::new(s_3051_10 as u128, 2u16);
        // D s_3051_12: cmp-eq s_3051_9 s_3051_11
        let s_3051_12: bool = ((s_3051_9) == (s_3051_11));
        // N s_3051_13: branch s_3051_12 b3054 b3052
        if s_3051_12 {
            return block_3054(state, tracer, fn_state);
        } else {
            return block_3052(state, tracer, fn_state);
        };
    }
    fn block_3052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3052_0: const #0u : u8
        let s_3052_0: bool = false;
        // D s_3052_1: write-var gs#398302 <= s_3052_0
        fn_state.gs_398302 = s_3052_0;
        // N s_3052_2: jump b3053
        return block_3053(state, tracer, fn_state);
    }
    fn block_3053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3053_0: read-var gs#398302:u8
        let s_3053_0: bool = fn_state.gs_398302;
        // D s_3053_1: write-var gs#398303 <= s_3053_0
        fn_state.gs_398303 = s_3053_0;
        // N s_3053_2: jump b375
        return block_375(state, tracer, fn_state);
    }
    fn block_3054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3054_0: const #8s : i
        let s_3054_0: i128 = 8;
        // D s_3054_1: read-var u#30715:u32
        let s_3054_1: u32 = fn_state.u_30715;
        // D s_3054_2: cast zx s_3054_1 -> bv
        let s_3054_2: Bits = Bits::new(s_3054_1 as u128, 32u16);
        // C s_3054_3: const #1s : i64
        let s_3054_3: i64 = 1;
        // C s_3054_4: cast zx s_3054_3 -> i
        let s_3054_4: i128 = (i128::try_from(s_3054_3).unwrap());
        // C s_3054_5: const #3s : i
        let s_3054_5: i128 = 3;
        // C s_3054_6: add s_3054_5 s_3054_4
        let s_3054_6: i128 = (s_3054_5 + s_3054_4);
        // D s_3054_7: bit-extract s_3054_2 s_3054_0 s_3054_6
        let s_3054_7: Bits = (Bits::new(
            ((s_3054_2) >> (s_3054_0)).value(),
            u16::try_from(s_3054_6).unwrap(),
        ));
        // D s_3054_8: cast reint s_3054_7 -> u8
        let s_3054_8: u8 = (s_3054_7.value() as u8);
        // D s_3054_9: cast zx s_3054_8 -> bv
        let s_3054_9: Bits = Bits::new(s_3054_8 as u128, 4u16);
        // C s_3054_10: const #1u : u8
        let s_3054_10: u8 = 1;
        // C s_3054_11: cast zx s_3054_10 -> bv
        let s_3054_11: Bits = Bits::new(s_3054_10 as u128, 4u16);
        // D s_3054_12: cmp-eq s_3054_9 s_3054_11
        let s_3054_12: bool = ((s_3054_9) == (s_3054_11));
        // N s_3054_13: branch s_3054_12 b3057 b3055
        if s_3054_12 {
            return block_3057(state, tracer, fn_state);
        } else {
            return block_3055(state, tracer, fn_state);
        };
    }
    fn block_3055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3055_0: const #0u : u8
        let s_3055_0: bool = false;
        // D s_3055_1: write-var gs#398301 <= s_3055_0
        fn_state.gs_398301 = s_3055_0;
        // N s_3055_2: jump b3056
        return block_3056(state, tracer, fn_state);
    }
    fn block_3056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3056_0: read-var gs#398301:u8
        let s_3056_0: bool = fn_state.gs_398301;
        // D s_3056_1: write-var gs#398302 <= s_3056_0
        fn_state.gs_398302 = s_3056_0;
        // N s_3056_2: jump b3053
        return block_3053(state, tracer, fn_state);
    }
    fn block_3057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3057_0: const #4s : i
        let s_3057_0: i128 = 4;
        // D s_3057_1: read-var u#30715:u32
        let s_3057_1: u32 = fn_state.u_30715;
        // D s_3057_2: cast zx s_3057_1 -> bv
        let s_3057_2: Bits = Bits::new(s_3057_1 as u128, 32u16);
        // C s_3057_3: const #1s : i64
        let s_3057_3: i64 = 1;
        // C s_3057_4: cast zx s_3057_3 -> i
        let s_3057_4: i128 = (i128::try_from(s_3057_3).unwrap());
        // C s_3057_5: const #0s : i
        let s_3057_5: i128 = 0;
        // C s_3057_6: add s_3057_5 s_3057_4
        let s_3057_6: i128 = (s_3057_5 + s_3057_4);
        // D s_3057_7: bit-extract s_3057_2 s_3057_0 s_3057_6
        let s_3057_7: Bits = (Bits::new(
            ((s_3057_2) >> (s_3057_0)).value(),
            u16::try_from(s_3057_6).unwrap(),
        ));
        // D s_3057_8: cast reint s_3057_7 -> u8
        let s_3057_8: bool = ((s_3057_7.value()) != 0);
        // D s_3057_9: cast zx s_3057_8 -> bv
        let s_3057_9: Bits = Bits::new(s_3057_8 as u128, 1u16);
        // C s_3057_10: const #1u : u8
        let s_3057_10: bool = true;
        // C s_3057_11: cast zx s_3057_10 -> bv
        let s_3057_11: Bits = Bits::new(s_3057_10 as u128, 1u16);
        // D s_3057_12: cmp-eq s_3057_9 s_3057_11
        let s_3057_12: bool = ((s_3057_9) == (s_3057_11));
        // D s_3057_13: write-var gs#398301 <= s_3057_12
        fn_state.gs_398301 = s_3057_12;
        // N s_3057_14: jump b3056
        return block_3056(state, tracer, fn_state);
    }
    fn block_3058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3058_0: const #3379s : i
        let s_3058_0: i128 = 3379;
        // C s_3058_1: const #14696u : u32
        let s_3058_1: u32 = 14696;
        // D s_3058_2: read-reg s_3058_1:i
        let s_3058_2: i128 = {
            let value = state.read_register::<i128>(s_3058_1 as isize);
            tracer.read_register(s_3058_1 as isize, value);
            value
        };
        // D s_3058_3: cmp-lt s_3058_2 s_3058_0
        let s_3058_3: bool = ((s_3058_2) < (s_3058_0));
        // D s_3058_4: write-var gs#398275 <= s_3058_3
        fn_state.gs_398275 = s_3058_3;
        // N s_3058_5: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_3059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3059_0: const #23s : i
        let s_3059_0: i128 = 23;
        // D s_3059_1: read-var u#30706:u32
        let s_3059_1: u32 = fn_state.u_30706;
        // D s_3059_2: cast zx s_3059_1 -> bv
        let s_3059_2: Bits = Bits::new(s_3059_1 as u128, 32u16);
        // C s_3059_3: const #1s : i64
        let s_3059_3: i64 = 1;
        // C s_3059_4: cast zx s_3059_3 -> i
        let s_3059_4: i128 = (i128::try_from(s_3059_3).unwrap());
        // C s_3059_5: const #0s : i
        let s_3059_5: i128 = 0;
        // C s_3059_6: add s_3059_5 s_3059_4
        let s_3059_6: i128 = (s_3059_5 + s_3059_4);
        // D s_3059_7: bit-extract s_3059_2 s_3059_0 s_3059_6
        let s_3059_7: Bits = (Bits::new(
            ((s_3059_2) >> (s_3059_0)).value(),
            u16::try_from(s_3059_6).unwrap(),
        ));
        // D s_3059_8: cast reint s_3059_7 -> u8
        let s_3059_8: bool = ((s_3059_7.value()) != 0);
        // D s_3059_9: cast zx s_3059_8 -> bv
        let s_3059_9: Bits = Bits::new(s_3059_8 as u128, 1u16);
        // C s_3059_10: const #1u : u8
        let s_3059_10: bool = true;
        // C s_3059_11: cast zx s_3059_10 -> bv
        let s_3059_11: Bits = Bits::new(s_3059_10 as u128, 1u16);
        // D s_3059_12: cmp-eq s_3059_9 s_3059_11
        let s_3059_12: bool = ((s_3059_9) == (s_3059_11));
        // N s_3059_13: branch s_3059_12 b3062 b3060
        if s_3059_12 {
            return block_3062(state, tracer, fn_state);
        } else {
            return block_3060(state, tracer, fn_state);
        };
    }
    fn block_3060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3060_0: const #0u : u8
        let s_3060_0: bool = false;
        // D s_3060_1: write-var gs#398272 <= s_3060_0
        fn_state.gs_398272 = s_3060_0;
        // N s_3060_2: jump b3061
        return block_3061(state, tracer, fn_state);
    }
    fn block_3061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3061_0: read-var gs#398272:u8
        let s_3061_0: bool = fn_state.gs_398272;
        // D s_3061_1: write-var gs#398273 <= s_3061_0
        fn_state.gs_398273 = s_3061_0;
        // N s_3061_2: jump b369
        return block_369(state, tracer, fn_state);
    }
    fn block_3062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3062_0: const #19s : i
        let s_3062_0: i128 = 19;
        // D s_3062_1: read-var u#30706:u32
        let s_3062_1: u32 = fn_state.u_30706;
        // D s_3062_2: cast zx s_3062_1 -> bv
        let s_3062_2: Bits = Bits::new(s_3062_1 as u128, 32u16);
        // C s_3062_3: const #1s : i64
        let s_3062_3: i64 = 1;
        // C s_3062_4: cast zx s_3062_3 -> i
        let s_3062_4: i128 = (i128::try_from(s_3062_3).unwrap());
        // C s_3062_5: const #2s : i
        let s_3062_5: i128 = 2;
        // C s_3062_6: add s_3062_5 s_3062_4
        let s_3062_6: i128 = (s_3062_5 + s_3062_4);
        // D s_3062_7: bit-extract s_3062_2 s_3062_0 s_3062_6
        let s_3062_7: Bits = (Bits::new(
            ((s_3062_2) >> (s_3062_0)).value(),
            u16::try_from(s_3062_6).unwrap(),
        ));
        // D s_3062_8: cast reint s_3062_7 -> u8
        let s_3062_8: u8 = (s_3062_7.value() as u8);
        // D s_3062_9: cast zx s_3062_8 -> bv
        let s_3062_9: Bits = Bits::new(s_3062_8 as u128, 3u16);
        // C s_3062_10: const #0u : u8
        let s_3062_10: u8 = 0;
        // C s_3062_11: cast zx s_3062_10 -> bv
        let s_3062_11: Bits = Bits::new(s_3062_10 as u128, 3u16);
        // D s_3062_12: cmp-eq s_3062_9 s_3062_11
        let s_3062_12: bool = ((s_3062_9) == (s_3062_11));
        // N s_3062_13: branch s_3062_12 b3065 b3063
        if s_3062_12 {
            return block_3065(state, tracer, fn_state);
        } else {
            return block_3063(state, tracer, fn_state);
        };
    }
    fn block_3063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3063_0: const #0u : u8
        let s_3063_0: bool = false;
        // D s_3063_1: write-var gs#398271 <= s_3063_0
        fn_state.gs_398271 = s_3063_0;
        // N s_3063_2: jump b3064
        return block_3064(state, tracer, fn_state);
    }
    fn block_3064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3064_0: read-var gs#398271:u8
        let s_3064_0: bool = fn_state.gs_398271;
        // D s_3064_1: write-var gs#398272 <= s_3064_0
        fn_state.gs_398272 = s_3064_0;
        // N s_3064_2: jump b3061
        return block_3061(state, tracer, fn_state);
    }
    fn block_3065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3065_0: const #10s : i
        let s_3065_0: i128 = 10;
        // D s_3065_1: read-var u#30706:u32
        let s_3065_1: u32 = fn_state.u_30706;
        // D s_3065_2: cast zx s_3065_1 -> bv
        let s_3065_2: Bits = Bits::new(s_3065_1 as u128, 32u16);
        // C s_3065_3: const #1s : i64
        let s_3065_3: i64 = 1;
        // C s_3065_4: cast zx s_3065_3 -> i
        let s_3065_4: i128 = (i128::try_from(s_3065_3).unwrap());
        // C s_3065_5: const #1s : i
        let s_3065_5: i128 = 1;
        // C s_3065_6: add s_3065_5 s_3065_4
        let s_3065_6: i128 = (s_3065_5 + s_3065_4);
        // D s_3065_7: bit-extract s_3065_2 s_3065_0 s_3065_6
        let s_3065_7: Bits = (Bits::new(
            ((s_3065_2) >> (s_3065_0)).value(),
            u16::try_from(s_3065_6).unwrap(),
        ));
        // D s_3065_8: cast reint s_3065_7 -> u8
        let s_3065_8: u8 = (s_3065_7.value() as u8);
        // D s_3065_9: cast zx s_3065_8 -> bv
        let s_3065_9: Bits = Bits::new(s_3065_8 as u128, 2u16);
        // C s_3065_10: const #2u : u8
        let s_3065_10: u8 = 2;
        // C s_3065_11: cast zx s_3065_10 -> bv
        let s_3065_11: Bits = Bits::new(s_3065_10 as u128, 2u16);
        // D s_3065_12: cmp-eq s_3065_9 s_3065_11
        let s_3065_12: bool = ((s_3065_9) == (s_3065_11));
        // N s_3065_13: branch s_3065_12 b3068 b3066
        if s_3065_12 {
            return block_3068(state, tracer, fn_state);
        } else {
            return block_3066(state, tracer, fn_state);
        };
    }
    fn block_3066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3066_0: const #0u : u8
        let s_3066_0: bool = false;
        // D s_3066_1: write-var gs#398270 <= s_3066_0
        fn_state.gs_398270 = s_3066_0;
        // N s_3066_2: jump b3067
        return block_3067(state, tracer, fn_state);
    }
    fn block_3067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3067_0: read-var gs#398270:u8
        let s_3067_0: bool = fn_state.gs_398270;
        // D s_3067_1: write-var gs#398271 <= s_3067_0
        fn_state.gs_398271 = s_3067_0;
        // N s_3067_2: jump b3064
        return block_3064(state, tracer, fn_state);
    }
    fn block_3068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3068_0: const #7s : i
        let s_3068_0: i128 = 7;
        // D s_3068_1: read-var u#30706:u32
        let s_3068_1: u32 = fn_state.u_30706;
        // D s_3068_2: cast zx s_3068_1 -> bv
        let s_3068_2: Bits = Bits::new(s_3068_1 as u128, 32u16);
        // C s_3068_3: const #1s : i64
        let s_3068_3: i64 = 1;
        // C s_3068_4: cast zx s_3068_3 -> i
        let s_3068_4: i128 = (i128::try_from(s_3068_3).unwrap());
        // C s_3068_5: const #1s : i
        let s_3068_5: i128 = 1;
        // C s_3068_6: add s_3068_5 s_3068_4
        let s_3068_6: i128 = (s_3068_5 + s_3068_4);
        // D s_3068_7: bit-extract s_3068_2 s_3068_0 s_3068_6
        let s_3068_7: Bits = (Bits::new(
            ((s_3068_2) >> (s_3068_0)).value(),
            u16::try_from(s_3068_6).unwrap(),
        ));
        // D s_3068_8: cast reint s_3068_7 -> u8
        let s_3068_8: u8 = (s_3068_7.value() as u8);
        // D s_3068_9: cast zx s_3068_8 -> bv
        let s_3068_9: Bits = Bits::new(s_3068_8 as u128, 2u16);
        // C s_3068_10: const #2u : u8
        let s_3068_10: u8 = 2;
        // C s_3068_11: cast zx s_3068_10 -> bv
        let s_3068_11: Bits = Bits::new(s_3068_10 as u128, 2u16);
        // D s_3068_12: cmp-eq s_3068_9 s_3068_11
        let s_3068_12: bool = ((s_3068_9) == (s_3068_11));
        // N s_3068_13: branch s_3068_12 b3071 b3069
        if s_3068_12 {
            return block_3071(state, tracer, fn_state);
        } else {
            return block_3069(state, tracer, fn_state);
        };
    }
    fn block_3069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3069_0: const #0u : u8
        let s_3069_0: bool = false;
        // D s_3069_1: write-var gs#398269 <= s_3069_0
        fn_state.gs_398269 = s_3069_0;
        // N s_3069_2: jump b3070
        return block_3070(state, tracer, fn_state);
    }
    fn block_3070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3070_0: read-var gs#398269:u8
        let s_3070_0: bool = fn_state.gs_398269;
        // D s_3070_1: write-var gs#398270 <= s_3070_0
        fn_state.gs_398270 = s_3070_0;
        // N s_3070_2: jump b3067
        return block_3067(state, tracer, fn_state);
    }
    fn block_3071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3071_0: const #4s : i
        let s_3071_0: i128 = 4;
        // D s_3071_1: read-var u#30706:u32
        let s_3071_1: u32 = fn_state.u_30706;
        // D s_3071_2: cast zx s_3071_1 -> bv
        let s_3071_2: Bits = Bits::new(s_3071_1 as u128, 32u16);
        // C s_3071_3: const #1s : i64
        let s_3071_3: i64 = 1;
        // C s_3071_4: cast zx s_3071_3 -> i
        let s_3071_4: i128 = (i128::try_from(s_3071_3).unwrap());
        // C s_3071_5: const #1s : i
        let s_3071_5: i128 = 1;
        // C s_3071_6: add s_3071_5 s_3071_4
        let s_3071_6: i128 = (s_3071_5 + s_3071_4);
        // D s_3071_7: bit-extract s_3071_2 s_3071_0 s_3071_6
        let s_3071_7: Bits = (Bits::new(
            ((s_3071_2) >> (s_3071_0)).value(),
            u16::try_from(s_3071_6).unwrap(),
        ));
        // D s_3071_8: cast reint s_3071_7 -> u8
        let s_3071_8: u8 = (s_3071_7.value() as u8);
        // D s_3071_9: cast zx s_3071_8 -> bv
        let s_3071_9: Bits = Bits::new(s_3071_8 as u128, 2u16);
        // C s_3071_10: const #3u : u8
        let s_3071_10: u8 = 3;
        // C s_3071_11: cast zx s_3071_10 -> bv
        let s_3071_11: Bits = Bits::new(s_3071_10 as u128, 2u16);
        // D s_3071_12: cmp-eq s_3071_9 s_3071_11
        let s_3071_12: bool = ((s_3071_9) == (s_3071_11));
        // D s_3071_13: write-var gs#398269 <= s_3071_12
        fn_state.gs_398269 = s_3071_12;
        // N s_3071_14: jump b3070
        return block_3070(state, tracer, fn_state);
    }
    fn block_3072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3072_0: const #3378s : i
        let s_3072_0: i128 = 3378;
        // C s_3072_1: const #14696u : u32
        let s_3072_1: u32 = 14696;
        // D s_3072_2: read-reg s_3072_1:i
        let s_3072_2: i128 = {
            let value = state.read_register::<i128>(s_3072_1 as isize);
            tracer.read_register(s_3072_1 as isize, value);
            value
        };
        // D s_3072_3: cmp-lt s_3072_2 s_3072_0
        let s_3072_3: bool = ((s_3072_2) < (s_3072_0));
        // D s_3072_4: write-var gs#398239 <= s_3072_3
        fn_state.gs_398239 = s_3072_3;
        // N s_3072_5: jump b365
        return block_365(state, tracer, fn_state);
    }
    fn block_3073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3073_0: const #23s : i
        let s_3073_0: i128 = 23;
        // D s_3073_1: read-var u#30701:u32
        let s_3073_1: u32 = fn_state.u_30701;
        // D s_3073_2: cast zx s_3073_1 -> bv
        let s_3073_2: Bits = Bits::new(s_3073_1 as u128, 32u16);
        // C s_3073_3: const #1s : i64
        let s_3073_3: i64 = 1;
        // C s_3073_4: cast zx s_3073_3 -> i
        let s_3073_4: i128 = (i128::try_from(s_3073_3).unwrap());
        // C s_3073_5: const #0s : i
        let s_3073_5: i128 = 0;
        // C s_3073_6: add s_3073_5 s_3073_4
        let s_3073_6: i128 = (s_3073_5 + s_3073_4);
        // D s_3073_7: bit-extract s_3073_2 s_3073_0 s_3073_6
        let s_3073_7: Bits = (Bits::new(
            ((s_3073_2) >> (s_3073_0)).value(),
            u16::try_from(s_3073_6).unwrap(),
        ));
        // D s_3073_8: cast reint s_3073_7 -> u8
        let s_3073_8: bool = ((s_3073_7.value()) != 0);
        // D s_3073_9: cast zx s_3073_8 -> bv
        let s_3073_9: Bits = Bits::new(s_3073_8 as u128, 1u16);
        // C s_3073_10: const #1u : u8
        let s_3073_10: bool = true;
        // C s_3073_11: cast zx s_3073_10 -> bv
        let s_3073_11: Bits = Bits::new(s_3073_10 as u128, 1u16);
        // D s_3073_12: cmp-eq s_3073_9 s_3073_11
        let s_3073_12: bool = ((s_3073_9) == (s_3073_11));
        // N s_3073_13: branch s_3073_12 b3076 b3074
        if s_3073_12 {
            return block_3076(state, tracer, fn_state);
        } else {
            return block_3074(state, tracer, fn_state);
        };
    }
    fn block_3074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3074_0: const #0u : u8
        let s_3074_0: bool = false;
        // D s_3074_1: write-var gs#398236 <= s_3074_0
        fn_state.gs_398236 = s_3074_0;
        // N s_3074_2: jump b3075
        return block_3075(state, tracer, fn_state);
    }
    fn block_3075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3075_0: read-var gs#398236:u8
        let s_3075_0: bool = fn_state.gs_398236;
        // D s_3075_1: write-var gs#398237 <= s_3075_0
        fn_state.gs_398237 = s_3075_0;
        // N s_3075_2: jump b363
        return block_363(state, tracer, fn_state);
    }
    fn block_3076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3076_0: const #19s : i
        let s_3076_0: i128 = 19;
        // D s_3076_1: read-var u#30701:u32
        let s_3076_1: u32 = fn_state.u_30701;
        // D s_3076_2: cast zx s_3076_1 -> bv
        let s_3076_2: Bits = Bits::new(s_3076_1 as u128, 32u16);
        // C s_3076_3: const #1s : i64
        let s_3076_3: i64 = 1;
        // C s_3076_4: cast zx s_3076_3 -> i
        let s_3076_4: i128 = (i128::try_from(s_3076_3).unwrap());
        // C s_3076_5: const #2s : i
        let s_3076_5: i128 = 2;
        // C s_3076_6: add s_3076_5 s_3076_4
        let s_3076_6: i128 = (s_3076_5 + s_3076_4);
        // D s_3076_7: bit-extract s_3076_2 s_3076_0 s_3076_6
        let s_3076_7: Bits = (Bits::new(
            ((s_3076_2) >> (s_3076_0)).value(),
            u16::try_from(s_3076_6).unwrap(),
        ));
        // D s_3076_8: cast reint s_3076_7 -> u8
        let s_3076_8: u8 = (s_3076_7.value() as u8);
        // D s_3076_9: cast zx s_3076_8 -> bv
        let s_3076_9: Bits = Bits::new(s_3076_8 as u128, 3u16);
        // C s_3076_10: const #0u : u8
        let s_3076_10: u8 = 0;
        // C s_3076_11: cast zx s_3076_10 -> bv
        let s_3076_11: Bits = Bits::new(s_3076_10 as u128, 3u16);
        // D s_3076_12: cmp-eq s_3076_9 s_3076_11
        let s_3076_12: bool = ((s_3076_9) == (s_3076_11));
        // N s_3076_13: branch s_3076_12 b3079 b3077
        if s_3076_12 {
            return block_3079(state, tracer, fn_state);
        } else {
            return block_3077(state, tracer, fn_state);
        };
    }
    fn block_3077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3077_0: const #0u : u8
        let s_3077_0: bool = false;
        // D s_3077_1: write-var gs#398235 <= s_3077_0
        fn_state.gs_398235 = s_3077_0;
        // N s_3077_2: jump b3078
        return block_3078(state, tracer, fn_state);
    }
    fn block_3078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3078_0: read-var gs#398235:u8
        let s_3078_0: bool = fn_state.gs_398235;
        // D s_3078_1: write-var gs#398236 <= s_3078_0
        fn_state.gs_398236 = s_3078_0;
        // N s_3078_2: jump b3075
        return block_3075(state, tracer, fn_state);
    }
    fn block_3079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3079_0: const #11s : i
        let s_3079_0: i128 = 11;
        // D s_3079_1: read-var u#30701:u32
        let s_3079_1: u32 = fn_state.u_30701;
        // D s_3079_2: cast zx s_3079_1 -> bv
        let s_3079_2: Bits = Bits::new(s_3079_1 as u128, 32u16);
        // C s_3079_3: const #1s : i64
        let s_3079_3: i64 = 1;
        // C s_3079_4: cast zx s_3079_3 -> i
        let s_3079_4: i128 = (i128::try_from(s_3079_3).unwrap());
        // C s_3079_5: const #0s : i
        let s_3079_5: i128 = 0;
        // C s_3079_6: add s_3079_5 s_3079_4
        let s_3079_6: i128 = (s_3079_5 + s_3079_4);
        // D s_3079_7: bit-extract s_3079_2 s_3079_0 s_3079_6
        let s_3079_7: Bits = (Bits::new(
            ((s_3079_2) >> (s_3079_0)).value(),
            u16::try_from(s_3079_6).unwrap(),
        ));
        // D s_3079_8: cast reint s_3079_7 -> u8
        let s_3079_8: bool = ((s_3079_7.value()) != 0);
        // D s_3079_9: cast zx s_3079_8 -> bv
        let s_3079_9: Bits = Bits::new(s_3079_8 as u128, 1u16);
        // C s_3079_10: const #0u : u8
        let s_3079_10: bool = false;
        // C s_3079_11: cast zx s_3079_10 -> bv
        let s_3079_11: Bits = Bits::new(s_3079_10 as u128, 1u16);
        // D s_3079_12: cmp-eq s_3079_9 s_3079_11
        let s_3079_12: bool = ((s_3079_9) == (s_3079_11));
        // N s_3079_13: branch s_3079_12 b3082 b3080
        if s_3079_12 {
            return block_3082(state, tracer, fn_state);
        } else {
            return block_3080(state, tracer, fn_state);
        };
    }
    fn block_3080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3080_0: const #0u : u8
        let s_3080_0: bool = false;
        // D s_3080_1: write-var gs#398234 <= s_3080_0
        fn_state.gs_398234 = s_3080_0;
        // N s_3080_2: jump b3081
        return block_3081(state, tracer, fn_state);
    }
    fn block_3081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3081_0: read-var gs#398234:u8
        let s_3081_0: bool = fn_state.gs_398234;
        // D s_3081_1: write-var gs#398235 <= s_3081_0
        fn_state.gs_398235 = s_3081_0;
        // N s_3081_2: jump b3078
        return block_3078(state, tracer, fn_state);
    }
    fn block_3082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3082_0: const #7s : i
        let s_3082_0: i128 = 7;
        // D s_3082_1: read-var u#30701:u32
        let s_3082_1: u32 = fn_state.u_30701;
        // D s_3082_2: cast zx s_3082_1 -> bv
        let s_3082_2: Bits = Bits::new(s_3082_1 as u128, 32u16);
        // C s_3082_3: const #1s : i64
        let s_3082_3: i64 = 1;
        // C s_3082_4: cast zx s_3082_3 -> i
        let s_3082_4: i128 = (i128::try_from(s_3082_3).unwrap());
        // C s_3082_5: const #1s : i
        let s_3082_5: i128 = 1;
        // C s_3082_6: add s_3082_5 s_3082_4
        let s_3082_6: i128 = (s_3082_5 + s_3082_4);
        // D s_3082_7: bit-extract s_3082_2 s_3082_0 s_3082_6
        let s_3082_7: Bits = (Bits::new(
            ((s_3082_2) >> (s_3082_0)).value(),
            u16::try_from(s_3082_6).unwrap(),
        ));
        // D s_3082_8: cast reint s_3082_7 -> u8
        let s_3082_8: u8 = (s_3082_7.value() as u8);
        // D s_3082_9: cast zx s_3082_8 -> bv
        let s_3082_9: Bits = Bits::new(s_3082_8 as u128, 2u16);
        // C s_3082_10: const #2u : u8
        let s_3082_10: u8 = 2;
        // C s_3082_11: cast zx s_3082_10 -> bv
        let s_3082_11: Bits = Bits::new(s_3082_10 as u128, 2u16);
        // D s_3082_12: cmp-eq s_3082_9 s_3082_11
        let s_3082_12: bool = ((s_3082_9) == (s_3082_11));
        // N s_3082_13: branch s_3082_12 b3085 b3083
        if s_3082_12 {
            return block_3085(state, tracer, fn_state);
        } else {
            return block_3083(state, tracer, fn_state);
        };
    }
    fn block_3083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3083_0: const #0u : u8
        let s_3083_0: bool = false;
        // D s_3083_1: write-var gs#398233 <= s_3083_0
        fn_state.gs_398233 = s_3083_0;
        // N s_3083_2: jump b3084
        return block_3084(state, tracer, fn_state);
    }
    fn block_3084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3084_0: read-var gs#398233:u8
        let s_3084_0: bool = fn_state.gs_398233;
        // D s_3084_1: write-var gs#398234 <= s_3084_0
        fn_state.gs_398234 = s_3084_0;
        // N s_3084_2: jump b3081
        return block_3081(state, tracer, fn_state);
    }
    fn block_3085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3085_0: const #4s : i
        let s_3085_0: i128 = 4;
        // D s_3085_1: read-var u#30701:u32
        let s_3085_1: u32 = fn_state.u_30701;
        // D s_3085_2: cast zx s_3085_1 -> bv
        let s_3085_2: Bits = Bits::new(s_3085_1 as u128, 32u16);
        // C s_3085_3: const #1s : i64
        let s_3085_3: i64 = 1;
        // C s_3085_4: cast zx s_3085_3 -> i
        let s_3085_4: i128 = (i128::try_from(s_3085_3).unwrap());
        // C s_3085_5: const #1s : i
        let s_3085_5: i128 = 1;
        // C s_3085_6: add s_3085_5 s_3085_4
        let s_3085_6: i128 = (s_3085_5 + s_3085_4);
        // D s_3085_7: bit-extract s_3085_2 s_3085_0 s_3085_6
        let s_3085_7: Bits = (Bits::new(
            ((s_3085_2) >> (s_3085_0)).value(),
            u16::try_from(s_3085_6).unwrap(),
        ));
        // D s_3085_8: cast reint s_3085_7 -> u8
        let s_3085_8: u8 = (s_3085_7.value() as u8);
        // D s_3085_9: cast zx s_3085_8 -> bv
        let s_3085_9: Bits = Bits::new(s_3085_8 as u128, 2u16);
        // C s_3085_10: const #3u : u8
        let s_3085_10: u8 = 3;
        // C s_3085_11: cast zx s_3085_10 -> bv
        let s_3085_11: Bits = Bits::new(s_3085_10 as u128, 2u16);
        // D s_3085_12: cmp-eq s_3085_9 s_3085_11
        let s_3085_12: bool = ((s_3085_9) == (s_3085_11));
        // D s_3085_13: write-var gs#398233 <= s_3085_12
        fn_state.gs_398233 = s_3085_12;
        // N s_3085_14: jump b3084
        return block_3084(state, tracer, fn_state);
    }
    fn block_3086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3086_0: const #3376s : i
        let s_3086_0: i128 = 3376;
        // C s_3086_1: const #14696u : u32
        let s_3086_1: u32 = 14696;
        // D s_3086_2: read-reg s_3086_1:i
        let s_3086_2: i128 = {
            let value = state.read_register::<i128>(s_3086_1 as isize);
            tracer.read_register(s_3086_1 as isize, value);
            value
        };
        // D s_3086_3: cmp-lt s_3086_2 s_3086_0
        let s_3086_3: bool = ((s_3086_2) < (s_3086_0));
        // D s_3086_4: write-var gs#398203 <= s_3086_3
        fn_state.gs_398203 = s_3086_3;
        // N s_3086_5: jump b359
        return block_359(state, tracer, fn_state);
    }
    fn block_3087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3087_0: const #20s : i
        let s_3087_0: i128 = 20;
        // D s_3087_1: read-var u#30692:u32
        let s_3087_1: u32 = fn_state.u_30692;
        // D s_3087_2: cast zx s_3087_1 -> bv
        let s_3087_2: Bits = Bits::new(s_3087_1 as u128, 32u16);
        // C s_3087_3: const #1s : i64
        let s_3087_3: i64 = 1;
        // C s_3087_4: cast zx s_3087_3 -> i
        let s_3087_4: i128 = (i128::try_from(s_3087_3).unwrap());
        // C s_3087_5: const #1s : i
        let s_3087_5: i128 = 1;
        // C s_3087_6: add s_3087_5 s_3087_4
        let s_3087_6: i128 = (s_3087_5 + s_3087_4);
        // D s_3087_7: bit-extract s_3087_2 s_3087_0 s_3087_6
        let s_3087_7: Bits = (Bits::new(
            ((s_3087_2) >> (s_3087_0)).value(),
            u16::try_from(s_3087_6).unwrap(),
        ));
        // D s_3087_8: cast reint s_3087_7 -> u8
        let s_3087_8: u8 = (s_3087_7.value() as u8);
        // D s_3087_9: cast zx s_3087_8 -> bv
        let s_3087_9: Bits = Bits::new(s_3087_8 as u128, 2u16);
        // C s_3087_10: const #0u : u8
        let s_3087_10: u8 = 0;
        // C s_3087_11: cast zx s_3087_10 -> bv
        let s_3087_11: Bits = Bits::new(s_3087_10 as u128, 2u16);
        // D s_3087_12: cmp-eq s_3087_9 s_3087_11
        let s_3087_12: bool = ((s_3087_9) == (s_3087_11));
        // N s_3087_13: branch s_3087_12 b3090 b3088
        if s_3087_12 {
            return block_3090(state, tracer, fn_state);
        } else {
            return block_3088(state, tracer, fn_state);
        };
    }
    fn block_3088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3088_0: const #0u : u8
        let s_3088_0: bool = false;
        // D s_3088_1: write-var gs#398200 <= s_3088_0
        fn_state.gs_398200 = s_3088_0;
        // N s_3088_2: jump b3089
        return block_3089(state, tracer, fn_state);
    }
    fn block_3089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3089_0: read-var gs#398200:u8
        let s_3089_0: bool = fn_state.gs_398200;
        // D s_3089_1: write-var gs#398201 <= s_3089_0
        fn_state.gs_398201 = s_3089_0;
        // N s_3089_2: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_3090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3090_0: const #8s : i
        let s_3090_0: i128 = 8;
        // D s_3090_1: read-var u#30692:u32
        let s_3090_1: u32 = fn_state.u_30692;
        // D s_3090_2: cast zx s_3090_1 -> bv
        let s_3090_2: Bits = Bits::new(s_3090_1 as u128, 32u16);
        // C s_3090_3: const #1s : i64
        let s_3090_3: i64 = 1;
        // C s_3090_4: cast zx s_3090_3 -> i
        let s_3090_4: i128 = (i128::try_from(s_3090_3).unwrap());
        // C s_3090_5: const #3s : i
        let s_3090_5: i128 = 3;
        // C s_3090_6: add s_3090_5 s_3090_4
        let s_3090_6: i128 = (s_3090_5 + s_3090_4);
        // D s_3090_7: bit-extract s_3090_2 s_3090_0 s_3090_6
        let s_3090_7: Bits = (Bits::new(
            ((s_3090_2) >> (s_3090_0)).value(),
            u16::try_from(s_3090_6).unwrap(),
        ));
        // D s_3090_8: cast reint s_3090_7 -> u8
        let s_3090_8: u8 = (s_3090_7.value() as u8);
        // D s_3090_9: cast zx s_3090_8 -> bv
        let s_3090_9: Bits = Bits::new(s_3090_8 as u128, 4u16);
        // C s_3090_10: const #1u : u8
        let s_3090_10: u8 = 1;
        // C s_3090_11: cast zx s_3090_10 -> bv
        let s_3090_11: Bits = Bits::new(s_3090_10 as u128, 4u16);
        // D s_3090_12: cmp-eq s_3090_9 s_3090_11
        let s_3090_12: bool = ((s_3090_9) == (s_3090_11));
        // N s_3090_13: branch s_3090_12 b3093 b3091
        if s_3090_12 {
            return block_3093(state, tracer, fn_state);
        } else {
            return block_3091(state, tracer, fn_state);
        };
    }
    fn block_3091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3091_0: const #0u : u8
        let s_3091_0: bool = false;
        // D s_3091_1: write-var gs#398199 <= s_3091_0
        fn_state.gs_398199 = s_3091_0;
        // N s_3091_2: jump b3092
        return block_3092(state, tracer, fn_state);
    }
    fn block_3092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3092_0: read-var gs#398199:u8
        let s_3092_0: bool = fn_state.gs_398199;
        // D s_3092_1: write-var gs#398200 <= s_3092_0
        fn_state.gs_398200 = s_3092_0;
        // N s_3092_2: jump b3089
        return block_3089(state, tracer, fn_state);
    }
    fn block_3093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3093_0: const #4s : i
        let s_3093_0: i128 = 4;
        // D s_3093_1: read-var u#30692:u32
        let s_3093_1: u32 = fn_state.u_30692;
        // D s_3093_2: cast zx s_3093_1 -> bv
        let s_3093_2: Bits = Bits::new(s_3093_1 as u128, 32u16);
        // C s_3093_3: const #1s : i64
        let s_3093_3: i64 = 1;
        // C s_3093_4: cast zx s_3093_3 -> i
        let s_3093_4: i128 = (i128::try_from(s_3093_3).unwrap());
        // C s_3093_5: const #0s : i
        let s_3093_5: i128 = 0;
        // C s_3093_6: add s_3093_5 s_3093_4
        let s_3093_6: i128 = (s_3093_5 + s_3093_4);
        // D s_3093_7: bit-extract s_3093_2 s_3093_0 s_3093_6
        let s_3093_7: Bits = (Bits::new(
            ((s_3093_2) >> (s_3093_0)).value(),
            u16::try_from(s_3093_6).unwrap(),
        ));
        // D s_3093_8: cast reint s_3093_7 -> u8
        let s_3093_8: bool = ((s_3093_7.value()) != 0);
        // D s_3093_9: cast zx s_3093_8 -> bv
        let s_3093_9: Bits = Bits::new(s_3093_8 as u128, 1u16);
        // C s_3093_10: const #1u : u8
        let s_3093_10: bool = true;
        // C s_3093_11: cast zx s_3093_10 -> bv
        let s_3093_11: Bits = Bits::new(s_3093_10 as u128, 1u16);
        // D s_3093_12: cmp-eq s_3093_9 s_3093_11
        let s_3093_12: bool = ((s_3093_9) == (s_3093_11));
        // D s_3093_13: write-var gs#398199 <= s_3093_12
        fn_state.gs_398199 = s_3093_12;
        // N s_3093_14: jump b3092
        return block_3092(state, tracer, fn_state);
    }
    fn block_3094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3094_0: const #3374s : i
        let s_3094_0: i128 = 3374;
        // C s_3094_1: const #14696u : u32
        let s_3094_1: u32 = 14696;
        // D s_3094_2: read-reg s_3094_1:i
        let s_3094_2: i128 = {
            let value = state.read_register::<i128>(s_3094_1 as isize);
            tracer.read_register(s_3094_1 as isize, value);
            value
        };
        // D s_3094_3: cmp-lt s_3094_2 s_3094_0
        let s_3094_3: bool = ((s_3094_2) < (s_3094_0));
        // D s_3094_4: write-var gs#398169 <= s_3094_3
        fn_state.gs_398169 = s_3094_3;
        // N s_3094_5: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_3095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3095_0: const #23s : i
        let s_3095_0: i128 = 23;
        // D s_3095_1: read-var u#30681:u32
        let s_3095_1: u32 = fn_state.u_30681;
        // D s_3095_2: cast zx s_3095_1 -> bv
        let s_3095_2: Bits = Bits::new(s_3095_1 as u128, 32u16);
        // C s_3095_3: const #1s : i64
        let s_3095_3: i64 = 1;
        // C s_3095_4: cast zx s_3095_3 -> i
        let s_3095_4: i128 = (i128::try_from(s_3095_3).unwrap());
        // C s_3095_5: const #0s : i
        let s_3095_5: i128 = 0;
        // C s_3095_6: add s_3095_5 s_3095_4
        let s_3095_6: i128 = (s_3095_5 + s_3095_4);
        // D s_3095_7: bit-extract s_3095_2 s_3095_0 s_3095_6
        let s_3095_7: Bits = (Bits::new(
            ((s_3095_2) >> (s_3095_0)).value(),
            u16::try_from(s_3095_6).unwrap(),
        ));
        // D s_3095_8: cast reint s_3095_7 -> u8
        let s_3095_8: bool = ((s_3095_7.value()) != 0);
        // D s_3095_9: cast zx s_3095_8 -> bv
        let s_3095_9: Bits = Bits::new(s_3095_8 as u128, 1u16);
        // C s_3095_10: const #1u : u8
        let s_3095_10: bool = true;
        // C s_3095_11: cast zx s_3095_10 -> bv
        let s_3095_11: Bits = Bits::new(s_3095_10 as u128, 1u16);
        // D s_3095_12: cmp-eq s_3095_9 s_3095_11
        let s_3095_12: bool = ((s_3095_9) == (s_3095_11));
        // N s_3095_13: branch s_3095_12 b3098 b3096
        if s_3095_12 {
            return block_3098(state, tracer, fn_state);
        } else {
            return block_3096(state, tracer, fn_state);
        };
    }
    fn block_3096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3096_0: const #0u : u8
        let s_3096_0: bool = false;
        // D s_3096_1: write-var gs#398166 <= s_3096_0
        fn_state.gs_398166 = s_3096_0;
        // N s_3096_2: jump b3097
        return block_3097(state, tracer, fn_state);
    }
    fn block_3097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3097_0: read-var gs#398166:u8
        let s_3097_0: bool = fn_state.gs_398166;
        // D s_3097_1: write-var gs#398167 <= s_3097_0
        fn_state.gs_398167 = s_3097_0;
        // N s_3097_2: jump b351
        return block_351(state, tracer, fn_state);
    }
    fn block_3098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3098_0: const #9s : i
        let s_3098_0: i128 = 9;
        // D s_3098_1: read-var u#30681:u32
        let s_3098_1: u32 = fn_state.u_30681;
        // D s_3098_2: cast zx s_3098_1 -> bv
        let s_3098_2: Bits = Bits::new(s_3098_1 as u128, 32u16);
        // C s_3098_3: const #1s : i64
        let s_3098_3: i64 = 1;
        // C s_3098_4: cast zx s_3098_3 -> i
        let s_3098_4: i128 = (i128::try_from(s_3098_3).unwrap());
        // C s_3098_5: const #2s : i
        let s_3098_5: i128 = 2;
        // C s_3098_6: add s_3098_5 s_3098_4
        let s_3098_6: i128 = (s_3098_5 + s_3098_4);
        // D s_3098_7: bit-extract s_3098_2 s_3098_0 s_3098_6
        let s_3098_7: Bits = (Bits::new(
            ((s_3098_2) >> (s_3098_0)).value(),
            u16::try_from(s_3098_6).unwrap(),
        ));
        // D s_3098_8: cast reint s_3098_7 -> u8
        let s_3098_8: u8 = (s_3098_7.value() as u8);
        // D s_3098_9: cast zx s_3098_8 -> bv
        let s_3098_9: Bits = Bits::new(s_3098_8 as u128, 3u16);
        // C s_3098_10: const #0u : u8
        let s_3098_10: u8 = 0;
        // C s_3098_11: cast zx s_3098_10 -> bv
        let s_3098_11: Bits = Bits::new(s_3098_10 as u128, 3u16);
        // D s_3098_12: cmp-eq s_3098_9 s_3098_11
        let s_3098_12: bool = ((s_3098_9) == (s_3098_11));
        // N s_3098_13: branch s_3098_12 b3101 b3099
        if s_3098_12 {
            return block_3101(state, tracer, fn_state);
        } else {
            return block_3099(state, tracer, fn_state);
        };
    }
    fn block_3099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3099_0: const #0u : u8
        let s_3099_0: bool = false;
        // D s_3099_1: write-var gs#398165 <= s_3099_0
        fn_state.gs_398165 = s_3099_0;
        // N s_3099_2: jump b3100
        return block_3100(state, tracer, fn_state);
    }
    fn block_3100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3100_0: read-var gs#398165:u8
        let s_3100_0: bool = fn_state.gs_398165;
        // D s_3100_1: write-var gs#398166 <= s_3100_0
        fn_state.gs_398166 = s_3100_0;
        // N s_3100_2: jump b3097
        return block_3097(state, tracer, fn_state);
    }
    fn block_3101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3101_0: const #6s : i
        let s_3101_0: i128 = 6;
        // D s_3101_1: read-var u#30681:u32
        let s_3101_1: u32 = fn_state.u_30681;
        // D s_3101_2: cast zx s_3101_1 -> bv
        let s_3101_2: Bits = Bits::new(s_3101_1 as u128, 32u16);
        // C s_3101_3: const #1s : i64
        let s_3101_3: i64 = 1;
        // C s_3101_4: cast zx s_3101_3 -> i
        let s_3101_4: i128 = (i128::try_from(s_3101_3).unwrap());
        // C s_3101_5: const #0s : i
        let s_3101_5: i128 = 0;
        // C s_3101_6: add s_3101_5 s_3101_4
        let s_3101_6: i128 = (s_3101_5 + s_3101_4);
        // D s_3101_7: bit-extract s_3101_2 s_3101_0 s_3101_6
        let s_3101_7: Bits = (Bits::new(
            ((s_3101_2) >> (s_3101_0)).value(),
            u16::try_from(s_3101_6).unwrap(),
        ));
        // D s_3101_8: cast reint s_3101_7 -> u8
        let s_3101_8: bool = ((s_3101_7.value()) != 0);
        // D s_3101_9: cast zx s_3101_8 -> bv
        let s_3101_9: Bits = Bits::new(s_3101_8 as u128, 1u16);
        // C s_3101_10: const #0u : u8
        let s_3101_10: bool = false;
        // C s_3101_11: cast zx s_3101_10 -> bv
        let s_3101_11: Bits = Bits::new(s_3101_10 as u128, 1u16);
        // D s_3101_12: cmp-eq s_3101_9 s_3101_11
        let s_3101_12: bool = ((s_3101_9) == (s_3101_11));
        // N s_3101_13: branch s_3101_12 b3104 b3102
        if s_3101_12 {
            return block_3104(state, tracer, fn_state);
        } else {
            return block_3102(state, tracer, fn_state);
        };
    }
    fn block_3102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3102_0: const #0u : u8
        let s_3102_0: bool = false;
        // D s_3102_1: write-var gs#398164 <= s_3102_0
        fn_state.gs_398164 = s_3102_0;
        // N s_3102_2: jump b3103
        return block_3103(state, tracer, fn_state);
    }
    fn block_3103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3103_0: read-var gs#398164:u8
        let s_3103_0: bool = fn_state.gs_398164;
        // D s_3103_1: write-var gs#398165 <= s_3103_0
        fn_state.gs_398165 = s_3103_0;
        // N s_3103_2: jump b3100
        return block_3100(state, tracer, fn_state);
    }
    fn block_3104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3104_0: const #4s : i
        let s_3104_0: i128 = 4;
        // D s_3104_1: read-var u#30681:u32
        let s_3104_1: u32 = fn_state.u_30681;
        // D s_3104_2: cast zx s_3104_1 -> bv
        let s_3104_2: Bits = Bits::new(s_3104_1 as u128, 32u16);
        // C s_3104_3: const #1s : i64
        let s_3104_3: i64 = 1;
        // C s_3104_4: cast zx s_3104_3 -> i
        let s_3104_4: i128 = (i128::try_from(s_3104_3).unwrap());
        // C s_3104_5: const #0s : i
        let s_3104_5: i128 = 0;
        // C s_3104_6: add s_3104_5 s_3104_4
        let s_3104_6: i128 = (s_3104_5 + s_3104_4);
        // D s_3104_7: bit-extract s_3104_2 s_3104_0 s_3104_6
        let s_3104_7: Bits = (Bits::new(
            ((s_3104_2) >> (s_3104_0)).value(),
            u16::try_from(s_3104_6).unwrap(),
        ));
        // D s_3104_8: cast reint s_3104_7 -> u8
        let s_3104_8: bool = ((s_3104_7.value()) != 0);
        // D s_3104_9: cast zx s_3104_8 -> bv
        let s_3104_9: Bits = Bits::new(s_3104_8 as u128, 1u16);
        // C s_3104_10: const #0u : u8
        let s_3104_10: bool = false;
        // C s_3104_11: cast zx s_3104_10 -> bv
        let s_3104_11: Bits = Bits::new(s_3104_10 as u128, 1u16);
        // D s_3104_12: cmp-eq s_3104_9 s_3104_11
        let s_3104_12: bool = ((s_3104_9) == (s_3104_11));
        // D s_3104_13: write-var gs#398164 <= s_3104_12
        fn_state.gs_398164 = s_3104_12;
        // N s_3104_14: jump b3103
        return block_3103(state, tracer, fn_state);
    }
    fn block_3105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3105_0: const #3372s : i
        let s_3105_0: i128 = 3372;
        // C s_3105_1: const #14696u : u32
        let s_3105_1: u32 = 14696;
        // D s_3105_2: read-reg s_3105_1:i
        let s_3105_2: i128 = {
            let value = state.read_register::<i128>(s_3105_1 as isize);
            tracer.read_register(s_3105_1 as isize, value);
            value
        };
        // D s_3105_3: cmp-lt s_3105_2 s_3105_0
        let s_3105_3: bool = ((s_3105_2) < (s_3105_0));
        // D s_3105_4: write-var gs#398134 <= s_3105_3
        fn_state.gs_398134 = s_3105_3;
        // N s_3105_5: jump b347
        return block_347(state, tracer, fn_state);
    }
    fn block_3106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3106_0: const #8s : i
        let s_3106_0: i128 = 8;
        // D s_3106_1: read-var u#30671:u32
        let s_3106_1: u32 = fn_state.u_30671;
        // D s_3106_2: cast zx s_3106_1 -> bv
        let s_3106_2: Bits = Bits::new(s_3106_1 as u128, 32u16);
        // C s_3106_3: const #1s : i64
        let s_3106_3: i64 = 1;
        // C s_3106_4: cast zx s_3106_3 -> i
        let s_3106_4: i128 = (i128::try_from(s_3106_3).unwrap());
        // C s_3106_5: const #3s : i
        let s_3106_5: i128 = 3;
        // C s_3106_6: add s_3106_5 s_3106_4
        let s_3106_6: i128 = (s_3106_5 + s_3106_4);
        // D s_3106_7: bit-extract s_3106_2 s_3106_0 s_3106_6
        let s_3106_7: Bits = (Bits::new(
            ((s_3106_2) >> (s_3106_0)).value(),
            u16::try_from(s_3106_6).unwrap(),
        ));
        // D s_3106_8: cast reint s_3106_7 -> u8
        let s_3106_8: u8 = (s_3106_7.value() as u8);
        // D s_3106_9: cast zx s_3106_8 -> bv
        let s_3106_9: Bits = Bits::new(s_3106_8 as u128, 4u16);
        // C s_3106_10: const #8u : u8
        let s_3106_10: u8 = 8;
        // C s_3106_11: cast zx s_3106_10 -> bv
        let s_3106_11: Bits = Bits::new(s_3106_10 as u128, 4u16);
        // D s_3106_12: cmp-eq s_3106_9 s_3106_11
        let s_3106_12: bool = ((s_3106_9) == (s_3106_11));
        // N s_3106_13: branch s_3106_12 b3109 b3107
        if s_3106_12 {
            return block_3109(state, tracer, fn_state);
        } else {
            return block_3107(state, tracer, fn_state);
        };
    }
    fn block_3107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3107_0: const #0u : u8
        let s_3107_0: bool = false;
        // D s_3107_1: write-var gs#398131 <= s_3107_0
        fn_state.gs_398131 = s_3107_0;
        // N s_3107_2: jump b3108
        return block_3108(state, tracer, fn_state);
    }
    fn block_3108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3108_0: read-var gs#398131:u8
        let s_3108_0: bool = fn_state.gs_398131;
        // D s_3108_1: write-var gs#398132 <= s_3108_0
        fn_state.gs_398132 = s_3108_0;
        // N s_3108_2: jump b345
        return block_345(state, tracer, fn_state);
    }
    fn block_3109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3109_0: const #4s : i
        let s_3109_0: i128 = 4;
        // D s_3109_1: read-var u#30671:u32
        let s_3109_1: u32 = fn_state.u_30671;
        // D s_3109_2: cast zx s_3109_1 -> bv
        let s_3109_2: Bits = Bits::new(s_3109_1 as u128, 32u16);
        // C s_3109_3: const #1s : i64
        let s_3109_3: i64 = 1;
        // C s_3109_4: cast zx s_3109_3 -> i
        let s_3109_4: i128 = (i128::try_from(s_3109_3).unwrap());
        // C s_3109_5: const #0s : i
        let s_3109_5: i128 = 0;
        // C s_3109_6: add s_3109_5 s_3109_4
        let s_3109_6: i128 = (s_3109_5 + s_3109_4);
        // D s_3109_7: bit-extract s_3109_2 s_3109_0 s_3109_6
        let s_3109_7: Bits = (Bits::new(
            ((s_3109_2) >> (s_3109_0)).value(),
            u16::try_from(s_3109_6).unwrap(),
        ));
        // D s_3109_8: cast reint s_3109_7 -> u8
        let s_3109_8: bool = ((s_3109_7.value()) != 0);
        // D s_3109_9: cast zx s_3109_8 -> bv
        let s_3109_9: Bits = Bits::new(s_3109_8 as u128, 1u16);
        // C s_3109_10: const #0u : u8
        let s_3109_10: bool = false;
        // C s_3109_11: cast zx s_3109_10 -> bv
        let s_3109_11: Bits = Bits::new(s_3109_10 as u128, 1u16);
        // D s_3109_12: cmp-eq s_3109_9 s_3109_11
        let s_3109_12: bool = ((s_3109_9) == (s_3109_11));
        // D s_3109_13: write-var gs#398131 <= s_3109_12
        fn_state.gs_398131 = s_3109_12;
        // N s_3109_14: jump b3108
        return block_3108(state, tracer, fn_state);
    }
    fn block_3110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3110_0: const #3370s : i
        let s_3110_0: i128 = 3370;
        // C s_3110_1: const #14696u : u32
        let s_3110_1: u32 = 14696;
        // D s_3110_2: read-reg s_3110_1:i
        let s_3110_2: i128 = {
            let value = state.read_register::<i128>(s_3110_1 as isize);
            tracer.read_register(s_3110_1 as isize, value);
            value
        };
        // D s_3110_3: cmp-lt s_3110_2 s_3110_0
        let s_3110_3: bool = ((s_3110_2) < (s_3110_0));
        // D s_3110_4: write-var gs#398107 <= s_3110_3
        fn_state.gs_398107 = s_3110_3;
        // N s_3110_5: jump b341
        return block_341(state, tracer, fn_state);
    }
    fn block_3111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3111_0: const #8s : i
        let s_3111_0: i128 = 8;
        // D s_3111_1: read-var u#30662:u32
        let s_3111_1: u32 = fn_state.u_30662;
        // D s_3111_2: cast zx s_3111_1 -> bv
        let s_3111_2: Bits = Bits::new(s_3111_1 as u128, 32u16);
        // C s_3111_3: const #1s : i64
        let s_3111_3: i64 = 1;
        // C s_3111_4: cast zx s_3111_3 -> i
        let s_3111_4: i128 = (i128::try_from(s_3111_3).unwrap());
        // C s_3111_5: const #3s : i
        let s_3111_5: i128 = 3;
        // C s_3111_6: add s_3111_5 s_3111_4
        let s_3111_6: i128 = (s_3111_5 + s_3111_4);
        // D s_3111_7: bit-extract s_3111_2 s_3111_0 s_3111_6
        let s_3111_7: Bits = (Bits::new(
            ((s_3111_2) >> (s_3111_0)).value(),
            u16::try_from(s_3111_6).unwrap(),
        ));
        // D s_3111_8: cast reint s_3111_7 -> u8
        let s_3111_8: u8 = (s_3111_7.value() as u8);
        // D s_3111_9: cast zx s_3111_8 -> bv
        let s_3111_9: Bits = Bits::new(s_3111_8 as u128, 4u16);
        // C s_3111_10: const #4u : u8
        let s_3111_10: u8 = 4;
        // C s_3111_11: cast zx s_3111_10 -> bv
        let s_3111_11: Bits = Bits::new(s_3111_10 as u128, 4u16);
        // D s_3111_12: cmp-eq s_3111_9 s_3111_11
        let s_3111_12: bool = ((s_3111_9) == (s_3111_11));
        // N s_3111_13: branch s_3111_12 b3114 b3112
        if s_3111_12 {
            return block_3114(state, tracer, fn_state);
        } else {
            return block_3112(state, tracer, fn_state);
        };
    }
    fn block_3112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3112_0: const #0u : u8
        let s_3112_0: bool = false;
        // D s_3112_1: write-var gs#398104 <= s_3112_0
        fn_state.gs_398104 = s_3112_0;
        // N s_3112_2: jump b3113
        return block_3113(state, tracer, fn_state);
    }
    fn block_3113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3113_0: read-var gs#398104:u8
        let s_3113_0: bool = fn_state.gs_398104;
        // D s_3113_1: write-var gs#398105 <= s_3113_0
        fn_state.gs_398105 = s_3113_0;
        // N s_3113_2: jump b339
        return block_339(state, tracer, fn_state);
    }
    fn block_3114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3114_0: const #6s : i
        let s_3114_0: i128 = 6;
        // D s_3114_1: read-var u#30662:u32
        let s_3114_1: u32 = fn_state.u_30662;
        // D s_3114_2: cast zx s_3114_1 -> bv
        let s_3114_2: Bits = Bits::new(s_3114_1 as u128, 32u16);
        // C s_3114_3: const #1s : i64
        let s_3114_3: i64 = 1;
        // C s_3114_4: cast zx s_3114_3 -> i
        let s_3114_4: i128 = (i128::try_from(s_3114_3).unwrap());
        // C s_3114_5: const #0s : i
        let s_3114_5: i128 = 0;
        // C s_3114_6: add s_3114_5 s_3114_4
        let s_3114_6: i128 = (s_3114_5 + s_3114_4);
        // D s_3114_7: bit-extract s_3114_2 s_3114_0 s_3114_6
        let s_3114_7: Bits = (Bits::new(
            ((s_3114_2) >> (s_3114_0)).value(),
            u16::try_from(s_3114_6).unwrap(),
        ));
        // D s_3114_8: cast reint s_3114_7 -> u8
        let s_3114_8: bool = ((s_3114_7.value()) != 0);
        // D s_3114_9: cast zx s_3114_8 -> bv
        let s_3114_9: Bits = Bits::new(s_3114_8 as u128, 1u16);
        // C s_3114_10: const #0u : u8
        let s_3114_10: bool = false;
        // C s_3114_11: cast zx s_3114_10 -> bv
        let s_3114_11: Bits = Bits::new(s_3114_10 as u128, 1u16);
        // D s_3114_12: cmp-eq s_3114_9 s_3114_11
        let s_3114_12: bool = ((s_3114_9) == (s_3114_11));
        // N s_3114_13: branch s_3114_12 b3117 b3115
        if s_3114_12 {
            return block_3117(state, tracer, fn_state);
        } else {
            return block_3115(state, tracer, fn_state);
        };
    }
    fn block_3115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3115_0: const #0u : u8
        let s_3115_0: bool = false;
        // D s_3115_1: write-var gs#398103 <= s_3115_0
        fn_state.gs_398103 = s_3115_0;
        // N s_3115_2: jump b3116
        return block_3116(state, tracer, fn_state);
    }
    fn block_3116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3116_0: read-var gs#398103:u8
        let s_3116_0: bool = fn_state.gs_398103;
        // D s_3116_1: write-var gs#398104 <= s_3116_0
        fn_state.gs_398104 = s_3116_0;
        // N s_3116_2: jump b3113
        return block_3113(state, tracer, fn_state);
    }
    fn block_3117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3117_0: const #4s : i
        let s_3117_0: i128 = 4;
        // D s_3117_1: read-var u#30662:u32
        let s_3117_1: u32 = fn_state.u_30662;
        // D s_3117_2: cast zx s_3117_1 -> bv
        let s_3117_2: Bits = Bits::new(s_3117_1 as u128, 32u16);
        // C s_3117_3: const #1s : i64
        let s_3117_3: i64 = 1;
        // C s_3117_4: cast zx s_3117_3 -> i
        let s_3117_4: i128 = (i128::try_from(s_3117_3).unwrap());
        // C s_3117_5: const #0s : i
        let s_3117_5: i128 = 0;
        // C s_3117_6: add s_3117_5 s_3117_4
        let s_3117_6: i128 = (s_3117_5 + s_3117_4);
        // D s_3117_7: bit-extract s_3117_2 s_3117_0 s_3117_6
        let s_3117_7: Bits = (Bits::new(
            ((s_3117_2) >> (s_3117_0)).value(),
            u16::try_from(s_3117_6).unwrap(),
        ));
        // D s_3117_8: cast reint s_3117_7 -> u8
        let s_3117_8: bool = ((s_3117_7.value()) != 0);
        // D s_3117_9: cast zx s_3117_8 -> bv
        let s_3117_9: Bits = Bits::new(s_3117_8 as u128, 1u16);
        // C s_3117_10: const #0u : u8
        let s_3117_10: bool = false;
        // C s_3117_11: cast zx s_3117_10 -> bv
        let s_3117_11: Bits = Bits::new(s_3117_10 as u128, 1u16);
        // D s_3117_12: cmp-eq s_3117_9 s_3117_11
        let s_3117_12: bool = ((s_3117_9) == (s_3117_11));
        // D s_3117_13: write-var gs#398103 <= s_3117_12
        fn_state.gs_398103 = s_3117_12;
        // N s_3117_14: jump b3116
        return block_3116(state, tracer, fn_state);
    }
    fn block_3118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3118_0: const #3366s : i
        let s_3118_0: i128 = 3366;
        // C s_3118_1: const #14696u : u32
        let s_3118_1: u32 = 14696;
        // D s_3118_2: read-reg s_3118_1:i
        let s_3118_2: i128 = {
            let value = state.read_register::<i128>(s_3118_1 as isize);
            tracer.read_register(s_3118_1 as isize, value);
            value
        };
        // D s_3118_3: cmp-lt s_3118_2 s_3118_0
        let s_3118_3: bool = ((s_3118_2) < (s_3118_0));
        // D s_3118_4: write-var gs#398075 <= s_3118_3
        fn_state.gs_398075 = s_3118_3;
        // N s_3118_5: jump b335
        return block_335(state, tracer, fn_state);
    }
    fn block_3119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3119_0: const #21s : i
        let s_3119_0: i128 = 21;
        // D s_3119_1: read-var u#30652:u32
        let s_3119_1: u32 = fn_state.u_30652;
        // D s_3119_2: cast zx s_3119_1 -> bv
        let s_3119_2: Bits = Bits::new(s_3119_1 as u128, 32u16);
        // C s_3119_3: const #1s : i64
        let s_3119_3: i64 = 1;
        // C s_3119_4: cast zx s_3119_3 -> i
        let s_3119_4: i128 = (i128::try_from(s_3119_3).unwrap());
        // C s_3119_5: const #0s : i
        let s_3119_5: i128 = 0;
        // C s_3119_6: add s_3119_5 s_3119_4
        let s_3119_6: i128 = (s_3119_5 + s_3119_4);
        // D s_3119_7: bit-extract s_3119_2 s_3119_0 s_3119_6
        let s_3119_7: Bits = (Bits::new(
            ((s_3119_2) >> (s_3119_0)).value(),
            u16::try_from(s_3119_6).unwrap(),
        ));
        // D s_3119_8: cast reint s_3119_7 -> u8
        let s_3119_8: bool = ((s_3119_7.value()) != 0);
        // D s_3119_9: cast zx s_3119_8 -> bv
        let s_3119_9: Bits = Bits::new(s_3119_8 as u128, 1u16);
        // C s_3119_10: const #0u : u8
        let s_3119_10: bool = false;
        // C s_3119_11: cast zx s_3119_10 -> bv
        let s_3119_11: Bits = Bits::new(s_3119_10 as u128, 1u16);
        // D s_3119_12: cmp-eq s_3119_9 s_3119_11
        let s_3119_12: bool = ((s_3119_9) == (s_3119_11));
        // N s_3119_13: branch s_3119_12 b3122 b3120
        if s_3119_12 {
            return block_3122(state, tracer, fn_state);
        } else {
            return block_3120(state, tracer, fn_state);
        };
    }
    fn block_3120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3120_0: const #0u : u8
        let s_3120_0: bool = false;
        // D s_3120_1: write-var gs#398072 <= s_3120_0
        fn_state.gs_398072 = s_3120_0;
        // N s_3120_2: jump b3121
        return block_3121(state, tracer, fn_state);
    }
    fn block_3121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3121_0: read-var gs#398072:u8
        let s_3121_0: bool = fn_state.gs_398072;
        // D s_3121_1: write-var gs#398073 <= s_3121_0
        fn_state.gs_398073 = s_3121_0;
        // N s_3121_2: jump b333
        return block_333(state, tracer, fn_state);
    }
    fn block_3122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3122_0: const #8s : i
        let s_3122_0: i128 = 8;
        // D s_3122_1: read-var u#30652:u32
        let s_3122_1: u32 = fn_state.u_30652;
        // D s_3122_2: cast zx s_3122_1 -> bv
        let s_3122_2: Bits = Bits::new(s_3122_1 as u128, 32u16);
        // C s_3122_3: const #1s : i64
        let s_3122_3: i64 = 1;
        // C s_3122_4: cast zx s_3122_3 -> i
        let s_3122_4: i128 = (i128::try_from(s_3122_3).unwrap());
        // C s_3122_5: const #3s : i
        let s_3122_5: i128 = 3;
        // C s_3122_6: add s_3122_5 s_3122_4
        let s_3122_6: i128 = (s_3122_5 + s_3122_4);
        // D s_3122_7: bit-extract s_3122_2 s_3122_0 s_3122_6
        let s_3122_7: Bits = (Bits::new(
            ((s_3122_2) >> (s_3122_0)).value(),
            u16::try_from(s_3122_6).unwrap(),
        ));
        // D s_3122_8: cast reint s_3122_7 -> u8
        let s_3122_8: u8 = (s_3122_7.value() as u8);
        // D s_3122_9: cast zx s_3122_8 -> bv
        let s_3122_9: Bits = Bits::new(s_3122_8 as u128, 4u16);
        // C s_3122_10: const #13u : u8
        let s_3122_10: u8 = 13;
        // C s_3122_11: cast zx s_3122_10 -> bv
        let s_3122_11: Bits = Bits::new(s_3122_10 as u128, 4u16);
        // D s_3122_12: cmp-eq s_3122_9 s_3122_11
        let s_3122_12: bool = ((s_3122_9) == (s_3122_11));
        // N s_3122_13: branch s_3122_12 b3125 b3123
        if s_3122_12 {
            return block_3125(state, tracer, fn_state);
        } else {
            return block_3123(state, tracer, fn_state);
        };
    }
    fn block_3123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3123_0: const #0u : u8
        let s_3123_0: bool = false;
        // D s_3123_1: write-var gs#398071 <= s_3123_0
        fn_state.gs_398071 = s_3123_0;
        // N s_3123_2: jump b3124
        return block_3124(state, tracer, fn_state);
    }
    fn block_3124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3124_0: read-var gs#398071:u8
        let s_3124_0: bool = fn_state.gs_398071;
        // D s_3124_1: write-var gs#398072 <= s_3124_0
        fn_state.gs_398072 = s_3124_0;
        // N s_3124_2: jump b3121
        return block_3121(state, tracer, fn_state);
    }
    fn block_3125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3125_0: const #4s : i
        let s_3125_0: i128 = 4;
        // D s_3125_1: read-var u#30652:u32
        let s_3125_1: u32 = fn_state.u_30652;
        // D s_3125_2: cast zx s_3125_1 -> bv
        let s_3125_2: Bits = Bits::new(s_3125_1 as u128, 32u16);
        // C s_3125_3: const #1s : i64
        let s_3125_3: i64 = 1;
        // C s_3125_4: cast zx s_3125_3 -> i
        let s_3125_4: i128 = (i128::try_from(s_3125_3).unwrap());
        // C s_3125_5: const #0s : i
        let s_3125_5: i128 = 0;
        // C s_3125_6: add s_3125_5 s_3125_4
        let s_3125_6: i128 = (s_3125_5 + s_3125_4);
        // D s_3125_7: bit-extract s_3125_2 s_3125_0 s_3125_6
        let s_3125_7: Bits = (Bits::new(
            ((s_3125_2) >> (s_3125_0)).value(),
            u16::try_from(s_3125_6).unwrap(),
        ));
        // D s_3125_8: cast reint s_3125_7 -> u8
        let s_3125_8: bool = ((s_3125_7.value()) != 0);
        // D s_3125_9: cast zx s_3125_8 -> bv
        let s_3125_9: Bits = Bits::new(s_3125_8 as u128, 1u16);
        // C s_3125_10: const #0u : u8
        let s_3125_10: bool = false;
        // C s_3125_11: cast zx s_3125_10 -> bv
        let s_3125_11: Bits = Bits::new(s_3125_10 as u128, 1u16);
        // D s_3125_12: cmp-eq s_3125_9 s_3125_11
        let s_3125_12: bool = ((s_3125_9) == (s_3125_11));
        // D s_3125_13: write-var gs#398071 <= s_3125_12
        fn_state.gs_398071 = s_3125_12;
        // N s_3125_14: jump b3124
        return block_3124(state, tracer, fn_state);
    }
    fn block_3126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3126_0: const #3364s : i
        let s_3126_0: i128 = 3364;
        // C s_3126_1: const #14696u : u32
        let s_3126_1: u32 = 14696;
        // D s_3126_2: read-reg s_3126_1:i
        let s_3126_2: i128 = {
            let value = state.read_register::<i128>(s_3126_1 as isize);
            tracer.read_register(s_3126_1 as isize, value);
            value
        };
        // D s_3126_3: cmp-lt s_3126_2 s_3126_0
        let s_3126_3: bool = ((s_3126_2) < (s_3126_0));
        // D s_3126_4: write-var gs#398041 <= s_3126_3
        fn_state.gs_398041 = s_3126_3;
        // N s_3126_5: jump b329
        return block_329(state, tracer, fn_state);
    }
    fn block_3127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3127_0: const #8s : i
        let s_3127_0: i128 = 8;
        // D s_3127_1: read-var u#30642:u32
        let s_3127_1: u32 = fn_state.u_30642;
        // D s_3127_2: cast zx s_3127_1 -> bv
        let s_3127_2: Bits = Bits::new(s_3127_1 as u128, 32u16);
        // C s_3127_3: const #1s : i64
        let s_3127_3: i64 = 1;
        // C s_3127_4: cast zx s_3127_3 -> i
        let s_3127_4: i128 = (i128::try_from(s_3127_3).unwrap());
        // C s_3127_5: const #3s : i
        let s_3127_5: i128 = 3;
        // C s_3127_6: add s_3127_5 s_3127_4
        let s_3127_6: i128 = (s_3127_5 + s_3127_4);
        // D s_3127_7: bit-extract s_3127_2 s_3127_0 s_3127_6
        let s_3127_7: Bits = (Bits::new(
            ((s_3127_2) >> (s_3127_0)).value(),
            u16::try_from(s_3127_6).unwrap(),
        ));
        // D s_3127_8: cast reint s_3127_7 -> u8
        let s_3127_8: u8 = (s_3127_7.value() as u8);
        // D s_3127_9: cast zx s_3127_8 -> bv
        let s_3127_9: Bits = Bits::new(s_3127_8 as u128, 4u16);
        // C s_3127_10: const #14u : u8
        let s_3127_10: u8 = 14;
        // C s_3127_11: cast zx s_3127_10 -> bv
        let s_3127_11: Bits = Bits::new(s_3127_10 as u128, 4u16);
        // D s_3127_12: cmp-eq s_3127_9 s_3127_11
        let s_3127_12: bool = ((s_3127_9) == (s_3127_11));
        // N s_3127_13: branch s_3127_12 b3130 b3128
        if s_3127_12 {
            return block_3130(state, tracer, fn_state);
        } else {
            return block_3128(state, tracer, fn_state);
        };
    }
    fn block_3128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3128_0: const #0u : u8
        let s_3128_0: bool = false;
        // D s_3128_1: write-var gs#398038 <= s_3128_0
        fn_state.gs_398038 = s_3128_0;
        // N s_3128_2: jump b3129
        return block_3129(state, tracer, fn_state);
    }
    fn block_3129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3129_0: read-var gs#398038:u8
        let s_3129_0: bool = fn_state.gs_398038;
        // D s_3129_1: write-var gs#398039 <= s_3129_0
        fn_state.gs_398039 = s_3129_0;
        // N s_3129_2: jump b327
        return block_327(state, tracer, fn_state);
    }
    fn block_3130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3130_0: const #4s : i
        let s_3130_0: i128 = 4;
        // D s_3130_1: read-var u#30642:u32
        let s_3130_1: u32 = fn_state.u_30642;
        // D s_3130_2: cast zx s_3130_1 -> bv
        let s_3130_2: Bits = Bits::new(s_3130_1 as u128, 32u16);
        // C s_3130_3: const #1s : i64
        let s_3130_3: i64 = 1;
        // C s_3130_4: cast zx s_3130_3 -> i
        let s_3130_4: i128 = (i128::try_from(s_3130_3).unwrap());
        // C s_3130_5: const #0s : i
        let s_3130_5: i128 = 0;
        // C s_3130_6: add s_3130_5 s_3130_4
        let s_3130_6: i128 = (s_3130_5 + s_3130_4);
        // D s_3130_7: bit-extract s_3130_2 s_3130_0 s_3130_6
        let s_3130_7: Bits = (Bits::new(
            ((s_3130_2) >> (s_3130_0)).value(),
            u16::try_from(s_3130_6).unwrap(),
        ));
        // D s_3130_8: cast reint s_3130_7 -> u8
        let s_3130_8: bool = ((s_3130_7.value()) != 0);
        // D s_3130_9: cast zx s_3130_8 -> bv
        let s_3130_9: Bits = Bits::new(s_3130_8 as u128, 1u16);
        // C s_3130_10: const #1u : u8
        let s_3130_10: bool = true;
        // C s_3130_11: cast zx s_3130_10 -> bv
        let s_3130_11: Bits = Bits::new(s_3130_10 as u128, 1u16);
        // D s_3130_12: cmp-eq s_3130_9 s_3130_11
        let s_3130_12: bool = ((s_3130_9) == (s_3130_11));
        // D s_3130_13: write-var gs#398038 <= s_3130_12
        fn_state.gs_398038 = s_3130_12;
        // N s_3130_14: jump b3129
        return block_3129(state, tracer, fn_state);
    }
    fn block_3131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3131_0: const #3360s : i
        let s_3131_0: i128 = 3360;
        // C s_3131_1: const #14696u : u32
        let s_3131_1: u32 = 14696;
        // D s_3131_2: read-reg s_3131_1:i
        let s_3131_2: i128 = {
            let value = state.read_register::<i128>(s_3131_1 as isize);
            tracer.read_register(s_3131_1 as isize, value);
            value
        };
        // D s_3131_3: cmp-lt s_3131_2 s_3131_0
        let s_3131_3: bool = ((s_3131_2) < (s_3131_0));
        // D s_3131_4: write-var gs#398014 <= s_3131_3
        fn_state.gs_398014 = s_3131_3;
        // N s_3131_5: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_3132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3132_0: const #20s : i
        let s_3132_0: i128 = 20;
        // D s_3132_1: read-var u#30634:u32
        let s_3132_1: u32 = fn_state.u_30634;
        // D s_3132_2: cast zx s_3132_1 -> bv
        let s_3132_2: Bits = Bits::new(s_3132_1 as u128, 32u16);
        // C s_3132_3: const #1s : i64
        let s_3132_3: i64 = 1;
        // C s_3132_4: cast zx s_3132_3 -> i
        let s_3132_4: i128 = (i128::try_from(s_3132_3).unwrap());
        // C s_3132_5: const #1s : i
        let s_3132_5: i128 = 1;
        // C s_3132_6: add s_3132_5 s_3132_4
        let s_3132_6: i128 = (s_3132_5 + s_3132_4);
        // D s_3132_7: bit-extract s_3132_2 s_3132_0 s_3132_6
        let s_3132_7: Bits = (Bits::new(
            ((s_3132_2) >> (s_3132_0)).value(),
            u16::try_from(s_3132_6).unwrap(),
        ));
        // D s_3132_8: cast reint s_3132_7 -> u8
        let s_3132_8: u8 = (s_3132_7.value() as u8);
        // D s_3132_9: cast zx s_3132_8 -> bv
        let s_3132_9: Bits = Bits::new(s_3132_8 as u128, 2u16);
        // C s_3132_10: const #3u : u8
        let s_3132_10: u8 = 3;
        // C s_3132_11: cast zx s_3132_10 -> bv
        let s_3132_11: Bits = Bits::new(s_3132_10 as u128, 2u16);
        // D s_3132_12: cmp-eq s_3132_9 s_3132_11
        let s_3132_12: bool = ((s_3132_9) == (s_3132_11));
        // N s_3132_13: branch s_3132_12 b3135 b3133
        if s_3132_12 {
            return block_3135(state, tracer, fn_state);
        } else {
            return block_3133(state, tracer, fn_state);
        };
    }
    fn block_3133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3133_0: const #0u : u8
        let s_3133_0: bool = false;
        // D s_3133_1: write-var gs#398011 <= s_3133_0
        fn_state.gs_398011 = s_3133_0;
        // N s_3133_2: jump b3134
        return block_3134(state, tracer, fn_state);
    }
    fn block_3134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3134_0: read-var gs#398011:u8
        let s_3134_0: bool = fn_state.gs_398011;
        // D s_3134_1: write-var gs#398012 <= s_3134_0
        fn_state.gs_398012 = s_3134_0;
        // N s_3134_2: jump b321
        return block_321(state, tracer, fn_state);
    }
    fn block_3135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3135_0: const #16s : i
        let s_3135_0: i128 = 16;
        // D s_3135_1: read-var u#30634:u32
        let s_3135_1: u32 = fn_state.u_30634;
        // D s_3135_2: cast zx s_3135_1 -> bv
        let s_3135_2: Bits = Bits::new(s_3135_1 as u128, 32u16);
        // C s_3135_3: const #1s : i64
        let s_3135_3: i64 = 1;
        // C s_3135_4: cast zx s_3135_3 -> i
        let s_3135_4: i128 = (i128::try_from(s_3135_3).unwrap());
        // C s_3135_5: const #1s : i
        let s_3135_5: i128 = 1;
        // C s_3135_6: add s_3135_5 s_3135_4
        let s_3135_6: i128 = (s_3135_5 + s_3135_4);
        // D s_3135_7: bit-extract s_3135_2 s_3135_0 s_3135_6
        let s_3135_7: Bits = (Bits::new(
            ((s_3135_2) >> (s_3135_0)).value(),
            u16::try_from(s_3135_6).unwrap(),
        ));
        // D s_3135_8: cast reint s_3135_7 -> u8
        let s_3135_8: u8 = (s_3135_7.value() as u8);
        // D s_3135_9: cast zx s_3135_8 -> bv
        let s_3135_9: Bits = Bits::new(s_3135_8 as u128, 2u16);
        // C s_3135_10: const #1u : u8
        let s_3135_10: u8 = 1;
        // C s_3135_11: cast zx s_3135_10 -> bv
        let s_3135_11: Bits = Bits::new(s_3135_10 as u128, 2u16);
        // D s_3135_12: cmp-eq s_3135_9 s_3135_11
        let s_3135_12: bool = ((s_3135_9) == (s_3135_11));
        // N s_3135_13: branch s_3135_12 b3138 b3136
        if s_3135_12 {
            return block_3138(state, tracer, fn_state);
        } else {
            return block_3136(state, tracer, fn_state);
        };
    }
    fn block_3136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3136_0: const #0u : u8
        let s_3136_0: bool = false;
        // D s_3136_1: write-var gs#398010 <= s_3136_0
        fn_state.gs_398010 = s_3136_0;
        // N s_3136_2: jump b3137
        return block_3137(state, tracer, fn_state);
    }
    fn block_3137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3137_0: read-var gs#398010:u8
        let s_3137_0: bool = fn_state.gs_398010;
        // D s_3137_1: write-var gs#398011 <= s_3137_0
        fn_state.gs_398011 = s_3137_0;
        // N s_3137_2: jump b3134
        return block_3134(state, tracer, fn_state);
    }
    fn block_3138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3138_0: const #11s : i
        let s_3138_0: i128 = 11;
        // D s_3138_1: read-var u#30634:u32
        let s_3138_1: u32 = fn_state.u_30634;
        // D s_3138_2: cast zx s_3138_1 -> bv
        let s_3138_2: Bits = Bits::new(s_3138_1 as u128, 32u16);
        // C s_3138_3: const #1s : i64
        let s_3138_3: i64 = 1;
        // C s_3138_4: cast zx s_3138_3 -> i
        let s_3138_4: i128 = (i128::try_from(s_3138_3).unwrap());
        // C s_3138_5: const #0s : i
        let s_3138_5: i128 = 0;
        // C s_3138_6: add s_3138_5 s_3138_4
        let s_3138_6: i128 = (s_3138_5 + s_3138_4);
        // D s_3138_7: bit-extract s_3138_2 s_3138_0 s_3138_6
        let s_3138_7: Bits = (Bits::new(
            ((s_3138_2) >> (s_3138_0)).value(),
            u16::try_from(s_3138_6).unwrap(),
        ));
        // D s_3138_8: cast reint s_3138_7 -> u8
        let s_3138_8: bool = ((s_3138_7.value()) != 0);
        // D s_3138_9: cast zx s_3138_8 -> bv
        let s_3138_9: Bits = Bits::new(s_3138_8 as u128, 1u16);
        // C s_3138_10: const #0u : u8
        let s_3138_10: bool = false;
        // C s_3138_11: cast zx s_3138_10 -> bv
        let s_3138_11: Bits = Bits::new(s_3138_10 as u128, 1u16);
        // D s_3138_12: cmp-eq s_3138_9 s_3138_11
        let s_3138_12: bool = ((s_3138_9) == (s_3138_11));
        // N s_3138_13: branch s_3138_12 b3141 b3139
        if s_3138_12 {
            return block_3141(state, tracer, fn_state);
        } else {
            return block_3139(state, tracer, fn_state);
        };
    }
    fn block_3139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3139_0: const #0u : u8
        let s_3139_0: bool = false;
        // D s_3139_1: write-var gs#398009 <= s_3139_0
        fn_state.gs_398009 = s_3139_0;
        // N s_3139_2: jump b3140
        return block_3140(state, tracer, fn_state);
    }
    fn block_3140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3140_0: read-var gs#398009:u8
        let s_3140_0: bool = fn_state.gs_398009;
        // D s_3140_1: write-var gs#398010 <= s_3140_0
        fn_state.gs_398010 = s_3140_0;
        // N s_3140_2: jump b3137
        return block_3137(state, tracer, fn_state);
    }
    fn block_3141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3141_0: const #7s : i
        let s_3141_0: i128 = 7;
        // D s_3141_1: read-var u#30634:u32
        let s_3141_1: u32 = fn_state.u_30634;
        // D s_3141_2: cast zx s_3141_1 -> bv
        let s_3141_2: Bits = Bits::new(s_3141_1 as u128, 32u16);
        // C s_3141_3: const #1s : i64
        let s_3141_3: i64 = 1;
        // C s_3141_4: cast zx s_3141_3 -> i
        let s_3141_4: i128 = (i128::try_from(s_3141_3).unwrap());
        // C s_3141_5: const #2s : i
        let s_3141_5: i128 = 2;
        // C s_3141_6: add s_3141_5 s_3141_4
        let s_3141_6: i128 = (s_3141_5 + s_3141_4);
        // D s_3141_7: bit-extract s_3141_2 s_3141_0 s_3141_6
        let s_3141_7: Bits = (Bits::new(
            ((s_3141_2) >> (s_3141_0)).value(),
            u16::try_from(s_3141_6).unwrap(),
        ));
        // D s_3141_8: cast reint s_3141_7 -> u8
        let s_3141_8: u8 = (s_3141_7.value() as u8);
        // D s_3141_9: cast zx s_3141_8 -> bv
        let s_3141_9: Bits = Bits::new(s_3141_8 as u128, 3u16);
        // C s_3141_10: const #6u : u8
        let s_3141_10: u8 = 6;
        // C s_3141_11: cast zx s_3141_10 -> bv
        let s_3141_11: Bits = Bits::new(s_3141_10 as u128, 3u16);
        // D s_3141_12: cmp-eq s_3141_9 s_3141_11
        let s_3141_12: bool = ((s_3141_9) == (s_3141_11));
        // N s_3141_13: branch s_3141_12 b3144 b3142
        if s_3141_12 {
            return block_3144(state, tracer, fn_state);
        } else {
            return block_3142(state, tracer, fn_state);
        };
    }
    fn block_3142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3142_0: const #0u : u8
        let s_3142_0: bool = false;
        // D s_3142_1: write-var gs#398008 <= s_3142_0
        fn_state.gs_398008 = s_3142_0;
        // N s_3142_2: jump b3143
        return block_3143(state, tracer, fn_state);
    }
    fn block_3143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3143_0: read-var gs#398008:u8
        let s_3143_0: bool = fn_state.gs_398008;
        // D s_3143_1: write-var gs#398009 <= s_3143_0
        fn_state.gs_398009 = s_3143_0;
        // N s_3143_2: jump b3140
        return block_3140(state, tracer, fn_state);
    }
    fn block_3144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3144_0: const #4s : i
        let s_3144_0: i128 = 4;
        // D s_3144_1: read-var u#30634:u32
        let s_3144_1: u32 = fn_state.u_30634;
        // D s_3144_2: cast zx s_3144_1 -> bv
        let s_3144_2: Bits = Bits::new(s_3144_1 as u128, 32u16);
        // C s_3144_3: const #1s : i64
        let s_3144_3: i64 = 1;
        // C s_3144_4: cast zx s_3144_3 -> i
        let s_3144_4: i128 = (i128::try_from(s_3144_3).unwrap());
        // C s_3144_5: const #0s : i
        let s_3144_5: i128 = 0;
        // C s_3144_6: add s_3144_5 s_3144_4
        let s_3144_6: i128 = (s_3144_5 + s_3144_4);
        // D s_3144_7: bit-extract s_3144_2 s_3144_0 s_3144_6
        let s_3144_7: Bits = (Bits::new(
            ((s_3144_2) >> (s_3144_0)).value(),
            u16::try_from(s_3144_6).unwrap(),
        ));
        // D s_3144_8: cast reint s_3144_7 -> u8
        let s_3144_8: bool = ((s_3144_7.value()) != 0);
        // D s_3144_9: cast zx s_3144_8 -> bv
        let s_3144_9: Bits = Bits::new(s_3144_8 as u128, 1u16);
        // C s_3144_10: const #0u : u8
        let s_3144_10: bool = false;
        // C s_3144_11: cast zx s_3144_10 -> bv
        let s_3144_11: Bits = Bits::new(s_3144_10 as u128, 1u16);
        // D s_3144_12: cmp-eq s_3144_9 s_3144_11
        let s_3144_12: bool = ((s_3144_9) == (s_3144_11));
        // D s_3144_13: write-var gs#398008 <= s_3144_12
        fn_state.gs_398008 = s_3144_12;
        // N s_3144_14: jump b3143
        return block_3143(state, tracer, fn_state);
    }
    fn block_3145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3145_0: const #3357s : i
        let s_3145_0: i128 = 3357;
        // C s_3145_1: const #14696u : u32
        let s_3145_1: u32 = 14696;
        // D s_3145_2: read-reg s_3145_1:i
        let s_3145_2: i128 = {
            let value = state.read_register::<i128>(s_3145_1 as isize);
            tracer.read_register(s_3145_1 as isize, value);
            value
        };
        // D s_3145_3: cmp-lt s_3145_2 s_3145_0
        let s_3145_3: bool = ((s_3145_2) < (s_3145_0));
        // D s_3145_4: write-var gs#397976 <= s_3145_3
        fn_state.gs_397976 = s_3145_3;
        // N s_3145_5: jump b317
        return block_317(state, tracer, fn_state);
    }
    fn block_3146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3146_0: const #23s : i
        let s_3146_0: i128 = 23;
        // D s_3146_1: read-var u#30624:u32
        let s_3146_1: u32 = fn_state.u_30624;
        // D s_3146_2: cast zx s_3146_1 -> bv
        let s_3146_2: Bits = Bits::new(s_3146_1 as u128, 32u16);
        // C s_3146_3: const #1s : i64
        let s_3146_3: i64 = 1;
        // C s_3146_4: cast zx s_3146_3 -> i
        let s_3146_4: i128 = (i128::try_from(s_3146_3).unwrap());
        // C s_3146_5: const #0s : i
        let s_3146_5: i128 = 0;
        // C s_3146_6: add s_3146_5 s_3146_4
        let s_3146_6: i128 = (s_3146_5 + s_3146_4);
        // D s_3146_7: bit-extract s_3146_2 s_3146_0 s_3146_6
        let s_3146_7: Bits = (Bits::new(
            ((s_3146_2) >> (s_3146_0)).value(),
            u16::try_from(s_3146_6).unwrap(),
        ));
        // D s_3146_8: cast reint s_3146_7 -> u8
        let s_3146_8: bool = ((s_3146_7.value()) != 0);
        // D s_3146_9: cast zx s_3146_8 -> bv
        let s_3146_9: Bits = Bits::new(s_3146_8 as u128, 1u16);
        // C s_3146_10: const #1u : u8
        let s_3146_10: bool = true;
        // C s_3146_11: cast zx s_3146_10 -> bv
        let s_3146_11: Bits = Bits::new(s_3146_10 as u128, 1u16);
        // D s_3146_12: cmp-eq s_3146_9 s_3146_11
        let s_3146_12: bool = ((s_3146_9) == (s_3146_11));
        // N s_3146_13: branch s_3146_12 b3149 b3147
        if s_3146_12 {
            return block_3149(state, tracer, fn_state);
        } else {
            return block_3147(state, tracer, fn_state);
        };
    }
    fn block_3147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3147_0: const #0u : u8
        let s_3147_0: bool = false;
        // D s_3147_1: write-var gs#397973 <= s_3147_0
        fn_state.gs_397973 = s_3147_0;
        // N s_3147_2: jump b3148
        return block_3148(state, tracer, fn_state);
    }
    fn block_3148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3148_0: read-var gs#397973:u8
        let s_3148_0: bool = fn_state.gs_397973;
        // D s_3148_1: write-var gs#397974 <= s_3148_0
        fn_state.gs_397974 = s_3148_0;
        // N s_3148_2: jump b315
        return block_315(state, tracer, fn_state);
    }
    fn block_3149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3149_0: const #8s : i
        let s_3149_0: i128 = 8;
        // D s_3149_1: read-var u#30624:u32
        let s_3149_1: u32 = fn_state.u_30624;
        // D s_3149_2: cast zx s_3149_1 -> bv
        let s_3149_2: Bits = Bits::new(s_3149_1 as u128, 32u16);
        // C s_3149_3: const #1s : i64
        let s_3149_3: i64 = 1;
        // C s_3149_4: cast zx s_3149_3 -> i
        let s_3149_4: i128 = (i128::try_from(s_3149_3).unwrap());
        // C s_3149_5: const #3s : i
        let s_3149_5: i128 = 3;
        // C s_3149_6: add s_3149_5 s_3149_4
        let s_3149_6: i128 = (s_3149_5 + s_3149_4);
        // D s_3149_7: bit-extract s_3149_2 s_3149_0 s_3149_6
        let s_3149_7: Bits = (Bits::new(
            ((s_3149_2) >> (s_3149_0)).value(),
            u16::try_from(s_3149_6).unwrap(),
        ));
        // D s_3149_8: cast reint s_3149_7 -> u8
        let s_3149_8: u8 = (s_3149_7.value() as u8);
        // D s_3149_9: cast zx s_3149_8 -> bv
        let s_3149_9: Bits = Bits::new(s_3149_8 as u128, 4u16);
        // C s_3149_10: const #7u : u8
        let s_3149_10: u8 = 7;
        // C s_3149_11: cast zx s_3149_10 -> bv
        let s_3149_11: Bits = Bits::new(s_3149_10 as u128, 4u16);
        // D s_3149_12: cmp-eq s_3149_9 s_3149_11
        let s_3149_12: bool = ((s_3149_9) == (s_3149_11));
        // N s_3149_13: branch s_3149_12 b3152 b3150
        if s_3149_12 {
            return block_3152(state, tracer, fn_state);
        } else {
            return block_3150(state, tracer, fn_state);
        };
    }
    fn block_3150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3150_0: const #0u : u8
        let s_3150_0: bool = false;
        // D s_3150_1: write-var gs#397972 <= s_3150_0
        fn_state.gs_397972 = s_3150_0;
        // N s_3150_2: jump b3151
        return block_3151(state, tracer, fn_state);
    }
    fn block_3151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3151_0: read-var gs#397972:u8
        let s_3151_0: bool = fn_state.gs_397972;
        // D s_3151_1: write-var gs#397973 <= s_3151_0
        fn_state.gs_397973 = s_3151_0;
        // N s_3151_2: jump b3148
        return block_3148(state, tracer, fn_state);
    }
    fn block_3152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3152_0: const #6s : i
        let s_3152_0: i128 = 6;
        // D s_3152_1: read-var u#30624:u32
        let s_3152_1: u32 = fn_state.u_30624;
        // D s_3152_2: cast zx s_3152_1 -> bv
        let s_3152_2: Bits = Bits::new(s_3152_1 as u128, 32u16);
        // C s_3152_3: const #1s : i64
        let s_3152_3: i64 = 1;
        // C s_3152_4: cast zx s_3152_3 -> i
        let s_3152_4: i128 = (i128::try_from(s_3152_3).unwrap());
        // C s_3152_5: const #0s : i
        let s_3152_5: i128 = 0;
        // C s_3152_6: add s_3152_5 s_3152_4
        let s_3152_6: i128 = (s_3152_5 + s_3152_4);
        // D s_3152_7: bit-extract s_3152_2 s_3152_0 s_3152_6
        let s_3152_7: Bits = (Bits::new(
            ((s_3152_2) >> (s_3152_0)).value(),
            u16::try_from(s_3152_6).unwrap(),
        ));
        // D s_3152_8: cast reint s_3152_7 -> u8
        let s_3152_8: bool = ((s_3152_7.value()) != 0);
        // D s_3152_9: cast zx s_3152_8 -> bv
        let s_3152_9: Bits = Bits::new(s_3152_8 as u128, 1u16);
        // C s_3152_10: const #0u : u8
        let s_3152_10: bool = false;
        // C s_3152_11: cast zx s_3152_10 -> bv
        let s_3152_11: Bits = Bits::new(s_3152_10 as u128, 1u16);
        // D s_3152_12: cmp-eq s_3152_9 s_3152_11
        let s_3152_12: bool = ((s_3152_9) == (s_3152_11));
        // N s_3152_13: branch s_3152_12 b3155 b3153
        if s_3152_12 {
            return block_3155(state, tracer, fn_state);
        } else {
            return block_3153(state, tracer, fn_state);
        };
    }
    fn block_3153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3153_0: const #0u : u8
        let s_3153_0: bool = false;
        // D s_3153_1: write-var gs#397971 <= s_3153_0
        fn_state.gs_397971 = s_3153_0;
        // N s_3153_2: jump b3154
        return block_3154(state, tracer, fn_state);
    }
    fn block_3154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3154_0: read-var gs#397971:u8
        let s_3154_0: bool = fn_state.gs_397971;
        // D s_3154_1: write-var gs#397972 <= s_3154_0
        fn_state.gs_397972 = s_3154_0;
        // N s_3154_2: jump b3151
        return block_3151(state, tracer, fn_state);
    }
    fn block_3155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3155_0: const #4s : i
        let s_3155_0: i128 = 4;
        // D s_3155_1: read-var u#30624:u32
        let s_3155_1: u32 = fn_state.u_30624;
        // D s_3155_2: cast zx s_3155_1 -> bv
        let s_3155_2: Bits = Bits::new(s_3155_1 as u128, 32u16);
        // C s_3155_3: const #1s : i64
        let s_3155_3: i64 = 1;
        // C s_3155_4: cast zx s_3155_3 -> i
        let s_3155_4: i128 = (i128::try_from(s_3155_3).unwrap());
        // C s_3155_5: const #0s : i
        let s_3155_5: i128 = 0;
        // C s_3155_6: add s_3155_5 s_3155_4
        let s_3155_6: i128 = (s_3155_5 + s_3155_4);
        // D s_3155_7: bit-extract s_3155_2 s_3155_0 s_3155_6
        let s_3155_7: Bits = (Bits::new(
            ((s_3155_2) >> (s_3155_0)).value(),
            u16::try_from(s_3155_6).unwrap(),
        ));
        // D s_3155_8: cast reint s_3155_7 -> u8
        let s_3155_8: bool = ((s_3155_7.value()) != 0);
        // D s_3155_9: cast zx s_3155_8 -> bv
        let s_3155_9: Bits = Bits::new(s_3155_8 as u128, 1u16);
        // C s_3155_10: const #0u : u8
        let s_3155_10: bool = false;
        // C s_3155_11: cast zx s_3155_10 -> bv
        let s_3155_11: Bits = Bits::new(s_3155_10 as u128, 1u16);
        // D s_3155_12: cmp-eq s_3155_9 s_3155_11
        let s_3155_12: bool = ((s_3155_9) == (s_3155_11));
        // D s_3155_13: write-var gs#397971 <= s_3155_12
        fn_state.gs_397971 = s_3155_12;
        // N s_3155_14: jump b3154
        return block_3154(state, tracer, fn_state);
    }
    fn block_3156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3156_0: const #3356s : i
        let s_3156_0: i128 = 3356;
        // C s_3156_1: const #14696u : u32
        let s_3156_1: u32 = 14696;
        // D s_3156_2: read-reg s_3156_1:i
        let s_3156_2: i128 = {
            let value = state.read_register::<i128>(s_3156_1 as isize);
            tracer.read_register(s_3156_1 as isize, value);
            value
        };
        // D s_3156_3: cmp-lt s_3156_2 s_3156_0
        let s_3156_3: bool = ((s_3156_2) < (s_3156_0));
        // D s_3156_4: write-var gs#397939 <= s_3156_3
        fn_state.gs_397939 = s_3156_3;
        // N s_3156_5: jump b311
        return block_311(state, tracer, fn_state);
    }
    fn block_3157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3157_0: const #23s : i
        let s_3157_0: i128 = 23;
        // D s_3157_1: read-var u#30613:u32
        let s_3157_1: u32 = fn_state.u_30613;
        // D s_3157_2: cast zx s_3157_1 -> bv
        let s_3157_2: Bits = Bits::new(s_3157_1 as u128, 32u16);
        // C s_3157_3: const #1s : i64
        let s_3157_3: i64 = 1;
        // C s_3157_4: cast zx s_3157_3 -> i
        let s_3157_4: i128 = (i128::try_from(s_3157_3).unwrap());
        // C s_3157_5: const #0s : i
        let s_3157_5: i128 = 0;
        // C s_3157_6: add s_3157_5 s_3157_4
        let s_3157_6: i128 = (s_3157_5 + s_3157_4);
        // D s_3157_7: bit-extract s_3157_2 s_3157_0 s_3157_6
        let s_3157_7: Bits = (Bits::new(
            ((s_3157_2) >> (s_3157_0)).value(),
            u16::try_from(s_3157_6).unwrap(),
        ));
        // D s_3157_8: cast reint s_3157_7 -> u8
        let s_3157_8: bool = ((s_3157_7.value()) != 0);
        // D s_3157_9: cast zx s_3157_8 -> bv
        let s_3157_9: Bits = Bits::new(s_3157_8 as u128, 1u16);
        // C s_3157_10: const #0u : u8
        let s_3157_10: bool = false;
        // C s_3157_11: cast zx s_3157_10 -> bv
        let s_3157_11: Bits = Bits::new(s_3157_10 as u128, 1u16);
        // D s_3157_12: cmp-eq s_3157_9 s_3157_11
        let s_3157_12: bool = ((s_3157_9) == (s_3157_11));
        // N s_3157_13: branch s_3157_12 b3160 b3158
        if s_3157_12 {
            return block_3160(state, tracer, fn_state);
        } else {
            return block_3158(state, tracer, fn_state);
        };
    }
    fn block_3158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3158_0: const #0u : u8
        let s_3158_0: bool = false;
        // D s_3158_1: write-var gs#397936 <= s_3158_0
        fn_state.gs_397936 = s_3158_0;
        // N s_3158_2: jump b3159
        return block_3159(state, tracer, fn_state);
    }
    fn block_3159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3159_0: read-var gs#397936:u8
        let s_3159_0: bool = fn_state.gs_397936;
        // D s_3159_1: write-var gs#397937 <= s_3159_0
        fn_state.gs_397937 = s_3159_0;
        // N s_3159_2: jump b309
        return block_309(state, tracer, fn_state);
    }
    fn block_3160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3160_0: const #8s : i
        let s_3160_0: i128 = 8;
        // D s_3160_1: read-var u#30613:u32
        let s_3160_1: u32 = fn_state.u_30613;
        // D s_3160_2: cast zx s_3160_1 -> bv
        let s_3160_2: Bits = Bits::new(s_3160_1 as u128, 32u16);
        // C s_3160_3: const #1s : i64
        let s_3160_3: i64 = 1;
        // C s_3160_4: cast zx s_3160_3 -> i
        let s_3160_4: i128 = (i128::try_from(s_3160_3).unwrap());
        // C s_3160_5: const #3s : i
        let s_3160_5: i128 = 3;
        // C s_3160_6: add s_3160_5 s_3160_4
        let s_3160_6: i128 = (s_3160_5 + s_3160_4);
        // D s_3160_7: bit-extract s_3160_2 s_3160_0 s_3160_6
        let s_3160_7: Bits = (Bits::new(
            ((s_3160_2) >> (s_3160_0)).value(),
            u16::try_from(s_3160_6).unwrap(),
        ));
        // D s_3160_8: cast reint s_3160_7 -> u8
        let s_3160_8: u8 = (s_3160_7.value() as u8);
        // D s_3160_9: cast zx s_3160_8 -> bv
        let s_3160_9: Bits = Bits::new(s_3160_8 as u128, 4u16);
        // C s_3160_10: const #7u : u8
        let s_3160_10: u8 = 7;
        // C s_3160_11: cast zx s_3160_10 -> bv
        let s_3160_11: Bits = Bits::new(s_3160_10 as u128, 4u16);
        // D s_3160_12: cmp-eq s_3160_9 s_3160_11
        let s_3160_12: bool = ((s_3160_9) == (s_3160_11));
        // N s_3160_13: branch s_3160_12 b3163 b3161
        if s_3160_12 {
            return block_3163(state, tracer, fn_state);
        } else {
            return block_3161(state, tracer, fn_state);
        };
    }
    fn block_3161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3161_0: const #0u : u8
        let s_3161_0: bool = false;
        // D s_3161_1: write-var gs#397935 <= s_3161_0
        fn_state.gs_397935 = s_3161_0;
        // N s_3161_2: jump b3162
        return block_3162(state, tracer, fn_state);
    }
    fn block_3162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3162_0: read-var gs#397935:u8
        let s_3162_0: bool = fn_state.gs_397935;
        // D s_3162_1: write-var gs#397936 <= s_3162_0
        fn_state.gs_397936 = s_3162_0;
        // N s_3162_2: jump b3159
        return block_3159(state, tracer, fn_state);
    }
    fn block_3163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3163_0: const #4s : i
        let s_3163_0: i128 = 4;
        // D s_3163_1: read-var u#30613:u32
        let s_3163_1: u32 = fn_state.u_30613;
        // D s_3163_2: cast zx s_3163_1 -> bv
        let s_3163_2: Bits = Bits::new(s_3163_1 as u128, 32u16);
        // C s_3163_3: const #1s : i64
        let s_3163_3: i64 = 1;
        // C s_3163_4: cast zx s_3163_3 -> i
        let s_3163_4: i128 = (i128::try_from(s_3163_3).unwrap());
        // C s_3163_5: const #0s : i
        let s_3163_5: i128 = 0;
        // C s_3163_6: add s_3163_5 s_3163_4
        let s_3163_6: i128 = (s_3163_5 + s_3163_4);
        // D s_3163_7: bit-extract s_3163_2 s_3163_0 s_3163_6
        let s_3163_7: Bits = (Bits::new(
            ((s_3163_2) >> (s_3163_0)).value(),
            u16::try_from(s_3163_6).unwrap(),
        ));
        // D s_3163_8: cast reint s_3163_7 -> u8
        let s_3163_8: bool = ((s_3163_7.value()) != 0);
        // D s_3163_9: cast zx s_3163_8 -> bv
        let s_3163_9: Bits = Bits::new(s_3163_8 as u128, 1u16);
        // C s_3163_10: const #0u : u8
        let s_3163_10: bool = false;
        // C s_3163_11: cast zx s_3163_10 -> bv
        let s_3163_11: Bits = Bits::new(s_3163_10 as u128, 1u16);
        // D s_3163_12: cmp-eq s_3163_9 s_3163_11
        let s_3163_12: bool = ((s_3163_9) == (s_3163_11));
        // D s_3163_13: write-var gs#397935 <= s_3163_12
        fn_state.gs_397935 = s_3163_12;
        // N s_3163_14: jump b3162
        return block_3162(state, tracer, fn_state);
    }
    fn block_3164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3164_0: const #3354s : i
        let s_3164_0: i128 = 3354;
        // C s_3164_1: const #14696u : u32
        let s_3164_1: u32 = 14696;
        // D s_3164_2: read-reg s_3164_1:i
        let s_3164_2: i128 = {
            let value = state.read_register::<i128>(s_3164_1 as isize);
            tracer.read_register(s_3164_1 as isize, value);
            value
        };
        // D s_3164_3: cmp-lt s_3164_2 s_3164_0
        let s_3164_3: bool = ((s_3164_2) < (s_3164_0));
        // D s_3164_4: write-var gs#397907 <= s_3164_3
        fn_state.gs_397907 = s_3164_3;
        // N s_3164_5: jump b305
        return block_305(state, tracer, fn_state);
    }
    fn block_3165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3165_0: const #21s : i
        let s_3165_0: i128 = 21;
        // D s_3165_1: read-var u#30604:u32
        let s_3165_1: u32 = fn_state.u_30604;
        // D s_3165_2: cast zx s_3165_1 -> bv
        let s_3165_2: Bits = Bits::new(s_3165_1 as u128, 32u16);
        // C s_3165_3: const #1s : i64
        let s_3165_3: i64 = 1;
        // C s_3165_4: cast zx s_3165_3 -> i
        let s_3165_4: i128 = (i128::try_from(s_3165_3).unwrap());
        // C s_3165_5: const #0s : i
        let s_3165_5: i128 = 0;
        // C s_3165_6: add s_3165_5 s_3165_4
        let s_3165_6: i128 = (s_3165_5 + s_3165_4);
        // D s_3165_7: bit-extract s_3165_2 s_3165_0 s_3165_6
        let s_3165_7: Bits = (Bits::new(
            ((s_3165_2) >> (s_3165_0)).value(),
            u16::try_from(s_3165_6).unwrap(),
        ));
        // D s_3165_8: cast reint s_3165_7 -> u8
        let s_3165_8: bool = ((s_3165_7.value()) != 0);
        // D s_3165_9: cast zx s_3165_8 -> bv
        let s_3165_9: Bits = Bits::new(s_3165_8 as u128, 1u16);
        // C s_3165_10: const #1u : u8
        let s_3165_10: bool = true;
        // C s_3165_11: cast zx s_3165_10 -> bv
        let s_3165_11: Bits = Bits::new(s_3165_10 as u128, 1u16);
        // D s_3165_12: cmp-eq s_3165_9 s_3165_11
        let s_3165_12: bool = ((s_3165_9) == (s_3165_11));
        // N s_3165_13: branch s_3165_12 b3168 b3166
        if s_3165_12 {
            return block_3168(state, tracer, fn_state);
        } else {
            return block_3166(state, tracer, fn_state);
        };
    }
    fn block_3166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3166_0: const #0u : u8
        let s_3166_0: bool = false;
        // D s_3166_1: write-var gs#397904 <= s_3166_0
        fn_state.gs_397904 = s_3166_0;
        // N s_3166_2: jump b3167
        return block_3167(state, tracer, fn_state);
    }
    fn block_3167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3167_0: read-var gs#397904:u8
        let s_3167_0: bool = fn_state.gs_397904;
        // D s_3167_1: write-var gs#397905 <= s_3167_0
        fn_state.gs_397905 = s_3167_0;
        // N s_3167_2: jump b303
        return block_303(state, tracer, fn_state);
    }
    fn block_3168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3168_0: const #8s : i
        let s_3168_0: i128 = 8;
        // D s_3168_1: read-var u#30604:u32
        let s_3168_1: u32 = fn_state.u_30604;
        // D s_3168_2: cast zx s_3168_1 -> bv
        let s_3168_2: Bits = Bits::new(s_3168_1 as u128, 32u16);
        // C s_3168_3: const #1s : i64
        let s_3168_3: i64 = 1;
        // C s_3168_4: cast zx s_3168_3 -> i
        let s_3168_4: i128 = (i128::try_from(s_3168_3).unwrap());
        // C s_3168_5: const #3s : i
        let s_3168_5: i128 = 3;
        // C s_3168_6: add s_3168_5 s_3168_4
        let s_3168_6: i128 = (s_3168_5 + s_3168_4);
        // D s_3168_7: bit-extract s_3168_2 s_3168_0 s_3168_6
        let s_3168_7: Bits = (Bits::new(
            ((s_3168_2) >> (s_3168_0)).value(),
            u16::try_from(s_3168_6).unwrap(),
        ));
        // D s_3168_8: cast reint s_3168_7 -> u8
        let s_3168_8: u8 = (s_3168_7.value() as u8);
        // D s_3168_9: cast zx s_3168_8 -> bv
        let s_3168_9: Bits = Bits::new(s_3168_8 as u128, 4u16);
        // C s_3168_10: const #13u : u8
        let s_3168_10: u8 = 13;
        // C s_3168_11: cast zx s_3168_10 -> bv
        let s_3168_11: Bits = Bits::new(s_3168_10 as u128, 4u16);
        // D s_3168_12: cmp-eq s_3168_9 s_3168_11
        let s_3168_12: bool = ((s_3168_9) == (s_3168_11));
        // N s_3168_13: branch s_3168_12 b3171 b3169
        if s_3168_12 {
            return block_3171(state, tracer, fn_state);
        } else {
            return block_3169(state, tracer, fn_state);
        };
    }
    fn block_3169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3169_0: const #0u : u8
        let s_3169_0: bool = false;
        // D s_3169_1: write-var gs#397903 <= s_3169_0
        fn_state.gs_397903 = s_3169_0;
        // N s_3169_2: jump b3170
        return block_3170(state, tracer, fn_state);
    }
    fn block_3170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3170_0: read-var gs#397903:u8
        let s_3170_0: bool = fn_state.gs_397903;
        // D s_3170_1: write-var gs#397904 <= s_3170_0
        fn_state.gs_397904 = s_3170_0;
        // N s_3170_2: jump b3167
        return block_3167(state, tracer, fn_state);
    }
    fn block_3171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3171_0: const #4s : i
        let s_3171_0: i128 = 4;
        // D s_3171_1: read-var u#30604:u32
        let s_3171_1: u32 = fn_state.u_30604;
        // D s_3171_2: cast zx s_3171_1 -> bv
        let s_3171_2: Bits = Bits::new(s_3171_1 as u128, 32u16);
        // C s_3171_3: const #1s : i64
        let s_3171_3: i64 = 1;
        // C s_3171_4: cast zx s_3171_3 -> i
        let s_3171_4: i128 = (i128::try_from(s_3171_3).unwrap());
        // C s_3171_5: const #0s : i
        let s_3171_5: i128 = 0;
        // C s_3171_6: add s_3171_5 s_3171_4
        let s_3171_6: i128 = (s_3171_5 + s_3171_4);
        // D s_3171_7: bit-extract s_3171_2 s_3171_0 s_3171_6
        let s_3171_7: Bits = (Bits::new(
            ((s_3171_2) >> (s_3171_0)).value(),
            u16::try_from(s_3171_6).unwrap(),
        ));
        // D s_3171_8: cast reint s_3171_7 -> u8
        let s_3171_8: bool = ((s_3171_7.value()) != 0);
        // D s_3171_9: cast zx s_3171_8 -> bv
        let s_3171_9: Bits = Bits::new(s_3171_8 as u128, 1u16);
        // C s_3171_10: const #0u : u8
        let s_3171_10: bool = false;
        // C s_3171_11: cast zx s_3171_10 -> bv
        let s_3171_11: Bits = Bits::new(s_3171_10 as u128, 1u16);
        // D s_3171_12: cmp-eq s_3171_9 s_3171_11
        let s_3171_12: bool = ((s_3171_9) == (s_3171_11));
        // D s_3171_13: write-var gs#397903 <= s_3171_12
        fn_state.gs_397903 = s_3171_12;
        // N s_3171_14: jump b3170
        return block_3170(state, tracer, fn_state);
    }
    fn block_3172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3172_0: const #3351s : i
        let s_3172_0: i128 = 3351;
        // C s_3172_1: const #14696u : u32
        let s_3172_1: u32 = 14696;
        // D s_3172_2: read-reg s_3172_1:i
        let s_3172_2: i128 = {
            let value = state.read_register::<i128>(s_3172_1 as isize);
            tracer.read_register(s_3172_1 as isize, value);
            value
        };
        // D s_3172_3: cmp-lt s_3172_2 s_3172_0
        let s_3172_3: bool = ((s_3172_2) < (s_3172_0));
        // D s_3172_4: write-var gs#397875 <= s_3172_3
        fn_state.gs_397875 = s_3172_3;
        // N s_3172_5: jump b299
        return block_299(state, tracer, fn_state);
    }
    fn block_3173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3173_0: const #23s : i
        let s_3173_0: i128 = 23;
        // D s_3173_1: read-var u#30594:u32
        let s_3173_1: u32 = fn_state.u_30594;
        // D s_3173_2: cast zx s_3173_1 -> bv
        let s_3173_2: Bits = Bits::new(s_3173_1 as u128, 32u16);
        // C s_3173_3: const #1s : i64
        let s_3173_3: i64 = 1;
        // C s_3173_4: cast zx s_3173_3 -> i
        let s_3173_4: i128 = (i128::try_from(s_3173_3).unwrap());
        // C s_3173_5: const #0s : i
        let s_3173_5: i128 = 0;
        // C s_3173_6: add s_3173_5 s_3173_4
        let s_3173_6: i128 = (s_3173_5 + s_3173_4);
        // D s_3173_7: bit-extract s_3173_2 s_3173_0 s_3173_6
        let s_3173_7: Bits = (Bits::new(
            ((s_3173_2) >> (s_3173_0)).value(),
            u16::try_from(s_3173_6).unwrap(),
        ));
        // D s_3173_8: cast reint s_3173_7 -> u8
        let s_3173_8: bool = ((s_3173_7.value()) != 0);
        // D s_3173_9: cast zx s_3173_8 -> bv
        let s_3173_9: Bits = Bits::new(s_3173_8 as u128, 1u16);
        // C s_3173_10: const #1u : u8
        let s_3173_10: bool = true;
        // C s_3173_11: cast zx s_3173_10 -> bv
        let s_3173_11: Bits = Bits::new(s_3173_10 as u128, 1u16);
        // D s_3173_12: cmp-eq s_3173_9 s_3173_11
        let s_3173_12: bool = ((s_3173_9) == (s_3173_11));
        // N s_3173_13: branch s_3173_12 b3176 b3174
        if s_3173_12 {
            return block_3176(state, tracer, fn_state);
        } else {
            return block_3174(state, tracer, fn_state);
        };
    }
    fn block_3174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3174_0: const #0u : u8
        let s_3174_0: bool = false;
        // D s_3174_1: write-var gs#397872 <= s_3174_0
        fn_state.gs_397872 = s_3174_0;
        // N s_3174_2: jump b3175
        return block_3175(state, tracer, fn_state);
    }
    fn block_3175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3175_0: read-var gs#397872:u8
        let s_3175_0: bool = fn_state.gs_397872;
        // D s_3175_1: write-var gs#397873 <= s_3175_0
        fn_state.gs_397873 = s_3175_0;
        // N s_3175_2: jump b297
        return block_297(state, tracer, fn_state);
    }
    fn block_3176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3176_0: const #8s : i
        let s_3176_0: i128 = 8;
        // D s_3176_1: read-var u#30594:u32
        let s_3176_1: u32 = fn_state.u_30594;
        // D s_3176_2: cast zx s_3176_1 -> bv
        let s_3176_2: Bits = Bits::new(s_3176_1 as u128, 32u16);
        // C s_3176_3: const #1s : i64
        let s_3176_3: i64 = 1;
        // C s_3176_4: cast zx s_3176_3 -> i
        let s_3176_4: i128 = (i128::try_from(s_3176_3).unwrap());
        // C s_3176_5: const #3s : i
        let s_3176_5: i128 = 3;
        // C s_3176_6: add s_3176_5 s_3176_4
        let s_3176_6: i128 = (s_3176_5 + s_3176_4);
        // D s_3176_7: bit-extract s_3176_2 s_3176_0 s_3176_6
        let s_3176_7: Bits = (Bits::new(
            ((s_3176_2) >> (s_3176_0)).value(),
            u16::try_from(s_3176_6).unwrap(),
        ));
        // D s_3176_8: cast reint s_3176_7 -> u8
        let s_3176_8: u8 = (s_3176_7.value() as u8);
        // D s_3176_9: cast zx s_3176_8 -> bv
        let s_3176_9: Bits = Bits::new(s_3176_8 as u128, 4u16);
        // C s_3176_10: const #5u : u8
        let s_3176_10: u8 = 5;
        // C s_3176_11: cast zx s_3176_10 -> bv
        let s_3176_11: Bits = Bits::new(s_3176_10 as u128, 4u16);
        // D s_3176_12: cmp-eq s_3176_9 s_3176_11
        let s_3176_12: bool = ((s_3176_9) == (s_3176_11));
        // N s_3176_13: branch s_3176_12 b3179 b3177
        if s_3176_12 {
            return block_3179(state, tracer, fn_state);
        } else {
            return block_3177(state, tracer, fn_state);
        };
    }
    fn block_3177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3177_0: const #0u : u8
        let s_3177_0: bool = false;
        // D s_3177_1: write-var gs#397871 <= s_3177_0
        fn_state.gs_397871 = s_3177_0;
        // N s_3177_2: jump b3178
        return block_3178(state, tracer, fn_state);
    }
    fn block_3178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3178_0: read-var gs#397871:u8
        let s_3178_0: bool = fn_state.gs_397871;
        // D s_3178_1: write-var gs#397872 <= s_3178_0
        fn_state.gs_397872 = s_3178_0;
        // N s_3178_2: jump b3175
        return block_3175(state, tracer, fn_state);
    }
    fn block_3179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3179_0: const #6s : i
        let s_3179_0: i128 = 6;
        // D s_3179_1: read-var u#30594:u32
        let s_3179_1: u32 = fn_state.u_30594;
        // D s_3179_2: cast zx s_3179_1 -> bv
        let s_3179_2: Bits = Bits::new(s_3179_1 as u128, 32u16);
        // C s_3179_3: const #1s : i64
        let s_3179_3: i64 = 1;
        // C s_3179_4: cast zx s_3179_3 -> i
        let s_3179_4: i128 = (i128::try_from(s_3179_3).unwrap());
        // C s_3179_5: const #0s : i
        let s_3179_5: i128 = 0;
        // C s_3179_6: add s_3179_5 s_3179_4
        let s_3179_6: i128 = (s_3179_5 + s_3179_4);
        // D s_3179_7: bit-extract s_3179_2 s_3179_0 s_3179_6
        let s_3179_7: Bits = (Bits::new(
            ((s_3179_2) >> (s_3179_0)).value(),
            u16::try_from(s_3179_6).unwrap(),
        ));
        // D s_3179_8: cast reint s_3179_7 -> u8
        let s_3179_8: bool = ((s_3179_7.value()) != 0);
        // D s_3179_9: cast zx s_3179_8 -> bv
        let s_3179_9: Bits = Bits::new(s_3179_8 as u128, 1u16);
        // C s_3179_10: const #0u : u8
        let s_3179_10: bool = false;
        // C s_3179_11: cast zx s_3179_10 -> bv
        let s_3179_11: Bits = Bits::new(s_3179_10 as u128, 1u16);
        // D s_3179_12: cmp-eq s_3179_9 s_3179_11
        let s_3179_12: bool = ((s_3179_9) == (s_3179_11));
        // N s_3179_13: branch s_3179_12 b3182 b3180
        if s_3179_12 {
            return block_3182(state, tracer, fn_state);
        } else {
            return block_3180(state, tracer, fn_state);
        };
    }
    fn block_3180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3180_0: const #0u : u8
        let s_3180_0: bool = false;
        // D s_3180_1: write-var gs#397870 <= s_3180_0
        fn_state.gs_397870 = s_3180_0;
        // N s_3180_2: jump b3181
        return block_3181(state, tracer, fn_state);
    }
    fn block_3181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3181_0: read-var gs#397870:u8
        let s_3181_0: bool = fn_state.gs_397870;
        // D s_3181_1: write-var gs#397871 <= s_3181_0
        fn_state.gs_397871 = s_3181_0;
        // N s_3181_2: jump b3178
        return block_3178(state, tracer, fn_state);
    }
    fn block_3182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3182_0: const #4s : i
        let s_3182_0: i128 = 4;
        // D s_3182_1: read-var u#30594:u32
        let s_3182_1: u32 = fn_state.u_30594;
        // D s_3182_2: cast zx s_3182_1 -> bv
        let s_3182_2: Bits = Bits::new(s_3182_1 as u128, 32u16);
        // C s_3182_3: const #1s : i64
        let s_3182_3: i64 = 1;
        // C s_3182_4: cast zx s_3182_3 -> i
        let s_3182_4: i128 = (i128::try_from(s_3182_3).unwrap());
        // C s_3182_5: const #0s : i
        let s_3182_5: i128 = 0;
        // C s_3182_6: add s_3182_5 s_3182_4
        let s_3182_6: i128 = (s_3182_5 + s_3182_4);
        // D s_3182_7: bit-extract s_3182_2 s_3182_0 s_3182_6
        let s_3182_7: Bits = (Bits::new(
            ((s_3182_2) >> (s_3182_0)).value(),
            u16::try_from(s_3182_6).unwrap(),
        ));
        // D s_3182_8: cast reint s_3182_7 -> u8
        let s_3182_8: bool = ((s_3182_7.value()) != 0);
        // D s_3182_9: cast zx s_3182_8 -> bv
        let s_3182_9: Bits = Bits::new(s_3182_8 as u128, 1u16);
        // C s_3182_10: const #0u : u8
        let s_3182_10: bool = false;
        // C s_3182_11: cast zx s_3182_10 -> bv
        let s_3182_11: Bits = Bits::new(s_3182_10 as u128, 1u16);
        // D s_3182_12: cmp-eq s_3182_9 s_3182_11
        let s_3182_12: bool = ((s_3182_9) == (s_3182_11));
        // D s_3182_13: write-var gs#397870 <= s_3182_12
        fn_state.gs_397870 = s_3182_12;
        // N s_3182_14: jump b3181
        return block_3181(state, tracer, fn_state);
    }
    fn block_3183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3183_0: const #3350s : i
        let s_3183_0: i128 = 3350;
        // C s_3183_1: const #14696u : u32
        let s_3183_1: u32 = 14696;
        // D s_3183_2: read-reg s_3183_1:i
        let s_3183_2: i128 = {
            let value = state.read_register::<i128>(s_3183_1 as isize);
            tracer.read_register(s_3183_1 as isize, value);
            value
        };
        // D s_3183_3: cmp-lt s_3183_2 s_3183_0
        let s_3183_3: bool = ((s_3183_2) < (s_3183_0));
        // D s_3183_4: write-var gs#397838 <= s_3183_3
        fn_state.gs_397838 = s_3183_3;
        // N s_3183_5: jump b293
        return block_293(state, tracer, fn_state);
    }
    fn block_3184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3184_0: const #23s : i
        let s_3184_0: i128 = 23;
        // D s_3184_1: read-var u#30591:u32
        let s_3184_1: u32 = fn_state.u_30591;
        // D s_3184_2: cast zx s_3184_1 -> bv
        let s_3184_2: Bits = Bits::new(s_3184_1 as u128, 32u16);
        // C s_3184_3: const #1s : i64
        let s_3184_3: i64 = 1;
        // C s_3184_4: cast zx s_3184_3 -> i
        let s_3184_4: i128 = (i128::try_from(s_3184_3).unwrap());
        // C s_3184_5: const #0s : i
        let s_3184_5: i128 = 0;
        // C s_3184_6: add s_3184_5 s_3184_4
        let s_3184_6: i128 = (s_3184_5 + s_3184_4);
        // D s_3184_7: bit-extract s_3184_2 s_3184_0 s_3184_6
        let s_3184_7: Bits = (Bits::new(
            ((s_3184_2) >> (s_3184_0)).value(),
            u16::try_from(s_3184_6).unwrap(),
        ));
        // D s_3184_8: cast reint s_3184_7 -> u8
        let s_3184_8: bool = ((s_3184_7.value()) != 0);
        // D s_3184_9: cast zx s_3184_8 -> bv
        let s_3184_9: Bits = Bits::new(s_3184_8 as u128, 1u16);
        // C s_3184_10: const #0u : u8
        let s_3184_10: bool = false;
        // C s_3184_11: cast zx s_3184_10 -> bv
        let s_3184_11: Bits = Bits::new(s_3184_10 as u128, 1u16);
        // D s_3184_12: cmp-eq s_3184_9 s_3184_11
        let s_3184_12: bool = ((s_3184_9) == (s_3184_11));
        // N s_3184_13: branch s_3184_12 b3187 b3185
        if s_3184_12 {
            return block_3187(state, tracer, fn_state);
        } else {
            return block_3185(state, tracer, fn_state);
        };
    }
    fn block_3185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3185_0: const #0u : u8
        let s_3185_0: bool = false;
        // D s_3185_1: write-var gs#397835 <= s_3185_0
        fn_state.gs_397835 = s_3185_0;
        // N s_3185_2: jump b3186
        return block_3186(state, tracer, fn_state);
    }
    fn block_3186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3186_0: read-var gs#397835:u8
        let s_3186_0: bool = fn_state.gs_397835;
        // D s_3186_1: write-var gs#397836 <= s_3186_0
        fn_state.gs_397836 = s_3186_0;
        // N s_3186_2: jump b291
        return block_291(state, tracer, fn_state);
    }
    fn block_3187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3187_0: const #8s : i
        let s_3187_0: i128 = 8;
        // D s_3187_1: read-var u#30591:u32
        let s_3187_1: u32 = fn_state.u_30591;
        // D s_3187_2: cast zx s_3187_1 -> bv
        let s_3187_2: Bits = Bits::new(s_3187_1 as u128, 32u16);
        // C s_3187_3: const #1s : i64
        let s_3187_3: i64 = 1;
        // C s_3187_4: cast zx s_3187_3 -> i
        let s_3187_4: i128 = (i128::try_from(s_3187_3).unwrap());
        // C s_3187_5: const #3s : i
        let s_3187_5: i128 = 3;
        // C s_3187_6: add s_3187_5 s_3187_4
        let s_3187_6: i128 = (s_3187_5 + s_3187_4);
        // D s_3187_7: bit-extract s_3187_2 s_3187_0 s_3187_6
        let s_3187_7: Bits = (Bits::new(
            ((s_3187_2) >> (s_3187_0)).value(),
            u16::try_from(s_3187_6).unwrap(),
        ));
        // D s_3187_8: cast reint s_3187_7 -> u8
        let s_3187_8: u8 = (s_3187_7.value() as u8);
        // D s_3187_9: cast zx s_3187_8 -> bv
        let s_3187_9: Bits = Bits::new(s_3187_8 as u128, 4u16);
        // C s_3187_10: const #7u : u8
        let s_3187_10: u8 = 7;
        // C s_3187_11: cast zx s_3187_10 -> bv
        let s_3187_11: Bits = Bits::new(s_3187_10 as u128, 4u16);
        // D s_3187_12: cmp-eq s_3187_9 s_3187_11
        let s_3187_12: bool = ((s_3187_9) == (s_3187_11));
        // N s_3187_13: branch s_3187_12 b3190 b3188
        if s_3187_12 {
            return block_3190(state, tracer, fn_state);
        } else {
            return block_3188(state, tracer, fn_state);
        };
    }
    fn block_3188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3188_0: const #0u : u8
        let s_3188_0: bool = false;
        // D s_3188_1: write-var gs#397834 <= s_3188_0
        fn_state.gs_397834 = s_3188_0;
        // N s_3188_2: jump b3189
        return block_3189(state, tracer, fn_state);
    }
    fn block_3189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3189_0: read-var gs#397834:u8
        let s_3189_0: bool = fn_state.gs_397834;
        // D s_3189_1: write-var gs#397835 <= s_3189_0
        fn_state.gs_397835 = s_3189_0;
        // N s_3189_2: jump b3186
        return block_3186(state, tracer, fn_state);
    }
    fn block_3190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3190_0: const #4s : i
        let s_3190_0: i128 = 4;
        // D s_3190_1: read-var u#30591:u32
        let s_3190_1: u32 = fn_state.u_30591;
        // D s_3190_2: cast zx s_3190_1 -> bv
        let s_3190_2: Bits = Bits::new(s_3190_1 as u128, 32u16);
        // C s_3190_3: const #1s : i64
        let s_3190_3: i64 = 1;
        // C s_3190_4: cast zx s_3190_3 -> i
        let s_3190_4: i128 = (i128::try_from(s_3190_3).unwrap());
        // C s_3190_5: const #0s : i
        let s_3190_5: i128 = 0;
        // C s_3190_6: add s_3190_5 s_3190_4
        let s_3190_6: i128 = (s_3190_5 + s_3190_4);
        // D s_3190_7: bit-extract s_3190_2 s_3190_0 s_3190_6
        let s_3190_7: Bits = (Bits::new(
            ((s_3190_2) >> (s_3190_0)).value(),
            u16::try_from(s_3190_6).unwrap(),
        ));
        // D s_3190_8: cast reint s_3190_7 -> u8
        let s_3190_8: bool = ((s_3190_7.value()) != 0);
        // D s_3190_9: cast zx s_3190_8 -> bv
        let s_3190_9: Bits = Bits::new(s_3190_8 as u128, 1u16);
        // C s_3190_10: const #1u : u8
        let s_3190_10: bool = true;
        // C s_3190_11: cast zx s_3190_10 -> bv
        let s_3190_11: Bits = Bits::new(s_3190_10 as u128, 1u16);
        // D s_3190_12: cmp-eq s_3190_9 s_3190_11
        let s_3190_12: bool = ((s_3190_9) == (s_3190_11));
        // D s_3190_13: write-var gs#397834 <= s_3190_12
        fn_state.gs_397834 = s_3190_12;
        // N s_3190_14: jump b3189
        return block_3189(state, tracer, fn_state);
    }
    fn block_3191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3191_0: const #3125s : i
        let s_3191_0: i128 = 3125;
        // C s_3191_1: const #14696u : u32
        let s_3191_1: u32 = 14696;
        // D s_3191_2: read-reg s_3191_1:i
        let s_3191_2: i128 = {
            let value = state.read_register::<i128>(s_3191_1 as isize);
            tracer.read_register(s_3191_1 as isize, value);
            value
        };
        // D s_3191_3: cmp-lt s_3191_2 s_3191_0
        let s_3191_3: bool = ((s_3191_2) < (s_3191_0));
        // D s_3191_4: write-var gs#397788 <= s_3191_3
        fn_state.gs_397788 = s_3191_3;
        // N s_3191_5: jump b255
        return block_255(state, tracer, fn_state);
    }
    fn block_3192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3192_0: const #0s : i
        let s_3192_0: i128 = 0;
        // D s_3192_1: read-var u#30589:u32
        let s_3192_1: u32 = fn_state.u_30589;
        // D s_3192_2: cast zx s_3192_1 -> bv
        let s_3192_2: Bits = Bits::new(s_3192_1 as u128, 32u16);
        // C s_3192_3: const #1s : i64
        let s_3192_3: i64 = 1;
        // C s_3192_4: cast zx s_3192_3 -> i
        let s_3192_4: i128 = (i128::try_from(s_3192_3).unwrap());
        // C s_3192_5: const #8s : i
        let s_3192_5: i128 = 8;
        // C s_3192_6: add s_3192_5 s_3192_4
        let s_3192_6: i128 = (s_3192_5 + s_3192_4);
        // D s_3192_7: bit-extract s_3192_2 s_3192_0 s_3192_6
        let s_3192_7: Bits = (Bits::new(
            ((s_3192_2) >> (s_3192_0)).value(),
            u16::try_from(s_3192_6).unwrap(),
        ));
        // D s_3192_8: cast reint s_3192_7 -> u9
        let s_3192_8: u16 = (s_3192_7.value() as u16);
        // D s_3192_9: cast zx s_3192_8 -> bv
        let s_3192_9: Bits = Bits::new(s_3192_8 as u128, 9u16);
        // C s_3192_10: const #0u : u9
        let s_3192_10: u16 = 0;
        // C s_3192_11: cast zx s_3192_10 -> bv
        let s_3192_11: Bits = Bits::new(s_3192_10 as u128, 9u16);
        // D s_3192_12: cmp-eq s_3192_9 s_3192_11
        let s_3192_12: bool = ((s_3192_9) == (s_3192_11));
        // D s_3192_13: write-var gs#397786 <= s_3192_12
        fn_state.gs_397786 = s_3192_12;
        // N s_3192_14: jump b253
        return block_253(state, tracer, fn_state);
    }
    fn block_3193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3193_0: const #3111s : i
        let s_3193_0: i128 = 3111;
        // C s_3193_1: const #14696u : u32
        let s_3193_1: u32 = 14696;
        // D s_3193_2: read-reg s_3193_1:i
        let s_3193_2: i128 = {
            let value = state.read_register::<i128>(s_3193_1 as isize);
            tracer.read_register(s_3193_1 as isize, value);
            value
        };
        // D s_3193_3: cmp-lt s_3193_2 s_3193_0
        let s_3193_3: bool = ((s_3193_2) < (s_3193_0));
        // D s_3193_4: write-var gs#397731 <= s_3193_3
        fn_state.gs_397731 = s_3193_3;
        // N s_3193_5: jump b202
        return block_202(state, tracer, fn_state);
    }
    fn block_3194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3194_0: const #3060s : i
        let s_3194_0: i128 = 3060;
        // C s_3194_1: const #14696u : u32
        let s_3194_1: u32 = 14696;
        // D s_3194_2: read-reg s_3194_1:i
        let s_3194_2: i128 = {
            let value = state.read_register::<i128>(s_3194_1 as isize);
            tracer.read_register(s_3194_1 as isize, value);
            value
        };
        // D s_3194_3: cmp-lt s_3194_2 s_3194_0
        let s_3194_3: bool = ((s_3194_2) < (s_3194_0));
        // D s_3194_4: write-var gs#397716 <= s_3194_3
        fn_state.gs_397716 = s_3194_3;
        // N s_3194_5: jump b198
        return block_198(state, tracer, fn_state);
    }
    fn block_3195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3195_0: const #20s : i
        let s_3195_0: i128 = 20;
        // D s_3195_1: read-var u#30580:u32
        let s_3195_1: u32 = fn_state.u_30580;
        // D s_3195_2: cast zx s_3195_1 -> bv
        let s_3195_2: Bits = Bits::new(s_3195_1 as u128, 32u16);
        // C s_3195_3: const #1s : i64
        let s_3195_3: i64 = 1;
        // C s_3195_4: cast zx s_3195_3 -> i
        let s_3195_4: i128 = (i128::try_from(s_3195_3).unwrap());
        // C s_3195_5: const #2s : i
        let s_3195_5: i128 = 2;
        // C s_3195_6: add s_3195_5 s_3195_4
        let s_3195_6: i128 = (s_3195_5 + s_3195_4);
        // D s_3195_7: bit-extract s_3195_2 s_3195_0 s_3195_6
        let s_3195_7: Bits = (Bits::new(
            ((s_3195_2) >> (s_3195_0)).value(),
            u16::try_from(s_3195_6).unwrap(),
        ));
        // D s_3195_8: cast reint s_3195_7 -> u8
        let s_3195_8: u8 = (s_3195_7.value() as u8);
        // D s_3195_9: cast zx s_3195_8 -> bv
        let s_3195_9: Bits = Bits::new(s_3195_8 as u128, 3u16);
        // C s_3195_10: const #5u : u8
        let s_3195_10: u8 = 5;
        // C s_3195_11: cast zx s_3195_10 -> bv
        let s_3195_11: Bits = Bits::new(s_3195_10 as u128, 3u16);
        // D s_3195_12: cmp-eq s_3195_9 s_3195_11
        let s_3195_12: bool = ((s_3195_9) == (s_3195_11));
        // N s_3195_13: branch s_3195_12 b3198 b3196
        if s_3195_12 {
            return block_3198(state, tracer, fn_state);
        } else {
            return block_3196(state, tracer, fn_state);
        };
    }
    fn block_3196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3196_0: const #0u : u8
        let s_3196_0: bool = false;
        // D s_3196_1: write-var gs#397713 <= s_3196_0
        fn_state.gs_397713 = s_3196_0;
        // N s_3196_2: jump b3197
        return block_3197(state, tracer, fn_state);
    }
    fn block_3197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3197_0: read-var gs#397713:u8
        let s_3197_0: bool = fn_state.gs_397713;
        // D s_3197_1: write-var gs#397714 <= s_3197_0
        fn_state.gs_397714 = s_3197_0;
        // N s_3197_2: jump b196
        return block_196(state, tracer, fn_state);
    }
    fn block_3198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3198_0: const #12s : i
        let s_3198_0: i128 = 12;
        // D s_3198_1: read-var u#30580:u32
        let s_3198_1: u32 = fn_state.u_30580;
        // D s_3198_2: cast zx s_3198_1 -> bv
        let s_3198_2: Bits = Bits::new(s_3198_1 as u128, 32u16);
        // C s_3198_3: const #1s : i64
        let s_3198_3: i64 = 1;
        // C s_3198_4: cast zx s_3198_3 -> i
        let s_3198_4: i128 = (i128::try_from(s_3198_3).unwrap());
        // C s_3198_5: const #3s : i
        let s_3198_5: i128 = 3;
        // C s_3198_6: add s_3198_5 s_3198_4
        let s_3198_6: i128 = (s_3198_5 + s_3198_4);
        // D s_3198_7: bit-extract s_3198_2 s_3198_0 s_3198_6
        let s_3198_7: Bits = (Bits::new(
            ((s_3198_2) >> (s_3198_0)).value(),
            u16::try_from(s_3198_6).unwrap(),
        ));
        // D s_3198_8: cast reint s_3198_7 -> u8
        let s_3198_8: u8 = (s_3198_7.value() as u8);
        // D s_3198_9: cast zx s_3198_8 -> bv
        let s_3198_9: Bits = Bits::new(s_3198_8 as u128, 4u16);
        // C s_3198_10: const #15u : u8
        let s_3198_10: u8 = 15;
        // C s_3198_11: cast zx s_3198_10 -> bv
        let s_3198_11: Bits = Bits::new(s_3198_10 as u128, 4u16);
        // D s_3198_12: cmp-eq s_3198_9 s_3198_11
        let s_3198_12: bool = ((s_3198_9) == (s_3198_11));
        // N s_3198_13: branch s_3198_12 b3201 b3199
        if s_3198_12 {
            return block_3201(state, tracer, fn_state);
        } else {
            return block_3199(state, tracer, fn_state);
        };
    }
    fn block_3199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3199_0: const #0u : u8
        let s_3199_0: bool = false;
        // D s_3199_1: write-var gs#397712 <= s_3199_0
        fn_state.gs_397712 = s_3199_0;
        // N s_3199_2: jump b3200
        return block_3200(state, tracer, fn_state);
    }
    fn block_3200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3200_0: read-var gs#397712:u8
        let s_3200_0: bool = fn_state.gs_397712;
        // D s_3200_1: write-var gs#397713 <= s_3200_0
        fn_state.gs_397713 = s_3200_0;
        // N s_3200_2: jump b3197
        return block_3197(state, tracer, fn_state);
    }
    fn block_3201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3201_0: const #4s : i
        let s_3201_0: i128 = 4;
        // D s_3201_1: read-var u#30580:u32
        let s_3201_1: u32 = fn_state.u_30580;
        // D s_3201_2: cast zx s_3201_1 -> bv
        let s_3201_2: Bits = Bits::new(s_3201_1 as u128, 32u16);
        // C s_3201_3: const #1s : i64
        let s_3201_3: i64 = 1;
        // C s_3201_4: cast zx s_3201_3 -> i
        let s_3201_4: i128 = (i128::try_from(s_3201_3).unwrap());
        // C s_3201_5: const #0s : i
        let s_3201_5: i128 = 0;
        // C s_3201_6: add s_3201_5 s_3201_4
        let s_3201_6: i128 = (s_3201_5 + s_3201_4);
        // D s_3201_7: bit-extract s_3201_2 s_3201_0 s_3201_6
        let s_3201_7: Bits = (Bits::new(
            ((s_3201_2) >> (s_3201_0)).value(),
            u16::try_from(s_3201_6).unwrap(),
        ));
        // D s_3201_8: cast reint s_3201_7 -> u8
        let s_3201_8: bool = ((s_3201_7.value()) != 0);
        // D s_3201_9: cast zx s_3201_8 -> bv
        let s_3201_9: Bits = Bits::new(s_3201_8 as u128, 1u16);
        // C s_3201_10: const #0u : u8
        let s_3201_10: bool = false;
        // C s_3201_11: cast zx s_3201_10 -> bv
        let s_3201_11: Bits = Bits::new(s_3201_10 as u128, 1u16);
        // D s_3201_12: cmp-eq s_3201_9 s_3201_11
        let s_3201_12: bool = ((s_3201_9) == (s_3201_11));
        // D s_3201_13: write-var gs#397712 <= s_3201_12
        fn_state.gs_397712 = s_3201_12;
        // N s_3201_14: jump b3200
        return block_3200(state, tracer, fn_state);
    }
    fn block_3202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3202_0: const #3056s : i
        let s_3202_0: i128 = 3056;
        // C s_3202_1: const #14696u : u32
        let s_3202_1: u32 = 14696;
        // D s_3202_2: read-reg s_3202_1:i
        let s_3202_2: i128 = {
            let value = state.read_register::<i128>(s_3202_1 as isize);
            tracer.read_register(s_3202_1 as isize, value);
            value
        };
        // D s_3202_3: cmp-lt s_3202_2 s_3202_0
        let s_3202_3: bool = ((s_3202_2) < (s_3202_0));
        // D s_3202_4: write-var gs#397694 <= s_3202_3
        fn_state.gs_397694 = s_3202_3;
        // N s_3202_5: jump b192
        return block_192(state, tracer, fn_state);
    }
    fn block_3203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3203_0: const #20s : i
        let s_3203_0: i128 = 20;
        // D s_3203_1: read-var u#30575:u32
        let s_3203_1: u32 = fn_state.u_30575;
        // D s_3203_2: cast zx s_3203_1 -> bv
        let s_3203_2: Bits = Bits::new(s_3203_1 as u128, 32u16);
        // C s_3203_3: const #1s : i64
        let s_3203_3: i64 = 1;
        // C s_3203_4: cast zx s_3203_3 -> i
        let s_3203_4: i128 = (i128::try_from(s_3203_3).unwrap());
        // C s_3203_5: const #2s : i
        let s_3203_5: i128 = 2;
        // C s_3203_6: add s_3203_5 s_3203_4
        let s_3203_6: i128 = (s_3203_5 + s_3203_4);
        // D s_3203_7: bit-extract s_3203_2 s_3203_0 s_3203_6
        let s_3203_7: Bits = (Bits::new(
            ((s_3203_2) >> (s_3203_0)).value(),
            u16::try_from(s_3203_6).unwrap(),
        ));
        // D s_3203_8: cast reint s_3203_7 -> u8
        let s_3203_8: u8 = (s_3203_7.value() as u8);
        // D s_3203_9: cast zx s_3203_8 -> bv
        let s_3203_9: Bits = Bits::new(s_3203_8 as u128, 3u16);
        // C s_3203_10: const #5u : u8
        let s_3203_10: u8 = 5;
        // C s_3203_11: cast zx s_3203_10 -> bv
        let s_3203_11: Bits = Bits::new(s_3203_10 as u128, 3u16);
        // D s_3203_12: cmp-eq s_3203_9 s_3203_11
        let s_3203_12: bool = ((s_3203_9) == (s_3203_11));
        // N s_3203_13: branch s_3203_12 b3206 b3204
        if s_3203_12 {
            return block_3206(state, tracer, fn_state);
        } else {
            return block_3204(state, tracer, fn_state);
        };
    }
    fn block_3204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3204_0: const #0u : u8
        let s_3204_0: bool = false;
        // D s_3204_1: write-var gs#397691 <= s_3204_0
        fn_state.gs_397691 = s_3204_0;
        // N s_3204_2: jump b3205
        return block_3205(state, tracer, fn_state);
    }
    fn block_3205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3205_0: read-var gs#397691:u8
        let s_3205_0: bool = fn_state.gs_397691;
        // D s_3205_1: write-var gs#397692 <= s_3205_0
        fn_state.gs_397692 = s_3205_0;
        // N s_3205_2: jump b190
        return block_190(state, tracer, fn_state);
    }
    fn block_3206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3206_0: const #12s : i
        let s_3206_0: i128 = 12;
        // D s_3206_1: read-var u#30575:u32
        let s_3206_1: u32 = fn_state.u_30575;
        // D s_3206_2: cast zx s_3206_1 -> bv
        let s_3206_2: Bits = Bits::new(s_3206_1 as u128, 32u16);
        // C s_3206_3: const #1s : i64
        let s_3206_3: i64 = 1;
        // C s_3206_4: cast zx s_3206_3 -> i
        let s_3206_4: i128 = (i128::try_from(s_3206_3).unwrap());
        // C s_3206_5: const #3s : i
        let s_3206_5: i128 = 3;
        // C s_3206_6: add s_3206_5 s_3206_4
        let s_3206_6: i128 = (s_3206_5 + s_3206_4);
        // D s_3206_7: bit-extract s_3206_2 s_3206_0 s_3206_6
        let s_3206_7: Bits = (Bits::new(
            ((s_3206_2) >> (s_3206_0)).value(),
            u16::try_from(s_3206_6).unwrap(),
        ));
        // D s_3206_8: cast reint s_3206_7 -> u8
        let s_3206_8: u8 = (s_3206_7.value() as u8);
        // D s_3206_9: cast zx s_3206_8 -> bv
        let s_3206_9: Bits = Bits::new(s_3206_8 as u128, 4u16);
        // C s_3206_10: const #15u : u8
        let s_3206_10: u8 = 15;
        // C s_3206_11: cast zx s_3206_10 -> bv
        let s_3206_11: Bits = Bits::new(s_3206_10 as u128, 4u16);
        // D s_3206_12: cmp-eq s_3206_9 s_3206_11
        let s_3206_12: bool = ((s_3206_9) == (s_3206_11));
        // D s_3206_13: write-var gs#397691 <= s_3206_12
        fn_state.gs_397691 = s_3206_12;
        // N s_3206_14: jump b3205
        return block_3205(state, tracer, fn_state);
    }
    fn block_3207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3207_0: const #3054s : i
        let s_3207_0: i128 = 3054;
        // C s_3207_1: const #14696u : u32
        let s_3207_1: u32 = 14696;
        // D s_3207_2: read-reg s_3207_1:i
        let s_3207_2: i128 = {
            let value = state.read_register::<i128>(s_3207_1 as isize);
            tracer.read_register(s_3207_1 as isize, value);
            value
        };
        // D s_3207_3: cmp-lt s_3207_2 s_3207_0
        let s_3207_3: bool = ((s_3207_2) < (s_3207_0));
        // D s_3207_4: write-var gs#397669 <= s_3207_3
        fn_state.gs_397669 = s_3207_3;
        // N s_3207_5: jump b186
        return block_186(state, tracer, fn_state);
    }
    fn block_3208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3208_0: const #20s : i
        let s_3208_0: i128 = 20;
        // D s_3208_1: read-var u#30570:u32
        let s_3208_1: u32 = fn_state.u_30570;
        // D s_3208_2: cast zx s_3208_1 -> bv
        let s_3208_2: Bits = Bits::new(s_3208_1 as u128, 32u16);
        // C s_3208_3: const #1s : i64
        let s_3208_3: i64 = 1;
        // C s_3208_4: cast zx s_3208_3 -> i
        let s_3208_4: i128 = (i128::try_from(s_3208_3).unwrap());
        // C s_3208_5: const #1s : i
        let s_3208_5: i128 = 1;
        // C s_3208_6: add s_3208_5 s_3208_4
        let s_3208_6: i128 = (s_3208_5 + s_3208_4);
        // D s_3208_7: bit-extract s_3208_2 s_3208_0 s_3208_6
        let s_3208_7: Bits = (Bits::new(
            ((s_3208_2) >> (s_3208_0)).value(),
            u16::try_from(s_3208_6).unwrap(),
        ));
        // D s_3208_8: cast reint s_3208_7 -> u8
        let s_3208_8: u8 = (s_3208_7.value() as u8);
        // D s_3208_9: cast zx s_3208_8 -> bv
        let s_3208_9: Bits = Bits::new(s_3208_8 as u128, 2u16);
        // C s_3208_10: const #1u : u8
        let s_3208_10: u8 = 1;
        // C s_3208_11: cast zx s_3208_10 -> bv
        let s_3208_11: Bits = Bits::new(s_3208_10 as u128, 2u16);
        // D s_3208_12: cmp-eq s_3208_9 s_3208_11
        let s_3208_12: bool = ((s_3208_9) == (s_3208_11));
        // N s_3208_13: branch s_3208_12 b3211 b3209
        if s_3208_12 {
            return block_3211(state, tracer, fn_state);
        } else {
            return block_3209(state, tracer, fn_state);
        };
    }
    fn block_3209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3209_0: const #0u : u8
        let s_3209_0: bool = false;
        // D s_3209_1: write-var gs#397666 <= s_3209_0
        fn_state.gs_397666 = s_3209_0;
        // N s_3209_2: jump b3210
        return block_3210(state, tracer, fn_state);
    }
    fn block_3210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3210_0: read-var gs#397666:u8
        let s_3210_0: bool = fn_state.gs_397666;
        // D s_3210_1: write-var gs#397667 <= s_3210_0
        fn_state.gs_397667 = s_3210_0;
        // N s_3210_2: jump b184
        return block_184(state, tracer, fn_state);
    }
    fn block_3211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3211_0: const #12s : i
        let s_3211_0: i128 = 12;
        // D s_3211_1: read-var u#30570:u32
        let s_3211_1: u32 = fn_state.u_30570;
        // D s_3211_2: cast zx s_3211_1 -> bv
        let s_3211_2: Bits = Bits::new(s_3211_1 as u128, 32u16);
        // C s_3211_3: const #1s : i64
        let s_3211_3: i64 = 1;
        // C s_3211_4: cast zx s_3211_3 -> i
        let s_3211_4: i128 = (i128::try_from(s_3211_3).unwrap());
        // C s_3211_5: const #3s : i
        let s_3211_5: i128 = 3;
        // C s_3211_6: add s_3211_5 s_3211_4
        let s_3211_6: i128 = (s_3211_5 + s_3211_4);
        // D s_3211_7: bit-extract s_3211_2 s_3211_0 s_3211_6
        let s_3211_7: Bits = (Bits::new(
            ((s_3211_2) >> (s_3211_0)).value(),
            u16::try_from(s_3211_6).unwrap(),
        ));
        // D s_3211_8: cast reint s_3211_7 -> u8
        let s_3211_8: u8 = (s_3211_7.value() as u8);
        // D s_3211_9: cast zx s_3211_8 -> bv
        let s_3211_9: Bits = Bits::new(s_3211_8 as u128, 4u16);
        // C s_3211_10: const #15u : u8
        let s_3211_10: u8 = 15;
        // C s_3211_11: cast zx s_3211_10 -> bv
        let s_3211_11: Bits = Bits::new(s_3211_10 as u128, 4u16);
        // D s_3211_12: cmp-eq s_3211_9 s_3211_11
        let s_3211_12: bool = ((s_3211_9) == (s_3211_11));
        // N s_3211_13: branch s_3211_12 b3214 b3212
        if s_3211_12 {
            return block_3214(state, tracer, fn_state);
        } else {
            return block_3212(state, tracer, fn_state);
        };
    }
    fn block_3212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3212_0: const #0u : u8
        let s_3212_0: bool = false;
        // D s_3212_1: write-var gs#397665 <= s_3212_0
        fn_state.gs_397665 = s_3212_0;
        // N s_3212_2: jump b3213
        return block_3213(state, tracer, fn_state);
    }
    fn block_3213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3213_0: read-var gs#397665:u8
        let s_3213_0: bool = fn_state.gs_397665;
        // D s_3213_1: write-var gs#397666 <= s_3213_0
        fn_state.gs_397666 = s_3213_0;
        // N s_3213_2: jump b3210
        return block_3210(state, tracer, fn_state);
    }
    fn block_3214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3214_0: const #4s : i
        let s_3214_0: i128 = 4;
        // D s_3214_1: read-var u#30570:u32
        let s_3214_1: u32 = fn_state.u_30570;
        // D s_3214_2: cast zx s_3214_1 -> bv
        let s_3214_2: Bits = Bits::new(s_3214_1 as u128, 32u16);
        // C s_3214_3: const #1s : i64
        let s_3214_3: i64 = 1;
        // C s_3214_4: cast zx s_3214_3 -> i
        let s_3214_4: i128 = (i128::try_from(s_3214_3).unwrap());
        // C s_3214_5: const #0s : i
        let s_3214_5: i128 = 0;
        // C s_3214_6: add s_3214_5 s_3214_4
        let s_3214_6: i128 = (s_3214_5 + s_3214_4);
        // D s_3214_7: bit-extract s_3214_2 s_3214_0 s_3214_6
        let s_3214_7: Bits = (Bits::new(
            ((s_3214_2) >> (s_3214_0)).value(),
            u16::try_from(s_3214_6).unwrap(),
        ));
        // D s_3214_8: cast reint s_3214_7 -> u8
        let s_3214_8: bool = ((s_3214_7.value()) != 0);
        // D s_3214_9: cast zx s_3214_8 -> bv
        let s_3214_9: Bits = Bits::new(s_3214_8 as u128, 1u16);
        // C s_3214_10: const #0u : u8
        let s_3214_10: bool = false;
        // C s_3214_11: cast zx s_3214_10 -> bv
        let s_3214_11: Bits = Bits::new(s_3214_10 as u128, 1u16);
        // D s_3214_12: cmp-eq s_3214_9 s_3214_11
        let s_3214_12: bool = ((s_3214_9) == (s_3214_11));
        // D s_3214_13: write-var gs#397665 <= s_3214_12
        fn_state.gs_397665 = s_3214_12;
        // N s_3214_14: jump b3213
        return block_3213(state, tracer, fn_state);
    }
    fn block_3215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3215_0: const #3052s : i
        let s_3215_0: i128 = 3052;
        // C s_3215_1: const #14696u : u32
        let s_3215_1: u32 = 14696;
        // D s_3215_2: read-reg s_3215_1:i
        let s_3215_2: i128 = {
            let value = state.read_register::<i128>(s_3215_1 as isize);
            tracer.read_register(s_3215_1 as isize, value);
            value
        };
        // D s_3215_3: cmp-lt s_3215_2 s_3215_0
        let s_3215_3: bool = ((s_3215_2) < (s_3215_0));
        // D s_3215_4: write-var gs#397647 <= s_3215_3
        fn_state.gs_397647 = s_3215_3;
        // N s_3215_5: jump b178
        return block_178(state, tracer, fn_state);
    }
    fn block_3216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3216_0: const #12s : i
        let s_3216_0: i128 = 12;
        // D s_3216_1: read-var u#30566:u32
        let s_3216_1: u32 = fn_state.u_30566;
        // D s_3216_2: cast zx s_3216_1 -> bv
        let s_3216_2: Bits = Bits::new(s_3216_1 as u128, 32u16);
        // C s_3216_3: const #1s : i64
        let s_3216_3: i64 = 1;
        // C s_3216_4: cast zx s_3216_3 -> i
        let s_3216_4: i128 = (i128::try_from(s_3216_3).unwrap());
        // C s_3216_5: const #10s : i
        let s_3216_5: i128 = 10;
        // C s_3216_6: add s_3216_5 s_3216_4
        let s_3216_6: i128 = (s_3216_5 + s_3216_4);
        // D s_3216_7: bit-extract s_3216_2 s_3216_0 s_3216_6
        let s_3216_7: Bits = (Bits::new(
            ((s_3216_2) >> (s_3216_0)).value(),
            u16::try_from(s_3216_6).unwrap(),
        ));
        // D s_3216_8: cast reint s_3216_7 -> u11
        let s_3216_8: u16 = (s_3216_7.value() as u16);
        // D s_3216_9: cast zx s_3216_8 -> bv
        let s_3216_9: Bits = Bits::new(s_3216_8 as u128, 11u16);
        // C s_3216_10: const #1535u : u11
        let s_3216_10: u16 = 1535;
        // C s_3216_11: cast zx s_3216_10 -> bv
        let s_3216_11: Bits = Bits::new(s_3216_10 as u128, 11u16);
        // D s_3216_12: cmp-eq s_3216_9 s_3216_11
        let s_3216_12: bool = ((s_3216_9) == (s_3216_11));
        // D s_3216_13: write-var gs#397645 <= s_3216_12
        fn_state.gs_397645 = s_3216_12;
        // N s_3216_14: jump b176
        return block_176(state, tracer, fn_state);
    }
    fn block_3217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3217_0: const #3049s : i
        let s_3217_0: i128 = 3049;
        // C s_3217_1: const #14696u : u32
        let s_3217_1: u32 = 14696;
        // D s_3217_2: read-reg s_3217_1:i
        let s_3217_2: i128 = {
            let value = state.read_register::<i128>(s_3217_1 as isize);
            tracer.read_register(s_3217_1 as isize, value);
            value
        };
        // D s_3217_3: cmp-lt s_3217_2 s_3217_0
        let s_3217_3: bool = ((s_3217_2) < (s_3217_0));
        // D s_3217_4: write-var gs#397629 <= s_3217_3
        fn_state.gs_397629 = s_3217_3;
        // N s_3217_5: jump b172
        return block_172(state, tracer, fn_state);
    }
    fn block_3218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3218_0: const #20s : i
        let s_3218_0: i128 = 20;
        // D s_3218_1: read-var u#30564:u32
        let s_3218_1: u32 = fn_state.u_30564;
        // D s_3218_2: cast zx s_3218_1 -> bv
        let s_3218_2: Bits = Bits::new(s_3218_1 as u128, 32u16);
        // C s_3218_3: const #1s : i64
        let s_3218_3: i64 = 1;
        // C s_3218_4: cast zx s_3218_3 -> i
        let s_3218_4: i128 = (i128::try_from(s_3218_3).unwrap());
        // C s_3218_5: const #1s : i
        let s_3218_5: i128 = 1;
        // C s_3218_6: add s_3218_5 s_3218_4
        let s_3218_6: i128 = (s_3218_5 + s_3218_4);
        // D s_3218_7: bit-extract s_3218_2 s_3218_0 s_3218_6
        let s_3218_7: Bits = (Bits::new(
            ((s_3218_2) >> (s_3218_0)).value(),
            u16::try_from(s_3218_6).unwrap(),
        ));
        // D s_3218_8: cast reint s_3218_7 -> u8
        let s_3218_8: u8 = (s_3218_7.value() as u8);
        // D s_3218_9: cast zx s_3218_8 -> bv
        let s_3218_9: Bits = Bits::new(s_3218_8 as u128, 2u16);
        // C s_3218_10: const #1u : u8
        let s_3218_10: u8 = 1;
        // C s_3218_11: cast zx s_3218_10 -> bv
        let s_3218_11: Bits = Bits::new(s_3218_10 as u128, 2u16);
        // D s_3218_12: cmp-eq s_3218_9 s_3218_11
        let s_3218_12: bool = ((s_3218_9) == (s_3218_11));
        // N s_3218_13: branch s_3218_12 b3221 b3219
        if s_3218_12 {
            return block_3221(state, tracer, fn_state);
        } else {
            return block_3219(state, tracer, fn_state);
        };
    }
    fn block_3219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3219_0: const #0u : u8
        let s_3219_0: bool = false;
        // D s_3219_1: write-var gs#397626 <= s_3219_0
        fn_state.gs_397626 = s_3219_0;
        // N s_3219_2: jump b3220
        return block_3220(state, tracer, fn_state);
    }
    fn block_3220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3220_0: read-var gs#397626:u8
        let s_3220_0: bool = fn_state.gs_397626;
        // D s_3220_1: write-var gs#397627 <= s_3220_0
        fn_state.gs_397627 = s_3220_0;
        // N s_3220_2: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_3221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3221_0: const #12s : i
        let s_3221_0: i128 = 12;
        // D s_3221_1: read-var u#30564:u32
        let s_3221_1: u32 = fn_state.u_30564;
        // D s_3221_2: cast zx s_3221_1 -> bv
        let s_3221_2: Bits = Bits::new(s_3221_1 as u128, 32u16);
        // C s_3221_3: const #1s : i64
        let s_3221_3: i64 = 1;
        // C s_3221_4: cast zx s_3221_3 -> i
        let s_3221_4: i128 = (i128::try_from(s_3221_3).unwrap());
        // C s_3221_5: const #3s : i
        let s_3221_5: i128 = 3;
        // C s_3221_6: add s_3221_5 s_3221_4
        let s_3221_6: i128 = (s_3221_5 + s_3221_4);
        // D s_3221_7: bit-extract s_3221_2 s_3221_0 s_3221_6
        let s_3221_7: Bits = (Bits::new(
            ((s_3221_2) >> (s_3221_0)).value(),
            u16::try_from(s_3221_6).unwrap(),
        ));
        // D s_3221_8: cast reint s_3221_7 -> u8
        let s_3221_8: u8 = (s_3221_7.value() as u8);
        // D s_3221_9: cast zx s_3221_8 -> bv
        let s_3221_9: Bits = Bits::new(s_3221_8 as u128, 4u16);
        // C s_3221_10: const #15u : u8
        let s_3221_10: u8 = 15;
        // C s_3221_11: cast zx s_3221_10 -> bv
        let s_3221_11: Bits = Bits::new(s_3221_10 as u128, 4u16);
        // D s_3221_12: cmp-eq s_3221_9 s_3221_11
        let s_3221_12: bool = ((s_3221_9) == (s_3221_11));
        // D s_3221_13: write-var gs#397626 <= s_3221_12
        fn_state.gs_397626 = s_3221_12;
        // N s_3221_14: jump b3220
        return block_3220(state, tracer, fn_state);
    }
    fn block_3222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3222_0: const #2909s : i
        let s_3222_0: i128 = 2909;
        // C s_3222_1: const #14696u : u32
        let s_3222_1: u32 = 14696;
        // D s_3222_2: read-reg s_3222_1:i
        let s_3222_2: i128 = {
            let value = state.read_register::<i128>(s_3222_1 as isize);
            tracer.read_register(s_3222_1 as isize, value);
            value
        };
        // D s_3222_3: cmp-lt s_3222_2 s_3222_0
        let s_3222_3: bool = ((s_3222_2) < (s_3222_0));
        // D s_3222_4: write-var gs#397579 <= s_3222_3
        fn_state.gs_397579 = s_3222_3;
        // N s_3222_5: jump b131
        return block_131(state, tracer, fn_state);
    }
    fn block_3223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3223_0: const #2901s : i
        let s_3223_0: i128 = 2901;
        // C s_3223_1: const #14696u : u32
        let s_3223_1: u32 = 14696;
        // D s_3223_2: read-reg s_3223_1:i
        let s_3223_2: i128 = {
            let value = state.read_register::<i128>(s_3223_1 as isize);
            tracer.read_register(s_3223_1 as isize, value);
            value
        };
        // D s_3223_3: cmp-lt s_3223_2 s_3223_0
        let s_3223_3: bool = ((s_3223_2) < (s_3223_0));
        // D s_3223_4: write-var gs#397535 <= s_3223_3
        fn_state.gs_397535 = s_3223_3;
        // N s_3223_5: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_3224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3224_0: const #2899s : i
        let s_3224_0: i128 = 2899;
        // C s_3224_1: const #14696u : u32
        let s_3224_1: u32 = 14696;
        // D s_3224_2: read-reg s_3224_1:i
        let s_3224_2: i128 = {
            let value = state.read_register::<i128>(s_3224_1 as isize);
            tracer.read_register(s_3224_1 as isize, value);
            value
        };
        // D s_3224_3: cmp-lt s_3224_2 s_3224_0
        let s_3224_3: bool = ((s_3224_2) < (s_3224_0));
        // D s_3224_4: write-var gs#397491 <= s_3224_3
        fn_state.gs_397491 = s_3224_3;
        // N s_3224_5: jump b53
        return block_53(state, tracer, fn_state);
    }
    fn block_3225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3225_0: const #2879s : i
        let s_3225_0: i128 = 2879;
        // C s_3225_1: const #14696u : u32
        let s_3225_1: u32 = 14696;
        // D s_3225_2: read-reg s_3225_1:i
        let s_3225_2: i128 = {
            let value = state.read_register::<i128>(s_3225_1 as isize);
            tracer.read_register(s_3225_1 as isize, value);
            value
        };
        // D s_3225_3: cmp-lt s_3225_2 s_3225_0
        let s_3225_3: bool = ((s_3225_2) < (s_3225_0));
        // D s_3225_4: write-var gs#397437 <= s_3225_3
        fn_state.gs_397437 = s_3225_3;
        // N s_3225_5: jump b2
        return block_2(state, tracer, fn_state);
    }
}
