#![no_std]
#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_doc_comments)]
#![allow(non_upper_case_globals)]
//! BOREALIS GENERATED FILE
extern crate alloc;
use decode_aarch32_instrs_SSUB16_A1enc_A_txt::*;
use decode_aarch32_instrs_UASX_A1enc_A_txt::*;
use decode_aarch32_instrs_UXTAB_A1enc_A_txt::*;
use decode_aarch32_instrs_UHADD8_A1enc_A_txt::*;
use decode_aarch32_instrs_SADD8_A1enc_A_txt::*;
use decode_aarch32_instrs_REVSH_A1enc_A_txt::*;
use decode_aarch32_instrs_SHSUB16_A1enc_A_txt::*;
use decode_aarch32_instrs_UADD16_A1enc_A_txt::*;
use decode_aarch32_instrs_QADD8_A1enc_A_txt::*;
use decode_aarch32_instrs_SXTAB16_A1enc_A_txt::*;
use decode_aarch32_instrs_QASX_A1enc_A_txt::*;
use decode_aarch32_instrs_UQADD16_A1enc_A_txt::*;
use decode_aarch32_instrs_SHADD16_A1enc_A_txt::*;
use decode_aarch32_instrs_SMLALD_A1enc_A_txt::*;
use decode_aarch32_instrs_BFI_A1enc_A_txt::*;
use decode_aarch32_instrs_SMUAD_A1enc_A_txt::*;
use decode_aarch32_instrs_SXTAH_A1enc_A_txt::*;
use decode_aarch32_instrs_UHADD16_A1enc_A_txt::*;
use decode_aarch32_instrs_RBIT_A1enc_A_txt::*;
use decode_aarch32_instrs_SDIV_A1enc_A_txt::*;
use decode_aarch32_instrs_SSAT16_A1enc_A_txt::*;
use decode_aarch32_instrs_UHSAX_A1enc_A_txt::*;
use decode_aarch32_instrs_SMUSD_A1enc_A_txt::*;
use decode_aarch32_instrs_UHSUB16_A1enc_A_txt::*;
use decode_aarch32_instrs_UHASX_A1enc_A_txt::*;
use decode_aarch32_instrs_UQSAX_A1enc_A_txt::*;
use decode_aarch32_instrs_SXTB16_A1enc_A_txt::*;
use decode_aarch32_instrs_SXTH_A1enc_A_txt::*;
use decode_aarch32_instrs_SHSAX_A1enc_A_txt::*;
use decode_aarch32_instrs_UBFX_A1enc_A_txt::*;
use decode_aarch32_instrs_USUB8_A1enc_A_txt::*;
use decode_aarch32_instrs_REV16_A1enc_A_txt::*;
use decode_aarch32_instrs_UHSUB8_A1enc_A_txt::*;
use decode_aarch32_instrs_UQSUB16_A1enc_A_txt::*;
use decode_aarch32_instrs_QSUB8_A1enc_A_txt::*;
use decode_aarch32_instrs_SHADD8_A1enc_A_txt::*;
use decode_aarch32_instrs_REV_A1enc_A_txt::*;
use decode_aarch32_instrs_UXTH_A1enc_A_txt::*;
use decode_aarch32_instrs_SADD16_A1enc_A_txt::*;
use decode_aarch32_instrs_UDIV_A1enc_A_txt::*;
use decode_aarch32_instrs_USAT_A1enc_A_txt::*;
use decode_aarch32_instrs_BFC_A1enc_A_txt::*;
use decode_aarch32_instrs_SASX_A1enc_A_txt::*;
use decode_aarch32_instrs_SBFX_A1enc_A_txt::*;
use decode_aarch32_instrs_SXTB_A1enc_A_txt::*;
use decode_aarch32_instrs_PKH_A1enc_A_txt::*;
use decode_aarch32_instrs_SHASX_A1enc_A_txt::*;
use decode_aarch32_instrs_SSAT_A1enc_A_txt::*;
use decode_aarch32_instrs_SMLAD_A1enc_A_txt::*;
use decode_aarch32_instrs_UDF_A1enc_A_txt::*;
use decode_aarch32_instrs_USAT16_A1enc_A_txt::*;
use decode_aarch32_instrs_SXTAB_A1enc_A_txt::*;
use decode_aarch32_instrs_SSUB8_A1enc_A_txt::*;
use decode_aarch32_instrs_UQASX_A1enc_A_txt::*;
use decode_aarch32_instrs_QSUB16_A1enc_A_txt::*;
use decode_aarch32_instrs_SSAX_A1enc_A_txt::*;
use decode_aarch32_instrs_UXTAH_A1enc_A_txt::*;
use decode_aarch32_instrs_QSAX_A1enc_A_txt::*;
use decode_aarch32_instrs_SHSUB8_A1enc_A_txt::*;
use decode_aarch32_instrs_SMLSD_A1enc_A_txt::*;
use decode_aarch32_instrs_UADD8_A1enc_A_txt::*;
use decode_aarch32_instrs_SMMLA_A1enc_A_txt::*;
use decode_aarch32_instrs_SMMLS_A1enc_A_txt::*;
use decode_aarch32_instrs_USADA8_A1enc_A_txt::*;
use decode_aarch32_instrs_UQSUB8_A1enc_A_txt::*;
use decode_aarch32_instrs_UXTB_A1enc_A_txt::*;
use decode_aarch32_instrs_USAD8_A1enc_A_txt::*;
use decode_aarch32_instrs_UXTAB16_A1enc_A_txt::*;
use decode_aarch32_instrs_SMLSLD_A1enc_A_txt::*;
use decode_aarch32_instrs_USUB16_A1enc_A_txt::*;
use decode_aarch32_instrs_QADD16_A1enc_A_txt::*;
use decode_aarch32_instrs_SEL_A1enc_A_txt::*;
use decode_aarch32_instrs_SMMUL_A1enc_A_txt::*;
use decode_aarch32_instrs_UXTB16_A1enc_A_txt::*;
use decode_aarch32_instrs_UQADD8_A1enc_A_txt::*;
use decode_aarch32_instrs_USAX_A1enc_A_txt::*;
use common::*;
pub fn u__DecodeA32_Media<T: Tracer>(
    state: &mut State,
    tracer: &T,
    gs_409089: i128,
    gs_409090: u32,
) -> () {
    #[derive(Default)]
    struct FunctionState {
        gs_409348: bool,
        u_33661: u8,
        gs_409548: bool,
        u_33742: u8,
        gs_410551: bool,
        gs_409441: bool,
        u_33752: u8,
        gs_410960: bool,
        u_33876: u32,
        gs_409459: bool,
        u_33488: u8,
        u_33832: u8,
        u_33817: u32,
        u_33627: u8,
        u_33788: u8,
        gs_410146: bool,
        u_33696: u8,
        u_33455: u32,
        gs_411257: bool,
        gs_409319: bool,
        gs_411205: bool,
        gs_411192: bool,
        u_33879: u8,
        gs_409284: bool,
        gs_409220: bool,
        u_33838: u8,
        u_33701: u8,
        gs_410928: bool,
        gs_411128: bool,
        gs_409229: bool,
        u_33553: u32,
        gs_409357: bool,
        u_33551: u8,
        gs_409977: bool,
        u_33764: u8,
        gs_410287: bool,
        gs_409615: bool,
        gs_410739: bool,
        u_33665: u8,
        u_33529: u32,
        gs_410327: bool,
        gs_410681: bool,
        u_33814: u8,
        gs_410513: bool,
        u_33835: u8,
        gs_410005: bool,
        gs_409949: bool,
        gs_410617: bool,
        u_33871: u8,
        u_33880: u8,
        u_33726: u32,
        u_33855: u8,
        gs_409921: bool,
        gs_410487: bool,
        u_33727: u8,
        u_33689: u8,
        gs_410439: bool,
        gs_410749: bool,
        gs_409420: bool,
        gs_410151: bool,
        u_33538: u8,
        u_33695: u8,
        u_33603: u32,
        u_33815: u8,
        gs_410893: bool,
        gs_409703: bool,
        gs_409885: bool,
        gs_409818: bool,
        gs_409525: bool,
        gs_410414: bool,
        gs_410963: bool,
        u_33554: u8,
        gs_411189: bool,
        u_33845: u8,
        u_33652: u8,
        gs_409580: bool,
        gs_409325: bool,
        gs_410497: bool,
        gs_411311: bool,
        gs_410098: bool,
        u_33451: u8,
        gs_409593: bool,
        u_33672: u8,
        gs_409144: bool,
        gs_409690: bool,
        u_33682: u8,
        gs_409882: bool,
        gs_411315: bool,
        gs_410896: bool,
        u_33626: u8,
        gs_409768: bool,
        u_33656: u8,
        gs_410701: bool,
        gs_409648: bool,
        gs_411110: bool,
        u_33629: u32,
        u_33669: u8,
        u_33489: u8,
        gs_409474: bool,
        u_33462: u8,
        gs_410669: bool,
        gs_411316: bool,
        u_33848: u8,
        u_33520: u8,
        u_33853: u8,
        gs_410172: bool,
        u_33523: u32,
        u_33793: u8,
        gs_410562: bool,
        gs_409393: bool,
        gs_409488: bool,
        u_33772: u8,
        gs_410545: bool,
        gs_409287: bool,
        u_33776: u8,
        u_33833: u8,
        u_33450: u8,
        u_33675: u8,
        u_33678: u8,
        u_33782: u8,
        u_33748: u8,
        u_33858: u8,
        gs_409821: bool,
        gs_409122: bool,
        u_33642: u32,
        gs_410070: bool,
        gs_409983: bool,
        u_33702: u8,
        u_33857: u32,
        u_33783: u8,
        u_33700: u8,
        u_33500: u8,
        gs_410039: bool,
        u_33547: u32,
        gs_409644: bool,
        gs_410299: bool,
        u_33759: u8,
        u_33556: u8,
        u_33468: u8,
        gs_411169: bool,
        gs_410166: bool,
        gs_410557: bool,
        gs_410303: bool,
        gs_410899: bool,
        gs_409188: bool,
        gs_411008: bool,
        gs_409201: bool,
        u_33464: u8,
        u_33433: u8,
        gs_410640: bool,
        gs_410777: bool,
        gs_410272: bool,
        gs_409426: bool,
        gs_410525: bool,
        u_33440: u8,
        gs_410957: bool,
        gs_410349: bool,
        u_33705: u8,
        gs_409832: bool,
        u_33645: u8,
        u_33763: u8,
        u_33877: u8,
        gs_410481: bool,
        u_33480: u8,
        u_33467: u32,
        u_33475: u8,
        u_33750: u32,
        gs_409831: bool,
        sat_imm: u8,
        gs_410995: bool,
        gs_410413: bool,
        gs_410864: bool,
        u_33694: u8,
        gs_409736: bool,
        gs_410814: bool,
        gs_410736: bool,
        gs_409375: bool,
        gs_409922: bool,
        gs_409545: bool,
        gs_410034: bool,
        gs_409362: bool,
        gs_410941: bool,
        gs_410387: bool,
        gs_409381: bool,
        gs_409859: bool,
        gs_411341: bool,
        gs_410123: bool,
        u_33768: u32,
        gs_410226: bool,
        gs_409432: bool,
        gs_410598: bool,
        gs_409261: bool,
        gs_409609: bool,
        u_33495: u8,
        gs_409384: bool,
        u_33766: u8,
        gs_410465: bool,
        gs_410092: bool,
        u_33862: u8,
        gs_409754: bool,
        u_33758: u8,
        u_33636: u32,
        u_33826: u8,
        gs_411160: bool,
        u_33686: u32,
        u_33658: u8,
        gs_410239: bool,
        gs_411080: bool,
        gs_410466: bool,
        u_33527: u8,
        gs_409621: bool,
        gs_409462: bool,
        gs_410403: bool,
        u_33668: u8,
        u_33798: u32,
        u_33646: u8,
        gs_411342: bool,
        u_33861: u8,
        gs_411003: bool,
        u_33478: u8,
        gs_410093: bool,
        gs_410909: bool,
        u_33494: u8,
        u_33474: u8,
        gs_409850: bool,
        gs_409786: bool,
        gs_410321: bool,
        u_33827: u8,
        u_33688: u8,
        gs_410255: bool,
        gs_410121: bool,
        gs_409390: bool,
        gs_410258: bool,
        gs_410713: bool,
        gs_409731: bool,
        u_33517: u32,
        u_33525: u8,
        u_33846: u8,
        u_33873: u8,
        u_33484: u8,
        u_33831: u32,
        gs_410293: bool,
        u_33878: u8,
        gs_409223: bool,
        u_33461: u32,
        u_33439: u8,
        u_33543: u8,
        u_33741: u8,
        u_33443: u32,
        gs_411331: bool,
        gs_410846: bool,
        gs_410548: bool,
        gs_410803: bool,
        u_33531: u8,
        u_33664: u8,
        u_33545: u8,
        gs_409423: bool,
        gs_409667: bool,
        u_33491: u8,
        gs_411030: bool,
        u_33781: u8,
        u_33789: u8,
        gs_409978: bool,
        gs_410750: bool,
        u_33850: u32,
        gs_409471: bool,
        gs_410516: bool,
        u_33804: u32,
        gs_411085: bool,
        gs_410582: bool,
        u_33501: u8,
        u_33778: u8,
        u_33874: u8,
        u_33792: u32,
        u_33566: u32,
        gs_410832: bool,
        gs_409687: bool,
        gs_409403: bool,
        u_33639: u8,
        gs_410781: bool,
        gs_410099: bool,
        u_33796: u8,
        gs_409096: bool,
        u_33643: u8,
        u__opcode: u32,
        merge_var: ProductType7b8639ca40b2f578,
        gs_409117: bool,
        u_33483: u8,
        u_33610: u32,
        u_33660: u32,
        u_33445: u8,
        gs_410440: bool,
        gs_410178: bool,
        gs_409799: bool,
        u_33463: u8,
        gs_409899: bool,
        gs_409297: bool,
        gs_409530: bool,
        gs_410686: bool,
        u_33811: u32,
        u_33866: u8,
        u_33650: u8,
        gs_409783: bool,
        u_33637: u8,
        gs_410653: bool,
        gs_409927: bool,
        gs_409583: bool,
        u_33548: u8,
        u_33485: u8,
        gs_409435: bool,
        gs_410271: bool,
        u_33777: u8,
        gs_410229: bool,
        gs_409671: bool,
        u_33550: u8,
        u_33559: u32,
        gs_410580: bool,
        gs_410561: bool,
        u_33677: u8,
        u_33535: u32,
        gs_409281: bool,
        u_33734: u8,
        gs_410267: bool,
        u_33812: u8,
        gs_409735: bool,
        gs_409345: bool,
        u_33774: u32,
        gs_410765: bool,
        gs_411109: bool,
        u_33865: u8,
        gs_410169: bool,
        gs_410925: bool,
        u_33555: u8,
        u_33667: u32,
        u_33533: u8,
        gs_409255: bool,
        gs_410359: bool,
        gs_409561: bool,
        gs_410010: bool,
        u_33502: u8,
        u_33834: u8,
        u_33490: u8,
        u_33497: u8,
        gs_410530: bool,
        gs_409165: bool,
        u_33588: u32,
        gs_410621: bool,
        u_33698: u32,
        u_33657: u8,
        u_33518: u8,
        gs_410331: bool,
        gs_410150: bool,
        u_33687: u8,
        gs_410771: bool,
        gs_409612: bool,
        gs_409699: bool,
        gs_409815: bool,
        gs_410332: bool,
        u_33595: u32,
        u_33738: u32,
        gs_409100: bool,
        gs_409507: bool,
        u_33847: u8,
        gs_411233: bool,
        gs_410063: bool,
        gs_410235: bool,
        u_33872: u8,
        gs_411125: bool,
        u_33671: u8,
        gs_410038: bool,
        gs_411305: bool,
        gs_409313: bool,
        gs_411068: bool,
        gs_410931: bool,
        gs_409468: bool,
        gs_409446: bool,
        gs_409551: bool,
        gs_410033: bool,
        gs_411173: bool,
        gs_409757: bool,
        gs_409298: bool,
        gs_409361: bool,
        gs_410207: bool,
        gs_410717: bool,
        u_33432: u8,
        gs_410672: bool,
        u_33537: u8,
        u_33754: u8,
        gs_409233: bool,
        gs_410127: bool,
        u_33640: u8,
        gs_410519: bool,
        gs_409982: bool,
        gs_410461: bool,
        u_33760: u8,
        gs_410203: bool,
        u_33426: u32,
        gs_411009: bool,
        gs_409864: bool,
        gs_411234: bool,
        u_33829: u8,
        gs_409847: bool,
        gs_411289: bool,
        gs_409293: bool,
        u_33456: u8,
        u_33459: u8,
        gs_410878: bool,
        u_33526: u8,
        gs_409704: bool,
        u_33719: u32,
        gs_409234: bool,
        gs_411195: bool,
        u_33852: u8,
        gs_410718: bool,
        u_33644: u8,
        gs_409329: bool,
        u_33503: u8,
        gs_411174: bool,
        gs_410989: bool,
        gs_411157: bool,
        u_33580: u32,
        gs_410183: bool,
        gs_409898: bool,
        u_33469: u8,
        gs_409404: bool,
        gs_409202: bool,
        u_33860: u8,
        u_33707: u8,
        gs_409562: bool,
        gs_410675: bool,
        gs_409140: bool,
        gs_409926: bool,
        gs_409101: bool,
        gs_410182: bool,
        gs_410835: bool,
        u_33717: u32,
        u_33499: u32,
        gs_409577: bool,
        gs_410654: bool,
        u_33438: u8,
        gs_409719: bool,
        gs_409693: bool,
        u_33867: u8,
        u_33479: u8,
        gs_411004: bool,
        u_33521: u8,
        gs_409625: bool,
        u_33625: u8,
        gs_410797: bool,
        u_33654: u32,
        u_33511: u32,
        u_33786: u32,
        u_33662: u8,
        gs_409399: bool,
        gs_409316: bool,
        u_33710: u32,
        gs_410973: bool,
        gs_410905: bool,
        u_33449: u32,
        gs_410383: bool,
        u_33704: u32,
        gs_409894: bool,
        u_33663: u8,
        u_33544: u8,
        gs_409672: bool,
        gs_409378: bool,
        gs_411261: bool,
        u_33477: u32,
        u_33864: u32,
        u_33784: u8,
        u_33473: u8,
        gs_410493: bool,
        u_33519: u8,
        gs_411071: bool,
        gs_410649: bool,
        u_33740: u8,
        u_33728: u8,
        u_33447: u8,
        gs_409252: bool,
        gs_410429: bool,
        u_33472: u32,
        u_33841: u8,
        gs_410388: bool,
        gs_410409: bool,
        gs_411131: bool,
        gs_409763: bool,
        u_33844: u8,
        gs_411285: bool,
        gs_409827: bool,
        gs_410685: bool,
        u_33790: u8,
        u_33680: u32,
        gs_409751: bool,
        u_33765: u8,
        u_33739: u8,
        gs_410128: bool,
        u_33868: u8,
        gs_410240: bool,
        gs_410643: bool,
        rotate: u8,
        gs_411053: bool,
        u_33794: u8,
        u_33770: u8,
        u_33452: u8,
        gs_409170: bool,
        u_33825: u32,
        u_33729: u8,
        u_33437: u32,
        u_33496: u8,
        gs_410208: bool,
        gs_409795: bool,
        gs_410813: bool,
        u_33775: u8,
        u_33753: u8,
        gs_409465: bool,
        u_33730: u8,
        gs_410622: bool,
        gs_410861: bool,
        u_33557: u8,
        gs_409477: bool,
        u_33747: u8,
        gs_409649: bool,
        gs_409483: bool,
        gs_410065: bool,
        u_33745: u8,
        gs_409429: bool,
        u_33854: u8,
        gs_411048: bool,
        u_33780: u32,
        gs_409445: bool,
        gs_409557: bool,
        u_33733: u8,
        u_33549: u8,
        gs_410937: bool,
        gs_409501: bool,
        gs_409893: bool,
        gs_411025: bool,
        u_33690: u8,
        gs_411279: bool,
        u_33699: u8,
        gs_409767: bool,
        gs_410992: bool,
        gs_411029: bool,
        u_33453: u8,
        u_33420: u32,
        gs_411337: bool,
        u_33536: u8,
        u_33795: u8,
        gs_410877: bool,
        gs_409510: bool,
        gs_410768: bool,
        gs_411251: bool,
        u_33762: u32,
        gs_409197: bool,
        gs_409516: bool,
        gs_409954: bool,
        u_33617: u32,
        u_33813: u8,
        u_33655: u8,
        gs_411105: bool,
        u_33446: u8,
        u_33532: u8,
        gs_409145: bool,
        gs_409789: bool,
        u_33441: u8,
        gs_410223: bool,
        u_33870: u32,
        gs_409487: bool,
        gs_409417: bool,
        u_33539: u8,
        u_33839: u8,
        gs_410122: bool,
        gs_409266: bool,
        u_33771: u8,
        gs_409800: bool,
        gs_409879: bool,
        u_33769: u8,
        gs_410011: bool,
        gs_409351: bool,
        gs_411206: bool,
        gs_410484: bool,
        u_33706: u8,
        u_33843: u32,
        gs_409853: bool,
        gs_410704: bool,
        u_33651: u8,
        gs_411229: bool,
        gs_409330: bool,
        u_33457: u8,
        gs_409722: bool,
        gs_409265: bool,
        u_33674: u32,
        gs_410873: bool,
        gs_410637: bool,
        u_33746: u8,
        gs_411052: bool,
        gs_410974: bool,
        gs_410290: bool,
        gs_411223: bool,
        gs_410006: bool,
        gs_411163: bool,
        gs_410455: bool,
        gs_411137: bool,
        gs_410942: bool,
        u_33470: u8,
        gs_410304: bool,
        u_33649: u8,
        u_33757: u8,
        u_33787: u8,
        u_33732: u32,
        u_33670: u8,
        gs_410261: bool,
        gs_409249: bool,
        u_33859: u8,
        gs_409950: bool,
        u_33751: u8,
        gs_409626: bool,
        gs_409863: bool,
        u_33684: u8,
        gs_410733: bool,
        u_33434: u8,
        gs_409589: bool,
        gs_411290: bool,
        gs_410094: bool,
        u_33648: u32,
        gs_409955: bool,
        u_33735: u8,
        u_33530: u8,
        gs_410910: bool,
        gs_410867: bool,
        gs_410745: bool,
        u_33572: u32,
        gs_410707: bool,
        gs_409513: bool,
        gs_410360: bool,
        u_33493: u32,
        u_33693: u8,
        u_33524: u8,
        u_33840: u8,
        gs_409519: bool,
        u_33482: u32,
        u_33505: u32,
        gs_410377: bool,
        gs_411357: bool,
        gs_409185: bool,
        gs_409387: bool,
        gs_411142: bool,
        u_33541: u32,
        gs_410435: bool,
        gs_410841: bool,
        u_33676: u8,
        gs_409169: bool,
        gs_409725: bool,
        u_33708: u8,
        gs_410809: bool,
        u_33683: u8,
        u_33444: u8,
        u_33487: u32,
        u_33851: u8,
        u_33458: u8,
        u_33435: u8,
        gs_410969: bool,
        u_33756: u32,
        u_33837: u32,
        gs_410064: bool,
        gs_411084: bool,
        gs_411141: bool,
        gs_410529: bool,
        gs_410594: bool,
        u_33465: u8,
        gs_411074: bool,
        gs_410599: bool,
        gs_409504: bool,
        u_33828: u8,
        u_33431: u32,
        u_33681: u8,
        u_33624: u32,
        gs_410498: bool,
        gs_411262: bool,
        gs_409217: bool,
        u_33692: u32,
        gs_409529: bool,
        u_33638: u8,
        gs_409191: bool,
        gs_409121: bool,
        u_33744: u32,
        gs_411201: bool,
        gs_409594: bool,
        u_33736: u8,
        gs_410845: bool,
        gs_410069: bool,
        gs_410800: bool,
        gs_410355: bool,
        gs_410782: bool,
        gs_410829: bool,
        u_33542: u8,
        gs_409089: i128,
        gs_409090: u32,
    }
    let fn_state = FunctionState {
        gs_409089,
        gs_409090,
        ..Default::default()
    };
    return block_0(state, tracer, fn_state);
    fn block_0<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_0_0: read-var gs#409089:i
        let s_0_0: i128 = fn_state.gs_409089;
        // D s_0_1: write-var merge#var.0 <= s_0_0
        fn_state.merge_var._0 = s_0_0;
        // D s_0_2: read-var gs#409090:u32
        let s_0_2: u32 = fn_state.gs_409090;
        // D s_0_3: write-var merge#var.1 <= s_0_2
        fn_state.merge_var._1 = s_0_2;
        // D s_0_4: read-var merge#var.1:struct
        let s_0_4: u32 = fn_state.merge_var._1;
        // D s_0_5: write-var __opcode <= s_0_4
        fn_state.u__opcode = s_0_4;
        // C s_0_6: const #21s : i
        let s_0_6: i128 = 21;
        // D s_0_7: read-var __opcode:u32
        let s_0_7: u32 = fn_state.u__opcode;
        // D s_0_8: cast zx s_0_7 -> bv
        let s_0_8: Bits = Bits::new(s_0_7 as u128, 32u16);
        // C s_0_9: const #1s : i64
        let s_0_9: i64 = 1;
        // C s_0_10: cast zx s_0_9 -> i
        let s_0_10: i128 = (i128::try_from(s_0_9).unwrap());
        // C s_0_11: const #6s : i
        let s_0_11: i128 = 6;
        // C s_0_12: add s_0_11 s_0_10
        let s_0_12: i128 = (s_0_11 + s_0_10);
        // D s_0_13: bit-extract s_0_8 s_0_6 s_0_12
        let s_0_13: Bits = (Bits::new(
            ((s_0_8) >> (s_0_6)).value(),
            u16::try_from(s_0_12).unwrap(),
        ));
        // D s_0_14: cast reint s_0_13 -> u8
        let s_0_14: u8 = (s_0_13.value() as u8);
        // D s_0_15: cast zx s_0_14 -> bv
        let s_0_15: Bits = Bits::new(s_0_14 as u128, 7u16);
        // C s_0_16: const #62u : u8
        let s_0_16: u8 = 62;
        // C s_0_17: cast zx s_0_16 -> bv
        let s_0_17: Bits = Bits::new(s_0_16 as u128, 7u16);
        // D s_0_18: cmp-eq s_0_15 s_0_17
        let s_0_18: bool = ((s_0_15) == (s_0_17));
        // N s_0_19: branch s_0_18 b1453 b1
        if s_0_18 {
            return block_1453(state, tracer, fn_state);
        } else {
            return block_1(state, tracer, fn_state);
        };
    }
    fn block_1<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1_0: const #0u : u8
        let s_1_0: bool = false;
        // D s_1_1: write-var gs#409096 <= s_1_0
        fn_state.gs_409096 = s_1_0;
        // N s_1_2: jump b2
        return block_2(state, tracer, fn_state);
    }
    fn block_2<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2_0: read-var gs#409096:u8
        let s_2_0: bool = fn_state.gs_409096;
        // N s_2_1: branch s_2_0 b1449 b3
        if s_2_0 {
            return block_1449(state, tracer, fn_state);
        } else {
            return block_3(state, tracer, fn_state);
        };
    }
    fn block_3<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3_0: const #0u : u8
        let s_3_0: bool = false;
        // D s_3_1: write-var gs#409101 <= s_3_0
        fn_state.gs_409101 = s_3_0;
        // N s_3_2: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_4<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4_0: read-var gs#409101:u8
        let s_4_0: bool = fn_state.gs_409101;
        // D s_4_1: not s_4_0
        let s_4_1: bool = !s_4_0;
        // N s_4_2: branch s_4_1 b6 b5
        if s_4_1 {
            return block_6(state, tracer, fn_state);
        } else {
            return block_5(state, tracer, fn_state);
        };
    }
    fn block_5<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_5_0: const #2856s : i
        let s_5_0: i128 = 2856;
        // C s_5_1: const #14696u : u32
        let s_5_1: u32 = 14696;
        // N s_5_2: write-reg s_5_1 <= s_5_0
        let s_5_2: () = {
            state.write_register::<i128>(s_5_1 as isize, s_5_0);
            tracer.write_register(s_5_1 as isize, s_5_0);
        };
        // C s_5_3: const #28s : i
        let s_5_3: i128 = 28;
        // C s_5_4: const #4s : i
        let s_5_4: i128 = 4;
        // D s_5_5: read-var __opcode:u32
        let s_5_5: u32 = fn_state.u__opcode;
        // D s_5_6: cast zx s_5_5 -> bv
        let s_5_6: Bits = Bits::new(s_5_5 as u128, 32u16);
        // D s_5_7: bit-extract s_5_6 s_5_3 s_5_4
        let s_5_7: Bits = (Bits::new(
            ((s_5_6) >> (s_5_3)).value(),
            u16::try_from(s_5_4).unwrap(),
        ));
        // D s_5_8: cast reint s_5_7 -> u8
        let s_5_8: u8 = (s_5_7.value() as u8);
        // C s_5_9: const #16s : i
        let s_5_9: i128 = 16;
        // C s_5_10: const #5s : i
        let s_5_10: i128 = 5;
        // D s_5_11: read-var __opcode:u32
        let s_5_11: u32 = fn_state.u__opcode;
        // D s_5_12: cast zx s_5_11 -> bv
        let s_5_12: Bits = Bits::new(s_5_11 as u128, 32u16);
        // D s_5_13: bit-extract s_5_12 s_5_9 s_5_10
        let s_5_13: Bits = (Bits::new(
            ((s_5_12) >> (s_5_9)).value(),
            u16::try_from(s_5_10).unwrap(),
        ));
        // D s_5_14: cast reint s_5_13 -> u8
        let s_5_14: u8 = (s_5_13.value() as u8);
        // C s_5_15: const #12s : i
        let s_5_15: i128 = 12;
        // C s_5_16: const #4s : i
        let s_5_16: i128 = 4;
        // D s_5_17: read-var __opcode:u32
        let s_5_17: u32 = fn_state.u__opcode;
        // D s_5_18: cast zx s_5_17 -> bv
        let s_5_18: Bits = Bits::new(s_5_17 as u128, 32u16);
        // D s_5_19: bit-extract s_5_18 s_5_15 s_5_16
        let s_5_19: Bits = (Bits::new(
            ((s_5_18) >> (s_5_15)).value(),
            u16::try_from(s_5_16).unwrap(),
        ));
        // D s_5_20: cast reint s_5_19 -> u8
        let s_5_20: u8 = (s_5_19.value() as u8);
        // C s_5_21: const #7s : i
        let s_5_21: i128 = 7;
        // C s_5_22: const #5s : i
        let s_5_22: i128 = 5;
        // D s_5_23: read-var __opcode:u32
        let s_5_23: u32 = fn_state.u__opcode;
        // D s_5_24: cast zx s_5_23 -> bv
        let s_5_24: Bits = Bits::new(s_5_23 as u128, 32u16);
        // D s_5_25: bit-extract s_5_24 s_5_21 s_5_22
        let s_5_25: Bits = (Bits::new(
            ((s_5_24) >> (s_5_21)).value(),
            u16::try_from(s_5_22).unwrap(),
        ));
        // D s_5_26: cast reint s_5_25 -> u8
        let s_5_26: u8 = (s_5_25.value() as u8);
        // D s_5_27: call decode_aarch32_instrs_BFC_A1enc_A_txt(s_5_8, s_5_14, s_5_20, s_5_26)
        let s_5_27: () = decode_aarch32_instrs_BFC_A1enc_A_txt(
            state,
            tracer,
            s_5_8,
            s_5_14,
            s_5_20,
            s_5_26,
        );
        // N s_5_28: return
        return;
    }
    fn block_6<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_6_0: read-var merge#var.1:struct
        let s_6_0: u32 = fn_state.merge_var._1;
        // D s_6_1: write-var u#33420 <= s_6_0
        fn_state.u_33420 = s_6_0;
        // C s_6_2: const #21s : i
        let s_6_2: i128 = 21;
        // D s_6_3: read-var u#33420:u32
        let s_6_3: u32 = fn_state.u_33420;
        // D s_6_4: cast zx s_6_3 -> bv
        let s_6_4: Bits = Bits::new(s_6_3 as u128, 32u16);
        // C s_6_5: const #1s : i64
        let s_6_5: i64 = 1;
        // C s_6_6: cast zx s_6_5 -> i
        let s_6_6: i128 = (i128::try_from(s_6_5).unwrap());
        // C s_6_7: const #6s : i
        let s_6_7: i128 = 6;
        // C s_6_8: add s_6_7 s_6_6
        let s_6_8: i128 = (s_6_7 + s_6_6);
        // D s_6_9: bit-extract s_6_4 s_6_2 s_6_8
        let s_6_9: Bits = (Bits::new(
            ((s_6_4) >> (s_6_2)).value(),
            u16::try_from(s_6_8).unwrap(),
        ));
        // D s_6_10: cast reint s_6_9 -> u8
        let s_6_10: u8 = (s_6_9.value() as u8);
        // D s_6_11: cast zx s_6_10 -> bv
        let s_6_11: Bits = Bits::new(s_6_10 as u128, 7u16);
        // C s_6_12: const #62u : u8
        let s_6_12: u8 = 62;
        // C s_6_13: cast zx s_6_12 -> bv
        let s_6_13: Bits = Bits::new(s_6_12 as u128, 7u16);
        // D s_6_14: cmp-eq s_6_11 s_6_13
        let s_6_14: bool = ((s_6_11) == (s_6_13));
        // N s_6_15: branch s_6_14 b1448 b7
        if s_6_14 {
            return block_1448(state, tracer, fn_state);
        } else {
            return block_7(state, tracer, fn_state);
        };
    }
    fn block_7<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_7_0: const #0u : u8
        let s_7_0: bool = false;
        // D s_7_1: write-var gs#409117 <= s_7_0
        fn_state.gs_409117 = s_7_0;
        // N s_7_2: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_8<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_8_0: read-var gs#409117:u8
        let s_8_0: bool = fn_state.gs_409117;
        // N s_8_1: branch s_8_0 b1444 b9
        if s_8_0 {
            return block_1444(state, tracer, fn_state);
        } else {
            return block_9(state, tracer, fn_state);
        };
    }
    fn block_9<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_9_0: const #0u : u8
        let s_9_0: bool = false;
        // D s_9_1: write-var gs#409122 <= s_9_0
        fn_state.gs_409122 = s_9_0;
        // N s_9_2: jump b10
        return block_10(state, tracer, fn_state);
    }
    fn block_10<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_10_0: read-var gs#409122:u8
        let s_10_0: bool = fn_state.gs_409122;
        // D s_10_1: not s_10_0
        let s_10_1: bool = !s_10_0;
        // N s_10_2: branch s_10_1 b12 b11
        if s_10_1 {
            return block_12(state, tracer, fn_state);
        } else {
            return block_11(state, tracer, fn_state);
        };
    }
    fn block_11<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_11_0: const #2858s : i
        let s_11_0: i128 = 2858;
        // C s_11_1: const #14696u : u32
        let s_11_1: u32 = 14696;
        // N s_11_2: write-reg s_11_1 <= s_11_0
        let s_11_2: () = {
            state.write_register::<i128>(s_11_1 as isize, s_11_0);
            tracer.write_register(s_11_1 as isize, s_11_0);
        };
        // C s_11_3: const #28s : i
        let s_11_3: i128 = 28;
        // C s_11_4: const #4s : i
        let s_11_4: i128 = 4;
        // D s_11_5: read-var u#33420:u32
        let s_11_5: u32 = fn_state.u_33420;
        // D s_11_6: cast zx s_11_5 -> bv
        let s_11_6: Bits = Bits::new(s_11_5 as u128, 32u16);
        // D s_11_7: bit-extract s_11_6 s_11_3 s_11_4
        let s_11_7: Bits = (Bits::new(
            ((s_11_6) >> (s_11_3)).value(),
            u16::try_from(s_11_4).unwrap(),
        ));
        // D s_11_8: cast reint s_11_7 -> u8
        let s_11_8: u8 = (s_11_7.value() as u8);
        // C s_11_9: const #16s : i
        let s_11_9: i128 = 16;
        // C s_11_10: const #5s : i
        let s_11_10: i128 = 5;
        // D s_11_11: read-var u#33420:u32
        let s_11_11: u32 = fn_state.u_33420;
        // D s_11_12: cast zx s_11_11 -> bv
        let s_11_12: Bits = Bits::new(s_11_11 as u128, 32u16);
        // D s_11_13: bit-extract s_11_12 s_11_9 s_11_10
        let s_11_13: Bits = (Bits::new(
            ((s_11_12) >> (s_11_9)).value(),
            u16::try_from(s_11_10).unwrap(),
        ));
        // D s_11_14: cast reint s_11_13 -> u8
        let s_11_14: u8 = (s_11_13.value() as u8);
        // C s_11_15: const #12s : i
        let s_11_15: i128 = 12;
        // C s_11_16: const #4s : i
        let s_11_16: i128 = 4;
        // D s_11_17: read-var u#33420:u32
        let s_11_17: u32 = fn_state.u_33420;
        // D s_11_18: cast zx s_11_17 -> bv
        let s_11_18: Bits = Bits::new(s_11_17 as u128, 32u16);
        // D s_11_19: bit-extract s_11_18 s_11_15 s_11_16
        let s_11_19: Bits = (Bits::new(
            ((s_11_18) >> (s_11_15)).value(),
            u16::try_from(s_11_16).unwrap(),
        ));
        // D s_11_20: cast reint s_11_19 -> u8
        let s_11_20: u8 = (s_11_19.value() as u8);
        // C s_11_21: const #7s : i
        let s_11_21: i128 = 7;
        // C s_11_22: const #5s : i
        let s_11_22: i128 = 5;
        // D s_11_23: read-var u#33420:u32
        let s_11_23: u32 = fn_state.u_33420;
        // D s_11_24: cast zx s_11_23 -> bv
        let s_11_24: Bits = Bits::new(s_11_23 as u128, 32u16);
        // D s_11_25: bit-extract s_11_24 s_11_21 s_11_22
        let s_11_25: Bits = (Bits::new(
            ((s_11_24) >> (s_11_21)).value(),
            u16::try_from(s_11_22).unwrap(),
        ));
        // D s_11_26: cast reint s_11_25 -> u8
        let s_11_26: u8 = (s_11_25.value() as u8);
        // C s_11_27: const #0s : i
        let s_11_27: i128 = 0;
        // C s_11_28: const #4s : i
        let s_11_28: i128 = 4;
        // D s_11_29: read-var u#33420:u32
        let s_11_29: u32 = fn_state.u_33420;
        // D s_11_30: cast zx s_11_29 -> bv
        let s_11_30: Bits = Bits::new(s_11_29 as u128, 32u16);
        // D s_11_31: bit-extract s_11_30 s_11_27 s_11_28
        let s_11_31: Bits = (Bits::new(
            ((s_11_30) >> (s_11_27)).value(),
            u16::try_from(s_11_28).unwrap(),
        ));
        // D s_11_32: cast reint s_11_31 -> u8
        let s_11_32: u8 = (s_11_31.value() as u8);
        // D s_11_33: call decode_aarch32_instrs_BFI_A1enc_A_txt(s_11_8, s_11_14, s_11_20, s_11_26, s_11_32)
        let s_11_33: () = decode_aarch32_instrs_BFI_A1enc_A_txt(
            state,
            tracer,
            s_11_8,
            s_11_14,
            s_11_20,
            s_11_26,
            s_11_32,
        );
        // N s_11_34: return
        return;
    }
    fn block_12<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_12_0: read-var merge#var.1:struct
        let s_12_0: u32 = fn_state.merge_var._1;
        // D s_12_1: write-var u#33426 <= s_12_0
        fn_state.u_33426 = s_12_0;
        // C s_12_2: const #20s : i
        let s_12_2: i128 = 20;
        // D s_12_3: read-var u#33426:u32
        let s_12_3: u32 = fn_state.u_33426;
        // D s_12_4: cast zx s_12_3 -> bv
        let s_12_4: Bits = Bits::new(s_12_3 as u128, 32u16);
        // C s_12_5: const #1s : i64
        let s_12_5: i64 = 1;
        // C s_12_6: cast zx s_12_5 -> i
        let s_12_6: i128 = (i128::try_from(s_12_5).unwrap());
        // C s_12_7: const #7s : i
        let s_12_7: i128 = 7;
        // C s_12_8: add s_12_7 s_12_6
        let s_12_8: i128 = (s_12_7 + s_12_6);
        // D s_12_9: bit-extract s_12_4 s_12_2 s_12_8
        let s_12_9: Bits = (Bits::new(
            ((s_12_4) >> (s_12_2)).value(),
            u16::try_from(s_12_8).unwrap(),
        ));
        // D s_12_10: cast reint s_12_9 -> u8
        let s_12_10: u8 = (s_12_9.value() as u8);
        // D s_12_11: cast zx s_12_10 -> bv
        let s_12_11: Bits = Bits::new(s_12_10 as u128, 8u16);
        // C s_12_12: const #104u : u8
        let s_12_12: u8 = 104;
        // C s_12_13: cast zx s_12_12 -> bv
        let s_12_13: Bits = Bits::new(s_12_12 as u128, 8u16);
        // D s_12_14: cmp-eq s_12_11 s_12_13
        let s_12_14: bool = ((s_12_11) == (s_12_13));
        // N s_12_15: branch s_12_14 b1443 b13
        if s_12_14 {
            return block_1443(state, tracer, fn_state);
        } else {
            return block_13(state, tracer, fn_state);
        };
    }
    fn block_13<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_13_0: const #0u : u8
        let s_13_0: bool = false;
        // D s_13_1: write-var gs#409140 <= s_13_0
        fn_state.gs_409140 = s_13_0;
        // N s_13_2: jump b14
        return block_14(state, tracer, fn_state);
    }
    fn block_14<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_14_0: read-var gs#409140:u8
        let s_14_0: bool = fn_state.gs_409140;
        // N s_14_1: branch s_14_0 b1439 b15
        if s_14_0 {
            return block_1439(state, tracer, fn_state);
        } else {
            return block_15(state, tracer, fn_state);
        };
    }
    fn block_15<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_15_0: const #0u : u8
        let s_15_0: bool = false;
        // D s_15_1: write-var gs#409145 <= s_15_0
        fn_state.gs_409145 = s_15_0;
        // N s_15_2: jump b16
        return block_16(state, tracer, fn_state);
    }
    fn block_16<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_16_0: read-var gs#409145:u8
        let s_16_0: bool = fn_state.gs_409145;
        // D s_16_1: not s_16_0
        let s_16_1: bool = !s_16_0;
        // N s_16_2: branch s_16_1 b18 b17
        if s_16_1 {
            return block_18(state, tracer, fn_state);
        } else {
            return block_17(state, tracer, fn_state);
        };
    }
    fn block_17<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_17_0: const #3047s : i
        let s_17_0: i128 = 3047;
        // C s_17_1: const #14696u : u32
        let s_17_1: u32 = 14696;
        // N s_17_2: write-reg s_17_1 <= s_17_0
        let s_17_2: () = {
            state.write_register::<i128>(s_17_1 as isize, s_17_0);
            tracer.write_register(s_17_1 as isize, s_17_0);
        };
        // C s_17_3: const #28s : i
        let s_17_3: i128 = 28;
        // C s_17_4: const #4s : i
        let s_17_4: i128 = 4;
        // D s_17_5: read-var u#33426:u32
        let s_17_5: u32 = fn_state.u_33426;
        // D s_17_6: cast zx s_17_5 -> bv
        let s_17_6: Bits = Bits::new(s_17_5 as u128, 32u16);
        // D s_17_7: bit-extract s_17_6 s_17_3 s_17_4
        let s_17_7: Bits = (Bits::new(
            ((s_17_6) >> (s_17_3)).value(),
            u16::try_from(s_17_4).unwrap(),
        ));
        // D s_17_8: cast reint s_17_7 -> u8
        let s_17_8: u8 = (s_17_7.value() as u8);
        // C s_17_9: const #16s : i
        let s_17_9: i128 = 16;
        // C s_17_10: const #4s : i
        let s_17_10: i128 = 4;
        // D s_17_11: read-var u#33426:u32
        let s_17_11: u32 = fn_state.u_33426;
        // D s_17_12: cast zx s_17_11 -> bv
        let s_17_12: Bits = Bits::new(s_17_11 as u128, 32u16);
        // D s_17_13: bit-extract s_17_12 s_17_9 s_17_10
        let s_17_13: Bits = (Bits::new(
            ((s_17_12) >> (s_17_9)).value(),
            u16::try_from(s_17_10).unwrap(),
        ));
        // D s_17_14: cast reint s_17_13 -> u8
        let s_17_14: u8 = (s_17_13.value() as u8);
        // C s_17_15: const #12s : i
        let s_17_15: i128 = 12;
        // C s_17_16: const #4s : i
        let s_17_16: i128 = 4;
        // D s_17_17: read-var u#33426:u32
        let s_17_17: u32 = fn_state.u_33426;
        // D s_17_18: cast zx s_17_17 -> bv
        let s_17_18: Bits = Bits::new(s_17_17 as u128, 32u16);
        // D s_17_19: bit-extract s_17_18 s_17_15 s_17_16
        let s_17_19: Bits = (Bits::new(
            ((s_17_18) >> (s_17_15)).value(),
            u16::try_from(s_17_16).unwrap(),
        ));
        // D s_17_20: cast reint s_17_19 -> u8
        let s_17_20: u8 = (s_17_19.value() as u8);
        // C s_17_21: const #7s : i
        let s_17_21: i128 = 7;
        // C s_17_22: const #5s : i
        let s_17_22: i128 = 5;
        // D s_17_23: read-var u#33426:u32
        let s_17_23: u32 = fn_state.u_33426;
        // D s_17_24: cast zx s_17_23 -> bv
        let s_17_24: Bits = Bits::new(s_17_23 as u128, 32u16);
        // D s_17_25: bit-extract s_17_24 s_17_21 s_17_22
        let s_17_25: Bits = (Bits::new(
            ((s_17_24) >> (s_17_21)).value(),
            u16::try_from(s_17_22).unwrap(),
        ));
        // D s_17_26: cast reint s_17_25 -> u8
        let s_17_26: u8 = (s_17_25.value() as u8);
        // C s_17_27: const #6s : i
        let s_17_27: i128 = 6;
        // C s_17_28: const #1s : i
        let s_17_28: i128 = 1;
        // D s_17_29: read-var u#33426:u32
        let s_17_29: u32 = fn_state.u_33426;
        // D s_17_30: cast zx s_17_29 -> bv
        let s_17_30: Bits = Bits::new(s_17_29 as u128, 32u16);
        // D s_17_31: bit-extract s_17_30 s_17_27 s_17_28
        let s_17_31: Bits = (Bits::new(
            ((s_17_30) >> (s_17_27)).value(),
            u16::try_from(s_17_28).unwrap(),
        ));
        // D s_17_32: cast reint s_17_31 -> u8
        let s_17_32: bool = ((s_17_31.value()) != 0);
        // C s_17_33: const #0s : i
        let s_17_33: i128 = 0;
        // C s_17_34: const #4s : i
        let s_17_34: i128 = 4;
        // D s_17_35: read-var u#33426:u32
        let s_17_35: u32 = fn_state.u_33426;
        // D s_17_36: cast zx s_17_35 -> bv
        let s_17_36: Bits = Bits::new(s_17_35 as u128, 32u16);
        // D s_17_37: bit-extract s_17_36 s_17_33 s_17_34
        let s_17_37: Bits = (Bits::new(
            ((s_17_36) >> (s_17_33)).value(),
            u16::try_from(s_17_34).unwrap(),
        ));
        // D s_17_38: cast reint s_17_37 -> u8
        let s_17_38: u8 = (s_17_37.value() as u8);
        // D s_17_39: call decode_aarch32_instrs_PKH_A1enc_A_txt(s_17_8, s_17_14, s_17_20, s_17_26, s_17_32, s_17_38)
        let s_17_39: () = decode_aarch32_instrs_PKH_A1enc_A_txt(
            state,
            tracer,
            s_17_8,
            s_17_14,
            s_17_20,
            s_17_26,
            s_17_32,
            s_17_38,
        );
        // N s_17_40: return
        return;
    }
    fn block_18<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_18_0: read-var merge#var.1:struct
        let s_18_0: u32 = fn_state.merge_var._1;
        // D s_18_1: write-var u#33431 <= s_18_0
        fn_state.u_33431 = s_18_0;
        // C s_18_2: const #20s : i
        let s_18_2: i128 = 20;
        // D s_18_3: read-var u#33431:u32
        let s_18_3: u32 = fn_state.u_33431;
        // D s_18_4: cast zx s_18_3 -> bv
        let s_18_4: Bits = Bits::new(s_18_3 as u128, 32u16);
        // C s_18_5: const #1s : i64
        let s_18_5: i64 = 1;
        // C s_18_6: cast zx s_18_5 -> i
        let s_18_6: i128 = (i128::try_from(s_18_5).unwrap());
        // C s_18_7: const #7s : i
        let s_18_7: i128 = 7;
        // C s_18_8: add s_18_7 s_18_6
        let s_18_8: i128 = (s_18_7 + s_18_6);
        // D s_18_9: bit-extract s_18_4 s_18_2 s_18_8
        let s_18_9: Bits = (Bits::new(
            ((s_18_4) >> (s_18_2)).value(),
            u16::try_from(s_18_8).unwrap(),
        ));
        // D s_18_10: cast reint s_18_9 -> u8
        let s_18_10: u8 = (s_18_9.value() as u8);
        // D s_18_11: cast zx s_18_10 -> bv
        let s_18_11: Bits = Bits::new(s_18_10 as u128, 8u16);
        // C s_18_12: const #98u : u8
        let s_18_12: u8 = 98;
        // C s_18_13: cast zx s_18_12 -> bv
        let s_18_13: Bits = Bits::new(s_18_12 as u128, 8u16);
        // D s_18_14: cmp-eq s_18_11 s_18_13
        let s_18_14: bool = ((s_18_11) == (s_18_13));
        // N s_18_15: branch s_18_14 b1438 b19
        if s_18_14 {
            return block_1438(state, tracer, fn_state);
        } else {
            return block_19(state, tracer, fn_state);
        };
    }
    fn block_19<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_19_0: const #0u : u8
        let s_19_0: bool = false;
        // D s_19_1: write-var gs#409165 <= s_19_0
        fn_state.gs_409165 = s_19_0;
        // N s_19_2: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_20<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_20_0: read-var gs#409165:u8
        let s_20_0: bool = fn_state.gs_409165;
        // N s_20_1: branch s_20_0 b1434 b21
        if s_20_0 {
            return block_1434(state, tracer, fn_state);
        } else {
            return block_21(state, tracer, fn_state);
        };
    }
    fn block_21<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_21_0: const #0u : u8
        let s_21_0: bool = false;
        // D s_21_1: write-var gs#409170 <= s_21_0
        fn_state.gs_409170 = s_21_0;
        // N s_21_2: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_22<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_22_0: read-var gs#409170:u8
        let s_22_0: bool = fn_state.gs_409170;
        // D s_22_1: not s_22_0
        let s_22_1: bool = !s_22_0;
        // N s_22_2: branch s_22_1 b35 b23
        if s_22_1 {
            return block_35(state, tracer, fn_state);
        } else {
            return block_23(state, tracer, fn_state);
        };
    }
    fn block_23<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_23_0: const #3064s : i
        let s_23_0: i128 = 3064;
        // C s_23_1: const #14696u : u32
        let s_23_1: u32 = 14696;
        // N s_23_2: write-reg s_23_1 <= s_23_0
        let s_23_2: () = {
            state.write_register::<i128>(s_23_1 as isize, s_23_0);
            tracer.write_register(s_23_1 as isize, s_23_0);
        };
        // C s_23_3: const #28s : i
        let s_23_3: i128 = 28;
        // C s_23_4: const #4s : i
        let s_23_4: i128 = 4;
        // D s_23_5: read-var u#33431:u32
        let s_23_5: u32 = fn_state.u_33431;
        // D s_23_6: cast zx s_23_5 -> bv
        let s_23_6: Bits = Bits::new(s_23_5 as u128, 32u16);
        // D s_23_7: bit-extract s_23_6 s_23_3 s_23_4
        let s_23_7: Bits = (Bits::new(
            ((s_23_6) >> (s_23_3)).value(),
            u16::try_from(s_23_4).unwrap(),
        ));
        // D s_23_8: cast reint s_23_7 -> u8
        let s_23_8: u8 = (s_23_7.value() as u8);
        // D s_23_9: write-var u#33432 <= s_23_8
        fn_state.u_33432 = s_23_8;
        // C s_23_10: const #16s : i
        let s_23_10: i128 = 16;
        // C s_23_11: const #4s : i
        let s_23_11: i128 = 4;
        // D s_23_12: read-var u#33431:u32
        let s_23_12: u32 = fn_state.u_33431;
        // D s_23_13: cast zx s_23_12 -> bv
        let s_23_13: Bits = Bits::new(s_23_12 as u128, 32u16);
        // D s_23_14: bit-extract s_23_13 s_23_10 s_23_11
        let s_23_14: Bits = (Bits::new(
            ((s_23_13) >> (s_23_10)).value(),
            u16::try_from(s_23_11).unwrap(),
        ));
        // D s_23_15: cast reint s_23_14 -> u8
        let s_23_15: u8 = (s_23_14.value() as u8);
        // D s_23_16: write-var u#33433 <= s_23_15
        fn_state.u_33433 = s_23_15;
        // C s_23_17: const #12s : i
        let s_23_17: i128 = 12;
        // C s_23_18: const #4s : i
        let s_23_18: i128 = 4;
        // D s_23_19: read-var u#33431:u32
        let s_23_19: u32 = fn_state.u_33431;
        // D s_23_20: cast zx s_23_19 -> bv
        let s_23_20: Bits = Bits::new(s_23_19 as u128, 32u16);
        // D s_23_21: bit-extract s_23_20 s_23_17 s_23_18
        let s_23_21: Bits = (Bits::new(
            ((s_23_20) >> (s_23_17)).value(),
            u16::try_from(s_23_18).unwrap(),
        ));
        // D s_23_22: cast reint s_23_21 -> u8
        let s_23_22: u8 = (s_23_21.value() as u8);
        // D s_23_23: write-var u#33434 <= s_23_22
        fn_state.u_33434 = s_23_22;
        // C s_23_24: const #0s : i
        let s_23_24: i128 = 0;
        // C s_23_25: const #4s : i
        let s_23_25: i128 = 4;
        // D s_23_26: read-var u#33431:u32
        let s_23_26: u32 = fn_state.u_33431;
        // D s_23_27: cast zx s_23_26 -> bv
        let s_23_27: Bits = Bits::new(s_23_26 as u128, 32u16);
        // D s_23_28: bit-extract s_23_27 s_23_24 s_23_25
        let s_23_28: Bits = (Bits::new(
            ((s_23_27) >> (s_23_24)).value(),
            u16::try_from(s_23_25).unwrap(),
        ));
        // D s_23_29: cast reint s_23_28 -> u8
        let s_23_29: u8 = (s_23_28.value() as u8);
        // D s_23_30: write-var u#33435 <= s_23_29
        fn_state.u_33435 = s_23_29;
        // C s_23_31: const #8s : i
        let s_23_31: i128 = 8;
        // D s_23_32: read-var u#33431:u32
        let s_23_32: u32 = fn_state.u_33431;
        // D s_23_33: cast zx s_23_32 -> bv
        let s_23_33: Bits = Bits::new(s_23_32 as u128, 32u16);
        // C s_23_34: const #1u : u64
        let s_23_34: u64 = 1;
        // D s_23_35: bit-extract s_23_33 s_23_31 s_23_34
        let s_23_35: Bits = (Bits::new(
            ((s_23_33) >> (s_23_31)).value(),
            u16::try_from(s_23_34).unwrap(),
        ));
        // D s_23_36: cast reint s_23_35 -> u8
        let s_23_36: bool = ((s_23_35.value()) != 0);
        // C s_23_37: const #0s : i
        let s_23_37: i128 = 0;
        // C s_23_38: const #0u : u64
        let s_23_38: u64 = 0;
        // D s_23_39: cast zx s_23_36 -> u64
        let s_23_39: u64 = (s_23_36 as u64);
        // C s_23_40: const #1u : u64
        let s_23_40: u64 = 1;
        // D s_23_41: and s_23_39 s_23_40
        let s_23_41: u64 = ((s_23_39) & (s_23_40));
        // D s_23_42: cmp-eq s_23_41 s_23_40
        let s_23_42: bool = ((s_23_41) == (s_23_40));
        // D s_23_43: lsl s_23_39 s_23_37
        let s_23_43: u64 = s_23_39 << s_23_37;
        // D s_23_44: or s_23_38 s_23_43
        let s_23_44: u64 = ((s_23_38) | (s_23_43));
        // D s_23_45: cmpl s_23_43
        let s_23_45: u64 = !s_23_43;
        // D s_23_46: and s_23_38 s_23_45
        let s_23_46: u64 = ((s_23_38) & (s_23_45));
        // D s_23_47: select s_23_42 s_23_44 s_23_46
        let s_23_47: u64 = if s_23_42 { s_23_44 } else { s_23_46 };
        // D s_23_48: cast trunc s_23_47 -> u8
        let s_23_48: bool = ((s_23_47) != 0);
        // D s_23_49: cast zx s_23_48 -> bv
        let s_23_49: Bits = Bits::new(s_23_48 as u128, 1u16);
        // C s_23_50: const #1u : u8
        let s_23_50: bool = true;
        // C s_23_51: cast zx s_23_50 -> bv
        let s_23_51: Bits = Bits::new(s_23_50 as u128, 1u16);
        // D s_23_52: cmp-ne s_23_49 s_23_51
        let s_23_52: bool = ((s_23_49) != (s_23_51));
        // N s_23_53: branch s_23_52 b34 b24
        if s_23_52 {
            return block_34(state, tracer, fn_state);
        } else {
            return block_24(state, tracer, fn_state);
        };
    }
    fn block_24<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_24_0: const #9s : i
        let s_24_0: i128 = 9;
        // D s_24_1: read-var u#33431:u32
        let s_24_1: u32 = fn_state.u_33431;
        // D s_24_2: cast zx s_24_1 -> bv
        let s_24_2: Bits = Bits::new(s_24_1 as u128, 32u16);
        // C s_24_3: const #1u : u64
        let s_24_3: u64 = 1;
        // D s_24_4: bit-extract s_24_2 s_24_0 s_24_3
        let s_24_4: Bits = (Bits::new(
            ((s_24_2) >> (s_24_0)).value(),
            u16::try_from(s_24_3).unwrap(),
        ));
        // D s_24_5: cast reint s_24_4 -> u8
        let s_24_5: bool = ((s_24_4.value()) != 0);
        // C s_24_6: const #0s : i
        let s_24_6: i128 = 0;
        // C s_24_7: const #0u : u64
        let s_24_7: u64 = 0;
        // D s_24_8: cast zx s_24_5 -> u64
        let s_24_8: u64 = (s_24_5 as u64);
        // C s_24_9: const #1u : u64
        let s_24_9: u64 = 1;
        // D s_24_10: and s_24_8 s_24_9
        let s_24_10: u64 = ((s_24_8) & (s_24_9));
        // D s_24_11: cmp-eq s_24_10 s_24_9
        let s_24_11: bool = ((s_24_10) == (s_24_9));
        // D s_24_12: lsl s_24_8 s_24_6
        let s_24_12: u64 = s_24_8 << s_24_6;
        // D s_24_13: or s_24_7 s_24_12
        let s_24_13: u64 = ((s_24_7) | (s_24_12));
        // D s_24_14: cmpl s_24_12
        let s_24_14: u64 = !s_24_12;
        // D s_24_15: and s_24_7 s_24_14
        let s_24_15: u64 = ((s_24_7) & (s_24_14));
        // D s_24_16: select s_24_11 s_24_13 s_24_15
        let s_24_16: u64 = if s_24_11 { s_24_13 } else { s_24_15 };
        // D s_24_17: cast trunc s_24_16 -> u8
        let s_24_17: bool = ((s_24_16) != 0);
        // D s_24_18: cast zx s_24_17 -> bv
        let s_24_18: Bits = Bits::new(s_24_17 as u128, 1u16);
        // C s_24_19: const #1u : u8
        let s_24_19: bool = true;
        // C s_24_20: cast zx s_24_19 -> bv
        let s_24_20: Bits = Bits::new(s_24_19 as u128, 1u16);
        // D s_24_21: cmp-ne s_24_18 s_24_20
        let s_24_21: bool = ((s_24_18) != (s_24_20));
        // D s_24_22: write-var gs#409185 <= s_24_21
        fn_state.gs_409185 = s_24_21;
        // N s_24_23: jump b25
        return block_25(state, tracer, fn_state);
    }
    fn block_25<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_25_0: read-var gs#409185:u8
        let s_25_0: bool = fn_state.gs_409185;
        // N s_25_1: branch s_25_0 b33 b26
        if s_25_0 {
            return block_33(state, tracer, fn_state);
        } else {
            return block_26(state, tracer, fn_state);
        };
    }
    fn block_26<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_26_0: const #10s : i
        let s_26_0: i128 = 10;
        // D s_26_1: read-var u#33431:u32
        let s_26_1: u32 = fn_state.u_33431;
        // D s_26_2: cast zx s_26_1 -> bv
        let s_26_2: Bits = Bits::new(s_26_1 as u128, 32u16);
        // C s_26_3: const #1u : u64
        let s_26_3: u64 = 1;
        // D s_26_4: bit-extract s_26_2 s_26_0 s_26_3
        let s_26_4: Bits = (Bits::new(
            ((s_26_2) >> (s_26_0)).value(),
            u16::try_from(s_26_3).unwrap(),
        ));
        // D s_26_5: cast reint s_26_4 -> u8
        let s_26_5: bool = ((s_26_4.value()) != 0);
        // C s_26_6: const #0s : i
        let s_26_6: i128 = 0;
        // C s_26_7: const #0u : u64
        let s_26_7: u64 = 0;
        // D s_26_8: cast zx s_26_5 -> u64
        let s_26_8: u64 = (s_26_5 as u64);
        // C s_26_9: const #1u : u64
        let s_26_9: u64 = 1;
        // D s_26_10: and s_26_8 s_26_9
        let s_26_10: u64 = ((s_26_8) & (s_26_9));
        // D s_26_11: cmp-eq s_26_10 s_26_9
        let s_26_11: bool = ((s_26_10) == (s_26_9));
        // D s_26_12: lsl s_26_8 s_26_6
        let s_26_12: u64 = s_26_8 << s_26_6;
        // D s_26_13: or s_26_7 s_26_12
        let s_26_13: u64 = ((s_26_7) | (s_26_12));
        // D s_26_14: cmpl s_26_12
        let s_26_14: u64 = !s_26_12;
        // D s_26_15: and s_26_7 s_26_14
        let s_26_15: u64 = ((s_26_7) & (s_26_14));
        // D s_26_16: select s_26_11 s_26_13 s_26_15
        let s_26_16: u64 = if s_26_11 { s_26_13 } else { s_26_15 };
        // D s_26_17: cast trunc s_26_16 -> u8
        let s_26_17: bool = ((s_26_16) != 0);
        // D s_26_18: cast zx s_26_17 -> bv
        let s_26_18: Bits = Bits::new(s_26_17 as u128, 1u16);
        // C s_26_19: const #1u : u8
        let s_26_19: bool = true;
        // C s_26_20: cast zx s_26_19 -> bv
        let s_26_20: Bits = Bits::new(s_26_19 as u128, 1u16);
        // D s_26_21: cmp-ne s_26_18 s_26_20
        let s_26_21: bool = ((s_26_18) != (s_26_20));
        // D s_26_22: write-var gs#409188 <= s_26_21
        fn_state.gs_409188 = s_26_21;
        // N s_26_23: jump b27
        return block_27(state, tracer, fn_state);
    }
    fn block_27<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_27_0: read-var gs#409188:u8
        let s_27_0: bool = fn_state.gs_409188;
        // N s_27_1: branch s_27_0 b32 b28
        if s_27_0 {
            return block_32(state, tracer, fn_state);
        } else {
            return block_28(state, tracer, fn_state);
        };
    }
    fn block_28<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_28_0: const #11s : i
        let s_28_0: i128 = 11;
        // D s_28_1: read-var u#33431:u32
        let s_28_1: u32 = fn_state.u_33431;
        // D s_28_2: cast zx s_28_1 -> bv
        let s_28_2: Bits = Bits::new(s_28_1 as u128, 32u16);
        // C s_28_3: const #1u : u64
        let s_28_3: u64 = 1;
        // D s_28_4: bit-extract s_28_2 s_28_0 s_28_3
        let s_28_4: Bits = (Bits::new(
            ((s_28_2) >> (s_28_0)).value(),
            u16::try_from(s_28_3).unwrap(),
        ));
        // D s_28_5: cast reint s_28_4 -> u8
        let s_28_5: bool = ((s_28_4.value()) != 0);
        // C s_28_6: const #0s : i
        let s_28_6: i128 = 0;
        // C s_28_7: const #0u : u64
        let s_28_7: u64 = 0;
        // D s_28_8: cast zx s_28_5 -> u64
        let s_28_8: u64 = (s_28_5 as u64);
        // C s_28_9: const #1u : u64
        let s_28_9: u64 = 1;
        // D s_28_10: and s_28_8 s_28_9
        let s_28_10: u64 = ((s_28_8) & (s_28_9));
        // D s_28_11: cmp-eq s_28_10 s_28_9
        let s_28_11: bool = ((s_28_10) == (s_28_9));
        // D s_28_12: lsl s_28_8 s_28_6
        let s_28_12: u64 = s_28_8 << s_28_6;
        // D s_28_13: or s_28_7 s_28_12
        let s_28_13: u64 = ((s_28_7) | (s_28_12));
        // D s_28_14: cmpl s_28_12
        let s_28_14: u64 = !s_28_12;
        // D s_28_15: and s_28_7 s_28_14
        let s_28_15: u64 = ((s_28_7) & (s_28_14));
        // D s_28_16: select s_28_11 s_28_13 s_28_15
        let s_28_16: u64 = if s_28_11 { s_28_13 } else { s_28_15 };
        // D s_28_17: cast trunc s_28_16 -> u8
        let s_28_17: bool = ((s_28_16) != 0);
        // D s_28_18: cast zx s_28_17 -> bv
        let s_28_18: Bits = Bits::new(s_28_17 as u128, 1u16);
        // C s_28_19: const #1u : u8
        let s_28_19: bool = true;
        // C s_28_20: cast zx s_28_19 -> bv
        let s_28_20: Bits = Bits::new(s_28_19 as u128, 1u16);
        // D s_28_21: cmp-ne s_28_18 s_28_20
        let s_28_21: bool = ((s_28_18) != (s_28_20));
        // D s_28_22: write-var gs#409191 <= s_28_21
        fn_state.gs_409191 = s_28_21;
        // N s_28_23: jump b29
        return block_29(state, tracer, fn_state);
    }
    fn block_29<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_29_0: read-var gs#409191:u8
        let s_29_0: bool = fn_state.gs_409191;
        // N s_29_1: branch s_29_0 b31 b30
        if s_29_0 {
            return block_31(state, tracer, fn_state);
        } else {
            return block_30(state, tracer, fn_state);
        };
    }
    fn block_30<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_30_0: read-var u#33432:u8
        let s_30_0: u8 = fn_state.u_33432;
        // D s_30_1: read-var u#33433:u8
        let s_30_1: u8 = fn_state.u_33433;
        // D s_30_2: read-var u#33434:u8
        let s_30_2: u8 = fn_state.u_33434;
        // D s_30_3: read-var u#33435:u8
        let s_30_3: u8 = fn_state.u_33435;
        // D s_30_4: call decode_aarch32_instrs_QADD16_A1enc_A_txt(s_30_0, s_30_1, s_30_2, s_30_3)
        let s_30_4: () = decode_aarch32_instrs_QADD16_A1enc_A_txt(
            state,
            tracer,
            s_30_0,
            s_30_1,
            s_30_2,
            s_30_3,
        );
        // N s_30_5: return
        return;
    }
    fn block_31<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_31_0: panic
        panic!("{:?}", ());
        // N s_31_1: return
        return;
    }
    fn block_32<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_32_0: const #1u : u8
        let s_32_0: bool = true;
        // D s_32_1: write-var gs#409191 <= s_32_0
        fn_state.gs_409191 = s_32_0;
        // N s_32_2: jump b29
        return block_29(state, tracer, fn_state);
    }
    fn block_33<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_33_0: const #1u : u8
        let s_33_0: bool = true;
        // D s_33_1: write-var gs#409188 <= s_33_0
        fn_state.gs_409188 = s_33_0;
        // N s_33_2: jump b27
        return block_27(state, tracer, fn_state);
    }
    fn block_34<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_34_0: const #1u : u8
        let s_34_0: bool = true;
        // D s_34_1: write-var gs#409185 <= s_34_0
        fn_state.gs_409185 = s_34_0;
        // N s_34_2: jump b25
        return block_25(state, tracer, fn_state);
    }
    fn block_35<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_35_0: read-var merge#var.1:struct
        let s_35_0: u32 = fn_state.merge_var._1;
        // D s_35_1: write-var u#33437 <= s_35_0
        fn_state.u_33437 = s_35_0;
        // C s_35_2: const #20s : i
        let s_35_2: i128 = 20;
        // D s_35_3: read-var u#33437:u32
        let s_35_3: u32 = fn_state.u_33437;
        // D s_35_4: cast zx s_35_3 -> bv
        let s_35_4: Bits = Bits::new(s_35_3 as u128, 32u16);
        // C s_35_5: const #1s : i64
        let s_35_5: i64 = 1;
        // C s_35_6: cast zx s_35_5 -> i
        let s_35_6: i128 = (i128::try_from(s_35_5).unwrap());
        // C s_35_7: const #7s : i
        let s_35_7: i128 = 7;
        // C s_35_8: add s_35_7 s_35_6
        let s_35_8: i128 = (s_35_7 + s_35_6);
        // D s_35_9: bit-extract s_35_4 s_35_2 s_35_8
        let s_35_9: Bits = (Bits::new(
            ((s_35_4) >> (s_35_2)).value(),
            u16::try_from(s_35_8).unwrap(),
        ));
        // D s_35_10: cast reint s_35_9 -> u8
        let s_35_10: u8 = (s_35_9.value() as u8);
        // D s_35_11: cast zx s_35_10 -> bv
        let s_35_11: Bits = Bits::new(s_35_10 as u128, 8u16);
        // C s_35_12: const #98u : u8
        let s_35_12: u8 = 98;
        // C s_35_13: cast zx s_35_12 -> bv
        let s_35_13: Bits = Bits::new(s_35_12 as u128, 8u16);
        // D s_35_14: cmp-eq s_35_11 s_35_13
        let s_35_14: bool = ((s_35_11) == (s_35_13));
        // N s_35_15: branch s_35_14 b1433 b36
        if s_35_14 {
            return block_1433(state, tracer, fn_state);
        } else {
            return block_36(state, tracer, fn_state);
        };
    }
    fn block_36<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_36_0: const #0u : u8
        let s_36_0: bool = false;
        // D s_36_1: write-var gs#409197 <= s_36_0
        fn_state.gs_409197 = s_36_0;
        // N s_36_2: jump b37
        return block_37(state, tracer, fn_state);
    }
    fn block_37<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_37_0: read-var gs#409197:u8
        let s_37_0: bool = fn_state.gs_409197;
        // N s_37_1: branch s_37_0 b1429 b38
        if s_37_0 {
            return block_1429(state, tracer, fn_state);
        } else {
            return block_38(state, tracer, fn_state);
        };
    }
    fn block_38<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_38_0: const #0u : u8
        let s_38_0: bool = false;
        // D s_38_1: write-var gs#409202 <= s_38_0
        fn_state.gs_409202 = s_38_0;
        // N s_38_2: jump b39
        return block_39(state, tracer, fn_state);
    }
    fn block_39<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_39_0: read-var gs#409202:u8
        let s_39_0: bool = fn_state.gs_409202;
        // D s_39_1: not s_39_0
        let s_39_1: bool = !s_39_0;
        // N s_39_2: branch s_39_1 b52 b40
        if s_39_1 {
            return block_52(state, tracer, fn_state);
        } else {
            return block_40(state, tracer, fn_state);
        };
    }
    fn block_40<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_40_0: const #3066s : i
        let s_40_0: i128 = 3066;
        // C s_40_1: const #14696u : u32
        let s_40_1: u32 = 14696;
        // N s_40_2: write-reg s_40_1 <= s_40_0
        let s_40_2: () = {
            state.write_register::<i128>(s_40_1 as isize, s_40_0);
            tracer.write_register(s_40_1 as isize, s_40_0);
        };
        // C s_40_3: const #28s : i
        let s_40_3: i128 = 28;
        // C s_40_4: const #4s : i
        let s_40_4: i128 = 4;
        // D s_40_5: read-var u#33437:u32
        let s_40_5: u32 = fn_state.u_33437;
        // D s_40_6: cast zx s_40_5 -> bv
        let s_40_6: Bits = Bits::new(s_40_5 as u128, 32u16);
        // D s_40_7: bit-extract s_40_6 s_40_3 s_40_4
        let s_40_7: Bits = (Bits::new(
            ((s_40_6) >> (s_40_3)).value(),
            u16::try_from(s_40_4).unwrap(),
        ));
        // D s_40_8: cast reint s_40_7 -> u8
        let s_40_8: u8 = (s_40_7.value() as u8);
        // D s_40_9: write-var u#33438 <= s_40_8
        fn_state.u_33438 = s_40_8;
        // C s_40_10: const #16s : i
        let s_40_10: i128 = 16;
        // C s_40_11: const #4s : i
        let s_40_11: i128 = 4;
        // D s_40_12: read-var u#33437:u32
        let s_40_12: u32 = fn_state.u_33437;
        // D s_40_13: cast zx s_40_12 -> bv
        let s_40_13: Bits = Bits::new(s_40_12 as u128, 32u16);
        // D s_40_14: bit-extract s_40_13 s_40_10 s_40_11
        let s_40_14: Bits = (Bits::new(
            ((s_40_13) >> (s_40_10)).value(),
            u16::try_from(s_40_11).unwrap(),
        ));
        // D s_40_15: cast reint s_40_14 -> u8
        let s_40_15: u8 = (s_40_14.value() as u8);
        // D s_40_16: write-var u#33439 <= s_40_15
        fn_state.u_33439 = s_40_15;
        // C s_40_17: const #12s : i
        let s_40_17: i128 = 12;
        // C s_40_18: const #4s : i
        let s_40_18: i128 = 4;
        // D s_40_19: read-var u#33437:u32
        let s_40_19: u32 = fn_state.u_33437;
        // D s_40_20: cast zx s_40_19 -> bv
        let s_40_20: Bits = Bits::new(s_40_19 as u128, 32u16);
        // D s_40_21: bit-extract s_40_20 s_40_17 s_40_18
        let s_40_21: Bits = (Bits::new(
            ((s_40_20) >> (s_40_17)).value(),
            u16::try_from(s_40_18).unwrap(),
        ));
        // D s_40_22: cast reint s_40_21 -> u8
        let s_40_22: u8 = (s_40_21.value() as u8);
        // D s_40_23: write-var u#33440 <= s_40_22
        fn_state.u_33440 = s_40_22;
        // C s_40_24: const #0s : i
        let s_40_24: i128 = 0;
        // C s_40_25: const #4s : i
        let s_40_25: i128 = 4;
        // D s_40_26: read-var u#33437:u32
        let s_40_26: u32 = fn_state.u_33437;
        // D s_40_27: cast zx s_40_26 -> bv
        let s_40_27: Bits = Bits::new(s_40_26 as u128, 32u16);
        // D s_40_28: bit-extract s_40_27 s_40_24 s_40_25
        let s_40_28: Bits = (Bits::new(
            ((s_40_27) >> (s_40_24)).value(),
            u16::try_from(s_40_25).unwrap(),
        ));
        // D s_40_29: cast reint s_40_28 -> u8
        let s_40_29: u8 = (s_40_28.value() as u8);
        // D s_40_30: write-var u#33441 <= s_40_29
        fn_state.u_33441 = s_40_29;
        // C s_40_31: const #8s : i
        let s_40_31: i128 = 8;
        // D s_40_32: read-var u#33437:u32
        let s_40_32: u32 = fn_state.u_33437;
        // D s_40_33: cast zx s_40_32 -> bv
        let s_40_33: Bits = Bits::new(s_40_32 as u128, 32u16);
        // C s_40_34: const #1u : u64
        let s_40_34: u64 = 1;
        // D s_40_35: bit-extract s_40_33 s_40_31 s_40_34
        let s_40_35: Bits = (Bits::new(
            ((s_40_33) >> (s_40_31)).value(),
            u16::try_from(s_40_34).unwrap(),
        ));
        // D s_40_36: cast reint s_40_35 -> u8
        let s_40_36: bool = ((s_40_35.value()) != 0);
        // C s_40_37: const #0s : i
        let s_40_37: i128 = 0;
        // C s_40_38: const #0u : u64
        let s_40_38: u64 = 0;
        // D s_40_39: cast zx s_40_36 -> u64
        let s_40_39: u64 = (s_40_36 as u64);
        // C s_40_40: const #1u : u64
        let s_40_40: u64 = 1;
        // D s_40_41: and s_40_39 s_40_40
        let s_40_41: u64 = ((s_40_39) & (s_40_40));
        // D s_40_42: cmp-eq s_40_41 s_40_40
        let s_40_42: bool = ((s_40_41) == (s_40_40));
        // D s_40_43: lsl s_40_39 s_40_37
        let s_40_43: u64 = s_40_39 << s_40_37;
        // D s_40_44: or s_40_38 s_40_43
        let s_40_44: u64 = ((s_40_38) | (s_40_43));
        // D s_40_45: cmpl s_40_43
        let s_40_45: u64 = !s_40_43;
        // D s_40_46: and s_40_38 s_40_45
        let s_40_46: u64 = ((s_40_38) & (s_40_45));
        // D s_40_47: select s_40_42 s_40_44 s_40_46
        let s_40_47: u64 = if s_40_42 { s_40_44 } else { s_40_46 };
        // D s_40_48: cast trunc s_40_47 -> u8
        let s_40_48: bool = ((s_40_47) != 0);
        // D s_40_49: cast zx s_40_48 -> bv
        let s_40_49: Bits = Bits::new(s_40_48 as u128, 1u16);
        // C s_40_50: const #1u : u8
        let s_40_50: bool = true;
        // C s_40_51: cast zx s_40_50 -> bv
        let s_40_51: Bits = Bits::new(s_40_50 as u128, 1u16);
        // D s_40_52: cmp-ne s_40_49 s_40_51
        let s_40_52: bool = ((s_40_49) != (s_40_51));
        // N s_40_53: branch s_40_52 b51 b41
        if s_40_52 {
            return block_51(state, tracer, fn_state);
        } else {
            return block_41(state, tracer, fn_state);
        };
    }
    fn block_41<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_41_0: const #9s : i
        let s_41_0: i128 = 9;
        // D s_41_1: read-var u#33437:u32
        let s_41_1: u32 = fn_state.u_33437;
        // D s_41_2: cast zx s_41_1 -> bv
        let s_41_2: Bits = Bits::new(s_41_1 as u128, 32u16);
        // C s_41_3: const #1u : u64
        let s_41_3: u64 = 1;
        // D s_41_4: bit-extract s_41_2 s_41_0 s_41_3
        let s_41_4: Bits = (Bits::new(
            ((s_41_2) >> (s_41_0)).value(),
            u16::try_from(s_41_3).unwrap(),
        ));
        // D s_41_5: cast reint s_41_4 -> u8
        let s_41_5: bool = ((s_41_4.value()) != 0);
        // C s_41_6: const #0s : i
        let s_41_6: i128 = 0;
        // C s_41_7: const #0u : u64
        let s_41_7: u64 = 0;
        // D s_41_8: cast zx s_41_5 -> u64
        let s_41_8: u64 = (s_41_5 as u64);
        // C s_41_9: const #1u : u64
        let s_41_9: u64 = 1;
        // D s_41_10: and s_41_8 s_41_9
        let s_41_10: u64 = ((s_41_8) & (s_41_9));
        // D s_41_11: cmp-eq s_41_10 s_41_9
        let s_41_11: bool = ((s_41_10) == (s_41_9));
        // D s_41_12: lsl s_41_8 s_41_6
        let s_41_12: u64 = s_41_8 << s_41_6;
        // D s_41_13: or s_41_7 s_41_12
        let s_41_13: u64 = ((s_41_7) | (s_41_12));
        // D s_41_14: cmpl s_41_12
        let s_41_14: u64 = !s_41_12;
        // D s_41_15: and s_41_7 s_41_14
        let s_41_15: u64 = ((s_41_7) & (s_41_14));
        // D s_41_16: select s_41_11 s_41_13 s_41_15
        let s_41_16: u64 = if s_41_11 { s_41_13 } else { s_41_15 };
        // D s_41_17: cast trunc s_41_16 -> u8
        let s_41_17: bool = ((s_41_16) != 0);
        // D s_41_18: cast zx s_41_17 -> bv
        let s_41_18: Bits = Bits::new(s_41_17 as u128, 1u16);
        // C s_41_19: const #1u : u8
        let s_41_19: bool = true;
        // C s_41_20: cast zx s_41_19 -> bv
        let s_41_20: Bits = Bits::new(s_41_19 as u128, 1u16);
        // D s_41_21: cmp-ne s_41_18 s_41_20
        let s_41_21: bool = ((s_41_18) != (s_41_20));
        // D s_41_22: write-var gs#409217 <= s_41_21
        fn_state.gs_409217 = s_41_21;
        // N s_41_23: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_42<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_42_0: read-var gs#409217:u8
        let s_42_0: bool = fn_state.gs_409217;
        // N s_42_1: branch s_42_0 b50 b43
        if s_42_0 {
            return block_50(state, tracer, fn_state);
        } else {
            return block_43(state, tracer, fn_state);
        };
    }
    fn block_43<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_43_0: const #10s : i
        let s_43_0: i128 = 10;
        // D s_43_1: read-var u#33437:u32
        let s_43_1: u32 = fn_state.u_33437;
        // D s_43_2: cast zx s_43_1 -> bv
        let s_43_2: Bits = Bits::new(s_43_1 as u128, 32u16);
        // C s_43_3: const #1u : u64
        let s_43_3: u64 = 1;
        // D s_43_4: bit-extract s_43_2 s_43_0 s_43_3
        let s_43_4: Bits = (Bits::new(
            ((s_43_2) >> (s_43_0)).value(),
            u16::try_from(s_43_3).unwrap(),
        ));
        // D s_43_5: cast reint s_43_4 -> u8
        let s_43_5: bool = ((s_43_4.value()) != 0);
        // C s_43_6: const #0s : i
        let s_43_6: i128 = 0;
        // C s_43_7: const #0u : u64
        let s_43_7: u64 = 0;
        // D s_43_8: cast zx s_43_5 -> u64
        let s_43_8: u64 = (s_43_5 as u64);
        // C s_43_9: const #1u : u64
        let s_43_9: u64 = 1;
        // D s_43_10: and s_43_8 s_43_9
        let s_43_10: u64 = ((s_43_8) & (s_43_9));
        // D s_43_11: cmp-eq s_43_10 s_43_9
        let s_43_11: bool = ((s_43_10) == (s_43_9));
        // D s_43_12: lsl s_43_8 s_43_6
        let s_43_12: u64 = s_43_8 << s_43_6;
        // D s_43_13: or s_43_7 s_43_12
        let s_43_13: u64 = ((s_43_7) | (s_43_12));
        // D s_43_14: cmpl s_43_12
        let s_43_14: u64 = !s_43_12;
        // D s_43_15: and s_43_7 s_43_14
        let s_43_15: u64 = ((s_43_7) & (s_43_14));
        // D s_43_16: select s_43_11 s_43_13 s_43_15
        let s_43_16: u64 = if s_43_11 { s_43_13 } else { s_43_15 };
        // D s_43_17: cast trunc s_43_16 -> u8
        let s_43_17: bool = ((s_43_16) != 0);
        // D s_43_18: cast zx s_43_17 -> bv
        let s_43_18: Bits = Bits::new(s_43_17 as u128, 1u16);
        // C s_43_19: const #1u : u8
        let s_43_19: bool = true;
        // C s_43_20: cast zx s_43_19 -> bv
        let s_43_20: Bits = Bits::new(s_43_19 as u128, 1u16);
        // D s_43_21: cmp-ne s_43_18 s_43_20
        let s_43_21: bool = ((s_43_18) != (s_43_20));
        // D s_43_22: write-var gs#409220 <= s_43_21
        fn_state.gs_409220 = s_43_21;
        // N s_43_23: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_44<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_44_0: read-var gs#409220:u8
        let s_44_0: bool = fn_state.gs_409220;
        // N s_44_1: branch s_44_0 b49 b45
        if s_44_0 {
            return block_49(state, tracer, fn_state);
        } else {
            return block_45(state, tracer, fn_state);
        };
    }
    fn block_45<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_45_0: const #11s : i
        let s_45_0: i128 = 11;
        // D s_45_1: read-var u#33437:u32
        let s_45_1: u32 = fn_state.u_33437;
        // D s_45_2: cast zx s_45_1 -> bv
        let s_45_2: Bits = Bits::new(s_45_1 as u128, 32u16);
        // C s_45_3: const #1u : u64
        let s_45_3: u64 = 1;
        // D s_45_4: bit-extract s_45_2 s_45_0 s_45_3
        let s_45_4: Bits = (Bits::new(
            ((s_45_2) >> (s_45_0)).value(),
            u16::try_from(s_45_3).unwrap(),
        ));
        // D s_45_5: cast reint s_45_4 -> u8
        let s_45_5: bool = ((s_45_4.value()) != 0);
        // C s_45_6: const #0s : i
        let s_45_6: i128 = 0;
        // C s_45_7: const #0u : u64
        let s_45_7: u64 = 0;
        // D s_45_8: cast zx s_45_5 -> u64
        let s_45_8: u64 = (s_45_5 as u64);
        // C s_45_9: const #1u : u64
        let s_45_9: u64 = 1;
        // D s_45_10: and s_45_8 s_45_9
        let s_45_10: u64 = ((s_45_8) & (s_45_9));
        // D s_45_11: cmp-eq s_45_10 s_45_9
        let s_45_11: bool = ((s_45_10) == (s_45_9));
        // D s_45_12: lsl s_45_8 s_45_6
        let s_45_12: u64 = s_45_8 << s_45_6;
        // D s_45_13: or s_45_7 s_45_12
        let s_45_13: u64 = ((s_45_7) | (s_45_12));
        // D s_45_14: cmpl s_45_12
        let s_45_14: u64 = !s_45_12;
        // D s_45_15: and s_45_7 s_45_14
        let s_45_15: u64 = ((s_45_7) & (s_45_14));
        // D s_45_16: select s_45_11 s_45_13 s_45_15
        let s_45_16: u64 = if s_45_11 { s_45_13 } else { s_45_15 };
        // D s_45_17: cast trunc s_45_16 -> u8
        let s_45_17: bool = ((s_45_16) != 0);
        // D s_45_18: cast zx s_45_17 -> bv
        let s_45_18: Bits = Bits::new(s_45_17 as u128, 1u16);
        // C s_45_19: const #1u : u8
        let s_45_19: bool = true;
        // C s_45_20: cast zx s_45_19 -> bv
        let s_45_20: Bits = Bits::new(s_45_19 as u128, 1u16);
        // D s_45_21: cmp-ne s_45_18 s_45_20
        let s_45_21: bool = ((s_45_18) != (s_45_20));
        // D s_45_22: write-var gs#409223 <= s_45_21
        fn_state.gs_409223 = s_45_21;
        // N s_45_23: jump b46
        return block_46(state, tracer, fn_state);
    }
    fn block_46<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_46_0: read-var gs#409223:u8
        let s_46_0: bool = fn_state.gs_409223;
        // N s_46_1: branch s_46_0 b48 b47
        if s_46_0 {
            return block_48(state, tracer, fn_state);
        } else {
            return block_47(state, tracer, fn_state);
        };
    }
    fn block_47<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_47_0: read-var u#33438:u8
        let s_47_0: u8 = fn_state.u_33438;
        // D s_47_1: read-var u#33439:u8
        let s_47_1: u8 = fn_state.u_33439;
        // D s_47_2: read-var u#33440:u8
        let s_47_2: u8 = fn_state.u_33440;
        // D s_47_3: read-var u#33441:u8
        let s_47_3: u8 = fn_state.u_33441;
        // D s_47_4: call decode_aarch32_instrs_QADD8_A1enc_A_txt(s_47_0, s_47_1, s_47_2, s_47_3)
        let s_47_4: () = decode_aarch32_instrs_QADD8_A1enc_A_txt(
            state,
            tracer,
            s_47_0,
            s_47_1,
            s_47_2,
            s_47_3,
        );
        // N s_47_5: return
        return;
    }
    fn block_48<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_48_0: panic
        panic!("{:?}", ());
        // N s_48_1: return
        return;
    }
    fn block_49<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_49_0: const #1u : u8
        let s_49_0: bool = true;
        // D s_49_1: write-var gs#409223 <= s_49_0
        fn_state.gs_409223 = s_49_0;
        // N s_49_2: jump b46
        return block_46(state, tracer, fn_state);
    }
    fn block_50<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_50_0: const #1u : u8
        let s_50_0: bool = true;
        // D s_50_1: write-var gs#409220 <= s_50_0
        fn_state.gs_409220 = s_50_0;
        // N s_50_2: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_51<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_51_0: const #1u : u8
        let s_51_0: bool = true;
        // D s_51_1: write-var gs#409217 <= s_51_0
        fn_state.gs_409217 = s_51_0;
        // N s_51_2: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_52<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_52_0: read-var merge#var.1:struct
        let s_52_0: u32 = fn_state.merge_var._1;
        // D s_52_1: write-var u#33443 <= s_52_0
        fn_state.u_33443 = s_52_0;
        // C s_52_2: const #20s : i
        let s_52_2: i128 = 20;
        // D s_52_3: read-var u#33443:u32
        let s_52_3: u32 = fn_state.u_33443;
        // D s_52_4: cast zx s_52_3 -> bv
        let s_52_4: Bits = Bits::new(s_52_3 as u128, 32u16);
        // C s_52_5: const #1s : i64
        let s_52_5: i64 = 1;
        // C s_52_6: cast zx s_52_5 -> i
        let s_52_6: i128 = (i128::try_from(s_52_5).unwrap());
        // C s_52_7: const #7s : i
        let s_52_7: i128 = 7;
        // C s_52_8: add s_52_7 s_52_6
        let s_52_8: i128 = (s_52_7 + s_52_6);
        // D s_52_9: bit-extract s_52_4 s_52_2 s_52_8
        let s_52_9: Bits = (Bits::new(
            ((s_52_4) >> (s_52_2)).value(),
            u16::try_from(s_52_8).unwrap(),
        ));
        // D s_52_10: cast reint s_52_9 -> u8
        let s_52_10: u8 = (s_52_9.value() as u8);
        // D s_52_11: cast zx s_52_10 -> bv
        let s_52_11: Bits = Bits::new(s_52_10 as u128, 8u16);
        // C s_52_12: const #98u : u8
        let s_52_12: u8 = 98;
        // C s_52_13: cast zx s_52_12 -> bv
        let s_52_13: Bits = Bits::new(s_52_12 as u128, 8u16);
        // D s_52_14: cmp-eq s_52_11 s_52_13
        let s_52_14: bool = ((s_52_11) == (s_52_13));
        // N s_52_15: branch s_52_14 b1428 b53
        if s_52_14 {
            return block_1428(state, tracer, fn_state);
        } else {
            return block_53(state, tracer, fn_state);
        };
    }
    fn block_53<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_53_0: const #0u : u8
        let s_53_0: bool = false;
        // D s_53_1: write-var gs#409229 <= s_53_0
        fn_state.gs_409229 = s_53_0;
        // N s_53_2: jump b54
        return block_54(state, tracer, fn_state);
    }
    fn block_54<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_54_0: read-var gs#409229:u8
        let s_54_0: bool = fn_state.gs_409229;
        // N s_54_1: branch s_54_0 b1424 b55
        if s_54_0 {
            return block_1424(state, tracer, fn_state);
        } else {
            return block_55(state, tracer, fn_state);
        };
    }
    fn block_55<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_55_0: const #0u : u8
        let s_55_0: bool = false;
        // D s_55_1: write-var gs#409234 <= s_55_0
        fn_state.gs_409234 = s_55_0;
        // N s_55_2: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_56<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_56_0: read-var gs#409234:u8
        let s_56_0: bool = fn_state.gs_409234;
        // D s_56_1: not s_56_0
        let s_56_1: bool = !s_56_0;
        // N s_56_2: branch s_56_1 b69 b57
        if s_56_1 {
            return block_69(state, tracer, fn_state);
        } else {
            return block_57(state, tracer, fn_state);
        };
    }
    fn block_57<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_57_0: const #3070s : i
        let s_57_0: i128 = 3070;
        // C s_57_1: const #14696u : u32
        let s_57_1: u32 = 14696;
        // N s_57_2: write-reg s_57_1 <= s_57_0
        let s_57_2: () = {
            state.write_register::<i128>(s_57_1 as isize, s_57_0);
            tracer.write_register(s_57_1 as isize, s_57_0);
        };
        // C s_57_3: const #28s : i
        let s_57_3: i128 = 28;
        // C s_57_4: const #4s : i
        let s_57_4: i128 = 4;
        // D s_57_5: read-var u#33443:u32
        let s_57_5: u32 = fn_state.u_33443;
        // D s_57_6: cast zx s_57_5 -> bv
        let s_57_6: Bits = Bits::new(s_57_5 as u128, 32u16);
        // D s_57_7: bit-extract s_57_6 s_57_3 s_57_4
        let s_57_7: Bits = (Bits::new(
            ((s_57_6) >> (s_57_3)).value(),
            u16::try_from(s_57_4).unwrap(),
        ));
        // D s_57_8: cast reint s_57_7 -> u8
        let s_57_8: u8 = (s_57_7.value() as u8);
        // D s_57_9: write-var u#33444 <= s_57_8
        fn_state.u_33444 = s_57_8;
        // C s_57_10: const #16s : i
        let s_57_10: i128 = 16;
        // C s_57_11: const #4s : i
        let s_57_11: i128 = 4;
        // D s_57_12: read-var u#33443:u32
        let s_57_12: u32 = fn_state.u_33443;
        // D s_57_13: cast zx s_57_12 -> bv
        let s_57_13: Bits = Bits::new(s_57_12 as u128, 32u16);
        // D s_57_14: bit-extract s_57_13 s_57_10 s_57_11
        let s_57_14: Bits = (Bits::new(
            ((s_57_13) >> (s_57_10)).value(),
            u16::try_from(s_57_11).unwrap(),
        ));
        // D s_57_15: cast reint s_57_14 -> u8
        let s_57_15: u8 = (s_57_14.value() as u8);
        // D s_57_16: write-var u#33445 <= s_57_15
        fn_state.u_33445 = s_57_15;
        // C s_57_17: const #12s : i
        let s_57_17: i128 = 12;
        // C s_57_18: const #4s : i
        let s_57_18: i128 = 4;
        // D s_57_19: read-var u#33443:u32
        let s_57_19: u32 = fn_state.u_33443;
        // D s_57_20: cast zx s_57_19 -> bv
        let s_57_20: Bits = Bits::new(s_57_19 as u128, 32u16);
        // D s_57_21: bit-extract s_57_20 s_57_17 s_57_18
        let s_57_21: Bits = (Bits::new(
            ((s_57_20) >> (s_57_17)).value(),
            u16::try_from(s_57_18).unwrap(),
        ));
        // D s_57_22: cast reint s_57_21 -> u8
        let s_57_22: u8 = (s_57_21.value() as u8);
        // D s_57_23: write-var u#33446 <= s_57_22
        fn_state.u_33446 = s_57_22;
        // C s_57_24: const #0s : i
        let s_57_24: i128 = 0;
        // C s_57_25: const #4s : i
        let s_57_25: i128 = 4;
        // D s_57_26: read-var u#33443:u32
        let s_57_26: u32 = fn_state.u_33443;
        // D s_57_27: cast zx s_57_26 -> bv
        let s_57_27: Bits = Bits::new(s_57_26 as u128, 32u16);
        // D s_57_28: bit-extract s_57_27 s_57_24 s_57_25
        let s_57_28: Bits = (Bits::new(
            ((s_57_27) >> (s_57_24)).value(),
            u16::try_from(s_57_25).unwrap(),
        ));
        // D s_57_29: cast reint s_57_28 -> u8
        let s_57_29: u8 = (s_57_28.value() as u8);
        // D s_57_30: write-var u#33447 <= s_57_29
        fn_state.u_33447 = s_57_29;
        // C s_57_31: const #8s : i
        let s_57_31: i128 = 8;
        // D s_57_32: read-var u#33443:u32
        let s_57_32: u32 = fn_state.u_33443;
        // D s_57_33: cast zx s_57_32 -> bv
        let s_57_33: Bits = Bits::new(s_57_32 as u128, 32u16);
        // C s_57_34: const #1u : u64
        let s_57_34: u64 = 1;
        // D s_57_35: bit-extract s_57_33 s_57_31 s_57_34
        let s_57_35: Bits = (Bits::new(
            ((s_57_33) >> (s_57_31)).value(),
            u16::try_from(s_57_34).unwrap(),
        ));
        // D s_57_36: cast reint s_57_35 -> u8
        let s_57_36: bool = ((s_57_35.value()) != 0);
        // C s_57_37: const #0s : i
        let s_57_37: i128 = 0;
        // C s_57_38: const #0u : u64
        let s_57_38: u64 = 0;
        // D s_57_39: cast zx s_57_36 -> u64
        let s_57_39: u64 = (s_57_36 as u64);
        // C s_57_40: const #1u : u64
        let s_57_40: u64 = 1;
        // D s_57_41: and s_57_39 s_57_40
        let s_57_41: u64 = ((s_57_39) & (s_57_40));
        // D s_57_42: cmp-eq s_57_41 s_57_40
        let s_57_42: bool = ((s_57_41) == (s_57_40));
        // D s_57_43: lsl s_57_39 s_57_37
        let s_57_43: u64 = s_57_39 << s_57_37;
        // D s_57_44: or s_57_38 s_57_43
        let s_57_44: u64 = ((s_57_38) | (s_57_43));
        // D s_57_45: cmpl s_57_43
        let s_57_45: u64 = !s_57_43;
        // D s_57_46: and s_57_38 s_57_45
        let s_57_46: u64 = ((s_57_38) & (s_57_45));
        // D s_57_47: select s_57_42 s_57_44 s_57_46
        let s_57_47: u64 = if s_57_42 { s_57_44 } else { s_57_46 };
        // D s_57_48: cast trunc s_57_47 -> u8
        let s_57_48: bool = ((s_57_47) != 0);
        // D s_57_49: cast zx s_57_48 -> bv
        let s_57_49: Bits = Bits::new(s_57_48 as u128, 1u16);
        // C s_57_50: const #1u : u8
        let s_57_50: bool = true;
        // C s_57_51: cast zx s_57_50 -> bv
        let s_57_51: Bits = Bits::new(s_57_50 as u128, 1u16);
        // D s_57_52: cmp-ne s_57_49 s_57_51
        let s_57_52: bool = ((s_57_49) != (s_57_51));
        // N s_57_53: branch s_57_52 b68 b58
        if s_57_52 {
            return block_68(state, tracer, fn_state);
        } else {
            return block_58(state, tracer, fn_state);
        };
    }
    fn block_58<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_58_0: const #9s : i
        let s_58_0: i128 = 9;
        // D s_58_1: read-var u#33443:u32
        let s_58_1: u32 = fn_state.u_33443;
        // D s_58_2: cast zx s_58_1 -> bv
        let s_58_2: Bits = Bits::new(s_58_1 as u128, 32u16);
        // C s_58_3: const #1u : u64
        let s_58_3: u64 = 1;
        // D s_58_4: bit-extract s_58_2 s_58_0 s_58_3
        let s_58_4: Bits = (Bits::new(
            ((s_58_2) >> (s_58_0)).value(),
            u16::try_from(s_58_3).unwrap(),
        ));
        // D s_58_5: cast reint s_58_4 -> u8
        let s_58_5: bool = ((s_58_4.value()) != 0);
        // C s_58_6: const #0s : i
        let s_58_6: i128 = 0;
        // C s_58_7: const #0u : u64
        let s_58_7: u64 = 0;
        // D s_58_8: cast zx s_58_5 -> u64
        let s_58_8: u64 = (s_58_5 as u64);
        // C s_58_9: const #1u : u64
        let s_58_9: u64 = 1;
        // D s_58_10: and s_58_8 s_58_9
        let s_58_10: u64 = ((s_58_8) & (s_58_9));
        // D s_58_11: cmp-eq s_58_10 s_58_9
        let s_58_11: bool = ((s_58_10) == (s_58_9));
        // D s_58_12: lsl s_58_8 s_58_6
        let s_58_12: u64 = s_58_8 << s_58_6;
        // D s_58_13: or s_58_7 s_58_12
        let s_58_13: u64 = ((s_58_7) | (s_58_12));
        // D s_58_14: cmpl s_58_12
        let s_58_14: u64 = !s_58_12;
        // D s_58_15: and s_58_7 s_58_14
        let s_58_15: u64 = ((s_58_7) & (s_58_14));
        // D s_58_16: select s_58_11 s_58_13 s_58_15
        let s_58_16: u64 = if s_58_11 { s_58_13 } else { s_58_15 };
        // D s_58_17: cast trunc s_58_16 -> u8
        let s_58_17: bool = ((s_58_16) != 0);
        // D s_58_18: cast zx s_58_17 -> bv
        let s_58_18: Bits = Bits::new(s_58_17 as u128, 1u16);
        // C s_58_19: const #1u : u8
        let s_58_19: bool = true;
        // C s_58_20: cast zx s_58_19 -> bv
        let s_58_20: Bits = Bits::new(s_58_19 as u128, 1u16);
        // D s_58_21: cmp-ne s_58_18 s_58_20
        let s_58_21: bool = ((s_58_18) != (s_58_20));
        // D s_58_22: write-var gs#409249 <= s_58_21
        fn_state.gs_409249 = s_58_21;
        // N s_58_23: jump b59
        return block_59(state, tracer, fn_state);
    }
    fn block_59<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_59_0: read-var gs#409249:u8
        let s_59_0: bool = fn_state.gs_409249;
        // N s_59_1: branch s_59_0 b67 b60
        if s_59_0 {
            return block_67(state, tracer, fn_state);
        } else {
            return block_60(state, tracer, fn_state);
        };
    }
    fn block_60<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_60_0: const #10s : i
        let s_60_0: i128 = 10;
        // D s_60_1: read-var u#33443:u32
        let s_60_1: u32 = fn_state.u_33443;
        // D s_60_2: cast zx s_60_1 -> bv
        let s_60_2: Bits = Bits::new(s_60_1 as u128, 32u16);
        // C s_60_3: const #1u : u64
        let s_60_3: u64 = 1;
        // D s_60_4: bit-extract s_60_2 s_60_0 s_60_3
        let s_60_4: Bits = (Bits::new(
            ((s_60_2) >> (s_60_0)).value(),
            u16::try_from(s_60_3).unwrap(),
        ));
        // D s_60_5: cast reint s_60_4 -> u8
        let s_60_5: bool = ((s_60_4.value()) != 0);
        // C s_60_6: const #0s : i
        let s_60_6: i128 = 0;
        // C s_60_7: const #0u : u64
        let s_60_7: u64 = 0;
        // D s_60_8: cast zx s_60_5 -> u64
        let s_60_8: u64 = (s_60_5 as u64);
        // C s_60_9: const #1u : u64
        let s_60_9: u64 = 1;
        // D s_60_10: and s_60_8 s_60_9
        let s_60_10: u64 = ((s_60_8) & (s_60_9));
        // D s_60_11: cmp-eq s_60_10 s_60_9
        let s_60_11: bool = ((s_60_10) == (s_60_9));
        // D s_60_12: lsl s_60_8 s_60_6
        let s_60_12: u64 = s_60_8 << s_60_6;
        // D s_60_13: or s_60_7 s_60_12
        let s_60_13: u64 = ((s_60_7) | (s_60_12));
        // D s_60_14: cmpl s_60_12
        let s_60_14: u64 = !s_60_12;
        // D s_60_15: and s_60_7 s_60_14
        let s_60_15: u64 = ((s_60_7) & (s_60_14));
        // D s_60_16: select s_60_11 s_60_13 s_60_15
        let s_60_16: u64 = if s_60_11 { s_60_13 } else { s_60_15 };
        // D s_60_17: cast trunc s_60_16 -> u8
        let s_60_17: bool = ((s_60_16) != 0);
        // D s_60_18: cast zx s_60_17 -> bv
        let s_60_18: Bits = Bits::new(s_60_17 as u128, 1u16);
        // C s_60_19: const #1u : u8
        let s_60_19: bool = true;
        // C s_60_20: cast zx s_60_19 -> bv
        let s_60_20: Bits = Bits::new(s_60_19 as u128, 1u16);
        // D s_60_21: cmp-ne s_60_18 s_60_20
        let s_60_21: bool = ((s_60_18) != (s_60_20));
        // D s_60_22: write-var gs#409252 <= s_60_21
        fn_state.gs_409252 = s_60_21;
        // N s_60_23: jump b61
        return block_61(state, tracer, fn_state);
    }
    fn block_61<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_61_0: read-var gs#409252:u8
        let s_61_0: bool = fn_state.gs_409252;
        // N s_61_1: branch s_61_0 b66 b62
        if s_61_0 {
            return block_66(state, tracer, fn_state);
        } else {
            return block_62(state, tracer, fn_state);
        };
    }
    fn block_62<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_62_0: const #11s : i
        let s_62_0: i128 = 11;
        // D s_62_1: read-var u#33443:u32
        let s_62_1: u32 = fn_state.u_33443;
        // D s_62_2: cast zx s_62_1 -> bv
        let s_62_2: Bits = Bits::new(s_62_1 as u128, 32u16);
        // C s_62_3: const #1u : u64
        let s_62_3: u64 = 1;
        // D s_62_4: bit-extract s_62_2 s_62_0 s_62_3
        let s_62_4: Bits = (Bits::new(
            ((s_62_2) >> (s_62_0)).value(),
            u16::try_from(s_62_3).unwrap(),
        ));
        // D s_62_5: cast reint s_62_4 -> u8
        let s_62_5: bool = ((s_62_4.value()) != 0);
        // C s_62_6: const #0s : i
        let s_62_6: i128 = 0;
        // C s_62_7: const #0u : u64
        let s_62_7: u64 = 0;
        // D s_62_8: cast zx s_62_5 -> u64
        let s_62_8: u64 = (s_62_5 as u64);
        // C s_62_9: const #1u : u64
        let s_62_9: u64 = 1;
        // D s_62_10: and s_62_8 s_62_9
        let s_62_10: u64 = ((s_62_8) & (s_62_9));
        // D s_62_11: cmp-eq s_62_10 s_62_9
        let s_62_11: bool = ((s_62_10) == (s_62_9));
        // D s_62_12: lsl s_62_8 s_62_6
        let s_62_12: u64 = s_62_8 << s_62_6;
        // D s_62_13: or s_62_7 s_62_12
        let s_62_13: u64 = ((s_62_7) | (s_62_12));
        // D s_62_14: cmpl s_62_12
        let s_62_14: u64 = !s_62_12;
        // D s_62_15: and s_62_7 s_62_14
        let s_62_15: u64 = ((s_62_7) & (s_62_14));
        // D s_62_16: select s_62_11 s_62_13 s_62_15
        let s_62_16: u64 = if s_62_11 { s_62_13 } else { s_62_15 };
        // D s_62_17: cast trunc s_62_16 -> u8
        let s_62_17: bool = ((s_62_16) != 0);
        // D s_62_18: cast zx s_62_17 -> bv
        let s_62_18: Bits = Bits::new(s_62_17 as u128, 1u16);
        // C s_62_19: const #1u : u8
        let s_62_19: bool = true;
        // C s_62_20: cast zx s_62_19 -> bv
        let s_62_20: Bits = Bits::new(s_62_19 as u128, 1u16);
        // D s_62_21: cmp-ne s_62_18 s_62_20
        let s_62_21: bool = ((s_62_18) != (s_62_20));
        // D s_62_22: write-var gs#409255 <= s_62_21
        fn_state.gs_409255 = s_62_21;
        // N s_62_23: jump b63
        return block_63(state, tracer, fn_state);
    }
    fn block_63<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_63_0: read-var gs#409255:u8
        let s_63_0: bool = fn_state.gs_409255;
        // N s_63_1: branch s_63_0 b65 b64
        if s_63_0 {
            return block_65(state, tracer, fn_state);
        } else {
            return block_64(state, tracer, fn_state);
        };
    }
    fn block_64<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_64_0: read-var u#33444:u8
        let s_64_0: u8 = fn_state.u_33444;
        // D s_64_1: read-var u#33445:u8
        let s_64_1: u8 = fn_state.u_33445;
        // D s_64_2: read-var u#33446:u8
        let s_64_2: u8 = fn_state.u_33446;
        // D s_64_3: read-var u#33447:u8
        let s_64_3: u8 = fn_state.u_33447;
        // D s_64_4: call decode_aarch32_instrs_QASX_A1enc_A_txt(s_64_0, s_64_1, s_64_2, s_64_3)
        let s_64_4: () = decode_aarch32_instrs_QASX_A1enc_A_txt(
            state,
            tracer,
            s_64_0,
            s_64_1,
            s_64_2,
            s_64_3,
        );
        // N s_64_5: return
        return;
    }
    fn block_65<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_65_0: panic
        panic!("{:?}", ());
        // N s_65_1: return
        return;
    }
    fn block_66<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_66_0: const #1u : u8
        let s_66_0: bool = true;
        // D s_66_1: write-var gs#409255 <= s_66_0
        fn_state.gs_409255 = s_66_0;
        // N s_66_2: jump b63
        return block_63(state, tracer, fn_state);
    }
    fn block_67<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_67_0: const #1u : u8
        let s_67_0: bool = true;
        // D s_67_1: write-var gs#409252 <= s_67_0
        fn_state.gs_409252 = s_67_0;
        // N s_67_2: jump b61
        return block_61(state, tracer, fn_state);
    }
    fn block_68<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_68_0: const #1u : u8
        let s_68_0: bool = true;
        // D s_68_1: write-var gs#409249 <= s_68_0
        fn_state.gs_409249 = s_68_0;
        // N s_68_2: jump b59
        return block_59(state, tracer, fn_state);
    }
    fn block_69<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_69_0: read-var merge#var.1:struct
        let s_69_0: u32 = fn_state.merge_var._1;
        // D s_69_1: write-var u#33449 <= s_69_0
        fn_state.u_33449 = s_69_0;
        // C s_69_2: const #20s : i
        let s_69_2: i128 = 20;
        // D s_69_3: read-var u#33449:u32
        let s_69_3: u32 = fn_state.u_33449;
        // D s_69_4: cast zx s_69_3 -> bv
        let s_69_4: Bits = Bits::new(s_69_3 as u128, 32u16);
        // C s_69_5: const #1s : i64
        let s_69_5: i64 = 1;
        // C s_69_6: cast zx s_69_5 -> i
        let s_69_6: i128 = (i128::try_from(s_69_5).unwrap());
        // C s_69_7: const #7s : i
        let s_69_7: i128 = 7;
        // C s_69_8: add s_69_7 s_69_6
        let s_69_8: i128 = (s_69_7 + s_69_6);
        // D s_69_9: bit-extract s_69_4 s_69_2 s_69_8
        let s_69_9: Bits = (Bits::new(
            ((s_69_4) >> (s_69_2)).value(),
            u16::try_from(s_69_8).unwrap(),
        ));
        // D s_69_10: cast reint s_69_9 -> u8
        let s_69_10: u8 = (s_69_9.value() as u8);
        // D s_69_11: cast zx s_69_10 -> bv
        let s_69_11: Bits = Bits::new(s_69_10 as u128, 8u16);
        // C s_69_12: const #98u : u8
        let s_69_12: u8 = 98;
        // C s_69_13: cast zx s_69_12 -> bv
        let s_69_13: Bits = Bits::new(s_69_12 as u128, 8u16);
        // D s_69_14: cmp-eq s_69_11 s_69_13
        let s_69_14: bool = ((s_69_11) == (s_69_13));
        // N s_69_15: branch s_69_14 b1423 b70
        if s_69_14 {
            return block_1423(state, tracer, fn_state);
        } else {
            return block_70(state, tracer, fn_state);
        };
    }
    fn block_70<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_70_0: const #0u : u8
        let s_70_0: bool = false;
        // D s_70_1: write-var gs#409261 <= s_70_0
        fn_state.gs_409261 = s_70_0;
        // N s_70_2: jump b71
        return block_71(state, tracer, fn_state);
    }
    fn block_71<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_71_0: read-var gs#409261:u8
        let s_71_0: bool = fn_state.gs_409261;
        // N s_71_1: branch s_71_0 b1419 b72
        if s_71_0 {
            return block_1419(state, tracer, fn_state);
        } else {
            return block_72(state, tracer, fn_state);
        };
    }
    fn block_72<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_72_0: const #0u : u8
        let s_72_0: bool = false;
        // D s_72_1: write-var gs#409266 <= s_72_0
        fn_state.gs_409266 = s_72_0;
        // N s_72_2: jump b73
        return block_73(state, tracer, fn_state);
    }
    fn block_73<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_73_0: read-var gs#409266:u8
        let s_73_0: bool = fn_state.gs_409266;
        // D s_73_1: not s_73_0
        let s_73_1: bool = !s_73_0;
        // N s_73_2: branch s_73_1 b86 b74
        if s_73_1 {
            return block_86(state, tracer, fn_state);
        } else {
            return block_74(state, tracer, fn_state);
        };
    }
    fn block_74<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_74_0: const #3076s : i
        let s_74_0: i128 = 3076;
        // C s_74_1: const #14696u : u32
        let s_74_1: u32 = 14696;
        // N s_74_2: write-reg s_74_1 <= s_74_0
        let s_74_2: () = {
            state.write_register::<i128>(s_74_1 as isize, s_74_0);
            tracer.write_register(s_74_1 as isize, s_74_0);
        };
        // C s_74_3: const #28s : i
        let s_74_3: i128 = 28;
        // C s_74_4: const #4s : i
        let s_74_4: i128 = 4;
        // D s_74_5: read-var u#33449:u32
        let s_74_5: u32 = fn_state.u_33449;
        // D s_74_6: cast zx s_74_5 -> bv
        let s_74_6: Bits = Bits::new(s_74_5 as u128, 32u16);
        // D s_74_7: bit-extract s_74_6 s_74_3 s_74_4
        let s_74_7: Bits = (Bits::new(
            ((s_74_6) >> (s_74_3)).value(),
            u16::try_from(s_74_4).unwrap(),
        ));
        // D s_74_8: cast reint s_74_7 -> u8
        let s_74_8: u8 = (s_74_7.value() as u8);
        // D s_74_9: write-var u#33450 <= s_74_8
        fn_state.u_33450 = s_74_8;
        // C s_74_10: const #16s : i
        let s_74_10: i128 = 16;
        // C s_74_11: const #4s : i
        let s_74_11: i128 = 4;
        // D s_74_12: read-var u#33449:u32
        let s_74_12: u32 = fn_state.u_33449;
        // D s_74_13: cast zx s_74_12 -> bv
        let s_74_13: Bits = Bits::new(s_74_12 as u128, 32u16);
        // D s_74_14: bit-extract s_74_13 s_74_10 s_74_11
        let s_74_14: Bits = (Bits::new(
            ((s_74_13) >> (s_74_10)).value(),
            u16::try_from(s_74_11).unwrap(),
        ));
        // D s_74_15: cast reint s_74_14 -> u8
        let s_74_15: u8 = (s_74_14.value() as u8);
        // D s_74_16: write-var u#33451 <= s_74_15
        fn_state.u_33451 = s_74_15;
        // C s_74_17: const #12s : i
        let s_74_17: i128 = 12;
        // C s_74_18: const #4s : i
        let s_74_18: i128 = 4;
        // D s_74_19: read-var u#33449:u32
        let s_74_19: u32 = fn_state.u_33449;
        // D s_74_20: cast zx s_74_19 -> bv
        let s_74_20: Bits = Bits::new(s_74_19 as u128, 32u16);
        // D s_74_21: bit-extract s_74_20 s_74_17 s_74_18
        let s_74_21: Bits = (Bits::new(
            ((s_74_20) >> (s_74_17)).value(),
            u16::try_from(s_74_18).unwrap(),
        ));
        // D s_74_22: cast reint s_74_21 -> u8
        let s_74_22: u8 = (s_74_21.value() as u8);
        // D s_74_23: write-var u#33452 <= s_74_22
        fn_state.u_33452 = s_74_22;
        // C s_74_24: const #0s : i
        let s_74_24: i128 = 0;
        // C s_74_25: const #4s : i
        let s_74_25: i128 = 4;
        // D s_74_26: read-var u#33449:u32
        let s_74_26: u32 = fn_state.u_33449;
        // D s_74_27: cast zx s_74_26 -> bv
        let s_74_27: Bits = Bits::new(s_74_26 as u128, 32u16);
        // D s_74_28: bit-extract s_74_27 s_74_24 s_74_25
        let s_74_28: Bits = (Bits::new(
            ((s_74_27) >> (s_74_24)).value(),
            u16::try_from(s_74_25).unwrap(),
        ));
        // D s_74_29: cast reint s_74_28 -> u8
        let s_74_29: u8 = (s_74_28.value() as u8);
        // D s_74_30: write-var u#33453 <= s_74_29
        fn_state.u_33453 = s_74_29;
        // C s_74_31: const #8s : i
        let s_74_31: i128 = 8;
        // D s_74_32: read-var u#33449:u32
        let s_74_32: u32 = fn_state.u_33449;
        // D s_74_33: cast zx s_74_32 -> bv
        let s_74_33: Bits = Bits::new(s_74_32 as u128, 32u16);
        // C s_74_34: const #1u : u64
        let s_74_34: u64 = 1;
        // D s_74_35: bit-extract s_74_33 s_74_31 s_74_34
        let s_74_35: Bits = (Bits::new(
            ((s_74_33) >> (s_74_31)).value(),
            u16::try_from(s_74_34).unwrap(),
        ));
        // D s_74_36: cast reint s_74_35 -> u8
        let s_74_36: bool = ((s_74_35.value()) != 0);
        // C s_74_37: const #0s : i
        let s_74_37: i128 = 0;
        // C s_74_38: const #0u : u64
        let s_74_38: u64 = 0;
        // D s_74_39: cast zx s_74_36 -> u64
        let s_74_39: u64 = (s_74_36 as u64);
        // C s_74_40: const #1u : u64
        let s_74_40: u64 = 1;
        // D s_74_41: and s_74_39 s_74_40
        let s_74_41: u64 = ((s_74_39) & (s_74_40));
        // D s_74_42: cmp-eq s_74_41 s_74_40
        let s_74_42: bool = ((s_74_41) == (s_74_40));
        // D s_74_43: lsl s_74_39 s_74_37
        let s_74_43: u64 = s_74_39 << s_74_37;
        // D s_74_44: or s_74_38 s_74_43
        let s_74_44: u64 = ((s_74_38) | (s_74_43));
        // D s_74_45: cmpl s_74_43
        let s_74_45: u64 = !s_74_43;
        // D s_74_46: and s_74_38 s_74_45
        let s_74_46: u64 = ((s_74_38) & (s_74_45));
        // D s_74_47: select s_74_42 s_74_44 s_74_46
        let s_74_47: u64 = if s_74_42 { s_74_44 } else { s_74_46 };
        // D s_74_48: cast trunc s_74_47 -> u8
        let s_74_48: bool = ((s_74_47) != 0);
        // D s_74_49: cast zx s_74_48 -> bv
        let s_74_49: Bits = Bits::new(s_74_48 as u128, 1u16);
        // C s_74_50: const #1u : u8
        let s_74_50: bool = true;
        // C s_74_51: cast zx s_74_50 -> bv
        let s_74_51: Bits = Bits::new(s_74_50 as u128, 1u16);
        // D s_74_52: cmp-ne s_74_49 s_74_51
        let s_74_52: bool = ((s_74_49) != (s_74_51));
        // N s_74_53: branch s_74_52 b85 b75
        if s_74_52 {
            return block_85(state, tracer, fn_state);
        } else {
            return block_75(state, tracer, fn_state);
        };
    }
    fn block_75<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_75_0: const #9s : i
        let s_75_0: i128 = 9;
        // D s_75_1: read-var u#33449:u32
        let s_75_1: u32 = fn_state.u_33449;
        // D s_75_2: cast zx s_75_1 -> bv
        let s_75_2: Bits = Bits::new(s_75_1 as u128, 32u16);
        // C s_75_3: const #1u : u64
        let s_75_3: u64 = 1;
        // D s_75_4: bit-extract s_75_2 s_75_0 s_75_3
        let s_75_4: Bits = (Bits::new(
            ((s_75_2) >> (s_75_0)).value(),
            u16::try_from(s_75_3).unwrap(),
        ));
        // D s_75_5: cast reint s_75_4 -> u8
        let s_75_5: bool = ((s_75_4.value()) != 0);
        // C s_75_6: const #0s : i
        let s_75_6: i128 = 0;
        // C s_75_7: const #0u : u64
        let s_75_7: u64 = 0;
        // D s_75_8: cast zx s_75_5 -> u64
        let s_75_8: u64 = (s_75_5 as u64);
        // C s_75_9: const #1u : u64
        let s_75_9: u64 = 1;
        // D s_75_10: and s_75_8 s_75_9
        let s_75_10: u64 = ((s_75_8) & (s_75_9));
        // D s_75_11: cmp-eq s_75_10 s_75_9
        let s_75_11: bool = ((s_75_10) == (s_75_9));
        // D s_75_12: lsl s_75_8 s_75_6
        let s_75_12: u64 = s_75_8 << s_75_6;
        // D s_75_13: or s_75_7 s_75_12
        let s_75_13: u64 = ((s_75_7) | (s_75_12));
        // D s_75_14: cmpl s_75_12
        let s_75_14: u64 = !s_75_12;
        // D s_75_15: and s_75_7 s_75_14
        let s_75_15: u64 = ((s_75_7) & (s_75_14));
        // D s_75_16: select s_75_11 s_75_13 s_75_15
        let s_75_16: u64 = if s_75_11 { s_75_13 } else { s_75_15 };
        // D s_75_17: cast trunc s_75_16 -> u8
        let s_75_17: bool = ((s_75_16) != 0);
        // D s_75_18: cast zx s_75_17 -> bv
        let s_75_18: Bits = Bits::new(s_75_17 as u128, 1u16);
        // C s_75_19: const #1u : u8
        let s_75_19: bool = true;
        // C s_75_20: cast zx s_75_19 -> bv
        let s_75_20: Bits = Bits::new(s_75_19 as u128, 1u16);
        // D s_75_21: cmp-ne s_75_18 s_75_20
        let s_75_21: bool = ((s_75_18) != (s_75_20));
        // D s_75_22: write-var gs#409281 <= s_75_21
        fn_state.gs_409281 = s_75_21;
        // N s_75_23: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_76<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_76_0: read-var gs#409281:u8
        let s_76_0: bool = fn_state.gs_409281;
        // N s_76_1: branch s_76_0 b84 b77
        if s_76_0 {
            return block_84(state, tracer, fn_state);
        } else {
            return block_77(state, tracer, fn_state);
        };
    }
    fn block_77<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_77_0: const #10s : i
        let s_77_0: i128 = 10;
        // D s_77_1: read-var u#33449:u32
        let s_77_1: u32 = fn_state.u_33449;
        // D s_77_2: cast zx s_77_1 -> bv
        let s_77_2: Bits = Bits::new(s_77_1 as u128, 32u16);
        // C s_77_3: const #1u : u64
        let s_77_3: u64 = 1;
        // D s_77_4: bit-extract s_77_2 s_77_0 s_77_3
        let s_77_4: Bits = (Bits::new(
            ((s_77_2) >> (s_77_0)).value(),
            u16::try_from(s_77_3).unwrap(),
        ));
        // D s_77_5: cast reint s_77_4 -> u8
        let s_77_5: bool = ((s_77_4.value()) != 0);
        // C s_77_6: const #0s : i
        let s_77_6: i128 = 0;
        // C s_77_7: const #0u : u64
        let s_77_7: u64 = 0;
        // D s_77_8: cast zx s_77_5 -> u64
        let s_77_8: u64 = (s_77_5 as u64);
        // C s_77_9: const #1u : u64
        let s_77_9: u64 = 1;
        // D s_77_10: and s_77_8 s_77_9
        let s_77_10: u64 = ((s_77_8) & (s_77_9));
        // D s_77_11: cmp-eq s_77_10 s_77_9
        let s_77_11: bool = ((s_77_10) == (s_77_9));
        // D s_77_12: lsl s_77_8 s_77_6
        let s_77_12: u64 = s_77_8 << s_77_6;
        // D s_77_13: or s_77_7 s_77_12
        let s_77_13: u64 = ((s_77_7) | (s_77_12));
        // D s_77_14: cmpl s_77_12
        let s_77_14: u64 = !s_77_12;
        // D s_77_15: and s_77_7 s_77_14
        let s_77_15: u64 = ((s_77_7) & (s_77_14));
        // D s_77_16: select s_77_11 s_77_13 s_77_15
        let s_77_16: u64 = if s_77_11 { s_77_13 } else { s_77_15 };
        // D s_77_17: cast trunc s_77_16 -> u8
        let s_77_17: bool = ((s_77_16) != 0);
        // D s_77_18: cast zx s_77_17 -> bv
        let s_77_18: Bits = Bits::new(s_77_17 as u128, 1u16);
        // C s_77_19: const #1u : u8
        let s_77_19: bool = true;
        // C s_77_20: cast zx s_77_19 -> bv
        let s_77_20: Bits = Bits::new(s_77_19 as u128, 1u16);
        // D s_77_21: cmp-ne s_77_18 s_77_20
        let s_77_21: bool = ((s_77_18) != (s_77_20));
        // D s_77_22: write-var gs#409284 <= s_77_21
        fn_state.gs_409284 = s_77_21;
        // N s_77_23: jump b78
        return block_78(state, tracer, fn_state);
    }
    fn block_78<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_78_0: read-var gs#409284:u8
        let s_78_0: bool = fn_state.gs_409284;
        // N s_78_1: branch s_78_0 b83 b79
        if s_78_0 {
            return block_83(state, tracer, fn_state);
        } else {
            return block_79(state, tracer, fn_state);
        };
    }
    fn block_79<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_79_0: const #11s : i
        let s_79_0: i128 = 11;
        // D s_79_1: read-var u#33449:u32
        let s_79_1: u32 = fn_state.u_33449;
        // D s_79_2: cast zx s_79_1 -> bv
        let s_79_2: Bits = Bits::new(s_79_1 as u128, 32u16);
        // C s_79_3: const #1u : u64
        let s_79_3: u64 = 1;
        // D s_79_4: bit-extract s_79_2 s_79_0 s_79_3
        let s_79_4: Bits = (Bits::new(
            ((s_79_2) >> (s_79_0)).value(),
            u16::try_from(s_79_3).unwrap(),
        ));
        // D s_79_5: cast reint s_79_4 -> u8
        let s_79_5: bool = ((s_79_4.value()) != 0);
        // C s_79_6: const #0s : i
        let s_79_6: i128 = 0;
        // C s_79_7: const #0u : u64
        let s_79_7: u64 = 0;
        // D s_79_8: cast zx s_79_5 -> u64
        let s_79_8: u64 = (s_79_5 as u64);
        // C s_79_9: const #1u : u64
        let s_79_9: u64 = 1;
        // D s_79_10: and s_79_8 s_79_9
        let s_79_10: u64 = ((s_79_8) & (s_79_9));
        // D s_79_11: cmp-eq s_79_10 s_79_9
        let s_79_11: bool = ((s_79_10) == (s_79_9));
        // D s_79_12: lsl s_79_8 s_79_6
        let s_79_12: u64 = s_79_8 << s_79_6;
        // D s_79_13: or s_79_7 s_79_12
        let s_79_13: u64 = ((s_79_7) | (s_79_12));
        // D s_79_14: cmpl s_79_12
        let s_79_14: u64 = !s_79_12;
        // D s_79_15: and s_79_7 s_79_14
        let s_79_15: u64 = ((s_79_7) & (s_79_14));
        // D s_79_16: select s_79_11 s_79_13 s_79_15
        let s_79_16: u64 = if s_79_11 { s_79_13 } else { s_79_15 };
        // D s_79_17: cast trunc s_79_16 -> u8
        let s_79_17: bool = ((s_79_16) != 0);
        // D s_79_18: cast zx s_79_17 -> bv
        let s_79_18: Bits = Bits::new(s_79_17 as u128, 1u16);
        // C s_79_19: const #1u : u8
        let s_79_19: bool = true;
        // C s_79_20: cast zx s_79_19 -> bv
        let s_79_20: Bits = Bits::new(s_79_19 as u128, 1u16);
        // D s_79_21: cmp-ne s_79_18 s_79_20
        let s_79_21: bool = ((s_79_18) != (s_79_20));
        // D s_79_22: write-var gs#409287 <= s_79_21
        fn_state.gs_409287 = s_79_21;
        // N s_79_23: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_80<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_80_0: read-var gs#409287:u8
        let s_80_0: bool = fn_state.gs_409287;
        // N s_80_1: branch s_80_0 b82 b81
        if s_80_0 {
            return block_82(state, tracer, fn_state);
        } else {
            return block_81(state, tracer, fn_state);
        };
    }
    fn block_81<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_81_0: read-var u#33450:u8
        let s_81_0: u8 = fn_state.u_33450;
        // D s_81_1: read-var u#33451:u8
        let s_81_1: u8 = fn_state.u_33451;
        // D s_81_2: read-var u#33452:u8
        let s_81_2: u8 = fn_state.u_33452;
        // D s_81_3: read-var u#33453:u8
        let s_81_3: u8 = fn_state.u_33453;
        // D s_81_4: call decode_aarch32_instrs_QSAX_A1enc_A_txt(s_81_0, s_81_1, s_81_2, s_81_3)
        let s_81_4: () = decode_aarch32_instrs_QSAX_A1enc_A_txt(
            state,
            tracer,
            s_81_0,
            s_81_1,
            s_81_2,
            s_81_3,
        );
        // N s_81_5: return
        return;
    }
    fn block_82<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_82_0: panic
        panic!("{:?}", ());
        // N s_82_1: return
        return;
    }
    fn block_83<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_83_0: const #1u : u8
        let s_83_0: bool = true;
        // D s_83_1: write-var gs#409287 <= s_83_0
        fn_state.gs_409287 = s_83_0;
        // N s_83_2: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_84<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_84_0: const #1u : u8
        let s_84_0: bool = true;
        // D s_84_1: write-var gs#409284 <= s_84_0
        fn_state.gs_409284 = s_84_0;
        // N s_84_2: jump b78
        return block_78(state, tracer, fn_state);
    }
    fn block_85<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_85_0: const #1u : u8
        let s_85_0: bool = true;
        // D s_85_1: write-var gs#409281 <= s_85_0
        fn_state.gs_409281 = s_85_0;
        // N s_85_2: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_86<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_86_0: read-var merge#var.1:struct
        let s_86_0: u32 = fn_state.merge_var._1;
        // D s_86_1: write-var u#33455 <= s_86_0
        fn_state.u_33455 = s_86_0;
        // C s_86_2: const #20s : i
        let s_86_2: i128 = 20;
        // D s_86_3: read-var u#33455:u32
        let s_86_3: u32 = fn_state.u_33455;
        // D s_86_4: cast zx s_86_3 -> bv
        let s_86_4: Bits = Bits::new(s_86_3 as u128, 32u16);
        // C s_86_5: const #1s : i64
        let s_86_5: i64 = 1;
        // C s_86_6: cast zx s_86_5 -> i
        let s_86_6: i128 = (i128::try_from(s_86_5).unwrap());
        // C s_86_7: const #7s : i
        let s_86_7: i128 = 7;
        // C s_86_8: add s_86_7 s_86_6
        let s_86_8: i128 = (s_86_7 + s_86_6);
        // D s_86_9: bit-extract s_86_4 s_86_2 s_86_8
        let s_86_9: Bits = (Bits::new(
            ((s_86_4) >> (s_86_2)).value(),
            u16::try_from(s_86_8).unwrap(),
        ));
        // D s_86_10: cast reint s_86_9 -> u8
        let s_86_10: u8 = (s_86_9.value() as u8);
        // D s_86_11: cast zx s_86_10 -> bv
        let s_86_11: Bits = Bits::new(s_86_10 as u128, 8u16);
        // C s_86_12: const #98u : u8
        let s_86_12: u8 = 98;
        // C s_86_13: cast zx s_86_12 -> bv
        let s_86_13: Bits = Bits::new(s_86_12 as u128, 8u16);
        // D s_86_14: cmp-eq s_86_11 s_86_13
        let s_86_14: bool = ((s_86_11) == (s_86_13));
        // N s_86_15: branch s_86_14 b1418 b87
        if s_86_14 {
            return block_1418(state, tracer, fn_state);
        } else {
            return block_87(state, tracer, fn_state);
        };
    }
    fn block_87<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_87_0: const #0u : u8
        let s_87_0: bool = false;
        // D s_87_1: write-var gs#409293 <= s_87_0
        fn_state.gs_409293 = s_87_0;
        // N s_87_2: jump b88
        return block_88(state, tracer, fn_state);
    }
    fn block_88<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_88_0: read-var gs#409293:u8
        let s_88_0: bool = fn_state.gs_409293;
        // N s_88_1: branch s_88_0 b1414 b89
        if s_88_0 {
            return block_1414(state, tracer, fn_state);
        } else {
            return block_89(state, tracer, fn_state);
        };
    }
    fn block_89<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_89_0: const #0u : u8
        let s_89_0: bool = false;
        // D s_89_1: write-var gs#409298 <= s_89_0
        fn_state.gs_409298 = s_89_0;
        // N s_89_2: jump b90
        return block_90(state, tracer, fn_state);
    }
    fn block_90<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_90_0: read-var gs#409298:u8
        let s_90_0: bool = fn_state.gs_409298;
        // D s_90_1: not s_90_0
        let s_90_1: bool = !s_90_0;
        // N s_90_2: branch s_90_1 b103 b91
        if s_90_1 {
            return block_103(state, tracer, fn_state);
        } else {
            return block_91(state, tracer, fn_state);
        };
    }
    fn block_91<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_91_0: const #3078s : i
        let s_91_0: i128 = 3078;
        // C s_91_1: const #14696u : u32
        let s_91_1: u32 = 14696;
        // N s_91_2: write-reg s_91_1 <= s_91_0
        let s_91_2: () = {
            state.write_register::<i128>(s_91_1 as isize, s_91_0);
            tracer.write_register(s_91_1 as isize, s_91_0);
        };
        // C s_91_3: const #28s : i
        let s_91_3: i128 = 28;
        // C s_91_4: const #4s : i
        let s_91_4: i128 = 4;
        // D s_91_5: read-var u#33455:u32
        let s_91_5: u32 = fn_state.u_33455;
        // D s_91_6: cast zx s_91_5 -> bv
        let s_91_6: Bits = Bits::new(s_91_5 as u128, 32u16);
        // D s_91_7: bit-extract s_91_6 s_91_3 s_91_4
        let s_91_7: Bits = (Bits::new(
            ((s_91_6) >> (s_91_3)).value(),
            u16::try_from(s_91_4).unwrap(),
        ));
        // D s_91_8: cast reint s_91_7 -> u8
        let s_91_8: u8 = (s_91_7.value() as u8);
        // D s_91_9: write-var u#33456 <= s_91_8
        fn_state.u_33456 = s_91_8;
        // C s_91_10: const #16s : i
        let s_91_10: i128 = 16;
        // C s_91_11: const #4s : i
        let s_91_11: i128 = 4;
        // D s_91_12: read-var u#33455:u32
        let s_91_12: u32 = fn_state.u_33455;
        // D s_91_13: cast zx s_91_12 -> bv
        let s_91_13: Bits = Bits::new(s_91_12 as u128, 32u16);
        // D s_91_14: bit-extract s_91_13 s_91_10 s_91_11
        let s_91_14: Bits = (Bits::new(
            ((s_91_13) >> (s_91_10)).value(),
            u16::try_from(s_91_11).unwrap(),
        ));
        // D s_91_15: cast reint s_91_14 -> u8
        let s_91_15: u8 = (s_91_14.value() as u8);
        // D s_91_16: write-var u#33457 <= s_91_15
        fn_state.u_33457 = s_91_15;
        // C s_91_17: const #12s : i
        let s_91_17: i128 = 12;
        // C s_91_18: const #4s : i
        let s_91_18: i128 = 4;
        // D s_91_19: read-var u#33455:u32
        let s_91_19: u32 = fn_state.u_33455;
        // D s_91_20: cast zx s_91_19 -> bv
        let s_91_20: Bits = Bits::new(s_91_19 as u128, 32u16);
        // D s_91_21: bit-extract s_91_20 s_91_17 s_91_18
        let s_91_21: Bits = (Bits::new(
            ((s_91_20) >> (s_91_17)).value(),
            u16::try_from(s_91_18).unwrap(),
        ));
        // D s_91_22: cast reint s_91_21 -> u8
        let s_91_22: u8 = (s_91_21.value() as u8);
        // D s_91_23: write-var u#33458 <= s_91_22
        fn_state.u_33458 = s_91_22;
        // C s_91_24: const #0s : i
        let s_91_24: i128 = 0;
        // C s_91_25: const #4s : i
        let s_91_25: i128 = 4;
        // D s_91_26: read-var u#33455:u32
        let s_91_26: u32 = fn_state.u_33455;
        // D s_91_27: cast zx s_91_26 -> bv
        let s_91_27: Bits = Bits::new(s_91_26 as u128, 32u16);
        // D s_91_28: bit-extract s_91_27 s_91_24 s_91_25
        let s_91_28: Bits = (Bits::new(
            ((s_91_27) >> (s_91_24)).value(),
            u16::try_from(s_91_25).unwrap(),
        ));
        // D s_91_29: cast reint s_91_28 -> u8
        let s_91_29: u8 = (s_91_28.value() as u8);
        // D s_91_30: write-var u#33459 <= s_91_29
        fn_state.u_33459 = s_91_29;
        // C s_91_31: const #8s : i
        let s_91_31: i128 = 8;
        // D s_91_32: read-var u#33455:u32
        let s_91_32: u32 = fn_state.u_33455;
        // D s_91_33: cast zx s_91_32 -> bv
        let s_91_33: Bits = Bits::new(s_91_32 as u128, 32u16);
        // C s_91_34: const #1u : u64
        let s_91_34: u64 = 1;
        // D s_91_35: bit-extract s_91_33 s_91_31 s_91_34
        let s_91_35: Bits = (Bits::new(
            ((s_91_33) >> (s_91_31)).value(),
            u16::try_from(s_91_34).unwrap(),
        ));
        // D s_91_36: cast reint s_91_35 -> u8
        let s_91_36: bool = ((s_91_35.value()) != 0);
        // C s_91_37: const #0s : i
        let s_91_37: i128 = 0;
        // C s_91_38: const #0u : u64
        let s_91_38: u64 = 0;
        // D s_91_39: cast zx s_91_36 -> u64
        let s_91_39: u64 = (s_91_36 as u64);
        // C s_91_40: const #1u : u64
        let s_91_40: u64 = 1;
        // D s_91_41: and s_91_39 s_91_40
        let s_91_41: u64 = ((s_91_39) & (s_91_40));
        // D s_91_42: cmp-eq s_91_41 s_91_40
        let s_91_42: bool = ((s_91_41) == (s_91_40));
        // D s_91_43: lsl s_91_39 s_91_37
        let s_91_43: u64 = s_91_39 << s_91_37;
        // D s_91_44: or s_91_38 s_91_43
        let s_91_44: u64 = ((s_91_38) | (s_91_43));
        // D s_91_45: cmpl s_91_43
        let s_91_45: u64 = !s_91_43;
        // D s_91_46: and s_91_38 s_91_45
        let s_91_46: u64 = ((s_91_38) & (s_91_45));
        // D s_91_47: select s_91_42 s_91_44 s_91_46
        let s_91_47: u64 = if s_91_42 { s_91_44 } else { s_91_46 };
        // D s_91_48: cast trunc s_91_47 -> u8
        let s_91_48: bool = ((s_91_47) != 0);
        // D s_91_49: cast zx s_91_48 -> bv
        let s_91_49: Bits = Bits::new(s_91_48 as u128, 1u16);
        // C s_91_50: const #1u : u8
        let s_91_50: bool = true;
        // C s_91_51: cast zx s_91_50 -> bv
        let s_91_51: Bits = Bits::new(s_91_50 as u128, 1u16);
        // D s_91_52: cmp-ne s_91_49 s_91_51
        let s_91_52: bool = ((s_91_49) != (s_91_51));
        // N s_91_53: branch s_91_52 b102 b92
        if s_91_52 {
            return block_102(state, tracer, fn_state);
        } else {
            return block_92(state, tracer, fn_state);
        };
    }
    fn block_92<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_92_0: const #9s : i
        let s_92_0: i128 = 9;
        // D s_92_1: read-var u#33455:u32
        let s_92_1: u32 = fn_state.u_33455;
        // D s_92_2: cast zx s_92_1 -> bv
        let s_92_2: Bits = Bits::new(s_92_1 as u128, 32u16);
        // C s_92_3: const #1u : u64
        let s_92_3: u64 = 1;
        // D s_92_4: bit-extract s_92_2 s_92_0 s_92_3
        let s_92_4: Bits = (Bits::new(
            ((s_92_2) >> (s_92_0)).value(),
            u16::try_from(s_92_3).unwrap(),
        ));
        // D s_92_5: cast reint s_92_4 -> u8
        let s_92_5: bool = ((s_92_4.value()) != 0);
        // C s_92_6: const #0s : i
        let s_92_6: i128 = 0;
        // C s_92_7: const #0u : u64
        let s_92_7: u64 = 0;
        // D s_92_8: cast zx s_92_5 -> u64
        let s_92_8: u64 = (s_92_5 as u64);
        // C s_92_9: const #1u : u64
        let s_92_9: u64 = 1;
        // D s_92_10: and s_92_8 s_92_9
        let s_92_10: u64 = ((s_92_8) & (s_92_9));
        // D s_92_11: cmp-eq s_92_10 s_92_9
        let s_92_11: bool = ((s_92_10) == (s_92_9));
        // D s_92_12: lsl s_92_8 s_92_6
        let s_92_12: u64 = s_92_8 << s_92_6;
        // D s_92_13: or s_92_7 s_92_12
        let s_92_13: u64 = ((s_92_7) | (s_92_12));
        // D s_92_14: cmpl s_92_12
        let s_92_14: u64 = !s_92_12;
        // D s_92_15: and s_92_7 s_92_14
        let s_92_15: u64 = ((s_92_7) & (s_92_14));
        // D s_92_16: select s_92_11 s_92_13 s_92_15
        let s_92_16: u64 = if s_92_11 { s_92_13 } else { s_92_15 };
        // D s_92_17: cast trunc s_92_16 -> u8
        let s_92_17: bool = ((s_92_16) != 0);
        // D s_92_18: cast zx s_92_17 -> bv
        let s_92_18: Bits = Bits::new(s_92_17 as u128, 1u16);
        // C s_92_19: const #1u : u8
        let s_92_19: bool = true;
        // C s_92_20: cast zx s_92_19 -> bv
        let s_92_20: Bits = Bits::new(s_92_19 as u128, 1u16);
        // D s_92_21: cmp-ne s_92_18 s_92_20
        let s_92_21: bool = ((s_92_18) != (s_92_20));
        // D s_92_22: write-var gs#409313 <= s_92_21
        fn_state.gs_409313 = s_92_21;
        // N s_92_23: jump b93
        return block_93(state, tracer, fn_state);
    }
    fn block_93<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_93_0: read-var gs#409313:u8
        let s_93_0: bool = fn_state.gs_409313;
        // N s_93_1: branch s_93_0 b101 b94
        if s_93_0 {
            return block_101(state, tracer, fn_state);
        } else {
            return block_94(state, tracer, fn_state);
        };
    }
    fn block_94<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_94_0: const #10s : i
        let s_94_0: i128 = 10;
        // D s_94_1: read-var u#33455:u32
        let s_94_1: u32 = fn_state.u_33455;
        // D s_94_2: cast zx s_94_1 -> bv
        let s_94_2: Bits = Bits::new(s_94_1 as u128, 32u16);
        // C s_94_3: const #1u : u64
        let s_94_3: u64 = 1;
        // D s_94_4: bit-extract s_94_2 s_94_0 s_94_3
        let s_94_4: Bits = (Bits::new(
            ((s_94_2) >> (s_94_0)).value(),
            u16::try_from(s_94_3).unwrap(),
        ));
        // D s_94_5: cast reint s_94_4 -> u8
        let s_94_5: bool = ((s_94_4.value()) != 0);
        // C s_94_6: const #0s : i
        let s_94_6: i128 = 0;
        // C s_94_7: const #0u : u64
        let s_94_7: u64 = 0;
        // D s_94_8: cast zx s_94_5 -> u64
        let s_94_8: u64 = (s_94_5 as u64);
        // C s_94_9: const #1u : u64
        let s_94_9: u64 = 1;
        // D s_94_10: and s_94_8 s_94_9
        let s_94_10: u64 = ((s_94_8) & (s_94_9));
        // D s_94_11: cmp-eq s_94_10 s_94_9
        let s_94_11: bool = ((s_94_10) == (s_94_9));
        // D s_94_12: lsl s_94_8 s_94_6
        let s_94_12: u64 = s_94_8 << s_94_6;
        // D s_94_13: or s_94_7 s_94_12
        let s_94_13: u64 = ((s_94_7) | (s_94_12));
        // D s_94_14: cmpl s_94_12
        let s_94_14: u64 = !s_94_12;
        // D s_94_15: and s_94_7 s_94_14
        let s_94_15: u64 = ((s_94_7) & (s_94_14));
        // D s_94_16: select s_94_11 s_94_13 s_94_15
        let s_94_16: u64 = if s_94_11 { s_94_13 } else { s_94_15 };
        // D s_94_17: cast trunc s_94_16 -> u8
        let s_94_17: bool = ((s_94_16) != 0);
        // D s_94_18: cast zx s_94_17 -> bv
        let s_94_18: Bits = Bits::new(s_94_17 as u128, 1u16);
        // C s_94_19: const #1u : u8
        let s_94_19: bool = true;
        // C s_94_20: cast zx s_94_19 -> bv
        let s_94_20: Bits = Bits::new(s_94_19 as u128, 1u16);
        // D s_94_21: cmp-ne s_94_18 s_94_20
        let s_94_21: bool = ((s_94_18) != (s_94_20));
        // D s_94_22: write-var gs#409316 <= s_94_21
        fn_state.gs_409316 = s_94_21;
        // N s_94_23: jump b95
        return block_95(state, tracer, fn_state);
    }
    fn block_95<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_95_0: read-var gs#409316:u8
        let s_95_0: bool = fn_state.gs_409316;
        // N s_95_1: branch s_95_0 b100 b96
        if s_95_0 {
            return block_100(state, tracer, fn_state);
        } else {
            return block_96(state, tracer, fn_state);
        };
    }
    fn block_96<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_96_0: const #11s : i
        let s_96_0: i128 = 11;
        // D s_96_1: read-var u#33455:u32
        let s_96_1: u32 = fn_state.u_33455;
        // D s_96_2: cast zx s_96_1 -> bv
        let s_96_2: Bits = Bits::new(s_96_1 as u128, 32u16);
        // C s_96_3: const #1u : u64
        let s_96_3: u64 = 1;
        // D s_96_4: bit-extract s_96_2 s_96_0 s_96_3
        let s_96_4: Bits = (Bits::new(
            ((s_96_2) >> (s_96_0)).value(),
            u16::try_from(s_96_3).unwrap(),
        ));
        // D s_96_5: cast reint s_96_4 -> u8
        let s_96_5: bool = ((s_96_4.value()) != 0);
        // C s_96_6: const #0s : i
        let s_96_6: i128 = 0;
        // C s_96_7: const #0u : u64
        let s_96_7: u64 = 0;
        // D s_96_8: cast zx s_96_5 -> u64
        let s_96_8: u64 = (s_96_5 as u64);
        // C s_96_9: const #1u : u64
        let s_96_9: u64 = 1;
        // D s_96_10: and s_96_8 s_96_9
        let s_96_10: u64 = ((s_96_8) & (s_96_9));
        // D s_96_11: cmp-eq s_96_10 s_96_9
        let s_96_11: bool = ((s_96_10) == (s_96_9));
        // D s_96_12: lsl s_96_8 s_96_6
        let s_96_12: u64 = s_96_8 << s_96_6;
        // D s_96_13: or s_96_7 s_96_12
        let s_96_13: u64 = ((s_96_7) | (s_96_12));
        // D s_96_14: cmpl s_96_12
        let s_96_14: u64 = !s_96_12;
        // D s_96_15: and s_96_7 s_96_14
        let s_96_15: u64 = ((s_96_7) & (s_96_14));
        // D s_96_16: select s_96_11 s_96_13 s_96_15
        let s_96_16: u64 = if s_96_11 { s_96_13 } else { s_96_15 };
        // D s_96_17: cast trunc s_96_16 -> u8
        let s_96_17: bool = ((s_96_16) != 0);
        // D s_96_18: cast zx s_96_17 -> bv
        let s_96_18: Bits = Bits::new(s_96_17 as u128, 1u16);
        // C s_96_19: const #1u : u8
        let s_96_19: bool = true;
        // C s_96_20: cast zx s_96_19 -> bv
        let s_96_20: Bits = Bits::new(s_96_19 as u128, 1u16);
        // D s_96_21: cmp-ne s_96_18 s_96_20
        let s_96_21: bool = ((s_96_18) != (s_96_20));
        // D s_96_22: write-var gs#409319 <= s_96_21
        fn_state.gs_409319 = s_96_21;
        // N s_96_23: jump b97
        return block_97(state, tracer, fn_state);
    }
    fn block_97<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_97_0: read-var gs#409319:u8
        let s_97_0: bool = fn_state.gs_409319;
        // N s_97_1: branch s_97_0 b99 b98
        if s_97_0 {
            return block_99(state, tracer, fn_state);
        } else {
            return block_98(state, tracer, fn_state);
        };
    }
    fn block_98<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_98_0: read-var u#33456:u8
        let s_98_0: u8 = fn_state.u_33456;
        // D s_98_1: read-var u#33457:u8
        let s_98_1: u8 = fn_state.u_33457;
        // D s_98_2: read-var u#33458:u8
        let s_98_2: u8 = fn_state.u_33458;
        // D s_98_3: read-var u#33459:u8
        let s_98_3: u8 = fn_state.u_33459;
        // D s_98_4: call decode_aarch32_instrs_QSUB16_A1enc_A_txt(s_98_0, s_98_1, s_98_2, s_98_3)
        let s_98_4: () = decode_aarch32_instrs_QSUB16_A1enc_A_txt(
            state,
            tracer,
            s_98_0,
            s_98_1,
            s_98_2,
            s_98_3,
        );
        // N s_98_5: return
        return;
    }
    fn block_99<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_99_0: panic
        panic!("{:?}", ());
        // N s_99_1: return
        return;
    }
    fn block_100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_100_0: const #1u : u8
        let s_100_0: bool = true;
        // D s_100_1: write-var gs#409319 <= s_100_0
        fn_state.gs_409319 = s_100_0;
        // N s_100_2: jump b97
        return block_97(state, tracer, fn_state);
    }
    fn block_101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_101_0: const #1u : u8
        let s_101_0: bool = true;
        // D s_101_1: write-var gs#409316 <= s_101_0
        fn_state.gs_409316 = s_101_0;
        // N s_101_2: jump b95
        return block_95(state, tracer, fn_state);
    }
    fn block_102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_102_0: const #1u : u8
        let s_102_0: bool = true;
        // D s_102_1: write-var gs#409313 <= s_102_0
        fn_state.gs_409313 = s_102_0;
        // N s_102_2: jump b93
        return block_93(state, tracer, fn_state);
    }
    fn block_103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_103_0: read-var merge#var.1:struct
        let s_103_0: u32 = fn_state.merge_var._1;
        // D s_103_1: write-var u#33461 <= s_103_0
        fn_state.u_33461 = s_103_0;
        // C s_103_2: const #20s : i
        let s_103_2: i128 = 20;
        // D s_103_3: read-var u#33461:u32
        let s_103_3: u32 = fn_state.u_33461;
        // D s_103_4: cast zx s_103_3 -> bv
        let s_103_4: Bits = Bits::new(s_103_3 as u128, 32u16);
        // C s_103_5: const #1s : i64
        let s_103_5: i64 = 1;
        // C s_103_6: cast zx s_103_5 -> i
        let s_103_6: i128 = (i128::try_from(s_103_5).unwrap());
        // C s_103_7: const #7s : i
        let s_103_7: i128 = 7;
        // C s_103_8: add s_103_7 s_103_6
        let s_103_8: i128 = (s_103_7 + s_103_6);
        // D s_103_9: bit-extract s_103_4 s_103_2 s_103_8
        let s_103_9: Bits = (Bits::new(
            ((s_103_4) >> (s_103_2)).value(),
            u16::try_from(s_103_8).unwrap(),
        ));
        // D s_103_10: cast reint s_103_9 -> u8
        let s_103_10: u8 = (s_103_9.value() as u8);
        // D s_103_11: cast zx s_103_10 -> bv
        let s_103_11: Bits = Bits::new(s_103_10 as u128, 8u16);
        // C s_103_12: const #98u : u8
        let s_103_12: u8 = 98;
        // C s_103_13: cast zx s_103_12 -> bv
        let s_103_13: Bits = Bits::new(s_103_12 as u128, 8u16);
        // D s_103_14: cmp-eq s_103_11 s_103_13
        let s_103_14: bool = ((s_103_11) == (s_103_13));
        // N s_103_15: branch s_103_14 b1413 b104
        if s_103_14 {
            return block_1413(state, tracer, fn_state);
        } else {
            return block_104(state, tracer, fn_state);
        };
    }
    fn block_104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_104_0: const #0u : u8
        let s_104_0: bool = false;
        // D s_104_1: write-var gs#409325 <= s_104_0
        fn_state.gs_409325 = s_104_0;
        // N s_104_2: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_105_0: read-var gs#409325:u8
        let s_105_0: bool = fn_state.gs_409325;
        // N s_105_1: branch s_105_0 b1409 b106
        if s_105_0 {
            return block_1409(state, tracer, fn_state);
        } else {
            return block_106(state, tracer, fn_state);
        };
    }
    fn block_106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_106_0: const #0u : u8
        let s_106_0: bool = false;
        // D s_106_1: write-var gs#409330 <= s_106_0
        fn_state.gs_409330 = s_106_0;
        // N s_106_2: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_107_0: read-var gs#409330:u8
        let s_107_0: bool = fn_state.gs_409330;
        // D s_107_1: not s_107_0
        let s_107_1: bool = !s_107_0;
        // N s_107_2: branch s_107_1 b120 b108
        if s_107_1 {
            return block_120(state, tracer, fn_state);
        } else {
            return block_108(state, tracer, fn_state);
        };
    }
    fn block_108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_108_0: const #3080s : i
        let s_108_0: i128 = 3080;
        // C s_108_1: const #14696u : u32
        let s_108_1: u32 = 14696;
        // N s_108_2: write-reg s_108_1 <= s_108_0
        let s_108_2: () = {
            state.write_register::<i128>(s_108_1 as isize, s_108_0);
            tracer.write_register(s_108_1 as isize, s_108_0);
        };
        // C s_108_3: const #28s : i
        let s_108_3: i128 = 28;
        // C s_108_4: const #4s : i
        let s_108_4: i128 = 4;
        // D s_108_5: read-var u#33461:u32
        let s_108_5: u32 = fn_state.u_33461;
        // D s_108_6: cast zx s_108_5 -> bv
        let s_108_6: Bits = Bits::new(s_108_5 as u128, 32u16);
        // D s_108_7: bit-extract s_108_6 s_108_3 s_108_4
        let s_108_7: Bits = (Bits::new(
            ((s_108_6) >> (s_108_3)).value(),
            u16::try_from(s_108_4).unwrap(),
        ));
        // D s_108_8: cast reint s_108_7 -> u8
        let s_108_8: u8 = (s_108_7.value() as u8);
        // D s_108_9: write-var u#33462 <= s_108_8
        fn_state.u_33462 = s_108_8;
        // C s_108_10: const #16s : i
        let s_108_10: i128 = 16;
        // C s_108_11: const #4s : i
        let s_108_11: i128 = 4;
        // D s_108_12: read-var u#33461:u32
        let s_108_12: u32 = fn_state.u_33461;
        // D s_108_13: cast zx s_108_12 -> bv
        let s_108_13: Bits = Bits::new(s_108_12 as u128, 32u16);
        // D s_108_14: bit-extract s_108_13 s_108_10 s_108_11
        let s_108_14: Bits = (Bits::new(
            ((s_108_13) >> (s_108_10)).value(),
            u16::try_from(s_108_11).unwrap(),
        ));
        // D s_108_15: cast reint s_108_14 -> u8
        let s_108_15: u8 = (s_108_14.value() as u8);
        // D s_108_16: write-var u#33463 <= s_108_15
        fn_state.u_33463 = s_108_15;
        // C s_108_17: const #12s : i
        let s_108_17: i128 = 12;
        // C s_108_18: const #4s : i
        let s_108_18: i128 = 4;
        // D s_108_19: read-var u#33461:u32
        let s_108_19: u32 = fn_state.u_33461;
        // D s_108_20: cast zx s_108_19 -> bv
        let s_108_20: Bits = Bits::new(s_108_19 as u128, 32u16);
        // D s_108_21: bit-extract s_108_20 s_108_17 s_108_18
        let s_108_21: Bits = (Bits::new(
            ((s_108_20) >> (s_108_17)).value(),
            u16::try_from(s_108_18).unwrap(),
        ));
        // D s_108_22: cast reint s_108_21 -> u8
        let s_108_22: u8 = (s_108_21.value() as u8);
        // D s_108_23: write-var u#33464 <= s_108_22
        fn_state.u_33464 = s_108_22;
        // C s_108_24: const #0s : i
        let s_108_24: i128 = 0;
        // C s_108_25: const #4s : i
        let s_108_25: i128 = 4;
        // D s_108_26: read-var u#33461:u32
        let s_108_26: u32 = fn_state.u_33461;
        // D s_108_27: cast zx s_108_26 -> bv
        let s_108_27: Bits = Bits::new(s_108_26 as u128, 32u16);
        // D s_108_28: bit-extract s_108_27 s_108_24 s_108_25
        let s_108_28: Bits = (Bits::new(
            ((s_108_27) >> (s_108_24)).value(),
            u16::try_from(s_108_25).unwrap(),
        ));
        // D s_108_29: cast reint s_108_28 -> u8
        let s_108_29: u8 = (s_108_28.value() as u8);
        // D s_108_30: write-var u#33465 <= s_108_29
        fn_state.u_33465 = s_108_29;
        // C s_108_31: const #8s : i
        let s_108_31: i128 = 8;
        // D s_108_32: read-var u#33461:u32
        let s_108_32: u32 = fn_state.u_33461;
        // D s_108_33: cast zx s_108_32 -> bv
        let s_108_33: Bits = Bits::new(s_108_32 as u128, 32u16);
        // C s_108_34: const #1u : u64
        let s_108_34: u64 = 1;
        // D s_108_35: bit-extract s_108_33 s_108_31 s_108_34
        let s_108_35: Bits = (Bits::new(
            ((s_108_33) >> (s_108_31)).value(),
            u16::try_from(s_108_34).unwrap(),
        ));
        // D s_108_36: cast reint s_108_35 -> u8
        let s_108_36: bool = ((s_108_35.value()) != 0);
        // C s_108_37: const #0s : i
        let s_108_37: i128 = 0;
        // C s_108_38: const #0u : u64
        let s_108_38: u64 = 0;
        // D s_108_39: cast zx s_108_36 -> u64
        let s_108_39: u64 = (s_108_36 as u64);
        // C s_108_40: const #1u : u64
        let s_108_40: u64 = 1;
        // D s_108_41: and s_108_39 s_108_40
        let s_108_41: u64 = ((s_108_39) & (s_108_40));
        // D s_108_42: cmp-eq s_108_41 s_108_40
        let s_108_42: bool = ((s_108_41) == (s_108_40));
        // D s_108_43: lsl s_108_39 s_108_37
        let s_108_43: u64 = s_108_39 << s_108_37;
        // D s_108_44: or s_108_38 s_108_43
        let s_108_44: u64 = ((s_108_38) | (s_108_43));
        // D s_108_45: cmpl s_108_43
        let s_108_45: u64 = !s_108_43;
        // D s_108_46: and s_108_38 s_108_45
        let s_108_46: u64 = ((s_108_38) & (s_108_45));
        // D s_108_47: select s_108_42 s_108_44 s_108_46
        let s_108_47: u64 = if s_108_42 { s_108_44 } else { s_108_46 };
        // D s_108_48: cast trunc s_108_47 -> u8
        let s_108_48: bool = ((s_108_47) != 0);
        // D s_108_49: cast zx s_108_48 -> bv
        let s_108_49: Bits = Bits::new(s_108_48 as u128, 1u16);
        // C s_108_50: const #1u : u8
        let s_108_50: bool = true;
        // C s_108_51: cast zx s_108_50 -> bv
        let s_108_51: Bits = Bits::new(s_108_50 as u128, 1u16);
        // D s_108_52: cmp-ne s_108_49 s_108_51
        let s_108_52: bool = ((s_108_49) != (s_108_51));
        // N s_108_53: branch s_108_52 b119 b109
        if s_108_52 {
            return block_119(state, tracer, fn_state);
        } else {
            return block_109(state, tracer, fn_state);
        };
    }
    fn block_109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_109_0: const #9s : i
        let s_109_0: i128 = 9;
        // D s_109_1: read-var u#33461:u32
        let s_109_1: u32 = fn_state.u_33461;
        // D s_109_2: cast zx s_109_1 -> bv
        let s_109_2: Bits = Bits::new(s_109_1 as u128, 32u16);
        // C s_109_3: const #1u : u64
        let s_109_3: u64 = 1;
        // D s_109_4: bit-extract s_109_2 s_109_0 s_109_3
        let s_109_4: Bits = (Bits::new(
            ((s_109_2) >> (s_109_0)).value(),
            u16::try_from(s_109_3).unwrap(),
        ));
        // D s_109_5: cast reint s_109_4 -> u8
        let s_109_5: bool = ((s_109_4.value()) != 0);
        // C s_109_6: const #0s : i
        let s_109_6: i128 = 0;
        // C s_109_7: const #0u : u64
        let s_109_7: u64 = 0;
        // D s_109_8: cast zx s_109_5 -> u64
        let s_109_8: u64 = (s_109_5 as u64);
        // C s_109_9: const #1u : u64
        let s_109_9: u64 = 1;
        // D s_109_10: and s_109_8 s_109_9
        let s_109_10: u64 = ((s_109_8) & (s_109_9));
        // D s_109_11: cmp-eq s_109_10 s_109_9
        let s_109_11: bool = ((s_109_10) == (s_109_9));
        // D s_109_12: lsl s_109_8 s_109_6
        let s_109_12: u64 = s_109_8 << s_109_6;
        // D s_109_13: or s_109_7 s_109_12
        let s_109_13: u64 = ((s_109_7) | (s_109_12));
        // D s_109_14: cmpl s_109_12
        let s_109_14: u64 = !s_109_12;
        // D s_109_15: and s_109_7 s_109_14
        let s_109_15: u64 = ((s_109_7) & (s_109_14));
        // D s_109_16: select s_109_11 s_109_13 s_109_15
        let s_109_16: u64 = if s_109_11 { s_109_13 } else { s_109_15 };
        // D s_109_17: cast trunc s_109_16 -> u8
        let s_109_17: bool = ((s_109_16) != 0);
        // D s_109_18: cast zx s_109_17 -> bv
        let s_109_18: Bits = Bits::new(s_109_17 as u128, 1u16);
        // C s_109_19: const #1u : u8
        let s_109_19: bool = true;
        // C s_109_20: cast zx s_109_19 -> bv
        let s_109_20: Bits = Bits::new(s_109_19 as u128, 1u16);
        // D s_109_21: cmp-ne s_109_18 s_109_20
        let s_109_21: bool = ((s_109_18) != (s_109_20));
        // D s_109_22: write-var gs#409345 <= s_109_21
        fn_state.gs_409345 = s_109_21;
        // N s_109_23: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_110_0: read-var gs#409345:u8
        let s_110_0: bool = fn_state.gs_409345;
        // N s_110_1: branch s_110_0 b118 b111
        if s_110_0 {
            return block_118(state, tracer, fn_state);
        } else {
            return block_111(state, tracer, fn_state);
        };
    }
    fn block_111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_111_0: const #10s : i
        let s_111_0: i128 = 10;
        // D s_111_1: read-var u#33461:u32
        let s_111_1: u32 = fn_state.u_33461;
        // D s_111_2: cast zx s_111_1 -> bv
        let s_111_2: Bits = Bits::new(s_111_1 as u128, 32u16);
        // C s_111_3: const #1u : u64
        let s_111_3: u64 = 1;
        // D s_111_4: bit-extract s_111_2 s_111_0 s_111_3
        let s_111_4: Bits = (Bits::new(
            ((s_111_2) >> (s_111_0)).value(),
            u16::try_from(s_111_3).unwrap(),
        ));
        // D s_111_5: cast reint s_111_4 -> u8
        let s_111_5: bool = ((s_111_4.value()) != 0);
        // C s_111_6: const #0s : i
        let s_111_6: i128 = 0;
        // C s_111_7: const #0u : u64
        let s_111_7: u64 = 0;
        // D s_111_8: cast zx s_111_5 -> u64
        let s_111_8: u64 = (s_111_5 as u64);
        // C s_111_9: const #1u : u64
        let s_111_9: u64 = 1;
        // D s_111_10: and s_111_8 s_111_9
        let s_111_10: u64 = ((s_111_8) & (s_111_9));
        // D s_111_11: cmp-eq s_111_10 s_111_9
        let s_111_11: bool = ((s_111_10) == (s_111_9));
        // D s_111_12: lsl s_111_8 s_111_6
        let s_111_12: u64 = s_111_8 << s_111_6;
        // D s_111_13: or s_111_7 s_111_12
        let s_111_13: u64 = ((s_111_7) | (s_111_12));
        // D s_111_14: cmpl s_111_12
        let s_111_14: u64 = !s_111_12;
        // D s_111_15: and s_111_7 s_111_14
        let s_111_15: u64 = ((s_111_7) & (s_111_14));
        // D s_111_16: select s_111_11 s_111_13 s_111_15
        let s_111_16: u64 = if s_111_11 { s_111_13 } else { s_111_15 };
        // D s_111_17: cast trunc s_111_16 -> u8
        let s_111_17: bool = ((s_111_16) != 0);
        // D s_111_18: cast zx s_111_17 -> bv
        let s_111_18: Bits = Bits::new(s_111_17 as u128, 1u16);
        // C s_111_19: const #1u : u8
        let s_111_19: bool = true;
        // C s_111_20: cast zx s_111_19 -> bv
        let s_111_20: Bits = Bits::new(s_111_19 as u128, 1u16);
        // D s_111_21: cmp-ne s_111_18 s_111_20
        let s_111_21: bool = ((s_111_18) != (s_111_20));
        // D s_111_22: write-var gs#409348 <= s_111_21
        fn_state.gs_409348 = s_111_21;
        // N s_111_23: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_112_0: read-var gs#409348:u8
        let s_112_0: bool = fn_state.gs_409348;
        // N s_112_1: branch s_112_0 b117 b113
        if s_112_0 {
            return block_117(state, tracer, fn_state);
        } else {
            return block_113(state, tracer, fn_state);
        };
    }
    fn block_113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_113_0: const #11s : i
        let s_113_0: i128 = 11;
        // D s_113_1: read-var u#33461:u32
        let s_113_1: u32 = fn_state.u_33461;
        // D s_113_2: cast zx s_113_1 -> bv
        let s_113_2: Bits = Bits::new(s_113_1 as u128, 32u16);
        // C s_113_3: const #1u : u64
        let s_113_3: u64 = 1;
        // D s_113_4: bit-extract s_113_2 s_113_0 s_113_3
        let s_113_4: Bits = (Bits::new(
            ((s_113_2) >> (s_113_0)).value(),
            u16::try_from(s_113_3).unwrap(),
        ));
        // D s_113_5: cast reint s_113_4 -> u8
        let s_113_5: bool = ((s_113_4.value()) != 0);
        // C s_113_6: const #0s : i
        let s_113_6: i128 = 0;
        // C s_113_7: const #0u : u64
        let s_113_7: u64 = 0;
        // D s_113_8: cast zx s_113_5 -> u64
        let s_113_8: u64 = (s_113_5 as u64);
        // C s_113_9: const #1u : u64
        let s_113_9: u64 = 1;
        // D s_113_10: and s_113_8 s_113_9
        let s_113_10: u64 = ((s_113_8) & (s_113_9));
        // D s_113_11: cmp-eq s_113_10 s_113_9
        let s_113_11: bool = ((s_113_10) == (s_113_9));
        // D s_113_12: lsl s_113_8 s_113_6
        let s_113_12: u64 = s_113_8 << s_113_6;
        // D s_113_13: or s_113_7 s_113_12
        let s_113_13: u64 = ((s_113_7) | (s_113_12));
        // D s_113_14: cmpl s_113_12
        let s_113_14: u64 = !s_113_12;
        // D s_113_15: and s_113_7 s_113_14
        let s_113_15: u64 = ((s_113_7) & (s_113_14));
        // D s_113_16: select s_113_11 s_113_13 s_113_15
        let s_113_16: u64 = if s_113_11 { s_113_13 } else { s_113_15 };
        // D s_113_17: cast trunc s_113_16 -> u8
        let s_113_17: bool = ((s_113_16) != 0);
        // D s_113_18: cast zx s_113_17 -> bv
        let s_113_18: Bits = Bits::new(s_113_17 as u128, 1u16);
        // C s_113_19: const #1u : u8
        let s_113_19: bool = true;
        // C s_113_20: cast zx s_113_19 -> bv
        let s_113_20: Bits = Bits::new(s_113_19 as u128, 1u16);
        // D s_113_21: cmp-ne s_113_18 s_113_20
        let s_113_21: bool = ((s_113_18) != (s_113_20));
        // D s_113_22: write-var gs#409351 <= s_113_21
        fn_state.gs_409351 = s_113_21;
        // N s_113_23: jump b114
        return block_114(state, tracer, fn_state);
    }
    fn block_114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_114_0: read-var gs#409351:u8
        let s_114_0: bool = fn_state.gs_409351;
        // N s_114_1: branch s_114_0 b116 b115
        if s_114_0 {
            return block_116(state, tracer, fn_state);
        } else {
            return block_115(state, tracer, fn_state);
        };
    }
    fn block_115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_115_0: read-var u#33462:u8
        let s_115_0: u8 = fn_state.u_33462;
        // D s_115_1: read-var u#33463:u8
        let s_115_1: u8 = fn_state.u_33463;
        // D s_115_2: read-var u#33464:u8
        let s_115_2: u8 = fn_state.u_33464;
        // D s_115_3: read-var u#33465:u8
        let s_115_3: u8 = fn_state.u_33465;
        // D s_115_4: call decode_aarch32_instrs_QSUB8_A1enc_A_txt(s_115_0, s_115_1, s_115_2, s_115_3)
        let s_115_4: () = decode_aarch32_instrs_QSUB8_A1enc_A_txt(
            state,
            tracer,
            s_115_0,
            s_115_1,
            s_115_2,
            s_115_3,
        );
        // N s_115_5: return
        return;
    }
    fn block_116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_116_0: panic
        panic!("{:?}", ());
        // N s_116_1: return
        return;
    }
    fn block_117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_117_0: const #1u : u8
        let s_117_0: bool = true;
        // D s_117_1: write-var gs#409351 <= s_117_0
        fn_state.gs_409351 = s_117_0;
        // N s_117_2: jump b114
        return block_114(state, tracer, fn_state);
    }
    fn block_118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_118_0: const #1u : u8
        let s_118_0: bool = true;
        // D s_118_1: write-var gs#409348 <= s_118_0
        fn_state.gs_409348 = s_118_0;
        // N s_118_2: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_119_0: const #1u : u8
        let s_119_0: bool = true;
        // D s_119_1: write-var gs#409345 <= s_119_0
        fn_state.gs_409345 = s_119_0;
        // N s_119_2: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_120_0: read-var merge#var.1:struct
        let s_120_0: u32 = fn_state.merge_var._1;
        // D s_120_1: write-var u#33467 <= s_120_0
        fn_state.u_33467 = s_120_0;
        // C s_120_2: const #16s : i
        let s_120_2: i128 = 16;
        // D s_120_3: read-var u#33467:u32
        let s_120_3: u32 = fn_state.u_33467;
        // D s_120_4: cast zx s_120_3 -> bv
        let s_120_4: Bits = Bits::new(s_120_3 as u128, 32u16);
        // C s_120_5: const #1s : i64
        let s_120_5: i64 = 1;
        // C s_120_6: cast zx s_120_5 -> i
        let s_120_6: i128 = (i128::try_from(s_120_5).unwrap());
        // C s_120_7: const #11s : i
        let s_120_7: i128 = 11;
        // C s_120_8: add s_120_7 s_120_6
        let s_120_8: i128 = (s_120_7 + s_120_6);
        // D s_120_9: bit-extract s_120_4 s_120_2 s_120_8
        let s_120_9: Bits = (Bits::new(
            ((s_120_4) >> (s_120_2)).value(),
            u16::try_from(s_120_8).unwrap(),
        ));
        // D s_120_10: cast reint s_120_9 -> u12
        let s_120_10: u16 = (s_120_9.value() as u16);
        // D s_120_11: cast zx s_120_10 -> bv
        let s_120_11: Bits = Bits::new(s_120_10 as u128, 12u16);
        // C s_120_12: const #1791u : u12
        let s_120_12: u16 = 1791;
        // C s_120_13: cast zx s_120_12 -> bv
        let s_120_13: Bits = Bits::new(s_120_12 as u128, 12u16);
        // D s_120_14: cmp-eq s_120_11 s_120_13
        let s_120_14: bool = ((s_120_11) == (s_120_13));
        // N s_120_15: branch s_120_14 b1408 b121
        if s_120_14 {
            return block_1408(state, tracer, fn_state);
        } else {
            return block_121(state, tracer, fn_state);
        };
    }
    fn block_121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_121_0: const #0u : u8
        let s_121_0: bool = false;
        // D s_121_1: write-var gs#409357 <= s_121_0
        fn_state.gs_409357 = s_121_0;
        // N s_121_2: jump b122
        return block_122(state, tracer, fn_state);
    }
    fn block_122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_122_0: read-var gs#409357:u8
        let s_122_0: bool = fn_state.gs_409357;
        // N s_122_1: branch s_122_0 b1404 b123
        if s_122_0 {
            return block_1404(state, tracer, fn_state);
        } else {
            return block_123(state, tracer, fn_state);
        };
    }
    fn block_123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_123_0: const #0u : u8
        let s_123_0: bool = false;
        // D s_123_1: write-var gs#409362 <= s_123_0
        fn_state.gs_409362 = s_123_0;
        // N s_123_2: jump b124
        return block_124(state, tracer, fn_state);
    }
    fn block_124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_124_0: read-var gs#409362:u8
        let s_124_0: bool = fn_state.gs_409362;
        // D s_124_1: not s_124_0
        let s_124_1: bool = !s_124_0;
        // N s_124_2: branch s_124_1 b149 b125
        if s_124_1 {
            return block_149(state, tracer, fn_state);
        } else {
            return block_125(state, tracer, fn_state);
        };
    }
    fn block_125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_125_0: const #3084s : i
        let s_125_0: i128 = 3084;
        // C s_125_1: const #14696u : u32
        let s_125_1: u32 = 14696;
        // N s_125_2: write-reg s_125_1 <= s_125_0
        let s_125_2: () = {
            state.write_register::<i128>(s_125_1 as isize, s_125_0);
            tracer.write_register(s_125_1 as isize, s_125_0);
        };
        // C s_125_3: const #28s : i
        let s_125_3: i128 = 28;
        // C s_125_4: const #4s : i
        let s_125_4: i128 = 4;
        // D s_125_5: read-var u#33467:u32
        let s_125_5: u32 = fn_state.u_33467;
        // D s_125_6: cast zx s_125_5 -> bv
        let s_125_6: Bits = Bits::new(s_125_5 as u128, 32u16);
        // D s_125_7: bit-extract s_125_6 s_125_3 s_125_4
        let s_125_7: Bits = (Bits::new(
            ((s_125_6) >> (s_125_3)).value(),
            u16::try_from(s_125_4).unwrap(),
        ));
        // D s_125_8: cast reint s_125_7 -> u8
        let s_125_8: u8 = (s_125_7.value() as u8);
        // D s_125_9: write-var u#33468 <= s_125_8
        fn_state.u_33468 = s_125_8;
        // C s_125_10: const #12s : i
        let s_125_10: i128 = 12;
        // C s_125_11: const #4s : i
        let s_125_11: i128 = 4;
        // D s_125_12: read-var u#33467:u32
        let s_125_12: u32 = fn_state.u_33467;
        // D s_125_13: cast zx s_125_12 -> bv
        let s_125_13: Bits = Bits::new(s_125_12 as u128, 32u16);
        // D s_125_14: bit-extract s_125_13 s_125_10 s_125_11
        let s_125_14: Bits = (Bits::new(
            ((s_125_13) >> (s_125_10)).value(),
            u16::try_from(s_125_11).unwrap(),
        ));
        // D s_125_15: cast reint s_125_14 -> u8
        let s_125_15: u8 = (s_125_14.value() as u8);
        // D s_125_16: write-var u#33469 <= s_125_15
        fn_state.u_33469 = s_125_15;
        // C s_125_17: const #0s : i
        let s_125_17: i128 = 0;
        // C s_125_18: const #4s : i
        let s_125_18: i128 = 4;
        // D s_125_19: read-var u#33467:u32
        let s_125_19: u32 = fn_state.u_33467;
        // D s_125_20: cast zx s_125_19 -> bv
        let s_125_20: Bits = Bits::new(s_125_19 as u128, 32u16);
        // D s_125_21: bit-extract s_125_20 s_125_17 s_125_18
        let s_125_21: Bits = (Bits::new(
            ((s_125_20) >> (s_125_17)).value(),
            u16::try_from(s_125_18).unwrap(),
        ));
        // D s_125_22: cast reint s_125_21 -> u8
        let s_125_22: u8 = (s_125_21.value() as u8);
        // D s_125_23: write-var u#33470 <= s_125_22
        fn_state.u_33470 = s_125_22;
        // C s_125_24: const #16s : i
        let s_125_24: i128 = 16;
        // D s_125_25: read-var u#33467:u32
        let s_125_25: u32 = fn_state.u_33467;
        // D s_125_26: cast zx s_125_25 -> bv
        let s_125_26: Bits = Bits::new(s_125_25 as u128, 32u16);
        // C s_125_27: const #1u : u64
        let s_125_27: u64 = 1;
        // D s_125_28: bit-extract s_125_26 s_125_24 s_125_27
        let s_125_28: Bits = (Bits::new(
            ((s_125_26) >> (s_125_24)).value(),
            u16::try_from(s_125_27).unwrap(),
        ));
        // D s_125_29: cast reint s_125_28 -> u8
        let s_125_29: bool = ((s_125_28.value()) != 0);
        // C s_125_30: const #0s : i
        let s_125_30: i128 = 0;
        // C s_125_31: const #0u : u64
        let s_125_31: u64 = 0;
        // D s_125_32: cast zx s_125_29 -> u64
        let s_125_32: u64 = (s_125_29 as u64);
        // C s_125_33: const #1u : u64
        let s_125_33: u64 = 1;
        // D s_125_34: and s_125_32 s_125_33
        let s_125_34: u64 = ((s_125_32) & (s_125_33));
        // D s_125_35: cmp-eq s_125_34 s_125_33
        let s_125_35: bool = ((s_125_34) == (s_125_33));
        // D s_125_36: lsl s_125_32 s_125_30
        let s_125_36: u64 = s_125_32 << s_125_30;
        // D s_125_37: or s_125_31 s_125_36
        let s_125_37: u64 = ((s_125_31) | (s_125_36));
        // D s_125_38: cmpl s_125_36
        let s_125_38: u64 = !s_125_36;
        // D s_125_39: and s_125_31 s_125_38
        let s_125_39: u64 = ((s_125_31) & (s_125_38));
        // D s_125_40: select s_125_35 s_125_37 s_125_39
        let s_125_40: u64 = if s_125_35 { s_125_37 } else { s_125_39 };
        // D s_125_41: cast trunc s_125_40 -> u8
        let s_125_41: bool = ((s_125_40) != 0);
        // D s_125_42: cast zx s_125_41 -> bv
        let s_125_42: Bits = Bits::new(s_125_41 as u128, 1u16);
        // C s_125_43: const #1u : u8
        let s_125_43: bool = true;
        // C s_125_44: cast zx s_125_43 -> bv
        let s_125_44: Bits = Bits::new(s_125_43 as u128, 1u16);
        // D s_125_45: cmp-ne s_125_42 s_125_44
        let s_125_45: bool = ((s_125_42) != (s_125_44));
        // N s_125_46: branch s_125_45 b148 b126
        if s_125_45 {
            return block_148(state, tracer, fn_state);
        } else {
            return block_126(state, tracer, fn_state);
        };
    }
    fn block_126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_126_0: const #17s : i
        let s_126_0: i128 = 17;
        // D s_126_1: read-var u#33467:u32
        let s_126_1: u32 = fn_state.u_33467;
        // D s_126_2: cast zx s_126_1 -> bv
        let s_126_2: Bits = Bits::new(s_126_1 as u128, 32u16);
        // C s_126_3: const #1u : u64
        let s_126_3: u64 = 1;
        // D s_126_4: bit-extract s_126_2 s_126_0 s_126_3
        let s_126_4: Bits = (Bits::new(
            ((s_126_2) >> (s_126_0)).value(),
            u16::try_from(s_126_3).unwrap(),
        ));
        // D s_126_5: cast reint s_126_4 -> u8
        let s_126_5: bool = ((s_126_4.value()) != 0);
        // C s_126_6: const #0s : i
        let s_126_6: i128 = 0;
        // C s_126_7: const #0u : u64
        let s_126_7: u64 = 0;
        // D s_126_8: cast zx s_126_5 -> u64
        let s_126_8: u64 = (s_126_5 as u64);
        // C s_126_9: const #1u : u64
        let s_126_9: u64 = 1;
        // D s_126_10: and s_126_8 s_126_9
        let s_126_10: u64 = ((s_126_8) & (s_126_9));
        // D s_126_11: cmp-eq s_126_10 s_126_9
        let s_126_11: bool = ((s_126_10) == (s_126_9));
        // D s_126_12: lsl s_126_8 s_126_6
        let s_126_12: u64 = s_126_8 << s_126_6;
        // D s_126_13: or s_126_7 s_126_12
        let s_126_13: u64 = ((s_126_7) | (s_126_12));
        // D s_126_14: cmpl s_126_12
        let s_126_14: u64 = !s_126_12;
        // D s_126_15: and s_126_7 s_126_14
        let s_126_15: u64 = ((s_126_7) & (s_126_14));
        // D s_126_16: select s_126_11 s_126_13 s_126_15
        let s_126_16: u64 = if s_126_11 { s_126_13 } else { s_126_15 };
        // D s_126_17: cast trunc s_126_16 -> u8
        let s_126_17: bool = ((s_126_16) != 0);
        // D s_126_18: cast zx s_126_17 -> bv
        let s_126_18: Bits = Bits::new(s_126_17 as u128, 1u16);
        // C s_126_19: const #1u : u8
        let s_126_19: bool = true;
        // C s_126_20: cast zx s_126_19 -> bv
        let s_126_20: Bits = Bits::new(s_126_19 as u128, 1u16);
        // D s_126_21: cmp-ne s_126_18 s_126_20
        let s_126_21: bool = ((s_126_18) != (s_126_20));
        // D s_126_22: write-var gs#409375 <= s_126_21
        fn_state.gs_409375 = s_126_21;
        // N s_126_23: jump b127
        return block_127(state, tracer, fn_state);
    }
    fn block_127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_127_0: read-var gs#409375:u8
        let s_127_0: bool = fn_state.gs_409375;
        // N s_127_1: branch s_127_0 b147 b128
        if s_127_0 {
            return block_147(state, tracer, fn_state);
        } else {
            return block_128(state, tracer, fn_state);
        };
    }
    fn block_128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_128_0: const #18s : i
        let s_128_0: i128 = 18;
        // D s_128_1: read-var u#33467:u32
        let s_128_1: u32 = fn_state.u_33467;
        // D s_128_2: cast zx s_128_1 -> bv
        let s_128_2: Bits = Bits::new(s_128_1 as u128, 32u16);
        // C s_128_3: const #1u : u64
        let s_128_3: u64 = 1;
        // D s_128_4: bit-extract s_128_2 s_128_0 s_128_3
        let s_128_4: Bits = (Bits::new(
            ((s_128_2) >> (s_128_0)).value(),
            u16::try_from(s_128_3).unwrap(),
        ));
        // D s_128_5: cast reint s_128_4 -> u8
        let s_128_5: bool = ((s_128_4.value()) != 0);
        // C s_128_6: const #0s : i
        let s_128_6: i128 = 0;
        // C s_128_7: const #0u : u64
        let s_128_7: u64 = 0;
        // D s_128_8: cast zx s_128_5 -> u64
        let s_128_8: u64 = (s_128_5 as u64);
        // C s_128_9: const #1u : u64
        let s_128_9: u64 = 1;
        // D s_128_10: and s_128_8 s_128_9
        let s_128_10: u64 = ((s_128_8) & (s_128_9));
        // D s_128_11: cmp-eq s_128_10 s_128_9
        let s_128_11: bool = ((s_128_10) == (s_128_9));
        // D s_128_12: lsl s_128_8 s_128_6
        let s_128_12: u64 = s_128_8 << s_128_6;
        // D s_128_13: or s_128_7 s_128_12
        let s_128_13: u64 = ((s_128_7) | (s_128_12));
        // D s_128_14: cmpl s_128_12
        let s_128_14: u64 = !s_128_12;
        // D s_128_15: and s_128_7 s_128_14
        let s_128_15: u64 = ((s_128_7) & (s_128_14));
        // D s_128_16: select s_128_11 s_128_13 s_128_15
        let s_128_16: u64 = if s_128_11 { s_128_13 } else { s_128_15 };
        // D s_128_17: cast trunc s_128_16 -> u8
        let s_128_17: bool = ((s_128_16) != 0);
        // D s_128_18: cast zx s_128_17 -> bv
        let s_128_18: Bits = Bits::new(s_128_17 as u128, 1u16);
        // C s_128_19: const #1u : u8
        let s_128_19: bool = true;
        // C s_128_20: cast zx s_128_19 -> bv
        let s_128_20: Bits = Bits::new(s_128_19 as u128, 1u16);
        // D s_128_21: cmp-ne s_128_18 s_128_20
        let s_128_21: bool = ((s_128_18) != (s_128_20));
        // D s_128_22: write-var gs#409378 <= s_128_21
        fn_state.gs_409378 = s_128_21;
        // N s_128_23: jump b129
        return block_129(state, tracer, fn_state);
    }
    fn block_129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_129_0: read-var gs#409378:u8
        let s_129_0: bool = fn_state.gs_409378;
        // N s_129_1: branch s_129_0 b146 b130
        if s_129_0 {
            return block_146(state, tracer, fn_state);
        } else {
            return block_130(state, tracer, fn_state);
        };
    }
    fn block_130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_130_0: const #19s : i
        let s_130_0: i128 = 19;
        // D s_130_1: read-var u#33467:u32
        let s_130_1: u32 = fn_state.u_33467;
        // D s_130_2: cast zx s_130_1 -> bv
        let s_130_2: Bits = Bits::new(s_130_1 as u128, 32u16);
        // C s_130_3: const #1u : u64
        let s_130_3: u64 = 1;
        // D s_130_4: bit-extract s_130_2 s_130_0 s_130_3
        let s_130_4: Bits = (Bits::new(
            ((s_130_2) >> (s_130_0)).value(),
            u16::try_from(s_130_3).unwrap(),
        ));
        // D s_130_5: cast reint s_130_4 -> u8
        let s_130_5: bool = ((s_130_4.value()) != 0);
        // C s_130_6: const #0s : i
        let s_130_6: i128 = 0;
        // C s_130_7: const #0u : u64
        let s_130_7: u64 = 0;
        // D s_130_8: cast zx s_130_5 -> u64
        let s_130_8: u64 = (s_130_5 as u64);
        // C s_130_9: const #1u : u64
        let s_130_9: u64 = 1;
        // D s_130_10: and s_130_8 s_130_9
        let s_130_10: u64 = ((s_130_8) & (s_130_9));
        // D s_130_11: cmp-eq s_130_10 s_130_9
        let s_130_11: bool = ((s_130_10) == (s_130_9));
        // D s_130_12: lsl s_130_8 s_130_6
        let s_130_12: u64 = s_130_8 << s_130_6;
        // D s_130_13: or s_130_7 s_130_12
        let s_130_13: u64 = ((s_130_7) | (s_130_12));
        // D s_130_14: cmpl s_130_12
        let s_130_14: u64 = !s_130_12;
        // D s_130_15: and s_130_7 s_130_14
        let s_130_15: u64 = ((s_130_7) & (s_130_14));
        // D s_130_16: select s_130_11 s_130_13 s_130_15
        let s_130_16: u64 = if s_130_11 { s_130_13 } else { s_130_15 };
        // D s_130_17: cast trunc s_130_16 -> u8
        let s_130_17: bool = ((s_130_16) != 0);
        // D s_130_18: cast zx s_130_17 -> bv
        let s_130_18: Bits = Bits::new(s_130_17 as u128, 1u16);
        // C s_130_19: const #1u : u8
        let s_130_19: bool = true;
        // C s_130_20: cast zx s_130_19 -> bv
        let s_130_20: Bits = Bits::new(s_130_19 as u128, 1u16);
        // D s_130_21: cmp-ne s_130_18 s_130_20
        let s_130_21: bool = ((s_130_18) != (s_130_20));
        // D s_130_22: write-var gs#409381 <= s_130_21
        fn_state.gs_409381 = s_130_21;
        // N s_130_23: jump b131
        return block_131(state, tracer, fn_state);
    }
    fn block_131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_131_0: read-var gs#409381:u8
        let s_131_0: bool = fn_state.gs_409381;
        // N s_131_1: branch s_131_0 b145 b132
        if s_131_0 {
            return block_145(state, tracer, fn_state);
        } else {
            return block_132(state, tracer, fn_state);
        };
    }
    fn block_132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_132_0: const #8s : i
        let s_132_0: i128 = 8;
        // D s_132_1: read-var u#33467:u32
        let s_132_1: u32 = fn_state.u_33467;
        // D s_132_2: cast zx s_132_1 -> bv
        let s_132_2: Bits = Bits::new(s_132_1 as u128, 32u16);
        // C s_132_3: const #1u : u64
        let s_132_3: u64 = 1;
        // D s_132_4: bit-extract s_132_2 s_132_0 s_132_3
        let s_132_4: Bits = (Bits::new(
            ((s_132_2) >> (s_132_0)).value(),
            u16::try_from(s_132_3).unwrap(),
        ));
        // D s_132_5: cast reint s_132_4 -> u8
        let s_132_5: bool = ((s_132_4.value()) != 0);
        // C s_132_6: const #0s : i
        let s_132_6: i128 = 0;
        // C s_132_7: const #0u : u64
        let s_132_7: u64 = 0;
        // D s_132_8: cast zx s_132_5 -> u64
        let s_132_8: u64 = (s_132_5 as u64);
        // C s_132_9: const #1u : u64
        let s_132_9: u64 = 1;
        // D s_132_10: and s_132_8 s_132_9
        let s_132_10: u64 = ((s_132_8) & (s_132_9));
        // D s_132_11: cmp-eq s_132_10 s_132_9
        let s_132_11: bool = ((s_132_10) == (s_132_9));
        // D s_132_12: lsl s_132_8 s_132_6
        let s_132_12: u64 = s_132_8 << s_132_6;
        // D s_132_13: or s_132_7 s_132_12
        let s_132_13: u64 = ((s_132_7) | (s_132_12));
        // D s_132_14: cmpl s_132_12
        let s_132_14: u64 = !s_132_12;
        // D s_132_15: and s_132_7 s_132_14
        let s_132_15: u64 = ((s_132_7) & (s_132_14));
        // D s_132_16: select s_132_11 s_132_13 s_132_15
        let s_132_16: u64 = if s_132_11 { s_132_13 } else { s_132_15 };
        // D s_132_17: cast trunc s_132_16 -> u8
        let s_132_17: bool = ((s_132_16) != 0);
        // D s_132_18: cast zx s_132_17 -> bv
        let s_132_18: Bits = Bits::new(s_132_17 as u128, 1u16);
        // C s_132_19: const #1u : u8
        let s_132_19: bool = true;
        // C s_132_20: cast zx s_132_19 -> bv
        let s_132_20: Bits = Bits::new(s_132_19 as u128, 1u16);
        // D s_132_21: cmp-ne s_132_18 s_132_20
        let s_132_21: bool = ((s_132_18) != (s_132_20));
        // D s_132_22: write-var gs#409384 <= s_132_21
        fn_state.gs_409384 = s_132_21;
        // N s_132_23: jump b133
        return block_133(state, tracer, fn_state);
    }
    fn block_133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_133_0: read-var gs#409384:u8
        let s_133_0: bool = fn_state.gs_409384;
        // N s_133_1: branch s_133_0 b144 b134
        if s_133_0 {
            return block_144(state, tracer, fn_state);
        } else {
            return block_134(state, tracer, fn_state);
        };
    }
    fn block_134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_134_0: const #9s : i
        let s_134_0: i128 = 9;
        // D s_134_1: read-var u#33467:u32
        let s_134_1: u32 = fn_state.u_33467;
        // D s_134_2: cast zx s_134_1 -> bv
        let s_134_2: Bits = Bits::new(s_134_1 as u128, 32u16);
        // C s_134_3: const #1u : u64
        let s_134_3: u64 = 1;
        // D s_134_4: bit-extract s_134_2 s_134_0 s_134_3
        let s_134_4: Bits = (Bits::new(
            ((s_134_2) >> (s_134_0)).value(),
            u16::try_from(s_134_3).unwrap(),
        ));
        // D s_134_5: cast reint s_134_4 -> u8
        let s_134_5: bool = ((s_134_4.value()) != 0);
        // C s_134_6: const #0s : i
        let s_134_6: i128 = 0;
        // C s_134_7: const #0u : u64
        let s_134_7: u64 = 0;
        // D s_134_8: cast zx s_134_5 -> u64
        let s_134_8: u64 = (s_134_5 as u64);
        // C s_134_9: const #1u : u64
        let s_134_9: u64 = 1;
        // D s_134_10: and s_134_8 s_134_9
        let s_134_10: u64 = ((s_134_8) & (s_134_9));
        // D s_134_11: cmp-eq s_134_10 s_134_9
        let s_134_11: bool = ((s_134_10) == (s_134_9));
        // D s_134_12: lsl s_134_8 s_134_6
        let s_134_12: u64 = s_134_8 << s_134_6;
        // D s_134_13: or s_134_7 s_134_12
        let s_134_13: u64 = ((s_134_7) | (s_134_12));
        // D s_134_14: cmpl s_134_12
        let s_134_14: u64 = !s_134_12;
        // D s_134_15: and s_134_7 s_134_14
        let s_134_15: u64 = ((s_134_7) & (s_134_14));
        // D s_134_16: select s_134_11 s_134_13 s_134_15
        let s_134_16: u64 = if s_134_11 { s_134_13 } else { s_134_15 };
        // D s_134_17: cast trunc s_134_16 -> u8
        let s_134_17: bool = ((s_134_16) != 0);
        // D s_134_18: cast zx s_134_17 -> bv
        let s_134_18: Bits = Bits::new(s_134_17 as u128, 1u16);
        // C s_134_19: const #1u : u8
        let s_134_19: bool = true;
        // C s_134_20: cast zx s_134_19 -> bv
        let s_134_20: Bits = Bits::new(s_134_19 as u128, 1u16);
        // D s_134_21: cmp-ne s_134_18 s_134_20
        let s_134_21: bool = ((s_134_18) != (s_134_20));
        // D s_134_22: write-var gs#409387 <= s_134_21
        fn_state.gs_409387 = s_134_21;
        // N s_134_23: jump b135
        return block_135(state, tracer, fn_state);
    }
    fn block_135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_135_0: read-var gs#409387:u8
        let s_135_0: bool = fn_state.gs_409387;
        // N s_135_1: branch s_135_0 b143 b136
        if s_135_0 {
            return block_143(state, tracer, fn_state);
        } else {
            return block_136(state, tracer, fn_state);
        };
    }
    fn block_136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_136_0: const #10s : i
        let s_136_0: i128 = 10;
        // D s_136_1: read-var u#33467:u32
        let s_136_1: u32 = fn_state.u_33467;
        // D s_136_2: cast zx s_136_1 -> bv
        let s_136_2: Bits = Bits::new(s_136_1 as u128, 32u16);
        // C s_136_3: const #1u : u64
        let s_136_3: u64 = 1;
        // D s_136_4: bit-extract s_136_2 s_136_0 s_136_3
        let s_136_4: Bits = (Bits::new(
            ((s_136_2) >> (s_136_0)).value(),
            u16::try_from(s_136_3).unwrap(),
        ));
        // D s_136_5: cast reint s_136_4 -> u8
        let s_136_5: bool = ((s_136_4.value()) != 0);
        // C s_136_6: const #0s : i
        let s_136_6: i128 = 0;
        // C s_136_7: const #0u : u64
        let s_136_7: u64 = 0;
        // D s_136_8: cast zx s_136_5 -> u64
        let s_136_8: u64 = (s_136_5 as u64);
        // C s_136_9: const #1u : u64
        let s_136_9: u64 = 1;
        // D s_136_10: and s_136_8 s_136_9
        let s_136_10: u64 = ((s_136_8) & (s_136_9));
        // D s_136_11: cmp-eq s_136_10 s_136_9
        let s_136_11: bool = ((s_136_10) == (s_136_9));
        // D s_136_12: lsl s_136_8 s_136_6
        let s_136_12: u64 = s_136_8 << s_136_6;
        // D s_136_13: or s_136_7 s_136_12
        let s_136_13: u64 = ((s_136_7) | (s_136_12));
        // D s_136_14: cmpl s_136_12
        let s_136_14: u64 = !s_136_12;
        // D s_136_15: and s_136_7 s_136_14
        let s_136_15: u64 = ((s_136_7) & (s_136_14));
        // D s_136_16: select s_136_11 s_136_13 s_136_15
        let s_136_16: u64 = if s_136_11 { s_136_13 } else { s_136_15 };
        // D s_136_17: cast trunc s_136_16 -> u8
        let s_136_17: bool = ((s_136_16) != 0);
        // D s_136_18: cast zx s_136_17 -> bv
        let s_136_18: Bits = Bits::new(s_136_17 as u128, 1u16);
        // C s_136_19: const #1u : u8
        let s_136_19: bool = true;
        // C s_136_20: cast zx s_136_19 -> bv
        let s_136_20: Bits = Bits::new(s_136_19 as u128, 1u16);
        // D s_136_21: cmp-ne s_136_18 s_136_20
        let s_136_21: bool = ((s_136_18) != (s_136_20));
        // D s_136_22: write-var gs#409390 <= s_136_21
        fn_state.gs_409390 = s_136_21;
        // N s_136_23: jump b137
        return block_137(state, tracer, fn_state);
    }
    fn block_137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_137_0: read-var gs#409390:u8
        let s_137_0: bool = fn_state.gs_409390;
        // N s_137_1: branch s_137_0 b142 b138
        if s_137_0 {
            return block_142(state, tracer, fn_state);
        } else {
            return block_138(state, tracer, fn_state);
        };
    }
    fn block_138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_138_0: const #11s : i
        let s_138_0: i128 = 11;
        // D s_138_1: read-var u#33467:u32
        let s_138_1: u32 = fn_state.u_33467;
        // D s_138_2: cast zx s_138_1 -> bv
        let s_138_2: Bits = Bits::new(s_138_1 as u128, 32u16);
        // C s_138_3: const #1u : u64
        let s_138_3: u64 = 1;
        // D s_138_4: bit-extract s_138_2 s_138_0 s_138_3
        let s_138_4: Bits = (Bits::new(
            ((s_138_2) >> (s_138_0)).value(),
            u16::try_from(s_138_3).unwrap(),
        ));
        // D s_138_5: cast reint s_138_4 -> u8
        let s_138_5: bool = ((s_138_4.value()) != 0);
        // C s_138_6: const #0s : i
        let s_138_6: i128 = 0;
        // C s_138_7: const #0u : u64
        let s_138_7: u64 = 0;
        // D s_138_8: cast zx s_138_5 -> u64
        let s_138_8: u64 = (s_138_5 as u64);
        // C s_138_9: const #1u : u64
        let s_138_9: u64 = 1;
        // D s_138_10: and s_138_8 s_138_9
        let s_138_10: u64 = ((s_138_8) & (s_138_9));
        // D s_138_11: cmp-eq s_138_10 s_138_9
        let s_138_11: bool = ((s_138_10) == (s_138_9));
        // D s_138_12: lsl s_138_8 s_138_6
        let s_138_12: u64 = s_138_8 << s_138_6;
        // D s_138_13: or s_138_7 s_138_12
        let s_138_13: u64 = ((s_138_7) | (s_138_12));
        // D s_138_14: cmpl s_138_12
        let s_138_14: u64 = !s_138_12;
        // D s_138_15: and s_138_7 s_138_14
        let s_138_15: u64 = ((s_138_7) & (s_138_14));
        // D s_138_16: select s_138_11 s_138_13 s_138_15
        let s_138_16: u64 = if s_138_11 { s_138_13 } else { s_138_15 };
        // D s_138_17: cast trunc s_138_16 -> u8
        let s_138_17: bool = ((s_138_16) != 0);
        // D s_138_18: cast zx s_138_17 -> bv
        let s_138_18: Bits = Bits::new(s_138_17 as u128, 1u16);
        // C s_138_19: const #1u : u8
        let s_138_19: bool = true;
        // C s_138_20: cast zx s_138_19 -> bv
        let s_138_20: Bits = Bits::new(s_138_19 as u128, 1u16);
        // D s_138_21: cmp-ne s_138_18 s_138_20
        let s_138_21: bool = ((s_138_18) != (s_138_20));
        // D s_138_22: write-var gs#409393 <= s_138_21
        fn_state.gs_409393 = s_138_21;
        // N s_138_23: jump b139
        return block_139(state, tracer, fn_state);
    }
    fn block_139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_139_0: read-var gs#409393:u8
        let s_139_0: bool = fn_state.gs_409393;
        // N s_139_1: branch s_139_0 b141 b140
        if s_139_0 {
            return block_141(state, tracer, fn_state);
        } else {
            return block_140(state, tracer, fn_state);
        };
    }
    fn block_140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_140_0: read-var u#33468:u8
        let s_140_0: u8 = fn_state.u_33468;
        // D s_140_1: read-var u#33469:u8
        let s_140_1: u8 = fn_state.u_33469;
        // D s_140_2: read-var u#33470:u8
        let s_140_2: u8 = fn_state.u_33470;
        // D s_140_3: call decode_aarch32_instrs_RBIT_A1enc_A_txt(s_140_0, s_140_1, s_140_2)
        let s_140_3: () = decode_aarch32_instrs_RBIT_A1enc_A_txt(
            state,
            tracer,
            s_140_0,
            s_140_1,
            s_140_2,
        );
        // N s_140_4: return
        return;
    }
    fn block_141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_141_0: panic
        panic!("{:?}", ());
        // N s_141_1: return
        return;
    }
    fn block_142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_142_0: const #1u : u8
        let s_142_0: bool = true;
        // D s_142_1: write-var gs#409393 <= s_142_0
        fn_state.gs_409393 = s_142_0;
        // N s_142_2: jump b139
        return block_139(state, tracer, fn_state);
    }
    fn block_143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_143_0: const #1u : u8
        let s_143_0: bool = true;
        // D s_143_1: write-var gs#409390 <= s_143_0
        fn_state.gs_409390 = s_143_0;
        // N s_143_2: jump b137
        return block_137(state, tracer, fn_state);
    }
    fn block_144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_144_0: const #1u : u8
        let s_144_0: bool = true;
        // D s_144_1: write-var gs#409387 <= s_144_0
        fn_state.gs_409387 = s_144_0;
        // N s_144_2: jump b135
        return block_135(state, tracer, fn_state);
    }
    fn block_145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_145_0: const #1u : u8
        let s_145_0: bool = true;
        // D s_145_1: write-var gs#409384 <= s_145_0
        fn_state.gs_409384 = s_145_0;
        // N s_145_2: jump b133
        return block_133(state, tracer, fn_state);
    }
    fn block_146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_146_0: const #1u : u8
        let s_146_0: bool = true;
        // D s_146_1: write-var gs#409381 <= s_146_0
        fn_state.gs_409381 = s_146_0;
        // N s_146_2: jump b131
        return block_131(state, tracer, fn_state);
    }
    fn block_147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_147_0: const #1u : u8
        let s_147_0: bool = true;
        // D s_147_1: write-var gs#409378 <= s_147_0
        fn_state.gs_409378 = s_147_0;
        // N s_147_2: jump b129
        return block_129(state, tracer, fn_state);
    }
    fn block_148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_148_0: const #1u : u8
        let s_148_0: bool = true;
        // D s_148_1: write-var gs#409375 <= s_148_0
        fn_state.gs_409375 = s_148_0;
        // N s_148_2: jump b127
        return block_127(state, tracer, fn_state);
    }
    fn block_149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_149_0: read-var merge#var.1:struct
        let s_149_0: u32 = fn_state.merge_var._1;
        // D s_149_1: write-var u#33472 <= s_149_0
        fn_state.u_33472 = s_149_0;
        // C s_149_2: const #16s : i
        let s_149_2: i128 = 16;
        // D s_149_3: read-var u#33472:u32
        let s_149_3: u32 = fn_state.u_33472;
        // D s_149_4: cast zx s_149_3 -> bv
        let s_149_4: Bits = Bits::new(s_149_3 as u128, 32u16);
        // C s_149_5: const #1s : i64
        let s_149_5: i64 = 1;
        // C s_149_6: cast zx s_149_5 -> i
        let s_149_6: i128 = (i128::try_from(s_149_5).unwrap());
        // C s_149_7: const #11s : i
        let s_149_7: i128 = 11;
        // C s_149_8: add s_149_7 s_149_6
        let s_149_8: i128 = (s_149_7 + s_149_6);
        // D s_149_9: bit-extract s_149_4 s_149_2 s_149_8
        let s_149_9: Bits = (Bits::new(
            ((s_149_4) >> (s_149_2)).value(),
            u16::try_from(s_149_8).unwrap(),
        ));
        // D s_149_10: cast reint s_149_9 -> u12
        let s_149_10: u16 = (s_149_9.value() as u16);
        // D s_149_11: cast zx s_149_10 -> bv
        let s_149_11: Bits = Bits::new(s_149_10 as u128, 12u16);
        // C s_149_12: const #1727u : u12
        let s_149_12: u16 = 1727;
        // C s_149_13: cast zx s_149_12 -> bv
        let s_149_13: Bits = Bits::new(s_149_12 as u128, 12u16);
        // D s_149_14: cmp-eq s_149_11 s_149_13
        let s_149_14: bool = ((s_149_11) == (s_149_13));
        // N s_149_15: branch s_149_14 b1403 b150
        if s_149_14 {
            return block_1403(state, tracer, fn_state);
        } else {
            return block_150(state, tracer, fn_state);
        };
    }
    fn block_150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_150_0: const #0u : u8
        let s_150_0: bool = false;
        // D s_150_1: write-var gs#409399 <= s_150_0
        fn_state.gs_409399 = s_150_0;
        // N s_150_2: jump b151
        return block_151(state, tracer, fn_state);
    }
    fn block_151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_151_0: read-var gs#409399:u8
        let s_151_0: bool = fn_state.gs_409399;
        // N s_151_1: branch s_151_0 b1399 b152
        if s_151_0 {
            return block_1399(state, tracer, fn_state);
        } else {
            return block_152(state, tracer, fn_state);
        };
    }
    fn block_152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_152_0: const #0u : u8
        let s_152_0: bool = false;
        // D s_152_1: write-var gs#409404 <= s_152_0
        fn_state.gs_409404 = s_152_0;
        // N s_152_2: jump b153
        return block_153(state, tracer, fn_state);
    }
    fn block_153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_153_0: read-var gs#409404:u8
        let s_153_0: bool = fn_state.gs_409404;
        // D s_153_1: not s_153_0
        let s_153_1: bool = !s_153_0;
        // N s_153_2: branch s_153_1 b178 b154
        if s_153_1 {
            return block_178(state, tracer, fn_state);
        } else {
            return block_154(state, tracer, fn_state);
        };
    }
    fn block_154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_154_0: const #3086s : i
        let s_154_0: i128 = 3086;
        // C s_154_1: const #14696u : u32
        let s_154_1: u32 = 14696;
        // N s_154_2: write-reg s_154_1 <= s_154_0
        let s_154_2: () = {
            state.write_register::<i128>(s_154_1 as isize, s_154_0);
            tracer.write_register(s_154_1 as isize, s_154_0);
        };
        // C s_154_3: const #28s : i
        let s_154_3: i128 = 28;
        // C s_154_4: const #4s : i
        let s_154_4: i128 = 4;
        // D s_154_5: read-var u#33472:u32
        let s_154_5: u32 = fn_state.u_33472;
        // D s_154_6: cast zx s_154_5 -> bv
        let s_154_6: Bits = Bits::new(s_154_5 as u128, 32u16);
        // D s_154_7: bit-extract s_154_6 s_154_3 s_154_4
        let s_154_7: Bits = (Bits::new(
            ((s_154_6) >> (s_154_3)).value(),
            u16::try_from(s_154_4).unwrap(),
        ));
        // D s_154_8: cast reint s_154_7 -> u8
        let s_154_8: u8 = (s_154_7.value() as u8);
        // D s_154_9: write-var u#33473 <= s_154_8
        fn_state.u_33473 = s_154_8;
        // C s_154_10: const #12s : i
        let s_154_10: i128 = 12;
        // C s_154_11: const #4s : i
        let s_154_11: i128 = 4;
        // D s_154_12: read-var u#33472:u32
        let s_154_12: u32 = fn_state.u_33472;
        // D s_154_13: cast zx s_154_12 -> bv
        let s_154_13: Bits = Bits::new(s_154_12 as u128, 32u16);
        // D s_154_14: bit-extract s_154_13 s_154_10 s_154_11
        let s_154_14: Bits = (Bits::new(
            ((s_154_13) >> (s_154_10)).value(),
            u16::try_from(s_154_11).unwrap(),
        ));
        // D s_154_15: cast reint s_154_14 -> u8
        let s_154_15: u8 = (s_154_14.value() as u8);
        // D s_154_16: write-var u#33474 <= s_154_15
        fn_state.u_33474 = s_154_15;
        // C s_154_17: const #0s : i
        let s_154_17: i128 = 0;
        // C s_154_18: const #4s : i
        let s_154_18: i128 = 4;
        // D s_154_19: read-var u#33472:u32
        let s_154_19: u32 = fn_state.u_33472;
        // D s_154_20: cast zx s_154_19 -> bv
        let s_154_20: Bits = Bits::new(s_154_19 as u128, 32u16);
        // D s_154_21: bit-extract s_154_20 s_154_17 s_154_18
        let s_154_21: Bits = (Bits::new(
            ((s_154_20) >> (s_154_17)).value(),
            u16::try_from(s_154_18).unwrap(),
        ));
        // D s_154_22: cast reint s_154_21 -> u8
        let s_154_22: u8 = (s_154_21.value() as u8);
        // D s_154_23: write-var u#33475 <= s_154_22
        fn_state.u_33475 = s_154_22;
        // C s_154_24: const #16s : i
        let s_154_24: i128 = 16;
        // D s_154_25: read-var u#33472:u32
        let s_154_25: u32 = fn_state.u_33472;
        // D s_154_26: cast zx s_154_25 -> bv
        let s_154_26: Bits = Bits::new(s_154_25 as u128, 32u16);
        // C s_154_27: const #1u : u64
        let s_154_27: u64 = 1;
        // D s_154_28: bit-extract s_154_26 s_154_24 s_154_27
        let s_154_28: Bits = (Bits::new(
            ((s_154_26) >> (s_154_24)).value(),
            u16::try_from(s_154_27).unwrap(),
        ));
        // D s_154_29: cast reint s_154_28 -> u8
        let s_154_29: bool = ((s_154_28.value()) != 0);
        // C s_154_30: const #0s : i
        let s_154_30: i128 = 0;
        // C s_154_31: const #0u : u64
        let s_154_31: u64 = 0;
        // D s_154_32: cast zx s_154_29 -> u64
        let s_154_32: u64 = (s_154_29 as u64);
        // C s_154_33: const #1u : u64
        let s_154_33: u64 = 1;
        // D s_154_34: and s_154_32 s_154_33
        let s_154_34: u64 = ((s_154_32) & (s_154_33));
        // D s_154_35: cmp-eq s_154_34 s_154_33
        let s_154_35: bool = ((s_154_34) == (s_154_33));
        // D s_154_36: lsl s_154_32 s_154_30
        let s_154_36: u64 = s_154_32 << s_154_30;
        // D s_154_37: or s_154_31 s_154_36
        let s_154_37: u64 = ((s_154_31) | (s_154_36));
        // D s_154_38: cmpl s_154_36
        let s_154_38: u64 = !s_154_36;
        // D s_154_39: and s_154_31 s_154_38
        let s_154_39: u64 = ((s_154_31) & (s_154_38));
        // D s_154_40: select s_154_35 s_154_37 s_154_39
        let s_154_40: u64 = if s_154_35 { s_154_37 } else { s_154_39 };
        // D s_154_41: cast trunc s_154_40 -> u8
        let s_154_41: bool = ((s_154_40) != 0);
        // D s_154_42: cast zx s_154_41 -> bv
        let s_154_42: Bits = Bits::new(s_154_41 as u128, 1u16);
        // C s_154_43: const #1u : u8
        let s_154_43: bool = true;
        // C s_154_44: cast zx s_154_43 -> bv
        let s_154_44: Bits = Bits::new(s_154_43 as u128, 1u16);
        // D s_154_45: cmp-ne s_154_42 s_154_44
        let s_154_45: bool = ((s_154_42) != (s_154_44));
        // N s_154_46: branch s_154_45 b177 b155
        if s_154_45 {
            return block_177(state, tracer, fn_state);
        } else {
            return block_155(state, tracer, fn_state);
        };
    }
    fn block_155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_155_0: const #17s : i
        let s_155_0: i128 = 17;
        // D s_155_1: read-var u#33472:u32
        let s_155_1: u32 = fn_state.u_33472;
        // D s_155_2: cast zx s_155_1 -> bv
        let s_155_2: Bits = Bits::new(s_155_1 as u128, 32u16);
        // C s_155_3: const #1u : u64
        let s_155_3: u64 = 1;
        // D s_155_4: bit-extract s_155_2 s_155_0 s_155_3
        let s_155_4: Bits = (Bits::new(
            ((s_155_2) >> (s_155_0)).value(),
            u16::try_from(s_155_3).unwrap(),
        ));
        // D s_155_5: cast reint s_155_4 -> u8
        let s_155_5: bool = ((s_155_4.value()) != 0);
        // C s_155_6: const #0s : i
        let s_155_6: i128 = 0;
        // C s_155_7: const #0u : u64
        let s_155_7: u64 = 0;
        // D s_155_8: cast zx s_155_5 -> u64
        let s_155_8: u64 = (s_155_5 as u64);
        // C s_155_9: const #1u : u64
        let s_155_9: u64 = 1;
        // D s_155_10: and s_155_8 s_155_9
        let s_155_10: u64 = ((s_155_8) & (s_155_9));
        // D s_155_11: cmp-eq s_155_10 s_155_9
        let s_155_11: bool = ((s_155_10) == (s_155_9));
        // D s_155_12: lsl s_155_8 s_155_6
        let s_155_12: u64 = s_155_8 << s_155_6;
        // D s_155_13: or s_155_7 s_155_12
        let s_155_13: u64 = ((s_155_7) | (s_155_12));
        // D s_155_14: cmpl s_155_12
        let s_155_14: u64 = !s_155_12;
        // D s_155_15: and s_155_7 s_155_14
        let s_155_15: u64 = ((s_155_7) & (s_155_14));
        // D s_155_16: select s_155_11 s_155_13 s_155_15
        let s_155_16: u64 = if s_155_11 { s_155_13 } else { s_155_15 };
        // D s_155_17: cast trunc s_155_16 -> u8
        let s_155_17: bool = ((s_155_16) != 0);
        // D s_155_18: cast zx s_155_17 -> bv
        let s_155_18: Bits = Bits::new(s_155_17 as u128, 1u16);
        // C s_155_19: const #1u : u8
        let s_155_19: bool = true;
        // C s_155_20: cast zx s_155_19 -> bv
        let s_155_20: Bits = Bits::new(s_155_19 as u128, 1u16);
        // D s_155_21: cmp-ne s_155_18 s_155_20
        let s_155_21: bool = ((s_155_18) != (s_155_20));
        // D s_155_22: write-var gs#409417 <= s_155_21
        fn_state.gs_409417 = s_155_21;
        // N s_155_23: jump b156
        return block_156(state, tracer, fn_state);
    }
    fn block_156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_156_0: read-var gs#409417:u8
        let s_156_0: bool = fn_state.gs_409417;
        // N s_156_1: branch s_156_0 b176 b157
        if s_156_0 {
            return block_176(state, tracer, fn_state);
        } else {
            return block_157(state, tracer, fn_state);
        };
    }
    fn block_157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_157_0: const #18s : i
        let s_157_0: i128 = 18;
        // D s_157_1: read-var u#33472:u32
        let s_157_1: u32 = fn_state.u_33472;
        // D s_157_2: cast zx s_157_1 -> bv
        let s_157_2: Bits = Bits::new(s_157_1 as u128, 32u16);
        // C s_157_3: const #1u : u64
        let s_157_3: u64 = 1;
        // D s_157_4: bit-extract s_157_2 s_157_0 s_157_3
        let s_157_4: Bits = (Bits::new(
            ((s_157_2) >> (s_157_0)).value(),
            u16::try_from(s_157_3).unwrap(),
        ));
        // D s_157_5: cast reint s_157_4 -> u8
        let s_157_5: bool = ((s_157_4.value()) != 0);
        // C s_157_6: const #0s : i
        let s_157_6: i128 = 0;
        // C s_157_7: const #0u : u64
        let s_157_7: u64 = 0;
        // D s_157_8: cast zx s_157_5 -> u64
        let s_157_8: u64 = (s_157_5 as u64);
        // C s_157_9: const #1u : u64
        let s_157_9: u64 = 1;
        // D s_157_10: and s_157_8 s_157_9
        let s_157_10: u64 = ((s_157_8) & (s_157_9));
        // D s_157_11: cmp-eq s_157_10 s_157_9
        let s_157_11: bool = ((s_157_10) == (s_157_9));
        // D s_157_12: lsl s_157_8 s_157_6
        let s_157_12: u64 = s_157_8 << s_157_6;
        // D s_157_13: or s_157_7 s_157_12
        let s_157_13: u64 = ((s_157_7) | (s_157_12));
        // D s_157_14: cmpl s_157_12
        let s_157_14: u64 = !s_157_12;
        // D s_157_15: and s_157_7 s_157_14
        let s_157_15: u64 = ((s_157_7) & (s_157_14));
        // D s_157_16: select s_157_11 s_157_13 s_157_15
        let s_157_16: u64 = if s_157_11 { s_157_13 } else { s_157_15 };
        // D s_157_17: cast trunc s_157_16 -> u8
        let s_157_17: bool = ((s_157_16) != 0);
        // D s_157_18: cast zx s_157_17 -> bv
        let s_157_18: Bits = Bits::new(s_157_17 as u128, 1u16);
        // C s_157_19: const #1u : u8
        let s_157_19: bool = true;
        // C s_157_20: cast zx s_157_19 -> bv
        let s_157_20: Bits = Bits::new(s_157_19 as u128, 1u16);
        // D s_157_21: cmp-ne s_157_18 s_157_20
        let s_157_21: bool = ((s_157_18) != (s_157_20));
        // D s_157_22: write-var gs#409420 <= s_157_21
        fn_state.gs_409420 = s_157_21;
        // N s_157_23: jump b158
        return block_158(state, tracer, fn_state);
    }
    fn block_158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_158_0: read-var gs#409420:u8
        let s_158_0: bool = fn_state.gs_409420;
        // N s_158_1: branch s_158_0 b175 b159
        if s_158_0 {
            return block_175(state, tracer, fn_state);
        } else {
            return block_159(state, tracer, fn_state);
        };
    }
    fn block_159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_159_0: const #19s : i
        let s_159_0: i128 = 19;
        // D s_159_1: read-var u#33472:u32
        let s_159_1: u32 = fn_state.u_33472;
        // D s_159_2: cast zx s_159_1 -> bv
        let s_159_2: Bits = Bits::new(s_159_1 as u128, 32u16);
        // C s_159_3: const #1u : u64
        let s_159_3: u64 = 1;
        // D s_159_4: bit-extract s_159_2 s_159_0 s_159_3
        let s_159_4: Bits = (Bits::new(
            ((s_159_2) >> (s_159_0)).value(),
            u16::try_from(s_159_3).unwrap(),
        ));
        // D s_159_5: cast reint s_159_4 -> u8
        let s_159_5: bool = ((s_159_4.value()) != 0);
        // C s_159_6: const #0s : i
        let s_159_6: i128 = 0;
        // C s_159_7: const #0u : u64
        let s_159_7: u64 = 0;
        // D s_159_8: cast zx s_159_5 -> u64
        let s_159_8: u64 = (s_159_5 as u64);
        // C s_159_9: const #1u : u64
        let s_159_9: u64 = 1;
        // D s_159_10: and s_159_8 s_159_9
        let s_159_10: u64 = ((s_159_8) & (s_159_9));
        // D s_159_11: cmp-eq s_159_10 s_159_9
        let s_159_11: bool = ((s_159_10) == (s_159_9));
        // D s_159_12: lsl s_159_8 s_159_6
        let s_159_12: u64 = s_159_8 << s_159_6;
        // D s_159_13: or s_159_7 s_159_12
        let s_159_13: u64 = ((s_159_7) | (s_159_12));
        // D s_159_14: cmpl s_159_12
        let s_159_14: u64 = !s_159_12;
        // D s_159_15: and s_159_7 s_159_14
        let s_159_15: u64 = ((s_159_7) & (s_159_14));
        // D s_159_16: select s_159_11 s_159_13 s_159_15
        let s_159_16: u64 = if s_159_11 { s_159_13 } else { s_159_15 };
        // D s_159_17: cast trunc s_159_16 -> u8
        let s_159_17: bool = ((s_159_16) != 0);
        // D s_159_18: cast zx s_159_17 -> bv
        let s_159_18: Bits = Bits::new(s_159_17 as u128, 1u16);
        // C s_159_19: const #1u : u8
        let s_159_19: bool = true;
        // C s_159_20: cast zx s_159_19 -> bv
        let s_159_20: Bits = Bits::new(s_159_19 as u128, 1u16);
        // D s_159_21: cmp-ne s_159_18 s_159_20
        let s_159_21: bool = ((s_159_18) != (s_159_20));
        // D s_159_22: write-var gs#409423 <= s_159_21
        fn_state.gs_409423 = s_159_21;
        // N s_159_23: jump b160
        return block_160(state, tracer, fn_state);
    }
    fn block_160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_160_0: read-var gs#409423:u8
        let s_160_0: bool = fn_state.gs_409423;
        // N s_160_1: branch s_160_0 b174 b161
        if s_160_0 {
            return block_174(state, tracer, fn_state);
        } else {
            return block_161(state, tracer, fn_state);
        };
    }
    fn block_161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_161_0: const #8s : i
        let s_161_0: i128 = 8;
        // D s_161_1: read-var u#33472:u32
        let s_161_1: u32 = fn_state.u_33472;
        // D s_161_2: cast zx s_161_1 -> bv
        let s_161_2: Bits = Bits::new(s_161_1 as u128, 32u16);
        // C s_161_3: const #1u : u64
        let s_161_3: u64 = 1;
        // D s_161_4: bit-extract s_161_2 s_161_0 s_161_3
        let s_161_4: Bits = (Bits::new(
            ((s_161_2) >> (s_161_0)).value(),
            u16::try_from(s_161_3).unwrap(),
        ));
        // D s_161_5: cast reint s_161_4 -> u8
        let s_161_5: bool = ((s_161_4.value()) != 0);
        // C s_161_6: const #0s : i
        let s_161_6: i128 = 0;
        // C s_161_7: const #0u : u64
        let s_161_7: u64 = 0;
        // D s_161_8: cast zx s_161_5 -> u64
        let s_161_8: u64 = (s_161_5 as u64);
        // C s_161_9: const #1u : u64
        let s_161_9: u64 = 1;
        // D s_161_10: and s_161_8 s_161_9
        let s_161_10: u64 = ((s_161_8) & (s_161_9));
        // D s_161_11: cmp-eq s_161_10 s_161_9
        let s_161_11: bool = ((s_161_10) == (s_161_9));
        // D s_161_12: lsl s_161_8 s_161_6
        let s_161_12: u64 = s_161_8 << s_161_6;
        // D s_161_13: or s_161_7 s_161_12
        let s_161_13: u64 = ((s_161_7) | (s_161_12));
        // D s_161_14: cmpl s_161_12
        let s_161_14: u64 = !s_161_12;
        // D s_161_15: and s_161_7 s_161_14
        let s_161_15: u64 = ((s_161_7) & (s_161_14));
        // D s_161_16: select s_161_11 s_161_13 s_161_15
        let s_161_16: u64 = if s_161_11 { s_161_13 } else { s_161_15 };
        // D s_161_17: cast trunc s_161_16 -> u8
        let s_161_17: bool = ((s_161_16) != 0);
        // D s_161_18: cast zx s_161_17 -> bv
        let s_161_18: Bits = Bits::new(s_161_17 as u128, 1u16);
        // C s_161_19: const #1u : u8
        let s_161_19: bool = true;
        // C s_161_20: cast zx s_161_19 -> bv
        let s_161_20: Bits = Bits::new(s_161_19 as u128, 1u16);
        // D s_161_21: cmp-ne s_161_18 s_161_20
        let s_161_21: bool = ((s_161_18) != (s_161_20));
        // D s_161_22: write-var gs#409426 <= s_161_21
        fn_state.gs_409426 = s_161_21;
        // N s_161_23: jump b162
        return block_162(state, tracer, fn_state);
    }
    fn block_162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_162_0: read-var gs#409426:u8
        let s_162_0: bool = fn_state.gs_409426;
        // N s_162_1: branch s_162_0 b173 b163
        if s_162_0 {
            return block_173(state, tracer, fn_state);
        } else {
            return block_163(state, tracer, fn_state);
        };
    }
    fn block_163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_163_0: const #9s : i
        let s_163_0: i128 = 9;
        // D s_163_1: read-var u#33472:u32
        let s_163_1: u32 = fn_state.u_33472;
        // D s_163_2: cast zx s_163_1 -> bv
        let s_163_2: Bits = Bits::new(s_163_1 as u128, 32u16);
        // C s_163_3: const #1u : u64
        let s_163_3: u64 = 1;
        // D s_163_4: bit-extract s_163_2 s_163_0 s_163_3
        let s_163_4: Bits = (Bits::new(
            ((s_163_2) >> (s_163_0)).value(),
            u16::try_from(s_163_3).unwrap(),
        ));
        // D s_163_5: cast reint s_163_4 -> u8
        let s_163_5: bool = ((s_163_4.value()) != 0);
        // C s_163_6: const #0s : i
        let s_163_6: i128 = 0;
        // C s_163_7: const #0u : u64
        let s_163_7: u64 = 0;
        // D s_163_8: cast zx s_163_5 -> u64
        let s_163_8: u64 = (s_163_5 as u64);
        // C s_163_9: const #1u : u64
        let s_163_9: u64 = 1;
        // D s_163_10: and s_163_8 s_163_9
        let s_163_10: u64 = ((s_163_8) & (s_163_9));
        // D s_163_11: cmp-eq s_163_10 s_163_9
        let s_163_11: bool = ((s_163_10) == (s_163_9));
        // D s_163_12: lsl s_163_8 s_163_6
        let s_163_12: u64 = s_163_8 << s_163_6;
        // D s_163_13: or s_163_7 s_163_12
        let s_163_13: u64 = ((s_163_7) | (s_163_12));
        // D s_163_14: cmpl s_163_12
        let s_163_14: u64 = !s_163_12;
        // D s_163_15: and s_163_7 s_163_14
        let s_163_15: u64 = ((s_163_7) & (s_163_14));
        // D s_163_16: select s_163_11 s_163_13 s_163_15
        let s_163_16: u64 = if s_163_11 { s_163_13 } else { s_163_15 };
        // D s_163_17: cast trunc s_163_16 -> u8
        let s_163_17: bool = ((s_163_16) != 0);
        // D s_163_18: cast zx s_163_17 -> bv
        let s_163_18: Bits = Bits::new(s_163_17 as u128, 1u16);
        // C s_163_19: const #1u : u8
        let s_163_19: bool = true;
        // C s_163_20: cast zx s_163_19 -> bv
        let s_163_20: Bits = Bits::new(s_163_19 as u128, 1u16);
        // D s_163_21: cmp-ne s_163_18 s_163_20
        let s_163_21: bool = ((s_163_18) != (s_163_20));
        // D s_163_22: write-var gs#409429 <= s_163_21
        fn_state.gs_409429 = s_163_21;
        // N s_163_23: jump b164
        return block_164(state, tracer, fn_state);
    }
    fn block_164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_164_0: read-var gs#409429:u8
        let s_164_0: bool = fn_state.gs_409429;
        // N s_164_1: branch s_164_0 b172 b165
        if s_164_0 {
            return block_172(state, tracer, fn_state);
        } else {
            return block_165(state, tracer, fn_state);
        };
    }
    fn block_165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_165_0: const #10s : i
        let s_165_0: i128 = 10;
        // D s_165_1: read-var u#33472:u32
        let s_165_1: u32 = fn_state.u_33472;
        // D s_165_2: cast zx s_165_1 -> bv
        let s_165_2: Bits = Bits::new(s_165_1 as u128, 32u16);
        // C s_165_3: const #1u : u64
        let s_165_3: u64 = 1;
        // D s_165_4: bit-extract s_165_2 s_165_0 s_165_3
        let s_165_4: Bits = (Bits::new(
            ((s_165_2) >> (s_165_0)).value(),
            u16::try_from(s_165_3).unwrap(),
        ));
        // D s_165_5: cast reint s_165_4 -> u8
        let s_165_5: bool = ((s_165_4.value()) != 0);
        // C s_165_6: const #0s : i
        let s_165_6: i128 = 0;
        // C s_165_7: const #0u : u64
        let s_165_7: u64 = 0;
        // D s_165_8: cast zx s_165_5 -> u64
        let s_165_8: u64 = (s_165_5 as u64);
        // C s_165_9: const #1u : u64
        let s_165_9: u64 = 1;
        // D s_165_10: and s_165_8 s_165_9
        let s_165_10: u64 = ((s_165_8) & (s_165_9));
        // D s_165_11: cmp-eq s_165_10 s_165_9
        let s_165_11: bool = ((s_165_10) == (s_165_9));
        // D s_165_12: lsl s_165_8 s_165_6
        let s_165_12: u64 = s_165_8 << s_165_6;
        // D s_165_13: or s_165_7 s_165_12
        let s_165_13: u64 = ((s_165_7) | (s_165_12));
        // D s_165_14: cmpl s_165_12
        let s_165_14: u64 = !s_165_12;
        // D s_165_15: and s_165_7 s_165_14
        let s_165_15: u64 = ((s_165_7) & (s_165_14));
        // D s_165_16: select s_165_11 s_165_13 s_165_15
        let s_165_16: u64 = if s_165_11 { s_165_13 } else { s_165_15 };
        // D s_165_17: cast trunc s_165_16 -> u8
        let s_165_17: bool = ((s_165_16) != 0);
        // D s_165_18: cast zx s_165_17 -> bv
        let s_165_18: Bits = Bits::new(s_165_17 as u128, 1u16);
        // C s_165_19: const #1u : u8
        let s_165_19: bool = true;
        // C s_165_20: cast zx s_165_19 -> bv
        let s_165_20: Bits = Bits::new(s_165_19 as u128, 1u16);
        // D s_165_21: cmp-ne s_165_18 s_165_20
        let s_165_21: bool = ((s_165_18) != (s_165_20));
        // D s_165_22: write-var gs#409432 <= s_165_21
        fn_state.gs_409432 = s_165_21;
        // N s_165_23: jump b166
        return block_166(state, tracer, fn_state);
    }
    fn block_166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_166_0: read-var gs#409432:u8
        let s_166_0: bool = fn_state.gs_409432;
        // N s_166_1: branch s_166_0 b171 b167
        if s_166_0 {
            return block_171(state, tracer, fn_state);
        } else {
            return block_167(state, tracer, fn_state);
        };
    }
    fn block_167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_167_0: const #11s : i
        let s_167_0: i128 = 11;
        // D s_167_1: read-var u#33472:u32
        let s_167_1: u32 = fn_state.u_33472;
        // D s_167_2: cast zx s_167_1 -> bv
        let s_167_2: Bits = Bits::new(s_167_1 as u128, 32u16);
        // C s_167_3: const #1u : u64
        let s_167_3: u64 = 1;
        // D s_167_4: bit-extract s_167_2 s_167_0 s_167_3
        let s_167_4: Bits = (Bits::new(
            ((s_167_2) >> (s_167_0)).value(),
            u16::try_from(s_167_3).unwrap(),
        ));
        // D s_167_5: cast reint s_167_4 -> u8
        let s_167_5: bool = ((s_167_4.value()) != 0);
        // C s_167_6: const #0s : i
        let s_167_6: i128 = 0;
        // C s_167_7: const #0u : u64
        let s_167_7: u64 = 0;
        // D s_167_8: cast zx s_167_5 -> u64
        let s_167_8: u64 = (s_167_5 as u64);
        // C s_167_9: const #1u : u64
        let s_167_9: u64 = 1;
        // D s_167_10: and s_167_8 s_167_9
        let s_167_10: u64 = ((s_167_8) & (s_167_9));
        // D s_167_11: cmp-eq s_167_10 s_167_9
        let s_167_11: bool = ((s_167_10) == (s_167_9));
        // D s_167_12: lsl s_167_8 s_167_6
        let s_167_12: u64 = s_167_8 << s_167_6;
        // D s_167_13: or s_167_7 s_167_12
        let s_167_13: u64 = ((s_167_7) | (s_167_12));
        // D s_167_14: cmpl s_167_12
        let s_167_14: u64 = !s_167_12;
        // D s_167_15: and s_167_7 s_167_14
        let s_167_15: u64 = ((s_167_7) & (s_167_14));
        // D s_167_16: select s_167_11 s_167_13 s_167_15
        let s_167_16: u64 = if s_167_11 { s_167_13 } else { s_167_15 };
        // D s_167_17: cast trunc s_167_16 -> u8
        let s_167_17: bool = ((s_167_16) != 0);
        // D s_167_18: cast zx s_167_17 -> bv
        let s_167_18: Bits = Bits::new(s_167_17 as u128, 1u16);
        // C s_167_19: const #1u : u8
        let s_167_19: bool = true;
        // C s_167_20: cast zx s_167_19 -> bv
        let s_167_20: Bits = Bits::new(s_167_19 as u128, 1u16);
        // D s_167_21: cmp-ne s_167_18 s_167_20
        let s_167_21: bool = ((s_167_18) != (s_167_20));
        // D s_167_22: write-var gs#409435 <= s_167_21
        fn_state.gs_409435 = s_167_21;
        // N s_167_23: jump b168
        return block_168(state, tracer, fn_state);
    }
    fn block_168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_168_0: read-var gs#409435:u8
        let s_168_0: bool = fn_state.gs_409435;
        // N s_168_1: branch s_168_0 b170 b169
        if s_168_0 {
            return block_170(state, tracer, fn_state);
        } else {
            return block_169(state, tracer, fn_state);
        };
    }
    fn block_169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_169_0: read-var u#33473:u8
        let s_169_0: u8 = fn_state.u_33473;
        // D s_169_1: read-var u#33474:u8
        let s_169_1: u8 = fn_state.u_33474;
        // D s_169_2: read-var u#33475:u8
        let s_169_2: u8 = fn_state.u_33475;
        // D s_169_3: call decode_aarch32_instrs_REV16_A1enc_A_txt(s_169_0, s_169_1, s_169_2)
        let s_169_3: () = decode_aarch32_instrs_REV16_A1enc_A_txt(
            state,
            tracer,
            s_169_0,
            s_169_1,
            s_169_2,
        );
        // N s_169_4: return
        return;
    }
    fn block_170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_170_0: panic
        panic!("{:?}", ());
        // N s_170_1: return
        return;
    }
    fn block_171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_171_0: const #1u : u8
        let s_171_0: bool = true;
        // D s_171_1: write-var gs#409435 <= s_171_0
        fn_state.gs_409435 = s_171_0;
        // N s_171_2: jump b168
        return block_168(state, tracer, fn_state);
    }
    fn block_172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_172_0: const #1u : u8
        let s_172_0: bool = true;
        // D s_172_1: write-var gs#409432 <= s_172_0
        fn_state.gs_409432 = s_172_0;
        // N s_172_2: jump b166
        return block_166(state, tracer, fn_state);
    }
    fn block_173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_173_0: const #1u : u8
        let s_173_0: bool = true;
        // D s_173_1: write-var gs#409429 <= s_173_0
        fn_state.gs_409429 = s_173_0;
        // N s_173_2: jump b164
        return block_164(state, tracer, fn_state);
    }
    fn block_174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_174_0: const #1u : u8
        let s_174_0: bool = true;
        // D s_174_1: write-var gs#409426 <= s_174_0
        fn_state.gs_409426 = s_174_0;
        // N s_174_2: jump b162
        return block_162(state, tracer, fn_state);
    }
    fn block_175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_175_0: const #1u : u8
        let s_175_0: bool = true;
        // D s_175_1: write-var gs#409423 <= s_175_0
        fn_state.gs_409423 = s_175_0;
        // N s_175_2: jump b160
        return block_160(state, tracer, fn_state);
    }
    fn block_176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_176_0: const #1u : u8
        let s_176_0: bool = true;
        // D s_176_1: write-var gs#409420 <= s_176_0
        fn_state.gs_409420 = s_176_0;
        // N s_176_2: jump b158
        return block_158(state, tracer, fn_state);
    }
    fn block_177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_177_0: const #1u : u8
        let s_177_0: bool = true;
        // D s_177_1: write-var gs#409417 <= s_177_0
        fn_state.gs_409417 = s_177_0;
        // N s_177_2: jump b156
        return block_156(state, tracer, fn_state);
    }
    fn block_178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_178_0: read-var merge#var.1:struct
        let s_178_0: u32 = fn_state.merge_var._1;
        // D s_178_1: write-var u#33477 <= s_178_0
        fn_state.u_33477 = s_178_0;
        // C s_178_2: const #16s : i
        let s_178_2: i128 = 16;
        // D s_178_3: read-var u#33477:u32
        let s_178_3: u32 = fn_state.u_33477;
        // D s_178_4: cast zx s_178_3 -> bv
        let s_178_4: Bits = Bits::new(s_178_3 as u128, 32u16);
        // C s_178_5: const #1s : i64
        let s_178_5: i64 = 1;
        // C s_178_6: cast zx s_178_5 -> i
        let s_178_6: i128 = (i128::try_from(s_178_5).unwrap());
        // C s_178_7: const #11s : i
        let s_178_7: i128 = 11;
        // C s_178_8: add s_178_7 s_178_6
        let s_178_8: i128 = (s_178_7 + s_178_6);
        // D s_178_9: bit-extract s_178_4 s_178_2 s_178_8
        let s_178_9: Bits = (Bits::new(
            ((s_178_4) >> (s_178_2)).value(),
            u16::try_from(s_178_8).unwrap(),
        ));
        // D s_178_10: cast reint s_178_9 -> u12
        let s_178_10: u16 = (s_178_9.value() as u16);
        // D s_178_11: cast zx s_178_10 -> bv
        let s_178_11: Bits = Bits::new(s_178_10 as u128, 12u16);
        // C s_178_12: const #1727u : u12
        let s_178_12: u16 = 1727;
        // C s_178_13: cast zx s_178_12 -> bv
        let s_178_13: Bits = Bits::new(s_178_12 as u128, 12u16);
        // D s_178_14: cmp-eq s_178_11 s_178_13
        let s_178_14: bool = ((s_178_11) == (s_178_13));
        // N s_178_15: branch s_178_14 b1398 b179
        if s_178_14 {
            return block_1398(state, tracer, fn_state);
        } else {
            return block_179(state, tracer, fn_state);
        };
    }
    fn block_179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_179_0: const #0u : u8
        let s_179_0: bool = false;
        // D s_179_1: write-var gs#409441 <= s_179_0
        fn_state.gs_409441 = s_179_0;
        // N s_179_2: jump b180
        return block_180(state, tracer, fn_state);
    }
    fn block_180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_180_0: read-var gs#409441:u8
        let s_180_0: bool = fn_state.gs_409441;
        // N s_180_1: branch s_180_0 b1394 b181
        if s_180_0 {
            return block_1394(state, tracer, fn_state);
        } else {
            return block_181(state, tracer, fn_state);
        };
    }
    fn block_181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_181_0: const #0u : u8
        let s_181_0: bool = false;
        // D s_181_1: write-var gs#409446 <= s_181_0
        fn_state.gs_409446 = s_181_0;
        // N s_181_2: jump b182
        return block_182(state, tracer, fn_state);
    }
    fn block_182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_182_0: read-var gs#409446:u8
        let s_182_0: bool = fn_state.gs_409446;
        // D s_182_1: not s_182_0
        let s_182_1: bool = !s_182_0;
        // N s_182_2: branch s_182_1 b207 b183
        if s_182_1 {
            return block_207(state, tracer, fn_state);
        } else {
            return block_183(state, tracer, fn_state);
        };
    }
    fn block_183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_183_0: const #3089s : i
        let s_183_0: i128 = 3089;
        // C s_183_1: const #14696u : u32
        let s_183_1: u32 = 14696;
        // N s_183_2: write-reg s_183_1 <= s_183_0
        let s_183_2: () = {
            state.write_register::<i128>(s_183_1 as isize, s_183_0);
            tracer.write_register(s_183_1 as isize, s_183_0);
        };
        // C s_183_3: const #28s : i
        let s_183_3: i128 = 28;
        // C s_183_4: const #4s : i
        let s_183_4: i128 = 4;
        // D s_183_5: read-var u#33477:u32
        let s_183_5: u32 = fn_state.u_33477;
        // D s_183_6: cast zx s_183_5 -> bv
        let s_183_6: Bits = Bits::new(s_183_5 as u128, 32u16);
        // D s_183_7: bit-extract s_183_6 s_183_3 s_183_4
        let s_183_7: Bits = (Bits::new(
            ((s_183_6) >> (s_183_3)).value(),
            u16::try_from(s_183_4).unwrap(),
        ));
        // D s_183_8: cast reint s_183_7 -> u8
        let s_183_8: u8 = (s_183_7.value() as u8);
        // D s_183_9: write-var u#33478 <= s_183_8
        fn_state.u_33478 = s_183_8;
        // C s_183_10: const #12s : i
        let s_183_10: i128 = 12;
        // C s_183_11: const #4s : i
        let s_183_11: i128 = 4;
        // D s_183_12: read-var u#33477:u32
        let s_183_12: u32 = fn_state.u_33477;
        // D s_183_13: cast zx s_183_12 -> bv
        let s_183_13: Bits = Bits::new(s_183_12 as u128, 32u16);
        // D s_183_14: bit-extract s_183_13 s_183_10 s_183_11
        let s_183_14: Bits = (Bits::new(
            ((s_183_13) >> (s_183_10)).value(),
            u16::try_from(s_183_11).unwrap(),
        ));
        // D s_183_15: cast reint s_183_14 -> u8
        let s_183_15: u8 = (s_183_14.value() as u8);
        // D s_183_16: write-var u#33479 <= s_183_15
        fn_state.u_33479 = s_183_15;
        // C s_183_17: const #0s : i
        let s_183_17: i128 = 0;
        // C s_183_18: const #4s : i
        let s_183_18: i128 = 4;
        // D s_183_19: read-var u#33477:u32
        let s_183_19: u32 = fn_state.u_33477;
        // D s_183_20: cast zx s_183_19 -> bv
        let s_183_20: Bits = Bits::new(s_183_19 as u128, 32u16);
        // D s_183_21: bit-extract s_183_20 s_183_17 s_183_18
        let s_183_21: Bits = (Bits::new(
            ((s_183_20) >> (s_183_17)).value(),
            u16::try_from(s_183_18).unwrap(),
        ));
        // D s_183_22: cast reint s_183_21 -> u8
        let s_183_22: u8 = (s_183_21.value() as u8);
        // D s_183_23: write-var u#33480 <= s_183_22
        fn_state.u_33480 = s_183_22;
        // C s_183_24: const #16s : i
        let s_183_24: i128 = 16;
        // D s_183_25: read-var u#33477:u32
        let s_183_25: u32 = fn_state.u_33477;
        // D s_183_26: cast zx s_183_25 -> bv
        let s_183_26: Bits = Bits::new(s_183_25 as u128, 32u16);
        // C s_183_27: const #1u : u64
        let s_183_27: u64 = 1;
        // D s_183_28: bit-extract s_183_26 s_183_24 s_183_27
        let s_183_28: Bits = (Bits::new(
            ((s_183_26) >> (s_183_24)).value(),
            u16::try_from(s_183_27).unwrap(),
        ));
        // D s_183_29: cast reint s_183_28 -> u8
        let s_183_29: bool = ((s_183_28.value()) != 0);
        // C s_183_30: const #0s : i
        let s_183_30: i128 = 0;
        // C s_183_31: const #0u : u64
        let s_183_31: u64 = 0;
        // D s_183_32: cast zx s_183_29 -> u64
        let s_183_32: u64 = (s_183_29 as u64);
        // C s_183_33: const #1u : u64
        let s_183_33: u64 = 1;
        // D s_183_34: and s_183_32 s_183_33
        let s_183_34: u64 = ((s_183_32) & (s_183_33));
        // D s_183_35: cmp-eq s_183_34 s_183_33
        let s_183_35: bool = ((s_183_34) == (s_183_33));
        // D s_183_36: lsl s_183_32 s_183_30
        let s_183_36: u64 = s_183_32 << s_183_30;
        // D s_183_37: or s_183_31 s_183_36
        let s_183_37: u64 = ((s_183_31) | (s_183_36));
        // D s_183_38: cmpl s_183_36
        let s_183_38: u64 = !s_183_36;
        // D s_183_39: and s_183_31 s_183_38
        let s_183_39: u64 = ((s_183_31) & (s_183_38));
        // D s_183_40: select s_183_35 s_183_37 s_183_39
        let s_183_40: u64 = if s_183_35 { s_183_37 } else { s_183_39 };
        // D s_183_41: cast trunc s_183_40 -> u8
        let s_183_41: bool = ((s_183_40) != 0);
        // D s_183_42: cast zx s_183_41 -> bv
        let s_183_42: Bits = Bits::new(s_183_41 as u128, 1u16);
        // C s_183_43: const #1u : u8
        let s_183_43: bool = true;
        // C s_183_44: cast zx s_183_43 -> bv
        let s_183_44: Bits = Bits::new(s_183_43 as u128, 1u16);
        // D s_183_45: cmp-ne s_183_42 s_183_44
        let s_183_45: bool = ((s_183_42) != (s_183_44));
        // N s_183_46: branch s_183_45 b206 b184
        if s_183_45 {
            return block_206(state, tracer, fn_state);
        } else {
            return block_184(state, tracer, fn_state);
        };
    }
    fn block_184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_184_0: const #17s : i
        let s_184_0: i128 = 17;
        // D s_184_1: read-var u#33477:u32
        let s_184_1: u32 = fn_state.u_33477;
        // D s_184_2: cast zx s_184_1 -> bv
        let s_184_2: Bits = Bits::new(s_184_1 as u128, 32u16);
        // C s_184_3: const #1u : u64
        let s_184_3: u64 = 1;
        // D s_184_4: bit-extract s_184_2 s_184_0 s_184_3
        let s_184_4: Bits = (Bits::new(
            ((s_184_2) >> (s_184_0)).value(),
            u16::try_from(s_184_3).unwrap(),
        ));
        // D s_184_5: cast reint s_184_4 -> u8
        let s_184_5: bool = ((s_184_4.value()) != 0);
        // C s_184_6: const #0s : i
        let s_184_6: i128 = 0;
        // C s_184_7: const #0u : u64
        let s_184_7: u64 = 0;
        // D s_184_8: cast zx s_184_5 -> u64
        let s_184_8: u64 = (s_184_5 as u64);
        // C s_184_9: const #1u : u64
        let s_184_9: u64 = 1;
        // D s_184_10: and s_184_8 s_184_9
        let s_184_10: u64 = ((s_184_8) & (s_184_9));
        // D s_184_11: cmp-eq s_184_10 s_184_9
        let s_184_11: bool = ((s_184_10) == (s_184_9));
        // D s_184_12: lsl s_184_8 s_184_6
        let s_184_12: u64 = s_184_8 << s_184_6;
        // D s_184_13: or s_184_7 s_184_12
        let s_184_13: u64 = ((s_184_7) | (s_184_12));
        // D s_184_14: cmpl s_184_12
        let s_184_14: u64 = !s_184_12;
        // D s_184_15: and s_184_7 s_184_14
        let s_184_15: u64 = ((s_184_7) & (s_184_14));
        // D s_184_16: select s_184_11 s_184_13 s_184_15
        let s_184_16: u64 = if s_184_11 { s_184_13 } else { s_184_15 };
        // D s_184_17: cast trunc s_184_16 -> u8
        let s_184_17: bool = ((s_184_16) != 0);
        // D s_184_18: cast zx s_184_17 -> bv
        let s_184_18: Bits = Bits::new(s_184_17 as u128, 1u16);
        // C s_184_19: const #1u : u8
        let s_184_19: bool = true;
        // C s_184_20: cast zx s_184_19 -> bv
        let s_184_20: Bits = Bits::new(s_184_19 as u128, 1u16);
        // D s_184_21: cmp-ne s_184_18 s_184_20
        let s_184_21: bool = ((s_184_18) != (s_184_20));
        // D s_184_22: write-var gs#409459 <= s_184_21
        fn_state.gs_409459 = s_184_21;
        // N s_184_23: jump b185
        return block_185(state, tracer, fn_state);
    }
    fn block_185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_185_0: read-var gs#409459:u8
        let s_185_0: bool = fn_state.gs_409459;
        // N s_185_1: branch s_185_0 b205 b186
        if s_185_0 {
            return block_205(state, tracer, fn_state);
        } else {
            return block_186(state, tracer, fn_state);
        };
    }
    fn block_186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_186_0: const #18s : i
        let s_186_0: i128 = 18;
        // D s_186_1: read-var u#33477:u32
        let s_186_1: u32 = fn_state.u_33477;
        // D s_186_2: cast zx s_186_1 -> bv
        let s_186_2: Bits = Bits::new(s_186_1 as u128, 32u16);
        // C s_186_3: const #1u : u64
        let s_186_3: u64 = 1;
        // D s_186_4: bit-extract s_186_2 s_186_0 s_186_3
        let s_186_4: Bits = (Bits::new(
            ((s_186_2) >> (s_186_0)).value(),
            u16::try_from(s_186_3).unwrap(),
        ));
        // D s_186_5: cast reint s_186_4 -> u8
        let s_186_5: bool = ((s_186_4.value()) != 0);
        // C s_186_6: const #0s : i
        let s_186_6: i128 = 0;
        // C s_186_7: const #0u : u64
        let s_186_7: u64 = 0;
        // D s_186_8: cast zx s_186_5 -> u64
        let s_186_8: u64 = (s_186_5 as u64);
        // C s_186_9: const #1u : u64
        let s_186_9: u64 = 1;
        // D s_186_10: and s_186_8 s_186_9
        let s_186_10: u64 = ((s_186_8) & (s_186_9));
        // D s_186_11: cmp-eq s_186_10 s_186_9
        let s_186_11: bool = ((s_186_10) == (s_186_9));
        // D s_186_12: lsl s_186_8 s_186_6
        let s_186_12: u64 = s_186_8 << s_186_6;
        // D s_186_13: or s_186_7 s_186_12
        let s_186_13: u64 = ((s_186_7) | (s_186_12));
        // D s_186_14: cmpl s_186_12
        let s_186_14: u64 = !s_186_12;
        // D s_186_15: and s_186_7 s_186_14
        let s_186_15: u64 = ((s_186_7) & (s_186_14));
        // D s_186_16: select s_186_11 s_186_13 s_186_15
        let s_186_16: u64 = if s_186_11 { s_186_13 } else { s_186_15 };
        // D s_186_17: cast trunc s_186_16 -> u8
        let s_186_17: bool = ((s_186_16) != 0);
        // D s_186_18: cast zx s_186_17 -> bv
        let s_186_18: Bits = Bits::new(s_186_17 as u128, 1u16);
        // C s_186_19: const #1u : u8
        let s_186_19: bool = true;
        // C s_186_20: cast zx s_186_19 -> bv
        let s_186_20: Bits = Bits::new(s_186_19 as u128, 1u16);
        // D s_186_21: cmp-ne s_186_18 s_186_20
        let s_186_21: bool = ((s_186_18) != (s_186_20));
        // D s_186_22: write-var gs#409462 <= s_186_21
        fn_state.gs_409462 = s_186_21;
        // N s_186_23: jump b187
        return block_187(state, tracer, fn_state);
    }
    fn block_187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_187_0: read-var gs#409462:u8
        let s_187_0: bool = fn_state.gs_409462;
        // N s_187_1: branch s_187_0 b204 b188
        if s_187_0 {
            return block_204(state, tracer, fn_state);
        } else {
            return block_188(state, tracer, fn_state);
        };
    }
    fn block_188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_188_0: const #19s : i
        let s_188_0: i128 = 19;
        // D s_188_1: read-var u#33477:u32
        let s_188_1: u32 = fn_state.u_33477;
        // D s_188_2: cast zx s_188_1 -> bv
        let s_188_2: Bits = Bits::new(s_188_1 as u128, 32u16);
        // C s_188_3: const #1u : u64
        let s_188_3: u64 = 1;
        // D s_188_4: bit-extract s_188_2 s_188_0 s_188_3
        let s_188_4: Bits = (Bits::new(
            ((s_188_2) >> (s_188_0)).value(),
            u16::try_from(s_188_3).unwrap(),
        ));
        // D s_188_5: cast reint s_188_4 -> u8
        let s_188_5: bool = ((s_188_4.value()) != 0);
        // C s_188_6: const #0s : i
        let s_188_6: i128 = 0;
        // C s_188_7: const #0u : u64
        let s_188_7: u64 = 0;
        // D s_188_8: cast zx s_188_5 -> u64
        let s_188_8: u64 = (s_188_5 as u64);
        // C s_188_9: const #1u : u64
        let s_188_9: u64 = 1;
        // D s_188_10: and s_188_8 s_188_9
        let s_188_10: u64 = ((s_188_8) & (s_188_9));
        // D s_188_11: cmp-eq s_188_10 s_188_9
        let s_188_11: bool = ((s_188_10) == (s_188_9));
        // D s_188_12: lsl s_188_8 s_188_6
        let s_188_12: u64 = s_188_8 << s_188_6;
        // D s_188_13: or s_188_7 s_188_12
        let s_188_13: u64 = ((s_188_7) | (s_188_12));
        // D s_188_14: cmpl s_188_12
        let s_188_14: u64 = !s_188_12;
        // D s_188_15: and s_188_7 s_188_14
        let s_188_15: u64 = ((s_188_7) & (s_188_14));
        // D s_188_16: select s_188_11 s_188_13 s_188_15
        let s_188_16: u64 = if s_188_11 { s_188_13 } else { s_188_15 };
        // D s_188_17: cast trunc s_188_16 -> u8
        let s_188_17: bool = ((s_188_16) != 0);
        // D s_188_18: cast zx s_188_17 -> bv
        let s_188_18: Bits = Bits::new(s_188_17 as u128, 1u16);
        // C s_188_19: const #1u : u8
        let s_188_19: bool = true;
        // C s_188_20: cast zx s_188_19 -> bv
        let s_188_20: Bits = Bits::new(s_188_19 as u128, 1u16);
        // D s_188_21: cmp-ne s_188_18 s_188_20
        let s_188_21: bool = ((s_188_18) != (s_188_20));
        // D s_188_22: write-var gs#409465 <= s_188_21
        fn_state.gs_409465 = s_188_21;
        // N s_188_23: jump b189
        return block_189(state, tracer, fn_state);
    }
    fn block_189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_189_0: read-var gs#409465:u8
        let s_189_0: bool = fn_state.gs_409465;
        // N s_189_1: branch s_189_0 b203 b190
        if s_189_0 {
            return block_203(state, tracer, fn_state);
        } else {
            return block_190(state, tracer, fn_state);
        };
    }
    fn block_190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_190_0: const #8s : i
        let s_190_0: i128 = 8;
        // D s_190_1: read-var u#33477:u32
        let s_190_1: u32 = fn_state.u_33477;
        // D s_190_2: cast zx s_190_1 -> bv
        let s_190_2: Bits = Bits::new(s_190_1 as u128, 32u16);
        // C s_190_3: const #1u : u64
        let s_190_3: u64 = 1;
        // D s_190_4: bit-extract s_190_2 s_190_0 s_190_3
        let s_190_4: Bits = (Bits::new(
            ((s_190_2) >> (s_190_0)).value(),
            u16::try_from(s_190_3).unwrap(),
        ));
        // D s_190_5: cast reint s_190_4 -> u8
        let s_190_5: bool = ((s_190_4.value()) != 0);
        // C s_190_6: const #0s : i
        let s_190_6: i128 = 0;
        // C s_190_7: const #0u : u64
        let s_190_7: u64 = 0;
        // D s_190_8: cast zx s_190_5 -> u64
        let s_190_8: u64 = (s_190_5 as u64);
        // C s_190_9: const #1u : u64
        let s_190_9: u64 = 1;
        // D s_190_10: and s_190_8 s_190_9
        let s_190_10: u64 = ((s_190_8) & (s_190_9));
        // D s_190_11: cmp-eq s_190_10 s_190_9
        let s_190_11: bool = ((s_190_10) == (s_190_9));
        // D s_190_12: lsl s_190_8 s_190_6
        let s_190_12: u64 = s_190_8 << s_190_6;
        // D s_190_13: or s_190_7 s_190_12
        let s_190_13: u64 = ((s_190_7) | (s_190_12));
        // D s_190_14: cmpl s_190_12
        let s_190_14: u64 = !s_190_12;
        // D s_190_15: and s_190_7 s_190_14
        let s_190_15: u64 = ((s_190_7) & (s_190_14));
        // D s_190_16: select s_190_11 s_190_13 s_190_15
        let s_190_16: u64 = if s_190_11 { s_190_13 } else { s_190_15 };
        // D s_190_17: cast trunc s_190_16 -> u8
        let s_190_17: bool = ((s_190_16) != 0);
        // D s_190_18: cast zx s_190_17 -> bv
        let s_190_18: Bits = Bits::new(s_190_17 as u128, 1u16);
        // C s_190_19: const #1u : u8
        let s_190_19: bool = true;
        // C s_190_20: cast zx s_190_19 -> bv
        let s_190_20: Bits = Bits::new(s_190_19 as u128, 1u16);
        // D s_190_21: cmp-ne s_190_18 s_190_20
        let s_190_21: bool = ((s_190_18) != (s_190_20));
        // D s_190_22: write-var gs#409468 <= s_190_21
        fn_state.gs_409468 = s_190_21;
        // N s_190_23: jump b191
        return block_191(state, tracer, fn_state);
    }
    fn block_191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_191_0: read-var gs#409468:u8
        let s_191_0: bool = fn_state.gs_409468;
        // N s_191_1: branch s_191_0 b202 b192
        if s_191_0 {
            return block_202(state, tracer, fn_state);
        } else {
            return block_192(state, tracer, fn_state);
        };
    }
    fn block_192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_192_0: const #9s : i
        let s_192_0: i128 = 9;
        // D s_192_1: read-var u#33477:u32
        let s_192_1: u32 = fn_state.u_33477;
        // D s_192_2: cast zx s_192_1 -> bv
        let s_192_2: Bits = Bits::new(s_192_1 as u128, 32u16);
        // C s_192_3: const #1u : u64
        let s_192_3: u64 = 1;
        // D s_192_4: bit-extract s_192_2 s_192_0 s_192_3
        let s_192_4: Bits = (Bits::new(
            ((s_192_2) >> (s_192_0)).value(),
            u16::try_from(s_192_3).unwrap(),
        ));
        // D s_192_5: cast reint s_192_4 -> u8
        let s_192_5: bool = ((s_192_4.value()) != 0);
        // C s_192_6: const #0s : i
        let s_192_6: i128 = 0;
        // C s_192_7: const #0u : u64
        let s_192_7: u64 = 0;
        // D s_192_8: cast zx s_192_5 -> u64
        let s_192_8: u64 = (s_192_5 as u64);
        // C s_192_9: const #1u : u64
        let s_192_9: u64 = 1;
        // D s_192_10: and s_192_8 s_192_9
        let s_192_10: u64 = ((s_192_8) & (s_192_9));
        // D s_192_11: cmp-eq s_192_10 s_192_9
        let s_192_11: bool = ((s_192_10) == (s_192_9));
        // D s_192_12: lsl s_192_8 s_192_6
        let s_192_12: u64 = s_192_8 << s_192_6;
        // D s_192_13: or s_192_7 s_192_12
        let s_192_13: u64 = ((s_192_7) | (s_192_12));
        // D s_192_14: cmpl s_192_12
        let s_192_14: u64 = !s_192_12;
        // D s_192_15: and s_192_7 s_192_14
        let s_192_15: u64 = ((s_192_7) & (s_192_14));
        // D s_192_16: select s_192_11 s_192_13 s_192_15
        let s_192_16: u64 = if s_192_11 { s_192_13 } else { s_192_15 };
        // D s_192_17: cast trunc s_192_16 -> u8
        let s_192_17: bool = ((s_192_16) != 0);
        // D s_192_18: cast zx s_192_17 -> bv
        let s_192_18: Bits = Bits::new(s_192_17 as u128, 1u16);
        // C s_192_19: const #1u : u8
        let s_192_19: bool = true;
        // C s_192_20: cast zx s_192_19 -> bv
        let s_192_20: Bits = Bits::new(s_192_19 as u128, 1u16);
        // D s_192_21: cmp-ne s_192_18 s_192_20
        let s_192_21: bool = ((s_192_18) != (s_192_20));
        // D s_192_22: write-var gs#409471 <= s_192_21
        fn_state.gs_409471 = s_192_21;
        // N s_192_23: jump b193
        return block_193(state, tracer, fn_state);
    }
    fn block_193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_193_0: read-var gs#409471:u8
        let s_193_0: bool = fn_state.gs_409471;
        // N s_193_1: branch s_193_0 b201 b194
        if s_193_0 {
            return block_201(state, tracer, fn_state);
        } else {
            return block_194(state, tracer, fn_state);
        };
    }
    fn block_194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_194_0: const #10s : i
        let s_194_0: i128 = 10;
        // D s_194_1: read-var u#33477:u32
        let s_194_1: u32 = fn_state.u_33477;
        // D s_194_2: cast zx s_194_1 -> bv
        let s_194_2: Bits = Bits::new(s_194_1 as u128, 32u16);
        // C s_194_3: const #1u : u64
        let s_194_3: u64 = 1;
        // D s_194_4: bit-extract s_194_2 s_194_0 s_194_3
        let s_194_4: Bits = (Bits::new(
            ((s_194_2) >> (s_194_0)).value(),
            u16::try_from(s_194_3).unwrap(),
        ));
        // D s_194_5: cast reint s_194_4 -> u8
        let s_194_5: bool = ((s_194_4.value()) != 0);
        // C s_194_6: const #0s : i
        let s_194_6: i128 = 0;
        // C s_194_7: const #0u : u64
        let s_194_7: u64 = 0;
        // D s_194_8: cast zx s_194_5 -> u64
        let s_194_8: u64 = (s_194_5 as u64);
        // C s_194_9: const #1u : u64
        let s_194_9: u64 = 1;
        // D s_194_10: and s_194_8 s_194_9
        let s_194_10: u64 = ((s_194_8) & (s_194_9));
        // D s_194_11: cmp-eq s_194_10 s_194_9
        let s_194_11: bool = ((s_194_10) == (s_194_9));
        // D s_194_12: lsl s_194_8 s_194_6
        let s_194_12: u64 = s_194_8 << s_194_6;
        // D s_194_13: or s_194_7 s_194_12
        let s_194_13: u64 = ((s_194_7) | (s_194_12));
        // D s_194_14: cmpl s_194_12
        let s_194_14: u64 = !s_194_12;
        // D s_194_15: and s_194_7 s_194_14
        let s_194_15: u64 = ((s_194_7) & (s_194_14));
        // D s_194_16: select s_194_11 s_194_13 s_194_15
        let s_194_16: u64 = if s_194_11 { s_194_13 } else { s_194_15 };
        // D s_194_17: cast trunc s_194_16 -> u8
        let s_194_17: bool = ((s_194_16) != 0);
        // D s_194_18: cast zx s_194_17 -> bv
        let s_194_18: Bits = Bits::new(s_194_17 as u128, 1u16);
        // C s_194_19: const #1u : u8
        let s_194_19: bool = true;
        // C s_194_20: cast zx s_194_19 -> bv
        let s_194_20: Bits = Bits::new(s_194_19 as u128, 1u16);
        // D s_194_21: cmp-ne s_194_18 s_194_20
        let s_194_21: bool = ((s_194_18) != (s_194_20));
        // D s_194_22: write-var gs#409474 <= s_194_21
        fn_state.gs_409474 = s_194_21;
        // N s_194_23: jump b195
        return block_195(state, tracer, fn_state);
    }
    fn block_195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_195_0: read-var gs#409474:u8
        let s_195_0: bool = fn_state.gs_409474;
        // N s_195_1: branch s_195_0 b200 b196
        if s_195_0 {
            return block_200(state, tracer, fn_state);
        } else {
            return block_196(state, tracer, fn_state);
        };
    }
    fn block_196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_196_0: const #11s : i
        let s_196_0: i128 = 11;
        // D s_196_1: read-var u#33477:u32
        let s_196_1: u32 = fn_state.u_33477;
        // D s_196_2: cast zx s_196_1 -> bv
        let s_196_2: Bits = Bits::new(s_196_1 as u128, 32u16);
        // C s_196_3: const #1u : u64
        let s_196_3: u64 = 1;
        // D s_196_4: bit-extract s_196_2 s_196_0 s_196_3
        let s_196_4: Bits = (Bits::new(
            ((s_196_2) >> (s_196_0)).value(),
            u16::try_from(s_196_3).unwrap(),
        ));
        // D s_196_5: cast reint s_196_4 -> u8
        let s_196_5: bool = ((s_196_4.value()) != 0);
        // C s_196_6: const #0s : i
        let s_196_6: i128 = 0;
        // C s_196_7: const #0u : u64
        let s_196_7: u64 = 0;
        // D s_196_8: cast zx s_196_5 -> u64
        let s_196_8: u64 = (s_196_5 as u64);
        // C s_196_9: const #1u : u64
        let s_196_9: u64 = 1;
        // D s_196_10: and s_196_8 s_196_9
        let s_196_10: u64 = ((s_196_8) & (s_196_9));
        // D s_196_11: cmp-eq s_196_10 s_196_9
        let s_196_11: bool = ((s_196_10) == (s_196_9));
        // D s_196_12: lsl s_196_8 s_196_6
        let s_196_12: u64 = s_196_8 << s_196_6;
        // D s_196_13: or s_196_7 s_196_12
        let s_196_13: u64 = ((s_196_7) | (s_196_12));
        // D s_196_14: cmpl s_196_12
        let s_196_14: u64 = !s_196_12;
        // D s_196_15: and s_196_7 s_196_14
        let s_196_15: u64 = ((s_196_7) & (s_196_14));
        // D s_196_16: select s_196_11 s_196_13 s_196_15
        let s_196_16: u64 = if s_196_11 { s_196_13 } else { s_196_15 };
        // D s_196_17: cast trunc s_196_16 -> u8
        let s_196_17: bool = ((s_196_16) != 0);
        // D s_196_18: cast zx s_196_17 -> bv
        let s_196_18: Bits = Bits::new(s_196_17 as u128, 1u16);
        // C s_196_19: const #1u : u8
        let s_196_19: bool = true;
        // C s_196_20: cast zx s_196_19 -> bv
        let s_196_20: Bits = Bits::new(s_196_19 as u128, 1u16);
        // D s_196_21: cmp-ne s_196_18 s_196_20
        let s_196_21: bool = ((s_196_18) != (s_196_20));
        // D s_196_22: write-var gs#409477 <= s_196_21
        fn_state.gs_409477 = s_196_21;
        // N s_196_23: jump b197
        return block_197(state, tracer, fn_state);
    }
    fn block_197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_197_0: read-var gs#409477:u8
        let s_197_0: bool = fn_state.gs_409477;
        // N s_197_1: branch s_197_0 b199 b198
        if s_197_0 {
            return block_199(state, tracer, fn_state);
        } else {
            return block_198(state, tracer, fn_state);
        };
    }
    fn block_198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_198_0: read-var u#33478:u8
        let s_198_0: u8 = fn_state.u_33478;
        // D s_198_1: read-var u#33479:u8
        let s_198_1: u8 = fn_state.u_33479;
        // D s_198_2: read-var u#33480:u8
        let s_198_2: u8 = fn_state.u_33480;
        // D s_198_3: call decode_aarch32_instrs_REV_A1enc_A_txt(s_198_0, s_198_1, s_198_2)
        let s_198_3: () = decode_aarch32_instrs_REV_A1enc_A_txt(
            state,
            tracer,
            s_198_0,
            s_198_1,
            s_198_2,
        );
        // N s_198_4: return
        return;
    }
    fn block_199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_199_0: panic
        panic!("{:?}", ());
        // N s_199_1: return
        return;
    }
    fn block_200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_200_0: const #1u : u8
        let s_200_0: bool = true;
        // D s_200_1: write-var gs#409477 <= s_200_0
        fn_state.gs_409477 = s_200_0;
        // N s_200_2: jump b197
        return block_197(state, tracer, fn_state);
    }
    fn block_201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_201_0: const #1u : u8
        let s_201_0: bool = true;
        // D s_201_1: write-var gs#409474 <= s_201_0
        fn_state.gs_409474 = s_201_0;
        // N s_201_2: jump b195
        return block_195(state, tracer, fn_state);
    }
    fn block_202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_202_0: const #1u : u8
        let s_202_0: bool = true;
        // D s_202_1: write-var gs#409471 <= s_202_0
        fn_state.gs_409471 = s_202_0;
        // N s_202_2: jump b193
        return block_193(state, tracer, fn_state);
    }
    fn block_203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_203_0: const #1u : u8
        let s_203_0: bool = true;
        // D s_203_1: write-var gs#409468 <= s_203_0
        fn_state.gs_409468 = s_203_0;
        // N s_203_2: jump b191
        return block_191(state, tracer, fn_state);
    }
    fn block_204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_204_0: const #1u : u8
        let s_204_0: bool = true;
        // D s_204_1: write-var gs#409465 <= s_204_0
        fn_state.gs_409465 = s_204_0;
        // N s_204_2: jump b189
        return block_189(state, tracer, fn_state);
    }
    fn block_205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_205_0: const #1u : u8
        let s_205_0: bool = true;
        // D s_205_1: write-var gs#409462 <= s_205_0
        fn_state.gs_409462 = s_205_0;
        // N s_205_2: jump b187
        return block_187(state, tracer, fn_state);
    }
    fn block_206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_206_0: const #1u : u8
        let s_206_0: bool = true;
        // D s_206_1: write-var gs#409459 <= s_206_0
        fn_state.gs_409459 = s_206_0;
        // N s_206_2: jump b185
        return block_185(state, tracer, fn_state);
    }
    fn block_207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_207_0: read-var merge#var.1:struct
        let s_207_0: u32 = fn_state.merge_var._1;
        // D s_207_1: write-var u#33482 <= s_207_0
        fn_state.u_33482 = s_207_0;
        // C s_207_2: const #16s : i
        let s_207_2: i128 = 16;
        // D s_207_3: read-var u#33482:u32
        let s_207_3: u32 = fn_state.u_33482;
        // D s_207_4: cast zx s_207_3 -> bv
        let s_207_4: Bits = Bits::new(s_207_3 as u128, 32u16);
        // C s_207_5: const #1s : i64
        let s_207_5: i64 = 1;
        // C s_207_6: cast zx s_207_5 -> i
        let s_207_6: i128 = (i128::try_from(s_207_5).unwrap());
        // C s_207_7: const #11s : i
        let s_207_7: i128 = 11;
        // C s_207_8: add s_207_7 s_207_6
        let s_207_8: i128 = (s_207_7 + s_207_6);
        // D s_207_9: bit-extract s_207_4 s_207_2 s_207_8
        let s_207_9: Bits = (Bits::new(
            ((s_207_4) >> (s_207_2)).value(),
            u16::try_from(s_207_8).unwrap(),
        ));
        // D s_207_10: cast reint s_207_9 -> u12
        let s_207_10: u16 = (s_207_9.value() as u16);
        // D s_207_11: cast zx s_207_10 -> bv
        let s_207_11: Bits = Bits::new(s_207_10 as u128, 12u16);
        // C s_207_12: const #1791u : u12
        let s_207_12: u16 = 1791;
        // C s_207_13: cast zx s_207_12 -> bv
        let s_207_13: Bits = Bits::new(s_207_12 as u128, 12u16);
        // D s_207_14: cmp-eq s_207_11 s_207_13
        let s_207_14: bool = ((s_207_11) == (s_207_13));
        // N s_207_15: branch s_207_14 b1393 b208
        if s_207_14 {
            return block_1393(state, tracer, fn_state);
        } else {
            return block_208(state, tracer, fn_state);
        };
    }
    fn block_208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_208_0: const #0u : u8
        let s_208_0: bool = false;
        // D s_208_1: write-var gs#409483 <= s_208_0
        fn_state.gs_409483 = s_208_0;
        // N s_208_2: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_209_0: read-var gs#409483:u8
        let s_209_0: bool = fn_state.gs_409483;
        // N s_209_1: branch s_209_0 b1389 b210
        if s_209_0 {
            return block_1389(state, tracer, fn_state);
        } else {
            return block_210(state, tracer, fn_state);
        };
    }
    fn block_210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_210_0: const #0u : u8
        let s_210_0: bool = false;
        // D s_210_1: write-var gs#409488 <= s_210_0
        fn_state.gs_409488 = s_210_0;
        // N s_210_2: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_211_0: read-var gs#409488:u8
        let s_211_0: bool = fn_state.gs_409488;
        // D s_211_1: not s_211_0
        let s_211_1: bool = !s_211_0;
        // N s_211_2: branch s_211_1 b236 b212
        if s_211_1 {
            return block_236(state, tracer, fn_state);
        } else {
            return block_212(state, tracer, fn_state);
        };
    }
    fn block_212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_212_0: const #3092s : i
        let s_212_0: i128 = 3092;
        // C s_212_1: const #14696u : u32
        let s_212_1: u32 = 14696;
        // N s_212_2: write-reg s_212_1 <= s_212_0
        let s_212_2: () = {
            state.write_register::<i128>(s_212_1 as isize, s_212_0);
            tracer.write_register(s_212_1 as isize, s_212_0);
        };
        // C s_212_3: const #28s : i
        let s_212_3: i128 = 28;
        // C s_212_4: const #4s : i
        let s_212_4: i128 = 4;
        // D s_212_5: read-var u#33482:u32
        let s_212_5: u32 = fn_state.u_33482;
        // D s_212_6: cast zx s_212_5 -> bv
        let s_212_6: Bits = Bits::new(s_212_5 as u128, 32u16);
        // D s_212_7: bit-extract s_212_6 s_212_3 s_212_4
        let s_212_7: Bits = (Bits::new(
            ((s_212_6) >> (s_212_3)).value(),
            u16::try_from(s_212_4).unwrap(),
        ));
        // D s_212_8: cast reint s_212_7 -> u8
        let s_212_8: u8 = (s_212_7.value() as u8);
        // D s_212_9: write-var u#33483 <= s_212_8
        fn_state.u_33483 = s_212_8;
        // C s_212_10: const #12s : i
        let s_212_10: i128 = 12;
        // C s_212_11: const #4s : i
        let s_212_11: i128 = 4;
        // D s_212_12: read-var u#33482:u32
        let s_212_12: u32 = fn_state.u_33482;
        // D s_212_13: cast zx s_212_12 -> bv
        let s_212_13: Bits = Bits::new(s_212_12 as u128, 32u16);
        // D s_212_14: bit-extract s_212_13 s_212_10 s_212_11
        let s_212_14: Bits = (Bits::new(
            ((s_212_13) >> (s_212_10)).value(),
            u16::try_from(s_212_11).unwrap(),
        ));
        // D s_212_15: cast reint s_212_14 -> u8
        let s_212_15: u8 = (s_212_14.value() as u8);
        // D s_212_16: write-var u#33484 <= s_212_15
        fn_state.u_33484 = s_212_15;
        // C s_212_17: const #0s : i
        let s_212_17: i128 = 0;
        // C s_212_18: const #4s : i
        let s_212_18: i128 = 4;
        // D s_212_19: read-var u#33482:u32
        let s_212_19: u32 = fn_state.u_33482;
        // D s_212_20: cast zx s_212_19 -> bv
        let s_212_20: Bits = Bits::new(s_212_19 as u128, 32u16);
        // D s_212_21: bit-extract s_212_20 s_212_17 s_212_18
        let s_212_21: Bits = (Bits::new(
            ((s_212_20) >> (s_212_17)).value(),
            u16::try_from(s_212_18).unwrap(),
        ));
        // D s_212_22: cast reint s_212_21 -> u8
        let s_212_22: u8 = (s_212_21.value() as u8);
        // D s_212_23: write-var u#33485 <= s_212_22
        fn_state.u_33485 = s_212_22;
        // C s_212_24: const #16s : i
        let s_212_24: i128 = 16;
        // D s_212_25: read-var u#33482:u32
        let s_212_25: u32 = fn_state.u_33482;
        // D s_212_26: cast zx s_212_25 -> bv
        let s_212_26: Bits = Bits::new(s_212_25 as u128, 32u16);
        // C s_212_27: const #1u : u64
        let s_212_27: u64 = 1;
        // D s_212_28: bit-extract s_212_26 s_212_24 s_212_27
        let s_212_28: Bits = (Bits::new(
            ((s_212_26) >> (s_212_24)).value(),
            u16::try_from(s_212_27).unwrap(),
        ));
        // D s_212_29: cast reint s_212_28 -> u8
        let s_212_29: bool = ((s_212_28.value()) != 0);
        // C s_212_30: const #0s : i
        let s_212_30: i128 = 0;
        // C s_212_31: const #0u : u64
        let s_212_31: u64 = 0;
        // D s_212_32: cast zx s_212_29 -> u64
        let s_212_32: u64 = (s_212_29 as u64);
        // C s_212_33: const #1u : u64
        let s_212_33: u64 = 1;
        // D s_212_34: and s_212_32 s_212_33
        let s_212_34: u64 = ((s_212_32) & (s_212_33));
        // D s_212_35: cmp-eq s_212_34 s_212_33
        let s_212_35: bool = ((s_212_34) == (s_212_33));
        // D s_212_36: lsl s_212_32 s_212_30
        let s_212_36: u64 = s_212_32 << s_212_30;
        // D s_212_37: or s_212_31 s_212_36
        let s_212_37: u64 = ((s_212_31) | (s_212_36));
        // D s_212_38: cmpl s_212_36
        let s_212_38: u64 = !s_212_36;
        // D s_212_39: and s_212_31 s_212_38
        let s_212_39: u64 = ((s_212_31) & (s_212_38));
        // D s_212_40: select s_212_35 s_212_37 s_212_39
        let s_212_40: u64 = if s_212_35 { s_212_37 } else { s_212_39 };
        // D s_212_41: cast trunc s_212_40 -> u8
        let s_212_41: bool = ((s_212_40) != 0);
        // D s_212_42: cast zx s_212_41 -> bv
        let s_212_42: Bits = Bits::new(s_212_41 as u128, 1u16);
        // C s_212_43: const #1u : u8
        let s_212_43: bool = true;
        // C s_212_44: cast zx s_212_43 -> bv
        let s_212_44: Bits = Bits::new(s_212_43 as u128, 1u16);
        // D s_212_45: cmp-ne s_212_42 s_212_44
        let s_212_45: bool = ((s_212_42) != (s_212_44));
        // N s_212_46: branch s_212_45 b235 b213
        if s_212_45 {
            return block_235(state, tracer, fn_state);
        } else {
            return block_213(state, tracer, fn_state);
        };
    }
    fn block_213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_213_0: const #17s : i
        let s_213_0: i128 = 17;
        // D s_213_1: read-var u#33482:u32
        let s_213_1: u32 = fn_state.u_33482;
        // D s_213_2: cast zx s_213_1 -> bv
        let s_213_2: Bits = Bits::new(s_213_1 as u128, 32u16);
        // C s_213_3: const #1u : u64
        let s_213_3: u64 = 1;
        // D s_213_4: bit-extract s_213_2 s_213_0 s_213_3
        let s_213_4: Bits = (Bits::new(
            ((s_213_2) >> (s_213_0)).value(),
            u16::try_from(s_213_3).unwrap(),
        ));
        // D s_213_5: cast reint s_213_4 -> u8
        let s_213_5: bool = ((s_213_4.value()) != 0);
        // C s_213_6: const #0s : i
        let s_213_6: i128 = 0;
        // C s_213_7: const #0u : u64
        let s_213_7: u64 = 0;
        // D s_213_8: cast zx s_213_5 -> u64
        let s_213_8: u64 = (s_213_5 as u64);
        // C s_213_9: const #1u : u64
        let s_213_9: u64 = 1;
        // D s_213_10: and s_213_8 s_213_9
        let s_213_10: u64 = ((s_213_8) & (s_213_9));
        // D s_213_11: cmp-eq s_213_10 s_213_9
        let s_213_11: bool = ((s_213_10) == (s_213_9));
        // D s_213_12: lsl s_213_8 s_213_6
        let s_213_12: u64 = s_213_8 << s_213_6;
        // D s_213_13: or s_213_7 s_213_12
        let s_213_13: u64 = ((s_213_7) | (s_213_12));
        // D s_213_14: cmpl s_213_12
        let s_213_14: u64 = !s_213_12;
        // D s_213_15: and s_213_7 s_213_14
        let s_213_15: u64 = ((s_213_7) & (s_213_14));
        // D s_213_16: select s_213_11 s_213_13 s_213_15
        let s_213_16: u64 = if s_213_11 { s_213_13 } else { s_213_15 };
        // D s_213_17: cast trunc s_213_16 -> u8
        let s_213_17: bool = ((s_213_16) != 0);
        // D s_213_18: cast zx s_213_17 -> bv
        let s_213_18: Bits = Bits::new(s_213_17 as u128, 1u16);
        // C s_213_19: const #1u : u8
        let s_213_19: bool = true;
        // C s_213_20: cast zx s_213_19 -> bv
        let s_213_20: Bits = Bits::new(s_213_19 as u128, 1u16);
        // D s_213_21: cmp-ne s_213_18 s_213_20
        let s_213_21: bool = ((s_213_18) != (s_213_20));
        // D s_213_22: write-var gs#409501 <= s_213_21
        fn_state.gs_409501 = s_213_21;
        // N s_213_23: jump b214
        return block_214(state, tracer, fn_state);
    }
    fn block_214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_214_0: read-var gs#409501:u8
        let s_214_0: bool = fn_state.gs_409501;
        // N s_214_1: branch s_214_0 b234 b215
        if s_214_0 {
            return block_234(state, tracer, fn_state);
        } else {
            return block_215(state, tracer, fn_state);
        };
    }
    fn block_215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_215_0: const #18s : i
        let s_215_0: i128 = 18;
        // D s_215_1: read-var u#33482:u32
        let s_215_1: u32 = fn_state.u_33482;
        // D s_215_2: cast zx s_215_1 -> bv
        let s_215_2: Bits = Bits::new(s_215_1 as u128, 32u16);
        // C s_215_3: const #1u : u64
        let s_215_3: u64 = 1;
        // D s_215_4: bit-extract s_215_2 s_215_0 s_215_3
        let s_215_4: Bits = (Bits::new(
            ((s_215_2) >> (s_215_0)).value(),
            u16::try_from(s_215_3).unwrap(),
        ));
        // D s_215_5: cast reint s_215_4 -> u8
        let s_215_5: bool = ((s_215_4.value()) != 0);
        // C s_215_6: const #0s : i
        let s_215_6: i128 = 0;
        // C s_215_7: const #0u : u64
        let s_215_7: u64 = 0;
        // D s_215_8: cast zx s_215_5 -> u64
        let s_215_8: u64 = (s_215_5 as u64);
        // C s_215_9: const #1u : u64
        let s_215_9: u64 = 1;
        // D s_215_10: and s_215_8 s_215_9
        let s_215_10: u64 = ((s_215_8) & (s_215_9));
        // D s_215_11: cmp-eq s_215_10 s_215_9
        let s_215_11: bool = ((s_215_10) == (s_215_9));
        // D s_215_12: lsl s_215_8 s_215_6
        let s_215_12: u64 = s_215_8 << s_215_6;
        // D s_215_13: or s_215_7 s_215_12
        let s_215_13: u64 = ((s_215_7) | (s_215_12));
        // D s_215_14: cmpl s_215_12
        let s_215_14: u64 = !s_215_12;
        // D s_215_15: and s_215_7 s_215_14
        let s_215_15: u64 = ((s_215_7) & (s_215_14));
        // D s_215_16: select s_215_11 s_215_13 s_215_15
        let s_215_16: u64 = if s_215_11 { s_215_13 } else { s_215_15 };
        // D s_215_17: cast trunc s_215_16 -> u8
        let s_215_17: bool = ((s_215_16) != 0);
        // D s_215_18: cast zx s_215_17 -> bv
        let s_215_18: Bits = Bits::new(s_215_17 as u128, 1u16);
        // C s_215_19: const #1u : u8
        let s_215_19: bool = true;
        // C s_215_20: cast zx s_215_19 -> bv
        let s_215_20: Bits = Bits::new(s_215_19 as u128, 1u16);
        // D s_215_21: cmp-ne s_215_18 s_215_20
        let s_215_21: bool = ((s_215_18) != (s_215_20));
        // D s_215_22: write-var gs#409504 <= s_215_21
        fn_state.gs_409504 = s_215_21;
        // N s_215_23: jump b216
        return block_216(state, tracer, fn_state);
    }
    fn block_216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_216_0: read-var gs#409504:u8
        let s_216_0: bool = fn_state.gs_409504;
        // N s_216_1: branch s_216_0 b233 b217
        if s_216_0 {
            return block_233(state, tracer, fn_state);
        } else {
            return block_217(state, tracer, fn_state);
        };
    }
    fn block_217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_217_0: const #19s : i
        let s_217_0: i128 = 19;
        // D s_217_1: read-var u#33482:u32
        let s_217_1: u32 = fn_state.u_33482;
        // D s_217_2: cast zx s_217_1 -> bv
        let s_217_2: Bits = Bits::new(s_217_1 as u128, 32u16);
        // C s_217_3: const #1u : u64
        let s_217_3: u64 = 1;
        // D s_217_4: bit-extract s_217_2 s_217_0 s_217_3
        let s_217_4: Bits = (Bits::new(
            ((s_217_2) >> (s_217_0)).value(),
            u16::try_from(s_217_3).unwrap(),
        ));
        // D s_217_5: cast reint s_217_4 -> u8
        let s_217_5: bool = ((s_217_4.value()) != 0);
        // C s_217_6: const #0s : i
        let s_217_6: i128 = 0;
        // C s_217_7: const #0u : u64
        let s_217_7: u64 = 0;
        // D s_217_8: cast zx s_217_5 -> u64
        let s_217_8: u64 = (s_217_5 as u64);
        // C s_217_9: const #1u : u64
        let s_217_9: u64 = 1;
        // D s_217_10: and s_217_8 s_217_9
        let s_217_10: u64 = ((s_217_8) & (s_217_9));
        // D s_217_11: cmp-eq s_217_10 s_217_9
        let s_217_11: bool = ((s_217_10) == (s_217_9));
        // D s_217_12: lsl s_217_8 s_217_6
        let s_217_12: u64 = s_217_8 << s_217_6;
        // D s_217_13: or s_217_7 s_217_12
        let s_217_13: u64 = ((s_217_7) | (s_217_12));
        // D s_217_14: cmpl s_217_12
        let s_217_14: u64 = !s_217_12;
        // D s_217_15: and s_217_7 s_217_14
        let s_217_15: u64 = ((s_217_7) & (s_217_14));
        // D s_217_16: select s_217_11 s_217_13 s_217_15
        let s_217_16: u64 = if s_217_11 { s_217_13 } else { s_217_15 };
        // D s_217_17: cast trunc s_217_16 -> u8
        let s_217_17: bool = ((s_217_16) != 0);
        // D s_217_18: cast zx s_217_17 -> bv
        let s_217_18: Bits = Bits::new(s_217_17 as u128, 1u16);
        // C s_217_19: const #1u : u8
        let s_217_19: bool = true;
        // C s_217_20: cast zx s_217_19 -> bv
        let s_217_20: Bits = Bits::new(s_217_19 as u128, 1u16);
        // D s_217_21: cmp-ne s_217_18 s_217_20
        let s_217_21: bool = ((s_217_18) != (s_217_20));
        // D s_217_22: write-var gs#409507 <= s_217_21
        fn_state.gs_409507 = s_217_21;
        // N s_217_23: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_218_0: read-var gs#409507:u8
        let s_218_0: bool = fn_state.gs_409507;
        // N s_218_1: branch s_218_0 b232 b219
        if s_218_0 {
            return block_232(state, tracer, fn_state);
        } else {
            return block_219(state, tracer, fn_state);
        };
    }
    fn block_219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_219_0: const #8s : i
        let s_219_0: i128 = 8;
        // D s_219_1: read-var u#33482:u32
        let s_219_1: u32 = fn_state.u_33482;
        // D s_219_2: cast zx s_219_1 -> bv
        let s_219_2: Bits = Bits::new(s_219_1 as u128, 32u16);
        // C s_219_3: const #1u : u64
        let s_219_3: u64 = 1;
        // D s_219_4: bit-extract s_219_2 s_219_0 s_219_3
        let s_219_4: Bits = (Bits::new(
            ((s_219_2) >> (s_219_0)).value(),
            u16::try_from(s_219_3).unwrap(),
        ));
        // D s_219_5: cast reint s_219_4 -> u8
        let s_219_5: bool = ((s_219_4.value()) != 0);
        // C s_219_6: const #0s : i
        let s_219_6: i128 = 0;
        // C s_219_7: const #0u : u64
        let s_219_7: u64 = 0;
        // D s_219_8: cast zx s_219_5 -> u64
        let s_219_8: u64 = (s_219_5 as u64);
        // C s_219_9: const #1u : u64
        let s_219_9: u64 = 1;
        // D s_219_10: and s_219_8 s_219_9
        let s_219_10: u64 = ((s_219_8) & (s_219_9));
        // D s_219_11: cmp-eq s_219_10 s_219_9
        let s_219_11: bool = ((s_219_10) == (s_219_9));
        // D s_219_12: lsl s_219_8 s_219_6
        let s_219_12: u64 = s_219_8 << s_219_6;
        // D s_219_13: or s_219_7 s_219_12
        let s_219_13: u64 = ((s_219_7) | (s_219_12));
        // D s_219_14: cmpl s_219_12
        let s_219_14: u64 = !s_219_12;
        // D s_219_15: and s_219_7 s_219_14
        let s_219_15: u64 = ((s_219_7) & (s_219_14));
        // D s_219_16: select s_219_11 s_219_13 s_219_15
        let s_219_16: u64 = if s_219_11 { s_219_13 } else { s_219_15 };
        // D s_219_17: cast trunc s_219_16 -> u8
        let s_219_17: bool = ((s_219_16) != 0);
        // D s_219_18: cast zx s_219_17 -> bv
        let s_219_18: Bits = Bits::new(s_219_17 as u128, 1u16);
        // C s_219_19: const #1u : u8
        let s_219_19: bool = true;
        // C s_219_20: cast zx s_219_19 -> bv
        let s_219_20: Bits = Bits::new(s_219_19 as u128, 1u16);
        // D s_219_21: cmp-ne s_219_18 s_219_20
        let s_219_21: bool = ((s_219_18) != (s_219_20));
        // D s_219_22: write-var gs#409510 <= s_219_21
        fn_state.gs_409510 = s_219_21;
        // N s_219_23: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_220_0: read-var gs#409510:u8
        let s_220_0: bool = fn_state.gs_409510;
        // N s_220_1: branch s_220_0 b231 b221
        if s_220_0 {
            return block_231(state, tracer, fn_state);
        } else {
            return block_221(state, tracer, fn_state);
        };
    }
    fn block_221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_221_0: const #9s : i
        let s_221_0: i128 = 9;
        // D s_221_1: read-var u#33482:u32
        let s_221_1: u32 = fn_state.u_33482;
        // D s_221_2: cast zx s_221_1 -> bv
        let s_221_2: Bits = Bits::new(s_221_1 as u128, 32u16);
        // C s_221_3: const #1u : u64
        let s_221_3: u64 = 1;
        // D s_221_4: bit-extract s_221_2 s_221_0 s_221_3
        let s_221_4: Bits = (Bits::new(
            ((s_221_2) >> (s_221_0)).value(),
            u16::try_from(s_221_3).unwrap(),
        ));
        // D s_221_5: cast reint s_221_4 -> u8
        let s_221_5: bool = ((s_221_4.value()) != 0);
        // C s_221_6: const #0s : i
        let s_221_6: i128 = 0;
        // C s_221_7: const #0u : u64
        let s_221_7: u64 = 0;
        // D s_221_8: cast zx s_221_5 -> u64
        let s_221_8: u64 = (s_221_5 as u64);
        // C s_221_9: const #1u : u64
        let s_221_9: u64 = 1;
        // D s_221_10: and s_221_8 s_221_9
        let s_221_10: u64 = ((s_221_8) & (s_221_9));
        // D s_221_11: cmp-eq s_221_10 s_221_9
        let s_221_11: bool = ((s_221_10) == (s_221_9));
        // D s_221_12: lsl s_221_8 s_221_6
        let s_221_12: u64 = s_221_8 << s_221_6;
        // D s_221_13: or s_221_7 s_221_12
        let s_221_13: u64 = ((s_221_7) | (s_221_12));
        // D s_221_14: cmpl s_221_12
        let s_221_14: u64 = !s_221_12;
        // D s_221_15: and s_221_7 s_221_14
        let s_221_15: u64 = ((s_221_7) & (s_221_14));
        // D s_221_16: select s_221_11 s_221_13 s_221_15
        let s_221_16: u64 = if s_221_11 { s_221_13 } else { s_221_15 };
        // D s_221_17: cast trunc s_221_16 -> u8
        let s_221_17: bool = ((s_221_16) != 0);
        // D s_221_18: cast zx s_221_17 -> bv
        let s_221_18: Bits = Bits::new(s_221_17 as u128, 1u16);
        // C s_221_19: const #1u : u8
        let s_221_19: bool = true;
        // C s_221_20: cast zx s_221_19 -> bv
        let s_221_20: Bits = Bits::new(s_221_19 as u128, 1u16);
        // D s_221_21: cmp-ne s_221_18 s_221_20
        let s_221_21: bool = ((s_221_18) != (s_221_20));
        // D s_221_22: write-var gs#409513 <= s_221_21
        fn_state.gs_409513 = s_221_21;
        // N s_221_23: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_222_0: read-var gs#409513:u8
        let s_222_0: bool = fn_state.gs_409513;
        // N s_222_1: branch s_222_0 b230 b223
        if s_222_0 {
            return block_230(state, tracer, fn_state);
        } else {
            return block_223(state, tracer, fn_state);
        };
    }
    fn block_223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_223_0: const #10s : i
        let s_223_0: i128 = 10;
        // D s_223_1: read-var u#33482:u32
        let s_223_1: u32 = fn_state.u_33482;
        // D s_223_2: cast zx s_223_1 -> bv
        let s_223_2: Bits = Bits::new(s_223_1 as u128, 32u16);
        // C s_223_3: const #1u : u64
        let s_223_3: u64 = 1;
        // D s_223_4: bit-extract s_223_2 s_223_0 s_223_3
        let s_223_4: Bits = (Bits::new(
            ((s_223_2) >> (s_223_0)).value(),
            u16::try_from(s_223_3).unwrap(),
        ));
        // D s_223_5: cast reint s_223_4 -> u8
        let s_223_5: bool = ((s_223_4.value()) != 0);
        // C s_223_6: const #0s : i
        let s_223_6: i128 = 0;
        // C s_223_7: const #0u : u64
        let s_223_7: u64 = 0;
        // D s_223_8: cast zx s_223_5 -> u64
        let s_223_8: u64 = (s_223_5 as u64);
        // C s_223_9: const #1u : u64
        let s_223_9: u64 = 1;
        // D s_223_10: and s_223_8 s_223_9
        let s_223_10: u64 = ((s_223_8) & (s_223_9));
        // D s_223_11: cmp-eq s_223_10 s_223_9
        let s_223_11: bool = ((s_223_10) == (s_223_9));
        // D s_223_12: lsl s_223_8 s_223_6
        let s_223_12: u64 = s_223_8 << s_223_6;
        // D s_223_13: or s_223_7 s_223_12
        let s_223_13: u64 = ((s_223_7) | (s_223_12));
        // D s_223_14: cmpl s_223_12
        let s_223_14: u64 = !s_223_12;
        // D s_223_15: and s_223_7 s_223_14
        let s_223_15: u64 = ((s_223_7) & (s_223_14));
        // D s_223_16: select s_223_11 s_223_13 s_223_15
        let s_223_16: u64 = if s_223_11 { s_223_13 } else { s_223_15 };
        // D s_223_17: cast trunc s_223_16 -> u8
        let s_223_17: bool = ((s_223_16) != 0);
        // D s_223_18: cast zx s_223_17 -> bv
        let s_223_18: Bits = Bits::new(s_223_17 as u128, 1u16);
        // C s_223_19: const #1u : u8
        let s_223_19: bool = true;
        // C s_223_20: cast zx s_223_19 -> bv
        let s_223_20: Bits = Bits::new(s_223_19 as u128, 1u16);
        // D s_223_21: cmp-ne s_223_18 s_223_20
        let s_223_21: bool = ((s_223_18) != (s_223_20));
        // D s_223_22: write-var gs#409516 <= s_223_21
        fn_state.gs_409516 = s_223_21;
        // N s_223_23: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_224_0: read-var gs#409516:u8
        let s_224_0: bool = fn_state.gs_409516;
        // N s_224_1: branch s_224_0 b229 b225
        if s_224_0 {
            return block_229(state, tracer, fn_state);
        } else {
            return block_225(state, tracer, fn_state);
        };
    }
    fn block_225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_225_0: const #11s : i
        let s_225_0: i128 = 11;
        // D s_225_1: read-var u#33482:u32
        let s_225_1: u32 = fn_state.u_33482;
        // D s_225_2: cast zx s_225_1 -> bv
        let s_225_2: Bits = Bits::new(s_225_1 as u128, 32u16);
        // C s_225_3: const #1u : u64
        let s_225_3: u64 = 1;
        // D s_225_4: bit-extract s_225_2 s_225_0 s_225_3
        let s_225_4: Bits = (Bits::new(
            ((s_225_2) >> (s_225_0)).value(),
            u16::try_from(s_225_3).unwrap(),
        ));
        // D s_225_5: cast reint s_225_4 -> u8
        let s_225_5: bool = ((s_225_4.value()) != 0);
        // C s_225_6: const #0s : i
        let s_225_6: i128 = 0;
        // C s_225_7: const #0u : u64
        let s_225_7: u64 = 0;
        // D s_225_8: cast zx s_225_5 -> u64
        let s_225_8: u64 = (s_225_5 as u64);
        // C s_225_9: const #1u : u64
        let s_225_9: u64 = 1;
        // D s_225_10: and s_225_8 s_225_9
        let s_225_10: u64 = ((s_225_8) & (s_225_9));
        // D s_225_11: cmp-eq s_225_10 s_225_9
        let s_225_11: bool = ((s_225_10) == (s_225_9));
        // D s_225_12: lsl s_225_8 s_225_6
        let s_225_12: u64 = s_225_8 << s_225_6;
        // D s_225_13: or s_225_7 s_225_12
        let s_225_13: u64 = ((s_225_7) | (s_225_12));
        // D s_225_14: cmpl s_225_12
        let s_225_14: u64 = !s_225_12;
        // D s_225_15: and s_225_7 s_225_14
        let s_225_15: u64 = ((s_225_7) & (s_225_14));
        // D s_225_16: select s_225_11 s_225_13 s_225_15
        let s_225_16: u64 = if s_225_11 { s_225_13 } else { s_225_15 };
        // D s_225_17: cast trunc s_225_16 -> u8
        let s_225_17: bool = ((s_225_16) != 0);
        // D s_225_18: cast zx s_225_17 -> bv
        let s_225_18: Bits = Bits::new(s_225_17 as u128, 1u16);
        // C s_225_19: const #1u : u8
        let s_225_19: bool = true;
        // C s_225_20: cast zx s_225_19 -> bv
        let s_225_20: Bits = Bits::new(s_225_19 as u128, 1u16);
        // D s_225_21: cmp-ne s_225_18 s_225_20
        let s_225_21: bool = ((s_225_18) != (s_225_20));
        // D s_225_22: write-var gs#409519 <= s_225_21
        fn_state.gs_409519 = s_225_21;
        // N s_225_23: jump b226
        return block_226(state, tracer, fn_state);
    }
    fn block_226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_226_0: read-var gs#409519:u8
        let s_226_0: bool = fn_state.gs_409519;
        // N s_226_1: branch s_226_0 b228 b227
        if s_226_0 {
            return block_228(state, tracer, fn_state);
        } else {
            return block_227(state, tracer, fn_state);
        };
    }
    fn block_227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_227_0: read-var u#33483:u8
        let s_227_0: u8 = fn_state.u_33483;
        // D s_227_1: read-var u#33484:u8
        let s_227_1: u8 = fn_state.u_33484;
        // D s_227_2: read-var u#33485:u8
        let s_227_2: u8 = fn_state.u_33485;
        // D s_227_3: call decode_aarch32_instrs_REVSH_A1enc_A_txt(s_227_0, s_227_1, s_227_2)
        let s_227_3: () = decode_aarch32_instrs_REVSH_A1enc_A_txt(
            state,
            tracer,
            s_227_0,
            s_227_1,
            s_227_2,
        );
        // N s_227_4: return
        return;
    }
    fn block_228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_228_0: panic
        panic!("{:?}", ());
        // N s_228_1: return
        return;
    }
    fn block_229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_229_0: const #1u : u8
        let s_229_0: bool = true;
        // D s_229_1: write-var gs#409519 <= s_229_0
        fn_state.gs_409519 = s_229_0;
        // N s_229_2: jump b226
        return block_226(state, tracer, fn_state);
    }
    fn block_230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_230_0: const #1u : u8
        let s_230_0: bool = true;
        // D s_230_1: write-var gs#409516 <= s_230_0
        fn_state.gs_409516 = s_230_0;
        // N s_230_2: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_231_0: const #1u : u8
        let s_231_0: bool = true;
        // D s_231_1: write-var gs#409513 <= s_231_0
        fn_state.gs_409513 = s_231_0;
        // N s_231_2: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_232_0: const #1u : u8
        let s_232_0: bool = true;
        // D s_232_1: write-var gs#409510 <= s_232_0
        fn_state.gs_409510 = s_232_0;
        // N s_232_2: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_233_0: const #1u : u8
        let s_233_0: bool = true;
        // D s_233_1: write-var gs#409507 <= s_233_0
        fn_state.gs_409507 = s_233_0;
        // N s_233_2: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_234_0: const #1u : u8
        let s_234_0: bool = true;
        // D s_234_1: write-var gs#409504 <= s_234_0
        fn_state.gs_409504 = s_234_0;
        // N s_234_2: jump b216
        return block_216(state, tracer, fn_state);
    }
    fn block_235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_235_0: const #1u : u8
        let s_235_0: bool = true;
        // D s_235_1: write-var gs#409501 <= s_235_0
        fn_state.gs_409501 = s_235_0;
        // N s_235_2: jump b214
        return block_214(state, tracer, fn_state);
    }
    fn block_236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_236_0: read-var merge#var.1:struct
        let s_236_0: u32 = fn_state.merge_var._1;
        // D s_236_1: write-var u#33487 <= s_236_0
        fn_state.u_33487 = s_236_0;
        // C s_236_2: const #20s : i
        let s_236_2: i128 = 20;
        // D s_236_3: read-var u#33487:u32
        let s_236_3: u32 = fn_state.u_33487;
        // D s_236_4: cast zx s_236_3 -> bv
        let s_236_4: Bits = Bits::new(s_236_3 as u128, 32u16);
        // C s_236_5: const #1s : i64
        let s_236_5: i64 = 1;
        // C s_236_6: cast zx s_236_5 -> i
        let s_236_6: i128 = (i128::try_from(s_236_5).unwrap());
        // C s_236_7: const #7s : i
        let s_236_7: i128 = 7;
        // C s_236_8: add s_236_7 s_236_6
        let s_236_8: i128 = (s_236_7 + s_236_6);
        // D s_236_9: bit-extract s_236_4 s_236_2 s_236_8
        let s_236_9: Bits = (Bits::new(
            ((s_236_4) >> (s_236_2)).value(),
            u16::try_from(s_236_8).unwrap(),
        ));
        // D s_236_10: cast reint s_236_9 -> u8
        let s_236_10: u8 = (s_236_9.value() as u8);
        // D s_236_11: cast zx s_236_10 -> bv
        let s_236_11: Bits = Bits::new(s_236_10 as u128, 8u16);
        // C s_236_12: const #97u : u8
        let s_236_12: u8 = 97;
        // C s_236_13: cast zx s_236_12 -> bv
        let s_236_13: Bits = Bits::new(s_236_12 as u128, 8u16);
        // D s_236_14: cmp-eq s_236_11 s_236_13
        let s_236_14: bool = ((s_236_11) == (s_236_13));
        // N s_236_15: branch s_236_14 b1388 b237
        if s_236_14 {
            return block_1388(state, tracer, fn_state);
        } else {
            return block_237(state, tracer, fn_state);
        };
    }
    fn block_237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_237_0: const #0u : u8
        let s_237_0: bool = false;
        // D s_237_1: write-var gs#409525 <= s_237_0
        fn_state.gs_409525 = s_237_0;
        // N s_237_2: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_238_0: read-var gs#409525:u8
        let s_238_0: bool = fn_state.gs_409525;
        // N s_238_1: branch s_238_0 b1384 b239
        if s_238_0 {
            return block_1384(state, tracer, fn_state);
        } else {
            return block_239(state, tracer, fn_state);
        };
    }
    fn block_239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_239_0: const #0u : u8
        let s_239_0: bool = false;
        // D s_239_1: write-var gs#409530 <= s_239_0
        fn_state.gs_409530 = s_239_0;
        // N s_239_2: jump b240
        return block_240(state, tracer, fn_state);
    }
    fn block_240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_240_0: read-var gs#409530:u8
        let s_240_0: bool = fn_state.gs_409530;
        // D s_240_1: not s_240_0
        let s_240_1: bool = !s_240_0;
        // N s_240_2: branch s_240_1 b253 b241
        if s_240_1 {
            return block_253(state, tracer, fn_state);
        } else {
            return block_241(state, tracer, fn_state);
        };
    }
    fn block_241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_241_0: const #3105s : i
        let s_241_0: i128 = 3105;
        // C s_241_1: const #14696u : u32
        let s_241_1: u32 = 14696;
        // N s_241_2: write-reg s_241_1 <= s_241_0
        let s_241_2: () = {
            state.write_register::<i128>(s_241_1 as isize, s_241_0);
            tracer.write_register(s_241_1 as isize, s_241_0);
        };
        // C s_241_3: const #28s : i
        let s_241_3: i128 = 28;
        // C s_241_4: const #4s : i
        let s_241_4: i128 = 4;
        // D s_241_5: read-var u#33487:u32
        let s_241_5: u32 = fn_state.u_33487;
        // D s_241_6: cast zx s_241_5 -> bv
        let s_241_6: Bits = Bits::new(s_241_5 as u128, 32u16);
        // D s_241_7: bit-extract s_241_6 s_241_3 s_241_4
        let s_241_7: Bits = (Bits::new(
            ((s_241_6) >> (s_241_3)).value(),
            u16::try_from(s_241_4).unwrap(),
        ));
        // D s_241_8: cast reint s_241_7 -> u8
        let s_241_8: u8 = (s_241_7.value() as u8);
        // D s_241_9: write-var u#33488 <= s_241_8
        fn_state.u_33488 = s_241_8;
        // C s_241_10: const #16s : i
        let s_241_10: i128 = 16;
        // C s_241_11: const #4s : i
        let s_241_11: i128 = 4;
        // D s_241_12: read-var u#33487:u32
        let s_241_12: u32 = fn_state.u_33487;
        // D s_241_13: cast zx s_241_12 -> bv
        let s_241_13: Bits = Bits::new(s_241_12 as u128, 32u16);
        // D s_241_14: bit-extract s_241_13 s_241_10 s_241_11
        let s_241_14: Bits = (Bits::new(
            ((s_241_13) >> (s_241_10)).value(),
            u16::try_from(s_241_11).unwrap(),
        ));
        // D s_241_15: cast reint s_241_14 -> u8
        let s_241_15: u8 = (s_241_14.value() as u8);
        // D s_241_16: write-var u#33489 <= s_241_15
        fn_state.u_33489 = s_241_15;
        // C s_241_17: const #12s : i
        let s_241_17: i128 = 12;
        // C s_241_18: const #4s : i
        let s_241_18: i128 = 4;
        // D s_241_19: read-var u#33487:u32
        let s_241_19: u32 = fn_state.u_33487;
        // D s_241_20: cast zx s_241_19 -> bv
        let s_241_20: Bits = Bits::new(s_241_19 as u128, 32u16);
        // D s_241_21: bit-extract s_241_20 s_241_17 s_241_18
        let s_241_21: Bits = (Bits::new(
            ((s_241_20) >> (s_241_17)).value(),
            u16::try_from(s_241_18).unwrap(),
        ));
        // D s_241_22: cast reint s_241_21 -> u8
        let s_241_22: u8 = (s_241_21.value() as u8);
        // D s_241_23: write-var u#33490 <= s_241_22
        fn_state.u_33490 = s_241_22;
        // C s_241_24: const #0s : i
        let s_241_24: i128 = 0;
        // C s_241_25: const #4s : i
        let s_241_25: i128 = 4;
        // D s_241_26: read-var u#33487:u32
        let s_241_26: u32 = fn_state.u_33487;
        // D s_241_27: cast zx s_241_26 -> bv
        let s_241_27: Bits = Bits::new(s_241_26 as u128, 32u16);
        // D s_241_28: bit-extract s_241_27 s_241_24 s_241_25
        let s_241_28: Bits = (Bits::new(
            ((s_241_27) >> (s_241_24)).value(),
            u16::try_from(s_241_25).unwrap(),
        ));
        // D s_241_29: cast reint s_241_28 -> u8
        let s_241_29: u8 = (s_241_28.value() as u8);
        // D s_241_30: write-var u#33491 <= s_241_29
        fn_state.u_33491 = s_241_29;
        // C s_241_31: const #8s : i
        let s_241_31: i128 = 8;
        // D s_241_32: read-var u#33487:u32
        let s_241_32: u32 = fn_state.u_33487;
        // D s_241_33: cast zx s_241_32 -> bv
        let s_241_33: Bits = Bits::new(s_241_32 as u128, 32u16);
        // C s_241_34: const #1u : u64
        let s_241_34: u64 = 1;
        // D s_241_35: bit-extract s_241_33 s_241_31 s_241_34
        let s_241_35: Bits = (Bits::new(
            ((s_241_33) >> (s_241_31)).value(),
            u16::try_from(s_241_34).unwrap(),
        ));
        // D s_241_36: cast reint s_241_35 -> u8
        let s_241_36: bool = ((s_241_35.value()) != 0);
        // C s_241_37: const #0s : i
        let s_241_37: i128 = 0;
        // C s_241_38: const #0u : u64
        let s_241_38: u64 = 0;
        // D s_241_39: cast zx s_241_36 -> u64
        let s_241_39: u64 = (s_241_36 as u64);
        // C s_241_40: const #1u : u64
        let s_241_40: u64 = 1;
        // D s_241_41: and s_241_39 s_241_40
        let s_241_41: u64 = ((s_241_39) & (s_241_40));
        // D s_241_42: cmp-eq s_241_41 s_241_40
        let s_241_42: bool = ((s_241_41) == (s_241_40));
        // D s_241_43: lsl s_241_39 s_241_37
        let s_241_43: u64 = s_241_39 << s_241_37;
        // D s_241_44: or s_241_38 s_241_43
        let s_241_44: u64 = ((s_241_38) | (s_241_43));
        // D s_241_45: cmpl s_241_43
        let s_241_45: u64 = !s_241_43;
        // D s_241_46: and s_241_38 s_241_45
        let s_241_46: u64 = ((s_241_38) & (s_241_45));
        // D s_241_47: select s_241_42 s_241_44 s_241_46
        let s_241_47: u64 = if s_241_42 { s_241_44 } else { s_241_46 };
        // D s_241_48: cast trunc s_241_47 -> u8
        let s_241_48: bool = ((s_241_47) != 0);
        // D s_241_49: cast zx s_241_48 -> bv
        let s_241_49: Bits = Bits::new(s_241_48 as u128, 1u16);
        // C s_241_50: const #1u : u8
        let s_241_50: bool = true;
        // C s_241_51: cast zx s_241_50 -> bv
        let s_241_51: Bits = Bits::new(s_241_50 as u128, 1u16);
        // D s_241_52: cmp-ne s_241_49 s_241_51
        let s_241_52: bool = ((s_241_49) != (s_241_51));
        // N s_241_53: branch s_241_52 b252 b242
        if s_241_52 {
            return block_252(state, tracer, fn_state);
        } else {
            return block_242(state, tracer, fn_state);
        };
    }
    fn block_242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_242_0: const #9s : i
        let s_242_0: i128 = 9;
        // D s_242_1: read-var u#33487:u32
        let s_242_1: u32 = fn_state.u_33487;
        // D s_242_2: cast zx s_242_1 -> bv
        let s_242_2: Bits = Bits::new(s_242_1 as u128, 32u16);
        // C s_242_3: const #1u : u64
        let s_242_3: u64 = 1;
        // D s_242_4: bit-extract s_242_2 s_242_0 s_242_3
        let s_242_4: Bits = (Bits::new(
            ((s_242_2) >> (s_242_0)).value(),
            u16::try_from(s_242_3).unwrap(),
        ));
        // D s_242_5: cast reint s_242_4 -> u8
        let s_242_5: bool = ((s_242_4.value()) != 0);
        // C s_242_6: const #0s : i
        let s_242_6: i128 = 0;
        // C s_242_7: const #0u : u64
        let s_242_7: u64 = 0;
        // D s_242_8: cast zx s_242_5 -> u64
        let s_242_8: u64 = (s_242_5 as u64);
        // C s_242_9: const #1u : u64
        let s_242_9: u64 = 1;
        // D s_242_10: and s_242_8 s_242_9
        let s_242_10: u64 = ((s_242_8) & (s_242_9));
        // D s_242_11: cmp-eq s_242_10 s_242_9
        let s_242_11: bool = ((s_242_10) == (s_242_9));
        // D s_242_12: lsl s_242_8 s_242_6
        let s_242_12: u64 = s_242_8 << s_242_6;
        // D s_242_13: or s_242_7 s_242_12
        let s_242_13: u64 = ((s_242_7) | (s_242_12));
        // D s_242_14: cmpl s_242_12
        let s_242_14: u64 = !s_242_12;
        // D s_242_15: and s_242_7 s_242_14
        let s_242_15: u64 = ((s_242_7) & (s_242_14));
        // D s_242_16: select s_242_11 s_242_13 s_242_15
        let s_242_16: u64 = if s_242_11 { s_242_13 } else { s_242_15 };
        // D s_242_17: cast trunc s_242_16 -> u8
        let s_242_17: bool = ((s_242_16) != 0);
        // D s_242_18: cast zx s_242_17 -> bv
        let s_242_18: Bits = Bits::new(s_242_17 as u128, 1u16);
        // C s_242_19: const #1u : u8
        let s_242_19: bool = true;
        // C s_242_20: cast zx s_242_19 -> bv
        let s_242_20: Bits = Bits::new(s_242_19 as u128, 1u16);
        // D s_242_21: cmp-ne s_242_18 s_242_20
        let s_242_21: bool = ((s_242_18) != (s_242_20));
        // D s_242_22: write-var gs#409545 <= s_242_21
        fn_state.gs_409545 = s_242_21;
        // N s_242_23: jump b243
        return block_243(state, tracer, fn_state);
    }
    fn block_243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_243_0: read-var gs#409545:u8
        let s_243_0: bool = fn_state.gs_409545;
        // N s_243_1: branch s_243_0 b251 b244
        if s_243_0 {
            return block_251(state, tracer, fn_state);
        } else {
            return block_244(state, tracer, fn_state);
        };
    }
    fn block_244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_244_0: const #10s : i
        let s_244_0: i128 = 10;
        // D s_244_1: read-var u#33487:u32
        let s_244_1: u32 = fn_state.u_33487;
        // D s_244_2: cast zx s_244_1 -> bv
        let s_244_2: Bits = Bits::new(s_244_1 as u128, 32u16);
        // C s_244_3: const #1u : u64
        let s_244_3: u64 = 1;
        // D s_244_4: bit-extract s_244_2 s_244_0 s_244_3
        let s_244_4: Bits = (Bits::new(
            ((s_244_2) >> (s_244_0)).value(),
            u16::try_from(s_244_3).unwrap(),
        ));
        // D s_244_5: cast reint s_244_4 -> u8
        let s_244_5: bool = ((s_244_4.value()) != 0);
        // C s_244_6: const #0s : i
        let s_244_6: i128 = 0;
        // C s_244_7: const #0u : u64
        let s_244_7: u64 = 0;
        // D s_244_8: cast zx s_244_5 -> u64
        let s_244_8: u64 = (s_244_5 as u64);
        // C s_244_9: const #1u : u64
        let s_244_9: u64 = 1;
        // D s_244_10: and s_244_8 s_244_9
        let s_244_10: u64 = ((s_244_8) & (s_244_9));
        // D s_244_11: cmp-eq s_244_10 s_244_9
        let s_244_11: bool = ((s_244_10) == (s_244_9));
        // D s_244_12: lsl s_244_8 s_244_6
        let s_244_12: u64 = s_244_8 << s_244_6;
        // D s_244_13: or s_244_7 s_244_12
        let s_244_13: u64 = ((s_244_7) | (s_244_12));
        // D s_244_14: cmpl s_244_12
        let s_244_14: u64 = !s_244_12;
        // D s_244_15: and s_244_7 s_244_14
        let s_244_15: u64 = ((s_244_7) & (s_244_14));
        // D s_244_16: select s_244_11 s_244_13 s_244_15
        let s_244_16: u64 = if s_244_11 { s_244_13 } else { s_244_15 };
        // D s_244_17: cast trunc s_244_16 -> u8
        let s_244_17: bool = ((s_244_16) != 0);
        // D s_244_18: cast zx s_244_17 -> bv
        let s_244_18: Bits = Bits::new(s_244_17 as u128, 1u16);
        // C s_244_19: const #1u : u8
        let s_244_19: bool = true;
        // C s_244_20: cast zx s_244_19 -> bv
        let s_244_20: Bits = Bits::new(s_244_19 as u128, 1u16);
        // D s_244_21: cmp-ne s_244_18 s_244_20
        let s_244_21: bool = ((s_244_18) != (s_244_20));
        // D s_244_22: write-var gs#409548 <= s_244_21
        fn_state.gs_409548 = s_244_21;
        // N s_244_23: jump b245
        return block_245(state, tracer, fn_state);
    }
    fn block_245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_245_0: read-var gs#409548:u8
        let s_245_0: bool = fn_state.gs_409548;
        // N s_245_1: branch s_245_0 b250 b246
        if s_245_0 {
            return block_250(state, tracer, fn_state);
        } else {
            return block_246(state, tracer, fn_state);
        };
    }
    fn block_246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_246_0: const #11s : i
        let s_246_0: i128 = 11;
        // D s_246_1: read-var u#33487:u32
        let s_246_1: u32 = fn_state.u_33487;
        // D s_246_2: cast zx s_246_1 -> bv
        let s_246_2: Bits = Bits::new(s_246_1 as u128, 32u16);
        // C s_246_3: const #1u : u64
        let s_246_3: u64 = 1;
        // D s_246_4: bit-extract s_246_2 s_246_0 s_246_3
        let s_246_4: Bits = (Bits::new(
            ((s_246_2) >> (s_246_0)).value(),
            u16::try_from(s_246_3).unwrap(),
        ));
        // D s_246_5: cast reint s_246_4 -> u8
        let s_246_5: bool = ((s_246_4.value()) != 0);
        // C s_246_6: const #0s : i
        let s_246_6: i128 = 0;
        // C s_246_7: const #0u : u64
        let s_246_7: u64 = 0;
        // D s_246_8: cast zx s_246_5 -> u64
        let s_246_8: u64 = (s_246_5 as u64);
        // C s_246_9: const #1u : u64
        let s_246_9: u64 = 1;
        // D s_246_10: and s_246_8 s_246_9
        let s_246_10: u64 = ((s_246_8) & (s_246_9));
        // D s_246_11: cmp-eq s_246_10 s_246_9
        let s_246_11: bool = ((s_246_10) == (s_246_9));
        // D s_246_12: lsl s_246_8 s_246_6
        let s_246_12: u64 = s_246_8 << s_246_6;
        // D s_246_13: or s_246_7 s_246_12
        let s_246_13: u64 = ((s_246_7) | (s_246_12));
        // D s_246_14: cmpl s_246_12
        let s_246_14: u64 = !s_246_12;
        // D s_246_15: and s_246_7 s_246_14
        let s_246_15: u64 = ((s_246_7) & (s_246_14));
        // D s_246_16: select s_246_11 s_246_13 s_246_15
        let s_246_16: u64 = if s_246_11 { s_246_13 } else { s_246_15 };
        // D s_246_17: cast trunc s_246_16 -> u8
        let s_246_17: bool = ((s_246_16) != 0);
        // D s_246_18: cast zx s_246_17 -> bv
        let s_246_18: Bits = Bits::new(s_246_17 as u128, 1u16);
        // C s_246_19: const #1u : u8
        let s_246_19: bool = true;
        // C s_246_20: cast zx s_246_19 -> bv
        let s_246_20: Bits = Bits::new(s_246_19 as u128, 1u16);
        // D s_246_21: cmp-ne s_246_18 s_246_20
        let s_246_21: bool = ((s_246_18) != (s_246_20));
        // D s_246_22: write-var gs#409551 <= s_246_21
        fn_state.gs_409551 = s_246_21;
        // N s_246_23: jump b247
        return block_247(state, tracer, fn_state);
    }
    fn block_247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_247_0: read-var gs#409551:u8
        let s_247_0: bool = fn_state.gs_409551;
        // N s_247_1: branch s_247_0 b249 b248
        if s_247_0 {
            return block_249(state, tracer, fn_state);
        } else {
            return block_248(state, tracer, fn_state);
        };
    }
    fn block_248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_248_0: read-var u#33488:u8
        let s_248_0: u8 = fn_state.u_33488;
        // D s_248_1: read-var u#33489:u8
        let s_248_1: u8 = fn_state.u_33489;
        // D s_248_2: read-var u#33490:u8
        let s_248_2: u8 = fn_state.u_33490;
        // D s_248_3: read-var u#33491:u8
        let s_248_3: u8 = fn_state.u_33491;
        // D s_248_4: call decode_aarch32_instrs_SADD16_A1enc_A_txt(s_248_0, s_248_1, s_248_2, s_248_3)
        let s_248_4: () = decode_aarch32_instrs_SADD16_A1enc_A_txt(
            state,
            tracer,
            s_248_0,
            s_248_1,
            s_248_2,
            s_248_3,
        );
        // N s_248_5: return
        return;
    }
    fn block_249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_249_0: panic
        panic!("{:?}", ());
        // N s_249_1: return
        return;
    }
    fn block_250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_250_0: const #1u : u8
        let s_250_0: bool = true;
        // D s_250_1: write-var gs#409551 <= s_250_0
        fn_state.gs_409551 = s_250_0;
        // N s_250_2: jump b247
        return block_247(state, tracer, fn_state);
    }
    fn block_251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_251_0: const #1u : u8
        let s_251_0: bool = true;
        // D s_251_1: write-var gs#409548 <= s_251_0
        fn_state.gs_409548 = s_251_0;
        // N s_251_2: jump b245
        return block_245(state, tracer, fn_state);
    }
    fn block_252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_252_0: const #1u : u8
        let s_252_0: bool = true;
        // D s_252_1: write-var gs#409545 <= s_252_0
        fn_state.gs_409545 = s_252_0;
        // N s_252_2: jump b243
        return block_243(state, tracer, fn_state);
    }
    fn block_253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_253_0: read-var merge#var.1:struct
        let s_253_0: u32 = fn_state.merge_var._1;
        // D s_253_1: write-var u#33493 <= s_253_0
        fn_state.u_33493 = s_253_0;
        // C s_253_2: const #20s : i
        let s_253_2: i128 = 20;
        // D s_253_3: read-var u#33493:u32
        let s_253_3: u32 = fn_state.u_33493;
        // D s_253_4: cast zx s_253_3 -> bv
        let s_253_4: Bits = Bits::new(s_253_3 as u128, 32u16);
        // C s_253_5: const #1s : i64
        let s_253_5: i64 = 1;
        // C s_253_6: cast zx s_253_5 -> i
        let s_253_6: i128 = (i128::try_from(s_253_5).unwrap());
        // C s_253_7: const #7s : i
        let s_253_7: i128 = 7;
        // C s_253_8: add s_253_7 s_253_6
        let s_253_8: i128 = (s_253_7 + s_253_6);
        // D s_253_9: bit-extract s_253_4 s_253_2 s_253_8
        let s_253_9: Bits = (Bits::new(
            ((s_253_4) >> (s_253_2)).value(),
            u16::try_from(s_253_8).unwrap(),
        ));
        // D s_253_10: cast reint s_253_9 -> u8
        let s_253_10: u8 = (s_253_9.value() as u8);
        // D s_253_11: cast zx s_253_10 -> bv
        let s_253_11: Bits = Bits::new(s_253_10 as u128, 8u16);
        // C s_253_12: const #97u : u8
        let s_253_12: u8 = 97;
        // C s_253_13: cast zx s_253_12 -> bv
        let s_253_13: Bits = Bits::new(s_253_12 as u128, 8u16);
        // D s_253_14: cmp-eq s_253_11 s_253_13
        let s_253_14: bool = ((s_253_11) == (s_253_13));
        // N s_253_15: branch s_253_14 b1383 b254
        if s_253_14 {
            return block_1383(state, tracer, fn_state);
        } else {
            return block_254(state, tracer, fn_state);
        };
    }
    fn block_254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_254_0: const #0u : u8
        let s_254_0: bool = false;
        // D s_254_1: write-var gs#409557 <= s_254_0
        fn_state.gs_409557 = s_254_0;
        // N s_254_2: jump b255
        return block_255(state, tracer, fn_state);
    }
    fn block_255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_255_0: read-var gs#409557:u8
        let s_255_0: bool = fn_state.gs_409557;
        // N s_255_1: branch s_255_0 b1379 b256
        if s_255_0 {
            return block_1379(state, tracer, fn_state);
        } else {
            return block_256(state, tracer, fn_state);
        };
    }
    fn block_256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_256_0: const #0u : u8
        let s_256_0: bool = false;
        // D s_256_1: write-var gs#409562 <= s_256_0
        fn_state.gs_409562 = s_256_0;
        // N s_256_2: jump b257
        return block_257(state, tracer, fn_state);
    }
    fn block_257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_257_0: read-var gs#409562:u8
        let s_257_0: bool = fn_state.gs_409562;
        // D s_257_1: not s_257_0
        let s_257_1: bool = !s_257_0;
        // N s_257_2: branch s_257_1 b270 b258
        if s_257_1 {
            return block_270(state, tracer, fn_state);
        } else {
            return block_258(state, tracer, fn_state);
        };
    }
    fn block_258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_258_0: const #3107s : i
        let s_258_0: i128 = 3107;
        // C s_258_1: const #14696u : u32
        let s_258_1: u32 = 14696;
        // N s_258_2: write-reg s_258_1 <= s_258_0
        let s_258_2: () = {
            state.write_register::<i128>(s_258_1 as isize, s_258_0);
            tracer.write_register(s_258_1 as isize, s_258_0);
        };
        // C s_258_3: const #28s : i
        let s_258_3: i128 = 28;
        // C s_258_4: const #4s : i
        let s_258_4: i128 = 4;
        // D s_258_5: read-var u#33493:u32
        let s_258_5: u32 = fn_state.u_33493;
        // D s_258_6: cast zx s_258_5 -> bv
        let s_258_6: Bits = Bits::new(s_258_5 as u128, 32u16);
        // D s_258_7: bit-extract s_258_6 s_258_3 s_258_4
        let s_258_7: Bits = (Bits::new(
            ((s_258_6) >> (s_258_3)).value(),
            u16::try_from(s_258_4).unwrap(),
        ));
        // D s_258_8: cast reint s_258_7 -> u8
        let s_258_8: u8 = (s_258_7.value() as u8);
        // D s_258_9: write-var u#33494 <= s_258_8
        fn_state.u_33494 = s_258_8;
        // C s_258_10: const #16s : i
        let s_258_10: i128 = 16;
        // C s_258_11: const #4s : i
        let s_258_11: i128 = 4;
        // D s_258_12: read-var u#33493:u32
        let s_258_12: u32 = fn_state.u_33493;
        // D s_258_13: cast zx s_258_12 -> bv
        let s_258_13: Bits = Bits::new(s_258_12 as u128, 32u16);
        // D s_258_14: bit-extract s_258_13 s_258_10 s_258_11
        let s_258_14: Bits = (Bits::new(
            ((s_258_13) >> (s_258_10)).value(),
            u16::try_from(s_258_11).unwrap(),
        ));
        // D s_258_15: cast reint s_258_14 -> u8
        let s_258_15: u8 = (s_258_14.value() as u8);
        // D s_258_16: write-var u#33495 <= s_258_15
        fn_state.u_33495 = s_258_15;
        // C s_258_17: const #12s : i
        let s_258_17: i128 = 12;
        // C s_258_18: const #4s : i
        let s_258_18: i128 = 4;
        // D s_258_19: read-var u#33493:u32
        let s_258_19: u32 = fn_state.u_33493;
        // D s_258_20: cast zx s_258_19 -> bv
        let s_258_20: Bits = Bits::new(s_258_19 as u128, 32u16);
        // D s_258_21: bit-extract s_258_20 s_258_17 s_258_18
        let s_258_21: Bits = (Bits::new(
            ((s_258_20) >> (s_258_17)).value(),
            u16::try_from(s_258_18).unwrap(),
        ));
        // D s_258_22: cast reint s_258_21 -> u8
        let s_258_22: u8 = (s_258_21.value() as u8);
        // D s_258_23: write-var u#33496 <= s_258_22
        fn_state.u_33496 = s_258_22;
        // C s_258_24: const #0s : i
        let s_258_24: i128 = 0;
        // C s_258_25: const #4s : i
        let s_258_25: i128 = 4;
        // D s_258_26: read-var u#33493:u32
        let s_258_26: u32 = fn_state.u_33493;
        // D s_258_27: cast zx s_258_26 -> bv
        let s_258_27: Bits = Bits::new(s_258_26 as u128, 32u16);
        // D s_258_28: bit-extract s_258_27 s_258_24 s_258_25
        let s_258_28: Bits = (Bits::new(
            ((s_258_27) >> (s_258_24)).value(),
            u16::try_from(s_258_25).unwrap(),
        ));
        // D s_258_29: cast reint s_258_28 -> u8
        let s_258_29: u8 = (s_258_28.value() as u8);
        // D s_258_30: write-var u#33497 <= s_258_29
        fn_state.u_33497 = s_258_29;
        // C s_258_31: const #8s : i
        let s_258_31: i128 = 8;
        // D s_258_32: read-var u#33493:u32
        let s_258_32: u32 = fn_state.u_33493;
        // D s_258_33: cast zx s_258_32 -> bv
        let s_258_33: Bits = Bits::new(s_258_32 as u128, 32u16);
        // C s_258_34: const #1u : u64
        let s_258_34: u64 = 1;
        // D s_258_35: bit-extract s_258_33 s_258_31 s_258_34
        let s_258_35: Bits = (Bits::new(
            ((s_258_33) >> (s_258_31)).value(),
            u16::try_from(s_258_34).unwrap(),
        ));
        // D s_258_36: cast reint s_258_35 -> u8
        let s_258_36: bool = ((s_258_35.value()) != 0);
        // C s_258_37: const #0s : i
        let s_258_37: i128 = 0;
        // C s_258_38: const #0u : u64
        let s_258_38: u64 = 0;
        // D s_258_39: cast zx s_258_36 -> u64
        let s_258_39: u64 = (s_258_36 as u64);
        // C s_258_40: const #1u : u64
        let s_258_40: u64 = 1;
        // D s_258_41: and s_258_39 s_258_40
        let s_258_41: u64 = ((s_258_39) & (s_258_40));
        // D s_258_42: cmp-eq s_258_41 s_258_40
        let s_258_42: bool = ((s_258_41) == (s_258_40));
        // D s_258_43: lsl s_258_39 s_258_37
        let s_258_43: u64 = s_258_39 << s_258_37;
        // D s_258_44: or s_258_38 s_258_43
        let s_258_44: u64 = ((s_258_38) | (s_258_43));
        // D s_258_45: cmpl s_258_43
        let s_258_45: u64 = !s_258_43;
        // D s_258_46: and s_258_38 s_258_45
        let s_258_46: u64 = ((s_258_38) & (s_258_45));
        // D s_258_47: select s_258_42 s_258_44 s_258_46
        let s_258_47: u64 = if s_258_42 { s_258_44 } else { s_258_46 };
        // D s_258_48: cast trunc s_258_47 -> u8
        let s_258_48: bool = ((s_258_47) != 0);
        // D s_258_49: cast zx s_258_48 -> bv
        let s_258_49: Bits = Bits::new(s_258_48 as u128, 1u16);
        // C s_258_50: const #1u : u8
        let s_258_50: bool = true;
        // C s_258_51: cast zx s_258_50 -> bv
        let s_258_51: Bits = Bits::new(s_258_50 as u128, 1u16);
        // D s_258_52: cmp-ne s_258_49 s_258_51
        let s_258_52: bool = ((s_258_49) != (s_258_51));
        // N s_258_53: branch s_258_52 b269 b259
        if s_258_52 {
            return block_269(state, tracer, fn_state);
        } else {
            return block_259(state, tracer, fn_state);
        };
    }
    fn block_259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_259_0: const #9s : i
        let s_259_0: i128 = 9;
        // D s_259_1: read-var u#33493:u32
        let s_259_1: u32 = fn_state.u_33493;
        // D s_259_2: cast zx s_259_1 -> bv
        let s_259_2: Bits = Bits::new(s_259_1 as u128, 32u16);
        // C s_259_3: const #1u : u64
        let s_259_3: u64 = 1;
        // D s_259_4: bit-extract s_259_2 s_259_0 s_259_3
        let s_259_4: Bits = (Bits::new(
            ((s_259_2) >> (s_259_0)).value(),
            u16::try_from(s_259_3).unwrap(),
        ));
        // D s_259_5: cast reint s_259_4 -> u8
        let s_259_5: bool = ((s_259_4.value()) != 0);
        // C s_259_6: const #0s : i
        let s_259_6: i128 = 0;
        // C s_259_7: const #0u : u64
        let s_259_7: u64 = 0;
        // D s_259_8: cast zx s_259_5 -> u64
        let s_259_8: u64 = (s_259_5 as u64);
        // C s_259_9: const #1u : u64
        let s_259_9: u64 = 1;
        // D s_259_10: and s_259_8 s_259_9
        let s_259_10: u64 = ((s_259_8) & (s_259_9));
        // D s_259_11: cmp-eq s_259_10 s_259_9
        let s_259_11: bool = ((s_259_10) == (s_259_9));
        // D s_259_12: lsl s_259_8 s_259_6
        let s_259_12: u64 = s_259_8 << s_259_6;
        // D s_259_13: or s_259_7 s_259_12
        let s_259_13: u64 = ((s_259_7) | (s_259_12));
        // D s_259_14: cmpl s_259_12
        let s_259_14: u64 = !s_259_12;
        // D s_259_15: and s_259_7 s_259_14
        let s_259_15: u64 = ((s_259_7) & (s_259_14));
        // D s_259_16: select s_259_11 s_259_13 s_259_15
        let s_259_16: u64 = if s_259_11 { s_259_13 } else { s_259_15 };
        // D s_259_17: cast trunc s_259_16 -> u8
        let s_259_17: bool = ((s_259_16) != 0);
        // D s_259_18: cast zx s_259_17 -> bv
        let s_259_18: Bits = Bits::new(s_259_17 as u128, 1u16);
        // C s_259_19: const #1u : u8
        let s_259_19: bool = true;
        // C s_259_20: cast zx s_259_19 -> bv
        let s_259_20: Bits = Bits::new(s_259_19 as u128, 1u16);
        // D s_259_21: cmp-ne s_259_18 s_259_20
        let s_259_21: bool = ((s_259_18) != (s_259_20));
        // D s_259_22: write-var gs#409577 <= s_259_21
        fn_state.gs_409577 = s_259_21;
        // N s_259_23: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_260_0: read-var gs#409577:u8
        let s_260_0: bool = fn_state.gs_409577;
        // N s_260_1: branch s_260_0 b268 b261
        if s_260_0 {
            return block_268(state, tracer, fn_state);
        } else {
            return block_261(state, tracer, fn_state);
        };
    }
    fn block_261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_261_0: const #10s : i
        let s_261_0: i128 = 10;
        // D s_261_1: read-var u#33493:u32
        let s_261_1: u32 = fn_state.u_33493;
        // D s_261_2: cast zx s_261_1 -> bv
        let s_261_2: Bits = Bits::new(s_261_1 as u128, 32u16);
        // C s_261_3: const #1u : u64
        let s_261_3: u64 = 1;
        // D s_261_4: bit-extract s_261_2 s_261_0 s_261_3
        let s_261_4: Bits = (Bits::new(
            ((s_261_2) >> (s_261_0)).value(),
            u16::try_from(s_261_3).unwrap(),
        ));
        // D s_261_5: cast reint s_261_4 -> u8
        let s_261_5: bool = ((s_261_4.value()) != 0);
        // C s_261_6: const #0s : i
        let s_261_6: i128 = 0;
        // C s_261_7: const #0u : u64
        let s_261_7: u64 = 0;
        // D s_261_8: cast zx s_261_5 -> u64
        let s_261_8: u64 = (s_261_5 as u64);
        // C s_261_9: const #1u : u64
        let s_261_9: u64 = 1;
        // D s_261_10: and s_261_8 s_261_9
        let s_261_10: u64 = ((s_261_8) & (s_261_9));
        // D s_261_11: cmp-eq s_261_10 s_261_9
        let s_261_11: bool = ((s_261_10) == (s_261_9));
        // D s_261_12: lsl s_261_8 s_261_6
        let s_261_12: u64 = s_261_8 << s_261_6;
        // D s_261_13: or s_261_7 s_261_12
        let s_261_13: u64 = ((s_261_7) | (s_261_12));
        // D s_261_14: cmpl s_261_12
        let s_261_14: u64 = !s_261_12;
        // D s_261_15: and s_261_7 s_261_14
        let s_261_15: u64 = ((s_261_7) & (s_261_14));
        // D s_261_16: select s_261_11 s_261_13 s_261_15
        let s_261_16: u64 = if s_261_11 { s_261_13 } else { s_261_15 };
        // D s_261_17: cast trunc s_261_16 -> u8
        let s_261_17: bool = ((s_261_16) != 0);
        // D s_261_18: cast zx s_261_17 -> bv
        let s_261_18: Bits = Bits::new(s_261_17 as u128, 1u16);
        // C s_261_19: const #1u : u8
        let s_261_19: bool = true;
        // C s_261_20: cast zx s_261_19 -> bv
        let s_261_20: Bits = Bits::new(s_261_19 as u128, 1u16);
        // D s_261_21: cmp-ne s_261_18 s_261_20
        let s_261_21: bool = ((s_261_18) != (s_261_20));
        // D s_261_22: write-var gs#409580 <= s_261_21
        fn_state.gs_409580 = s_261_21;
        // N s_261_23: jump b262
        return block_262(state, tracer, fn_state);
    }
    fn block_262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_262_0: read-var gs#409580:u8
        let s_262_0: bool = fn_state.gs_409580;
        // N s_262_1: branch s_262_0 b267 b263
        if s_262_0 {
            return block_267(state, tracer, fn_state);
        } else {
            return block_263(state, tracer, fn_state);
        };
    }
    fn block_263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_263_0: const #11s : i
        let s_263_0: i128 = 11;
        // D s_263_1: read-var u#33493:u32
        let s_263_1: u32 = fn_state.u_33493;
        // D s_263_2: cast zx s_263_1 -> bv
        let s_263_2: Bits = Bits::new(s_263_1 as u128, 32u16);
        // C s_263_3: const #1u : u64
        let s_263_3: u64 = 1;
        // D s_263_4: bit-extract s_263_2 s_263_0 s_263_3
        let s_263_4: Bits = (Bits::new(
            ((s_263_2) >> (s_263_0)).value(),
            u16::try_from(s_263_3).unwrap(),
        ));
        // D s_263_5: cast reint s_263_4 -> u8
        let s_263_5: bool = ((s_263_4.value()) != 0);
        // C s_263_6: const #0s : i
        let s_263_6: i128 = 0;
        // C s_263_7: const #0u : u64
        let s_263_7: u64 = 0;
        // D s_263_8: cast zx s_263_5 -> u64
        let s_263_8: u64 = (s_263_5 as u64);
        // C s_263_9: const #1u : u64
        let s_263_9: u64 = 1;
        // D s_263_10: and s_263_8 s_263_9
        let s_263_10: u64 = ((s_263_8) & (s_263_9));
        // D s_263_11: cmp-eq s_263_10 s_263_9
        let s_263_11: bool = ((s_263_10) == (s_263_9));
        // D s_263_12: lsl s_263_8 s_263_6
        let s_263_12: u64 = s_263_8 << s_263_6;
        // D s_263_13: or s_263_7 s_263_12
        let s_263_13: u64 = ((s_263_7) | (s_263_12));
        // D s_263_14: cmpl s_263_12
        let s_263_14: u64 = !s_263_12;
        // D s_263_15: and s_263_7 s_263_14
        let s_263_15: u64 = ((s_263_7) & (s_263_14));
        // D s_263_16: select s_263_11 s_263_13 s_263_15
        let s_263_16: u64 = if s_263_11 { s_263_13 } else { s_263_15 };
        // D s_263_17: cast trunc s_263_16 -> u8
        let s_263_17: bool = ((s_263_16) != 0);
        // D s_263_18: cast zx s_263_17 -> bv
        let s_263_18: Bits = Bits::new(s_263_17 as u128, 1u16);
        // C s_263_19: const #1u : u8
        let s_263_19: bool = true;
        // C s_263_20: cast zx s_263_19 -> bv
        let s_263_20: Bits = Bits::new(s_263_19 as u128, 1u16);
        // D s_263_21: cmp-ne s_263_18 s_263_20
        let s_263_21: bool = ((s_263_18) != (s_263_20));
        // D s_263_22: write-var gs#409583 <= s_263_21
        fn_state.gs_409583 = s_263_21;
        // N s_263_23: jump b264
        return block_264(state, tracer, fn_state);
    }
    fn block_264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_264_0: read-var gs#409583:u8
        let s_264_0: bool = fn_state.gs_409583;
        // N s_264_1: branch s_264_0 b266 b265
        if s_264_0 {
            return block_266(state, tracer, fn_state);
        } else {
            return block_265(state, tracer, fn_state);
        };
    }
    fn block_265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_265_0: read-var u#33494:u8
        let s_265_0: u8 = fn_state.u_33494;
        // D s_265_1: read-var u#33495:u8
        let s_265_1: u8 = fn_state.u_33495;
        // D s_265_2: read-var u#33496:u8
        let s_265_2: u8 = fn_state.u_33496;
        // D s_265_3: read-var u#33497:u8
        let s_265_3: u8 = fn_state.u_33497;
        // D s_265_4: call decode_aarch32_instrs_SADD8_A1enc_A_txt(s_265_0, s_265_1, s_265_2, s_265_3)
        let s_265_4: () = decode_aarch32_instrs_SADD8_A1enc_A_txt(
            state,
            tracer,
            s_265_0,
            s_265_1,
            s_265_2,
            s_265_3,
        );
        // N s_265_5: return
        return;
    }
    fn block_266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_266_0: panic
        panic!("{:?}", ());
        // N s_266_1: return
        return;
    }
    fn block_267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_267_0: const #1u : u8
        let s_267_0: bool = true;
        // D s_267_1: write-var gs#409583 <= s_267_0
        fn_state.gs_409583 = s_267_0;
        // N s_267_2: jump b264
        return block_264(state, tracer, fn_state);
    }
    fn block_268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_268_0: const #1u : u8
        let s_268_0: bool = true;
        // D s_268_1: write-var gs#409580 <= s_268_0
        fn_state.gs_409580 = s_268_0;
        // N s_268_2: jump b262
        return block_262(state, tracer, fn_state);
    }
    fn block_269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_269_0: const #1u : u8
        let s_269_0: bool = true;
        // D s_269_1: write-var gs#409577 <= s_269_0
        fn_state.gs_409577 = s_269_0;
        // N s_269_2: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_270_0: read-var merge#var.1:struct
        let s_270_0: u32 = fn_state.merge_var._1;
        // D s_270_1: write-var u#33499 <= s_270_0
        fn_state.u_33499 = s_270_0;
        // C s_270_2: const #20s : i
        let s_270_2: i128 = 20;
        // D s_270_3: read-var u#33499:u32
        let s_270_3: u32 = fn_state.u_33499;
        // D s_270_4: cast zx s_270_3 -> bv
        let s_270_4: Bits = Bits::new(s_270_3 as u128, 32u16);
        // C s_270_5: const #1s : i64
        let s_270_5: i64 = 1;
        // C s_270_6: cast zx s_270_5 -> i
        let s_270_6: i128 = (i128::try_from(s_270_5).unwrap());
        // C s_270_7: const #7s : i
        let s_270_7: i128 = 7;
        // C s_270_8: add s_270_7 s_270_6
        let s_270_8: i128 = (s_270_7 + s_270_6);
        // D s_270_9: bit-extract s_270_4 s_270_2 s_270_8
        let s_270_9: Bits = (Bits::new(
            ((s_270_4) >> (s_270_2)).value(),
            u16::try_from(s_270_8).unwrap(),
        ));
        // D s_270_10: cast reint s_270_9 -> u8
        let s_270_10: u8 = (s_270_9.value() as u8);
        // D s_270_11: cast zx s_270_10 -> bv
        let s_270_11: Bits = Bits::new(s_270_10 as u128, 8u16);
        // C s_270_12: const #97u : u8
        let s_270_12: u8 = 97;
        // C s_270_13: cast zx s_270_12 -> bv
        let s_270_13: Bits = Bits::new(s_270_12 as u128, 8u16);
        // D s_270_14: cmp-eq s_270_11 s_270_13
        let s_270_14: bool = ((s_270_11) == (s_270_13));
        // N s_270_15: branch s_270_14 b1378 b271
        if s_270_14 {
            return block_1378(state, tracer, fn_state);
        } else {
            return block_271(state, tracer, fn_state);
        };
    }
    fn block_271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_271_0: const #0u : u8
        let s_271_0: bool = false;
        // D s_271_1: write-var gs#409589 <= s_271_0
        fn_state.gs_409589 = s_271_0;
        // N s_271_2: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_272_0: read-var gs#409589:u8
        let s_272_0: bool = fn_state.gs_409589;
        // N s_272_1: branch s_272_0 b1374 b273
        if s_272_0 {
            return block_1374(state, tracer, fn_state);
        } else {
            return block_273(state, tracer, fn_state);
        };
    }
    fn block_273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_273_0: const #0u : u8
        let s_273_0: bool = false;
        // D s_273_1: write-var gs#409594 <= s_273_0
        fn_state.gs_409594 = s_273_0;
        // N s_273_2: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_274_0: read-var gs#409594:u8
        let s_274_0: bool = fn_state.gs_409594;
        // D s_274_1: not s_274_0
        let s_274_1: bool = !s_274_0;
        // N s_274_2: branch s_274_1 b287 b275
        if s_274_1 {
            return block_287(state, tracer, fn_state);
        } else {
            return block_275(state, tracer, fn_state);
        };
    }
    fn block_275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_275_0: const #3109s : i
        let s_275_0: i128 = 3109;
        // C s_275_1: const #14696u : u32
        let s_275_1: u32 = 14696;
        // N s_275_2: write-reg s_275_1 <= s_275_0
        let s_275_2: () = {
            state.write_register::<i128>(s_275_1 as isize, s_275_0);
            tracer.write_register(s_275_1 as isize, s_275_0);
        };
        // C s_275_3: const #28s : i
        let s_275_3: i128 = 28;
        // C s_275_4: const #4s : i
        let s_275_4: i128 = 4;
        // D s_275_5: read-var u#33499:u32
        let s_275_5: u32 = fn_state.u_33499;
        // D s_275_6: cast zx s_275_5 -> bv
        let s_275_6: Bits = Bits::new(s_275_5 as u128, 32u16);
        // D s_275_7: bit-extract s_275_6 s_275_3 s_275_4
        let s_275_7: Bits = (Bits::new(
            ((s_275_6) >> (s_275_3)).value(),
            u16::try_from(s_275_4).unwrap(),
        ));
        // D s_275_8: cast reint s_275_7 -> u8
        let s_275_8: u8 = (s_275_7.value() as u8);
        // D s_275_9: write-var u#33500 <= s_275_8
        fn_state.u_33500 = s_275_8;
        // C s_275_10: const #16s : i
        let s_275_10: i128 = 16;
        // C s_275_11: const #4s : i
        let s_275_11: i128 = 4;
        // D s_275_12: read-var u#33499:u32
        let s_275_12: u32 = fn_state.u_33499;
        // D s_275_13: cast zx s_275_12 -> bv
        let s_275_13: Bits = Bits::new(s_275_12 as u128, 32u16);
        // D s_275_14: bit-extract s_275_13 s_275_10 s_275_11
        let s_275_14: Bits = (Bits::new(
            ((s_275_13) >> (s_275_10)).value(),
            u16::try_from(s_275_11).unwrap(),
        ));
        // D s_275_15: cast reint s_275_14 -> u8
        let s_275_15: u8 = (s_275_14.value() as u8);
        // D s_275_16: write-var u#33501 <= s_275_15
        fn_state.u_33501 = s_275_15;
        // C s_275_17: const #12s : i
        let s_275_17: i128 = 12;
        // C s_275_18: const #4s : i
        let s_275_18: i128 = 4;
        // D s_275_19: read-var u#33499:u32
        let s_275_19: u32 = fn_state.u_33499;
        // D s_275_20: cast zx s_275_19 -> bv
        let s_275_20: Bits = Bits::new(s_275_19 as u128, 32u16);
        // D s_275_21: bit-extract s_275_20 s_275_17 s_275_18
        let s_275_21: Bits = (Bits::new(
            ((s_275_20) >> (s_275_17)).value(),
            u16::try_from(s_275_18).unwrap(),
        ));
        // D s_275_22: cast reint s_275_21 -> u8
        let s_275_22: u8 = (s_275_21.value() as u8);
        // D s_275_23: write-var u#33502 <= s_275_22
        fn_state.u_33502 = s_275_22;
        // C s_275_24: const #0s : i
        let s_275_24: i128 = 0;
        // C s_275_25: const #4s : i
        let s_275_25: i128 = 4;
        // D s_275_26: read-var u#33499:u32
        let s_275_26: u32 = fn_state.u_33499;
        // D s_275_27: cast zx s_275_26 -> bv
        let s_275_27: Bits = Bits::new(s_275_26 as u128, 32u16);
        // D s_275_28: bit-extract s_275_27 s_275_24 s_275_25
        let s_275_28: Bits = (Bits::new(
            ((s_275_27) >> (s_275_24)).value(),
            u16::try_from(s_275_25).unwrap(),
        ));
        // D s_275_29: cast reint s_275_28 -> u8
        let s_275_29: u8 = (s_275_28.value() as u8);
        // D s_275_30: write-var u#33503 <= s_275_29
        fn_state.u_33503 = s_275_29;
        // C s_275_31: const #8s : i
        let s_275_31: i128 = 8;
        // D s_275_32: read-var u#33499:u32
        let s_275_32: u32 = fn_state.u_33499;
        // D s_275_33: cast zx s_275_32 -> bv
        let s_275_33: Bits = Bits::new(s_275_32 as u128, 32u16);
        // C s_275_34: const #1u : u64
        let s_275_34: u64 = 1;
        // D s_275_35: bit-extract s_275_33 s_275_31 s_275_34
        let s_275_35: Bits = (Bits::new(
            ((s_275_33) >> (s_275_31)).value(),
            u16::try_from(s_275_34).unwrap(),
        ));
        // D s_275_36: cast reint s_275_35 -> u8
        let s_275_36: bool = ((s_275_35.value()) != 0);
        // C s_275_37: const #0s : i
        let s_275_37: i128 = 0;
        // C s_275_38: const #0u : u64
        let s_275_38: u64 = 0;
        // D s_275_39: cast zx s_275_36 -> u64
        let s_275_39: u64 = (s_275_36 as u64);
        // C s_275_40: const #1u : u64
        let s_275_40: u64 = 1;
        // D s_275_41: and s_275_39 s_275_40
        let s_275_41: u64 = ((s_275_39) & (s_275_40));
        // D s_275_42: cmp-eq s_275_41 s_275_40
        let s_275_42: bool = ((s_275_41) == (s_275_40));
        // D s_275_43: lsl s_275_39 s_275_37
        let s_275_43: u64 = s_275_39 << s_275_37;
        // D s_275_44: or s_275_38 s_275_43
        let s_275_44: u64 = ((s_275_38) | (s_275_43));
        // D s_275_45: cmpl s_275_43
        let s_275_45: u64 = !s_275_43;
        // D s_275_46: and s_275_38 s_275_45
        let s_275_46: u64 = ((s_275_38) & (s_275_45));
        // D s_275_47: select s_275_42 s_275_44 s_275_46
        let s_275_47: u64 = if s_275_42 { s_275_44 } else { s_275_46 };
        // D s_275_48: cast trunc s_275_47 -> u8
        let s_275_48: bool = ((s_275_47) != 0);
        // D s_275_49: cast zx s_275_48 -> bv
        let s_275_49: Bits = Bits::new(s_275_48 as u128, 1u16);
        // C s_275_50: const #1u : u8
        let s_275_50: bool = true;
        // C s_275_51: cast zx s_275_50 -> bv
        let s_275_51: Bits = Bits::new(s_275_50 as u128, 1u16);
        // D s_275_52: cmp-ne s_275_49 s_275_51
        let s_275_52: bool = ((s_275_49) != (s_275_51));
        // N s_275_53: branch s_275_52 b286 b276
        if s_275_52 {
            return block_286(state, tracer, fn_state);
        } else {
            return block_276(state, tracer, fn_state);
        };
    }
    fn block_276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_276_0: const #9s : i
        let s_276_0: i128 = 9;
        // D s_276_1: read-var u#33499:u32
        let s_276_1: u32 = fn_state.u_33499;
        // D s_276_2: cast zx s_276_1 -> bv
        let s_276_2: Bits = Bits::new(s_276_1 as u128, 32u16);
        // C s_276_3: const #1u : u64
        let s_276_3: u64 = 1;
        // D s_276_4: bit-extract s_276_2 s_276_0 s_276_3
        let s_276_4: Bits = (Bits::new(
            ((s_276_2) >> (s_276_0)).value(),
            u16::try_from(s_276_3).unwrap(),
        ));
        // D s_276_5: cast reint s_276_4 -> u8
        let s_276_5: bool = ((s_276_4.value()) != 0);
        // C s_276_6: const #0s : i
        let s_276_6: i128 = 0;
        // C s_276_7: const #0u : u64
        let s_276_7: u64 = 0;
        // D s_276_8: cast zx s_276_5 -> u64
        let s_276_8: u64 = (s_276_5 as u64);
        // C s_276_9: const #1u : u64
        let s_276_9: u64 = 1;
        // D s_276_10: and s_276_8 s_276_9
        let s_276_10: u64 = ((s_276_8) & (s_276_9));
        // D s_276_11: cmp-eq s_276_10 s_276_9
        let s_276_11: bool = ((s_276_10) == (s_276_9));
        // D s_276_12: lsl s_276_8 s_276_6
        let s_276_12: u64 = s_276_8 << s_276_6;
        // D s_276_13: or s_276_7 s_276_12
        let s_276_13: u64 = ((s_276_7) | (s_276_12));
        // D s_276_14: cmpl s_276_12
        let s_276_14: u64 = !s_276_12;
        // D s_276_15: and s_276_7 s_276_14
        let s_276_15: u64 = ((s_276_7) & (s_276_14));
        // D s_276_16: select s_276_11 s_276_13 s_276_15
        let s_276_16: u64 = if s_276_11 { s_276_13 } else { s_276_15 };
        // D s_276_17: cast trunc s_276_16 -> u8
        let s_276_17: bool = ((s_276_16) != 0);
        // D s_276_18: cast zx s_276_17 -> bv
        let s_276_18: Bits = Bits::new(s_276_17 as u128, 1u16);
        // C s_276_19: const #1u : u8
        let s_276_19: bool = true;
        // C s_276_20: cast zx s_276_19 -> bv
        let s_276_20: Bits = Bits::new(s_276_19 as u128, 1u16);
        // D s_276_21: cmp-ne s_276_18 s_276_20
        let s_276_21: bool = ((s_276_18) != (s_276_20));
        // D s_276_22: write-var gs#409609 <= s_276_21
        fn_state.gs_409609 = s_276_21;
        // N s_276_23: jump b277
        return block_277(state, tracer, fn_state);
    }
    fn block_277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_277_0: read-var gs#409609:u8
        let s_277_0: bool = fn_state.gs_409609;
        // N s_277_1: branch s_277_0 b285 b278
        if s_277_0 {
            return block_285(state, tracer, fn_state);
        } else {
            return block_278(state, tracer, fn_state);
        };
    }
    fn block_278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_278_0: const #10s : i
        let s_278_0: i128 = 10;
        // D s_278_1: read-var u#33499:u32
        let s_278_1: u32 = fn_state.u_33499;
        // D s_278_2: cast zx s_278_1 -> bv
        let s_278_2: Bits = Bits::new(s_278_1 as u128, 32u16);
        // C s_278_3: const #1u : u64
        let s_278_3: u64 = 1;
        // D s_278_4: bit-extract s_278_2 s_278_0 s_278_3
        let s_278_4: Bits = (Bits::new(
            ((s_278_2) >> (s_278_0)).value(),
            u16::try_from(s_278_3).unwrap(),
        ));
        // D s_278_5: cast reint s_278_4 -> u8
        let s_278_5: bool = ((s_278_4.value()) != 0);
        // C s_278_6: const #0s : i
        let s_278_6: i128 = 0;
        // C s_278_7: const #0u : u64
        let s_278_7: u64 = 0;
        // D s_278_8: cast zx s_278_5 -> u64
        let s_278_8: u64 = (s_278_5 as u64);
        // C s_278_9: const #1u : u64
        let s_278_9: u64 = 1;
        // D s_278_10: and s_278_8 s_278_9
        let s_278_10: u64 = ((s_278_8) & (s_278_9));
        // D s_278_11: cmp-eq s_278_10 s_278_9
        let s_278_11: bool = ((s_278_10) == (s_278_9));
        // D s_278_12: lsl s_278_8 s_278_6
        let s_278_12: u64 = s_278_8 << s_278_6;
        // D s_278_13: or s_278_7 s_278_12
        let s_278_13: u64 = ((s_278_7) | (s_278_12));
        // D s_278_14: cmpl s_278_12
        let s_278_14: u64 = !s_278_12;
        // D s_278_15: and s_278_7 s_278_14
        let s_278_15: u64 = ((s_278_7) & (s_278_14));
        // D s_278_16: select s_278_11 s_278_13 s_278_15
        let s_278_16: u64 = if s_278_11 { s_278_13 } else { s_278_15 };
        // D s_278_17: cast trunc s_278_16 -> u8
        let s_278_17: bool = ((s_278_16) != 0);
        // D s_278_18: cast zx s_278_17 -> bv
        let s_278_18: Bits = Bits::new(s_278_17 as u128, 1u16);
        // C s_278_19: const #1u : u8
        let s_278_19: bool = true;
        // C s_278_20: cast zx s_278_19 -> bv
        let s_278_20: Bits = Bits::new(s_278_19 as u128, 1u16);
        // D s_278_21: cmp-ne s_278_18 s_278_20
        let s_278_21: bool = ((s_278_18) != (s_278_20));
        // D s_278_22: write-var gs#409612 <= s_278_21
        fn_state.gs_409612 = s_278_21;
        // N s_278_23: jump b279
        return block_279(state, tracer, fn_state);
    }
    fn block_279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_279_0: read-var gs#409612:u8
        let s_279_0: bool = fn_state.gs_409612;
        // N s_279_1: branch s_279_0 b284 b280
        if s_279_0 {
            return block_284(state, tracer, fn_state);
        } else {
            return block_280(state, tracer, fn_state);
        };
    }
    fn block_280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_280_0: const #11s : i
        let s_280_0: i128 = 11;
        // D s_280_1: read-var u#33499:u32
        let s_280_1: u32 = fn_state.u_33499;
        // D s_280_2: cast zx s_280_1 -> bv
        let s_280_2: Bits = Bits::new(s_280_1 as u128, 32u16);
        // C s_280_3: const #1u : u64
        let s_280_3: u64 = 1;
        // D s_280_4: bit-extract s_280_2 s_280_0 s_280_3
        let s_280_4: Bits = (Bits::new(
            ((s_280_2) >> (s_280_0)).value(),
            u16::try_from(s_280_3).unwrap(),
        ));
        // D s_280_5: cast reint s_280_4 -> u8
        let s_280_5: bool = ((s_280_4.value()) != 0);
        // C s_280_6: const #0s : i
        let s_280_6: i128 = 0;
        // C s_280_7: const #0u : u64
        let s_280_7: u64 = 0;
        // D s_280_8: cast zx s_280_5 -> u64
        let s_280_8: u64 = (s_280_5 as u64);
        // C s_280_9: const #1u : u64
        let s_280_9: u64 = 1;
        // D s_280_10: and s_280_8 s_280_9
        let s_280_10: u64 = ((s_280_8) & (s_280_9));
        // D s_280_11: cmp-eq s_280_10 s_280_9
        let s_280_11: bool = ((s_280_10) == (s_280_9));
        // D s_280_12: lsl s_280_8 s_280_6
        let s_280_12: u64 = s_280_8 << s_280_6;
        // D s_280_13: or s_280_7 s_280_12
        let s_280_13: u64 = ((s_280_7) | (s_280_12));
        // D s_280_14: cmpl s_280_12
        let s_280_14: u64 = !s_280_12;
        // D s_280_15: and s_280_7 s_280_14
        let s_280_15: u64 = ((s_280_7) & (s_280_14));
        // D s_280_16: select s_280_11 s_280_13 s_280_15
        let s_280_16: u64 = if s_280_11 { s_280_13 } else { s_280_15 };
        // D s_280_17: cast trunc s_280_16 -> u8
        let s_280_17: bool = ((s_280_16) != 0);
        // D s_280_18: cast zx s_280_17 -> bv
        let s_280_18: Bits = Bits::new(s_280_17 as u128, 1u16);
        // C s_280_19: const #1u : u8
        let s_280_19: bool = true;
        // C s_280_20: cast zx s_280_19 -> bv
        let s_280_20: Bits = Bits::new(s_280_19 as u128, 1u16);
        // D s_280_21: cmp-ne s_280_18 s_280_20
        let s_280_21: bool = ((s_280_18) != (s_280_20));
        // D s_280_22: write-var gs#409615 <= s_280_21
        fn_state.gs_409615 = s_280_21;
        // N s_280_23: jump b281
        return block_281(state, tracer, fn_state);
    }
    fn block_281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_281_0: read-var gs#409615:u8
        let s_281_0: bool = fn_state.gs_409615;
        // N s_281_1: branch s_281_0 b283 b282
        if s_281_0 {
            return block_283(state, tracer, fn_state);
        } else {
            return block_282(state, tracer, fn_state);
        };
    }
    fn block_282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_282_0: read-var u#33500:u8
        let s_282_0: u8 = fn_state.u_33500;
        // D s_282_1: read-var u#33501:u8
        let s_282_1: u8 = fn_state.u_33501;
        // D s_282_2: read-var u#33502:u8
        let s_282_2: u8 = fn_state.u_33502;
        // D s_282_3: read-var u#33503:u8
        let s_282_3: u8 = fn_state.u_33503;
        // D s_282_4: call decode_aarch32_instrs_SASX_A1enc_A_txt(s_282_0, s_282_1, s_282_2, s_282_3)
        let s_282_4: () = decode_aarch32_instrs_SASX_A1enc_A_txt(
            state,
            tracer,
            s_282_0,
            s_282_1,
            s_282_2,
            s_282_3,
        );
        // N s_282_5: return
        return;
    }
    fn block_283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_283_0: panic
        panic!("{:?}", ());
        // N s_283_1: return
        return;
    }
    fn block_284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_284_0: const #1u : u8
        let s_284_0: bool = true;
        // D s_284_1: write-var gs#409615 <= s_284_0
        fn_state.gs_409615 = s_284_0;
        // N s_284_2: jump b281
        return block_281(state, tracer, fn_state);
    }
    fn block_285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_285_0: const #1u : u8
        let s_285_0: bool = true;
        // D s_285_1: write-var gs#409612 <= s_285_0
        fn_state.gs_409612 = s_285_0;
        // N s_285_2: jump b279
        return block_279(state, tracer, fn_state);
    }
    fn block_286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_286_0: const #1u : u8
        let s_286_0: bool = true;
        // D s_286_1: write-var gs#409609 <= s_286_0
        fn_state.gs_409609 = s_286_0;
        // N s_286_2: jump b277
        return block_277(state, tracer, fn_state);
    }
    fn block_287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_287_0: read-var merge#var.1:struct
        let s_287_0: u32 = fn_state.merge_var._1;
        // D s_287_1: write-var u#33505 <= s_287_0
        fn_state.u_33505 = s_287_0;
        // C s_287_2: const #21s : i
        let s_287_2: i128 = 21;
        // D s_287_3: read-var u#33505:u32
        let s_287_3: u32 = fn_state.u_33505;
        // D s_287_4: cast zx s_287_3 -> bv
        let s_287_4: Bits = Bits::new(s_287_3 as u128, 32u16);
        // C s_287_5: const #1s : i64
        let s_287_5: i64 = 1;
        // C s_287_6: cast zx s_287_5 -> i
        let s_287_6: i128 = (i128::try_from(s_287_5).unwrap());
        // C s_287_7: const #6s : i
        let s_287_7: i128 = 6;
        // C s_287_8: add s_287_7 s_287_6
        let s_287_8: i128 = (s_287_7 + s_287_6);
        // D s_287_9: bit-extract s_287_4 s_287_2 s_287_8
        let s_287_9: Bits = (Bits::new(
            ((s_287_4) >> (s_287_2)).value(),
            u16::try_from(s_287_8).unwrap(),
        ));
        // D s_287_10: cast reint s_287_9 -> u8
        let s_287_10: u8 = (s_287_9.value() as u8);
        // D s_287_11: cast zx s_287_10 -> bv
        let s_287_11: Bits = Bits::new(s_287_10 as u128, 7u16);
        // C s_287_12: const #61u : u8
        let s_287_12: u8 = 61;
        // C s_287_13: cast zx s_287_12 -> bv
        let s_287_13: Bits = Bits::new(s_287_12 as u128, 7u16);
        // D s_287_14: cmp-eq s_287_11 s_287_13
        let s_287_14: bool = ((s_287_11) == (s_287_13));
        // N s_287_15: branch s_287_14 b1373 b288
        if s_287_14 {
            return block_1373(state, tracer, fn_state);
        } else {
            return block_288(state, tracer, fn_state);
        };
    }
    fn block_288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_288_0: const #0u : u8
        let s_288_0: bool = false;
        // D s_288_1: write-var gs#409621 <= s_288_0
        fn_state.gs_409621 = s_288_0;
        // N s_288_2: jump b289
        return block_289(state, tracer, fn_state);
    }
    fn block_289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_289_0: read-var gs#409621:u8
        let s_289_0: bool = fn_state.gs_409621;
        // N s_289_1: branch s_289_0 b1369 b290
        if s_289_0 {
            return block_1369(state, tracer, fn_state);
        } else {
            return block_290(state, tracer, fn_state);
        };
    }
    fn block_290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_290_0: const #0u : u8
        let s_290_0: bool = false;
        // D s_290_1: write-var gs#409626 <= s_290_0
        fn_state.gs_409626 = s_290_0;
        // N s_290_2: jump b291
        return block_291(state, tracer, fn_state);
    }
    fn block_291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_291_0: read-var gs#409626:u8
        let s_291_0: bool = fn_state.gs_409626;
        // D s_291_1: not s_291_0
        let s_291_1: bool = !s_291_0;
        // N s_291_2: branch s_291_1 b293 b292
        if s_291_1 {
            return block_293(state, tracer, fn_state);
        } else {
            return block_292(state, tracer, fn_state);
        };
    }
    fn block_292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_292_0: const #3119s : i
        let s_292_0: i128 = 3119;
        // C s_292_1: const #14696u : u32
        let s_292_1: u32 = 14696;
        // N s_292_2: write-reg s_292_1 <= s_292_0
        let s_292_2: () = {
            state.write_register::<i128>(s_292_1 as isize, s_292_0);
            tracer.write_register(s_292_1 as isize, s_292_0);
        };
        // C s_292_3: const #28s : i
        let s_292_3: i128 = 28;
        // C s_292_4: const #4s : i
        let s_292_4: i128 = 4;
        // D s_292_5: read-var u#33505:u32
        let s_292_5: u32 = fn_state.u_33505;
        // D s_292_6: cast zx s_292_5 -> bv
        let s_292_6: Bits = Bits::new(s_292_5 as u128, 32u16);
        // D s_292_7: bit-extract s_292_6 s_292_3 s_292_4
        let s_292_7: Bits = (Bits::new(
            ((s_292_6) >> (s_292_3)).value(),
            u16::try_from(s_292_4).unwrap(),
        ));
        // D s_292_8: cast reint s_292_7 -> u8
        let s_292_8: u8 = (s_292_7.value() as u8);
        // C s_292_9: const #16s : i
        let s_292_9: i128 = 16;
        // C s_292_10: const #5s : i
        let s_292_10: i128 = 5;
        // D s_292_11: read-var u#33505:u32
        let s_292_11: u32 = fn_state.u_33505;
        // D s_292_12: cast zx s_292_11 -> bv
        let s_292_12: Bits = Bits::new(s_292_11 as u128, 32u16);
        // D s_292_13: bit-extract s_292_12 s_292_9 s_292_10
        let s_292_13: Bits = (Bits::new(
            ((s_292_12) >> (s_292_9)).value(),
            u16::try_from(s_292_10).unwrap(),
        ));
        // D s_292_14: cast reint s_292_13 -> u8
        let s_292_14: u8 = (s_292_13.value() as u8);
        // C s_292_15: const #12s : i
        let s_292_15: i128 = 12;
        // C s_292_16: const #4s : i
        let s_292_16: i128 = 4;
        // D s_292_17: read-var u#33505:u32
        let s_292_17: u32 = fn_state.u_33505;
        // D s_292_18: cast zx s_292_17 -> bv
        let s_292_18: Bits = Bits::new(s_292_17 as u128, 32u16);
        // D s_292_19: bit-extract s_292_18 s_292_15 s_292_16
        let s_292_19: Bits = (Bits::new(
            ((s_292_18) >> (s_292_15)).value(),
            u16::try_from(s_292_16).unwrap(),
        ));
        // D s_292_20: cast reint s_292_19 -> u8
        let s_292_20: u8 = (s_292_19.value() as u8);
        // C s_292_21: const #7s : i
        let s_292_21: i128 = 7;
        // C s_292_22: const #5s : i
        let s_292_22: i128 = 5;
        // D s_292_23: read-var u#33505:u32
        let s_292_23: u32 = fn_state.u_33505;
        // D s_292_24: cast zx s_292_23 -> bv
        let s_292_24: Bits = Bits::new(s_292_23 as u128, 32u16);
        // D s_292_25: bit-extract s_292_24 s_292_21 s_292_22
        let s_292_25: Bits = (Bits::new(
            ((s_292_24) >> (s_292_21)).value(),
            u16::try_from(s_292_22).unwrap(),
        ));
        // D s_292_26: cast reint s_292_25 -> u8
        let s_292_26: u8 = (s_292_25.value() as u8);
        // C s_292_27: const #0s : i
        let s_292_27: i128 = 0;
        // C s_292_28: const #4s : i
        let s_292_28: i128 = 4;
        // D s_292_29: read-var u#33505:u32
        let s_292_29: u32 = fn_state.u_33505;
        // D s_292_30: cast zx s_292_29 -> bv
        let s_292_30: Bits = Bits::new(s_292_29 as u128, 32u16);
        // D s_292_31: bit-extract s_292_30 s_292_27 s_292_28
        let s_292_31: Bits = (Bits::new(
            ((s_292_30) >> (s_292_27)).value(),
            u16::try_from(s_292_28).unwrap(),
        ));
        // D s_292_32: cast reint s_292_31 -> u8
        let s_292_32: u8 = (s_292_31.value() as u8);
        // D s_292_33: call decode_aarch32_instrs_SBFX_A1enc_A_txt(s_292_8, s_292_14, s_292_20, s_292_26, s_292_32)
        let s_292_33: () = decode_aarch32_instrs_SBFX_A1enc_A_txt(
            state,
            tracer,
            s_292_8,
            s_292_14,
            s_292_20,
            s_292_26,
            s_292_32,
        );
        // N s_292_34: return
        return;
    }
    fn block_293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_293_0: read-var merge#var.1:struct
        let s_293_0: u32 = fn_state.merge_var._1;
        // D s_293_1: write-var u#33511 <= s_293_0
        fn_state.u_33511 = s_293_0;
        // C s_293_2: const #20s : i
        let s_293_2: i128 = 20;
        // D s_293_3: read-var u#33511:u32
        let s_293_3: u32 = fn_state.u_33511;
        // D s_293_4: cast zx s_293_3 -> bv
        let s_293_4: Bits = Bits::new(s_293_3 as u128, 32u16);
        // C s_293_5: const #1s : i64
        let s_293_5: i64 = 1;
        // C s_293_6: cast zx s_293_5 -> i
        let s_293_6: i128 = (i128::try_from(s_293_5).unwrap());
        // C s_293_7: const #7s : i
        let s_293_7: i128 = 7;
        // C s_293_8: add s_293_7 s_293_6
        let s_293_8: i128 = (s_293_7 + s_293_6);
        // D s_293_9: bit-extract s_293_4 s_293_2 s_293_8
        let s_293_9: Bits = (Bits::new(
            ((s_293_4) >> (s_293_2)).value(),
            u16::try_from(s_293_8).unwrap(),
        ));
        // D s_293_10: cast reint s_293_9 -> u8
        let s_293_10: u8 = (s_293_9.value() as u8);
        // D s_293_11: cast zx s_293_10 -> bv
        let s_293_11: Bits = Bits::new(s_293_10 as u128, 8u16);
        // C s_293_12: const #113u : u8
        let s_293_12: u8 = 113;
        // C s_293_13: cast zx s_293_12 -> bv
        let s_293_13: Bits = Bits::new(s_293_12 as u128, 8u16);
        // D s_293_14: cmp-eq s_293_11 s_293_13
        let s_293_14: bool = ((s_293_11) == (s_293_13));
        // N s_293_15: branch s_293_14 b1368 b294
        if s_293_14 {
            return block_1368(state, tracer, fn_state);
        } else {
            return block_294(state, tracer, fn_state);
        };
    }
    fn block_294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_294_0: const #0u : u8
        let s_294_0: bool = false;
        // D s_294_1: write-var gs#409644 <= s_294_0
        fn_state.gs_409644 = s_294_0;
        // N s_294_2: jump b295
        return block_295(state, tracer, fn_state);
    }
    fn block_295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_295_0: read-var gs#409644:u8
        let s_295_0: bool = fn_state.gs_409644;
        // N s_295_1: branch s_295_0 b1364 b296
        if s_295_0 {
            return block_1364(state, tracer, fn_state);
        } else {
            return block_296(state, tracer, fn_state);
        };
    }
    fn block_296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_296_0: const #0u : u8
        let s_296_0: bool = false;
        // D s_296_1: write-var gs#409649 <= s_296_0
        fn_state.gs_409649 = s_296_0;
        // N s_296_2: jump b297
        return block_297(state, tracer, fn_state);
    }
    fn block_297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_297_0: read-var gs#409649:u8
        let s_297_0: bool = fn_state.gs_409649;
        // D s_297_1: not s_297_0
        let s_297_1: bool = !s_297_0;
        // N s_297_2: branch s_297_1 b299 b298
        if s_297_1 {
            return block_299(state, tracer, fn_state);
        } else {
            return block_298(state, tracer, fn_state);
        };
    }
    fn block_298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_298_0: const #3121s : i
        let s_298_0: i128 = 3121;
        // C s_298_1: const #14696u : u32
        let s_298_1: u32 = 14696;
        // N s_298_2: write-reg s_298_1 <= s_298_0
        let s_298_2: () = {
            state.write_register::<i128>(s_298_1 as isize, s_298_0);
            tracer.write_register(s_298_1 as isize, s_298_0);
        };
        // C s_298_3: const #28s : i
        let s_298_3: i128 = 28;
        // C s_298_4: const #4s : i
        let s_298_4: i128 = 4;
        // D s_298_5: read-var u#33511:u32
        let s_298_5: u32 = fn_state.u_33511;
        // D s_298_6: cast zx s_298_5 -> bv
        let s_298_6: Bits = Bits::new(s_298_5 as u128, 32u16);
        // D s_298_7: bit-extract s_298_6 s_298_3 s_298_4
        let s_298_7: Bits = (Bits::new(
            ((s_298_6) >> (s_298_3)).value(),
            u16::try_from(s_298_4).unwrap(),
        ));
        // D s_298_8: cast reint s_298_7 -> u8
        let s_298_8: u8 = (s_298_7.value() as u8);
        // C s_298_9: const #16s : i
        let s_298_9: i128 = 16;
        // C s_298_10: const #4s : i
        let s_298_10: i128 = 4;
        // D s_298_11: read-var u#33511:u32
        let s_298_11: u32 = fn_state.u_33511;
        // D s_298_12: cast zx s_298_11 -> bv
        let s_298_12: Bits = Bits::new(s_298_11 as u128, 32u16);
        // D s_298_13: bit-extract s_298_12 s_298_9 s_298_10
        let s_298_13: Bits = (Bits::new(
            ((s_298_12) >> (s_298_9)).value(),
            u16::try_from(s_298_10).unwrap(),
        ));
        // D s_298_14: cast reint s_298_13 -> u8
        let s_298_14: u8 = (s_298_13.value() as u8);
        // C s_298_15: const #12s : i
        let s_298_15: i128 = 12;
        // C s_298_16: const #4s : i
        let s_298_16: i128 = 4;
        // D s_298_17: read-var u#33511:u32
        let s_298_17: u32 = fn_state.u_33511;
        // D s_298_18: cast zx s_298_17 -> bv
        let s_298_18: Bits = Bits::new(s_298_17 as u128, 32u16);
        // D s_298_19: bit-extract s_298_18 s_298_15 s_298_16
        let s_298_19: Bits = (Bits::new(
            ((s_298_18) >> (s_298_15)).value(),
            u16::try_from(s_298_16).unwrap(),
        ));
        // D s_298_20: cast reint s_298_19 -> u8
        let s_298_20: u8 = (s_298_19.value() as u8);
        // C s_298_21: const #8s : i
        let s_298_21: i128 = 8;
        // C s_298_22: const #4s : i
        let s_298_22: i128 = 4;
        // D s_298_23: read-var u#33511:u32
        let s_298_23: u32 = fn_state.u_33511;
        // D s_298_24: cast zx s_298_23 -> bv
        let s_298_24: Bits = Bits::new(s_298_23 as u128, 32u16);
        // D s_298_25: bit-extract s_298_24 s_298_21 s_298_22
        let s_298_25: Bits = (Bits::new(
            ((s_298_24) >> (s_298_21)).value(),
            u16::try_from(s_298_22).unwrap(),
        ));
        // D s_298_26: cast reint s_298_25 -> u8
        let s_298_26: u8 = (s_298_25.value() as u8);
        // C s_298_27: const #0s : i
        let s_298_27: i128 = 0;
        // C s_298_28: const #4s : i
        let s_298_28: i128 = 4;
        // D s_298_29: read-var u#33511:u32
        let s_298_29: u32 = fn_state.u_33511;
        // D s_298_30: cast zx s_298_29 -> bv
        let s_298_30: Bits = Bits::new(s_298_29 as u128, 32u16);
        // D s_298_31: bit-extract s_298_30 s_298_27 s_298_28
        let s_298_31: Bits = (Bits::new(
            ((s_298_30) >> (s_298_27)).value(),
            u16::try_from(s_298_28).unwrap(),
        ));
        // D s_298_32: cast reint s_298_31 -> u8
        let s_298_32: u8 = (s_298_31.value() as u8);
        // D s_298_33: call decode_aarch32_instrs_SDIV_A1enc_A_txt(s_298_8, s_298_14, s_298_20, s_298_26, s_298_32)
        let s_298_33: () = decode_aarch32_instrs_SDIV_A1enc_A_txt(
            state,
            tracer,
            s_298_8,
            s_298_14,
            s_298_20,
            s_298_26,
            s_298_32,
        );
        // N s_298_34: return
        return;
    }
    fn block_299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_299_0: read-var merge#var.1:struct
        let s_299_0: u32 = fn_state.merge_var._1;
        // D s_299_1: write-var u#33517 <= s_299_0
        fn_state.u_33517 = s_299_0;
        // C s_299_2: const #20s : i
        let s_299_2: i128 = 20;
        // D s_299_3: read-var u#33517:u32
        let s_299_3: u32 = fn_state.u_33517;
        // D s_299_4: cast zx s_299_3 -> bv
        let s_299_4: Bits = Bits::new(s_299_3 as u128, 32u16);
        // C s_299_5: const #1s : i64
        let s_299_5: i64 = 1;
        // C s_299_6: cast zx s_299_5 -> i
        let s_299_6: i128 = (i128::try_from(s_299_5).unwrap());
        // C s_299_7: const #7s : i
        let s_299_7: i128 = 7;
        // C s_299_8: add s_299_7 s_299_6
        let s_299_8: i128 = (s_299_7 + s_299_6);
        // D s_299_9: bit-extract s_299_4 s_299_2 s_299_8
        let s_299_9: Bits = (Bits::new(
            ((s_299_4) >> (s_299_2)).value(),
            u16::try_from(s_299_8).unwrap(),
        ));
        // D s_299_10: cast reint s_299_9 -> u8
        let s_299_10: u8 = (s_299_9.value() as u8);
        // D s_299_11: cast zx s_299_10 -> bv
        let s_299_11: Bits = Bits::new(s_299_10 as u128, 8u16);
        // C s_299_12: const #104u : u8
        let s_299_12: u8 = 104;
        // C s_299_13: cast zx s_299_12 -> bv
        let s_299_13: Bits = Bits::new(s_299_12 as u128, 8u16);
        // D s_299_14: cmp-eq s_299_11 s_299_13
        let s_299_14: bool = ((s_299_11) == (s_299_13));
        // N s_299_15: branch s_299_14 b1363 b300
        if s_299_14 {
            return block_1363(state, tracer, fn_state);
        } else {
            return block_300(state, tracer, fn_state);
        };
    }
    fn block_300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_300_0: const #0u : u8
        let s_300_0: bool = false;
        // D s_300_1: write-var gs#409667 <= s_300_0
        fn_state.gs_409667 = s_300_0;
        // N s_300_2: jump b301
        return block_301(state, tracer, fn_state);
    }
    fn block_301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_301_0: read-var gs#409667:u8
        let s_301_0: bool = fn_state.gs_409667;
        // N s_301_1: branch s_301_0 b1359 b302
        if s_301_0 {
            return block_1359(state, tracer, fn_state);
        } else {
            return block_302(state, tracer, fn_state);
        };
    }
    fn block_302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_302_0: const #0u : u8
        let s_302_0: bool = false;
        // D s_302_1: write-var gs#409672 <= s_302_0
        fn_state.gs_409672 = s_302_0;
        // N s_302_2: jump b303
        return block_303(state, tracer, fn_state);
    }
    fn block_303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_303_0: read-var gs#409672:u8
        let s_303_0: bool = fn_state.gs_409672;
        // D s_303_1: not s_303_0
        let s_303_1: bool = !s_303_0;
        // N s_303_2: branch s_303_1 b316 b304
        if s_303_1 {
            return block_316(state, tracer, fn_state);
        } else {
            return block_304(state, tracer, fn_state);
        };
    }
    fn block_304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_304_0: const #3123s : i
        let s_304_0: i128 = 3123;
        // C s_304_1: const #14696u : u32
        let s_304_1: u32 = 14696;
        // N s_304_2: write-reg s_304_1 <= s_304_0
        let s_304_2: () = {
            state.write_register::<i128>(s_304_1 as isize, s_304_0);
            tracer.write_register(s_304_1 as isize, s_304_0);
        };
        // C s_304_3: const #28s : i
        let s_304_3: i128 = 28;
        // C s_304_4: const #4s : i
        let s_304_4: i128 = 4;
        // D s_304_5: read-var u#33517:u32
        let s_304_5: u32 = fn_state.u_33517;
        // D s_304_6: cast zx s_304_5 -> bv
        let s_304_6: Bits = Bits::new(s_304_5 as u128, 32u16);
        // D s_304_7: bit-extract s_304_6 s_304_3 s_304_4
        let s_304_7: Bits = (Bits::new(
            ((s_304_6) >> (s_304_3)).value(),
            u16::try_from(s_304_4).unwrap(),
        ));
        // D s_304_8: cast reint s_304_7 -> u8
        let s_304_8: u8 = (s_304_7.value() as u8);
        // D s_304_9: write-var u#33518 <= s_304_8
        fn_state.u_33518 = s_304_8;
        // C s_304_10: const #16s : i
        let s_304_10: i128 = 16;
        // C s_304_11: const #4s : i
        let s_304_11: i128 = 4;
        // D s_304_12: read-var u#33517:u32
        let s_304_12: u32 = fn_state.u_33517;
        // D s_304_13: cast zx s_304_12 -> bv
        let s_304_13: Bits = Bits::new(s_304_12 as u128, 32u16);
        // D s_304_14: bit-extract s_304_13 s_304_10 s_304_11
        let s_304_14: Bits = (Bits::new(
            ((s_304_13) >> (s_304_10)).value(),
            u16::try_from(s_304_11).unwrap(),
        ));
        // D s_304_15: cast reint s_304_14 -> u8
        let s_304_15: u8 = (s_304_14.value() as u8);
        // D s_304_16: write-var u#33519 <= s_304_15
        fn_state.u_33519 = s_304_15;
        // C s_304_17: const #12s : i
        let s_304_17: i128 = 12;
        // C s_304_18: const #4s : i
        let s_304_18: i128 = 4;
        // D s_304_19: read-var u#33517:u32
        let s_304_19: u32 = fn_state.u_33517;
        // D s_304_20: cast zx s_304_19 -> bv
        let s_304_20: Bits = Bits::new(s_304_19 as u128, 32u16);
        // D s_304_21: bit-extract s_304_20 s_304_17 s_304_18
        let s_304_21: Bits = (Bits::new(
            ((s_304_20) >> (s_304_17)).value(),
            u16::try_from(s_304_18).unwrap(),
        ));
        // D s_304_22: cast reint s_304_21 -> u8
        let s_304_22: u8 = (s_304_21.value() as u8);
        // D s_304_23: write-var u#33520 <= s_304_22
        fn_state.u_33520 = s_304_22;
        // C s_304_24: const #0s : i
        let s_304_24: i128 = 0;
        // C s_304_25: const #4s : i
        let s_304_25: i128 = 4;
        // D s_304_26: read-var u#33517:u32
        let s_304_26: u32 = fn_state.u_33517;
        // D s_304_27: cast zx s_304_26 -> bv
        let s_304_27: Bits = Bits::new(s_304_26 as u128, 32u16);
        // D s_304_28: bit-extract s_304_27 s_304_24 s_304_25
        let s_304_28: Bits = (Bits::new(
            ((s_304_27) >> (s_304_24)).value(),
            u16::try_from(s_304_25).unwrap(),
        ));
        // D s_304_29: cast reint s_304_28 -> u8
        let s_304_29: u8 = (s_304_28.value() as u8);
        // D s_304_30: write-var u#33521 <= s_304_29
        fn_state.u_33521 = s_304_29;
        // C s_304_31: const #8s : i
        let s_304_31: i128 = 8;
        // D s_304_32: read-var u#33517:u32
        let s_304_32: u32 = fn_state.u_33517;
        // D s_304_33: cast zx s_304_32 -> bv
        let s_304_33: Bits = Bits::new(s_304_32 as u128, 32u16);
        // C s_304_34: const #1u : u64
        let s_304_34: u64 = 1;
        // D s_304_35: bit-extract s_304_33 s_304_31 s_304_34
        let s_304_35: Bits = (Bits::new(
            ((s_304_33) >> (s_304_31)).value(),
            u16::try_from(s_304_34).unwrap(),
        ));
        // D s_304_36: cast reint s_304_35 -> u8
        let s_304_36: bool = ((s_304_35.value()) != 0);
        // C s_304_37: const #0s : i
        let s_304_37: i128 = 0;
        // C s_304_38: const #0u : u64
        let s_304_38: u64 = 0;
        // D s_304_39: cast zx s_304_36 -> u64
        let s_304_39: u64 = (s_304_36 as u64);
        // C s_304_40: const #1u : u64
        let s_304_40: u64 = 1;
        // D s_304_41: and s_304_39 s_304_40
        let s_304_41: u64 = ((s_304_39) & (s_304_40));
        // D s_304_42: cmp-eq s_304_41 s_304_40
        let s_304_42: bool = ((s_304_41) == (s_304_40));
        // D s_304_43: lsl s_304_39 s_304_37
        let s_304_43: u64 = s_304_39 << s_304_37;
        // D s_304_44: or s_304_38 s_304_43
        let s_304_44: u64 = ((s_304_38) | (s_304_43));
        // D s_304_45: cmpl s_304_43
        let s_304_45: u64 = !s_304_43;
        // D s_304_46: and s_304_38 s_304_45
        let s_304_46: u64 = ((s_304_38) & (s_304_45));
        // D s_304_47: select s_304_42 s_304_44 s_304_46
        let s_304_47: u64 = if s_304_42 { s_304_44 } else { s_304_46 };
        // D s_304_48: cast trunc s_304_47 -> u8
        let s_304_48: bool = ((s_304_47) != 0);
        // D s_304_49: cast zx s_304_48 -> bv
        let s_304_49: Bits = Bits::new(s_304_48 as u128, 1u16);
        // C s_304_50: const #1u : u8
        let s_304_50: bool = true;
        // C s_304_51: cast zx s_304_50 -> bv
        let s_304_51: Bits = Bits::new(s_304_50 as u128, 1u16);
        // D s_304_52: cmp-ne s_304_49 s_304_51
        let s_304_52: bool = ((s_304_49) != (s_304_51));
        // N s_304_53: branch s_304_52 b315 b305
        if s_304_52 {
            return block_315(state, tracer, fn_state);
        } else {
            return block_305(state, tracer, fn_state);
        };
    }
    fn block_305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_305_0: const #9s : i
        let s_305_0: i128 = 9;
        // D s_305_1: read-var u#33517:u32
        let s_305_1: u32 = fn_state.u_33517;
        // D s_305_2: cast zx s_305_1 -> bv
        let s_305_2: Bits = Bits::new(s_305_1 as u128, 32u16);
        // C s_305_3: const #1u : u64
        let s_305_3: u64 = 1;
        // D s_305_4: bit-extract s_305_2 s_305_0 s_305_3
        let s_305_4: Bits = (Bits::new(
            ((s_305_2) >> (s_305_0)).value(),
            u16::try_from(s_305_3).unwrap(),
        ));
        // D s_305_5: cast reint s_305_4 -> u8
        let s_305_5: bool = ((s_305_4.value()) != 0);
        // C s_305_6: const #0s : i
        let s_305_6: i128 = 0;
        // C s_305_7: const #0u : u64
        let s_305_7: u64 = 0;
        // D s_305_8: cast zx s_305_5 -> u64
        let s_305_8: u64 = (s_305_5 as u64);
        // C s_305_9: const #1u : u64
        let s_305_9: u64 = 1;
        // D s_305_10: and s_305_8 s_305_9
        let s_305_10: u64 = ((s_305_8) & (s_305_9));
        // D s_305_11: cmp-eq s_305_10 s_305_9
        let s_305_11: bool = ((s_305_10) == (s_305_9));
        // D s_305_12: lsl s_305_8 s_305_6
        let s_305_12: u64 = s_305_8 << s_305_6;
        // D s_305_13: or s_305_7 s_305_12
        let s_305_13: u64 = ((s_305_7) | (s_305_12));
        // D s_305_14: cmpl s_305_12
        let s_305_14: u64 = !s_305_12;
        // D s_305_15: and s_305_7 s_305_14
        let s_305_15: u64 = ((s_305_7) & (s_305_14));
        // D s_305_16: select s_305_11 s_305_13 s_305_15
        let s_305_16: u64 = if s_305_11 { s_305_13 } else { s_305_15 };
        // D s_305_17: cast trunc s_305_16 -> u8
        let s_305_17: bool = ((s_305_16) != 0);
        // D s_305_18: cast zx s_305_17 -> bv
        let s_305_18: Bits = Bits::new(s_305_17 as u128, 1u16);
        // C s_305_19: const #1u : u8
        let s_305_19: bool = true;
        // C s_305_20: cast zx s_305_19 -> bv
        let s_305_20: Bits = Bits::new(s_305_19 as u128, 1u16);
        // D s_305_21: cmp-ne s_305_18 s_305_20
        let s_305_21: bool = ((s_305_18) != (s_305_20));
        // D s_305_22: write-var gs#409687 <= s_305_21
        fn_state.gs_409687 = s_305_21;
        // N s_305_23: jump b306
        return block_306(state, tracer, fn_state);
    }
    fn block_306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_306_0: read-var gs#409687:u8
        let s_306_0: bool = fn_state.gs_409687;
        // N s_306_1: branch s_306_0 b314 b307
        if s_306_0 {
            return block_314(state, tracer, fn_state);
        } else {
            return block_307(state, tracer, fn_state);
        };
    }
    fn block_307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_307_0: const #10s : i
        let s_307_0: i128 = 10;
        // D s_307_1: read-var u#33517:u32
        let s_307_1: u32 = fn_state.u_33517;
        // D s_307_2: cast zx s_307_1 -> bv
        let s_307_2: Bits = Bits::new(s_307_1 as u128, 32u16);
        // C s_307_3: const #1u : u64
        let s_307_3: u64 = 1;
        // D s_307_4: bit-extract s_307_2 s_307_0 s_307_3
        let s_307_4: Bits = (Bits::new(
            ((s_307_2) >> (s_307_0)).value(),
            u16::try_from(s_307_3).unwrap(),
        ));
        // D s_307_5: cast reint s_307_4 -> u8
        let s_307_5: bool = ((s_307_4.value()) != 0);
        // C s_307_6: const #0s : i
        let s_307_6: i128 = 0;
        // C s_307_7: const #0u : u64
        let s_307_7: u64 = 0;
        // D s_307_8: cast zx s_307_5 -> u64
        let s_307_8: u64 = (s_307_5 as u64);
        // C s_307_9: const #1u : u64
        let s_307_9: u64 = 1;
        // D s_307_10: and s_307_8 s_307_9
        let s_307_10: u64 = ((s_307_8) & (s_307_9));
        // D s_307_11: cmp-eq s_307_10 s_307_9
        let s_307_11: bool = ((s_307_10) == (s_307_9));
        // D s_307_12: lsl s_307_8 s_307_6
        let s_307_12: u64 = s_307_8 << s_307_6;
        // D s_307_13: or s_307_7 s_307_12
        let s_307_13: u64 = ((s_307_7) | (s_307_12));
        // D s_307_14: cmpl s_307_12
        let s_307_14: u64 = !s_307_12;
        // D s_307_15: and s_307_7 s_307_14
        let s_307_15: u64 = ((s_307_7) & (s_307_14));
        // D s_307_16: select s_307_11 s_307_13 s_307_15
        let s_307_16: u64 = if s_307_11 { s_307_13 } else { s_307_15 };
        // D s_307_17: cast trunc s_307_16 -> u8
        let s_307_17: bool = ((s_307_16) != 0);
        // D s_307_18: cast zx s_307_17 -> bv
        let s_307_18: Bits = Bits::new(s_307_17 as u128, 1u16);
        // C s_307_19: const #1u : u8
        let s_307_19: bool = true;
        // C s_307_20: cast zx s_307_19 -> bv
        let s_307_20: Bits = Bits::new(s_307_19 as u128, 1u16);
        // D s_307_21: cmp-ne s_307_18 s_307_20
        let s_307_21: bool = ((s_307_18) != (s_307_20));
        // D s_307_22: write-var gs#409690 <= s_307_21
        fn_state.gs_409690 = s_307_21;
        // N s_307_23: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_308_0: read-var gs#409690:u8
        let s_308_0: bool = fn_state.gs_409690;
        // N s_308_1: branch s_308_0 b313 b309
        if s_308_0 {
            return block_313(state, tracer, fn_state);
        } else {
            return block_309(state, tracer, fn_state);
        };
    }
    fn block_309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_309_0: const #11s : i
        let s_309_0: i128 = 11;
        // D s_309_1: read-var u#33517:u32
        let s_309_1: u32 = fn_state.u_33517;
        // D s_309_2: cast zx s_309_1 -> bv
        let s_309_2: Bits = Bits::new(s_309_1 as u128, 32u16);
        // C s_309_3: const #1u : u64
        let s_309_3: u64 = 1;
        // D s_309_4: bit-extract s_309_2 s_309_0 s_309_3
        let s_309_4: Bits = (Bits::new(
            ((s_309_2) >> (s_309_0)).value(),
            u16::try_from(s_309_3).unwrap(),
        ));
        // D s_309_5: cast reint s_309_4 -> u8
        let s_309_5: bool = ((s_309_4.value()) != 0);
        // C s_309_6: const #0s : i
        let s_309_6: i128 = 0;
        // C s_309_7: const #0u : u64
        let s_309_7: u64 = 0;
        // D s_309_8: cast zx s_309_5 -> u64
        let s_309_8: u64 = (s_309_5 as u64);
        // C s_309_9: const #1u : u64
        let s_309_9: u64 = 1;
        // D s_309_10: and s_309_8 s_309_9
        let s_309_10: u64 = ((s_309_8) & (s_309_9));
        // D s_309_11: cmp-eq s_309_10 s_309_9
        let s_309_11: bool = ((s_309_10) == (s_309_9));
        // D s_309_12: lsl s_309_8 s_309_6
        let s_309_12: u64 = s_309_8 << s_309_6;
        // D s_309_13: or s_309_7 s_309_12
        let s_309_13: u64 = ((s_309_7) | (s_309_12));
        // D s_309_14: cmpl s_309_12
        let s_309_14: u64 = !s_309_12;
        // D s_309_15: and s_309_7 s_309_14
        let s_309_15: u64 = ((s_309_7) & (s_309_14));
        // D s_309_16: select s_309_11 s_309_13 s_309_15
        let s_309_16: u64 = if s_309_11 { s_309_13 } else { s_309_15 };
        // D s_309_17: cast trunc s_309_16 -> u8
        let s_309_17: bool = ((s_309_16) != 0);
        // D s_309_18: cast zx s_309_17 -> bv
        let s_309_18: Bits = Bits::new(s_309_17 as u128, 1u16);
        // C s_309_19: const #1u : u8
        let s_309_19: bool = true;
        // C s_309_20: cast zx s_309_19 -> bv
        let s_309_20: Bits = Bits::new(s_309_19 as u128, 1u16);
        // D s_309_21: cmp-ne s_309_18 s_309_20
        let s_309_21: bool = ((s_309_18) != (s_309_20));
        // D s_309_22: write-var gs#409693 <= s_309_21
        fn_state.gs_409693 = s_309_21;
        // N s_309_23: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_310_0: read-var gs#409693:u8
        let s_310_0: bool = fn_state.gs_409693;
        // N s_310_1: branch s_310_0 b312 b311
        if s_310_0 {
            return block_312(state, tracer, fn_state);
        } else {
            return block_311(state, tracer, fn_state);
        };
    }
    fn block_311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_311_0: read-var u#33518:u8
        let s_311_0: u8 = fn_state.u_33518;
        // D s_311_1: read-var u#33519:u8
        let s_311_1: u8 = fn_state.u_33519;
        // D s_311_2: read-var u#33520:u8
        let s_311_2: u8 = fn_state.u_33520;
        // D s_311_3: read-var u#33521:u8
        let s_311_3: u8 = fn_state.u_33521;
        // D s_311_4: call decode_aarch32_instrs_SEL_A1enc_A_txt(s_311_0, s_311_1, s_311_2, s_311_3)
        let s_311_4: () = decode_aarch32_instrs_SEL_A1enc_A_txt(
            state,
            tracer,
            s_311_0,
            s_311_1,
            s_311_2,
            s_311_3,
        );
        // N s_311_5: return
        return;
    }
    fn block_312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_312_0: panic
        panic!("{:?}", ());
        // N s_312_1: return
        return;
    }
    fn block_313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_313_0: const #1u : u8
        let s_313_0: bool = true;
        // D s_313_1: write-var gs#409693 <= s_313_0
        fn_state.gs_409693 = s_313_0;
        // N s_313_2: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_314_0: const #1u : u8
        let s_314_0: bool = true;
        // D s_314_1: write-var gs#409690 <= s_314_0
        fn_state.gs_409690 = s_314_0;
        // N s_314_2: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_315_0: const #1u : u8
        let s_315_0: bool = true;
        // D s_315_1: write-var gs#409687 <= s_315_0
        fn_state.gs_409687 = s_315_0;
        // N s_315_2: jump b306
        return block_306(state, tracer, fn_state);
    }
    fn block_316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_316_0: read-var merge#var.1:struct
        let s_316_0: u32 = fn_state.merge_var._1;
        // D s_316_1: write-var u#33523 <= s_316_0
        fn_state.u_33523 = s_316_0;
        // C s_316_2: const #20s : i
        let s_316_2: i128 = 20;
        // D s_316_3: read-var u#33523:u32
        let s_316_3: u32 = fn_state.u_33523;
        // D s_316_4: cast zx s_316_3 -> bv
        let s_316_4: Bits = Bits::new(s_316_3 as u128, 32u16);
        // C s_316_5: const #1s : i64
        let s_316_5: i64 = 1;
        // C s_316_6: cast zx s_316_5 -> i
        let s_316_6: i128 = (i128::try_from(s_316_5).unwrap());
        // C s_316_7: const #7s : i
        let s_316_7: i128 = 7;
        // C s_316_8: add s_316_7 s_316_6
        let s_316_8: i128 = (s_316_7 + s_316_6);
        // D s_316_9: bit-extract s_316_4 s_316_2 s_316_8
        let s_316_9: Bits = (Bits::new(
            ((s_316_4) >> (s_316_2)).value(),
            u16::try_from(s_316_8).unwrap(),
        ));
        // D s_316_10: cast reint s_316_9 -> u8
        let s_316_10: u8 = (s_316_9.value() as u8);
        // D s_316_11: cast zx s_316_10 -> bv
        let s_316_11: Bits = Bits::new(s_316_10 as u128, 8u16);
        // C s_316_12: const #99u : u8
        let s_316_12: u8 = 99;
        // C s_316_13: cast zx s_316_12 -> bv
        let s_316_13: Bits = Bits::new(s_316_12 as u128, 8u16);
        // D s_316_14: cmp-eq s_316_11 s_316_13
        let s_316_14: bool = ((s_316_11) == (s_316_13));
        // N s_316_15: branch s_316_14 b1358 b317
        if s_316_14 {
            return block_1358(state, tracer, fn_state);
        } else {
            return block_317(state, tracer, fn_state);
        };
    }
    fn block_317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_317_0: const #0u : u8
        let s_317_0: bool = false;
        // D s_317_1: write-var gs#409699 <= s_317_0
        fn_state.gs_409699 = s_317_0;
        // N s_317_2: jump b318
        return block_318(state, tracer, fn_state);
    }
    fn block_318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_318_0: read-var gs#409699:u8
        let s_318_0: bool = fn_state.gs_409699;
        // N s_318_1: branch s_318_0 b1354 b319
        if s_318_0 {
            return block_1354(state, tracer, fn_state);
        } else {
            return block_319(state, tracer, fn_state);
        };
    }
    fn block_319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_319_0: const #0u : u8
        let s_319_0: bool = false;
        // D s_319_1: write-var gs#409704 <= s_319_0
        fn_state.gs_409704 = s_319_0;
        // N s_319_2: jump b320
        return block_320(state, tracer, fn_state);
    }
    fn block_320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_320_0: read-var gs#409704:u8
        let s_320_0: bool = fn_state.gs_409704;
        // D s_320_1: not s_320_0
        let s_320_1: bool = !s_320_0;
        // N s_320_2: branch s_320_1 b333 b321
        if s_320_1 {
            return block_333(state, tracer, fn_state);
        } else {
            return block_321(state, tracer, fn_state);
        };
    }
    fn block_321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_321_0: const #3130s : i
        let s_321_0: i128 = 3130;
        // C s_321_1: const #14696u : u32
        let s_321_1: u32 = 14696;
        // N s_321_2: write-reg s_321_1 <= s_321_0
        let s_321_2: () = {
            state.write_register::<i128>(s_321_1 as isize, s_321_0);
            tracer.write_register(s_321_1 as isize, s_321_0);
        };
        // C s_321_3: const #28s : i
        let s_321_3: i128 = 28;
        // C s_321_4: const #4s : i
        let s_321_4: i128 = 4;
        // D s_321_5: read-var u#33523:u32
        let s_321_5: u32 = fn_state.u_33523;
        // D s_321_6: cast zx s_321_5 -> bv
        let s_321_6: Bits = Bits::new(s_321_5 as u128, 32u16);
        // D s_321_7: bit-extract s_321_6 s_321_3 s_321_4
        let s_321_7: Bits = (Bits::new(
            ((s_321_6) >> (s_321_3)).value(),
            u16::try_from(s_321_4).unwrap(),
        ));
        // D s_321_8: cast reint s_321_7 -> u8
        let s_321_8: u8 = (s_321_7.value() as u8);
        // D s_321_9: write-var u#33524 <= s_321_8
        fn_state.u_33524 = s_321_8;
        // C s_321_10: const #16s : i
        let s_321_10: i128 = 16;
        // C s_321_11: const #4s : i
        let s_321_11: i128 = 4;
        // D s_321_12: read-var u#33523:u32
        let s_321_12: u32 = fn_state.u_33523;
        // D s_321_13: cast zx s_321_12 -> bv
        let s_321_13: Bits = Bits::new(s_321_12 as u128, 32u16);
        // D s_321_14: bit-extract s_321_13 s_321_10 s_321_11
        let s_321_14: Bits = (Bits::new(
            ((s_321_13) >> (s_321_10)).value(),
            u16::try_from(s_321_11).unwrap(),
        ));
        // D s_321_15: cast reint s_321_14 -> u8
        let s_321_15: u8 = (s_321_14.value() as u8);
        // D s_321_16: write-var u#33525 <= s_321_15
        fn_state.u_33525 = s_321_15;
        // C s_321_17: const #12s : i
        let s_321_17: i128 = 12;
        // C s_321_18: const #4s : i
        let s_321_18: i128 = 4;
        // D s_321_19: read-var u#33523:u32
        let s_321_19: u32 = fn_state.u_33523;
        // D s_321_20: cast zx s_321_19 -> bv
        let s_321_20: Bits = Bits::new(s_321_19 as u128, 32u16);
        // D s_321_21: bit-extract s_321_20 s_321_17 s_321_18
        let s_321_21: Bits = (Bits::new(
            ((s_321_20) >> (s_321_17)).value(),
            u16::try_from(s_321_18).unwrap(),
        ));
        // D s_321_22: cast reint s_321_21 -> u8
        let s_321_22: u8 = (s_321_21.value() as u8);
        // D s_321_23: write-var u#33526 <= s_321_22
        fn_state.u_33526 = s_321_22;
        // C s_321_24: const #0s : i
        let s_321_24: i128 = 0;
        // C s_321_25: const #4s : i
        let s_321_25: i128 = 4;
        // D s_321_26: read-var u#33523:u32
        let s_321_26: u32 = fn_state.u_33523;
        // D s_321_27: cast zx s_321_26 -> bv
        let s_321_27: Bits = Bits::new(s_321_26 as u128, 32u16);
        // D s_321_28: bit-extract s_321_27 s_321_24 s_321_25
        let s_321_28: Bits = (Bits::new(
            ((s_321_27) >> (s_321_24)).value(),
            u16::try_from(s_321_25).unwrap(),
        ));
        // D s_321_29: cast reint s_321_28 -> u8
        let s_321_29: u8 = (s_321_28.value() as u8);
        // D s_321_30: write-var u#33527 <= s_321_29
        fn_state.u_33527 = s_321_29;
        // C s_321_31: const #8s : i
        let s_321_31: i128 = 8;
        // D s_321_32: read-var u#33523:u32
        let s_321_32: u32 = fn_state.u_33523;
        // D s_321_33: cast zx s_321_32 -> bv
        let s_321_33: Bits = Bits::new(s_321_32 as u128, 32u16);
        // C s_321_34: const #1u : u64
        let s_321_34: u64 = 1;
        // D s_321_35: bit-extract s_321_33 s_321_31 s_321_34
        let s_321_35: Bits = (Bits::new(
            ((s_321_33) >> (s_321_31)).value(),
            u16::try_from(s_321_34).unwrap(),
        ));
        // D s_321_36: cast reint s_321_35 -> u8
        let s_321_36: bool = ((s_321_35.value()) != 0);
        // C s_321_37: const #0s : i
        let s_321_37: i128 = 0;
        // C s_321_38: const #0u : u64
        let s_321_38: u64 = 0;
        // D s_321_39: cast zx s_321_36 -> u64
        let s_321_39: u64 = (s_321_36 as u64);
        // C s_321_40: const #1u : u64
        let s_321_40: u64 = 1;
        // D s_321_41: and s_321_39 s_321_40
        let s_321_41: u64 = ((s_321_39) & (s_321_40));
        // D s_321_42: cmp-eq s_321_41 s_321_40
        let s_321_42: bool = ((s_321_41) == (s_321_40));
        // D s_321_43: lsl s_321_39 s_321_37
        let s_321_43: u64 = s_321_39 << s_321_37;
        // D s_321_44: or s_321_38 s_321_43
        let s_321_44: u64 = ((s_321_38) | (s_321_43));
        // D s_321_45: cmpl s_321_43
        let s_321_45: u64 = !s_321_43;
        // D s_321_46: and s_321_38 s_321_45
        let s_321_46: u64 = ((s_321_38) & (s_321_45));
        // D s_321_47: select s_321_42 s_321_44 s_321_46
        let s_321_47: u64 = if s_321_42 { s_321_44 } else { s_321_46 };
        // D s_321_48: cast trunc s_321_47 -> u8
        let s_321_48: bool = ((s_321_47) != 0);
        // D s_321_49: cast zx s_321_48 -> bv
        let s_321_49: Bits = Bits::new(s_321_48 as u128, 1u16);
        // C s_321_50: const #1u : u8
        let s_321_50: bool = true;
        // C s_321_51: cast zx s_321_50 -> bv
        let s_321_51: Bits = Bits::new(s_321_50 as u128, 1u16);
        // D s_321_52: cmp-ne s_321_49 s_321_51
        let s_321_52: bool = ((s_321_49) != (s_321_51));
        // N s_321_53: branch s_321_52 b332 b322
        if s_321_52 {
            return block_332(state, tracer, fn_state);
        } else {
            return block_322(state, tracer, fn_state);
        };
    }
    fn block_322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_322_0: const #9s : i
        let s_322_0: i128 = 9;
        // D s_322_1: read-var u#33523:u32
        let s_322_1: u32 = fn_state.u_33523;
        // D s_322_2: cast zx s_322_1 -> bv
        let s_322_2: Bits = Bits::new(s_322_1 as u128, 32u16);
        // C s_322_3: const #1u : u64
        let s_322_3: u64 = 1;
        // D s_322_4: bit-extract s_322_2 s_322_0 s_322_3
        let s_322_4: Bits = (Bits::new(
            ((s_322_2) >> (s_322_0)).value(),
            u16::try_from(s_322_3).unwrap(),
        ));
        // D s_322_5: cast reint s_322_4 -> u8
        let s_322_5: bool = ((s_322_4.value()) != 0);
        // C s_322_6: const #0s : i
        let s_322_6: i128 = 0;
        // C s_322_7: const #0u : u64
        let s_322_7: u64 = 0;
        // D s_322_8: cast zx s_322_5 -> u64
        let s_322_8: u64 = (s_322_5 as u64);
        // C s_322_9: const #1u : u64
        let s_322_9: u64 = 1;
        // D s_322_10: and s_322_8 s_322_9
        let s_322_10: u64 = ((s_322_8) & (s_322_9));
        // D s_322_11: cmp-eq s_322_10 s_322_9
        let s_322_11: bool = ((s_322_10) == (s_322_9));
        // D s_322_12: lsl s_322_8 s_322_6
        let s_322_12: u64 = s_322_8 << s_322_6;
        // D s_322_13: or s_322_7 s_322_12
        let s_322_13: u64 = ((s_322_7) | (s_322_12));
        // D s_322_14: cmpl s_322_12
        let s_322_14: u64 = !s_322_12;
        // D s_322_15: and s_322_7 s_322_14
        let s_322_15: u64 = ((s_322_7) & (s_322_14));
        // D s_322_16: select s_322_11 s_322_13 s_322_15
        let s_322_16: u64 = if s_322_11 { s_322_13 } else { s_322_15 };
        // D s_322_17: cast trunc s_322_16 -> u8
        let s_322_17: bool = ((s_322_16) != 0);
        // D s_322_18: cast zx s_322_17 -> bv
        let s_322_18: Bits = Bits::new(s_322_17 as u128, 1u16);
        // C s_322_19: const #1u : u8
        let s_322_19: bool = true;
        // C s_322_20: cast zx s_322_19 -> bv
        let s_322_20: Bits = Bits::new(s_322_19 as u128, 1u16);
        // D s_322_21: cmp-ne s_322_18 s_322_20
        let s_322_21: bool = ((s_322_18) != (s_322_20));
        // D s_322_22: write-var gs#409719 <= s_322_21
        fn_state.gs_409719 = s_322_21;
        // N s_322_23: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_323_0: read-var gs#409719:u8
        let s_323_0: bool = fn_state.gs_409719;
        // N s_323_1: branch s_323_0 b331 b324
        if s_323_0 {
            return block_331(state, tracer, fn_state);
        } else {
            return block_324(state, tracer, fn_state);
        };
    }
    fn block_324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_324_0: const #10s : i
        let s_324_0: i128 = 10;
        // D s_324_1: read-var u#33523:u32
        let s_324_1: u32 = fn_state.u_33523;
        // D s_324_2: cast zx s_324_1 -> bv
        let s_324_2: Bits = Bits::new(s_324_1 as u128, 32u16);
        // C s_324_3: const #1u : u64
        let s_324_3: u64 = 1;
        // D s_324_4: bit-extract s_324_2 s_324_0 s_324_3
        let s_324_4: Bits = (Bits::new(
            ((s_324_2) >> (s_324_0)).value(),
            u16::try_from(s_324_3).unwrap(),
        ));
        // D s_324_5: cast reint s_324_4 -> u8
        let s_324_5: bool = ((s_324_4.value()) != 0);
        // C s_324_6: const #0s : i
        let s_324_6: i128 = 0;
        // C s_324_7: const #0u : u64
        let s_324_7: u64 = 0;
        // D s_324_8: cast zx s_324_5 -> u64
        let s_324_8: u64 = (s_324_5 as u64);
        // C s_324_9: const #1u : u64
        let s_324_9: u64 = 1;
        // D s_324_10: and s_324_8 s_324_9
        let s_324_10: u64 = ((s_324_8) & (s_324_9));
        // D s_324_11: cmp-eq s_324_10 s_324_9
        let s_324_11: bool = ((s_324_10) == (s_324_9));
        // D s_324_12: lsl s_324_8 s_324_6
        let s_324_12: u64 = s_324_8 << s_324_6;
        // D s_324_13: or s_324_7 s_324_12
        let s_324_13: u64 = ((s_324_7) | (s_324_12));
        // D s_324_14: cmpl s_324_12
        let s_324_14: u64 = !s_324_12;
        // D s_324_15: and s_324_7 s_324_14
        let s_324_15: u64 = ((s_324_7) & (s_324_14));
        // D s_324_16: select s_324_11 s_324_13 s_324_15
        let s_324_16: u64 = if s_324_11 { s_324_13 } else { s_324_15 };
        // D s_324_17: cast trunc s_324_16 -> u8
        let s_324_17: bool = ((s_324_16) != 0);
        // D s_324_18: cast zx s_324_17 -> bv
        let s_324_18: Bits = Bits::new(s_324_17 as u128, 1u16);
        // C s_324_19: const #1u : u8
        let s_324_19: bool = true;
        // C s_324_20: cast zx s_324_19 -> bv
        let s_324_20: Bits = Bits::new(s_324_19 as u128, 1u16);
        // D s_324_21: cmp-ne s_324_18 s_324_20
        let s_324_21: bool = ((s_324_18) != (s_324_20));
        // D s_324_22: write-var gs#409722 <= s_324_21
        fn_state.gs_409722 = s_324_21;
        // N s_324_23: jump b325
        return block_325(state, tracer, fn_state);
    }
    fn block_325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_325_0: read-var gs#409722:u8
        let s_325_0: bool = fn_state.gs_409722;
        // N s_325_1: branch s_325_0 b330 b326
        if s_325_0 {
            return block_330(state, tracer, fn_state);
        } else {
            return block_326(state, tracer, fn_state);
        };
    }
    fn block_326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_326_0: const #11s : i
        let s_326_0: i128 = 11;
        // D s_326_1: read-var u#33523:u32
        let s_326_1: u32 = fn_state.u_33523;
        // D s_326_2: cast zx s_326_1 -> bv
        let s_326_2: Bits = Bits::new(s_326_1 as u128, 32u16);
        // C s_326_3: const #1u : u64
        let s_326_3: u64 = 1;
        // D s_326_4: bit-extract s_326_2 s_326_0 s_326_3
        let s_326_4: Bits = (Bits::new(
            ((s_326_2) >> (s_326_0)).value(),
            u16::try_from(s_326_3).unwrap(),
        ));
        // D s_326_5: cast reint s_326_4 -> u8
        let s_326_5: bool = ((s_326_4.value()) != 0);
        // C s_326_6: const #0s : i
        let s_326_6: i128 = 0;
        // C s_326_7: const #0u : u64
        let s_326_7: u64 = 0;
        // D s_326_8: cast zx s_326_5 -> u64
        let s_326_8: u64 = (s_326_5 as u64);
        // C s_326_9: const #1u : u64
        let s_326_9: u64 = 1;
        // D s_326_10: and s_326_8 s_326_9
        let s_326_10: u64 = ((s_326_8) & (s_326_9));
        // D s_326_11: cmp-eq s_326_10 s_326_9
        let s_326_11: bool = ((s_326_10) == (s_326_9));
        // D s_326_12: lsl s_326_8 s_326_6
        let s_326_12: u64 = s_326_8 << s_326_6;
        // D s_326_13: or s_326_7 s_326_12
        let s_326_13: u64 = ((s_326_7) | (s_326_12));
        // D s_326_14: cmpl s_326_12
        let s_326_14: u64 = !s_326_12;
        // D s_326_15: and s_326_7 s_326_14
        let s_326_15: u64 = ((s_326_7) & (s_326_14));
        // D s_326_16: select s_326_11 s_326_13 s_326_15
        let s_326_16: u64 = if s_326_11 { s_326_13 } else { s_326_15 };
        // D s_326_17: cast trunc s_326_16 -> u8
        let s_326_17: bool = ((s_326_16) != 0);
        // D s_326_18: cast zx s_326_17 -> bv
        let s_326_18: Bits = Bits::new(s_326_17 as u128, 1u16);
        // C s_326_19: const #1u : u8
        let s_326_19: bool = true;
        // C s_326_20: cast zx s_326_19 -> bv
        let s_326_20: Bits = Bits::new(s_326_19 as u128, 1u16);
        // D s_326_21: cmp-ne s_326_18 s_326_20
        let s_326_21: bool = ((s_326_18) != (s_326_20));
        // D s_326_22: write-var gs#409725 <= s_326_21
        fn_state.gs_409725 = s_326_21;
        // N s_326_23: jump b327
        return block_327(state, tracer, fn_state);
    }
    fn block_327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_327_0: read-var gs#409725:u8
        let s_327_0: bool = fn_state.gs_409725;
        // N s_327_1: branch s_327_0 b329 b328
        if s_327_0 {
            return block_329(state, tracer, fn_state);
        } else {
            return block_328(state, tracer, fn_state);
        };
    }
    fn block_328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_328_0: read-var u#33524:u8
        let s_328_0: u8 = fn_state.u_33524;
        // D s_328_1: read-var u#33525:u8
        let s_328_1: u8 = fn_state.u_33525;
        // D s_328_2: read-var u#33526:u8
        let s_328_2: u8 = fn_state.u_33526;
        // D s_328_3: read-var u#33527:u8
        let s_328_3: u8 = fn_state.u_33527;
        // D s_328_4: call decode_aarch32_instrs_SHADD16_A1enc_A_txt(s_328_0, s_328_1, s_328_2, s_328_3)
        let s_328_4: () = decode_aarch32_instrs_SHADD16_A1enc_A_txt(
            state,
            tracer,
            s_328_0,
            s_328_1,
            s_328_2,
            s_328_3,
        );
        // N s_328_5: return
        return;
    }
    fn block_329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_329_0: panic
        panic!("{:?}", ());
        // N s_329_1: return
        return;
    }
    fn block_330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_330_0: const #1u : u8
        let s_330_0: bool = true;
        // D s_330_1: write-var gs#409725 <= s_330_0
        fn_state.gs_409725 = s_330_0;
        // N s_330_2: jump b327
        return block_327(state, tracer, fn_state);
    }
    fn block_331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_331_0: const #1u : u8
        let s_331_0: bool = true;
        // D s_331_1: write-var gs#409722 <= s_331_0
        fn_state.gs_409722 = s_331_0;
        // N s_331_2: jump b325
        return block_325(state, tracer, fn_state);
    }
    fn block_332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_332_0: const #1u : u8
        let s_332_0: bool = true;
        // D s_332_1: write-var gs#409719 <= s_332_0
        fn_state.gs_409719 = s_332_0;
        // N s_332_2: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_333_0: read-var merge#var.1:struct
        let s_333_0: u32 = fn_state.merge_var._1;
        // D s_333_1: write-var u#33529 <= s_333_0
        fn_state.u_33529 = s_333_0;
        // C s_333_2: const #20s : i
        let s_333_2: i128 = 20;
        // D s_333_3: read-var u#33529:u32
        let s_333_3: u32 = fn_state.u_33529;
        // D s_333_4: cast zx s_333_3 -> bv
        let s_333_4: Bits = Bits::new(s_333_3 as u128, 32u16);
        // C s_333_5: const #1s : i64
        let s_333_5: i64 = 1;
        // C s_333_6: cast zx s_333_5 -> i
        let s_333_6: i128 = (i128::try_from(s_333_5).unwrap());
        // C s_333_7: const #7s : i
        let s_333_7: i128 = 7;
        // C s_333_8: add s_333_7 s_333_6
        let s_333_8: i128 = (s_333_7 + s_333_6);
        // D s_333_9: bit-extract s_333_4 s_333_2 s_333_8
        let s_333_9: Bits = (Bits::new(
            ((s_333_4) >> (s_333_2)).value(),
            u16::try_from(s_333_8).unwrap(),
        ));
        // D s_333_10: cast reint s_333_9 -> u8
        let s_333_10: u8 = (s_333_9.value() as u8);
        // D s_333_11: cast zx s_333_10 -> bv
        let s_333_11: Bits = Bits::new(s_333_10 as u128, 8u16);
        // C s_333_12: const #99u : u8
        let s_333_12: u8 = 99;
        // C s_333_13: cast zx s_333_12 -> bv
        let s_333_13: Bits = Bits::new(s_333_12 as u128, 8u16);
        // D s_333_14: cmp-eq s_333_11 s_333_13
        let s_333_14: bool = ((s_333_11) == (s_333_13));
        // N s_333_15: branch s_333_14 b1353 b334
        if s_333_14 {
            return block_1353(state, tracer, fn_state);
        } else {
            return block_334(state, tracer, fn_state);
        };
    }
    fn block_334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_334_0: const #0u : u8
        let s_334_0: bool = false;
        // D s_334_1: write-var gs#409731 <= s_334_0
        fn_state.gs_409731 = s_334_0;
        // N s_334_2: jump b335
        return block_335(state, tracer, fn_state);
    }
    fn block_335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_335_0: read-var gs#409731:u8
        let s_335_0: bool = fn_state.gs_409731;
        // N s_335_1: branch s_335_0 b1349 b336
        if s_335_0 {
            return block_1349(state, tracer, fn_state);
        } else {
            return block_336(state, tracer, fn_state);
        };
    }
    fn block_336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_336_0: const #0u : u8
        let s_336_0: bool = false;
        // D s_336_1: write-var gs#409736 <= s_336_0
        fn_state.gs_409736 = s_336_0;
        // N s_336_2: jump b337
        return block_337(state, tracer, fn_state);
    }
    fn block_337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_337_0: read-var gs#409736:u8
        let s_337_0: bool = fn_state.gs_409736;
        // D s_337_1: not s_337_0
        let s_337_1: bool = !s_337_0;
        // N s_337_2: branch s_337_1 b350 b338
        if s_337_1 {
            return block_350(state, tracer, fn_state);
        } else {
            return block_338(state, tracer, fn_state);
        };
    }
    fn block_338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_338_0: const #3132s : i
        let s_338_0: i128 = 3132;
        // C s_338_1: const #14696u : u32
        let s_338_1: u32 = 14696;
        // N s_338_2: write-reg s_338_1 <= s_338_0
        let s_338_2: () = {
            state.write_register::<i128>(s_338_1 as isize, s_338_0);
            tracer.write_register(s_338_1 as isize, s_338_0);
        };
        // C s_338_3: const #28s : i
        let s_338_3: i128 = 28;
        // C s_338_4: const #4s : i
        let s_338_4: i128 = 4;
        // D s_338_5: read-var u#33529:u32
        let s_338_5: u32 = fn_state.u_33529;
        // D s_338_6: cast zx s_338_5 -> bv
        let s_338_6: Bits = Bits::new(s_338_5 as u128, 32u16);
        // D s_338_7: bit-extract s_338_6 s_338_3 s_338_4
        let s_338_7: Bits = (Bits::new(
            ((s_338_6) >> (s_338_3)).value(),
            u16::try_from(s_338_4).unwrap(),
        ));
        // D s_338_8: cast reint s_338_7 -> u8
        let s_338_8: u8 = (s_338_7.value() as u8);
        // D s_338_9: write-var u#33530 <= s_338_8
        fn_state.u_33530 = s_338_8;
        // C s_338_10: const #16s : i
        let s_338_10: i128 = 16;
        // C s_338_11: const #4s : i
        let s_338_11: i128 = 4;
        // D s_338_12: read-var u#33529:u32
        let s_338_12: u32 = fn_state.u_33529;
        // D s_338_13: cast zx s_338_12 -> bv
        let s_338_13: Bits = Bits::new(s_338_12 as u128, 32u16);
        // D s_338_14: bit-extract s_338_13 s_338_10 s_338_11
        let s_338_14: Bits = (Bits::new(
            ((s_338_13) >> (s_338_10)).value(),
            u16::try_from(s_338_11).unwrap(),
        ));
        // D s_338_15: cast reint s_338_14 -> u8
        let s_338_15: u8 = (s_338_14.value() as u8);
        // D s_338_16: write-var u#33531 <= s_338_15
        fn_state.u_33531 = s_338_15;
        // C s_338_17: const #12s : i
        let s_338_17: i128 = 12;
        // C s_338_18: const #4s : i
        let s_338_18: i128 = 4;
        // D s_338_19: read-var u#33529:u32
        let s_338_19: u32 = fn_state.u_33529;
        // D s_338_20: cast zx s_338_19 -> bv
        let s_338_20: Bits = Bits::new(s_338_19 as u128, 32u16);
        // D s_338_21: bit-extract s_338_20 s_338_17 s_338_18
        let s_338_21: Bits = (Bits::new(
            ((s_338_20) >> (s_338_17)).value(),
            u16::try_from(s_338_18).unwrap(),
        ));
        // D s_338_22: cast reint s_338_21 -> u8
        let s_338_22: u8 = (s_338_21.value() as u8);
        // D s_338_23: write-var u#33532 <= s_338_22
        fn_state.u_33532 = s_338_22;
        // C s_338_24: const #0s : i
        let s_338_24: i128 = 0;
        // C s_338_25: const #4s : i
        let s_338_25: i128 = 4;
        // D s_338_26: read-var u#33529:u32
        let s_338_26: u32 = fn_state.u_33529;
        // D s_338_27: cast zx s_338_26 -> bv
        let s_338_27: Bits = Bits::new(s_338_26 as u128, 32u16);
        // D s_338_28: bit-extract s_338_27 s_338_24 s_338_25
        let s_338_28: Bits = (Bits::new(
            ((s_338_27) >> (s_338_24)).value(),
            u16::try_from(s_338_25).unwrap(),
        ));
        // D s_338_29: cast reint s_338_28 -> u8
        let s_338_29: u8 = (s_338_28.value() as u8);
        // D s_338_30: write-var u#33533 <= s_338_29
        fn_state.u_33533 = s_338_29;
        // C s_338_31: const #8s : i
        let s_338_31: i128 = 8;
        // D s_338_32: read-var u#33529:u32
        let s_338_32: u32 = fn_state.u_33529;
        // D s_338_33: cast zx s_338_32 -> bv
        let s_338_33: Bits = Bits::new(s_338_32 as u128, 32u16);
        // C s_338_34: const #1u : u64
        let s_338_34: u64 = 1;
        // D s_338_35: bit-extract s_338_33 s_338_31 s_338_34
        let s_338_35: Bits = (Bits::new(
            ((s_338_33) >> (s_338_31)).value(),
            u16::try_from(s_338_34).unwrap(),
        ));
        // D s_338_36: cast reint s_338_35 -> u8
        let s_338_36: bool = ((s_338_35.value()) != 0);
        // C s_338_37: const #0s : i
        let s_338_37: i128 = 0;
        // C s_338_38: const #0u : u64
        let s_338_38: u64 = 0;
        // D s_338_39: cast zx s_338_36 -> u64
        let s_338_39: u64 = (s_338_36 as u64);
        // C s_338_40: const #1u : u64
        let s_338_40: u64 = 1;
        // D s_338_41: and s_338_39 s_338_40
        let s_338_41: u64 = ((s_338_39) & (s_338_40));
        // D s_338_42: cmp-eq s_338_41 s_338_40
        let s_338_42: bool = ((s_338_41) == (s_338_40));
        // D s_338_43: lsl s_338_39 s_338_37
        let s_338_43: u64 = s_338_39 << s_338_37;
        // D s_338_44: or s_338_38 s_338_43
        let s_338_44: u64 = ((s_338_38) | (s_338_43));
        // D s_338_45: cmpl s_338_43
        let s_338_45: u64 = !s_338_43;
        // D s_338_46: and s_338_38 s_338_45
        let s_338_46: u64 = ((s_338_38) & (s_338_45));
        // D s_338_47: select s_338_42 s_338_44 s_338_46
        let s_338_47: u64 = if s_338_42 { s_338_44 } else { s_338_46 };
        // D s_338_48: cast trunc s_338_47 -> u8
        let s_338_48: bool = ((s_338_47) != 0);
        // D s_338_49: cast zx s_338_48 -> bv
        let s_338_49: Bits = Bits::new(s_338_48 as u128, 1u16);
        // C s_338_50: const #1u : u8
        let s_338_50: bool = true;
        // C s_338_51: cast zx s_338_50 -> bv
        let s_338_51: Bits = Bits::new(s_338_50 as u128, 1u16);
        // D s_338_52: cmp-ne s_338_49 s_338_51
        let s_338_52: bool = ((s_338_49) != (s_338_51));
        // N s_338_53: branch s_338_52 b349 b339
        if s_338_52 {
            return block_349(state, tracer, fn_state);
        } else {
            return block_339(state, tracer, fn_state);
        };
    }
    fn block_339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_339_0: const #9s : i
        let s_339_0: i128 = 9;
        // D s_339_1: read-var u#33529:u32
        let s_339_1: u32 = fn_state.u_33529;
        // D s_339_2: cast zx s_339_1 -> bv
        let s_339_2: Bits = Bits::new(s_339_1 as u128, 32u16);
        // C s_339_3: const #1u : u64
        let s_339_3: u64 = 1;
        // D s_339_4: bit-extract s_339_2 s_339_0 s_339_3
        let s_339_4: Bits = (Bits::new(
            ((s_339_2) >> (s_339_0)).value(),
            u16::try_from(s_339_3).unwrap(),
        ));
        // D s_339_5: cast reint s_339_4 -> u8
        let s_339_5: bool = ((s_339_4.value()) != 0);
        // C s_339_6: const #0s : i
        let s_339_6: i128 = 0;
        // C s_339_7: const #0u : u64
        let s_339_7: u64 = 0;
        // D s_339_8: cast zx s_339_5 -> u64
        let s_339_8: u64 = (s_339_5 as u64);
        // C s_339_9: const #1u : u64
        let s_339_9: u64 = 1;
        // D s_339_10: and s_339_8 s_339_9
        let s_339_10: u64 = ((s_339_8) & (s_339_9));
        // D s_339_11: cmp-eq s_339_10 s_339_9
        let s_339_11: bool = ((s_339_10) == (s_339_9));
        // D s_339_12: lsl s_339_8 s_339_6
        let s_339_12: u64 = s_339_8 << s_339_6;
        // D s_339_13: or s_339_7 s_339_12
        let s_339_13: u64 = ((s_339_7) | (s_339_12));
        // D s_339_14: cmpl s_339_12
        let s_339_14: u64 = !s_339_12;
        // D s_339_15: and s_339_7 s_339_14
        let s_339_15: u64 = ((s_339_7) & (s_339_14));
        // D s_339_16: select s_339_11 s_339_13 s_339_15
        let s_339_16: u64 = if s_339_11 { s_339_13 } else { s_339_15 };
        // D s_339_17: cast trunc s_339_16 -> u8
        let s_339_17: bool = ((s_339_16) != 0);
        // D s_339_18: cast zx s_339_17 -> bv
        let s_339_18: Bits = Bits::new(s_339_17 as u128, 1u16);
        // C s_339_19: const #1u : u8
        let s_339_19: bool = true;
        // C s_339_20: cast zx s_339_19 -> bv
        let s_339_20: Bits = Bits::new(s_339_19 as u128, 1u16);
        // D s_339_21: cmp-ne s_339_18 s_339_20
        let s_339_21: bool = ((s_339_18) != (s_339_20));
        // D s_339_22: write-var gs#409751 <= s_339_21
        fn_state.gs_409751 = s_339_21;
        // N s_339_23: jump b340
        return block_340(state, tracer, fn_state);
    }
    fn block_340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_340_0: read-var gs#409751:u8
        let s_340_0: bool = fn_state.gs_409751;
        // N s_340_1: branch s_340_0 b348 b341
        if s_340_0 {
            return block_348(state, tracer, fn_state);
        } else {
            return block_341(state, tracer, fn_state);
        };
    }
    fn block_341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_341_0: const #10s : i
        let s_341_0: i128 = 10;
        // D s_341_1: read-var u#33529:u32
        let s_341_1: u32 = fn_state.u_33529;
        // D s_341_2: cast zx s_341_1 -> bv
        let s_341_2: Bits = Bits::new(s_341_1 as u128, 32u16);
        // C s_341_3: const #1u : u64
        let s_341_3: u64 = 1;
        // D s_341_4: bit-extract s_341_2 s_341_0 s_341_3
        let s_341_4: Bits = (Bits::new(
            ((s_341_2) >> (s_341_0)).value(),
            u16::try_from(s_341_3).unwrap(),
        ));
        // D s_341_5: cast reint s_341_4 -> u8
        let s_341_5: bool = ((s_341_4.value()) != 0);
        // C s_341_6: const #0s : i
        let s_341_6: i128 = 0;
        // C s_341_7: const #0u : u64
        let s_341_7: u64 = 0;
        // D s_341_8: cast zx s_341_5 -> u64
        let s_341_8: u64 = (s_341_5 as u64);
        // C s_341_9: const #1u : u64
        let s_341_9: u64 = 1;
        // D s_341_10: and s_341_8 s_341_9
        let s_341_10: u64 = ((s_341_8) & (s_341_9));
        // D s_341_11: cmp-eq s_341_10 s_341_9
        let s_341_11: bool = ((s_341_10) == (s_341_9));
        // D s_341_12: lsl s_341_8 s_341_6
        let s_341_12: u64 = s_341_8 << s_341_6;
        // D s_341_13: or s_341_7 s_341_12
        let s_341_13: u64 = ((s_341_7) | (s_341_12));
        // D s_341_14: cmpl s_341_12
        let s_341_14: u64 = !s_341_12;
        // D s_341_15: and s_341_7 s_341_14
        let s_341_15: u64 = ((s_341_7) & (s_341_14));
        // D s_341_16: select s_341_11 s_341_13 s_341_15
        let s_341_16: u64 = if s_341_11 { s_341_13 } else { s_341_15 };
        // D s_341_17: cast trunc s_341_16 -> u8
        let s_341_17: bool = ((s_341_16) != 0);
        // D s_341_18: cast zx s_341_17 -> bv
        let s_341_18: Bits = Bits::new(s_341_17 as u128, 1u16);
        // C s_341_19: const #1u : u8
        let s_341_19: bool = true;
        // C s_341_20: cast zx s_341_19 -> bv
        let s_341_20: Bits = Bits::new(s_341_19 as u128, 1u16);
        // D s_341_21: cmp-ne s_341_18 s_341_20
        let s_341_21: bool = ((s_341_18) != (s_341_20));
        // D s_341_22: write-var gs#409754 <= s_341_21
        fn_state.gs_409754 = s_341_21;
        // N s_341_23: jump b342
        return block_342(state, tracer, fn_state);
    }
    fn block_342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_342_0: read-var gs#409754:u8
        let s_342_0: bool = fn_state.gs_409754;
        // N s_342_1: branch s_342_0 b347 b343
        if s_342_0 {
            return block_347(state, tracer, fn_state);
        } else {
            return block_343(state, tracer, fn_state);
        };
    }
    fn block_343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_343_0: const #11s : i
        let s_343_0: i128 = 11;
        // D s_343_1: read-var u#33529:u32
        let s_343_1: u32 = fn_state.u_33529;
        // D s_343_2: cast zx s_343_1 -> bv
        let s_343_2: Bits = Bits::new(s_343_1 as u128, 32u16);
        // C s_343_3: const #1u : u64
        let s_343_3: u64 = 1;
        // D s_343_4: bit-extract s_343_2 s_343_0 s_343_3
        let s_343_4: Bits = (Bits::new(
            ((s_343_2) >> (s_343_0)).value(),
            u16::try_from(s_343_3).unwrap(),
        ));
        // D s_343_5: cast reint s_343_4 -> u8
        let s_343_5: bool = ((s_343_4.value()) != 0);
        // C s_343_6: const #0s : i
        let s_343_6: i128 = 0;
        // C s_343_7: const #0u : u64
        let s_343_7: u64 = 0;
        // D s_343_8: cast zx s_343_5 -> u64
        let s_343_8: u64 = (s_343_5 as u64);
        // C s_343_9: const #1u : u64
        let s_343_9: u64 = 1;
        // D s_343_10: and s_343_8 s_343_9
        let s_343_10: u64 = ((s_343_8) & (s_343_9));
        // D s_343_11: cmp-eq s_343_10 s_343_9
        let s_343_11: bool = ((s_343_10) == (s_343_9));
        // D s_343_12: lsl s_343_8 s_343_6
        let s_343_12: u64 = s_343_8 << s_343_6;
        // D s_343_13: or s_343_7 s_343_12
        let s_343_13: u64 = ((s_343_7) | (s_343_12));
        // D s_343_14: cmpl s_343_12
        let s_343_14: u64 = !s_343_12;
        // D s_343_15: and s_343_7 s_343_14
        let s_343_15: u64 = ((s_343_7) & (s_343_14));
        // D s_343_16: select s_343_11 s_343_13 s_343_15
        let s_343_16: u64 = if s_343_11 { s_343_13 } else { s_343_15 };
        // D s_343_17: cast trunc s_343_16 -> u8
        let s_343_17: bool = ((s_343_16) != 0);
        // D s_343_18: cast zx s_343_17 -> bv
        let s_343_18: Bits = Bits::new(s_343_17 as u128, 1u16);
        // C s_343_19: const #1u : u8
        let s_343_19: bool = true;
        // C s_343_20: cast zx s_343_19 -> bv
        let s_343_20: Bits = Bits::new(s_343_19 as u128, 1u16);
        // D s_343_21: cmp-ne s_343_18 s_343_20
        let s_343_21: bool = ((s_343_18) != (s_343_20));
        // D s_343_22: write-var gs#409757 <= s_343_21
        fn_state.gs_409757 = s_343_21;
        // N s_343_23: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_344_0: read-var gs#409757:u8
        let s_344_0: bool = fn_state.gs_409757;
        // N s_344_1: branch s_344_0 b346 b345
        if s_344_0 {
            return block_346(state, tracer, fn_state);
        } else {
            return block_345(state, tracer, fn_state);
        };
    }
    fn block_345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_345_0: read-var u#33530:u8
        let s_345_0: u8 = fn_state.u_33530;
        // D s_345_1: read-var u#33531:u8
        let s_345_1: u8 = fn_state.u_33531;
        // D s_345_2: read-var u#33532:u8
        let s_345_2: u8 = fn_state.u_33532;
        // D s_345_3: read-var u#33533:u8
        let s_345_3: u8 = fn_state.u_33533;
        // D s_345_4: call decode_aarch32_instrs_SHADD8_A1enc_A_txt(s_345_0, s_345_1, s_345_2, s_345_3)
        let s_345_4: () = decode_aarch32_instrs_SHADD8_A1enc_A_txt(
            state,
            tracer,
            s_345_0,
            s_345_1,
            s_345_2,
            s_345_3,
        );
        // N s_345_5: return
        return;
    }
    fn block_346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_346_0: panic
        panic!("{:?}", ());
        // N s_346_1: return
        return;
    }
    fn block_347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_347_0: const #1u : u8
        let s_347_0: bool = true;
        // D s_347_1: write-var gs#409757 <= s_347_0
        fn_state.gs_409757 = s_347_0;
        // N s_347_2: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_348_0: const #1u : u8
        let s_348_0: bool = true;
        // D s_348_1: write-var gs#409754 <= s_348_0
        fn_state.gs_409754 = s_348_0;
        // N s_348_2: jump b342
        return block_342(state, tracer, fn_state);
    }
    fn block_349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_349_0: const #1u : u8
        let s_349_0: bool = true;
        // D s_349_1: write-var gs#409751 <= s_349_0
        fn_state.gs_409751 = s_349_0;
        // N s_349_2: jump b340
        return block_340(state, tracer, fn_state);
    }
    fn block_350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_350_0: read-var merge#var.1:struct
        let s_350_0: u32 = fn_state.merge_var._1;
        // D s_350_1: write-var u#33535 <= s_350_0
        fn_state.u_33535 = s_350_0;
        // C s_350_2: const #20s : i
        let s_350_2: i128 = 20;
        // D s_350_3: read-var u#33535:u32
        let s_350_3: u32 = fn_state.u_33535;
        // D s_350_4: cast zx s_350_3 -> bv
        let s_350_4: Bits = Bits::new(s_350_3 as u128, 32u16);
        // C s_350_5: const #1s : i64
        let s_350_5: i64 = 1;
        // C s_350_6: cast zx s_350_5 -> i
        let s_350_6: i128 = (i128::try_from(s_350_5).unwrap());
        // C s_350_7: const #7s : i
        let s_350_7: i128 = 7;
        // C s_350_8: add s_350_7 s_350_6
        let s_350_8: i128 = (s_350_7 + s_350_6);
        // D s_350_9: bit-extract s_350_4 s_350_2 s_350_8
        let s_350_9: Bits = (Bits::new(
            ((s_350_4) >> (s_350_2)).value(),
            u16::try_from(s_350_8).unwrap(),
        ));
        // D s_350_10: cast reint s_350_9 -> u8
        let s_350_10: u8 = (s_350_9.value() as u8);
        // D s_350_11: cast zx s_350_10 -> bv
        let s_350_11: Bits = Bits::new(s_350_10 as u128, 8u16);
        // C s_350_12: const #99u : u8
        let s_350_12: u8 = 99;
        // C s_350_13: cast zx s_350_12 -> bv
        let s_350_13: Bits = Bits::new(s_350_12 as u128, 8u16);
        // D s_350_14: cmp-eq s_350_11 s_350_13
        let s_350_14: bool = ((s_350_11) == (s_350_13));
        // N s_350_15: branch s_350_14 b1348 b351
        if s_350_14 {
            return block_1348(state, tracer, fn_state);
        } else {
            return block_351(state, tracer, fn_state);
        };
    }
    fn block_351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_351_0: const #0u : u8
        let s_351_0: bool = false;
        // D s_351_1: write-var gs#409763 <= s_351_0
        fn_state.gs_409763 = s_351_0;
        // N s_351_2: jump b352
        return block_352(state, tracer, fn_state);
    }
    fn block_352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_352_0: read-var gs#409763:u8
        let s_352_0: bool = fn_state.gs_409763;
        // N s_352_1: branch s_352_0 b1344 b353
        if s_352_0 {
            return block_1344(state, tracer, fn_state);
        } else {
            return block_353(state, tracer, fn_state);
        };
    }
    fn block_353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_353_0: const #0u : u8
        let s_353_0: bool = false;
        // D s_353_1: write-var gs#409768 <= s_353_0
        fn_state.gs_409768 = s_353_0;
        // N s_353_2: jump b354
        return block_354(state, tracer, fn_state);
    }
    fn block_354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_354_0: read-var gs#409768:u8
        let s_354_0: bool = fn_state.gs_409768;
        // D s_354_1: not s_354_0
        let s_354_1: bool = !s_354_0;
        // N s_354_2: branch s_354_1 b367 b355
        if s_354_1 {
            return block_367(state, tracer, fn_state);
        } else {
            return block_355(state, tracer, fn_state);
        };
    }
    fn block_355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_355_0: const #3134s : i
        let s_355_0: i128 = 3134;
        // C s_355_1: const #14696u : u32
        let s_355_1: u32 = 14696;
        // N s_355_2: write-reg s_355_1 <= s_355_0
        let s_355_2: () = {
            state.write_register::<i128>(s_355_1 as isize, s_355_0);
            tracer.write_register(s_355_1 as isize, s_355_0);
        };
        // C s_355_3: const #28s : i
        let s_355_3: i128 = 28;
        // C s_355_4: const #4s : i
        let s_355_4: i128 = 4;
        // D s_355_5: read-var u#33535:u32
        let s_355_5: u32 = fn_state.u_33535;
        // D s_355_6: cast zx s_355_5 -> bv
        let s_355_6: Bits = Bits::new(s_355_5 as u128, 32u16);
        // D s_355_7: bit-extract s_355_6 s_355_3 s_355_4
        let s_355_7: Bits = (Bits::new(
            ((s_355_6) >> (s_355_3)).value(),
            u16::try_from(s_355_4).unwrap(),
        ));
        // D s_355_8: cast reint s_355_7 -> u8
        let s_355_8: u8 = (s_355_7.value() as u8);
        // D s_355_9: write-var u#33536 <= s_355_8
        fn_state.u_33536 = s_355_8;
        // C s_355_10: const #16s : i
        let s_355_10: i128 = 16;
        // C s_355_11: const #4s : i
        let s_355_11: i128 = 4;
        // D s_355_12: read-var u#33535:u32
        let s_355_12: u32 = fn_state.u_33535;
        // D s_355_13: cast zx s_355_12 -> bv
        let s_355_13: Bits = Bits::new(s_355_12 as u128, 32u16);
        // D s_355_14: bit-extract s_355_13 s_355_10 s_355_11
        let s_355_14: Bits = (Bits::new(
            ((s_355_13) >> (s_355_10)).value(),
            u16::try_from(s_355_11).unwrap(),
        ));
        // D s_355_15: cast reint s_355_14 -> u8
        let s_355_15: u8 = (s_355_14.value() as u8);
        // D s_355_16: write-var u#33537 <= s_355_15
        fn_state.u_33537 = s_355_15;
        // C s_355_17: const #12s : i
        let s_355_17: i128 = 12;
        // C s_355_18: const #4s : i
        let s_355_18: i128 = 4;
        // D s_355_19: read-var u#33535:u32
        let s_355_19: u32 = fn_state.u_33535;
        // D s_355_20: cast zx s_355_19 -> bv
        let s_355_20: Bits = Bits::new(s_355_19 as u128, 32u16);
        // D s_355_21: bit-extract s_355_20 s_355_17 s_355_18
        let s_355_21: Bits = (Bits::new(
            ((s_355_20) >> (s_355_17)).value(),
            u16::try_from(s_355_18).unwrap(),
        ));
        // D s_355_22: cast reint s_355_21 -> u8
        let s_355_22: u8 = (s_355_21.value() as u8);
        // D s_355_23: write-var u#33538 <= s_355_22
        fn_state.u_33538 = s_355_22;
        // C s_355_24: const #0s : i
        let s_355_24: i128 = 0;
        // C s_355_25: const #4s : i
        let s_355_25: i128 = 4;
        // D s_355_26: read-var u#33535:u32
        let s_355_26: u32 = fn_state.u_33535;
        // D s_355_27: cast zx s_355_26 -> bv
        let s_355_27: Bits = Bits::new(s_355_26 as u128, 32u16);
        // D s_355_28: bit-extract s_355_27 s_355_24 s_355_25
        let s_355_28: Bits = (Bits::new(
            ((s_355_27) >> (s_355_24)).value(),
            u16::try_from(s_355_25).unwrap(),
        ));
        // D s_355_29: cast reint s_355_28 -> u8
        let s_355_29: u8 = (s_355_28.value() as u8);
        // D s_355_30: write-var u#33539 <= s_355_29
        fn_state.u_33539 = s_355_29;
        // C s_355_31: const #8s : i
        let s_355_31: i128 = 8;
        // D s_355_32: read-var u#33535:u32
        let s_355_32: u32 = fn_state.u_33535;
        // D s_355_33: cast zx s_355_32 -> bv
        let s_355_33: Bits = Bits::new(s_355_32 as u128, 32u16);
        // C s_355_34: const #1u : u64
        let s_355_34: u64 = 1;
        // D s_355_35: bit-extract s_355_33 s_355_31 s_355_34
        let s_355_35: Bits = (Bits::new(
            ((s_355_33) >> (s_355_31)).value(),
            u16::try_from(s_355_34).unwrap(),
        ));
        // D s_355_36: cast reint s_355_35 -> u8
        let s_355_36: bool = ((s_355_35.value()) != 0);
        // C s_355_37: const #0s : i
        let s_355_37: i128 = 0;
        // C s_355_38: const #0u : u64
        let s_355_38: u64 = 0;
        // D s_355_39: cast zx s_355_36 -> u64
        let s_355_39: u64 = (s_355_36 as u64);
        // C s_355_40: const #1u : u64
        let s_355_40: u64 = 1;
        // D s_355_41: and s_355_39 s_355_40
        let s_355_41: u64 = ((s_355_39) & (s_355_40));
        // D s_355_42: cmp-eq s_355_41 s_355_40
        let s_355_42: bool = ((s_355_41) == (s_355_40));
        // D s_355_43: lsl s_355_39 s_355_37
        let s_355_43: u64 = s_355_39 << s_355_37;
        // D s_355_44: or s_355_38 s_355_43
        let s_355_44: u64 = ((s_355_38) | (s_355_43));
        // D s_355_45: cmpl s_355_43
        let s_355_45: u64 = !s_355_43;
        // D s_355_46: and s_355_38 s_355_45
        let s_355_46: u64 = ((s_355_38) & (s_355_45));
        // D s_355_47: select s_355_42 s_355_44 s_355_46
        let s_355_47: u64 = if s_355_42 { s_355_44 } else { s_355_46 };
        // D s_355_48: cast trunc s_355_47 -> u8
        let s_355_48: bool = ((s_355_47) != 0);
        // D s_355_49: cast zx s_355_48 -> bv
        let s_355_49: Bits = Bits::new(s_355_48 as u128, 1u16);
        // C s_355_50: const #1u : u8
        let s_355_50: bool = true;
        // C s_355_51: cast zx s_355_50 -> bv
        let s_355_51: Bits = Bits::new(s_355_50 as u128, 1u16);
        // D s_355_52: cmp-ne s_355_49 s_355_51
        let s_355_52: bool = ((s_355_49) != (s_355_51));
        // N s_355_53: branch s_355_52 b366 b356
        if s_355_52 {
            return block_366(state, tracer, fn_state);
        } else {
            return block_356(state, tracer, fn_state);
        };
    }
    fn block_356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_356_0: const #9s : i
        let s_356_0: i128 = 9;
        // D s_356_1: read-var u#33535:u32
        let s_356_1: u32 = fn_state.u_33535;
        // D s_356_2: cast zx s_356_1 -> bv
        let s_356_2: Bits = Bits::new(s_356_1 as u128, 32u16);
        // C s_356_3: const #1u : u64
        let s_356_3: u64 = 1;
        // D s_356_4: bit-extract s_356_2 s_356_0 s_356_3
        let s_356_4: Bits = (Bits::new(
            ((s_356_2) >> (s_356_0)).value(),
            u16::try_from(s_356_3).unwrap(),
        ));
        // D s_356_5: cast reint s_356_4 -> u8
        let s_356_5: bool = ((s_356_4.value()) != 0);
        // C s_356_6: const #0s : i
        let s_356_6: i128 = 0;
        // C s_356_7: const #0u : u64
        let s_356_7: u64 = 0;
        // D s_356_8: cast zx s_356_5 -> u64
        let s_356_8: u64 = (s_356_5 as u64);
        // C s_356_9: const #1u : u64
        let s_356_9: u64 = 1;
        // D s_356_10: and s_356_8 s_356_9
        let s_356_10: u64 = ((s_356_8) & (s_356_9));
        // D s_356_11: cmp-eq s_356_10 s_356_9
        let s_356_11: bool = ((s_356_10) == (s_356_9));
        // D s_356_12: lsl s_356_8 s_356_6
        let s_356_12: u64 = s_356_8 << s_356_6;
        // D s_356_13: or s_356_7 s_356_12
        let s_356_13: u64 = ((s_356_7) | (s_356_12));
        // D s_356_14: cmpl s_356_12
        let s_356_14: u64 = !s_356_12;
        // D s_356_15: and s_356_7 s_356_14
        let s_356_15: u64 = ((s_356_7) & (s_356_14));
        // D s_356_16: select s_356_11 s_356_13 s_356_15
        let s_356_16: u64 = if s_356_11 { s_356_13 } else { s_356_15 };
        // D s_356_17: cast trunc s_356_16 -> u8
        let s_356_17: bool = ((s_356_16) != 0);
        // D s_356_18: cast zx s_356_17 -> bv
        let s_356_18: Bits = Bits::new(s_356_17 as u128, 1u16);
        // C s_356_19: const #1u : u8
        let s_356_19: bool = true;
        // C s_356_20: cast zx s_356_19 -> bv
        let s_356_20: Bits = Bits::new(s_356_19 as u128, 1u16);
        // D s_356_21: cmp-ne s_356_18 s_356_20
        let s_356_21: bool = ((s_356_18) != (s_356_20));
        // D s_356_22: write-var gs#409783 <= s_356_21
        fn_state.gs_409783 = s_356_21;
        // N s_356_23: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_357_0: read-var gs#409783:u8
        let s_357_0: bool = fn_state.gs_409783;
        // N s_357_1: branch s_357_0 b365 b358
        if s_357_0 {
            return block_365(state, tracer, fn_state);
        } else {
            return block_358(state, tracer, fn_state);
        };
    }
    fn block_358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_358_0: const #10s : i
        let s_358_0: i128 = 10;
        // D s_358_1: read-var u#33535:u32
        let s_358_1: u32 = fn_state.u_33535;
        // D s_358_2: cast zx s_358_1 -> bv
        let s_358_2: Bits = Bits::new(s_358_1 as u128, 32u16);
        // C s_358_3: const #1u : u64
        let s_358_3: u64 = 1;
        // D s_358_4: bit-extract s_358_2 s_358_0 s_358_3
        let s_358_4: Bits = (Bits::new(
            ((s_358_2) >> (s_358_0)).value(),
            u16::try_from(s_358_3).unwrap(),
        ));
        // D s_358_5: cast reint s_358_4 -> u8
        let s_358_5: bool = ((s_358_4.value()) != 0);
        // C s_358_6: const #0s : i
        let s_358_6: i128 = 0;
        // C s_358_7: const #0u : u64
        let s_358_7: u64 = 0;
        // D s_358_8: cast zx s_358_5 -> u64
        let s_358_8: u64 = (s_358_5 as u64);
        // C s_358_9: const #1u : u64
        let s_358_9: u64 = 1;
        // D s_358_10: and s_358_8 s_358_9
        let s_358_10: u64 = ((s_358_8) & (s_358_9));
        // D s_358_11: cmp-eq s_358_10 s_358_9
        let s_358_11: bool = ((s_358_10) == (s_358_9));
        // D s_358_12: lsl s_358_8 s_358_6
        let s_358_12: u64 = s_358_8 << s_358_6;
        // D s_358_13: or s_358_7 s_358_12
        let s_358_13: u64 = ((s_358_7) | (s_358_12));
        // D s_358_14: cmpl s_358_12
        let s_358_14: u64 = !s_358_12;
        // D s_358_15: and s_358_7 s_358_14
        let s_358_15: u64 = ((s_358_7) & (s_358_14));
        // D s_358_16: select s_358_11 s_358_13 s_358_15
        let s_358_16: u64 = if s_358_11 { s_358_13 } else { s_358_15 };
        // D s_358_17: cast trunc s_358_16 -> u8
        let s_358_17: bool = ((s_358_16) != 0);
        // D s_358_18: cast zx s_358_17 -> bv
        let s_358_18: Bits = Bits::new(s_358_17 as u128, 1u16);
        // C s_358_19: const #1u : u8
        let s_358_19: bool = true;
        // C s_358_20: cast zx s_358_19 -> bv
        let s_358_20: Bits = Bits::new(s_358_19 as u128, 1u16);
        // D s_358_21: cmp-ne s_358_18 s_358_20
        let s_358_21: bool = ((s_358_18) != (s_358_20));
        // D s_358_22: write-var gs#409786 <= s_358_21
        fn_state.gs_409786 = s_358_21;
        // N s_358_23: jump b359
        return block_359(state, tracer, fn_state);
    }
    fn block_359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_359_0: read-var gs#409786:u8
        let s_359_0: bool = fn_state.gs_409786;
        // N s_359_1: branch s_359_0 b364 b360
        if s_359_0 {
            return block_364(state, tracer, fn_state);
        } else {
            return block_360(state, tracer, fn_state);
        };
    }
    fn block_360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_360_0: const #11s : i
        let s_360_0: i128 = 11;
        // D s_360_1: read-var u#33535:u32
        let s_360_1: u32 = fn_state.u_33535;
        // D s_360_2: cast zx s_360_1 -> bv
        let s_360_2: Bits = Bits::new(s_360_1 as u128, 32u16);
        // C s_360_3: const #1u : u64
        let s_360_3: u64 = 1;
        // D s_360_4: bit-extract s_360_2 s_360_0 s_360_3
        let s_360_4: Bits = (Bits::new(
            ((s_360_2) >> (s_360_0)).value(),
            u16::try_from(s_360_3).unwrap(),
        ));
        // D s_360_5: cast reint s_360_4 -> u8
        let s_360_5: bool = ((s_360_4.value()) != 0);
        // C s_360_6: const #0s : i
        let s_360_6: i128 = 0;
        // C s_360_7: const #0u : u64
        let s_360_7: u64 = 0;
        // D s_360_8: cast zx s_360_5 -> u64
        let s_360_8: u64 = (s_360_5 as u64);
        // C s_360_9: const #1u : u64
        let s_360_9: u64 = 1;
        // D s_360_10: and s_360_8 s_360_9
        let s_360_10: u64 = ((s_360_8) & (s_360_9));
        // D s_360_11: cmp-eq s_360_10 s_360_9
        let s_360_11: bool = ((s_360_10) == (s_360_9));
        // D s_360_12: lsl s_360_8 s_360_6
        let s_360_12: u64 = s_360_8 << s_360_6;
        // D s_360_13: or s_360_7 s_360_12
        let s_360_13: u64 = ((s_360_7) | (s_360_12));
        // D s_360_14: cmpl s_360_12
        let s_360_14: u64 = !s_360_12;
        // D s_360_15: and s_360_7 s_360_14
        let s_360_15: u64 = ((s_360_7) & (s_360_14));
        // D s_360_16: select s_360_11 s_360_13 s_360_15
        let s_360_16: u64 = if s_360_11 { s_360_13 } else { s_360_15 };
        // D s_360_17: cast trunc s_360_16 -> u8
        let s_360_17: bool = ((s_360_16) != 0);
        // D s_360_18: cast zx s_360_17 -> bv
        let s_360_18: Bits = Bits::new(s_360_17 as u128, 1u16);
        // C s_360_19: const #1u : u8
        let s_360_19: bool = true;
        // C s_360_20: cast zx s_360_19 -> bv
        let s_360_20: Bits = Bits::new(s_360_19 as u128, 1u16);
        // D s_360_21: cmp-ne s_360_18 s_360_20
        let s_360_21: bool = ((s_360_18) != (s_360_20));
        // D s_360_22: write-var gs#409789 <= s_360_21
        fn_state.gs_409789 = s_360_21;
        // N s_360_23: jump b361
        return block_361(state, tracer, fn_state);
    }
    fn block_361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_361_0: read-var gs#409789:u8
        let s_361_0: bool = fn_state.gs_409789;
        // N s_361_1: branch s_361_0 b363 b362
        if s_361_0 {
            return block_363(state, tracer, fn_state);
        } else {
            return block_362(state, tracer, fn_state);
        };
    }
    fn block_362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_362_0: read-var u#33536:u8
        let s_362_0: u8 = fn_state.u_33536;
        // D s_362_1: read-var u#33537:u8
        let s_362_1: u8 = fn_state.u_33537;
        // D s_362_2: read-var u#33538:u8
        let s_362_2: u8 = fn_state.u_33538;
        // D s_362_3: read-var u#33539:u8
        let s_362_3: u8 = fn_state.u_33539;
        // D s_362_4: call decode_aarch32_instrs_SHASX_A1enc_A_txt(s_362_0, s_362_1, s_362_2, s_362_3)
        let s_362_4: () = decode_aarch32_instrs_SHASX_A1enc_A_txt(
            state,
            tracer,
            s_362_0,
            s_362_1,
            s_362_2,
            s_362_3,
        );
        // N s_362_5: return
        return;
    }
    fn block_363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_363_0: panic
        panic!("{:?}", ());
        // N s_363_1: return
        return;
    }
    fn block_364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_364_0: const #1u : u8
        let s_364_0: bool = true;
        // D s_364_1: write-var gs#409789 <= s_364_0
        fn_state.gs_409789 = s_364_0;
        // N s_364_2: jump b361
        return block_361(state, tracer, fn_state);
    }
    fn block_365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_365_0: const #1u : u8
        let s_365_0: bool = true;
        // D s_365_1: write-var gs#409786 <= s_365_0
        fn_state.gs_409786 = s_365_0;
        // N s_365_2: jump b359
        return block_359(state, tracer, fn_state);
    }
    fn block_366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_366_0: const #1u : u8
        let s_366_0: bool = true;
        // D s_366_1: write-var gs#409783 <= s_366_0
        fn_state.gs_409783 = s_366_0;
        // N s_366_2: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_367_0: read-var merge#var.1:struct
        let s_367_0: u32 = fn_state.merge_var._1;
        // D s_367_1: write-var u#33541 <= s_367_0
        fn_state.u_33541 = s_367_0;
        // C s_367_2: const #20s : i
        let s_367_2: i128 = 20;
        // D s_367_3: read-var u#33541:u32
        let s_367_3: u32 = fn_state.u_33541;
        // D s_367_4: cast zx s_367_3 -> bv
        let s_367_4: Bits = Bits::new(s_367_3 as u128, 32u16);
        // C s_367_5: const #1s : i64
        let s_367_5: i64 = 1;
        // C s_367_6: cast zx s_367_5 -> i
        let s_367_6: i128 = (i128::try_from(s_367_5).unwrap());
        // C s_367_7: const #7s : i
        let s_367_7: i128 = 7;
        // C s_367_8: add s_367_7 s_367_6
        let s_367_8: i128 = (s_367_7 + s_367_6);
        // D s_367_9: bit-extract s_367_4 s_367_2 s_367_8
        let s_367_9: Bits = (Bits::new(
            ((s_367_4) >> (s_367_2)).value(),
            u16::try_from(s_367_8).unwrap(),
        ));
        // D s_367_10: cast reint s_367_9 -> u8
        let s_367_10: u8 = (s_367_9.value() as u8);
        // D s_367_11: cast zx s_367_10 -> bv
        let s_367_11: Bits = Bits::new(s_367_10 as u128, 8u16);
        // C s_367_12: const #99u : u8
        let s_367_12: u8 = 99;
        // C s_367_13: cast zx s_367_12 -> bv
        let s_367_13: Bits = Bits::new(s_367_12 as u128, 8u16);
        // D s_367_14: cmp-eq s_367_11 s_367_13
        let s_367_14: bool = ((s_367_11) == (s_367_13));
        // N s_367_15: branch s_367_14 b1343 b368
        if s_367_14 {
            return block_1343(state, tracer, fn_state);
        } else {
            return block_368(state, tracer, fn_state);
        };
    }
    fn block_368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_368_0: const #0u : u8
        let s_368_0: bool = false;
        // D s_368_1: write-var gs#409795 <= s_368_0
        fn_state.gs_409795 = s_368_0;
        // N s_368_2: jump b369
        return block_369(state, tracer, fn_state);
    }
    fn block_369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_369_0: read-var gs#409795:u8
        let s_369_0: bool = fn_state.gs_409795;
        // N s_369_1: branch s_369_0 b1339 b370
        if s_369_0 {
            return block_1339(state, tracer, fn_state);
        } else {
            return block_370(state, tracer, fn_state);
        };
    }
    fn block_370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_370_0: const #0u : u8
        let s_370_0: bool = false;
        // D s_370_1: write-var gs#409800 <= s_370_0
        fn_state.gs_409800 = s_370_0;
        // N s_370_2: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_371_0: read-var gs#409800:u8
        let s_371_0: bool = fn_state.gs_409800;
        // D s_371_1: not s_371_0
        let s_371_1: bool = !s_371_0;
        // N s_371_2: branch s_371_1 b384 b372
        if s_371_1 {
            return block_384(state, tracer, fn_state);
        } else {
            return block_372(state, tracer, fn_state);
        };
    }
    fn block_372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_372_0: const #3136s : i
        let s_372_0: i128 = 3136;
        // C s_372_1: const #14696u : u32
        let s_372_1: u32 = 14696;
        // N s_372_2: write-reg s_372_1 <= s_372_0
        let s_372_2: () = {
            state.write_register::<i128>(s_372_1 as isize, s_372_0);
            tracer.write_register(s_372_1 as isize, s_372_0);
        };
        // C s_372_3: const #28s : i
        let s_372_3: i128 = 28;
        // C s_372_4: const #4s : i
        let s_372_4: i128 = 4;
        // D s_372_5: read-var u#33541:u32
        let s_372_5: u32 = fn_state.u_33541;
        // D s_372_6: cast zx s_372_5 -> bv
        let s_372_6: Bits = Bits::new(s_372_5 as u128, 32u16);
        // D s_372_7: bit-extract s_372_6 s_372_3 s_372_4
        let s_372_7: Bits = (Bits::new(
            ((s_372_6) >> (s_372_3)).value(),
            u16::try_from(s_372_4).unwrap(),
        ));
        // D s_372_8: cast reint s_372_7 -> u8
        let s_372_8: u8 = (s_372_7.value() as u8);
        // D s_372_9: write-var u#33542 <= s_372_8
        fn_state.u_33542 = s_372_8;
        // C s_372_10: const #16s : i
        let s_372_10: i128 = 16;
        // C s_372_11: const #4s : i
        let s_372_11: i128 = 4;
        // D s_372_12: read-var u#33541:u32
        let s_372_12: u32 = fn_state.u_33541;
        // D s_372_13: cast zx s_372_12 -> bv
        let s_372_13: Bits = Bits::new(s_372_12 as u128, 32u16);
        // D s_372_14: bit-extract s_372_13 s_372_10 s_372_11
        let s_372_14: Bits = (Bits::new(
            ((s_372_13) >> (s_372_10)).value(),
            u16::try_from(s_372_11).unwrap(),
        ));
        // D s_372_15: cast reint s_372_14 -> u8
        let s_372_15: u8 = (s_372_14.value() as u8);
        // D s_372_16: write-var u#33543 <= s_372_15
        fn_state.u_33543 = s_372_15;
        // C s_372_17: const #12s : i
        let s_372_17: i128 = 12;
        // C s_372_18: const #4s : i
        let s_372_18: i128 = 4;
        // D s_372_19: read-var u#33541:u32
        let s_372_19: u32 = fn_state.u_33541;
        // D s_372_20: cast zx s_372_19 -> bv
        let s_372_20: Bits = Bits::new(s_372_19 as u128, 32u16);
        // D s_372_21: bit-extract s_372_20 s_372_17 s_372_18
        let s_372_21: Bits = (Bits::new(
            ((s_372_20) >> (s_372_17)).value(),
            u16::try_from(s_372_18).unwrap(),
        ));
        // D s_372_22: cast reint s_372_21 -> u8
        let s_372_22: u8 = (s_372_21.value() as u8);
        // D s_372_23: write-var u#33544 <= s_372_22
        fn_state.u_33544 = s_372_22;
        // C s_372_24: const #0s : i
        let s_372_24: i128 = 0;
        // C s_372_25: const #4s : i
        let s_372_25: i128 = 4;
        // D s_372_26: read-var u#33541:u32
        let s_372_26: u32 = fn_state.u_33541;
        // D s_372_27: cast zx s_372_26 -> bv
        let s_372_27: Bits = Bits::new(s_372_26 as u128, 32u16);
        // D s_372_28: bit-extract s_372_27 s_372_24 s_372_25
        let s_372_28: Bits = (Bits::new(
            ((s_372_27) >> (s_372_24)).value(),
            u16::try_from(s_372_25).unwrap(),
        ));
        // D s_372_29: cast reint s_372_28 -> u8
        let s_372_29: u8 = (s_372_28.value() as u8);
        // D s_372_30: write-var u#33545 <= s_372_29
        fn_state.u_33545 = s_372_29;
        // C s_372_31: const #8s : i
        let s_372_31: i128 = 8;
        // D s_372_32: read-var u#33541:u32
        let s_372_32: u32 = fn_state.u_33541;
        // D s_372_33: cast zx s_372_32 -> bv
        let s_372_33: Bits = Bits::new(s_372_32 as u128, 32u16);
        // C s_372_34: const #1u : u64
        let s_372_34: u64 = 1;
        // D s_372_35: bit-extract s_372_33 s_372_31 s_372_34
        let s_372_35: Bits = (Bits::new(
            ((s_372_33) >> (s_372_31)).value(),
            u16::try_from(s_372_34).unwrap(),
        ));
        // D s_372_36: cast reint s_372_35 -> u8
        let s_372_36: bool = ((s_372_35.value()) != 0);
        // C s_372_37: const #0s : i
        let s_372_37: i128 = 0;
        // C s_372_38: const #0u : u64
        let s_372_38: u64 = 0;
        // D s_372_39: cast zx s_372_36 -> u64
        let s_372_39: u64 = (s_372_36 as u64);
        // C s_372_40: const #1u : u64
        let s_372_40: u64 = 1;
        // D s_372_41: and s_372_39 s_372_40
        let s_372_41: u64 = ((s_372_39) & (s_372_40));
        // D s_372_42: cmp-eq s_372_41 s_372_40
        let s_372_42: bool = ((s_372_41) == (s_372_40));
        // D s_372_43: lsl s_372_39 s_372_37
        let s_372_43: u64 = s_372_39 << s_372_37;
        // D s_372_44: or s_372_38 s_372_43
        let s_372_44: u64 = ((s_372_38) | (s_372_43));
        // D s_372_45: cmpl s_372_43
        let s_372_45: u64 = !s_372_43;
        // D s_372_46: and s_372_38 s_372_45
        let s_372_46: u64 = ((s_372_38) & (s_372_45));
        // D s_372_47: select s_372_42 s_372_44 s_372_46
        let s_372_47: u64 = if s_372_42 { s_372_44 } else { s_372_46 };
        // D s_372_48: cast trunc s_372_47 -> u8
        let s_372_48: bool = ((s_372_47) != 0);
        // D s_372_49: cast zx s_372_48 -> bv
        let s_372_49: Bits = Bits::new(s_372_48 as u128, 1u16);
        // C s_372_50: const #1u : u8
        let s_372_50: bool = true;
        // C s_372_51: cast zx s_372_50 -> bv
        let s_372_51: Bits = Bits::new(s_372_50 as u128, 1u16);
        // D s_372_52: cmp-ne s_372_49 s_372_51
        let s_372_52: bool = ((s_372_49) != (s_372_51));
        // N s_372_53: branch s_372_52 b383 b373
        if s_372_52 {
            return block_383(state, tracer, fn_state);
        } else {
            return block_373(state, tracer, fn_state);
        };
    }
    fn block_373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_373_0: const #9s : i
        let s_373_0: i128 = 9;
        // D s_373_1: read-var u#33541:u32
        let s_373_1: u32 = fn_state.u_33541;
        // D s_373_2: cast zx s_373_1 -> bv
        let s_373_2: Bits = Bits::new(s_373_1 as u128, 32u16);
        // C s_373_3: const #1u : u64
        let s_373_3: u64 = 1;
        // D s_373_4: bit-extract s_373_2 s_373_0 s_373_3
        let s_373_4: Bits = (Bits::new(
            ((s_373_2) >> (s_373_0)).value(),
            u16::try_from(s_373_3).unwrap(),
        ));
        // D s_373_5: cast reint s_373_4 -> u8
        let s_373_5: bool = ((s_373_4.value()) != 0);
        // C s_373_6: const #0s : i
        let s_373_6: i128 = 0;
        // C s_373_7: const #0u : u64
        let s_373_7: u64 = 0;
        // D s_373_8: cast zx s_373_5 -> u64
        let s_373_8: u64 = (s_373_5 as u64);
        // C s_373_9: const #1u : u64
        let s_373_9: u64 = 1;
        // D s_373_10: and s_373_8 s_373_9
        let s_373_10: u64 = ((s_373_8) & (s_373_9));
        // D s_373_11: cmp-eq s_373_10 s_373_9
        let s_373_11: bool = ((s_373_10) == (s_373_9));
        // D s_373_12: lsl s_373_8 s_373_6
        let s_373_12: u64 = s_373_8 << s_373_6;
        // D s_373_13: or s_373_7 s_373_12
        let s_373_13: u64 = ((s_373_7) | (s_373_12));
        // D s_373_14: cmpl s_373_12
        let s_373_14: u64 = !s_373_12;
        // D s_373_15: and s_373_7 s_373_14
        let s_373_15: u64 = ((s_373_7) & (s_373_14));
        // D s_373_16: select s_373_11 s_373_13 s_373_15
        let s_373_16: u64 = if s_373_11 { s_373_13 } else { s_373_15 };
        // D s_373_17: cast trunc s_373_16 -> u8
        let s_373_17: bool = ((s_373_16) != 0);
        // D s_373_18: cast zx s_373_17 -> bv
        let s_373_18: Bits = Bits::new(s_373_17 as u128, 1u16);
        // C s_373_19: const #1u : u8
        let s_373_19: bool = true;
        // C s_373_20: cast zx s_373_19 -> bv
        let s_373_20: Bits = Bits::new(s_373_19 as u128, 1u16);
        // D s_373_21: cmp-ne s_373_18 s_373_20
        let s_373_21: bool = ((s_373_18) != (s_373_20));
        // D s_373_22: write-var gs#409815 <= s_373_21
        fn_state.gs_409815 = s_373_21;
        // N s_373_23: jump b374
        return block_374(state, tracer, fn_state);
    }
    fn block_374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_374_0: read-var gs#409815:u8
        let s_374_0: bool = fn_state.gs_409815;
        // N s_374_1: branch s_374_0 b382 b375
        if s_374_0 {
            return block_382(state, tracer, fn_state);
        } else {
            return block_375(state, tracer, fn_state);
        };
    }
    fn block_375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_375_0: const #10s : i
        let s_375_0: i128 = 10;
        // D s_375_1: read-var u#33541:u32
        let s_375_1: u32 = fn_state.u_33541;
        // D s_375_2: cast zx s_375_1 -> bv
        let s_375_2: Bits = Bits::new(s_375_1 as u128, 32u16);
        // C s_375_3: const #1u : u64
        let s_375_3: u64 = 1;
        // D s_375_4: bit-extract s_375_2 s_375_0 s_375_3
        let s_375_4: Bits = (Bits::new(
            ((s_375_2) >> (s_375_0)).value(),
            u16::try_from(s_375_3).unwrap(),
        ));
        // D s_375_5: cast reint s_375_4 -> u8
        let s_375_5: bool = ((s_375_4.value()) != 0);
        // C s_375_6: const #0s : i
        let s_375_6: i128 = 0;
        // C s_375_7: const #0u : u64
        let s_375_7: u64 = 0;
        // D s_375_8: cast zx s_375_5 -> u64
        let s_375_8: u64 = (s_375_5 as u64);
        // C s_375_9: const #1u : u64
        let s_375_9: u64 = 1;
        // D s_375_10: and s_375_8 s_375_9
        let s_375_10: u64 = ((s_375_8) & (s_375_9));
        // D s_375_11: cmp-eq s_375_10 s_375_9
        let s_375_11: bool = ((s_375_10) == (s_375_9));
        // D s_375_12: lsl s_375_8 s_375_6
        let s_375_12: u64 = s_375_8 << s_375_6;
        // D s_375_13: or s_375_7 s_375_12
        let s_375_13: u64 = ((s_375_7) | (s_375_12));
        // D s_375_14: cmpl s_375_12
        let s_375_14: u64 = !s_375_12;
        // D s_375_15: and s_375_7 s_375_14
        let s_375_15: u64 = ((s_375_7) & (s_375_14));
        // D s_375_16: select s_375_11 s_375_13 s_375_15
        let s_375_16: u64 = if s_375_11 { s_375_13 } else { s_375_15 };
        // D s_375_17: cast trunc s_375_16 -> u8
        let s_375_17: bool = ((s_375_16) != 0);
        // D s_375_18: cast zx s_375_17 -> bv
        let s_375_18: Bits = Bits::new(s_375_17 as u128, 1u16);
        // C s_375_19: const #1u : u8
        let s_375_19: bool = true;
        // C s_375_20: cast zx s_375_19 -> bv
        let s_375_20: Bits = Bits::new(s_375_19 as u128, 1u16);
        // D s_375_21: cmp-ne s_375_18 s_375_20
        let s_375_21: bool = ((s_375_18) != (s_375_20));
        // D s_375_22: write-var gs#409818 <= s_375_21
        fn_state.gs_409818 = s_375_21;
        // N s_375_23: jump b376
        return block_376(state, tracer, fn_state);
    }
    fn block_376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_376_0: read-var gs#409818:u8
        let s_376_0: bool = fn_state.gs_409818;
        // N s_376_1: branch s_376_0 b381 b377
        if s_376_0 {
            return block_381(state, tracer, fn_state);
        } else {
            return block_377(state, tracer, fn_state);
        };
    }
    fn block_377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_377_0: const #11s : i
        let s_377_0: i128 = 11;
        // D s_377_1: read-var u#33541:u32
        let s_377_1: u32 = fn_state.u_33541;
        // D s_377_2: cast zx s_377_1 -> bv
        let s_377_2: Bits = Bits::new(s_377_1 as u128, 32u16);
        // C s_377_3: const #1u : u64
        let s_377_3: u64 = 1;
        // D s_377_4: bit-extract s_377_2 s_377_0 s_377_3
        let s_377_4: Bits = (Bits::new(
            ((s_377_2) >> (s_377_0)).value(),
            u16::try_from(s_377_3).unwrap(),
        ));
        // D s_377_5: cast reint s_377_4 -> u8
        let s_377_5: bool = ((s_377_4.value()) != 0);
        // C s_377_6: const #0s : i
        let s_377_6: i128 = 0;
        // C s_377_7: const #0u : u64
        let s_377_7: u64 = 0;
        // D s_377_8: cast zx s_377_5 -> u64
        let s_377_8: u64 = (s_377_5 as u64);
        // C s_377_9: const #1u : u64
        let s_377_9: u64 = 1;
        // D s_377_10: and s_377_8 s_377_9
        let s_377_10: u64 = ((s_377_8) & (s_377_9));
        // D s_377_11: cmp-eq s_377_10 s_377_9
        let s_377_11: bool = ((s_377_10) == (s_377_9));
        // D s_377_12: lsl s_377_8 s_377_6
        let s_377_12: u64 = s_377_8 << s_377_6;
        // D s_377_13: or s_377_7 s_377_12
        let s_377_13: u64 = ((s_377_7) | (s_377_12));
        // D s_377_14: cmpl s_377_12
        let s_377_14: u64 = !s_377_12;
        // D s_377_15: and s_377_7 s_377_14
        let s_377_15: u64 = ((s_377_7) & (s_377_14));
        // D s_377_16: select s_377_11 s_377_13 s_377_15
        let s_377_16: u64 = if s_377_11 { s_377_13 } else { s_377_15 };
        // D s_377_17: cast trunc s_377_16 -> u8
        let s_377_17: bool = ((s_377_16) != 0);
        // D s_377_18: cast zx s_377_17 -> bv
        let s_377_18: Bits = Bits::new(s_377_17 as u128, 1u16);
        // C s_377_19: const #1u : u8
        let s_377_19: bool = true;
        // C s_377_20: cast zx s_377_19 -> bv
        let s_377_20: Bits = Bits::new(s_377_19 as u128, 1u16);
        // D s_377_21: cmp-ne s_377_18 s_377_20
        let s_377_21: bool = ((s_377_18) != (s_377_20));
        // D s_377_22: write-var gs#409821 <= s_377_21
        fn_state.gs_409821 = s_377_21;
        // N s_377_23: jump b378
        return block_378(state, tracer, fn_state);
    }
    fn block_378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_378_0: read-var gs#409821:u8
        let s_378_0: bool = fn_state.gs_409821;
        // N s_378_1: branch s_378_0 b380 b379
        if s_378_0 {
            return block_380(state, tracer, fn_state);
        } else {
            return block_379(state, tracer, fn_state);
        };
    }
    fn block_379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_379_0: read-var u#33542:u8
        let s_379_0: u8 = fn_state.u_33542;
        // D s_379_1: read-var u#33543:u8
        let s_379_1: u8 = fn_state.u_33543;
        // D s_379_2: read-var u#33544:u8
        let s_379_2: u8 = fn_state.u_33544;
        // D s_379_3: read-var u#33545:u8
        let s_379_3: u8 = fn_state.u_33545;
        // D s_379_4: call decode_aarch32_instrs_SHSAX_A1enc_A_txt(s_379_0, s_379_1, s_379_2, s_379_3)
        let s_379_4: () = decode_aarch32_instrs_SHSAX_A1enc_A_txt(
            state,
            tracer,
            s_379_0,
            s_379_1,
            s_379_2,
            s_379_3,
        );
        // N s_379_5: return
        return;
    }
    fn block_380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_380_0: panic
        panic!("{:?}", ());
        // N s_380_1: return
        return;
    }
    fn block_381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_381_0: const #1u : u8
        let s_381_0: bool = true;
        // D s_381_1: write-var gs#409821 <= s_381_0
        fn_state.gs_409821 = s_381_0;
        // N s_381_2: jump b378
        return block_378(state, tracer, fn_state);
    }
    fn block_382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_382_0: const #1u : u8
        let s_382_0: bool = true;
        // D s_382_1: write-var gs#409818 <= s_382_0
        fn_state.gs_409818 = s_382_0;
        // N s_382_2: jump b376
        return block_376(state, tracer, fn_state);
    }
    fn block_383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_383_0: const #1u : u8
        let s_383_0: bool = true;
        // D s_383_1: write-var gs#409815 <= s_383_0
        fn_state.gs_409815 = s_383_0;
        // N s_383_2: jump b374
        return block_374(state, tracer, fn_state);
    }
    fn block_384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_384_0: read-var merge#var.1:struct
        let s_384_0: u32 = fn_state.merge_var._1;
        // D s_384_1: write-var u#33547 <= s_384_0
        fn_state.u_33547 = s_384_0;
        // C s_384_2: const #20s : i
        let s_384_2: i128 = 20;
        // D s_384_3: read-var u#33547:u32
        let s_384_3: u32 = fn_state.u_33547;
        // D s_384_4: cast zx s_384_3 -> bv
        let s_384_4: Bits = Bits::new(s_384_3 as u128, 32u16);
        // C s_384_5: const #1s : i64
        let s_384_5: i64 = 1;
        // C s_384_6: cast zx s_384_5 -> i
        let s_384_6: i128 = (i128::try_from(s_384_5).unwrap());
        // C s_384_7: const #7s : i
        let s_384_7: i128 = 7;
        // C s_384_8: add s_384_7 s_384_6
        let s_384_8: i128 = (s_384_7 + s_384_6);
        // D s_384_9: bit-extract s_384_4 s_384_2 s_384_8
        let s_384_9: Bits = (Bits::new(
            ((s_384_4) >> (s_384_2)).value(),
            u16::try_from(s_384_8).unwrap(),
        ));
        // D s_384_10: cast reint s_384_9 -> u8
        let s_384_10: u8 = (s_384_9.value() as u8);
        // D s_384_11: cast zx s_384_10 -> bv
        let s_384_11: Bits = Bits::new(s_384_10 as u128, 8u16);
        // C s_384_12: const #99u : u8
        let s_384_12: u8 = 99;
        // C s_384_13: cast zx s_384_12 -> bv
        let s_384_13: Bits = Bits::new(s_384_12 as u128, 8u16);
        // D s_384_14: cmp-eq s_384_11 s_384_13
        let s_384_14: bool = ((s_384_11) == (s_384_13));
        // N s_384_15: branch s_384_14 b1338 b385
        if s_384_14 {
            return block_1338(state, tracer, fn_state);
        } else {
            return block_385(state, tracer, fn_state);
        };
    }
    fn block_385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_385_0: const #0u : u8
        let s_385_0: bool = false;
        // D s_385_1: write-var gs#409827 <= s_385_0
        fn_state.gs_409827 = s_385_0;
        // N s_385_2: jump b386
        return block_386(state, tracer, fn_state);
    }
    fn block_386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_386_0: read-var gs#409827:u8
        let s_386_0: bool = fn_state.gs_409827;
        // N s_386_1: branch s_386_0 b1334 b387
        if s_386_0 {
            return block_1334(state, tracer, fn_state);
        } else {
            return block_387(state, tracer, fn_state);
        };
    }
    fn block_387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_387_0: const #0u : u8
        let s_387_0: bool = false;
        // D s_387_1: write-var gs#409832 <= s_387_0
        fn_state.gs_409832 = s_387_0;
        // N s_387_2: jump b388
        return block_388(state, tracer, fn_state);
    }
    fn block_388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_388_0: read-var gs#409832:u8
        let s_388_0: bool = fn_state.gs_409832;
        // D s_388_1: not s_388_0
        let s_388_1: bool = !s_388_0;
        // N s_388_2: branch s_388_1 b401 b389
        if s_388_1 {
            return block_401(state, tracer, fn_state);
        } else {
            return block_389(state, tracer, fn_state);
        };
    }
    fn block_389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_389_0: const #3138s : i
        let s_389_0: i128 = 3138;
        // C s_389_1: const #14696u : u32
        let s_389_1: u32 = 14696;
        // N s_389_2: write-reg s_389_1 <= s_389_0
        let s_389_2: () = {
            state.write_register::<i128>(s_389_1 as isize, s_389_0);
            tracer.write_register(s_389_1 as isize, s_389_0);
        };
        // C s_389_3: const #28s : i
        let s_389_3: i128 = 28;
        // C s_389_4: const #4s : i
        let s_389_4: i128 = 4;
        // D s_389_5: read-var u#33547:u32
        let s_389_5: u32 = fn_state.u_33547;
        // D s_389_6: cast zx s_389_5 -> bv
        let s_389_6: Bits = Bits::new(s_389_5 as u128, 32u16);
        // D s_389_7: bit-extract s_389_6 s_389_3 s_389_4
        let s_389_7: Bits = (Bits::new(
            ((s_389_6) >> (s_389_3)).value(),
            u16::try_from(s_389_4).unwrap(),
        ));
        // D s_389_8: cast reint s_389_7 -> u8
        let s_389_8: u8 = (s_389_7.value() as u8);
        // D s_389_9: write-var u#33548 <= s_389_8
        fn_state.u_33548 = s_389_8;
        // C s_389_10: const #16s : i
        let s_389_10: i128 = 16;
        // C s_389_11: const #4s : i
        let s_389_11: i128 = 4;
        // D s_389_12: read-var u#33547:u32
        let s_389_12: u32 = fn_state.u_33547;
        // D s_389_13: cast zx s_389_12 -> bv
        let s_389_13: Bits = Bits::new(s_389_12 as u128, 32u16);
        // D s_389_14: bit-extract s_389_13 s_389_10 s_389_11
        let s_389_14: Bits = (Bits::new(
            ((s_389_13) >> (s_389_10)).value(),
            u16::try_from(s_389_11).unwrap(),
        ));
        // D s_389_15: cast reint s_389_14 -> u8
        let s_389_15: u8 = (s_389_14.value() as u8);
        // D s_389_16: write-var u#33549 <= s_389_15
        fn_state.u_33549 = s_389_15;
        // C s_389_17: const #12s : i
        let s_389_17: i128 = 12;
        // C s_389_18: const #4s : i
        let s_389_18: i128 = 4;
        // D s_389_19: read-var u#33547:u32
        let s_389_19: u32 = fn_state.u_33547;
        // D s_389_20: cast zx s_389_19 -> bv
        let s_389_20: Bits = Bits::new(s_389_19 as u128, 32u16);
        // D s_389_21: bit-extract s_389_20 s_389_17 s_389_18
        let s_389_21: Bits = (Bits::new(
            ((s_389_20) >> (s_389_17)).value(),
            u16::try_from(s_389_18).unwrap(),
        ));
        // D s_389_22: cast reint s_389_21 -> u8
        let s_389_22: u8 = (s_389_21.value() as u8);
        // D s_389_23: write-var u#33550 <= s_389_22
        fn_state.u_33550 = s_389_22;
        // C s_389_24: const #0s : i
        let s_389_24: i128 = 0;
        // C s_389_25: const #4s : i
        let s_389_25: i128 = 4;
        // D s_389_26: read-var u#33547:u32
        let s_389_26: u32 = fn_state.u_33547;
        // D s_389_27: cast zx s_389_26 -> bv
        let s_389_27: Bits = Bits::new(s_389_26 as u128, 32u16);
        // D s_389_28: bit-extract s_389_27 s_389_24 s_389_25
        let s_389_28: Bits = (Bits::new(
            ((s_389_27) >> (s_389_24)).value(),
            u16::try_from(s_389_25).unwrap(),
        ));
        // D s_389_29: cast reint s_389_28 -> u8
        let s_389_29: u8 = (s_389_28.value() as u8);
        // D s_389_30: write-var u#33551 <= s_389_29
        fn_state.u_33551 = s_389_29;
        // C s_389_31: const #8s : i
        let s_389_31: i128 = 8;
        // D s_389_32: read-var u#33547:u32
        let s_389_32: u32 = fn_state.u_33547;
        // D s_389_33: cast zx s_389_32 -> bv
        let s_389_33: Bits = Bits::new(s_389_32 as u128, 32u16);
        // C s_389_34: const #1u : u64
        let s_389_34: u64 = 1;
        // D s_389_35: bit-extract s_389_33 s_389_31 s_389_34
        let s_389_35: Bits = (Bits::new(
            ((s_389_33) >> (s_389_31)).value(),
            u16::try_from(s_389_34).unwrap(),
        ));
        // D s_389_36: cast reint s_389_35 -> u8
        let s_389_36: bool = ((s_389_35.value()) != 0);
        // C s_389_37: const #0s : i
        let s_389_37: i128 = 0;
        // C s_389_38: const #0u : u64
        let s_389_38: u64 = 0;
        // D s_389_39: cast zx s_389_36 -> u64
        let s_389_39: u64 = (s_389_36 as u64);
        // C s_389_40: const #1u : u64
        let s_389_40: u64 = 1;
        // D s_389_41: and s_389_39 s_389_40
        let s_389_41: u64 = ((s_389_39) & (s_389_40));
        // D s_389_42: cmp-eq s_389_41 s_389_40
        let s_389_42: bool = ((s_389_41) == (s_389_40));
        // D s_389_43: lsl s_389_39 s_389_37
        let s_389_43: u64 = s_389_39 << s_389_37;
        // D s_389_44: or s_389_38 s_389_43
        let s_389_44: u64 = ((s_389_38) | (s_389_43));
        // D s_389_45: cmpl s_389_43
        let s_389_45: u64 = !s_389_43;
        // D s_389_46: and s_389_38 s_389_45
        let s_389_46: u64 = ((s_389_38) & (s_389_45));
        // D s_389_47: select s_389_42 s_389_44 s_389_46
        let s_389_47: u64 = if s_389_42 { s_389_44 } else { s_389_46 };
        // D s_389_48: cast trunc s_389_47 -> u8
        let s_389_48: bool = ((s_389_47) != 0);
        // D s_389_49: cast zx s_389_48 -> bv
        let s_389_49: Bits = Bits::new(s_389_48 as u128, 1u16);
        // C s_389_50: const #1u : u8
        let s_389_50: bool = true;
        // C s_389_51: cast zx s_389_50 -> bv
        let s_389_51: Bits = Bits::new(s_389_50 as u128, 1u16);
        // D s_389_52: cmp-ne s_389_49 s_389_51
        let s_389_52: bool = ((s_389_49) != (s_389_51));
        // N s_389_53: branch s_389_52 b400 b390
        if s_389_52 {
            return block_400(state, tracer, fn_state);
        } else {
            return block_390(state, tracer, fn_state);
        };
    }
    fn block_390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_390_0: const #9s : i
        let s_390_0: i128 = 9;
        // D s_390_1: read-var u#33547:u32
        let s_390_1: u32 = fn_state.u_33547;
        // D s_390_2: cast zx s_390_1 -> bv
        let s_390_2: Bits = Bits::new(s_390_1 as u128, 32u16);
        // C s_390_3: const #1u : u64
        let s_390_3: u64 = 1;
        // D s_390_4: bit-extract s_390_2 s_390_0 s_390_3
        let s_390_4: Bits = (Bits::new(
            ((s_390_2) >> (s_390_0)).value(),
            u16::try_from(s_390_3).unwrap(),
        ));
        // D s_390_5: cast reint s_390_4 -> u8
        let s_390_5: bool = ((s_390_4.value()) != 0);
        // C s_390_6: const #0s : i
        let s_390_6: i128 = 0;
        // C s_390_7: const #0u : u64
        let s_390_7: u64 = 0;
        // D s_390_8: cast zx s_390_5 -> u64
        let s_390_8: u64 = (s_390_5 as u64);
        // C s_390_9: const #1u : u64
        let s_390_9: u64 = 1;
        // D s_390_10: and s_390_8 s_390_9
        let s_390_10: u64 = ((s_390_8) & (s_390_9));
        // D s_390_11: cmp-eq s_390_10 s_390_9
        let s_390_11: bool = ((s_390_10) == (s_390_9));
        // D s_390_12: lsl s_390_8 s_390_6
        let s_390_12: u64 = s_390_8 << s_390_6;
        // D s_390_13: or s_390_7 s_390_12
        let s_390_13: u64 = ((s_390_7) | (s_390_12));
        // D s_390_14: cmpl s_390_12
        let s_390_14: u64 = !s_390_12;
        // D s_390_15: and s_390_7 s_390_14
        let s_390_15: u64 = ((s_390_7) & (s_390_14));
        // D s_390_16: select s_390_11 s_390_13 s_390_15
        let s_390_16: u64 = if s_390_11 { s_390_13 } else { s_390_15 };
        // D s_390_17: cast trunc s_390_16 -> u8
        let s_390_17: bool = ((s_390_16) != 0);
        // D s_390_18: cast zx s_390_17 -> bv
        let s_390_18: Bits = Bits::new(s_390_17 as u128, 1u16);
        // C s_390_19: const #1u : u8
        let s_390_19: bool = true;
        // C s_390_20: cast zx s_390_19 -> bv
        let s_390_20: Bits = Bits::new(s_390_19 as u128, 1u16);
        // D s_390_21: cmp-ne s_390_18 s_390_20
        let s_390_21: bool = ((s_390_18) != (s_390_20));
        // D s_390_22: write-var gs#409847 <= s_390_21
        fn_state.gs_409847 = s_390_21;
        // N s_390_23: jump b391
        return block_391(state, tracer, fn_state);
    }
    fn block_391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_391_0: read-var gs#409847:u8
        let s_391_0: bool = fn_state.gs_409847;
        // N s_391_1: branch s_391_0 b399 b392
        if s_391_0 {
            return block_399(state, tracer, fn_state);
        } else {
            return block_392(state, tracer, fn_state);
        };
    }
    fn block_392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_392_0: const #10s : i
        let s_392_0: i128 = 10;
        // D s_392_1: read-var u#33547:u32
        let s_392_1: u32 = fn_state.u_33547;
        // D s_392_2: cast zx s_392_1 -> bv
        let s_392_2: Bits = Bits::new(s_392_1 as u128, 32u16);
        // C s_392_3: const #1u : u64
        let s_392_3: u64 = 1;
        // D s_392_4: bit-extract s_392_2 s_392_0 s_392_3
        let s_392_4: Bits = (Bits::new(
            ((s_392_2) >> (s_392_0)).value(),
            u16::try_from(s_392_3).unwrap(),
        ));
        // D s_392_5: cast reint s_392_4 -> u8
        let s_392_5: bool = ((s_392_4.value()) != 0);
        // C s_392_6: const #0s : i
        let s_392_6: i128 = 0;
        // C s_392_7: const #0u : u64
        let s_392_7: u64 = 0;
        // D s_392_8: cast zx s_392_5 -> u64
        let s_392_8: u64 = (s_392_5 as u64);
        // C s_392_9: const #1u : u64
        let s_392_9: u64 = 1;
        // D s_392_10: and s_392_8 s_392_9
        let s_392_10: u64 = ((s_392_8) & (s_392_9));
        // D s_392_11: cmp-eq s_392_10 s_392_9
        let s_392_11: bool = ((s_392_10) == (s_392_9));
        // D s_392_12: lsl s_392_8 s_392_6
        let s_392_12: u64 = s_392_8 << s_392_6;
        // D s_392_13: or s_392_7 s_392_12
        let s_392_13: u64 = ((s_392_7) | (s_392_12));
        // D s_392_14: cmpl s_392_12
        let s_392_14: u64 = !s_392_12;
        // D s_392_15: and s_392_7 s_392_14
        let s_392_15: u64 = ((s_392_7) & (s_392_14));
        // D s_392_16: select s_392_11 s_392_13 s_392_15
        let s_392_16: u64 = if s_392_11 { s_392_13 } else { s_392_15 };
        // D s_392_17: cast trunc s_392_16 -> u8
        let s_392_17: bool = ((s_392_16) != 0);
        // D s_392_18: cast zx s_392_17 -> bv
        let s_392_18: Bits = Bits::new(s_392_17 as u128, 1u16);
        // C s_392_19: const #1u : u8
        let s_392_19: bool = true;
        // C s_392_20: cast zx s_392_19 -> bv
        let s_392_20: Bits = Bits::new(s_392_19 as u128, 1u16);
        // D s_392_21: cmp-ne s_392_18 s_392_20
        let s_392_21: bool = ((s_392_18) != (s_392_20));
        // D s_392_22: write-var gs#409850 <= s_392_21
        fn_state.gs_409850 = s_392_21;
        // N s_392_23: jump b393
        return block_393(state, tracer, fn_state);
    }
    fn block_393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_393_0: read-var gs#409850:u8
        let s_393_0: bool = fn_state.gs_409850;
        // N s_393_1: branch s_393_0 b398 b394
        if s_393_0 {
            return block_398(state, tracer, fn_state);
        } else {
            return block_394(state, tracer, fn_state);
        };
    }
    fn block_394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_394_0: const #11s : i
        let s_394_0: i128 = 11;
        // D s_394_1: read-var u#33547:u32
        let s_394_1: u32 = fn_state.u_33547;
        // D s_394_2: cast zx s_394_1 -> bv
        let s_394_2: Bits = Bits::new(s_394_1 as u128, 32u16);
        // C s_394_3: const #1u : u64
        let s_394_3: u64 = 1;
        // D s_394_4: bit-extract s_394_2 s_394_0 s_394_3
        let s_394_4: Bits = (Bits::new(
            ((s_394_2) >> (s_394_0)).value(),
            u16::try_from(s_394_3).unwrap(),
        ));
        // D s_394_5: cast reint s_394_4 -> u8
        let s_394_5: bool = ((s_394_4.value()) != 0);
        // C s_394_6: const #0s : i
        let s_394_6: i128 = 0;
        // C s_394_7: const #0u : u64
        let s_394_7: u64 = 0;
        // D s_394_8: cast zx s_394_5 -> u64
        let s_394_8: u64 = (s_394_5 as u64);
        // C s_394_9: const #1u : u64
        let s_394_9: u64 = 1;
        // D s_394_10: and s_394_8 s_394_9
        let s_394_10: u64 = ((s_394_8) & (s_394_9));
        // D s_394_11: cmp-eq s_394_10 s_394_9
        let s_394_11: bool = ((s_394_10) == (s_394_9));
        // D s_394_12: lsl s_394_8 s_394_6
        let s_394_12: u64 = s_394_8 << s_394_6;
        // D s_394_13: or s_394_7 s_394_12
        let s_394_13: u64 = ((s_394_7) | (s_394_12));
        // D s_394_14: cmpl s_394_12
        let s_394_14: u64 = !s_394_12;
        // D s_394_15: and s_394_7 s_394_14
        let s_394_15: u64 = ((s_394_7) & (s_394_14));
        // D s_394_16: select s_394_11 s_394_13 s_394_15
        let s_394_16: u64 = if s_394_11 { s_394_13 } else { s_394_15 };
        // D s_394_17: cast trunc s_394_16 -> u8
        let s_394_17: bool = ((s_394_16) != 0);
        // D s_394_18: cast zx s_394_17 -> bv
        let s_394_18: Bits = Bits::new(s_394_17 as u128, 1u16);
        // C s_394_19: const #1u : u8
        let s_394_19: bool = true;
        // C s_394_20: cast zx s_394_19 -> bv
        let s_394_20: Bits = Bits::new(s_394_19 as u128, 1u16);
        // D s_394_21: cmp-ne s_394_18 s_394_20
        let s_394_21: bool = ((s_394_18) != (s_394_20));
        // D s_394_22: write-var gs#409853 <= s_394_21
        fn_state.gs_409853 = s_394_21;
        // N s_394_23: jump b395
        return block_395(state, tracer, fn_state);
    }
    fn block_395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_395_0: read-var gs#409853:u8
        let s_395_0: bool = fn_state.gs_409853;
        // N s_395_1: branch s_395_0 b397 b396
        if s_395_0 {
            return block_397(state, tracer, fn_state);
        } else {
            return block_396(state, tracer, fn_state);
        };
    }
    fn block_396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_396_0: read-var u#33548:u8
        let s_396_0: u8 = fn_state.u_33548;
        // D s_396_1: read-var u#33549:u8
        let s_396_1: u8 = fn_state.u_33549;
        // D s_396_2: read-var u#33550:u8
        let s_396_2: u8 = fn_state.u_33550;
        // D s_396_3: read-var u#33551:u8
        let s_396_3: u8 = fn_state.u_33551;
        // D s_396_4: call decode_aarch32_instrs_SHSUB16_A1enc_A_txt(s_396_0, s_396_1, s_396_2, s_396_3)
        let s_396_4: () = decode_aarch32_instrs_SHSUB16_A1enc_A_txt(
            state,
            tracer,
            s_396_0,
            s_396_1,
            s_396_2,
            s_396_3,
        );
        // N s_396_5: return
        return;
    }
    fn block_397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_397_0: panic
        panic!("{:?}", ());
        // N s_397_1: return
        return;
    }
    fn block_398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_398_0: const #1u : u8
        let s_398_0: bool = true;
        // D s_398_1: write-var gs#409853 <= s_398_0
        fn_state.gs_409853 = s_398_0;
        // N s_398_2: jump b395
        return block_395(state, tracer, fn_state);
    }
    fn block_399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_399_0: const #1u : u8
        let s_399_0: bool = true;
        // D s_399_1: write-var gs#409850 <= s_399_0
        fn_state.gs_409850 = s_399_0;
        // N s_399_2: jump b393
        return block_393(state, tracer, fn_state);
    }
    fn block_400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_400_0: const #1u : u8
        let s_400_0: bool = true;
        // D s_400_1: write-var gs#409847 <= s_400_0
        fn_state.gs_409847 = s_400_0;
        // N s_400_2: jump b391
        return block_391(state, tracer, fn_state);
    }
    fn block_401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_401_0: read-var merge#var.1:struct
        let s_401_0: u32 = fn_state.merge_var._1;
        // D s_401_1: write-var u#33553 <= s_401_0
        fn_state.u_33553 = s_401_0;
        // C s_401_2: const #20s : i
        let s_401_2: i128 = 20;
        // D s_401_3: read-var u#33553:u32
        let s_401_3: u32 = fn_state.u_33553;
        // D s_401_4: cast zx s_401_3 -> bv
        let s_401_4: Bits = Bits::new(s_401_3 as u128, 32u16);
        // C s_401_5: const #1s : i64
        let s_401_5: i64 = 1;
        // C s_401_6: cast zx s_401_5 -> i
        let s_401_6: i128 = (i128::try_from(s_401_5).unwrap());
        // C s_401_7: const #7s : i
        let s_401_7: i128 = 7;
        // C s_401_8: add s_401_7 s_401_6
        let s_401_8: i128 = (s_401_7 + s_401_6);
        // D s_401_9: bit-extract s_401_4 s_401_2 s_401_8
        let s_401_9: Bits = (Bits::new(
            ((s_401_4) >> (s_401_2)).value(),
            u16::try_from(s_401_8).unwrap(),
        ));
        // D s_401_10: cast reint s_401_9 -> u8
        let s_401_10: u8 = (s_401_9.value() as u8);
        // D s_401_11: cast zx s_401_10 -> bv
        let s_401_11: Bits = Bits::new(s_401_10 as u128, 8u16);
        // C s_401_12: const #99u : u8
        let s_401_12: u8 = 99;
        // C s_401_13: cast zx s_401_12 -> bv
        let s_401_13: Bits = Bits::new(s_401_12 as u128, 8u16);
        // D s_401_14: cmp-eq s_401_11 s_401_13
        let s_401_14: bool = ((s_401_11) == (s_401_13));
        // N s_401_15: branch s_401_14 b1333 b402
        if s_401_14 {
            return block_1333(state, tracer, fn_state);
        } else {
            return block_402(state, tracer, fn_state);
        };
    }
    fn block_402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_402_0: const #0u : u8
        let s_402_0: bool = false;
        // D s_402_1: write-var gs#409859 <= s_402_0
        fn_state.gs_409859 = s_402_0;
        // N s_402_2: jump b403
        return block_403(state, tracer, fn_state);
    }
    fn block_403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_403_0: read-var gs#409859:u8
        let s_403_0: bool = fn_state.gs_409859;
        // N s_403_1: branch s_403_0 b1329 b404
        if s_403_0 {
            return block_1329(state, tracer, fn_state);
        } else {
            return block_404(state, tracer, fn_state);
        };
    }
    fn block_404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_404_0: const #0u : u8
        let s_404_0: bool = false;
        // D s_404_1: write-var gs#409864 <= s_404_0
        fn_state.gs_409864 = s_404_0;
        // N s_404_2: jump b405
        return block_405(state, tracer, fn_state);
    }
    fn block_405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_405_0: read-var gs#409864:u8
        let s_405_0: bool = fn_state.gs_409864;
        // D s_405_1: not s_405_0
        let s_405_1: bool = !s_405_0;
        // N s_405_2: branch s_405_1 b418 b406
        if s_405_1 {
            return block_418(state, tracer, fn_state);
        } else {
            return block_406(state, tracer, fn_state);
        };
    }
    fn block_406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_406_0: const #3140s : i
        let s_406_0: i128 = 3140;
        // C s_406_1: const #14696u : u32
        let s_406_1: u32 = 14696;
        // N s_406_2: write-reg s_406_1 <= s_406_0
        let s_406_2: () = {
            state.write_register::<i128>(s_406_1 as isize, s_406_0);
            tracer.write_register(s_406_1 as isize, s_406_0);
        };
        // C s_406_3: const #28s : i
        let s_406_3: i128 = 28;
        // C s_406_4: const #4s : i
        let s_406_4: i128 = 4;
        // D s_406_5: read-var u#33553:u32
        let s_406_5: u32 = fn_state.u_33553;
        // D s_406_6: cast zx s_406_5 -> bv
        let s_406_6: Bits = Bits::new(s_406_5 as u128, 32u16);
        // D s_406_7: bit-extract s_406_6 s_406_3 s_406_4
        let s_406_7: Bits = (Bits::new(
            ((s_406_6) >> (s_406_3)).value(),
            u16::try_from(s_406_4).unwrap(),
        ));
        // D s_406_8: cast reint s_406_7 -> u8
        let s_406_8: u8 = (s_406_7.value() as u8);
        // D s_406_9: write-var u#33554 <= s_406_8
        fn_state.u_33554 = s_406_8;
        // C s_406_10: const #16s : i
        let s_406_10: i128 = 16;
        // C s_406_11: const #4s : i
        let s_406_11: i128 = 4;
        // D s_406_12: read-var u#33553:u32
        let s_406_12: u32 = fn_state.u_33553;
        // D s_406_13: cast zx s_406_12 -> bv
        let s_406_13: Bits = Bits::new(s_406_12 as u128, 32u16);
        // D s_406_14: bit-extract s_406_13 s_406_10 s_406_11
        let s_406_14: Bits = (Bits::new(
            ((s_406_13) >> (s_406_10)).value(),
            u16::try_from(s_406_11).unwrap(),
        ));
        // D s_406_15: cast reint s_406_14 -> u8
        let s_406_15: u8 = (s_406_14.value() as u8);
        // D s_406_16: write-var u#33555 <= s_406_15
        fn_state.u_33555 = s_406_15;
        // C s_406_17: const #12s : i
        let s_406_17: i128 = 12;
        // C s_406_18: const #4s : i
        let s_406_18: i128 = 4;
        // D s_406_19: read-var u#33553:u32
        let s_406_19: u32 = fn_state.u_33553;
        // D s_406_20: cast zx s_406_19 -> bv
        let s_406_20: Bits = Bits::new(s_406_19 as u128, 32u16);
        // D s_406_21: bit-extract s_406_20 s_406_17 s_406_18
        let s_406_21: Bits = (Bits::new(
            ((s_406_20) >> (s_406_17)).value(),
            u16::try_from(s_406_18).unwrap(),
        ));
        // D s_406_22: cast reint s_406_21 -> u8
        let s_406_22: u8 = (s_406_21.value() as u8);
        // D s_406_23: write-var u#33556 <= s_406_22
        fn_state.u_33556 = s_406_22;
        // C s_406_24: const #0s : i
        let s_406_24: i128 = 0;
        // C s_406_25: const #4s : i
        let s_406_25: i128 = 4;
        // D s_406_26: read-var u#33553:u32
        let s_406_26: u32 = fn_state.u_33553;
        // D s_406_27: cast zx s_406_26 -> bv
        let s_406_27: Bits = Bits::new(s_406_26 as u128, 32u16);
        // D s_406_28: bit-extract s_406_27 s_406_24 s_406_25
        let s_406_28: Bits = (Bits::new(
            ((s_406_27) >> (s_406_24)).value(),
            u16::try_from(s_406_25).unwrap(),
        ));
        // D s_406_29: cast reint s_406_28 -> u8
        let s_406_29: u8 = (s_406_28.value() as u8);
        // D s_406_30: write-var u#33557 <= s_406_29
        fn_state.u_33557 = s_406_29;
        // C s_406_31: const #8s : i
        let s_406_31: i128 = 8;
        // D s_406_32: read-var u#33553:u32
        let s_406_32: u32 = fn_state.u_33553;
        // D s_406_33: cast zx s_406_32 -> bv
        let s_406_33: Bits = Bits::new(s_406_32 as u128, 32u16);
        // C s_406_34: const #1u : u64
        let s_406_34: u64 = 1;
        // D s_406_35: bit-extract s_406_33 s_406_31 s_406_34
        let s_406_35: Bits = (Bits::new(
            ((s_406_33) >> (s_406_31)).value(),
            u16::try_from(s_406_34).unwrap(),
        ));
        // D s_406_36: cast reint s_406_35 -> u8
        let s_406_36: bool = ((s_406_35.value()) != 0);
        // C s_406_37: const #0s : i
        let s_406_37: i128 = 0;
        // C s_406_38: const #0u : u64
        let s_406_38: u64 = 0;
        // D s_406_39: cast zx s_406_36 -> u64
        let s_406_39: u64 = (s_406_36 as u64);
        // C s_406_40: const #1u : u64
        let s_406_40: u64 = 1;
        // D s_406_41: and s_406_39 s_406_40
        let s_406_41: u64 = ((s_406_39) & (s_406_40));
        // D s_406_42: cmp-eq s_406_41 s_406_40
        let s_406_42: bool = ((s_406_41) == (s_406_40));
        // D s_406_43: lsl s_406_39 s_406_37
        let s_406_43: u64 = s_406_39 << s_406_37;
        // D s_406_44: or s_406_38 s_406_43
        let s_406_44: u64 = ((s_406_38) | (s_406_43));
        // D s_406_45: cmpl s_406_43
        let s_406_45: u64 = !s_406_43;
        // D s_406_46: and s_406_38 s_406_45
        let s_406_46: u64 = ((s_406_38) & (s_406_45));
        // D s_406_47: select s_406_42 s_406_44 s_406_46
        let s_406_47: u64 = if s_406_42 { s_406_44 } else { s_406_46 };
        // D s_406_48: cast trunc s_406_47 -> u8
        let s_406_48: bool = ((s_406_47) != 0);
        // D s_406_49: cast zx s_406_48 -> bv
        let s_406_49: Bits = Bits::new(s_406_48 as u128, 1u16);
        // C s_406_50: const #1u : u8
        let s_406_50: bool = true;
        // C s_406_51: cast zx s_406_50 -> bv
        let s_406_51: Bits = Bits::new(s_406_50 as u128, 1u16);
        // D s_406_52: cmp-ne s_406_49 s_406_51
        let s_406_52: bool = ((s_406_49) != (s_406_51));
        // N s_406_53: branch s_406_52 b417 b407
        if s_406_52 {
            return block_417(state, tracer, fn_state);
        } else {
            return block_407(state, tracer, fn_state);
        };
    }
    fn block_407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_407_0: const #9s : i
        let s_407_0: i128 = 9;
        // D s_407_1: read-var u#33553:u32
        let s_407_1: u32 = fn_state.u_33553;
        // D s_407_2: cast zx s_407_1 -> bv
        let s_407_2: Bits = Bits::new(s_407_1 as u128, 32u16);
        // C s_407_3: const #1u : u64
        let s_407_3: u64 = 1;
        // D s_407_4: bit-extract s_407_2 s_407_0 s_407_3
        let s_407_4: Bits = (Bits::new(
            ((s_407_2) >> (s_407_0)).value(),
            u16::try_from(s_407_3).unwrap(),
        ));
        // D s_407_5: cast reint s_407_4 -> u8
        let s_407_5: bool = ((s_407_4.value()) != 0);
        // C s_407_6: const #0s : i
        let s_407_6: i128 = 0;
        // C s_407_7: const #0u : u64
        let s_407_7: u64 = 0;
        // D s_407_8: cast zx s_407_5 -> u64
        let s_407_8: u64 = (s_407_5 as u64);
        // C s_407_9: const #1u : u64
        let s_407_9: u64 = 1;
        // D s_407_10: and s_407_8 s_407_9
        let s_407_10: u64 = ((s_407_8) & (s_407_9));
        // D s_407_11: cmp-eq s_407_10 s_407_9
        let s_407_11: bool = ((s_407_10) == (s_407_9));
        // D s_407_12: lsl s_407_8 s_407_6
        let s_407_12: u64 = s_407_8 << s_407_6;
        // D s_407_13: or s_407_7 s_407_12
        let s_407_13: u64 = ((s_407_7) | (s_407_12));
        // D s_407_14: cmpl s_407_12
        let s_407_14: u64 = !s_407_12;
        // D s_407_15: and s_407_7 s_407_14
        let s_407_15: u64 = ((s_407_7) & (s_407_14));
        // D s_407_16: select s_407_11 s_407_13 s_407_15
        let s_407_16: u64 = if s_407_11 { s_407_13 } else { s_407_15 };
        // D s_407_17: cast trunc s_407_16 -> u8
        let s_407_17: bool = ((s_407_16) != 0);
        // D s_407_18: cast zx s_407_17 -> bv
        let s_407_18: Bits = Bits::new(s_407_17 as u128, 1u16);
        // C s_407_19: const #1u : u8
        let s_407_19: bool = true;
        // C s_407_20: cast zx s_407_19 -> bv
        let s_407_20: Bits = Bits::new(s_407_19 as u128, 1u16);
        // D s_407_21: cmp-ne s_407_18 s_407_20
        let s_407_21: bool = ((s_407_18) != (s_407_20));
        // D s_407_22: write-var gs#409879 <= s_407_21
        fn_state.gs_409879 = s_407_21;
        // N s_407_23: jump b408
        return block_408(state, tracer, fn_state);
    }
    fn block_408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_408_0: read-var gs#409879:u8
        let s_408_0: bool = fn_state.gs_409879;
        // N s_408_1: branch s_408_0 b416 b409
        if s_408_0 {
            return block_416(state, tracer, fn_state);
        } else {
            return block_409(state, tracer, fn_state);
        };
    }
    fn block_409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_409_0: const #10s : i
        let s_409_0: i128 = 10;
        // D s_409_1: read-var u#33553:u32
        let s_409_1: u32 = fn_state.u_33553;
        // D s_409_2: cast zx s_409_1 -> bv
        let s_409_2: Bits = Bits::new(s_409_1 as u128, 32u16);
        // C s_409_3: const #1u : u64
        let s_409_3: u64 = 1;
        // D s_409_4: bit-extract s_409_2 s_409_0 s_409_3
        let s_409_4: Bits = (Bits::new(
            ((s_409_2) >> (s_409_0)).value(),
            u16::try_from(s_409_3).unwrap(),
        ));
        // D s_409_5: cast reint s_409_4 -> u8
        let s_409_5: bool = ((s_409_4.value()) != 0);
        // C s_409_6: const #0s : i
        let s_409_6: i128 = 0;
        // C s_409_7: const #0u : u64
        let s_409_7: u64 = 0;
        // D s_409_8: cast zx s_409_5 -> u64
        let s_409_8: u64 = (s_409_5 as u64);
        // C s_409_9: const #1u : u64
        let s_409_9: u64 = 1;
        // D s_409_10: and s_409_8 s_409_9
        let s_409_10: u64 = ((s_409_8) & (s_409_9));
        // D s_409_11: cmp-eq s_409_10 s_409_9
        let s_409_11: bool = ((s_409_10) == (s_409_9));
        // D s_409_12: lsl s_409_8 s_409_6
        let s_409_12: u64 = s_409_8 << s_409_6;
        // D s_409_13: or s_409_7 s_409_12
        let s_409_13: u64 = ((s_409_7) | (s_409_12));
        // D s_409_14: cmpl s_409_12
        let s_409_14: u64 = !s_409_12;
        // D s_409_15: and s_409_7 s_409_14
        let s_409_15: u64 = ((s_409_7) & (s_409_14));
        // D s_409_16: select s_409_11 s_409_13 s_409_15
        let s_409_16: u64 = if s_409_11 { s_409_13 } else { s_409_15 };
        // D s_409_17: cast trunc s_409_16 -> u8
        let s_409_17: bool = ((s_409_16) != 0);
        // D s_409_18: cast zx s_409_17 -> bv
        let s_409_18: Bits = Bits::new(s_409_17 as u128, 1u16);
        // C s_409_19: const #1u : u8
        let s_409_19: bool = true;
        // C s_409_20: cast zx s_409_19 -> bv
        let s_409_20: Bits = Bits::new(s_409_19 as u128, 1u16);
        // D s_409_21: cmp-ne s_409_18 s_409_20
        let s_409_21: bool = ((s_409_18) != (s_409_20));
        // D s_409_22: write-var gs#409882 <= s_409_21
        fn_state.gs_409882 = s_409_21;
        // N s_409_23: jump b410
        return block_410(state, tracer, fn_state);
    }
    fn block_410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_410_0: read-var gs#409882:u8
        let s_410_0: bool = fn_state.gs_409882;
        // N s_410_1: branch s_410_0 b415 b411
        if s_410_0 {
            return block_415(state, tracer, fn_state);
        } else {
            return block_411(state, tracer, fn_state);
        };
    }
    fn block_411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_411_0: const #11s : i
        let s_411_0: i128 = 11;
        // D s_411_1: read-var u#33553:u32
        let s_411_1: u32 = fn_state.u_33553;
        // D s_411_2: cast zx s_411_1 -> bv
        let s_411_2: Bits = Bits::new(s_411_1 as u128, 32u16);
        // C s_411_3: const #1u : u64
        let s_411_3: u64 = 1;
        // D s_411_4: bit-extract s_411_2 s_411_0 s_411_3
        let s_411_4: Bits = (Bits::new(
            ((s_411_2) >> (s_411_0)).value(),
            u16::try_from(s_411_3).unwrap(),
        ));
        // D s_411_5: cast reint s_411_4 -> u8
        let s_411_5: bool = ((s_411_4.value()) != 0);
        // C s_411_6: const #0s : i
        let s_411_6: i128 = 0;
        // C s_411_7: const #0u : u64
        let s_411_7: u64 = 0;
        // D s_411_8: cast zx s_411_5 -> u64
        let s_411_8: u64 = (s_411_5 as u64);
        // C s_411_9: const #1u : u64
        let s_411_9: u64 = 1;
        // D s_411_10: and s_411_8 s_411_9
        let s_411_10: u64 = ((s_411_8) & (s_411_9));
        // D s_411_11: cmp-eq s_411_10 s_411_9
        let s_411_11: bool = ((s_411_10) == (s_411_9));
        // D s_411_12: lsl s_411_8 s_411_6
        let s_411_12: u64 = s_411_8 << s_411_6;
        // D s_411_13: or s_411_7 s_411_12
        let s_411_13: u64 = ((s_411_7) | (s_411_12));
        // D s_411_14: cmpl s_411_12
        let s_411_14: u64 = !s_411_12;
        // D s_411_15: and s_411_7 s_411_14
        let s_411_15: u64 = ((s_411_7) & (s_411_14));
        // D s_411_16: select s_411_11 s_411_13 s_411_15
        let s_411_16: u64 = if s_411_11 { s_411_13 } else { s_411_15 };
        // D s_411_17: cast trunc s_411_16 -> u8
        let s_411_17: bool = ((s_411_16) != 0);
        // D s_411_18: cast zx s_411_17 -> bv
        let s_411_18: Bits = Bits::new(s_411_17 as u128, 1u16);
        // C s_411_19: const #1u : u8
        let s_411_19: bool = true;
        // C s_411_20: cast zx s_411_19 -> bv
        let s_411_20: Bits = Bits::new(s_411_19 as u128, 1u16);
        // D s_411_21: cmp-ne s_411_18 s_411_20
        let s_411_21: bool = ((s_411_18) != (s_411_20));
        // D s_411_22: write-var gs#409885 <= s_411_21
        fn_state.gs_409885 = s_411_21;
        // N s_411_23: jump b412
        return block_412(state, tracer, fn_state);
    }
    fn block_412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_412_0: read-var gs#409885:u8
        let s_412_0: bool = fn_state.gs_409885;
        // N s_412_1: branch s_412_0 b414 b413
        if s_412_0 {
            return block_414(state, tracer, fn_state);
        } else {
            return block_413(state, tracer, fn_state);
        };
    }
    fn block_413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_413_0: read-var u#33554:u8
        let s_413_0: u8 = fn_state.u_33554;
        // D s_413_1: read-var u#33555:u8
        let s_413_1: u8 = fn_state.u_33555;
        // D s_413_2: read-var u#33556:u8
        let s_413_2: u8 = fn_state.u_33556;
        // D s_413_3: read-var u#33557:u8
        let s_413_3: u8 = fn_state.u_33557;
        // D s_413_4: call decode_aarch32_instrs_SHSUB8_A1enc_A_txt(s_413_0, s_413_1, s_413_2, s_413_3)
        let s_413_4: () = decode_aarch32_instrs_SHSUB8_A1enc_A_txt(
            state,
            tracer,
            s_413_0,
            s_413_1,
            s_413_2,
            s_413_3,
        );
        // N s_413_5: return
        return;
    }
    fn block_414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_414_0: panic
        panic!("{:?}", ());
        // N s_414_1: return
        return;
    }
    fn block_415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_415_0: const #1u : u8
        let s_415_0: bool = true;
        // D s_415_1: write-var gs#409885 <= s_415_0
        fn_state.gs_409885 = s_415_0;
        // N s_415_2: jump b412
        return block_412(state, tracer, fn_state);
    }
    fn block_416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_416_0: const #1u : u8
        let s_416_0: bool = true;
        // D s_416_1: write-var gs#409882 <= s_416_0
        fn_state.gs_409882 = s_416_0;
        // N s_416_2: jump b410
        return block_410(state, tracer, fn_state);
    }
    fn block_417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_417_0: const #1u : u8
        let s_417_0: bool = true;
        // D s_417_1: write-var gs#409879 <= s_417_0
        fn_state.gs_409879 = s_417_0;
        // N s_417_2: jump b408
        return block_408(state, tracer, fn_state);
    }
    fn block_418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_418_0: read-var merge#var.1:struct
        let s_418_0: u32 = fn_state.merge_var._1;
        // D s_418_1: write-var u#33559 <= s_418_0
        fn_state.u_33559 = s_418_0;
        // C s_418_2: const #20s : i
        let s_418_2: i128 = 20;
        // D s_418_3: read-var u#33559:u32
        let s_418_3: u32 = fn_state.u_33559;
        // D s_418_4: cast zx s_418_3 -> bv
        let s_418_4: Bits = Bits::new(s_418_3 as u128, 32u16);
        // C s_418_5: const #1s : i64
        let s_418_5: i64 = 1;
        // C s_418_6: cast zx s_418_5 -> i
        let s_418_6: i128 = (i128::try_from(s_418_5).unwrap());
        // C s_418_7: const #7s : i
        let s_418_7: i128 = 7;
        // C s_418_8: add s_418_7 s_418_6
        let s_418_8: i128 = (s_418_7 + s_418_6);
        // D s_418_9: bit-extract s_418_4 s_418_2 s_418_8
        let s_418_9: Bits = (Bits::new(
            ((s_418_4) >> (s_418_2)).value(),
            u16::try_from(s_418_8).unwrap(),
        ));
        // D s_418_10: cast reint s_418_9 -> u8
        let s_418_10: u8 = (s_418_9.value() as u8);
        // D s_418_11: cast zx s_418_10 -> bv
        let s_418_11: Bits = Bits::new(s_418_10 as u128, 8u16);
        // C s_418_12: const #112u : u8
        let s_418_12: u8 = 112;
        // C s_418_13: cast zx s_418_12 -> bv
        let s_418_13: Bits = Bits::new(s_418_12 as u128, 8u16);
        // D s_418_14: cmp-eq s_418_11 s_418_13
        let s_418_14: bool = ((s_418_11) == (s_418_13));
        // N s_418_15: branch s_418_14 b1325 b419
        if s_418_14 {
            return block_1325(state, tracer, fn_state);
        } else {
            return block_419(state, tracer, fn_state);
        };
    }
    fn block_419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_419_0: const #0u : u8
        let s_419_0: bool = false;
        // D s_419_1: write-var gs#409894 <= s_419_0
        fn_state.gs_409894 = s_419_0;
        // N s_419_2: jump b420
        return block_420(state, tracer, fn_state);
    }
    fn block_420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_420_0: read-var gs#409894:u8
        let s_420_0: bool = fn_state.gs_409894;
        // N s_420_1: branch s_420_0 b1321 b421
        if s_420_0 {
            return block_1321(state, tracer, fn_state);
        } else {
            return block_421(state, tracer, fn_state);
        };
    }
    fn block_421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_421_0: const #0u : u8
        let s_421_0: bool = false;
        // D s_421_1: write-var gs#409899 <= s_421_0
        fn_state.gs_409899 = s_421_0;
        // N s_421_2: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_422_0: read-var gs#409899:u8
        let s_422_0: bool = fn_state.gs_409899;
        // D s_422_1: not s_422_0
        let s_422_1: bool = !s_422_0;
        // N s_422_2: branch s_422_1 b424 b423
        if s_422_1 {
            return block_424(state, tracer, fn_state);
        } else {
            return block_423(state, tracer, fn_state);
        };
    }
    fn block_423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_423_0: const #3144s : i
        let s_423_0: i128 = 3144;
        // C s_423_1: const #14696u : u32
        let s_423_1: u32 = 14696;
        // N s_423_2: write-reg s_423_1 <= s_423_0
        let s_423_2: () = {
            state.write_register::<i128>(s_423_1 as isize, s_423_0);
            tracer.write_register(s_423_1 as isize, s_423_0);
        };
        // C s_423_3: const #28s : i
        let s_423_3: i128 = 28;
        // C s_423_4: const #4s : i
        let s_423_4: i128 = 4;
        // D s_423_5: read-var u#33559:u32
        let s_423_5: u32 = fn_state.u_33559;
        // D s_423_6: cast zx s_423_5 -> bv
        let s_423_6: Bits = Bits::new(s_423_5 as u128, 32u16);
        // D s_423_7: bit-extract s_423_6 s_423_3 s_423_4
        let s_423_7: Bits = (Bits::new(
            ((s_423_6) >> (s_423_3)).value(),
            u16::try_from(s_423_4).unwrap(),
        ));
        // D s_423_8: cast reint s_423_7 -> u8
        let s_423_8: u8 = (s_423_7.value() as u8);
        // C s_423_9: const #16s : i
        let s_423_9: i128 = 16;
        // C s_423_10: const #4s : i
        let s_423_10: i128 = 4;
        // D s_423_11: read-var u#33559:u32
        let s_423_11: u32 = fn_state.u_33559;
        // D s_423_12: cast zx s_423_11 -> bv
        let s_423_12: Bits = Bits::new(s_423_11 as u128, 32u16);
        // D s_423_13: bit-extract s_423_12 s_423_9 s_423_10
        let s_423_13: Bits = (Bits::new(
            ((s_423_12) >> (s_423_9)).value(),
            u16::try_from(s_423_10).unwrap(),
        ));
        // D s_423_14: cast reint s_423_13 -> u8
        let s_423_14: u8 = (s_423_13.value() as u8);
        // C s_423_15: const #12s : i
        let s_423_15: i128 = 12;
        // C s_423_16: const #4s : i
        let s_423_16: i128 = 4;
        // D s_423_17: read-var u#33559:u32
        let s_423_17: u32 = fn_state.u_33559;
        // D s_423_18: cast zx s_423_17 -> bv
        let s_423_18: Bits = Bits::new(s_423_17 as u128, 32u16);
        // D s_423_19: bit-extract s_423_18 s_423_15 s_423_16
        let s_423_19: Bits = (Bits::new(
            ((s_423_18) >> (s_423_15)).value(),
            u16::try_from(s_423_16).unwrap(),
        ));
        // D s_423_20: cast reint s_423_19 -> u8
        let s_423_20: u8 = (s_423_19.value() as u8);
        // C s_423_21: const #8s : i
        let s_423_21: i128 = 8;
        // C s_423_22: const #4s : i
        let s_423_22: i128 = 4;
        // D s_423_23: read-var u#33559:u32
        let s_423_23: u32 = fn_state.u_33559;
        // D s_423_24: cast zx s_423_23 -> bv
        let s_423_24: Bits = Bits::new(s_423_23 as u128, 32u16);
        // D s_423_25: bit-extract s_423_24 s_423_21 s_423_22
        let s_423_25: Bits = (Bits::new(
            ((s_423_24) >> (s_423_21)).value(),
            u16::try_from(s_423_22).unwrap(),
        ));
        // D s_423_26: cast reint s_423_25 -> u8
        let s_423_26: u8 = (s_423_25.value() as u8);
        // C s_423_27: const #5s : i
        let s_423_27: i128 = 5;
        // C s_423_28: const #1s : i
        let s_423_28: i128 = 1;
        // D s_423_29: read-var u#33559:u32
        let s_423_29: u32 = fn_state.u_33559;
        // D s_423_30: cast zx s_423_29 -> bv
        let s_423_30: Bits = Bits::new(s_423_29 as u128, 32u16);
        // D s_423_31: bit-extract s_423_30 s_423_27 s_423_28
        let s_423_31: Bits = (Bits::new(
            ((s_423_30) >> (s_423_27)).value(),
            u16::try_from(s_423_28).unwrap(),
        ));
        // D s_423_32: cast reint s_423_31 -> u8
        let s_423_32: bool = ((s_423_31.value()) != 0);
        // C s_423_33: const #0s : i
        let s_423_33: i128 = 0;
        // C s_423_34: const #4s : i
        let s_423_34: i128 = 4;
        // D s_423_35: read-var u#33559:u32
        let s_423_35: u32 = fn_state.u_33559;
        // D s_423_36: cast zx s_423_35 -> bv
        let s_423_36: Bits = Bits::new(s_423_35 as u128, 32u16);
        // D s_423_37: bit-extract s_423_36 s_423_33 s_423_34
        let s_423_37: Bits = (Bits::new(
            ((s_423_36) >> (s_423_33)).value(),
            u16::try_from(s_423_34).unwrap(),
        ));
        // D s_423_38: cast reint s_423_37 -> u8
        let s_423_38: u8 = (s_423_37.value() as u8);
        // D s_423_39: call decode_aarch32_instrs_SMLAD_A1enc_A_txt(s_423_8, s_423_14, s_423_20, s_423_26, s_423_32, s_423_38)
        let s_423_39: () = decode_aarch32_instrs_SMLAD_A1enc_A_txt(
            state,
            tracer,
            s_423_8,
            s_423_14,
            s_423_20,
            s_423_26,
            s_423_32,
            s_423_38,
        );
        // N s_423_40: return
        return;
    }
    fn block_424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_424_0: read-var merge#var.1:struct
        let s_424_0: u32 = fn_state.merge_var._1;
        // D s_424_1: write-var u#33566 <= s_424_0
        fn_state.u_33566 = s_424_0;
        // C s_424_2: const #20s : i
        let s_424_2: i128 = 20;
        // D s_424_3: read-var u#33566:u32
        let s_424_3: u32 = fn_state.u_33566;
        // D s_424_4: cast zx s_424_3 -> bv
        let s_424_4: Bits = Bits::new(s_424_3 as u128, 32u16);
        // C s_424_5: const #1s : i64
        let s_424_5: i64 = 1;
        // C s_424_6: cast zx s_424_5 -> i
        let s_424_6: i128 = (i128::try_from(s_424_5).unwrap());
        // C s_424_7: const #7s : i
        let s_424_7: i128 = 7;
        // C s_424_8: add s_424_7 s_424_6
        let s_424_8: i128 = (s_424_7 + s_424_6);
        // D s_424_9: bit-extract s_424_4 s_424_2 s_424_8
        let s_424_9: Bits = (Bits::new(
            ((s_424_4) >> (s_424_2)).value(),
            u16::try_from(s_424_8).unwrap(),
        ));
        // D s_424_10: cast reint s_424_9 -> u8
        let s_424_10: u8 = (s_424_9.value() as u8);
        // D s_424_11: cast zx s_424_10 -> bv
        let s_424_11: Bits = Bits::new(s_424_10 as u128, 8u16);
        // C s_424_12: const #116u : u8
        let s_424_12: u8 = 116;
        // C s_424_13: cast zx s_424_12 -> bv
        let s_424_13: Bits = Bits::new(s_424_12 as u128, 8u16);
        // D s_424_14: cmp-eq s_424_11 s_424_13
        let s_424_14: bool = ((s_424_11) == (s_424_13));
        // N s_424_15: branch s_424_14 b1317 b425
        if s_424_14 {
            return block_1317(state, tracer, fn_state);
        } else {
            return block_425(state, tracer, fn_state);
        };
    }
    fn block_425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_425_0: const #0u : u8
        let s_425_0: bool = false;
        // D s_425_1: write-var gs#409922 <= s_425_0
        fn_state.gs_409922 = s_425_0;
        // N s_425_2: jump b426
        return block_426(state, tracer, fn_state);
    }
    fn block_426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_426_0: read-var gs#409922:u8
        let s_426_0: bool = fn_state.gs_409922;
        // N s_426_1: branch s_426_0 b1313 b427
        if s_426_0 {
            return block_1313(state, tracer, fn_state);
        } else {
            return block_427(state, tracer, fn_state);
        };
    }
    fn block_427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_427_0: const #0u : u8
        let s_427_0: bool = false;
        // D s_427_1: write-var gs#409927 <= s_427_0
        fn_state.gs_409927 = s_427_0;
        // N s_427_2: jump b428
        return block_428(state, tracer, fn_state);
    }
    fn block_428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_428_0: read-var gs#409927:u8
        let s_428_0: bool = fn_state.gs_409927;
        // D s_428_1: not s_428_0
        let s_428_1: bool = !s_428_0;
        // N s_428_2: branch s_428_1 b430 b429
        if s_428_1 {
            return block_430(state, tracer, fn_state);
        } else {
            return block_429(state, tracer, fn_state);
        };
    }
    fn block_429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_429_0: const #3150s : i
        let s_429_0: i128 = 3150;
        // C s_429_1: const #14696u : u32
        let s_429_1: u32 = 14696;
        // N s_429_2: write-reg s_429_1 <= s_429_0
        let s_429_2: () = {
            state.write_register::<i128>(s_429_1 as isize, s_429_0);
            tracer.write_register(s_429_1 as isize, s_429_0);
        };
        // C s_429_3: const #28s : i
        let s_429_3: i128 = 28;
        // C s_429_4: const #4s : i
        let s_429_4: i128 = 4;
        // D s_429_5: read-var u#33566:u32
        let s_429_5: u32 = fn_state.u_33566;
        // D s_429_6: cast zx s_429_5 -> bv
        let s_429_6: Bits = Bits::new(s_429_5 as u128, 32u16);
        // D s_429_7: bit-extract s_429_6 s_429_3 s_429_4
        let s_429_7: Bits = (Bits::new(
            ((s_429_6) >> (s_429_3)).value(),
            u16::try_from(s_429_4).unwrap(),
        ));
        // D s_429_8: cast reint s_429_7 -> u8
        let s_429_8: u8 = (s_429_7.value() as u8);
        // C s_429_9: const #16s : i
        let s_429_9: i128 = 16;
        // C s_429_10: const #4s : i
        let s_429_10: i128 = 4;
        // D s_429_11: read-var u#33566:u32
        let s_429_11: u32 = fn_state.u_33566;
        // D s_429_12: cast zx s_429_11 -> bv
        let s_429_12: Bits = Bits::new(s_429_11 as u128, 32u16);
        // D s_429_13: bit-extract s_429_12 s_429_9 s_429_10
        let s_429_13: Bits = (Bits::new(
            ((s_429_12) >> (s_429_9)).value(),
            u16::try_from(s_429_10).unwrap(),
        ));
        // D s_429_14: cast reint s_429_13 -> u8
        let s_429_14: u8 = (s_429_13.value() as u8);
        // C s_429_15: const #12s : i
        let s_429_15: i128 = 12;
        // C s_429_16: const #4s : i
        let s_429_16: i128 = 4;
        // D s_429_17: read-var u#33566:u32
        let s_429_17: u32 = fn_state.u_33566;
        // D s_429_18: cast zx s_429_17 -> bv
        let s_429_18: Bits = Bits::new(s_429_17 as u128, 32u16);
        // D s_429_19: bit-extract s_429_18 s_429_15 s_429_16
        let s_429_19: Bits = (Bits::new(
            ((s_429_18) >> (s_429_15)).value(),
            u16::try_from(s_429_16).unwrap(),
        ));
        // D s_429_20: cast reint s_429_19 -> u8
        let s_429_20: u8 = (s_429_19.value() as u8);
        // C s_429_21: const #8s : i
        let s_429_21: i128 = 8;
        // C s_429_22: const #4s : i
        let s_429_22: i128 = 4;
        // D s_429_23: read-var u#33566:u32
        let s_429_23: u32 = fn_state.u_33566;
        // D s_429_24: cast zx s_429_23 -> bv
        let s_429_24: Bits = Bits::new(s_429_23 as u128, 32u16);
        // D s_429_25: bit-extract s_429_24 s_429_21 s_429_22
        let s_429_25: Bits = (Bits::new(
            ((s_429_24) >> (s_429_21)).value(),
            u16::try_from(s_429_22).unwrap(),
        ));
        // D s_429_26: cast reint s_429_25 -> u8
        let s_429_26: u8 = (s_429_25.value() as u8);
        // C s_429_27: const #5s : i
        let s_429_27: i128 = 5;
        // C s_429_28: const #1s : i
        let s_429_28: i128 = 1;
        // D s_429_29: read-var u#33566:u32
        let s_429_29: u32 = fn_state.u_33566;
        // D s_429_30: cast zx s_429_29 -> bv
        let s_429_30: Bits = Bits::new(s_429_29 as u128, 32u16);
        // D s_429_31: bit-extract s_429_30 s_429_27 s_429_28
        let s_429_31: Bits = (Bits::new(
            ((s_429_30) >> (s_429_27)).value(),
            u16::try_from(s_429_28).unwrap(),
        ));
        // D s_429_32: cast reint s_429_31 -> u8
        let s_429_32: bool = ((s_429_31.value()) != 0);
        // C s_429_33: const #0s : i
        let s_429_33: i128 = 0;
        // C s_429_34: const #4s : i
        let s_429_34: i128 = 4;
        // D s_429_35: read-var u#33566:u32
        let s_429_35: u32 = fn_state.u_33566;
        // D s_429_36: cast zx s_429_35 -> bv
        let s_429_36: Bits = Bits::new(s_429_35 as u128, 32u16);
        // D s_429_37: bit-extract s_429_36 s_429_33 s_429_34
        let s_429_37: Bits = (Bits::new(
            ((s_429_36) >> (s_429_33)).value(),
            u16::try_from(s_429_34).unwrap(),
        ));
        // D s_429_38: cast reint s_429_37 -> u8
        let s_429_38: u8 = (s_429_37.value() as u8);
        // D s_429_39: call decode_aarch32_instrs_SMLALD_A1enc_A_txt(s_429_8, s_429_14, s_429_20, s_429_26, s_429_32, s_429_38)
        let s_429_39: () = decode_aarch32_instrs_SMLALD_A1enc_A_txt(
            state,
            tracer,
            s_429_8,
            s_429_14,
            s_429_20,
            s_429_26,
            s_429_32,
            s_429_38,
        );
        // N s_429_40: return
        return;
    }
    fn block_430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_430_0: read-var merge#var.1:struct
        let s_430_0: u32 = fn_state.merge_var._1;
        // D s_430_1: write-var u#33572 <= s_430_0
        fn_state.u_33572 = s_430_0;
        // C s_430_2: const #20s : i
        let s_430_2: i128 = 20;
        // D s_430_3: read-var u#33572:u32
        let s_430_3: u32 = fn_state.u_33572;
        // D s_430_4: cast zx s_430_3 -> bv
        let s_430_4: Bits = Bits::new(s_430_3 as u128, 32u16);
        // C s_430_5: const #1s : i64
        let s_430_5: i64 = 1;
        // C s_430_6: cast zx s_430_5 -> i
        let s_430_6: i128 = (i128::try_from(s_430_5).unwrap());
        // C s_430_7: const #7s : i
        let s_430_7: i128 = 7;
        // C s_430_8: add s_430_7 s_430_6
        let s_430_8: i128 = (s_430_7 + s_430_6);
        // D s_430_9: bit-extract s_430_4 s_430_2 s_430_8
        let s_430_9: Bits = (Bits::new(
            ((s_430_4) >> (s_430_2)).value(),
            u16::try_from(s_430_8).unwrap(),
        ));
        // D s_430_10: cast reint s_430_9 -> u8
        let s_430_10: u8 = (s_430_9.value() as u8);
        // D s_430_11: cast zx s_430_10 -> bv
        let s_430_11: Bits = Bits::new(s_430_10 as u128, 8u16);
        // C s_430_12: const #112u : u8
        let s_430_12: u8 = 112;
        // C s_430_13: cast zx s_430_12 -> bv
        let s_430_13: Bits = Bits::new(s_430_12 as u128, 8u16);
        // D s_430_14: cmp-eq s_430_11 s_430_13
        let s_430_14: bool = ((s_430_11) == (s_430_13));
        // N s_430_15: branch s_430_14 b1309 b431
        if s_430_14 {
            return block_1309(state, tracer, fn_state);
        } else {
            return block_431(state, tracer, fn_state);
        };
    }
    fn block_431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_431_0: const #0u : u8
        let s_431_0: bool = false;
        // D s_431_1: write-var gs#409950 <= s_431_0
        fn_state.gs_409950 = s_431_0;
        // N s_431_2: jump b432
        return block_432(state, tracer, fn_state);
    }
    fn block_432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_432_0: read-var gs#409950:u8
        let s_432_0: bool = fn_state.gs_409950;
        // N s_432_1: branch s_432_0 b1305 b433
        if s_432_0 {
            return block_1305(state, tracer, fn_state);
        } else {
            return block_433(state, tracer, fn_state);
        };
    }
    fn block_433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_433_0: const #0u : u8
        let s_433_0: bool = false;
        // D s_433_1: write-var gs#409955 <= s_433_0
        fn_state.gs_409955 = s_433_0;
        // N s_433_2: jump b434
        return block_434(state, tracer, fn_state);
    }
    fn block_434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_434_0: read-var gs#409955:u8
        let s_434_0: bool = fn_state.gs_409955;
        // D s_434_1: not s_434_0
        let s_434_1: bool = !s_434_0;
        // N s_434_2: branch s_434_1 b436 b435
        if s_434_1 {
            return block_436(state, tracer, fn_state);
        } else {
            return block_435(state, tracer, fn_state);
        };
    }
    fn block_435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_435_0: const #3154s : i
        let s_435_0: i128 = 3154;
        // C s_435_1: const #14696u : u32
        let s_435_1: u32 = 14696;
        // N s_435_2: write-reg s_435_1 <= s_435_0
        let s_435_2: () = {
            state.write_register::<i128>(s_435_1 as isize, s_435_0);
            tracer.write_register(s_435_1 as isize, s_435_0);
        };
        // C s_435_3: const #28s : i
        let s_435_3: i128 = 28;
        // C s_435_4: const #4s : i
        let s_435_4: i128 = 4;
        // D s_435_5: read-var u#33572:u32
        let s_435_5: u32 = fn_state.u_33572;
        // D s_435_6: cast zx s_435_5 -> bv
        let s_435_6: Bits = Bits::new(s_435_5 as u128, 32u16);
        // D s_435_7: bit-extract s_435_6 s_435_3 s_435_4
        let s_435_7: Bits = (Bits::new(
            ((s_435_6) >> (s_435_3)).value(),
            u16::try_from(s_435_4).unwrap(),
        ));
        // D s_435_8: cast reint s_435_7 -> u8
        let s_435_8: u8 = (s_435_7.value() as u8);
        // C s_435_9: const #16s : i
        let s_435_9: i128 = 16;
        // C s_435_10: const #4s : i
        let s_435_10: i128 = 4;
        // D s_435_11: read-var u#33572:u32
        let s_435_11: u32 = fn_state.u_33572;
        // D s_435_12: cast zx s_435_11 -> bv
        let s_435_12: Bits = Bits::new(s_435_11 as u128, 32u16);
        // D s_435_13: bit-extract s_435_12 s_435_9 s_435_10
        let s_435_13: Bits = (Bits::new(
            ((s_435_12) >> (s_435_9)).value(),
            u16::try_from(s_435_10).unwrap(),
        ));
        // D s_435_14: cast reint s_435_13 -> u8
        let s_435_14: u8 = (s_435_13.value() as u8);
        // C s_435_15: const #12s : i
        let s_435_15: i128 = 12;
        // C s_435_16: const #4s : i
        let s_435_16: i128 = 4;
        // D s_435_17: read-var u#33572:u32
        let s_435_17: u32 = fn_state.u_33572;
        // D s_435_18: cast zx s_435_17 -> bv
        let s_435_18: Bits = Bits::new(s_435_17 as u128, 32u16);
        // D s_435_19: bit-extract s_435_18 s_435_15 s_435_16
        let s_435_19: Bits = (Bits::new(
            ((s_435_18) >> (s_435_15)).value(),
            u16::try_from(s_435_16).unwrap(),
        ));
        // D s_435_20: cast reint s_435_19 -> u8
        let s_435_20: u8 = (s_435_19.value() as u8);
        // C s_435_21: const #8s : i
        let s_435_21: i128 = 8;
        // C s_435_22: const #4s : i
        let s_435_22: i128 = 4;
        // D s_435_23: read-var u#33572:u32
        let s_435_23: u32 = fn_state.u_33572;
        // D s_435_24: cast zx s_435_23 -> bv
        let s_435_24: Bits = Bits::new(s_435_23 as u128, 32u16);
        // D s_435_25: bit-extract s_435_24 s_435_21 s_435_22
        let s_435_25: Bits = (Bits::new(
            ((s_435_24) >> (s_435_21)).value(),
            u16::try_from(s_435_22).unwrap(),
        ));
        // D s_435_26: cast reint s_435_25 -> u8
        let s_435_26: u8 = (s_435_25.value() as u8);
        // C s_435_27: const #5s : i
        let s_435_27: i128 = 5;
        // C s_435_28: const #1s : i
        let s_435_28: i128 = 1;
        // D s_435_29: read-var u#33572:u32
        let s_435_29: u32 = fn_state.u_33572;
        // D s_435_30: cast zx s_435_29 -> bv
        let s_435_30: Bits = Bits::new(s_435_29 as u128, 32u16);
        // D s_435_31: bit-extract s_435_30 s_435_27 s_435_28
        let s_435_31: Bits = (Bits::new(
            ((s_435_30) >> (s_435_27)).value(),
            u16::try_from(s_435_28).unwrap(),
        ));
        // D s_435_32: cast reint s_435_31 -> u8
        let s_435_32: bool = ((s_435_31.value()) != 0);
        // C s_435_33: const #0s : i
        let s_435_33: i128 = 0;
        // C s_435_34: const #4s : i
        let s_435_34: i128 = 4;
        // D s_435_35: read-var u#33572:u32
        let s_435_35: u32 = fn_state.u_33572;
        // D s_435_36: cast zx s_435_35 -> bv
        let s_435_36: Bits = Bits::new(s_435_35 as u128, 32u16);
        // D s_435_37: bit-extract s_435_36 s_435_33 s_435_34
        let s_435_37: Bits = (Bits::new(
            ((s_435_36) >> (s_435_33)).value(),
            u16::try_from(s_435_34).unwrap(),
        ));
        // D s_435_38: cast reint s_435_37 -> u8
        let s_435_38: u8 = (s_435_37.value() as u8);
        // D s_435_39: call decode_aarch32_instrs_SMLSD_A1enc_A_txt(s_435_8, s_435_14, s_435_20, s_435_26, s_435_32, s_435_38)
        let s_435_39: () = decode_aarch32_instrs_SMLSD_A1enc_A_txt(
            state,
            tracer,
            s_435_8,
            s_435_14,
            s_435_20,
            s_435_26,
            s_435_32,
            s_435_38,
        );
        // N s_435_40: return
        return;
    }
    fn block_436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_436_0: read-var merge#var.1:struct
        let s_436_0: u32 = fn_state.merge_var._1;
        // D s_436_1: write-var u#33580 <= s_436_0
        fn_state.u_33580 = s_436_0;
        // C s_436_2: const #20s : i
        let s_436_2: i128 = 20;
        // D s_436_3: read-var u#33580:u32
        let s_436_3: u32 = fn_state.u_33580;
        // D s_436_4: cast zx s_436_3 -> bv
        let s_436_4: Bits = Bits::new(s_436_3 as u128, 32u16);
        // C s_436_5: const #1s : i64
        let s_436_5: i64 = 1;
        // C s_436_6: cast zx s_436_5 -> i
        let s_436_6: i128 = (i128::try_from(s_436_5).unwrap());
        // C s_436_7: const #7s : i
        let s_436_7: i128 = 7;
        // C s_436_8: add s_436_7 s_436_6
        let s_436_8: i128 = (s_436_7 + s_436_6);
        // D s_436_9: bit-extract s_436_4 s_436_2 s_436_8
        let s_436_9: Bits = (Bits::new(
            ((s_436_4) >> (s_436_2)).value(),
            u16::try_from(s_436_8).unwrap(),
        ));
        // D s_436_10: cast reint s_436_9 -> u8
        let s_436_10: u8 = (s_436_9.value() as u8);
        // D s_436_11: cast zx s_436_10 -> bv
        let s_436_11: Bits = Bits::new(s_436_10 as u128, 8u16);
        // C s_436_12: const #116u : u8
        let s_436_12: u8 = 116;
        // C s_436_13: cast zx s_436_12 -> bv
        let s_436_13: Bits = Bits::new(s_436_12 as u128, 8u16);
        // D s_436_14: cmp-eq s_436_11 s_436_13
        let s_436_14: bool = ((s_436_11) == (s_436_13));
        // N s_436_15: branch s_436_14 b1301 b437
        if s_436_14 {
            return block_1301(state, tracer, fn_state);
        } else {
            return block_437(state, tracer, fn_state);
        };
    }
    fn block_437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_437_0: const #0u : u8
        let s_437_0: bool = false;
        // D s_437_1: write-var gs#409978 <= s_437_0
        fn_state.gs_409978 = s_437_0;
        // N s_437_2: jump b438
        return block_438(state, tracer, fn_state);
    }
    fn block_438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_438_0: read-var gs#409978:u8
        let s_438_0: bool = fn_state.gs_409978;
        // N s_438_1: branch s_438_0 b1297 b439
        if s_438_0 {
            return block_1297(state, tracer, fn_state);
        } else {
            return block_439(state, tracer, fn_state);
        };
    }
    fn block_439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_439_0: const #0u : u8
        let s_439_0: bool = false;
        // D s_439_1: write-var gs#409983 <= s_439_0
        fn_state.gs_409983 = s_439_0;
        // N s_439_2: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_440_0: read-var gs#409983:u8
        let s_440_0: bool = fn_state.gs_409983;
        // D s_440_1: not s_440_0
        let s_440_1: bool = !s_440_0;
        // N s_440_2: branch s_440_1 b442 b441
        if s_440_1 {
            return block_442(state, tracer, fn_state);
        } else {
            return block_441(state, tracer, fn_state);
        };
    }
    fn block_441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_441_0: const #3156s : i
        let s_441_0: i128 = 3156;
        // C s_441_1: const #14696u : u32
        let s_441_1: u32 = 14696;
        // N s_441_2: write-reg s_441_1 <= s_441_0
        let s_441_2: () = {
            state.write_register::<i128>(s_441_1 as isize, s_441_0);
            tracer.write_register(s_441_1 as isize, s_441_0);
        };
        // C s_441_3: const #28s : i
        let s_441_3: i128 = 28;
        // C s_441_4: const #4s : i
        let s_441_4: i128 = 4;
        // D s_441_5: read-var u#33580:u32
        let s_441_5: u32 = fn_state.u_33580;
        // D s_441_6: cast zx s_441_5 -> bv
        let s_441_6: Bits = Bits::new(s_441_5 as u128, 32u16);
        // D s_441_7: bit-extract s_441_6 s_441_3 s_441_4
        let s_441_7: Bits = (Bits::new(
            ((s_441_6) >> (s_441_3)).value(),
            u16::try_from(s_441_4).unwrap(),
        ));
        // D s_441_8: cast reint s_441_7 -> u8
        let s_441_8: u8 = (s_441_7.value() as u8);
        // C s_441_9: const #16s : i
        let s_441_9: i128 = 16;
        // C s_441_10: const #4s : i
        let s_441_10: i128 = 4;
        // D s_441_11: read-var u#33580:u32
        let s_441_11: u32 = fn_state.u_33580;
        // D s_441_12: cast zx s_441_11 -> bv
        let s_441_12: Bits = Bits::new(s_441_11 as u128, 32u16);
        // D s_441_13: bit-extract s_441_12 s_441_9 s_441_10
        let s_441_13: Bits = (Bits::new(
            ((s_441_12) >> (s_441_9)).value(),
            u16::try_from(s_441_10).unwrap(),
        ));
        // D s_441_14: cast reint s_441_13 -> u8
        let s_441_14: u8 = (s_441_13.value() as u8);
        // C s_441_15: const #12s : i
        let s_441_15: i128 = 12;
        // C s_441_16: const #4s : i
        let s_441_16: i128 = 4;
        // D s_441_17: read-var u#33580:u32
        let s_441_17: u32 = fn_state.u_33580;
        // D s_441_18: cast zx s_441_17 -> bv
        let s_441_18: Bits = Bits::new(s_441_17 as u128, 32u16);
        // D s_441_19: bit-extract s_441_18 s_441_15 s_441_16
        let s_441_19: Bits = (Bits::new(
            ((s_441_18) >> (s_441_15)).value(),
            u16::try_from(s_441_16).unwrap(),
        ));
        // D s_441_20: cast reint s_441_19 -> u8
        let s_441_20: u8 = (s_441_19.value() as u8);
        // C s_441_21: const #8s : i
        let s_441_21: i128 = 8;
        // C s_441_22: const #4s : i
        let s_441_22: i128 = 4;
        // D s_441_23: read-var u#33580:u32
        let s_441_23: u32 = fn_state.u_33580;
        // D s_441_24: cast zx s_441_23 -> bv
        let s_441_24: Bits = Bits::new(s_441_23 as u128, 32u16);
        // D s_441_25: bit-extract s_441_24 s_441_21 s_441_22
        let s_441_25: Bits = (Bits::new(
            ((s_441_24) >> (s_441_21)).value(),
            u16::try_from(s_441_22).unwrap(),
        ));
        // D s_441_26: cast reint s_441_25 -> u8
        let s_441_26: u8 = (s_441_25.value() as u8);
        // C s_441_27: const #5s : i
        let s_441_27: i128 = 5;
        // C s_441_28: const #1s : i
        let s_441_28: i128 = 1;
        // D s_441_29: read-var u#33580:u32
        let s_441_29: u32 = fn_state.u_33580;
        // D s_441_30: cast zx s_441_29 -> bv
        let s_441_30: Bits = Bits::new(s_441_29 as u128, 32u16);
        // D s_441_31: bit-extract s_441_30 s_441_27 s_441_28
        let s_441_31: Bits = (Bits::new(
            ((s_441_30) >> (s_441_27)).value(),
            u16::try_from(s_441_28).unwrap(),
        ));
        // D s_441_32: cast reint s_441_31 -> u8
        let s_441_32: bool = ((s_441_31.value()) != 0);
        // C s_441_33: const #0s : i
        let s_441_33: i128 = 0;
        // C s_441_34: const #4s : i
        let s_441_34: i128 = 4;
        // D s_441_35: read-var u#33580:u32
        let s_441_35: u32 = fn_state.u_33580;
        // D s_441_36: cast zx s_441_35 -> bv
        let s_441_36: Bits = Bits::new(s_441_35 as u128, 32u16);
        // D s_441_37: bit-extract s_441_36 s_441_33 s_441_34
        let s_441_37: Bits = (Bits::new(
            ((s_441_36) >> (s_441_33)).value(),
            u16::try_from(s_441_34).unwrap(),
        ));
        // D s_441_38: cast reint s_441_37 -> u8
        let s_441_38: u8 = (s_441_37.value() as u8);
        // D s_441_39: call decode_aarch32_instrs_SMLSLD_A1enc_A_txt(s_441_8, s_441_14, s_441_20, s_441_26, s_441_32, s_441_38)
        let s_441_39: () = decode_aarch32_instrs_SMLSLD_A1enc_A_txt(
            state,
            tracer,
            s_441_8,
            s_441_14,
            s_441_20,
            s_441_26,
            s_441_32,
            s_441_38,
        );
        // N s_441_40: return
        return;
    }
    fn block_442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_442_0: read-var merge#var.1:struct
        let s_442_0: u32 = fn_state.merge_var._1;
        // D s_442_1: write-var u#33588 <= s_442_0
        fn_state.u_33588 = s_442_0;
        // C s_442_2: const #20s : i
        let s_442_2: i128 = 20;
        // D s_442_3: read-var u#33588:u32
        let s_442_3: u32 = fn_state.u_33588;
        // D s_442_4: cast zx s_442_3 -> bv
        let s_442_4: Bits = Bits::new(s_442_3 as u128, 32u16);
        // C s_442_5: const #1s : i64
        let s_442_5: i64 = 1;
        // C s_442_6: cast zx s_442_5 -> i
        let s_442_6: i128 = (i128::try_from(s_442_5).unwrap());
        // C s_442_7: const #7s : i
        let s_442_7: i128 = 7;
        // C s_442_8: add s_442_7 s_442_6
        let s_442_8: i128 = (s_442_7 + s_442_6);
        // D s_442_9: bit-extract s_442_4 s_442_2 s_442_8
        let s_442_9: Bits = (Bits::new(
            ((s_442_4) >> (s_442_2)).value(),
            u16::try_from(s_442_8).unwrap(),
        ));
        // D s_442_10: cast reint s_442_9 -> u8
        let s_442_10: u8 = (s_442_9.value() as u8);
        // D s_442_11: cast zx s_442_10 -> bv
        let s_442_11: Bits = Bits::new(s_442_10 as u128, 8u16);
        // C s_442_12: const #117u : u8
        let s_442_12: u8 = 117;
        // C s_442_13: cast zx s_442_12 -> bv
        let s_442_13: Bits = Bits::new(s_442_12 as u128, 8u16);
        // D s_442_14: cmp-eq s_442_11 s_442_13
        let s_442_14: bool = ((s_442_11) == (s_442_13));
        // N s_442_15: branch s_442_14 b1293 b443
        if s_442_14 {
            return block_1293(state, tracer, fn_state);
        } else {
            return block_443(state, tracer, fn_state);
        };
    }
    fn block_443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_443_0: const #0u : u8
        let s_443_0: bool = false;
        // D s_443_1: write-var gs#410006 <= s_443_0
        fn_state.gs_410006 = s_443_0;
        // N s_443_2: jump b444
        return block_444(state, tracer, fn_state);
    }
    fn block_444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_444_0: read-var gs#410006:u8
        let s_444_0: bool = fn_state.gs_410006;
        // N s_444_1: branch s_444_0 b1289 b445
        if s_444_0 {
            return block_1289(state, tracer, fn_state);
        } else {
            return block_445(state, tracer, fn_state);
        };
    }
    fn block_445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_445_0: const #0u : u8
        let s_445_0: bool = false;
        // D s_445_1: write-var gs#410011 <= s_445_0
        fn_state.gs_410011 = s_445_0;
        // N s_445_2: jump b446
        return block_446(state, tracer, fn_state);
    }
    fn block_446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_446_0: read-var gs#410011:u8
        let s_446_0: bool = fn_state.gs_410011;
        // D s_446_1: not s_446_0
        let s_446_1: bool = !s_446_0;
        // N s_446_2: branch s_446_1 b448 b447
        if s_446_1 {
            return block_448(state, tracer, fn_state);
        } else {
            return block_447(state, tracer, fn_state);
        };
    }
    fn block_447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_447_0: const #3158s : i
        let s_447_0: i128 = 3158;
        // C s_447_1: const #14696u : u32
        let s_447_1: u32 = 14696;
        // N s_447_2: write-reg s_447_1 <= s_447_0
        let s_447_2: () = {
            state.write_register::<i128>(s_447_1 as isize, s_447_0);
            tracer.write_register(s_447_1 as isize, s_447_0);
        };
        // C s_447_3: const #28s : i
        let s_447_3: i128 = 28;
        // C s_447_4: const #4s : i
        let s_447_4: i128 = 4;
        // D s_447_5: read-var u#33588:u32
        let s_447_5: u32 = fn_state.u_33588;
        // D s_447_6: cast zx s_447_5 -> bv
        let s_447_6: Bits = Bits::new(s_447_5 as u128, 32u16);
        // D s_447_7: bit-extract s_447_6 s_447_3 s_447_4
        let s_447_7: Bits = (Bits::new(
            ((s_447_6) >> (s_447_3)).value(),
            u16::try_from(s_447_4).unwrap(),
        ));
        // D s_447_8: cast reint s_447_7 -> u8
        let s_447_8: u8 = (s_447_7.value() as u8);
        // C s_447_9: const #16s : i
        let s_447_9: i128 = 16;
        // C s_447_10: const #4s : i
        let s_447_10: i128 = 4;
        // D s_447_11: read-var u#33588:u32
        let s_447_11: u32 = fn_state.u_33588;
        // D s_447_12: cast zx s_447_11 -> bv
        let s_447_12: Bits = Bits::new(s_447_11 as u128, 32u16);
        // D s_447_13: bit-extract s_447_12 s_447_9 s_447_10
        let s_447_13: Bits = (Bits::new(
            ((s_447_12) >> (s_447_9)).value(),
            u16::try_from(s_447_10).unwrap(),
        ));
        // D s_447_14: cast reint s_447_13 -> u8
        let s_447_14: u8 = (s_447_13.value() as u8);
        // C s_447_15: const #12s : i
        let s_447_15: i128 = 12;
        // C s_447_16: const #4s : i
        let s_447_16: i128 = 4;
        // D s_447_17: read-var u#33588:u32
        let s_447_17: u32 = fn_state.u_33588;
        // D s_447_18: cast zx s_447_17 -> bv
        let s_447_18: Bits = Bits::new(s_447_17 as u128, 32u16);
        // D s_447_19: bit-extract s_447_18 s_447_15 s_447_16
        let s_447_19: Bits = (Bits::new(
            ((s_447_18) >> (s_447_15)).value(),
            u16::try_from(s_447_16).unwrap(),
        ));
        // D s_447_20: cast reint s_447_19 -> u8
        let s_447_20: u8 = (s_447_19.value() as u8);
        // C s_447_21: const #8s : i
        let s_447_21: i128 = 8;
        // C s_447_22: const #4s : i
        let s_447_22: i128 = 4;
        // D s_447_23: read-var u#33588:u32
        let s_447_23: u32 = fn_state.u_33588;
        // D s_447_24: cast zx s_447_23 -> bv
        let s_447_24: Bits = Bits::new(s_447_23 as u128, 32u16);
        // D s_447_25: bit-extract s_447_24 s_447_21 s_447_22
        let s_447_25: Bits = (Bits::new(
            ((s_447_24) >> (s_447_21)).value(),
            u16::try_from(s_447_22).unwrap(),
        ));
        // D s_447_26: cast reint s_447_25 -> u8
        let s_447_26: u8 = (s_447_25.value() as u8);
        // C s_447_27: const #5s : i
        let s_447_27: i128 = 5;
        // C s_447_28: const #1s : i
        let s_447_28: i128 = 1;
        // D s_447_29: read-var u#33588:u32
        let s_447_29: u32 = fn_state.u_33588;
        // D s_447_30: cast zx s_447_29 -> bv
        let s_447_30: Bits = Bits::new(s_447_29 as u128, 32u16);
        // D s_447_31: bit-extract s_447_30 s_447_27 s_447_28
        let s_447_31: Bits = (Bits::new(
            ((s_447_30) >> (s_447_27)).value(),
            u16::try_from(s_447_28).unwrap(),
        ));
        // D s_447_32: cast reint s_447_31 -> u8
        let s_447_32: bool = ((s_447_31.value()) != 0);
        // C s_447_33: const #0s : i
        let s_447_33: i128 = 0;
        // C s_447_34: const #4s : i
        let s_447_34: i128 = 4;
        // D s_447_35: read-var u#33588:u32
        let s_447_35: u32 = fn_state.u_33588;
        // D s_447_36: cast zx s_447_35 -> bv
        let s_447_36: Bits = Bits::new(s_447_35 as u128, 32u16);
        // D s_447_37: bit-extract s_447_36 s_447_33 s_447_34
        let s_447_37: Bits = (Bits::new(
            ((s_447_36) >> (s_447_33)).value(),
            u16::try_from(s_447_34).unwrap(),
        ));
        // D s_447_38: cast reint s_447_37 -> u8
        let s_447_38: u8 = (s_447_37.value() as u8);
        // D s_447_39: call decode_aarch32_instrs_SMMLA_A1enc_A_txt(s_447_8, s_447_14, s_447_20, s_447_26, s_447_32, s_447_38)
        let s_447_39: () = decode_aarch32_instrs_SMMLA_A1enc_A_txt(
            state,
            tracer,
            s_447_8,
            s_447_14,
            s_447_20,
            s_447_26,
            s_447_32,
            s_447_38,
        );
        // N s_447_40: return
        return;
    }
    fn block_448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_448_0: read-var merge#var.1:struct
        let s_448_0: u32 = fn_state.merge_var._1;
        // D s_448_1: write-var u#33595 <= s_448_0
        fn_state.u_33595 = s_448_0;
        // C s_448_2: const #20s : i
        let s_448_2: i128 = 20;
        // D s_448_3: read-var u#33595:u32
        let s_448_3: u32 = fn_state.u_33595;
        // D s_448_4: cast zx s_448_3 -> bv
        let s_448_4: Bits = Bits::new(s_448_3 as u128, 32u16);
        // C s_448_5: const #1s : i64
        let s_448_5: i64 = 1;
        // C s_448_6: cast zx s_448_5 -> i
        let s_448_6: i128 = (i128::try_from(s_448_5).unwrap());
        // C s_448_7: const #7s : i
        let s_448_7: i128 = 7;
        // C s_448_8: add s_448_7 s_448_6
        let s_448_8: i128 = (s_448_7 + s_448_6);
        // D s_448_9: bit-extract s_448_4 s_448_2 s_448_8
        let s_448_9: Bits = (Bits::new(
            ((s_448_4) >> (s_448_2)).value(),
            u16::try_from(s_448_8).unwrap(),
        ));
        // D s_448_10: cast reint s_448_9 -> u8
        let s_448_10: u8 = (s_448_9.value() as u8);
        // D s_448_11: cast zx s_448_10 -> bv
        let s_448_11: Bits = Bits::new(s_448_10 as u128, 8u16);
        // C s_448_12: const #117u : u8
        let s_448_12: u8 = 117;
        // C s_448_13: cast zx s_448_12 -> bv
        let s_448_13: Bits = Bits::new(s_448_12 as u128, 8u16);
        // D s_448_14: cmp-eq s_448_11 s_448_13
        let s_448_14: bool = ((s_448_11) == (s_448_13));
        // N s_448_15: branch s_448_14 b1285 b449
        if s_448_14 {
            return block_1285(state, tracer, fn_state);
        } else {
            return block_449(state, tracer, fn_state);
        };
    }
    fn block_449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_449_0: const #0u : u8
        let s_449_0: bool = false;
        // D s_449_1: write-var gs#410034 <= s_449_0
        fn_state.gs_410034 = s_449_0;
        // N s_449_2: jump b450
        return block_450(state, tracer, fn_state);
    }
    fn block_450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_450_0: read-var gs#410034:u8
        let s_450_0: bool = fn_state.gs_410034;
        // N s_450_1: branch s_450_0 b1281 b451
        if s_450_0 {
            return block_1281(state, tracer, fn_state);
        } else {
            return block_451(state, tracer, fn_state);
        };
    }
    fn block_451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_451_0: const #0u : u8
        let s_451_0: bool = false;
        // D s_451_1: write-var gs#410039 <= s_451_0
        fn_state.gs_410039 = s_451_0;
        // N s_451_2: jump b452
        return block_452(state, tracer, fn_state);
    }
    fn block_452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_452_0: read-var gs#410039:u8
        let s_452_0: bool = fn_state.gs_410039;
        // D s_452_1: not s_452_0
        let s_452_1: bool = !s_452_0;
        // N s_452_2: branch s_452_1 b454 b453
        if s_452_1 {
            return block_454(state, tracer, fn_state);
        } else {
            return block_453(state, tracer, fn_state);
        };
    }
    fn block_453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_453_0: const #3160s : i
        let s_453_0: i128 = 3160;
        // C s_453_1: const #14696u : u32
        let s_453_1: u32 = 14696;
        // N s_453_2: write-reg s_453_1 <= s_453_0
        let s_453_2: () = {
            state.write_register::<i128>(s_453_1 as isize, s_453_0);
            tracer.write_register(s_453_1 as isize, s_453_0);
        };
        // C s_453_3: const #28s : i
        let s_453_3: i128 = 28;
        // C s_453_4: const #4s : i
        let s_453_4: i128 = 4;
        // D s_453_5: read-var u#33595:u32
        let s_453_5: u32 = fn_state.u_33595;
        // D s_453_6: cast zx s_453_5 -> bv
        let s_453_6: Bits = Bits::new(s_453_5 as u128, 32u16);
        // D s_453_7: bit-extract s_453_6 s_453_3 s_453_4
        let s_453_7: Bits = (Bits::new(
            ((s_453_6) >> (s_453_3)).value(),
            u16::try_from(s_453_4).unwrap(),
        ));
        // D s_453_8: cast reint s_453_7 -> u8
        let s_453_8: u8 = (s_453_7.value() as u8);
        // C s_453_9: const #16s : i
        let s_453_9: i128 = 16;
        // C s_453_10: const #4s : i
        let s_453_10: i128 = 4;
        // D s_453_11: read-var u#33595:u32
        let s_453_11: u32 = fn_state.u_33595;
        // D s_453_12: cast zx s_453_11 -> bv
        let s_453_12: Bits = Bits::new(s_453_11 as u128, 32u16);
        // D s_453_13: bit-extract s_453_12 s_453_9 s_453_10
        let s_453_13: Bits = (Bits::new(
            ((s_453_12) >> (s_453_9)).value(),
            u16::try_from(s_453_10).unwrap(),
        ));
        // D s_453_14: cast reint s_453_13 -> u8
        let s_453_14: u8 = (s_453_13.value() as u8);
        // C s_453_15: const #12s : i
        let s_453_15: i128 = 12;
        // C s_453_16: const #4s : i
        let s_453_16: i128 = 4;
        // D s_453_17: read-var u#33595:u32
        let s_453_17: u32 = fn_state.u_33595;
        // D s_453_18: cast zx s_453_17 -> bv
        let s_453_18: Bits = Bits::new(s_453_17 as u128, 32u16);
        // D s_453_19: bit-extract s_453_18 s_453_15 s_453_16
        let s_453_19: Bits = (Bits::new(
            ((s_453_18) >> (s_453_15)).value(),
            u16::try_from(s_453_16).unwrap(),
        ));
        // D s_453_20: cast reint s_453_19 -> u8
        let s_453_20: u8 = (s_453_19.value() as u8);
        // C s_453_21: const #8s : i
        let s_453_21: i128 = 8;
        // C s_453_22: const #4s : i
        let s_453_22: i128 = 4;
        // D s_453_23: read-var u#33595:u32
        let s_453_23: u32 = fn_state.u_33595;
        // D s_453_24: cast zx s_453_23 -> bv
        let s_453_24: Bits = Bits::new(s_453_23 as u128, 32u16);
        // D s_453_25: bit-extract s_453_24 s_453_21 s_453_22
        let s_453_25: Bits = (Bits::new(
            ((s_453_24) >> (s_453_21)).value(),
            u16::try_from(s_453_22).unwrap(),
        ));
        // D s_453_26: cast reint s_453_25 -> u8
        let s_453_26: u8 = (s_453_25.value() as u8);
        // C s_453_27: const #5s : i
        let s_453_27: i128 = 5;
        // C s_453_28: const #1s : i
        let s_453_28: i128 = 1;
        // D s_453_29: read-var u#33595:u32
        let s_453_29: u32 = fn_state.u_33595;
        // D s_453_30: cast zx s_453_29 -> bv
        let s_453_30: Bits = Bits::new(s_453_29 as u128, 32u16);
        // D s_453_31: bit-extract s_453_30 s_453_27 s_453_28
        let s_453_31: Bits = (Bits::new(
            ((s_453_30) >> (s_453_27)).value(),
            u16::try_from(s_453_28).unwrap(),
        ));
        // D s_453_32: cast reint s_453_31 -> u8
        let s_453_32: bool = ((s_453_31.value()) != 0);
        // C s_453_33: const #0s : i
        let s_453_33: i128 = 0;
        // C s_453_34: const #4s : i
        let s_453_34: i128 = 4;
        // D s_453_35: read-var u#33595:u32
        let s_453_35: u32 = fn_state.u_33595;
        // D s_453_36: cast zx s_453_35 -> bv
        let s_453_36: Bits = Bits::new(s_453_35 as u128, 32u16);
        // D s_453_37: bit-extract s_453_36 s_453_33 s_453_34
        let s_453_37: Bits = (Bits::new(
            ((s_453_36) >> (s_453_33)).value(),
            u16::try_from(s_453_34).unwrap(),
        ));
        // D s_453_38: cast reint s_453_37 -> u8
        let s_453_38: u8 = (s_453_37.value() as u8);
        // D s_453_39: call decode_aarch32_instrs_SMMLS_A1enc_A_txt(s_453_8, s_453_14, s_453_20, s_453_26, s_453_32, s_453_38)
        let s_453_39: () = decode_aarch32_instrs_SMMLS_A1enc_A_txt(
            state,
            tracer,
            s_453_8,
            s_453_14,
            s_453_20,
            s_453_26,
            s_453_32,
            s_453_38,
        );
        // N s_453_40: return
        return;
    }
    fn block_454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_454_0: read-var merge#var.1:struct
        let s_454_0: u32 = fn_state.merge_var._1;
        // D s_454_1: write-var u#33603 <= s_454_0
        fn_state.u_33603 = s_454_0;
        // C s_454_2: const #20s : i
        let s_454_2: i128 = 20;
        // D s_454_3: read-var u#33603:u32
        let s_454_3: u32 = fn_state.u_33603;
        // D s_454_4: cast zx s_454_3 -> bv
        let s_454_4: Bits = Bits::new(s_454_3 as u128, 32u16);
        // C s_454_5: const #1s : i64
        let s_454_5: i64 = 1;
        // C s_454_6: cast zx s_454_5 -> i
        let s_454_6: i128 = (i128::try_from(s_454_5).unwrap());
        // C s_454_7: const #7s : i
        let s_454_7: i128 = 7;
        // C s_454_8: add s_454_7 s_454_6
        let s_454_8: i128 = (s_454_7 + s_454_6);
        // D s_454_9: bit-extract s_454_4 s_454_2 s_454_8
        let s_454_9: Bits = (Bits::new(
            ((s_454_4) >> (s_454_2)).value(),
            u16::try_from(s_454_8).unwrap(),
        ));
        // D s_454_10: cast reint s_454_9 -> u8
        let s_454_10: u8 = (s_454_9.value() as u8);
        // D s_454_11: cast zx s_454_10 -> bv
        let s_454_11: Bits = Bits::new(s_454_10 as u128, 8u16);
        // C s_454_12: const #117u : u8
        let s_454_12: u8 = 117;
        // C s_454_13: cast zx s_454_12 -> bv
        let s_454_13: Bits = Bits::new(s_454_12 as u128, 8u16);
        // D s_454_14: cmp-eq s_454_11 s_454_13
        let s_454_14: bool = ((s_454_11) == (s_454_13));
        // N s_454_15: branch s_454_14 b1274 b455
        if s_454_14 {
            return block_1274(state, tracer, fn_state);
        } else {
            return block_455(state, tracer, fn_state);
        };
    }
    fn block_455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_455_0: const #0u : u8
        let s_455_0: bool = false;
        // D s_455_1: write-var gs#410065 <= s_455_0
        fn_state.gs_410065 = s_455_0;
        // N s_455_2: jump b456
        return block_456(state, tracer, fn_state);
    }
    fn block_456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_456_0: read-var gs#410065:u8
        let s_456_0: bool = fn_state.gs_410065;
        // N s_456_1: branch s_456_0 b1270 b457
        if s_456_0 {
            return block_1270(state, tracer, fn_state);
        } else {
            return block_457(state, tracer, fn_state);
        };
    }
    fn block_457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_457_0: const #0u : u8
        let s_457_0: bool = false;
        // D s_457_1: write-var gs#410070 <= s_457_0
        fn_state.gs_410070 = s_457_0;
        // N s_457_2: jump b458
        return block_458(state, tracer, fn_state);
    }
    fn block_458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_458_0: read-var gs#410070:u8
        let s_458_0: bool = fn_state.gs_410070;
        // D s_458_1: not s_458_0
        let s_458_1: bool = !s_458_0;
        // N s_458_2: branch s_458_1 b460 b459
        if s_458_1 {
            return block_460(state, tracer, fn_state);
        } else {
            return block_459(state, tracer, fn_state);
        };
    }
    fn block_459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_459_0: const #3162s : i
        let s_459_0: i128 = 3162;
        // C s_459_1: const #14696u : u32
        let s_459_1: u32 = 14696;
        // N s_459_2: write-reg s_459_1 <= s_459_0
        let s_459_2: () = {
            state.write_register::<i128>(s_459_1 as isize, s_459_0);
            tracer.write_register(s_459_1 as isize, s_459_0);
        };
        // C s_459_3: const #28s : i
        let s_459_3: i128 = 28;
        // C s_459_4: const #4s : i
        let s_459_4: i128 = 4;
        // D s_459_5: read-var u#33603:u32
        let s_459_5: u32 = fn_state.u_33603;
        // D s_459_6: cast zx s_459_5 -> bv
        let s_459_6: Bits = Bits::new(s_459_5 as u128, 32u16);
        // D s_459_7: bit-extract s_459_6 s_459_3 s_459_4
        let s_459_7: Bits = (Bits::new(
            ((s_459_6) >> (s_459_3)).value(),
            u16::try_from(s_459_4).unwrap(),
        ));
        // D s_459_8: cast reint s_459_7 -> u8
        let s_459_8: u8 = (s_459_7.value() as u8);
        // C s_459_9: const #16s : i
        let s_459_9: i128 = 16;
        // C s_459_10: const #4s : i
        let s_459_10: i128 = 4;
        // D s_459_11: read-var u#33603:u32
        let s_459_11: u32 = fn_state.u_33603;
        // D s_459_12: cast zx s_459_11 -> bv
        let s_459_12: Bits = Bits::new(s_459_11 as u128, 32u16);
        // D s_459_13: bit-extract s_459_12 s_459_9 s_459_10
        let s_459_13: Bits = (Bits::new(
            ((s_459_12) >> (s_459_9)).value(),
            u16::try_from(s_459_10).unwrap(),
        ));
        // D s_459_14: cast reint s_459_13 -> u8
        let s_459_14: u8 = (s_459_13.value() as u8);
        // C s_459_15: const #8s : i
        let s_459_15: i128 = 8;
        // C s_459_16: const #4s : i
        let s_459_16: i128 = 4;
        // D s_459_17: read-var u#33603:u32
        let s_459_17: u32 = fn_state.u_33603;
        // D s_459_18: cast zx s_459_17 -> bv
        let s_459_18: Bits = Bits::new(s_459_17 as u128, 32u16);
        // D s_459_19: bit-extract s_459_18 s_459_15 s_459_16
        let s_459_19: Bits = (Bits::new(
            ((s_459_18) >> (s_459_15)).value(),
            u16::try_from(s_459_16).unwrap(),
        ));
        // D s_459_20: cast reint s_459_19 -> u8
        let s_459_20: u8 = (s_459_19.value() as u8);
        // C s_459_21: const #5s : i
        let s_459_21: i128 = 5;
        // C s_459_22: const #1s : i
        let s_459_22: i128 = 1;
        // D s_459_23: read-var u#33603:u32
        let s_459_23: u32 = fn_state.u_33603;
        // D s_459_24: cast zx s_459_23 -> bv
        let s_459_24: Bits = Bits::new(s_459_23 as u128, 32u16);
        // D s_459_25: bit-extract s_459_24 s_459_21 s_459_22
        let s_459_25: Bits = (Bits::new(
            ((s_459_24) >> (s_459_21)).value(),
            u16::try_from(s_459_22).unwrap(),
        ));
        // D s_459_26: cast reint s_459_25 -> u8
        let s_459_26: bool = ((s_459_25.value()) != 0);
        // C s_459_27: const #0s : i
        let s_459_27: i128 = 0;
        // C s_459_28: const #4s : i
        let s_459_28: i128 = 4;
        // D s_459_29: read-var u#33603:u32
        let s_459_29: u32 = fn_state.u_33603;
        // D s_459_30: cast zx s_459_29 -> bv
        let s_459_30: Bits = Bits::new(s_459_29 as u128, 32u16);
        // D s_459_31: bit-extract s_459_30 s_459_27 s_459_28
        let s_459_31: Bits = (Bits::new(
            ((s_459_30) >> (s_459_27)).value(),
            u16::try_from(s_459_28).unwrap(),
        ));
        // D s_459_32: cast reint s_459_31 -> u8
        let s_459_32: u8 = (s_459_31.value() as u8);
        // D s_459_33: call decode_aarch32_instrs_SMMUL_A1enc_A_txt(s_459_8, s_459_14, s_459_20, s_459_26, s_459_32)
        let s_459_33: () = decode_aarch32_instrs_SMMUL_A1enc_A_txt(
            state,
            tracer,
            s_459_8,
            s_459_14,
            s_459_20,
            s_459_26,
            s_459_32,
        );
        // N s_459_34: return
        return;
    }
    fn block_460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_460_0: read-var merge#var.1:struct
        let s_460_0: u32 = fn_state.merge_var._1;
        // D s_460_1: write-var u#33610 <= s_460_0
        fn_state.u_33610 = s_460_0;
        // C s_460_2: const #20s : i
        let s_460_2: i128 = 20;
        // D s_460_3: read-var u#33610:u32
        let s_460_3: u32 = fn_state.u_33610;
        // D s_460_4: cast zx s_460_3 -> bv
        let s_460_4: Bits = Bits::new(s_460_3 as u128, 32u16);
        // C s_460_5: const #1s : i64
        let s_460_5: i64 = 1;
        // C s_460_6: cast zx s_460_5 -> i
        let s_460_6: i128 = (i128::try_from(s_460_5).unwrap());
        // C s_460_7: const #7s : i
        let s_460_7: i128 = 7;
        // C s_460_8: add s_460_7 s_460_6
        let s_460_8: i128 = (s_460_7 + s_460_6);
        // D s_460_9: bit-extract s_460_4 s_460_2 s_460_8
        let s_460_9: Bits = (Bits::new(
            ((s_460_4) >> (s_460_2)).value(),
            u16::try_from(s_460_8).unwrap(),
        ));
        // D s_460_10: cast reint s_460_9 -> u8
        let s_460_10: u8 = (s_460_9.value() as u8);
        // D s_460_11: cast zx s_460_10 -> bv
        let s_460_11: Bits = Bits::new(s_460_10 as u128, 8u16);
        // C s_460_12: const #112u : u8
        let s_460_12: u8 = 112;
        // C s_460_13: cast zx s_460_12 -> bv
        let s_460_13: Bits = Bits::new(s_460_12 as u128, 8u16);
        // D s_460_14: cmp-eq s_460_11 s_460_13
        let s_460_14: bool = ((s_460_11) == (s_460_13));
        // N s_460_15: branch s_460_14 b1263 b461
        if s_460_14 {
            return block_1263(state, tracer, fn_state);
        } else {
            return block_461(state, tracer, fn_state);
        };
    }
    fn block_461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_461_0: const #0u : u8
        let s_461_0: bool = false;
        // D s_461_1: write-var gs#410094 <= s_461_0
        fn_state.gs_410094 = s_461_0;
        // N s_461_2: jump b462
        return block_462(state, tracer, fn_state);
    }
    fn block_462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_462_0: read-var gs#410094:u8
        let s_462_0: bool = fn_state.gs_410094;
        // N s_462_1: branch s_462_0 b1259 b463
        if s_462_0 {
            return block_1259(state, tracer, fn_state);
        } else {
            return block_463(state, tracer, fn_state);
        };
    }
    fn block_463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_463_0: const #0u : u8
        let s_463_0: bool = false;
        // D s_463_1: write-var gs#410099 <= s_463_0
        fn_state.gs_410099 = s_463_0;
        // N s_463_2: jump b464
        return block_464(state, tracer, fn_state);
    }
    fn block_464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_464_0: read-var gs#410099:u8
        let s_464_0: bool = fn_state.gs_410099;
        // D s_464_1: not s_464_0
        let s_464_1: bool = !s_464_0;
        // N s_464_2: branch s_464_1 b466 b465
        if s_464_1 {
            return block_466(state, tracer, fn_state);
        } else {
            return block_465(state, tracer, fn_state);
        };
    }
    fn block_465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_465_0: const #3164s : i
        let s_465_0: i128 = 3164;
        // C s_465_1: const #14696u : u32
        let s_465_1: u32 = 14696;
        // N s_465_2: write-reg s_465_1 <= s_465_0
        let s_465_2: () = {
            state.write_register::<i128>(s_465_1 as isize, s_465_0);
            tracer.write_register(s_465_1 as isize, s_465_0);
        };
        // C s_465_3: const #28s : i
        let s_465_3: i128 = 28;
        // C s_465_4: const #4s : i
        let s_465_4: i128 = 4;
        // D s_465_5: read-var u#33610:u32
        let s_465_5: u32 = fn_state.u_33610;
        // D s_465_6: cast zx s_465_5 -> bv
        let s_465_6: Bits = Bits::new(s_465_5 as u128, 32u16);
        // D s_465_7: bit-extract s_465_6 s_465_3 s_465_4
        let s_465_7: Bits = (Bits::new(
            ((s_465_6) >> (s_465_3)).value(),
            u16::try_from(s_465_4).unwrap(),
        ));
        // D s_465_8: cast reint s_465_7 -> u8
        let s_465_8: u8 = (s_465_7.value() as u8);
        // C s_465_9: const #16s : i
        let s_465_9: i128 = 16;
        // C s_465_10: const #4s : i
        let s_465_10: i128 = 4;
        // D s_465_11: read-var u#33610:u32
        let s_465_11: u32 = fn_state.u_33610;
        // D s_465_12: cast zx s_465_11 -> bv
        let s_465_12: Bits = Bits::new(s_465_11 as u128, 32u16);
        // D s_465_13: bit-extract s_465_12 s_465_9 s_465_10
        let s_465_13: Bits = (Bits::new(
            ((s_465_12) >> (s_465_9)).value(),
            u16::try_from(s_465_10).unwrap(),
        ));
        // D s_465_14: cast reint s_465_13 -> u8
        let s_465_14: u8 = (s_465_13.value() as u8);
        // C s_465_15: const #8s : i
        let s_465_15: i128 = 8;
        // C s_465_16: const #4s : i
        let s_465_16: i128 = 4;
        // D s_465_17: read-var u#33610:u32
        let s_465_17: u32 = fn_state.u_33610;
        // D s_465_18: cast zx s_465_17 -> bv
        let s_465_18: Bits = Bits::new(s_465_17 as u128, 32u16);
        // D s_465_19: bit-extract s_465_18 s_465_15 s_465_16
        let s_465_19: Bits = (Bits::new(
            ((s_465_18) >> (s_465_15)).value(),
            u16::try_from(s_465_16).unwrap(),
        ));
        // D s_465_20: cast reint s_465_19 -> u8
        let s_465_20: u8 = (s_465_19.value() as u8);
        // C s_465_21: const #5s : i
        let s_465_21: i128 = 5;
        // C s_465_22: const #1s : i
        let s_465_22: i128 = 1;
        // D s_465_23: read-var u#33610:u32
        let s_465_23: u32 = fn_state.u_33610;
        // D s_465_24: cast zx s_465_23 -> bv
        let s_465_24: Bits = Bits::new(s_465_23 as u128, 32u16);
        // D s_465_25: bit-extract s_465_24 s_465_21 s_465_22
        let s_465_25: Bits = (Bits::new(
            ((s_465_24) >> (s_465_21)).value(),
            u16::try_from(s_465_22).unwrap(),
        ));
        // D s_465_26: cast reint s_465_25 -> u8
        let s_465_26: bool = ((s_465_25.value()) != 0);
        // C s_465_27: const #0s : i
        let s_465_27: i128 = 0;
        // C s_465_28: const #4s : i
        let s_465_28: i128 = 4;
        // D s_465_29: read-var u#33610:u32
        let s_465_29: u32 = fn_state.u_33610;
        // D s_465_30: cast zx s_465_29 -> bv
        let s_465_30: Bits = Bits::new(s_465_29 as u128, 32u16);
        // D s_465_31: bit-extract s_465_30 s_465_27 s_465_28
        let s_465_31: Bits = (Bits::new(
            ((s_465_30) >> (s_465_27)).value(),
            u16::try_from(s_465_28).unwrap(),
        ));
        // D s_465_32: cast reint s_465_31 -> u8
        let s_465_32: u8 = (s_465_31.value() as u8);
        // D s_465_33: call decode_aarch32_instrs_SMUAD_A1enc_A_txt(s_465_8, s_465_14, s_465_20, s_465_26, s_465_32)
        let s_465_33: () = decode_aarch32_instrs_SMUAD_A1enc_A_txt(
            state,
            tracer,
            s_465_8,
            s_465_14,
            s_465_20,
            s_465_26,
            s_465_32,
        );
        // N s_465_34: return
        return;
    }
    fn block_466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_466_0: read-var merge#var.1:struct
        let s_466_0: u32 = fn_state.merge_var._1;
        // D s_466_1: write-var u#33617 <= s_466_0
        fn_state.u_33617 = s_466_0;
        // C s_466_2: const #20s : i
        let s_466_2: i128 = 20;
        // D s_466_3: read-var u#33617:u32
        let s_466_3: u32 = fn_state.u_33617;
        // D s_466_4: cast zx s_466_3 -> bv
        let s_466_4: Bits = Bits::new(s_466_3 as u128, 32u16);
        // C s_466_5: const #1s : i64
        let s_466_5: i64 = 1;
        // C s_466_6: cast zx s_466_5 -> i
        let s_466_6: i128 = (i128::try_from(s_466_5).unwrap());
        // C s_466_7: const #7s : i
        let s_466_7: i128 = 7;
        // C s_466_8: add s_466_7 s_466_6
        let s_466_8: i128 = (s_466_7 + s_466_6);
        // D s_466_9: bit-extract s_466_4 s_466_2 s_466_8
        let s_466_9: Bits = (Bits::new(
            ((s_466_4) >> (s_466_2)).value(),
            u16::try_from(s_466_8).unwrap(),
        ));
        // D s_466_10: cast reint s_466_9 -> u8
        let s_466_10: u8 = (s_466_9.value() as u8);
        // D s_466_11: cast zx s_466_10 -> bv
        let s_466_11: Bits = Bits::new(s_466_10 as u128, 8u16);
        // C s_466_12: const #112u : u8
        let s_466_12: u8 = 112;
        // C s_466_13: cast zx s_466_12 -> bv
        let s_466_13: Bits = Bits::new(s_466_12 as u128, 8u16);
        // D s_466_14: cmp-eq s_466_11 s_466_13
        let s_466_14: bool = ((s_466_11) == (s_466_13));
        // N s_466_15: branch s_466_14 b1252 b467
        if s_466_14 {
            return block_1252(state, tracer, fn_state);
        } else {
            return block_467(state, tracer, fn_state);
        };
    }
    fn block_467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_467_0: const #0u : u8
        let s_467_0: bool = false;
        // D s_467_1: write-var gs#410123 <= s_467_0
        fn_state.gs_410123 = s_467_0;
        // N s_467_2: jump b468
        return block_468(state, tracer, fn_state);
    }
    fn block_468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_468_0: read-var gs#410123:u8
        let s_468_0: bool = fn_state.gs_410123;
        // N s_468_1: branch s_468_0 b1248 b469
        if s_468_0 {
            return block_1248(state, tracer, fn_state);
        } else {
            return block_469(state, tracer, fn_state);
        };
    }
    fn block_469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_469_0: const #0u : u8
        let s_469_0: bool = false;
        // D s_469_1: write-var gs#410128 <= s_469_0
        fn_state.gs_410128 = s_469_0;
        // N s_469_2: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_470_0: read-var gs#410128:u8
        let s_470_0: bool = fn_state.gs_410128;
        // D s_470_1: not s_470_0
        let s_470_1: bool = !s_470_0;
        // N s_470_2: branch s_470_1 b472 b471
        if s_470_1 {
            return block_472(state, tracer, fn_state);
        } else {
            return block_471(state, tracer, fn_state);
        };
    }
    fn block_471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_471_0: const #3172s : i
        let s_471_0: i128 = 3172;
        // C s_471_1: const #14696u : u32
        let s_471_1: u32 = 14696;
        // N s_471_2: write-reg s_471_1 <= s_471_0
        let s_471_2: () = {
            state.write_register::<i128>(s_471_1 as isize, s_471_0);
            tracer.write_register(s_471_1 as isize, s_471_0);
        };
        // C s_471_3: const #28s : i
        let s_471_3: i128 = 28;
        // C s_471_4: const #4s : i
        let s_471_4: i128 = 4;
        // D s_471_5: read-var u#33617:u32
        let s_471_5: u32 = fn_state.u_33617;
        // D s_471_6: cast zx s_471_5 -> bv
        let s_471_6: Bits = Bits::new(s_471_5 as u128, 32u16);
        // D s_471_7: bit-extract s_471_6 s_471_3 s_471_4
        let s_471_7: Bits = (Bits::new(
            ((s_471_6) >> (s_471_3)).value(),
            u16::try_from(s_471_4).unwrap(),
        ));
        // D s_471_8: cast reint s_471_7 -> u8
        let s_471_8: u8 = (s_471_7.value() as u8);
        // C s_471_9: const #16s : i
        let s_471_9: i128 = 16;
        // C s_471_10: const #4s : i
        let s_471_10: i128 = 4;
        // D s_471_11: read-var u#33617:u32
        let s_471_11: u32 = fn_state.u_33617;
        // D s_471_12: cast zx s_471_11 -> bv
        let s_471_12: Bits = Bits::new(s_471_11 as u128, 32u16);
        // D s_471_13: bit-extract s_471_12 s_471_9 s_471_10
        let s_471_13: Bits = (Bits::new(
            ((s_471_12) >> (s_471_9)).value(),
            u16::try_from(s_471_10).unwrap(),
        ));
        // D s_471_14: cast reint s_471_13 -> u8
        let s_471_14: u8 = (s_471_13.value() as u8);
        // C s_471_15: const #8s : i
        let s_471_15: i128 = 8;
        // C s_471_16: const #4s : i
        let s_471_16: i128 = 4;
        // D s_471_17: read-var u#33617:u32
        let s_471_17: u32 = fn_state.u_33617;
        // D s_471_18: cast zx s_471_17 -> bv
        let s_471_18: Bits = Bits::new(s_471_17 as u128, 32u16);
        // D s_471_19: bit-extract s_471_18 s_471_15 s_471_16
        let s_471_19: Bits = (Bits::new(
            ((s_471_18) >> (s_471_15)).value(),
            u16::try_from(s_471_16).unwrap(),
        ));
        // D s_471_20: cast reint s_471_19 -> u8
        let s_471_20: u8 = (s_471_19.value() as u8);
        // C s_471_21: const #5s : i
        let s_471_21: i128 = 5;
        // C s_471_22: const #1s : i
        let s_471_22: i128 = 1;
        // D s_471_23: read-var u#33617:u32
        let s_471_23: u32 = fn_state.u_33617;
        // D s_471_24: cast zx s_471_23 -> bv
        let s_471_24: Bits = Bits::new(s_471_23 as u128, 32u16);
        // D s_471_25: bit-extract s_471_24 s_471_21 s_471_22
        let s_471_25: Bits = (Bits::new(
            ((s_471_24) >> (s_471_21)).value(),
            u16::try_from(s_471_22).unwrap(),
        ));
        // D s_471_26: cast reint s_471_25 -> u8
        let s_471_26: bool = ((s_471_25.value()) != 0);
        // C s_471_27: const #0s : i
        let s_471_27: i128 = 0;
        // C s_471_28: const #4s : i
        let s_471_28: i128 = 4;
        // D s_471_29: read-var u#33617:u32
        let s_471_29: u32 = fn_state.u_33617;
        // D s_471_30: cast zx s_471_29 -> bv
        let s_471_30: Bits = Bits::new(s_471_29 as u128, 32u16);
        // D s_471_31: bit-extract s_471_30 s_471_27 s_471_28
        let s_471_31: Bits = (Bits::new(
            ((s_471_30) >> (s_471_27)).value(),
            u16::try_from(s_471_28).unwrap(),
        ));
        // D s_471_32: cast reint s_471_31 -> u8
        let s_471_32: u8 = (s_471_31.value() as u8);
        // D s_471_33: call decode_aarch32_instrs_SMUSD_A1enc_A_txt(s_471_8, s_471_14, s_471_20, s_471_26, s_471_32)
        let s_471_33: () = decode_aarch32_instrs_SMUSD_A1enc_A_txt(
            state,
            tracer,
            s_471_8,
            s_471_14,
            s_471_20,
            s_471_26,
            s_471_32,
        );
        // N s_471_34: return
        return;
    }
    fn block_472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_472_0: read-var merge#var.1:struct
        let s_472_0: u32 = fn_state.merge_var._1;
        // D s_472_1: write-var u#33624 <= s_472_0
        fn_state.u_33624 = s_472_0;
        // C s_472_2: const #20s : i
        let s_472_2: i128 = 20;
        // D s_472_3: read-var u#33624:u32
        let s_472_3: u32 = fn_state.u_33624;
        // D s_472_4: cast zx s_472_3 -> bv
        let s_472_4: Bits = Bits::new(s_472_3 as u128, 32u16);
        // C s_472_5: const #1s : i64
        let s_472_5: i64 = 1;
        // C s_472_6: cast zx s_472_5 -> i
        let s_472_6: i128 = (i128::try_from(s_472_5).unwrap());
        // C s_472_7: const #7s : i
        let s_472_7: i128 = 7;
        // C s_472_8: add s_472_7 s_472_6
        let s_472_8: i128 = (s_472_7 + s_472_6);
        // D s_472_9: bit-extract s_472_4 s_472_2 s_472_8
        let s_472_9: Bits = (Bits::new(
            ((s_472_4) >> (s_472_2)).value(),
            u16::try_from(s_472_8).unwrap(),
        ));
        // D s_472_10: cast reint s_472_9 -> u8
        let s_472_10: u8 = (s_472_9.value() as u8);
        // D s_472_11: cast zx s_472_10 -> bv
        let s_472_11: Bits = Bits::new(s_472_10 as u128, 8u16);
        // C s_472_12: const #106u : u8
        let s_472_12: u8 = 106;
        // C s_472_13: cast zx s_472_12 -> bv
        let s_472_13: Bits = Bits::new(s_472_12 as u128, 8u16);
        // D s_472_14: cmp-eq s_472_11 s_472_13
        let s_472_14: bool = ((s_472_11) == (s_472_13));
        // N s_472_15: branch s_472_14 b1247 b473
        if s_472_14 {
            return block_1247(state, tracer, fn_state);
        } else {
            return block_473(state, tracer, fn_state);
        };
    }
    fn block_473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_473_0: const #0u : u8
        let s_473_0: bool = false;
        // D s_473_1: write-var gs#410146 <= s_473_0
        fn_state.gs_410146 = s_473_0;
        // N s_473_2: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_474_0: read-var gs#410146:u8
        let s_474_0: bool = fn_state.gs_410146;
        // N s_474_1: branch s_474_0 b1243 b475
        if s_474_0 {
            return block_1243(state, tracer, fn_state);
        } else {
            return block_475(state, tracer, fn_state);
        };
    }
    fn block_475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_475_0: const #0u : u8
        let s_475_0: bool = false;
        // D s_475_1: write-var gs#410151 <= s_475_0
        fn_state.gs_410151 = s_475_0;
        // N s_475_2: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_476_0: read-var gs#410151:u8
        let s_476_0: bool = fn_state.gs_410151;
        // D s_476_1: not s_476_0
        let s_476_1: bool = !s_476_0;
        // N s_476_2: branch s_476_1 b489 b477
        if s_476_1 {
            return block_489(state, tracer, fn_state);
        } else {
            return block_477(state, tracer, fn_state);
        };
    }
    fn block_477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_477_0: const #3174s : i
        let s_477_0: i128 = 3174;
        // C s_477_1: const #14696u : u32
        let s_477_1: u32 = 14696;
        // N s_477_2: write-reg s_477_1 <= s_477_0
        let s_477_2: () = {
            state.write_register::<i128>(s_477_1 as isize, s_477_0);
            tracer.write_register(s_477_1 as isize, s_477_0);
        };
        // C s_477_3: const #28s : i
        let s_477_3: i128 = 28;
        // C s_477_4: const #4s : i
        let s_477_4: i128 = 4;
        // D s_477_5: read-var u#33624:u32
        let s_477_5: u32 = fn_state.u_33624;
        // D s_477_6: cast zx s_477_5 -> bv
        let s_477_6: Bits = Bits::new(s_477_5 as u128, 32u16);
        // D s_477_7: bit-extract s_477_6 s_477_3 s_477_4
        let s_477_7: Bits = (Bits::new(
            ((s_477_6) >> (s_477_3)).value(),
            u16::try_from(s_477_4).unwrap(),
        ));
        // D s_477_8: cast reint s_477_7 -> u8
        let s_477_8: u8 = (s_477_7.value() as u8);
        // D s_477_9: write-var u#33625 <= s_477_8
        fn_state.u_33625 = s_477_8;
        // C s_477_10: const #16s : i
        let s_477_10: i128 = 16;
        // C s_477_11: const #4s : i
        let s_477_11: i128 = 4;
        // D s_477_12: read-var u#33624:u32
        let s_477_12: u32 = fn_state.u_33624;
        // D s_477_13: cast zx s_477_12 -> bv
        let s_477_13: Bits = Bits::new(s_477_12 as u128, 32u16);
        // D s_477_14: bit-extract s_477_13 s_477_10 s_477_11
        let s_477_14: Bits = (Bits::new(
            ((s_477_13) >> (s_477_10)).value(),
            u16::try_from(s_477_11).unwrap(),
        ));
        // D s_477_15: cast reint s_477_14 -> u8
        let s_477_15: u8 = (s_477_14.value() as u8);
        // D s_477_16: write-var sat_imm <= s_477_15
        fn_state.sat_imm = s_477_15;
        // C s_477_17: const #12s : i
        let s_477_17: i128 = 12;
        // C s_477_18: const #4s : i
        let s_477_18: i128 = 4;
        // D s_477_19: read-var u#33624:u32
        let s_477_19: u32 = fn_state.u_33624;
        // D s_477_20: cast zx s_477_19 -> bv
        let s_477_20: Bits = Bits::new(s_477_19 as u128, 32u16);
        // D s_477_21: bit-extract s_477_20 s_477_17 s_477_18
        let s_477_21: Bits = (Bits::new(
            ((s_477_20) >> (s_477_17)).value(),
            u16::try_from(s_477_18).unwrap(),
        ));
        // D s_477_22: cast reint s_477_21 -> u8
        let s_477_22: u8 = (s_477_21.value() as u8);
        // D s_477_23: write-var u#33626 <= s_477_22
        fn_state.u_33626 = s_477_22;
        // C s_477_24: const #0s : i
        let s_477_24: i128 = 0;
        // C s_477_25: const #4s : i
        let s_477_25: i128 = 4;
        // D s_477_26: read-var u#33624:u32
        let s_477_26: u32 = fn_state.u_33624;
        // D s_477_27: cast zx s_477_26 -> bv
        let s_477_27: Bits = Bits::new(s_477_26 as u128, 32u16);
        // D s_477_28: bit-extract s_477_27 s_477_24 s_477_25
        let s_477_28: Bits = (Bits::new(
            ((s_477_27) >> (s_477_24)).value(),
            u16::try_from(s_477_25).unwrap(),
        ));
        // D s_477_29: cast reint s_477_28 -> u8
        let s_477_29: u8 = (s_477_28.value() as u8);
        // D s_477_30: write-var u#33627 <= s_477_29
        fn_state.u_33627 = s_477_29;
        // C s_477_31: const #8s : i
        let s_477_31: i128 = 8;
        // D s_477_32: read-var u#33624:u32
        let s_477_32: u32 = fn_state.u_33624;
        // D s_477_33: cast zx s_477_32 -> bv
        let s_477_33: Bits = Bits::new(s_477_32 as u128, 32u16);
        // C s_477_34: const #1u : u64
        let s_477_34: u64 = 1;
        // D s_477_35: bit-extract s_477_33 s_477_31 s_477_34
        let s_477_35: Bits = (Bits::new(
            ((s_477_33) >> (s_477_31)).value(),
            u16::try_from(s_477_34).unwrap(),
        ));
        // D s_477_36: cast reint s_477_35 -> u8
        let s_477_36: bool = ((s_477_35.value()) != 0);
        // C s_477_37: const #0s : i
        let s_477_37: i128 = 0;
        // C s_477_38: const #0u : u64
        let s_477_38: u64 = 0;
        // D s_477_39: cast zx s_477_36 -> u64
        let s_477_39: u64 = (s_477_36 as u64);
        // C s_477_40: const #1u : u64
        let s_477_40: u64 = 1;
        // D s_477_41: and s_477_39 s_477_40
        let s_477_41: u64 = ((s_477_39) & (s_477_40));
        // D s_477_42: cmp-eq s_477_41 s_477_40
        let s_477_42: bool = ((s_477_41) == (s_477_40));
        // D s_477_43: lsl s_477_39 s_477_37
        let s_477_43: u64 = s_477_39 << s_477_37;
        // D s_477_44: or s_477_38 s_477_43
        let s_477_44: u64 = ((s_477_38) | (s_477_43));
        // D s_477_45: cmpl s_477_43
        let s_477_45: u64 = !s_477_43;
        // D s_477_46: and s_477_38 s_477_45
        let s_477_46: u64 = ((s_477_38) & (s_477_45));
        // D s_477_47: select s_477_42 s_477_44 s_477_46
        let s_477_47: u64 = if s_477_42 { s_477_44 } else { s_477_46 };
        // D s_477_48: cast trunc s_477_47 -> u8
        let s_477_48: bool = ((s_477_47) != 0);
        // D s_477_49: cast zx s_477_48 -> bv
        let s_477_49: Bits = Bits::new(s_477_48 as u128, 1u16);
        // C s_477_50: const #1u : u8
        let s_477_50: bool = true;
        // C s_477_51: cast zx s_477_50 -> bv
        let s_477_51: Bits = Bits::new(s_477_50 as u128, 1u16);
        // D s_477_52: cmp-ne s_477_49 s_477_51
        let s_477_52: bool = ((s_477_49) != (s_477_51));
        // N s_477_53: branch s_477_52 b488 b478
        if s_477_52 {
            return block_488(state, tracer, fn_state);
        } else {
            return block_478(state, tracer, fn_state);
        };
    }
    fn block_478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_478_0: const #9s : i
        let s_478_0: i128 = 9;
        // D s_478_1: read-var u#33624:u32
        let s_478_1: u32 = fn_state.u_33624;
        // D s_478_2: cast zx s_478_1 -> bv
        let s_478_2: Bits = Bits::new(s_478_1 as u128, 32u16);
        // C s_478_3: const #1u : u64
        let s_478_3: u64 = 1;
        // D s_478_4: bit-extract s_478_2 s_478_0 s_478_3
        let s_478_4: Bits = (Bits::new(
            ((s_478_2) >> (s_478_0)).value(),
            u16::try_from(s_478_3).unwrap(),
        ));
        // D s_478_5: cast reint s_478_4 -> u8
        let s_478_5: bool = ((s_478_4.value()) != 0);
        // C s_478_6: const #0s : i
        let s_478_6: i128 = 0;
        // C s_478_7: const #0u : u64
        let s_478_7: u64 = 0;
        // D s_478_8: cast zx s_478_5 -> u64
        let s_478_8: u64 = (s_478_5 as u64);
        // C s_478_9: const #1u : u64
        let s_478_9: u64 = 1;
        // D s_478_10: and s_478_8 s_478_9
        let s_478_10: u64 = ((s_478_8) & (s_478_9));
        // D s_478_11: cmp-eq s_478_10 s_478_9
        let s_478_11: bool = ((s_478_10) == (s_478_9));
        // D s_478_12: lsl s_478_8 s_478_6
        let s_478_12: u64 = s_478_8 << s_478_6;
        // D s_478_13: or s_478_7 s_478_12
        let s_478_13: u64 = ((s_478_7) | (s_478_12));
        // D s_478_14: cmpl s_478_12
        let s_478_14: u64 = !s_478_12;
        // D s_478_15: and s_478_7 s_478_14
        let s_478_15: u64 = ((s_478_7) & (s_478_14));
        // D s_478_16: select s_478_11 s_478_13 s_478_15
        let s_478_16: u64 = if s_478_11 { s_478_13 } else { s_478_15 };
        // D s_478_17: cast trunc s_478_16 -> u8
        let s_478_17: bool = ((s_478_16) != 0);
        // D s_478_18: cast zx s_478_17 -> bv
        let s_478_18: Bits = Bits::new(s_478_17 as u128, 1u16);
        // C s_478_19: const #1u : u8
        let s_478_19: bool = true;
        // C s_478_20: cast zx s_478_19 -> bv
        let s_478_20: Bits = Bits::new(s_478_19 as u128, 1u16);
        // D s_478_21: cmp-ne s_478_18 s_478_20
        let s_478_21: bool = ((s_478_18) != (s_478_20));
        // D s_478_22: write-var gs#410166 <= s_478_21
        fn_state.gs_410166 = s_478_21;
        // N s_478_23: jump b479
        return block_479(state, tracer, fn_state);
    }
    fn block_479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_479_0: read-var gs#410166:u8
        let s_479_0: bool = fn_state.gs_410166;
        // N s_479_1: branch s_479_0 b487 b480
        if s_479_0 {
            return block_487(state, tracer, fn_state);
        } else {
            return block_480(state, tracer, fn_state);
        };
    }
    fn block_480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_480_0: const #10s : i
        let s_480_0: i128 = 10;
        // D s_480_1: read-var u#33624:u32
        let s_480_1: u32 = fn_state.u_33624;
        // D s_480_2: cast zx s_480_1 -> bv
        let s_480_2: Bits = Bits::new(s_480_1 as u128, 32u16);
        // C s_480_3: const #1u : u64
        let s_480_3: u64 = 1;
        // D s_480_4: bit-extract s_480_2 s_480_0 s_480_3
        let s_480_4: Bits = (Bits::new(
            ((s_480_2) >> (s_480_0)).value(),
            u16::try_from(s_480_3).unwrap(),
        ));
        // D s_480_5: cast reint s_480_4 -> u8
        let s_480_5: bool = ((s_480_4.value()) != 0);
        // C s_480_6: const #0s : i
        let s_480_6: i128 = 0;
        // C s_480_7: const #0u : u64
        let s_480_7: u64 = 0;
        // D s_480_8: cast zx s_480_5 -> u64
        let s_480_8: u64 = (s_480_5 as u64);
        // C s_480_9: const #1u : u64
        let s_480_9: u64 = 1;
        // D s_480_10: and s_480_8 s_480_9
        let s_480_10: u64 = ((s_480_8) & (s_480_9));
        // D s_480_11: cmp-eq s_480_10 s_480_9
        let s_480_11: bool = ((s_480_10) == (s_480_9));
        // D s_480_12: lsl s_480_8 s_480_6
        let s_480_12: u64 = s_480_8 << s_480_6;
        // D s_480_13: or s_480_7 s_480_12
        let s_480_13: u64 = ((s_480_7) | (s_480_12));
        // D s_480_14: cmpl s_480_12
        let s_480_14: u64 = !s_480_12;
        // D s_480_15: and s_480_7 s_480_14
        let s_480_15: u64 = ((s_480_7) & (s_480_14));
        // D s_480_16: select s_480_11 s_480_13 s_480_15
        let s_480_16: u64 = if s_480_11 { s_480_13 } else { s_480_15 };
        // D s_480_17: cast trunc s_480_16 -> u8
        let s_480_17: bool = ((s_480_16) != 0);
        // D s_480_18: cast zx s_480_17 -> bv
        let s_480_18: Bits = Bits::new(s_480_17 as u128, 1u16);
        // C s_480_19: const #1u : u8
        let s_480_19: bool = true;
        // C s_480_20: cast zx s_480_19 -> bv
        let s_480_20: Bits = Bits::new(s_480_19 as u128, 1u16);
        // D s_480_21: cmp-ne s_480_18 s_480_20
        let s_480_21: bool = ((s_480_18) != (s_480_20));
        // D s_480_22: write-var gs#410169 <= s_480_21
        fn_state.gs_410169 = s_480_21;
        // N s_480_23: jump b481
        return block_481(state, tracer, fn_state);
    }
    fn block_481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_481_0: read-var gs#410169:u8
        let s_481_0: bool = fn_state.gs_410169;
        // N s_481_1: branch s_481_0 b486 b482
        if s_481_0 {
            return block_486(state, tracer, fn_state);
        } else {
            return block_482(state, tracer, fn_state);
        };
    }
    fn block_482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_482_0: const #11s : i
        let s_482_0: i128 = 11;
        // D s_482_1: read-var u#33624:u32
        let s_482_1: u32 = fn_state.u_33624;
        // D s_482_2: cast zx s_482_1 -> bv
        let s_482_2: Bits = Bits::new(s_482_1 as u128, 32u16);
        // C s_482_3: const #1u : u64
        let s_482_3: u64 = 1;
        // D s_482_4: bit-extract s_482_2 s_482_0 s_482_3
        let s_482_4: Bits = (Bits::new(
            ((s_482_2) >> (s_482_0)).value(),
            u16::try_from(s_482_3).unwrap(),
        ));
        // D s_482_5: cast reint s_482_4 -> u8
        let s_482_5: bool = ((s_482_4.value()) != 0);
        // C s_482_6: const #0s : i
        let s_482_6: i128 = 0;
        // C s_482_7: const #0u : u64
        let s_482_7: u64 = 0;
        // D s_482_8: cast zx s_482_5 -> u64
        let s_482_8: u64 = (s_482_5 as u64);
        // C s_482_9: const #1u : u64
        let s_482_9: u64 = 1;
        // D s_482_10: and s_482_8 s_482_9
        let s_482_10: u64 = ((s_482_8) & (s_482_9));
        // D s_482_11: cmp-eq s_482_10 s_482_9
        let s_482_11: bool = ((s_482_10) == (s_482_9));
        // D s_482_12: lsl s_482_8 s_482_6
        let s_482_12: u64 = s_482_8 << s_482_6;
        // D s_482_13: or s_482_7 s_482_12
        let s_482_13: u64 = ((s_482_7) | (s_482_12));
        // D s_482_14: cmpl s_482_12
        let s_482_14: u64 = !s_482_12;
        // D s_482_15: and s_482_7 s_482_14
        let s_482_15: u64 = ((s_482_7) & (s_482_14));
        // D s_482_16: select s_482_11 s_482_13 s_482_15
        let s_482_16: u64 = if s_482_11 { s_482_13 } else { s_482_15 };
        // D s_482_17: cast trunc s_482_16 -> u8
        let s_482_17: bool = ((s_482_16) != 0);
        // D s_482_18: cast zx s_482_17 -> bv
        let s_482_18: Bits = Bits::new(s_482_17 as u128, 1u16);
        // C s_482_19: const #1u : u8
        let s_482_19: bool = true;
        // C s_482_20: cast zx s_482_19 -> bv
        let s_482_20: Bits = Bits::new(s_482_19 as u128, 1u16);
        // D s_482_21: cmp-ne s_482_18 s_482_20
        let s_482_21: bool = ((s_482_18) != (s_482_20));
        // D s_482_22: write-var gs#410172 <= s_482_21
        fn_state.gs_410172 = s_482_21;
        // N s_482_23: jump b483
        return block_483(state, tracer, fn_state);
    }
    fn block_483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_483_0: read-var gs#410172:u8
        let s_483_0: bool = fn_state.gs_410172;
        // N s_483_1: branch s_483_0 b485 b484
        if s_483_0 {
            return block_485(state, tracer, fn_state);
        } else {
            return block_484(state, tracer, fn_state);
        };
    }
    fn block_484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_484_0: read-var u#33625:u8
        let s_484_0: u8 = fn_state.u_33625;
        // D s_484_1: read-var sat_imm:u8
        let s_484_1: u8 = fn_state.sat_imm;
        // D s_484_2: read-var u#33626:u8
        let s_484_2: u8 = fn_state.u_33626;
        // D s_484_3: read-var u#33627:u8
        let s_484_3: u8 = fn_state.u_33627;
        // D s_484_4: call decode_aarch32_instrs_SSAT16_A1enc_A_txt(s_484_0, s_484_1, s_484_2, s_484_3)
        let s_484_4: () = decode_aarch32_instrs_SSAT16_A1enc_A_txt(
            state,
            tracer,
            s_484_0,
            s_484_1,
            s_484_2,
            s_484_3,
        );
        // N s_484_5: return
        return;
    }
    fn block_485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_485_0: panic
        panic!("{:?}", ());
        // N s_485_1: return
        return;
    }
    fn block_486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_486_0: const #1u : u8
        let s_486_0: bool = true;
        // D s_486_1: write-var gs#410172 <= s_486_0
        fn_state.gs_410172 = s_486_0;
        // N s_486_2: jump b483
        return block_483(state, tracer, fn_state);
    }
    fn block_487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_487_0: const #1u : u8
        let s_487_0: bool = true;
        // D s_487_1: write-var gs#410169 <= s_487_0
        fn_state.gs_410169 = s_487_0;
        // N s_487_2: jump b481
        return block_481(state, tracer, fn_state);
    }
    fn block_488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_488_0: const #1u : u8
        let s_488_0: bool = true;
        // D s_488_1: write-var gs#410166 <= s_488_0
        fn_state.gs_410166 = s_488_0;
        // N s_488_2: jump b479
        return block_479(state, tracer, fn_state);
    }
    fn block_489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_489_0: read-var merge#var.1:struct
        let s_489_0: u32 = fn_state.merge_var._1;
        // D s_489_1: write-var u#33629 <= s_489_0
        fn_state.u_33629 = s_489_0;
        // C s_489_2: const #21s : i
        let s_489_2: i128 = 21;
        // D s_489_3: read-var u#33629:u32
        let s_489_3: u32 = fn_state.u_33629;
        // D s_489_4: cast zx s_489_3 -> bv
        let s_489_4: Bits = Bits::new(s_489_3 as u128, 32u16);
        // C s_489_5: const #1s : i64
        let s_489_5: i64 = 1;
        // C s_489_6: cast zx s_489_5 -> i
        let s_489_6: i128 = (i128::try_from(s_489_5).unwrap());
        // C s_489_7: const #6s : i
        let s_489_7: i128 = 6;
        // C s_489_8: add s_489_7 s_489_6
        let s_489_8: i128 = (s_489_7 + s_489_6);
        // D s_489_9: bit-extract s_489_4 s_489_2 s_489_8
        let s_489_9: Bits = (Bits::new(
            ((s_489_4) >> (s_489_2)).value(),
            u16::try_from(s_489_8).unwrap(),
        ));
        // D s_489_10: cast reint s_489_9 -> u8
        let s_489_10: u8 = (s_489_9.value() as u8);
        // D s_489_11: cast zx s_489_10 -> bv
        let s_489_11: Bits = Bits::new(s_489_10 as u128, 7u16);
        // C s_489_12: const #53u : u8
        let s_489_12: u8 = 53;
        // C s_489_13: cast zx s_489_12 -> bv
        let s_489_13: Bits = Bits::new(s_489_12 as u128, 7u16);
        // D s_489_14: cmp-eq s_489_11 s_489_13
        let s_489_14: bool = ((s_489_11) == (s_489_13));
        // N s_489_15: branch s_489_14 b1242 b490
        if s_489_14 {
            return block_1242(state, tracer, fn_state);
        } else {
            return block_490(state, tracer, fn_state);
        };
    }
    fn block_490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_490_0: const #0u : u8
        let s_490_0: bool = false;
        // D s_490_1: write-var gs#410178 <= s_490_0
        fn_state.gs_410178 = s_490_0;
        // N s_490_2: jump b491
        return block_491(state, tracer, fn_state);
    }
    fn block_491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_491_0: read-var gs#410178:u8
        let s_491_0: bool = fn_state.gs_410178;
        // N s_491_1: branch s_491_0 b1238 b492
        if s_491_0 {
            return block_1238(state, tracer, fn_state);
        } else {
            return block_492(state, tracer, fn_state);
        };
    }
    fn block_492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_492_0: const #0u : u8
        let s_492_0: bool = false;
        // D s_492_1: write-var gs#410183 <= s_492_0
        fn_state.gs_410183 = s_492_0;
        // N s_492_2: jump b493
        return block_493(state, tracer, fn_state);
    }
    fn block_493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_493_0: read-var gs#410183:u8
        let s_493_0: bool = fn_state.gs_410183;
        // D s_493_1: not s_493_0
        let s_493_1: bool = !s_493_0;
        // N s_493_2: branch s_493_1 b495 b494
        if s_493_1 {
            return block_495(state, tracer, fn_state);
        } else {
            return block_494(state, tracer, fn_state);
        };
    }
    fn block_494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_494_0: const #3176s : i
        let s_494_0: i128 = 3176;
        // C s_494_1: const #14696u : u32
        let s_494_1: u32 = 14696;
        // N s_494_2: write-reg s_494_1 <= s_494_0
        let s_494_2: () = {
            state.write_register::<i128>(s_494_1 as isize, s_494_0);
            tracer.write_register(s_494_1 as isize, s_494_0);
        };
        // C s_494_3: const #28s : i
        let s_494_3: i128 = 28;
        // C s_494_4: const #4s : i
        let s_494_4: i128 = 4;
        // D s_494_5: read-var u#33629:u32
        let s_494_5: u32 = fn_state.u_33629;
        // D s_494_6: cast zx s_494_5 -> bv
        let s_494_6: Bits = Bits::new(s_494_5 as u128, 32u16);
        // D s_494_7: bit-extract s_494_6 s_494_3 s_494_4
        let s_494_7: Bits = (Bits::new(
            ((s_494_6) >> (s_494_3)).value(),
            u16::try_from(s_494_4).unwrap(),
        ));
        // D s_494_8: cast reint s_494_7 -> u8
        let s_494_8: u8 = (s_494_7.value() as u8);
        // C s_494_9: const #16s : i
        let s_494_9: i128 = 16;
        // C s_494_10: const #5s : i
        let s_494_10: i128 = 5;
        // D s_494_11: read-var u#33629:u32
        let s_494_11: u32 = fn_state.u_33629;
        // D s_494_12: cast zx s_494_11 -> bv
        let s_494_12: Bits = Bits::new(s_494_11 as u128, 32u16);
        // D s_494_13: bit-extract s_494_12 s_494_9 s_494_10
        let s_494_13: Bits = (Bits::new(
            ((s_494_12) >> (s_494_9)).value(),
            u16::try_from(s_494_10).unwrap(),
        ));
        // D s_494_14: cast reint s_494_13 -> u8
        let s_494_14: u8 = (s_494_13.value() as u8);
        // C s_494_15: const #12s : i
        let s_494_15: i128 = 12;
        // C s_494_16: const #4s : i
        let s_494_16: i128 = 4;
        // D s_494_17: read-var u#33629:u32
        let s_494_17: u32 = fn_state.u_33629;
        // D s_494_18: cast zx s_494_17 -> bv
        let s_494_18: Bits = Bits::new(s_494_17 as u128, 32u16);
        // D s_494_19: bit-extract s_494_18 s_494_15 s_494_16
        let s_494_19: Bits = (Bits::new(
            ((s_494_18) >> (s_494_15)).value(),
            u16::try_from(s_494_16).unwrap(),
        ));
        // D s_494_20: cast reint s_494_19 -> u8
        let s_494_20: u8 = (s_494_19.value() as u8);
        // C s_494_21: const #7s : i
        let s_494_21: i128 = 7;
        // C s_494_22: const #5s : i
        let s_494_22: i128 = 5;
        // D s_494_23: read-var u#33629:u32
        let s_494_23: u32 = fn_state.u_33629;
        // D s_494_24: cast zx s_494_23 -> bv
        let s_494_24: Bits = Bits::new(s_494_23 as u128, 32u16);
        // D s_494_25: bit-extract s_494_24 s_494_21 s_494_22
        let s_494_25: Bits = (Bits::new(
            ((s_494_24) >> (s_494_21)).value(),
            u16::try_from(s_494_22).unwrap(),
        ));
        // D s_494_26: cast reint s_494_25 -> u8
        let s_494_26: u8 = (s_494_25.value() as u8);
        // C s_494_27: const #6s : i
        let s_494_27: i128 = 6;
        // C s_494_28: const #1s : i
        let s_494_28: i128 = 1;
        // D s_494_29: read-var u#33629:u32
        let s_494_29: u32 = fn_state.u_33629;
        // D s_494_30: cast zx s_494_29 -> bv
        let s_494_30: Bits = Bits::new(s_494_29 as u128, 32u16);
        // D s_494_31: bit-extract s_494_30 s_494_27 s_494_28
        let s_494_31: Bits = (Bits::new(
            ((s_494_30) >> (s_494_27)).value(),
            u16::try_from(s_494_28).unwrap(),
        ));
        // D s_494_32: cast reint s_494_31 -> u8
        let s_494_32: bool = ((s_494_31.value()) != 0);
        // C s_494_33: const #0s : i
        let s_494_33: i128 = 0;
        // C s_494_34: const #4s : i
        let s_494_34: i128 = 4;
        // D s_494_35: read-var u#33629:u32
        let s_494_35: u32 = fn_state.u_33629;
        // D s_494_36: cast zx s_494_35 -> bv
        let s_494_36: Bits = Bits::new(s_494_35 as u128, 32u16);
        // D s_494_37: bit-extract s_494_36 s_494_33 s_494_34
        let s_494_37: Bits = (Bits::new(
            ((s_494_36) >> (s_494_33)).value(),
            u16::try_from(s_494_34).unwrap(),
        ));
        // D s_494_38: cast reint s_494_37 -> u8
        let s_494_38: u8 = (s_494_37.value() as u8);
        // D s_494_39: call decode_aarch32_instrs_SSAT_A1enc_A_txt(s_494_8, s_494_14, s_494_20, s_494_26, s_494_32, s_494_38)
        let s_494_39: () = decode_aarch32_instrs_SSAT_A1enc_A_txt(
            state,
            tracer,
            s_494_8,
            s_494_14,
            s_494_20,
            s_494_26,
            s_494_32,
            s_494_38,
        );
        // N s_494_40: return
        return;
    }
    fn block_495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_495_0: read-var merge#var.1:struct
        let s_495_0: u32 = fn_state.merge_var._1;
        // D s_495_1: write-var u#33636 <= s_495_0
        fn_state.u_33636 = s_495_0;
        // C s_495_2: const #20s : i
        let s_495_2: i128 = 20;
        // D s_495_3: read-var u#33636:u32
        let s_495_3: u32 = fn_state.u_33636;
        // D s_495_4: cast zx s_495_3 -> bv
        let s_495_4: Bits = Bits::new(s_495_3 as u128, 32u16);
        // C s_495_5: const #1s : i64
        let s_495_5: i64 = 1;
        // C s_495_6: cast zx s_495_5 -> i
        let s_495_6: i128 = (i128::try_from(s_495_5).unwrap());
        // C s_495_7: const #7s : i
        let s_495_7: i128 = 7;
        // C s_495_8: add s_495_7 s_495_6
        let s_495_8: i128 = (s_495_7 + s_495_6);
        // D s_495_9: bit-extract s_495_4 s_495_2 s_495_8
        let s_495_9: Bits = (Bits::new(
            ((s_495_4) >> (s_495_2)).value(),
            u16::try_from(s_495_8).unwrap(),
        ));
        // D s_495_10: cast reint s_495_9 -> u8
        let s_495_10: u8 = (s_495_9.value() as u8);
        // D s_495_11: cast zx s_495_10 -> bv
        let s_495_11: Bits = Bits::new(s_495_10 as u128, 8u16);
        // C s_495_12: const #97u : u8
        let s_495_12: u8 = 97;
        // C s_495_13: cast zx s_495_12 -> bv
        let s_495_13: Bits = Bits::new(s_495_12 as u128, 8u16);
        // D s_495_14: cmp-eq s_495_11 s_495_13
        let s_495_14: bool = ((s_495_11) == (s_495_13));
        // N s_495_15: branch s_495_14 b1237 b496
        if s_495_14 {
            return block_1237(state, tracer, fn_state);
        } else {
            return block_496(state, tracer, fn_state);
        };
    }
    fn block_496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_496_0: const #0u : u8
        let s_496_0: bool = false;
        // D s_496_1: write-var gs#410203 <= s_496_0
        fn_state.gs_410203 = s_496_0;
        // N s_496_2: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_497_0: read-var gs#410203:u8
        let s_497_0: bool = fn_state.gs_410203;
        // N s_497_1: branch s_497_0 b1233 b498
        if s_497_0 {
            return block_1233(state, tracer, fn_state);
        } else {
            return block_498(state, tracer, fn_state);
        };
    }
    fn block_498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_498_0: const #0u : u8
        let s_498_0: bool = false;
        // D s_498_1: write-var gs#410208 <= s_498_0
        fn_state.gs_410208 = s_498_0;
        // N s_498_2: jump b499
        return block_499(state, tracer, fn_state);
    }
    fn block_499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_499_0: read-var gs#410208:u8
        let s_499_0: bool = fn_state.gs_410208;
        // D s_499_1: not s_499_0
        let s_499_1: bool = !s_499_0;
        // N s_499_2: branch s_499_1 b512 b500
        if s_499_1 {
            return block_512(state, tracer, fn_state);
        } else {
            return block_500(state, tracer, fn_state);
        };
    }
    fn block_500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_500_0: const #3178s : i
        let s_500_0: i128 = 3178;
        // C s_500_1: const #14696u : u32
        let s_500_1: u32 = 14696;
        // N s_500_2: write-reg s_500_1 <= s_500_0
        let s_500_2: () = {
            state.write_register::<i128>(s_500_1 as isize, s_500_0);
            tracer.write_register(s_500_1 as isize, s_500_0);
        };
        // C s_500_3: const #28s : i
        let s_500_3: i128 = 28;
        // C s_500_4: const #4s : i
        let s_500_4: i128 = 4;
        // D s_500_5: read-var u#33636:u32
        let s_500_5: u32 = fn_state.u_33636;
        // D s_500_6: cast zx s_500_5 -> bv
        let s_500_6: Bits = Bits::new(s_500_5 as u128, 32u16);
        // D s_500_7: bit-extract s_500_6 s_500_3 s_500_4
        let s_500_7: Bits = (Bits::new(
            ((s_500_6) >> (s_500_3)).value(),
            u16::try_from(s_500_4).unwrap(),
        ));
        // D s_500_8: cast reint s_500_7 -> u8
        let s_500_8: u8 = (s_500_7.value() as u8);
        // D s_500_9: write-var u#33637 <= s_500_8
        fn_state.u_33637 = s_500_8;
        // C s_500_10: const #16s : i
        let s_500_10: i128 = 16;
        // C s_500_11: const #4s : i
        let s_500_11: i128 = 4;
        // D s_500_12: read-var u#33636:u32
        let s_500_12: u32 = fn_state.u_33636;
        // D s_500_13: cast zx s_500_12 -> bv
        let s_500_13: Bits = Bits::new(s_500_12 as u128, 32u16);
        // D s_500_14: bit-extract s_500_13 s_500_10 s_500_11
        let s_500_14: Bits = (Bits::new(
            ((s_500_13) >> (s_500_10)).value(),
            u16::try_from(s_500_11).unwrap(),
        ));
        // D s_500_15: cast reint s_500_14 -> u8
        let s_500_15: u8 = (s_500_14.value() as u8);
        // D s_500_16: write-var u#33638 <= s_500_15
        fn_state.u_33638 = s_500_15;
        // C s_500_17: const #12s : i
        let s_500_17: i128 = 12;
        // C s_500_18: const #4s : i
        let s_500_18: i128 = 4;
        // D s_500_19: read-var u#33636:u32
        let s_500_19: u32 = fn_state.u_33636;
        // D s_500_20: cast zx s_500_19 -> bv
        let s_500_20: Bits = Bits::new(s_500_19 as u128, 32u16);
        // D s_500_21: bit-extract s_500_20 s_500_17 s_500_18
        let s_500_21: Bits = (Bits::new(
            ((s_500_20) >> (s_500_17)).value(),
            u16::try_from(s_500_18).unwrap(),
        ));
        // D s_500_22: cast reint s_500_21 -> u8
        let s_500_22: u8 = (s_500_21.value() as u8);
        // D s_500_23: write-var u#33639 <= s_500_22
        fn_state.u_33639 = s_500_22;
        // C s_500_24: const #0s : i
        let s_500_24: i128 = 0;
        // C s_500_25: const #4s : i
        let s_500_25: i128 = 4;
        // D s_500_26: read-var u#33636:u32
        let s_500_26: u32 = fn_state.u_33636;
        // D s_500_27: cast zx s_500_26 -> bv
        let s_500_27: Bits = Bits::new(s_500_26 as u128, 32u16);
        // D s_500_28: bit-extract s_500_27 s_500_24 s_500_25
        let s_500_28: Bits = (Bits::new(
            ((s_500_27) >> (s_500_24)).value(),
            u16::try_from(s_500_25).unwrap(),
        ));
        // D s_500_29: cast reint s_500_28 -> u8
        let s_500_29: u8 = (s_500_28.value() as u8);
        // D s_500_30: write-var u#33640 <= s_500_29
        fn_state.u_33640 = s_500_29;
        // C s_500_31: const #8s : i
        let s_500_31: i128 = 8;
        // D s_500_32: read-var u#33636:u32
        let s_500_32: u32 = fn_state.u_33636;
        // D s_500_33: cast zx s_500_32 -> bv
        let s_500_33: Bits = Bits::new(s_500_32 as u128, 32u16);
        // C s_500_34: const #1u : u64
        let s_500_34: u64 = 1;
        // D s_500_35: bit-extract s_500_33 s_500_31 s_500_34
        let s_500_35: Bits = (Bits::new(
            ((s_500_33) >> (s_500_31)).value(),
            u16::try_from(s_500_34).unwrap(),
        ));
        // D s_500_36: cast reint s_500_35 -> u8
        let s_500_36: bool = ((s_500_35.value()) != 0);
        // C s_500_37: const #0s : i
        let s_500_37: i128 = 0;
        // C s_500_38: const #0u : u64
        let s_500_38: u64 = 0;
        // D s_500_39: cast zx s_500_36 -> u64
        let s_500_39: u64 = (s_500_36 as u64);
        // C s_500_40: const #1u : u64
        let s_500_40: u64 = 1;
        // D s_500_41: and s_500_39 s_500_40
        let s_500_41: u64 = ((s_500_39) & (s_500_40));
        // D s_500_42: cmp-eq s_500_41 s_500_40
        let s_500_42: bool = ((s_500_41) == (s_500_40));
        // D s_500_43: lsl s_500_39 s_500_37
        let s_500_43: u64 = s_500_39 << s_500_37;
        // D s_500_44: or s_500_38 s_500_43
        let s_500_44: u64 = ((s_500_38) | (s_500_43));
        // D s_500_45: cmpl s_500_43
        let s_500_45: u64 = !s_500_43;
        // D s_500_46: and s_500_38 s_500_45
        let s_500_46: u64 = ((s_500_38) & (s_500_45));
        // D s_500_47: select s_500_42 s_500_44 s_500_46
        let s_500_47: u64 = if s_500_42 { s_500_44 } else { s_500_46 };
        // D s_500_48: cast trunc s_500_47 -> u8
        let s_500_48: bool = ((s_500_47) != 0);
        // D s_500_49: cast zx s_500_48 -> bv
        let s_500_49: Bits = Bits::new(s_500_48 as u128, 1u16);
        // C s_500_50: const #1u : u8
        let s_500_50: bool = true;
        // C s_500_51: cast zx s_500_50 -> bv
        let s_500_51: Bits = Bits::new(s_500_50 as u128, 1u16);
        // D s_500_52: cmp-ne s_500_49 s_500_51
        let s_500_52: bool = ((s_500_49) != (s_500_51));
        // N s_500_53: branch s_500_52 b511 b501
        if s_500_52 {
            return block_511(state, tracer, fn_state);
        } else {
            return block_501(state, tracer, fn_state);
        };
    }
    fn block_501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_501_0: const #9s : i
        let s_501_0: i128 = 9;
        // D s_501_1: read-var u#33636:u32
        let s_501_1: u32 = fn_state.u_33636;
        // D s_501_2: cast zx s_501_1 -> bv
        let s_501_2: Bits = Bits::new(s_501_1 as u128, 32u16);
        // C s_501_3: const #1u : u64
        let s_501_3: u64 = 1;
        // D s_501_4: bit-extract s_501_2 s_501_0 s_501_3
        let s_501_4: Bits = (Bits::new(
            ((s_501_2) >> (s_501_0)).value(),
            u16::try_from(s_501_3).unwrap(),
        ));
        // D s_501_5: cast reint s_501_4 -> u8
        let s_501_5: bool = ((s_501_4.value()) != 0);
        // C s_501_6: const #0s : i
        let s_501_6: i128 = 0;
        // C s_501_7: const #0u : u64
        let s_501_7: u64 = 0;
        // D s_501_8: cast zx s_501_5 -> u64
        let s_501_8: u64 = (s_501_5 as u64);
        // C s_501_9: const #1u : u64
        let s_501_9: u64 = 1;
        // D s_501_10: and s_501_8 s_501_9
        let s_501_10: u64 = ((s_501_8) & (s_501_9));
        // D s_501_11: cmp-eq s_501_10 s_501_9
        let s_501_11: bool = ((s_501_10) == (s_501_9));
        // D s_501_12: lsl s_501_8 s_501_6
        let s_501_12: u64 = s_501_8 << s_501_6;
        // D s_501_13: or s_501_7 s_501_12
        let s_501_13: u64 = ((s_501_7) | (s_501_12));
        // D s_501_14: cmpl s_501_12
        let s_501_14: u64 = !s_501_12;
        // D s_501_15: and s_501_7 s_501_14
        let s_501_15: u64 = ((s_501_7) & (s_501_14));
        // D s_501_16: select s_501_11 s_501_13 s_501_15
        let s_501_16: u64 = if s_501_11 { s_501_13 } else { s_501_15 };
        // D s_501_17: cast trunc s_501_16 -> u8
        let s_501_17: bool = ((s_501_16) != 0);
        // D s_501_18: cast zx s_501_17 -> bv
        let s_501_18: Bits = Bits::new(s_501_17 as u128, 1u16);
        // C s_501_19: const #1u : u8
        let s_501_19: bool = true;
        // C s_501_20: cast zx s_501_19 -> bv
        let s_501_20: Bits = Bits::new(s_501_19 as u128, 1u16);
        // D s_501_21: cmp-ne s_501_18 s_501_20
        let s_501_21: bool = ((s_501_18) != (s_501_20));
        // D s_501_22: write-var gs#410223 <= s_501_21
        fn_state.gs_410223 = s_501_21;
        // N s_501_23: jump b502
        return block_502(state, tracer, fn_state);
    }
    fn block_502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_502_0: read-var gs#410223:u8
        let s_502_0: bool = fn_state.gs_410223;
        // N s_502_1: branch s_502_0 b510 b503
        if s_502_0 {
            return block_510(state, tracer, fn_state);
        } else {
            return block_503(state, tracer, fn_state);
        };
    }
    fn block_503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_503_0: const #10s : i
        let s_503_0: i128 = 10;
        // D s_503_1: read-var u#33636:u32
        let s_503_1: u32 = fn_state.u_33636;
        // D s_503_2: cast zx s_503_1 -> bv
        let s_503_2: Bits = Bits::new(s_503_1 as u128, 32u16);
        // C s_503_3: const #1u : u64
        let s_503_3: u64 = 1;
        // D s_503_4: bit-extract s_503_2 s_503_0 s_503_3
        let s_503_4: Bits = (Bits::new(
            ((s_503_2) >> (s_503_0)).value(),
            u16::try_from(s_503_3).unwrap(),
        ));
        // D s_503_5: cast reint s_503_4 -> u8
        let s_503_5: bool = ((s_503_4.value()) != 0);
        // C s_503_6: const #0s : i
        let s_503_6: i128 = 0;
        // C s_503_7: const #0u : u64
        let s_503_7: u64 = 0;
        // D s_503_8: cast zx s_503_5 -> u64
        let s_503_8: u64 = (s_503_5 as u64);
        // C s_503_9: const #1u : u64
        let s_503_9: u64 = 1;
        // D s_503_10: and s_503_8 s_503_9
        let s_503_10: u64 = ((s_503_8) & (s_503_9));
        // D s_503_11: cmp-eq s_503_10 s_503_9
        let s_503_11: bool = ((s_503_10) == (s_503_9));
        // D s_503_12: lsl s_503_8 s_503_6
        let s_503_12: u64 = s_503_8 << s_503_6;
        // D s_503_13: or s_503_7 s_503_12
        let s_503_13: u64 = ((s_503_7) | (s_503_12));
        // D s_503_14: cmpl s_503_12
        let s_503_14: u64 = !s_503_12;
        // D s_503_15: and s_503_7 s_503_14
        let s_503_15: u64 = ((s_503_7) & (s_503_14));
        // D s_503_16: select s_503_11 s_503_13 s_503_15
        let s_503_16: u64 = if s_503_11 { s_503_13 } else { s_503_15 };
        // D s_503_17: cast trunc s_503_16 -> u8
        let s_503_17: bool = ((s_503_16) != 0);
        // D s_503_18: cast zx s_503_17 -> bv
        let s_503_18: Bits = Bits::new(s_503_17 as u128, 1u16);
        // C s_503_19: const #1u : u8
        let s_503_19: bool = true;
        // C s_503_20: cast zx s_503_19 -> bv
        let s_503_20: Bits = Bits::new(s_503_19 as u128, 1u16);
        // D s_503_21: cmp-ne s_503_18 s_503_20
        let s_503_21: bool = ((s_503_18) != (s_503_20));
        // D s_503_22: write-var gs#410226 <= s_503_21
        fn_state.gs_410226 = s_503_21;
        // N s_503_23: jump b504
        return block_504(state, tracer, fn_state);
    }
    fn block_504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_504_0: read-var gs#410226:u8
        let s_504_0: bool = fn_state.gs_410226;
        // N s_504_1: branch s_504_0 b509 b505
        if s_504_0 {
            return block_509(state, tracer, fn_state);
        } else {
            return block_505(state, tracer, fn_state);
        };
    }
    fn block_505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_505_0: const #11s : i
        let s_505_0: i128 = 11;
        // D s_505_1: read-var u#33636:u32
        let s_505_1: u32 = fn_state.u_33636;
        // D s_505_2: cast zx s_505_1 -> bv
        let s_505_2: Bits = Bits::new(s_505_1 as u128, 32u16);
        // C s_505_3: const #1u : u64
        let s_505_3: u64 = 1;
        // D s_505_4: bit-extract s_505_2 s_505_0 s_505_3
        let s_505_4: Bits = (Bits::new(
            ((s_505_2) >> (s_505_0)).value(),
            u16::try_from(s_505_3).unwrap(),
        ));
        // D s_505_5: cast reint s_505_4 -> u8
        let s_505_5: bool = ((s_505_4.value()) != 0);
        // C s_505_6: const #0s : i
        let s_505_6: i128 = 0;
        // C s_505_7: const #0u : u64
        let s_505_7: u64 = 0;
        // D s_505_8: cast zx s_505_5 -> u64
        let s_505_8: u64 = (s_505_5 as u64);
        // C s_505_9: const #1u : u64
        let s_505_9: u64 = 1;
        // D s_505_10: and s_505_8 s_505_9
        let s_505_10: u64 = ((s_505_8) & (s_505_9));
        // D s_505_11: cmp-eq s_505_10 s_505_9
        let s_505_11: bool = ((s_505_10) == (s_505_9));
        // D s_505_12: lsl s_505_8 s_505_6
        let s_505_12: u64 = s_505_8 << s_505_6;
        // D s_505_13: or s_505_7 s_505_12
        let s_505_13: u64 = ((s_505_7) | (s_505_12));
        // D s_505_14: cmpl s_505_12
        let s_505_14: u64 = !s_505_12;
        // D s_505_15: and s_505_7 s_505_14
        let s_505_15: u64 = ((s_505_7) & (s_505_14));
        // D s_505_16: select s_505_11 s_505_13 s_505_15
        let s_505_16: u64 = if s_505_11 { s_505_13 } else { s_505_15 };
        // D s_505_17: cast trunc s_505_16 -> u8
        let s_505_17: bool = ((s_505_16) != 0);
        // D s_505_18: cast zx s_505_17 -> bv
        let s_505_18: Bits = Bits::new(s_505_17 as u128, 1u16);
        // C s_505_19: const #1u : u8
        let s_505_19: bool = true;
        // C s_505_20: cast zx s_505_19 -> bv
        let s_505_20: Bits = Bits::new(s_505_19 as u128, 1u16);
        // D s_505_21: cmp-ne s_505_18 s_505_20
        let s_505_21: bool = ((s_505_18) != (s_505_20));
        // D s_505_22: write-var gs#410229 <= s_505_21
        fn_state.gs_410229 = s_505_21;
        // N s_505_23: jump b506
        return block_506(state, tracer, fn_state);
    }
    fn block_506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_506_0: read-var gs#410229:u8
        let s_506_0: bool = fn_state.gs_410229;
        // N s_506_1: branch s_506_0 b508 b507
        if s_506_0 {
            return block_508(state, tracer, fn_state);
        } else {
            return block_507(state, tracer, fn_state);
        };
    }
    fn block_507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_507_0: read-var u#33637:u8
        let s_507_0: u8 = fn_state.u_33637;
        // D s_507_1: read-var u#33638:u8
        let s_507_1: u8 = fn_state.u_33638;
        // D s_507_2: read-var u#33639:u8
        let s_507_2: u8 = fn_state.u_33639;
        // D s_507_3: read-var u#33640:u8
        let s_507_3: u8 = fn_state.u_33640;
        // D s_507_4: call decode_aarch32_instrs_SSAX_A1enc_A_txt(s_507_0, s_507_1, s_507_2, s_507_3)
        let s_507_4: () = decode_aarch32_instrs_SSAX_A1enc_A_txt(
            state,
            tracer,
            s_507_0,
            s_507_1,
            s_507_2,
            s_507_3,
        );
        // N s_507_5: return
        return;
    }
    fn block_508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_508_0: panic
        panic!("{:?}", ());
        // N s_508_1: return
        return;
    }
    fn block_509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_509_0: const #1u : u8
        let s_509_0: bool = true;
        // D s_509_1: write-var gs#410229 <= s_509_0
        fn_state.gs_410229 = s_509_0;
        // N s_509_2: jump b506
        return block_506(state, tracer, fn_state);
    }
    fn block_510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_510_0: const #1u : u8
        let s_510_0: bool = true;
        // D s_510_1: write-var gs#410226 <= s_510_0
        fn_state.gs_410226 = s_510_0;
        // N s_510_2: jump b504
        return block_504(state, tracer, fn_state);
    }
    fn block_511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_511_0: const #1u : u8
        let s_511_0: bool = true;
        // D s_511_1: write-var gs#410223 <= s_511_0
        fn_state.gs_410223 = s_511_0;
        // N s_511_2: jump b502
        return block_502(state, tracer, fn_state);
    }
    fn block_512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_512_0: read-var merge#var.1:struct
        let s_512_0: u32 = fn_state.merge_var._1;
        // D s_512_1: write-var u#33642 <= s_512_0
        fn_state.u_33642 = s_512_0;
        // C s_512_2: const #20s : i
        let s_512_2: i128 = 20;
        // D s_512_3: read-var u#33642:u32
        let s_512_3: u32 = fn_state.u_33642;
        // D s_512_4: cast zx s_512_3 -> bv
        let s_512_4: Bits = Bits::new(s_512_3 as u128, 32u16);
        // C s_512_5: const #1s : i64
        let s_512_5: i64 = 1;
        // C s_512_6: cast zx s_512_5 -> i
        let s_512_6: i128 = (i128::try_from(s_512_5).unwrap());
        // C s_512_7: const #7s : i
        let s_512_7: i128 = 7;
        // C s_512_8: add s_512_7 s_512_6
        let s_512_8: i128 = (s_512_7 + s_512_6);
        // D s_512_9: bit-extract s_512_4 s_512_2 s_512_8
        let s_512_9: Bits = (Bits::new(
            ((s_512_4) >> (s_512_2)).value(),
            u16::try_from(s_512_8).unwrap(),
        ));
        // D s_512_10: cast reint s_512_9 -> u8
        let s_512_10: u8 = (s_512_9.value() as u8);
        // D s_512_11: cast zx s_512_10 -> bv
        let s_512_11: Bits = Bits::new(s_512_10 as u128, 8u16);
        // C s_512_12: const #97u : u8
        let s_512_12: u8 = 97;
        // C s_512_13: cast zx s_512_12 -> bv
        let s_512_13: Bits = Bits::new(s_512_12 as u128, 8u16);
        // D s_512_14: cmp-eq s_512_11 s_512_13
        let s_512_14: bool = ((s_512_11) == (s_512_13));
        // N s_512_15: branch s_512_14 b1232 b513
        if s_512_14 {
            return block_1232(state, tracer, fn_state);
        } else {
            return block_513(state, tracer, fn_state);
        };
    }
    fn block_513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_513_0: const #0u : u8
        let s_513_0: bool = false;
        // D s_513_1: write-var gs#410235 <= s_513_0
        fn_state.gs_410235 = s_513_0;
        // N s_513_2: jump b514
        return block_514(state, tracer, fn_state);
    }
    fn block_514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_514_0: read-var gs#410235:u8
        let s_514_0: bool = fn_state.gs_410235;
        // N s_514_1: branch s_514_0 b1228 b515
        if s_514_0 {
            return block_1228(state, tracer, fn_state);
        } else {
            return block_515(state, tracer, fn_state);
        };
    }
    fn block_515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_515_0: const #0u : u8
        let s_515_0: bool = false;
        // D s_515_1: write-var gs#410240 <= s_515_0
        fn_state.gs_410240 = s_515_0;
        // N s_515_2: jump b516
        return block_516(state, tracer, fn_state);
    }
    fn block_516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_516_0: read-var gs#410240:u8
        let s_516_0: bool = fn_state.gs_410240;
        // D s_516_1: not s_516_0
        let s_516_1: bool = !s_516_0;
        // N s_516_2: branch s_516_1 b529 b517
        if s_516_1 {
            return block_529(state, tracer, fn_state);
        } else {
            return block_517(state, tracer, fn_state);
        };
    }
    fn block_517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_517_0: const #3180s : i
        let s_517_0: i128 = 3180;
        // C s_517_1: const #14696u : u32
        let s_517_1: u32 = 14696;
        // N s_517_2: write-reg s_517_1 <= s_517_0
        let s_517_2: () = {
            state.write_register::<i128>(s_517_1 as isize, s_517_0);
            tracer.write_register(s_517_1 as isize, s_517_0);
        };
        // C s_517_3: const #28s : i
        let s_517_3: i128 = 28;
        // C s_517_4: const #4s : i
        let s_517_4: i128 = 4;
        // D s_517_5: read-var u#33642:u32
        let s_517_5: u32 = fn_state.u_33642;
        // D s_517_6: cast zx s_517_5 -> bv
        let s_517_6: Bits = Bits::new(s_517_5 as u128, 32u16);
        // D s_517_7: bit-extract s_517_6 s_517_3 s_517_4
        let s_517_7: Bits = (Bits::new(
            ((s_517_6) >> (s_517_3)).value(),
            u16::try_from(s_517_4).unwrap(),
        ));
        // D s_517_8: cast reint s_517_7 -> u8
        let s_517_8: u8 = (s_517_7.value() as u8);
        // D s_517_9: write-var u#33643 <= s_517_8
        fn_state.u_33643 = s_517_8;
        // C s_517_10: const #16s : i
        let s_517_10: i128 = 16;
        // C s_517_11: const #4s : i
        let s_517_11: i128 = 4;
        // D s_517_12: read-var u#33642:u32
        let s_517_12: u32 = fn_state.u_33642;
        // D s_517_13: cast zx s_517_12 -> bv
        let s_517_13: Bits = Bits::new(s_517_12 as u128, 32u16);
        // D s_517_14: bit-extract s_517_13 s_517_10 s_517_11
        let s_517_14: Bits = (Bits::new(
            ((s_517_13) >> (s_517_10)).value(),
            u16::try_from(s_517_11).unwrap(),
        ));
        // D s_517_15: cast reint s_517_14 -> u8
        let s_517_15: u8 = (s_517_14.value() as u8);
        // D s_517_16: write-var u#33644 <= s_517_15
        fn_state.u_33644 = s_517_15;
        // C s_517_17: const #12s : i
        let s_517_17: i128 = 12;
        // C s_517_18: const #4s : i
        let s_517_18: i128 = 4;
        // D s_517_19: read-var u#33642:u32
        let s_517_19: u32 = fn_state.u_33642;
        // D s_517_20: cast zx s_517_19 -> bv
        let s_517_20: Bits = Bits::new(s_517_19 as u128, 32u16);
        // D s_517_21: bit-extract s_517_20 s_517_17 s_517_18
        let s_517_21: Bits = (Bits::new(
            ((s_517_20) >> (s_517_17)).value(),
            u16::try_from(s_517_18).unwrap(),
        ));
        // D s_517_22: cast reint s_517_21 -> u8
        let s_517_22: u8 = (s_517_21.value() as u8);
        // D s_517_23: write-var u#33645 <= s_517_22
        fn_state.u_33645 = s_517_22;
        // C s_517_24: const #0s : i
        let s_517_24: i128 = 0;
        // C s_517_25: const #4s : i
        let s_517_25: i128 = 4;
        // D s_517_26: read-var u#33642:u32
        let s_517_26: u32 = fn_state.u_33642;
        // D s_517_27: cast zx s_517_26 -> bv
        let s_517_27: Bits = Bits::new(s_517_26 as u128, 32u16);
        // D s_517_28: bit-extract s_517_27 s_517_24 s_517_25
        let s_517_28: Bits = (Bits::new(
            ((s_517_27) >> (s_517_24)).value(),
            u16::try_from(s_517_25).unwrap(),
        ));
        // D s_517_29: cast reint s_517_28 -> u8
        let s_517_29: u8 = (s_517_28.value() as u8);
        // D s_517_30: write-var u#33646 <= s_517_29
        fn_state.u_33646 = s_517_29;
        // C s_517_31: const #8s : i
        let s_517_31: i128 = 8;
        // D s_517_32: read-var u#33642:u32
        let s_517_32: u32 = fn_state.u_33642;
        // D s_517_33: cast zx s_517_32 -> bv
        let s_517_33: Bits = Bits::new(s_517_32 as u128, 32u16);
        // C s_517_34: const #1u : u64
        let s_517_34: u64 = 1;
        // D s_517_35: bit-extract s_517_33 s_517_31 s_517_34
        let s_517_35: Bits = (Bits::new(
            ((s_517_33) >> (s_517_31)).value(),
            u16::try_from(s_517_34).unwrap(),
        ));
        // D s_517_36: cast reint s_517_35 -> u8
        let s_517_36: bool = ((s_517_35.value()) != 0);
        // C s_517_37: const #0s : i
        let s_517_37: i128 = 0;
        // C s_517_38: const #0u : u64
        let s_517_38: u64 = 0;
        // D s_517_39: cast zx s_517_36 -> u64
        let s_517_39: u64 = (s_517_36 as u64);
        // C s_517_40: const #1u : u64
        let s_517_40: u64 = 1;
        // D s_517_41: and s_517_39 s_517_40
        let s_517_41: u64 = ((s_517_39) & (s_517_40));
        // D s_517_42: cmp-eq s_517_41 s_517_40
        let s_517_42: bool = ((s_517_41) == (s_517_40));
        // D s_517_43: lsl s_517_39 s_517_37
        let s_517_43: u64 = s_517_39 << s_517_37;
        // D s_517_44: or s_517_38 s_517_43
        let s_517_44: u64 = ((s_517_38) | (s_517_43));
        // D s_517_45: cmpl s_517_43
        let s_517_45: u64 = !s_517_43;
        // D s_517_46: and s_517_38 s_517_45
        let s_517_46: u64 = ((s_517_38) & (s_517_45));
        // D s_517_47: select s_517_42 s_517_44 s_517_46
        let s_517_47: u64 = if s_517_42 { s_517_44 } else { s_517_46 };
        // D s_517_48: cast trunc s_517_47 -> u8
        let s_517_48: bool = ((s_517_47) != 0);
        // D s_517_49: cast zx s_517_48 -> bv
        let s_517_49: Bits = Bits::new(s_517_48 as u128, 1u16);
        // C s_517_50: const #1u : u8
        let s_517_50: bool = true;
        // C s_517_51: cast zx s_517_50 -> bv
        let s_517_51: Bits = Bits::new(s_517_50 as u128, 1u16);
        // D s_517_52: cmp-ne s_517_49 s_517_51
        let s_517_52: bool = ((s_517_49) != (s_517_51));
        // N s_517_53: branch s_517_52 b528 b518
        if s_517_52 {
            return block_528(state, tracer, fn_state);
        } else {
            return block_518(state, tracer, fn_state);
        };
    }
    fn block_518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_518_0: const #9s : i
        let s_518_0: i128 = 9;
        // D s_518_1: read-var u#33642:u32
        let s_518_1: u32 = fn_state.u_33642;
        // D s_518_2: cast zx s_518_1 -> bv
        let s_518_2: Bits = Bits::new(s_518_1 as u128, 32u16);
        // C s_518_3: const #1u : u64
        let s_518_3: u64 = 1;
        // D s_518_4: bit-extract s_518_2 s_518_0 s_518_3
        let s_518_4: Bits = (Bits::new(
            ((s_518_2) >> (s_518_0)).value(),
            u16::try_from(s_518_3).unwrap(),
        ));
        // D s_518_5: cast reint s_518_4 -> u8
        let s_518_5: bool = ((s_518_4.value()) != 0);
        // C s_518_6: const #0s : i
        let s_518_6: i128 = 0;
        // C s_518_7: const #0u : u64
        let s_518_7: u64 = 0;
        // D s_518_8: cast zx s_518_5 -> u64
        let s_518_8: u64 = (s_518_5 as u64);
        // C s_518_9: const #1u : u64
        let s_518_9: u64 = 1;
        // D s_518_10: and s_518_8 s_518_9
        let s_518_10: u64 = ((s_518_8) & (s_518_9));
        // D s_518_11: cmp-eq s_518_10 s_518_9
        let s_518_11: bool = ((s_518_10) == (s_518_9));
        // D s_518_12: lsl s_518_8 s_518_6
        let s_518_12: u64 = s_518_8 << s_518_6;
        // D s_518_13: or s_518_7 s_518_12
        let s_518_13: u64 = ((s_518_7) | (s_518_12));
        // D s_518_14: cmpl s_518_12
        let s_518_14: u64 = !s_518_12;
        // D s_518_15: and s_518_7 s_518_14
        let s_518_15: u64 = ((s_518_7) & (s_518_14));
        // D s_518_16: select s_518_11 s_518_13 s_518_15
        let s_518_16: u64 = if s_518_11 { s_518_13 } else { s_518_15 };
        // D s_518_17: cast trunc s_518_16 -> u8
        let s_518_17: bool = ((s_518_16) != 0);
        // D s_518_18: cast zx s_518_17 -> bv
        let s_518_18: Bits = Bits::new(s_518_17 as u128, 1u16);
        // C s_518_19: const #1u : u8
        let s_518_19: bool = true;
        // C s_518_20: cast zx s_518_19 -> bv
        let s_518_20: Bits = Bits::new(s_518_19 as u128, 1u16);
        // D s_518_21: cmp-ne s_518_18 s_518_20
        let s_518_21: bool = ((s_518_18) != (s_518_20));
        // D s_518_22: write-var gs#410255 <= s_518_21
        fn_state.gs_410255 = s_518_21;
        // N s_518_23: jump b519
        return block_519(state, tracer, fn_state);
    }
    fn block_519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_519_0: read-var gs#410255:u8
        let s_519_0: bool = fn_state.gs_410255;
        // N s_519_1: branch s_519_0 b527 b520
        if s_519_0 {
            return block_527(state, tracer, fn_state);
        } else {
            return block_520(state, tracer, fn_state);
        };
    }
    fn block_520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_520_0: const #10s : i
        let s_520_0: i128 = 10;
        // D s_520_1: read-var u#33642:u32
        let s_520_1: u32 = fn_state.u_33642;
        // D s_520_2: cast zx s_520_1 -> bv
        let s_520_2: Bits = Bits::new(s_520_1 as u128, 32u16);
        // C s_520_3: const #1u : u64
        let s_520_3: u64 = 1;
        // D s_520_4: bit-extract s_520_2 s_520_0 s_520_3
        let s_520_4: Bits = (Bits::new(
            ((s_520_2) >> (s_520_0)).value(),
            u16::try_from(s_520_3).unwrap(),
        ));
        // D s_520_5: cast reint s_520_4 -> u8
        let s_520_5: bool = ((s_520_4.value()) != 0);
        // C s_520_6: const #0s : i
        let s_520_6: i128 = 0;
        // C s_520_7: const #0u : u64
        let s_520_7: u64 = 0;
        // D s_520_8: cast zx s_520_5 -> u64
        let s_520_8: u64 = (s_520_5 as u64);
        // C s_520_9: const #1u : u64
        let s_520_9: u64 = 1;
        // D s_520_10: and s_520_8 s_520_9
        let s_520_10: u64 = ((s_520_8) & (s_520_9));
        // D s_520_11: cmp-eq s_520_10 s_520_9
        let s_520_11: bool = ((s_520_10) == (s_520_9));
        // D s_520_12: lsl s_520_8 s_520_6
        let s_520_12: u64 = s_520_8 << s_520_6;
        // D s_520_13: or s_520_7 s_520_12
        let s_520_13: u64 = ((s_520_7) | (s_520_12));
        // D s_520_14: cmpl s_520_12
        let s_520_14: u64 = !s_520_12;
        // D s_520_15: and s_520_7 s_520_14
        let s_520_15: u64 = ((s_520_7) & (s_520_14));
        // D s_520_16: select s_520_11 s_520_13 s_520_15
        let s_520_16: u64 = if s_520_11 { s_520_13 } else { s_520_15 };
        // D s_520_17: cast trunc s_520_16 -> u8
        let s_520_17: bool = ((s_520_16) != 0);
        // D s_520_18: cast zx s_520_17 -> bv
        let s_520_18: Bits = Bits::new(s_520_17 as u128, 1u16);
        // C s_520_19: const #1u : u8
        let s_520_19: bool = true;
        // C s_520_20: cast zx s_520_19 -> bv
        let s_520_20: Bits = Bits::new(s_520_19 as u128, 1u16);
        // D s_520_21: cmp-ne s_520_18 s_520_20
        let s_520_21: bool = ((s_520_18) != (s_520_20));
        // D s_520_22: write-var gs#410258 <= s_520_21
        fn_state.gs_410258 = s_520_21;
        // N s_520_23: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_521_0: read-var gs#410258:u8
        let s_521_0: bool = fn_state.gs_410258;
        // N s_521_1: branch s_521_0 b526 b522
        if s_521_0 {
            return block_526(state, tracer, fn_state);
        } else {
            return block_522(state, tracer, fn_state);
        };
    }
    fn block_522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_522_0: const #11s : i
        let s_522_0: i128 = 11;
        // D s_522_1: read-var u#33642:u32
        let s_522_1: u32 = fn_state.u_33642;
        // D s_522_2: cast zx s_522_1 -> bv
        let s_522_2: Bits = Bits::new(s_522_1 as u128, 32u16);
        // C s_522_3: const #1u : u64
        let s_522_3: u64 = 1;
        // D s_522_4: bit-extract s_522_2 s_522_0 s_522_3
        let s_522_4: Bits = (Bits::new(
            ((s_522_2) >> (s_522_0)).value(),
            u16::try_from(s_522_3).unwrap(),
        ));
        // D s_522_5: cast reint s_522_4 -> u8
        let s_522_5: bool = ((s_522_4.value()) != 0);
        // C s_522_6: const #0s : i
        let s_522_6: i128 = 0;
        // C s_522_7: const #0u : u64
        let s_522_7: u64 = 0;
        // D s_522_8: cast zx s_522_5 -> u64
        let s_522_8: u64 = (s_522_5 as u64);
        // C s_522_9: const #1u : u64
        let s_522_9: u64 = 1;
        // D s_522_10: and s_522_8 s_522_9
        let s_522_10: u64 = ((s_522_8) & (s_522_9));
        // D s_522_11: cmp-eq s_522_10 s_522_9
        let s_522_11: bool = ((s_522_10) == (s_522_9));
        // D s_522_12: lsl s_522_8 s_522_6
        let s_522_12: u64 = s_522_8 << s_522_6;
        // D s_522_13: or s_522_7 s_522_12
        let s_522_13: u64 = ((s_522_7) | (s_522_12));
        // D s_522_14: cmpl s_522_12
        let s_522_14: u64 = !s_522_12;
        // D s_522_15: and s_522_7 s_522_14
        let s_522_15: u64 = ((s_522_7) & (s_522_14));
        // D s_522_16: select s_522_11 s_522_13 s_522_15
        let s_522_16: u64 = if s_522_11 { s_522_13 } else { s_522_15 };
        // D s_522_17: cast trunc s_522_16 -> u8
        let s_522_17: bool = ((s_522_16) != 0);
        // D s_522_18: cast zx s_522_17 -> bv
        let s_522_18: Bits = Bits::new(s_522_17 as u128, 1u16);
        // C s_522_19: const #1u : u8
        let s_522_19: bool = true;
        // C s_522_20: cast zx s_522_19 -> bv
        let s_522_20: Bits = Bits::new(s_522_19 as u128, 1u16);
        // D s_522_21: cmp-ne s_522_18 s_522_20
        let s_522_21: bool = ((s_522_18) != (s_522_20));
        // D s_522_22: write-var gs#410261 <= s_522_21
        fn_state.gs_410261 = s_522_21;
        // N s_522_23: jump b523
        return block_523(state, tracer, fn_state);
    }
    fn block_523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_523_0: read-var gs#410261:u8
        let s_523_0: bool = fn_state.gs_410261;
        // N s_523_1: branch s_523_0 b525 b524
        if s_523_0 {
            return block_525(state, tracer, fn_state);
        } else {
            return block_524(state, tracer, fn_state);
        };
    }
    fn block_524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_524_0: read-var u#33643:u8
        let s_524_0: u8 = fn_state.u_33643;
        // D s_524_1: read-var u#33644:u8
        let s_524_1: u8 = fn_state.u_33644;
        // D s_524_2: read-var u#33645:u8
        let s_524_2: u8 = fn_state.u_33645;
        // D s_524_3: read-var u#33646:u8
        let s_524_3: u8 = fn_state.u_33646;
        // D s_524_4: call decode_aarch32_instrs_SSUB16_A1enc_A_txt(s_524_0, s_524_1, s_524_2, s_524_3)
        let s_524_4: () = decode_aarch32_instrs_SSUB16_A1enc_A_txt(
            state,
            tracer,
            s_524_0,
            s_524_1,
            s_524_2,
            s_524_3,
        );
        // N s_524_5: return
        return;
    }
    fn block_525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_525_0: panic
        panic!("{:?}", ());
        // N s_525_1: return
        return;
    }
    fn block_526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_526_0: const #1u : u8
        let s_526_0: bool = true;
        // D s_526_1: write-var gs#410261 <= s_526_0
        fn_state.gs_410261 = s_526_0;
        // N s_526_2: jump b523
        return block_523(state, tracer, fn_state);
    }
    fn block_527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_527_0: const #1u : u8
        let s_527_0: bool = true;
        // D s_527_1: write-var gs#410258 <= s_527_0
        fn_state.gs_410258 = s_527_0;
        // N s_527_2: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_528_0: const #1u : u8
        let s_528_0: bool = true;
        // D s_528_1: write-var gs#410255 <= s_528_0
        fn_state.gs_410255 = s_528_0;
        // N s_528_2: jump b519
        return block_519(state, tracer, fn_state);
    }
    fn block_529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_529_0: read-var merge#var.1:struct
        let s_529_0: u32 = fn_state.merge_var._1;
        // D s_529_1: write-var u#33648 <= s_529_0
        fn_state.u_33648 = s_529_0;
        // C s_529_2: const #20s : i
        let s_529_2: i128 = 20;
        // D s_529_3: read-var u#33648:u32
        let s_529_3: u32 = fn_state.u_33648;
        // D s_529_4: cast zx s_529_3 -> bv
        let s_529_4: Bits = Bits::new(s_529_3 as u128, 32u16);
        // C s_529_5: const #1s : i64
        let s_529_5: i64 = 1;
        // C s_529_6: cast zx s_529_5 -> i
        let s_529_6: i128 = (i128::try_from(s_529_5).unwrap());
        // C s_529_7: const #7s : i
        let s_529_7: i128 = 7;
        // C s_529_8: add s_529_7 s_529_6
        let s_529_8: i128 = (s_529_7 + s_529_6);
        // D s_529_9: bit-extract s_529_4 s_529_2 s_529_8
        let s_529_9: Bits = (Bits::new(
            ((s_529_4) >> (s_529_2)).value(),
            u16::try_from(s_529_8).unwrap(),
        ));
        // D s_529_10: cast reint s_529_9 -> u8
        let s_529_10: u8 = (s_529_9.value() as u8);
        // D s_529_11: cast zx s_529_10 -> bv
        let s_529_11: Bits = Bits::new(s_529_10 as u128, 8u16);
        // C s_529_12: const #97u : u8
        let s_529_12: u8 = 97;
        // C s_529_13: cast zx s_529_12 -> bv
        let s_529_13: Bits = Bits::new(s_529_12 as u128, 8u16);
        // D s_529_14: cmp-eq s_529_11 s_529_13
        let s_529_14: bool = ((s_529_11) == (s_529_13));
        // N s_529_15: branch s_529_14 b1227 b530
        if s_529_14 {
            return block_1227(state, tracer, fn_state);
        } else {
            return block_530(state, tracer, fn_state);
        };
    }
    fn block_530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_530_0: const #0u : u8
        let s_530_0: bool = false;
        // D s_530_1: write-var gs#410267 <= s_530_0
        fn_state.gs_410267 = s_530_0;
        // N s_530_2: jump b531
        return block_531(state, tracer, fn_state);
    }
    fn block_531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_531_0: read-var gs#410267:u8
        let s_531_0: bool = fn_state.gs_410267;
        // N s_531_1: branch s_531_0 b1223 b532
        if s_531_0 {
            return block_1223(state, tracer, fn_state);
        } else {
            return block_532(state, tracer, fn_state);
        };
    }
    fn block_532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_532_0: const #0u : u8
        let s_532_0: bool = false;
        // D s_532_1: write-var gs#410272 <= s_532_0
        fn_state.gs_410272 = s_532_0;
        // N s_532_2: jump b533
        return block_533(state, tracer, fn_state);
    }
    fn block_533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_533_0: read-var gs#410272:u8
        let s_533_0: bool = fn_state.gs_410272;
        // D s_533_1: not s_533_0
        let s_533_1: bool = !s_533_0;
        // N s_533_2: branch s_533_1 b546 b534
        if s_533_1 {
            return block_546(state, tracer, fn_state);
        } else {
            return block_534(state, tracer, fn_state);
        };
    }
    fn block_534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_534_0: const #3182s : i
        let s_534_0: i128 = 3182;
        // C s_534_1: const #14696u : u32
        let s_534_1: u32 = 14696;
        // N s_534_2: write-reg s_534_1 <= s_534_0
        let s_534_2: () = {
            state.write_register::<i128>(s_534_1 as isize, s_534_0);
            tracer.write_register(s_534_1 as isize, s_534_0);
        };
        // C s_534_3: const #28s : i
        let s_534_3: i128 = 28;
        // C s_534_4: const #4s : i
        let s_534_4: i128 = 4;
        // D s_534_5: read-var u#33648:u32
        let s_534_5: u32 = fn_state.u_33648;
        // D s_534_6: cast zx s_534_5 -> bv
        let s_534_6: Bits = Bits::new(s_534_5 as u128, 32u16);
        // D s_534_7: bit-extract s_534_6 s_534_3 s_534_4
        let s_534_7: Bits = (Bits::new(
            ((s_534_6) >> (s_534_3)).value(),
            u16::try_from(s_534_4).unwrap(),
        ));
        // D s_534_8: cast reint s_534_7 -> u8
        let s_534_8: u8 = (s_534_7.value() as u8);
        // D s_534_9: write-var u#33649 <= s_534_8
        fn_state.u_33649 = s_534_8;
        // C s_534_10: const #16s : i
        let s_534_10: i128 = 16;
        // C s_534_11: const #4s : i
        let s_534_11: i128 = 4;
        // D s_534_12: read-var u#33648:u32
        let s_534_12: u32 = fn_state.u_33648;
        // D s_534_13: cast zx s_534_12 -> bv
        let s_534_13: Bits = Bits::new(s_534_12 as u128, 32u16);
        // D s_534_14: bit-extract s_534_13 s_534_10 s_534_11
        let s_534_14: Bits = (Bits::new(
            ((s_534_13) >> (s_534_10)).value(),
            u16::try_from(s_534_11).unwrap(),
        ));
        // D s_534_15: cast reint s_534_14 -> u8
        let s_534_15: u8 = (s_534_14.value() as u8);
        // D s_534_16: write-var u#33650 <= s_534_15
        fn_state.u_33650 = s_534_15;
        // C s_534_17: const #12s : i
        let s_534_17: i128 = 12;
        // C s_534_18: const #4s : i
        let s_534_18: i128 = 4;
        // D s_534_19: read-var u#33648:u32
        let s_534_19: u32 = fn_state.u_33648;
        // D s_534_20: cast zx s_534_19 -> bv
        let s_534_20: Bits = Bits::new(s_534_19 as u128, 32u16);
        // D s_534_21: bit-extract s_534_20 s_534_17 s_534_18
        let s_534_21: Bits = (Bits::new(
            ((s_534_20) >> (s_534_17)).value(),
            u16::try_from(s_534_18).unwrap(),
        ));
        // D s_534_22: cast reint s_534_21 -> u8
        let s_534_22: u8 = (s_534_21.value() as u8);
        // D s_534_23: write-var u#33651 <= s_534_22
        fn_state.u_33651 = s_534_22;
        // C s_534_24: const #0s : i
        let s_534_24: i128 = 0;
        // C s_534_25: const #4s : i
        let s_534_25: i128 = 4;
        // D s_534_26: read-var u#33648:u32
        let s_534_26: u32 = fn_state.u_33648;
        // D s_534_27: cast zx s_534_26 -> bv
        let s_534_27: Bits = Bits::new(s_534_26 as u128, 32u16);
        // D s_534_28: bit-extract s_534_27 s_534_24 s_534_25
        let s_534_28: Bits = (Bits::new(
            ((s_534_27) >> (s_534_24)).value(),
            u16::try_from(s_534_25).unwrap(),
        ));
        // D s_534_29: cast reint s_534_28 -> u8
        let s_534_29: u8 = (s_534_28.value() as u8);
        // D s_534_30: write-var u#33652 <= s_534_29
        fn_state.u_33652 = s_534_29;
        // C s_534_31: const #8s : i
        let s_534_31: i128 = 8;
        // D s_534_32: read-var u#33648:u32
        let s_534_32: u32 = fn_state.u_33648;
        // D s_534_33: cast zx s_534_32 -> bv
        let s_534_33: Bits = Bits::new(s_534_32 as u128, 32u16);
        // C s_534_34: const #1u : u64
        let s_534_34: u64 = 1;
        // D s_534_35: bit-extract s_534_33 s_534_31 s_534_34
        let s_534_35: Bits = (Bits::new(
            ((s_534_33) >> (s_534_31)).value(),
            u16::try_from(s_534_34).unwrap(),
        ));
        // D s_534_36: cast reint s_534_35 -> u8
        let s_534_36: bool = ((s_534_35.value()) != 0);
        // C s_534_37: const #0s : i
        let s_534_37: i128 = 0;
        // C s_534_38: const #0u : u64
        let s_534_38: u64 = 0;
        // D s_534_39: cast zx s_534_36 -> u64
        let s_534_39: u64 = (s_534_36 as u64);
        // C s_534_40: const #1u : u64
        let s_534_40: u64 = 1;
        // D s_534_41: and s_534_39 s_534_40
        let s_534_41: u64 = ((s_534_39) & (s_534_40));
        // D s_534_42: cmp-eq s_534_41 s_534_40
        let s_534_42: bool = ((s_534_41) == (s_534_40));
        // D s_534_43: lsl s_534_39 s_534_37
        let s_534_43: u64 = s_534_39 << s_534_37;
        // D s_534_44: or s_534_38 s_534_43
        let s_534_44: u64 = ((s_534_38) | (s_534_43));
        // D s_534_45: cmpl s_534_43
        let s_534_45: u64 = !s_534_43;
        // D s_534_46: and s_534_38 s_534_45
        let s_534_46: u64 = ((s_534_38) & (s_534_45));
        // D s_534_47: select s_534_42 s_534_44 s_534_46
        let s_534_47: u64 = if s_534_42 { s_534_44 } else { s_534_46 };
        // D s_534_48: cast trunc s_534_47 -> u8
        let s_534_48: bool = ((s_534_47) != 0);
        // D s_534_49: cast zx s_534_48 -> bv
        let s_534_49: Bits = Bits::new(s_534_48 as u128, 1u16);
        // C s_534_50: const #1u : u8
        let s_534_50: bool = true;
        // C s_534_51: cast zx s_534_50 -> bv
        let s_534_51: Bits = Bits::new(s_534_50 as u128, 1u16);
        // D s_534_52: cmp-ne s_534_49 s_534_51
        let s_534_52: bool = ((s_534_49) != (s_534_51));
        // N s_534_53: branch s_534_52 b545 b535
        if s_534_52 {
            return block_545(state, tracer, fn_state);
        } else {
            return block_535(state, tracer, fn_state);
        };
    }
    fn block_535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_535_0: const #9s : i
        let s_535_0: i128 = 9;
        // D s_535_1: read-var u#33648:u32
        let s_535_1: u32 = fn_state.u_33648;
        // D s_535_2: cast zx s_535_1 -> bv
        let s_535_2: Bits = Bits::new(s_535_1 as u128, 32u16);
        // C s_535_3: const #1u : u64
        let s_535_3: u64 = 1;
        // D s_535_4: bit-extract s_535_2 s_535_0 s_535_3
        let s_535_4: Bits = (Bits::new(
            ((s_535_2) >> (s_535_0)).value(),
            u16::try_from(s_535_3).unwrap(),
        ));
        // D s_535_5: cast reint s_535_4 -> u8
        let s_535_5: bool = ((s_535_4.value()) != 0);
        // C s_535_6: const #0s : i
        let s_535_6: i128 = 0;
        // C s_535_7: const #0u : u64
        let s_535_7: u64 = 0;
        // D s_535_8: cast zx s_535_5 -> u64
        let s_535_8: u64 = (s_535_5 as u64);
        // C s_535_9: const #1u : u64
        let s_535_9: u64 = 1;
        // D s_535_10: and s_535_8 s_535_9
        let s_535_10: u64 = ((s_535_8) & (s_535_9));
        // D s_535_11: cmp-eq s_535_10 s_535_9
        let s_535_11: bool = ((s_535_10) == (s_535_9));
        // D s_535_12: lsl s_535_8 s_535_6
        let s_535_12: u64 = s_535_8 << s_535_6;
        // D s_535_13: or s_535_7 s_535_12
        let s_535_13: u64 = ((s_535_7) | (s_535_12));
        // D s_535_14: cmpl s_535_12
        let s_535_14: u64 = !s_535_12;
        // D s_535_15: and s_535_7 s_535_14
        let s_535_15: u64 = ((s_535_7) & (s_535_14));
        // D s_535_16: select s_535_11 s_535_13 s_535_15
        let s_535_16: u64 = if s_535_11 { s_535_13 } else { s_535_15 };
        // D s_535_17: cast trunc s_535_16 -> u8
        let s_535_17: bool = ((s_535_16) != 0);
        // D s_535_18: cast zx s_535_17 -> bv
        let s_535_18: Bits = Bits::new(s_535_17 as u128, 1u16);
        // C s_535_19: const #1u : u8
        let s_535_19: bool = true;
        // C s_535_20: cast zx s_535_19 -> bv
        let s_535_20: Bits = Bits::new(s_535_19 as u128, 1u16);
        // D s_535_21: cmp-ne s_535_18 s_535_20
        let s_535_21: bool = ((s_535_18) != (s_535_20));
        // D s_535_22: write-var gs#410287 <= s_535_21
        fn_state.gs_410287 = s_535_21;
        // N s_535_23: jump b536
        return block_536(state, tracer, fn_state);
    }
    fn block_536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_536_0: read-var gs#410287:u8
        let s_536_0: bool = fn_state.gs_410287;
        // N s_536_1: branch s_536_0 b544 b537
        if s_536_0 {
            return block_544(state, tracer, fn_state);
        } else {
            return block_537(state, tracer, fn_state);
        };
    }
    fn block_537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_537_0: const #10s : i
        let s_537_0: i128 = 10;
        // D s_537_1: read-var u#33648:u32
        let s_537_1: u32 = fn_state.u_33648;
        // D s_537_2: cast zx s_537_1 -> bv
        let s_537_2: Bits = Bits::new(s_537_1 as u128, 32u16);
        // C s_537_3: const #1u : u64
        let s_537_3: u64 = 1;
        // D s_537_4: bit-extract s_537_2 s_537_0 s_537_3
        let s_537_4: Bits = (Bits::new(
            ((s_537_2) >> (s_537_0)).value(),
            u16::try_from(s_537_3).unwrap(),
        ));
        // D s_537_5: cast reint s_537_4 -> u8
        let s_537_5: bool = ((s_537_4.value()) != 0);
        // C s_537_6: const #0s : i
        let s_537_6: i128 = 0;
        // C s_537_7: const #0u : u64
        let s_537_7: u64 = 0;
        // D s_537_8: cast zx s_537_5 -> u64
        let s_537_8: u64 = (s_537_5 as u64);
        // C s_537_9: const #1u : u64
        let s_537_9: u64 = 1;
        // D s_537_10: and s_537_8 s_537_9
        let s_537_10: u64 = ((s_537_8) & (s_537_9));
        // D s_537_11: cmp-eq s_537_10 s_537_9
        let s_537_11: bool = ((s_537_10) == (s_537_9));
        // D s_537_12: lsl s_537_8 s_537_6
        let s_537_12: u64 = s_537_8 << s_537_6;
        // D s_537_13: or s_537_7 s_537_12
        let s_537_13: u64 = ((s_537_7) | (s_537_12));
        // D s_537_14: cmpl s_537_12
        let s_537_14: u64 = !s_537_12;
        // D s_537_15: and s_537_7 s_537_14
        let s_537_15: u64 = ((s_537_7) & (s_537_14));
        // D s_537_16: select s_537_11 s_537_13 s_537_15
        let s_537_16: u64 = if s_537_11 { s_537_13 } else { s_537_15 };
        // D s_537_17: cast trunc s_537_16 -> u8
        let s_537_17: bool = ((s_537_16) != 0);
        // D s_537_18: cast zx s_537_17 -> bv
        let s_537_18: Bits = Bits::new(s_537_17 as u128, 1u16);
        // C s_537_19: const #1u : u8
        let s_537_19: bool = true;
        // C s_537_20: cast zx s_537_19 -> bv
        let s_537_20: Bits = Bits::new(s_537_19 as u128, 1u16);
        // D s_537_21: cmp-ne s_537_18 s_537_20
        let s_537_21: bool = ((s_537_18) != (s_537_20));
        // D s_537_22: write-var gs#410290 <= s_537_21
        fn_state.gs_410290 = s_537_21;
        // N s_537_23: jump b538
        return block_538(state, tracer, fn_state);
    }
    fn block_538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_538_0: read-var gs#410290:u8
        let s_538_0: bool = fn_state.gs_410290;
        // N s_538_1: branch s_538_0 b543 b539
        if s_538_0 {
            return block_543(state, tracer, fn_state);
        } else {
            return block_539(state, tracer, fn_state);
        };
    }
    fn block_539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_539_0: const #11s : i
        let s_539_0: i128 = 11;
        // D s_539_1: read-var u#33648:u32
        let s_539_1: u32 = fn_state.u_33648;
        // D s_539_2: cast zx s_539_1 -> bv
        let s_539_2: Bits = Bits::new(s_539_1 as u128, 32u16);
        // C s_539_3: const #1u : u64
        let s_539_3: u64 = 1;
        // D s_539_4: bit-extract s_539_2 s_539_0 s_539_3
        let s_539_4: Bits = (Bits::new(
            ((s_539_2) >> (s_539_0)).value(),
            u16::try_from(s_539_3).unwrap(),
        ));
        // D s_539_5: cast reint s_539_4 -> u8
        let s_539_5: bool = ((s_539_4.value()) != 0);
        // C s_539_6: const #0s : i
        let s_539_6: i128 = 0;
        // C s_539_7: const #0u : u64
        let s_539_7: u64 = 0;
        // D s_539_8: cast zx s_539_5 -> u64
        let s_539_8: u64 = (s_539_5 as u64);
        // C s_539_9: const #1u : u64
        let s_539_9: u64 = 1;
        // D s_539_10: and s_539_8 s_539_9
        let s_539_10: u64 = ((s_539_8) & (s_539_9));
        // D s_539_11: cmp-eq s_539_10 s_539_9
        let s_539_11: bool = ((s_539_10) == (s_539_9));
        // D s_539_12: lsl s_539_8 s_539_6
        let s_539_12: u64 = s_539_8 << s_539_6;
        // D s_539_13: or s_539_7 s_539_12
        let s_539_13: u64 = ((s_539_7) | (s_539_12));
        // D s_539_14: cmpl s_539_12
        let s_539_14: u64 = !s_539_12;
        // D s_539_15: and s_539_7 s_539_14
        let s_539_15: u64 = ((s_539_7) & (s_539_14));
        // D s_539_16: select s_539_11 s_539_13 s_539_15
        let s_539_16: u64 = if s_539_11 { s_539_13 } else { s_539_15 };
        // D s_539_17: cast trunc s_539_16 -> u8
        let s_539_17: bool = ((s_539_16) != 0);
        // D s_539_18: cast zx s_539_17 -> bv
        let s_539_18: Bits = Bits::new(s_539_17 as u128, 1u16);
        // C s_539_19: const #1u : u8
        let s_539_19: bool = true;
        // C s_539_20: cast zx s_539_19 -> bv
        let s_539_20: Bits = Bits::new(s_539_19 as u128, 1u16);
        // D s_539_21: cmp-ne s_539_18 s_539_20
        let s_539_21: bool = ((s_539_18) != (s_539_20));
        // D s_539_22: write-var gs#410293 <= s_539_21
        fn_state.gs_410293 = s_539_21;
        // N s_539_23: jump b540
        return block_540(state, tracer, fn_state);
    }
    fn block_540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_540_0: read-var gs#410293:u8
        let s_540_0: bool = fn_state.gs_410293;
        // N s_540_1: branch s_540_0 b542 b541
        if s_540_0 {
            return block_542(state, tracer, fn_state);
        } else {
            return block_541(state, tracer, fn_state);
        };
    }
    fn block_541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_541_0: read-var u#33649:u8
        let s_541_0: u8 = fn_state.u_33649;
        // D s_541_1: read-var u#33650:u8
        let s_541_1: u8 = fn_state.u_33650;
        // D s_541_2: read-var u#33651:u8
        let s_541_2: u8 = fn_state.u_33651;
        // D s_541_3: read-var u#33652:u8
        let s_541_3: u8 = fn_state.u_33652;
        // D s_541_4: call decode_aarch32_instrs_SSUB8_A1enc_A_txt(s_541_0, s_541_1, s_541_2, s_541_3)
        let s_541_4: () = decode_aarch32_instrs_SSUB8_A1enc_A_txt(
            state,
            tracer,
            s_541_0,
            s_541_1,
            s_541_2,
            s_541_3,
        );
        // N s_541_5: return
        return;
    }
    fn block_542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_542_0: panic
        panic!("{:?}", ());
        // N s_542_1: return
        return;
    }
    fn block_543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_543_0: const #1u : u8
        let s_543_0: bool = true;
        // D s_543_1: write-var gs#410293 <= s_543_0
        fn_state.gs_410293 = s_543_0;
        // N s_543_2: jump b540
        return block_540(state, tracer, fn_state);
    }
    fn block_544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_544_0: const #1u : u8
        let s_544_0: bool = true;
        // D s_544_1: write-var gs#410290 <= s_544_0
        fn_state.gs_410290 = s_544_0;
        // N s_544_2: jump b538
        return block_538(state, tracer, fn_state);
    }
    fn block_545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_545_0: const #1u : u8
        let s_545_0: bool = true;
        // D s_545_1: write-var gs#410287 <= s_545_0
        fn_state.gs_410287 = s_545_0;
        // N s_545_2: jump b536
        return block_536(state, tracer, fn_state);
    }
    fn block_546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_546_0: read-var merge#var.1:struct
        let s_546_0: u32 = fn_state.merge_var._1;
        // D s_546_1: write-var u#33654 <= s_546_0
        fn_state.u_33654 = s_546_0;
        // C s_546_2: const #20s : i
        let s_546_2: i128 = 20;
        // D s_546_3: read-var u#33654:u32
        let s_546_3: u32 = fn_state.u_33654;
        // D s_546_4: cast zx s_546_3 -> bv
        let s_546_4: Bits = Bits::new(s_546_3 as u128, 32u16);
        // C s_546_5: const #1s : i64
        let s_546_5: i64 = 1;
        // C s_546_6: cast zx s_546_5 -> i
        let s_546_6: i128 = (i128::try_from(s_546_5).unwrap());
        // C s_546_7: const #7s : i
        let s_546_7: i128 = 7;
        // C s_546_8: add s_546_7 s_546_6
        let s_546_8: i128 = (s_546_7 + s_546_6);
        // D s_546_9: bit-extract s_546_4 s_546_2 s_546_8
        let s_546_9: Bits = (Bits::new(
            ((s_546_4) >> (s_546_2)).value(),
            u16::try_from(s_546_8).unwrap(),
        ));
        // D s_546_10: cast reint s_546_9 -> u8
        let s_546_10: u8 = (s_546_9.value() as u8);
        // D s_546_11: cast zx s_546_10 -> bv
        let s_546_11: Bits = Bits::new(s_546_10 as u128, 8u16);
        // C s_546_12: const #104u : u8
        let s_546_12: u8 = 104;
        // C s_546_13: cast zx s_546_12 -> bv
        let s_546_13: Bits = Bits::new(s_546_12 as u128, 8u16);
        // D s_546_14: cmp-eq s_546_11 s_546_13
        let s_546_14: bool = ((s_546_11) == (s_546_13));
        // N s_546_15: branch s_546_14 b1222 b547
        if s_546_14 {
            return block_1222(state, tracer, fn_state);
        } else {
            return block_547(state, tracer, fn_state);
        };
    }
    fn block_547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_547_0: const #0u : u8
        let s_547_0: bool = false;
        // D s_547_1: write-var gs#410299 <= s_547_0
        fn_state.gs_410299 = s_547_0;
        // N s_547_2: jump b548
        return block_548(state, tracer, fn_state);
    }
    fn block_548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_548_0: read-var gs#410299:u8
        let s_548_0: bool = fn_state.gs_410299;
        // N s_548_1: branch s_548_0 b1218 b549
        if s_548_0 {
            return block_1218(state, tracer, fn_state);
        } else {
            return block_549(state, tracer, fn_state);
        };
    }
    fn block_549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_549_0: const #0u : u8
        let s_549_0: bool = false;
        // D s_549_1: write-var gs#410304 <= s_549_0
        fn_state.gs_410304 = s_549_0;
        // N s_549_2: jump b550
        return block_550(state, tracer, fn_state);
    }
    fn block_550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_550_0: read-var gs#410304:u8
        let s_550_0: bool = fn_state.gs_410304;
        // D s_550_1: not s_550_0
        let s_550_1: bool = !s_550_0;
        // N s_550_2: branch s_550_1 b557 b551
        if s_550_1 {
            return block_557(state, tracer, fn_state);
        } else {
            return block_551(state, tracer, fn_state);
        };
    }
    fn block_551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_551_0: const #3253s : i
        let s_551_0: i128 = 3253;
        // C s_551_1: const #14696u : u32
        let s_551_1: u32 = 14696;
        // N s_551_2: write-reg s_551_1 <= s_551_0
        let s_551_2: () = {
            state.write_register::<i128>(s_551_1 as isize, s_551_0);
            tracer.write_register(s_551_1 as isize, s_551_0);
        };
        // C s_551_3: const #28s : i
        let s_551_3: i128 = 28;
        // C s_551_4: const #4s : i
        let s_551_4: i128 = 4;
        // D s_551_5: read-var u#33654:u32
        let s_551_5: u32 = fn_state.u_33654;
        // D s_551_6: cast zx s_551_5 -> bv
        let s_551_6: Bits = Bits::new(s_551_5 as u128, 32u16);
        // D s_551_7: bit-extract s_551_6 s_551_3 s_551_4
        let s_551_7: Bits = (Bits::new(
            ((s_551_6) >> (s_551_3)).value(),
            u16::try_from(s_551_4).unwrap(),
        ));
        // D s_551_8: cast reint s_551_7 -> u8
        let s_551_8: u8 = (s_551_7.value() as u8);
        // D s_551_9: write-var u#33655 <= s_551_8
        fn_state.u_33655 = s_551_8;
        // C s_551_10: const #16s : i
        let s_551_10: i128 = 16;
        // C s_551_11: const #4s : i
        let s_551_11: i128 = 4;
        // D s_551_12: read-var u#33654:u32
        let s_551_12: u32 = fn_state.u_33654;
        // D s_551_13: cast zx s_551_12 -> bv
        let s_551_13: Bits = Bits::new(s_551_12 as u128, 32u16);
        // D s_551_14: bit-extract s_551_13 s_551_10 s_551_11
        let s_551_14: Bits = (Bits::new(
            ((s_551_13) >> (s_551_10)).value(),
            u16::try_from(s_551_11).unwrap(),
        ));
        // D s_551_15: cast reint s_551_14 -> u8
        let s_551_15: u8 = (s_551_14.value() as u8);
        // D s_551_16: write-var u#33656 <= s_551_15
        fn_state.u_33656 = s_551_15;
        // C s_551_17: const #12s : i
        let s_551_17: i128 = 12;
        // C s_551_18: const #4s : i
        let s_551_18: i128 = 4;
        // D s_551_19: read-var u#33654:u32
        let s_551_19: u32 = fn_state.u_33654;
        // D s_551_20: cast zx s_551_19 -> bv
        let s_551_20: Bits = Bits::new(s_551_19 as u128, 32u16);
        // D s_551_21: bit-extract s_551_20 s_551_17 s_551_18
        let s_551_21: Bits = (Bits::new(
            ((s_551_20) >> (s_551_17)).value(),
            u16::try_from(s_551_18).unwrap(),
        ));
        // D s_551_22: cast reint s_551_21 -> u8
        let s_551_22: u8 = (s_551_21.value() as u8);
        // D s_551_23: write-var u#33657 <= s_551_22
        fn_state.u_33657 = s_551_22;
        // C s_551_24: const #10s : i
        let s_551_24: i128 = 10;
        // C s_551_25: const #2s : i
        let s_551_25: i128 = 2;
        // D s_551_26: read-var u#33654:u32
        let s_551_26: u32 = fn_state.u_33654;
        // D s_551_27: cast zx s_551_26 -> bv
        let s_551_27: Bits = Bits::new(s_551_26 as u128, 32u16);
        // D s_551_28: bit-extract s_551_27 s_551_24 s_551_25
        let s_551_28: Bits = (Bits::new(
            ((s_551_27) >> (s_551_24)).value(),
            u16::try_from(s_551_25).unwrap(),
        ));
        // D s_551_29: cast reint s_551_28 -> u8
        let s_551_29: u8 = (s_551_28.value() as u8);
        // D s_551_30: write-var rotate <= s_551_29
        fn_state.rotate = s_551_29;
        // C s_551_31: const #0s : i
        let s_551_31: i128 = 0;
        // C s_551_32: const #4s : i
        let s_551_32: i128 = 4;
        // D s_551_33: read-var u#33654:u32
        let s_551_33: u32 = fn_state.u_33654;
        // D s_551_34: cast zx s_551_33 -> bv
        let s_551_34: Bits = Bits::new(s_551_33 as u128, 32u16);
        // D s_551_35: bit-extract s_551_34 s_551_31 s_551_32
        let s_551_35: Bits = (Bits::new(
            ((s_551_34) >> (s_551_31)).value(),
            u16::try_from(s_551_32).unwrap(),
        ));
        // D s_551_36: cast reint s_551_35 -> u8
        let s_551_36: u8 = (s_551_35.value() as u8);
        // D s_551_37: write-var u#33658 <= s_551_36
        fn_state.u_33658 = s_551_36;
        // C s_551_38: const #8s : i
        let s_551_38: i128 = 8;
        // D s_551_39: read-var u#33654:u32
        let s_551_39: u32 = fn_state.u_33654;
        // D s_551_40: cast zx s_551_39 -> bv
        let s_551_40: Bits = Bits::new(s_551_39 as u128, 32u16);
        // C s_551_41: const #1u : u64
        let s_551_41: u64 = 1;
        // D s_551_42: bit-extract s_551_40 s_551_38 s_551_41
        let s_551_42: Bits = (Bits::new(
            ((s_551_40) >> (s_551_38)).value(),
            u16::try_from(s_551_41).unwrap(),
        ));
        // D s_551_43: cast reint s_551_42 -> u8
        let s_551_43: bool = ((s_551_42.value()) != 0);
        // C s_551_44: const #0s : i
        let s_551_44: i128 = 0;
        // C s_551_45: const #0u : u64
        let s_551_45: u64 = 0;
        // D s_551_46: cast zx s_551_43 -> u64
        let s_551_46: u64 = (s_551_43 as u64);
        // C s_551_47: const #1u : u64
        let s_551_47: u64 = 1;
        // D s_551_48: and s_551_46 s_551_47
        let s_551_48: u64 = ((s_551_46) & (s_551_47));
        // D s_551_49: cmp-eq s_551_48 s_551_47
        let s_551_49: bool = ((s_551_48) == (s_551_47));
        // D s_551_50: lsl s_551_46 s_551_44
        let s_551_50: u64 = s_551_46 << s_551_44;
        // D s_551_51: or s_551_45 s_551_50
        let s_551_51: u64 = ((s_551_45) | (s_551_50));
        // D s_551_52: cmpl s_551_50
        let s_551_52: u64 = !s_551_50;
        // D s_551_53: and s_551_45 s_551_52
        let s_551_53: u64 = ((s_551_45) & (s_551_52));
        // D s_551_54: select s_551_49 s_551_51 s_551_53
        let s_551_54: u64 = if s_551_49 { s_551_51 } else { s_551_53 };
        // D s_551_55: cast trunc s_551_54 -> u8
        let s_551_55: bool = ((s_551_54) != 0);
        // D s_551_56: cast zx s_551_55 -> bv
        let s_551_56: Bits = Bits::new(s_551_55 as u128, 1u16);
        // C s_551_57: const #0u : u8
        let s_551_57: bool = false;
        // C s_551_58: cast zx s_551_57 -> bv
        let s_551_58: Bits = Bits::new(s_551_57 as u128, 1u16);
        // D s_551_59: cmp-ne s_551_56 s_551_58
        let s_551_59: bool = ((s_551_56) != (s_551_58));
        // N s_551_60: branch s_551_59 b556 b552
        if s_551_59 {
            return block_556(state, tracer, fn_state);
        } else {
            return block_552(state, tracer, fn_state);
        };
    }
    fn block_552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_552_0: const #9s : i
        let s_552_0: i128 = 9;
        // D s_552_1: read-var u#33654:u32
        let s_552_1: u32 = fn_state.u_33654;
        // D s_552_2: cast zx s_552_1 -> bv
        let s_552_2: Bits = Bits::new(s_552_1 as u128, 32u16);
        // C s_552_3: const #1u : u64
        let s_552_3: u64 = 1;
        // D s_552_4: bit-extract s_552_2 s_552_0 s_552_3
        let s_552_4: Bits = (Bits::new(
            ((s_552_2) >> (s_552_0)).value(),
            u16::try_from(s_552_3).unwrap(),
        ));
        // D s_552_5: cast reint s_552_4 -> u8
        let s_552_5: bool = ((s_552_4.value()) != 0);
        // C s_552_6: const #0s : i
        let s_552_6: i128 = 0;
        // C s_552_7: const #0u : u64
        let s_552_7: u64 = 0;
        // D s_552_8: cast zx s_552_5 -> u64
        let s_552_8: u64 = (s_552_5 as u64);
        // C s_552_9: const #1u : u64
        let s_552_9: u64 = 1;
        // D s_552_10: and s_552_8 s_552_9
        let s_552_10: u64 = ((s_552_8) & (s_552_9));
        // D s_552_11: cmp-eq s_552_10 s_552_9
        let s_552_11: bool = ((s_552_10) == (s_552_9));
        // D s_552_12: lsl s_552_8 s_552_6
        let s_552_12: u64 = s_552_8 << s_552_6;
        // D s_552_13: or s_552_7 s_552_12
        let s_552_13: u64 = ((s_552_7) | (s_552_12));
        // D s_552_14: cmpl s_552_12
        let s_552_14: u64 = !s_552_12;
        // D s_552_15: and s_552_7 s_552_14
        let s_552_15: u64 = ((s_552_7) & (s_552_14));
        // D s_552_16: select s_552_11 s_552_13 s_552_15
        let s_552_16: u64 = if s_552_11 { s_552_13 } else { s_552_15 };
        // D s_552_17: cast trunc s_552_16 -> u8
        let s_552_17: bool = ((s_552_16) != 0);
        // D s_552_18: cast zx s_552_17 -> bv
        let s_552_18: Bits = Bits::new(s_552_17 as u128, 1u16);
        // C s_552_19: const #0u : u8
        let s_552_19: bool = false;
        // C s_552_20: cast zx s_552_19 -> bv
        let s_552_20: Bits = Bits::new(s_552_19 as u128, 1u16);
        // D s_552_21: cmp-ne s_552_18 s_552_20
        let s_552_21: bool = ((s_552_18) != (s_552_20));
        // D s_552_22: write-var gs#410321 <= s_552_21
        fn_state.gs_410321 = s_552_21;
        // N s_552_23: jump b553
        return block_553(state, tracer, fn_state);
    }
    fn block_553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_553_0: read-var gs#410321:u8
        let s_553_0: bool = fn_state.gs_410321;
        // N s_553_1: branch s_553_0 b555 b554
        if s_553_0 {
            return block_555(state, tracer, fn_state);
        } else {
            return block_554(state, tracer, fn_state);
        };
    }
    fn block_554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_554_0: read-var u#33655:u8
        let s_554_0: u8 = fn_state.u_33655;
        // D s_554_1: read-var u#33656:u8
        let s_554_1: u8 = fn_state.u_33656;
        // D s_554_2: read-var u#33657:u8
        let s_554_2: u8 = fn_state.u_33657;
        // D s_554_3: read-var rotate:u8
        let s_554_3: u8 = fn_state.rotate;
        // D s_554_4: read-var u#33658:u8
        let s_554_4: u8 = fn_state.u_33658;
        // D s_554_5: call decode_aarch32_instrs_SXTAB16_A1enc_A_txt(s_554_0, s_554_1, s_554_2, s_554_3, s_554_4)
        let s_554_5: () = decode_aarch32_instrs_SXTAB16_A1enc_A_txt(
            state,
            tracer,
            s_554_0,
            s_554_1,
            s_554_2,
            s_554_3,
            s_554_4,
        );
        // N s_554_6: return
        return;
    }
    fn block_555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_555_0: panic
        panic!("{:?}", ());
        // N s_555_1: return
        return;
    }
    fn block_556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_556_0: const #1u : u8
        let s_556_0: bool = true;
        // D s_556_1: write-var gs#410321 <= s_556_0
        fn_state.gs_410321 = s_556_0;
        // N s_556_2: jump b553
        return block_553(state, tracer, fn_state);
    }
    fn block_557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_557_0: read-var merge#var.1:struct
        let s_557_0: u32 = fn_state.merge_var._1;
        // D s_557_1: write-var u#33660 <= s_557_0
        fn_state.u_33660 = s_557_0;
        // C s_557_2: const #20s : i
        let s_557_2: i128 = 20;
        // D s_557_3: read-var u#33660:u32
        let s_557_3: u32 = fn_state.u_33660;
        // D s_557_4: cast zx s_557_3 -> bv
        let s_557_4: Bits = Bits::new(s_557_3 as u128, 32u16);
        // C s_557_5: const #1s : i64
        let s_557_5: i64 = 1;
        // C s_557_6: cast zx s_557_5 -> i
        let s_557_6: i128 = (i128::try_from(s_557_5).unwrap());
        // C s_557_7: const #7s : i
        let s_557_7: i128 = 7;
        // C s_557_8: add s_557_7 s_557_6
        let s_557_8: i128 = (s_557_7 + s_557_6);
        // D s_557_9: bit-extract s_557_4 s_557_2 s_557_8
        let s_557_9: Bits = (Bits::new(
            ((s_557_4) >> (s_557_2)).value(),
            u16::try_from(s_557_8).unwrap(),
        ));
        // D s_557_10: cast reint s_557_9 -> u8
        let s_557_10: u8 = (s_557_9.value() as u8);
        // D s_557_11: cast zx s_557_10 -> bv
        let s_557_11: Bits = Bits::new(s_557_10 as u128, 8u16);
        // C s_557_12: const #106u : u8
        let s_557_12: u8 = 106;
        // C s_557_13: cast zx s_557_12 -> bv
        let s_557_13: Bits = Bits::new(s_557_12 as u128, 8u16);
        // D s_557_14: cmp-eq s_557_11 s_557_13
        let s_557_14: bool = ((s_557_11) == (s_557_13));
        // N s_557_15: branch s_557_14 b1217 b558
        if s_557_14 {
            return block_1217(state, tracer, fn_state);
        } else {
            return block_558(state, tracer, fn_state);
        };
    }
    fn block_558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_558_0: const #0u : u8
        let s_558_0: bool = false;
        // D s_558_1: write-var gs#410327 <= s_558_0
        fn_state.gs_410327 = s_558_0;
        // N s_558_2: jump b559
        return block_559(state, tracer, fn_state);
    }
    fn block_559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_559_0: read-var gs#410327:u8
        let s_559_0: bool = fn_state.gs_410327;
        // N s_559_1: branch s_559_0 b1213 b560
        if s_559_0 {
            return block_1213(state, tracer, fn_state);
        } else {
            return block_560(state, tracer, fn_state);
        };
    }
    fn block_560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_560_0: const #0u : u8
        let s_560_0: bool = false;
        // D s_560_1: write-var gs#410332 <= s_560_0
        fn_state.gs_410332 = s_560_0;
        // N s_560_2: jump b561
        return block_561(state, tracer, fn_state);
    }
    fn block_561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_561_0: read-var gs#410332:u8
        let s_561_0: bool = fn_state.gs_410332;
        // D s_561_1: not s_561_0
        let s_561_1: bool = !s_561_0;
        // N s_561_2: branch s_561_1 b568 b562
        if s_561_1 {
            return block_568(state, tracer, fn_state);
        } else {
            return block_562(state, tracer, fn_state);
        };
    }
    fn block_562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_562_0: const #3255s : i
        let s_562_0: i128 = 3255;
        // C s_562_1: const #14696u : u32
        let s_562_1: u32 = 14696;
        // N s_562_2: write-reg s_562_1 <= s_562_0
        let s_562_2: () = {
            state.write_register::<i128>(s_562_1 as isize, s_562_0);
            tracer.write_register(s_562_1 as isize, s_562_0);
        };
        // C s_562_3: const #28s : i
        let s_562_3: i128 = 28;
        // C s_562_4: const #4s : i
        let s_562_4: i128 = 4;
        // D s_562_5: read-var u#33660:u32
        let s_562_5: u32 = fn_state.u_33660;
        // D s_562_6: cast zx s_562_5 -> bv
        let s_562_6: Bits = Bits::new(s_562_5 as u128, 32u16);
        // D s_562_7: bit-extract s_562_6 s_562_3 s_562_4
        let s_562_7: Bits = (Bits::new(
            ((s_562_6) >> (s_562_3)).value(),
            u16::try_from(s_562_4).unwrap(),
        ));
        // D s_562_8: cast reint s_562_7 -> u8
        let s_562_8: u8 = (s_562_7.value() as u8);
        // D s_562_9: write-var u#33661 <= s_562_8
        fn_state.u_33661 = s_562_8;
        // C s_562_10: const #16s : i
        let s_562_10: i128 = 16;
        // C s_562_11: const #4s : i
        let s_562_11: i128 = 4;
        // D s_562_12: read-var u#33660:u32
        let s_562_12: u32 = fn_state.u_33660;
        // D s_562_13: cast zx s_562_12 -> bv
        let s_562_13: Bits = Bits::new(s_562_12 as u128, 32u16);
        // D s_562_14: bit-extract s_562_13 s_562_10 s_562_11
        let s_562_14: Bits = (Bits::new(
            ((s_562_13) >> (s_562_10)).value(),
            u16::try_from(s_562_11).unwrap(),
        ));
        // D s_562_15: cast reint s_562_14 -> u8
        let s_562_15: u8 = (s_562_14.value() as u8);
        // D s_562_16: write-var u#33662 <= s_562_15
        fn_state.u_33662 = s_562_15;
        // C s_562_17: const #12s : i
        let s_562_17: i128 = 12;
        // C s_562_18: const #4s : i
        let s_562_18: i128 = 4;
        // D s_562_19: read-var u#33660:u32
        let s_562_19: u32 = fn_state.u_33660;
        // D s_562_20: cast zx s_562_19 -> bv
        let s_562_20: Bits = Bits::new(s_562_19 as u128, 32u16);
        // D s_562_21: bit-extract s_562_20 s_562_17 s_562_18
        let s_562_21: Bits = (Bits::new(
            ((s_562_20) >> (s_562_17)).value(),
            u16::try_from(s_562_18).unwrap(),
        ));
        // D s_562_22: cast reint s_562_21 -> u8
        let s_562_22: u8 = (s_562_21.value() as u8);
        // D s_562_23: write-var u#33663 <= s_562_22
        fn_state.u_33663 = s_562_22;
        // C s_562_24: const #10s : i
        let s_562_24: i128 = 10;
        // C s_562_25: const #2s : i
        let s_562_25: i128 = 2;
        // D s_562_26: read-var u#33660:u32
        let s_562_26: u32 = fn_state.u_33660;
        // D s_562_27: cast zx s_562_26 -> bv
        let s_562_27: Bits = Bits::new(s_562_26 as u128, 32u16);
        // D s_562_28: bit-extract s_562_27 s_562_24 s_562_25
        let s_562_28: Bits = (Bits::new(
            ((s_562_27) >> (s_562_24)).value(),
            u16::try_from(s_562_25).unwrap(),
        ));
        // D s_562_29: cast reint s_562_28 -> u8
        let s_562_29: u8 = (s_562_28.value() as u8);
        // D s_562_30: write-var u#33664 <= s_562_29
        fn_state.u_33664 = s_562_29;
        // C s_562_31: const #0s : i
        let s_562_31: i128 = 0;
        // C s_562_32: const #4s : i
        let s_562_32: i128 = 4;
        // D s_562_33: read-var u#33660:u32
        let s_562_33: u32 = fn_state.u_33660;
        // D s_562_34: cast zx s_562_33 -> bv
        let s_562_34: Bits = Bits::new(s_562_33 as u128, 32u16);
        // D s_562_35: bit-extract s_562_34 s_562_31 s_562_32
        let s_562_35: Bits = (Bits::new(
            ((s_562_34) >> (s_562_31)).value(),
            u16::try_from(s_562_32).unwrap(),
        ));
        // D s_562_36: cast reint s_562_35 -> u8
        let s_562_36: u8 = (s_562_35.value() as u8);
        // D s_562_37: write-var u#33665 <= s_562_36
        fn_state.u_33665 = s_562_36;
        // C s_562_38: const #8s : i
        let s_562_38: i128 = 8;
        // D s_562_39: read-var u#33660:u32
        let s_562_39: u32 = fn_state.u_33660;
        // D s_562_40: cast zx s_562_39 -> bv
        let s_562_40: Bits = Bits::new(s_562_39 as u128, 32u16);
        // C s_562_41: const #1u : u64
        let s_562_41: u64 = 1;
        // D s_562_42: bit-extract s_562_40 s_562_38 s_562_41
        let s_562_42: Bits = (Bits::new(
            ((s_562_40) >> (s_562_38)).value(),
            u16::try_from(s_562_41).unwrap(),
        ));
        // D s_562_43: cast reint s_562_42 -> u8
        let s_562_43: bool = ((s_562_42.value()) != 0);
        // C s_562_44: const #0s : i
        let s_562_44: i128 = 0;
        // C s_562_45: const #0u : u64
        let s_562_45: u64 = 0;
        // D s_562_46: cast zx s_562_43 -> u64
        let s_562_46: u64 = (s_562_43 as u64);
        // C s_562_47: const #1u : u64
        let s_562_47: u64 = 1;
        // D s_562_48: and s_562_46 s_562_47
        let s_562_48: u64 = ((s_562_46) & (s_562_47));
        // D s_562_49: cmp-eq s_562_48 s_562_47
        let s_562_49: bool = ((s_562_48) == (s_562_47));
        // D s_562_50: lsl s_562_46 s_562_44
        let s_562_50: u64 = s_562_46 << s_562_44;
        // D s_562_51: or s_562_45 s_562_50
        let s_562_51: u64 = ((s_562_45) | (s_562_50));
        // D s_562_52: cmpl s_562_50
        let s_562_52: u64 = !s_562_50;
        // D s_562_53: and s_562_45 s_562_52
        let s_562_53: u64 = ((s_562_45) & (s_562_52));
        // D s_562_54: select s_562_49 s_562_51 s_562_53
        let s_562_54: u64 = if s_562_49 { s_562_51 } else { s_562_53 };
        // D s_562_55: cast trunc s_562_54 -> u8
        let s_562_55: bool = ((s_562_54) != 0);
        // D s_562_56: cast zx s_562_55 -> bv
        let s_562_56: Bits = Bits::new(s_562_55 as u128, 1u16);
        // C s_562_57: const #0u : u8
        let s_562_57: bool = false;
        // C s_562_58: cast zx s_562_57 -> bv
        let s_562_58: Bits = Bits::new(s_562_57 as u128, 1u16);
        // D s_562_59: cmp-ne s_562_56 s_562_58
        let s_562_59: bool = ((s_562_56) != (s_562_58));
        // N s_562_60: branch s_562_59 b567 b563
        if s_562_59 {
            return block_567(state, tracer, fn_state);
        } else {
            return block_563(state, tracer, fn_state);
        };
    }
    fn block_563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_563_0: const #9s : i
        let s_563_0: i128 = 9;
        // D s_563_1: read-var u#33660:u32
        let s_563_1: u32 = fn_state.u_33660;
        // D s_563_2: cast zx s_563_1 -> bv
        let s_563_2: Bits = Bits::new(s_563_1 as u128, 32u16);
        // C s_563_3: const #1u : u64
        let s_563_3: u64 = 1;
        // D s_563_4: bit-extract s_563_2 s_563_0 s_563_3
        let s_563_4: Bits = (Bits::new(
            ((s_563_2) >> (s_563_0)).value(),
            u16::try_from(s_563_3).unwrap(),
        ));
        // D s_563_5: cast reint s_563_4 -> u8
        let s_563_5: bool = ((s_563_4.value()) != 0);
        // C s_563_6: const #0s : i
        let s_563_6: i128 = 0;
        // C s_563_7: const #0u : u64
        let s_563_7: u64 = 0;
        // D s_563_8: cast zx s_563_5 -> u64
        let s_563_8: u64 = (s_563_5 as u64);
        // C s_563_9: const #1u : u64
        let s_563_9: u64 = 1;
        // D s_563_10: and s_563_8 s_563_9
        let s_563_10: u64 = ((s_563_8) & (s_563_9));
        // D s_563_11: cmp-eq s_563_10 s_563_9
        let s_563_11: bool = ((s_563_10) == (s_563_9));
        // D s_563_12: lsl s_563_8 s_563_6
        let s_563_12: u64 = s_563_8 << s_563_6;
        // D s_563_13: or s_563_7 s_563_12
        let s_563_13: u64 = ((s_563_7) | (s_563_12));
        // D s_563_14: cmpl s_563_12
        let s_563_14: u64 = !s_563_12;
        // D s_563_15: and s_563_7 s_563_14
        let s_563_15: u64 = ((s_563_7) & (s_563_14));
        // D s_563_16: select s_563_11 s_563_13 s_563_15
        let s_563_16: u64 = if s_563_11 { s_563_13 } else { s_563_15 };
        // D s_563_17: cast trunc s_563_16 -> u8
        let s_563_17: bool = ((s_563_16) != 0);
        // D s_563_18: cast zx s_563_17 -> bv
        let s_563_18: Bits = Bits::new(s_563_17 as u128, 1u16);
        // C s_563_19: const #0u : u8
        let s_563_19: bool = false;
        // C s_563_20: cast zx s_563_19 -> bv
        let s_563_20: Bits = Bits::new(s_563_19 as u128, 1u16);
        // D s_563_21: cmp-ne s_563_18 s_563_20
        let s_563_21: bool = ((s_563_18) != (s_563_20));
        // D s_563_22: write-var gs#410349 <= s_563_21
        fn_state.gs_410349 = s_563_21;
        // N s_563_23: jump b564
        return block_564(state, tracer, fn_state);
    }
    fn block_564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_564_0: read-var gs#410349:u8
        let s_564_0: bool = fn_state.gs_410349;
        // N s_564_1: branch s_564_0 b566 b565
        if s_564_0 {
            return block_566(state, tracer, fn_state);
        } else {
            return block_565(state, tracer, fn_state);
        };
    }
    fn block_565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_565_0: read-var u#33661:u8
        let s_565_0: u8 = fn_state.u_33661;
        // D s_565_1: read-var u#33662:u8
        let s_565_1: u8 = fn_state.u_33662;
        // D s_565_2: read-var u#33663:u8
        let s_565_2: u8 = fn_state.u_33663;
        // D s_565_3: read-var u#33664:u8
        let s_565_3: u8 = fn_state.u_33664;
        // D s_565_4: read-var u#33665:u8
        let s_565_4: u8 = fn_state.u_33665;
        // D s_565_5: call decode_aarch32_instrs_SXTAB_A1enc_A_txt(s_565_0, s_565_1, s_565_2, s_565_3, s_565_4)
        let s_565_5: () = decode_aarch32_instrs_SXTAB_A1enc_A_txt(
            state,
            tracer,
            s_565_0,
            s_565_1,
            s_565_2,
            s_565_3,
            s_565_4,
        );
        // N s_565_6: return
        return;
    }
    fn block_566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_566_0: panic
        panic!("{:?}", ());
        // N s_566_1: return
        return;
    }
    fn block_567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_567_0: const #1u : u8
        let s_567_0: bool = true;
        // D s_567_1: write-var gs#410349 <= s_567_0
        fn_state.gs_410349 = s_567_0;
        // N s_567_2: jump b564
        return block_564(state, tracer, fn_state);
    }
    fn block_568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_568_0: read-var merge#var.1:struct
        let s_568_0: u32 = fn_state.merge_var._1;
        // D s_568_1: write-var u#33667 <= s_568_0
        fn_state.u_33667 = s_568_0;
        // C s_568_2: const #20s : i
        let s_568_2: i128 = 20;
        // D s_568_3: read-var u#33667:u32
        let s_568_3: u32 = fn_state.u_33667;
        // D s_568_4: cast zx s_568_3 -> bv
        let s_568_4: Bits = Bits::new(s_568_3 as u128, 32u16);
        // C s_568_5: const #1s : i64
        let s_568_5: i64 = 1;
        // C s_568_6: cast zx s_568_5 -> i
        let s_568_6: i128 = (i128::try_from(s_568_5).unwrap());
        // C s_568_7: const #7s : i
        let s_568_7: i128 = 7;
        // C s_568_8: add s_568_7 s_568_6
        let s_568_8: i128 = (s_568_7 + s_568_6);
        // D s_568_9: bit-extract s_568_4 s_568_2 s_568_8
        let s_568_9: Bits = (Bits::new(
            ((s_568_4) >> (s_568_2)).value(),
            u16::try_from(s_568_8).unwrap(),
        ));
        // D s_568_10: cast reint s_568_9 -> u8
        let s_568_10: u8 = (s_568_9.value() as u8);
        // D s_568_11: cast zx s_568_10 -> bv
        let s_568_11: Bits = Bits::new(s_568_10 as u128, 8u16);
        // C s_568_12: const #107u : u8
        let s_568_12: u8 = 107;
        // C s_568_13: cast zx s_568_12 -> bv
        let s_568_13: Bits = Bits::new(s_568_12 as u128, 8u16);
        // D s_568_14: cmp-eq s_568_11 s_568_13
        let s_568_14: bool = ((s_568_11) == (s_568_13));
        // N s_568_15: branch s_568_14 b1212 b569
        if s_568_14 {
            return block_1212(state, tracer, fn_state);
        } else {
            return block_569(state, tracer, fn_state);
        };
    }
    fn block_569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_569_0: const #0u : u8
        let s_569_0: bool = false;
        // D s_569_1: write-var gs#410355 <= s_569_0
        fn_state.gs_410355 = s_569_0;
        // N s_569_2: jump b570
        return block_570(state, tracer, fn_state);
    }
    fn block_570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_570_0: read-var gs#410355:u8
        let s_570_0: bool = fn_state.gs_410355;
        // N s_570_1: branch s_570_0 b1208 b571
        if s_570_0 {
            return block_1208(state, tracer, fn_state);
        } else {
            return block_571(state, tracer, fn_state);
        };
    }
    fn block_571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_571_0: const #0u : u8
        let s_571_0: bool = false;
        // D s_571_1: write-var gs#410360 <= s_571_0
        fn_state.gs_410360 = s_571_0;
        // N s_571_2: jump b572
        return block_572(state, tracer, fn_state);
    }
    fn block_572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_572_0: read-var gs#410360:u8
        let s_572_0: bool = fn_state.gs_410360;
        // D s_572_1: not s_572_0
        let s_572_1: bool = !s_572_0;
        // N s_572_2: branch s_572_1 b579 b573
        if s_572_1 {
            return block_579(state, tracer, fn_state);
        } else {
            return block_573(state, tracer, fn_state);
        };
    }
    fn block_573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_573_0: const #3257s : i
        let s_573_0: i128 = 3257;
        // C s_573_1: const #14696u : u32
        let s_573_1: u32 = 14696;
        // N s_573_2: write-reg s_573_1 <= s_573_0
        let s_573_2: () = {
            state.write_register::<i128>(s_573_1 as isize, s_573_0);
            tracer.write_register(s_573_1 as isize, s_573_0);
        };
        // C s_573_3: const #28s : i
        let s_573_3: i128 = 28;
        // C s_573_4: const #4s : i
        let s_573_4: i128 = 4;
        // D s_573_5: read-var u#33667:u32
        let s_573_5: u32 = fn_state.u_33667;
        // D s_573_6: cast zx s_573_5 -> bv
        let s_573_6: Bits = Bits::new(s_573_5 as u128, 32u16);
        // D s_573_7: bit-extract s_573_6 s_573_3 s_573_4
        let s_573_7: Bits = (Bits::new(
            ((s_573_6) >> (s_573_3)).value(),
            u16::try_from(s_573_4).unwrap(),
        ));
        // D s_573_8: cast reint s_573_7 -> u8
        let s_573_8: u8 = (s_573_7.value() as u8);
        // D s_573_9: write-var u#33668 <= s_573_8
        fn_state.u_33668 = s_573_8;
        // C s_573_10: const #16s : i
        let s_573_10: i128 = 16;
        // C s_573_11: const #4s : i
        let s_573_11: i128 = 4;
        // D s_573_12: read-var u#33667:u32
        let s_573_12: u32 = fn_state.u_33667;
        // D s_573_13: cast zx s_573_12 -> bv
        let s_573_13: Bits = Bits::new(s_573_12 as u128, 32u16);
        // D s_573_14: bit-extract s_573_13 s_573_10 s_573_11
        let s_573_14: Bits = (Bits::new(
            ((s_573_13) >> (s_573_10)).value(),
            u16::try_from(s_573_11).unwrap(),
        ));
        // D s_573_15: cast reint s_573_14 -> u8
        let s_573_15: u8 = (s_573_14.value() as u8);
        // D s_573_16: write-var u#33669 <= s_573_15
        fn_state.u_33669 = s_573_15;
        // C s_573_17: const #12s : i
        let s_573_17: i128 = 12;
        // C s_573_18: const #4s : i
        let s_573_18: i128 = 4;
        // D s_573_19: read-var u#33667:u32
        let s_573_19: u32 = fn_state.u_33667;
        // D s_573_20: cast zx s_573_19 -> bv
        let s_573_20: Bits = Bits::new(s_573_19 as u128, 32u16);
        // D s_573_21: bit-extract s_573_20 s_573_17 s_573_18
        let s_573_21: Bits = (Bits::new(
            ((s_573_20) >> (s_573_17)).value(),
            u16::try_from(s_573_18).unwrap(),
        ));
        // D s_573_22: cast reint s_573_21 -> u8
        let s_573_22: u8 = (s_573_21.value() as u8);
        // D s_573_23: write-var u#33670 <= s_573_22
        fn_state.u_33670 = s_573_22;
        // C s_573_24: const #10s : i
        let s_573_24: i128 = 10;
        // C s_573_25: const #2s : i
        let s_573_25: i128 = 2;
        // D s_573_26: read-var u#33667:u32
        let s_573_26: u32 = fn_state.u_33667;
        // D s_573_27: cast zx s_573_26 -> bv
        let s_573_27: Bits = Bits::new(s_573_26 as u128, 32u16);
        // D s_573_28: bit-extract s_573_27 s_573_24 s_573_25
        let s_573_28: Bits = (Bits::new(
            ((s_573_27) >> (s_573_24)).value(),
            u16::try_from(s_573_25).unwrap(),
        ));
        // D s_573_29: cast reint s_573_28 -> u8
        let s_573_29: u8 = (s_573_28.value() as u8);
        // D s_573_30: write-var u#33671 <= s_573_29
        fn_state.u_33671 = s_573_29;
        // C s_573_31: const #0s : i
        let s_573_31: i128 = 0;
        // C s_573_32: const #4s : i
        let s_573_32: i128 = 4;
        // D s_573_33: read-var u#33667:u32
        let s_573_33: u32 = fn_state.u_33667;
        // D s_573_34: cast zx s_573_33 -> bv
        let s_573_34: Bits = Bits::new(s_573_33 as u128, 32u16);
        // D s_573_35: bit-extract s_573_34 s_573_31 s_573_32
        let s_573_35: Bits = (Bits::new(
            ((s_573_34) >> (s_573_31)).value(),
            u16::try_from(s_573_32).unwrap(),
        ));
        // D s_573_36: cast reint s_573_35 -> u8
        let s_573_36: u8 = (s_573_35.value() as u8);
        // D s_573_37: write-var u#33672 <= s_573_36
        fn_state.u_33672 = s_573_36;
        // C s_573_38: const #8s : i
        let s_573_38: i128 = 8;
        // D s_573_39: read-var u#33667:u32
        let s_573_39: u32 = fn_state.u_33667;
        // D s_573_40: cast zx s_573_39 -> bv
        let s_573_40: Bits = Bits::new(s_573_39 as u128, 32u16);
        // C s_573_41: const #1u : u64
        let s_573_41: u64 = 1;
        // D s_573_42: bit-extract s_573_40 s_573_38 s_573_41
        let s_573_42: Bits = (Bits::new(
            ((s_573_40) >> (s_573_38)).value(),
            u16::try_from(s_573_41).unwrap(),
        ));
        // D s_573_43: cast reint s_573_42 -> u8
        let s_573_43: bool = ((s_573_42.value()) != 0);
        // C s_573_44: const #0s : i
        let s_573_44: i128 = 0;
        // C s_573_45: const #0u : u64
        let s_573_45: u64 = 0;
        // D s_573_46: cast zx s_573_43 -> u64
        let s_573_46: u64 = (s_573_43 as u64);
        // C s_573_47: const #1u : u64
        let s_573_47: u64 = 1;
        // D s_573_48: and s_573_46 s_573_47
        let s_573_48: u64 = ((s_573_46) & (s_573_47));
        // D s_573_49: cmp-eq s_573_48 s_573_47
        let s_573_49: bool = ((s_573_48) == (s_573_47));
        // D s_573_50: lsl s_573_46 s_573_44
        let s_573_50: u64 = s_573_46 << s_573_44;
        // D s_573_51: or s_573_45 s_573_50
        let s_573_51: u64 = ((s_573_45) | (s_573_50));
        // D s_573_52: cmpl s_573_50
        let s_573_52: u64 = !s_573_50;
        // D s_573_53: and s_573_45 s_573_52
        let s_573_53: u64 = ((s_573_45) & (s_573_52));
        // D s_573_54: select s_573_49 s_573_51 s_573_53
        let s_573_54: u64 = if s_573_49 { s_573_51 } else { s_573_53 };
        // D s_573_55: cast trunc s_573_54 -> u8
        let s_573_55: bool = ((s_573_54) != 0);
        // D s_573_56: cast zx s_573_55 -> bv
        let s_573_56: Bits = Bits::new(s_573_55 as u128, 1u16);
        // C s_573_57: const #0u : u8
        let s_573_57: bool = false;
        // C s_573_58: cast zx s_573_57 -> bv
        let s_573_58: Bits = Bits::new(s_573_57 as u128, 1u16);
        // D s_573_59: cmp-ne s_573_56 s_573_58
        let s_573_59: bool = ((s_573_56) != (s_573_58));
        // N s_573_60: branch s_573_59 b578 b574
        if s_573_59 {
            return block_578(state, tracer, fn_state);
        } else {
            return block_574(state, tracer, fn_state);
        };
    }
    fn block_574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_574_0: const #9s : i
        let s_574_0: i128 = 9;
        // D s_574_1: read-var u#33667:u32
        let s_574_1: u32 = fn_state.u_33667;
        // D s_574_2: cast zx s_574_1 -> bv
        let s_574_2: Bits = Bits::new(s_574_1 as u128, 32u16);
        // C s_574_3: const #1u : u64
        let s_574_3: u64 = 1;
        // D s_574_4: bit-extract s_574_2 s_574_0 s_574_3
        let s_574_4: Bits = (Bits::new(
            ((s_574_2) >> (s_574_0)).value(),
            u16::try_from(s_574_3).unwrap(),
        ));
        // D s_574_5: cast reint s_574_4 -> u8
        let s_574_5: bool = ((s_574_4.value()) != 0);
        // C s_574_6: const #0s : i
        let s_574_6: i128 = 0;
        // C s_574_7: const #0u : u64
        let s_574_7: u64 = 0;
        // D s_574_8: cast zx s_574_5 -> u64
        let s_574_8: u64 = (s_574_5 as u64);
        // C s_574_9: const #1u : u64
        let s_574_9: u64 = 1;
        // D s_574_10: and s_574_8 s_574_9
        let s_574_10: u64 = ((s_574_8) & (s_574_9));
        // D s_574_11: cmp-eq s_574_10 s_574_9
        let s_574_11: bool = ((s_574_10) == (s_574_9));
        // D s_574_12: lsl s_574_8 s_574_6
        let s_574_12: u64 = s_574_8 << s_574_6;
        // D s_574_13: or s_574_7 s_574_12
        let s_574_13: u64 = ((s_574_7) | (s_574_12));
        // D s_574_14: cmpl s_574_12
        let s_574_14: u64 = !s_574_12;
        // D s_574_15: and s_574_7 s_574_14
        let s_574_15: u64 = ((s_574_7) & (s_574_14));
        // D s_574_16: select s_574_11 s_574_13 s_574_15
        let s_574_16: u64 = if s_574_11 { s_574_13 } else { s_574_15 };
        // D s_574_17: cast trunc s_574_16 -> u8
        let s_574_17: bool = ((s_574_16) != 0);
        // D s_574_18: cast zx s_574_17 -> bv
        let s_574_18: Bits = Bits::new(s_574_17 as u128, 1u16);
        // C s_574_19: const #0u : u8
        let s_574_19: bool = false;
        // C s_574_20: cast zx s_574_19 -> bv
        let s_574_20: Bits = Bits::new(s_574_19 as u128, 1u16);
        // D s_574_21: cmp-ne s_574_18 s_574_20
        let s_574_21: bool = ((s_574_18) != (s_574_20));
        // D s_574_22: write-var gs#410377 <= s_574_21
        fn_state.gs_410377 = s_574_21;
        // N s_574_23: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_575_0: read-var gs#410377:u8
        let s_575_0: bool = fn_state.gs_410377;
        // N s_575_1: branch s_575_0 b577 b576
        if s_575_0 {
            return block_577(state, tracer, fn_state);
        } else {
            return block_576(state, tracer, fn_state);
        };
    }
    fn block_576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_576_0: read-var u#33668:u8
        let s_576_0: u8 = fn_state.u_33668;
        // D s_576_1: read-var u#33669:u8
        let s_576_1: u8 = fn_state.u_33669;
        // D s_576_2: read-var u#33670:u8
        let s_576_2: u8 = fn_state.u_33670;
        // D s_576_3: read-var u#33671:u8
        let s_576_3: u8 = fn_state.u_33671;
        // D s_576_4: read-var u#33672:u8
        let s_576_4: u8 = fn_state.u_33672;
        // D s_576_5: call decode_aarch32_instrs_SXTAH_A1enc_A_txt(s_576_0, s_576_1, s_576_2, s_576_3, s_576_4)
        let s_576_5: () = decode_aarch32_instrs_SXTAH_A1enc_A_txt(
            state,
            tracer,
            s_576_0,
            s_576_1,
            s_576_2,
            s_576_3,
            s_576_4,
        );
        // N s_576_6: return
        return;
    }
    fn block_577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_577_0: panic
        panic!("{:?}", ());
        // N s_577_1: return
        return;
    }
    fn block_578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_578_0: const #1u : u8
        let s_578_0: bool = true;
        // D s_578_1: write-var gs#410377 <= s_578_0
        fn_state.gs_410377 = s_578_0;
        // N s_578_2: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_579_0: read-var merge#var.1:struct
        let s_579_0: u32 = fn_state.merge_var._1;
        // D s_579_1: write-var u#33674 <= s_579_0
        fn_state.u_33674 = s_579_0;
        // C s_579_2: const #16s : i
        let s_579_2: i128 = 16;
        // D s_579_3: read-var u#33674:u32
        let s_579_3: u32 = fn_state.u_33674;
        // D s_579_4: cast zx s_579_3 -> bv
        let s_579_4: Bits = Bits::new(s_579_3 as u128, 32u16);
        // C s_579_5: const #1s : i64
        let s_579_5: i64 = 1;
        // C s_579_6: cast zx s_579_5 -> i
        let s_579_6: i128 = (i128::try_from(s_579_5).unwrap());
        // C s_579_7: const #11s : i
        let s_579_7: i128 = 11;
        // C s_579_8: add s_579_7 s_579_6
        let s_579_8: i128 = (s_579_7 + s_579_6);
        // D s_579_9: bit-extract s_579_4 s_579_2 s_579_8
        let s_579_9: Bits = (Bits::new(
            ((s_579_4) >> (s_579_2)).value(),
            u16::try_from(s_579_8).unwrap(),
        ));
        // D s_579_10: cast reint s_579_9 -> u12
        let s_579_10: u16 = (s_579_9.value() as u16);
        // D s_579_11: cast zx s_579_10 -> bv
        let s_579_11: Bits = Bits::new(s_579_10 as u128, 12u16);
        // C s_579_12: const #1679u : u12
        let s_579_12: u16 = 1679;
        // C s_579_13: cast zx s_579_12 -> bv
        let s_579_13: Bits = Bits::new(s_579_12 as u128, 12u16);
        // D s_579_14: cmp-eq s_579_11 s_579_13
        let s_579_14: bool = ((s_579_11) == (s_579_13));
        // N s_579_15: branch s_579_14 b1207 b580
        if s_579_14 {
            return block_1207(state, tracer, fn_state);
        } else {
            return block_580(state, tracer, fn_state);
        };
    }
    fn block_580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_580_0: const #0u : u8
        let s_580_0: bool = false;
        // D s_580_1: write-var gs#410383 <= s_580_0
        fn_state.gs_410383 = s_580_0;
        // N s_580_2: jump b581
        return block_581(state, tracer, fn_state);
    }
    fn block_581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_581_0: read-var gs#410383:u8
        let s_581_0: bool = fn_state.gs_410383;
        // N s_581_1: branch s_581_0 b1203 b582
        if s_581_0 {
            return block_1203(state, tracer, fn_state);
        } else {
            return block_582(state, tracer, fn_state);
        };
    }
    fn block_582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_582_0: const #0u : u8
        let s_582_0: bool = false;
        // D s_582_1: write-var gs#410388 <= s_582_0
        fn_state.gs_410388 = s_582_0;
        // N s_582_2: jump b583
        return block_583(state, tracer, fn_state);
    }
    fn block_583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_583_0: read-var gs#410388:u8
        let s_583_0: bool = fn_state.gs_410388;
        // D s_583_1: not s_583_0
        let s_583_1: bool = !s_583_0;
        // N s_583_2: branch s_583_1 b590 b584
        if s_583_1 {
            return block_590(state, tracer, fn_state);
        } else {
            return block_584(state, tracer, fn_state);
        };
    }
    fn block_584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_584_0: const #3259s : i
        let s_584_0: i128 = 3259;
        // C s_584_1: const #14696u : u32
        let s_584_1: u32 = 14696;
        // N s_584_2: write-reg s_584_1 <= s_584_0
        let s_584_2: () = {
            state.write_register::<i128>(s_584_1 as isize, s_584_0);
            tracer.write_register(s_584_1 as isize, s_584_0);
        };
        // C s_584_3: const #28s : i
        let s_584_3: i128 = 28;
        // C s_584_4: const #4s : i
        let s_584_4: i128 = 4;
        // D s_584_5: read-var u#33674:u32
        let s_584_5: u32 = fn_state.u_33674;
        // D s_584_6: cast zx s_584_5 -> bv
        let s_584_6: Bits = Bits::new(s_584_5 as u128, 32u16);
        // D s_584_7: bit-extract s_584_6 s_584_3 s_584_4
        let s_584_7: Bits = (Bits::new(
            ((s_584_6) >> (s_584_3)).value(),
            u16::try_from(s_584_4).unwrap(),
        ));
        // D s_584_8: cast reint s_584_7 -> u8
        let s_584_8: u8 = (s_584_7.value() as u8);
        // D s_584_9: write-var u#33675 <= s_584_8
        fn_state.u_33675 = s_584_8;
        // C s_584_10: const #12s : i
        let s_584_10: i128 = 12;
        // C s_584_11: const #4s : i
        let s_584_11: i128 = 4;
        // D s_584_12: read-var u#33674:u32
        let s_584_12: u32 = fn_state.u_33674;
        // D s_584_13: cast zx s_584_12 -> bv
        let s_584_13: Bits = Bits::new(s_584_12 as u128, 32u16);
        // D s_584_14: bit-extract s_584_13 s_584_10 s_584_11
        let s_584_14: Bits = (Bits::new(
            ((s_584_13) >> (s_584_10)).value(),
            u16::try_from(s_584_11).unwrap(),
        ));
        // D s_584_15: cast reint s_584_14 -> u8
        let s_584_15: u8 = (s_584_14.value() as u8);
        // D s_584_16: write-var u#33676 <= s_584_15
        fn_state.u_33676 = s_584_15;
        // C s_584_17: const #10s : i
        let s_584_17: i128 = 10;
        // C s_584_18: const #2s : i
        let s_584_18: i128 = 2;
        // D s_584_19: read-var u#33674:u32
        let s_584_19: u32 = fn_state.u_33674;
        // D s_584_20: cast zx s_584_19 -> bv
        let s_584_20: Bits = Bits::new(s_584_19 as u128, 32u16);
        // D s_584_21: bit-extract s_584_20 s_584_17 s_584_18
        let s_584_21: Bits = (Bits::new(
            ((s_584_20) >> (s_584_17)).value(),
            u16::try_from(s_584_18).unwrap(),
        ));
        // D s_584_22: cast reint s_584_21 -> u8
        let s_584_22: u8 = (s_584_21.value() as u8);
        // D s_584_23: write-var u#33677 <= s_584_22
        fn_state.u_33677 = s_584_22;
        // C s_584_24: const #0s : i
        let s_584_24: i128 = 0;
        // C s_584_25: const #4s : i
        let s_584_25: i128 = 4;
        // D s_584_26: read-var u#33674:u32
        let s_584_26: u32 = fn_state.u_33674;
        // D s_584_27: cast zx s_584_26 -> bv
        let s_584_27: Bits = Bits::new(s_584_26 as u128, 32u16);
        // D s_584_28: bit-extract s_584_27 s_584_24 s_584_25
        let s_584_28: Bits = (Bits::new(
            ((s_584_27) >> (s_584_24)).value(),
            u16::try_from(s_584_25).unwrap(),
        ));
        // D s_584_29: cast reint s_584_28 -> u8
        let s_584_29: u8 = (s_584_28.value() as u8);
        // D s_584_30: write-var u#33678 <= s_584_29
        fn_state.u_33678 = s_584_29;
        // C s_584_31: const #8s : i
        let s_584_31: i128 = 8;
        // D s_584_32: read-var u#33674:u32
        let s_584_32: u32 = fn_state.u_33674;
        // D s_584_33: cast zx s_584_32 -> bv
        let s_584_33: Bits = Bits::new(s_584_32 as u128, 32u16);
        // C s_584_34: const #1u : u64
        let s_584_34: u64 = 1;
        // D s_584_35: bit-extract s_584_33 s_584_31 s_584_34
        let s_584_35: Bits = (Bits::new(
            ((s_584_33) >> (s_584_31)).value(),
            u16::try_from(s_584_34).unwrap(),
        ));
        // D s_584_36: cast reint s_584_35 -> u8
        let s_584_36: bool = ((s_584_35.value()) != 0);
        // C s_584_37: const #0s : i
        let s_584_37: i128 = 0;
        // C s_584_38: const #0u : u64
        let s_584_38: u64 = 0;
        // D s_584_39: cast zx s_584_36 -> u64
        let s_584_39: u64 = (s_584_36 as u64);
        // C s_584_40: const #1u : u64
        let s_584_40: u64 = 1;
        // D s_584_41: and s_584_39 s_584_40
        let s_584_41: u64 = ((s_584_39) & (s_584_40));
        // D s_584_42: cmp-eq s_584_41 s_584_40
        let s_584_42: bool = ((s_584_41) == (s_584_40));
        // D s_584_43: lsl s_584_39 s_584_37
        let s_584_43: u64 = s_584_39 << s_584_37;
        // D s_584_44: or s_584_38 s_584_43
        let s_584_44: u64 = ((s_584_38) | (s_584_43));
        // D s_584_45: cmpl s_584_43
        let s_584_45: u64 = !s_584_43;
        // D s_584_46: and s_584_38 s_584_45
        let s_584_46: u64 = ((s_584_38) & (s_584_45));
        // D s_584_47: select s_584_42 s_584_44 s_584_46
        let s_584_47: u64 = if s_584_42 { s_584_44 } else { s_584_46 };
        // D s_584_48: cast trunc s_584_47 -> u8
        let s_584_48: bool = ((s_584_47) != 0);
        // D s_584_49: cast zx s_584_48 -> bv
        let s_584_49: Bits = Bits::new(s_584_48 as u128, 1u16);
        // C s_584_50: const #0u : u8
        let s_584_50: bool = false;
        // C s_584_51: cast zx s_584_50 -> bv
        let s_584_51: Bits = Bits::new(s_584_50 as u128, 1u16);
        // D s_584_52: cmp-ne s_584_49 s_584_51
        let s_584_52: bool = ((s_584_49) != (s_584_51));
        // N s_584_53: branch s_584_52 b589 b585
        if s_584_52 {
            return block_589(state, tracer, fn_state);
        } else {
            return block_585(state, tracer, fn_state);
        };
    }
    fn block_585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_585_0: const #9s : i
        let s_585_0: i128 = 9;
        // D s_585_1: read-var u#33674:u32
        let s_585_1: u32 = fn_state.u_33674;
        // D s_585_2: cast zx s_585_1 -> bv
        let s_585_2: Bits = Bits::new(s_585_1 as u128, 32u16);
        // C s_585_3: const #1u : u64
        let s_585_3: u64 = 1;
        // D s_585_4: bit-extract s_585_2 s_585_0 s_585_3
        let s_585_4: Bits = (Bits::new(
            ((s_585_2) >> (s_585_0)).value(),
            u16::try_from(s_585_3).unwrap(),
        ));
        // D s_585_5: cast reint s_585_4 -> u8
        let s_585_5: bool = ((s_585_4.value()) != 0);
        // C s_585_6: const #0s : i
        let s_585_6: i128 = 0;
        // C s_585_7: const #0u : u64
        let s_585_7: u64 = 0;
        // D s_585_8: cast zx s_585_5 -> u64
        let s_585_8: u64 = (s_585_5 as u64);
        // C s_585_9: const #1u : u64
        let s_585_9: u64 = 1;
        // D s_585_10: and s_585_8 s_585_9
        let s_585_10: u64 = ((s_585_8) & (s_585_9));
        // D s_585_11: cmp-eq s_585_10 s_585_9
        let s_585_11: bool = ((s_585_10) == (s_585_9));
        // D s_585_12: lsl s_585_8 s_585_6
        let s_585_12: u64 = s_585_8 << s_585_6;
        // D s_585_13: or s_585_7 s_585_12
        let s_585_13: u64 = ((s_585_7) | (s_585_12));
        // D s_585_14: cmpl s_585_12
        let s_585_14: u64 = !s_585_12;
        // D s_585_15: and s_585_7 s_585_14
        let s_585_15: u64 = ((s_585_7) & (s_585_14));
        // D s_585_16: select s_585_11 s_585_13 s_585_15
        let s_585_16: u64 = if s_585_11 { s_585_13 } else { s_585_15 };
        // D s_585_17: cast trunc s_585_16 -> u8
        let s_585_17: bool = ((s_585_16) != 0);
        // D s_585_18: cast zx s_585_17 -> bv
        let s_585_18: Bits = Bits::new(s_585_17 as u128, 1u16);
        // C s_585_19: const #0u : u8
        let s_585_19: bool = false;
        // C s_585_20: cast zx s_585_19 -> bv
        let s_585_20: Bits = Bits::new(s_585_19 as u128, 1u16);
        // D s_585_21: cmp-ne s_585_18 s_585_20
        let s_585_21: bool = ((s_585_18) != (s_585_20));
        // D s_585_22: write-var gs#410403 <= s_585_21
        fn_state.gs_410403 = s_585_21;
        // N s_585_23: jump b586
        return block_586(state, tracer, fn_state);
    }
    fn block_586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_586_0: read-var gs#410403:u8
        let s_586_0: bool = fn_state.gs_410403;
        // N s_586_1: branch s_586_0 b588 b587
        if s_586_0 {
            return block_588(state, tracer, fn_state);
        } else {
            return block_587(state, tracer, fn_state);
        };
    }
    fn block_587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_587_0: read-var u#33675:u8
        let s_587_0: u8 = fn_state.u_33675;
        // D s_587_1: read-var u#33676:u8
        let s_587_1: u8 = fn_state.u_33676;
        // D s_587_2: read-var u#33677:u8
        let s_587_2: u8 = fn_state.u_33677;
        // D s_587_3: read-var u#33678:u8
        let s_587_3: u8 = fn_state.u_33678;
        // D s_587_4: call decode_aarch32_instrs_SXTB16_A1enc_A_txt(s_587_0, s_587_1, s_587_2, s_587_3)
        let s_587_4: () = decode_aarch32_instrs_SXTB16_A1enc_A_txt(
            state,
            tracer,
            s_587_0,
            s_587_1,
            s_587_2,
            s_587_3,
        );
        // N s_587_5: return
        return;
    }
    fn block_588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_588_0: panic
        panic!("{:?}", ());
        // N s_588_1: return
        return;
    }
    fn block_589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_589_0: const #1u : u8
        let s_589_0: bool = true;
        // D s_589_1: write-var gs#410403 <= s_589_0
        fn_state.gs_410403 = s_589_0;
        // N s_589_2: jump b586
        return block_586(state, tracer, fn_state);
    }
    fn block_590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_590_0: read-var merge#var.1:struct
        let s_590_0: u32 = fn_state.merge_var._1;
        // D s_590_1: write-var u#33680 <= s_590_0
        fn_state.u_33680 = s_590_0;
        // C s_590_2: const #16s : i
        let s_590_2: i128 = 16;
        // D s_590_3: read-var u#33680:u32
        let s_590_3: u32 = fn_state.u_33680;
        // D s_590_4: cast zx s_590_3 -> bv
        let s_590_4: Bits = Bits::new(s_590_3 as u128, 32u16);
        // C s_590_5: const #1s : i64
        let s_590_5: i64 = 1;
        // C s_590_6: cast zx s_590_5 -> i
        let s_590_6: i128 = (i128::try_from(s_590_5).unwrap());
        // C s_590_7: const #11s : i
        let s_590_7: i128 = 11;
        // C s_590_8: add s_590_7 s_590_6
        let s_590_8: i128 = (s_590_7 + s_590_6);
        // D s_590_9: bit-extract s_590_4 s_590_2 s_590_8
        let s_590_9: Bits = (Bits::new(
            ((s_590_4) >> (s_590_2)).value(),
            u16::try_from(s_590_8).unwrap(),
        ));
        // D s_590_10: cast reint s_590_9 -> u12
        let s_590_10: u16 = (s_590_9.value() as u16);
        // D s_590_11: cast zx s_590_10 -> bv
        let s_590_11: Bits = Bits::new(s_590_10 as u128, 12u16);
        // C s_590_12: const #1711u : u12
        let s_590_12: u16 = 1711;
        // C s_590_13: cast zx s_590_12 -> bv
        let s_590_13: Bits = Bits::new(s_590_12 as u128, 12u16);
        // D s_590_14: cmp-eq s_590_11 s_590_13
        let s_590_14: bool = ((s_590_11) == (s_590_13));
        // N s_590_15: branch s_590_14 b1202 b591
        if s_590_14 {
            return block_1202(state, tracer, fn_state);
        } else {
            return block_591(state, tracer, fn_state);
        };
    }
    fn block_591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_591_0: const #0u : u8
        let s_591_0: bool = false;
        // D s_591_1: write-var gs#410409 <= s_591_0
        fn_state.gs_410409 = s_591_0;
        // N s_591_2: jump b592
        return block_592(state, tracer, fn_state);
    }
    fn block_592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_592_0: read-var gs#410409:u8
        let s_592_0: bool = fn_state.gs_410409;
        // N s_592_1: branch s_592_0 b1198 b593
        if s_592_0 {
            return block_1198(state, tracer, fn_state);
        } else {
            return block_593(state, tracer, fn_state);
        };
    }
    fn block_593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_593_0: const #0u : u8
        let s_593_0: bool = false;
        // D s_593_1: write-var gs#410414 <= s_593_0
        fn_state.gs_410414 = s_593_0;
        // N s_593_2: jump b594
        return block_594(state, tracer, fn_state);
    }
    fn block_594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_594_0: read-var gs#410414:u8
        let s_594_0: bool = fn_state.gs_410414;
        // D s_594_1: not s_594_0
        let s_594_1: bool = !s_594_0;
        // N s_594_2: branch s_594_1 b601 b595
        if s_594_1 {
            return block_601(state, tracer, fn_state);
        } else {
            return block_595(state, tracer, fn_state);
        };
    }
    fn block_595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_595_0: const #3261s : i
        let s_595_0: i128 = 3261;
        // C s_595_1: const #14696u : u32
        let s_595_1: u32 = 14696;
        // N s_595_2: write-reg s_595_1 <= s_595_0
        let s_595_2: () = {
            state.write_register::<i128>(s_595_1 as isize, s_595_0);
            tracer.write_register(s_595_1 as isize, s_595_0);
        };
        // C s_595_3: const #28s : i
        let s_595_3: i128 = 28;
        // C s_595_4: const #4s : i
        let s_595_4: i128 = 4;
        // D s_595_5: read-var u#33680:u32
        let s_595_5: u32 = fn_state.u_33680;
        // D s_595_6: cast zx s_595_5 -> bv
        let s_595_6: Bits = Bits::new(s_595_5 as u128, 32u16);
        // D s_595_7: bit-extract s_595_6 s_595_3 s_595_4
        let s_595_7: Bits = (Bits::new(
            ((s_595_6) >> (s_595_3)).value(),
            u16::try_from(s_595_4).unwrap(),
        ));
        // D s_595_8: cast reint s_595_7 -> u8
        let s_595_8: u8 = (s_595_7.value() as u8);
        // D s_595_9: write-var u#33681 <= s_595_8
        fn_state.u_33681 = s_595_8;
        // C s_595_10: const #12s : i
        let s_595_10: i128 = 12;
        // C s_595_11: const #4s : i
        let s_595_11: i128 = 4;
        // D s_595_12: read-var u#33680:u32
        let s_595_12: u32 = fn_state.u_33680;
        // D s_595_13: cast zx s_595_12 -> bv
        let s_595_13: Bits = Bits::new(s_595_12 as u128, 32u16);
        // D s_595_14: bit-extract s_595_13 s_595_10 s_595_11
        let s_595_14: Bits = (Bits::new(
            ((s_595_13) >> (s_595_10)).value(),
            u16::try_from(s_595_11).unwrap(),
        ));
        // D s_595_15: cast reint s_595_14 -> u8
        let s_595_15: u8 = (s_595_14.value() as u8);
        // D s_595_16: write-var u#33682 <= s_595_15
        fn_state.u_33682 = s_595_15;
        // C s_595_17: const #10s : i
        let s_595_17: i128 = 10;
        // C s_595_18: const #2s : i
        let s_595_18: i128 = 2;
        // D s_595_19: read-var u#33680:u32
        let s_595_19: u32 = fn_state.u_33680;
        // D s_595_20: cast zx s_595_19 -> bv
        let s_595_20: Bits = Bits::new(s_595_19 as u128, 32u16);
        // D s_595_21: bit-extract s_595_20 s_595_17 s_595_18
        let s_595_21: Bits = (Bits::new(
            ((s_595_20) >> (s_595_17)).value(),
            u16::try_from(s_595_18).unwrap(),
        ));
        // D s_595_22: cast reint s_595_21 -> u8
        let s_595_22: u8 = (s_595_21.value() as u8);
        // D s_595_23: write-var u#33683 <= s_595_22
        fn_state.u_33683 = s_595_22;
        // C s_595_24: const #0s : i
        let s_595_24: i128 = 0;
        // C s_595_25: const #4s : i
        let s_595_25: i128 = 4;
        // D s_595_26: read-var u#33680:u32
        let s_595_26: u32 = fn_state.u_33680;
        // D s_595_27: cast zx s_595_26 -> bv
        let s_595_27: Bits = Bits::new(s_595_26 as u128, 32u16);
        // D s_595_28: bit-extract s_595_27 s_595_24 s_595_25
        let s_595_28: Bits = (Bits::new(
            ((s_595_27) >> (s_595_24)).value(),
            u16::try_from(s_595_25).unwrap(),
        ));
        // D s_595_29: cast reint s_595_28 -> u8
        let s_595_29: u8 = (s_595_28.value() as u8);
        // D s_595_30: write-var u#33684 <= s_595_29
        fn_state.u_33684 = s_595_29;
        // C s_595_31: const #8s : i
        let s_595_31: i128 = 8;
        // D s_595_32: read-var u#33680:u32
        let s_595_32: u32 = fn_state.u_33680;
        // D s_595_33: cast zx s_595_32 -> bv
        let s_595_33: Bits = Bits::new(s_595_32 as u128, 32u16);
        // C s_595_34: const #1u : u64
        let s_595_34: u64 = 1;
        // D s_595_35: bit-extract s_595_33 s_595_31 s_595_34
        let s_595_35: Bits = (Bits::new(
            ((s_595_33) >> (s_595_31)).value(),
            u16::try_from(s_595_34).unwrap(),
        ));
        // D s_595_36: cast reint s_595_35 -> u8
        let s_595_36: bool = ((s_595_35.value()) != 0);
        // C s_595_37: const #0s : i
        let s_595_37: i128 = 0;
        // C s_595_38: const #0u : u64
        let s_595_38: u64 = 0;
        // D s_595_39: cast zx s_595_36 -> u64
        let s_595_39: u64 = (s_595_36 as u64);
        // C s_595_40: const #1u : u64
        let s_595_40: u64 = 1;
        // D s_595_41: and s_595_39 s_595_40
        let s_595_41: u64 = ((s_595_39) & (s_595_40));
        // D s_595_42: cmp-eq s_595_41 s_595_40
        let s_595_42: bool = ((s_595_41) == (s_595_40));
        // D s_595_43: lsl s_595_39 s_595_37
        let s_595_43: u64 = s_595_39 << s_595_37;
        // D s_595_44: or s_595_38 s_595_43
        let s_595_44: u64 = ((s_595_38) | (s_595_43));
        // D s_595_45: cmpl s_595_43
        let s_595_45: u64 = !s_595_43;
        // D s_595_46: and s_595_38 s_595_45
        let s_595_46: u64 = ((s_595_38) & (s_595_45));
        // D s_595_47: select s_595_42 s_595_44 s_595_46
        let s_595_47: u64 = if s_595_42 { s_595_44 } else { s_595_46 };
        // D s_595_48: cast trunc s_595_47 -> u8
        let s_595_48: bool = ((s_595_47) != 0);
        // D s_595_49: cast zx s_595_48 -> bv
        let s_595_49: Bits = Bits::new(s_595_48 as u128, 1u16);
        // C s_595_50: const #0u : u8
        let s_595_50: bool = false;
        // C s_595_51: cast zx s_595_50 -> bv
        let s_595_51: Bits = Bits::new(s_595_50 as u128, 1u16);
        // D s_595_52: cmp-ne s_595_49 s_595_51
        let s_595_52: bool = ((s_595_49) != (s_595_51));
        // N s_595_53: branch s_595_52 b600 b596
        if s_595_52 {
            return block_600(state, tracer, fn_state);
        } else {
            return block_596(state, tracer, fn_state);
        };
    }
    fn block_596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_596_0: const #9s : i
        let s_596_0: i128 = 9;
        // D s_596_1: read-var u#33680:u32
        let s_596_1: u32 = fn_state.u_33680;
        // D s_596_2: cast zx s_596_1 -> bv
        let s_596_2: Bits = Bits::new(s_596_1 as u128, 32u16);
        // C s_596_3: const #1u : u64
        let s_596_3: u64 = 1;
        // D s_596_4: bit-extract s_596_2 s_596_0 s_596_3
        let s_596_4: Bits = (Bits::new(
            ((s_596_2) >> (s_596_0)).value(),
            u16::try_from(s_596_3).unwrap(),
        ));
        // D s_596_5: cast reint s_596_4 -> u8
        let s_596_5: bool = ((s_596_4.value()) != 0);
        // C s_596_6: const #0s : i
        let s_596_6: i128 = 0;
        // C s_596_7: const #0u : u64
        let s_596_7: u64 = 0;
        // D s_596_8: cast zx s_596_5 -> u64
        let s_596_8: u64 = (s_596_5 as u64);
        // C s_596_9: const #1u : u64
        let s_596_9: u64 = 1;
        // D s_596_10: and s_596_8 s_596_9
        let s_596_10: u64 = ((s_596_8) & (s_596_9));
        // D s_596_11: cmp-eq s_596_10 s_596_9
        let s_596_11: bool = ((s_596_10) == (s_596_9));
        // D s_596_12: lsl s_596_8 s_596_6
        let s_596_12: u64 = s_596_8 << s_596_6;
        // D s_596_13: or s_596_7 s_596_12
        let s_596_13: u64 = ((s_596_7) | (s_596_12));
        // D s_596_14: cmpl s_596_12
        let s_596_14: u64 = !s_596_12;
        // D s_596_15: and s_596_7 s_596_14
        let s_596_15: u64 = ((s_596_7) & (s_596_14));
        // D s_596_16: select s_596_11 s_596_13 s_596_15
        let s_596_16: u64 = if s_596_11 { s_596_13 } else { s_596_15 };
        // D s_596_17: cast trunc s_596_16 -> u8
        let s_596_17: bool = ((s_596_16) != 0);
        // D s_596_18: cast zx s_596_17 -> bv
        let s_596_18: Bits = Bits::new(s_596_17 as u128, 1u16);
        // C s_596_19: const #0u : u8
        let s_596_19: bool = false;
        // C s_596_20: cast zx s_596_19 -> bv
        let s_596_20: Bits = Bits::new(s_596_19 as u128, 1u16);
        // D s_596_21: cmp-ne s_596_18 s_596_20
        let s_596_21: bool = ((s_596_18) != (s_596_20));
        // D s_596_22: write-var gs#410429 <= s_596_21
        fn_state.gs_410429 = s_596_21;
        // N s_596_23: jump b597
        return block_597(state, tracer, fn_state);
    }
    fn block_597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_597_0: read-var gs#410429:u8
        let s_597_0: bool = fn_state.gs_410429;
        // N s_597_1: branch s_597_0 b599 b598
        if s_597_0 {
            return block_599(state, tracer, fn_state);
        } else {
            return block_598(state, tracer, fn_state);
        };
    }
    fn block_598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_598_0: read-var u#33681:u8
        let s_598_0: u8 = fn_state.u_33681;
        // D s_598_1: read-var u#33682:u8
        let s_598_1: u8 = fn_state.u_33682;
        // D s_598_2: read-var u#33683:u8
        let s_598_2: u8 = fn_state.u_33683;
        // D s_598_3: read-var u#33684:u8
        let s_598_3: u8 = fn_state.u_33684;
        // D s_598_4: call decode_aarch32_instrs_SXTB_A1enc_A_txt(s_598_0, s_598_1, s_598_2, s_598_3)
        let s_598_4: () = decode_aarch32_instrs_SXTB_A1enc_A_txt(
            state,
            tracer,
            s_598_0,
            s_598_1,
            s_598_2,
            s_598_3,
        );
        // N s_598_5: return
        return;
    }
    fn block_599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_599_0: panic
        panic!("{:?}", ());
        // N s_599_1: return
        return;
    }
    fn block_600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_600_0: const #1u : u8
        let s_600_0: bool = true;
        // D s_600_1: write-var gs#410429 <= s_600_0
        fn_state.gs_410429 = s_600_0;
        // N s_600_2: jump b597
        return block_597(state, tracer, fn_state);
    }
    fn block_601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_601_0: read-var merge#var.1:struct
        let s_601_0: u32 = fn_state.merge_var._1;
        // D s_601_1: write-var u#33686 <= s_601_0
        fn_state.u_33686 = s_601_0;
        // C s_601_2: const #16s : i
        let s_601_2: i128 = 16;
        // D s_601_3: read-var u#33686:u32
        let s_601_3: u32 = fn_state.u_33686;
        // D s_601_4: cast zx s_601_3 -> bv
        let s_601_4: Bits = Bits::new(s_601_3 as u128, 32u16);
        // C s_601_5: const #1s : i64
        let s_601_5: i64 = 1;
        // C s_601_6: cast zx s_601_5 -> i
        let s_601_6: i128 = (i128::try_from(s_601_5).unwrap());
        // C s_601_7: const #11s : i
        let s_601_7: i128 = 11;
        // C s_601_8: add s_601_7 s_601_6
        let s_601_8: i128 = (s_601_7 + s_601_6);
        // D s_601_9: bit-extract s_601_4 s_601_2 s_601_8
        let s_601_9: Bits = (Bits::new(
            ((s_601_4) >> (s_601_2)).value(),
            u16::try_from(s_601_8).unwrap(),
        ));
        // D s_601_10: cast reint s_601_9 -> u12
        let s_601_10: u16 = (s_601_9.value() as u16);
        // D s_601_11: cast zx s_601_10 -> bv
        let s_601_11: Bits = Bits::new(s_601_10 as u128, 12u16);
        // C s_601_12: const #1727u : u12
        let s_601_12: u16 = 1727;
        // C s_601_13: cast zx s_601_12 -> bv
        let s_601_13: Bits = Bits::new(s_601_12 as u128, 12u16);
        // D s_601_14: cmp-eq s_601_11 s_601_13
        let s_601_14: bool = ((s_601_11) == (s_601_13));
        // N s_601_15: branch s_601_14 b1197 b602
        if s_601_14 {
            return block_1197(state, tracer, fn_state);
        } else {
            return block_602(state, tracer, fn_state);
        };
    }
    fn block_602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_602_0: const #0u : u8
        let s_602_0: bool = false;
        // D s_602_1: write-var gs#410435 <= s_602_0
        fn_state.gs_410435 = s_602_0;
        // N s_602_2: jump b603
        return block_603(state, tracer, fn_state);
    }
    fn block_603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_603_0: read-var gs#410435:u8
        let s_603_0: bool = fn_state.gs_410435;
        // N s_603_1: branch s_603_0 b1193 b604
        if s_603_0 {
            return block_1193(state, tracer, fn_state);
        } else {
            return block_604(state, tracer, fn_state);
        };
    }
    fn block_604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_604_0: const #0u : u8
        let s_604_0: bool = false;
        // D s_604_1: write-var gs#410440 <= s_604_0
        fn_state.gs_410440 = s_604_0;
        // N s_604_2: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_605_0: read-var gs#410440:u8
        let s_605_0: bool = fn_state.gs_410440;
        // D s_605_1: not s_605_0
        let s_605_1: bool = !s_605_0;
        // N s_605_2: branch s_605_1 b612 b606
        if s_605_1 {
            return block_612(state, tracer, fn_state);
        } else {
            return block_606(state, tracer, fn_state);
        };
    }
    fn block_606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_606_0: const #3264s : i
        let s_606_0: i128 = 3264;
        // C s_606_1: const #14696u : u32
        let s_606_1: u32 = 14696;
        // N s_606_2: write-reg s_606_1 <= s_606_0
        let s_606_2: () = {
            state.write_register::<i128>(s_606_1 as isize, s_606_0);
            tracer.write_register(s_606_1 as isize, s_606_0);
        };
        // C s_606_3: const #28s : i
        let s_606_3: i128 = 28;
        // C s_606_4: const #4s : i
        let s_606_4: i128 = 4;
        // D s_606_5: read-var u#33686:u32
        let s_606_5: u32 = fn_state.u_33686;
        // D s_606_6: cast zx s_606_5 -> bv
        let s_606_6: Bits = Bits::new(s_606_5 as u128, 32u16);
        // D s_606_7: bit-extract s_606_6 s_606_3 s_606_4
        let s_606_7: Bits = (Bits::new(
            ((s_606_6) >> (s_606_3)).value(),
            u16::try_from(s_606_4).unwrap(),
        ));
        // D s_606_8: cast reint s_606_7 -> u8
        let s_606_8: u8 = (s_606_7.value() as u8);
        // D s_606_9: write-var u#33687 <= s_606_8
        fn_state.u_33687 = s_606_8;
        // C s_606_10: const #12s : i
        let s_606_10: i128 = 12;
        // C s_606_11: const #4s : i
        let s_606_11: i128 = 4;
        // D s_606_12: read-var u#33686:u32
        let s_606_12: u32 = fn_state.u_33686;
        // D s_606_13: cast zx s_606_12 -> bv
        let s_606_13: Bits = Bits::new(s_606_12 as u128, 32u16);
        // D s_606_14: bit-extract s_606_13 s_606_10 s_606_11
        let s_606_14: Bits = (Bits::new(
            ((s_606_13) >> (s_606_10)).value(),
            u16::try_from(s_606_11).unwrap(),
        ));
        // D s_606_15: cast reint s_606_14 -> u8
        let s_606_15: u8 = (s_606_14.value() as u8);
        // D s_606_16: write-var u#33688 <= s_606_15
        fn_state.u_33688 = s_606_15;
        // C s_606_17: const #10s : i
        let s_606_17: i128 = 10;
        // C s_606_18: const #2s : i
        let s_606_18: i128 = 2;
        // D s_606_19: read-var u#33686:u32
        let s_606_19: u32 = fn_state.u_33686;
        // D s_606_20: cast zx s_606_19 -> bv
        let s_606_20: Bits = Bits::new(s_606_19 as u128, 32u16);
        // D s_606_21: bit-extract s_606_20 s_606_17 s_606_18
        let s_606_21: Bits = (Bits::new(
            ((s_606_20) >> (s_606_17)).value(),
            u16::try_from(s_606_18).unwrap(),
        ));
        // D s_606_22: cast reint s_606_21 -> u8
        let s_606_22: u8 = (s_606_21.value() as u8);
        // D s_606_23: write-var u#33689 <= s_606_22
        fn_state.u_33689 = s_606_22;
        // C s_606_24: const #0s : i
        let s_606_24: i128 = 0;
        // C s_606_25: const #4s : i
        let s_606_25: i128 = 4;
        // D s_606_26: read-var u#33686:u32
        let s_606_26: u32 = fn_state.u_33686;
        // D s_606_27: cast zx s_606_26 -> bv
        let s_606_27: Bits = Bits::new(s_606_26 as u128, 32u16);
        // D s_606_28: bit-extract s_606_27 s_606_24 s_606_25
        let s_606_28: Bits = (Bits::new(
            ((s_606_27) >> (s_606_24)).value(),
            u16::try_from(s_606_25).unwrap(),
        ));
        // D s_606_29: cast reint s_606_28 -> u8
        let s_606_29: u8 = (s_606_28.value() as u8);
        // D s_606_30: write-var u#33690 <= s_606_29
        fn_state.u_33690 = s_606_29;
        // C s_606_31: const #8s : i
        let s_606_31: i128 = 8;
        // D s_606_32: read-var u#33686:u32
        let s_606_32: u32 = fn_state.u_33686;
        // D s_606_33: cast zx s_606_32 -> bv
        let s_606_33: Bits = Bits::new(s_606_32 as u128, 32u16);
        // C s_606_34: const #1u : u64
        let s_606_34: u64 = 1;
        // D s_606_35: bit-extract s_606_33 s_606_31 s_606_34
        let s_606_35: Bits = (Bits::new(
            ((s_606_33) >> (s_606_31)).value(),
            u16::try_from(s_606_34).unwrap(),
        ));
        // D s_606_36: cast reint s_606_35 -> u8
        let s_606_36: bool = ((s_606_35.value()) != 0);
        // C s_606_37: const #0s : i
        let s_606_37: i128 = 0;
        // C s_606_38: const #0u : u64
        let s_606_38: u64 = 0;
        // D s_606_39: cast zx s_606_36 -> u64
        let s_606_39: u64 = (s_606_36 as u64);
        // C s_606_40: const #1u : u64
        let s_606_40: u64 = 1;
        // D s_606_41: and s_606_39 s_606_40
        let s_606_41: u64 = ((s_606_39) & (s_606_40));
        // D s_606_42: cmp-eq s_606_41 s_606_40
        let s_606_42: bool = ((s_606_41) == (s_606_40));
        // D s_606_43: lsl s_606_39 s_606_37
        let s_606_43: u64 = s_606_39 << s_606_37;
        // D s_606_44: or s_606_38 s_606_43
        let s_606_44: u64 = ((s_606_38) | (s_606_43));
        // D s_606_45: cmpl s_606_43
        let s_606_45: u64 = !s_606_43;
        // D s_606_46: and s_606_38 s_606_45
        let s_606_46: u64 = ((s_606_38) & (s_606_45));
        // D s_606_47: select s_606_42 s_606_44 s_606_46
        let s_606_47: u64 = if s_606_42 { s_606_44 } else { s_606_46 };
        // D s_606_48: cast trunc s_606_47 -> u8
        let s_606_48: bool = ((s_606_47) != 0);
        // D s_606_49: cast zx s_606_48 -> bv
        let s_606_49: Bits = Bits::new(s_606_48 as u128, 1u16);
        // C s_606_50: const #0u : u8
        let s_606_50: bool = false;
        // C s_606_51: cast zx s_606_50 -> bv
        let s_606_51: Bits = Bits::new(s_606_50 as u128, 1u16);
        // D s_606_52: cmp-ne s_606_49 s_606_51
        let s_606_52: bool = ((s_606_49) != (s_606_51));
        // N s_606_53: branch s_606_52 b611 b607
        if s_606_52 {
            return block_611(state, tracer, fn_state);
        } else {
            return block_607(state, tracer, fn_state);
        };
    }
    fn block_607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_607_0: const #9s : i
        let s_607_0: i128 = 9;
        // D s_607_1: read-var u#33686:u32
        let s_607_1: u32 = fn_state.u_33686;
        // D s_607_2: cast zx s_607_1 -> bv
        let s_607_2: Bits = Bits::new(s_607_1 as u128, 32u16);
        // C s_607_3: const #1u : u64
        let s_607_3: u64 = 1;
        // D s_607_4: bit-extract s_607_2 s_607_0 s_607_3
        let s_607_4: Bits = (Bits::new(
            ((s_607_2) >> (s_607_0)).value(),
            u16::try_from(s_607_3).unwrap(),
        ));
        // D s_607_5: cast reint s_607_4 -> u8
        let s_607_5: bool = ((s_607_4.value()) != 0);
        // C s_607_6: const #0s : i
        let s_607_6: i128 = 0;
        // C s_607_7: const #0u : u64
        let s_607_7: u64 = 0;
        // D s_607_8: cast zx s_607_5 -> u64
        let s_607_8: u64 = (s_607_5 as u64);
        // C s_607_9: const #1u : u64
        let s_607_9: u64 = 1;
        // D s_607_10: and s_607_8 s_607_9
        let s_607_10: u64 = ((s_607_8) & (s_607_9));
        // D s_607_11: cmp-eq s_607_10 s_607_9
        let s_607_11: bool = ((s_607_10) == (s_607_9));
        // D s_607_12: lsl s_607_8 s_607_6
        let s_607_12: u64 = s_607_8 << s_607_6;
        // D s_607_13: or s_607_7 s_607_12
        let s_607_13: u64 = ((s_607_7) | (s_607_12));
        // D s_607_14: cmpl s_607_12
        let s_607_14: u64 = !s_607_12;
        // D s_607_15: and s_607_7 s_607_14
        let s_607_15: u64 = ((s_607_7) & (s_607_14));
        // D s_607_16: select s_607_11 s_607_13 s_607_15
        let s_607_16: u64 = if s_607_11 { s_607_13 } else { s_607_15 };
        // D s_607_17: cast trunc s_607_16 -> u8
        let s_607_17: bool = ((s_607_16) != 0);
        // D s_607_18: cast zx s_607_17 -> bv
        let s_607_18: Bits = Bits::new(s_607_17 as u128, 1u16);
        // C s_607_19: const #0u : u8
        let s_607_19: bool = false;
        // C s_607_20: cast zx s_607_19 -> bv
        let s_607_20: Bits = Bits::new(s_607_19 as u128, 1u16);
        // D s_607_21: cmp-ne s_607_18 s_607_20
        let s_607_21: bool = ((s_607_18) != (s_607_20));
        // D s_607_22: write-var gs#410455 <= s_607_21
        fn_state.gs_410455 = s_607_21;
        // N s_607_23: jump b608
        return block_608(state, tracer, fn_state);
    }
    fn block_608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_608_0: read-var gs#410455:u8
        let s_608_0: bool = fn_state.gs_410455;
        // N s_608_1: branch s_608_0 b610 b609
        if s_608_0 {
            return block_610(state, tracer, fn_state);
        } else {
            return block_609(state, tracer, fn_state);
        };
    }
    fn block_609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_609_0: read-var u#33687:u8
        let s_609_0: u8 = fn_state.u_33687;
        // D s_609_1: read-var u#33688:u8
        let s_609_1: u8 = fn_state.u_33688;
        // D s_609_2: read-var u#33689:u8
        let s_609_2: u8 = fn_state.u_33689;
        // D s_609_3: read-var u#33690:u8
        let s_609_3: u8 = fn_state.u_33690;
        // D s_609_4: call decode_aarch32_instrs_SXTH_A1enc_A_txt(s_609_0, s_609_1, s_609_2, s_609_3)
        let s_609_4: () = decode_aarch32_instrs_SXTH_A1enc_A_txt(
            state,
            tracer,
            s_609_0,
            s_609_1,
            s_609_2,
            s_609_3,
        );
        // N s_609_5: return
        return;
    }
    fn block_610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_610_0: panic
        panic!("{:?}", ());
        // N s_610_1: return
        return;
    }
    fn block_611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_611_0: const #1u : u8
        let s_611_0: bool = true;
        // D s_611_1: write-var gs#410455 <= s_611_0
        fn_state.gs_410455 = s_611_0;
        // N s_611_2: jump b608
        return block_608(state, tracer, fn_state);
    }
    fn block_612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_612_0: read-var merge#var.1:struct
        let s_612_0: u32 = fn_state.merge_var._1;
        // D s_612_1: write-var u#33692 <= s_612_0
        fn_state.u_33692 = s_612_0;
        // C s_612_2: const #20s : i
        let s_612_2: i128 = 20;
        // D s_612_3: read-var u#33692:u32
        let s_612_3: u32 = fn_state.u_33692;
        // D s_612_4: cast zx s_612_3 -> bv
        let s_612_4: Bits = Bits::new(s_612_3 as u128, 32u16);
        // C s_612_5: const #1s : i64
        let s_612_5: i64 = 1;
        // C s_612_6: cast zx s_612_5 -> i
        let s_612_6: i128 = (i128::try_from(s_612_5).unwrap());
        // C s_612_7: const #7s : i
        let s_612_7: i128 = 7;
        // C s_612_8: add s_612_7 s_612_6
        let s_612_8: i128 = (s_612_7 + s_612_6);
        // D s_612_9: bit-extract s_612_4 s_612_2 s_612_8
        let s_612_9: Bits = (Bits::new(
            ((s_612_4) >> (s_612_2)).value(),
            u16::try_from(s_612_8).unwrap(),
        ));
        // D s_612_10: cast reint s_612_9 -> u8
        let s_612_10: u8 = (s_612_9.value() as u8);
        // D s_612_11: cast zx s_612_10 -> bv
        let s_612_11: Bits = Bits::new(s_612_10 as u128, 8u16);
        // C s_612_12: const #101u : u8
        let s_612_12: u8 = 101;
        // C s_612_13: cast zx s_612_12 -> bv
        let s_612_13: Bits = Bits::new(s_612_12 as u128, 8u16);
        // D s_612_14: cmp-eq s_612_11 s_612_13
        let s_612_14: bool = ((s_612_11) == (s_612_13));
        // N s_612_15: branch s_612_14 b1192 b613
        if s_612_14 {
            return block_1192(state, tracer, fn_state);
        } else {
            return block_613(state, tracer, fn_state);
        };
    }
    fn block_613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_613_0: const #0u : u8
        let s_613_0: bool = false;
        // D s_613_1: write-var gs#410461 <= s_613_0
        fn_state.gs_410461 = s_613_0;
        // N s_613_2: jump b614
        return block_614(state, tracer, fn_state);
    }
    fn block_614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_614_0: read-var gs#410461:u8
        let s_614_0: bool = fn_state.gs_410461;
        // N s_614_1: branch s_614_0 b1188 b615
        if s_614_0 {
            return block_1188(state, tracer, fn_state);
        } else {
            return block_615(state, tracer, fn_state);
        };
    }
    fn block_615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_615_0: const #0u : u8
        let s_615_0: bool = false;
        // D s_615_1: write-var gs#410466 <= s_615_0
        fn_state.gs_410466 = s_615_0;
        // N s_615_2: jump b616
        return block_616(state, tracer, fn_state);
    }
    fn block_616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_616_0: read-var gs#410466:u8
        let s_616_0: bool = fn_state.gs_410466;
        // D s_616_1: not s_616_0
        let s_616_1: bool = !s_616_0;
        // N s_616_2: branch s_616_1 b629 b617
        if s_616_1 {
            return block_629(state, tracer, fn_state);
        } else {
            return block_617(state, tracer, fn_state);
        };
    }
    fn block_617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_617_0: const #3279s : i
        let s_617_0: i128 = 3279;
        // C s_617_1: const #14696u : u32
        let s_617_1: u32 = 14696;
        // N s_617_2: write-reg s_617_1 <= s_617_0
        let s_617_2: () = {
            state.write_register::<i128>(s_617_1 as isize, s_617_0);
            tracer.write_register(s_617_1 as isize, s_617_0);
        };
        // C s_617_3: const #28s : i
        let s_617_3: i128 = 28;
        // C s_617_4: const #4s : i
        let s_617_4: i128 = 4;
        // D s_617_5: read-var u#33692:u32
        let s_617_5: u32 = fn_state.u_33692;
        // D s_617_6: cast zx s_617_5 -> bv
        let s_617_6: Bits = Bits::new(s_617_5 as u128, 32u16);
        // D s_617_7: bit-extract s_617_6 s_617_3 s_617_4
        let s_617_7: Bits = (Bits::new(
            ((s_617_6) >> (s_617_3)).value(),
            u16::try_from(s_617_4).unwrap(),
        ));
        // D s_617_8: cast reint s_617_7 -> u8
        let s_617_8: u8 = (s_617_7.value() as u8);
        // D s_617_9: write-var u#33693 <= s_617_8
        fn_state.u_33693 = s_617_8;
        // C s_617_10: const #16s : i
        let s_617_10: i128 = 16;
        // C s_617_11: const #4s : i
        let s_617_11: i128 = 4;
        // D s_617_12: read-var u#33692:u32
        let s_617_12: u32 = fn_state.u_33692;
        // D s_617_13: cast zx s_617_12 -> bv
        let s_617_13: Bits = Bits::new(s_617_12 as u128, 32u16);
        // D s_617_14: bit-extract s_617_13 s_617_10 s_617_11
        let s_617_14: Bits = (Bits::new(
            ((s_617_13) >> (s_617_10)).value(),
            u16::try_from(s_617_11).unwrap(),
        ));
        // D s_617_15: cast reint s_617_14 -> u8
        let s_617_15: u8 = (s_617_14.value() as u8);
        // D s_617_16: write-var u#33694 <= s_617_15
        fn_state.u_33694 = s_617_15;
        // C s_617_17: const #12s : i
        let s_617_17: i128 = 12;
        // C s_617_18: const #4s : i
        let s_617_18: i128 = 4;
        // D s_617_19: read-var u#33692:u32
        let s_617_19: u32 = fn_state.u_33692;
        // D s_617_20: cast zx s_617_19 -> bv
        let s_617_20: Bits = Bits::new(s_617_19 as u128, 32u16);
        // D s_617_21: bit-extract s_617_20 s_617_17 s_617_18
        let s_617_21: Bits = (Bits::new(
            ((s_617_20) >> (s_617_17)).value(),
            u16::try_from(s_617_18).unwrap(),
        ));
        // D s_617_22: cast reint s_617_21 -> u8
        let s_617_22: u8 = (s_617_21.value() as u8);
        // D s_617_23: write-var u#33695 <= s_617_22
        fn_state.u_33695 = s_617_22;
        // C s_617_24: const #0s : i
        let s_617_24: i128 = 0;
        // C s_617_25: const #4s : i
        let s_617_25: i128 = 4;
        // D s_617_26: read-var u#33692:u32
        let s_617_26: u32 = fn_state.u_33692;
        // D s_617_27: cast zx s_617_26 -> bv
        let s_617_27: Bits = Bits::new(s_617_26 as u128, 32u16);
        // D s_617_28: bit-extract s_617_27 s_617_24 s_617_25
        let s_617_28: Bits = (Bits::new(
            ((s_617_27) >> (s_617_24)).value(),
            u16::try_from(s_617_25).unwrap(),
        ));
        // D s_617_29: cast reint s_617_28 -> u8
        let s_617_29: u8 = (s_617_28.value() as u8);
        // D s_617_30: write-var u#33696 <= s_617_29
        fn_state.u_33696 = s_617_29;
        // C s_617_31: const #8s : i
        let s_617_31: i128 = 8;
        // D s_617_32: read-var u#33692:u32
        let s_617_32: u32 = fn_state.u_33692;
        // D s_617_33: cast zx s_617_32 -> bv
        let s_617_33: Bits = Bits::new(s_617_32 as u128, 32u16);
        // C s_617_34: const #1u : u64
        let s_617_34: u64 = 1;
        // D s_617_35: bit-extract s_617_33 s_617_31 s_617_34
        let s_617_35: Bits = (Bits::new(
            ((s_617_33) >> (s_617_31)).value(),
            u16::try_from(s_617_34).unwrap(),
        ));
        // D s_617_36: cast reint s_617_35 -> u8
        let s_617_36: bool = ((s_617_35.value()) != 0);
        // C s_617_37: const #0s : i
        let s_617_37: i128 = 0;
        // C s_617_38: const #0u : u64
        let s_617_38: u64 = 0;
        // D s_617_39: cast zx s_617_36 -> u64
        let s_617_39: u64 = (s_617_36 as u64);
        // C s_617_40: const #1u : u64
        let s_617_40: u64 = 1;
        // D s_617_41: and s_617_39 s_617_40
        let s_617_41: u64 = ((s_617_39) & (s_617_40));
        // D s_617_42: cmp-eq s_617_41 s_617_40
        let s_617_42: bool = ((s_617_41) == (s_617_40));
        // D s_617_43: lsl s_617_39 s_617_37
        let s_617_43: u64 = s_617_39 << s_617_37;
        // D s_617_44: or s_617_38 s_617_43
        let s_617_44: u64 = ((s_617_38) | (s_617_43));
        // D s_617_45: cmpl s_617_43
        let s_617_45: u64 = !s_617_43;
        // D s_617_46: and s_617_38 s_617_45
        let s_617_46: u64 = ((s_617_38) & (s_617_45));
        // D s_617_47: select s_617_42 s_617_44 s_617_46
        let s_617_47: u64 = if s_617_42 { s_617_44 } else { s_617_46 };
        // D s_617_48: cast trunc s_617_47 -> u8
        let s_617_48: bool = ((s_617_47) != 0);
        // D s_617_49: cast zx s_617_48 -> bv
        let s_617_49: Bits = Bits::new(s_617_48 as u128, 1u16);
        // C s_617_50: const #1u : u8
        let s_617_50: bool = true;
        // C s_617_51: cast zx s_617_50 -> bv
        let s_617_51: Bits = Bits::new(s_617_50 as u128, 1u16);
        // D s_617_52: cmp-ne s_617_49 s_617_51
        let s_617_52: bool = ((s_617_49) != (s_617_51));
        // N s_617_53: branch s_617_52 b628 b618
        if s_617_52 {
            return block_628(state, tracer, fn_state);
        } else {
            return block_618(state, tracer, fn_state);
        };
    }
    fn block_618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_618_0: const #9s : i
        let s_618_0: i128 = 9;
        // D s_618_1: read-var u#33692:u32
        let s_618_1: u32 = fn_state.u_33692;
        // D s_618_2: cast zx s_618_1 -> bv
        let s_618_2: Bits = Bits::new(s_618_1 as u128, 32u16);
        // C s_618_3: const #1u : u64
        let s_618_3: u64 = 1;
        // D s_618_4: bit-extract s_618_2 s_618_0 s_618_3
        let s_618_4: Bits = (Bits::new(
            ((s_618_2) >> (s_618_0)).value(),
            u16::try_from(s_618_3).unwrap(),
        ));
        // D s_618_5: cast reint s_618_4 -> u8
        let s_618_5: bool = ((s_618_4.value()) != 0);
        // C s_618_6: const #0s : i
        let s_618_6: i128 = 0;
        // C s_618_7: const #0u : u64
        let s_618_7: u64 = 0;
        // D s_618_8: cast zx s_618_5 -> u64
        let s_618_8: u64 = (s_618_5 as u64);
        // C s_618_9: const #1u : u64
        let s_618_9: u64 = 1;
        // D s_618_10: and s_618_8 s_618_9
        let s_618_10: u64 = ((s_618_8) & (s_618_9));
        // D s_618_11: cmp-eq s_618_10 s_618_9
        let s_618_11: bool = ((s_618_10) == (s_618_9));
        // D s_618_12: lsl s_618_8 s_618_6
        let s_618_12: u64 = s_618_8 << s_618_6;
        // D s_618_13: or s_618_7 s_618_12
        let s_618_13: u64 = ((s_618_7) | (s_618_12));
        // D s_618_14: cmpl s_618_12
        let s_618_14: u64 = !s_618_12;
        // D s_618_15: and s_618_7 s_618_14
        let s_618_15: u64 = ((s_618_7) & (s_618_14));
        // D s_618_16: select s_618_11 s_618_13 s_618_15
        let s_618_16: u64 = if s_618_11 { s_618_13 } else { s_618_15 };
        // D s_618_17: cast trunc s_618_16 -> u8
        let s_618_17: bool = ((s_618_16) != 0);
        // D s_618_18: cast zx s_618_17 -> bv
        let s_618_18: Bits = Bits::new(s_618_17 as u128, 1u16);
        // C s_618_19: const #1u : u8
        let s_618_19: bool = true;
        // C s_618_20: cast zx s_618_19 -> bv
        let s_618_20: Bits = Bits::new(s_618_19 as u128, 1u16);
        // D s_618_21: cmp-ne s_618_18 s_618_20
        let s_618_21: bool = ((s_618_18) != (s_618_20));
        // D s_618_22: write-var gs#410481 <= s_618_21
        fn_state.gs_410481 = s_618_21;
        // N s_618_23: jump b619
        return block_619(state, tracer, fn_state);
    }
    fn block_619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_619_0: read-var gs#410481:u8
        let s_619_0: bool = fn_state.gs_410481;
        // N s_619_1: branch s_619_0 b627 b620
        if s_619_0 {
            return block_627(state, tracer, fn_state);
        } else {
            return block_620(state, tracer, fn_state);
        };
    }
    fn block_620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_620_0: const #10s : i
        let s_620_0: i128 = 10;
        // D s_620_1: read-var u#33692:u32
        let s_620_1: u32 = fn_state.u_33692;
        // D s_620_2: cast zx s_620_1 -> bv
        let s_620_2: Bits = Bits::new(s_620_1 as u128, 32u16);
        // C s_620_3: const #1u : u64
        let s_620_3: u64 = 1;
        // D s_620_4: bit-extract s_620_2 s_620_0 s_620_3
        let s_620_4: Bits = (Bits::new(
            ((s_620_2) >> (s_620_0)).value(),
            u16::try_from(s_620_3).unwrap(),
        ));
        // D s_620_5: cast reint s_620_4 -> u8
        let s_620_5: bool = ((s_620_4.value()) != 0);
        // C s_620_6: const #0s : i
        let s_620_6: i128 = 0;
        // C s_620_7: const #0u : u64
        let s_620_7: u64 = 0;
        // D s_620_8: cast zx s_620_5 -> u64
        let s_620_8: u64 = (s_620_5 as u64);
        // C s_620_9: const #1u : u64
        let s_620_9: u64 = 1;
        // D s_620_10: and s_620_8 s_620_9
        let s_620_10: u64 = ((s_620_8) & (s_620_9));
        // D s_620_11: cmp-eq s_620_10 s_620_9
        let s_620_11: bool = ((s_620_10) == (s_620_9));
        // D s_620_12: lsl s_620_8 s_620_6
        let s_620_12: u64 = s_620_8 << s_620_6;
        // D s_620_13: or s_620_7 s_620_12
        let s_620_13: u64 = ((s_620_7) | (s_620_12));
        // D s_620_14: cmpl s_620_12
        let s_620_14: u64 = !s_620_12;
        // D s_620_15: and s_620_7 s_620_14
        let s_620_15: u64 = ((s_620_7) & (s_620_14));
        // D s_620_16: select s_620_11 s_620_13 s_620_15
        let s_620_16: u64 = if s_620_11 { s_620_13 } else { s_620_15 };
        // D s_620_17: cast trunc s_620_16 -> u8
        let s_620_17: bool = ((s_620_16) != 0);
        // D s_620_18: cast zx s_620_17 -> bv
        let s_620_18: Bits = Bits::new(s_620_17 as u128, 1u16);
        // C s_620_19: const #1u : u8
        let s_620_19: bool = true;
        // C s_620_20: cast zx s_620_19 -> bv
        let s_620_20: Bits = Bits::new(s_620_19 as u128, 1u16);
        // D s_620_21: cmp-ne s_620_18 s_620_20
        let s_620_21: bool = ((s_620_18) != (s_620_20));
        // D s_620_22: write-var gs#410484 <= s_620_21
        fn_state.gs_410484 = s_620_21;
        // N s_620_23: jump b621
        return block_621(state, tracer, fn_state);
    }
    fn block_621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_621_0: read-var gs#410484:u8
        let s_621_0: bool = fn_state.gs_410484;
        // N s_621_1: branch s_621_0 b626 b622
        if s_621_0 {
            return block_626(state, tracer, fn_state);
        } else {
            return block_622(state, tracer, fn_state);
        };
    }
    fn block_622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_622_0: const #11s : i
        let s_622_0: i128 = 11;
        // D s_622_1: read-var u#33692:u32
        let s_622_1: u32 = fn_state.u_33692;
        // D s_622_2: cast zx s_622_1 -> bv
        let s_622_2: Bits = Bits::new(s_622_1 as u128, 32u16);
        // C s_622_3: const #1u : u64
        let s_622_3: u64 = 1;
        // D s_622_4: bit-extract s_622_2 s_622_0 s_622_3
        let s_622_4: Bits = (Bits::new(
            ((s_622_2) >> (s_622_0)).value(),
            u16::try_from(s_622_3).unwrap(),
        ));
        // D s_622_5: cast reint s_622_4 -> u8
        let s_622_5: bool = ((s_622_4.value()) != 0);
        // C s_622_6: const #0s : i
        let s_622_6: i128 = 0;
        // C s_622_7: const #0u : u64
        let s_622_7: u64 = 0;
        // D s_622_8: cast zx s_622_5 -> u64
        let s_622_8: u64 = (s_622_5 as u64);
        // C s_622_9: const #1u : u64
        let s_622_9: u64 = 1;
        // D s_622_10: and s_622_8 s_622_9
        let s_622_10: u64 = ((s_622_8) & (s_622_9));
        // D s_622_11: cmp-eq s_622_10 s_622_9
        let s_622_11: bool = ((s_622_10) == (s_622_9));
        // D s_622_12: lsl s_622_8 s_622_6
        let s_622_12: u64 = s_622_8 << s_622_6;
        // D s_622_13: or s_622_7 s_622_12
        let s_622_13: u64 = ((s_622_7) | (s_622_12));
        // D s_622_14: cmpl s_622_12
        let s_622_14: u64 = !s_622_12;
        // D s_622_15: and s_622_7 s_622_14
        let s_622_15: u64 = ((s_622_7) & (s_622_14));
        // D s_622_16: select s_622_11 s_622_13 s_622_15
        let s_622_16: u64 = if s_622_11 { s_622_13 } else { s_622_15 };
        // D s_622_17: cast trunc s_622_16 -> u8
        let s_622_17: bool = ((s_622_16) != 0);
        // D s_622_18: cast zx s_622_17 -> bv
        let s_622_18: Bits = Bits::new(s_622_17 as u128, 1u16);
        // C s_622_19: const #1u : u8
        let s_622_19: bool = true;
        // C s_622_20: cast zx s_622_19 -> bv
        let s_622_20: Bits = Bits::new(s_622_19 as u128, 1u16);
        // D s_622_21: cmp-ne s_622_18 s_622_20
        let s_622_21: bool = ((s_622_18) != (s_622_20));
        // D s_622_22: write-var gs#410487 <= s_622_21
        fn_state.gs_410487 = s_622_21;
        // N s_622_23: jump b623
        return block_623(state, tracer, fn_state);
    }
    fn block_623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_623_0: read-var gs#410487:u8
        let s_623_0: bool = fn_state.gs_410487;
        // N s_623_1: branch s_623_0 b625 b624
        if s_623_0 {
            return block_625(state, tracer, fn_state);
        } else {
            return block_624(state, tracer, fn_state);
        };
    }
    fn block_624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_624_0: read-var u#33693:u8
        let s_624_0: u8 = fn_state.u_33693;
        // D s_624_1: read-var u#33694:u8
        let s_624_1: u8 = fn_state.u_33694;
        // D s_624_2: read-var u#33695:u8
        let s_624_2: u8 = fn_state.u_33695;
        // D s_624_3: read-var u#33696:u8
        let s_624_3: u8 = fn_state.u_33696;
        // D s_624_4: call decode_aarch32_instrs_UADD16_A1enc_A_txt(s_624_0, s_624_1, s_624_2, s_624_3)
        let s_624_4: () = decode_aarch32_instrs_UADD16_A1enc_A_txt(
            state,
            tracer,
            s_624_0,
            s_624_1,
            s_624_2,
            s_624_3,
        );
        // N s_624_5: return
        return;
    }
    fn block_625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_625_0: panic
        panic!("{:?}", ());
        // N s_625_1: return
        return;
    }
    fn block_626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_626_0: const #1u : u8
        let s_626_0: bool = true;
        // D s_626_1: write-var gs#410487 <= s_626_0
        fn_state.gs_410487 = s_626_0;
        // N s_626_2: jump b623
        return block_623(state, tracer, fn_state);
    }
    fn block_627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_627_0: const #1u : u8
        let s_627_0: bool = true;
        // D s_627_1: write-var gs#410484 <= s_627_0
        fn_state.gs_410484 = s_627_0;
        // N s_627_2: jump b621
        return block_621(state, tracer, fn_state);
    }
    fn block_628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_628_0: const #1u : u8
        let s_628_0: bool = true;
        // D s_628_1: write-var gs#410481 <= s_628_0
        fn_state.gs_410481 = s_628_0;
        // N s_628_2: jump b619
        return block_619(state, tracer, fn_state);
    }
    fn block_629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_629_0: read-var merge#var.1:struct
        let s_629_0: u32 = fn_state.merge_var._1;
        // D s_629_1: write-var u#33698 <= s_629_0
        fn_state.u_33698 = s_629_0;
        // C s_629_2: const #20s : i
        let s_629_2: i128 = 20;
        // D s_629_3: read-var u#33698:u32
        let s_629_3: u32 = fn_state.u_33698;
        // D s_629_4: cast zx s_629_3 -> bv
        let s_629_4: Bits = Bits::new(s_629_3 as u128, 32u16);
        // C s_629_5: const #1s : i64
        let s_629_5: i64 = 1;
        // C s_629_6: cast zx s_629_5 -> i
        let s_629_6: i128 = (i128::try_from(s_629_5).unwrap());
        // C s_629_7: const #7s : i
        let s_629_7: i128 = 7;
        // C s_629_8: add s_629_7 s_629_6
        let s_629_8: i128 = (s_629_7 + s_629_6);
        // D s_629_9: bit-extract s_629_4 s_629_2 s_629_8
        let s_629_9: Bits = (Bits::new(
            ((s_629_4) >> (s_629_2)).value(),
            u16::try_from(s_629_8).unwrap(),
        ));
        // D s_629_10: cast reint s_629_9 -> u8
        let s_629_10: u8 = (s_629_9.value() as u8);
        // D s_629_11: cast zx s_629_10 -> bv
        let s_629_11: Bits = Bits::new(s_629_10 as u128, 8u16);
        // C s_629_12: const #101u : u8
        let s_629_12: u8 = 101;
        // C s_629_13: cast zx s_629_12 -> bv
        let s_629_13: Bits = Bits::new(s_629_12 as u128, 8u16);
        // D s_629_14: cmp-eq s_629_11 s_629_13
        let s_629_14: bool = ((s_629_11) == (s_629_13));
        // N s_629_15: branch s_629_14 b1187 b630
        if s_629_14 {
            return block_1187(state, tracer, fn_state);
        } else {
            return block_630(state, tracer, fn_state);
        };
    }
    fn block_630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_630_0: const #0u : u8
        let s_630_0: bool = false;
        // D s_630_1: write-var gs#410493 <= s_630_0
        fn_state.gs_410493 = s_630_0;
        // N s_630_2: jump b631
        return block_631(state, tracer, fn_state);
    }
    fn block_631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_631_0: read-var gs#410493:u8
        let s_631_0: bool = fn_state.gs_410493;
        // N s_631_1: branch s_631_0 b1183 b632
        if s_631_0 {
            return block_1183(state, tracer, fn_state);
        } else {
            return block_632(state, tracer, fn_state);
        };
    }
    fn block_632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_632_0: const #0u : u8
        let s_632_0: bool = false;
        // D s_632_1: write-var gs#410498 <= s_632_0
        fn_state.gs_410498 = s_632_0;
        // N s_632_2: jump b633
        return block_633(state, tracer, fn_state);
    }
    fn block_633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_633_0: read-var gs#410498:u8
        let s_633_0: bool = fn_state.gs_410498;
        // D s_633_1: not s_633_0
        let s_633_1: bool = !s_633_0;
        // N s_633_2: branch s_633_1 b646 b634
        if s_633_1 {
            return block_646(state, tracer, fn_state);
        } else {
            return block_634(state, tracer, fn_state);
        };
    }
    fn block_634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_634_0: const #3281s : i
        let s_634_0: i128 = 3281;
        // C s_634_1: const #14696u : u32
        let s_634_1: u32 = 14696;
        // N s_634_2: write-reg s_634_1 <= s_634_0
        let s_634_2: () = {
            state.write_register::<i128>(s_634_1 as isize, s_634_0);
            tracer.write_register(s_634_1 as isize, s_634_0);
        };
        // C s_634_3: const #28s : i
        let s_634_3: i128 = 28;
        // C s_634_4: const #4s : i
        let s_634_4: i128 = 4;
        // D s_634_5: read-var u#33698:u32
        let s_634_5: u32 = fn_state.u_33698;
        // D s_634_6: cast zx s_634_5 -> bv
        let s_634_6: Bits = Bits::new(s_634_5 as u128, 32u16);
        // D s_634_7: bit-extract s_634_6 s_634_3 s_634_4
        let s_634_7: Bits = (Bits::new(
            ((s_634_6) >> (s_634_3)).value(),
            u16::try_from(s_634_4).unwrap(),
        ));
        // D s_634_8: cast reint s_634_7 -> u8
        let s_634_8: u8 = (s_634_7.value() as u8);
        // D s_634_9: write-var u#33699 <= s_634_8
        fn_state.u_33699 = s_634_8;
        // C s_634_10: const #16s : i
        let s_634_10: i128 = 16;
        // C s_634_11: const #4s : i
        let s_634_11: i128 = 4;
        // D s_634_12: read-var u#33698:u32
        let s_634_12: u32 = fn_state.u_33698;
        // D s_634_13: cast zx s_634_12 -> bv
        let s_634_13: Bits = Bits::new(s_634_12 as u128, 32u16);
        // D s_634_14: bit-extract s_634_13 s_634_10 s_634_11
        let s_634_14: Bits = (Bits::new(
            ((s_634_13) >> (s_634_10)).value(),
            u16::try_from(s_634_11).unwrap(),
        ));
        // D s_634_15: cast reint s_634_14 -> u8
        let s_634_15: u8 = (s_634_14.value() as u8);
        // D s_634_16: write-var u#33700 <= s_634_15
        fn_state.u_33700 = s_634_15;
        // C s_634_17: const #12s : i
        let s_634_17: i128 = 12;
        // C s_634_18: const #4s : i
        let s_634_18: i128 = 4;
        // D s_634_19: read-var u#33698:u32
        let s_634_19: u32 = fn_state.u_33698;
        // D s_634_20: cast zx s_634_19 -> bv
        let s_634_20: Bits = Bits::new(s_634_19 as u128, 32u16);
        // D s_634_21: bit-extract s_634_20 s_634_17 s_634_18
        let s_634_21: Bits = (Bits::new(
            ((s_634_20) >> (s_634_17)).value(),
            u16::try_from(s_634_18).unwrap(),
        ));
        // D s_634_22: cast reint s_634_21 -> u8
        let s_634_22: u8 = (s_634_21.value() as u8);
        // D s_634_23: write-var u#33701 <= s_634_22
        fn_state.u_33701 = s_634_22;
        // C s_634_24: const #0s : i
        let s_634_24: i128 = 0;
        // C s_634_25: const #4s : i
        let s_634_25: i128 = 4;
        // D s_634_26: read-var u#33698:u32
        let s_634_26: u32 = fn_state.u_33698;
        // D s_634_27: cast zx s_634_26 -> bv
        let s_634_27: Bits = Bits::new(s_634_26 as u128, 32u16);
        // D s_634_28: bit-extract s_634_27 s_634_24 s_634_25
        let s_634_28: Bits = (Bits::new(
            ((s_634_27) >> (s_634_24)).value(),
            u16::try_from(s_634_25).unwrap(),
        ));
        // D s_634_29: cast reint s_634_28 -> u8
        let s_634_29: u8 = (s_634_28.value() as u8);
        // D s_634_30: write-var u#33702 <= s_634_29
        fn_state.u_33702 = s_634_29;
        // C s_634_31: const #8s : i
        let s_634_31: i128 = 8;
        // D s_634_32: read-var u#33698:u32
        let s_634_32: u32 = fn_state.u_33698;
        // D s_634_33: cast zx s_634_32 -> bv
        let s_634_33: Bits = Bits::new(s_634_32 as u128, 32u16);
        // C s_634_34: const #1u : u64
        let s_634_34: u64 = 1;
        // D s_634_35: bit-extract s_634_33 s_634_31 s_634_34
        let s_634_35: Bits = (Bits::new(
            ((s_634_33) >> (s_634_31)).value(),
            u16::try_from(s_634_34).unwrap(),
        ));
        // D s_634_36: cast reint s_634_35 -> u8
        let s_634_36: bool = ((s_634_35.value()) != 0);
        // C s_634_37: const #0s : i
        let s_634_37: i128 = 0;
        // C s_634_38: const #0u : u64
        let s_634_38: u64 = 0;
        // D s_634_39: cast zx s_634_36 -> u64
        let s_634_39: u64 = (s_634_36 as u64);
        // C s_634_40: const #1u : u64
        let s_634_40: u64 = 1;
        // D s_634_41: and s_634_39 s_634_40
        let s_634_41: u64 = ((s_634_39) & (s_634_40));
        // D s_634_42: cmp-eq s_634_41 s_634_40
        let s_634_42: bool = ((s_634_41) == (s_634_40));
        // D s_634_43: lsl s_634_39 s_634_37
        let s_634_43: u64 = s_634_39 << s_634_37;
        // D s_634_44: or s_634_38 s_634_43
        let s_634_44: u64 = ((s_634_38) | (s_634_43));
        // D s_634_45: cmpl s_634_43
        let s_634_45: u64 = !s_634_43;
        // D s_634_46: and s_634_38 s_634_45
        let s_634_46: u64 = ((s_634_38) & (s_634_45));
        // D s_634_47: select s_634_42 s_634_44 s_634_46
        let s_634_47: u64 = if s_634_42 { s_634_44 } else { s_634_46 };
        // D s_634_48: cast trunc s_634_47 -> u8
        let s_634_48: bool = ((s_634_47) != 0);
        // D s_634_49: cast zx s_634_48 -> bv
        let s_634_49: Bits = Bits::new(s_634_48 as u128, 1u16);
        // C s_634_50: const #1u : u8
        let s_634_50: bool = true;
        // C s_634_51: cast zx s_634_50 -> bv
        let s_634_51: Bits = Bits::new(s_634_50 as u128, 1u16);
        // D s_634_52: cmp-ne s_634_49 s_634_51
        let s_634_52: bool = ((s_634_49) != (s_634_51));
        // N s_634_53: branch s_634_52 b645 b635
        if s_634_52 {
            return block_645(state, tracer, fn_state);
        } else {
            return block_635(state, tracer, fn_state);
        };
    }
    fn block_635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_635_0: const #9s : i
        let s_635_0: i128 = 9;
        // D s_635_1: read-var u#33698:u32
        let s_635_1: u32 = fn_state.u_33698;
        // D s_635_2: cast zx s_635_1 -> bv
        let s_635_2: Bits = Bits::new(s_635_1 as u128, 32u16);
        // C s_635_3: const #1u : u64
        let s_635_3: u64 = 1;
        // D s_635_4: bit-extract s_635_2 s_635_0 s_635_3
        let s_635_4: Bits = (Bits::new(
            ((s_635_2) >> (s_635_0)).value(),
            u16::try_from(s_635_3).unwrap(),
        ));
        // D s_635_5: cast reint s_635_4 -> u8
        let s_635_5: bool = ((s_635_4.value()) != 0);
        // C s_635_6: const #0s : i
        let s_635_6: i128 = 0;
        // C s_635_7: const #0u : u64
        let s_635_7: u64 = 0;
        // D s_635_8: cast zx s_635_5 -> u64
        let s_635_8: u64 = (s_635_5 as u64);
        // C s_635_9: const #1u : u64
        let s_635_9: u64 = 1;
        // D s_635_10: and s_635_8 s_635_9
        let s_635_10: u64 = ((s_635_8) & (s_635_9));
        // D s_635_11: cmp-eq s_635_10 s_635_9
        let s_635_11: bool = ((s_635_10) == (s_635_9));
        // D s_635_12: lsl s_635_8 s_635_6
        let s_635_12: u64 = s_635_8 << s_635_6;
        // D s_635_13: or s_635_7 s_635_12
        let s_635_13: u64 = ((s_635_7) | (s_635_12));
        // D s_635_14: cmpl s_635_12
        let s_635_14: u64 = !s_635_12;
        // D s_635_15: and s_635_7 s_635_14
        let s_635_15: u64 = ((s_635_7) & (s_635_14));
        // D s_635_16: select s_635_11 s_635_13 s_635_15
        let s_635_16: u64 = if s_635_11 { s_635_13 } else { s_635_15 };
        // D s_635_17: cast trunc s_635_16 -> u8
        let s_635_17: bool = ((s_635_16) != 0);
        // D s_635_18: cast zx s_635_17 -> bv
        let s_635_18: Bits = Bits::new(s_635_17 as u128, 1u16);
        // C s_635_19: const #1u : u8
        let s_635_19: bool = true;
        // C s_635_20: cast zx s_635_19 -> bv
        let s_635_20: Bits = Bits::new(s_635_19 as u128, 1u16);
        // D s_635_21: cmp-ne s_635_18 s_635_20
        let s_635_21: bool = ((s_635_18) != (s_635_20));
        // D s_635_22: write-var gs#410513 <= s_635_21
        fn_state.gs_410513 = s_635_21;
        // N s_635_23: jump b636
        return block_636(state, tracer, fn_state);
    }
    fn block_636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_636_0: read-var gs#410513:u8
        let s_636_0: bool = fn_state.gs_410513;
        // N s_636_1: branch s_636_0 b644 b637
        if s_636_0 {
            return block_644(state, tracer, fn_state);
        } else {
            return block_637(state, tracer, fn_state);
        };
    }
    fn block_637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_637_0: const #10s : i
        let s_637_0: i128 = 10;
        // D s_637_1: read-var u#33698:u32
        let s_637_1: u32 = fn_state.u_33698;
        // D s_637_2: cast zx s_637_1 -> bv
        let s_637_2: Bits = Bits::new(s_637_1 as u128, 32u16);
        // C s_637_3: const #1u : u64
        let s_637_3: u64 = 1;
        // D s_637_4: bit-extract s_637_2 s_637_0 s_637_3
        let s_637_4: Bits = (Bits::new(
            ((s_637_2) >> (s_637_0)).value(),
            u16::try_from(s_637_3).unwrap(),
        ));
        // D s_637_5: cast reint s_637_4 -> u8
        let s_637_5: bool = ((s_637_4.value()) != 0);
        // C s_637_6: const #0s : i
        let s_637_6: i128 = 0;
        // C s_637_7: const #0u : u64
        let s_637_7: u64 = 0;
        // D s_637_8: cast zx s_637_5 -> u64
        let s_637_8: u64 = (s_637_5 as u64);
        // C s_637_9: const #1u : u64
        let s_637_9: u64 = 1;
        // D s_637_10: and s_637_8 s_637_9
        let s_637_10: u64 = ((s_637_8) & (s_637_9));
        // D s_637_11: cmp-eq s_637_10 s_637_9
        let s_637_11: bool = ((s_637_10) == (s_637_9));
        // D s_637_12: lsl s_637_8 s_637_6
        let s_637_12: u64 = s_637_8 << s_637_6;
        // D s_637_13: or s_637_7 s_637_12
        let s_637_13: u64 = ((s_637_7) | (s_637_12));
        // D s_637_14: cmpl s_637_12
        let s_637_14: u64 = !s_637_12;
        // D s_637_15: and s_637_7 s_637_14
        let s_637_15: u64 = ((s_637_7) & (s_637_14));
        // D s_637_16: select s_637_11 s_637_13 s_637_15
        let s_637_16: u64 = if s_637_11 { s_637_13 } else { s_637_15 };
        // D s_637_17: cast trunc s_637_16 -> u8
        let s_637_17: bool = ((s_637_16) != 0);
        // D s_637_18: cast zx s_637_17 -> bv
        let s_637_18: Bits = Bits::new(s_637_17 as u128, 1u16);
        // C s_637_19: const #1u : u8
        let s_637_19: bool = true;
        // C s_637_20: cast zx s_637_19 -> bv
        let s_637_20: Bits = Bits::new(s_637_19 as u128, 1u16);
        // D s_637_21: cmp-ne s_637_18 s_637_20
        let s_637_21: bool = ((s_637_18) != (s_637_20));
        // D s_637_22: write-var gs#410516 <= s_637_21
        fn_state.gs_410516 = s_637_21;
        // N s_637_23: jump b638
        return block_638(state, tracer, fn_state);
    }
    fn block_638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_638_0: read-var gs#410516:u8
        let s_638_0: bool = fn_state.gs_410516;
        // N s_638_1: branch s_638_0 b643 b639
        if s_638_0 {
            return block_643(state, tracer, fn_state);
        } else {
            return block_639(state, tracer, fn_state);
        };
    }
    fn block_639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_639_0: const #11s : i
        let s_639_0: i128 = 11;
        // D s_639_1: read-var u#33698:u32
        let s_639_1: u32 = fn_state.u_33698;
        // D s_639_2: cast zx s_639_1 -> bv
        let s_639_2: Bits = Bits::new(s_639_1 as u128, 32u16);
        // C s_639_3: const #1u : u64
        let s_639_3: u64 = 1;
        // D s_639_4: bit-extract s_639_2 s_639_0 s_639_3
        let s_639_4: Bits = (Bits::new(
            ((s_639_2) >> (s_639_0)).value(),
            u16::try_from(s_639_3).unwrap(),
        ));
        // D s_639_5: cast reint s_639_4 -> u8
        let s_639_5: bool = ((s_639_4.value()) != 0);
        // C s_639_6: const #0s : i
        let s_639_6: i128 = 0;
        // C s_639_7: const #0u : u64
        let s_639_7: u64 = 0;
        // D s_639_8: cast zx s_639_5 -> u64
        let s_639_8: u64 = (s_639_5 as u64);
        // C s_639_9: const #1u : u64
        let s_639_9: u64 = 1;
        // D s_639_10: and s_639_8 s_639_9
        let s_639_10: u64 = ((s_639_8) & (s_639_9));
        // D s_639_11: cmp-eq s_639_10 s_639_9
        let s_639_11: bool = ((s_639_10) == (s_639_9));
        // D s_639_12: lsl s_639_8 s_639_6
        let s_639_12: u64 = s_639_8 << s_639_6;
        // D s_639_13: or s_639_7 s_639_12
        let s_639_13: u64 = ((s_639_7) | (s_639_12));
        // D s_639_14: cmpl s_639_12
        let s_639_14: u64 = !s_639_12;
        // D s_639_15: and s_639_7 s_639_14
        let s_639_15: u64 = ((s_639_7) & (s_639_14));
        // D s_639_16: select s_639_11 s_639_13 s_639_15
        let s_639_16: u64 = if s_639_11 { s_639_13 } else { s_639_15 };
        // D s_639_17: cast trunc s_639_16 -> u8
        let s_639_17: bool = ((s_639_16) != 0);
        // D s_639_18: cast zx s_639_17 -> bv
        let s_639_18: Bits = Bits::new(s_639_17 as u128, 1u16);
        // C s_639_19: const #1u : u8
        let s_639_19: bool = true;
        // C s_639_20: cast zx s_639_19 -> bv
        let s_639_20: Bits = Bits::new(s_639_19 as u128, 1u16);
        // D s_639_21: cmp-ne s_639_18 s_639_20
        let s_639_21: bool = ((s_639_18) != (s_639_20));
        // D s_639_22: write-var gs#410519 <= s_639_21
        fn_state.gs_410519 = s_639_21;
        // N s_639_23: jump b640
        return block_640(state, tracer, fn_state);
    }
    fn block_640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_640_0: read-var gs#410519:u8
        let s_640_0: bool = fn_state.gs_410519;
        // N s_640_1: branch s_640_0 b642 b641
        if s_640_0 {
            return block_642(state, tracer, fn_state);
        } else {
            return block_641(state, tracer, fn_state);
        };
    }
    fn block_641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_641_0: read-var u#33699:u8
        let s_641_0: u8 = fn_state.u_33699;
        // D s_641_1: read-var u#33700:u8
        let s_641_1: u8 = fn_state.u_33700;
        // D s_641_2: read-var u#33701:u8
        let s_641_2: u8 = fn_state.u_33701;
        // D s_641_3: read-var u#33702:u8
        let s_641_3: u8 = fn_state.u_33702;
        // D s_641_4: call decode_aarch32_instrs_UADD8_A1enc_A_txt(s_641_0, s_641_1, s_641_2, s_641_3)
        let s_641_4: () = decode_aarch32_instrs_UADD8_A1enc_A_txt(
            state,
            tracer,
            s_641_0,
            s_641_1,
            s_641_2,
            s_641_3,
        );
        // N s_641_5: return
        return;
    }
    fn block_642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_642_0: panic
        panic!("{:?}", ());
        // N s_642_1: return
        return;
    }
    fn block_643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_643_0: const #1u : u8
        let s_643_0: bool = true;
        // D s_643_1: write-var gs#410519 <= s_643_0
        fn_state.gs_410519 = s_643_0;
        // N s_643_2: jump b640
        return block_640(state, tracer, fn_state);
    }
    fn block_644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_644_0: const #1u : u8
        let s_644_0: bool = true;
        // D s_644_1: write-var gs#410516 <= s_644_0
        fn_state.gs_410516 = s_644_0;
        // N s_644_2: jump b638
        return block_638(state, tracer, fn_state);
    }
    fn block_645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_645_0: const #1u : u8
        let s_645_0: bool = true;
        // D s_645_1: write-var gs#410513 <= s_645_0
        fn_state.gs_410513 = s_645_0;
        // N s_645_2: jump b636
        return block_636(state, tracer, fn_state);
    }
    fn block_646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_646_0: read-var merge#var.1:struct
        let s_646_0: u32 = fn_state.merge_var._1;
        // D s_646_1: write-var u#33704 <= s_646_0
        fn_state.u_33704 = s_646_0;
        // C s_646_2: const #20s : i
        let s_646_2: i128 = 20;
        // D s_646_3: read-var u#33704:u32
        let s_646_3: u32 = fn_state.u_33704;
        // D s_646_4: cast zx s_646_3 -> bv
        let s_646_4: Bits = Bits::new(s_646_3 as u128, 32u16);
        // C s_646_5: const #1s : i64
        let s_646_5: i64 = 1;
        // C s_646_6: cast zx s_646_5 -> i
        let s_646_6: i128 = (i128::try_from(s_646_5).unwrap());
        // C s_646_7: const #7s : i
        let s_646_7: i128 = 7;
        // C s_646_8: add s_646_7 s_646_6
        let s_646_8: i128 = (s_646_7 + s_646_6);
        // D s_646_9: bit-extract s_646_4 s_646_2 s_646_8
        let s_646_9: Bits = (Bits::new(
            ((s_646_4) >> (s_646_2)).value(),
            u16::try_from(s_646_8).unwrap(),
        ));
        // D s_646_10: cast reint s_646_9 -> u8
        let s_646_10: u8 = (s_646_9.value() as u8);
        // D s_646_11: cast zx s_646_10 -> bv
        let s_646_11: Bits = Bits::new(s_646_10 as u128, 8u16);
        // C s_646_12: const #101u : u8
        let s_646_12: u8 = 101;
        // C s_646_13: cast zx s_646_12 -> bv
        let s_646_13: Bits = Bits::new(s_646_12 as u128, 8u16);
        // D s_646_14: cmp-eq s_646_11 s_646_13
        let s_646_14: bool = ((s_646_11) == (s_646_13));
        // N s_646_15: branch s_646_14 b1182 b647
        if s_646_14 {
            return block_1182(state, tracer, fn_state);
        } else {
            return block_647(state, tracer, fn_state);
        };
    }
    fn block_647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_647_0: const #0u : u8
        let s_647_0: bool = false;
        // D s_647_1: write-var gs#410525 <= s_647_0
        fn_state.gs_410525 = s_647_0;
        // N s_647_2: jump b648
        return block_648(state, tracer, fn_state);
    }
    fn block_648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_648_0: read-var gs#410525:u8
        let s_648_0: bool = fn_state.gs_410525;
        // N s_648_1: branch s_648_0 b1178 b649
        if s_648_0 {
            return block_1178(state, tracer, fn_state);
        } else {
            return block_649(state, tracer, fn_state);
        };
    }
    fn block_649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_649_0: const #0u : u8
        let s_649_0: bool = false;
        // D s_649_1: write-var gs#410530 <= s_649_0
        fn_state.gs_410530 = s_649_0;
        // N s_649_2: jump b650
        return block_650(state, tracer, fn_state);
    }
    fn block_650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_650_0: read-var gs#410530:u8
        let s_650_0: bool = fn_state.gs_410530;
        // D s_650_1: not s_650_0
        let s_650_1: bool = !s_650_0;
        // N s_650_2: branch s_650_1 b663 b651
        if s_650_1 {
            return block_663(state, tracer, fn_state);
        } else {
            return block_651(state, tracer, fn_state);
        };
    }
    fn block_651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_651_0: const #3283s : i
        let s_651_0: i128 = 3283;
        // C s_651_1: const #14696u : u32
        let s_651_1: u32 = 14696;
        // N s_651_2: write-reg s_651_1 <= s_651_0
        let s_651_2: () = {
            state.write_register::<i128>(s_651_1 as isize, s_651_0);
            tracer.write_register(s_651_1 as isize, s_651_0);
        };
        // C s_651_3: const #28s : i
        let s_651_3: i128 = 28;
        // C s_651_4: const #4s : i
        let s_651_4: i128 = 4;
        // D s_651_5: read-var u#33704:u32
        let s_651_5: u32 = fn_state.u_33704;
        // D s_651_6: cast zx s_651_5 -> bv
        let s_651_6: Bits = Bits::new(s_651_5 as u128, 32u16);
        // D s_651_7: bit-extract s_651_6 s_651_3 s_651_4
        let s_651_7: Bits = (Bits::new(
            ((s_651_6) >> (s_651_3)).value(),
            u16::try_from(s_651_4).unwrap(),
        ));
        // D s_651_8: cast reint s_651_7 -> u8
        let s_651_8: u8 = (s_651_7.value() as u8);
        // D s_651_9: write-var u#33705 <= s_651_8
        fn_state.u_33705 = s_651_8;
        // C s_651_10: const #16s : i
        let s_651_10: i128 = 16;
        // C s_651_11: const #4s : i
        let s_651_11: i128 = 4;
        // D s_651_12: read-var u#33704:u32
        let s_651_12: u32 = fn_state.u_33704;
        // D s_651_13: cast zx s_651_12 -> bv
        let s_651_13: Bits = Bits::new(s_651_12 as u128, 32u16);
        // D s_651_14: bit-extract s_651_13 s_651_10 s_651_11
        let s_651_14: Bits = (Bits::new(
            ((s_651_13) >> (s_651_10)).value(),
            u16::try_from(s_651_11).unwrap(),
        ));
        // D s_651_15: cast reint s_651_14 -> u8
        let s_651_15: u8 = (s_651_14.value() as u8);
        // D s_651_16: write-var u#33706 <= s_651_15
        fn_state.u_33706 = s_651_15;
        // C s_651_17: const #12s : i
        let s_651_17: i128 = 12;
        // C s_651_18: const #4s : i
        let s_651_18: i128 = 4;
        // D s_651_19: read-var u#33704:u32
        let s_651_19: u32 = fn_state.u_33704;
        // D s_651_20: cast zx s_651_19 -> bv
        let s_651_20: Bits = Bits::new(s_651_19 as u128, 32u16);
        // D s_651_21: bit-extract s_651_20 s_651_17 s_651_18
        let s_651_21: Bits = (Bits::new(
            ((s_651_20) >> (s_651_17)).value(),
            u16::try_from(s_651_18).unwrap(),
        ));
        // D s_651_22: cast reint s_651_21 -> u8
        let s_651_22: u8 = (s_651_21.value() as u8);
        // D s_651_23: write-var u#33707 <= s_651_22
        fn_state.u_33707 = s_651_22;
        // C s_651_24: const #0s : i
        let s_651_24: i128 = 0;
        // C s_651_25: const #4s : i
        let s_651_25: i128 = 4;
        // D s_651_26: read-var u#33704:u32
        let s_651_26: u32 = fn_state.u_33704;
        // D s_651_27: cast zx s_651_26 -> bv
        let s_651_27: Bits = Bits::new(s_651_26 as u128, 32u16);
        // D s_651_28: bit-extract s_651_27 s_651_24 s_651_25
        let s_651_28: Bits = (Bits::new(
            ((s_651_27) >> (s_651_24)).value(),
            u16::try_from(s_651_25).unwrap(),
        ));
        // D s_651_29: cast reint s_651_28 -> u8
        let s_651_29: u8 = (s_651_28.value() as u8);
        // D s_651_30: write-var u#33708 <= s_651_29
        fn_state.u_33708 = s_651_29;
        // C s_651_31: const #8s : i
        let s_651_31: i128 = 8;
        // D s_651_32: read-var u#33704:u32
        let s_651_32: u32 = fn_state.u_33704;
        // D s_651_33: cast zx s_651_32 -> bv
        let s_651_33: Bits = Bits::new(s_651_32 as u128, 32u16);
        // C s_651_34: const #1u : u64
        let s_651_34: u64 = 1;
        // D s_651_35: bit-extract s_651_33 s_651_31 s_651_34
        let s_651_35: Bits = (Bits::new(
            ((s_651_33) >> (s_651_31)).value(),
            u16::try_from(s_651_34).unwrap(),
        ));
        // D s_651_36: cast reint s_651_35 -> u8
        let s_651_36: bool = ((s_651_35.value()) != 0);
        // C s_651_37: const #0s : i
        let s_651_37: i128 = 0;
        // C s_651_38: const #0u : u64
        let s_651_38: u64 = 0;
        // D s_651_39: cast zx s_651_36 -> u64
        let s_651_39: u64 = (s_651_36 as u64);
        // C s_651_40: const #1u : u64
        let s_651_40: u64 = 1;
        // D s_651_41: and s_651_39 s_651_40
        let s_651_41: u64 = ((s_651_39) & (s_651_40));
        // D s_651_42: cmp-eq s_651_41 s_651_40
        let s_651_42: bool = ((s_651_41) == (s_651_40));
        // D s_651_43: lsl s_651_39 s_651_37
        let s_651_43: u64 = s_651_39 << s_651_37;
        // D s_651_44: or s_651_38 s_651_43
        let s_651_44: u64 = ((s_651_38) | (s_651_43));
        // D s_651_45: cmpl s_651_43
        let s_651_45: u64 = !s_651_43;
        // D s_651_46: and s_651_38 s_651_45
        let s_651_46: u64 = ((s_651_38) & (s_651_45));
        // D s_651_47: select s_651_42 s_651_44 s_651_46
        let s_651_47: u64 = if s_651_42 { s_651_44 } else { s_651_46 };
        // D s_651_48: cast trunc s_651_47 -> u8
        let s_651_48: bool = ((s_651_47) != 0);
        // D s_651_49: cast zx s_651_48 -> bv
        let s_651_49: Bits = Bits::new(s_651_48 as u128, 1u16);
        // C s_651_50: const #1u : u8
        let s_651_50: bool = true;
        // C s_651_51: cast zx s_651_50 -> bv
        let s_651_51: Bits = Bits::new(s_651_50 as u128, 1u16);
        // D s_651_52: cmp-ne s_651_49 s_651_51
        let s_651_52: bool = ((s_651_49) != (s_651_51));
        // N s_651_53: branch s_651_52 b662 b652
        if s_651_52 {
            return block_662(state, tracer, fn_state);
        } else {
            return block_652(state, tracer, fn_state);
        };
    }
    fn block_652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_652_0: const #9s : i
        let s_652_0: i128 = 9;
        // D s_652_1: read-var u#33704:u32
        let s_652_1: u32 = fn_state.u_33704;
        // D s_652_2: cast zx s_652_1 -> bv
        let s_652_2: Bits = Bits::new(s_652_1 as u128, 32u16);
        // C s_652_3: const #1u : u64
        let s_652_3: u64 = 1;
        // D s_652_4: bit-extract s_652_2 s_652_0 s_652_3
        let s_652_4: Bits = (Bits::new(
            ((s_652_2) >> (s_652_0)).value(),
            u16::try_from(s_652_3).unwrap(),
        ));
        // D s_652_5: cast reint s_652_4 -> u8
        let s_652_5: bool = ((s_652_4.value()) != 0);
        // C s_652_6: const #0s : i
        let s_652_6: i128 = 0;
        // C s_652_7: const #0u : u64
        let s_652_7: u64 = 0;
        // D s_652_8: cast zx s_652_5 -> u64
        let s_652_8: u64 = (s_652_5 as u64);
        // C s_652_9: const #1u : u64
        let s_652_9: u64 = 1;
        // D s_652_10: and s_652_8 s_652_9
        let s_652_10: u64 = ((s_652_8) & (s_652_9));
        // D s_652_11: cmp-eq s_652_10 s_652_9
        let s_652_11: bool = ((s_652_10) == (s_652_9));
        // D s_652_12: lsl s_652_8 s_652_6
        let s_652_12: u64 = s_652_8 << s_652_6;
        // D s_652_13: or s_652_7 s_652_12
        let s_652_13: u64 = ((s_652_7) | (s_652_12));
        // D s_652_14: cmpl s_652_12
        let s_652_14: u64 = !s_652_12;
        // D s_652_15: and s_652_7 s_652_14
        let s_652_15: u64 = ((s_652_7) & (s_652_14));
        // D s_652_16: select s_652_11 s_652_13 s_652_15
        let s_652_16: u64 = if s_652_11 { s_652_13 } else { s_652_15 };
        // D s_652_17: cast trunc s_652_16 -> u8
        let s_652_17: bool = ((s_652_16) != 0);
        // D s_652_18: cast zx s_652_17 -> bv
        let s_652_18: Bits = Bits::new(s_652_17 as u128, 1u16);
        // C s_652_19: const #1u : u8
        let s_652_19: bool = true;
        // C s_652_20: cast zx s_652_19 -> bv
        let s_652_20: Bits = Bits::new(s_652_19 as u128, 1u16);
        // D s_652_21: cmp-ne s_652_18 s_652_20
        let s_652_21: bool = ((s_652_18) != (s_652_20));
        // D s_652_22: write-var gs#410545 <= s_652_21
        fn_state.gs_410545 = s_652_21;
        // N s_652_23: jump b653
        return block_653(state, tracer, fn_state);
    }
    fn block_653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_653_0: read-var gs#410545:u8
        let s_653_0: bool = fn_state.gs_410545;
        // N s_653_1: branch s_653_0 b661 b654
        if s_653_0 {
            return block_661(state, tracer, fn_state);
        } else {
            return block_654(state, tracer, fn_state);
        };
    }
    fn block_654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_654_0: const #10s : i
        let s_654_0: i128 = 10;
        // D s_654_1: read-var u#33704:u32
        let s_654_1: u32 = fn_state.u_33704;
        // D s_654_2: cast zx s_654_1 -> bv
        let s_654_2: Bits = Bits::new(s_654_1 as u128, 32u16);
        // C s_654_3: const #1u : u64
        let s_654_3: u64 = 1;
        // D s_654_4: bit-extract s_654_2 s_654_0 s_654_3
        let s_654_4: Bits = (Bits::new(
            ((s_654_2) >> (s_654_0)).value(),
            u16::try_from(s_654_3).unwrap(),
        ));
        // D s_654_5: cast reint s_654_4 -> u8
        let s_654_5: bool = ((s_654_4.value()) != 0);
        // C s_654_6: const #0s : i
        let s_654_6: i128 = 0;
        // C s_654_7: const #0u : u64
        let s_654_7: u64 = 0;
        // D s_654_8: cast zx s_654_5 -> u64
        let s_654_8: u64 = (s_654_5 as u64);
        // C s_654_9: const #1u : u64
        let s_654_9: u64 = 1;
        // D s_654_10: and s_654_8 s_654_9
        let s_654_10: u64 = ((s_654_8) & (s_654_9));
        // D s_654_11: cmp-eq s_654_10 s_654_9
        let s_654_11: bool = ((s_654_10) == (s_654_9));
        // D s_654_12: lsl s_654_8 s_654_6
        let s_654_12: u64 = s_654_8 << s_654_6;
        // D s_654_13: or s_654_7 s_654_12
        let s_654_13: u64 = ((s_654_7) | (s_654_12));
        // D s_654_14: cmpl s_654_12
        let s_654_14: u64 = !s_654_12;
        // D s_654_15: and s_654_7 s_654_14
        let s_654_15: u64 = ((s_654_7) & (s_654_14));
        // D s_654_16: select s_654_11 s_654_13 s_654_15
        let s_654_16: u64 = if s_654_11 { s_654_13 } else { s_654_15 };
        // D s_654_17: cast trunc s_654_16 -> u8
        let s_654_17: bool = ((s_654_16) != 0);
        // D s_654_18: cast zx s_654_17 -> bv
        let s_654_18: Bits = Bits::new(s_654_17 as u128, 1u16);
        // C s_654_19: const #1u : u8
        let s_654_19: bool = true;
        // C s_654_20: cast zx s_654_19 -> bv
        let s_654_20: Bits = Bits::new(s_654_19 as u128, 1u16);
        // D s_654_21: cmp-ne s_654_18 s_654_20
        let s_654_21: bool = ((s_654_18) != (s_654_20));
        // D s_654_22: write-var gs#410548 <= s_654_21
        fn_state.gs_410548 = s_654_21;
        // N s_654_23: jump b655
        return block_655(state, tracer, fn_state);
    }
    fn block_655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_655_0: read-var gs#410548:u8
        let s_655_0: bool = fn_state.gs_410548;
        // N s_655_1: branch s_655_0 b660 b656
        if s_655_0 {
            return block_660(state, tracer, fn_state);
        } else {
            return block_656(state, tracer, fn_state);
        };
    }
    fn block_656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_656_0: const #11s : i
        let s_656_0: i128 = 11;
        // D s_656_1: read-var u#33704:u32
        let s_656_1: u32 = fn_state.u_33704;
        // D s_656_2: cast zx s_656_1 -> bv
        let s_656_2: Bits = Bits::new(s_656_1 as u128, 32u16);
        // C s_656_3: const #1u : u64
        let s_656_3: u64 = 1;
        // D s_656_4: bit-extract s_656_2 s_656_0 s_656_3
        let s_656_4: Bits = (Bits::new(
            ((s_656_2) >> (s_656_0)).value(),
            u16::try_from(s_656_3).unwrap(),
        ));
        // D s_656_5: cast reint s_656_4 -> u8
        let s_656_5: bool = ((s_656_4.value()) != 0);
        // C s_656_6: const #0s : i
        let s_656_6: i128 = 0;
        // C s_656_7: const #0u : u64
        let s_656_7: u64 = 0;
        // D s_656_8: cast zx s_656_5 -> u64
        let s_656_8: u64 = (s_656_5 as u64);
        // C s_656_9: const #1u : u64
        let s_656_9: u64 = 1;
        // D s_656_10: and s_656_8 s_656_9
        let s_656_10: u64 = ((s_656_8) & (s_656_9));
        // D s_656_11: cmp-eq s_656_10 s_656_9
        let s_656_11: bool = ((s_656_10) == (s_656_9));
        // D s_656_12: lsl s_656_8 s_656_6
        let s_656_12: u64 = s_656_8 << s_656_6;
        // D s_656_13: or s_656_7 s_656_12
        let s_656_13: u64 = ((s_656_7) | (s_656_12));
        // D s_656_14: cmpl s_656_12
        let s_656_14: u64 = !s_656_12;
        // D s_656_15: and s_656_7 s_656_14
        let s_656_15: u64 = ((s_656_7) & (s_656_14));
        // D s_656_16: select s_656_11 s_656_13 s_656_15
        let s_656_16: u64 = if s_656_11 { s_656_13 } else { s_656_15 };
        // D s_656_17: cast trunc s_656_16 -> u8
        let s_656_17: bool = ((s_656_16) != 0);
        // D s_656_18: cast zx s_656_17 -> bv
        let s_656_18: Bits = Bits::new(s_656_17 as u128, 1u16);
        // C s_656_19: const #1u : u8
        let s_656_19: bool = true;
        // C s_656_20: cast zx s_656_19 -> bv
        let s_656_20: Bits = Bits::new(s_656_19 as u128, 1u16);
        // D s_656_21: cmp-ne s_656_18 s_656_20
        let s_656_21: bool = ((s_656_18) != (s_656_20));
        // D s_656_22: write-var gs#410551 <= s_656_21
        fn_state.gs_410551 = s_656_21;
        // N s_656_23: jump b657
        return block_657(state, tracer, fn_state);
    }
    fn block_657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_657_0: read-var gs#410551:u8
        let s_657_0: bool = fn_state.gs_410551;
        // N s_657_1: branch s_657_0 b659 b658
        if s_657_0 {
            return block_659(state, tracer, fn_state);
        } else {
            return block_658(state, tracer, fn_state);
        };
    }
    fn block_658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_658_0: read-var u#33705:u8
        let s_658_0: u8 = fn_state.u_33705;
        // D s_658_1: read-var u#33706:u8
        let s_658_1: u8 = fn_state.u_33706;
        // D s_658_2: read-var u#33707:u8
        let s_658_2: u8 = fn_state.u_33707;
        // D s_658_3: read-var u#33708:u8
        let s_658_3: u8 = fn_state.u_33708;
        // D s_658_4: call decode_aarch32_instrs_UASX_A1enc_A_txt(s_658_0, s_658_1, s_658_2, s_658_3)
        let s_658_4: () = decode_aarch32_instrs_UASX_A1enc_A_txt(
            state,
            tracer,
            s_658_0,
            s_658_1,
            s_658_2,
            s_658_3,
        );
        // N s_658_5: return
        return;
    }
    fn block_659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_659_0: panic
        panic!("{:?}", ());
        // N s_659_1: return
        return;
    }
    fn block_660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_660_0: const #1u : u8
        let s_660_0: bool = true;
        // D s_660_1: write-var gs#410551 <= s_660_0
        fn_state.gs_410551 = s_660_0;
        // N s_660_2: jump b657
        return block_657(state, tracer, fn_state);
    }
    fn block_661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_661_0: const #1u : u8
        let s_661_0: bool = true;
        // D s_661_1: write-var gs#410548 <= s_661_0
        fn_state.gs_410548 = s_661_0;
        // N s_661_2: jump b655
        return block_655(state, tracer, fn_state);
    }
    fn block_662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_662_0: const #1u : u8
        let s_662_0: bool = true;
        // D s_662_1: write-var gs#410545 <= s_662_0
        fn_state.gs_410545 = s_662_0;
        // N s_662_2: jump b653
        return block_653(state, tracer, fn_state);
    }
    fn block_663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_663_0: read-var merge#var.1:struct
        let s_663_0: u32 = fn_state.merge_var._1;
        // D s_663_1: write-var u#33710 <= s_663_0
        fn_state.u_33710 = s_663_0;
        // C s_663_2: const #21s : i
        let s_663_2: i128 = 21;
        // D s_663_3: read-var u#33710:u32
        let s_663_3: u32 = fn_state.u_33710;
        // D s_663_4: cast zx s_663_3 -> bv
        let s_663_4: Bits = Bits::new(s_663_3 as u128, 32u16);
        // C s_663_5: const #1s : i64
        let s_663_5: i64 = 1;
        // C s_663_6: cast zx s_663_5 -> i
        let s_663_6: i128 = (i128::try_from(s_663_5).unwrap());
        // C s_663_7: const #6s : i
        let s_663_7: i128 = 6;
        // C s_663_8: add s_663_7 s_663_6
        let s_663_8: i128 = (s_663_7 + s_663_6);
        // D s_663_9: bit-extract s_663_4 s_663_2 s_663_8
        let s_663_9: Bits = (Bits::new(
            ((s_663_4) >> (s_663_2)).value(),
            u16::try_from(s_663_8).unwrap(),
        ));
        // D s_663_10: cast reint s_663_9 -> u8
        let s_663_10: u8 = (s_663_9.value() as u8);
        // D s_663_11: cast zx s_663_10 -> bv
        let s_663_11: Bits = Bits::new(s_663_10 as u128, 7u16);
        // C s_663_12: const #63u : u8
        let s_663_12: u8 = 63;
        // C s_663_13: cast zx s_663_12 -> bv
        let s_663_13: Bits = Bits::new(s_663_12 as u128, 7u16);
        // D s_663_14: cmp-eq s_663_11 s_663_13
        let s_663_14: bool = ((s_663_11) == (s_663_13));
        // N s_663_15: branch s_663_14 b1177 b664
        if s_663_14 {
            return block_1177(state, tracer, fn_state);
        } else {
            return block_664(state, tracer, fn_state);
        };
    }
    fn block_664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_664_0: const #0u : u8
        let s_664_0: bool = false;
        // D s_664_1: write-var gs#410557 <= s_664_0
        fn_state.gs_410557 = s_664_0;
        // N s_664_2: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_665_0: read-var gs#410557:u8
        let s_665_0: bool = fn_state.gs_410557;
        // N s_665_1: branch s_665_0 b1173 b666
        if s_665_0 {
            return block_1173(state, tracer, fn_state);
        } else {
            return block_666(state, tracer, fn_state);
        };
    }
    fn block_666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_666_0: const #0u : u8
        let s_666_0: bool = false;
        // D s_666_1: write-var gs#410562 <= s_666_0
        fn_state.gs_410562 = s_666_0;
        // N s_666_2: jump b667
        return block_667(state, tracer, fn_state);
    }
    fn block_667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_667_0: read-var gs#410562:u8
        let s_667_0: bool = fn_state.gs_410562;
        // D s_667_1: not s_667_0
        let s_667_1: bool = !s_667_0;
        // N s_667_2: branch s_667_1 b669 b668
        if s_667_1 {
            return block_669(state, tracer, fn_state);
        } else {
            return block_668(state, tracer, fn_state);
        };
    }
    fn block_668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_668_0: const #3285s : i
        let s_668_0: i128 = 3285;
        // C s_668_1: const #14696u : u32
        let s_668_1: u32 = 14696;
        // N s_668_2: write-reg s_668_1 <= s_668_0
        let s_668_2: () = {
            state.write_register::<i128>(s_668_1 as isize, s_668_0);
            tracer.write_register(s_668_1 as isize, s_668_0);
        };
        // C s_668_3: const #28s : i
        let s_668_3: i128 = 28;
        // C s_668_4: const #4s : i
        let s_668_4: i128 = 4;
        // D s_668_5: read-var u#33710:u32
        let s_668_5: u32 = fn_state.u_33710;
        // D s_668_6: cast zx s_668_5 -> bv
        let s_668_6: Bits = Bits::new(s_668_5 as u128, 32u16);
        // D s_668_7: bit-extract s_668_6 s_668_3 s_668_4
        let s_668_7: Bits = (Bits::new(
            ((s_668_6) >> (s_668_3)).value(),
            u16::try_from(s_668_4).unwrap(),
        ));
        // D s_668_8: cast reint s_668_7 -> u8
        let s_668_8: u8 = (s_668_7.value() as u8);
        // C s_668_9: const #16s : i
        let s_668_9: i128 = 16;
        // C s_668_10: const #5s : i
        let s_668_10: i128 = 5;
        // D s_668_11: read-var u#33710:u32
        let s_668_11: u32 = fn_state.u_33710;
        // D s_668_12: cast zx s_668_11 -> bv
        let s_668_12: Bits = Bits::new(s_668_11 as u128, 32u16);
        // D s_668_13: bit-extract s_668_12 s_668_9 s_668_10
        let s_668_13: Bits = (Bits::new(
            ((s_668_12) >> (s_668_9)).value(),
            u16::try_from(s_668_10).unwrap(),
        ));
        // D s_668_14: cast reint s_668_13 -> u8
        let s_668_14: u8 = (s_668_13.value() as u8);
        // C s_668_15: const #12s : i
        let s_668_15: i128 = 12;
        // C s_668_16: const #4s : i
        let s_668_16: i128 = 4;
        // D s_668_17: read-var u#33710:u32
        let s_668_17: u32 = fn_state.u_33710;
        // D s_668_18: cast zx s_668_17 -> bv
        let s_668_18: Bits = Bits::new(s_668_17 as u128, 32u16);
        // D s_668_19: bit-extract s_668_18 s_668_15 s_668_16
        let s_668_19: Bits = (Bits::new(
            ((s_668_18) >> (s_668_15)).value(),
            u16::try_from(s_668_16).unwrap(),
        ));
        // D s_668_20: cast reint s_668_19 -> u8
        let s_668_20: u8 = (s_668_19.value() as u8);
        // C s_668_21: const #7s : i
        let s_668_21: i128 = 7;
        // C s_668_22: const #5s : i
        let s_668_22: i128 = 5;
        // D s_668_23: read-var u#33710:u32
        let s_668_23: u32 = fn_state.u_33710;
        // D s_668_24: cast zx s_668_23 -> bv
        let s_668_24: Bits = Bits::new(s_668_23 as u128, 32u16);
        // D s_668_25: bit-extract s_668_24 s_668_21 s_668_22
        let s_668_25: Bits = (Bits::new(
            ((s_668_24) >> (s_668_21)).value(),
            u16::try_from(s_668_22).unwrap(),
        ));
        // D s_668_26: cast reint s_668_25 -> u8
        let s_668_26: u8 = (s_668_25.value() as u8);
        // C s_668_27: const #0s : i
        let s_668_27: i128 = 0;
        // C s_668_28: const #4s : i
        let s_668_28: i128 = 4;
        // D s_668_29: read-var u#33710:u32
        let s_668_29: u32 = fn_state.u_33710;
        // D s_668_30: cast zx s_668_29 -> bv
        let s_668_30: Bits = Bits::new(s_668_29 as u128, 32u16);
        // D s_668_31: bit-extract s_668_30 s_668_27 s_668_28
        let s_668_31: Bits = (Bits::new(
            ((s_668_30) >> (s_668_27)).value(),
            u16::try_from(s_668_28).unwrap(),
        ));
        // D s_668_32: cast reint s_668_31 -> u8
        let s_668_32: u8 = (s_668_31.value() as u8);
        // D s_668_33: call decode_aarch32_instrs_UBFX_A1enc_A_txt(s_668_8, s_668_14, s_668_20, s_668_26, s_668_32)
        let s_668_33: () = decode_aarch32_instrs_UBFX_A1enc_A_txt(
            state,
            tracer,
            s_668_8,
            s_668_14,
            s_668_20,
            s_668_26,
            s_668_32,
        );
        // N s_668_34: return
        return;
    }
    fn block_669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_669_0: read-var merge#var.1:struct
        let s_669_0: u32 = fn_state.merge_var._1;
        // D s_669_1: write-var u#33717 <= s_669_0
        fn_state.u_33717 = s_669_0;
        // C s_669_2: const #20s : i
        let s_669_2: i128 = 20;
        // D s_669_3: read-var u#33717:u32
        let s_669_3: u32 = fn_state.u_33717;
        // D s_669_4: cast zx s_669_3 -> bv
        let s_669_4: Bits = Bits::new(s_669_3 as u128, 32u16);
        // C s_669_5: const #1s : i64
        let s_669_5: i64 = 1;
        // C s_669_6: cast zx s_669_5 -> i
        let s_669_6: i128 = (i128::try_from(s_669_5).unwrap());
        // C s_669_7: const #11s : i
        let s_669_7: i128 = 11;
        // C s_669_8: add s_669_7 s_669_6
        let s_669_8: i128 = (s_669_7 + s_669_6);
        // D s_669_9: bit-extract s_669_4 s_669_2 s_669_8
        let s_669_9: Bits = (Bits::new(
            ((s_669_4) >> (s_669_2)).value(),
            u16::try_from(s_669_8).unwrap(),
        ));
        // D s_669_10: cast reint s_669_9 -> u12
        let s_669_10: u16 = (s_669_9.value() as u16);
        // D s_669_11: cast zx s_669_10 -> bv
        let s_669_11: Bits = Bits::new(s_669_10 as u128, 12u16);
        // C s_669_12: const #3711u : u12
        let s_669_12: u16 = 3711;
        // C s_669_13: cast zx s_669_12 -> bv
        let s_669_13: Bits = Bits::new(s_669_12 as u128, 12u16);
        // D s_669_14: cmp-eq s_669_11 s_669_13
        let s_669_14: bool = ((s_669_11) == (s_669_13));
        // N s_669_15: branch s_669_14 b1172 b670
        if s_669_14 {
            return block_1172(state, tracer, fn_state);
        } else {
            return block_670(state, tracer, fn_state);
        };
    }
    fn block_670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_670_0: const #0u : u8
        let s_670_0: bool = false;
        // D s_670_1: write-var gs#410580 <= s_670_0
        fn_state.gs_410580 = s_670_0;
        // N s_670_2: jump b671
        return block_671(state, tracer, fn_state);
    }
    fn block_671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_671_0: read-var gs#410580:u8
        let s_671_0: bool = fn_state.gs_410580;
        // N s_671_1: branch s_671_0 b1171 b672
        if s_671_0 {
            return block_1171(state, tracer, fn_state);
        } else {
            return block_672(state, tracer, fn_state);
        };
    }
    fn block_672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_672_0: const #0u : u8
        let s_672_0: bool = false;
        // D s_672_1: write-var gs#410582 <= s_672_0
        fn_state.gs_410582 = s_672_0;
        // N s_672_2: jump b673
        return block_673(state, tracer, fn_state);
    }
    fn block_673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_673_0: read-var gs#410582:u8
        let s_673_0: bool = fn_state.gs_410582;
        // D s_673_1: not s_673_0
        let s_673_1: bool = !s_673_0;
        // N s_673_2: branch s_673_1 b675 b674
        if s_673_1 {
            return block_675(state, tracer, fn_state);
        } else {
            return block_674(state, tracer, fn_state);
        };
    }
    fn block_674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_674_0: const #3287s : i
        let s_674_0: i128 = 3287;
        // C s_674_1: const #14696u : u32
        let s_674_1: u32 = 14696;
        // N s_674_2: write-reg s_674_1 <= s_674_0
        let s_674_2: () = {
            state.write_register::<i128>(s_674_1 as isize, s_674_0);
            tracer.write_register(s_674_1 as isize, s_674_0);
        };
        // C s_674_3: const #8s : i
        let s_674_3: i128 = 8;
        // C s_674_4: const #12s : i
        let s_674_4: i128 = 12;
        // D s_674_5: read-var u#33717:u32
        let s_674_5: u32 = fn_state.u_33717;
        // D s_674_6: cast zx s_674_5 -> bv
        let s_674_6: Bits = Bits::new(s_674_5 as u128, 32u16);
        // D s_674_7: bit-extract s_674_6 s_674_3 s_674_4
        let s_674_7: Bits = (Bits::new(
            ((s_674_6) >> (s_674_3)).value(),
            u16::try_from(s_674_4).unwrap(),
        ));
        // D s_674_8: cast reint s_674_7 -> u12
        let s_674_8: u16 = (s_674_7.value() as u16);
        // C s_674_9: const #0s : i
        let s_674_9: i128 = 0;
        // C s_674_10: const #4s : i
        let s_674_10: i128 = 4;
        // D s_674_11: read-var u#33717:u32
        let s_674_11: u32 = fn_state.u_33717;
        // D s_674_12: cast zx s_674_11 -> bv
        let s_674_12: Bits = Bits::new(s_674_11 as u128, 32u16);
        // D s_674_13: bit-extract s_674_12 s_674_9 s_674_10
        let s_674_13: Bits = (Bits::new(
            ((s_674_12) >> (s_674_9)).value(),
            u16::try_from(s_674_10).unwrap(),
        ));
        // D s_674_14: cast reint s_674_13 -> u8
        let s_674_14: u8 = (s_674_13.value() as u8);
        // D s_674_15: call decode_aarch32_instrs_UDF_A1enc_A_txt(s_674_8, s_674_14)
        let s_674_15: () = decode_aarch32_instrs_UDF_A1enc_A_txt(
            state,
            tracer,
            s_674_8,
            s_674_14,
        );
        // N s_674_16: return
        return;
    }
    fn block_675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_675_0: read-var merge#var.1:struct
        let s_675_0: u32 = fn_state.merge_var._1;
        // D s_675_1: write-var u#33719 <= s_675_0
        fn_state.u_33719 = s_675_0;
        // C s_675_2: const #20s : i
        let s_675_2: i128 = 20;
        // D s_675_3: read-var u#33719:u32
        let s_675_3: u32 = fn_state.u_33719;
        // D s_675_4: cast zx s_675_3 -> bv
        let s_675_4: Bits = Bits::new(s_675_3 as u128, 32u16);
        // C s_675_5: const #1s : i64
        let s_675_5: i64 = 1;
        // C s_675_6: cast zx s_675_5 -> i
        let s_675_6: i128 = (i128::try_from(s_675_5).unwrap());
        // C s_675_7: const #7s : i
        let s_675_7: i128 = 7;
        // C s_675_8: add s_675_7 s_675_6
        let s_675_8: i128 = (s_675_7 + s_675_6);
        // D s_675_9: bit-extract s_675_4 s_675_2 s_675_8
        let s_675_9: Bits = (Bits::new(
            ((s_675_4) >> (s_675_2)).value(),
            u16::try_from(s_675_8).unwrap(),
        ));
        // D s_675_10: cast reint s_675_9 -> u8
        let s_675_10: u8 = (s_675_9.value() as u8);
        // D s_675_11: cast zx s_675_10 -> bv
        let s_675_11: Bits = Bits::new(s_675_10 as u128, 8u16);
        // C s_675_12: const #115u : u8
        let s_675_12: u8 = 115;
        // C s_675_13: cast zx s_675_12 -> bv
        let s_675_13: Bits = Bits::new(s_675_12 as u128, 8u16);
        // D s_675_14: cmp-eq s_675_11 s_675_13
        let s_675_14: bool = ((s_675_11) == (s_675_13));
        // N s_675_15: branch s_675_14 b1170 b676
        if s_675_14 {
            return block_1170(state, tracer, fn_state);
        } else {
            return block_676(state, tracer, fn_state);
        };
    }
    fn block_676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_676_0: const #0u : u8
        let s_676_0: bool = false;
        // D s_676_1: write-var gs#410594 <= s_676_0
        fn_state.gs_410594 = s_676_0;
        // N s_676_2: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_677_0: read-var gs#410594:u8
        let s_677_0: bool = fn_state.gs_410594;
        // N s_677_1: branch s_677_0 b1166 b678
        if s_677_0 {
            return block_1166(state, tracer, fn_state);
        } else {
            return block_678(state, tracer, fn_state);
        };
    }
    fn block_678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_678_0: const #0u : u8
        let s_678_0: bool = false;
        // D s_678_1: write-var gs#410599 <= s_678_0
        fn_state.gs_410599 = s_678_0;
        // N s_678_2: jump b679
        return block_679(state, tracer, fn_state);
    }
    fn block_679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_679_0: read-var gs#410599:u8
        let s_679_0: bool = fn_state.gs_410599;
        // D s_679_1: not s_679_0
        let s_679_1: bool = !s_679_0;
        // N s_679_2: branch s_679_1 b681 b680
        if s_679_1 {
            return block_681(state, tracer, fn_state);
        } else {
            return block_680(state, tracer, fn_state);
        };
    }
    fn block_680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_680_0: const #3290s : i
        let s_680_0: i128 = 3290;
        // C s_680_1: const #14696u : u32
        let s_680_1: u32 = 14696;
        // N s_680_2: write-reg s_680_1 <= s_680_0
        let s_680_2: () = {
            state.write_register::<i128>(s_680_1 as isize, s_680_0);
            tracer.write_register(s_680_1 as isize, s_680_0);
        };
        // C s_680_3: const #28s : i
        let s_680_3: i128 = 28;
        // C s_680_4: const #4s : i
        let s_680_4: i128 = 4;
        // D s_680_5: read-var u#33719:u32
        let s_680_5: u32 = fn_state.u_33719;
        // D s_680_6: cast zx s_680_5 -> bv
        let s_680_6: Bits = Bits::new(s_680_5 as u128, 32u16);
        // D s_680_7: bit-extract s_680_6 s_680_3 s_680_4
        let s_680_7: Bits = (Bits::new(
            ((s_680_6) >> (s_680_3)).value(),
            u16::try_from(s_680_4).unwrap(),
        ));
        // D s_680_8: cast reint s_680_7 -> u8
        let s_680_8: u8 = (s_680_7.value() as u8);
        // C s_680_9: const #16s : i
        let s_680_9: i128 = 16;
        // C s_680_10: const #4s : i
        let s_680_10: i128 = 4;
        // D s_680_11: read-var u#33719:u32
        let s_680_11: u32 = fn_state.u_33719;
        // D s_680_12: cast zx s_680_11 -> bv
        let s_680_12: Bits = Bits::new(s_680_11 as u128, 32u16);
        // D s_680_13: bit-extract s_680_12 s_680_9 s_680_10
        let s_680_13: Bits = (Bits::new(
            ((s_680_12) >> (s_680_9)).value(),
            u16::try_from(s_680_10).unwrap(),
        ));
        // D s_680_14: cast reint s_680_13 -> u8
        let s_680_14: u8 = (s_680_13.value() as u8);
        // C s_680_15: const #12s : i
        let s_680_15: i128 = 12;
        // C s_680_16: const #4s : i
        let s_680_16: i128 = 4;
        // D s_680_17: read-var u#33719:u32
        let s_680_17: u32 = fn_state.u_33719;
        // D s_680_18: cast zx s_680_17 -> bv
        let s_680_18: Bits = Bits::new(s_680_17 as u128, 32u16);
        // D s_680_19: bit-extract s_680_18 s_680_15 s_680_16
        let s_680_19: Bits = (Bits::new(
            ((s_680_18) >> (s_680_15)).value(),
            u16::try_from(s_680_16).unwrap(),
        ));
        // D s_680_20: cast reint s_680_19 -> u8
        let s_680_20: u8 = (s_680_19.value() as u8);
        // C s_680_21: const #8s : i
        let s_680_21: i128 = 8;
        // C s_680_22: const #4s : i
        let s_680_22: i128 = 4;
        // D s_680_23: read-var u#33719:u32
        let s_680_23: u32 = fn_state.u_33719;
        // D s_680_24: cast zx s_680_23 -> bv
        let s_680_24: Bits = Bits::new(s_680_23 as u128, 32u16);
        // D s_680_25: bit-extract s_680_24 s_680_21 s_680_22
        let s_680_25: Bits = (Bits::new(
            ((s_680_24) >> (s_680_21)).value(),
            u16::try_from(s_680_22).unwrap(),
        ));
        // D s_680_26: cast reint s_680_25 -> u8
        let s_680_26: u8 = (s_680_25.value() as u8);
        // C s_680_27: const #0s : i
        let s_680_27: i128 = 0;
        // C s_680_28: const #4s : i
        let s_680_28: i128 = 4;
        // D s_680_29: read-var u#33719:u32
        let s_680_29: u32 = fn_state.u_33719;
        // D s_680_30: cast zx s_680_29 -> bv
        let s_680_30: Bits = Bits::new(s_680_29 as u128, 32u16);
        // D s_680_31: bit-extract s_680_30 s_680_27 s_680_28
        let s_680_31: Bits = (Bits::new(
            ((s_680_30) >> (s_680_27)).value(),
            u16::try_from(s_680_28).unwrap(),
        ));
        // D s_680_32: cast reint s_680_31 -> u8
        let s_680_32: u8 = (s_680_31.value() as u8);
        // D s_680_33: call decode_aarch32_instrs_UDIV_A1enc_A_txt(s_680_8, s_680_14, s_680_20, s_680_26, s_680_32)
        let s_680_33: () = decode_aarch32_instrs_UDIV_A1enc_A_txt(
            state,
            tracer,
            s_680_8,
            s_680_14,
            s_680_20,
            s_680_26,
            s_680_32,
        );
        // N s_680_34: return
        return;
    }
    fn block_681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_681_0: read-var merge#var.1:struct
        let s_681_0: u32 = fn_state.merge_var._1;
        // D s_681_1: write-var u#33726 <= s_681_0
        fn_state.u_33726 = s_681_0;
        // C s_681_2: const #20s : i
        let s_681_2: i128 = 20;
        // D s_681_3: read-var u#33726:u32
        let s_681_3: u32 = fn_state.u_33726;
        // D s_681_4: cast zx s_681_3 -> bv
        let s_681_4: Bits = Bits::new(s_681_3 as u128, 32u16);
        // C s_681_5: const #1s : i64
        let s_681_5: i64 = 1;
        // C s_681_6: cast zx s_681_5 -> i
        let s_681_6: i128 = (i128::try_from(s_681_5).unwrap());
        // C s_681_7: const #7s : i
        let s_681_7: i128 = 7;
        // C s_681_8: add s_681_7 s_681_6
        let s_681_8: i128 = (s_681_7 + s_681_6);
        // D s_681_9: bit-extract s_681_4 s_681_2 s_681_8
        let s_681_9: Bits = (Bits::new(
            ((s_681_4) >> (s_681_2)).value(),
            u16::try_from(s_681_8).unwrap(),
        ));
        // D s_681_10: cast reint s_681_9 -> u8
        let s_681_10: u8 = (s_681_9.value() as u8);
        // D s_681_11: cast zx s_681_10 -> bv
        let s_681_11: Bits = Bits::new(s_681_10 as u128, 8u16);
        // C s_681_12: const #103u : u8
        let s_681_12: u8 = 103;
        // C s_681_13: cast zx s_681_12 -> bv
        let s_681_13: Bits = Bits::new(s_681_12 as u128, 8u16);
        // D s_681_14: cmp-eq s_681_11 s_681_13
        let s_681_14: bool = ((s_681_11) == (s_681_13));
        // N s_681_15: branch s_681_14 b1165 b682
        if s_681_14 {
            return block_1165(state, tracer, fn_state);
        } else {
            return block_682(state, tracer, fn_state);
        };
    }
    fn block_682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_682_0: const #0u : u8
        let s_682_0: bool = false;
        // D s_682_1: write-var gs#410617 <= s_682_0
        fn_state.gs_410617 = s_682_0;
        // N s_682_2: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_683_0: read-var gs#410617:u8
        let s_683_0: bool = fn_state.gs_410617;
        // N s_683_1: branch s_683_0 b1161 b684
        if s_683_0 {
            return block_1161(state, tracer, fn_state);
        } else {
            return block_684(state, tracer, fn_state);
        };
    }
    fn block_684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_684_0: const #0u : u8
        let s_684_0: bool = false;
        // D s_684_1: write-var gs#410622 <= s_684_0
        fn_state.gs_410622 = s_684_0;
        // N s_684_2: jump b685
        return block_685(state, tracer, fn_state);
    }
    fn block_685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_685_0: read-var gs#410622:u8
        let s_685_0: bool = fn_state.gs_410622;
        // D s_685_1: not s_685_0
        let s_685_1: bool = !s_685_0;
        // N s_685_2: branch s_685_1 b698 b686
        if s_685_1 {
            return block_698(state, tracer, fn_state);
        } else {
            return block_686(state, tracer, fn_state);
        };
    }
    fn block_686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_686_0: const #3292s : i
        let s_686_0: i128 = 3292;
        // C s_686_1: const #14696u : u32
        let s_686_1: u32 = 14696;
        // N s_686_2: write-reg s_686_1 <= s_686_0
        let s_686_2: () = {
            state.write_register::<i128>(s_686_1 as isize, s_686_0);
            tracer.write_register(s_686_1 as isize, s_686_0);
        };
        // C s_686_3: const #28s : i
        let s_686_3: i128 = 28;
        // C s_686_4: const #4s : i
        let s_686_4: i128 = 4;
        // D s_686_5: read-var u#33726:u32
        let s_686_5: u32 = fn_state.u_33726;
        // D s_686_6: cast zx s_686_5 -> bv
        let s_686_6: Bits = Bits::new(s_686_5 as u128, 32u16);
        // D s_686_7: bit-extract s_686_6 s_686_3 s_686_4
        let s_686_7: Bits = (Bits::new(
            ((s_686_6) >> (s_686_3)).value(),
            u16::try_from(s_686_4).unwrap(),
        ));
        // D s_686_8: cast reint s_686_7 -> u8
        let s_686_8: u8 = (s_686_7.value() as u8);
        // D s_686_9: write-var u#33727 <= s_686_8
        fn_state.u_33727 = s_686_8;
        // C s_686_10: const #16s : i
        let s_686_10: i128 = 16;
        // C s_686_11: const #4s : i
        let s_686_11: i128 = 4;
        // D s_686_12: read-var u#33726:u32
        let s_686_12: u32 = fn_state.u_33726;
        // D s_686_13: cast zx s_686_12 -> bv
        let s_686_13: Bits = Bits::new(s_686_12 as u128, 32u16);
        // D s_686_14: bit-extract s_686_13 s_686_10 s_686_11
        let s_686_14: Bits = (Bits::new(
            ((s_686_13) >> (s_686_10)).value(),
            u16::try_from(s_686_11).unwrap(),
        ));
        // D s_686_15: cast reint s_686_14 -> u8
        let s_686_15: u8 = (s_686_14.value() as u8);
        // D s_686_16: write-var u#33728 <= s_686_15
        fn_state.u_33728 = s_686_15;
        // C s_686_17: const #12s : i
        let s_686_17: i128 = 12;
        // C s_686_18: const #4s : i
        let s_686_18: i128 = 4;
        // D s_686_19: read-var u#33726:u32
        let s_686_19: u32 = fn_state.u_33726;
        // D s_686_20: cast zx s_686_19 -> bv
        let s_686_20: Bits = Bits::new(s_686_19 as u128, 32u16);
        // D s_686_21: bit-extract s_686_20 s_686_17 s_686_18
        let s_686_21: Bits = (Bits::new(
            ((s_686_20) >> (s_686_17)).value(),
            u16::try_from(s_686_18).unwrap(),
        ));
        // D s_686_22: cast reint s_686_21 -> u8
        let s_686_22: u8 = (s_686_21.value() as u8);
        // D s_686_23: write-var u#33729 <= s_686_22
        fn_state.u_33729 = s_686_22;
        // C s_686_24: const #0s : i
        let s_686_24: i128 = 0;
        // C s_686_25: const #4s : i
        let s_686_25: i128 = 4;
        // D s_686_26: read-var u#33726:u32
        let s_686_26: u32 = fn_state.u_33726;
        // D s_686_27: cast zx s_686_26 -> bv
        let s_686_27: Bits = Bits::new(s_686_26 as u128, 32u16);
        // D s_686_28: bit-extract s_686_27 s_686_24 s_686_25
        let s_686_28: Bits = (Bits::new(
            ((s_686_27) >> (s_686_24)).value(),
            u16::try_from(s_686_25).unwrap(),
        ));
        // D s_686_29: cast reint s_686_28 -> u8
        let s_686_29: u8 = (s_686_28.value() as u8);
        // D s_686_30: write-var u#33730 <= s_686_29
        fn_state.u_33730 = s_686_29;
        // C s_686_31: const #8s : i
        let s_686_31: i128 = 8;
        // D s_686_32: read-var u#33726:u32
        let s_686_32: u32 = fn_state.u_33726;
        // D s_686_33: cast zx s_686_32 -> bv
        let s_686_33: Bits = Bits::new(s_686_32 as u128, 32u16);
        // C s_686_34: const #1u : u64
        let s_686_34: u64 = 1;
        // D s_686_35: bit-extract s_686_33 s_686_31 s_686_34
        let s_686_35: Bits = (Bits::new(
            ((s_686_33) >> (s_686_31)).value(),
            u16::try_from(s_686_34).unwrap(),
        ));
        // D s_686_36: cast reint s_686_35 -> u8
        let s_686_36: bool = ((s_686_35.value()) != 0);
        // C s_686_37: const #0s : i
        let s_686_37: i128 = 0;
        // C s_686_38: const #0u : u64
        let s_686_38: u64 = 0;
        // D s_686_39: cast zx s_686_36 -> u64
        let s_686_39: u64 = (s_686_36 as u64);
        // C s_686_40: const #1u : u64
        let s_686_40: u64 = 1;
        // D s_686_41: and s_686_39 s_686_40
        let s_686_41: u64 = ((s_686_39) & (s_686_40));
        // D s_686_42: cmp-eq s_686_41 s_686_40
        let s_686_42: bool = ((s_686_41) == (s_686_40));
        // D s_686_43: lsl s_686_39 s_686_37
        let s_686_43: u64 = s_686_39 << s_686_37;
        // D s_686_44: or s_686_38 s_686_43
        let s_686_44: u64 = ((s_686_38) | (s_686_43));
        // D s_686_45: cmpl s_686_43
        let s_686_45: u64 = !s_686_43;
        // D s_686_46: and s_686_38 s_686_45
        let s_686_46: u64 = ((s_686_38) & (s_686_45));
        // D s_686_47: select s_686_42 s_686_44 s_686_46
        let s_686_47: u64 = if s_686_42 { s_686_44 } else { s_686_46 };
        // D s_686_48: cast trunc s_686_47 -> u8
        let s_686_48: bool = ((s_686_47) != 0);
        // D s_686_49: cast zx s_686_48 -> bv
        let s_686_49: Bits = Bits::new(s_686_48 as u128, 1u16);
        // C s_686_50: const #1u : u8
        let s_686_50: bool = true;
        // C s_686_51: cast zx s_686_50 -> bv
        let s_686_51: Bits = Bits::new(s_686_50 as u128, 1u16);
        // D s_686_52: cmp-ne s_686_49 s_686_51
        let s_686_52: bool = ((s_686_49) != (s_686_51));
        // N s_686_53: branch s_686_52 b697 b687
        if s_686_52 {
            return block_697(state, tracer, fn_state);
        } else {
            return block_687(state, tracer, fn_state);
        };
    }
    fn block_687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_687_0: const #9s : i
        let s_687_0: i128 = 9;
        // D s_687_1: read-var u#33726:u32
        let s_687_1: u32 = fn_state.u_33726;
        // D s_687_2: cast zx s_687_1 -> bv
        let s_687_2: Bits = Bits::new(s_687_1 as u128, 32u16);
        // C s_687_3: const #1u : u64
        let s_687_3: u64 = 1;
        // D s_687_4: bit-extract s_687_2 s_687_0 s_687_3
        let s_687_4: Bits = (Bits::new(
            ((s_687_2) >> (s_687_0)).value(),
            u16::try_from(s_687_3).unwrap(),
        ));
        // D s_687_5: cast reint s_687_4 -> u8
        let s_687_5: bool = ((s_687_4.value()) != 0);
        // C s_687_6: const #0s : i
        let s_687_6: i128 = 0;
        // C s_687_7: const #0u : u64
        let s_687_7: u64 = 0;
        // D s_687_8: cast zx s_687_5 -> u64
        let s_687_8: u64 = (s_687_5 as u64);
        // C s_687_9: const #1u : u64
        let s_687_9: u64 = 1;
        // D s_687_10: and s_687_8 s_687_9
        let s_687_10: u64 = ((s_687_8) & (s_687_9));
        // D s_687_11: cmp-eq s_687_10 s_687_9
        let s_687_11: bool = ((s_687_10) == (s_687_9));
        // D s_687_12: lsl s_687_8 s_687_6
        let s_687_12: u64 = s_687_8 << s_687_6;
        // D s_687_13: or s_687_7 s_687_12
        let s_687_13: u64 = ((s_687_7) | (s_687_12));
        // D s_687_14: cmpl s_687_12
        let s_687_14: u64 = !s_687_12;
        // D s_687_15: and s_687_7 s_687_14
        let s_687_15: u64 = ((s_687_7) & (s_687_14));
        // D s_687_16: select s_687_11 s_687_13 s_687_15
        let s_687_16: u64 = if s_687_11 { s_687_13 } else { s_687_15 };
        // D s_687_17: cast trunc s_687_16 -> u8
        let s_687_17: bool = ((s_687_16) != 0);
        // D s_687_18: cast zx s_687_17 -> bv
        let s_687_18: Bits = Bits::new(s_687_17 as u128, 1u16);
        // C s_687_19: const #1u : u8
        let s_687_19: bool = true;
        // C s_687_20: cast zx s_687_19 -> bv
        let s_687_20: Bits = Bits::new(s_687_19 as u128, 1u16);
        // D s_687_21: cmp-ne s_687_18 s_687_20
        let s_687_21: bool = ((s_687_18) != (s_687_20));
        // D s_687_22: write-var gs#410637 <= s_687_21
        fn_state.gs_410637 = s_687_21;
        // N s_687_23: jump b688
        return block_688(state, tracer, fn_state);
    }
    fn block_688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_688_0: read-var gs#410637:u8
        let s_688_0: bool = fn_state.gs_410637;
        // N s_688_1: branch s_688_0 b696 b689
        if s_688_0 {
            return block_696(state, tracer, fn_state);
        } else {
            return block_689(state, tracer, fn_state);
        };
    }
    fn block_689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_689_0: const #10s : i
        let s_689_0: i128 = 10;
        // D s_689_1: read-var u#33726:u32
        let s_689_1: u32 = fn_state.u_33726;
        // D s_689_2: cast zx s_689_1 -> bv
        let s_689_2: Bits = Bits::new(s_689_1 as u128, 32u16);
        // C s_689_3: const #1u : u64
        let s_689_3: u64 = 1;
        // D s_689_4: bit-extract s_689_2 s_689_0 s_689_3
        let s_689_4: Bits = (Bits::new(
            ((s_689_2) >> (s_689_0)).value(),
            u16::try_from(s_689_3).unwrap(),
        ));
        // D s_689_5: cast reint s_689_4 -> u8
        let s_689_5: bool = ((s_689_4.value()) != 0);
        // C s_689_6: const #0s : i
        let s_689_6: i128 = 0;
        // C s_689_7: const #0u : u64
        let s_689_7: u64 = 0;
        // D s_689_8: cast zx s_689_5 -> u64
        let s_689_8: u64 = (s_689_5 as u64);
        // C s_689_9: const #1u : u64
        let s_689_9: u64 = 1;
        // D s_689_10: and s_689_8 s_689_9
        let s_689_10: u64 = ((s_689_8) & (s_689_9));
        // D s_689_11: cmp-eq s_689_10 s_689_9
        let s_689_11: bool = ((s_689_10) == (s_689_9));
        // D s_689_12: lsl s_689_8 s_689_6
        let s_689_12: u64 = s_689_8 << s_689_6;
        // D s_689_13: or s_689_7 s_689_12
        let s_689_13: u64 = ((s_689_7) | (s_689_12));
        // D s_689_14: cmpl s_689_12
        let s_689_14: u64 = !s_689_12;
        // D s_689_15: and s_689_7 s_689_14
        let s_689_15: u64 = ((s_689_7) & (s_689_14));
        // D s_689_16: select s_689_11 s_689_13 s_689_15
        let s_689_16: u64 = if s_689_11 { s_689_13 } else { s_689_15 };
        // D s_689_17: cast trunc s_689_16 -> u8
        let s_689_17: bool = ((s_689_16) != 0);
        // D s_689_18: cast zx s_689_17 -> bv
        let s_689_18: Bits = Bits::new(s_689_17 as u128, 1u16);
        // C s_689_19: const #1u : u8
        let s_689_19: bool = true;
        // C s_689_20: cast zx s_689_19 -> bv
        let s_689_20: Bits = Bits::new(s_689_19 as u128, 1u16);
        // D s_689_21: cmp-ne s_689_18 s_689_20
        let s_689_21: bool = ((s_689_18) != (s_689_20));
        // D s_689_22: write-var gs#410640 <= s_689_21
        fn_state.gs_410640 = s_689_21;
        // N s_689_23: jump b690
        return block_690(state, tracer, fn_state);
    }
    fn block_690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_690_0: read-var gs#410640:u8
        let s_690_0: bool = fn_state.gs_410640;
        // N s_690_1: branch s_690_0 b695 b691
        if s_690_0 {
            return block_695(state, tracer, fn_state);
        } else {
            return block_691(state, tracer, fn_state);
        };
    }
    fn block_691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_691_0: const #11s : i
        let s_691_0: i128 = 11;
        // D s_691_1: read-var u#33726:u32
        let s_691_1: u32 = fn_state.u_33726;
        // D s_691_2: cast zx s_691_1 -> bv
        let s_691_2: Bits = Bits::new(s_691_1 as u128, 32u16);
        // C s_691_3: const #1u : u64
        let s_691_3: u64 = 1;
        // D s_691_4: bit-extract s_691_2 s_691_0 s_691_3
        let s_691_4: Bits = (Bits::new(
            ((s_691_2) >> (s_691_0)).value(),
            u16::try_from(s_691_3).unwrap(),
        ));
        // D s_691_5: cast reint s_691_4 -> u8
        let s_691_5: bool = ((s_691_4.value()) != 0);
        // C s_691_6: const #0s : i
        let s_691_6: i128 = 0;
        // C s_691_7: const #0u : u64
        let s_691_7: u64 = 0;
        // D s_691_8: cast zx s_691_5 -> u64
        let s_691_8: u64 = (s_691_5 as u64);
        // C s_691_9: const #1u : u64
        let s_691_9: u64 = 1;
        // D s_691_10: and s_691_8 s_691_9
        let s_691_10: u64 = ((s_691_8) & (s_691_9));
        // D s_691_11: cmp-eq s_691_10 s_691_9
        let s_691_11: bool = ((s_691_10) == (s_691_9));
        // D s_691_12: lsl s_691_8 s_691_6
        let s_691_12: u64 = s_691_8 << s_691_6;
        // D s_691_13: or s_691_7 s_691_12
        let s_691_13: u64 = ((s_691_7) | (s_691_12));
        // D s_691_14: cmpl s_691_12
        let s_691_14: u64 = !s_691_12;
        // D s_691_15: and s_691_7 s_691_14
        let s_691_15: u64 = ((s_691_7) & (s_691_14));
        // D s_691_16: select s_691_11 s_691_13 s_691_15
        let s_691_16: u64 = if s_691_11 { s_691_13 } else { s_691_15 };
        // D s_691_17: cast trunc s_691_16 -> u8
        let s_691_17: bool = ((s_691_16) != 0);
        // D s_691_18: cast zx s_691_17 -> bv
        let s_691_18: Bits = Bits::new(s_691_17 as u128, 1u16);
        // C s_691_19: const #1u : u8
        let s_691_19: bool = true;
        // C s_691_20: cast zx s_691_19 -> bv
        let s_691_20: Bits = Bits::new(s_691_19 as u128, 1u16);
        // D s_691_21: cmp-ne s_691_18 s_691_20
        let s_691_21: bool = ((s_691_18) != (s_691_20));
        // D s_691_22: write-var gs#410643 <= s_691_21
        fn_state.gs_410643 = s_691_21;
        // N s_691_23: jump b692
        return block_692(state, tracer, fn_state);
    }
    fn block_692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_692_0: read-var gs#410643:u8
        let s_692_0: bool = fn_state.gs_410643;
        // N s_692_1: branch s_692_0 b694 b693
        if s_692_0 {
            return block_694(state, tracer, fn_state);
        } else {
            return block_693(state, tracer, fn_state);
        };
    }
    fn block_693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_693_0: read-var u#33727:u8
        let s_693_0: u8 = fn_state.u_33727;
        // D s_693_1: read-var u#33728:u8
        let s_693_1: u8 = fn_state.u_33728;
        // D s_693_2: read-var u#33729:u8
        let s_693_2: u8 = fn_state.u_33729;
        // D s_693_3: read-var u#33730:u8
        let s_693_3: u8 = fn_state.u_33730;
        // D s_693_4: call decode_aarch32_instrs_UHADD16_A1enc_A_txt(s_693_0, s_693_1, s_693_2, s_693_3)
        let s_693_4: () = decode_aarch32_instrs_UHADD16_A1enc_A_txt(
            state,
            tracer,
            s_693_0,
            s_693_1,
            s_693_2,
            s_693_3,
        );
        // N s_693_5: return
        return;
    }
    fn block_694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_694_0: panic
        panic!("{:?}", ());
        // N s_694_1: return
        return;
    }
    fn block_695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_695_0: const #1u : u8
        let s_695_0: bool = true;
        // D s_695_1: write-var gs#410643 <= s_695_0
        fn_state.gs_410643 = s_695_0;
        // N s_695_2: jump b692
        return block_692(state, tracer, fn_state);
    }
    fn block_696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_696_0: const #1u : u8
        let s_696_0: bool = true;
        // D s_696_1: write-var gs#410640 <= s_696_0
        fn_state.gs_410640 = s_696_0;
        // N s_696_2: jump b690
        return block_690(state, tracer, fn_state);
    }
    fn block_697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_697_0: const #1u : u8
        let s_697_0: bool = true;
        // D s_697_1: write-var gs#410637 <= s_697_0
        fn_state.gs_410637 = s_697_0;
        // N s_697_2: jump b688
        return block_688(state, tracer, fn_state);
    }
    fn block_698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_698_0: read-var merge#var.1:struct
        let s_698_0: u32 = fn_state.merge_var._1;
        // D s_698_1: write-var u#33732 <= s_698_0
        fn_state.u_33732 = s_698_0;
        // C s_698_2: const #20s : i
        let s_698_2: i128 = 20;
        // D s_698_3: read-var u#33732:u32
        let s_698_3: u32 = fn_state.u_33732;
        // D s_698_4: cast zx s_698_3 -> bv
        let s_698_4: Bits = Bits::new(s_698_3 as u128, 32u16);
        // C s_698_5: const #1s : i64
        let s_698_5: i64 = 1;
        // C s_698_6: cast zx s_698_5 -> i
        let s_698_6: i128 = (i128::try_from(s_698_5).unwrap());
        // C s_698_7: const #7s : i
        let s_698_7: i128 = 7;
        // C s_698_8: add s_698_7 s_698_6
        let s_698_8: i128 = (s_698_7 + s_698_6);
        // D s_698_9: bit-extract s_698_4 s_698_2 s_698_8
        let s_698_9: Bits = (Bits::new(
            ((s_698_4) >> (s_698_2)).value(),
            u16::try_from(s_698_8).unwrap(),
        ));
        // D s_698_10: cast reint s_698_9 -> u8
        let s_698_10: u8 = (s_698_9.value() as u8);
        // D s_698_11: cast zx s_698_10 -> bv
        let s_698_11: Bits = Bits::new(s_698_10 as u128, 8u16);
        // C s_698_12: const #103u : u8
        let s_698_12: u8 = 103;
        // C s_698_13: cast zx s_698_12 -> bv
        let s_698_13: Bits = Bits::new(s_698_12 as u128, 8u16);
        // D s_698_14: cmp-eq s_698_11 s_698_13
        let s_698_14: bool = ((s_698_11) == (s_698_13));
        // N s_698_15: branch s_698_14 b1160 b699
        if s_698_14 {
            return block_1160(state, tracer, fn_state);
        } else {
            return block_699(state, tracer, fn_state);
        };
    }
    fn block_699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_699_0: const #0u : u8
        let s_699_0: bool = false;
        // D s_699_1: write-var gs#410649 <= s_699_0
        fn_state.gs_410649 = s_699_0;
        // N s_699_2: jump b700
        return block_700(state, tracer, fn_state);
    }
    fn block_700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_700_0: read-var gs#410649:u8
        let s_700_0: bool = fn_state.gs_410649;
        // N s_700_1: branch s_700_0 b1156 b701
        if s_700_0 {
            return block_1156(state, tracer, fn_state);
        } else {
            return block_701(state, tracer, fn_state);
        };
    }
    fn block_701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_701_0: const #0u : u8
        let s_701_0: bool = false;
        // D s_701_1: write-var gs#410654 <= s_701_0
        fn_state.gs_410654 = s_701_0;
        // N s_701_2: jump b702
        return block_702(state, tracer, fn_state);
    }
    fn block_702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_702_0: read-var gs#410654:u8
        let s_702_0: bool = fn_state.gs_410654;
        // D s_702_1: not s_702_0
        let s_702_1: bool = !s_702_0;
        // N s_702_2: branch s_702_1 b715 b703
        if s_702_1 {
            return block_715(state, tracer, fn_state);
        } else {
            return block_703(state, tracer, fn_state);
        };
    }
    fn block_703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_703_0: const #3294s : i
        let s_703_0: i128 = 3294;
        // C s_703_1: const #14696u : u32
        let s_703_1: u32 = 14696;
        // N s_703_2: write-reg s_703_1 <= s_703_0
        let s_703_2: () = {
            state.write_register::<i128>(s_703_1 as isize, s_703_0);
            tracer.write_register(s_703_1 as isize, s_703_0);
        };
        // C s_703_3: const #28s : i
        let s_703_3: i128 = 28;
        // C s_703_4: const #4s : i
        let s_703_4: i128 = 4;
        // D s_703_5: read-var u#33732:u32
        let s_703_5: u32 = fn_state.u_33732;
        // D s_703_6: cast zx s_703_5 -> bv
        let s_703_6: Bits = Bits::new(s_703_5 as u128, 32u16);
        // D s_703_7: bit-extract s_703_6 s_703_3 s_703_4
        let s_703_7: Bits = (Bits::new(
            ((s_703_6) >> (s_703_3)).value(),
            u16::try_from(s_703_4).unwrap(),
        ));
        // D s_703_8: cast reint s_703_7 -> u8
        let s_703_8: u8 = (s_703_7.value() as u8);
        // D s_703_9: write-var u#33733 <= s_703_8
        fn_state.u_33733 = s_703_8;
        // C s_703_10: const #16s : i
        let s_703_10: i128 = 16;
        // C s_703_11: const #4s : i
        let s_703_11: i128 = 4;
        // D s_703_12: read-var u#33732:u32
        let s_703_12: u32 = fn_state.u_33732;
        // D s_703_13: cast zx s_703_12 -> bv
        let s_703_13: Bits = Bits::new(s_703_12 as u128, 32u16);
        // D s_703_14: bit-extract s_703_13 s_703_10 s_703_11
        let s_703_14: Bits = (Bits::new(
            ((s_703_13) >> (s_703_10)).value(),
            u16::try_from(s_703_11).unwrap(),
        ));
        // D s_703_15: cast reint s_703_14 -> u8
        let s_703_15: u8 = (s_703_14.value() as u8);
        // D s_703_16: write-var u#33734 <= s_703_15
        fn_state.u_33734 = s_703_15;
        // C s_703_17: const #12s : i
        let s_703_17: i128 = 12;
        // C s_703_18: const #4s : i
        let s_703_18: i128 = 4;
        // D s_703_19: read-var u#33732:u32
        let s_703_19: u32 = fn_state.u_33732;
        // D s_703_20: cast zx s_703_19 -> bv
        let s_703_20: Bits = Bits::new(s_703_19 as u128, 32u16);
        // D s_703_21: bit-extract s_703_20 s_703_17 s_703_18
        let s_703_21: Bits = (Bits::new(
            ((s_703_20) >> (s_703_17)).value(),
            u16::try_from(s_703_18).unwrap(),
        ));
        // D s_703_22: cast reint s_703_21 -> u8
        let s_703_22: u8 = (s_703_21.value() as u8);
        // D s_703_23: write-var u#33735 <= s_703_22
        fn_state.u_33735 = s_703_22;
        // C s_703_24: const #0s : i
        let s_703_24: i128 = 0;
        // C s_703_25: const #4s : i
        let s_703_25: i128 = 4;
        // D s_703_26: read-var u#33732:u32
        let s_703_26: u32 = fn_state.u_33732;
        // D s_703_27: cast zx s_703_26 -> bv
        let s_703_27: Bits = Bits::new(s_703_26 as u128, 32u16);
        // D s_703_28: bit-extract s_703_27 s_703_24 s_703_25
        let s_703_28: Bits = (Bits::new(
            ((s_703_27) >> (s_703_24)).value(),
            u16::try_from(s_703_25).unwrap(),
        ));
        // D s_703_29: cast reint s_703_28 -> u8
        let s_703_29: u8 = (s_703_28.value() as u8);
        // D s_703_30: write-var u#33736 <= s_703_29
        fn_state.u_33736 = s_703_29;
        // C s_703_31: const #8s : i
        let s_703_31: i128 = 8;
        // D s_703_32: read-var u#33732:u32
        let s_703_32: u32 = fn_state.u_33732;
        // D s_703_33: cast zx s_703_32 -> bv
        let s_703_33: Bits = Bits::new(s_703_32 as u128, 32u16);
        // C s_703_34: const #1u : u64
        let s_703_34: u64 = 1;
        // D s_703_35: bit-extract s_703_33 s_703_31 s_703_34
        let s_703_35: Bits = (Bits::new(
            ((s_703_33) >> (s_703_31)).value(),
            u16::try_from(s_703_34).unwrap(),
        ));
        // D s_703_36: cast reint s_703_35 -> u8
        let s_703_36: bool = ((s_703_35.value()) != 0);
        // C s_703_37: const #0s : i
        let s_703_37: i128 = 0;
        // C s_703_38: const #0u : u64
        let s_703_38: u64 = 0;
        // D s_703_39: cast zx s_703_36 -> u64
        let s_703_39: u64 = (s_703_36 as u64);
        // C s_703_40: const #1u : u64
        let s_703_40: u64 = 1;
        // D s_703_41: and s_703_39 s_703_40
        let s_703_41: u64 = ((s_703_39) & (s_703_40));
        // D s_703_42: cmp-eq s_703_41 s_703_40
        let s_703_42: bool = ((s_703_41) == (s_703_40));
        // D s_703_43: lsl s_703_39 s_703_37
        let s_703_43: u64 = s_703_39 << s_703_37;
        // D s_703_44: or s_703_38 s_703_43
        let s_703_44: u64 = ((s_703_38) | (s_703_43));
        // D s_703_45: cmpl s_703_43
        let s_703_45: u64 = !s_703_43;
        // D s_703_46: and s_703_38 s_703_45
        let s_703_46: u64 = ((s_703_38) & (s_703_45));
        // D s_703_47: select s_703_42 s_703_44 s_703_46
        let s_703_47: u64 = if s_703_42 { s_703_44 } else { s_703_46 };
        // D s_703_48: cast trunc s_703_47 -> u8
        let s_703_48: bool = ((s_703_47) != 0);
        // D s_703_49: cast zx s_703_48 -> bv
        let s_703_49: Bits = Bits::new(s_703_48 as u128, 1u16);
        // C s_703_50: const #1u : u8
        let s_703_50: bool = true;
        // C s_703_51: cast zx s_703_50 -> bv
        let s_703_51: Bits = Bits::new(s_703_50 as u128, 1u16);
        // D s_703_52: cmp-ne s_703_49 s_703_51
        let s_703_52: bool = ((s_703_49) != (s_703_51));
        // N s_703_53: branch s_703_52 b714 b704
        if s_703_52 {
            return block_714(state, tracer, fn_state);
        } else {
            return block_704(state, tracer, fn_state);
        };
    }
    fn block_704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_704_0: const #9s : i
        let s_704_0: i128 = 9;
        // D s_704_1: read-var u#33732:u32
        let s_704_1: u32 = fn_state.u_33732;
        // D s_704_2: cast zx s_704_1 -> bv
        let s_704_2: Bits = Bits::new(s_704_1 as u128, 32u16);
        // C s_704_3: const #1u : u64
        let s_704_3: u64 = 1;
        // D s_704_4: bit-extract s_704_2 s_704_0 s_704_3
        let s_704_4: Bits = (Bits::new(
            ((s_704_2) >> (s_704_0)).value(),
            u16::try_from(s_704_3).unwrap(),
        ));
        // D s_704_5: cast reint s_704_4 -> u8
        let s_704_5: bool = ((s_704_4.value()) != 0);
        // C s_704_6: const #0s : i
        let s_704_6: i128 = 0;
        // C s_704_7: const #0u : u64
        let s_704_7: u64 = 0;
        // D s_704_8: cast zx s_704_5 -> u64
        let s_704_8: u64 = (s_704_5 as u64);
        // C s_704_9: const #1u : u64
        let s_704_9: u64 = 1;
        // D s_704_10: and s_704_8 s_704_9
        let s_704_10: u64 = ((s_704_8) & (s_704_9));
        // D s_704_11: cmp-eq s_704_10 s_704_9
        let s_704_11: bool = ((s_704_10) == (s_704_9));
        // D s_704_12: lsl s_704_8 s_704_6
        let s_704_12: u64 = s_704_8 << s_704_6;
        // D s_704_13: or s_704_7 s_704_12
        let s_704_13: u64 = ((s_704_7) | (s_704_12));
        // D s_704_14: cmpl s_704_12
        let s_704_14: u64 = !s_704_12;
        // D s_704_15: and s_704_7 s_704_14
        let s_704_15: u64 = ((s_704_7) & (s_704_14));
        // D s_704_16: select s_704_11 s_704_13 s_704_15
        let s_704_16: u64 = if s_704_11 { s_704_13 } else { s_704_15 };
        // D s_704_17: cast trunc s_704_16 -> u8
        let s_704_17: bool = ((s_704_16) != 0);
        // D s_704_18: cast zx s_704_17 -> bv
        let s_704_18: Bits = Bits::new(s_704_17 as u128, 1u16);
        // C s_704_19: const #1u : u8
        let s_704_19: bool = true;
        // C s_704_20: cast zx s_704_19 -> bv
        let s_704_20: Bits = Bits::new(s_704_19 as u128, 1u16);
        // D s_704_21: cmp-ne s_704_18 s_704_20
        let s_704_21: bool = ((s_704_18) != (s_704_20));
        // D s_704_22: write-var gs#410669 <= s_704_21
        fn_state.gs_410669 = s_704_21;
        // N s_704_23: jump b705
        return block_705(state, tracer, fn_state);
    }
    fn block_705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_705_0: read-var gs#410669:u8
        let s_705_0: bool = fn_state.gs_410669;
        // N s_705_1: branch s_705_0 b713 b706
        if s_705_0 {
            return block_713(state, tracer, fn_state);
        } else {
            return block_706(state, tracer, fn_state);
        };
    }
    fn block_706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_706_0: const #10s : i
        let s_706_0: i128 = 10;
        // D s_706_1: read-var u#33732:u32
        let s_706_1: u32 = fn_state.u_33732;
        // D s_706_2: cast zx s_706_1 -> bv
        let s_706_2: Bits = Bits::new(s_706_1 as u128, 32u16);
        // C s_706_3: const #1u : u64
        let s_706_3: u64 = 1;
        // D s_706_4: bit-extract s_706_2 s_706_0 s_706_3
        let s_706_4: Bits = (Bits::new(
            ((s_706_2) >> (s_706_0)).value(),
            u16::try_from(s_706_3).unwrap(),
        ));
        // D s_706_5: cast reint s_706_4 -> u8
        let s_706_5: bool = ((s_706_4.value()) != 0);
        // C s_706_6: const #0s : i
        let s_706_6: i128 = 0;
        // C s_706_7: const #0u : u64
        let s_706_7: u64 = 0;
        // D s_706_8: cast zx s_706_5 -> u64
        let s_706_8: u64 = (s_706_5 as u64);
        // C s_706_9: const #1u : u64
        let s_706_9: u64 = 1;
        // D s_706_10: and s_706_8 s_706_9
        let s_706_10: u64 = ((s_706_8) & (s_706_9));
        // D s_706_11: cmp-eq s_706_10 s_706_9
        let s_706_11: bool = ((s_706_10) == (s_706_9));
        // D s_706_12: lsl s_706_8 s_706_6
        let s_706_12: u64 = s_706_8 << s_706_6;
        // D s_706_13: or s_706_7 s_706_12
        let s_706_13: u64 = ((s_706_7) | (s_706_12));
        // D s_706_14: cmpl s_706_12
        let s_706_14: u64 = !s_706_12;
        // D s_706_15: and s_706_7 s_706_14
        let s_706_15: u64 = ((s_706_7) & (s_706_14));
        // D s_706_16: select s_706_11 s_706_13 s_706_15
        let s_706_16: u64 = if s_706_11 { s_706_13 } else { s_706_15 };
        // D s_706_17: cast trunc s_706_16 -> u8
        let s_706_17: bool = ((s_706_16) != 0);
        // D s_706_18: cast zx s_706_17 -> bv
        let s_706_18: Bits = Bits::new(s_706_17 as u128, 1u16);
        // C s_706_19: const #1u : u8
        let s_706_19: bool = true;
        // C s_706_20: cast zx s_706_19 -> bv
        let s_706_20: Bits = Bits::new(s_706_19 as u128, 1u16);
        // D s_706_21: cmp-ne s_706_18 s_706_20
        let s_706_21: bool = ((s_706_18) != (s_706_20));
        // D s_706_22: write-var gs#410672 <= s_706_21
        fn_state.gs_410672 = s_706_21;
        // N s_706_23: jump b707
        return block_707(state, tracer, fn_state);
    }
    fn block_707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_707_0: read-var gs#410672:u8
        let s_707_0: bool = fn_state.gs_410672;
        // N s_707_1: branch s_707_0 b712 b708
        if s_707_0 {
            return block_712(state, tracer, fn_state);
        } else {
            return block_708(state, tracer, fn_state);
        };
    }
    fn block_708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_708_0: const #11s : i
        let s_708_0: i128 = 11;
        // D s_708_1: read-var u#33732:u32
        let s_708_1: u32 = fn_state.u_33732;
        // D s_708_2: cast zx s_708_1 -> bv
        let s_708_2: Bits = Bits::new(s_708_1 as u128, 32u16);
        // C s_708_3: const #1u : u64
        let s_708_3: u64 = 1;
        // D s_708_4: bit-extract s_708_2 s_708_0 s_708_3
        let s_708_4: Bits = (Bits::new(
            ((s_708_2) >> (s_708_0)).value(),
            u16::try_from(s_708_3).unwrap(),
        ));
        // D s_708_5: cast reint s_708_4 -> u8
        let s_708_5: bool = ((s_708_4.value()) != 0);
        // C s_708_6: const #0s : i
        let s_708_6: i128 = 0;
        // C s_708_7: const #0u : u64
        let s_708_7: u64 = 0;
        // D s_708_8: cast zx s_708_5 -> u64
        let s_708_8: u64 = (s_708_5 as u64);
        // C s_708_9: const #1u : u64
        let s_708_9: u64 = 1;
        // D s_708_10: and s_708_8 s_708_9
        let s_708_10: u64 = ((s_708_8) & (s_708_9));
        // D s_708_11: cmp-eq s_708_10 s_708_9
        let s_708_11: bool = ((s_708_10) == (s_708_9));
        // D s_708_12: lsl s_708_8 s_708_6
        let s_708_12: u64 = s_708_8 << s_708_6;
        // D s_708_13: or s_708_7 s_708_12
        let s_708_13: u64 = ((s_708_7) | (s_708_12));
        // D s_708_14: cmpl s_708_12
        let s_708_14: u64 = !s_708_12;
        // D s_708_15: and s_708_7 s_708_14
        let s_708_15: u64 = ((s_708_7) & (s_708_14));
        // D s_708_16: select s_708_11 s_708_13 s_708_15
        let s_708_16: u64 = if s_708_11 { s_708_13 } else { s_708_15 };
        // D s_708_17: cast trunc s_708_16 -> u8
        let s_708_17: bool = ((s_708_16) != 0);
        // D s_708_18: cast zx s_708_17 -> bv
        let s_708_18: Bits = Bits::new(s_708_17 as u128, 1u16);
        // C s_708_19: const #1u : u8
        let s_708_19: bool = true;
        // C s_708_20: cast zx s_708_19 -> bv
        let s_708_20: Bits = Bits::new(s_708_19 as u128, 1u16);
        // D s_708_21: cmp-ne s_708_18 s_708_20
        let s_708_21: bool = ((s_708_18) != (s_708_20));
        // D s_708_22: write-var gs#410675 <= s_708_21
        fn_state.gs_410675 = s_708_21;
        // N s_708_23: jump b709
        return block_709(state, tracer, fn_state);
    }
    fn block_709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_709_0: read-var gs#410675:u8
        let s_709_0: bool = fn_state.gs_410675;
        // N s_709_1: branch s_709_0 b711 b710
        if s_709_0 {
            return block_711(state, tracer, fn_state);
        } else {
            return block_710(state, tracer, fn_state);
        };
    }
    fn block_710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_710_0: read-var u#33733:u8
        let s_710_0: u8 = fn_state.u_33733;
        // D s_710_1: read-var u#33734:u8
        let s_710_1: u8 = fn_state.u_33734;
        // D s_710_2: read-var u#33735:u8
        let s_710_2: u8 = fn_state.u_33735;
        // D s_710_3: read-var u#33736:u8
        let s_710_3: u8 = fn_state.u_33736;
        // D s_710_4: call decode_aarch32_instrs_UHADD8_A1enc_A_txt(s_710_0, s_710_1, s_710_2, s_710_3)
        let s_710_4: () = decode_aarch32_instrs_UHADD8_A1enc_A_txt(
            state,
            tracer,
            s_710_0,
            s_710_1,
            s_710_2,
            s_710_3,
        );
        // N s_710_5: return
        return;
    }
    fn block_711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_711_0: panic
        panic!("{:?}", ());
        // N s_711_1: return
        return;
    }
    fn block_712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_712_0: const #1u : u8
        let s_712_0: bool = true;
        // D s_712_1: write-var gs#410675 <= s_712_0
        fn_state.gs_410675 = s_712_0;
        // N s_712_2: jump b709
        return block_709(state, tracer, fn_state);
    }
    fn block_713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_713_0: const #1u : u8
        let s_713_0: bool = true;
        // D s_713_1: write-var gs#410672 <= s_713_0
        fn_state.gs_410672 = s_713_0;
        // N s_713_2: jump b707
        return block_707(state, tracer, fn_state);
    }
    fn block_714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_714_0: const #1u : u8
        let s_714_0: bool = true;
        // D s_714_1: write-var gs#410669 <= s_714_0
        fn_state.gs_410669 = s_714_0;
        // N s_714_2: jump b705
        return block_705(state, tracer, fn_state);
    }
    fn block_715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_715_0: read-var merge#var.1:struct
        let s_715_0: u32 = fn_state.merge_var._1;
        // D s_715_1: write-var u#33738 <= s_715_0
        fn_state.u_33738 = s_715_0;
        // C s_715_2: const #20s : i
        let s_715_2: i128 = 20;
        // D s_715_3: read-var u#33738:u32
        let s_715_3: u32 = fn_state.u_33738;
        // D s_715_4: cast zx s_715_3 -> bv
        let s_715_4: Bits = Bits::new(s_715_3 as u128, 32u16);
        // C s_715_5: const #1s : i64
        let s_715_5: i64 = 1;
        // C s_715_6: cast zx s_715_5 -> i
        let s_715_6: i128 = (i128::try_from(s_715_5).unwrap());
        // C s_715_7: const #7s : i
        let s_715_7: i128 = 7;
        // C s_715_8: add s_715_7 s_715_6
        let s_715_8: i128 = (s_715_7 + s_715_6);
        // D s_715_9: bit-extract s_715_4 s_715_2 s_715_8
        let s_715_9: Bits = (Bits::new(
            ((s_715_4) >> (s_715_2)).value(),
            u16::try_from(s_715_8).unwrap(),
        ));
        // D s_715_10: cast reint s_715_9 -> u8
        let s_715_10: u8 = (s_715_9.value() as u8);
        // D s_715_11: cast zx s_715_10 -> bv
        let s_715_11: Bits = Bits::new(s_715_10 as u128, 8u16);
        // C s_715_12: const #103u : u8
        let s_715_12: u8 = 103;
        // C s_715_13: cast zx s_715_12 -> bv
        let s_715_13: Bits = Bits::new(s_715_12 as u128, 8u16);
        // D s_715_14: cmp-eq s_715_11 s_715_13
        let s_715_14: bool = ((s_715_11) == (s_715_13));
        // N s_715_15: branch s_715_14 b1155 b716
        if s_715_14 {
            return block_1155(state, tracer, fn_state);
        } else {
            return block_716(state, tracer, fn_state);
        };
    }
    fn block_716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_716_0: const #0u : u8
        let s_716_0: bool = false;
        // D s_716_1: write-var gs#410681 <= s_716_0
        fn_state.gs_410681 = s_716_0;
        // N s_716_2: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_717_0: read-var gs#410681:u8
        let s_717_0: bool = fn_state.gs_410681;
        // N s_717_1: branch s_717_0 b1151 b718
        if s_717_0 {
            return block_1151(state, tracer, fn_state);
        } else {
            return block_718(state, tracer, fn_state);
        };
    }
    fn block_718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_718_0: const #0u : u8
        let s_718_0: bool = false;
        // D s_718_1: write-var gs#410686 <= s_718_0
        fn_state.gs_410686 = s_718_0;
        // N s_718_2: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_719_0: read-var gs#410686:u8
        let s_719_0: bool = fn_state.gs_410686;
        // D s_719_1: not s_719_0
        let s_719_1: bool = !s_719_0;
        // N s_719_2: branch s_719_1 b732 b720
        if s_719_1 {
            return block_732(state, tracer, fn_state);
        } else {
            return block_720(state, tracer, fn_state);
        };
    }
    fn block_720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_720_0: const #3296s : i
        let s_720_0: i128 = 3296;
        // C s_720_1: const #14696u : u32
        let s_720_1: u32 = 14696;
        // N s_720_2: write-reg s_720_1 <= s_720_0
        let s_720_2: () = {
            state.write_register::<i128>(s_720_1 as isize, s_720_0);
            tracer.write_register(s_720_1 as isize, s_720_0);
        };
        // C s_720_3: const #28s : i
        let s_720_3: i128 = 28;
        // C s_720_4: const #4s : i
        let s_720_4: i128 = 4;
        // D s_720_5: read-var u#33738:u32
        let s_720_5: u32 = fn_state.u_33738;
        // D s_720_6: cast zx s_720_5 -> bv
        let s_720_6: Bits = Bits::new(s_720_5 as u128, 32u16);
        // D s_720_7: bit-extract s_720_6 s_720_3 s_720_4
        let s_720_7: Bits = (Bits::new(
            ((s_720_6) >> (s_720_3)).value(),
            u16::try_from(s_720_4).unwrap(),
        ));
        // D s_720_8: cast reint s_720_7 -> u8
        let s_720_8: u8 = (s_720_7.value() as u8);
        // D s_720_9: write-var u#33739 <= s_720_8
        fn_state.u_33739 = s_720_8;
        // C s_720_10: const #16s : i
        let s_720_10: i128 = 16;
        // C s_720_11: const #4s : i
        let s_720_11: i128 = 4;
        // D s_720_12: read-var u#33738:u32
        let s_720_12: u32 = fn_state.u_33738;
        // D s_720_13: cast zx s_720_12 -> bv
        let s_720_13: Bits = Bits::new(s_720_12 as u128, 32u16);
        // D s_720_14: bit-extract s_720_13 s_720_10 s_720_11
        let s_720_14: Bits = (Bits::new(
            ((s_720_13) >> (s_720_10)).value(),
            u16::try_from(s_720_11).unwrap(),
        ));
        // D s_720_15: cast reint s_720_14 -> u8
        let s_720_15: u8 = (s_720_14.value() as u8);
        // D s_720_16: write-var u#33740 <= s_720_15
        fn_state.u_33740 = s_720_15;
        // C s_720_17: const #12s : i
        let s_720_17: i128 = 12;
        // C s_720_18: const #4s : i
        let s_720_18: i128 = 4;
        // D s_720_19: read-var u#33738:u32
        let s_720_19: u32 = fn_state.u_33738;
        // D s_720_20: cast zx s_720_19 -> bv
        let s_720_20: Bits = Bits::new(s_720_19 as u128, 32u16);
        // D s_720_21: bit-extract s_720_20 s_720_17 s_720_18
        let s_720_21: Bits = (Bits::new(
            ((s_720_20) >> (s_720_17)).value(),
            u16::try_from(s_720_18).unwrap(),
        ));
        // D s_720_22: cast reint s_720_21 -> u8
        let s_720_22: u8 = (s_720_21.value() as u8);
        // D s_720_23: write-var u#33741 <= s_720_22
        fn_state.u_33741 = s_720_22;
        // C s_720_24: const #0s : i
        let s_720_24: i128 = 0;
        // C s_720_25: const #4s : i
        let s_720_25: i128 = 4;
        // D s_720_26: read-var u#33738:u32
        let s_720_26: u32 = fn_state.u_33738;
        // D s_720_27: cast zx s_720_26 -> bv
        let s_720_27: Bits = Bits::new(s_720_26 as u128, 32u16);
        // D s_720_28: bit-extract s_720_27 s_720_24 s_720_25
        let s_720_28: Bits = (Bits::new(
            ((s_720_27) >> (s_720_24)).value(),
            u16::try_from(s_720_25).unwrap(),
        ));
        // D s_720_29: cast reint s_720_28 -> u8
        let s_720_29: u8 = (s_720_28.value() as u8);
        // D s_720_30: write-var u#33742 <= s_720_29
        fn_state.u_33742 = s_720_29;
        // C s_720_31: const #8s : i
        let s_720_31: i128 = 8;
        // D s_720_32: read-var u#33738:u32
        let s_720_32: u32 = fn_state.u_33738;
        // D s_720_33: cast zx s_720_32 -> bv
        let s_720_33: Bits = Bits::new(s_720_32 as u128, 32u16);
        // C s_720_34: const #1u : u64
        let s_720_34: u64 = 1;
        // D s_720_35: bit-extract s_720_33 s_720_31 s_720_34
        let s_720_35: Bits = (Bits::new(
            ((s_720_33) >> (s_720_31)).value(),
            u16::try_from(s_720_34).unwrap(),
        ));
        // D s_720_36: cast reint s_720_35 -> u8
        let s_720_36: bool = ((s_720_35.value()) != 0);
        // C s_720_37: const #0s : i
        let s_720_37: i128 = 0;
        // C s_720_38: const #0u : u64
        let s_720_38: u64 = 0;
        // D s_720_39: cast zx s_720_36 -> u64
        let s_720_39: u64 = (s_720_36 as u64);
        // C s_720_40: const #1u : u64
        let s_720_40: u64 = 1;
        // D s_720_41: and s_720_39 s_720_40
        let s_720_41: u64 = ((s_720_39) & (s_720_40));
        // D s_720_42: cmp-eq s_720_41 s_720_40
        let s_720_42: bool = ((s_720_41) == (s_720_40));
        // D s_720_43: lsl s_720_39 s_720_37
        let s_720_43: u64 = s_720_39 << s_720_37;
        // D s_720_44: or s_720_38 s_720_43
        let s_720_44: u64 = ((s_720_38) | (s_720_43));
        // D s_720_45: cmpl s_720_43
        let s_720_45: u64 = !s_720_43;
        // D s_720_46: and s_720_38 s_720_45
        let s_720_46: u64 = ((s_720_38) & (s_720_45));
        // D s_720_47: select s_720_42 s_720_44 s_720_46
        let s_720_47: u64 = if s_720_42 { s_720_44 } else { s_720_46 };
        // D s_720_48: cast trunc s_720_47 -> u8
        let s_720_48: bool = ((s_720_47) != 0);
        // D s_720_49: cast zx s_720_48 -> bv
        let s_720_49: Bits = Bits::new(s_720_48 as u128, 1u16);
        // C s_720_50: const #1u : u8
        let s_720_50: bool = true;
        // C s_720_51: cast zx s_720_50 -> bv
        let s_720_51: Bits = Bits::new(s_720_50 as u128, 1u16);
        // D s_720_52: cmp-ne s_720_49 s_720_51
        let s_720_52: bool = ((s_720_49) != (s_720_51));
        // N s_720_53: branch s_720_52 b731 b721
        if s_720_52 {
            return block_731(state, tracer, fn_state);
        } else {
            return block_721(state, tracer, fn_state);
        };
    }
    fn block_721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_721_0: const #9s : i
        let s_721_0: i128 = 9;
        // D s_721_1: read-var u#33738:u32
        let s_721_1: u32 = fn_state.u_33738;
        // D s_721_2: cast zx s_721_1 -> bv
        let s_721_2: Bits = Bits::new(s_721_1 as u128, 32u16);
        // C s_721_3: const #1u : u64
        let s_721_3: u64 = 1;
        // D s_721_4: bit-extract s_721_2 s_721_0 s_721_3
        let s_721_4: Bits = (Bits::new(
            ((s_721_2) >> (s_721_0)).value(),
            u16::try_from(s_721_3).unwrap(),
        ));
        // D s_721_5: cast reint s_721_4 -> u8
        let s_721_5: bool = ((s_721_4.value()) != 0);
        // C s_721_6: const #0s : i
        let s_721_6: i128 = 0;
        // C s_721_7: const #0u : u64
        let s_721_7: u64 = 0;
        // D s_721_8: cast zx s_721_5 -> u64
        let s_721_8: u64 = (s_721_5 as u64);
        // C s_721_9: const #1u : u64
        let s_721_9: u64 = 1;
        // D s_721_10: and s_721_8 s_721_9
        let s_721_10: u64 = ((s_721_8) & (s_721_9));
        // D s_721_11: cmp-eq s_721_10 s_721_9
        let s_721_11: bool = ((s_721_10) == (s_721_9));
        // D s_721_12: lsl s_721_8 s_721_6
        let s_721_12: u64 = s_721_8 << s_721_6;
        // D s_721_13: or s_721_7 s_721_12
        let s_721_13: u64 = ((s_721_7) | (s_721_12));
        // D s_721_14: cmpl s_721_12
        let s_721_14: u64 = !s_721_12;
        // D s_721_15: and s_721_7 s_721_14
        let s_721_15: u64 = ((s_721_7) & (s_721_14));
        // D s_721_16: select s_721_11 s_721_13 s_721_15
        let s_721_16: u64 = if s_721_11 { s_721_13 } else { s_721_15 };
        // D s_721_17: cast trunc s_721_16 -> u8
        let s_721_17: bool = ((s_721_16) != 0);
        // D s_721_18: cast zx s_721_17 -> bv
        let s_721_18: Bits = Bits::new(s_721_17 as u128, 1u16);
        // C s_721_19: const #1u : u8
        let s_721_19: bool = true;
        // C s_721_20: cast zx s_721_19 -> bv
        let s_721_20: Bits = Bits::new(s_721_19 as u128, 1u16);
        // D s_721_21: cmp-ne s_721_18 s_721_20
        let s_721_21: bool = ((s_721_18) != (s_721_20));
        // D s_721_22: write-var gs#410701 <= s_721_21
        fn_state.gs_410701 = s_721_21;
        // N s_721_23: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_722_0: read-var gs#410701:u8
        let s_722_0: bool = fn_state.gs_410701;
        // N s_722_1: branch s_722_0 b730 b723
        if s_722_0 {
            return block_730(state, tracer, fn_state);
        } else {
            return block_723(state, tracer, fn_state);
        };
    }
    fn block_723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_723_0: const #10s : i
        let s_723_0: i128 = 10;
        // D s_723_1: read-var u#33738:u32
        let s_723_1: u32 = fn_state.u_33738;
        // D s_723_2: cast zx s_723_1 -> bv
        let s_723_2: Bits = Bits::new(s_723_1 as u128, 32u16);
        // C s_723_3: const #1u : u64
        let s_723_3: u64 = 1;
        // D s_723_4: bit-extract s_723_2 s_723_0 s_723_3
        let s_723_4: Bits = (Bits::new(
            ((s_723_2) >> (s_723_0)).value(),
            u16::try_from(s_723_3).unwrap(),
        ));
        // D s_723_5: cast reint s_723_4 -> u8
        let s_723_5: bool = ((s_723_4.value()) != 0);
        // C s_723_6: const #0s : i
        let s_723_6: i128 = 0;
        // C s_723_7: const #0u : u64
        let s_723_7: u64 = 0;
        // D s_723_8: cast zx s_723_5 -> u64
        let s_723_8: u64 = (s_723_5 as u64);
        // C s_723_9: const #1u : u64
        let s_723_9: u64 = 1;
        // D s_723_10: and s_723_8 s_723_9
        let s_723_10: u64 = ((s_723_8) & (s_723_9));
        // D s_723_11: cmp-eq s_723_10 s_723_9
        let s_723_11: bool = ((s_723_10) == (s_723_9));
        // D s_723_12: lsl s_723_8 s_723_6
        let s_723_12: u64 = s_723_8 << s_723_6;
        // D s_723_13: or s_723_7 s_723_12
        let s_723_13: u64 = ((s_723_7) | (s_723_12));
        // D s_723_14: cmpl s_723_12
        let s_723_14: u64 = !s_723_12;
        // D s_723_15: and s_723_7 s_723_14
        let s_723_15: u64 = ((s_723_7) & (s_723_14));
        // D s_723_16: select s_723_11 s_723_13 s_723_15
        let s_723_16: u64 = if s_723_11 { s_723_13 } else { s_723_15 };
        // D s_723_17: cast trunc s_723_16 -> u8
        let s_723_17: bool = ((s_723_16) != 0);
        // D s_723_18: cast zx s_723_17 -> bv
        let s_723_18: Bits = Bits::new(s_723_17 as u128, 1u16);
        // C s_723_19: const #1u : u8
        let s_723_19: bool = true;
        // C s_723_20: cast zx s_723_19 -> bv
        let s_723_20: Bits = Bits::new(s_723_19 as u128, 1u16);
        // D s_723_21: cmp-ne s_723_18 s_723_20
        let s_723_21: bool = ((s_723_18) != (s_723_20));
        // D s_723_22: write-var gs#410704 <= s_723_21
        fn_state.gs_410704 = s_723_21;
        // N s_723_23: jump b724
        return block_724(state, tracer, fn_state);
    }
    fn block_724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_724_0: read-var gs#410704:u8
        let s_724_0: bool = fn_state.gs_410704;
        // N s_724_1: branch s_724_0 b729 b725
        if s_724_0 {
            return block_729(state, tracer, fn_state);
        } else {
            return block_725(state, tracer, fn_state);
        };
    }
    fn block_725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_725_0: const #11s : i
        let s_725_0: i128 = 11;
        // D s_725_1: read-var u#33738:u32
        let s_725_1: u32 = fn_state.u_33738;
        // D s_725_2: cast zx s_725_1 -> bv
        let s_725_2: Bits = Bits::new(s_725_1 as u128, 32u16);
        // C s_725_3: const #1u : u64
        let s_725_3: u64 = 1;
        // D s_725_4: bit-extract s_725_2 s_725_0 s_725_3
        let s_725_4: Bits = (Bits::new(
            ((s_725_2) >> (s_725_0)).value(),
            u16::try_from(s_725_3).unwrap(),
        ));
        // D s_725_5: cast reint s_725_4 -> u8
        let s_725_5: bool = ((s_725_4.value()) != 0);
        // C s_725_6: const #0s : i
        let s_725_6: i128 = 0;
        // C s_725_7: const #0u : u64
        let s_725_7: u64 = 0;
        // D s_725_8: cast zx s_725_5 -> u64
        let s_725_8: u64 = (s_725_5 as u64);
        // C s_725_9: const #1u : u64
        let s_725_9: u64 = 1;
        // D s_725_10: and s_725_8 s_725_9
        let s_725_10: u64 = ((s_725_8) & (s_725_9));
        // D s_725_11: cmp-eq s_725_10 s_725_9
        let s_725_11: bool = ((s_725_10) == (s_725_9));
        // D s_725_12: lsl s_725_8 s_725_6
        let s_725_12: u64 = s_725_8 << s_725_6;
        // D s_725_13: or s_725_7 s_725_12
        let s_725_13: u64 = ((s_725_7) | (s_725_12));
        // D s_725_14: cmpl s_725_12
        let s_725_14: u64 = !s_725_12;
        // D s_725_15: and s_725_7 s_725_14
        let s_725_15: u64 = ((s_725_7) & (s_725_14));
        // D s_725_16: select s_725_11 s_725_13 s_725_15
        let s_725_16: u64 = if s_725_11 { s_725_13 } else { s_725_15 };
        // D s_725_17: cast trunc s_725_16 -> u8
        let s_725_17: bool = ((s_725_16) != 0);
        // D s_725_18: cast zx s_725_17 -> bv
        let s_725_18: Bits = Bits::new(s_725_17 as u128, 1u16);
        // C s_725_19: const #1u : u8
        let s_725_19: bool = true;
        // C s_725_20: cast zx s_725_19 -> bv
        let s_725_20: Bits = Bits::new(s_725_19 as u128, 1u16);
        // D s_725_21: cmp-ne s_725_18 s_725_20
        let s_725_21: bool = ((s_725_18) != (s_725_20));
        // D s_725_22: write-var gs#410707 <= s_725_21
        fn_state.gs_410707 = s_725_21;
        // N s_725_23: jump b726
        return block_726(state, tracer, fn_state);
    }
    fn block_726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_726_0: read-var gs#410707:u8
        let s_726_0: bool = fn_state.gs_410707;
        // N s_726_1: branch s_726_0 b728 b727
        if s_726_0 {
            return block_728(state, tracer, fn_state);
        } else {
            return block_727(state, tracer, fn_state);
        };
    }
    fn block_727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_727_0: read-var u#33739:u8
        let s_727_0: u8 = fn_state.u_33739;
        // D s_727_1: read-var u#33740:u8
        let s_727_1: u8 = fn_state.u_33740;
        // D s_727_2: read-var u#33741:u8
        let s_727_2: u8 = fn_state.u_33741;
        // D s_727_3: read-var u#33742:u8
        let s_727_3: u8 = fn_state.u_33742;
        // D s_727_4: call decode_aarch32_instrs_UHASX_A1enc_A_txt(s_727_0, s_727_1, s_727_2, s_727_3)
        let s_727_4: () = decode_aarch32_instrs_UHASX_A1enc_A_txt(
            state,
            tracer,
            s_727_0,
            s_727_1,
            s_727_2,
            s_727_3,
        );
        // N s_727_5: return
        return;
    }
    fn block_728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_728_0: panic
        panic!("{:?}", ());
        // N s_728_1: return
        return;
    }
    fn block_729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_729_0: const #1u : u8
        let s_729_0: bool = true;
        // D s_729_1: write-var gs#410707 <= s_729_0
        fn_state.gs_410707 = s_729_0;
        // N s_729_2: jump b726
        return block_726(state, tracer, fn_state);
    }
    fn block_730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_730_0: const #1u : u8
        let s_730_0: bool = true;
        // D s_730_1: write-var gs#410704 <= s_730_0
        fn_state.gs_410704 = s_730_0;
        // N s_730_2: jump b724
        return block_724(state, tracer, fn_state);
    }
    fn block_731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_731_0: const #1u : u8
        let s_731_0: bool = true;
        // D s_731_1: write-var gs#410701 <= s_731_0
        fn_state.gs_410701 = s_731_0;
        // N s_731_2: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_732_0: read-var merge#var.1:struct
        let s_732_0: u32 = fn_state.merge_var._1;
        // D s_732_1: write-var u#33744 <= s_732_0
        fn_state.u_33744 = s_732_0;
        // C s_732_2: const #20s : i
        let s_732_2: i128 = 20;
        // D s_732_3: read-var u#33744:u32
        let s_732_3: u32 = fn_state.u_33744;
        // D s_732_4: cast zx s_732_3 -> bv
        let s_732_4: Bits = Bits::new(s_732_3 as u128, 32u16);
        // C s_732_5: const #1s : i64
        let s_732_5: i64 = 1;
        // C s_732_6: cast zx s_732_5 -> i
        let s_732_6: i128 = (i128::try_from(s_732_5).unwrap());
        // C s_732_7: const #7s : i
        let s_732_7: i128 = 7;
        // C s_732_8: add s_732_7 s_732_6
        let s_732_8: i128 = (s_732_7 + s_732_6);
        // D s_732_9: bit-extract s_732_4 s_732_2 s_732_8
        let s_732_9: Bits = (Bits::new(
            ((s_732_4) >> (s_732_2)).value(),
            u16::try_from(s_732_8).unwrap(),
        ));
        // D s_732_10: cast reint s_732_9 -> u8
        let s_732_10: u8 = (s_732_9.value() as u8);
        // D s_732_11: cast zx s_732_10 -> bv
        let s_732_11: Bits = Bits::new(s_732_10 as u128, 8u16);
        // C s_732_12: const #103u : u8
        let s_732_12: u8 = 103;
        // C s_732_13: cast zx s_732_12 -> bv
        let s_732_13: Bits = Bits::new(s_732_12 as u128, 8u16);
        // D s_732_14: cmp-eq s_732_11 s_732_13
        let s_732_14: bool = ((s_732_11) == (s_732_13));
        // N s_732_15: branch s_732_14 b1150 b733
        if s_732_14 {
            return block_1150(state, tracer, fn_state);
        } else {
            return block_733(state, tracer, fn_state);
        };
    }
    fn block_733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_733_0: const #0u : u8
        let s_733_0: bool = false;
        // D s_733_1: write-var gs#410713 <= s_733_0
        fn_state.gs_410713 = s_733_0;
        // N s_733_2: jump b734
        return block_734(state, tracer, fn_state);
    }
    fn block_734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_734_0: read-var gs#410713:u8
        let s_734_0: bool = fn_state.gs_410713;
        // N s_734_1: branch s_734_0 b1146 b735
        if s_734_0 {
            return block_1146(state, tracer, fn_state);
        } else {
            return block_735(state, tracer, fn_state);
        };
    }
    fn block_735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_735_0: const #0u : u8
        let s_735_0: bool = false;
        // D s_735_1: write-var gs#410718 <= s_735_0
        fn_state.gs_410718 = s_735_0;
        // N s_735_2: jump b736
        return block_736(state, tracer, fn_state);
    }
    fn block_736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_736_0: read-var gs#410718:u8
        let s_736_0: bool = fn_state.gs_410718;
        // D s_736_1: not s_736_0
        let s_736_1: bool = !s_736_0;
        // N s_736_2: branch s_736_1 b749 b737
        if s_736_1 {
            return block_749(state, tracer, fn_state);
        } else {
            return block_737(state, tracer, fn_state);
        };
    }
    fn block_737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_737_0: const #3298s : i
        let s_737_0: i128 = 3298;
        // C s_737_1: const #14696u : u32
        let s_737_1: u32 = 14696;
        // N s_737_2: write-reg s_737_1 <= s_737_0
        let s_737_2: () = {
            state.write_register::<i128>(s_737_1 as isize, s_737_0);
            tracer.write_register(s_737_1 as isize, s_737_0);
        };
        // C s_737_3: const #28s : i
        let s_737_3: i128 = 28;
        // C s_737_4: const #4s : i
        let s_737_4: i128 = 4;
        // D s_737_5: read-var u#33744:u32
        let s_737_5: u32 = fn_state.u_33744;
        // D s_737_6: cast zx s_737_5 -> bv
        let s_737_6: Bits = Bits::new(s_737_5 as u128, 32u16);
        // D s_737_7: bit-extract s_737_6 s_737_3 s_737_4
        let s_737_7: Bits = (Bits::new(
            ((s_737_6) >> (s_737_3)).value(),
            u16::try_from(s_737_4).unwrap(),
        ));
        // D s_737_8: cast reint s_737_7 -> u8
        let s_737_8: u8 = (s_737_7.value() as u8);
        // D s_737_9: write-var u#33745 <= s_737_8
        fn_state.u_33745 = s_737_8;
        // C s_737_10: const #16s : i
        let s_737_10: i128 = 16;
        // C s_737_11: const #4s : i
        let s_737_11: i128 = 4;
        // D s_737_12: read-var u#33744:u32
        let s_737_12: u32 = fn_state.u_33744;
        // D s_737_13: cast zx s_737_12 -> bv
        let s_737_13: Bits = Bits::new(s_737_12 as u128, 32u16);
        // D s_737_14: bit-extract s_737_13 s_737_10 s_737_11
        let s_737_14: Bits = (Bits::new(
            ((s_737_13) >> (s_737_10)).value(),
            u16::try_from(s_737_11).unwrap(),
        ));
        // D s_737_15: cast reint s_737_14 -> u8
        let s_737_15: u8 = (s_737_14.value() as u8);
        // D s_737_16: write-var u#33746 <= s_737_15
        fn_state.u_33746 = s_737_15;
        // C s_737_17: const #12s : i
        let s_737_17: i128 = 12;
        // C s_737_18: const #4s : i
        let s_737_18: i128 = 4;
        // D s_737_19: read-var u#33744:u32
        let s_737_19: u32 = fn_state.u_33744;
        // D s_737_20: cast zx s_737_19 -> bv
        let s_737_20: Bits = Bits::new(s_737_19 as u128, 32u16);
        // D s_737_21: bit-extract s_737_20 s_737_17 s_737_18
        let s_737_21: Bits = (Bits::new(
            ((s_737_20) >> (s_737_17)).value(),
            u16::try_from(s_737_18).unwrap(),
        ));
        // D s_737_22: cast reint s_737_21 -> u8
        let s_737_22: u8 = (s_737_21.value() as u8);
        // D s_737_23: write-var u#33747 <= s_737_22
        fn_state.u_33747 = s_737_22;
        // C s_737_24: const #0s : i
        let s_737_24: i128 = 0;
        // C s_737_25: const #4s : i
        let s_737_25: i128 = 4;
        // D s_737_26: read-var u#33744:u32
        let s_737_26: u32 = fn_state.u_33744;
        // D s_737_27: cast zx s_737_26 -> bv
        let s_737_27: Bits = Bits::new(s_737_26 as u128, 32u16);
        // D s_737_28: bit-extract s_737_27 s_737_24 s_737_25
        let s_737_28: Bits = (Bits::new(
            ((s_737_27) >> (s_737_24)).value(),
            u16::try_from(s_737_25).unwrap(),
        ));
        // D s_737_29: cast reint s_737_28 -> u8
        let s_737_29: u8 = (s_737_28.value() as u8);
        // D s_737_30: write-var u#33748 <= s_737_29
        fn_state.u_33748 = s_737_29;
        // C s_737_31: const #8s : i
        let s_737_31: i128 = 8;
        // D s_737_32: read-var u#33744:u32
        let s_737_32: u32 = fn_state.u_33744;
        // D s_737_33: cast zx s_737_32 -> bv
        let s_737_33: Bits = Bits::new(s_737_32 as u128, 32u16);
        // C s_737_34: const #1u : u64
        let s_737_34: u64 = 1;
        // D s_737_35: bit-extract s_737_33 s_737_31 s_737_34
        let s_737_35: Bits = (Bits::new(
            ((s_737_33) >> (s_737_31)).value(),
            u16::try_from(s_737_34).unwrap(),
        ));
        // D s_737_36: cast reint s_737_35 -> u8
        let s_737_36: bool = ((s_737_35.value()) != 0);
        // C s_737_37: const #0s : i
        let s_737_37: i128 = 0;
        // C s_737_38: const #0u : u64
        let s_737_38: u64 = 0;
        // D s_737_39: cast zx s_737_36 -> u64
        let s_737_39: u64 = (s_737_36 as u64);
        // C s_737_40: const #1u : u64
        let s_737_40: u64 = 1;
        // D s_737_41: and s_737_39 s_737_40
        let s_737_41: u64 = ((s_737_39) & (s_737_40));
        // D s_737_42: cmp-eq s_737_41 s_737_40
        let s_737_42: bool = ((s_737_41) == (s_737_40));
        // D s_737_43: lsl s_737_39 s_737_37
        let s_737_43: u64 = s_737_39 << s_737_37;
        // D s_737_44: or s_737_38 s_737_43
        let s_737_44: u64 = ((s_737_38) | (s_737_43));
        // D s_737_45: cmpl s_737_43
        let s_737_45: u64 = !s_737_43;
        // D s_737_46: and s_737_38 s_737_45
        let s_737_46: u64 = ((s_737_38) & (s_737_45));
        // D s_737_47: select s_737_42 s_737_44 s_737_46
        let s_737_47: u64 = if s_737_42 { s_737_44 } else { s_737_46 };
        // D s_737_48: cast trunc s_737_47 -> u8
        let s_737_48: bool = ((s_737_47) != 0);
        // D s_737_49: cast zx s_737_48 -> bv
        let s_737_49: Bits = Bits::new(s_737_48 as u128, 1u16);
        // C s_737_50: const #1u : u8
        let s_737_50: bool = true;
        // C s_737_51: cast zx s_737_50 -> bv
        let s_737_51: Bits = Bits::new(s_737_50 as u128, 1u16);
        // D s_737_52: cmp-ne s_737_49 s_737_51
        let s_737_52: bool = ((s_737_49) != (s_737_51));
        // N s_737_53: branch s_737_52 b748 b738
        if s_737_52 {
            return block_748(state, tracer, fn_state);
        } else {
            return block_738(state, tracer, fn_state);
        };
    }
    fn block_738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_738_0: const #9s : i
        let s_738_0: i128 = 9;
        // D s_738_1: read-var u#33744:u32
        let s_738_1: u32 = fn_state.u_33744;
        // D s_738_2: cast zx s_738_1 -> bv
        let s_738_2: Bits = Bits::new(s_738_1 as u128, 32u16);
        // C s_738_3: const #1u : u64
        let s_738_3: u64 = 1;
        // D s_738_4: bit-extract s_738_2 s_738_0 s_738_3
        let s_738_4: Bits = (Bits::new(
            ((s_738_2) >> (s_738_0)).value(),
            u16::try_from(s_738_3).unwrap(),
        ));
        // D s_738_5: cast reint s_738_4 -> u8
        let s_738_5: bool = ((s_738_4.value()) != 0);
        // C s_738_6: const #0s : i
        let s_738_6: i128 = 0;
        // C s_738_7: const #0u : u64
        let s_738_7: u64 = 0;
        // D s_738_8: cast zx s_738_5 -> u64
        let s_738_8: u64 = (s_738_5 as u64);
        // C s_738_9: const #1u : u64
        let s_738_9: u64 = 1;
        // D s_738_10: and s_738_8 s_738_9
        let s_738_10: u64 = ((s_738_8) & (s_738_9));
        // D s_738_11: cmp-eq s_738_10 s_738_9
        let s_738_11: bool = ((s_738_10) == (s_738_9));
        // D s_738_12: lsl s_738_8 s_738_6
        let s_738_12: u64 = s_738_8 << s_738_6;
        // D s_738_13: or s_738_7 s_738_12
        let s_738_13: u64 = ((s_738_7) | (s_738_12));
        // D s_738_14: cmpl s_738_12
        let s_738_14: u64 = !s_738_12;
        // D s_738_15: and s_738_7 s_738_14
        let s_738_15: u64 = ((s_738_7) & (s_738_14));
        // D s_738_16: select s_738_11 s_738_13 s_738_15
        let s_738_16: u64 = if s_738_11 { s_738_13 } else { s_738_15 };
        // D s_738_17: cast trunc s_738_16 -> u8
        let s_738_17: bool = ((s_738_16) != 0);
        // D s_738_18: cast zx s_738_17 -> bv
        let s_738_18: Bits = Bits::new(s_738_17 as u128, 1u16);
        // C s_738_19: const #1u : u8
        let s_738_19: bool = true;
        // C s_738_20: cast zx s_738_19 -> bv
        let s_738_20: Bits = Bits::new(s_738_19 as u128, 1u16);
        // D s_738_21: cmp-ne s_738_18 s_738_20
        let s_738_21: bool = ((s_738_18) != (s_738_20));
        // D s_738_22: write-var gs#410733 <= s_738_21
        fn_state.gs_410733 = s_738_21;
        // N s_738_23: jump b739
        return block_739(state, tracer, fn_state);
    }
    fn block_739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_739_0: read-var gs#410733:u8
        let s_739_0: bool = fn_state.gs_410733;
        // N s_739_1: branch s_739_0 b747 b740
        if s_739_0 {
            return block_747(state, tracer, fn_state);
        } else {
            return block_740(state, tracer, fn_state);
        };
    }
    fn block_740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_740_0: const #10s : i
        let s_740_0: i128 = 10;
        // D s_740_1: read-var u#33744:u32
        let s_740_1: u32 = fn_state.u_33744;
        // D s_740_2: cast zx s_740_1 -> bv
        let s_740_2: Bits = Bits::new(s_740_1 as u128, 32u16);
        // C s_740_3: const #1u : u64
        let s_740_3: u64 = 1;
        // D s_740_4: bit-extract s_740_2 s_740_0 s_740_3
        let s_740_4: Bits = (Bits::new(
            ((s_740_2) >> (s_740_0)).value(),
            u16::try_from(s_740_3).unwrap(),
        ));
        // D s_740_5: cast reint s_740_4 -> u8
        let s_740_5: bool = ((s_740_4.value()) != 0);
        // C s_740_6: const #0s : i
        let s_740_6: i128 = 0;
        // C s_740_7: const #0u : u64
        let s_740_7: u64 = 0;
        // D s_740_8: cast zx s_740_5 -> u64
        let s_740_8: u64 = (s_740_5 as u64);
        // C s_740_9: const #1u : u64
        let s_740_9: u64 = 1;
        // D s_740_10: and s_740_8 s_740_9
        let s_740_10: u64 = ((s_740_8) & (s_740_9));
        // D s_740_11: cmp-eq s_740_10 s_740_9
        let s_740_11: bool = ((s_740_10) == (s_740_9));
        // D s_740_12: lsl s_740_8 s_740_6
        let s_740_12: u64 = s_740_8 << s_740_6;
        // D s_740_13: or s_740_7 s_740_12
        let s_740_13: u64 = ((s_740_7) | (s_740_12));
        // D s_740_14: cmpl s_740_12
        let s_740_14: u64 = !s_740_12;
        // D s_740_15: and s_740_7 s_740_14
        let s_740_15: u64 = ((s_740_7) & (s_740_14));
        // D s_740_16: select s_740_11 s_740_13 s_740_15
        let s_740_16: u64 = if s_740_11 { s_740_13 } else { s_740_15 };
        // D s_740_17: cast trunc s_740_16 -> u8
        let s_740_17: bool = ((s_740_16) != 0);
        // D s_740_18: cast zx s_740_17 -> bv
        let s_740_18: Bits = Bits::new(s_740_17 as u128, 1u16);
        // C s_740_19: const #1u : u8
        let s_740_19: bool = true;
        // C s_740_20: cast zx s_740_19 -> bv
        let s_740_20: Bits = Bits::new(s_740_19 as u128, 1u16);
        // D s_740_21: cmp-ne s_740_18 s_740_20
        let s_740_21: bool = ((s_740_18) != (s_740_20));
        // D s_740_22: write-var gs#410736 <= s_740_21
        fn_state.gs_410736 = s_740_21;
        // N s_740_23: jump b741
        return block_741(state, tracer, fn_state);
    }
    fn block_741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_741_0: read-var gs#410736:u8
        let s_741_0: bool = fn_state.gs_410736;
        // N s_741_1: branch s_741_0 b746 b742
        if s_741_0 {
            return block_746(state, tracer, fn_state);
        } else {
            return block_742(state, tracer, fn_state);
        };
    }
    fn block_742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_742_0: const #11s : i
        let s_742_0: i128 = 11;
        // D s_742_1: read-var u#33744:u32
        let s_742_1: u32 = fn_state.u_33744;
        // D s_742_2: cast zx s_742_1 -> bv
        let s_742_2: Bits = Bits::new(s_742_1 as u128, 32u16);
        // C s_742_3: const #1u : u64
        let s_742_3: u64 = 1;
        // D s_742_4: bit-extract s_742_2 s_742_0 s_742_3
        let s_742_4: Bits = (Bits::new(
            ((s_742_2) >> (s_742_0)).value(),
            u16::try_from(s_742_3).unwrap(),
        ));
        // D s_742_5: cast reint s_742_4 -> u8
        let s_742_5: bool = ((s_742_4.value()) != 0);
        // C s_742_6: const #0s : i
        let s_742_6: i128 = 0;
        // C s_742_7: const #0u : u64
        let s_742_7: u64 = 0;
        // D s_742_8: cast zx s_742_5 -> u64
        let s_742_8: u64 = (s_742_5 as u64);
        // C s_742_9: const #1u : u64
        let s_742_9: u64 = 1;
        // D s_742_10: and s_742_8 s_742_9
        let s_742_10: u64 = ((s_742_8) & (s_742_9));
        // D s_742_11: cmp-eq s_742_10 s_742_9
        let s_742_11: bool = ((s_742_10) == (s_742_9));
        // D s_742_12: lsl s_742_8 s_742_6
        let s_742_12: u64 = s_742_8 << s_742_6;
        // D s_742_13: or s_742_7 s_742_12
        let s_742_13: u64 = ((s_742_7) | (s_742_12));
        // D s_742_14: cmpl s_742_12
        let s_742_14: u64 = !s_742_12;
        // D s_742_15: and s_742_7 s_742_14
        let s_742_15: u64 = ((s_742_7) & (s_742_14));
        // D s_742_16: select s_742_11 s_742_13 s_742_15
        let s_742_16: u64 = if s_742_11 { s_742_13 } else { s_742_15 };
        // D s_742_17: cast trunc s_742_16 -> u8
        let s_742_17: bool = ((s_742_16) != 0);
        // D s_742_18: cast zx s_742_17 -> bv
        let s_742_18: Bits = Bits::new(s_742_17 as u128, 1u16);
        // C s_742_19: const #1u : u8
        let s_742_19: bool = true;
        // C s_742_20: cast zx s_742_19 -> bv
        let s_742_20: Bits = Bits::new(s_742_19 as u128, 1u16);
        // D s_742_21: cmp-ne s_742_18 s_742_20
        let s_742_21: bool = ((s_742_18) != (s_742_20));
        // D s_742_22: write-var gs#410739 <= s_742_21
        fn_state.gs_410739 = s_742_21;
        // N s_742_23: jump b743
        return block_743(state, tracer, fn_state);
    }
    fn block_743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_743_0: read-var gs#410739:u8
        let s_743_0: bool = fn_state.gs_410739;
        // N s_743_1: branch s_743_0 b745 b744
        if s_743_0 {
            return block_745(state, tracer, fn_state);
        } else {
            return block_744(state, tracer, fn_state);
        };
    }
    fn block_744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_744_0: read-var u#33745:u8
        let s_744_0: u8 = fn_state.u_33745;
        // D s_744_1: read-var u#33746:u8
        let s_744_1: u8 = fn_state.u_33746;
        // D s_744_2: read-var u#33747:u8
        let s_744_2: u8 = fn_state.u_33747;
        // D s_744_3: read-var u#33748:u8
        let s_744_3: u8 = fn_state.u_33748;
        // D s_744_4: call decode_aarch32_instrs_UHSAX_A1enc_A_txt(s_744_0, s_744_1, s_744_2, s_744_3)
        let s_744_4: () = decode_aarch32_instrs_UHSAX_A1enc_A_txt(
            state,
            tracer,
            s_744_0,
            s_744_1,
            s_744_2,
            s_744_3,
        );
        // N s_744_5: return
        return;
    }
    fn block_745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_745_0: panic
        panic!("{:?}", ());
        // N s_745_1: return
        return;
    }
    fn block_746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_746_0: const #1u : u8
        let s_746_0: bool = true;
        // D s_746_1: write-var gs#410739 <= s_746_0
        fn_state.gs_410739 = s_746_0;
        // N s_746_2: jump b743
        return block_743(state, tracer, fn_state);
    }
    fn block_747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_747_0: const #1u : u8
        let s_747_0: bool = true;
        // D s_747_1: write-var gs#410736 <= s_747_0
        fn_state.gs_410736 = s_747_0;
        // N s_747_2: jump b741
        return block_741(state, tracer, fn_state);
    }
    fn block_748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_748_0: const #1u : u8
        let s_748_0: bool = true;
        // D s_748_1: write-var gs#410733 <= s_748_0
        fn_state.gs_410733 = s_748_0;
        // N s_748_2: jump b739
        return block_739(state, tracer, fn_state);
    }
    fn block_749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_749_0: read-var merge#var.1:struct
        let s_749_0: u32 = fn_state.merge_var._1;
        // D s_749_1: write-var u#33750 <= s_749_0
        fn_state.u_33750 = s_749_0;
        // C s_749_2: const #20s : i
        let s_749_2: i128 = 20;
        // D s_749_3: read-var u#33750:u32
        let s_749_3: u32 = fn_state.u_33750;
        // D s_749_4: cast zx s_749_3 -> bv
        let s_749_4: Bits = Bits::new(s_749_3 as u128, 32u16);
        // C s_749_5: const #1s : i64
        let s_749_5: i64 = 1;
        // C s_749_6: cast zx s_749_5 -> i
        let s_749_6: i128 = (i128::try_from(s_749_5).unwrap());
        // C s_749_7: const #7s : i
        let s_749_7: i128 = 7;
        // C s_749_8: add s_749_7 s_749_6
        let s_749_8: i128 = (s_749_7 + s_749_6);
        // D s_749_9: bit-extract s_749_4 s_749_2 s_749_8
        let s_749_9: Bits = (Bits::new(
            ((s_749_4) >> (s_749_2)).value(),
            u16::try_from(s_749_8).unwrap(),
        ));
        // D s_749_10: cast reint s_749_9 -> u8
        let s_749_10: u8 = (s_749_9.value() as u8);
        // D s_749_11: cast zx s_749_10 -> bv
        let s_749_11: Bits = Bits::new(s_749_10 as u128, 8u16);
        // C s_749_12: const #103u : u8
        let s_749_12: u8 = 103;
        // C s_749_13: cast zx s_749_12 -> bv
        let s_749_13: Bits = Bits::new(s_749_12 as u128, 8u16);
        // D s_749_14: cmp-eq s_749_11 s_749_13
        let s_749_14: bool = ((s_749_11) == (s_749_13));
        // N s_749_15: branch s_749_14 b1145 b750
        if s_749_14 {
            return block_1145(state, tracer, fn_state);
        } else {
            return block_750(state, tracer, fn_state);
        };
    }
    fn block_750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_750_0: const #0u : u8
        let s_750_0: bool = false;
        // D s_750_1: write-var gs#410745 <= s_750_0
        fn_state.gs_410745 = s_750_0;
        // N s_750_2: jump b751
        return block_751(state, tracer, fn_state);
    }
    fn block_751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_751_0: read-var gs#410745:u8
        let s_751_0: bool = fn_state.gs_410745;
        // N s_751_1: branch s_751_0 b1141 b752
        if s_751_0 {
            return block_1141(state, tracer, fn_state);
        } else {
            return block_752(state, tracer, fn_state);
        };
    }
    fn block_752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_752_0: const #0u : u8
        let s_752_0: bool = false;
        // D s_752_1: write-var gs#410750 <= s_752_0
        fn_state.gs_410750 = s_752_0;
        // N s_752_2: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_753_0: read-var gs#410750:u8
        let s_753_0: bool = fn_state.gs_410750;
        // D s_753_1: not s_753_0
        let s_753_1: bool = !s_753_0;
        // N s_753_2: branch s_753_1 b766 b754
        if s_753_1 {
            return block_766(state, tracer, fn_state);
        } else {
            return block_754(state, tracer, fn_state);
        };
    }
    fn block_754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_754_0: const #3300s : i
        let s_754_0: i128 = 3300;
        // C s_754_1: const #14696u : u32
        let s_754_1: u32 = 14696;
        // N s_754_2: write-reg s_754_1 <= s_754_0
        let s_754_2: () = {
            state.write_register::<i128>(s_754_1 as isize, s_754_0);
            tracer.write_register(s_754_1 as isize, s_754_0);
        };
        // C s_754_3: const #28s : i
        let s_754_3: i128 = 28;
        // C s_754_4: const #4s : i
        let s_754_4: i128 = 4;
        // D s_754_5: read-var u#33750:u32
        let s_754_5: u32 = fn_state.u_33750;
        // D s_754_6: cast zx s_754_5 -> bv
        let s_754_6: Bits = Bits::new(s_754_5 as u128, 32u16);
        // D s_754_7: bit-extract s_754_6 s_754_3 s_754_4
        let s_754_7: Bits = (Bits::new(
            ((s_754_6) >> (s_754_3)).value(),
            u16::try_from(s_754_4).unwrap(),
        ));
        // D s_754_8: cast reint s_754_7 -> u8
        let s_754_8: u8 = (s_754_7.value() as u8);
        // D s_754_9: write-var u#33751 <= s_754_8
        fn_state.u_33751 = s_754_8;
        // C s_754_10: const #16s : i
        let s_754_10: i128 = 16;
        // C s_754_11: const #4s : i
        let s_754_11: i128 = 4;
        // D s_754_12: read-var u#33750:u32
        let s_754_12: u32 = fn_state.u_33750;
        // D s_754_13: cast zx s_754_12 -> bv
        let s_754_13: Bits = Bits::new(s_754_12 as u128, 32u16);
        // D s_754_14: bit-extract s_754_13 s_754_10 s_754_11
        let s_754_14: Bits = (Bits::new(
            ((s_754_13) >> (s_754_10)).value(),
            u16::try_from(s_754_11).unwrap(),
        ));
        // D s_754_15: cast reint s_754_14 -> u8
        let s_754_15: u8 = (s_754_14.value() as u8);
        // D s_754_16: write-var u#33752 <= s_754_15
        fn_state.u_33752 = s_754_15;
        // C s_754_17: const #12s : i
        let s_754_17: i128 = 12;
        // C s_754_18: const #4s : i
        let s_754_18: i128 = 4;
        // D s_754_19: read-var u#33750:u32
        let s_754_19: u32 = fn_state.u_33750;
        // D s_754_20: cast zx s_754_19 -> bv
        let s_754_20: Bits = Bits::new(s_754_19 as u128, 32u16);
        // D s_754_21: bit-extract s_754_20 s_754_17 s_754_18
        let s_754_21: Bits = (Bits::new(
            ((s_754_20) >> (s_754_17)).value(),
            u16::try_from(s_754_18).unwrap(),
        ));
        // D s_754_22: cast reint s_754_21 -> u8
        let s_754_22: u8 = (s_754_21.value() as u8);
        // D s_754_23: write-var u#33753 <= s_754_22
        fn_state.u_33753 = s_754_22;
        // C s_754_24: const #0s : i
        let s_754_24: i128 = 0;
        // C s_754_25: const #4s : i
        let s_754_25: i128 = 4;
        // D s_754_26: read-var u#33750:u32
        let s_754_26: u32 = fn_state.u_33750;
        // D s_754_27: cast zx s_754_26 -> bv
        let s_754_27: Bits = Bits::new(s_754_26 as u128, 32u16);
        // D s_754_28: bit-extract s_754_27 s_754_24 s_754_25
        let s_754_28: Bits = (Bits::new(
            ((s_754_27) >> (s_754_24)).value(),
            u16::try_from(s_754_25).unwrap(),
        ));
        // D s_754_29: cast reint s_754_28 -> u8
        let s_754_29: u8 = (s_754_28.value() as u8);
        // D s_754_30: write-var u#33754 <= s_754_29
        fn_state.u_33754 = s_754_29;
        // C s_754_31: const #8s : i
        let s_754_31: i128 = 8;
        // D s_754_32: read-var u#33750:u32
        let s_754_32: u32 = fn_state.u_33750;
        // D s_754_33: cast zx s_754_32 -> bv
        let s_754_33: Bits = Bits::new(s_754_32 as u128, 32u16);
        // C s_754_34: const #1u : u64
        let s_754_34: u64 = 1;
        // D s_754_35: bit-extract s_754_33 s_754_31 s_754_34
        let s_754_35: Bits = (Bits::new(
            ((s_754_33) >> (s_754_31)).value(),
            u16::try_from(s_754_34).unwrap(),
        ));
        // D s_754_36: cast reint s_754_35 -> u8
        let s_754_36: bool = ((s_754_35.value()) != 0);
        // C s_754_37: const #0s : i
        let s_754_37: i128 = 0;
        // C s_754_38: const #0u : u64
        let s_754_38: u64 = 0;
        // D s_754_39: cast zx s_754_36 -> u64
        let s_754_39: u64 = (s_754_36 as u64);
        // C s_754_40: const #1u : u64
        let s_754_40: u64 = 1;
        // D s_754_41: and s_754_39 s_754_40
        let s_754_41: u64 = ((s_754_39) & (s_754_40));
        // D s_754_42: cmp-eq s_754_41 s_754_40
        let s_754_42: bool = ((s_754_41) == (s_754_40));
        // D s_754_43: lsl s_754_39 s_754_37
        let s_754_43: u64 = s_754_39 << s_754_37;
        // D s_754_44: or s_754_38 s_754_43
        let s_754_44: u64 = ((s_754_38) | (s_754_43));
        // D s_754_45: cmpl s_754_43
        let s_754_45: u64 = !s_754_43;
        // D s_754_46: and s_754_38 s_754_45
        let s_754_46: u64 = ((s_754_38) & (s_754_45));
        // D s_754_47: select s_754_42 s_754_44 s_754_46
        let s_754_47: u64 = if s_754_42 { s_754_44 } else { s_754_46 };
        // D s_754_48: cast trunc s_754_47 -> u8
        let s_754_48: bool = ((s_754_47) != 0);
        // D s_754_49: cast zx s_754_48 -> bv
        let s_754_49: Bits = Bits::new(s_754_48 as u128, 1u16);
        // C s_754_50: const #1u : u8
        let s_754_50: bool = true;
        // C s_754_51: cast zx s_754_50 -> bv
        let s_754_51: Bits = Bits::new(s_754_50 as u128, 1u16);
        // D s_754_52: cmp-ne s_754_49 s_754_51
        let s_754_52: bool = ((s_754_49) != (s_754_51));
        // N s_754_53: branch s_754_52 b765 b755
        if s_754_52 {
            return block_765(state, tracer, fn_state);
        } else {
            return block_755(state, tracer, fn_state);
        };
    }
    fn block_755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_755_0: const #9s : i
        let s_755_0: i128 = 9;
        // D s_755_1: read-var u#33750:u32
        let s_755_1: u32 = fn_state.u_33750;
        // D s_755_2: cast zx s_755_1 -> bv
        let s_755_2: Bits = Bits::new(s_755_1 as u128, 32u16);
        // C s_755_3: const #1u : u64
        let s_755_3: u64 = 1;
        // D s_755_4: bit-extract s_755_2 s_755_0 s_755_3
        let s_755_4: Bits = (Bits::new(
            ((s_755_2) >> (s_755_0)).value(),
            u16::try_from(s_755_3).unwrap(),
        ));
        // D s_755_5: cast reint s_755_4 -> u8
        let s_755_5: bool = ((s_755_4.value()) != 0);
        // C s_755_6: const #0s : i
        let s_755_6: i128 = 0;
        // C s_755_7: const #0u : u64
        let s_755_7: u64 = 0;
        // D s_755_8: cast zx s_755_5 -> u64
        let s_755_8: u64 = (s_755_5 as u64);
        // C s_755_9: const #1u : u64
        let s_755_9: u64 = 1;
        // D s_755_10: and s_755_8 s_755_9
        let s_755_10: u64 = ((s_755_8) & (s_755_9));
        // D s_755_11: cmp-eq s_755_10 s_755_9
        let s_755_11: bool = ((s_755_10) == (s_755_9));
        // D s_755_12: lsl s_755_8 s_755_6
        let s_755_12: u64 = s_755_8 << s_755_6;
        // D s_755_13: or s_755_7 s_755_12
        let s_755_13: u64 = ((s_755_7) | (s_755_12));
        // D s_755_14: cmpl s_755_12
        let s_755_14: u64 = !s_755_12;
        // D s_755_15: and s_755_7 s_755_14
        let s_755_15: u64 = ((s_755_7) & (s_755_14));
        // D s_755_16: select s_755_11 s_755_13 s_755_15
        let s_755_16: u64 = if s_755_11 { s_755_13 } else { s_755_15 };
        // D s_755_17: cast trunc s_755_16 -> u8
        let s_755_17: bool = ((s_755_16) != 0);
        // D s_755_18: cast zx s_755_17 -> bv
        let s_755_18: Bits = Bits::new(s_755_17 as u128, 1u16);
        // C s_755_19: const #1u : u8
        let s_755_19: bool = true;
        // C s_755_20: cast zx s_755_19 -> bv
        let s_755_20: Bits = Bits::new(s_755_19 as u128, 1u16);
        // D s_755_21: cmp-ne s_755_18 s_755_20
        let s_755_21: bool = ((s_755_18) != (s_755_20));
        // D s_755_22: write-var gs#410765 <= s_755_21
        fn_state.gs_410765 = s_755_21;
        // N s_755_23: jump b756
        return block_756(state, tracer, fn_state);
    }
    fn block_756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_756_0: read-var gs#410765:u8
        let s_756_0: bool = fn_state.gs_410765;
        // N s_756_1: branch s_756_0 b764 b757
        if s_756_0 {
            return block_764(state, tracer, fn_state);
        } else {
            return block_757(state, tracer, fn_state);
        };
    }
    fn block_757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_757_0: const #10s : i
        let s_757_0: i128 = 10;
        // D s_757_1: read-var u#33750:u32
        let s_757_1: u32 = fn_state.u_33750;
        // D s_757_2: cast zx s_757_1 -> bv
        let s_757_2: Bits = Bits::new(s_757_1 as u128, 32u16);
        // C s_757_3: const #1u : u64
        let s_757_3: u64 = 1;
        // D s_757_4: bit-extract s_757_2 s_757_0 s_757_3
        let s_757_4: Bits = (Bits::new(
            ((s_757_2) >> (s_757_0)).value(),
            u16::try_from(s_757_3).unwrap(),
        ));
        // D s_757_5: cast reint s_757_4 -> u8
        let s_757_5: bool = ((s_757_4.value()) != 0);
        // C s_757_6: const #0s : i
        let s_757_6: i128 = 0;
        // C s_757_7: const #0u : u64
        let s_757_7: u64 = 0;
        // D s_757_8: cast zx s_757_5 -> u64
        let s_757_8: u64 = (s_757_5 as u64);
        // C s_757_9: const #1u : u64
        let s_757_9: u64 = 1;
        // D s_757_10: and s_757_8 s_757_9
        let s_757_10: u64 = ((s_757_8) & (s_757_9));
        // D s_757_11: cmp-eq s_757_10 s_757_9
        let s_757_11: bool = ((s_757_10) == (s_757_9));
        // D s_757_12: lsl s_757_8 s_757_6
        let s_757_12: u64 = s_757_8 << s_757_6;
        // D s_757_13: or s_757_7 s_757_12
        let s_757_13: u64 = ((s_757_7) | (s_757_12));
        // D s_757_14: cmpl s_757_12
        let s_757_14: u64 = !s_757_12;
        // D s_757_15: and s_757_7 s_757_14
        let s_757_15: u64 = ((s_757_7) & (s_757_14));
        // D s_757_16: select s_757_11 s_757_13 s_757_15
        let s_757_16: u64 = if s_757_11 { s_757_13 } else { s_757_15 };
        // D s_757_17: cast trunc s_757_16 -> u8
        let s_757_17: bool = ((s_757_16) != 0);
        // D s_757_18: cast zx s_757_17 -> bv
        let s_757_18: Bits = Bits::new(s_757_17 as u128, 1u16);
        // C s_757_19: const #1u : u8
        let s_757_19: bool = true;
        // C s_757_20: cast zx s_757_19 -> bv
        let s_757_20: Bits = Bits::new(s_757_19 as u128, 1u16);
        // D s_757_21: cmp-ne s_757_18 s_757_20
        let s_757_21: bool = ((s_757_18) != (s_757_20));
        // D s_757_22: write-var gs#410768 <= s_757_21
        fn_state.gs_410768 = s_757_21;
        // N s_757_23: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_758_0: read-var gs#410768:u8
        let s_758_0: bool = fn_state.gs_410768;
        // N s_758_1: branch s_758_0 b763 b759
        if s_758_0 {
            return block_763(state, tracer, fn_state);
        } else {
            return block_759(state, tracer, fn_state);
        };
    }
    fn block_759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_759_0: const #11s : i
        let s_759_0: i128 = 11;
        // D s_759_1: read-var u#33750:u32
        let s_759_1: u32 = fn_state.u_33750;
        // D s_759_2: cast zx s_759_1 -> bv
        let s_759_2: Bits = Bits::new(s_759_1 as u128, 32u16);
        // C s_759_3: const #1u : u64
        let s_759_3: u64 = 1;
        // D s_759_4: bit-extract s_759_2 s_759_0 s_759_3
        let s_759_4: Bits = (Bits::new(
            ((s_759_2) >> (s_759_0)).value(),
            u16::try_from(s_759_3).unwrap(),
        ));
        // D s_759_5: cast reint s_759_4 -> u8
        let s_759_5: bool = ((s_759_4.value()) != 0);
        // C s_759_6: const #0s : i
        let s_759_6: i128 = 0;
        // C s_759_7: const #0u : u64
        let s_759_7: u64 = 0;
        // D s_759_8: cast zx s_759_5 -> u64
        let s_759_8: u64 = (s_759_5 as u64);
        // C s_759_9: const #1u : u64
        let s_759_9: u64 = 1;
        // D s_759_10: and s_759_8 s_759_9
        let s_759_10: u64 = ((s_759_8) & (s_759_9));
        // D s_759_11: cmp-eq s_759_10 s_759_9
        let s_759_11: bool = ((s_759_10) == (s_759_9));
        // D s_759_12: lsl s_759_8 s_759_6
        let s_759_12: u64 = s_759_8 << s_759_6;
        // D s_759_13: or s_759_7 s_759_12
        let s_759_13: u64 = ((s_759_7) | (s_759_12));
        // D s_759_14: cmpl s_759_12
        let s_759_14: u64 = !s_759_12;
        // D s_759_15: and s_759_7 s_759_14
        let s_759_15: u64 = ((s_759_7) & (s_759_14));
        // D s_759_16: select s_759_11 s_759_13 s_759_15
        let s_759_16: u64 = if s_759_11 { s_759_13 } else { s_759_15 };
        // D s_759_17: cast trunc s_759_16 -> u8
        let s_759_17: bool = ((s_759_16) != 0);
        // D s_759_18: cast zx s_759_17 -> bv
        let s_759_18: Bits = Bits::new(s_759_17 as u128, 1u16);
        // C s_759_19: const #1u : u8
        let s_759_19: bool = true;
        // C s_759_20: cast zx s_759_19 -> bv
        let s_759_20: Bits = Bits::new(s_759_19 as u128, 1u16);
        // D s_759_21: cmp-ne s_759_18 s_759_20
        let s_759_21: bool = ((s_759_18) != (s_759_20));
        // D s_759_22: write-var gs#410771 <= s_759_21
        fn_state.gs_410771 = s_759_21;
        // N s_759_23: jump b760
        return block_760(state, tracer, fn_state);
    }
    fn block_760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_760_0: read-var gs#410771:u8
        let s_760_0: bool = fn_state.gs_410771;
        // N s_760_1: branch s_760_0 b762 b761
        if s_760_0 {
            return block_762(state, tracer, fn_state);
        } else {
            return block_761(state, tracer, fn_state);
        };
    }
    fn block_761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_761_0: read-var u#33751:u8
        let s_761_0: u8 = fn_state.u_33751;
        // D s_761_1: read-var u#33752:u8
        let s_761_1: u8 = fn_state.u_33752;
        // D s_761_2: read-var u#33753:u8
        let s_761_2: u8 = fn_state.u_33753;
        // D s_761_3: read-var u#33754:u8
        let s_761_3: u8 = fn_state.u_33754;
        // D s_761_4: call decode_aarch32_instrs_UHSUB16_A1enc_A_txt(s_761_0, s_761_1, s_761_2, s_761_3)
        let s_761_4: () = decode_aarch32_instrs_UHSUB16_A1enc_A_txt(
            state,
            tracer,
            s_761_0,
            s_761_1,
            s_761_2,
            s_761_3,
        );
        // N s_761_5: return
        return;
    }
    fn block_762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_762_0: panic
        panic!("{:?}", ());
        // N s_762_1: return
        return;
    }
    fn block_763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_763_0: const #1u : u8
        let s_763_0: bool = true;
        // D s_763_1: write-var gs#410771 <= s_763_0
        fn_state.gs_410771 = s_763_0;
        // N s_763_2: jump b760
        return block_760(state, tracer, fn_state);
    }
    fn block_764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_764_0: const #1u : u8
        let s_764_0: bool = true;
        // D s_764_1: write-var gs#410768 <= s_764_0
        fn_state.gs_410768 = s_764_0;
        // N s_764_2: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_765_0: const #1u : u8
        let s_765_0: bool = true;
        // D s_765_1: write-var gs#410765 <= s_765_0
        fn_state.gs_410765 = s_765_0;
        // N s_765_2: jump b756
        return block_756(state, tracer, fn_state);
    }
    fn block_766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_766_0: read-var merge#var.1:struct
        let s_766_0: u32 = fn_state.merge_var._1;
        // D s_766_1: write-var u#33756 <= s_766_0
        fn_state.u_33756 = s_766_0;
        // C s_766_2: const #20s : i
        let s_766_2: i128 = 20;
        // D s_766_3: read-var u#33756:u32
        let s_766_3: u32 = fn_state.u_33756;
        // D s_766_4: cast zx s_766_3 -> bv
        let s_766_4: Bits = Bits::new(s_766_3 as u128, 32u16);
        // C s_766_5: const #1s : i64
        let s_766_5: i64 = 1;
        // C s_766_6: cast zx s_766_5 -> i
        let s_766_6: i128 = (i128::try_from(s_766_5).unwrap());
        // C s_766_7: const #7s : i
        let s_766_7: i128 = 7;
        // C s_766_8: add s_766_7 s_766_6
        let s_766_8: i128 = (s_766_7 + s_766_6);
        // D s_766_9: bit-extract s_766_4 s_766_2 s_766_8
        let s_766_9: Bits = (Bits::new(
            ((s_766_4) >> (s_766_2)).value(),
            u16::try_from(s_766_8).unwrap(),
        ));
        // D s_766_10: cast reint s_766_9 -> u8
        let s_766_10: u8 = (s_766_9.value() as u8);
        // D s_766_11: cast zx s_766_10 -> bv
        let s_766_11: Bits = Bits::new(s_766_10 as u128, 8u16);
        // C s_766_12: const #103u : u8
        let s_766_12: u8 = 103;
        // C s_766_13: cast zx s_766_12 -> bv
        let s_766_13: Bits = Bits::new(s_766_12 as u128, 8u16);
        // D s_766_14: cmp-eq s_766_11 s_766_13
        let s_766_14: bool = ((s_766_11) == (s_766_13));
        // N s_766_15: branch s_766_14 b1140 b767
        if s_766_14 {
            return block_1140(state, tracer, fn_state);
        } else {
            return block_767(state, tracer, fn_state);
        };
    }
    fn block_767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_767_0: const #0u : u8
        let s_767_0: bool = false;
        // D s_767_1: write-var gs#410777 <= s_767_0
        fn_state.gs_410777 = s_767_0;
        // N s_767_2: jump b768
        return block_768(state, tracer, fn_state);
    }
    fn block_768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_768_0: read-var gs#410777:u8
        let s_768_0: bool = fn_state.gs_410777;
        // N s_768_1: branch s_768_0 b1136 b769
        if s_768_0 {
            return block_1136(state, tracer, fn_state);
        } else {
            return block_769(state, tracer, fn_state);
        };
    }
    fn block_769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_769_0: const #0u : u8
        let s_769_0: bool = false;
        // D s_769_1: write-var gs#410782 <= s_769_0
        fn_state.gs_410782 = s_769_0;
        // N s_769_2: jump b770
        return block_770(state, tracer, fn_state);
    }
    fn block_770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_770_0: read-var gs#410782:u8
        let s_770_0: bool = fn_state.gs_410782;
        // D s_770_1: not s_770_0
        let s_770_1: bool = !s_770_0;
        // N s_770_2: branch s_770_1 b783 b771
        if s_770_1 {
            return block_783(state, tracer, fn_state);
        } else {
            return block_771(state, tracer, fn_state);
        };
    }
    fn block_771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_771_0: const #3302s : i
        let s_771_0: i128 = 3302;
        // C s_771_1: const #14696u : u32
        let s_771_1: u32 = 14696;
        // N s_771_2: write-reg s_771_1 <= s_771_0
        let s_771_2: () = {
            state.write_register::<i128>(s_771_1 as isize, s_771_0);
            tracer.write_register(s_771_1 as isize, s_771_0);
        };
        // C s_771_3: const #28s : i
        let s_771_3: i128 = 28;
        // C s_771_4: const #4s : i
        let s_771_4: i128 = 4;
        // D s_771_5: read-var u#33756:u32
        let s_771_5: u32 = fn_state.u_33756;
        // D s_771_6: cast zx s_771_5 -> bv
        let s_771_6: Bits = Bits::new(s_771_5 as u128, 32u16);
        // D s_771_7: bit-extract s_771_6 s_771_3 s_771_4
        let s_771_7: Bits = (Bits::new(
            ((s_771_6) >> (s_771_3)).value(),
            u16::try_from(s_771_4).unwrap(),
        ));
        // D s_771_8: cast reint s_771_7 -> u8
        let s_771_8: u8 = (s_771_7.value() as u8);
        // D s_771_9: write-var u#33757 <= s_771_8
        fn_state.u_33757 = s_771_8;
        // C s_771_10: const #16s : i
        let s_771_10: i128 = 16;
        // C s_771_11: const #4s : i
        let s_771_11: i128 = 4;
        // D s_771_12: read-var u#33756:u32
        let s_771_12: u32 = fn_state.u_33756;
        // D s_771_13: cast zx s_771_12 -> bv
        let s_771_13: Bits = Bits::new(s_771_12 as u128, 32u16);
        // D s_771_14: bit-extract s_771_13 s_771_10 s_771_11
        let s_771_14: Bits = (Bits::new(
            ((s_771_13) >> (s_771_10)).value(),
            u16::try_from(s_771_11).unwrap(),
        ));
        // D s_771_15: cast reint s_771_14 -> u8
        let s_771_15: u8 = (s_771_14.value() as u8);
        // D s_771_16: write-var u#33758 <= s_771_15
        fn_state.u_33758 = s_771_15;
        // C s_771_17: const #12s : i
        let s_771_17: i128 = 12;
        // C s_771_18: const #4s : i
        let s_771_18: i128 = 4;
        // D s_771_19: read-var u#33756:u32
        let s_771_19: u32 = fn_state.u_33756;
        // D s_771_20: cast zx s_771_19 -> bv
        let s_771_20: Bits = Bits::new(s_771_19 as u128, 32u16);
        // D s_771_21: bit-extract s_771_20 s_771_17 s_771_18
        let s_771_21: Bits = (Bits::new(
            ((s_771_20) >> (s_771_17)).value(),
            u16::try_from(s_771_18).unwrap(),
        ));
        // D s_771_22: cast reint s_771_21 -> u8
        let s_771_22: u8 = (s_771_21.value() as u8);
        // D s_771_23: write-var u#33759 <= s_771_22
        fn_state.u_33759 = s_771_22;
        // C s_771_24: const #0s : i
        let s_771_24: i128 = 0;
        // C s_771_25: const #4s : i
        let s_771_25: i128 = 4;
        // D s_771_26: read-var u#33756:u32
        let s_771_26: u32 = fn_state.u_33756;
        // D s_771_27: cast zx s_771_26 -> bv
        let s_771_27: Bits = Bits::new(s_771_26 as u128, 32u16);
        // D s_771_28: bit-extract s_771_27 s_771_24 s_771_25
        let s_771_28: Bits = (Bits::new(
            ((s_771_27) >> (s_771_24)).value(),
            u16::try_from(s_771_25).unwrap(),
        ));
        // D s_771_29: cast reint s_771_28 -> u8
        let s_771_29: u8 = (s_771_28.value() as u8);
        // D s_771_30: write-var u#33760 <= s_771_29
        fn_state.u_33760 = s_771_29;
        // C s_771_31: const #8s : i
        let s_771_31: i128 = 8;
        // D s_771_32: read-var u#33756:u32
        let s_771_32: u32 = fn_state.u_33756;
        // D s_771_33: cast zx s_771_32 -> bv
        let s_771_33: Bits = Bits::new(s_771_32 as u128, 32u16);
        // C s_771_34: const #1u : u64
        let s_771_34: u64 = 1;
        // D s_771_35: bit-extract s_771_33 s_771_31 s_771_34
        let s_771_35: Bits = (Bits::new(
            ((s_771_33) >> (s_771_31)).value(),
            u16::try_from(s_771_34).unwrap(),
        ));
        // D s_771_36: cast reint s_771_35 -> u8
        let s_771_36: bool = ((s_771_35.value()) != 0);
        // C s_771_37: const #0s : i
        let s_771_37: i128 = 0;
        // C s_771_38: const #0u : u64
        let s_771_38: u64 = 0;
        // D s_771_39: cast zx s_771_36 -> u64
        let s_771_39: u64 = (s_771_36 as u64);
        // C s_771_40: const #1u : u64
        let s_771_40: u64 = 1;
        // D s_771_41: and s_771_39 s_771_40
        let s_771_41: u64 = ((s_771_39) & (s_771_40));
        // D s_771_42: cmp-eq s_771_41 s_771_40
        let s_771_42: bool = ((s_771_41) == (s_771_40));
        // D s_771_43: lsl s_771_39 s_771_37
        let s_771_43: u64 = s_771_39 << s_771_37;
        // D s_771_44: or s_771_38 s_771_43
        let s_771_44: u64 = ((s_771_38) | (s_771_43));
        // D s_771_45: cmpl s_771_43
        let s_771_45: u64 = !s_771_43;
        // D s_771_46: and s_771_38 s_771_45
        let s_771_46: u64 = ((s_771_38) & (s_771_45));
        // D s_771_47: select s_771_42 s_771_44 s_771_46
        let s_771_47: u64 = if s_771_42 { s_771_44 } else { s_771_46 };
        // D s_771_48: cast trunc s_771_47 -> u8
        let s_771_48: bool = ((s_771_47) != 0);
        // D s_771_49: cast zx s_771_48 -> bv
        let s_771_49: Bits = Bits::new(s_771_48 as u128, 1u16);
        // C s_771_50: const #1u : u8
        let s_771_50: bool = true;
        // C s_771_51: cast zx s_771_50 -> bv
        let s_771_51: Bits = Bits::new(s_771_50 as u128, 1u16);
        // D s_771_52: cmp-ne s_771_49 s_771_51
        let s_771_52: bool = ((s_771_49) != (s_771_51));
        // N s_771_53: branch s_771_52 b782 b772
        if s_771_52 {
            return block_782(state, tracer, fn_state);
        } else {
            return block_772(state, tracer, fn_state);
        };
    }
    fn block_772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_772_0: const #9s : i
        let s_772_0: i128 = 9;
        // D s_772_1: read-var u#33756:u32
        let s_772_1: u32 = fn_state.u_33756;
        // D s_772_2: cast zx s_772_1 -> bv
        let s_772_2: Bits = Bits::new(s_772_1 as u128, 32u16);
        // C s_772_3: const #1u : u64
        let s_772_3: u64 = 1;
        // D s_772_4: bit-extract s_772_2 s_772_0 s_772_3
        let s_772_4: Bits = (Bits::new(
            ((s_772_2) >> (s_772_0)).value(),
            u16::try_from(s_772_3).unwrap(),
        ));
        // D s_772_5: cast reint s_772_4 -> u8
        let s_772_5: bool = ((s_772_4.value()) != 0);
        // C s_772_6: const #0s : i
        let s_772_6: i128 = 0;
        // C s_772_7: const #0u : u64
        let s_772_7: u64 = 0;
        // D s_772_8: cast zx s_772_5 -> u64
        let s_772_8: u64 = (s_772_5 as u64);
        // C s_772_9: const #1u : u64
        let s_772_9: u64 = 1;
        // D s_772_10: and s_772_8 s_772_9
        let s_772_10: u64 = ((s_772_8) & (s_772_9));
        // D s_772_11: cmp-eq s_772_10 s_772_9
        let s_772_11: bool = ((s_772_10) == (s_772_9));
        // D s_772_12: lsl s_772_8 s_772_6
        let s_772_12: u64 = s_772_8 << s_772_6;
        // D s_772_13: or s_772_7 s_772_12
        let s_772_13: u64 = ((s_772_7) | (s_772_12));
        // D s_772_14: cmpl s_772_12
        let s_772_14: u64 = !s_772_12;
        // D s_772_15: and s_772_7 s_772_14
        let s_772_15: u64 = ((s_772_7) & (s_772_14));
        // D s_772_16: select s_772_11 s_772_13 s_772_15
        let s_772_16: u64 = if s_772_11 { s_772_13 } else { s_772_15 };
        // D s_772_17: cast trunc s_772_16 -> u8
        let s_772_17: bool = ((s_772_16) != 0);
        // D s_772_18: cast zx s_772_17 -> bv
        let s_772_18: Bits = Bits::new(s_772_17 as u128, 1u16);
        // C s_772_19: const #1u : u8
        let s_772_19: bool = true;
        // C s_772_20: cast zx s_772_19 -> bv
        let s_772_20: Bits = Bits::new(s_772_19 as u128, 1u16);
        // D s_772_21: cmp-ne s_772_18 s_772_20
        let s_772_21: bool = ((s_772_18) != (s_772_20));
        // D s_772_22: write-var gs#410797 <= s_772_21
        fn_state.gs_410797 = s_772_21;
        // N s_772_23: jump b773
        return block_773(state, tracer, fn_state);
    }
    fn block_773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_773_0: read-var gs#410797:u8
        let s_773_0: bool = fn_state.gs_410797;
        // N s_773_1: branch s_773_0 b781 b774
        if s_773_0 {
            return block_781(state, tracer, fn_state);
        } else {
            return block_774(state, tracer, fn_state);
        };
    }
    fn block_774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_774_0: const #10s : i
        let s_774_0: i128 = 10;
        // D s_774_1: read-var u#33756:u32
        let s_774_1: u32 = fn_state.u_33756;
        // D s_774_2: cast zx s_774_1 -> bv
        let s_774_2: Bits = Bits::new(s_774_1 as u128, 32u16);
        // C s_774_3: const #1u : u64
        let s_774_3: u64 = 1;
        // D s_774_4: bit-extract s_774_2 s_774_0 s_774_3
        let s_774_4: Bits = (Bits::new(
            ((s_774_2) >> (s_774_0)).value(),
            u16::try_from(s_774_3).unwrap(),
        ));
        // D s_774_5: cast reint s_774_4 -> u8
        let s_774_5: bool = ((s_774_4.value()) != 0);
        // C s_774_6: const #0s : i
        let s_774_6: i128 = 0;
        // C s_774_7: const #0u : u64
        let s_774_7: u64 = 0;
        // D s_774_8: cast zx s_774_5 -> u64
        let s_774_8: u64 = (s_774_5 as u64);
        // C s_774_9: const #1u : u64
        let s_774_9: u64 = 1;
        // D s_774_10: and s_774_8 s_774_9
        let s_774_10: u64 = ((s_774_8) & (s_774_9));
        // D s_774_11: cmp-eq s_774_10 s_774_9
        let s_774_11: bool = ((s_774_10) == (s_774_9));
        // D s_774_12: lsl s_774_8 s_774_6
        let s_774_12: u64 = s_774_8 << s_774_6;
        // D s_774_13: or s_774_7 s_774_12
        let s_774_13: u64 = ((s_774_7) | (s_774_12));
        // D s_774_14: cmpl s_774_12
        let s_774_14: u64 = !s_774_12;
        // D s_774_15: and s_774_7 s_774_14
        let s_774_15: u64 = ((s_774_7) & (s_774_14));
        // D s_774_16: select s_774_11 s_774_13 s_774_15
        let s_774_16: u64 = if s_774_11 { s_774_13 } else { s_774_15 };
        // D s_774_17: cast trunc s_774_16 -> u8
        let s_774_17: bool = ((s_774_16) != 0);
        // D s_774_18: cast zx s_774_17 -> bv
        let s_774_18: Bits = Bits::new(s_774_17 as u128, 1u16);
        // C s_774_19: const #1u : u8
        let s_774_19: bool = true;
        // C s_774_20: cast zx s_774_19 -> bv
        let s_774_20: Bits = Bits::new(s_774_19 as u128, 1u16);
        // D s_774_21: cmp-ne s_774_18 s_774_20
        let s_774_21: bool = ((s_774_18) != (s_774_20));
        // D s_774_22: write-var gs#410800 <= s_774_21
        fn_state.gs_410800 = s_774_21;
        // N s_774_23: jump b775
        return block_775(state, tracer, fn_state);
    }
    fn block_775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_775_0: read-var gs#410800:u8
        let s_775_0: bool = fn_state.gs_410800;
        // N s_775_1: branch s_775_0 b780 b776
        if s_775_0 {
            return block_780(state, tracer, fn_state);
        } else {
            return block_776(state, tracer, fn_state);
        };
    }
    fn block_776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_776_0: const #11s : i
        let s_776_0: i128 = 11;
        // D s_776_1: read-var u#33756:u32
        let s_776_1: u32 = fn_state.u_33756;
        // D s_776_2: cast zx s_776_1 -> bv
        let s_776_2: Bits = Bits::new(s_776_1 as u128, 32u16);
        // C s_776_3: const #1u : u64
        let s_776_3: u64 = 1;
        // D s_776_4: bit-extract s_776_2 s_776_0 s_776_3
        let s_776_4: Bits = (Bits::new(
            ((s_776_2) >> (s_776_0)).value(),
            u16::try_from(s_776_3).unwrap(),
        ));
        // D s_776_5: cast reint s_776_4 -> u8
        let s_776_5: bool = ((s_776_4.value()) != 0);
        // C s_776_6: const #0s : i
        let s_776_6: i128 = 0;
        // C s_776_7: const #0u : u64
        let s_776_7: u64 = 0;
        // D s_776_8: cast zx s_776_5 -> u64
        let s_776_8: u64 = (s_776_5 as u64);
        // C s_776_9: const #1u : u64
        let s_776_9: u64 = 1;
        // D s_776_10: and s_776_8 s_776_9
        let s_776_10: u64 = ((s_776_8) & (s_776_9));
        // D s_776_11: cmp-eq s_776_10 s_776_9
        let s_776_11: bool = ((s_776_10) == (s_776_9));
        // D s_776_12: lsl s_776_8 s_776_6
        let s_776_12: u64 = s_776_8 << s_776_6;
        // D s_776_13: or s_776_7 s_776_12
        let s_776_13: u64 = ((s_776_7) | (s_776_12));
        // D s_776_14: cmpl s_776_12
        let s_776_14: u64 = !s_776_12;
        // D s_776_15: and s_776_7 s_776_14
        let s_776_15: u64 = ((s_776_7) & (s_776_14));
        // D s_776_16: select s_776_11 s_776_13 s_776_15
        let s_776_16: u64 = if s_776_11 { s_776_13 } else { s_776_15 };
        // D s_776_17: cast trunc s_776_16 -> u8
        let s_776_17: bool = ((s_776_16) != 0);
        // D s_776_18: cast zx s_776_17 -> bv
        let s_776_18: Bits = Bits::new(s_776_17 as u128, 1u16);
        // C s_776_19: const #1u : u8
        let s_776_19: bool = true;
        // C s_776_20: cast zx s_776_19 -> bv
        let s_776_20: Bits = Bits::new(s_776_19 as u128, 1u16);
        // D s_776_21: cmp-ne s_776_18 s_776_20
        let s_776_21: bool = ((s_776_18) != (s_776_20));
        // D s_776_22: write-var gs#410803 <= s_776_21
        fn_state.gs_410803 = s_776_21;
        // N s_776_23: jump b777
        return block_777(state, tracer, fn_state);
    }
    fn block_777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_777_0: read-var gs#410803:u8
        let s_777_0: bool = fn_state.gs_410803;
        // N s_777_1: branch s_777_0 b779 b778
        if s_777_0 {
            return block_779(state, tracer, fn_state);
        } else {
            return block_778(state, tracer, fn_state);
        };
    }
    fn block_778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_778_0: read-var u#33757:u8
        let s_778_0: u8 = fn_state.u_33757;
        // D s_778_1: read-var u#33758:u8
        let s_778_1: u8 = fn_state.u_33758;
        // D s_778_2: read-var u#33759:u8
        let s_778_2: u8 = fn_state.u_33759;
        // D s_778_3: read-var u#33760:u8
        let s_778_3: u8 = fn_state.u_33760;
        // D s_778_4: call decode_aarch32_instrs_UHSUB8_A1enc_A_txt(s_778_0, s_778_1, s_778_2, s_778_3)
        let s_778_4: () = decode_aarch32_instrs_UHSUB8_A1enc_A_txt(
            state,
            tracer,
            s_778_0,
            s_778_1,
            s_778_2,
            s_778_3,
        );
        // N s_778_5: return
        return;
    }
    fn block_779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_779_0: panic
        panic!("{:?}", ());
        // N s_779_1: return
        return;
    }
    fn block_780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_780_0: const #1u : u8
        let s_780_0: bool = true;
        // D s_780_1: write-var gs#410803 <= s_780_0
        fn_state.gs_410803 = s_780_0;
        // N s_780_2: jump b777
        return block_777(state, tracer, fn_state);
    }
    fn block_781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_781_0: const #1u : u8
        let s_781_0: bool = true;
        // D s_781_1: write-var gs#410800 <= s_781_0
        fn_state.gs_410800 = s_781_0;
        // N s_781_2: jump b775
        return block_775(state, tracer, fn_state);
    }
    fn block_782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_782_0: const #1u : u8
        let s_782_0: bool = true;
        // D s_782_1: write-var gs#410797 <= s_782_0
        fn_state.gs_410797 = s_782_0;
        // N s_782_2: jump b773
        return block_773(state, tracer, fn_state);
    }
    fn block_783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_783_0: read-var merge#var.1:struct
        let s_783_0: u32 = fn_state.merge_var._1;
        // D s_783_1: write-var u#33762 <= s_783_0
        fn_state.u_33762 = s_783_0;
        // C s_783_2: const #20s : i
        let s_783_2: i128 = 20;
        // D s_783_3: read-var u#33762:u32
        let s_783_3: u32 = fn_state.u_33762;
        // D s_783_4: cast zx s_783_3 -> bv
        let s_783_4: Bits = Bits::new(s_783_3 as u128, 32u16);
        // C s_783_5: const #1s : i64
        let s_783_5: i64 = 1;
        // C s_783_6: cast zx s_783_5 -> i
        let s_783_6: i128 = (i128::try_from(s_783_5).unwrap());
        // C s_783_7: const #7s : i
        let s_783_7: i128 = 7;
        // C s_783_8: add s_783_7 s_783_6
        let s_783_8: i128 = (s_783_7 + s_783_6);
        // D s_783_9: bit-extract s_783_4 s_783_2 s_783_8
        let s_783_9: Bits = (Bits::new(
            ((s_783_4) >> (s_783_2)).value(),
            u16::try_from(s_783_8).unwrap(),
        ));
        // D s_783_10: cast reint s_783_9 -> u8
        let s_783_10: u8 = (s_783_9.value() as u8);
        // D s_783_11: cast zx s_783_10 -> bv
        let s_783_11: Bits = Bits::new(s_783_10 as u128, 8u16);
        // C s_783_12: const #102u : u8
        let s_783_12: u8 = 102;
        // C s_783_13: cast zx s_783_12 -> bv
        let s_783_13: Bits = Bits::new(s_783_12 as u128, 8u16);
        // D s_783_14: cmp-eq s_783_11 s_783_13
        let s_783_14: bool = ((s_783_11) == (s_783_13));
        // N s_783_15: branch s_783_14 b1135 b784
        if s_783_14 {
            return block_1135(state, tracer, fn_state);
        } else {
            return block_784(state, tracer, fn_state);
        };
    }
    fn block_784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_784_0: const #0u : u8
        let s_784_0: bool = false;
        // D s_784_1: write-var gs#410809 <= s_784_0
        fn_state.gs_410809 = s_784_0;
        // N s_784_2: jump b785
        return block_785(state, tracer, fn_state);
    }
    fn block_785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_785_0: read-var gs#410809:u8
        let s_785_0: bool = fn_state.gs_410809;
        // N s_785_1: branch s_785_0 b1131 b786
        if s_785_0 {
            return block_1131(state, tracer, fn_state);
        } else {
            return block_786(state, tracer, fn_state);
        };
    }
    fn block_786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_786_0: const #0u : u8
        let s_786_0: bool = false;
        // D s_786_1: write-var gs#410814 <= s_786_0
        fn_state.gs_410814 = s_786_0;
        // N s_786_2: jump b787
        return block_787(state, tracer, fn_state);
    }
    fn block_787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_787_0: read-var gs#410814:u8
        let s_787_0: bool = fn_state.gs_410814;
        // D s_787_1: not s_787_0
        let s_787_1: bool = !s_787_0;
        // N s_787_2: branch s_787_1 b800 b788
        if s_787_1 {
            return block_800(state, tracer, fn_state);
        } else {
            return block_788(state, tracer, fn_state);
        };
    }
    fn block_788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_788_0: const #3310s : i
        let s_788_0: i128 = 3310;
        // C s_788_1: const #14696u : u32
        let s_788_1: u32 = 14696;
        // N s_788_2: write-reg s_788_1 <= s_788_0
        let s_788_2: () = {
            state.write_register::<i128>(s_788_1 as isize, s_788_0);
            tracer.write_register(s_788_1 as isize, s_788_0);
        };
        // C s_788_3: const #28s : i
        let s_788_3: i128 = 28;
        // C s_788_4: const #4s : i
        let s_788_4: i128 = 4;
        // D s_788_5: read-var u#33762:u32
        let s_788_5: u32 = fn_state.u_33762;
        // D s_788_6: cast zx s_788_5 -> bv
        let s_788_6: Bits = Bits::new(s_788_5 as u128, 32u16);
        // D s_788_7: bit-extract s_788_6 s_788_3 s_788_4
        let s_788_7: Bits = (Bits::new(
            ((s_788_6) >> (s_788_3)).value(),
            u16::try_from(s_788_4).unwrap(),
        ));
        // D s_788_8: cast reint s_788_7 -> u8
        let s_788_8: u8 = (s_788_7.value() as u8);
        // D s_788_9: write-var u#33763 <= s_788_8
        fn_state.u_33763 = s_788_8;
        // C s_788_10: const #16s : i
        let s_788_10: i128 = 16;
        // C s_788_11: const #4s : i
        let s_788_11: i128 = 4;
        // D s_788_12: read-var u#33762:u32
        let s_788_12: u32 = fn_state.u_33762;
        // D s_788_13: cast zx s_788_12 -> bv
        let s_788_13: Bits = Bits::new(s_788_12 as u128, 32u16);
        // D s_788_14: bit-extract s_788_13 s_788_10 s_788_11
        let s_788_14: Bits = (Bits::new(
            ((s_788_13) >> (s_788_10)).value(),
            u16::try_from(s_788_11).unwrap(),
        ));
        // D s_788_15: cast reint s_788_14 -> u8
        let s_788_15: u8 = (s_788_14.value() as u8);
        // D s_788_16: write-var u#33764 <= s_788_15
        fn_state.u_33764 = s_788_15;
        // C s_788_17: const #12s : i
        let s_788_17: i128 = 12;
        // C s_788_18: const #4s : i
        let s_788_18: i128 = 4;
        // D s_788_19: read-var u#33762:u32
        let s_788_19: u32 = fn_state.u_33762;
        // D s_788_20: cast zx s_788_19 -> bv
        let s_788_20: Bits = Bits::new(s_788_19 as u128, 32u16);
        // D s_788_21: bit-extract s_788_20 s_788_17 s_788_18
        let s_788_21: Bits = (Bits::new(
            ((s_788_20) >> (s_788_17)).value(),
            u16::try_from(s_788_18).unwrap(),
        ));
        // D s_788_22: cast reint s_788_21 -> u8
        let s_788_22: u8 = (s_788_21.value() as u8);
        // D s_788_23: write-var u#33765 <= s_788_22
        fn_state.u_33765 = s_788_22;
        // C s_788_24: const #0s : i
        let s_788_24: i128 = 0;
        // C s_788_25: const #4s : i
        let s_788_25: i128 = 4;
        // D s_788_26: read-var u#33762:u32
        let s_788_26: u32 = fn_state.u_33762;
        // D s_788_27: cast zx s_788_26 -> bv
        let s_788_27: Bits = Bits::new(s_788_26 as u128, 32u16);
        // D s_788_28: bit-extract s_788_27 s_788_24 s_788_25
        let s_788_28: Bits = (Bits::new(
            ((s_788_27) >> (s_788_24)).value(),
            u16::try_from(s_788_25).unwrap(),
        ));
        // D s_788_29: cast reint s_788_28 -> u8
        let s_788_29: u8 = (s_788_28.value() as u8);
        // D s_788_30: write-var u#33766 <= s_788_29
        fn_state.u_33766 = s_788_29;
        // C s_788_31: const #8s : i
        let s_788_31: i128 = 8;
        // D s_788_32: read-var u#33762:u32
        let s_788_32: u32 = fn_state.u_33762;
        // D s_788_33: cast zx s_788_32 -> bv
        let s_788_33: Bits = Bits::new(s_788_32 as u128, 32u16);
        // C s_788_34: const #1u : u64
        let s_788_34: u64 = 1;
        // D s_788_35: bit-extract s_788_33 s_788_31 s_788_34
        let s_788_35: Bits = (Bits::new(
            ((s_788_33) >> (s_788_31)).value(),
            u16::try_from(s_788_34).unwrap(),
        ));
        // D s_788_36: cast reint s_788_35 -> u8
        let s_788_36: bool = ((s_788_35.value()) != 0);
        // C s_788_37: const #0s : i
        let s_788_37: i128 = 0;
        // C s_788_38: const #0u : u64
        let s_788_38: u64 = 0;
        // D s_788_39: cast zx s_788_36 -> u64
        let s_788_39: u64 = (s_788_36 as u64);
        // C s_788_40: const #1u : u64
        let s_788_40: u64 = 1;
        // D s_788_41: and s_788_39 s_788_40
        let s_788_41: u64 = ((s_788_39) & (s_788_40));
        // D s_788_42: cmp-eq s_788_41 s_788_40
        let s_788_42: bool = ((s_788_41) == (s_788_40));
        // D s_788_43: lsl s_788_39 s_788_37
        let s_788_43: u64 = s_788_39 << s_788_37;
        // D s_788_44: or s_788_38 s_788_43
        let s_788_44: u64 = ((s_788_38) | (s_788_43));
        // D s_788_45: cmpl s_788_43
        let s_788_45: u64 = !s_788_43;
        // D s_788_46: and s_788_38 s_788_45
        let s_788_46: u64 = ((s_788_38) & (s_788_45));
        // D s_788_47: select s_788_42 s_788_44 s_788_46
        let s_788_47: u64 = if s_788_42 { s_788_44 } else { s_788_46 };
        // D s_788_48: cast trunc s_788_47 -> u8
        let s_788_48: bool = ((s_788_47) != 0);
        // D s_788_49: cast zx s_788_48 -> bv
        let s_788_49: Bits = Bits::new(s_788_48 as u128, 1u16);
        // C s_788_50: const #1u : u8
        let s_788_50: bool = true;
        // C s_788_51: cast zx s_788_50 -> bv
        let s_788_51: Bits = Bits::new(s_788_50 as u128, 1u16);
        // D s_788_52: cmp-ne s_788_49 s_788_51
        let s_788_52: bool = ((s_788_49) != (s_788_51));
        // N s_788_53: branch s_788_52 b799 b789
        if s_788_52 {
            return block_799(state, tracer, fn_state);
        } else {
            return block_789(state, tracer, fn_state);
        };
    }
    fn block_789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_789_0: const #9s : i
        let s_789_0: i128 = 9;
        // D s_789_1: read-var u#33762:u32
        let s_789_1: u32 = fn_state.u_33762;
        // D s_789_2: cast zx s_789_1 -> bv
        let s_789_2: Bits = Bits::new(s_789_1 as u128, 32u16);
        // C s_789_3: const #1u : u64
        let s_789_3: u64 = 1;
        // D s_789_4: bit-extract s_789_2 s_789_0 s_789_3
        let s_789_4: Bits = (Bits::new(
            ((s_789_2) >> (s_789_0)).value(),
            u16::try_from(s_789_3).unwrap(),
        ));
        // D s_789_5: cast reint s_789_4 -> u8
        let s_789_5: bool = ((s_789_4.value()) != 0);
        // C s_789_6: const #0s : i
        let s_789_6: i128 = 0;
        // C s_789_7: const #0u : u64
        let s_789_7: u64 = 0;
        // D s_789_8: cast zx s_789_5 -> u64
        let s_789_8: u64 = (s_789_5 as u64);
        // C s_789_9: const #1u : u64
        let s_789_9: u64 = 1;
        // D s_789_10: and s_789_8 s_789_9
        let s_789_10: u64 = ((s_789_8) & (s_789_9));
        // D s_789_11: cmp-eq s_789_10 s_789_9
        let s_789_11: bool = ((s_789_10) == (s_789_9));
        // D s_789_12: lsl s_789_8 s_789_6
        let s_789_12: u64 = s_789_8 << s_789_6;
        // D s_789_13: or s_789_7 s_789_12
        let s_789_13: u64 = ((s_789_7) | (s_789_12));
        // D s_789_14: cmpl s_789_12
        let s_789_14: u64 = !s_789_12;
        // D s_789_15: and s_789_7 s_789_14
        let s_789_15: u64 = ((s_789_7) & (s_789_14));
        // D s_789_16: select s_789_11 s_789_13 s_789_15
        let s_789_16: u64 = if s_789_11 { s_789_13 } else { s_789_15 };
        // D s_789_17: cast trunc s_789_16 -> u8
        let s_789_17: bool = ((s_789_16) != 0);
        // D s_789_18: cast zx s_789_17 -> bv
        let s_789_18: Bits = Bits::new(s_789_17 as u128, 1u16);
        // C s_789_19: const #1u : u8
        let s_789_19: bool = true;
        // C s_789_20: cast zx s_789_19 -> bv
        let s_789_20: Bits = Bits::new(s_789_19 as u128, 1u16);
        // D s_789_21: cmp-ne s_789_18 s_789_20
        let s_789_21: bool = ((s_789_18) != (s_789_20));
        // D s_789_22: write-var gs#410829 <= s_789_21
        fn_state.gs_410829 = s_789_21;
        // N s_789_23: jump b790
        return block_790(state, tracer, fn_state);
    }
    fn block_790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_790_0: read-var gs#410829:u8
        let s_790_0: bool = fn_state.gs_410829;
        // N s_790_1: branch s_790_0 b798 b791
        if s_790_0 {
            return block_798(state, tracer, fn_state);
        } else {
            return block_791(state, tracer, fn_state);
        };
    }
    fn block_791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_791_0: const #10s : i
        let s_791_0: i128 = 10;
        // D s_791_1: read-var u#33762:u32
        let s_791_1: u32 = fn_state.u_33762;
        // D s_791_2: cast zx s_791_1 -> bv
        let s_791_2: Bits = Bits::new(s_791_1 as u128, 32u16);
        // C s_791_3: const #1u : u64
        let s_791_3: u64 = 1;
        // D s_791_4: bit-extract s_791_2 s_791_0 s_791_3
        let s_791_4: Bits = (Bits::new(
            ((s_791_2) >> (s_791_0)).value(),
            u16::try_from(s_791_3).unwrap(),
        ));
        // D s_791_5: cast reint s_791_4 -> u8
        let s_791_5: bool = ((s_791_4.value()) != 0);
        // C s_791_6: const #0s : i
        let s_791_6: i128 = 0;
        // C s_791_7: const #0u : u64
        let s_791_7: u64 = 0;
        // D s_791_8: cast zx s_791_5 -> u64
        let s_791_8: u64 = (s_791_5 as u64);
        // C s_791_9: const #1u : u64
        let s_791_9: u64 = 1;
        // D s_791_10: and s_791_8 s_791_9
        let s_791_10: u64 = ((s_791_8) & (s_791_9));
        // D s_791_11: cmp-eq s_791_10 s_791_9
        let s_791_11: bool = ((s_791_10) == (s_791_9));
        // D s_791_12: lsl s_791_8 s_791_6
        let s_791_12: u64 = s_791_8 << s_791_6;
        // D s_791_13: or s_791_7 s_791_12
        let s_791_13: u64 = ((s_791_7) | (s_791_12));
        // D s_791_14: cmpl s_791_12
        let s_791_14: u64 = !s_791_12;
        // D s_791_15: and s_791_7 s_791_14
        let s_791_15: u64 = ((s_791_7) & (s_791_14));
        // D s_791_16: select s_791_11 s_791_13 s_791_15
        let s_791_16: u64 = if s_791_11 { s_791_13 } else { s_791_15 };
        // D s_791_17: cast trunc s_791_16 -> u8
        let s_791_17: bool = ((s_791_16) != 0);
        // D s_791_18: cast zx s_791_17 -> bv
        let s_791_18: Bits = Bits::new(s_791_17 as u128, 1u16);
        // C s_791_19: const #1u : u8
        let s_791_19: bool = true;
        // C s_791_20: cast zx s_791_19 -> bv
        let s_791_20: Bits = Bits::new(s_791_19 as u128, 1u16);
        // D s_791_21: cmp-ne s_791_18 s_791_20
        let s_791_21: bool = ((s_791_18) != (s_791_20));
        // D s_791_22: write-var gs#410832 <= s_791_21
        fn_state.gs_410832 = s_791_21;
        // N s_791_23: jump b792
        return block_792(state, tracer, fn_state);
    }
    fn block_792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_792_0: read-var gs#410832:u8
        let s_792_0: bool = fn_state.gs_410832;
        // N s_792_1: branch s_792_0 b797 b793
        if s_792_0 {
            return block_797(state, tracer, fn_state);
        } else {
            return block_793(state, tracer, fn_state);
        };
    }
    fn block_793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_793_0: const #11s : i
        let s_793_0: i128 = 11;
        // D s_793_1: read-var u#33762:u32
        let s_793_1: u32 = fn_state.u_33762;
        // D s_793_2: cast zx s_793_1 -> bv
        let s_793_2: Bits = Bits::new(s_793_1 as u128, 32u16);
        // C s_793_3: const #1u : u64
        let s_793_3: u64 = 1;
        // D s_793_4: bit-extract s_793_2 s_793_0 s_793_3
        let s_793_4: Bits = (Bits::new(
            ((s_793_2) >> (s_793_0)).value(),
            u16::try_from(s_793_3).unwrap(),
        ));
        // D s_793_5: cast reint s_793_4 -> u8
        let s_793_5: bool = ((s_793_4.value()) != 0);
        // C s_793_6: const #0s : i
        let s_793_6: i128 = 0;
        // C s_793_7: const #0u : u64
        let s_793_7: u64 = 0;
        // D s_793_8: cast zx s_793_5 -> u64
        let s_793_8: u64 = (s_793_5 as u64);
        // C s_793_9: const #1u : u64
        let s_793_9: u64 = 1;
        // D s_793_10: and s_793_8 s_793_9
        let s_793_10: u64 = ((s_793_8) & (s_793_9));
        // D s_793_11: cmp-eq s_793_10 s_793_9
        let s_793_11: bool = ((s_793_10) == (s_793_9));
        // D s_793_12: lsl s_793_8 s_793_6
        let s_793_12: u64 = s_793_8 << s_793_6;
        // D s_793_13: or s_793_7 s_793_12
        let s_793_13: u64 = ((s_793_7) | (s_793_12));
        // D s_793_14: cmpl s_793_12
        let s_793_14: u64 = !s_793_12;
        // D s_793_15: and s_793_7 s_793_14
        let s_793_15: u64 = ((s_793_7) & (s_793_14));
        // D s_793_16: select s_793_11 s_793_13 s_793_15
        let s_793_16: u64 = if s_793_11 { s_793_13 } else { s_793_15 };
        // D s_793_17: cast trunc s_793_16 -> u8
        let s_793_17: bool = ((s_793_16) != 0);
        // D s_793_18: cast zx s_793_17 -> bv
        let s_793_18: Bits = Bits::new(s_793_17 as u128, 1u16);
        // C s_793_19: const #1u : u8
        let s_793_19: bool = true;
        // C s_793_20: cast zx s_793_19 -> bv
        let s_793_20: Bits = Bits::new(s_793_19 as u128, 1u16);
        // D s_793_21: cmp-ne s_793_18 s_793_20
        let s_793_21: bool = ((s_793_18) != (s_793_20));
        // D s_793_22: write-var gs#410835 <= s_793_21
        fn_state.gs_410835 = s_793_21;
        // N s_793_23: jump b794
        return block_794(state, tracer, fn_state);
    }
    fn block_794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_794_0: read-var gs#410835:u8
        let s_794_0: bool = fn_state.gs_410835;
        // N s_794_1: branch s_794_0 b796 b795
        if s_794_0 {
            return block_796(state, tracer, fn_state);
        } else {
            return block_795(state, tracer, fn_state);
        };
    }
    fn block_795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_795_0: read-var u#33763:u8
        let s_795_0: u8 = fn_state.u_33763;
        // D s_795_1: read-var u#33764:u8
        let s_795_1: u8 = fn_state.u_33764;
        // D s_795_2: read-var u#33765:u8
        let s_795_2: u8 = fn_state.u_33765;
        // D s_795_3: read-var u#33766:u8
        let s_795_3: u8 = fn_state.u_33766;
        // D s_795_4: call decode_aarch32_instrs_UQADD16_A1enc_A_txt(s_795_0, s_795_1, s_795_2, s_795_3)
        let s_795_4: () = decode_aarch32_instrs_UQADD16_A1enc_A_txt(
            state,
            tracer,
            s_795_0,
            s_795_1,
            s_795_2,
            s_795_3,
        );
        // N s_795_5: return
        return;
    }
    fn block_796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_796_0: panic
        panic!("{:?}", ());
        // N s_796_1: return
        return;
    }
    fn block_797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_797_0: const #1u : u8
        let s_797_0: bool = true;
        // D s_797_1: write-var gs#410835 <= s_797_0
        fn_state.gs_410835 = s_797_0;
        // N s_797_2: jump b794
        return block_794(state, tracer, fn_state);
    }
    fn block_798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_798_0: const #1u : u8
        let s_798_0: bool = true;
        // D s_798_1: write-var gs#410832 <= s_798_0
        fn_state.gs_410832 = s_798_0;
        // N s_798_2: jump b792
        return block_792(state, tracer, fn_state);
    }
    fn block_799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_799_0: const #1u : u8
        let s_799_0: bool = true;
        // D s_799_1: write-var gs#410829 <= s_799_0
        fn_state.gs_410829 = s_799_0;
        // N s_799_2: jump b790
        return block_790(state, tracer, fn_state);
    }
    fn block_800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_800_0: read-var merge#var.1:struct
        let s_800_0: u32 = fn_state.merge_var._1;
        // D s_800_1: write-var u#33768 <= s_800_0
        fn_state.u_33768 = s_800_0;
        // C s_800_2: const #20s : i
        let s_800_2: i128 = 20;
        // D s_800_3: read-var u#33768:u32
        let s_800_3: u32 = fn_state.u_33768;
        // D s_800_4: cast zx s_800_3 -> bv
        let s_800_4: Bits = Bits::new(s_800_3 as u128, 32u16);
        // C s_800_5: const #1s : i64
        let s_800_5: i64 = 1;
        // C s_800_6: cast zx s_800_5 -> i
        let s_800_6: i128 = (i128::try_from(s_800_5).unwrap());
        // C s_800_7: const #7s : i
        let s_800_7: i128 = 7;
        // C s_800_8: add s_800_7 s_800_6
        let s_800_8: i128 = (s_800_7 + s_800_6);
        // D s_800_9: bit-extract s_800_4 s_800_2 s_800_8
        let s_800_9: Bits = (Bits::new(
            ((s_800_4) >> (s_800_2)).value(),
            u16::try_from(s_800_8).unwrap(),
        ));
        // D s_800_10: cast reint s_800_9 -> u8
        let s_800_10: u8 = (s_800_9.value() as u8);
        // D s_800_11: cast zx s_800_10 -> bv
        let s_800_11: Bits = Bits::new(s_800_10 as u128, 8u16);
        // C s_800_12: const #102u : u8
        let s_800_12: u8 = 102;
        // C s_800_13: cast zx s_800_12 -> bv
        let s_800_13: Bits = Bits::new(s_800_12 as u128, 8u16);
        // D s_800_14: cmp-eq s_800_11 s_800_13
        let s_800_14: bool = ((s_800_11) == (s_800_13));
        // N s_800_15: branch s_800_14 b1130 b801
        if s_800_14 {
            return block_1130(state, tracer, fn_state);
        } else {
            return block_801(state, tracer, fn_state);
        };
    }
    fn block_801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_801_0: const #0u : u8
        let s_801_0: bool = false;
        // D s_801_1: write-var gs#410841 <= s_801_0
        fn_state.gs_410841 = s_801_0;
        // N s_801_2: jump b802
        return block_802(state, tracer, fn_state);
    }
    fn block_802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_802_0: read-var gs#410841:u8
        let s_802_0: bool = fn_state.gs_410841;
        // N s_802_1: branch s_802_0 b1126 b803
        if s_802_0 {
            return block_1126(state, tracer, fn_state);
        } else {
            return block_803(state, tracer, fn_state);
        };
    }
    fn block_803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_803_0: const #0u : u8
        let s_803_0: bool = false;
        // D s_803_1: write-var gs#410846 <= s_803_0
        fn_state.gs_410846 = s_803_0;
        // N s_803_2: jump b804
        return block_804(state, tracer, fn_state);
    }
    fn block_804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_804_0: read-var gs#410846:u8
        let s_804_0: bool = fn_state.gs_410846;
        // D s_804_1: not s_804_0
        let s_804_1: bool = !s_804_0;
        // N s_804_2: branch s_804_1 b817 b805
        if s_804_1 {
            return block_817(state, tracer, fn_state);
        } else {
            return block_805(state, tracer, fn_state);
        };
    }
    fn block_805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_805_0: const #3312s : i
        let s_805_0: i128 = 3312;
        // C s_805_1: const #14696u : u32
        let s_805_1: u32 = 14696;
        // N s_805_2: write-reg s_805_1 <= s_805_0
        let s_805_2: () = {
            state.write_register::<i128>(s_805_1 as isize, s_805_0);
            tracer.write_register(s_805_1 as isize, s_805_0);
        };
        // C s_805_3: const #28s : i
        let s_805_3: i128 = 28;
        // C s_805_4: const #4s : i
        let s_805_4: i128 = 4;
        // D s_805_5: read-var u#33768:u32
        let s_805_5: u32 = fn_state.u_33768;
        // D s_805_6: cast zx s_805_5 -> bv
        let s_805_6: Bits = Bits::new(s_805_5 as u128, 32u16);
        // D s_805_7: bit-extract s_805_6 s_805_3 s_805_4
        let s_805_7: Bits = (Bits::new(
            ((s_805_6) >> (s_805_3)).value(),
            u16::try_from(s_805_4).unwrap(),
        ));
        // D s_805_8: cast reint s_805_7 -> u8
        let s_805_8: u8 = (s_805_7.value() as u8);
        // D s_805_9: write-var u#33769 <= s_805_8
        fn_state.u_33769 = s_805_8;
        // C s_805_10: const #16s : i
        let s_805_10: i128 = 16;
        // C s_805_11: const #4s : i
        let s_805_11: i128 = 4;
        // D s_805_12: read-var u#33768:u32
        let s_805_12: u32 = fn_state.u_33768;
        // D s_805_13: cast zx s_805_12 -> bv
        let s_805_13: Bits = Bits::new(s_805_12 as u128, 32u16);
        // D s_805_14: bit-extract s_805_13 s_805_10 s_805_11
        let s_805_14: Bits = (Bits::new(
            ((s_805_13) >> (s_805_10)).value(),
            u16::try_from(s_805_11).unwrap(),
        ));
        // D s_805_15: cast reint s_805_14 -> u8
        let s_805_15: u8 = (s_805_14.value() as u8);
        // D s_805_16: write-var u#33770 <= s_805_15
        fn_state.u_33770 = s_805_15;
        // C s_805_17: const #12s : i
        let s_805_17: i128 = 12;
        // C s_805_18: const #4s : i
        let s_805_18: i128 = 4;
        // D s_805_19: read-var u#33768:u32
        let s_805_19: u32 = fn_state.u_33768;
        // D s_805_20: cast zx s_805_19 -> bv
        let s_805_20: Bits = Bits::new(s_805_19 as u128, 32u16);
        // D s_805_21: bit-extract s_805_20 s_805_17 s_805_18
        let s_805_21: Bits = (Bits::new(
            ((s_805_20) >> (s_805_17)).value(),
            u16::try_from(s_805_18).unwrap(),
        ));
        // D s_805_22: cast reint s_805_21 -> u8
        let s_805_22: u8 = (s_805_21.value() as u8);
        // D s_805_23: write-var u#33771 <= s_805_22
        fn_state.u_33771 = s_805_22;
        // C s_805_24: const #0s : i
        let s_805_24: i128 = 0;
        // C s_805_25: const #4s : i
        let s_805_25: i128 = 4;
        // D s_805_26: read-var u#33768:u32
        let s_805_26: u32 = fn_state.u_33768;
        // D s_805_27: cast zx s_805_26 -> bv
        let s_805_27: Bits = Bits::new(s_805_26 as u128, 32u16);
        // D s_805_28: bit-extract s_805_27 s_805_24 s_805_25
        let s_805_28: Bits = (Bits::new(
            ((s_805_27) >> (s_805_24)).value(),
            u16::try_from(s_805_25).unwrap(),
        ));
        // D s_805_29: cast reint s_805_28 -> u8
        let s_805_29: u8 = (s_805_28.value() as u8);
        // D s_805_30: write-var u#33772 <= s_805_29
        fn_state.u_33772 = s_805_29;
        // C s_805_31: const #8s : i
        let s_805_31: i128 = 8;
        // D s_805_32: read-var u#33768:u32
        let s_805_32: u32 = fn_state.u_33768;
        // D s_805_33: cast zx s_805_32 -> bv
        let s_805_33: Bits = Bits::new(s_805_32 as u128, 32u16);
        // C s_805_34: const #1u : u64
        let s_805_34: u64 = 1;
        // D s_805_35: bit-extract s_805_33 s_805_31 s_805_34
        let s_805_35: Bits = (Bits::new(
            ((s_805_33) >> (s_805_31)).value(),
            u16::try_from(s_805_34).unwrap(),
        ));
        // D s_805_36: cast reint s_805_35 -> u8
        let s_805_36: bool = ((s_805_35.value()) != 0);
        // C s_805_37: const #0s : i
        let s_805_37: i128 = 0;
        // C s_805_38: const #0u : u64
        let s_805_38: u64 = 0;
        // D s_805_39: cast zx s_805_36 -> u64
        let s_805_39: u64 = (s_805_36 as u64);
        // C s_805_40: const #1u : u64
        let s_805_40: u64 = 1;
        // D s_805_41: and s_805_39 s_805_40
        let s_805_41: u64 = ((s_805_39) & (s_805_40));
        // D s_805_42: cmp-eq s_805_41 s_805_40
        let s_805_42: bool = ((s_805_41) == (s_805_40));
        // D s_805_43: lsl s_805_39 s_805_37
        let s_805_43: u64 = s_805_39 << s_805_37;
        // D s_805_44: or s_805_38 s_805_43
        let s_805_44: u64 = ((s_805_38) | (s_805_43));
        // D s_805_45: cmpl s_805_43
        let s_805_45: u64 = !s_805_43;
        // D s_805_46: and s_805_38 s_805_45
        let s_805_46: u64 = ((s_805_38) & (s_805_45));
        // D s_805_47: select s_805_42 s_805_44 s_805_46
        let s_805_47: u64 = if s_805_42 { s_805_44 } else { s_805_46 };
        // D s_805_48: cast trunc s_805_47 -> u8
        let s_805_48: bool = ((s_805_47) != 0);
        // D s_805_49: cast zx s_805_48 -> bv
        let s_805_49: Bits = Bits::new(s_805_48 as u128, 1u16);
        // C s_805_50: const #1u : u8
        let s_805_50: bool = true;
        // C s_805_51: cast zx s_805_50 -> bv
        let s_805_51: Bits = Bits::new(s_805_50 as u128, 1u16);
        // D s_805_52: cmp-ne s_805_49 s_805_51
        let s_805_52: bool = ((s_805_49) != (s_805_51));
        // N s_805_53: branch s_805_52 b816 b806
        if s_805_52 {
            return block_816(state, tracer, fn_state);
        } else {
            return block_806(state, tracer, fn_state);
        };
    }
    fn block_806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_806_0: const #9s : i
        let s_806_0: i128 = 9;
        // D s_806_1: read-var u#33768:u32
        let s_806_1: u32 = fn_state.u_33768;
        // D s_806_2: cast zx s_806_1 -> bv
        let s_806_2: Bits = Bits::new(s_806_1 as u128, 32u16);
        // C s_806_3: const #1u : u64
        let s_806_3: u64 = 1;
        // D s_806_4: bit-extract s_806_2 s_806_0 s_806_3
        let s_806_4: Bits = (Bits::new(
            ((s_806_2) >> (s_806_0)).value(),
            u16::try_from(s_806_3).unwrap(),
        ));
        // D s_806_5: cast reint s_806_4 -> u8
        let s_806_5: bool = ((s_806_4.value()) != 0);
        // C s_806_6: const #0s : i
        let s_806_6: i128 = 0;
        // C s_806_7: const #0u : u64
        let s_806_7: u64 = 0;
        // D s_806_8: cast zx s_806_5 -> u64
        let s_806_8: u64 = (s_806_5 as u64);
        // C s_806_9: const #1u : u64
        let s_806_9: u64 = 1;
        // D s_806_10: and s_806_8 s_806_9
        let s_806_10: u64 = ((s_806_8) & (s_806_9));
        // D s_806_11: cmp-eq s_806_10 s_806_9
        let s_806_11: bool = ((s_806_10) == (s_806_9));
        // D s_806_12: lsl s_806_8 s_806_6
        let s_806_12: u64 = s_806_8 << s_806_6;
        // D s_806_13: or s_806_7 s_806_12
        let s_806_13: u64 = ((s_806_7) | (s_806_12));
        // D s_806_14: cmpl s_806_12
        let s_806_14: u64 = !s_806_12;
        // D s_806_15: and s_806_7 s_806_14
        let s_806_15: u64 = ((s_806_7) & (s_806_14));
        // D s_806_16: select s_806_11 s_806_13 s_806_15
        let s_806_16: u64 = if s_806_11 { s_806_13 } else { s_806_15 };
        // D s_806_17: cast trunc s_806_16 -> u8
        let s_806_17: bool = ((s_806_16) != 0);
        // D s_806_18: cast zx s_806_17 -> bv
        let s_806_18: Bits = Bits::new(s_806_17 as u128, 1u16);
        // C s_806_19: const #1u : u8
        let s_806_19: bool = true;
        // C s_806_20: cast zx s_806_19 -> bv
        let s_806_20: Bits = Bits::new(s_806_19 as u128, 1u16);
        // D s_806_21: cmp-ne s_806_18 s_806_20
        let s_806_21: bool = ((s_806_18) != (s_806_20));
        // D s_806_22: write-var gs#410861 <= s_806_21
        fn_state.gs_410861 = s_806_21;
        // N s_806_23: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_807_0: read-var gs#410861:u8
        let s_807_0: bool = fn_state.gs_410861;
        // N s_807_1: branch s_807_0 b815 b808
        if s_807_0 {
            return block_815(state, tracer, fn_state);
        } else {
            return block_808(state, tracer, fn_state);
        };
    }
    fn block_808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_808_0: const #10s : i
        let s_808_0: i128 = 10;
        // D s_808_1: read-var u#33768:u32
        let s_808_1: u32 = fn_state.u_33768;
        // D s_808_2: cast zx s_808_1 -> bv
        let s_808_2: Bits = Bits::new(s_808_1 as u128, 32u16);
        // C s_808_3: const #1u : u64
        let s_808_3: u64 = 1;
        // D s_808_4: bit-extract s_808_2 s_808_0 s_808_3
        let s_808_4: Bits = (Bits::new(
            ((s_808_2) >> (s_808_0)).value(),
            u16::try_from(s_808_3).unwrap(),
        ));
        // D s_808_5: cast reint s_808_4 -> u8
        let s_808_5: bool = ((s_808_4.value()) != 0);
        // C s_808_6: const #0s : i
        let s_808_6: i128 = 0;
        // C s_808_7: const #0u : u64
        let s_808_7: u64 = 0;
        // D s_808_8: cast zx s_808_5 -> u64
        let s_808_8: u64 = (s_808_5 as u64);
        // C s_808_9: const #1u : u64
        let s_808_9: u64 = 1;
        // D s_808_10: and s_808_8 s_808_9
        let s_808_10: u64 = ((s_808_8) & (s_808_9));
        // D s_808_11: cmp-eq s_808_10 s_808_9
        let s_808_11: bool = ((s_808_10) == (s_808_9));
        // D s_808_12: lsl s_808_8 s_808_6
        let s_808_12: u64 = s_808_8 << s_808_6;
        // D s_808_13: or s_808_7 s_808_12
        let s_808_13: u64 = ((s_808_7) | (s_808_12));
        // D s_808_14: cmpl s_808_12
        let s_808_14: u64 = !s_808_12;
        // D s_808_15: and s_808_7 s_808_14
        let s_808_15: u64 = ((s_808_7) & (s_808_14));
        // D s_808_16: select s_808_11 s_808_13 s_808_15
        let s_808_16: u64 = if s_808_11 { s_808_13 } else { s_808_15 };
        // D s_808_17: cast trunc s_808_16 -> u8
        let s_808_17: bool = ((s_808_16) != 0);
        // D s_808_18: cast zx s_808_17 -> bv
        let s_808_18: Bits = Bits::new(s_808_17 as u128, 1u16);
        // C s_808_19: const #1u : u8
        let s_808_19: bool = true;
        // C s_808_20: cast zx s_808_19 -> bv
        let s_808_20: Bits = Bits::new(s_808_19 as u128, 1u16);
        // D s_808_21: cmp-ne s_808_18 s_808_20
        let s_808_21: bool = ((s_808_18) != (s_808_20));
        // D s_808_22: write-var gs#410864 <= s_808_21
        fn_state.gs_410864 = s_808_21;
        // N s_808_23: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_809_0: read-var gs#410864:u8
        let s_809_0: bool = fn_state.gs_410864;
        // N s_809_1: branch s_809_0 b814 b810
        if s_809_0 {
            return block_814(state, tracer, fn_state);
        } else {
            return block_810(state, tracer, fn_state);
        };
    }
    fn block_810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_810_0: const #11s : i
        let s_810_0: i128 = 11;
        // D s_810_1: read-var u#33768:u32
        let s_810_1: u32 = fn_state.u_33768;
        // D s_810_2: cast zx s_810_1 -> bv
        let s_810_2: Bits = Bits::new(s_810_1 as u128, 32u16);
        // C s_810_3: const #1u : u64
        let s_810_3: u64 = 1;
        // D s_810_4: bit-extract s_810_2 s_810_0 s_810_3
        let s_810_4: Bits = (Bits::new(
            ((s_810_2) >> (s_810_0)).value(),
            u16::try_from(s_810_3).unwrap(),
        ));
        // D s_810_5: cast reint s_810_4 -> u8
        let s_810_5: bool = ((s_810_4.value()) != 0);
        // C s_810_6: const #0s : i
        let s_810_6: i128 = 0;
        // C s_810_7: const #0u : u64
        let s_810_7: u64 = 0;
        // D s_810_8: cast zx s_810_5 -> u64
        let s_810_8: u64 = (s_810_5 as u64);
        // C s_810_9: const #1u : u64
        let s_810_9: u64 = 1;
        // D s_810_10: and s_810_8 s_810_9
        let s_810_10: u64 = ((s_810_8) & (s_810_9));
        // D s_810_11: cmp-eq s_810_10 s_810_9
        let s_810_11: bool = ((s_810_10) == (s_810_9));
        // D s_810_12: lsl s_810_8 s_810_6
        let s_810_12: u64 = s_810_8 << s_810_6;
        // D s_810_13: or s_810_7 s_810_12
        let s_810_13: u64 = ((s_810_7) | (s_810_12));
        // D s_810_14: cmpl s_810_12
        let s_810_14: u64 = !s_810_12;
        // D s_810_15: and s_810_7 s_810_14
        let s_810_15: u64 = ((s_810_7) & (s_810_14));
        // D s_810_16: select s_810_11 s_810_13 s_810_15
        let s_810_16: u64 = if s_810_11 { s_810_13 } else { s_810_15 };
        // D s_810_17: cast trunc s_810_16 -> u8
        let s_810_17: bool = ((s_810_16) != 0);
        // D s_810_18: cast zx s_810_17 -> bv
        let s_810_18: Bits = Bits::new(s_810_17 as u128, 1u16);
        // C s_810_19: const #1u : u8
        let s_810_19: bool = true;
        // C s_810_20: cast zx s_810_19 -> bv
        let s_810_20: Bits = Bits::new(s_810_19 as u128, 1u16);
        // D s_810_21: cmp-ne s_810_18 s_810_20
        let s_810_21: bool = ((s_810_18) != (s_810_20));
        // D s_810_22: write-var gs#410867 <= s_810_21
        fn_state.gs_410867 = s_810_21;
        // N s_810_23: jump b811
        return block_811(state, tracer, fn_state);
    }
    fn block_811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_811_0: read-var gs#410867:u8
        let s_811_0: bool = fn_state.gs_410867;
        // N s_811_1: branch s_811_0 b813 b812
        if s_811_0 {
            return block_813(state, tracer, fn_state);
        } else {
            return block_812(state, tracer, fn_state);
        };
    }
    fn block_812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_812_0: read-var u#33769:u8
        let s_812_0: u8 = fn_state.u_33769;
        // D s_812_1: read-var u#33770:u8
        let s_812_1: u8 = fn_state.u_33770;
        // D s_812_2: read-var u#33771:u8
        let s_812_2: u8 = fn_state.u_33771;
        // D s_812_3: read-var u#33772:u8
        let s_812_3: u8 = fn_state.u_33772;
        // D s_812_4: call decode_aarch32_instrs_UQADD8_A1enc_A_txt(s_812_0, s_812_1, s_812_2, s_812_3)
        let s_812_4: () = decode_aarch32_instrs_UQADD8_A1enc_A_txt(
            state,
            tracer,
            s_812_0,
            s_812_1,
            s_812_2,
            s_812_3,
        );
        // N s_812_5: return
        return;
    }
    fn block_813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_813_0: panic
        panic!("{:?}", ());
        // N s_813_1: return
        return;
    }
    fn block_814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_814_0: const #1u : u8
        let s_814_0: bool = true;
        // D s_814_1: write-var gs#410867 <= s_814_0
        fn_state.gs_410867 = s_814_0;
        // N s_814_2: jump b811
        return block_811(state, tracer, fn_state);
    }
    fn block_815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_815_0: const #1u : u8
        let s_815_0: bool = true;
        // D s_815_1: write-var gs#410864 <= s_815_0
        fn_state.gs_410864 = s_815_0;
        // N s_815_2: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_816_0: const #1u : u8
        let s_816_0: bool = true;
        // D s_816_1: write-var gs#410861 <= s_816_0
        fn_state.gs_410861 = s_816_0;
        // N s_816_2: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_817_0: read-var merge#var.1:struct
        let s_817_0: u32 = fn_state.merge_var._1;
        // D s_817_1: write-var u#33774 <= s_817_0
        fn_state.u_33774 = s_817_0;
        // C s_817_2: const #20s : i
        let s_817_2: i128 = 20;
        // D s_817_3: read-var u#33774:u32
        let s_817_3: u32 = fn_state.u_33774;
        // D s_817_4: cast zx s_817_3 -> bv
        let s_817_4: Bits = Bits::new(s_817_3 as u128, 32u16);
        // C s_817_5: const #1s : i64
        let s_817_5: i64 = 1;
        // C s_817_6: cast zx s_817_5 -> i
        let s_817_6: i128 = (i128::try_from(s_817_5).unwrap());
        // C s_817_7: const #7s : i
        let s_817_7: i128 = 7;
        // C s_817_8: add s_817_7 s_817_6
        let s_817_8: i128 = (s_817_7 + s_817_6);
        // D s_817_9: bit-extract s_817_4 s_817_2 s_817_8
        let s_817_9: Bits = (Bits::new(
            ((s_817_4) >> (s_817_2)).value(),
            u16::try_from(s_817_8).unwrap(),
        ));
        // D s_817_10: cast reint s_817_9 -> u8
        let s_817_10: u8 = (s_817_9.value() as u8);
        // D s_817_11: cast zx s_817_10 -> bv
        let s_817_11: Bits = Bits::new(s_817_10 as u128, 8u16);
        // C s_817_12: const #102u : u8
        let s_817_12: u8 = 102;
        // C s_817_13: cast zx s_817_12 -> bv
        let s_817_13: Bits = Bits::new(s_817_12 as u128, 8u16);
        // D s_817_14: cmp-eq s_817_11 s_817_13
        let s_817_14: bool = ((s_817_11) == (s_817_13));
        // N s_817_15: branch s_817_14 b1125 b818
        if s_817_14 {
            return block_1125(state, tracer, fn_state);
        } else {
            return block_818(state, tracer, fn_state);
        };
    }
    fn block_818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_818_0: const #0u : u8
        let s_818_0: bool = false;
        // D s_818_1: write-var gs#410873 <= s_818_0
        fn_state.gs_410873 = s_818_0;
        // N s_818_2: jump b819
        return block_819(state, tracer, fn_state);
    }
    fn block_819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_819_0: read-var gs#410873:u8
        let s_819_0: bool = fn_state.gs_410873;
        // N s_819_1: branch s_819_0 b1121 b820
        if s_819_0 {
            return block_1121(state, tracer, fn_state);
        } else {
            return block_820(state, tracer, fn_state);
        };
    }
    fn block_820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_820_0: const #0u : u8
        let s_820_0: bool = false;
        // D s_820_1: write-var gs#410878 <= s_820_0
        fn_state.gs_410878 = s_820_0;
        // N s_820_2: jump b821
        return block_821(state, tracer, fn_state);
    }
    fn block_821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_821_0: read-var gs#410878:u8
        let s_821_0: bool = fn_state.gs_410878;
        // D s_821_1: not s_821_0
        let s_821_1: bool = !s_821_0;
        // N s_821_2: branch s_821_1 b834 b822
        if s_821_1 {
            return block_834(state, tracer, fn_state);
        } else {
            return block_822(state, tracer, fn_state);
        };
    }
    fn block_822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_822_0: const #3314s : i
        let s_822_0: i128 = 3314;
        // C s_822_1: const #14696u : u32
        let s_822_1: u32 = 14696;
        // N s_822_2: write-reg s_822_1 <= s_822_0
        let s_822_2: () = {
            state.write_register::<i128>(s_822_1 as isize, s_822_0);
            tracer.write_register(s_822_1 as isize, s_822_0);
        };
        // C s_822_3: const #28s : i
        let s_822_3: i128 = 28;
        // C s_822_4: const #4s : i
        let s_822_4: i128 = 4;
        // D s_822_5: read-var u#33774:u32
        let s_822_5: u32 = fn_state.u_33774;
        // D s_822_6: cast zx s_822_5 -> bv
        let s_822_6: Bits = Bits::new(s_822_5 as u128, 32u16);
        // D s_822_7: bit-extract s_822_6 s_822_3 s_822_4
        let s_822_7: Bits = (Bits::new(
            ((s_822_6) >> (s_822_3)).value(),
            u16::try_from(s_822_4).unwrap(),
        ));
        // D s_822_8: cast reint s_822_7 -> u8
        let s_822_8: u8 = (s_822_7.value() as u8);
        // D s_822_9: write-var u#33775 <= s_822_8
        fn_state.u_33775 = s_822_8;
        // C s_822_10: const #16s : i
        let s_822_10: i128 = 16;
        // C s_822_11: const #4s : i
        let s_822_11: i128 = 4;
        // D s_822_12: read-var u#33774:u32
        let s_822_12: u32 = fn_state.u_33774;
        // D s_822_13: cast zx s_822_12 -> bv
        let s_822_13: Bits = Bits::new(s_822_12 as u128, 32u16);
        // D s_822_14: bit-extract s_822_13 s_822_10 s_822_11
        let s_822_14: Bits = (Bits::new(
            ((s_822_13) >> (s_822_10)).value(),
            u16::try_from(s_822_11).unwrap(),
        ));
        // D s_822_15: cast reint s_822_14 -> u8
        let s_822_15: u8 = (s_822_14.value() as u8);
        // D s_822_16: write-var u#33776 <= s_822_15
        fn_state.u_33776 = s_822_15;
        // C s_822_17: const #12s : i
        let s_822_17: i128 = 12;
        // C s_822_18: const #4s : i
        let s_822_18: i128 = 4;
        // D s_822_19: read-var u#33774:u32
        let s_822_19: u32 = fn_state.u_33774;
        // D s_822_20: cast zx s_822_19 -> bv
        let s_822_20: Bits = Bits::new(s_822_19 as u128, 32u16);
        // D s_822_21: bit-extract s_822_20 s_822_17 s_822_18
        let s_822_21: Bits = (Bits::new(
            ((s_822_20) >> (s_822_17)).value(),
            u16::try_from(s_822_18).unwrap(),
        ));
        // D s_822_22: cast reint s_822_21 -> u8
        let s_822_22: u8 = (s_822_21.value() as u8);
        // D s_822_23: write-var u#33777 <= s_822_22
        fn_state.u_33777 = s_822_22;
        // C s_822_24: const #0s : i
        let s_822_24: i128 = 0;
        // C s_822_25: const #4s : i
        let s_822_25: i128 = 4;
        // D s_822_26: read-var u#33774:u32
        let s_822_26: u32 = fn_state.u_33774;
        // D s_822_27: cast zx s_822_26 -> bv
        let s_822_27: Bits = Bits::new(s_822_26 as u128, 32u16);
        // D s_822_28: bit-extract s_822_27 s_822_24 s_822_25
        let s_822_28: Bits = (Bits::new(
            ((s_822_27) >> (s_822_24)).value(),
            u16::try_from(s_822_25).unwrap(),
        ));
        // D s_822_29: cast reint s_822_28 -> u8
        let s_822_29: u8 = (s_822_28.value() as u8);
        // D s_822_30: write-var u#33778 <= s_822_29
        fn_state.u_33778 = s_822_29;
        // C s_822_31: const #8s : i
        let s_822_31: i128 = 8;
        // D s_822_32: read-var u#33774:u32
        let s_822_32: u32 = fn_state.u_33774;
        // D s_822_33: cast zx s_822_32 -> bv
        let s_822_33: Bits = Bits::new(s_822_32 as u128, 32u16);
        // C s_822_34: const #1u : u64
        let s_822_34: u64 = 1;
        // D s_822_35: bit-extract s_822_33 s_822_31 s_822_34
        let s_822_35: Bits = (Bits::new(
            ((s_822_33) >> (s_822_31)).value(),
            u16::try_from(s_822_34).unwrap(),
        ));
        // D s_822_36: cast reint s_822_35 -> u8
        let s_822_36: bool = ((s_822_35.value()) != 0);
        // C s_822_37: const #0s : i
        let s_822_37: i128 = 0;
        // C s_822_38: const #0u : u64
        let s_822_38: u64 = 0;
        // D s_822_39: cast zx s_822_36 -> u64
        let s_822_39: u64 = (s_822_36 as u64);
        // C s_822_40: const #1u : u64
        let s_822_40: u64 = 1;
        // D s_822_41: and s_822_39 s_822_40
        let s_822_41: u64 = ((s_822_39) & (s_822_40));
        // D s_822_42: cmp-eq s_822_41 s_822_40
        let s_822_42: bool = ((s_822_41) == (s_822_40));
        // D s_822_43: lsl s_822_39 s_822_37
        let s_822_43: u64 = s_822_39 << s_822_37;
        // D s_822_44: or s_822_38 s_822_43
        let s_822_44: u64 = ((s_822_38) | (s_822_43));
        // D s_822_45: cmpl s_822_43
        let s_822_45: u64 = !s_822_43;
        // D s_822_46: and s_822_38 s_822_45
        let s_822_46: u64 = ((s_822_38) & (s_822_45));
        // D s_822_47: select s_822_42 s_822_44 s_822_46
        let s_822_47: u64 = if s_822_42 { s_822_44 } else { s_822_46 };
        // D s_822_48: cast trunc s_822_47 -> u8
        let s_822_48: bool = ((s_822_47) != 0);
        // D s_822_49: cast zx s_822_48 -> bv
        let s_822_49: Bits = Bits::new(s_822_48 as u128, 1u16);
        // C s_822_50: const #1u : u8
        let s_822_50: bool = true;
        // C s_822_51: cast zx s_822_50 -> bv
        let s_822_51: Bits = Bits::new(s_822_50 as u128, 1u16);
        // D s_822_52: cmp-ne s_822_49 s_822_51
        let s_822_52: bool = ((s_822_49) != (s_822_51));
        // N s_822_53: branch s_822_52 b833 b823
        if s_822_52 {
            return block_833(state, tracer, fn_state);
        } else {
            return block_823(state, tracer, fn_state);
        };
    }
    fn block_823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_823_0: const #9s : i
        let s_823_0: i128 = 9;
        // D s_823_1: read-var u#33774:u32
        let s_823_1: u32 = fn_state.u_33774;
        // D s_823_2: cast zx s_823_1 -> bv
        let s_823_2: Bits = Bits::new(s_823_1 as u128, 32u16);
        // C s_823_3: const #1u : u64
        let s_823_3: u64 = 1;
        // D s_823_4: bit-extract s_823_2 s_823_0 s_823_3
        let s_823_4: Bits = (Bits::new(
            ((s_823_2) >> (s_823_0)).value(),
            u16::try_from(s_823_3).unwrap(),
        ));
        // D s_823_5: cast reint s_823_4 -> u8
        let s_823_5: bool = ((s_823_4.value()) != 0);
        // C s_823_6: const #0s : i
        let s_823_6: i128 = 0;
        // C s_823_7: const #0u : u64
        let s_823_7: u64 = 0;
        // D s_823_8: cast zx s_823_5 -> u64
        let s_823_8: u64 = (s_823_5 as u64);
        // C s_823_9: const #1u : u64
        let s_823_9: u64 = 1;
        // D s_823_10: and s_823_8 s_823_9
        let s_823_10: u64 = ((s_823_8) & (s_823_9));
        // D s_823_11: cmp-eq s_823_10 s_823_9
        let s_823_11: bool = ((s_823_10) == (s_823_9));
        // D s_823_12: lsl s_823_8 s_823_6
        let s_823_12: u64 = s_823_8 << s_823_6;
        // D s_823_13: or s_823_7 s_823_12
        let s_823_13: u64 = ((s_823_7) | (s_823_12));
        // D s_823_14: cmpl s_823_12
        let s_823_14: u64 = !s_823_12;
        // D s_823_15: and s_823_7 s_823_14
        let s_823_15: u64 = ((s_823_7) & (s_823_14));
        // D s_823_16: select s_823_11 s_823_13 s_823_15
        let s_823_16: u64 = if s_823_11 { s_823_13 } else { s_823_15 };
        // D s_823_17: cast trunc s_823_16 -> u8
        let s_823_17: bool = ((s_823_16) != 0);
        // D s_823_18: cast zx s_823_17 -> bv
        let s_823_18: Bits = Bits::new(s_823_17 as u128, 1u16);
        // C s_823_19: const #1u : u8
        let s_823_19: bool = true;
        // C s_823_20: cast zx s_823_19 -> bv
        let s_823_20: Bits = Bits::new(s_823_19 as u128, 1u16);
        // D s_823_21: cmp-ne s_823_18 s_823_20
        let s_823_21: bool = ((s_823_18) != (s_823_20));
        // D s_823_22: write-var gs#410893 <= s_823_21
        fn_state.gs_410893 = s_823_21;
        // N s_823_23: jump b824
        return block_824(state, tracer, fn_state);
    }
    fn block_824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_824_0: read-var gs#410893:u8
        let s_824_0: bool = fn_state.gs_410893;
        // N s_824_1: branch s_824_0 b832 b825
        if s_824_0 {
            return block_832(state, tracer, fn_state);
        } else {
            return block_825(state, tracer, fn_state);
        };
    }
    fn block_825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_825_0: const #10s : i
        let s_825_0: i128 = 10;
        // D s_825_1: read-var u#33774:u32
        let s_825_1: u32 = fn_state.u_33774;
        // D s_825_2: cast zx s_825_1 -> bv
        let s_825_2: Bits = Bits::new(s_825_1 as u128, 32u16);
        // C s_825_3: const #1u : u64
        let s_825_3: u64 = 1;
        // D s_825_4: bit-extract s_825_2 s_825_0 s_825_3
        let s_825_4: Bits = (Bits::new(
            ((s_825_2) >> (s_825_0)).value(),
            u16::try_from(s_825_3).unwrap(),
        ));
        // D s_825_5: cast reint s_825_4 -> u8
        let s_825_5: bool = ((s_825_4.value()) != 0);
        // C s_825_6: const #0s : i
        let s_825_6: i128 = 0;
        // C s_825_7: const #0u : u64
        let s_825_7: u64 = 0;
        // D s_825_8: cast zx s_825_5 -> u64
        let s_825_8: u64 = (s_825_5 as u64);
        // C s_825_9: const #1u : u64
        let s_825_9: u64 = 1;
        // D s_825_10: and s_825_8 s_825_9
        let s_825_10: u64 = ((s_825_8) & (s_825_9));
        // D s_825_11: cmp-eq s_825_10 s_825_9
        let s_825_11: bool = ((s_825_10) == (s_825_9));
        // D s_825_12: lsl s_825_8 s_825_6
        let s_825_12: u64 = s_825_8 << s_825_6;
        // D s_825_13: or s_825_7 s_825_12
        let s_825_13: u64 = ((s_825_7) | (s_825_12));
        // D s_825_14: cmpl s_825_12
        let s_825_14: u64 = !s_825_12;
        // D s_825_15: and s_825_7 s_825_14
        let s_825_15: u64 = ((s_825_7) & (s_825_14));
        // D s_825_16: select s_825_11 s_825_13 s_825_15
        let s_825_16: u64 = if s_825_11 { s_825_13 } else { s_825_15 };
        // D s_825_17: cast trunc s_825_16 -> u8
        let s_825_17: bool = ((s_825_16) != 0);
        // D s_825_18: cast zx s_825_17 -> bv
        let s_825_18: Bits = Bits::new(s_825_17 as u128, 1u16);
        // C s_825_19: const #1u : u8
        let s_825_19: bool = true;
        // C s_825_20: cast zx s_825_19 -> bv
        let s_825_20: Bits = Bits::new(s_825_19 as u128, 1u16);
        // D s_825_21: cmp-ne s_825_18 s_825_20
        let s_825_21: bool = ((s_825_18) != (s_825_20));
        // D s_825_22: write-var gs#410896 <= s_825_21
        fn_state.gs_410896 = s_825_21;
        // N s_825_23: jump b826
        return block_826(state, tracer, fn_state);
    }
    fn block_826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_826_0: read-var gs#410896:u8
        let s_826_0: bool = fn_state.gs_410896;
        // N s_826_1: branch s_826_0 b831 b827
        if s_826_0 {
            return block_831(state, tracer, fn_state);
        } else {
            return block_827(state, tracer, fn_state);
        };
    }
    fn block_827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_827_0: const #11s : i
        let s_827_0: i128 = 11;
        // D s_827_1: read-var u#33774:u32
        let s_827_1: u32 = fn_state.u_33774;
        // D s_827_2: cast zx s_827_1 -> bv
        let s_827_2: Bits = Bits::new(s_827_1 as u128, 32u16);
        // C s_827_3: const #1u : u64
        let s_827_3: u64 = 1;
        // D s_827_4: bit-extract s_827_2 s_827_0 s_827_3
        let s_827_4: Bits = (Bits::new(
            ((s_827_2) >> (s_827_0)).value(),
            u16::try_from(s_827_3).unwrap(),
        ));
        // D s_827_5: cast reint s_827_4 -> u8
        let s_827_5: bool = ((s_827_4.value()) != 0);
        // C s_827_6: const #0s : i
        let s_827_6: i128 = 0;
        // C s_827_7: const #0u : u64
        let s_827_7: u64 = 0;
        // D s_827_8: cast zx s_827_5 -> u64
        let s_827_8: u64 = (s_827_5 as u64);
        // C s_827_9: const #1u : u64
        let s_827_9: u64 = 1;
        // D s_827_10: and s_827_8 s_827_9
        let s_827_10: u64 = ((s_827_8) & (s_827_9));
        // D s_827_11: cmp-eq s_827_10 s_827_9
        let s_827_11: bool = ((s_827_10) == (s_827_9));
        // D s_827_12: lsl s_827_8 s_827_6
        let s_827_12: u64 = s_827_8 << s_827_6;
        // D s_827_13: or s_827_7 s_827_12
        let s_827_13: u64 = ((s_827_7) | (s_827_12));
        // D s_827_14: cmpl s_827_12
        let s_827_14: u64 = !s_827_12;
        // D s_827_15: and s_827_7 s_827_14
        let s_827_15: u64 = ((s_827_7) & (s_827_14));
        // D s_827_16: select s_827_11 s_827_13 s_827_15
        let s_827_16: u64 = if s_827_11 { s_827_13 } else { s_827_15 };
        // D s_827_17: cast trunc s_827_16 -> u8
        let s_827_17: bool = ((s_827_16) != 0);
        // D s_827_18: cast zx s_827_17 -> bv
        let s_827_18: Bits = Bits::new(s_827_17 as u128, 1u16);
        // C s_827_19: const #1u : u8
        let s_827_19: bool = true;
        // C s_827_20: cast zx s_827_19 -> bv
        let s_827_20: Bits = Bits::new(s_827_19 as u128, 1u16);
        // D s_827_21: cmp-ne s_827_18 s_827_20
        let s_827_21: bool = ((s_827_18) != (s_827_20));
        // D s_827_22: write-var gs#410899 <= s_827_21
        fn_state.gs_410899 = s_827_21;
        // N s_827_23: jump b828
        return block_828(state, tracer, fn_state);
    }
    fn block_828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_828_0: read-var gs#410899:u8
        let s_828_0: bool = fn_state.gs_410899;
        // N s_828_1: branch s_828_0 b830 b829
        if s_828_0 {
            return block_830(state, tracer, fn_state);
        } else {
            return block_829(state, tracer, fn_state);
        };
    }
    fn block_829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_829_0: read-var u#33775:u8
        let s_829_0: u8 = fn_state.u_33775;
        // D s_829_1: read-var u#33776:u8
        let s_829_1: u8 = fn_state.u_33776;
        // D s_829_2: read-var u#33777:u8
        let s_829_2: u8 = fn_state.u_33777;
        // D s_829_3: read-var u#33778:u8
        let s_829_3: u8 = fn_state.u_33778;
        // D s_829_4: call decode_aarch32_instrs_UQASX_A1enc_A_txt(s_829_0, s_829_1, s_829_2, s_829_3)
        let s_829_4: () = decode_aarch32_instrs_UQASX_A1enc_A_txt(
            state,
            tracer,
            s_829_0,
            s_829_1,
            s_829_2,
            s_829_3,
        );
        // N s_829_5: return
        return;
    }
    fn block_830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_830_0: panic
        panic!("{:?}", ());
        // N s_830_1: return
        return;
    }
    fn block_831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_831_0: const #1u : u8
        let s_831_0: bool = true;
        // D s_831_1: write-var gs#410899 <= s_831_0
        fn_state.gs_410899 = s_831_0;
        // N s_831_2: jump b828
        return block_828(state, tracer, fn_state);
    }
    fn block_832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_832_0: const #1u : u8
        let s_832_0: bool = true;
        // D s_832_1: write-var gs#410896 <= s_832_0
        fn_state.gs_410896 = s_832_0;
        // N s_832_2: jump b826
        return block_826(state, tracer, fn_state);
    }
    fn block_833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_833_0: const #1u : u8
        let s_833_0: bool = true;
        // D s_833_1: write-var gs#410893 <= s_833_0
        fn_state.gs_410893 = s_833_0;
        // N s_833_2: jump b824
        return block_824(state, tracer, fn_state);
    }
    fn block_834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_834_0: read-var merge#var.1:struct
        let s_834_0: u32 = fn_state.merge_var._1;
        // D s_834_1: write-var u#33780 <= s_834_0
        fn_state.u_33780 = s_834_0;
        // C s_834_2: const #20s : i
        let s_834_2: i128 = 20;
        // D s_834_3: read-var u#33780:u32
        let s_834_3: u32 = fn_state.u_33780;
        // D s_834_4: cast zx s_834_3 -> bv
        let s_834_4: Bits = Bits::new(s_834_3 as u128, 32u16);
        // C s_834_5: const #1s : i64
        let s_834_5: i64 = 1;
        // C s_834_6: cast zx s_834_5 -> i
        let s_834_6: i128 = (i128::try_from(s_834_5).unwrap());
        // C s_834_7: const #7s : i
        let s_834_7: i128 = 7;
        // C s_834_8: add s_834_7 s_834_6
        let s_834_8: i128 = (s_834_7 + s_834_6);
        // D s_834_9: bit-extract s_834_4 s_834_2 s_834_8
        let s_834_9: Bits = (Bits::new(
            ((s_834_4) >> (s_834_2)).value(),
            u16::try_from(s_834_8).unwrap(),
        ));
        // D s_834_10: cast reint s_834_9 -> u8
        let s_834_10: u8 = (s_834_9.value() as u8);
        // D s_834_11: cast zx s_834_10 -> bv
        let s_834_11: Bits = Bits::new(s_834_10 as u128, 8u16);
        // C s_834_12: const #102u : u8
        let s_834_12: u8 = 102;
        // C s_834_13: cast zx s_834_12 -> bv
        let s_834_13: Bits = Bits::new(s_834_12 as u128, 8u16);
        // D s_834_14: cmp-eq s_834_11 s_834_13
        let s_834_14: bool = ((s_834_11) == (s_834_13));
        // N s_834_15: branch s_834_14 b1120 b835
        if s_834_14 {
            return block_1120(state, tracer, fn_state);
        } else {
            return block_835(state, tracer, fn_state);
        };
    }
    fn block_835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_835_0: const #0u : u8
        let s_835_0: bool = false;
        // D s_835_1: write-var gs#410905 <= s_835_0
        fn_state.gs_410905 = s_835_0;
        // N s_835_2: jump b836
        return block_836(state, tracer, fn_state);
    }
    fn block_836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_836_0: read-var gs#410905:u8
        let s_836_0: bool = fn_state.gs_410905;
        // N s_836_1: branch s_836_0 b1116 b837
        if s_836_0 {
            return block_1116(state, tracer, fn_state);
        } else {
            return block_837(state, tracer, fn_state);
        };
    }
    fn block_837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_837_0: const #0u : u8
        let s_837_0: bool = false;
        // D s_837_1: write-var gs#410910 <= s_837_0
        fn_state.gs_410910 = s_837_0;
        // N s_837_2: jump b838
        return block_838(state, tracer, fn_state);
    }
    fn block_838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_838_0: read-var gs#410910:u8
        let s_838_0: bool = fn_state.gs_410910;
        // D s_838_1: not s_838_0
        let s_838_1: bool = !s_838_0;
        // N s_838_2: branch s_838_1 b851 b839
        if s_838_1 {
            return block_851(state, tracer, fn_state);
        } else {
            return block_839(state, tracer, fn_state);
        };
    }
    fn block_839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_839_0: const #3316s : i
        let s_839_0: i128 = 3316;
        // C s_839_1: const #14696u : u32
        let s_839_1: u32 = 14696;
        // N s_839_2: write-reg s_839_1 <= s_839_0
        let s_839_2: () = {
            state.write_register::<i128>(s_839_1 as isize, s_839_0);
            tracer.write_register(s_839_1 as isize, s_839_0);
        };
        // C s_839_3: const #28s : i
        let s_839_3: i128 = 28;
        // C s_839_4: const #4s : i
        let s_839_4: i128 = 4;
        // D s_839_5: read-var u#33780:u32
        let s_839_5: u32 = fn_state.u_33780;
        // D s_839_6: cast zx s_839_5 -> bv
        let s_839_6: Bits = Bits::new(s_839_5 as u128, 32u16);
        // D s_839_7: bit-extract s_839_6 s_839_3 s_839_4
        let s_839_7: Bits = (Bits::new(
            ((s_839_6) >> (s_839_3)).value(),
            u16::try_from(s_839_4).unwrap(),
        ));
        // D s_839_8: cast reint s_839_7 -> u8
        let s_839_8: u8 = (s_839_7.value() as u8);
        // D s_839_9: write-var u#33781 <= s_839_8
        fn_state.u_33781 = s_839_8;
        // C s_839_10: const #16s : i
        let s_839_10: i128 = 16;
        // C s_839_11: const #4s : i
        let s_839_11: i128 = 4;
        // D s_839_12: read-var u#33780:u32
        let s_839_12: u32 = fn_state.u_33780;
        // D s_839_13: cast zx s_839_12 -> bv
        let s_839_13: Bits = Bits::new(s_839_12 as u128, 32u16);
        // D s_839_14: bit-extract s_839_13 s_839_10 s_839_11
        let s_839_14: Bits = (Bits::new(
            ((s_839_13) >> (s_839_10)).value(),
            u16::try_from(s_839_11).unwrap(),
        ));
        // D s_839_15: cast reint s_839_14 -> u8
        let s_839_15: u8 = (s_839_14.value() as u8);
        // D s_839_16: write-var u#33782 <= s_839_15
        fn_state.u_33782 = s_839_15;
        // C s_839_17: const #12s : i
        let s_839_17: i128 = 12;
        // C s_839_18: const #4s : i
        let s_839_18: i128 = 4;
        // D s_839_19: read-var u#33780:u32
        let s_839_19: u32 = fn_state.u_33780;
        // D s_839_20: cast zx s_839_19 -> bv
        let s_839_20: Bits = Bits::new(s_839_19 as u128, 32u16);
        // D s_839_21: bit-extract s_839_20 s_839_17 s_839_18
        let s_839_21: Bits = (Bits::new(
            ((s_839_20) >> (s_839_17)).value(),
            u16::try_from(s_839_18).unwrap(),
        ));
        // D s_839_22: cast reint s_839_21 -> u8
        let s_839_22: u8 = (s_839_21.value() as u8);
        // D s_839_23: write-var u#33783 <= s_839_22
        fn_state.u_33783 = s_839_22;
        // C s_839_24: const #0s : i
        let s_839_24: i128 = 0;
        // C s_839_25: const #4s : i
        let s_839_25: i128 = 4;
        // D s_839_26: read-var u#33780:u32
        let s_839_26: u32 = fn_state.u_33780;
        // D s_839_27: cast zx s_839_26 -> bv
        let s_839_27: Bits = Bits::new(s_839_26 as u128, 32u16);
        // D s_839_28: bit-extract s_839_27 s_839_24 s_839_25
        let s_839_28: Bits = (Bits::new(
            ((s_839_27) >> (s_839_24)).value(),
            u16::try_from(s_839_25).unwrap(),
        ));
        // D s_839_29: cast reint s_839_28 -> u8
        let s_839_29: u8 = (s_839_28.value() as u8);
        // D s_839_30: write-var u#33784 <= s_839_29
        fn_state.u_33784 = s_839_29;
        // C s_839_31: const #8s : i
        let s_839_31: i128 = 8;
        // D s_839_32: read-var u#33780:u32
        let s_839_32: u32 = fn_state.u_33780;
        // D s_839_33: cast zx s_839_32 -> bv
        let s_839_33: Bits = Bits::new(s_839_32 as u128, 32u16);
        // C s_839_34: const #1u : u64
        let s_839_34: u64 = 1;
        // D s_839_35: bit-extract s_839_33 s_839_31 s_839_34
        let s_839_35: Bits = (Bits::new(
            ((s_839_33) >> (s_839_31)).value(),
            u16::try_from(s_839_34).unwrap(),
        ));
        // D s_839_36: cast reint s_839_35 -> u8
        let s_839_36: bool = ((s_839_35.value()) != 0);
        // C s_839_37: const #0s : i
        let s_839_37: i128 = 0;
        // C s_839_38: const #0u : u64
        let s_839_38: u64 = 0;
        // D s_839_39: cast zx s_839_36 -> u64
        let s_839_39: u64 = (s_839_36 as u64);
        // C s_839_40: const #1u : u64
        let s_839_40: u64 = 1;
        // D s_839_41: and s_839_39 s_839_40
        let s_839_41: u64 = ((s_839_39) & (s_839_40));
        // D s_839_42: cmp-eq s_839_41 s_839_40
        let s_839_42: bool = ((s_839_41) == (s_839_40));
        // D s_839_43: lsl s_839_39 s_839_37
        let s_839_43: u64 = s_839_39 << s_839_37;
        // D s_839_44: or s_839_38 s_839_43
        let s_839_44: u64 = ((s_839_38) | (s_839_43));
        // D s_839_45: cmpl s_839_43
        let s_839_45: u64 = !s_839_43;
        // D s_839_46: and s_839_38 s_839_45
        let s_839_46: u64 = ((s_839_38) & (s_839_45));
        // D s_839_47: select s_839_42 s_839_44 s_839_46
        let s_839_47: u64 = if s_839_42 { s_839_44 } else { s_839_46 };
        // D s_839_48: cast trunc s_839_47 -> u8
        let s_839_48: bool = ((s_839_47) != 0);
        // D s_839_49: cast zx s_839_48 -> bv
        let s_839_49: Bits = Bits::new(s_839_48 as u128, 1u16);
        // C s_839_50: const #1u : u8
        let s_839_50: bool = true;
        // C s_839_51: cast zx s_839_50 -> bv
        let s_839_51: Bits = Bits::new(s_839_50 as u128, 1u16);
        // D s_839_52: cmp-ne s_839_49 s_839_51
        let s_839_52: bool = ((s_839_49) != (s_839_51));
        // N s_839_53: branch s_839_52 b850 b840
        if s_839_52 {
            return block_850(state, tracer, fn_state);
        } else {
            return block_840(state, tracer, fn_state);
        };
    }
    fn block_840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_840_0: const #9s : i
        let s_840_0: i128 = 9;
        // D s_840_1: read-var u#33780:u32
        let s_840_1: u32 = fn_state.u_33780;
        // D s_840_2: cast zx s_840_1 -> bv
        let s_840_2: Bits = Bits::new(s_840_1 as u128, 32u16);
        // C s_840_3: const #1u : u64
        let s_840_3: u64 = 1;
        // D s_840_4: bit-extract s_840_2 s_840_0 s_840_3
        let s_840_4: Bits = (Bits::new(
            ((s_840_2) >> (s_840_0)).value(),
            u16::try_from(s_840_3).unwrap(),
        ));
        // D s_840_5: cast reint s_840_4 -> u8
        let s_840_5: bool = ((s_840_4.value()) != 0);
        // C s_840_6: const #0s : i
        let s_840_6: i128 = 0;
        // C s_840_7: const #0u : u64
        let s_840_7: u64 = 0;
        // D s_840_8: cast zx s_840_5 -> u64
        let s_840_8: u64 = (s_840_5 as u64);
        // C s_840_9: const #1u : u64
        let s_840_9: u64 = 1;
        // D s_840_10: and s_840_8 s_840_9
        let s_840_10: u64 = ((s_840_8) & (s_840_9));
        // D s_840_11: cmp-eq s_840_10 s_840_9
        let s_840_11: bool = ((s_840_10) == (s_840_9));
        // D s_840_12: lsl s_840_8 s_840_6
        let s_840_12: u64 = s_840_8 << s_840_6;
        // D s_840_13: or s_840_7 s_840_12
        let s_840_13: u64 = ((s_840_7) | (s_840_12));
        // D s_840_14: cmpl s_840_12
        let s_840_14: u64 = !s_840_12;
        // D s_840_15: and s_840_7 s_840_14
        let s_840_15: u64 = ((s_840_7) & (s_840_14));
        // D s_840_16: select s_840_11 s_840_13 s_840_15
        let s_840_16: u64 = if s_840_11 { s_840_13 } else { s_840_15 };
        // D s_840_17: cast trunc s_840_16 -> u8
        let s_840_17: bool = ((s_840_16) != 0);
        // D s_840_18: cast zx s_840_17 -> bv
        let s_840_18: Bits = Bits::new(s_840_17 as u128, 1u16);
        // C s_840_19: const #1u : u8
        let s_840_19: bool = true;
        // C s_840_20: cast zx s_840_19 -> bv
        let s_840_20: Bits = Bits::new(s_840_19 as u128, 1u16);
        // D s_840_21: cmp-ne s_840_18 s_840_20
        let s_840_21: bool = ((s_840_18) != (s_840_20));
        // D s_840_22: write-var gs#410925 <= s_840_21
        fn_state.gs_410925 = s_840_21;
        // N s_840_23: jump b841
        return block_841(state, tracer, fn_state);
    }
    fn block_841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_841_0: read-var gs#410925:u8
        let s_841_0: bool = fn_state.gs_410925;
        // N s_841_1: branch s_841_0 b849 b842
        if s_841_0 {
            return block_849(state, tracer, fn_state);
        } else {
            return block_842(state, tracer, fn_state);
        };
    }
    fn block_842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_842_0: const #10s : i
        let s_842_0: i128 = 10;
        // D s_842_1: read-var u#33780:u32
        let s_842_1: u32 = fn_state.u_33780;
        // D s_842_2: cast zx s_842_1 -> bv
        let s_842_2: Bits = Bits::new(s_842_1 as u128, 32u16);
        // C s_842_3: const #1u : u64
        let s_842_3: u64 = 1;
        // D s_842_4: bit-extract s_842_2 s_842_0 s_842_3
        let s_842_4: Bits = (Bits::new(
            ((s_842_2) >> (s_842_0)).value(),
            u16::try_from(s_842_3).unwrap(),
        ));
        // D s_842_5: cast reint s_842_4 -> u8
        let s_842_5: bool = ((s_842_4.value()) != 0);
        // C s_842_6: const #0s : i
        let s_842_6: i128 = 0;
        // C s_842_7: const #0u : u64
        let s_842_7: u64 = 0;
        // D s_842_8: cast zx s_842_5 -> u64
        let s_842_8: u64 = (s_842_5 as u64);
        // C s_842_9: const #1u : u64
        let s_842_9: u64 = 1;
        // D s_842_10: and s_842_8 s_842_9
        let s_842_10: u64 = ((s_842_8) & (s_842_9));
        // D s_842_11: cmp-eq s_842_10 s_842_9
        let s_842_11: bool = ((s_842_10) == (s_842_9));
        // D s_842_12: lsl s_842_8 s_842_6
        let s_842_12: u64 = s_842_8 << s_842_6;
        // D s_842_13: or s_842_7 s_842_12
        let s_842_13: u64 = ((s_842_7) | (s_842_12));
        // D s_842_14: cmpl s_842_12
        let s_842_14: u64 = !s_842_12;
        // D s_842_15: and s_842_7 s_842_14
        let s_842_15: u64 = ((s_842_7) & (s_842_14));
        // D s_842_16: select s_842_11 s_842_13 s_842_15
        let s_842_16: u64 = if s_842_11 { s_842_13 } else { s_842_15 };
        // D s_842_17: cast trunc s_842_16 -> u8
        let s_842_17: bool = ((s_842_16) != 0);
        // D s_842_18: cast zx s_842_17 -> bv
        let s_842_18: Bits = Bits::new(s_842_17 as u128, 1u16);
        // C s_842_19: const #1u : u8
        let s_842_19: bool = true;
        // C s_842_20: cast zx s_842_19 -> bv
        let s_842_20: Bits = Bits::new(s_842_19 as u128, 1u16);
        // D s_842_21: cmp-ne s_842_18 s_842_20
        let s_842_21: bool = ((s_842_18) != (s_842_20));
        // D s_842_22: write-var gs#410928 <= s_842_21
        fn_state.gs_410928 = s_842_21;
        // N s_842_23: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_843_0: read-var gs#410928:u8
        let s_843_0: bool = fn_state.gs_410928;
        // N s_843_1: branch s_843_0 b848 b844
        if s_843_0 {
            return block_848(state, tracer, fn_state);
        } else {
            return block_844(state, tracer, fn_state);
        };
    }
    fn block_844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_844_0: const #11s : i
        let s_844_0: i128 = 11;
        // D s_844_1: read-var u#33780:u32
        let s_844_1: u32 = fn_state.u_33780;
        // D s_844_2: cast zx s_844_1 -> bv
        let s_844_2: Bits = Bits::new(s_844_1 as u128, 32u16);
        // C s_844_3: const #1u : u64
        let s_844_3: u64 = 1;
        // D s_844_4: bit-extract s_844_2 s_844_0 s_844_3
        let s_844_4: Bits = (Bits::new(
            ((s_844_2) >> (s_844_0)).value(),
            u16::try_from(s_844_3).unwrap(),
        ));
        // D s_844_5: cast reint s_844_4 -> u8
        let s_844_5: bool = ((s_844_4.value()) != 0);
        // C s_844_6: const #0s : i
        let s_844_6: i128 = 0;
        // C s_844_7: const #0u : u64
        let s_844_7: u64 = 0;
        // D s_844_8: cast zx s_844_5 -> u64
        let s_844_8: u64 = (s_844_5 as u64);
        // C s_844_9: const #1u : u64
        let s_844_9: u64 = 1;
        // D s_844_10: and s_844_8 s_844_9
        let s_844_10: u64 = ((s_844_8) & (s_844_9));
        // D s_844_11: cmp-eq s_844_10 s_844_9
        let s_844_11: bool = ((s_844_10) == (s_844_9));
        // D s_844_12: lsl s_844_8 s_844_6
        let s_844_12: u64 = s_844_8 << s_844_6;
        // D s_844_13: or s_844_7 s_844_12
        let s_844_13: u64 = ((s_844_7) | (s_844_12));
        // D s_844_14: cmpl s_844_12
        let s_844_14: u64 = !s_844_12;
        // D s_844_15: and s_844_7 s_844_14
        let s_844_15: u64 = ((s_844_7) & (s_844_14));
        // D s_844_16: select s_844_11 s_844_13 s_844_15
        let s_844_16: u64 = if s_844_11 { s_844_13 } else { s_844_15 };
        // D s_844_17: cast trunc s_844_16 -> u8
        let s_844_17: bool = ((s_844_16) != 0);
        // D s_844_18: cast zx s_844_17 -> bv
        let s_844_18: Bits = Bits::new(s_844_17 as u128, 1u16);
        // C s_844_19: const #1u : u8
        let s_844_19: bool = true;
        // C s_844_20: cast zx s_844_19 -> bv
        let s_844_20: Bits = Bits::new(s_844_19 as u128, 1u16);
        // D s_844_21: cmp-ne s_844_18 s_844_20
        let s_844_21: bool = ((s_844_18) != (s_844_20));
        // D s_844_22: write-var gs#410931 <= s_844_21
        fn_state.gs_410931 = s_844_21;
        // N s_844_23: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_845_0: read-var gs#410931:u8
        let s_845_0: bool = fn_state.gs_410931;
        // N s_845_1: branch s_845_0 b847 b846
        if s_845_0 {
            return block_847(state, tracer, fn_state);
        } else {
            return block_846(state, tracer, fn_state);
        };
    }
    fn block_846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_846_0: read-var u#33781:u8
        let s_846_0: u8 = fn_state.u_33781;
        // D s_846_1: read-var u#33782:u8
        let s_846_1: u8 = fn_state.u_33782;
        // D s_846_2: read-var u#33783:u8
        let s_846_2: u8 = fn_state.u_33783;
        // D s_846_3: read-var u#33784:u8
        let s_846_3: u8 = fn_state.u_33784;
        // D s_846_4: call decode_aarch32_instrs_UQSAX_A1enc_A_txt(s_846_0, s_846_1, s_846_2, s_846_3)
        let s_846_4: () = decode_aarch32_instrs_UQSAX_A1enc_A_txt(
            state,
            tracer,
            s_846_0,
            s_846_1,
            s_846_2,
            s_846_3,
        );
        // N s_846_5: return
        return;
    }
    fn block_847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_847_0: panic
        panic!("{:?}", ());
        // N s_847_1: return
        return;
    }
    fn block_848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_848_0: const #1u : u8
        let s_848_0: bool = true;
        // D s_848_1: write-var gs#410931 <= s_848_0
        fn_state.gs_410931 = s_848_0;
        // N s_848_2: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_849_0: const #1u : u8
        let s_849_0: bool = true;
        // D s_849_1: write-var gs#410928 <= s_849_0
        fn_state.gs_410928 = s_849_0;
        // N s_849_2: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_850_0: const #1u : u8
        let s_850_0: bool = true;
        // D s_850_1: write-var gs#410925 <= s_850_0
        fn_state.gs_410925 = s_850_0;
        // N s_850_2: jump b841
        return block_841(state, tracer, fn_state);
    }
    fn block_851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_851_0: read-var merge#var.1:struct
        let s_851_0: u32 = fn_state.merge_var._1;
        // D s_851_1: write-var u#33786 <= s_851_0
        fn_state.u_33786 = s_851_0;
        // C s_851_2: const #20s : i
        let s_851_2: i128 = 20;
        // D s_851_3: read-var u#33786:u32
        let s_851_3: u32 = fn_state.u_33786;
        // D s_851_4: cast zx s_851_3 -> bv
        let s_851_4: Bits = Bits::new(s_851_3 as u128, 32u16);
        // C s_851_5: const #1s : i64
        let s_851_5: i64 = 1;
        // C s_851_6: cast zx s_851_5 -> i
        let s_851_6: i128 = (i128::try_from(s_851_5).unwrap());
        // C s_851_7: const #7s : i
        let s_851_7: i128 = 7;
        // C s_851_8: add s_851_7 s_851_6
        let s_851_8: i128 = (s_851_7 + s_851_6);
        // D s_851_9: bit-extract s_851_4 s_851_2 s_851_8
        let s_851_9: Bits = (Bits::new(
            ((s_851_4) >> (s_851_2)).value(),
            u16::try_from(s_851_8).unwrap(),
        ));
        // D s_851_10: cast reint s_851_9 -> u8
        let s_851_10: u8 = (s_851_9.value() as u8);
        // D s_851_11: cast zx s_851_10 -> bv
        let s_851_11: Bits = Bits::new(s_851_10 as u128, 8u16);
        // C s_851_12: const #102u : u8
        let s_851_12: u8 = 102;
        // C s_851_13: cast zx s_851_12 -> bv
        let s_851_13: Bits = Bits::new(s_851_12 as u128, 8u16);
        // D s_851_14: cmp-eq s_851_11 s_851_13
        let s_851_14: bool = ((s_851_11) == (s_851_13));
        // N s_851_15: branch s_851_14 b1115 b852
        if s_851_14 {
            return block_1115(state, tracer, fn_state);
        } else {
            return block_852(state, tracer, fn_state);
        };
    }
    fn block_852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_852_0: const #0u : u8
        let s_852_0: bool = false;
        // D s_852_1: write-var gs#410937 <= s_852_0
        fn_state.gs_410937 = s_852_0;
        // N s_852_2: jump b853
        return block_853(state, tracer, fn_state);
    }
    fn block_853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_853_0: read-var gs#410937:u8
        let s_853_0: bool = fn_state.gs_410937;
        // N s_853_1: branch s_853_0 b1111 b854
        if s_853_0 {
            return block_1111(state, tracer, fn_state);
        } else {
            return block_854(state, tracer, fn_state);
        };
    }
    fn block_854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_854_0: const #0u : u8
        let s_854_0: bool = false;
        // D s_854_1: write-var gs#410942 <= s_854_0
        fn_state.gs_410942 = s_854_0;
        // N s_854_2: jump b855
        return block_855(state, tracer, fn_state);
    }
    fn block_855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_855_0: read-var gs#410942:u8
        let s_855_0: bool = fn_state.gs_410942;
        // D s_855_1: not s_855_0
        let s_855_1: bool = !s_855_0;
        // N s_855_2: branch s_855_1 b868 b856
        if s_855_1 {
            return block_868(state, tracer, fn_state);
        } else {
            return block_856(state, tracer, fn_state);
        };
    }
    fn block_856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_856_0: const #3318s : i
        let s_856_0: i128 = 3318;
        // C s_856_1: const #14696u : u32
        let s_856_1: u32 = 14696;
        // N s_856_2: write-reg s_856_1 <= s_856_0
        let s_856_2: () = {
            state.write_register::<i128>(s_856_1 as isize, s_856_0);
            tracer.write_register(s_856_1 as isize, s_856_0);
        };
        // C s_856_3: const #28s : i
        let s_856_3: i128 = 28;
        // C s_856_4: const #4s : i
        let s_856_4: i128 = 4;
        // D s_856_5: read-var u#33786:u32
        let s_856_5: u32 = fn_state.u_33786;
        // D s_856_6: cast zx s_856_5 -> bv
        let s_856_6: Bits = Bits::new(s_856_5 as u128, 32u16);
        // D s_856_7: bit-extract s_856_6 s_856_3 s_856_4
        let s_856_7: Bits = (Bits::new(
            ((s_856_6) >> (s_856_3)).value(),
            u16::try_from(s_856_4).unwrap(),
        ));
        // D s_856_8: cast reint s_856_7 -> u8
        let s_856_8: u8 = (s_856_7.value() as u8);
        // D s_856_9: write-var u#33787 <= s_856_8
        fn_state.u_33787 = s_856_8;
        // C s_856_10: const #16s : i
        let s_856_10: i128 = 16;
        // C s_856_11: const #4s : i
        let s_856_11: i128 = 4;
        // D s_856_12: read-var u#33786:u32
        let s_856_12: u32 = fn_state.u_33786;
        // D s_856_13: cast zx s_856_12 -> bv
        let s_856_13: Bits = Bits::new(s_856_12 as u128, 32u16);
        // D s_856_14: bit-extract s_856_13 s_856_10 s_856_11
        let s_856_14: Bits = (Bits::new(
            ((s_856_13) >> (s_856_10)).value(),
            u16::try_from(s_856_11).unwrap(),
        ));
        // D s_856_15: cast reint s_856_14 -> u8
        let s_856_15: u8 = (s_856_14.value() as u8);
        // D s_856_16: write-var u#33788 <= s_856_15
        fn_state.u_33788 = s_856_15;
        // C s_856_17: const #12s : i
        let s_856_17: i128 = 12;
        // C s_856_18: const #4s : i
        let s_856_18: i128 = 4;
        // D s_856_19: read-var u#33786:u32
        let s_856_19: u32 = fn_state.u_33786;
        // D s_856_20: cast zx s_856_19 -> bv
        let s_856_20: Bits = Bits::new(s_856_19 as u128, 32u16);
        // D s_856_21: bit-extract s_856_20 s_856_17 s_856_18
        let s_856_21: Bits = (Bits::new(
            ((s_856_20) >> (s_856_17)).value(),
            u16::try_from(s_856_18).unwrap(),
        ));
        // D s_856_22: cast reint s_856_21 -> u8
        let s_856_22: u8 = (s_856_21.value() as u8);
        // D s_856_23: write-var u#33789 <= s_856_22
        fn_state.u_33789 = s_856_22;
        // C s_856_24: const #0s : i
        let s_856_24: i128 = 0;
        // C s_856_25: const #4s : i
        let s_856_25: i128 = 4;
        // D s_856_26: read-var u#33786:u32
        let s_856_26: u32 = fn_state.u_33786;
        // D s_856_27: cast zx s_856_26 -> bv
        let s_856_27: Bits = Bits::new(s_856_26 as u128, 32u16);
        // D s_856_28: bit-extract s_856_27 s_856_24 s_856_25
        let s_856_28: Bits = (Bits::new(
            ((s_856_27) >> (s_856_24)).value(),
            u16::try_from(s_856_25).unwrap(),
        ));
        // D s_856_29: cast reint s_856_28 -> u8
        let s_856_29: u8 = (s_856_28.value() as u8);
        // D s_856_30: write-var u#33790 <= s_856_29
        fn_state.u_33790 = s_856_29;
        // C s_856_31: const #8s : i
        let s_856_31: i128 = 8;
        // D s_856_32: read-var u#33786:u32
        let s_856_32: u32 = fn_state.u_33786;
        // D s_856_33: cast zx s_856_32 -> bv
        let s_856_33: Bits = Bits::new(s_856_32 as u128, 32u16);
        // C s_856_34: const #1u : u64
        let s_856_34: u64 = 1;
        // D s_856_35: bit-extract s_856_33 s_856_31 s_856_34
        let s_856_35: Bits = (Bits::new(
            ((s_856_33) >> (s_856_31)).value(),
            u16::try_from(s_856_34).unwrap(),
        ));
        // D s_856_36: cast reint s_856_35 -> u8
        let s_856_36: bool = ((s_856_35.value()) != 0);
        // C s_856_37: const #0s : i
        let s_856_37: i128 = 0;
        // C s_856_38: const #0u : u64
        let s_856_38: u64 = 0;
        // D s_856_39: cast zx s_856_36 -> u64
        let s_856_39: u64 = (s_856_36 as u64);
        // C s_856_40: const #1u : u64
        let s_856_40: u64 = 1;
        // D s_856_41: and s_856_39 s_856_40
        let s_856_41: u64 = ((s_856_39) & (s_856_40));
        // D s_856_42: cmp-eq s_856_41 s_856_40
        let s_856_42: bool = ((s_856_41) == (s_856_40));
        // D s_856_43: lsl s_856_39 s_856_37
        let s_856_43: u64 = s_856_39 << s_856_37;
        // D s_856_44: or s_856_38 s_856_43
        let s_856_44: u64 = ((s_856_38) | (s_856_43));
        // D s_856_45: cmpl s_856_43
        let s_856_45: u64 = !s_856_43;
        // D s_856_46: and s_856_38 s_856_45
        let s_856_46: u64 = ((s_856_38) & (s_856_45));
        // D s_856_47: select s_856_42 s_856_44 s_856_46
        let s_856_47: u64 = if s_856_42 { s_856_44 } else { s_856_46 };
        // D s_856_48: cast trunc s_856_47 -> u8
        let s_856_48: bool = ((s_856_47) != 0);
        // D s_856_49: cast zx s_856_48 -> bv
        let s_856_49: Bits = Bits::new(s_856_48 as u128, 1u16);
        // C s_856_50: const #1u : u8
        let s_856_50: bool = true;
        // C s_856_51: cast zx s_856_50 -> bv
        let s_856_51: Bits = Bits::new(s_856_50 as u128, 1u16);
        // D s_856_52: cmp-ne s_856_49 s_856_51
        let s_856_52: bool = ((s_856_49) != (s_856_51));
        // N s_856_53: branch s_856_52 b867 b857
        if s_856_52 {
            return block_867(state, tracer, fn_state);
        } else {
            return block_857(state, tracer, fn_state);
        };
    }
    fn block_857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_857_0: const #9s : i
        let s_857_0: i128 = 9;
        // D s_857_1: read-var u#33786:u32
        let s_857_1: u32 = fn_state.u_33786;
        // D s_857_2: cast zx s_857_1 -> bv
        let s_857_2: Bits = Bits::new(s_857_1 as u128, 32u16);
        // C s_857_3: const #1u : u64
        let s_857_3: u64 = 1;
        // D s_857_4: bit-extract s_857_2 s_857_0 s_857_3
        let s_857_4: Bits = (Bits::new(
            ((s_857_2) >> (s_857_0)).value(),
            u16::try_from(s_857_3).unwrap(),
        ));
        // D s_857_5: cast reint s_857_4 -> u8
        let s_857_5: bool = ((s_857_4.value()) != 0);
        // C s_857_6: const #0s : i
        let s_857_6: i128 = 0;
        // C s_857_7: const #0u : u64
        let s_857_7: u64 = 0;
        // D s_857_8: cast zx s_857_5 -> u64
        let s_857_8: u64 = (s_857_5 as u64);
        // C s_857_9: const #1u : u64
        let s_857_9: u64 = 1;
        // D s_857_10: and s_857_8 s_857_9
        let s_857_10: u64 = ((s_857_8) & (s_857_9));
        // D s_857_11: cmp-eq s_857_10 s_857_9
        let s_857_11: bool = ((s_857_10) == (s_857_9));
        // D s_857_12: lsl s_857_8 s_857_6
        let s_857_12: u64 = s_857_8 << s_857_6;
        // D s_857_13: or s_857_7 s_857_12
        let s_857_13: u64 = ((s_857_7) | (s_857_12));
        // D s_857_14: cmpl s_857_12
        let s_857_14: u64 = !s_857_12;
        // D s_857_15: and s_857_7 s_857_14
        let s_857_15: u64 = ((s_857_7) & (s_857_14));
        // D s_857_16: select s_857_11 s_857_13 s_857_15
        let s_857_16: u64 = if s_857_11 { s_857_13 } else { s_857_15 };
        // D s_857_17: cast trunc s_857_16 -> u8
        let s_857_17: bool = ((s_857_16) != 0);
        // D s_857_18: cast zx s_857_17 -> bv
        let s_857_18: Bits = Bits::new(s_857_17 as u128, 1u16);
        // C s_857_19: const #1u : u8
        let s_857_19: bool = true;
        // C s_857_20: cast zx s_857_19 -> bv
        let s_857_20: Bits = Bits::new(s_857_19 as u128, 1u16);
        // D s_857_21: cmp-ne s_857_18 s_857_20
        let s_857_21: bool = ((s_857_18) != (s_857_20));
        // D s_857_22: write-var gs#410957 <= s_857_21
        fn_state.gs_410957 = s_857_21;
        // N s_857_23: jump b858
        return block_858(state, tracer, fn_state);
    }
    fn block_858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_858_0: read-var gs#410957:u8
        let s_858_0: bool = fn_state.gs_410957;
        // N s_858_1: branch s_858_0 b866 b859
        if s_858_0 {
            return block_866(state, tracer, fn_state);
        } else {
            return block_859(state, tracer, fn_state);
        };
    }
    fn block_859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_859_0: const #10s : i
        let s_859_0: i128 = 10;
        // D s_859_1: read-var u#33786:u32
        let s_859_1: u32 = fn_state.u_33786;
        // D s_859_2: cast zx s_859_1 -> bv
        let s_859_2: Bits = Bits::new(s_859_1 as u128, 32u16);
        // C s_859_3: const #1u : u64
        let s_859_3: u64 = 1;
        // D s_859_4: bit-extract s_859_2 s_859_0 s_859_3
        let s_859_4: Bits = (Bits::new(
            ((s_859_2) >> (s_859_0)).value(),
            u16::try_from(s_859_3).unwrap(),
        ));
        // D s_859_5: cast reint s_859_4 -> u8
        let s_859_5: bool = ((s_859_4.value()) != 0);
        // C s_859_6: const #0s : i
        let s_859_6: i128 = 0;
        // C s_859_7: const #0u : u64
        let s_859_7: u64 = 0;
        // D s_859_8: cast zx s_859_5 -> u64
        let s_859_8: u64 = (s_859_5 as u64);
        // C s_859_9: const #1u : u64
        let s_859_9: u64 = 1;
        // D s_859_10: and s_859_8 s_859_9
        let s_859_10: u64 = ((s_859_8) & (s_859_9));
        // D s_859_11: cmp-eq s_859_10 s_859_9
        let s_859_11: bool = ((s_859_10) == (s_859_9));
        // D s_859_12: lsl s_859_8 s_859_6
        let s_859_12: u64 = s_859_8 << s_859_6;
        // D s_859_13: or s_859_7 s_859_12
        let s_859_13: u64 = ((s_859_7) | (s_859_12));
        // D s_859_14: cmpl s_859_12
        let s_859_14: u64 = !s_859_12;
        // D s_859_15: and s_859_7 s_859_14
        let s_859_15: u64 = ((s_859_7) & (s_859_14));
        // D s_859_16: select s_859_11 s_859_13 s_859_15
        let s_859_16: u64 = if s_859_11 { s_859_13 } else { s_859_15 };
        // D s_859_17: cast trunc s_859_16 -> u8
        let s_859_17: bool = ((s_859_16) != 0);
        // D s_859_18: cast zx s_859_17 -> bv
        let s_859_18: Bits = Bits::new(s_859_17 as u128, 1u16);
        // C s_859_19: const #1u : u8
        let s_859_19: bool = true;
        // C s_859_20: cast zx s_859_19 -> bv
        let s_859_20: Bits = Bits::new(s_859_19 as u128, 1u16);
        // D s_859_21: cmp-ne s_859_18 s_859_20
        let s_859_21: bool = ((s_859_18) != (s_859_20));
        // D s_859_22: write-var gs#410960 <= s_859_21
        fn_state.gs_410960 = s_859_21;
        // N s_859_23: jump b860
        return block_860(state, tracer, fn_state);
    }
    fn block_860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_860_0: read-var gs#410960:u8
        let s_860_0: bool = fn_state.gs_410960;
        // N s_860_1: branch s_860_0 b865 b861
        if s_860_0 {
            return block_865(state, tracer, fn_state);
        } else {
            return block_861(state, tracer, fn_state);
        };
    }
    fn block_861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_861_0: const #11s : i
        let s_861_0: i128 = 11;
        // D s_861_1: read-var u#33786:u32
        let s_861_1: u32 = fn_state.u_33786;
        // D s_861_2: cast zx s_861_1 -> bv
        let s_861_2: Bits = Bits::new(s_861_1 as u128, 32u16);
        // C s_861_3: const #1u : u64
        let s_861_3: u64 = 1;
        // D s_861_4: bit-extract s_861_2 s_861_0 s_861_3
        let s_861_4: Bits = (Bits::new(
            ((s_861_2) >> (s_861_0)).value(),
            u16::try_from(s_861_3).unwrap(),
        ));
        // D s_861_5: cast reint s_861_4 -> u8
        let s_861_5: bool = ((s_861_4.value()) != 0);
        // C s_861_6: const #0s : i
        let s_861_6: i128 = 0;
        // C s_861_7: const #0u : u64
        let s_861_7: u64 = 0;
        // D s_861_8: cast zx s_861_5 -> u64
        let s_861_8: u64 = (s_861_5 as u64);
        // C s_861_9: const #1u : u64
        let s_861_9: u64 = 1;
        // D s_861_10: and s_861_8 s_861_9
        let s_861_10: u64 = ((s_861_8) & (s_861_9));
        // D s_861_11: cmp-eq s_861_10 s_861_9
        let s_861_11: bool = ((s_861_10) == (s_861_9));
        // D s_861_12: lsl s_861_8 s_861_6
        let s_861_12: u64 = s_861_8 << s_861_6;
        // D s_861_13: or s_861_7 s_861_12
        let s_861_13: u64 = ((s_861_7) | (s_861_12));
        // D s_861_14: cmpl s_861_12
        let s_861_14: u64 = !s_861_12;
        // D s_861_15: and s_861_7 s_861_14
        let s_861_15: u64 = ((s_861_7) & (s_861_14));
        // D s_861_16: select s_861_11 s_861_13 s_861_15
        let s_861_16: u64 = if s_861_11 { s_861_13 } else { s_861_15 };
        // D s_861_17: cast trunc s_861_16 -> u8
        let s_861_17: bool = ((s_861_16) != 0);
        // D s_861_18: cast zx s_861_17 -> bv
        let s_861_18: Bits = Bits::new(s_861_17 as u128, 1u16);
        // C s_861_19: const #1u : u8
        let s_861_19: bool = true;
        // C s_861_20: cast zx s_861_19 -> bv
        let s_861_20: Bits = Bits::new(s_861_19 as u128, 1u16);
        // D s_861_21: cmp-ne s_861_18 s_861_20
        let s_861_21: bool = ((s_861_18) != (s_861_20));
        // D s_861_22: write-var gs#410963 <= s_861_21
        fn_state.gs_410963 = s_861_21;
        // N s_861_23: jump b862
        return block_862(state, tracer, fn_state);
    }
    fn block_862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_862_0: read-var gs#410963:u8
        let s_862_0: bool = fn_state.gs_410963;
        // N s_862_1: branch s_862_0 b864 b863
        if s_862_0 {
            return block_864(state, tracer, fn_state);
        } else {
            return block_863(state, tracer, fn_state);
        };
    }
    fn block_863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_863_0: read-var u#33787:u8
        let s_863_0: u8 = fn_state.u_33787;
        // D s_863_1: read-var u#33788:u8
        let s_863_1: u8 = fn_state.u_33788;
        // D s_863_2: read-var u#33789:u8
        let s_863_2: u8 = fn_state.u_33789;
        // D s_863_3: read-var u#33790:u8
        let s_863_3: u8 = fn_state.u_33790;
        // D s_863_4: call decode_aarch32_instrs_UQSUB16_A1enc_A_txt(s_863_0, s_863_1, s_863_2, s_863_3)
        let s_863_4: () = decode_aarch32_instrs_UQSUB16_A1enc_A_txt(
            state,
            tracer,
            s_863_0,
            s_863_1,
            s_863_2,
            s_863_3,
        );
        // N s_863_5: return
        return;
    }
    fn block_864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_864_0: panic
        panic!("{:?}", ());
        // N s_864_1: return
        return;
    }
    fn block_865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_865_0: const #1u : u8
        let s_865_0: bool = true;
        // D s_865_1: write-var gs#410963 <= s_865_0
        fn_state.gs_410963 = s_865_0;
        // N s_865_2: jump b862
        return block_862(state, tracer, fn_state);
    }
    fn block_866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_866_0: const #1u : u8
        let s_866_0: bool = true;
        // D s_866_1: write-var gs#410960 <= s_866_0
        fn_state.gs_410960 = s_866_0;
        // N s_866_2: jump b860
        return block_860(state, tracer, fn_state);
    }
    fn block_867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_867_0: const #1u : u8
        let s_867_0: bool = true;
        // D s_867_1: write-var gs#410957 <= s_867_0
        fn_state.gs_410957 = s_867_0;
        // N s_867_2: jump b858
        return block_858(state, tracer, fn_state);
    }
    fn block_868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_868_0: read-var merge#var.1:struct
        let s_868_0: u32 = fn_state.merge_var._1;
        // D s_868_1: write-var u#33792 <= s_868_0
        fn_state.u_33792 = s_868_0;
        // C s_868_2: const #20s : i
        let s_868_2: i128 = 20;
        // D s_868_3: read-var u#33792:u32
        let s_868_3: u32 = fn_state.u_33792;
        // D s_868_4: cast zx s_868_3 -> bv
        let s_868_4: Bits = Bits::new(s_868_3 as u128, 32u16);
        // C s_868_5: const #1s : i64
        let s_868_5: i64 = 1;
        // C s_868_6: cast zx s_868_5 -> i
        let s_868_6: i128 = (i128::try_from(s_868_5).unwrap());
        // C s_868_7: const #7s : i
        let s_868_7: i128 = 7;
        // C s_868_8: add s_868_7 s_868_6
        let s_868_8: i128 = (s_868_7 + s_868_6);
        // D s_868_9: bit-extract s_868_4 s_868_2 s_868_8
        let s_868_9: Bits = (Bits::new(
            ((s_868_4) >> (s_868_2)).value(),
            u16::try_from(s_868_8).unwrap(),
        ));
        // D s_868_10: cast reint s_868_9 -> u8
        let s_868_10: u8 = (s_868_9.value() as u8);
        // D s_868_11: cast zx s_868_10 -> bv
        let s_868_11: Bits = Bits::new(s_868_10 as u128, 8u16);
        // C s_868_12: const #102u : u8
        let s_868_12: u8 = 102;
        // C s_868_13: cast zx s_868_12 -> bv
        let s_868_13: Bits = Bits::new(s_868_12 as u128, 8u16);
        // D s_868_14: cmp-eq s_868_11 s_868_13
        let s_868_14: bool = ((s_868_11) == (s_868_13));
        // N s_868_15: branch s_868_14 b1110 b869
        if s_868_14 {
            return block_1110(state, tracer, fn_state);
        } else {
            return block_869(state, tracer, fn_state);
        };
    }
    fn block_869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_869_0: const #0u : u8
        let s_869_0: bool = false;
        // D s_869_1: write-var gs#410969 <= s_869_0
        fn_state.gs_410969 = s_869_0;
        // N s_869_2: jump b870
        return block_870(state, tracer, fn_state);
    }
    fn block_870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_870_0: read-var gs#410969:u8
        let s_870_0: bool = fn_state.gs_410969;
        // N s_870_1: branch s_870_0 b1106 b871
        if s_870_0 {
            return block_1106(state, tracer, fn_state);
        } else {
            return block_871(state, tracer, fn_state);
        };
    }
    fn block_871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_871_0: const #0u : u8
        let s_871_0: bool = false;
        // D s_871_1: write-var gs#410974 <= s_871_0
        fn_state.gs_410974 = s_871_0;
        // N s_871_2: jump b872
        return block_872(state, tracer, fn_state);
    }
    fn block_872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_872_0: read-var gs#410974:u8
        let s_872_0: bool = fn_state.gs_410974;
        // D s_872_1: not s_872_0
        let s_872_1: bool = !s_872_0;
        // N s_872_2: branch s_872_1 b885 b873
        if s_872_1 {
            return block_885(state, tracer, fn_state);
        } else {
            return block_873(state, tracer, fn_state);
        };
    }
    fn block_873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_873_0: const #3320s : i
        let s_873_0: i128 = 3320;
        // C s_873_1: const #14696u : u32
        let s_873_1: u32 = 14696;
        // N s_873_2: write-reg s_873_1 <= s_873_0
        let s_873_2: () = {
            state.write_register::<i128>(s_873_1 as isize, s_873_0);
            tracer.write_register(s_873_1 as isize, s_873_0);
        };
        // C s_873_3: const #28s : i
        let s_873_3: i128 = 28;
        // C s_873_4: const #4s : i
        let s_873_4: i128 = 4;
        // D s_873_5: read-var u#33792:u32
        let s_873_5: u32 = fn_state.u_33792;
        // D s_873_6: cast zx s_873_5 -> bv
        let s_873_6: Bits = Bits::new(s_873_5 as u128, 32u16);
        // D s_873_7: bit-extract s_873_6 s_873_3 s_873_4
        let s_873_7: Bits = (Bits::new(
            ((s_873_6) >> (s_873_3)).value(),
            u16::try_from(s_873_4).unwrap(),
        ));
        // D s_873_8: cast reint s_873_7 -> u8
        let s_873_8: u8 = (s_873_7.value() as u8);
        // D s_873_9: write-var u#33793 <= s_873_8
        fn_state.u_33793 = s_873_8;
        // C s_873_10: const #16s : i
        let s_873_10: i128 = 16;
        // C s_873_11: const #4s : i
        let s_873_11: i128 = 4;
        // D s_873_12: read-var u#33792:u32
        let s_873_12: u32 = fn_state.u_33792;
        // D s_873_13: cast zx s_873_12 -> bv
        let s_873_13: Bits = Bits::new(s_873_12 as u128, 32u16);
        // D s_873_14: bit-extract s_873_13 s_873_10 s_873_11
        let s_873_14: Bits = (Bits::new(
            ((s_873_13) >> (s_873_10)).value(),
            u16::try_from(s_873_11).unwrap(),
        ));
        // D s_873_15: cast reint s_873_14 -> u8
        let s_873_15: u8 = (s_873_14.value() as u8);
        // D s_873_16: write-var u#33794 <= s_873_15
        fn_state.u_33794 = s_873_15;
        // C s_873_17: const #12s : i
        let s_873_17: i128 = 12;
        // C s_873_18: const #4s : i
        let s_873_18: i128 = 4;
        // D s_873_19: read-var u#33792:u32
        let s_873_19: u32 = fn_state.u_33792;
        // D s_873_20: cast zx s_873_19 -> bv
        let s_873_20: Bits = Bits::new(s_873_19 as u128, 32u16);
        // D s_873_21: bit-extract s_873_20 s_873_17 s_873_18
        let s_873_21: Bits = (Bits::new(
            ((s_873_20) >> (s_873_17)).value(),
            u16::try_from(s_873_18).unwrap(),
        ));
        // D s_873_22: cast reint s_873_21 -> u8
        let s_873_22: u8 = (s_873_21.value() as u8);
        // D s_873_23: write-var u#33795 <= s_873_22
        fn_state.u_33795 = s_873_22;
        // C s_873_24: const #0s : i
        let s_873_24: i128 = 0;
        // C s_873_25: const #4s : i
        let s_873_25: i128 = 4;
        // D s_873_26: read-var u#33792:u32
        let s_873_26: u32 = fn_state.u_33792;
        // D s_873_27: cast zx s_873_26 -> bv
        let s_873_27: Bits = Bits::new(s_873_26 as u128, 32u16);
        // D s_873_28: bit-extract s_873_27 s_873_24 s_873_25
        let s_873_28: Bits = (Bits::new(
            ((s_873_27) >> (s_873_24)).value(),
            u16::try_from(s_873_25).unwrap(),
        ));
        // D s_873_29: cast reint s_873_28 -> u8
        let s_873_29: u8 = (s_873_28.value() as u8);
        // D s_873_30: write-var u#33796 <= s_873_29
        fn_state.u_33796 = s_873_29;
        // C s_873_31: const #8s : i
        let s_873_31: i128 = 8;
        // D s_873_32: read-var u#33792:u32
        let s_873_32: u32 = fn_state.u_33792;
        // D s_873_33: cast zx s_873_32 -> bv
        let s_873_33: Bits = Bits::new(s_873_32 as u128, 32u16);
        // C s_873_34: const #1u : u64
        let s_873_34: u64 = 1;
        // D s_873_35: bit-extract s_873_33 s_873_31 s_873_34
        let s_873_35: Bits = (Bits::new(
            ((s_873_33) >> (s_873_31)).value(),
            u16::try_from(s_873_34).unwrap(),
        ));
        // D s_873_36: cast reint s_873_35 -> u8
        let s_873_36: bool = ((s_873_35.value()) != 0);
        // C s_873_37: const #0s : i
        let s_873_37: i128 = 0;
        // C s_873_38: const #0u : u64
        let s_873_38: u64 = 0;
        // D s_873_39: cast zx s_873_36 -> u64
        let s_873_39: u64 = (s_873_36 as u64);
        // C s_873_40: const #1u : u64
        let s_873_40: u64 = 1;
        // D s_873_41: and s_873_39 s_873_40
        let s_873_41: u64 = ((s_873_39) & (s_873_40));
        // D s_873_42: cmp-eq s_873_41 s_873_40
        let s_873_42: bool = ((s_873_41) == (s_873_40));
        // D s_873_43: lsl s_873_39 s_873_37
        let s_873_43: u64 = s_873_39 << s_873_37;
        // D s_873_44: or s_873_38 s_873_43
        let s_873_44: u64 = ((s_873_38) | (s_873_43));
        // D s_873_45: cmpl s_873_43
        let s_873_45: u64 = !s_873_43;
        // D s_873_46: and s_873_38 s_873_45
        let s_873_46: u64 = ((s_873_38) & (s_873_45));
        // D s_873_47: select s_873_42 s_873_44 s_873_46
        let s_873_47: u64 = if s_873_42 { s_873_44 } else { s_873_46 };
        // D s_873_48: cast trunc s_873_47 -> u8
        let s_873_48: bool = ((s_873_47) != 0);
        // D s_873_49: cast zx s_873_48 -> bv
        let s_873_49: Bits = Bits::new(s_873_48 as u128, 1u16);
        // C s_873_50: const #1u : u8
        let s_873_50: bool = true;
        // C s_873_51: cast zx s_873_50 -> bv
        let s_873_51: Bits = Bits::new(s_873_50 as u128, 1u16);
        // D s_873_52: cmp-ne s_873_49 s_873_51
        let s_873_52: bool = ((s_873_49) != (s_873_51));
        // N s_873_53: branch s_873_52 b884 b874
        if s_873_52 {
            return block_884(state, tracer, fn_state);
        } else {
            return block_874(state, tracer, fn_state);
        };
    }
    fn block_874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_874_0: const #9s : i
        let s_874_0: i128 = 9;
        // D s_874_1: read-var u#33792:u32
        let s_874_1: u32 = fn_state.u_33792;
        // D s_874_2: cast zx s_874_1 -> bv
        let s_874_2: Bits = Bits::new(s_874_1 as u128, 32u16);
        // C s_874_3: const #1u : u64
        let s_874_3: u64 = 1;
        // D s_874_4: bit-extract s_874_2 s_874_0 s_874_3
        let s_874_4: Bits = (Bits::new(
            ((s_874_2) >> (s_874_0)).value(),
            u16::try_from(s_874_3).unwrap(),
        ));
        // D s_874_5: cast reint s_874_4 -> u8
        let s_874_5: bool = ((s_874_4.value()) != 0);
        // C s_874_6: const #0s : i
        let s_874_6: i128 = 0;
        // C s_874_7: const #0u : u64
        let s_874_7: u64 = 0;
        // D s_874_8: cast zx s_874_5 -> u64
        let s_874_8: u64 = (s_874_5 as u64);
        // C s_874_9: const #1u : u64
        let s_874_9: u64 = 1;
        // D s_874_10: and s_874_8 s_874_9
        let s_874_10: u64 = ((s_874_8) & (s_874_9));
        // D s_874_11: cmp-eq s_874_10 s_874_9
        let s_874_11: bool = ((s_874_10) == (s_874_9));
        // D s_874_12: lsl s_874_8 s_874_6
        let s_874_12: u64 = s_874_8 << s_874_6;
        // D s_874_13: or s_874_7 s_874_12
        let s_874_13: u64 = ((s_874_7) | (s_874_12));
        // D s_874_14: cmpl s_874_12
        let s_874_14: u64 = !s_874_12;
        // D s_874_15: and s_874_7 s_874_14
        let s_874_15: u64 = ((s_874_7) & (s_874_14));
        // D s_874_16: select s_874_11 s_874_13 s_874_15
        let s_874_16: u64 = if s_874_11 { s_874_13 } else { s_874_15 };
        // D s_874_17: cast trunc s_874_16 -> u8
        let s_874_17: bool = ((s_874_16) != 0);
        // D s_874_18: cast zx s_874_17 -> bv
        let s_874_18: Bits = Bits::new(s_874_17 as u128, 1u16);
        // C s_874_19: const #1u : u8
        let s_874_19: bool = true;
        // C s_874_20: cast zx s_874_19 -> bv
        let s_874_20: Bits = Bits::new(s_874_19 as u128, 1u16);
        // D s_874_21: cmp-ne s_874_18 s_874_20
        let s_874_21: bool = ((s_874_18) != (s_874_20));
        // D s_874_22: write-var gs#410989 <= s_874_21
        fn_state.gs_410989 = s_874_21;
        // N s_874_23: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_875_0: read-var gs#410989:u8
        let s_875_0: bool = fn_state.gs_410989;
        // N s_875_1: branch s_875_0 b883 b876
        if s_875_0 {
            return block_883(state, tracer, fn_state);
        } else {
            return block_876(state, tracer, fn_state);
        };
    }
    fn block_876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_876_0: const #10s : i
        let s_876_0: i128 = 10;
        // D s_876_1: read-var u#33792:u32
        let s_876_1: u32 = fn_state.u_33792;
        // D s_876_2: cast zx s_876_1 -> bv
        let s_876_2: Bits = Bits::new(s_876_1 as u128, 32u16);
        // C s_876_3: const #1u : u64
        let s_876_3: u64 = 1;
        // D s_876_4: bit-extract s_876_2 s_876_0 s_876_3
        let s_876_4: Bits = (Bits::new(
            ((s_876_2) >> (s_876_0)).value(),
            u16::try_from(s_876_3).unwrap(),
        ));
        // D s_876_5: cast reint s_876_4 -> u8
        let s_876_5: bool = ((s_876_4.value()) != 0);
        // C s_876_6: const #0s : i
        let s_876_6: i128 = 0;
        // C s_876_7: const #0u : u64
        let s_876_7: u64 = 0;
        // D s_876_8: cast zx s_876_5 -> u64
        let s_876_8: u64 = (s_876_5 as u64);
        // C s_876_9: const #1u : u64
        let s_876_9: u64 = 1;
        // D s_876_10: and s_876_8 s_876_9
        let s_876_10: u64 = ((s_876_8) & (s_876_9));
        // D s_876_11: cmp-eq s_876_10 s_876_9
        let s_876_11: bool = ((s_876_10) == (s_876_9));
        // D s_876_12: lsl s_876_8 s_876_6
        let s_876_12: u64 = s_876_8 << s_876_6;
        // D s_876_13: or s_876_7 s_876_12
        let s_876_13: u64 = ((s_876_7) | (s_876_12));
        // D s_876_14: cmpl s_876_12
        let s_876_14: u64 = !s_876_12;
        // D s_876_15: and s_876_7 s_876_14
        let s_876_15: u64 = ((s_876_7) & (s_876_14));
        // D s_876_16: select s_876_11 s_876_13 s_876_15
        let s_876_16: u64 = if s_876_11 { s_876_13 } else { s_876_15 };
        // D s_876_17: cast trunc s_876_16 -> u8
        let s_876_17: bool = ((s_876_16) != 0);
        // D s_876_18: cast zx s_876_17 -> bv
        let s_876_18: Bits = Bits::new(s_876_17 as u128, 1u16);
        // C s_876_19: const #1u : u8
        let s_876_19: bool = true;
        // C s_876_20: cast zx s_876_19 -> bv
        let s_876_20: Bits = Bits::new(s_876_19 as u128, 1u16);
        // D s_876_21: cmp-ne s_876_18 s_876_20
        let s_876_21: bool = ((s_876_18) != (s_876_20));
        // D s_876_22: write-var gs#410992 <= s_876_21
        fn_state.gs_410992 = s_876_21;
        // N s_876_23: jump b877
        return block_877(state, tracer, fn_state);
    }
    fn block_877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_877_0: read-var gs#410992:u8
        let s_877_0: bool = fn_state.gs_410992;
        // N s_877_1: branch s_877_0 b882 b878
        if s_877_0 {
            return block_882(state, tracer, fn_state);
        } else {
            return block_878(state, tracer, fn_state);
        };
    }
    fn block_878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_878_0: const #11s : i
        let s_878_0: i128 = 11;
        // D s_878_1: read-var u#33792:u32
        let s_878_1: u32 = fn_state.u_33792;
        // D s_878_2: cast zx s_878_1 -> bv
        let s_878_2: Bits = Bits::new(s_878_1 as u128, 32u16);
        // C s_878_3: const #1u : u64
        let s_878_3: u64 = 1;
        // D s_878_4: bit-extract s_878_2 s_878_0 s_878_3
        let s_878_4: Bits = (Bits::new(
            ((s_878_2) >> (s_878_0)).value(),
            u16::try_from(s_878_3).unwrap(),
        ));
        // D s_878_5: cast reint s_878_4 -> u8
        let s_878_5: bool = ((s_878_4.value()) != 0);
        // C s_878_6: const #0s : i
        let s_878_6: i128 = 0;
        // C s_878_7: const #0u : u64
        let s_878_7: u64 = 0;
        // D s_878_8: cast zx s_878_5 -> u64
        let s_878_8: u64 = (s_878_5 as u64);
        // C s_878_9: const #1u : u64
        let s_878_9: u64 = 1;
        // D s_878_10: and s_878_8 s_878_9
        let s_878_10: u64 = ((s_878_8) & (s_878_9));
        // D s_878_11: cmp-eq s_878_10 s_878_9
        let s_878_11: bool = ((s_878_10) == (s_878_9));
        // D s_878_12: lsl s_878_8 s_878_6
        let s_878_12: u64 = s_878_8 << s_878_6;
        // D s_878_13: or s_878_7 s_878_12
        let s_878_13: u64 = ((s_878_7) | (s_878_12));
        // D s_878_14: cmpl s_878_12
        let s_878_14: u64 = !s_878_12;
        // D s_878_15: and s_878_7 s_878_14
        let s_878_15: u64 = ((s_878_7) & (s_878_14));
        // D s_878_16: select s_878_11 s_878_13 s_878_15
        let s_878_16: u64 = if s_878_11 { s_878_13 } else { s_878_15 };
        // D s_878_17: cast trunc s_878_16 -> u8
        let s_878_17: bool = ((s_878_16) != 0);
        // D s_878_18: cast zx s_878_17 -> bv
        let s_878_18: Bits = Bits::new(s_878_17 as u128, 1u16);
        // C s_878_19: const #1u : u8
        let s_878_19: bool = true;
        // C s_878_20: cast zx s_878_19 -> bv
        let s_878_20: Bits = Bits::new(s_878_19 as u128, 1u16);
        // D s_878_21: cmp-ne s_878_18 s_878_20
        let s_878_21: bool = ((s_878_18) != (s_878_20));
        // D s_878_22: write-var gs#410995 <= s_878_21
        fn_state.gs_410995 = s_878_21;
        // N s_878_23: jump b879
        return block_879(state, tracer, fn_state);
    }
    fn block_879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_879_0: read-var gs#410995:u8
        let s_879_0: bool = fn_state.gs_410995;
        // N s_879_1: branch s_879_0 b881 b880
        if s_879_0 {
            return block_881(state, tracer, fn_state);
        } else {
            return block_880(state, tracer, fn_state);
        };
    }
    fn block_880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_880_0: read-var u#33793:u8
        let s_880_0: u8 = fn_state.u_33793;
        // D s_880_1: read-var u#33794:u8
        let s_880_1: u8 = fn_state.u_33794;
        // D s_880_2: read-var u#33795:u8
        let s_880_2: u8 = fn_state.u_33795;
        // D s_880_3: read-var u#33796:u8
        let s_880_3: u8 = fn_state.u_33796;
        // D s_880_4: call decode_aarch32_instrs_UQSUB8_A1enc_A_txt(s_880_0, s_880_1, s_880_2, s_880_3)
        let s_880_4: () = decode_aarch32_instrs_UQSUB8_A1enc_A_txt(
            state,
            tracer,
            s_880_0,
            s_880_1,
            s_880_2,
            s_880_3,
        );
        // N s_880_5: return
        return;
    }
    fn block_881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_881_0: panic
        panic!("{:?}", ());
        // N s_881_1: return
        return;
    }
    fn block_882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_882_0: const #1u : u8
        let s_882_0: bool = true;
        // D s_882_1: write-var gs#410995 <= s_882_0
        fn_state.gs_410995 = s_882_0;
        // N s_882_2: jump b879
        return block_879(state, tracer, fn_state);
    }
    fn block_883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_883_0: const #1u : u8
        let s_883_0: bool = true;
        // D s_883_1: write-var gs#410992 <= s_883_0
        fn_state.gs_410992 = s_883_0;
        // N s_883_2: jump b877
        return block_877(state, tracer, fn_state);
    }
    fn block_884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_884_0: const #1u : u8
        let s_884_0: bool = true;
        // D s_884_1: write-var gs#410989 <= s_884_0
        fn_state.gs_410989 = s_884_0;
        // N s_884_2: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_885_0: read-var merge#var.1:struct
        let s_885_0: u32 = fn_state.merge_var._1;
        // D s_885_1: write-var u#33798 <= s_885_0
        fn_state.u_33798 = s_885_0;
        // C s_885_2: const #20s : i
        let s_885_2: i128 = 20;
        // D s_885_3: read-var u#33798:u32
        let s_885_3: u32 = fn_state.u_33798;
        // D s_885_4: cast zx s_885_3 -> bv
        let s_885_4: Bits = Bits::new(s_885_3 as u128, 32u16);
        // C s_885_5: const #1s : i64
        let s_885_5: i64 = 1;
        // C s_885_6: cast zx s_885_5 -> i
        let s_885_6: i128 = (i128::try_from(s_885_5).unwrap());
        // C s_885_7: const #7s : i
        let s_885_7: i128 = 7;
        // C s_885_8: add s_885_7 s_885_6
        let s_885_8: i128 = (s_885_7 + s_885_6);
        // D s_885_9: bit-extract s_885_4 s_885_2 s_885_8
        let s_885_9: Bits = (Bits::new(
            ((s_885_4) >> (s_885_2)).value(),
            u16::try_from(s_885_8).unwrap(),
        ));
        // D s_885_10: cast reint s_885_9 -> u8
        let s_885_10: u8 = (s_885_9.value() as u8);
        // D s_885_11: cast zx s_885_10 -> bv
        let s_885_11: Bits = Bits::new(s_885_10 as u128, 8u16);
        // C s_885_12: const #120u : u8
        let s_885_12: u8 = 120;
        // C s_885_13: cast zx s_885_12 -> bv
        let s_885_13: Bits = Bits::new(s_885_12 as u128, 8u16);
        // D s_885_14: cmp-eq s_885_11 s_885_13
        let s_885_14: bool = ((s_885_11) == (s_885_13));
        // N s_885_15: branch s_885_14 b1102 b886
        if s_885_14 {
            return block_1102(state, tracer, fn_state);
        } else {
            return block_886(state, tracer, fn_state);
        };
    }
    fn block_886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_886_0: const #0u : u8
        let s_886_0: bool = false;
        // D s_886_1: write-var gs#411004 <= s_886_0
        fn_state.gs_411004 = s_886_0;
        // N s_886_2: jump b887
        return block_887(state, tracer, fn_state);
    }
    fn block_887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_887_0: read-var gs#411004:u8
        let s_887_0: bool = fn_state.gs_411004;
        // N s_887_1: branch s_887_0 b1098 b888
        if s_887_0 {
            return block_1098(state, tracer, fn_state);
        } else {
            return block_888(state, tracer, fn_state);
        };
    }
    fn block_888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_888_0: const #0u : u8
        let s_888_0: bool = false;
        // D s_888_1: write-var gs#411009 <= s_888_0
        fn_state.gs_411009 = s_888_0;
        // N s_888_2: jump b889
        return block_889(state, tracer, fn_state);
    }
    fn block_889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_889_0: read-var gs#411009:u8
        let s_889_0: bool = fn_state.gs_411009;
        // D s_889_1: not s_889_0
        let s_889_1: bool = !s_889_0;
        // N s_889_2: branch s_889_1 b891 b890
        if s_889_1 {
            return block_891(state, tracer, fn_state);
        } else {
            return block_890(state, tracer, fn_state);
        };
    }
    fn block_890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_890_0: const #3322s : i
        let s_890_0: i128 = 3322;
        // C s_890_1: const #14696u : u32
        let s_890_1: u32 = 14696;
        // N s_890_2: write-reg s_890_1 <= s_890_0
        let s_890_2: () = {
            state.write_register::<i128>(s_890_1 as isize, s_890_0);
            tracer.write_register(s_890_1 as isize, s_890_0);
        };
        // C s_890_3: const #28s : i
        let s_890_3: i128 = 28;
        // C s_890_4: const #4s : i
        let s_890_4: i128 = 4;
        // D s_890_5: read-var u#33798:u32
        let s_890_5: u32 = fn_state.u_33798;
        // D s_890_6: cast zx s_890_5 -> bv
        let s_890_6: Bits = Bits::new(s_890_5 as u128, 32u16);
        // D s_890_7: bit-extract s_890_6 s_890_3 s_890_4
        let s_890_7: Bits = (Bits::new(
            ((s_890_6) >> (s_890_3)).value(),
            u16::try_from(s_890_4).unwrap(),
        ));
        // D s_890_8: cast reint s_890_7 -> u8
        let s_890_8: u8 = (s_890_7.value() as u8);
        // C s_890_9: const #16s : i
        let s_890_9: i128 = 16;
        // C s_890_10: const #4s : i
        let s_890_10: i128 = 4;
        // D s_890_11: read-var u#33798:u32
        let s_890_11: u32 = fn_state.u_33798;
        // D s_890_12: cast zx s_890_11 -> bv
        let s_890_12: Bits = Bits::new(s_890_11 as u128, 32u16);
        // D s_890_13: bit-extract s_890_12 s_890_9 s_890_10
        let s_890_13: Bits = (Bits::new(
            ((s_890_12) >> (s_890_9)).value(),
            u16::try_from(s_890_10).unwrap(),
        ));
        // D s_890_14: cast reint s_890_13 -> u8
        let s_890_14: u8 = (s_890_13.value() as u8);
        // C s_890_15: const #8s : i
        let s_890_15: i128 = 8;
        // C s_890_16: const #4s : i
        let s_890_16: i128 = 4;
        // D s_890_17: read-var u#33798:u32
        let s_890_17: u32 = fn_state.u_33798;
        // D s_890_18: cast zx s_890_17 -> bv
        let s_890_18: Bits = Bits::new(s_890_17 as u128, 32u16);
        // D s_890_19: bit-extract s_890_18 s_890_15 s_890_16
        let s_890_19: Bits = (Bits::new(
            ((s_890_18) >> (s_890_15)).value(),
            u16::try_from(s_890_16).unwrap(),
        ));
        // D s_890_20: cast reint s_890_19 -> u8
        let s_890_20: u8 = (s_890_19.value() as u8);
        // C s_890_21: const #0s : i
        let s_890_21: i128 = 0;
        // C s_890_22: const #4s : i
        let s_890_22: i128 = 4;
        // D s_890_23: read-var u#33798:u32
        let s_890_23: u32 = fn_state.u_33798;
        // D s_890_24: cast zx s_890_23 -> bv
        let s_890_24: Bits = Bits::new(s_890_23 as u128, 32u16);
        // D s_890_25: bit-extract s_890_24 s_890_21 s_890_22
        let s_890_25: Bits = (Bits::new(
            ((s_890_24) >> (s_890_21)).value(),
            u16::try_from(s_890_22).unwrap(),
        ));
        // D s_890_26: cast reint s_890_25 -> u8
        let s_890_26: u8 = (s_890_25.value() as u8);
        // D s_890_27: call decode_aarch32_instrs_USAD8_A1enc_A_txt(s_890_8, s_890_14, s_890_20, s_890_26)
        let s_890_27: () = decode_aarch32_instrs_USAD8_A1enc_A_txt(
            state,
            tracer,
            s_890_8,
            s_890_14,
            s_890_20,
            s_890_26,
        );
        // N s_890_28: return
        return;
    }
    fn block_891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_891_0: read-var merge#var.1:struct
        let s_891_0: u32 = fn_state.merge_var._1;
        // D s_891_1: write-var u#33804 <= s_891_0
        fn_state.u_33804 = s_891_0;
        // C s_891_2: const #20s : i
        let s_891_2: i128 = 20;
        // D s_891_3: read-var u#33804:u32
        let s_891_3: u32 = fn_state.u_33804;
        // D s_891_4: cast zx s_891_3 -> bv
        let s_891_4: Bits = Bits::new(s_891_3 as u128, 32u16);
        // C s_891_5: const #1s : i64
        let s_891_5: i64 = 1;
        // C s_891_6: cast zx s_891_5 -> i
        let s_891_6: i128 = (i128::try_from(s_891_5).unwrap());
        // C s_891_7: const #7s : i
        let s_891_7: i128 = 7;
        // C s_891_8: add s_891_7 s_891_6
        let s_891_8: i128 = (s_891_7 + s_891_6);
        // D s_891_9: bit-extract s_891_4 s_891_2 s_891_8
        let s_891_9: Bits = (Bits::new(
            ((s_891_4) >> (s_891_2)).value(),
            u16::try_from(s_891_8).unwrap(),
        ));
        // D s_891_10: cast reint s_891_9 -> u8
        let s_891_10: u8 = (s_891_9.value() as u8);
        // D s_891_11: cast zx s_891_10 -> bv
        let s_891_11: Bits = Bits::new(s_891_10 as u128, 8u16);
        // C s_891_12: const #120u : u8
        let s_891_12: u8 = 120;
        // C s_891_13: cast zx s_891_12 -> bv
        let s_891_13: Bits = Bits::new(s_891_12 as u128, 8u16);
        // D s_891_14: cmp-eq s_891_11 s_891_13
        let s_891_14: bool = ((s_891_11) == (s_891_13));
        // N s_891_15: branch s_891_14 b1097 b892
        if s_891_14 {
            return block_1097(state, tracer, fn_state);
        } else {
            return block_892(state, tracer, fn_state);
        };
    }
    fn block_892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_892_0: const #0u : u8
        let s_892_0: bool = false;
        // D s_892_1: write-var gs#411025 <= s_892_0
        fn_state.gs_411025 = s_892_0;
        // N s_892_2: jump b893
        return block_893(state, tracer, fn_state);
    }
    fn block_893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_893_0: read-var gs#411025:u8
        let s_893_0: bool = fn_state.gs_411025;
        // N s_893_1: branch s_893_0 b1093 b894
        if s_893_0 {
            return block_1093(state, tracer, fn_state);
        } else {
            return block_894(state, tracer, fn_state);
        };
    }
    fn block_894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_894_0: const #0u : u8
        let s_894_0: bool = false;
        // D s_894_1: write-var gs#411030 <= s_894_0
        fn_state.gs_411030 = s_894_0;
        // N s_894_2: jump b895
        return block_895(state, tracer, fn_state);
    }
    fn block_895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_895_0: read-var gs#411030:u8
        let s_895_0: bool = fn_state.gs_411030;
        // D s_895_1: not s_895_0
        let s_895_1: bool = !s_895_0;
        // N s_895_2: branch s_895_1 b897 b896
        if s_895_1 {
            return block_897(state, tracer, fn_state);
        } else {
            return block_896(state, tracer, fn_state);
        };
    }
    fn block_896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_896_0: const #3324s : i
        let s_896_0: i128 = 3324;
        // C s_896_1: const #14696u : u32
        let s_896_1: u32 = 14696;
        // N s_896_2: write-reg s_896_1 <= s_896_0
        let s_896_2: () = {
            state.write_register::<i128>(s_896_1 as isize, s_896_0);
            tracer.write_register(s_896_1 as isize, s_896_0);
        };
        // C s_896_3: const #28s : i
        let s_896_3: i128 = 28;
        // C s_896_4: const #4s : i
        let s_896_4: i128 = 4;
        // D s_896_5: read-var u#33804:u32
        let s_896_5: u32 = fn_state.u_33804;
        // D s_896_6: cast zx s_896_5 -> bv
        let s_896_6: Bits = Bits::new(s_896_5 as u128, 32u16);
        // D s_896_7: bit-extract s_896_6 s_896_3 s_896_4
        let s_896_7: Bits = (Bits::new(
            ((s_896_6) >> (s_896_3)).value(),
            u16::try_from(s_896_4).unwrap(),
        ));
        // D s_896_8: cast reint s_896_7 -> u8
        let s_896_8: u8 = (s_896_7.value() as u8);
        // C s_896_9: const #16s : i
        let s_896_9: i128 = 16;
        // C s_896_10: const #4s : i
        let s_896_10: i128 = 4;
        // D s_896_11: read-var u#33804:u32
        let s_896_11: u32 = fn_state.u_33804;
        // D s_896_12: cast zx s_896_11 -> bv
        let s_896_12: Bits = Bits::new(s_896_11 as u128, 32u16);
        // D s_896_13: bit-extract s_896_12 s_896_9 s_896_10
        let s_896_13: Bits = (Bits::new(
            ((s_896_12) >> (s_896_9)).value(),
            u16::try_from(s_896_10).unwrap(),
        ));
        // D s_896_14: cast reint s_896_13 -> u8
        let s_896_14: u8 = (s_896_13.value() as u8);
        // C s_896_15: const #12s : i
        let s_896_15: i128 = 12;
        // C s_896_16: const #4s : i
        let s_896_16: i128 = 4;
        // D s_896_17: read-var u#33804:u32
        let s_896_17: u32 = fn_state.u_33804;
        // D s_896_18: cast zx s_896_17 -> bv
        let s_896_18: Bits = Bits::new(s_896_17 as u128, 32u16);
        // D s_896_19: bit-extract s_896_18 s_896_15 s_896_16
        let s_896_19: Bits = (Bits::new(
            ((s_896_18) >> (s_896_15)).value(),
            u16::try_from(s_896_16).unwrap(),
        ));
        // D s_896_20: cast reint s_896_19 -> u8
        let s_896_20: u8 = (s_896_19.value() as u8);
        // C s_896_21: const #8s : i
        let s_896_21: i128 = 8;
        // C s_896_22: const #4s : i
        let s_896_22: i128 = 4;
        // D s_896_23: read-var u#33804:u32
        let s_896_23: u32 = fn_state.u_33804;
        // D s_896_24: cast zx s_896_23 -> bv
        let s_896_24: Bits = Bits::new(s_896_23 as u128, 32u16);
        // D s_896_25: bit-extract s_896_24 s_896_21 s_896_22
        let s_896_25: Bits = (Bits::new(
            ((s_896_24) >> (s_896_21)).value(),
            u16::try_from(s_896_22).unwrap(),
        ));
        // D s_896_26: cast reint s_896_25 -> u8
        let s_896_26: u8 = (s_896_25.value() as u8);
        // C s_896_27: const #0s : i
        let s_896_27: i128 = 0;
        // C s_896_28: const #4s : i
        let s_896_28: i128 = 4;
        // D s_896_29: read-var u#33804:u32
        let s_896_29: u32 = fn_state.u_33804;
        // D s_896_30: cast zx s_896_29 -> bv
        let s_896_30: Bits = Bits::new(s_896_29 as u128, 32u16);
        // D s_896_31: bit-extract s_896_30 s_896_27 s_896_28
        let s_896_31: Bits = (Bits::new(
            ((s_896_30) >> (s_896_27)).value(),
            u16::try_from(s_896_28).unwrap(),
        ));
        // D s_896_32: cast reint s_896_31 -> u8
        let s_896_32: u8 = (s_896_31.value() as u8);
        // D s_896_33: call decode_aarch32_instrs_USADA8_A1enc_A_txt(s_896_8, s_896_14, s_896_20, s_896_26, s_896_32)
        let s_896_33: () = decode_aarch32_instrs_USADA8_A1enc_A_txt(
            state,
            tracer,
            s_896_8,
            s_896_14,
            s_896_20,
            s_896_26,
            s_896_32,
        );
        // N s_896_34: return
        return;
    }
    fn block_897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_897_0: read-var merge#var.1:struct
        let s_897_0: u32 = fn_state.merge_var._1;
        // D s_897_1: write-var u#33811 <= s_897_0
        fn_state.u_33811 = s_897_0;
        // C s_897_2: const #20s : i
        let s_897_2: i128 = 20;
        // D s_897_3: read-var u#33811:u32
        let s_897_3: u32 = fn_state.u_33811;
        // D s_897_4: cast zx s_897_3 -> bv
        let s_897_4: Bits = Bits::new(s_897_3 as u128, 32u16);
        // C s_897_5: const #1s : i64
        let s_897_5: i64 = 1;
        // C s_897_6: cast zx s_897_5 -> i
        let s_897_6: i128 = (i128::try_from(s_897_5).unwrap());
        // C s_897_7: const #7s : i
        let s_897_7: i128 = 7;
        // C s_897_8: add s_897_7 s_897_6
        let s_897_8: i128 = (s_897_7 + s_897_6);
        // D s_897_9: bit-extract s_897_4 s_897_2 s_897_8
        let s_897_9: Bits = (Bits::new(
            ((s_897_4) >> (s_897_2)).value(),
            u16::try_from(s_897_8).unwrap(),
        ));
        // D s_897_10: cast reint s_897_9 -> u8
        let s_897_10: u8 = (s_897_9.value() as u8);
        // D s_897_11: cast zx s_897_10 -> bv
        let s_897_11: Bits = Bits::new(s_897_10 as u128, 8u16);
        // C s_897_12: const #110u : u8
        let s_897_12: u8 = 110;
        // C s_897_13: cast zx s_897_12 -> bv
        let s_897_13: Bits = Bits::new(s_897_12 as u128, 8u16);
        // D s_897_14: cmp-eq s_897_11 s_897_13
        let s_897_14: bool = ((s_897_11) == (s_897_13));
        // N s_897_15: branch s_897_14 b1092 b898
        if s_897_14 {
            return block_1092(state, tracer, fn_state);
        } else {
            return block_898(state, tracer, fn_state);
        };
    }
    fn block_898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_898_0: const #0u : u8
        let s_898_0: bool = false;
        // D s_898_1: write-var gs#411048 <= s_898_0
        fn_state.gs_411048 = s_898_0;
        // N s_898_2: jump b899
        return block_899(state, tracer, fn_state);
    }
    fn block_899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_899_0: read-var gs#411048:u8
        let s_899_0: bool = fn_state.gs_411048;
        // N s_899_1: branch s_899_0 b1088 b900
        if s_899_0 {
            return block_1088(state, tracer, fn_state);
        } else {
            return block_900(state, tracer, fn_state);
        };
    }
    fn block_900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_900_0: const #0u : u8
        let s_900_0: bool = false;
        // D s_900_1: write-var gs#411053 <= s_900_0
        fn_state.gs_411053 = s_900_0;
        // N s_900_2: jump b901
        return block_901(state, tracer, fn_state);
    }
    fn block_901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_901_0: read-var gs#411053:u8
        let s_901_0: bool = fn_state.gs_411053;
        // D s_901_1: not s_901_0
        let s_901_1: bool = !s_901_0;
        // N s_901_2: branch s_901_1 b914 b902
        if s_901_1 {
            return block_914(state, tracer, fn_state);
        } else {
            return block_902(state, tracer, fn_state);
        };
    }
    fn block_902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_902_0: const #3326s : i
        let s_902_0: i128 = 3326;
        // C s_902_1: const #14696u : u32
        let s_902_1: u32 = 14696;
        // N s_902_2: write-reg s_902_1 <= s_902_0
        let s_902_2: () = {
            state.write_register::<i128>(s_902_1 as isize, s_902_0);
            tracer.write_register(s_902_1 as isize, s_902_0);
        };
        // C s_902_3: const #28s : i
        let s_902_3: i128 = 28;
        // C s_902_4: const #4s : i
        let s_902_4: i128 = 4;
        // D s_902_5: read-var u#33811:u32
        let s_902_5: u32 = fn_state.u_33811;
        // D s_902_6: cast zx s_902_5 -> bv
        let s_902_6: Bits = Bits::new(s_902_5 as u128, 32u16);
        // D s_902_7: bit-extract s_902_6 s_902_3 s_902_4
        let s_902_7: Bits = (Bits::new(
            ((s_902_6) >> (s_902_3)).value(),
            u16::try_from(s_902_4).unwrap(),
        ));
        // D s_902_8: cast reint s_902_7 -> u8
        let s_902_8: u8 = (s_902_7.value() as u8);
        // D s_902_9: write-var u#33812 <= s_902_8
        fn_state.u_33812 = s_902_8;
        // C s_902_10: const #16s : i
        let s_902_10: i128 = 16;
        // C s_902_11: const #4s : i
        let s_902_11: i128 = 4;
        // D s_902_12: read-var u#33811:u32
        let s_902_12: u32 = fn_state.u_33811;
        // D s_902_13: cast zx s_902_12 -> bv
        let s_902_13: Bits = Bits::new(s_902_12 as u128, 32u16);
        // D s_902_14: bit-extract s_902_13 s_902_10 s_902_11
        let s_902_14: Bits = (Bits::new(
            ((s_902_13) >> (s_902_10)).value(),
            u16::try_from(s_902_11).unwrap(),
        ));
        // D s_902_15: cast reint s_902_14 -> u8
        let s_902_15: u8 = (s_902_14.value() as u8);
        // D s_902_16: write-var u#33813 <= s_902_15
        fn_state.u_33813 = s_902_15;
        // C s_902_17: const #12s : i
        let s_902_17: i128 = 12;
        // C s_902_18: const #4s : i
        let s_902_18: i128 = 4;
        // D s_902_19: read-var u#33811:u32
        let s_902_19: u32 = fn_state.u_33811;
        // D s_902_20: cast zx s_902_19 -> bv
        let s_902_20: Bits = Bits::new(s_902_19 as u128, 32u16);
        // D s_902_21: bit-extract s_902_20 s_902_17 s_902_18
        let s_902_21: Bits = (Bits::new(
            ((s_902_20) >> (s_902_17)).value(),
            u16::try_from(s_902_18).unwrap(),
        ));
        // D s_902_22: cast reint s_902_21 -> u8
        let s_902_22: u8 = (s_902_21.value() as u8);
        // D s_902_23: write-var u#33814 <= s_902_22
        fn_state.u_33814 = s_902_22;
        // C s_902_24: const #0s : i
        let s_902_24: i128 = 0;
        // C s_902_25: const #4s : i
        let s_902_25: i128 = 4;
        // D s_902_26: read-var u#33811:u32
        let s_902_26: u32 = fn_state.u_33811;
        // D s_902_27: cast zx s_902_26 -> bv
        let s_902_27: Bits = Bits::new(s_902_26 as u128, 32u16);
        // D s_902_28: bit-extract s_902_27 s_902_24 s_902_25
        let s_902_28: Bits = (Bits::new(
            ((s_902_27) >> (s_902_24)).value(),
            u16::try_from(s_902_25).unwrap(),
        ));
        // D s_902_29: cast reint s_902_28 -> u8
        let s_902_29: u8 = (s_902_28.value() as u8);
        // D s_902_30: write-var u#33815 <= s_902_29
        fn_state.u_33815 = s_902_29;
        // C s_902_31: const #8s : i
        let s_902_31: i128 = 8;
        // D s_902_32: read-var u#33811:u32
        let s_902_32: u32 = fn_state.u_33811;
        // D s_902_33: cast zx s_902_32 -> bv
        let s_902_33: Bits = Bits::new(s_902_32 as u128, 32u16);
        // C s_902_34: const #1u : u64
        let s_902_34: u64 = 1;
        // D s_902_35: bit-extract s_902_33 s_902_31 s_902_34
        let s_902_35: Bits = (Bits::new(
            ((s_902_33) >> (s_902_31)).value(),
            u16::try_from(s_902_34).unwrap(),
        ));
        // D s_902_36: cast reint s_902_35 -> u8
        let s_902_36: bool = ((s_902_35.value()) != 0);
        // C s_902_37: const #0s : i
        let s_902_37: i128 = 0;
        // C s_902_38: const #0u : u64
        let s_902_38: u64 = 0;
        // D s_902_39: cast zx s_902_36 -> u64
        let s_902_39: u64 = (s_902_36 as u64);
        // C s_902_40: const #1u : u64
        let s_902_40: u64 = 1;
        // D s_902_41: and s_902_39 s_902_40
        let s_902_41: u64 = ((s_902_39) & (s_902_40));
        // D s_902_42: cmp-eq s_902_41 s_902_40
        let s_902_42: bool = ((s_902_41) == (s_902_40));
        // D s_902_43: lsl s_902_39 s_902_37
        let s_902_43: u64 = s_902_39 << s_902_37;
        // D s_902_44: or s_902_38 s_902_43
        let s_902_44: u64 = ((s_902_38) | (s_902_43));
        // D s_902_45: cmpl s_902_43
        let s_902_45: u64 = !s_902_43;
        // D s_902_46: and s_902_38 s_902_45
        let s_902_46: u64 = ((s_902_38) & (s_902_45));
        // D s_902_47: select s_902_42 s_902_44 s_902_46
        let s_902_47: u64 = if s_902_42 { s_902_44 } else { s_902_46 };
        // D s_902_48: cast trunc s_902_47 -> u8
        let s_902_48: bool = ((s_902_47) != 0);
        // D s_902_49: cast zx s_902_48 -> bv
        let s_902_49: Bits = Bits::new(s_902_48 as u128, 1u16);
        // C s_902_50: const #1u : u8
        let s_902_50: bool = true;
        // C s_902_51: cast zx s_902_50 -> bv
        let s_902_51: Bits = Bits::new(s_902_50 as u128, 1u16);
        // D s_902_52: cmp-ne s_902_49 s_902_51
        let s_902_52: bool = ((s_902_49) != (s_902_51));
        // N s_902_53: branch s_902_52 b913 b903
        if s_902_52 {
            return block_913(state, tracer, fn_state);
        } else {
            return block_903(state, tracer, fn_state);
        };
    }
    fn block_903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_903_0: const #9s : i
        let s_903_0: i128 = 9;
        // D s_903_1: read-var u#33811:u32
        let s_903_1: u32 = fn_state.u_33811;
        // D s_903_2: cast zx s_903_1 -> bv
        let s_903_2: Bits = Bits::new(s_903_1 as u128, 32u16);
        // C s_903_3: const #1u : u64
        let s_903_3: u64 = 1;
        // D s_903_4: bit-extract s_903_2 s_903_0 s_903_3
        let s_903_4: Bits = (Bits::new(
            ((s_903_2) >> (s_903_0)).value(),
            u16::try_from(s_903_3).unwrap(),
        ));
        // D s_903_5: cast reint s_903_4 -> u8
        let s_903_5: bool = ((s_903_4.value()) != 0);
        // C s_903_6: const #0s : i
        let s_903_6: i128 = 0;
        // C s_903_7: const #0u : u64
        let s_903_7: u64 = 0;
        // D s_903_8: cast zx s_903_5 -> u64
        let s_903_8: u64 = (s_903_5 as u64);
        // C s_903_9: const #1u : u64
        let s_903_9: u64 = 1;
        // D s_903_10: and s_903_8 s_903_9
        let s_903_10: u64 = ((s_903_8) & (s_903_9));
        // D s_903_11: cmp-eq s_903_10 s_903_9
        let s_903_11: bool = ((s_903_10) == (s_903_9));
        // D s_903_12: lsl s_903_8 s_903_6
        let s_903_12: u64 = s_903_8 << s_903_6;
        // D s_903_13: or s_903_7 s_903_12
        let s_903_13: u64 = ((s_903_7) | (s_903_12));
        // D s_903_14: cmpl s_903_12
        let s_903_14: u64 = !s_903_12;
        // D s_903_15: and s_903_7 s_903_14
        let s_903_15: u64 = ((s_903_7) & (s_903_14));
        // D s_903_16: select s_903_11 s_903_13 s_903_15
        let s_903_16: u64 = if s_903_11 { s_903_13 } else { s_903_15 };
        // D s_903_17: cast trunc s_903_16 -> u8
        let s_903_17: bool = ((s_903_16) != 0);
        // D s_903_18: cast zx s_903_17 -> bv
        let s_903_18: Bits = Bits::new(s_903_17 as u128, 1u16);
        // C s_903_19: const #1u : u8
        let s_903_19: bool = true;
        // C s_903_20: cast zx s_903_19 -> bv
        let s_903_20: Bits = Bits::new(s_903_19 as u128, 1u16);
        // D s_903_21: cmp-ne s_903_18 s_903_20
        let s_903_21: bool = ((s_903_18) != (s_903_20));
        // D s_903_22: write-var gs#411068 <= s_903_21
        fn_state.gs_411068 = s_903_21;
        // N s_903_23: jump b904
        return block_904(state, tracer, fn_state);
    }
    fn block_904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_904_0: read-var gs#411068:u8
        let s_904_0: bool = fn_state.gs_411068;
        // N s_904_1: branch s_904_0 b912 b905
        if s_904_0 {
            return block_912(state, tracer, fn_state);
        } else {
            return block_905(state, tracer, fn_state);
        };
    }
    fn block_905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_905_0: const #10s : i
        let s_905_0: i128 = 10;
        // D s_905_1: read-var u#33811:u32
        let s_905_1: u32 = fn_state.u_33811;
        // D s_905_2: cast zx s_905_1 -> bv
        let s_905_2: Bits = Bits::new(s_905_1 as u128, 32u16);
        // C s_905_3: const #1u : u64
        let s_905_3: u64 = 1;
        // D s_905_4: bit-extract s_905_2 s_905_0 s_905_3
        let s_905_4: Bits = (Bits::new(
            ((s_905_2) >> (s_905_0)).value(),
            u16::try_from(s_905_3).unwrap(),
        ));
        // D s_905_5: cast reint s_905_4 -> u8
        let s_905_5: bool = ((s_905_4.value()) != 0);
        // C s_905_6: const #0s : i
        let s_905_6: i128 = 0;
        // C s_905_7: const #0u : u64
        let s_905_7: u64 = 0;
        // D s_905_8: cast zx s_905_5 -> u64
        let s_905_8: u64 = (s_905_5 as u64);
        // C s_905_9: const #1u : u64
        let s_905_9: u64 = 1;
        // D s_905_10: and s_905_8 s_905_9
        let s_905_10: u64 = ((s_905_8) & (s_905_9));
        // D s_905_11: cmp-eq s_905_10 s_905_9
        let s_905_11: bool = ((s_905_10) == (s_905_9));
        // D s_905_12: lsl s_905_8 s_905_6
        let s_905_12: u64 = s_905_8 << s_905_6;
        // D s_905_13: or s_905_7 s_905_12
        let s_905_13: u64 = ((s_905_7) | (s_905_12));
        // D s_905_14: cmpl s_905_12
        let s_905_14: u64 = !s_905_12;
        // D s_905_15: and s_905_7 s_905_14
        let s_905_15: u64 = ((s_905_7) & (s_905_14));
        // D s_905_16: select s_905_11 s_905_13 s_905_15
        let s_905_16: u64 = if s_905_11 { s_905_13 } else { s_905_15 };
        // D s_905_17: cast trunc s_905_16 -> u8
        let s_905_17: bool = ((s_905_16) != 0);
        // D s_905_18: cast zx s_905_17 -> bv
        let s_905_18: Bits = Bits::new(s_905_17 as u128, 1u16);
        // C s_905_19: const #1u : u8
        let s_905_19: bool = true;
        // C s_905_20: cast zx s_905_19 -> bv
        let s_905_20: Bits = Bits::new(s_905_19 as u128, 1u16);
        // D s_905_21: cmp-ne s_905_18 s_905_20
        let s_905_21: bool = ((s_905_18) != (s_905_20));
        // D s_905_22: write-var gs#411071 <= s_905_21
        fn_state.gs_411071 = s_905_21;
        // N s_905_23: jump b906
        return block_906(state, tracer, fn_state);
    }
    fn block_906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_906_0: read-var gs#411071:u8
        let s_906_0: bool = fn_state.gs_411071;
        // N s_906_1: branch s_906_0 b911 b907
        if s_906_0 {
            return block_911(state, tracer, fn_state);
        } else {
            return block_907(state, tracer, fn_state);
        };
    }
    fn block_907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_907_0: const #11s : i
        let s_907_0: i128 = 11;
        // D s_907_1: read-var u#33811:u32
        let s_907_1: u32 = fn_state.u_33811;
        // D s_907_2: cast zx s_907_1 -> bv
        let s_907_2: Bits = Bits::new(s_907_1 as u128, 32u16);
        // C s_907_3: const #1u : u64
        let s_907_3: u64 = 1;
        // D s_907_4: bit-extract s_907_2 s_907_0 s_907_3
        let s_907_4: Bits = (Bits::new(
            ((s_907_2) >> (s_907_0)).value(),
            u16::try_from(s_907_3).unwrap(),
        ));
        // D s_907_5: cast reint s_907_4 -> u8
        let s_907_5: bool = ((s_907_4.value()) != 0);
        // C s_907_6: const #0s : i
        let s_907_6: i128 = 0;
        // C s_907_7: const #0u : u64
        let s_907_7: u64 = 0;
        // D s_907_8: cast zx s_907_5 -> u64
        let s_907_8: u64 = (s_907_5 as u64);
        // C s_907_9: const #1u : u64
        let s_907_9: u64 = 1;
        // D s_907_10: and s_907_8 s_907_9
        let s_907_10: u64 = ((s_907_8) & (s_907_9));
        // D s_907_11: cmp-eq s_907_10 s_907_9
        let s_907_11: bool = ((s_907_10) == (s_907_9));
        // D s_907_12: lsl s_907_8 s_907_6
        let s_907_12: u64 = s_907_8 << s_907_6;
        // D s_907_13: or s_907_7 s_907_12
        let s_907_13: u64 = ((s_907_7) | (s_907_12));
        // D s_907_14: cmpl s_907_12
        let s_907_14: u64 = !s_907_12;
        // D s_907_15: and s_907_7 s_907_14
        let s_907_15: u64 = ((s_907_7) & (s_907_14));
        // D s_907_16: select s_907_11 s_907_13 s_907_15
        let s_907_16: u64 = if s_907_11 { s_907_13 } else { s_907_15 };
        // D s_907_17: cast trunc s_907_16 -> u8
        let s_907_17: bool = ((s_907_16) != 0);
        // D s_907_18: cast zx s_907_17 -> bv
        let s_907_18: Bits = Bits::new(s_907_17 as u128, 1u16);
        // C s_907_19: const #1u : u8
        let s_907_19: bool = true;
        // C s_907_20: cast zx s_907_19 -> bv
        let s_907_20: Bits = Bits::new(s_907_19 as u128, 1u16);
        // D s_907_21: cmp-ne s_907_18 s_907_20
        let s_907_21: bool = ((s_907_18) != (s_907_20));
        // D s_907_22: write-var gs#411074 <= s_907_21
        fn_state.gs_411074 = s_907_21;
        // N s_907_23: jump b908
        return block_908(state, tracer, fn_state);
    }
    fn block_908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_908_0: read-var gs#411074:u8
        let s_908_0: bool = fn_state.gs_411074;
        // N s_908_1: branch s_908_0 b910 b909
        if s_908_0 {
            return block_910(state, tracer, fn_state);
        } else {
            return block_909(state, tracer, fn_state);
        };
    }
    fn block_909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_909_0: read-var u#33812:u8
        let s_909_0: u8 = fn_state.u_33812;
        // D s_909_1: read-var u#33813:u8
        let s_909_1: u8 = fn_state.u_33813;
        // D s_909_2: read-var u#33814:u8
        let s_909_2: u8 = fn_state.u_33814;
        // D s_909_3: read-var u#33815:u8
        let s_909_3: u8 = fn_state.u_33815;
        // D s_909_4: call decode_aarch32_instrs_USAT16_A1enc_A_txt(s_909_0, s_909_1, s_909_2, s_909_3)
        let s_909_4: () = decode_aarch32_instrs_USAT16_A1enc_A_txt(
            state,
            tracer,
            s_909_0,
            s_909_1,
            s_909_2,
            s_909_3,
        );
        // N s_909_5: return
        return;
    }
    fn block_910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_910_0: panic
        panic!("{:?}", ());
        // N s_910_1: return
        return;
    }
    fn block_911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_911_0: const #1u : u8
        let s_911_0: bool = true;
        // D s_911_1: write-var gs#411074 <= s_911_0
        fn_state.gs_411074 = s_911_0;
        // N s_911_2: jump b908
        return block_908(state, tracer, fn_state);
    }
    fn block_912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_912_0: const #1u : u8
        let s_912_0: bool = true;
        // D s_912_1: write-var gs#411071 <= s_912_0
        fn_state.gs_411071 = s_912_0;
        // N s_912_2: jump b906
        return block_906(state, tracer, fn_state);
    }
    fn block_913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_913_0: const #1u : u8
        let s_913_0: bool = true;
        // D s_913_1: write-var gs#411068 <= s_913_0
        fn_state.gs_411068 = s_913_0;
        // N s_913_2: jump b904
        return block_904(state, tracer, fn_state);
    }
    fn block_914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_914_0: read-var merge#var.1:struct
        let s_914_0: u32 = fn_state.merge_var._1;
        // D s_914_1: write-var u#33817 <= s_914_0
        fn_state.u_33817 = s_914_0;
        // C s_914_2: const #21s : i
        let s_914_2: i128 = 21;
        // D s_914_3: read-var u#33817:u32
        let s_914_3: u32 = fn_state.u_33817;
        // D s_914_4: cast zx s_914_3 -> bv
        let s_914_4: Bits = Bits::new(s_914_3 as u128, 32u16);
        // C s_914_5: const #1s : i64
        let s_914_5: i64 = 1;
        // C s_914_6: cast zx s_914_5 -> i
        let s_914_6: i128 = (i128::try_from(s_914_5).unwrap());
        // C s_914_7: const #6s : i
        let s_914_7: i128 = 6;
        // C s_914_8: add s_914_7 s_914_6
        let s_914_8: i128 = (s_914_7 + s_914_6);
        // D s_914_9: bit-extract s_914_4 s_914_2 s_914_8
        let s_914_9: Bits = (Bits::new(
            ((s_914_4) >> (s_914_2)).value(),
            u16::try_from(s_914_8).unwrap(),
        ));
        // D s_914_10: cast reint s_914_9 -> u8
        let s_914_10: u8 = (s_914_9.value() as u8);
        // D s_914_11: cast zx s_914_10 -> bv
        let s_914_11: Bits = Bits::new(s_914_10 as u128, 7u16);
        // C s_914_12: const #55u : u8
        let s_914_12: u8 = 55;
        // C s_914_13: cast zx s_914_12 -> bv
        let s_914_13: Bits = Bits::new(s_914_12 as u128, 7u16);
        // D s_914_14: cmp-eq s_914_11 s_914_13
        let s_914_14: bool = ((s_914_11) == (s_914_13));
        // N s_914_15: branch s_914_14 b1087 b915
        if s_914_14 {
            return block_1087(state, tracer, fn_state);
        } else {
            return block_915(state, tracer, fn_state);
        };
    }
    fn block_915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_915_0: const #0u : u8
        let s_915_0: bool = false;
        // D s_915_1: write-var gs#411080 <= s_915_0
        fn_state.gs_411080 = s_915_0;
        // N s_915_2: jump b916
        return block_916(state, tracer, fn_state);
    }
    fn block_916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_916_0: read-var gs#411080:u8
        let s_916_0: bool = fn_state.gs_411080;
        // N s_916_1: branch s_916_0 b1083 b917
        if s_916_0 {
            return block_1083(state, tracer, fn_state);
        } else {
            return block_917(state, tracer, fn_state);
        };
    }
    fn block_917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_917_0: const #0u : u8
        let s_917_0: bool = false;
        // D s_917_1: write-var gs#411085 <= s_917_0
        fn_state.gs_411085 = s_917_0;
        // N s_917_2: jump b918
        return block_918(state, tracer, fn_state);
    }
    fn block_918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_918_0: read-var gs#411085:u8
        let s_918_0: bool = fn_state.gs_411085;
        // D s_918_1: not s_918_0
        let s_918_1: bool = !s_918_0;
        // N s_918_2: branch s_918_1 b920 b919
        if s_918_1 {
            return block_920(state, tracer, fn_state);
        } else {
            return block_919(state, tracer, fn_state);
        };
    }
    fn block_919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_919_0: const #3328s : i
        let s_919_0: i128 = 3328;
        // C s_919_1: const #14696u : u32
        let s_919_1: u32 = 14696;
        // N s_919_2: write-reg s_919_1 <= s_919_0
        let s_919_2: () = {
            state.write_register::<i128>(s_919_1 as isize, s_919_0);
            tracer.write_register(s_919_1 as isize, s_919_0);
        };
        // C s_919_3: const #28s : i
        let s_919_3: i128 = 28;
        // C s_919_4: const #4s : i
        let s_919_4: i128 = 4;
        // D s_919_5: read-var u#33817:u32
        let s_919_5: u32 = fn_state.u_33817;
        // D s_919_6: cast zx s_919_5 -> bv
        let s_919_6: Bits = Bits::new(s_919_5 as u128, 32u16);
        // D s_919_7: bit-extract s_919_6 s_919_3 s_919_4
        let s_919_7: Bits = (Bits::new(
            ((s_919_6) >> (s_919_3)).value(),
            u16::try_from(s_919_4).unwrap(),
        ));
        // D s_919_8: cast reint s_919_7 -> u8
        let s_919_8: u8 = (s_919_7.value() as u8);
        // C s_919_9: const #16s : i
        let s_919_9: i128 = 16;
        // C s_919_10: const #5s : i
        let s_919_10: i128 = 5;
        // D s_919_11: read-var u#33817:u32
        let s_919_11: u32 = fn_state.u_33817;
        // D s_919_12: cast zx s_919_11 -> bv
        let s_919_12: Bits = Bits::new(s_919_11 as u128, 32u16);
        // D s_919_13: bit-extract s_919_12 s_919_9 s_919_10
        let s_919_13: Bits = (Bits::new(
            ((s_919_12) >> (s_919_9)).value(),
            u16::try_from(s_919_10).unwrap(),
        ));
        // D s_919_14: cast reint s_919_13 -> u8
        let s_919_14: u8 = (s_919_13.value() as u8);
        // C s_919_15: const #12s : i
        let s_919_15: i128 = 12;
        // C s_919_16: const #4s : i
        let s_919_16: i128 = 4;
        // D s_919_17: read-var u#33817:u32
        let s_919_17: u32 = fn_state.u_33817;
        // D s_919_18: cast zx s_919_17 -> bv
        let s_919_18: Bits = Bits::new(s_919_17 as u128, 32u16);
        // D s_919_19: bit-extract s_919_18 s_919_15 s_919_16
        let s_919_19: Bits = (Bits::new(
            ((s_919_18) >> (s_919_15)).value(),
            u16::try_from(s_919_16).unwrap(),
        ));
        // D s_919_20: cast reint s_919_19 -> u8
        let s_919_20: u8 = (s_919_19.value() as u8);
        // C s_919_21: const #7s : i
        let s_919_21: i128 = 7;
        // C s_919_22: const #5s : i
        let s_919_22: i128 = 5;
        // D s_919_23: read-var u#33817:u32
        let s_919_23: u32 = fn_state.u_33817;
        // D s_919_24: cast zx s_919_23 -> bv
        let s_919_24: Bits = Bits::new(s_919_23 as u128, 32u16);
        // D s_919_25: bit-extract s_919_24 s_919_21 s_919_22
        let s_919_25: Bits = (Bits::new(
            ((s_919_24) >> (s_919_21)).value(),
            u16::try_from(s_919_22).unwrap(),
        ));
        // D s_919_26: cast reint s_919_25 -> u8
        let s_919_26: u8 = (s_919_25.value() as u8);
        // C s_919_27: const #6s : i
        let s_919_27: i128 = 6;
        // C s_919_28: const #1s : i
        let s_919_28: i128 = 1;
        // D s_919_29: read-var u#33817:u32
        let s_919_29: u32 = fn_state.u_33817;
        // D s_919_30: cast zx s_919_29 -> bv
        let s_919_30: Bits = Bits::new(s_919_29 as u128, 32u16);
        // D s_919_31: bit-extract s_919_30 s_919_27 s_919_28
        let s_919_31: Bits = (Bits::new(
            ((s_919_30) >> (s_919_27)).value(),
            u16::try_from(s_919_28).unwrap(),
        ));
        // D s_919_32: cast reint s_919_31 -> u8
        let s_919_32: bool = ((s_919_31.value()) != 0);
        // C s_919_33: const #0s : i
        let s_919_33: i128 = 0;
        // C s_919_34: const #4s : i
        let s_919_34: i128 = 4;
        // D s_919_35: read-var u#33817:u32
        let s_919_35: u32 = fn_state.u_33817;
        // D s_919_36: cast zx s_919_35 -> bv
        let s_919_36: Bits = Bits::new(s_919_35 as u128, 32u16);
        // D s_919_37: bit-extract s_919_36 s_919_33 s_919_34
        let s_919_37: Bits = (Bits::new(
            ((s_919_36) >> (s_919_33)).value(),
            u16::try_from(s_919_34).unwrap(),
        ));
        // D s_919_38: cast reint s_919_37 -> u8
        let s_919_38: u8 = (s_919_37.value() as u8);
        // D s_919_39: call decode_aarch32_instrs_USAT_A1enc_A_txt(s_919_8, s_919_14, s_919_20, s_919_26, s_919_32, s_919_38)
        let s_919_39: () = decode_aarch32_instrs_USAT_A1enc_A_txt(
            state,
            tracer,
            s_919_8,
            s_919_14,
            s_919_20,
            s_919_26,
            s_919_32,
            s_919_38,
        );
        // N s_919_40: return
        return;
    }
    fn block_920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_920_0: read-var merge#var.1:struct
        let s_920_0: u32 = fn_state.merge_var._1;
        // D s_920_1: write-var u#33825 <= s_920_0
        fn_state.u_33825 = s_920_0;
        // C s_920_2: const #20s : i
        let s_920_2: i128 = 20;
        // D s_920_3: read-var u#33825:u32
        let s_920_3: u32 = fn_state.u_33825;
        // D s_920_4: cast zx s_920_3 -> bv
        let s_920_4: Bits = Bits::new(s_920_3 as u128, 32u16);
        // C s_920_5: const #1s : i64
        let s_920_5: i64 = 1;
        // C s_920_6: cast zx s_920_5 -> i
        let s_920_6: i128 = (i128::try_from(s_920_5).unwrap());
        // C s_920_7: const #7s : i
        let s_920_7: i128 = 7;
        // C s_920_8: add s_920_7 s_920_6
        let s_920_8: i128 = (s_920_7 + s_920_6);
        // D s_920_9: bit-extract s_920_4 s_920_2 s_920_8
        let s_920_9: Bits = (Bits::new(
            ((s_920_4) >> (s_920_2)).value(),
            u16::try_from(s_920_8).unwrap(),
        ));
        // D s_920_10: cast reint s_920_9 -> u8
        let s_920_10: u8 = (s_920_9.value() as u8);
        // D s_920_11: cast zx s_920_10 -> bv
        let s_920_11: Bits = Bits::new(s_920_10 as u128, 8u16);
        // C s_920_12: const #101u : u8
        let s_920_12: u8 = 101;
        // C s_920_13: cast zx s_920_12 -> bv
        let s_920_13: Bits = Bits::new(s_920_12 as u128, 8u16);
        // D s_920_14: cmp-eq s_920_11 s_920_13
        let s_920_14: bool = ((s_920_11) == (s_920_13));
        // N s_920_15: branch s_920_14 b1082 b921
        if s_920_14 {
            return block_1082(state, tracer, fn_state);
        } else {
            return block_921(state, tracer, fn_state);
        };
    }
    fn block_921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_921_0: const #0u : u8
        let s_921_0: bool = false;
        // D s_921_1: write-var gs#411105 <= s_921_0
        fn_state.gs_411105 = s_921_0;
        // N s_921_2: jump b922
        return block_922(state, tracer, fn_state);
    }
    fn block_922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_922_0: read-var gs#411105:u8
        let s_922_0: bool = fn_state.gs_411105;
        // N s_922_1: branch s_922_0 b1078 b923
        if s_922_0 {
            return block_1078(state, tracer, fn_state);
        } else {
            return block_923(state, tracer, fn_state);
        };
    }
    fn block_923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_923_0: const #0u : u8
        let s_923_0: bool = false;
        // D s_923_1: write-var gs#411110 <= s_923_0
        fn_state.gs_411110 = s_923_0;
        // N s_923_2: jump b924
        return block_924(state, tracer, fn_state);
    }
    fn block_924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_924_0: read-var gs#411110:u8
        let s_924_0: bool = fn_state.gs_411110;
        // D s_924_1: not s_924_0
        let s_924_1: bool = !s_924_0;
        // N s_924_2: branch s_924_1 b937 b925
        if s_924_1 {
            return block_937(state, tracer, fn_state);
        } else {
            return block_925(state, tracer, fn_state);
        };
    }
    fn block_925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_925_0: const #3330s : i
        let s_925_0: i128 = 3330;
        // C s_925_1: const #14696u : u32
        let s_925_1: u32 = 14696;
        // N s_925_2: write-reg s_925_1 <= s_925_0
        let s_925_2: () = {
            state.write_register::<i128>(s_925_1 as isize, s_925_0);
            tracer.write_register(s_925_1 as isize, s_925_0);
        };
        // C s_925_3: const #28s : i
        let s_925_3: i128 = 28;
        // C s_925_4: const #4s : i
        let s_925_4: i128 = 4;
        // D s_925_5: read-var u#33825:u32
        let s_925_5: u32 = fn_state.u_33825;
        // D s_925_6: cast zx s_925_5 -> bv
        let s_925_6: Bits = Bits::new(s_925_5 as u128, 32u16);
        // D s_925_7: bit-extract s_925_6 s_925_3 s_925_4
        let s_925_7: Bits = (Bits::new(
            ((s_925_6) >> (s_925_3)).value(),
            u16::try_from(s_925_4).unwrap(),
        ));
        // D s_925_8: cast reint s_925_7 -> u8
        let s_925_8: u8 = (s_925_7.value() as u8);
        // D s_925_9: write-var u#33826 <= s_925_8
        fn_state.u_33826 = s_925_8;
        // C s_925_10: const #16s : i
        let s_925_10: i128 = 16;
        // C s_925_11: const #4s : i
        let s_925_11: i128 = 4;
        // D s_925_12: read-var u#33825:u32
        let s_925_12: u32 = fn_state.u_33825;
        // D s_925_13: cast zx s_925_12 -> bv
        let s_925_13: Bits = Bits::new(s_925_12 as u128, 32u16);
        // D s_925_14: bit-extract s_925_13 s_925_10 s_925_11
        let s_925_14: Bits = (Bits::new(
            ((s_925_13) >> (s_925_10)).value(),
            u16::try_from(s_925_11).unwrap(),
        ));
        // D s_925_15: cast reint s_925_14 -> u8
        let s_925_15: u8 = (s_925_14.value() as u8);
        // D s_925_16: write-var u#33827 <= s_925_15
        fn_state.u_33827 = s_925_15;
        // C s_925_17: const #12s : i
        let s_925_17: i128 = 12;
        // C s_925_18: const #4s : i
        let s_925_18: i128 = 4;
        // D s_925_19: read-var u#33825:u32
        let s_925_19: u32 = fn_state.u_33825;
        // D s_925_20: cast zx s_925_19 -> bv
        let s_925_20: Bits = Bits::new(s_925_19 as u128, 32u16);
        // D s_925_21: bit-extract s_925_20 s_925_17 s_925_18
        let s_925_21: Bits = (Bits::new(
            ((s_925_20) >> (s_925_17)).value(),
            u16::try_from(s_925_18).unwrap(),
        ));
        // D s_925_22: cast reint s_925_21 -> u8
        let s_925_22: u8 = (s_925_21.value() as u8);
        // D s_925_23: write-var u#33828 <= s_925_22
        fn_state.u_33828 = s_925_22;
        // C s_925_24: const #0s : i
        let s_925_24: i128 = 0;
        // C s_925_25: const #4s : i
        let s_925_25: i128 = 4;
        // D s_925_26: read-var u#33825:u32
        let s_925_26: u32 = fn_state.u_33825;
        // D s_925_27: cast zx s_925_26 -> bv
        let s_925_27: Bits = Bits::new(s_925_26 as u128, 32u16);
        // D s_925_28: bit-extract s_925_27 s_925_24 s_925_25
        let s_925_28: Bits = (Bits::new(
            ((s_925_27) >> (s_925_24)).value(),
            u16::try_from(s_925_25).unwrap(),
        ));
        // D s_925_29: cast reint s_925_28 -> u8
        let s_925_29: u8 = (s_925_28.value() as u8);
        // D s_925_30: write-var u#33829 <= s_925_29
        fn_state.u_33829 = s_925_29;
        // C s_925_31: const #8s : i
        let s_925_31: i128 = 8;
        // D s_925_32: read-var u#33825:u32
        let s_925_32: u32 = fn_state.u_33825;
        // D s_925_33: cast zx s_925_32 -> bv
        let s_925_33: Bits = Bits::new(s_925_32 as u128, 32u16);
        // C s_925_34: const #1u : u64
        let s_925_34: u64 = 1;
        // D s_925_35: bit-extract s_925_33 s_925_31 s_925_34
        let s_925_35: Bits = (Bits::new(
            ((s_925_33) >> (s_925_31)).value(),
            u16::try_from(s_925_34).unwrap(),
        ));
        // D s_925_36: cast reint s_925_35 -> u8
        let s_925_36: bool = ((s_925_35.value()) != 0);
        // C s_925_37: const #0s : i
        let s_925_37: i128 = 0;
        // C s_925_38: const #0u : u64
        let s_925_38: u64 = 0;
        // D s_925_39: cast zx s_925_36 -> u64
        let s_925_39: u64 = (s_925_36 as u64);
        // C s_925_40: const #1u : u64
        let s_925_40: u64 = 1;
        // D s_925_41: and s_925_39 s_925_40
        let s_925_41: u64 = ((s_925_39) & (s_925_40));
        // D s_925_42: cmp-eq s_925_41 s_925_40
        let s_925_42: bool = ((s_925_41) == (s_925_40));
        // D s_925_43: lsl s_925_39 s_925_37
        let s_925_43: u64 = s_925_39 << s_925_37;
        // D s_925_44: or s_925_38 s_925_43
        let s_925_44: u64 = ((s_925_38) | (s_925_43));
        // D s_925_45: cmpl s_925_43
        let s_925_45: u64 = !s_925_43;
        // D s_925_46: and s_925_38 s_925_45
        let s_925_46: u64 = ((s_925_38) & (s_925_45));
        // D s_925_47: select s_925_42 s_925_44 s_925_46
        let s_925_47: u64 = if s_925_42 { s_925_44 } else { s_925_46 };
        // D s_925_48: cast trunc s_925_47 -> u8
        let s_925_48: bool = ((s_925_47) != 0);
        // D s_925_49: cast zx s_925_48 -> bv
        let s_925_49: Bits = Bits::new(s_925_48 as u128, 1u16);
        // C s_925_50: const #1u : u8
        let s_925_50: bool = true;
        // C s_925_51: cast zx s_925_50 -> bv
        let s_925_51: Bits = Bits::new(s_925_50 as u128, 1u16);
        // D s_925_52: cmp-ne s_925_49 s_925_51
        let s_925_52: bool = ((s_925_49) != (s_925_51));
        // N s_925_53: branch s_925_52 b936 b926
        if s_925_52 {
            return block_936(state, tracer, fn_state);
        } else {
            return block_926(state, tracer, fn_state);
        };
    }
    fn block_926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_926_0: const #9s : i
        let s_926_0: i128 = 9;
        // D s_926_1: read-var u#33825:u32
        let s_926_1: u32 = fn_state.u_33825;
        // D s_926_2: cast zx s_926_1 -> bv
        let s_926_2: Bits = Bits::new(s_926_1 as u128, 32u16);
        // C s_926_3: const #1u : u64
        let s_926_3: u64 = 1;
        // D s_926_4: bit-extract s_926_2 s_926_0 s_926_3
        let s_926_4: Bits = (Bits::new(
            ((s_926_2) >> (s_926_0)).value(),
            u16::try_from(s_926_3).unwrap(),
        ));
        // D s_926_5: cast reint s_926_4 -> u8
        let s_926_5: bool = ((s_926_4.value()) != 0);
        // C s_926_6: const #0s : i
        let s_926_6: i128 = 0;
        // C s_926_7: const #0u : u64
        let s_926_7: u64 = 0;
        // D s_926_8: cast zx s_926_5 -> u64
        let s_926_8: u64 = (s_926_5 as u64);
        // C s_926_9: const #1u : u64
        let s_926_9: u64 = 1;
        // D s_926_10: and s_926_8 s_926_9
        let s_926_10: u64 = ((s_926_8) & (s_926_9));
        // D s_926_11: cmp-eq s_926_10 s_926_9
        let s_926_11: bool = ((s_926_10) == (s_926_9));
        // D s_926_12: lsl s_926_8 s_926_6
        let s_926_12: u64 = s_926_8 << s_926_6;
        // D s_926_13: or s_926_7 s_926_12
        let s_926_13: u64 = ((s_926_7) | (s_926_12));
        // D s_926_14: cmpl s_926_12
        let s_926_14: u64 = !s_926_12;
        // D s_926_15: and s_926_7 s_926_14
        let s_926_15: u64 = ((s_926_7) & (s_926_14));
        // D s_926_16: select s_926_11 s_926_13 s_926_15
        let s_926_16: u64 = if s_926_11 { s_926_13 } else { s_926_15 };
        // D s_926_17: cast trunc s_926_16 -> u8
        let s_926_17: bool = ((s_926_16) != 0);
        // D s_926_18: cast zx s_926_17 -> bv
        let s_926_18: Bits = Bits::new(s_926_17 as u128, 1u16);
        // C s_926_19: const #1u : u8
        let s_926_19: bool = true;
        // C s_926_20: cast zx s_926_19 -> bv
        let s_926_20: Bits = Bits::new(s_926_19 as u128, 1u16);
        // D s_926_21: cmp-ne s_926_18 s_926_20
        let s_926_21: bool = ((s_926_18) != (s_926_20));
        // D s_926_22: write-var gs#411125 <= s_926_21
        fn_state.gs_411125 = s_926_21;
        // N s_926_23: jump b927
        return block_927(state, tracer, fn_state);
    }
    fn block_927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_927_0: read-var gs#411125:u8
        let s_927_0: bool = fn_state.gs_411125;
        // N s_927_1: branch s_927_0 b935 b928
        if s_927_0 {
            return block_935(state, tracer, fn_state);
        } else {
            return block_928(state, tracer, fn_state);
        };
    }
    fn block_928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_928_0: const #10s : i
        let s_928_0: i128 = 10;
        // D s_928_1: read-var u#33825:u32
        let s_928_1: u32 = fn_state.u_33825;
        // D s_928_2: cast zx s_928_1 -> bv
        let s_928_2: Bits = Bits::new(s_928_1 as u128, 32u16);
        // C s_928_3: const #1u : u64
        let s_928_3: u64 = 1;
        // D s_928_4: bit-extract s_928_2 s_928_0 s_928_3
        let s_928_4: Bits = (Bits::new(
            ((s_928_2) >> (s_928_0)).value(),
            u16::try_from(s_928_3).unwrap(),
        ));
        // D s_928_5: cast reint s_928_4 -> u8
        let s_928_5: bool = ((s_928_4.value()) != 0);
        // C s_928_6: const #0s : i
        let s_928_6: i128 = 0;
        // C s_928_7: const #0u : u64
        let s_928_7: u64 = 0;
        // D s_928_8: cast zx s_928_5 -> u64
        let s_928_8: u64 = (s_928_5 as u64);
        // C s_928_9: const #1u : u64
        let s_928_9: u64 = 1;
        // D s_928_10: and s_928_8 s_928_9
        let s_928_10: u64 = ((s_928_8) & (s_928_9));
        // D s_928_11: cmp-eq s_928_10 s_928_9
        let s_928_11: bool = ((s_928_10) == (s_928_9));
        // D s_928_12: lsl s_928_8 s_928_6
        let s_928_12: u64 = s_928_8 << s_928_6;
        // D s_928_13: or s_928_7 s_928_12
        let s_928_13: u64 = ((s_928_7) | (s_928_12));
        // D s_928_14: cmpl s_928_12
        let s_928_14: u64 = !s_928_12;
        // D s_928_15: and s_928_7 s_928_14
        let s_928_15: u64 = ((s_928_7) & (s_928_14));
        // D s_928_16: select s_928_11 s_928_13 s_928_15
        let s_928_16: u64 = if s_928_11 { s_928_13 } else { s_928_15 };
        // D s_928_17: cast trunc s_928_16 -> u8
        let s_928_17: bool = ((s_928_16) != 0);
        // D s_928_18: cast zx s_928_17 -> bv
        let s_928_18: Bits = Bits::new(s_928_17 as u128, 1u16);
        // C s_928_19: const #1u : u8
        let s_928_19: bool = true;
        // C s_928_20: cast zx s_928_19 -> bv
        let s_928_20: Bits = Bits::new(s_928_19 as u128, 1u16);
        // D s_928_21: cmp-ne s_928_18 s_928_20
        let s_928_21: bool = ((s_928_18) != (s_928_20));
        // D s_928_22: write-var gs#411128 <= s_928_21
        fn_state.gs_411128 = s_928_21;
        // N s_928_23: jump b929
        return block_929(state, tracer, fn_state);
    }
    fn block_929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_929_0: read-var gs#411128:u8
        let s_929_0: bool = fn_state.gs_411128;
        // N s_929_1: branch s_929_0 b934 b930
        if s_929_0 {
            return block_934(state, tracer, fn_state);
        } else {
            return block_930(state, tracer, fn_state);
        };
    }
    fn block_930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_930_0: const #11s : i
        let s_930_0: i128 = 11;
        // D s_930_1: read-var u#33825:u32
        let s_930_1: u32 = fn_state.u_33825;
        // D s_930_2: cast zx s_930_1 -> bv
        let s_930_2: Bits = Bits::new(s_930_1 as u128, 32u16);
        // C s_930_3: const #1u : u64
        let s_930_3: u64 = 1;
        // D s_930_4: bit-extract s_930_2 s_930_0 s_930_3
        let s_930_4: Bits = (Bits::new(
            ((s_930_2) >> (s_930_0)).value(),
            u16::try_from(s_930_3).unwrap(),
        ));
        // D s_930_5: cast reint s_930_4 -> u8
        let s_930_5: bool = ((s_930_4.value()) != 0);
        // C s_930_6: const #0s : i
        let s_930_6: i128 = 0;
        // C s_930_7: const #0u : u64
        let s_930_7: u64 = 0;
        // D s_930_8: cast zx s_930_5 -> u64
        let s_930_8: u64 = (s_930_5 as u64);
        // C s_930_9: const #1u : u64
        let s_930_9: u64 = 1;
        // D s_930_10: and s_930_8 s_930_9
        let s_930_10: u64 = ((s_930_8) & (s_930_9));
        // D s_930_11: cmp-eq s_930_10 s_930_9
        let s_930_11: bool = ((s_930_10) == (s_930_9));
        // D s_930_12: lsl s_930_8 s_930_6
        let s_930_12: u64 = s_930_8 << s_930_6;
        // D s_930_13: or s_930_7 s_930_12
        let s_930_13: u64 = ((s_930_7) | (s_930_12));
        // D s_930_14: cmpl s_930_12
        let s_930_14: u64 = !s_930_12;
        // D s_930_15: and s_930_7 s_930_14
        let s_930_15: u64 = ((s_930_7) & (s_930_14));
        // D s_930_16: select s_930_11 s_930_13 s_930_15
        let s_930_16: u64 = if s_930_11 { s_930_13 } else { s_930_15 };
        // D s_930_17: cast trunc s_930_16 -> u8
        let s_930_17: bool = ((s_930_16) != 0);
        // D s_930_18: cast zx s_930_17 -> bv
        let s_930_18: Bits = Bits::new(s_930_17 as u128, 1u16);
        // C s_930_19: const #1u : u8
        let s_930_19: bool = true;
        // C s_930_20: cast zx s_930_19 -> bv
        let s_930_20: Bits = Bits::new(s_930_19 as u128, 1u16);
        // D s_930_21: cmp-ne s_930_18 s_930_20
        let s_930_21: bool = ((s_930_18) != (s_930_20));
        // D s_930_22: write-var gs#411131 <= s_930_21
        fn_state.gs_411131 = s_930_21;
        // N s_930_23: jump b931
        return block_931(state, tracer, fn_state);
    }
    fn block_931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_931_0: read-var gs#411131:u8
        let s_931_0: bool = fn_state.gs_411131;
        // N s_931_1: branch s_931_0 b933 b932
        if s_931_0 {
            return block_933(state, tracer, fn_state);
        } else {
            return block_932(state, tracer, fn_state);
        };
    }
    fn block_932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_932_0: read-var u#33826:u8
        let s_932_0: u8 = fn_state.u_33826;
        // D s_932_1: read-var u#33827:u8
        let s_932_1: u8 = fn_state.u_33827;
        // D s_932_2: read-var u#33828:u8
        let s_932_2: u8 = fn_state.u_33828;
        // D s_932_3: read-var u#33829:u8
        let s_932_3: u8 = fn_state.u_33829;
        // D s_932_4: call decode_aarch32_instrs_USAX_A1enc_A_txt(s_932_0, s_932_1, s_932_2, s_932_3)
        let s_932_4: () = decode_aarch32_instrs_USAX_A1enc_A_txt(
            state,
            tracer,
            s_932_0,
            s_932_1,
            s_932_2,
            s_932_3,
        );
        // N s_932_5: return
        return;
    }
    fn block_933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_933_0: panic
        panic!("{:?}", ());
        // N s_933_1: return
        return;
    }
    fn block_934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_934_0: const #1u : u8
        let s_934_0: bool = true;
        // D s_934_1: write-var gs#411131 <= s_934_0
        fn_state.gs_411131 = s_934_0;
        // N s_934_2: jump b931
        return block_931(state, tracer, fn_state);
    }
    fn block_935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_935_0: const #1u : u8
        let s_935_0: bool = true;
        // D s_935_1: write-var gs#411128 <= s_935_0
        fn_state.gs_411128 = s_935_0;
        // N s_935_2: jump b929
        return block_929(state, tracer, fn_state);
    }
    fn block_936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_936_0: const #1u : u8
        let s_936_0: bool = true;
        // D s_936_1: write-var gs#411125 <= s_936_0
        fn_state.gs_411125 = s_936_0;
        // N s_936_2: jump b927
        return block_927(state, tracer, fn_state);
    }
    fn block_937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_937_0: read-var merge#var.1:struct
        let s_937_0: u32 = fn_state.merge_var._1;
        // D s_937_1: write-var u#33831 <= s_937_0
        fn_state.u_33831 = s_937_0;
        // C s_937_2: const #20s : i
        let s_937_2: i128 = 20;
        // D s_937_3: read-var u#33831:u32
        let s_937_3: u32 = fn_state.u_33831;
        // D s_937_4: cast zx s_937_3 -> bv
        let s_937_4: Bits = Bits::new(s_937_3 as u128, 32u16);
        // C s_937_5: const #1s : i64
        let s_937_5: i64 = 1;
        // C s_937_6: cast zx s_937_5 -> i
        let s_937_6: i128 = (i128::try_from(s_937_5).unwrap());
        // C s_937_7: const #7s : i
        let s_937_7: i128 = 7;
        // C s_937_8: add s_937_7 s_937_6
        let s_937_8: i128 = (s_937_7 + s_937_6);
        // D s_937_9: bit-extract s_937_4 s_937_2 s_937_8
        let s_937_9: Bits = (Bits::new(
            ((s_937_4) >> (s_937_2)).value(),
            u16::try_from(s_937_8).unwrap(),
        ));
        // D s_937_10: cast reint s_937_9 -> u8
        let s_937_10: u8 = (s_937_9.value() as u8);
        // D s_937_11: cast zx s_937_10 -> bv
        let s_937_11: Bits = Bits::new(s_937_10 as u128, 8u16);
        // C s_937_12: const #101u : u8
        let s_937_12: u8 = 101;
        // C s_937_13: cast zx s_937_12 -> bv
        let s_937_13: Bits = Bits::new(s_937_12 as u128, 8u16);
        // D s_937_14: cmp-eq s_937_11 s_937_13
        let s_937_14: bool = ((s_937_11) == (s_937_13));
        // N s_937_15: branch s_937_14 b1077 b938
        if s_937_14 {
            return block_1077(state, tracer, fn_state);
        } else {
            return block_938(state, tracer, fn_state);
        };
    }
    fn block_938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_938_0: const #0u : u8
        let s_938_0: bool = false;
        // D s_938_1: write-var gs#411137 <= s_938_0
        fn_state.gs_411137 = s_938_0;
        // N s_938_2: jump b939
        return block_939(state, tracer, fn_state);
    }
    fn block_939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_939_0: read-var gs#411137:u8
        let s_939_0: bool = fn_state.gs_411137;
        // N s_939_1: branch s_939_0 b1073 b940
        if s_939_0 {
            return block_1073(state, tracer, fn_state);
        } else {
            return block_940(state, tracer, fn_state);
        };
    }
    fn block_940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_940_0: const #0u : u8
        let s_940_0: bool = false;
        // D s_940_1: write-var gs#411142 <= s_940_0
        fn_state.gs_411142 = s_940_0;
        // N s_940_2: jump b941
        return block_941(state, tracer, fn_state);
    }
    fn block_941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_941_0: read-var gs#411142:u8
        let s_941_0: bool = fn_state.gs_411142;
        // D s_941_1: not s_941_0
        let s_941_1: bool = !s_941_0;
        // N s_941_2: branch s_941_1 b954 b942
        if s_941_1 {
            return block_954(state, tracer, fn_state);
        } else {
            return block_942(state, tracer, fn_state);
        };
    }
    fn block_942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_942_0: const #3332s : i
        let s_942_0: i128 = 3332;
        // C s_942_1: const #14696u : u32
        let s_942_1: u32 = 14696;
        // N s_942_2: write-reg s_942_1 <= s_942_0
        let s_942_2: () = {
            state.write_register::<i128>(s_942_1 as isize, s_942_0);
            tracer.write_register(s_942_1 as isize, s_942_0);
        };
        // C s_942_3: const #28s : i
        let s_942_3: i128 = 28;
        // C s_942_4: const #4s : i
        let s_942_4: i128 = 4;
        // D s_942_5: read-var u#33831:u32
        let s_942_5: u32 = fn_state.u_33831;
        // D s_942_6: cast zx s_942_5 -> bv
        let s_942_6: Bits = Bits::new(s_942_5 as u128, 32u16);
        // D s_942_7: bit-extract s_942_6 s_942_3 s_942_4
        let s_942_7: Bits = (Bits::new(
            ((s_942_6) >> (s_942_3)).value(),
            u16::try_from(s_942_4).unwrap(),
        ));
        // D s_942_8: cast reint s_942_7 -> u8
        let s_942_8: u8 = (s_942_7.value() as u8);
        // D s_942_9: write-var u#33832 <= s_942_8
        fn_state.u_33832 = s_942_8;
        // C s_942_10: const #16s : i
        let s_942_10: i128 = 16;
        // C s_942_11: const #4s : i
        let s_942_11: i128 = 4;
        // D s_942_12: read-var u#33831:u32
        let s_942_12: u32 = fn_state.u_33831;
        // D s_942_13: cast zx s_942_12 -> bv
        let s_942_13: Bits = Bits::new(s_942_12 as u128, 32u16);
        // D s_942_14: bit-extract s_942_13 s_942_10 s_942_11
        let s_942_14: Bits = (Bits::new(
            ((s_942_13) >> (s_942_10)).value(),
            u16::try_from(s_942_11).unwrap(),
        ));
        // D s_942_15: cast reint s_942_14 -> u8
        let s_942_15: u8 = (s_942_14.value() as u8);
        // D s_942_16: write-var u#33833 <= s_942_15
        fn_state.u_33833 = s_942_15;
        // C s_942_17: const #12s : i
        let s_942_17: i128 = 12;
        // C s_942_18: const #4s : i
        let s_942_18: i128 = 4;
        // D s_942_19: read-var u#33831:u32
        let s_942_19: u32 = fn_state.u_33831;
        // D s_942_20: cast zx s_942_19 -> bv
        let s_942_20: Bits = Bits::new(s_942_19 as u128, 32u16);
        // D s_942_21: bit-extract s_942_20 s_942_17 s_942_18
        let s_942_21: Bits = (Bits::new(
            ((s_942_20) >> (s_942_17)).value(),
            u16::try_from(s_942_18).unwrap(),
        ));
        // D s_942_22: cast reint s_942_21 -> u8
        let s_942_22: u8 = (s_942_21.value() as u8);
        // D s_942_23: write-var u#33834 <= s_942_22
        fn_state.u_33834 = s_942_22;
        // C s_942_24: const #0s : i
        let s_942_24: i128 = 0;
        // C s_942_25: const #4s : i
        let s_942_25: i128 = 4;
        // D s_942_26: read-var u#33831:u32
        let s_942_26: u32 = fn_state.u_33831;
        // D s_942_27: cast zx s_942_26 -> bv
        let s_942_27: Bits = Bits::new(s_942_26 as u128, 32u16);
        // D s_942_28: bit-extract s_942_27 s_942_24 s_942_25
        let s_942_28: Bits = (Bits::new(
            ((s_942_27) >> (s_942_24)).value(),
            u16::try_from(s_942_25).unwrap(),
        ));
        // D s_942_29: cast reint s_942_28 -> u8
        let s_942_29: u8 = (s_942_28.value() as u8);
        // D s_942_30: write-var u#33835 <= s_942_29
        fn_state.u_33835 = s_942_29;
        // C s_942_31: const #8s : i
        let s_942_31: i128 = 8;
        // D s_942_32: read-var u#33831:u32
        let s_942_32: u32 = fn_state.u_33831;
        // D s_942_33: cast zx s_942_32 -> bv
        let s_942_33: Bits = Bits::new(s_942_32 as u128, 32u16);
        // C s_942_34: const #1u : u64
        let s_942_34: u64 = 1;
        // D s_942_35: bit-extract s_942_33 s_942_31 s_942_34
        let s_942_35: Bits = (Bits::new(
            ((s_942_33) >> (s_942_31)).value(),
            u16::try_from(s_942_34).unwrap(),
        ));
        // D s_942_36: cast reint s_942_35 -> u8
        let s_942_36: bool = ((s_942_35.value()) != 0);
        // C s_942_37: const #0s : i
        let s_942_37: i128 = 0;
        // C s_942_38: const #0u : u64
        let s_942_38: u64 = 0;
        // D s_942_39: cast zx s_942_36 -> u64
        let s_942_39: u64 = (s_942_36 as u64);
        // C s_942_40: const #1u : u64
        let s_942_40: u64 = 1;
        // D s_942_41: and s_942_39 s_942_40
        let s_942_41: u64 = ((s_942_39) & (s_942_40));
        // D s_942_42: cmp-eq s_942_41 s_942_40
        let s_942_42: bool = ((s_942_41) == (s_942_40));
        // D s_942_43: lsl s_942_39 s_942_37
        let s_942_43: u64 = s_942_39 << s_942_37;
        // D s_942_44: or s_942_38 s_942_43
        let s_942_44: u64 = ((s_942_38) | (s_942_43));
        // D s_942_45: cmpl s_942_43
        let s_942_45: u64 = !s_942_43;
        // D s_942_46: and s_942_38 s_942_45
        let s_942_46: u64 = ((s_942_38) & (s_942_45));
        // D s_942_47: select s_942_42 s_942_44 s_942_46
        let s_942_47: u64 = if s_942_42 { s_942_44 } else { s_942_46 };
        // D s_942_48: cast trunc s_942_47 -> u8
        let s_942_48: bool = ((s_942_47) != 0);
        // D s_942_49: cast zx s_942_48 -> bv
        let s_942_49: Bits = Bits::new(s_942_48 as u128, 1u16);
        // C s_942_50: const #1u : u8
        let s_942_50: bool = true;
        // C s_942_51: cast zx s_942_50 -> bv
        let s_942_51: Bits = Bits::new(s_942_50 as u128, 1u16);
        // D s_942_52: cmp-ne s_942_49 s_942_51
        let s_942_52: bool = ((s_942_49) != (s_942_51));
        // N s_942_53: branch s_942_52 b953 b943
        if s_942_52 {
            return block_953(state, tracer, fn_state);
        } else {
            return block_943(state, tracer, fn_state);
        };
    }
    fn block_943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_943_0: const #9s : i
        let s_943_0: i128 = 9;
        // D s_943_1: read-var u#33831:u32
        let s_943_1: u32 = fn_state.u_33831;
        // D s_943_2: cast zx s_943_1 -> bv
        let s_943_2: Bits = Bits::new(s_943_1 as u128, 32u16);
        // C s_943_3: const #1u : u64
        let s_943_3: u64 = 1;
        // D s_943_4: bit-extract s_943_2 s_943_0 s_943_3
        let s_943_4: Bits = (Bits::new(
            ((s_943_2) >> (s_943_0)).value(),
            u16::try_from(s_943_3).unwrap(),
        ));
        // D s_943_5: cast reint s_943_4 -> u8
        let s_943_5: bool = ((s_943_4.value()) != 0);
        // C s_943_6: const #0s : i
        let s_943_6: i128 = 0;
        // C s_943_7: const #0u : u64
        let s_943_7: u64 = 0;
        // D s_943_8: cast zx s_943_5 -> u64
        let s_943_8: u64 = (s_943_5 as u64);
        // C s_943_9: const #1u : u64
        let s_943_9: u64 = 1;
        // D s_943_10: and s_943_8 s_943_9
        let s_943_10: u64 = ((s_943_8) & (s_943_9));
        // D s_943_11: cmp-eq s_943_10 s_943_9
        let s_943_11: bool = ((s_943_10) == (s_943_9));
        // D s_943_12: lsl s_943_8 s_943_6
        let s_943_12: u64 = s_943_8 << s_943_6;
        // D s_943_13: or s_943_7 s_943_12
        let s_943_13: u64 = ((s_943_7) | (s_943_12));
        // D s_943_14: cmpl s_943_12
        let s_943_14: u64 = !s_943_12;
        // D s_943_15: and s_943_7 s_943_14
        let s_943_15: u64 = ((s_943_7) & (s_943_14));
        // D s_943_16: select s_943_11 s_943_13 s_943_15
        let s_943_16: u64 = if s_943_11 { s_943_13 } else { s_943_15 };
        // D s_943_17: cast trunc s_943_16 -> u8
        let s_943_17: bool = ((s_943_16) != 0);
        // D s_943_18: cast zx s_943_17 -> bv
        let s_943_18: Bits = Bits::new(s_943_17 as u128, 1u16);
        // C s_943_19: const #1u : u8
        let s_943_19: bool = true;
        // C s_943_20: cast zx s_943_19 -> bv
        let s_943_20: Bits = Bits::new(s_943_19 as u128, 1u16);
        // D s_943_21: cmp-ne s_943_18 s_943_20
        let s_943_21: bool = ((s_943_18) != (s_943_20));
        // D s_943_22: write-var gs#411157 <= s_943_21
        fn_state.gs_411157 = s_943_21;
        // N s_943_23: jump b944
        return block_944(state, tracer, fn_state);
    }
    fn block_944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_944_0: read-var gs#411157:u8
        let s_944_0: bool = fn_state.gs_411157;
        // N s_944_1: branch s_944_0 b952 b945
        if s_944_0 {
            return block_952(state, tracer, fn_state);
        } else {
            return block_945(state, tracer, fn_state);
        };
    }
    fn block_945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_945_0: const #10s : i
        let s_945_0: i128 = 10;
        // D s_945_1: read-var u#33831:u32
        let s_945_1: u32 = fn_state.u_33831;
        // D s_945_2: cast zx s_945_1 -> bv
        let s_945_2: Bits = Bits::new(s_945_1 as u128, 32u16);
        // C s_945_3: const #1u : u64
        let s_945_3: u64 = 1;
        // D s_945_4: bit-extract s_945_2 s_945_0 s_945_3
        let s_945_4: Bits = (Bits::new(
            ((s_945_2) >> (s_945_0)).value(),
            u16::try_from(s_945_3).unwrap(),
        ));
        // D s_945_5: cast reint s_945_4 -> u8
        let s_945_5: bool = ((s_945_4.value()) != 0);
        // C s_945_6: const #0s : i
        let s_945_6: i128 = 0;
        // C s_945_7: const #0u : u64
        let s_945_7: u64 = 0;
        // D s_945_8: cast zx s_945_5 -> u64
        let s_945_8: u64 = (s_945_5 as u64);
        // C s_945_9: const #1u : u64
        let s_945_9: u64 = 1;
        // D s_945_10: and s_945_8 s_945_9
        let s_945_10: u64 = ((s_945_8) & (s_945_9));
        // D s_945_11: cmp-eq s_945_10 s_945_9
        let s_945_11: bool = ((s_945_10) == (s_945_9));
        // D s_945_12: lsl s_945_8 s_945_6
        let s_945_12: u64 = s_945_8 << s_945_6;
        // D s_945_13: or s_945_7 s_945_12
        let s_945_13: u64 = ((s_945_7) | (s_945_12));
        // D s_945_14: cmpl s_945_12
        let s_945_14: u64 = !s_945_12;
        // D s_945_15: and s_945_7 s_945_14
        let s_945_15: u64 = ((s_945_7) & (s_945_14));
        // D s_945_16: select s_945_11 s_945_13 s_945_15
        let s_945_16: u64 = if s_945_11 { s_945_13 } else { s_945_15 };
        // D s_945_17: cast trunc s_945_16 -> u8
        let s_945_17: bool = ((s_945_16) != 0);
        // D s_945_18: cast zx s_945_17 -> bv
        let s_945_18: Bits = Bits::new(s_945_17 as u128, 1u16);
        // C s_945_19: const #1u : u8
        let s_945_19: bool = true;
        // C s_945_20: cast zx s_945_19 -> bv
        let s_945_20: Bits = Bits::new(s_945_19 as u128, 1u16);
        // D s_945_21: cmp-ne s_945_18 s_945_20
        let s_945_21: bool = ((s_945_18) != (s_945_20));
        // D s_945_22: write-var gs#411160 <= s_945_21
        fn_state.gs_411160 = s_945_21;
        // N s_945_23: jump b946
        return block_946(state, tracer, fn_state);
    }
    fn block_946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_946_0: read-var gs#411160:u8
        let s_946_0: bool = fn_state.gs_411160;
        // N s_946_1: branch s_946_0 b951 b947
        if s_946_0 {
            return block_951(state, tracer, fn_state);
        } else {
            return block_947(state, tracer, fn_state);
        };
    }
    fn block_947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_947_0: const #11s : i
        let s_947_0: i128 = 11;
        // D s_947_1: read-var u#33831:u32
        let s_947_1: u32 = fn_state.u_33831;
        // D s_947_2: cast zx s_947_1 -> bv
        let s_947_2: Bits = Bits::new(s_947_1 as u128, 32u16);
        // C s_947_3: const #1u : u64
        let s_947_3: u64 = 1;
        // D s_947_4: bit-extract s_947_2 s_947_0 s_947_3
        let s_947_4: Bits = (Bits::new(
            ((s_947_2) >> (s_947_0)).value(),
            u16::try_from(s_947_3).unwrap(),
        ));
        // D s_947_5: cast reint s_947_4 -> u8
        let s_947_5: bool = ((s_947_4.value()) != 0);
        // C s_947_6: const #0s : i
        let s_947_6: i128 = 0;
        // C s_947_7: const #0u : u64
        let s_947_7: u64 = 0;
        // D s_947_8: cast zx s_947_5 -> u64
        let s_947_8: u64 = (s_947_5 as u64);
        // C s_947_9: const #1u : u64
        let s_947_9: u64 = 1;
        // D s_947_10: and s_947_8 s_947_9
        let s_947_10: u64 = ((s_947_8) & (s_947_9));
        // D s_947_11: cmp-eq s_947_10 s_947_9
        let s_947_11: bool = ((s_947_10) == (s_947_9));
        // D s_947_12: lsl s_947_8 s_947_6
        let s_947_12: u64 = s_947_8 << s_947_6;
        // D s_947_13: or s_947_7 s_947_12
        let s_947_13: u64 = ((s_947_7) | (s_947_12));
        // D s_947_14: cmpl s_947_12
        let s_947_14: u64 = !s_947_12;
        // D s_947_15: and s_947_7 s_947_14
        let s_947_15: u64 = ((s_947_7) & (s_947_14));
        // D s_947_16: select s_947_11 s_947_13 s_947_15
        let s_947_16: u64 = if s_947_11 { s_947_13 } else { s_947_15 };
        // D s_947_17: cast trunc s_947_16 -> u8
        let s_947_17: bool = ((s_947_16) != 0);
        // D s_947_18: cast zx s_947_17 -> bv
        let s_947_18: Bits = Bits::new(s_947_17 as u128, 1u16);
        // C s_947_19: const #1u : u8
        let s_947_19: bool = true;
        // C s_947_20: cast zx s_947_19 -> bv
        let s_947_20: Bits = Bits::new(s_947_19 as u128, 1u16);
        // D s_947_21: cmp-ne s_947_18 s_947_20
        let s_947_21: bool = ((s_947_18) != (s_947_20));
        // D s_947_22: write-var gs#411163 <= s_947_21
        fn_state.gs_411163 = s_947_21;
        // N s_947_23: jump b948
        return block_948(state, tracer, fn_state);
    }
    fn block_948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_948_0: read-var gs#411163:u8
        let s_948_0: bool = fn_state.gs_411163;
        // N s_948_1: branch s_948_0 b950 b949
        if s_948_0 {
            return block_950(state, tracer, fn_state);
        } else {
            return block_949(state, tracer, fn_state);
        };
    }
    fn block_949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_949_0: read-var u#33832:u8
        let s_949_0: u8 = fn_state.u_33832;
        // D s_949_1: read-var u#33833:u8
        let s_949_1: u8 = fn_state.u_33833;
        // D s_949_2: read-var u#33834:u8
        let s_949_2: u8 = fn_state.u_33834;
        // D s_949_3: read-var u#33835:u8
        let s_949_3: u8 = fn_state.u_33835;
        // D s_949_4: call decode_aarch32_instrs_USUB16_A1enc_A_txt(s_949_0, s_949_1, s_949_2, s_949_3)
        let s_949_4: () = decode_aarch32_instrs_USUB16_A1enc_A_txt(
            state,
            tracer,
            s_949_0,
            s_949_1,
            s_949_2,
            s_949_3,
        );
        // N s_949_5: return
        return;
    }
    fn block_950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_950_0: panic
        panic!("{:?}", ());
        // N s_950_1: return
        return;
    }
    fn block_951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_951_0: const #1u : u8
        let s_951_0: bool = true;
        // D s_951_1: write-var gs#411163 <= s_951_0
        fn_state.gs_411163 = s_951_0;
        // N s_951_2: jump b948
        return block_948(state, tracer, fn_state);
    }
    fn block_952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_952_0: const #1u : u8
        let s_952_0: bool = true;
        // D s_952_1: write-var gs#411160 <= s_952_0
        fn_state.gs_411160 = s_952_0;
        // N s_952_2: jump b946
        return block_946(state, tracer, fn_state);
    }
    fn block_953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_953_0: const #1u : u8
        let s_953_0: bool = true;
        // D s_953_1: write-var gs#411157 <= s_953_0
        fn_state.gs_411157 = s_953_0;
        // N s_953_2: jump b944
        return block_944(state, tracer, fn_state);
    }
    fn block_954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_954_0: read-var merge#var.1:struct
        let s_954_0: u32 = fn_state.merge_var._1;
        // D s_954_1: write-var u#33837 <= s_954_0
        fn_state.u_33837 = s_954_0;
        // C s_954_2: const #20s : i
        let s_954_2: i128 = 20;
        // D s_954_3: read-var u#33837:u32
        let s_954_3: u32 = fn_state.u_33837;
        // D s_954_4: cast zx s_954_3 -> bv
        let s_954_4: Bits = Bits::new(s_954_3 as u128, 32u16);
        // C s_954_5: const #1s : i64
        let s_954_5: i64 = 1;
        // C s_954_6: cast zx s_954_5 -> i
        let s_954_6: i128 = (i128::try_from(s_954_5).unwrap());
        // C s_954_7: const #7s : i
        let s_954_7: i128 = 7;
        // C s_954_8: add s_954_7 s_954_6
        let s_954_8: i128 = (s_954_7 + s_954_6);
        // D s_954_9: bit-extract s_954_4 s_954_2 s_954_8
        let s_954_9: Bits = (Bits::new(
            ((s_954_4) >> (s_954_2)).value(),
            u16::try_from(s_954_8).unwrap(),
        ));
        // D s_954_10: cast reint s_954_9 -> u8
        let s_954_10: u8 = (s_954_9.value() as u8);
        // D s_954_11: cast zx s_954_10 -> bv
        let s_954_11: Bits = Bits::new(s_954_10 as u128, 8u16);
        // C s_954_12: const #101u : u8
        let s_954_12: u8 = 101;
        // C s_954_13: cast zx s_954_12 -> bv
        let s_954_13: Bits = Bits::new(s_954_12 as u128, 8u16);
        // D s_954_14: cmp-eq s_954_11 s_954_13
        let s_954_14: bool = ((s_954_11) == (s_954_13));
        // N s_954_15: branch s_954_14 b1072 b955
        if s_954_14 {
            return block_1072(state, tracer, fn_state);
        } else {
            return block_955(state, tracer, fn_state);
        };
    }
    fn block_955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_955_0: const #0u : u8
        let s_955_0: bool = false;
        // D s_955_1: write-var gs#411169 <= s_955_0
        fn_state.gs_411169 = s_955_0;
        // N s_955_2: jump b956
        return block_956(state, tracer, fn_state);
    }
    fn block_956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_956_0: read-var gs#411169:u8
        let s_956_0: bool = fn_state.gs_411169;
        // N s_956_1: branch s_956_0 b1068 b957
        if s_956_0 {
            return block_1068(state, tracer, fn_state);
        } else {
            return block_957(state, tracer, fn_state);
        };
    }
    fn block_957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_957_0: const #0u : u8
        let s_957_0: bool = false;
        // D s_957_1: write-var gs#411174 <= s_957_0
        fn_state.gs_411174 = s_957_0;
        // N s_957_2: jump b958
        return block_958(state, tracer, fn_state);
    }
    fn block_958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_958_0: read-var gs#411174:u8
        let s_958_0: bool = fn_state.gs_411174;
        // D s_958_1: not s_958_0
        let s_958_1: bool = !s_958_0;
        // N s_958_2: branch s_958_1 b971 b959
        if s_958_1 {
            return block_971(state, tracer, fn_state);
        } else {
            return block_959(state, tracer, fn_state);
        };
    }
    fn block_959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_959_0: const #3334s : i
        let s_959_0: i128 = 3334;
        // C s_959_1: const #14696u : u32
        let s_959_1: u32 = 14696;
        // N s_959_2: write-reg s_959_1 <= s_959_0
        let s_959_2: () = {
            state.write_register::<i128>(s_959_1 as isize, s_959_0);
            tracer.write_register(s_959_1 as isize, s_959_0);
        };
        // C s_959_3: const #28s : i
        let s_959_3: i128 = 28;
        // C s_959_4: const #4s : i
        let s_959_4: i128 = 4;
        // D s_959_5: read-var u#33837:u32
        let s_959_5: u32 = fn_state.u_33837;
        // D s_959_6: cast zx s_959_5 -> bv
        let s_959_6: Bits = Bits::new(s_959_5 as u128, 32u16);
        // D s_959_7: bit-extract s_959_6 s_959_3 s_959_4
        let s_959_7: Bits = (Bits::new(
            ((s_959_6) >> (s_959_3)).value(),
            u16::try_from(s_959_4).unwrap(),
        ));
        // D s_959_8: cast reint s_959_7 -> u8
        let s_959_8: u8 = (s_959_7.value() as u8);
        // D s_959_9: write-var u#33838 <= s_959_8
        fn_state.u_33838 = s_959_8;
        // C s_959_10: const #16s : i
        let s_959_10: i128 = 16;
        // C s_959_11: const #4s : i
        let s_959_11: i128 = 4;
        // D s_959_12: read-var u#33837:u32
        let s_959_12: u32 = fn_state.u_33837;
        // D s_959_13: cast zx s_959_12 -> bv
        let s_959_13: Bits = Bits::new(s_959_12 as u128, 32u16);
        // D s_959_14: bit-extract s_959_13 s_959_10 s_959_11
        let s_959_14: Bits = (Bits::new(
            ((s_959_13) >> (s_959_10)).value(),
            u16::try_from(s_959_11).unwrap(),
        ));
        // D s_959_15: cast reint s_959_14 -> u8
        let s_959_15: u8 = (s_959_14.value() as u8);
        // D s_959_16: write-var u#33839 <= s_959_15
        fn_state.u_33839 = s_959_15;
        // C s_959_17: const #12s : i
        let s_959_17: i128 = 12;
        // C s_959_18: const #4s : i
        let s_959_18: i128 = 4;
        // D s_959_19: read-var u#33837:u32
        let s_959_19: u32 = fn_state.u_33837;
        // D s_959_20: cast zx s_959_19 -> bv
        let s_959_20: Bits = Bits::new(s_959_19 as u128, 32u16);
        // D s_959_21: bit-extract s_959_20 s_959_17 s_959_18
        let s_959_21: Bits = (Bits::new(
            ((s_959_20) >> (s_959_17)).value(),
            u16::try_from(s_959_18).unwrap(),
        ));
        // D s_959_22: cast reint s_959_21 -> u8
        let s_959_22: u8 = (s_959_21.value() as u8);
        // D s_959_23: write-var u#33840 <= s_959_22
        fn_state.u_33840 = s_959_22;
        // C s_959_24: const #0s : i
        let s_959_24: i128 = 0;
        // C s_959_25: const #4s : i
        let s_959_25: i128 = 4;
        // D s_959_26: read-var u#33837:u32
        let s_959_26: u32 = fn_state.u_33837;
        // D s_959_27: cast zx s_959_26 -> bv
        let s_959_27: Bits = Bits::new(s_959_26 as u128, 32u16);
        // D s_959_28: bit-extract s_959_27 s_959_24 s_959_25
        let s_959_28: Bits = (Bits::new(
            ((s_959_27) >> (s_959_24)).value(),
            u16::try_from(s_959_25).unwrap(),
        ));
        // D s_959_29: cast reint s_959_28 -> u8
        let s_959_29: u8 = (s_959_28.value() as u8);
        // D s_959_30: write-var u#33841 <= s_959_29
        fn_state.u_33841 = s_959_29;
        // C s_959_31: const #8s : i
        let s_959_31: i128 = 8;
        // D s_959_32: read-var u#33837:u32
        let s_959_32: u32 = fn_state.u_33837;
        // D s_959_33: cast zx s_959_32 -> bv
        let s_959_33: Bits = Bits::new(s_959_32 as u128, 32u16);
        // C s_959_34: const #1u : u64
        let s_959_34: u64 = 1;
        // D s_959_35: bit-extract s_959_33 s_959_31 s_959_34
        let s_959_35: Bits = (Bits::new(
            ((s_959_33) >> (s_959_31)).value(),
            u16::try_from(s_959_34).unwrap(),
        ));
        // D s_959_36: cast reint s_959_35 -> u8
        let s_959_36: bool = ((s_959_35.value()) != 0);
        // C s_959_37: const #0s : i
        let s_959_37: i128 = 0;
        // C s_959_38: const #0u : u64
        let s_959_38: u64 = 0;
        // D s_959_39: cast zx s_959_36 -> u64
        let s_959_39: u64 = (s_959_36 as u64);
        // C s_959_40: const #1u : u64
        let s_959_40: u64 = 1;
        // D s_959_41: and s_959_39 s_959_40
        let s_959_41: u64 = ((s_959_39) & (s_959_40));
        // D s_959_42: cmp-eq s_959_41 s_959_40
        let s_959_42: bool = ((s_959_41) == (s_959_40));
        // D s_959_43: lsl s_959_39 s_959_37
        let s_959_43: u64 = s_959_39 << s_959_37;
        // D s_959_44: or s_959_38 s_959_43
        let s_959_44: u64 = ((s_959_38) | (s_959_43));
        // D s_959_45: cmpl s_959_43
        let s_959_45: u64 = !s_959_43;
        // D s_959_46: and s_959_38 s_959_45
        let s_959_46: u64 = ((s_959_38) & (s_959_45));
        // D s_959_47: select s_959_42 s_959_44 s_959_46
        let s_959_47: u64 = if s_959_42 { s_959_44 } else { s_959_46 };
        // D s_959_48: cast trunc s_959_47 -> u8
        let s_959_48: bool = ((s_959_47) != 0);
        // D s_959_49: cast zx s_959_48 -> bv
        let s_959_49: Bits = Bits::new(s_959_48 as u128, 1u16);
        // C s_959_50: const #1u : u8
        let s_959_50: bool = true;
        // C s_959_51: cast zx s_959_50 -> bv
        let s_959_51: Bits = Bits::new(s_959_50 as u128, 1u16);
        // D s_959_52: cmp-ne s_959_49 s_959_51
        let s_959_52: bool = ((s_959_49) != (s_959_51));
        // N s_959_53: branch s_959_52 b970 b960
        if s_959_52 {
            return block_970(state, tracer, fn_state);
        } else {
            return block_960(state, tracer, fn_state);
        };
    }
    fn block_960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_960_0: const #9s : i
        let s_960_0: i128 = 9;
        // D s_960_1: read-var u#33837:u32
        let s_960_1: u32 = fn_state.u_33837;
        // D s_960_2: cast zx s_960_1 -> bv
        let s_960_2: Bits = Bits::new(s_960_1 as u128, 32u16);
        // C s_960_3: const #1u : u64
        let s_960_3: u64 = 1;
        // D s_960_4: bit-extract s_960_2 s_960_0 s_960_3
        let s_960_4: Bits = (Bits::new(
            ((s_960_2) >> (s_960_0)).value(),
            u16::try_from(s_960_3).unwrap(),
        ));
        // D s_960_5: cast reint s_960_4 -> u8
        let s_960_5: bool = ((s_960_4.value()) != 0);
        // C s_960_6: const #0s : i
        let s_960_6: i128 = 0;
        // C s_960_7: const #0u : u64
        let s_960_7: u64 = 0;
        // D s_960_8: cast zx s_960_5 -> u64
        let s_960_8: u64 = (s_960_5 as u64);
        // C s_960_9: const #1u : u64
        let s_960_9: u64 = 1;
        // D s_960_10: and s_960_8 s_960_9
        let s_960_10: u64 = ((s_960_8) & (s_960_9));
        // D s_960_11: cmp-eq s_960_10 s_960_9
        let s_960_11: bool = ((s_960_10) == (s_960_9));
        // D s_960_12: lsl s_960_8 s_960_6
        let s_960_12: u64 = s_960_8 << s_960_6;
        // D s_960_13: or s_960_7 s_960_12
        let s_960_13: u64 = ((s_960_7) | (s_960_12));
        // D s_960_14: cmpl s_960_12
        let s_960_14: u64 = !s_960_12;
        // D s_960_15: and s_960_7 s_960_14
        let s_960_15: u64 = ((s_960_7) & (s_960_14));
        // D s_960_16: select s_960_11 s_960_13 s_960_15
        let s_960_16: u64 = if s_960_11 { s_960_13 } else { s_960_15 };
        // D s_960_17: cast trunc s_960_16 -> u8
        let s_960_17: bool = ((s_960_16) != 0);
        // D s_960_18: cast zx s_960_17 -> bv
        let s_960_18: Bits = Bits::new(s_960_17 as u128, 1u16);
        // C s_960_19: const #1u : u8
        let s_960_19: bool = true;
        // C s_960_20: cast zx s_960_19 -> bv
        let s_960_20: Bits = Bits::new(s_960_19 as u128, 1u16);
        // D s_960_21: cmp-ne s_960_18 s_960_20
        let s_960_21: bool = ((s_960_18) != (s_960_20));
        // D s_960_22: write-var gs#411189 <= s_960_21
        fn_state.gs_411189 = s_960_21;
        // N s_960_23: jump b961
        return block_961(state, tracer, fn_state);
    }
    fn block_961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_961_0: read-var gs#411189:u8
        let s_961_0: bool = fn_state.gs_411189;
        // N s_961_1: branch s_961_0 b969 b962
        if s_961_0 {
            return block_969(state, tracer, fn_state);
        } else {
            return block_962(state, tracer, fn_state);
        };
    }
    fn block_962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_962_0: const #10s : i
        let s_962_0: i128 = 10;
        // D s_962_1: read-var u#33837:u32
        let s_962_1: u32 = fn_state.u_33837;
        // D s_962_2: cast zx s_962_1 -> bv
        let s_962_2: Bits = Bits::new(s_962_1 as u128, 32u16);
        // C s_962_3: const #1u : u64
        let s_962_3: u64 = 1;
        // D s_962_4: bit-extract s_962_2 s_962_0 s_962_3
        let s_962_4: Bits = (Bits::new(
            ((s_962_2) >> (s_962_0)).value(),
            u16::try_from(s_962_3).unwrap(),
        ));
        // D s_962_5: cast reint s_962_4 -> u8
        let s_962_5: bool = ((s_962_4.value()) != 0);
        // C s_962_6: const #0s : i
        let s_962_6: i128 = 0;
        // C s_962_7: const #0u : u64
        let s_962_7: u64 = 0;
        // D s_962_8: cast zx s_962_5 -> u64
        let s_962_8: u64 = (s_962_5 as u64);
        // C s_962_9: const #1u : u64
        let s_962_9: u64 = 1;
        // D s_962_10: and s_962_8 s_962_9
        let s_962_10: u64 = ((s_962_8) & (s_962_9));
        // D s_962_11: cmp-eq s_962_10 s_962_9
        let s_962_11: bool = ((s_962_10) == (s_962_9));
        // D s_962_12: lsl s_962_8 s_962_6
        let s_962_12: u64 = s_962_8 << s_962_6;
        // D s_962_13: or s_962_7 s_962_12
        let s_962_13: u64 = ((s_962_7) | (s_962_12));
        // D s_962_14: cmpl s_962_12
        let s_962_14: u64 = !s_962_12;
        // D s_962_15: and s_962_7 s_962_14
        let s_962_15: u64 = ((s_962_7) & (s_962_14));
        // D s_962_16: select s_962_11 s_962_13 s_962_15
        let s_962_16: u64 = if s_962_11 { s_962_13 } else { s_962_15 };
        // D s_962_17: cast trunc s_962_16 -> u8
        let s_962_17: bool = ((s_962_16) != 0);
        // D s_962_18: cast zx s_962_17 -> bv
        let s_962_18: Bits = Bits::new(s_962_17 as u128, 1u16);
        // C s_962_19: const #1u : u8
        let s_962_19: bool = true;
        // C s_962_20: cast zx s_962_19 -> bv
        let s_962_20: Bits = Bits::new(s_962_19 as u128, 1u16);
        // D s_962_21: cmp-ne s_962_18 s_962_20
        let s_962_21: bool = ((s_962_18) != (s_962_20));
        // D s_962_22: write-var gs#411192 <= s_962_21
        fn_state.gs_411192 = s_962_21;
        // N s_962_23: jump b963
        return block_963(state, tracer, fn_state);
    }
    fn block_963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_963_0: read-var gs#411192:u8
        let s_963_0: bool = fn_state.gs_411192;
        // N s_963_1: branch s_963_0 b968 b964
        if s_963_0 {
            return block_968(state, tracer, fn_state);
        } else {
            return block_964(state, tracer, fn_state);
        };
    }
    fn block_964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_964_0: const #11s : i
        let s_964_0: i128 = 11;
        // D s_964_1: read-var u#33837:u32
        let s_964_1: u32 = fn_state.u_33837;
        // D s_964_2: cast zx s_964_1 -> bv
        let s_964_2: Bits = Bits::new(s_964_1 as u128, 32u16);
        // C s_964_3: const #1u : u64
        let s_964_3: u64 = 1;
        // D s_964_4: bit-extract s_964_2 s_964_0 s_964_3
        let s_964_4: Bits = (Bits::new(
            ((s_964_2) >> (s_964_0)).value(),
            u16::try_from(s_964_3).unwrap(),
        ));
        // D s_964_5: cast reint s_964_4 -> u8
        let s_964_5: bool = ((s_964_4.value()) != 0);
        // C s_964_6: const #0s : i
        let s_964_6: i128 = 0;
        // C s_964_7: const #0u : u64
        let s_964_7: u64 = 0;
        // D s_964_8: cast zx s_964_5 -> u64
        let s_964_8: u64 = (s_964_5 as u64);
        // C s_964_9: const #1u : u64
        let s_964_9: u64 = 1;
        // D s_964_10: and s_964_8 s_964_9
        let s_964_10: u64 = ((s_964_8) & (s_964_9));
        // D s_964_11: cmp-eq s_964_10 s_964_9
        let s_964_11: bool = ((s_964_10) == (s_964_9));
        // D s_964_12: lsl s_964_8 s_964_6
        let s_964_12: u64 = s_964_8 << s_964_6;
        // D s_964_13: or s_964_7 s_964_12
        let s_964_13: u64 = ((s_964_7) | (s_964_12));
        // D s_964_14: cmpl s_964_12
        let s_964_14: u64 = !s_964_12;
        // D s_964_15: and s_964_7 s_964_14
        let s_964_15: u64 = ((s_964_7) & (s_964_14));
        // D s_964_16: select s_964_11 s_964_13 s_964_15
        let s_964_16: u64 = if s_964_11 { s_964_13 } else { s_964_15 };
        // D s_964_17: cast trunc s_964_16 -> u8
        let s_964_17: bool = ((s_964_16) != 0);
        // D s_964_18: cast zx s_964_17 -> bv
        let s_964_18: Bits = Bits::new(s_964_17 as u128, 1u16);
        // C s_964_19: const #1u : u8
        let s_964_19: bool = true;
        // C s_964_20: cast zx s_964_19 -> bv
        let s_964_20: Bits = Bits::new(s_964_19 as u128, 1u16);
        // D s_964_21: cmp-ne s_964_18 s_964_20
        let s_964_21: bool = ((s_964_18) != (s_964_20));
        // D s_964_22: write-var gs#411195 <= s_964_21
        fn_state.gs_411195 = s_964_21;
        // N s_964_23: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_965_0: read-var gs#411195:u8
        let s_965_0: bool = fn_state.gs_411195;
        // N s_965_1: branch s_965_0 b967 b966
        if s_965_0 {
            return block_967(state, tracer, fn_state);
        } else {
            return block_966(state, tracer, fn_state);
        };
    }
    fn block_966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_966_0: read-var u#33838:u8
        let s_966_0: u8 = fn_state.u_33838;
        // D s_966_1: read-var u#33839:u8
        let s_966_1: u8 = fn_state.u_33839;
        // D s_966_2: read-var u#33840:u8
        let s_966_2: u8 = fn_state.u_33840;
        // D s_966_3: read-var u#33841:u8
        let s_966_3: u8 = fn_state.u_33841;
        // D s_966_4: call decode_aarch32_instrs_USUB8_A1enc_A_txt(s_966_0, s_966_1, s_966_2, s_966_3)
        let s_966_4: () = decode_aarch32_instrs_USUB8_A1enc_A_txt(
            state,
            tracer,
            s_966_0,
            s_966_1,
            s_966_2,
            s_966_3,
        );
        // N s_966_5: return
        return;
    }
    fn block_967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_967_0: panic
        panic!("{:?}", ());
        // N s_967_1: return
        return;
    }
    fn block_968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_968_0: const #1u : u8
        let s_968_0: bool = true;
        // D s_968_1: write-var gs#411195 <= s_968_0
        fn_state.gs_411195 = s_968_0;
        // N s_968_2: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_969_0: const #1u : u8
        let s_969_0: bool = true;
        // D s_969_1: write-var gs#411192 <= s_969_0
        fn_state.gs_411192 = s_969_0;
        // N s_969_2: jump b963
        return block_963(state, tracer, fn_state);
    }
    fn block_970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_970_0: const #1u : u8
        let s_970_0: bool = true;
        // D s_970_1: write-var gs#411189 <= s_970_0
        fn_state.gs_411189 = s_970_0;
        // N s_970_2: jump b961
        return block_961(state, tracer, fn_state);
    }
    fn block_971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_971_0: read-var merge#var.1:struct
        let s_971_0: u32 = fn_state.merge_var._1;
        // D s_971_1: write-var u#33843 <= s_971_0
        fn_state.u_33843 = s_971_0;
        // C s_971_2: const #20s : i
        let s_971_2: i128 = 20;
        // D s_971_3: read-var u#33843:u32
        let s_971_3: u32 = fn_state.u_33843;
        // D s_971_4: cast zx s_971_3 -> bv
        let s_971_4: Bits = Bits::new(s_971_3 as u128, 32u16);
        // C s_971_5: const #1s : i64
        let s_971_5: i64 = 1;
        // C s_971_6: cast zx s_971_5 -> i
        let s_971_6: i128 = (i128::try_from(s_971_5).unwrap());
        // C s_971_7: const #7s : i
        let s_971_7: i128 = 7;
        // C s_971_8: add s_971_7 s_971_6
        let s_971_8: i128 = (s_971_7 + s_971_6);
        // D s_971_9: bit-extract s_971_4 s_971_2 s_971_8
        let s_971_9: Bits = (Bits::new(
            ((s_971_4) >> (s_971_2)).value(),
            u16::try_from(s_971_8).unwrap(),
        ));
        // D s_971_10: cast reint s_971_9 -> u8
        let s_971_10: u8 = (s_971_9.value() as u8);
        // D s_971_11: cast zx s_971_10 -> bv
        let s_971_11: Bits = Bits::new(s_971_10 as u128, 8u16);
        // C s_971_12: const #108u : u8
        let s_971_12: u8 = 108;
        // C s_971_13: cast zx s_971_12 -> bv
        let s_971_13: Bits = Bits::new(s_971_12 as u128, 8u16);
        // D s_971_14: cmp-eq s_971_11 s_971_13
        let s_971_14: bool = ((s_971_11) == (s_971_13));
        // N s_971_15: branch s_971_14 b1067 b972
        if s_971_14 {
            return block_1067(state, tracer, fn_state);
        } else {
            return block_972(state, tracer, fn_state);
        };
    }
    fn block_972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_972_0: const #0u : u8
        let s_972_0: bool = false;
        // D s_972_1: write-var gs#411201 <= s_972_0
        fn_state.gs_411201 = s_972_0;
        // N s_972_2: jump b973
        return block_973(state, tracer, fn_state);
    }
    fn block_973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_973_0: read-var gs#411201:u8
        let s_973_0: bool = fn_state.gs_411201;
        // N s_973_1: branch s_973_0 b1063 b974
        if s_973_0 {
            return block_1063(state, tracer, fn_state);
        } else {
            return block_974(state, tracer, fn_state);
        };
    }
    fn block_974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_974_0: const #0u : u8
        let s_974_0: bool = false;
        // D s_974_1: write-var gs#411206 <= s_974_0
        fn_state.gs_411206 = s_974_0;
        // N s_974_2: jump b975
        return block_975(state, tracer, fn_state);
    }
    fn block_975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_975_0: read-var gs#411206:u8
        let s_975_0: bool = fn_state.gs_411206;
        // D s_975_1: not s_975_0
        let s_975_1: bool = !s_975_0;
        // N s_975_2: branch s_975_1 b982 b976
        if s_975_1 {
            return block_982(state, tracer, fn_state);
        } else {
            return block_976(state, tracer, fn_state);
        };
    }
    fn block_976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_976_0: const #3336s : i
        let s_976_0: i128 = 3336;
        // C s_976_1: const #14696u : u32
        let s_976_1: u32 = 14696;
        // N s_976_2: write-reg s_976_1 <= s_976_0
        let s_976_2: () = {
            state.write_register::<i128>(s_976_1 as isize, s_976_0);
            tracer.write_register(s_976_1 as isize, s_976_0);
        };
        // C s_976_3: const #28s : i
        let s_976_3: i128 = 28;
        // C s_976_4: const #4s : i
        let s_976_4: i128 = 4;
        // D s_976_5: read-var u#33843:u32
        let s_976_5: u32 = fn_state.u_33843;
        // D s_976_6: cast zx s_976_5 -> bv
        let s_976_6: Bits = Bits::new(s_976_5 as u128, 32u16);
        // D s_976_7: bit-extract s_976_6 s_976_3 s_976_4
        let s_976_7: Bits = (Bits::new(
            ((s_976_6) >> (s_976_3)).value(),
            u16::try_from(s_976_4).unwrap(),
        ));
        // D s_976_8: cast reint s_976_7 -> u8
        let s_976_8: u8 = (s_976_7.value() as u8);
        // D s_976_9: write-var u#33844 <= s_976_8
        fn_state.u_33844 = s_976_8;
        // C s_976_10: const #16s : i
        let s_976_10: i128 = 16;
        // C s_976_11: const #4s : i
        let s_976_11: i128 = 4;
        // D s_976_12: read-var u#33843:u32
        let s_976_12: u32 = fn_state.u_33843;
        // D s_976_13: cast zx s_976_12 -> bv
        let s_976_13: Bits = Bits::new(s_976_12 as u128, 32u16);
        // D s_976_14: bit-extract s_976_13 s_976_10 s_976_11
        let s_976_14: Bits = (Bits::new(
            ((s_976_13) >> (s_976_10)).value(),
            u16::try_from(s_976_11).unwrap(),
        ));
        // D s_976_15: cast reint s_976_14 -> u8
        let s_976_15: u8 = (s_976_14.value() as u8);
        // D s_976_16: write-var u#33845 <= s_976_15
        fn_state.u_33845 = s_976_15;
        // C s_976_17: const #12s : i
        let s_976_17: i128 = 12;
        // C s_976_18: const #4s : i
        let s_976_18: i128 = 4;
        // D s_976_19: read-var u#33843:u32
        let s_976_19: u32 = fn_state.u_33843;
        // D s_976_20: cast zx s_976_19 -> bv
        let s_976_20: Bits = Bits::new(s_976_19 as u128, 32u16);
        // D s_976_21: bit-extract s_976_20 s_976_17 s_976_18
        let s_976_21: Bits = (Bits::new(
            ((s_976_20) >> (s_976_17)).value(),
            u16::try_from(s_976_18).unwrap(),
        ));
        // D s_976_22: cast reint s_976_21 -> u8
        let s_976_22: u8 = (s_976_21.value() as u8);
        // D s_976_23: write-var u#33846 <= s_976_22
        fn_state.u_33846 = s_976_22;
        // C s_976_24: const #10s : i
        let s_976_24: i128 = 10;
        // C s_976_25: const #2s : i
        let s_976_25: i128 = 2;
        // D s_976_26: read-var u#33843:u32
        let s_976_26: u32 = fn_state.u_33843;
        // D s_976_27: cast zx s_976_26 -> bv
        let s_976_27: Bits = Bits::new(s_976_26 as u128, 32u16);
        // D s_976_28: bit-extract s_976_27 s_976_24 s_976_25
        let s_976_28: Bits = (Bits::new(
            ((s_976_27) >> (s_976_24)).value(),
            u16::try_from(s_976_25).unwrap(),
        ));
        // D s_976_29: cast reint s_976_28 -> u8
        let s_976_29: u8 = (s_976_28.value() as u8);
        // D s_976_30: write-var u#33847 <= s_976_29
        fn_state.u_33847 = s_976_29;
        // C s_976_31: const #0s : i
        let s_976_31: i128 = 0;
        // C s_976_32: const #4s : i
        let s_976_32: i128 = 4;
        // D s_976_33: read-var u#33843:u32
        let s_976_33: u32 = fn_state.u_33843;
        // D s_976_34: cast zx s_976_33 -> bv
        let s_976_34: Bits = Bits::new(s_976_33 as u128, 32u16);
        // D s_976_35: bit-extract s_976_34 s_976_31 s_976_32
        let s_976_35: Bits = (Bits::new(
            ((s_976_34) >> (s_976_31)).value(),
            u16::try_from(s_976_32).unwrap(),
        ));
        // D s_976_36: cast reint s_976_35 -> u8
        let s_976_36: u8 = (s_976_35.value() as u8);
        // D s_976_37: write-var u#33848 <= s_976_36
        fn_state.u_33848 = s_976_36;
        // C s_976_38: const #8s : i
        let s_976_38: i128 = 8;
        // D s_976_39: read-var u#33843:u32
        let s_976_39: u32 = fn_state.u_33843;
        // D s_976_40: cast zx s_976_39 -> bv
        let s_976_40: Bits = Bits::new(s_976_39 as u128, 32u16);
        // C s_976_41: const #1u : u64
        let s_976_41: u64 = 1;
        // D s_976_42: bit-extract s_976_40 s_976_38 s_976_41
        let s_976_42: Bits = (Bits::new(
            ((s_976_40) >> (s_976_38)).value(),
            u16::try_from(s_976_41).unwrap(),
        ));
        // D s_976_43: cast reint s_976_42 -> u8
        let s_976_43: bool = ((s_976_42.value()) != 0);
        // C s_976_44: const #0s : i
        let s_976_44: i128 = 0;
        // C s_976_45: const #0u : u64
        let s_976_45: u64 = 0;
        // D s_976_46: cast zx s_976_43 -> u64
        let s_976_46: u64 = (s_976_43 as u64);
        // C s_976_47: const #1u : u64
        let s_976_47: u64 = 1;
        // D s_976_48: and s_976_46 s_976_47
        let s_976_48: u64 = ((s_976_46) & (s_976_47));
        // D s_976_49: cmp-eq s_976_48 s_976_47
        let s_976_49: bool = ((s_976_48) == (s_976_47));
        // D s_976_50: lsl s_976_46 s_976_44
        let s_976_50: u64 = s_976_46 << s_976_44;
        // D s_976_51: or s_976_45 s_976_50
        let s_976_51: u64 = ((s_976_45) | (s_976_50));
        // D s_976_52: cmpl s_976_50
        let s_976_52: u64 = !s_976_50;
        // D s_976_53: and s_976_45 s_976_52
        let s_976_53: u64 = ((s_976_45) & (s_976_52));
        // D s_976_54: select s_976_49 s_976_51 s_976_53
        let s_976_54: u64 = if s_976_49 { s_976_51 } else { s_976_53 };
        // D s_976_55: cast trunc s_976_54 -> u8
        let s_976_55: bool = ((s_976_54) != 0);
        // D s_976_56: cast zx s_976_55 -> bv
        let s_976_56: Bits = Bits::new(s_976_55 as u128, 1u16);
        // C s_976_57: const #0u : u8
        let s_976_57: bool = false;
        // C s_976_58: cast zx s_976_57 -> bv
        let s_976_58: Bits = Bits::new(s_976_57 as u128, 1u16);
        // D s_976_59: cmp-ne s_976_56 s_976_58
        let s_976_59: bool = ((s_976_56) != (s_976_58));
        // N s_976_60: branch s_976_59 b981 b977
        if s_976_59 {
            return block_981(state, tracer, fn_state);
        } else {
            return block_977(state, tracer, fn_state);
        };
    }
    fn block_977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_977_0: const #9s : i
        let s_977_0: i128 = 9;
        // D s_977_1: read-var u#33843:u32
        let s_977_1: u32 = fn_state.u_33843;
        // D s_977_2: cast zx s_977_1 -> bv
        let s_977_2: Bits = Bits::new(s_977_1 as u128, 32u16);
        // C s_977_3: const #1u : u64
        let s_977_3: u64 = 1;
        // D s_977_4: bit-extract s_977_2 s_977_0 s_977_3
        let s_977_4: Bits = (Bits::new(
            ((s_977_2) >> (s_977_0)).value(),
            u16::try_from(s_977_3).unwrap(),
        ));
        // D s_977_5: cast reint s_977_4 -> u8
        let s_977_5: bool = ((s_977_4.value()) != 0);
        // C s_977_6: const #0s : i
        let s_977_6: i128 = 0;
        // C s_977_7: const #0u : u64
        let s_977_7: u64 = 0;
        // D s_977_8: cast zx s_977_5 -> u64
        let s_977_8: u64 = (s_977_5 as u64);
        // C s_977_9: const #1u : u64
        let s_977_9: u64 = 1;
        // D s_977_10: and s_977_8 s_977_9
        let s_977_10: u64 = ((s_977_8) & (s_977_9));
        // D s_977_11: cmp-eq s_977_10 s_977_9
        let s_977_11: bool = ((s_977_10) == (s_977_9));
        // D s_977_12: lsl s_977_8 s_977_6
        let s_977_12: u64 = s_977_8 << s_977_6;
        // D s_977_13: or s_977_7 s_977_12
        let s_977_13: u64 = ((s_977_7) | (s_977_12));
        // D s_977_14: cmpl s_977_12
        let s_977_14: u64 = !s_977_12;
        // D s_977_15: and s_977_7 s_977_14
        let s_977_15: u64 = ((s_977_7) & (s_977_14));
        // D s_977_16: select s_977_11 s_977_13 s_977_15
        let s_977_16: u64 = if s_977_11 { s_977_13 } else { s_977_15 };
        // D s_977_17: cast trunc s_977_16 -> u8
        let s_977_17: bool = ((s_977_16) != 0);
        // D s_977_18: cast zx s_977_17 -> bv
        let s_977_18: Bits = Bits::new(s_977_17 as u128, 1u16);
        // C s_977_19: const #0u : u8
        let s_977_19: bool = false;
        // C s_977_20: cast zx s_977_19 -> bv
        let s_977_20: Bits = Bits::new(s_977_19 as u128, 1u16);
        // D s_977_21: cmp-ne s_977_18 s_977_20
        let s_977_21: bool = ((s_977_18) != (s_977_20));
        // D s_977_22: write-var gs#411223 <= s_977_21
        fn_state.gs_411223 = s_977_21;
        // N s_977_23: jump b978
        return block_978(state, tracer, fn_state);
    }
    fn block_978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_978_0: read-var gs#411223:u8
        let s_978_0: bool = fn_state.gs_411223;
        // N s_978_1: branch s_978_0 b980 b979
        if s_978_0 {
            return block_980(state, tracer, fn_state);
        } else {
            return block_979(state, tracer, fn_state);
        };
    }
    fn block_979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_979_0: read-var u#33844:u8
        let s_979_0: u8 = fn_state.u_33844;
        // D s_979_1: read-var u#33845:u8
        let s_979_1: u8 = fn_state.u_33845;
        // D s_979_2: read-var u#33846:u8
        let s_979_2: u8 = fn_state.u_33846;
        // D s_979_3: read-var u#33847:u8
        let s_979_3: u8 = fn_state.u_33847;
        // D s_979_4: read-var u#33848:u8
        let s_979_4: u8 = fn_state.u_33848;
        // D s_979_5: call decode_aarch32_instrs_UXTAB16_A1enc_A_txt(s_979_0, s_979_1, s_979_2, s_979_3, s_979_4)
        let s_979_5: () = decode_aarch32_instrs_UXTAB16_A1enc_A_txt(
            state,
            tracer,
            s_979_0,
            s_979_1,
            s_979_2,
            s_979_3,
            s_979_4,
        );
        // N s_979_6: return
        return;
    }
    fn block_980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_980_0: panic
        panic!("{:?}", ());
        // N s_980_1: return
        return;
    }
    fn block_981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_981_0: const #1u : u8
        let s_981_0: bool = true;
        // D s_981_1: write-var gs#411223 <= s_981_0
        fn_state.gs_411223 = s_981_0;
        // N s_981_2: jump b978
        return block_978(state, tracer, fn_state);
    }
    fn block_982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_982_0: read-var merge#var.1:struct
        let s_982_0: u32 = fn_state.merge_var._1;
        // D s_982_1: write-var u#33850 <= s_982_0
        fn_state.u_33850 = s_982_0;
        // C s_982_2: const #20s : i
        let s_982_2: i128 = 20;
        // D s_982_3: read-var u#33850:u32
        let s_982_3: u32 = fn_state.u_33850;
        // D s_982_4: cast zx s_982_3 -> bv
        let s_982_4: Bits = Bits::new(s_982_3 as u128, 32u16);
        // C s_982_5: const #1s : i64
        let s_982_5: i64 = 1;
        // C s_982_6: cast zx s_982_5 -> i
        let s_982_6: i128 = (i128::try_from(s_982_5).unwrap());
        // C s_982_7: const #7s : i
        let s_982_7: i128 = 7;
        // C s_982_8: add s_982_7 s_982_6
        let s_982_8: i128 = (s_982_7 + s_982_6);
        // D s_982_9: bit-extract s_982_4 s_982_2 s_982_8
        let s_982_9: Bits = (Bits::new(
            ((s_982_4) >> (s_982_2)).value(),
            u16::try_from(s_982_8).unwrap(),
        ));
        // D s_982_10: cast reint s_982_9 -> u8
        let s_982_10: u8 = (s_982_9.value() as u8);
        // D s_982_11: cast zx s_982_10 -> bv
        let s_982_11: Bits = Bits::new(s_982_10 as u128, 8u16);
        // C s_982_12: const #110u : u8
        let s_982_12: u8 = 110;
        // C s_982_13: cast zx s_982_12 -> bv
        let s_982_13: Bits = Bits::new(s_982_12 as u128, 8u16);
        // D s_982_14: cmp-eq s_982_11 s_982_13
        let s_982_14: bool = ((s_982_11) == (s_982_13));
        // N s_982_15: branch s_982_14 b1062 b983
        if s_982_14 {
            return block_1062(state, tracer, fn_state);
        } else {
            return block_983(state, tracer, fn_state);
        };
    }
    fn block_983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_983_0: const #0u : u8
        let s_983_0: bool = false;
        // D s_983_1: write-var gs#411229 <= s_983_0
        fn_state.gs_411229 = s_983_0;
        // N s_983_2: jump b984
        return block_984(state, tracer, fn_state);
    }
    fn block_984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_984_0: read-var gs#411229:u8
        let s_984_0: bool = fn_state.gs_411229;
        // N s_984_1: branch s_984_0 b1058 b985
        if s_984_0 {
            return block_1058(state, tracer, fn_state);
        } else {
            return block_985(state, tracer, fn_state);
        };
    }
    fn block_985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_985_0: const #0u : u8
        let s_985_0: bool = false;
        // D s_985_1: write-var gs#411234 <= s_985_0
        fn_state.gs_411234 = s_985_0;
        // N s_985_2: jump b986
        return block_986(state, tracer, fn_state);
    }
    fn block_986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_986_0: read-var gs#411234:u8
        let s_986_0: bool = fn_state.gs_411234;
        // D s_986_1: not s_986_0
        let s_986_1: bool = !s_986_0;
        // N s_986_2: branch s_986_1 b993 b987
        if s_986_1 {
            return block_993(state, tracer, fn_state);
        } else {
            return block_987(state, tracer, fn_state);
        };
    }
    fn block_987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_987_0: const #3338s : i
        let s_987_0: i128 = 3338;
        // C s_987_1: const #14696u : u32
        let s_987_1: u32 = 14696;
        // N s_987_2: write-reg s_987_1 <= s_987_0
        let s_987_2: () = {
            state.write_register::<i128>(s_987_1 as isize, s_987_0);
            tracer.write_register(s_987_1 as isize, s_987_0);
        };
        // C s_987_3: const #28s : i
        let s_987_3: i128 = 28;
        // C s_987_4: const #4s : i
        let s_987_4: i128 = 4;
        // D s_987_5: read-var u#33850:u32
        let s_987_5: u32 = fn_state.u_33850;
        // D s_987_6: cast zx s_987_5 -> bv
        let s_987_6: Bits = Bits::new(s_987_5 as u128, 32u16);
        // D s_987_7: bit-extract s_987_6 s_987_3 s_987_4
        let s_987_7: Bits = (Bits::new(
            ((s_987_6) >> (s_987_3)).value(),
            u16::try_from(s_987_4).unwrap(),
        ));
        // D s_987_8: cast reint s_987_7 -> u8
        let s_987_8: u8 = (s_987_7.value() as u8);
        // D s_987_9: write-var u#33851 <= s_987_8
        fn_state.u_33851 = s_987_8;
        // C s_987_10: const #16s : i
        let s_987_10: i128 = 16;
        // C s_987_11: const #4s : i
        let s_987_11: i128 = 4;
        // D s_987_12: read-var u#33850:u32
        let s_987_12: u32 = fn_state.u_33850;
        // D s_987_13: cast zx s_987_12 -> bv
        let s_987_13: Bits = Bits::new(s_987_12 as u128, 32u16);
        // D s_987_14: bit-extract s_987_13 s_987_10 s_987_11
        let s_987_14: Bits = (Bits::new(
            ((s_987_13) >> (s_987_10)).value(),
            u16::try_from(s_987_11).unwrap(),
        ));
        // D s_987_15: cast reint s_987_14 -> u8
        let s_987_15: u8 = (s_987_14.value() as u8);
        // D s_987_16: write-var u#33852 <= s_987_15
        fn_state.u_33852 = s_987_15;
        // C s_987_17: const #12s : i
        let s_987_17: i128 = 12;
        // C s_987_18: const #4s : i
        let s_987_18: i128 = 4;
        // D s_987_19: read-var u#33850:u32
        let s_987_19: u32 = fn_state.u_33850;
        // D s_987_20: cast zx s_987_19 -> bv
        let s_987_20: Bits = Bits::new(s_987_19 as u128, 32u16);
        // D s_987_21: bit-extract s_987_20 s_987_17 s_987_18
        let s_987_21: Bits = (Bits::new(
            ((s_987_20) >> (s_987_17)).value(),
            u16::try_from(s_987_18).unwrap(),
        ));
        // D s_987_22: cast reint s_987_21 -> u8
        let s_987_22: u8 = (s_987_21.value() as u8);
        // D s_987_23: write-var u#33853 <= s_987_22
        fn_state.u_33853 = s_987_22;
        // C s_987_24: const #10s : i
        let s_987_24: i128 = 10;
        // C s_987_25: const #2s : i
        let s_987_25: i128 = 2;
        // D s_987_26: read-var u#33850:u32
        let s_987_26: u32 = fn_state.u_33850;
        // D s_987_27: cast zx s_987_26 -> bv
        let s_987_27: Bits = Bits::new(s_987_26 as u128, 32u16);
        // D s_987_28: bit-extract s_987_27 s_987_24 s_987_25
        let s_987_28: Bits = (Bits::new(
            ((s_987_27) >> (s_987_24)).value(),
            u16::try_from(s_987_25).unwrap(),
        ));
        // D s_987_29: cast reint s_987_28 -> u8
        let s_987_29: u8 = (s_987_28.value() as u8);
        // D s_987_30: write-var u#33854 <= s_987_29
        fn_state.u_33854 = s_987_29;
        // C s_987_31: const #0s : i
        let s_987_31: i128 = 0;
        // C s_987_32: const #4s : i
        let s_987_32: i128 = 4;
        // D s_987_33: read-var u#33850:u32
        let s_987_33: u32 = fn_state.u_33850;
        // D s_987_34: cast zx s_987_33 -> bv
        let s_987_34: Bits = Bits::new(s_987_33 as u128, 32u16);
        // D s_987_35: bit-extract s_987_34 s_987_31 s_987_32
        let s_987_35: Bits = (Bits::new(
            ((s_987_34) >> (s_987_31)).value(),
            u16::try_from(s_987_32).unwrap(),
        ));
        // D s_987_36: cast reint s_987_35 -> u8
        let s_987_36: u8 = (s_987_35.value() as u8);
        // D s_987_37: write-var u#33855 <= s_987_36
        fn_state.u_33855 = s_987_36;
        // C s_987_38: const #8s : i
        let s_987_38: i128 = 8;
        // D s_987_39: read-var u#33850:u32
        let s_987_39: u32 = fn_state.u_33850;
        // D s_987_40: cast zx s_987_39 -> bv
        let s_987_40: Bits = Bits::new(s_987_39 as u128, 32u16);
        // C s_987_41: const #1u : u64
        let s_987_41: u64 = 1;
        // D s_987_42: bit-extract s_987_40 s_987_38 s_987_41
        let s_987_42: Bits = (Bits::new(
            ((s_987_40) >> (s_987_38)).value(),
            u16::try_from(s_987_41).unwrap(),
        ));
        // D s_987_43: cast reint s_987_42 -> u8
        let s_987_43: bool = ((s_987_42.value()) != 0);
        // C s_987_44: const #0s : i
        let s_987_44: i128 = 0;
        // C s_987_45: const #0u : u64
        let s_987_45: u64 = 0;
        // D s_987_46: cast zx s_987_43 -> u64
        let s_987_46: u64 = (s_987_43 as u64);
        // C s_987_47: const #1u : u64
        let s_987_47: u64 = 1;
        // D s_987_48: and s_987_46 s_987_47
        let s_987_48: u64 = ((s_987_46) & (s_987_47));
        // D s_987_49: cmp-eq s_987_48 s_987_47
        let s_987_49: bool = ((s_987_48) == (s_987_47));
        // D s_987_50: lsl s_987_46 s_987_44
        let s_987_50: u64 = s_987_46 << s_987_44;
        // D s_987_51: or s_987_45 s_987_50
        let s_987_51: u64 = ((s_987_45) | (s_987_50));
        // D s_987_52: cmpl s_987_50
        let s_987_52: u64 = !s_987_50;
        // D s_987_53: and s_987_45 s_987_52
        let s_987_53: u64 = ((s_987_45) & (s_987_52));
        // D s_987_54: select s_987_49 s_987_51 s_987_53
        let s_987_54: u64 = if s_987_49 { s_987_51 } else { s_987_53 };
        // D s_987_55: cast trunc s_987_54 -> u8
        let s_987_55: bool = ((s_987_54) != 0);
        // D s_987_56: cast zx s_987_55 -> bv
        let s_987_56: Bits = Bits::new(s_987_55 as u128, 1u16);
        // C s_987_57: const #0u : u8
        let s_987_57: bool = false;
        // C s_987_58: cast zx s_987_57 -> bv
        let s_987_58: Bits = Bits::new(s_987_57 as u128, 1u16);
        // D s_987_59: cmp-ne s_987_56 s_987_58
        let s_987_59: bool = ((s_987_56) != (s_987_58));
        // N s_987_60: branch s_987_59 b992 b988
        if s_987_59 {
            return block_992(state, tracer, fn_state);
        } else {
            return block_988(state, tracer, fn_state);
        };
    }
    fn block_988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_988_0: const #9s : i
        let s_988_0: i128 = 9;
        // D s_988_1: read-var u#33850:u32
        let s_988_1: u32 = fn_state.u_33850;
        // D s_988_2: cast zx s_988_1 -> bv
        let s_988_2: Bits = Bits::new(s_988_1 as u128, 32u16);
        // C s_988_3: const #1u : u64
        let s_988_3: u64 = 1;
        // D s_988_4: bit-extract s_988_2 s_988_0 s_988_3
        let s_988_4: Bits = (Bits::new(
            ((s_988_2) >> (s_988_0)).value(),
            u16::try_from(s_988_3).unwrap(),
        ));
        // D s_988_5: cast reint s_988_4 -> u8
        let s_988_5: bool = ((s_988_4.value()) != 0);
        // C s_988_6: const #0s : i
        let s_988_6: i128 = 0;
        // C s_988_7: const #0u : u64
        let s_988_7: u64 = 0;
        // D s_988_8: cast zx s_988_5 -> u64
        let s_988_8: u64 = (s_988_5 as u64);
        // C s_988_9: const #1u : u64
        let s_988_9: u64 = 1;
        // D s_988_10: and s_988_8 s_988_9
        let s_988_10: u64 = ((s_988_8) & (s_988_9));
        // D s_988_11: cmp-eq s_988_10 s_988_9
        let s_988_11: bool = ((s_988_10) == (s_988_9));
        // D s_988_12: lsl s_988_8 s_988_6
        let s_988_12: u64 = s_988_8 << s_988_6;
        // D s_988_13: or s_988_7 s_988_12
        let s_988_13: u64 = ((s_988_7) | (s_988_12));
        // D s_988_14: cmpl s_988_12
        let s_988_14: u64 = !s_988_12;
        // D s_988_15: and s_988_7 s_988_14
        let s_988_15: u64 = ((s_988_7) & (s_988_14));
        // D s_988_16: select s_988_11 s_988_13 s_988_15
        let s_988_16: u64 = if s_988_11 { s_988_13 } else { s_988_15 };
        // D s_988_17: cast trunc s_988_16 -> u8
        let s_988_17: bool = ((s_988_16) != 0);
        // D s_988_18: cast zx s_988_17 -> bv
        let s_988_18: Bits = Bits::new(s_988_17 as u128, 1u16);
        // C s_988_19: const #0u : u8
        let s_988_19: bool = false;
        // C s_988_20: cast zx s_988_19 -> bv
        let s_988_20: Bits = Bits::new(s_988_19 as u128, 1u16);
        // D s_988_21: cmp-ne s_988_18 s_988_20
        let s_988_21: bool = ((s_988_18) != (s_988_20));
        // D s_988_22: write-var gs#411251 <= s_988_21
        fn_state.gs_411251 = s_988_21;
        // N s_988_23: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_989_0: read-var gs#411251:u8
        let s_989_0: bool = fn_state.gs_411251;
        // N s_989_1: branch s_989_0 b991 b990
        if s_989_0 {
            return block_991(state, tracer, fn_state);
        } else {
            return block_990(state, tracer, fn_state);
        };
    }
    fn block_990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_990_0: read-var u#33851:u8
        let s_990_0: u8 = fn_state.u_33851;
        // D s_990_1: read-var u#33852:u8
        let s_990_1: u8 = fn_state.u_33852;
        // D s_990_2: read-var u#33853:u8
        let s_990_2: u8 = fn_state.u_33853;
        // D s_990_3: read-var u#33854:u8
        let s_990_3: u8 = fn_state.u_33854;
        // D s_990_4: read-var u#33855:u8
        let s_990_4: u8 = fn_state.u_33855;
        // D s_990_5: call decode_aarch32_instrs_UXTAB_A1enc_A_txt(s_990_0, s_990_1, s_990_2, s_990_3, s_990_4)
        let s_990_5: () = decode_aarch32_instrs_UXTAB_A1enc_A_txt(
            state,
            tracer,
            s_990_0,
            s_990_1,
            s_990_2,
            s_990_3,
            s_990_4,
        );
        // N s_990_6: return
        return;
    }
    fn block_991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_991_0: panic
        panic!("{:?}", ());
        // N s_991_1: return
        return;
    }
    fn block_992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_992_0: const #1u : u8
        let s_992_0: bool = true;
        // D s_992_1: write-var gs#411251 <= s_992_0
        fn_state.gs_411251 = s_992_0;
        // N s_992_2: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_993_0: read-var merge#var.1:struct
        let s_993_0: u32 = fn_state.merge_var._1;
        // D s_993_1: write-var u#33857 <= s_993_0
        fn_state.u_33857 = s_993_0;
        // C s_993_2: const #20s : i
        let s_993_2: i128 = 20;
        // D s_993_3: read-var u#33857:u32
        let s_993_3: u32 = fn_state.u_33857;
        // D s_993_4: cast zx s_993_3 -> bv
        let s_993_4: Bits = Bits::new(s_993_3 as u128, 32u16);
        // C s_993_5: const #1s : i64
        let s_993_5: i64 = 1;
        // C s_993_6: cast zx s_993_5 -> i
        let s_993_6: i128 = (i128::try_from(s_993_5).unwrap());
        // C s_993_7: const #7s : i
        let s_993_7: i128 = 7;
        // C s_993_8: add s_993_7 s_993_6
        let s_993_8: i128 = (s_993_7 + s_993_6);
        // D s_993_9: bit-extract s_993_4 s_993_2 s_993_8
        let s_993_9: Bits = (Bits::new(
            ((s_993_4) >> (s_993_2)).value(),
            u16::try_from(s_993_8).unwrap(),
        ));
        // D s_993_10: cast reint s_993_9 -> u8
        let s_993_10: u8 = (s_993_9.value() as u8);
        // D s_993_11: cast zx s_993_10 -> bv
        let s_993_11: Bits = Bits::new(s_993_10 as u128, 8u16);
        // C s_993_12: const #111u : u8
        let s_993_12: u8 = 111;
        // C s_993_13: cast zx s_993_12 -> bv
        let s_993_13: Bits = Bits::new(s_993_12 as u128, 8u16);
        // D s_993_14: cmp-eq s_993_11 s_993_13
        let s_993_14: bool = ((s_993_11) == (s_993_13));
        // N s_993_15: branch s_993_14 b1057 b994
        if s_993_14 {
            return block_1057(state, tracer, fn_state);
        } else {
            return block_994(state, tracer, fn_state);
        };
    }
    fn block_994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_994_0: const #0u : u8
        let s_994_0: bool = false;
        // D s_994_1: write-var gs#411257 <= s_994_0
        fn_state.gs_411257 = s_994_0;
        // N s_994_2: jump b995
        return block_995(state, tracer, fn_state);
    }
    fn block_995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_995_0: read-var gs#411257:u8
        let s_995_0: bool = fn_state.gs_411257;
        // N s_995_1: branch s_995_0 b1053 b996
        if s_995_0 {
            return block_1053(state, tracer, fn_state);
        } else {
            return block_996(state, tracer, fn_state);
        };
    }
    fn block_996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_996_0: const #0u : u8
        let s_996_0: bool = false;
        // D s_996_1: write-var gs#411262 <= s_996_0
        fn_state.gs_411262 = s_996_0;
        // N s_996_2: jump b997
        return block_997(state, tracer, fn_state);
    }
    fn block_997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_997_0: read-var gs#411262:u8
        let s_997_0: bool = fn_state.gs_411262;
        // D s_997_1: not s_997_0
        let s_997_1: bool = !s_997_0;
        // N s_997_2: branch s_997_1 b1004 b998
        if s_997_1 {
            return block_1004(state, tracer, fn_state);
        } else {
            return block_998(state, tracer, fn_state);
        };
    }
    fn block_998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_998_0: const #3340s : i
        let s_998_0: i128 = 3340;
        // C s_998_1: const #14696u : u32
        let s_998_1: u32 = 14696;
        // N s_998_2: write-reg s_998_1 <= s_998_0
        let s_998_2: () = {
            state.write_register::<i128>(s_998_1 as isize, s_998_0);
            tracer.write_register(s_998_1 as isize, s_998_0);
        };
        // C s_998_3: const #28s : i
        let s_998_3: i128 = 28;
        // C s_998_4: const #4s : i
        let s_998_4: i128 = 4;
        // D s_998_5: read-var u#33857:u32
        let s_998_5: u32 = fn_state.u_33857;
        // D s_998_6: cast zx s_998_5 -> bv
        let s_998_6: Bits = Bits::new(s_998_5 as u128, 32u16);
        // D s_998_7: bit-extract s_998_6 s_998_3 s_998_4
        let s_998_7: Bits = (Bits::new(
            ((s_998_6) >> (s_998_3)).value(),
            u16::try_from(s_998_4).unwrap(),
        ));
        // D s_998_8: cast reint s_998_7 -> u8
        let s_998_8: u8 = (s_998_7.value() as u8);
        // D s_998_9: write-var u#33858 <= s_998_8
        fn_state.u_33858 = s_998_8;
        // C s_998_10: const #16s : i
        let s_998_10: i128 = 16;
        // C s_998_11: const #4s : i
        let s_998_11: i128 = 4;
        // D s_998_12: read-var u#33857:u32
        let s_998_12: u32 = fn_state.u_33857;
        // D s_998_13: cast zx s_998_12 -> bv
        let s_998_13: Bits = Bits::new(s_998_12 as u128, 32u16);
        // D s_998_14: bit-extract s_998_13 s_998_10 s_998_11
        let s_998_14: Bits = (Bits::new(
            ((s_998_13) >> (s_998_10)).value(),
            u16::try_from(s_998_11).unwrap(),
        ));
        // D s_998_15: cast reint s_998_14 -> u8
        let s_998_15: u8 = (s_998_14.value() as u8);
        // D s_998_16: write-var u#33859 <= s_998_15
        fn_state.u_33859 = s_998_15;
        // C s_998_17: const #12s : i
        let s_998_17: i128 = 12;
        // C s_998_18: const #4s : i
        let s_998_18: i128 = 4;
        // D s_998_19: read-var u#33857:u32
        let s_998_19: u32 = fn_state.u_33857;
        // D s_998_20: cast zx s_998_19 -> bv
        let s_998_20: Bits = Bits::new(s_998_19 as u128, 32u16);
        // D s_998_21: bit-extract s_998_20 s_998_17 s_998_18
        let s_998_21: Bits = (Bits::new(
            ((s_998_20) >> (s_998_17)).value(),
            u16::try_from(s_998_18).unwrap(),
        ));
        // D s_998_22: cast reint s_998_21 -> u8
        let s_998_22: u8 = (s_998_21.value() as u8);
        // D s_998_23: write-var u#33860 <= s_998_22
        fn_state.u_33860 = s_998_22;
        // C s_998_24: const #10s : i
        let s_998_24: i128 = 10;
        // C s_998_25: const #2s : i
        let s_998_25: i128 = 2;
        // D s_998_26: read-var u#33857:u32
        let s_998_26: u32 = fn_state.u_33857;
        // D s_998_27: cast zx s_998_26 -> bv
        let s_998_27: Bits = Bits::new(s_998_26 as u128, 32u16);
        // D s_998_28: bit-extract s_998_27 s_998_24 s_998_25
        let s_998_28: Bits = (Bits::new(
            ((s_998_27) >> (s_998_24)).value(),
            u16::try_from(s_998_25).unwrap(),
        ));
        // D s_998_29: cast reint s_998_28 -> u8
        let s_998_29: u8 = (s_998_28.value() as u8);
        // D s_998_30: write-var u#33861 <= s_998_29
        fn_state.u_33861 = s_998_29;
        // C s_998_31: const #0s : i
        let s_998_31: i128 = 0;
        // C s_998_32: const #4s : i
        let s_998_32: i128 = 4;
        // D s_998_33: read-var u#33857:u32
        let s_998_33: u32 = fn_state.u_33857;
        // D s_998_34: cast zx s_998_33 -> bv
        let s_998_34: Bits = Bits::new(s_998_33 as u128, 32u16);
        // D s_998_35: bit-extract s_998_34 s_998_31 s_998_32
        let s_998_35: Bits = (Bits::new(
            ((s_998_34) >> (s_998_31)).value(),
            u16::try_from(s_998_32).unwrap(),
        ));
        // D s_998_36: cast reint s_998_35 -> u8
        let s_998_36: u8 = (s_998_35.value() as u8);
        // D s_998_37: write-var u#33862 <= s_998_36
        fn_state.u_33862 = s_998_36;
        // C s_998_38: const #8s : i
        let s_998_38: i128 = 8;
        // D s_998_39: read-var u#33857:u32
        let s_998_39: u32 = fn_state.u_33857;
        // D s_998_40: cast zx s_998_39 -> bv
        let s_998_40: Bits = Bits::new(s_998_39 as u128, 32u16);
        // C s_998_41: const #1u : u64
        let s_998_41: u64 = 1;
        // D s_998_42: bit-extract s_998_40 s_998_38 s_998_41
        let s_998_42: Bits = (Bits::new(
            ((s_998_40) >> (s_998_38)).value(),
            u16::try_from(s_998_41).unwrap(),
        ));
        // D s_998_43: cast reint s_998_42 -> u8
        let s_998_43: bool = ((s_998_42.value()) != 0);
        // C s_998_44: const #0s : i
        let s_998_44: i128 = 0;
        // C s_998_45: const #0u : u64
        let s_998_45: u64 = 0;
        // D s_998_46: cast zx s_998_43 -> u64
        let s_998_46: u64 = (s_998_43 as u64);
        // C s_998_47: const #1u : u64
        let s_998_47: u64 = 1;
        // D s_998_48: and s_998_46 s_998_47
        let s_998_48: u64 = ((s_998_46) & (s_998_47));
        // D s_998_49: cmp-eq s_998_48 s_998_47
        let s_998_49: bool = ((s_998_48) == (s_998_47));
        // D s_998_50: lsl s_998_46 s_998_44
        let s_998_50: u64 = s_998_46 << s_998_44;
        // D s_998_51: or s_998_45 s_998_50
        let s_998_51: u64 = ((s_998_45) | (s_998_50));
        // D s_998_52: cmpl s_998_50
        let s_998_52: u64 = !s_998_50;
        // D s_998_53: and s_998_45 s_998_52
        let s_998_53: u64 = ((s_998_45) & (s_998_52));
        // D s_998_54: select s_998_49 s_998_51 s_998_53
        let s_998_54: u64 = if s_998_49 { s_998_51 } else { s_998_53 };
        // D s_998_55: cast trunc s_998_54 -> u8
        let s_998_55: bool = ((s_998_54) != 0);
        // D s_998_56: cast zx s_998_55 -> bv
        let s_998_56: Bits = Bits::new(s_998_55 as u128, 1u16);
        // C s_998_57: const #0u : u8
        let s_998_57: bool = false;
        // C s_998_58: cast zx s_998_57 -> bv
        let s_998_58: Bits = Bits::new(s_998_57 as u128, 1u16);
        // D s_998_59: cmp-ne s_998_56 s_998_58
        let s_998_59: bool = ((s_998_56) != (s_998_58));
        // N s_998_60: branch s_998_59 b1003 b999
        if s_998_59 {
            return block_1003(state, tracer, fn_state);
        } else {
            return block_999(state, tracer, fn_state);
        };
    }
    fn block_999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_999_0: const #9s : i
        let s_999_0: i128 = 9;
        // D s_999_1: read-var u#33857:u32
        let s_999_1: u32 = fn_state.u_33857;
        // D s_999_2: cast zx s_999_1 -> bv
        let s_999_2: Bits = Bits::new(s_999_1 as u128, 32u16);
        // C s_999_3: const #1u : u64
        let s_999_3: u64 = 1;
        // D s_999_4: bit-extract s_999_2 s_999_0 s_999_3
        let s_999_4: Bits = (Bits::new(
            ((s_999_2) >> (s_999_0)).value(),
            u16::try_from(s_999_3).unwrap(),
        ));
        // D s_999_5: cast reint s_999_4 -> u8
        let s_999_5: bool = ((s_999_4.value()) != 0);
        // C s_999_6: const #0s : i
        let s_999_6: i128 = 0;
        // C s_999_7: const #0u : u64
        let s_999_7: u64 = 0;
        // D s_999_8: cast zx s_999_5 -> u64
        let s_999_8: u64 = (s_999_5 as u64);
        // C s_999_9: const #1u : u64
        let s_999_9: u64 = 1;
        // D s_999_10: and s_999_8 s_999_9
        let s_999_10: u64 = ((s_999_8) & (s_999_9));
        // D s_999_11: cmp-eq s_999_10 s_999_9
        let s_999_11: bool = ((s_999_10) == (s_999_9));
        // D s_999_12: lsl s_999_8 s_999_6
        let s_999_12: u64 = s_999_8 << s_999_6;
        // D s_999_13: or s_999_7 s_999_12
        let s_999_13: u64 = ((s_999_7) | (s_999_12));
        // D s_999_14: cmpl s_999_12
        let s_999_14: u64 = !s_999_12;
        // D s_999_15: and s_999_7 s_999_14
        let s_999_15: u64 = ((s_999_7) & (s_999_14));
        // D s_999_16: select s_999_11 s_999_13 s_999_15
        let s_999_16: u64 = if s_999_11 { s_999_13 } else { s_999_15 };
        // D s_999_17: cast trunc s_999_16 -> u8
        let s_999_17: bool = ((s_999_16) != 0);
        // D s_999_18: cast zx s_999_17 -> bv
        let s_999_18: Bits = Bits::new(s_999_17 as u128, 1u16);
        // C s_999_19: const #0u : u8
        let s_999_19: bool = false;
        // C s_999_20: cast zx s_999_19 -> bv
        let s_999_20: Bits = Bits::new(s_999_19 as u128, 1u16);
        // D s_999_21: cmp-ne s_999_18 s_999_20
        let s_999_21: bool = ((s_999_18) != (s_999_20));
        // D s_999_22: write-var gs#411279 <= s_999_21
        fn_state.gs_411279 = s_999_21;
        // N s_999_23: jump b1000
        return block_1000(state, tracer, fn_state);
    }
    fn block_1000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1000_0: read-var gs#411279:u8
        let s_1000_0: bool = fn_state.gs_411279;
        // N s_1000_1: branch s_1000_0 b1002 b1001
        if s_1000_0 {
            return block_1002(state, tracer, fn_state);
        } else {
            return block_1001(state, tracer, fn_state);
        };
    }
    fn block_1001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1001_0: read-var u#33858:u8
        let s_1001_0: u8 = fn_state.u_33858;
        // D s_1001_1: read-var u#33859:u8
        let s_1001_1: u8 = fn_state.u_33859;
        // D s_1001_2: read-var u#33860:u8
        let s_1001_2: u8 = fn_state.u_33860;
        // D s_1001_3: read-var u#33861:u8
        let s_1001_3: u8 = fn_state.u_33861;
        // D s_1001_4: read-var u#33862:u8
        let s_1001_4: u8 = fn_state.u_33862;
        // D s_1001_5: call decode_aarch32_instrs_UXTAH_A1enc_A_txt(s_1001_0, s_1001_1, s_1001_2, s_1001_3, s_1001_4)
        let s_1001_5: () = decode_aarch32_instrs_UXTAH_A1enc_A_txt(
            state,
            tracer,
            s_1001_0,
            s_1001_1,
            s_1001_2,
            s_1001_3,
            s_1001_4,
        );
        // N s_1001_6: return
        return;
    }
    fn block_1002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1002_0: panic
        panic!("{:?}", ());
        // N s_1002_1: return
        return;
    }
    fn block_1003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1003_0: const #1u : u8
        let s_1003_0: bool = true;
        // D s_1003_1: write-var gs#411279 <= s_1003_0
        fn_state.gs_411279 = s_1003_0;
        // N s_1003_2: jump b1000
        return block_1000(state, tracer, fn_state);
    }
    fn block_1004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1004_0: read-var merge#var.1:struct
        let s_1004_0: u32 = fn_state.merge_var._1;
        // D s_1004_1: write-var u#33864 <= s_1004_0
        fn_state.u_33864 = s_1004_0;
        // C s_1004_2: const #16s : i
        let s_1004_2: i128 = 16;
        // D s_1004_3: read-var u#33864:u32
        let s_1004_3: u32 = fn_state.u_33864;
        // D s_1004_4: cast zx s_1004_3 -> bv
        let s_1004_4: Bits = Bits::new(s_1004_3 as u128, 32u16);
        // C s_1004_5: const #1s : i64
        let s_1004_5: i64 = 1;
        // C s_1004_6: cast zx s_1004_5 -> i
        let s_1004_6: i128 = (i128::try_from(s_1004_5).unwrap());
        // C s_1004_7: const #11s : i
        let s_1004_7: i128 = 11;
        // C s_1004_8: add s_1004_7 s_1004_6
        let s_1004_8: i128 = (s_1004_7 + s_1004_6);
        // D s_1004_9: bit-extract s_1004_4 s_1004_2 s_1004_8
        let s_1004_9: Bits = (Bits::new(
            ((s_1004_4) >> (s_1004_2)).value(),
            u16::try_from(s_1004_8).unwrap(),
        ));
        // D s_1004_10: cast reint s_1004_9 -> u12
        let s_1004_10: u16 = (s_1004_9.value() as u16);
        // D s_1004_11: cast zx s_1004_10 -> bv
        let s_1004_11: Bits = Bits::new(s_1004_10 as u128, 12u16);
        // C s_1004_12: const #1743u : u12
        let s_1004_12: u16 = 1743;
        // C s_1004_13: cast zx s_1004_12 -> bv
        let s_1004_13: Bits = Bits::new(s_1004_12 as u128, 12u16);
        // D s_1004_14: cmp-eq s_1004_11 s_1004_13
        let s_1004_14: bool = ((s_1004_11) == (s_1004_13));
        // N s_1004_15: branch s_1004_14 b1052 b1005
        if s_1004_14 {
            return block_1052(state, tracer, fn_state);
        } else {
            return block_1005(state, tracer, fn_state);
        };
    }
    fn block_1005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1005_0: const #0u : u8
        let s_1005_0: bool = false;
        // D s_1005_1: write-var gs#411285 <= s_1005_0
        fn_state.gs_411285 = s_1005_0;
        // N s_1005_2: jump b1006
        return block_1006(state, tracer, fn_state);
    }
    fn block_1006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1006_0: read-var gs#411285:u8
        let s_1006_0: bool = fn_state.gs_411285;
        // N s_1006_1: branch s_1006_0 b1048 b1007
        if s_1006_0 {
            return block_1048(state, tracer, fn_state);
        } else {
            return block_1007(state, tracer, fn_state);
        };
    }
    fn block_1007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1007_0: const #0u : u8
        let s_1007_0: bool = false;
        // D s_1007_1: write-var gs#411290 <= s_1007_0
        fn_state.gs_411290 = s_1007_0;
        // N s_1007_2: jump b1008
        return block_1008(state, tracer, fn_state);
    }
    fn block_1008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1008_0: read-var gs#411290:u8
        let s_1008_0: bool = fn_state.gs_411290;
        // D s_1008_1: not s_1008_0
        let s_1008_1: bool = !s_1008_0;
        // N s_1008_2: branch s_1008_1 b1015 b1009
        if s_1008_1 {
            return block_1015(state, tracer, fn_state);
        } else {
            return block_1009(state, tracer, fn_state);
        };
    }
    fn block_1009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1009_0: const #3342s : i
        let s_1009_0: i128 = 3342;
        // C s_1009_1: const #14696u : u32
        let s_1009_1: u32 = 14696;
        // N s_1009_2: write-reg s_1009_1 <= s_1009_0
        let s_1009_2: () = {
            state.write_register::<i128>(s_1009_1 as isize, s_1009_0);
            tracer.write_register(s_1009_1 as isize, s_1009_0);
        };
        // C s_1009_3: const #28s : i
        let s_1009_3: i128 = 28;
        // C s_1009_4: const #4s : i
        let s_1009_4: i128 = 4;
        // D s_1009_5: read-var u#33864:u32
        let s_1009_5: u32 = fn_state.u_33864;
        // D s_1009_6: cast zx s_1009_5 -> bv
        let s_1009_6: Bits = Bits::new(s_1009_5 as u128, 32u16);
        // D s_1009_7: bit-extract s_1009_6 s_1009_3 s_1009_4
        let s_1009_7: Bits = (Bits::new(
            ((s_1009_6) >> (s_1009_3)).value(),
            u16::try_from(s_1009_4).unwrap(),
        ));
        // D s_1009_8: cast reint s_1009_7 -> u8
        let s_1009_8: u8 = (s_1009_7.value() as u8);
        // D s_1009_9: write-var u#33865 <= s_1009_8
        fn_state.u_33865 = s_1009_8;
        // C s_1009_10: const #12s : i
        let s_1009_10: i128 = 12;
        // C s_1009_11: const #4s : i
        let s_1009_11: i128 = 4;
        // D s_1009_12: read-var u#33864:u32
        let s_1009_12: u32 = fn_state.u_33864;
        // D s_1009_13: cast zx s_1009_12 -> bv
        let s_1009_13: Bits = Bits::new(s_1009_12 as u128, 32u16);
        // D s_1009_14: bit-extract s_1009_13 s_1009_10 s_1009_11
        let s_1009_14: Bits = (Bits::new(
            ((s_1009_13) >> (s_1009_10)).value(),
            u16::try_from(s_1009_11).unwrap(),
        ));
        // D s_1009_15: cast reint s_1009_14 -> u8
        let s_1009_15: u8 = (s_1009_14.value() as u8);
        // D s_1009_16: write-var u#33866 <= s_1009_15
        fn_state.u_33866 = s_1009_15;
        // C s_1009_17: const #10s : i
        let s_1009_17: i128 = 10;
        // C s_1009_18: const #2s : i
        let s_1009_18: i128 = 2;
        // D s_1009_19: read-var u#33864:u32
        let s_1009_19: u32 = fn_state.u_33864;
        // D s_1009_20: cast zx s_1009_19 -> bv
        let s_1009_20: Bits = Bits::new(s_1009_19 as u128, 32u16);
        // D s_1009_21: bit-extract s_1009_20 s_1009_17 s_1009_18
        let s_1009_21: Bits = (Bits::new(
            ((s_1009_20) >> (s_1009_17)).value(),
            u16::try_from(s_1009_18).unwrap(),
        ));
        // D s_1009_22: cast reint s_1009_21 -> u8
        let s_1009_22: u8 = (s_1009_21.value() as u8);
        // D s_1009_23: write-var u#33867 <= s_1009_22
        fn_state.u_33867 = s_1009_22;
        // C s_1009_24: const #0s : i
        let s_1009_24: i128 = 0;
        // C s_1009_25: const #4s : i
        let s_1009_25: i128 = 4;
        // D s_1009_26: read-var u#33864:u32
        let s_1009_26: u32 = fn_state.u_33864;
        // D s_1009_27: cast zx s_1009_26 -> bv
        let s_1009_27: Bits = Bits::new(s_1009_26 as u128, 32u16);
        // D s_1009_28: bit-extract s_1009_27 s_1009_24 s_1009_25
        let s_1009_28: Bits = (Bits::new(
            ((s_1009_27) >> (s_1009_24)).value(),
            u16::try_from(s_1009_25).unwrap(),
        ));
        // D s_1009_29: cast reint s_1009_28 -> u8
        let s_1009_29: u8 = (s_1009_28.value() as u8);
        // D s_1009_30: write-var u#33868 <= s_1009_29
        fn_state.u_33868 = s_1009_29;
        // C s_1009_31: const #8s : i
        let s_1009_31: i128 = 8;
        // D s_1009_32: read-var u#33864:u32
        let s_1009_32: u32 = fn_state.u_33864;
        // D s_1009_33: cast zx s_1009_32 -> bv
        let s_1009_33: Bits = Bits::new(s_1009_32 as u128, 32u16);
        // C s_1009_34: const #1u : u64
        let s_1009_34: u64 = 1;
        // D s_1009_35: bit-extract s_1009_33 s_1009_31 s_1009_34
        let s_1009_35: Bits = (Bits::new(
            ((s_1009_33) >> (s_1009_31)).value(),
            u16::try_from(s_1009_34).unwrap(),
        ));
        // D s_1009_36: cast reint s_1009_35 -> u8
        let s_1009_36: bool = ((s_1009_35.value()) != 0);
        // C s_1009_37: const #0s : i
        let s_1009_37: i128 = 0;
        // C s_1009_38: const #0u : u64
        let s_1009_38: u64 = 0;
        // D s_1009_39: cast zx s_1009_36 -> u64
        let s_1009_39: u64 = (s_1009_36 as u64);
        // C s_1009_40: const #1u : u64
        let s_1009_40: u64 = 1;
        // D s_1009_41: and s_1009_39 s_1009_40
        let s_1009_41: u64 = ((s_1009_39) & (s_1009_40));
        // D s_1009_42: cmp-eq s_1009_41 s_1009_40
        let s_1009_42: bool = ((s_1009_41) == (s_1009_40));
        // D s_1009_43: lsl s_1009_39 s_1009_37
        let s_1009_43: u64 = s_1009_39 << s_1009_37;
        // D s_1009_44: or s_1009_38 s_1009_43
        let s_1009_44: u64 = ((s_1009_38) | (s_1009_43));
        // D s_1009_45: cmpl s_1009_43
        let s_1009_45: u64 = !s_1009_43;
        // D s_1009_46: and s_1009_38 s_1009_45
        let s_1009_46: u64 = ((s_1009_38) & (s_1009_45));
        // D s_1009_47: select s_1009_42 s_1009_44 s_1009_46
        let s_1009_47: u64 = if s_1009_42 { s_1009_44 } else { s_1009_46 };
        // D s_1009_48: cast trunc s_1009_47 -> u8
        let s_1009_48: bool = ((s_1009_47) != 0);
        // D s_1009_49: cast zx s_1009_48 -> bv
        let s_1009_49: Bits = Bits::new(s_1009_48 as u128, 1u16);
        // C s_1009_50: const #0u : u8
        let s_1009_50: bool = false;
        // C s_1009_51: cast zx s_1009_50 -> bv
        let s_1009_51: Bits = Bits::new(s_1009_50 as u128, 1u16);
        // D s_1009_52: cmp-ne s_1009_49 s_1009_51
        let s_1009_52: bool = ((s_1009_49) != (s_1009_51));
        // N s_1009_53: branch s_1009_52 b1014 b1010
        if s_1009_52 {
            return block_1014(state, tracer, fn_state);
        } else {
            return block_1010(state, tracer, fn_state);
        };
    }
    fn block_1010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1010_0: const #9s : i
        let s_1010_0: i128 = 9;
        // D s_1010_1: read-var u#33864:u32
        let s_1010_1: u32 = fn_state.u_33864;
        // D s_1010_2: cast zx s_1010_1 -> bv
        let s_1010_2: Bits = Bits::new(s_1010_1 as u128, 32u16);
        // C s_1010_3: const #1u : u64
        let s_1010_3: u64 = 1;
        // D s_1010_4: bit-extract s_1010_2 s_1010_0 s_1010_3
        let s_1010_4: Bits = (Bits::new(
            ((s_1010_2) >> (s_1010_0)).value(),
            u16::try_from(s_1010_3).unwrap(),
        ));
        // D s_1010_5: cast reint s_1010_4 -> u8
        let s_1010_5: bool = ((s_1010_4.value()) != 0);
        // C s_1010_6: const #0s : i
        let s_1010_6: i128 = 0;
        // C s_1010_7: const #0u : u64
        let s_1010_7: u64 = 0;
        // D s_1010_8: cast zx s_1010_5 -> u64
        let s_1010_8: u64 = (s_1010_5 as u64);
        // C s_1010_9: const #1u : u64
        let s_1010_9: u64 = 1;
        // D s_1010_10: and s_1010_8 s_1010_9
        let s_1010_10: u64 = ((s_1010_8) & (s_1010_9));
        // D s_1010_11: cmp-eq s_1010_10 s_1010_9
        let s_1010_11: bool = ((s_1010_10) == (s_1010_9));
        // D s_1010_12: lsl s_1010_8 s_1010_6
        let s_1010_12: u64 = s_1010_8 << s_1010_6;
        // D s_1010_13: or s_1010_7 s_1010_12
        let s_1010_13: u64 = ((s_1010_7) | (s_1010_12));
        // D s_1010_14: cmpl s_1010_12
        let s_1010_14: u64 = !s_1010_12;
        // D s_1010_15: and s_1010_7 s_1010_14
        let s_1010_15: u64 = ((s_1010_7) & (s_1010_14));
        // D s_1010_16: select s_1010_11 s_1010_13 s_1010_15
        let s_1010_16: u64 = if s_1010_11 { s_1010_13 } else { s_1010_15 };
        // D s_1010_17: cast trunc s_1010_16 -> u8
        let s_1010_17: bool = ((s_1010_16) != 0);
        // D s_1010_18: cast zx s_1010_17 -> bv
        let s_1010_18: Bits = Bits::new(s_1010_17 as u128, 1u16);
        // C s_1010_19: const #0u : u8
        let s_1010_19: bool = false;
        // C s_1010_20: cast zx s_1010_19 -> bv
        let s_1010_20: Bits = Bits::new(s_1010_19 as u128, 1u16);
        // D s_1010_21: cmp-ne s_1010_18 s_1010_20
        let s_1010_21: bool = ((s_1010_18) != (s_1010_20));
        // D s_1010_22: write-var gs#411305 <= s_1010_21
        fn_state.gs_411305 = s_1010_21;
        // N s_1010_23: jump b1011
        return block_1011(state, tracer, fn_state);
    }
    fn block_1011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1011_0: read-var gs#411305:u8
        let s_1011_0: bool = fn_state.gs_411305;
        // N s_1011_1: branch s_1011_0 b1013 b1012
        if s_1011_0 {
            return block_1013(state, tracer, fn_state);
        } else {
            return block_1012(state, tracer, fn_state);
        };
    }
    fn block_1012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1012_0: read-var u#33865:u8
        let s_1012_0: u8 = fn_state.u_33865;
        // D s_1012_1: read-var u#33866:u8
        let s_1012_1: u8 = fn_state.u_33866;
        // D s_1012_2: read-var u#33867:u8
        let s_1012_2: u8 = fn_state.u_33867;
        // D s_1012_3: read-var u#33868:u8
        let s_1012_3: u8 = fn_state.u_33868;
        // D s_1012_4: call decode_aarch32_instrs_UXTB16_A1enc_A_txt(s_1012_0, s_1012_1, s_1012_2, s_1012_3)
        let s_1012_4: () = decode_aarch32_instrs_UXTB16_A1enc_A_txt(
            state,
            tracer,
            s_1012_0,
            s_1012_1,
            s_1012_2,
            s_1012_3,
        );
        // N s_1012_5: return
        return;
    }
    fn block_1013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1013_0: panic
        panic!("{:?}", ());
        // N s_1013_1: return
        return;
    }
    fn block_1014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1014_0: const #1u : u8
        let s_1014_0: bool = true;
        // D s_1014_1: write-var gs#411305 <= s_1014_0
        fn_state.gs_411305 = s_1014_0;
        // N s_1014_2: jump b1011
        return block_1011(state, tracer, fn_state);
    }
    fn block_1015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1015_0: read-var merge#var.1:struct
        let s_1015_0: u32 = fn_state.merge_var._1;
        // D s_1015_1: write-var u#33870 <= s_1015_0
        fn_state.u_33870 = s_1015_0;
        // C s_1015_2: const #16s : i
        let s_1015_2: i128 = 16;
        // D s_1015_3: read-var u#33870:u32
        let s_1015_3: u32 = fn_state.u_33870;
        // D s_1015_4: cast zx s_1015_3 -> bv
        let s_1015_4: Bits = Bits::new(s_1015_3 as u128, 32u16);
        // C s_1015_5: const #1s : i64
        let s_1015_5: i64 = 1;
        // C s_1015_6: cast zx s_1015_5 -> i
        let s_1015_6: i128 = (i128::try_from(s_1015_5).unwrap());
        // C s_1015_7: const #11s : i
        let s_1015_7: i128 = 11;
        // C s_1015_8: add s_1015_7 s_1015_6
        let s_1015_8: i128 = (s_1015_7 + s_1015_6);
        // D s_1015_9: bit-extract s_1015_4 s_1015_2 s_1015_8
        let s_1015_9: Bits = (Bits::new(
            ((s_1015_4) >> (s_1015_2)).value(),
            u16::try_from(s_1015_8).unwrap(),
        ));
        // D s_1015_10: cast reint s_1015_9 -> u12
        let s_1015_10: u16 = (s_1015_9.value() as u16);
        // D s_1015_11: cast zx s_1015_10 -> bv
        let s_1015_11: Bits = Bits::new(s_1015_10 as u128, 12u16);
        // C s_1015_12: const #1775u : u12
        let s_1015_12: u16 = 1775;
        // C s_1015_13: cast zx s_1015_12 -> bv
        let s_1015_13: Bits = Bits::new(s_1015_12 as u128, 12u16);
        // D s_1015_14: cmp-eq s_1015_11 s_1015_13
        let s_1015_14: bool = ((s_1015_11) == (s_1015_13));
        // N s_1015_15: branch s_1015_14 b1047 b1016
        if s_1015_14 {
            return block_1047(state, tracer, fn_state);
        } else {
            return block_1016(state, tracer, fn_state);
        };
    }
    fn block_1016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1016_0: const #0u : u8
        let s_1016_0: bool = false;
        // D s_1016_1: write-var gs#411311 <= s_1016_0
        fn_state.gs_411311 = s_1016_0;
        // N s_1016_2: jump b1017
        return block_1017(state, tracer, fn_state);
    }
    fn block_1017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1017_0: read-var gs#411311:u8
        let s_1017_0: bool = fn_state.gs_411311;
        // N s_1017_1: branch s_1017_0 b1043 b1018
        if s_1017_0 {
            return block_1043(state, tracer, fn_state);
        } else {
            return block_1018(state, tracer, fn_state);
        };
    }
    fn block_1018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1018_0: const #0u : u8
        let s_1018_0: bool = false;
        // D s_1018_1: write-var gs#411316 <= s_1018_0
        fn_state.gs_411316 = s_1018_0;
        // N s_1018_2: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_1019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1019_0: read-var gs#411316:u8
        let s_1019_0: bool = fn_state.gs_411316;
        // D s_1019_1: not s_1019_0
        let s_1019_1: bool = !s_1019_0;
        // N s_1019_2: branch s_1019_1 b1026 b1020
        if s_1019_1 {
            return block_1026(state, tracer, fn_state);
        } else {
            return block_1020(state, tracer, fn_state);
        };
    }
    fn block_1020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1020_0: const #3344s : i
        let s_1020_0: i128 = 3344;
        // C s_1020_1: const #14696u : u32
        let s_1020_1: u32 = 14696;
        // N s_1020_2: write-reg s_1020_1 <= s_1020_0
        let s_1020_2: () = {
            state.write_register::<i128>(s_1020_1 as isize, s_1020_0);
            tracer.write_register(s_1020_1 as isize, s_1020_0);
        };
        // C s_1020_3: const #28s : i
        let s_1020_3: i128 = 28;
        // C s_1020_4: const #4s : i
        let s_1020_4: i128 = 4;
        // D s_1020_5: read-var u#33870:u32
        let s_1020_5: u32 = fn_state.u_33870;
        // D s_1020_6: cast zx s_1020_5 -> bv
        let s_1020_6: Bits = Bits::new(s_1020_5 as u128, 32u16);
        // D s_1020_7: bit-extract s_1020_6 s_1020_3 s_1020_4
        let s_1020_7: Bits = (Bits::new(
            ((s_1020_6) >> (s_1020_3)).value(),
            u16::try_from(s_1020_4).unwrap(),
        ));
        // D s_1020_8: cast reint s_1020_7 -> u8
        let s_1020_8: u8 = (s_1020_7.value() as u8);
        // D s_1020_9: write-var u#33871 <= s_1020_8
        fn_state.u_33871 = s_1020_8;
        // C s_1020_10: const #12s : i
        let s_1020_10: i128 = 12;
        // C s_1020_11: const #4s : i
        let s_1020_11: i128 = 4;
        // D s_1020_12: read-var u#33870:u32
        let s_1020_12: u32 = fn_state.u_33870;
        // D s_1020_13: cast zx s_1020_12 -> bv
        let s_1020_13: Bits = Bits::new(s_1020_12 as u128, 32u16);
        // D s_1020_14: bit-extract s_1020_13 s_1020_10 s_1020_11
        let s_1020_14: Bits = (Bits::new(
            ((s_1020_13) >> (s_1020_10)).value(),
            u16::try_from(s_1020_11).unwrap(),
        ));
        // D s_1020_15: cast reint s_1020_14 -> u8
        let s_1020_15: u8 = (s_1020_14.value() as u8);
        // D s_1020_16: write-var u#33872 <= s_1020_15
        fn_state.u_33872 = s_1020_15;
        // C s_1020_17: const #10s : i
        let s_1020_17: i128 = 10;
        // C s_1020_18: const #2s : i
        let s_1020_18: i128 = 2;
        // D s_1020_19: read-var u#33870:u32
        let s_1020_19: u32 = fn_state.u_33870;
        // D s_1020_20: cast zx s_1020_19 -> bv
        let s_1020_20: Bits = Bits::new(s_1020_19 as u128, 32u16);
        // D s_1020_21: bit-extract s_1020_20 s_1020_17 s_1020_18
        let s_1020_21: Bits = (Bits::new(
            ((s_1020_20) >> (s_1020_17)).value(),
            u16::try_from(s_1020_18).unwrap(),
        ));
        // D s_1020_22: cast reint s_1020_21 -> u8
        let s_1020_22: u8 = (s_1020_21.value() as u8);
        // D s_1020_23: write-var u#33873 <= s_1020_22
        fn_state.u_33873 = s_1020_22;
        // C s_1020_24: const #0s : i
        let s_1020_24: i128 = 0;
        // C s_1020_25: const #4s : i
        let s_1020_25: i128 = 4;
        // D s_1020_26: read-var u#33870:u32
        let s_1020_26: u32 = fn_state.u_33870;
        // D s_1020_27: cast zx s_1020_26 -> bv
        let s_1020_27: Bits = Bits::new(s_1020_26 as u128, 32u16);
        // D s_1020_28: bit-extract s_1020_27 s_1020_24 s_1020_25
        let s_1020_28: Bits = (Bits::new(
            ((s_1020_27) >> (s_1020_24)).value(),
            u16::try_from(s_1020_25).unwrap(),
        ));
        // D s_1020_29: cast reint s_1020_28 -> u8
        let s_1020_29: u8 = (s_1020_28.value() as u8);
        // D s_1020_30: write-var u#33874 <= s_1020_29
        fn_state.u_33874 = s_1020_29;
        // C s_1020_31: const #8s : i
        let s_1020_31: i128 = 8;
        // D s_1020_32: read-var u#33870:u32
        let s_1020_32: u32 = fn_state.u_33870;
        // D s_1020_33: cast zx s_1020_32 -> bv
        let s_1020_33: Bits = Bits::new(s_1020_32 as u128, 32u16);
        // C s_1020_34: const #1u : u64
        let s_1020_34: u64 = 1;
        // D s_1020_35: bit-extract s_1020_33 s_1020_31 s_1020_34
        let s_1020_35: Bits = (Bits::new(
            ((s_1020_33) >> (s_1020_31)).value(),
            u16::try_from(s_1020_34).unwrap(),
        ));
        // D s_1020_36: cast reint s_1020_35 -> u8
        let s_1020_36: bool = ((s_1020_35.value()) != 0);
        // C s_1020_37: const #0s : i
        let s_1020_37: i128 = 0;
        // C s_1020_38: const #0u : u64
        let s_1020_38: u64 = 0;
        // D s_1020_39: cast zx s_1020_36 -> u64
        let s_1020_39: u64 = (s_1020_36 as u64);
        // C s_1020_40: const #1u : u64
        let s_1020_40: u64 = 1;
        // D s_1020_41: and s_1020_39 s_1020_40
        let s_1020_41: u64 = ((s_1020_39) & (s_1020_40));
        // D s_1020_42: cmp-eq s_1020_41 s_1020_40
        let s_1020_42: bool = ((s_1020_41) == (s_1020_40));
        // D s_1020_43: lsl s_1020_39 s_1020_37
        let s_1020_43: u64 = s_1020_39 << s_1020_37;
        // D s_1020_44: or s_1020_38 s_1020_43
        let s_1020_44: u64 = ((s_1020_38) | (s_1020_43));
        // D s_1020_45: cmpl s_1020_43
        let s_1020_45: u64 = !s_1020_43;
        // D s_1020_46: and s_1020_38 s_1020_45
        let s_1020_46: u64 = ((s_1020_38) & (s_1020_45));
        // D s_1020_47: select s_1020_42 s_1020_44 s_1020_46
        let s_1020_47: u64 = if s_1020_42 { s_1020_44 } else { s_1020_46 };
        // D s_1020_48: cast trunc s_1020_47 -> u8
        let s_1020_48: bool = ((s_1020_47) != 0);
        // D s_1020_49: cast zx s_1020_48 -> bv
        let s_1020_49: Bits = Bits::new(s_1020_48 as u128, 1u16);
        // C s_1020_50: const #0u : u8
        let s_1020_50: bool = false;
        // C s_1020_51: cast zx s_1020_50 -> bv
        let s_1020_51: Bits = Bits::new(s_1020_50 as u128, 1u16);
        // D s_1020_52: cmp-ne s_1020_49 s_1020_51
        let s_1020_52: bool = ((s_1020_49) != (s_1020_51));
        // N s_1020_53: branch s_1020_52 b1025 b1021
        if s_1020_52 {
            return block_1025(state, tracer, fn_state);
        } else {
            return block_1021(state, tracer, fn_state);
        };
    }
    fn block_1021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1021_0: const #9s : i
        let s_1021_0: i128 = 9;
        // D s_1021_1: read-var u#33870:u32
        let s_1021_1: u32 = fn_state.u_33870;
        // D s_1021_2: cast zx s_1021_1 -> bv
        let s_1021_2: Bits = Bits::new(s_1021_1 as u128, 32u16);
        // C s_1021_3: const #1u : u64
        let s_1021_3: u64 = 1;
        // D s_1021_4: bit-extract s_1021_2 s_1021_0 s_1021_3
        let s_1021_4: Bits = (Bits::new(
            ((s_1021_2) >> (s_1021_0)).value(),
            u16::try_from(s_1021_3).unwrap(),
        ));
        // D s_1021_5: cast reint s_1021_4 -> u8
        let s_1021_5: bool = ((s_1021_4.value()) != 0);
        // C s_1021_6: const #0s : i
        let s_1021_6: i128 = 0;
        // C s_1021_7: const #0u : u64
        let s_1021_7: u64 = 0;
        // D s_1021_8: cast zx s_1021_5 -> u64
        let s_1021_8: u64 = (s_1021_5 as u64);
        // C s_1021_9: const #1u : u64
        let s_1021_9: u64 = 1;
        // D s_1021_10: and s_1021_8 s_1021_9
        let s_1021_10: u64 = ((s_1021_8) & (s_1021_9));
        // D s_1021_11: cmp-eq s_1021_10 s_1021_9
        let s_1021_11: bool = ((s_1021_10) == (s_1021_9));
        // D s_1021_12: lsl s_1021_8 s_1021_6
        let s_1021_12: u64 = s_1021_8 << s_1021_6;
        // D s_1021_13: or s_1021_7 s_1021_12
        let s_1021_13: u64 = ((s_1021_7) | (s_1021_12));
        // D s_1021_14: cmpl s_1021_12
        let s_1021_14: u64 = !s_1021_12;
        // D s_1021_15: and s_1021_7 s_1021_14
        let s_1021_15: u64 = ((s_1021_7) & (s_1021_14));
        // D s_1021_16: select s_1021_11 s_1021_13 s_1021_15
        let s_1021_16: u64 = if s_1021_11 { s_1021_13 } else { s_1021_15 };
        // D s_1021_17: cast trunc s_1021_16 -> u8
        let s_1021_17: bool = ((s_1021_16) != 0);
        // D s_1021_18: cast zx s_1021_17 -> bv
        let s_1021_18: Bits = Bits::new(s_1021_17 as u128, 1u16);
        // C s_1021_19: const #0u : u8
        let s_1021_19: bool = false;
        // C s_1021_20: cast zx s_1021_19 -> bv
        let s_1021_20: Bits = Bits::new(s_1021_19 as u128, 1u16);
        // D s_1021_21: cmp-ne s_1021_18 s_1021_20
        let s_1021_21: bool = ((s_1021_18) != (s_1021_20));
        // D s_1021_22: write-var gs#411331 <= s_1021_21
        fn_state.gs_411331 = s_1021_21;
        // N s_1021_23: jump b1022
        return block_1022(state, tracer, fn_state);
    }
    fn block_1022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1022_0: read-var gs#411331:u8
        let s_1022_0: bool = fn_state.gs_411331;
        // N s_1022_1: branch s_1022_0 b1024 b1023
        if s_1022_0 {
            return block_1024(state, tracer, fn_state);
        } else {
            return block_1023(state, tracer, fn_state);
        };
    }
    fn block_1023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1023_0: read-var u#33871:u8
        let s_1023_0: u8 = fn_state.u_33871;
        // D s_1023_1: read-var u#33872:u8
        let s_1023_1: u8 = fn_state.u_33872;
        // D s_1023_2: read-var u#33873:u8
        let s_1023_2: u8 = fn_state.u_33873;
        // D s_1023_3: read-var u#33874:u8
        let s_1023_3: u8 = fn_state.u_33874;
        // D s_1023_4: call decode_aarch32_instrs_UXTB_A1enc_A_txt(s_1023_0, s_1023_1, s_1023_2, s_1023_3)
        let s_1023_4: () = decode_aarch32_instrs_UXTB_A1enc_A_txt(
            state,
            tracer,
            s_1023_0,
            s_1023_1,
            s_1023_2,
            s_1023_3,
        );
        // N s_1023_5: return
        return;
    }
    fn block_1024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1024_0: panic
        panic!("{:?}", ());
        // N s_1024_1: return
        return;
    }
    fn block_1025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1025_0: const #1u : u8
        let s_1025_0: bool = true;
        // D s_1025_1: write-var gs#411331 <= s_1025_0
        fn_state.gs_411331 = s_1025_0;
        // N s_1025_2: jump b1022
        return block_1022(state, tracer, fn_state);
    }
    fn block_1026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1026_0: read-var merge#var.1:struct
        let s_1026_0: u32 = fn_state.merge_var._1;
        // D s_1026_1: write-var u#33876 <= s_1026_0
        fn_state.u_33876 = s_1026_0;
        // C s_1026_2: const #16s : i
        let s_1026_2: i128 = 16;
        // D s_1026_3: read-var u#33876:u32
        let s_1026_3: u32 = fn_state.u_33876;
        // D s_1026_4: cast zx s_1026_3 -> bv
        let s_1026_4: Bits = Bits::new(s_1026_3 as u128, 32u16);
        // C s_1026_5: const #1s : i64
        let s_1026_5: i64 = 1;
        // C s_1026_6: cast zx s_1026_5 -> i
        let s_1026_6: i128 = (i128::try_from(s_1026_5).unwrap());
        // C s_1026_7: const #11s : i
        let s_1026_7: i128 = 11;
        // C s_1026_8: add s_1026_7 s_1026_6
        let s_1026_8: i128 = (s_1026_7 + s_1026_6);
        // D s_1026_9: bit-extract s_1026_4 s_1026_2 s_1026_8
        let s_1026_9: Bits = (Bits::new(
            ((s_1026_4) >> (s_1026_2)).value(),
            u16::try_from(s_1026_8).unwrap(),
        ));
        // D s_1026_10: cast reint s_1026_9 -> u12
        let s_1026_10: u16 = (s_1026_9.value() as u16);
        // D s_1026_11: cast zx s_1026_10 -> bv
        let s_1026_11: Bits = Bits::new(s_1026_10 as u128, 12u16);
        // C s_1026_12: const #1791u : u12
        let s_1026_12: u16 = 1791;
        // C s_1026_13: cast zx s_1026_12 -> bv
        let s_1026_13: Bits = Bits::new(s_1026_12 as u128, 12u16);
        // D s_1026_14: cmp-eq s_1026_11 s_1026_13
        let s_1026_14: bool = ((s_1026_11) == (s_1026_13));
        // N s_1026_15: branch s_1026_14 b1042 b1027
        if s_1026_14 {
            return block_1042(state, tracer, fn_state);
        } else {
            return block_1027(state, tracer, fn_state);
        };
    }
    fn block_1027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1027_0: const #0u : u8
        let s_1027_0: bool = false;
        // D s_1027_1: write-var gs#411337 <= s_1027_0
        fn_state.gs_411337 = s_1027_0;
        // N s_1027_2: jump b1028
        return block_1028(state, tracer, fn_state);
    }
    fn block_1028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1028_0: read-var gs#411337:u8
        let s_1028_0: bool = fn_state.gs_411337;
        // N s_1028_1: branch s_1028_0 b1038 b1029
        if s_1028_0 {
            return block_1038(state, tracer, fn_state);
        } else {
            return block_1029(state, tracer, fn_state);
        };
    }
    fn block_1029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1029_0: const #0u : u8
        let s_1029_0: bool = false;
        // D s_1029_1: write-var gs#411342 <= s_1029_0
        fn_state.gs_411342 = s_1029_0;
        // N s_1029_2: jump b1030
        return block_1030(state, tracer, fn_state);
    }
    fn block_1030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1030_0: read-var gs#411342:u8
        let s_1030_0: bool = fn_state.gs_411342;
        // D s_1030_1: not s_1030_0
        let s_1030_1: bool = !s_1030_0;
        // N s_1030_2: branch s_1030_1 b1037 b1031
        if s_1030_1 {
            return block_1037(state, tracer, fn_state);
        } else {
            return block_1031(state, tracer, fn_state);
        };
    }
    fn block_1031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1031_0: const #3347s : i
        let s_1031_0: i128 = 3347;
        // C s_1031_1: const #14696u : u32
        let s_1031_1: u32 = 14696;
        // N s_1031_2: write-reg s_1031_1 <= s_1031_0
        let s_1031_2: () = {
            state.write_register::<i128>(s_1031_1 as isize, s_1031_0);
            tracer.write_register(s_1031_1 as isize, s_1031_0);
        };
        // C s_1031_3: const #28s : i
        let s_1031_3: i128 = 28;
        // C s_1031_4: const #4s : i
        let s_1031_4: i128 = 4;
        // D s_1031_5: read-var u#33876:u32
        let s_1031_5: u32 = fn_state.u_33876;
        // D s_1031_6: cast zx s_1031_5 -> bv
        let s_1031_6: Bits = Bits::new(s_1031_5 as u128, 32u16);
        // D s_1031_7: bit-extract s_1031_6 s_1031_3 s_1031_4
        let s_1031_7: Bits = (Bits::new(
            ((s_1031_6) >> (s_1031_3)).value(),
            u16::try_from(s_1031_4).unwrap(),
        ));
        // D s_1031_8: cast reint s_1031_7 -> u8
        let s_1031_8: u8 = (s_1031_7.value() as u8);
        // D s_1031_9: write-var u#33877 <= s_1031_8
        fn_state.u_33877 = s_1031_8;
        // C s_1031_10: const #12s : i
        let s_1031_10: i128 = 12;
        // C s_1031_11: const #4s : i
        let s_1031_11: i128 = 4;
        // D s_1031_12: read-var u#33876:u32
        let s_1031_12: u32 = fn_state.u_33876;
        // D s_1031_13: cast zx s_1031_12 -> bv
        let s_1031_13: Bits = Bits::new(s_1031_12 as u128, 32u16);
        // D s_1031_14: bit-extract s_1031_13 s_1031_10 s_1031_11
        let s_1031_14: Bits = (Bits::new(
            ((s_1031_13) >> (s_1031_10)).value(),
            u16::try_from(s_1031_11).unwrap(),
        ));
        // D s_1031_15: cast reint s_1031_14 -> u8
        let s_1031_15: u8 = (s_1031_14.value() as u8);
        // D s_1031_16: write-var u#33878 <= s_1031_15
        fn_state.u_33878 = s_1031_15;
        // C s_1031_17: const #10s : i
        let s_1031_17: i128 = 10;
        // C s_1031_18: const #2s : i
        let s_1031_18: i128 = 2;
        // D s_1031_19: read-var u#33876:u32
        let s_1031_19: u32 = fn_state.u_33876;
        // D s_1031_20: cast zx s_1031_19 -> bv
        let s_1031_20: Bits = Bits::new(s_1031_19 as u128, 32u16);
        // D s_1031_21: bit-extract s_1031_20 s_1031_17 s_1031_18
        let s_1031_21: Bits = (Bits::new(
            ((s_1031_20) >> (s_1031_17)).value(),
            u16::try_from(s_1031_18).unwrap(),
        ));
        // D s_1031_22: cast reint s_1031_21 -> u8
        let s_1031_22: u8 = (s_1031_21.value() as u8);
        // D s_1031_23: write-var u#33879 <= s_1031_22
        fn_state.u_33879 = s_1031_22;
        // C s_1031_24: const #0s : i
        let s_1031_24: i128 = 0;
        // C s_1031_25: const #4s : i
        let s_1031_25: i128 = 4;
        // D s_1031_26: read-var u#33876:u32
        let s_1031_26: u32 = fn_state.u_33876;
        // D s_1031_27: cast zx s_1031_26 -> bv
        let s_1031_27: Bits = Bits::new(s_1031_26 as u128, 32u16);
        // D s_1031_28: bit-extract s_1031_27 s_1031_24 s_1031_25
        let s_1031_28: Bits = (Bits::new(
            ((s_1031_27) >> (s_1031_24)).value(),
            u16::try_from(s_1031_25).unwrap(),
        ));
        // D s_1031_29: cast reint s_1031_28 -> u8
        let s_1031_29: u8 = (s_1031_28.value() as u8);
        // D s_1031_30: write-var u#33880 <= s_1031_29
        fn_state.u_33880 = s_1031_29;
        // C s_1031_31: const #8s : i
        let s_1031_31: i128 = 8;
        // D s_1031_32: read-var u#33876:u32
        let s_1031_32: u32 = fn_state.u_33876;
        // D s_1031_33: cast zx s_1031_32 -> bv
        let s_1031_33: Bits = Bits::new(s_1031_32 as u128, 32u16);
        // C s_1031_34: const #1u : u64
        let s_1031_34: u64 = 1;
        // D s_1031_35: bit-extract s_1031_33 s_1031_31 s_1031_34
        let s_1031_35: Bits = (Bits::new(
            ((s_1031_33) >> (s_1031_31)).value(),
            u16::try_from(s_1031_34).unwrap(),
        ));
        // D s_1031_36: cast reint s_1031_35 -> u8
        let s_1031_36: bool = ((s_1031_35.value()) != 0);
        // C s_1031_37: const #0s : i
        let s_1031_37: i128 = 0;
        // C s_1031_38: const #0u : u64
        let s_1031_38: u64 = 0;
        // D s_1031_39: cast zx s_1031_36 -> u64
        let s_1031_39: u64 = (s_1031_36 as u64);
        // C s_1031_40: const #1u : u64
        let s_1031_40: u64 = 1;
        // D s_1031_41: and s_1031_39 s_1031_40
        let s_1031_41: u64 = ((s_1031_39) & (s_1031_40));
        // D s_1031_42: cmp-eq s_1031_41 s_1031_40
        let s_1031_42: bool = ((s_1031_41) == (s_1031_40));
        // D s_1031_43: lsl s_1031_39 s_1031_37
        let s_1031_43: u64 = s_1031_39 << s_1031_37;
        // D s_1031_44: or s_1031_38 s_1031_43
        let s_1031_44: u64 = ((s_1031_38) | (s_1031_43));
        // D s_1031_45: cmpl s_1031_43
        let s_1031_45: u64 = !s_1031_43;
        // D s_1031_46: and s_1031_38 s_1031_45
        let s_1031_46: u64 = ((s_1031_38) & (s_1031_45));
        // D s_1031_47: select s_1031_42 s_1031_44 s_1031_46
        let s_1031_47: u64 = if s_1031_42 { s_1031_44 } else { s_1031_46 };
        // D s_1031_48: cast trunc s_1031_47 -> u8
        let s_1031_48: bool = ((s_1031_47) != 0);
        // D s_1031_49: cast zx s_1031_48 -> bv
        let s_1031_49: Bits = Bits::new(s_1031_48 as u128, 1u16);
        // C s_1031_50: const #0u : u8
        let s_1031_50: bool = false;
        // C s_1031_51: cast zx s_1031_50 -> bv
        let s_1031_51: Bits = Bits::new(s_1031_50 as u128, 1u16);
        // D s_1031_52: cmp-ne s_1031_49 s_1031_51
        let s_1031_52: bool = ((s_1031_49) != (s_1031_51));
        // N s_1031_53: branch s_1031_52 b1036 b1032
        if s_1031_52 {
            return block_1036(state, tracer, fn_state);
        } else {
            return block_1032(state, tracer, fn_state);
        };
    }
    fn block_1032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1032_0: const #9s : i
        let s_1032_0: i128 = 9;
        // D s_1032_1: read-var u#33876:u32
        let s_1032_1: u32 = fn_state.u_33876;
        // D s_1032_2: cast zx s_1032_1 -> bv
        let s_1032_2: Bits = Bits::new(s_1032_1 as u128, 32u16);
        // C s_1032_3: const #1u : u64
        let s_1032_3: u64 = 1;
        // D s_1032_4: bit-extract s_1032_2 s_1032_0 s_1032_3
        let s_1032_4: Bits = (Bits::new(
            ((s_1032_2) >> (s_1032_0)).value(),
            u16::try_from(s_1032_3).unwrap(),
        ));
        // D s_1032_5: cast reint s_1032_4 -> u8
        let s_1032_5: bool = ((s_1032_4.value()) != 0);
        // C s_1032_6: const #0s : i
        let s_1032_6: i128 = 0;
        // C s_1032_7: const #0u : u64
        let s_1032_7: u64 = 0;
        // D s_1032_8: cast zx s_1032_5 -> u64
        let s_1032_8: u64 = (s_1032_5 as u64);
        // C s_1032_9: const #1u : u64
        let s_1032_9: u64 = 1;
        // D s_1032_10: and s_1032_8 s_1032_9
        let s_1032_10: u64 = ((s_1032_8) & (s_1032_9));
        // D s_1032_11: cmp-eq s_1032_10 s_1032_9
        let s_1032_11: bool = ((s_1032_10) == (s_1032_9));
        // D s_1032_12: lsl s_1032_8 s_1032_6
        let s_1032_12: u64 = s_1032_8 << s_1032_6;
        // D s_1032_13: or s_1032_7 s_1032_12
        let s_1032_13: u64 = ((s_1032_7) | (s_1032_12));
        // D s_1032_14: cmpl s_1032_12
        let s_1032_14: u64 = !s_1032_12;
        // D s_1032_15: and s_1032_7 s_1032_14
        let s_1032_15: u64 = ((s_1032_7) & (s_1032_14));
        // D s_1032_16: select s_1032_11 s_1032_13 s_1032_15
        let s_1032_16: u64 = if s_1032_11 { s_1032_13 } else { s_1032_15 };
        // D s_1032_17: cast trunc s_1032_16 -> u8
        let s_1032_17: bool = ((s_1032_16) != 0);
        // D s_1032_18: cast zx s_1032_17 -> bv
        let s_1032_18: Bits = Bits::new(s_1032_17 as u128, 1u16);
        // C s_1032_19: const #0u : u8
        let s_1032_19: bool = false;
        // C s_1032_20: cast zx s_1032_19 -> bv
        let s_1032_20: Bits = Bits::new(s_1032_19 as u128, 1u16);
        // D s_1032_21: cmp-ne s_1032_18 s_1032_20
        let s_1032_21: bool = ((s_1032_18) != (s_1032_20));
        // D s_1032_22: write-var gs#411357 <= s_1032_21
        fn_state.gs_411357 = s_1032_21;
        // N s_1032_23: jump b1033
        return block_1033(state, tracer, fn_state);
    }
    fn block_1033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1033_0: read-var gs#411357:u8
        let s_1033_0: bool = fn_state.gs_411357;
        // N s_1033_1: branch s_1033_0 b1035 b1034
        if s_1033_0 {
            return block_1035(state, tracer, fn_state);
        } else {
            return block_1034(state, tracer, fn_state);
        };
    }
    fn block_1034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1034_0: read-var u#33877:u8
        let s_1034_0: u8 = fn_state.u_33877;
        // D s_1034_1: read-var u#33878:u8
        let s_1034_1: u8 = fn_state.u_33878;
        // D s_1034_2: read-var u#33879:u8
        let s_1034_2: u8 = fn_state.u_33879;
        // D s_1034_3: read-var u#33880:u8
        let s_1034_3: u8 = fn_state.u_33880;
        // D s_1034_4: call decode_aarch32_instrs_UXTH_A1enc_A_txt(s_1034_0, s_1034_1, s_1034_2, s_1034_3)
        let s_1034_4: () = decode_aarch32_instrs_UXTH_A1enc_A_txt(
            state,
            tracer,
            s_1034_0,
            s_1034_1,
            s_1034_2,
            s_1034_3,
        );
        // N s_1034_5: return
        return;
    }
    fn block_1035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1035_0: panic
        panic!("{:?}", ());
        // N s_1035_1: return
        return;
    }
    fn block_1036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1036_0: const #1u : u8
        let s_1036_0: bool = true;
        // D s_1036_1: write-var gs#411357 <= s_1036_0
        fn_state.gs_411357 = s_1036_0;
        // N s_1036_2: jump b1033
        return block_1033(state, tracer, fn_state);
    }
    fn block_1037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1037_0: panic
        panic!("{:?}", ());
        // N s_1037_1: return
        return;
    }
    fn block_1038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1038_0: const #28s : i
        let s_1038_0: i128 = 28;
        // C s_1038_1: const #4s : i
        let s_1038_1: i128 = 4;
        // D s_1038_2: read-var u#33876:u32
        let s_1038_2: u32 = fn_state.u_33876;
        // D s_1038_3: cast zx s_1038_2 -> bv
        let s_1038_3: Bits = Bits::new(s_1038_2 as u128, 32u16);
        // D s_1038_4: bit-extract s_1038_3 s_1038_0 s_1038_1
        let s_1038_4: Bits = (Bits::new(
            ((s_1038_3) >> (s_1038_0)).value(),
            u16::try_from(s_1038_1).unwrap(),
        ));
        // D s_1038_5: cast reint s_1038_4 -> u8
        let s_1038_5: u8 = (s_1038_4.value() as u8);
        // D s_1038_6: cast zx s_1038_5 -> bv
        let s_1038_6: Bits = Bits::new(s_1038_5 as u128, 4u16);
        // C s_1038_7: const #15u : u8
        let s_1038_7: u8 = 15;
        // C s_1038_8: cast zx s_1038_7 -> bv
        let s_1038_8: Bits = Bits::new(s_1038_7 as u128, 4u16);
        // D s_1038_9: cmp-ne s_1038_6 s_1038_8
        let s_1038_9: bool = ((s_1038_6) != (s_1038_8));
        // N s_1038_10: branch s_1038_9 b1041 b1039
        if s_1038_9 {
            return block_1041(state, tracer, fn_state);
        } else {
            return block_1039(state, tracer, fn_state);
        };
    }
    fn block_1039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1039_0: const #0u : u8
        let s_1039_0: bool = false;
        // D s_1039_1: write-var gs#411341 <= s_1039_0
        fn_state.gs_411341 = s_1039_0;
        // N s_1039_2: jump b1040
        return block_1040(state, tracer, fn_state);
    }
    fn block_1040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1040_0: read-var gs#411341:u8
        let s_1040_0: bool = fn_state.gs_411341;
        // D s_1040_1: write-var gs#411342 <= s_1040_0
        fn_state.gs_411342 = s_1040_0;
        // N s_1040_2: jump b1030
        return block_1030(state, tracer, fn_state);
    }
    fn block_1041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1041_0: const #3347s : i
        let s_1041_0: i128 = 3347;
        // C s_1041_1: const #14696u : u32
        let s_1041_1: u32 = 14696;
        // D s_1041_2: read-reg s_1041_1:i
        let s_1041_2: i128 = {
            let value = state.read_register::<i128>(s_1041_1 as isize);
            tracer.read_register(s_1041_1 as isize, value);
            value
        };
        // D s_1041_3: cmp-lt s_1041_2 s_1041_0
        let s_1041_3: bool = ((s_1041_2) < (s_1041_0));
        // D s_1041_4: write-var gs#411341 <= s_1041_3
        fn_state.gs_411341 = s_1041_3;
        // N s_1041_5: jump b1040
        return block_1040(state, tracer, fn_state);
    }
    fn block_1042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1042_0: const #4s : i
        let s_1042_0: i128 = 4;
        // D s_1042_1: read-var u#33876:u32
        let s_1042_1: u32 = fn_state.u_33876;
        // D s_1042_2: cast zx s_1042_1 -> bv
        let s_1042_2: Bits = Bits::new(s_1042_1 as u128, 32u16);
        // C s_1042_3: const #1s : i64
        let s_1042_3: i64 = 1;
        // C s_1042_4: cast zx s_1042_3 -> i
        let s_1042_4: i128 = (i128::try_from(s_1042_3).unwrap());
        // C s_1042_5: const #5s : i
        let s_1042_5: i128 = 5;
        // C s_1042_6: add s_1042_5 s_1042_4
        let s_1042_6: i128 = (s_1042_5 + s_1042_4);
        // D s_1042_7: bit-extract s_1042_2 s_1042_0 s_1042_6
        let s_1042_7: Bits = (Bits::new(
            ((s_1042_2) >> (s_1042_0)).value(),
            u16::try_from(s_1042_6).unwrap(),
        ));
        // D s_1042_8: cast reint s_1042_7 -> u8
        let s_1042_8: u8 = (s_1042_7.value() as u8);
        // D s_1042_9: cast zx s_1042_8 -> bv
        let s_1042_9: Bits = Bits::new(s_1042_8 as u128, 6u16);
        // C s_1042_10: const #7u : u8
        let s_1042_10: u8 = 7;
        // C s_1042_11: cast zx s_1042_10 -> bv
        let s_1042_11: Bits = Bits::new(s_1042_10 as u128, 6u16);
        // D s_1042_12: cmp-eq s_1042_9 s_1042_11
        let s_1042_12: bool = ((s_1042_9) == (s_1042_11));
        // D s_1042_13: write-var gs#411337 <= s_1042_12
        fn_state.gs_411337 = s_1042_12;
        // N s_1042_14: jump b1028
        return block_1028(state, tracer, fn_state);
    }
    fn block_1043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1043_0: const #28s : i
        let s_1043_0: i128 = 28;
        // C s_1043_1: const #4s : i
        let s_1043_1: i128 = 4;
        // D s_1043_2: read-var u#33870:u32
        let s_1043_2: u32 = fn_state.u_33870;
        // D s_1043_3: cast zx s_1043_2 -> bv
        let s_1043_3: Bits = Bits::new(s_1043_2 as u128, 32u16);
        // D s_1043_4: bit-extract s_1043_3 s_1043_0 s_1043_1
        let s_1043_4: Bits = (Bits::new(
            ((s_1043_3) >> (s_1043_0)).value(),
            u16::try_from(s_1043_1).unwrap(),
        ));
        // D s_1043_5: cast reint s_1043_4 -> u8
        let s_1043_5: u8 = (s_1043_4.value() as u8);
        // D s_1043_6: cast zx s_1043_5 -> bv
        let s_1043_6: Bits = Bits::new(s_1043_5 as u128, 4u16);
        // C s_1043_7: const #15u : u8
        let s_1043_7: u8 = 15;
        // C s_1043_8: cast zx s_1043_7 -> bv
        let s_1043_8: Bits = Bits::new(s_1043_7 as u128, 4u16);
        // D s_1043_9: cmp-ne s_1043_6 s_1043_8
        let s_1043_9: bool = ((s_1043_6) != (s_1043_8));
        // N s_1043_10: branch s_1043_9 b1046 b1044
        if s_1043_9 {
            return block_1046(state, tracer, fn_state);
        } else {
            return block_1044(state, tracer, fn_state);
        };
    }
    fn block_1044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1044_0: const #0u : u8
        let s_1044_0: bool = false;
        // D s_1044_1: write-var gs#411315 <= s_1044_0
        fn_state.gs_411315 = s_1044_0;
        // N s_1044_2: jump b1045
        return block_1045(state, tracer, fn_state);
    }
    fn block_1045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1045_0: read-var gs#411315:u8
        let s_1045_0: bool = fn_state.gs_411315;
        // D s_1045_1: write-var gs#411316 <= s_1045_0
        fn_state.gs_411316 = s_1045_0;
        // N s_1045_2: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_1046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1046_0: const #3344s : i
        let s_1046_0: i128 = 3344;
        // C s_1046_1: const #14696u : u32
        let s_1046_1: u32 = 14696;
        // D s_1046_2: read-reg s_1046_1:i
        let s_1046_2: i128 = {
            let value = state.read_register::<i128>(s_1046_1 as isize);
            tracer.read_register(s_1046_1 as isize, value);
            value
        };
        // D s_1046_3: cmp-lt s_1046_2 s_1046_0
        let s_1046_3: bool = ((s_1046_2) < (s_1046_0));
        // D s_1046_4: write-var gs#411315 <= s_1046_3
        fn_state.gs_411315 = s_1046_3;
        // N s_1046_5: jump b1045
        return block_1045(state, tracer, fn_state);
    }
    fn block_1047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1047_0: const #4s : i
        let s_1047_0: i128 = 4;
        // D s_1047_1: read-var u#33870:u32
        let s_1047_1: u32 = fn_state.u_33870;
        // D s_1047_2: cast zx s_1047_1 -> bv
        let s_1047_2: Bits = Bits::new(s_1047_1 as u128, 32u16);
        // C s_1047_3: const #1s : i64
        let s_1047_3: i64 = 1;
        // C s_1047_4: cast zx s_1047_3 -> i
        let s_1047_4: i128 = (i128::try_from(s_1047_3).unwrap());
        // C s_1047_5: const #5s : i
        let s_1047_5: i128 = 5;
        // C s_1047_6: add s_1047_5 s_1047_4
        let s_1047_6: i128 = (s_1047_5 + s_1047_4);
        // D s_1047_7: bit-extract s_1047_2 s_1047_0 s_1047_6
        let s_1047_7: Bits = (Bits::new(
            ((s_1047_2) >> (s_1047_0)).value(),
            u16::try_from(s_1047_6).unwrap(),
        ));
        // D s_1047_8: cast reint s_1047_7 -> u8
        let s_1047_8: u8 = (s_1047_7.value() as u8);
        // D s_1047_9: cast zx s_1047_8 -> bv
        let s_1047_9: Bits = Bits::new(s_1047_8 as u128, 6u16);
        // C s_1047_10: const #7u : u8
        let s_1047_10: u8 = 7;
        // C s_1047_11: cast zx s_1047_10 -> bv
        let s_1047_11: Bits = Bits::new(s_1047_10 as u128, 6u16);
        // D s_1047_12: cmp-eq s_1047_9 s_1047_11
        let s_1047_12: bool = ((s_1047_9) == (s_1047_11));
        // D s_1047_13: write-var gs#411311 <= s_1047_12
        fn_state.gs_411311 = s_1047_12;
        // N s_1047_14: jump b1017
        return block_1017(state, tracer, fn_state);
    }
    fn block_1048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1048_0: const #28s : i
        let s_1048_0: i128 = 28;
        // C s_1048_1: const #4s : i
        let s_1048_1: i128 = 4;
        // D s_1048_2: read-var u#33864:u32
        let s_1048_2: u32 = fn_state.u_33864;
        // D s_1048_3: cast zx s_1048_2 -> bv
        let s_1048_3: Bits = Bits::new(s_1048_2 as u128, 32u16);
        // D s_1048_4: bit-extract s_1048_3 s_1048_0 s_1048_1
        let s_1048_4: Bits = (Bits::new(
            ((s_1048_3) >> (s_1048_0)).value(),
            u16::try_from(s_1048_1).unwrap(),
        ));
        // D s_1048_5: cast reint s_1048_4 -> u8
        let s_1048_5: u8 = (s_1048_4.value() as u8);
        // D s_1048_6: cast zx s_1048_5 -> bv
        let s_1048_6: Bits = Bits::new(s_1048_5 as u128, 4u16);
        // C s_1048_7: const #15u : u8
        let s_1048_7: u8 = 15;
        // C s_1048_8: cast zx s_1048_7 -> bv
        let s_1048_8: Bits = Bits::new(s_1048_7 as u128, 4u16);
        // D s_1048_9: cmp-ne s_1048_6 s_1048_8
        let s_1048_9: bool = ((s_1048_6) != (s_1048_8));
        // N s_1048_10: branch s_1048_9 b1051 b1049
        if s_1048_9 {
            return block_1051(state, tracer, fn_state);
        } else {
            return block_1049(state, tracer, fn_state);
        };
    }
    fn block_1049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1049_0: const #0u : u8
        let s_1049_0: bool = false;
        // D s_1049_1: write-var gs#411289 <= s_1049_0
        fn_state.gs_411289 = s_1049_0;
        // N s_1049_2: jump b1050
        return block_1050(state, tracer, fn_state);
    }
    fn block_1050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1050_0: read-var gs#411289:u8
        let s_1050_0: bool = fn_state.gs_411289;
        // D s_1050_1: write-var gs#411290 <= s_1050_0
        fn_state.gs_411290 = s_1050_0;
        // N s_1050_2: jump b1008
        return block_1008(state, tracer, fn_state);
    }
    fn block_1051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1051_0: const #3342s : i
        let s_1051_0: i128 = 3342;
        // C s_1051_1: const #14696u : u32
        let s_1051_1: u32 = 14696;
        // D s_1051_2: read-reg s_1051_1:i
        let s_1051_2: i128 = {
            let value = state.read_register::<i128>(s_1051_1 as isize);
            tracer.read_register(s_1051_1 as isize, value);
            value
        };
        // D s_1051_3: cmp-lt s_1051_2 s_1051_0
        let s_1051_3: bool = ((s_1051_2) < (s_1051_0));
        // D s_1051_4: write-var gs#411289 <= s_1051_3
        fn_state.gs_411289 = s_1051_3;
        // N s_1051_5: jump b1050
        return block_1050(state, tracer, fn_state);
    }
    fn block_1052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1052_0: const #4s : i
        let s_1052_0: i128 = 4;
        // D s_1052_1: read-var u#33864:u32
        let s_1052_1: u32 = fn_state.u_33864;
        // D s_1052_2: cast zx s_1052_1 -> bv
        let s_1052_2: Bits = Bits::new(s_1052_1 as u128, 32u16);
        // C s_1052_3: const #1s : i64
        let s_1052_3: i64 = 1;
        // C s_1052_4: cast zx s_1052_3 -> i
        let s_1052_4: i128 = (i128::try_from(s_1052_3).unwrap());
        // C s_1052_5: const #5s : i
        let s_1052_5: i128 = 5;
        // C s_1052_6: add s_1052_5 s_1052_4
        let s_1052_6: i128 = (s_1052_5 + s_1052_4);
        // D s_1052_7: bit-extract s_1052_2 s_1052_0 s_1052_6
        let s_1052_7: Bits = (Bits::new(
            ((s_1052_2) >> (s_1052_0)).value(),
            u16::try_from(s_1052_6).unwrap(),
        ));
        // D s_1052_8: cast reint s_1052_7 -> u8
        let s_1052_8: u8 = (s_1052_7.value() as u8);
        // D s_1052_9: cast zx s_1052_8 -> bv
        let s_1052_9: Bits = Bits::new(s_1052_8 as u128, 6u16);
        // C s_1052_10: const #7u : u8
        let s_1052_10: u8 = 7;
        // C s_1052_11: cast zx s_1052_10 -> bv
        let s_1052_11: Bits = Bits::new(s_1052_10 as u128, 6u16);
        // D s_1052_12: cmp-eq s_1052_9 s_1052_11
        let s_1052_12: bool = ((s_1052_9) == (s_1052_11));
        // D s_1052_13: write-var gs#411285 <= s_1052_12
        fn_state.gs_411285 = s_1052_12;
        // N s_1052_14: jump b1006
        return block_1006(state, tracer, fn_state);
    }
    fn block_1053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1053_0: const #28s : i
        let s_1053_0: i128 = 28;
        // C s_1053_1: const #4s : i
        let s_1053_1: i128 = 4;
        // D s_1053_2: read-var u#33857:u32
        let s_1053_2: u32 = fn_state.u_33857;
        // D s_1053_3: cast zx s_1053_2 -> bv
        let s_1053_3: Bits = Bits::new(s_1053_2 as u128, 32u16);
        // D s_1053_4: bit-extract s_1053_3 s_1053_0 s_1053_1
        let s_1053_4: Bits = (Bits::new(
            ((s_1053_3) >> (s_1053_0)).value(),
            u16::try_from(s_1053_1).unwrap(),
        ));
        // D s_1053_5: cast reint s_1053_4 -> u8
        let s_1053_5: u8 = (s_1053_4.value() as u8);
        // D s_1053_6: cast zx s_1053_5 -> bv
        let s_1053_6: Bits = Bits::new(s_1053_5 as u128, 4u16);
        // C s_1053_7: const #15u : u8
        let s_1053_7: u8 = 15;
        // C s_1053_8: cast zx s_1053_7 -> bv
        let s_1053_8: Bits = Bits::new(s_1053_7 as u128, 4u16);
        // D s_1053_9: cmp-ne s_1053_6 s_1053_8
        let s_1053_9: bool = ((s_1053_6) != (s_1053_8));
        // N s_1053_10: branch s_1053_9 b1056 b1054
        if s_1053_9 {
            return block_1056(state, tracer, fn_state);
        } else {
            return block_1054(state, tracer, fn_state);
        };
    }
    fn block_1054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1054_0: const #0u : u8
        let s_1054_0: bool = false;
        // D s_1054_1: write-var gs#411261 <= s_1054_0
        fn_state.gs_411261 = s_1054_0;
        // N s_1054_2: jump b1055
        return block_1055(state, tracer, fn_state);
    }
    fn block_1055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1055_0: read-var gs#411261:u8
        let s_1055_0: bool = fn_state.gs_411261;
        // D s_1055_1: write-var gs#411262 <= s_1055_0
        fn_state.gs_411262 = s_1055_0;
        // N s_1055_2: jump b997
        return block_997(state, tracer, fn_state);
    }
    fn block_1056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1056_0: const #3340s : i
        let s_1056_0: i128 = 3340;
        // C s_1056_1: const #14696u : u32
        let s_1056_1: u32 = 14696;
        // D s_1056_2: read-reg s_1056_1:i
        let s_1056_2: i128 = {
            let value = state.read_register::<i128>(s_1056_1 as isize);
            tracer.read_register(s_1056_1 as isize, value);
            value
        };
        // D s_1056_3: cmp-lt s_1056_2 s_1056_0
        let s_1056_3: bool = ((s_1056_2) < (s_1056_0));
        // D s_1056_4: write-var gs#411261 <= s_1056_3
        fn_state.gs_411261 = s_1056_3;
        // N s_1056_5: jump b1055
        return block_1055(state, tracer, fn_state);
    }
    fn block_1057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1057_0: const #4s : i
        let s_1057_0: i128 = 4;
        // D s_1057_1: read-var u#33857:u32
        let s_1057_1: u32 = fn_state.u_33857;
        // D s_1057_2: cast zx s_1057_1 -> bv
        let s_1057_2: Bits = Bits::new(s_1057_1 as u128, 32u16);
        // C s_1057_3: const #1s : i64
        let s_1057_3: i64 = 1;
        // C s_1057_4: cast zx s_1057_3 -> i
        let s_1057_4: i128 = (i128::try_from(s_1057_3).unwrap());
        // C s_1057_5: const #5s : i
        let s_1057_5: i128 = 5;
        // C s_1057_6: add s_1057_5 s_1057_4
        let s_1057_6: i128 = (s_1057_5 + s_1057_4);
        // D s_1057_7: bit-extract s_1057_2 s_1057_0 s_1057_6
        let s_1057_7: Bits = (Bits::new(
            ((s_1057_2) >> (s_1057_0)).value(),
            u16::try_from(s_1057_6).unwrap(),
        ));
        // D s_1057_8: cast reint s_1057_7 -> u8
        let s_1057_8: u8 = (s_1057_7.value() as u8);
        // D s_1057_9: cast zx s_1057_8 -> bv
        let s_1057_9: Bits = Bits::new(s_1057_8 as u128, 6u16);
        // C s_1057_10: const #7u : u8
        let s_1057_10: u8 = 7;
        // C s_1057_11: cast zx s_1057_10 -> bv
        let s_1057_11: Bits = Bits::new(s_1057_10 as u128, 6u16);
        // D s_1057_12: cmp-eq s_1057_9 s_1057_11
        let s_1057_12: bool = ((s_1057_9) == (s_1057_11));
        // D s_1057_13: write-var gs#411257 <= s_1057_12
        fn_state.gs_411257 = s_1057_12;
        // N s_1057_14: jump b995
        return block_995(state, tracer, fn_state);
    }
    fn block_1058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1058_0: const #28s : i
        let s_1058_0: i128 = 28;
        // C s_1058_1: const #4s : i
        let s_1058_1: i128 = 4;
        // D s_1058_2: read-var u#33850:u32
        let s_1058_2: u32 = fn_state.u_33850;
        // D s_1058_3: cast zx s_1058_2 -> bv
        let s_1058_3: Bits = Bits::new(s_1058_2 as u128, 32u16);
        // D s_1058_4: bit-extract s_1058_3 s_1058_0 s_1058_1
        let s_1058_4: Bits = (Bits::new(
            ((s_1058_3) >> (s_1058_0)).value(),
            u16::try_from(s_1058_1).unwrap(),
        ));
        // D s_1058_5: cast reint s_1058_4 -> u8
        let s_1058_5: u8 = (s_1058_4.value() as u8);
        // D s_1058_6: cast zx s_1058_5 -> bv
        let s_1058_6: Bits = Bits::new(s_1058_5 as u128, 4u16);
        // C s_1058_7: const #15u : u8
        let s_1058_7: u8 = 15;
        // C s_1058_8: cast zx s_1058_7 -> bv
        let s_1058_8: Bits = Bits::new(s_1058_7 as u128, 4u16);
        // D s_1058_9: cmp-ne s_1058_6 s_1058_8
        let s_1058_9: bool = ((s_1058_6) != (s_1058_8));
        // N s_1058_10: branch s_1058_9 b1061 b1059
        if s_1058_9 {
            return block_1061(state, tracer, fn_state);
        } else {
            return block_1059(state, tracer, fn_state);
        };
    }
    fn block_1059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1059_0: const #0u : u8
        let s_1059_0: bool = false;
        // D s_1059_1: write-var gs#411233 <= s_1059_0
        fn_state.gs_411233 = s_1059_0;
        // N s_1059_2: jump b1060
        return block_1060(state, tracer, fn_state);
    }
    fn block_1060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1060_0: read-var gs#411233:u8
        let s_1060_0: bool = fn_state.gs_411233;
        // D s_1060_1: write-var gs#411234 <= s_1060_0
        fn_state.gs_411234 = s_1060_0;
        // N s_1060_2: jump b986
        return block_986(state, tracer, fn_state);
    }
    fn block_1061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1061_0: const #3338s : i
        let s_1061_0: i128 = 3338;
        // C s_1061_1: const #14696u : u32
        let s_1061_1: u32 = 14696;
        // D s_1061_2: read-reg s_1061_1:i
        let s_1061_2: i128 = {
            let value = state.read_register::<i128>(s_1061_1 as isize);
            tracer.read_register(s_1061_1 as isize, value);
            value
        };
        // D s_1061_3: cmp-lt s_1061_2 s_1061_0
        let s_1061_3: bool = ((s_1061_2) < (s_1061_0));
        // D s_1061_4: write-var gs#411233 <= s_1061_3
        fn_state.gs_411233 = s_1061_3;
        // N s_1061_5: jump b1060
        return block_1060(state, tracer, fn_state);
    }
    fn block_1062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1062_0: const #4s : i
        let s_1062_0: i128 = 4;
        // D s_1062_1: read-var u#33850:u32
        let s_1062_1: u32 = fn_state.u_33850;
        // D s_1062_2: cast zx s_1062_1 -> bv
        let s_1062_2: Bits = Bits::new(s_1062_1 as u128, 32u16);
        // C s_1062_3: const #1s : i64
        let s_1062_3: i64 = 1;
        // C s_1062_4: cast zx s_1062_3 -> i
        let s_1062_4: i128 = (i128::try_from(s_1062_3).unwrap());
        // C s_1062_5: const #5s : i
        let s_1062_5: i128 = 5;
        // C s_1062_6: add s_1062_5 s_1062_4
        let s_1062_6: i128 = (s_1062_5 + s_1062_4);
        // D s_1062_7: bit-extract s_1062_2 s_1062_0 s_1062_6
        let s_1062_7: Bits = (Bits::new(
            ((s_1062_2) >> (s_1062_0)).value(),
            u16::try_from(s_1062_6).unwrap(),
        ));
        // D s_1062_8: cast reint s_1062_7 -> u8
        let s_1062_8: u8 = (s_1062_7.value() as u8);
        // D s_1062_9: cast zx s_1062_8 -> bv
        let s_1062_9: Bits = Bits::new(s_1062_8 as u128, 6u16);
        // C s_1062_10: const #7u : u8
        let s_1062_10: u8 = 7;
        // C s_1062_11: cast zx s_1062_10 -> bv
        let s_1062_11: Bits = Bits::new(s_1062_10 as u128, 6u16);
        // D s_1062_12: cmp-eq s_1062_9 s_1062_11
        let s_1062_12: bool = ((s_1062_9) == (s_1062_11));
        // D s_1062_13: write-var gs#411229 <= s_1062_12
        fn_state.gs_411229 = s_1062_12;
        // N s_1062_14: jump b984
        return block_984(state, tracer, fn_state);
    }
    fn block_1063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1063_0: const #28s : i
        let s_1063_0: i128 = 28;
        // C s_1063_1: const #4s : i
        let s_1063_1: i128 = 4;
        // D s_1063_2: read-var u#33843:u32
        let s_1063_2: u32 = fn_state.u_33843;
        // D s_1063_3: cast zx s_1063_2 -> bv
        let s_1063_3: Bits = Bits::new(s_1063_2 as u128, 32u16);
        // D s_1063_4: bit-extract s_1063_3 s_1063_0 s_1063_1
        let s_1063_4: Bits = (Bits::new(
            ((s_1063_3) >> (s_1063_0)).value(),
            u16::try_from(s_1063_1).unwrap(),
        ));
        // D s_1063_5: cast reint s_1063_4 -> u8
        let s_1063_5: u8 = (s_1063_4.value() as u8);
        // D s_1063_6: cast zx s_1063_5 -> bv
        let s_1063_6: Bits = Bits::new(s_1063_5 as u128, 4u16);
        // C s_1063_7: const #15u : u8
        let s_1063_7: u8 = 15;
        // C s_1063_8: cast zx s_1063_7 -> bv
        let s_1063_8: Bits = Bits::new(s_1063_7 as u128, 4u16);
        // D s_1063_9: cmp-ne s_1063_6 s_1063_8
        let s_1063_9: bool = ((s_1063_6) != (s_1063_8));
        // N s_1063_10: branch s_1063_9 b1066 b1064
        if s_1063_9 {
            return block_1066(state, tracer, fn_state);
        } else {
            return block_1064(state, tracer, fn_state);
        };
    }
    fn block_1064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1064_0: const #0u : u8
        let s_1064_0: bool = false;
        // D s_1064_1: write-var gs#411205 <= s_1064_0
        fn_state.gs_411205 = s_1064_0;
        // N s_1064_2: jump b1065
        return block_1065(state, tracer, fn_state);
    }
    fn block_1065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1065_0: read-var gs#411205:u8
        let s_1065_0: bool = fn_state.gs_411205;
        // D s_1065_1: write-var gs#411206 <= s_1065_0
        fn_state.gs_411206 = s_1065_0;
        // N s_1065_2: jump b975
        return block_975(state, tracer, fn_state);
    }
    fn block_1066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1066_0: const #3336s : i
        let s_1066_0: i128 = 3336;
        // C s_1066_1: const #14696u : u32
        let s_1066_1: u32 = 14696;
        // D s_1066_2: read-reg s_1066_1:i
        let s_1066_2: i128 = {
            let value = state.read_register::<i128>(s_1066_1 as isize);
            tracer.read_register(s_1066_1 as isize, value);
            value
        };
        // D s_1066_3: cmp-lt s_1066_2 s_1066_0
        let s_1066_3: bool = ((s_1066_2) < (s_1066_0));
        // D s_1066_4: write-var gs#411205 <= s_1066_3
        fn_state.gs_411205 = s_1066_3;
        // N s_1066_5: jump b1065
        return block_1065(state, tracer, fn_state);
    }
    fn block_1067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1067_0: const #4s : i
        let s_1067_0: i128 = 4;
        // D s_1067_1: read-var u#33843:u32
        let s_1067_1: u32 = fn_state.u_33843;
        // D s_1067_2: cast zx s_1067_1 -> bv
        let s_1067_2: Bits = Bits::new(s_1067_1 as u128, 32u16);
        // C s_1067_3: const #1s : i64
        let s_1067_3: i64 = 1;
        // C s_1067_4: cast zx s_1067_3 -> i
        let s_1067_4: i128 = (i128::try_from(s_1067_3).unwrap());
        // C s_1067_5: const #5s : i
        let s_1067_5: i128 = 5;
        // C s_1067_6: add s_1067_5 s_1067_4
        let s_1067_6: i128 = (s_1067_5 + s_1067_4);
        // D s_1067_7: bit-extract s_1067_2 s_1067_0 s_1067_6
        let s_1067_7: Bits = (Bits::new(
            ((s_1067_2) >> (s_1067_0)).value(),
            u16::try_from(s_1067_6).unwrap(),
        ));
        // D s_1067_8: cast reint s_1067_7 -> u8
        let s_1067_8: u8 = (s_1067_7.value() as u8);
        // D s_1067_9: cast zx s_1067_8 -> bv
        let s_1067_9: Bits = Bits::new(s_1067_8 as u128, 6u16);
        // C s_1067_10: const #7u : u8
        let s_1067_10: u8 = 7;
        // C s_1067_11: cast zx s_1067_10 -> bv
        let s_1067_11: Bits = Bits::new(s_1067_10 as u128, 6u16);
        // D s_1067_12: cmp-eq s_1067_9 s_1067_11
        let s_1067_12: bool = ((s_1067_9) == (s_1067_11));
        // D s_1067_13: write-var gs#411201 <= s_1067_12
        fn_state.gs_411201 = s_1067_12;
        // N s_1067_14: jump b973
        return block_973(state, tracer, fn_state);
    }
    fn block_1068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1068_0: const #28s : i
        let s_1068_0: i128 = 28;
        // C s_1068_1: const #4s : i
        let s_1068_1: i128 = 4;
        // D s_1068_2: read-var u#33837:u32
        let s_1068_2: u32 = fn_state.u_33837;
        // D s_1068_3: cast zx s_1068_2 -> bv
        let s_1068_3: Bits = Bits::new(s_1068_2 as u128, 32u16);
        // D s_1068_4: bit-extract s_1068_3 s_1068_0 s_1068_1
        let s_1068_4: Bits = (Bits::new(
            ((s_1068_3) >> (s_1068_0)).value(),
            u16::try_from(s_1068_1).unwrap(),
        ));
        // D s_1068_5: cast reint s_1068_4 -> u8
        let s_1068_5: u8 = (s_1068_4.value() as u8);
        // D s_1068_6: cast zx s_1068_5 -> bv
        let s_1068_6: Bits = Bits::new(s_1068_5 as u128, 4u16);
        // C s_1068_7: const #15u : u8
        let s_1068_7: u8 = 15;
        // C s_1068_8: cast zx s_1068_7 -> bv
        let s_1068_8: Bits = Bits::new(s_1068_7 as u128, 4u16);
        // D s_1068_9: cmp-ne s_1068_6 s_1068_8
        let s_1068_9: bool = ((s_1068_6) != (s_1068_8));
        // N s_1068_10: branch s_1068_9 b1071 b1069
        if s_1068_9 {
            return block_1071(state, tracer, fn_state);
        } else {
            return block_1069(state, tracer, fn_state);
        };
    }
    fn block_1069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1069_0: const #0u : u8
        let s_1069_0: bool = false;
        // D s_1069_1: write-var gs#411173 <= s_1069_0
        fn_state.gs_411173 = s_1069_0;
        // N s_1069_2: jump b1070
        return block_1070(state, tracer, fn_state);
    }
    fn block_1070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1070_0: read-var gs#411173:u8
        let s_1070_0: bool = fn_state.gs_411173;
        // D s_1070_1: write-var gs#411174 <= s_1070_0
        fn_state.gs_411174 = s_1070_0;
        // N s_1070_2: jump b958
        return block_958(state, tracer, fn_state);
    }
    fn block_1071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1071_0: const #3334s : i
        let s_1071_0: i128 = 3334;
        // C s_1071_1: const #14696u : u32
        let s_1071_1: u32 = 14696;
        // D s_1071_2: read-reg s_1071_1:i
        let s_1071_2: i128 = {
            let value = state.read_register::<i128>(s_1071_1 as isize);
            tracer.read_register(s_1071_1 as isize, value);
            value
        };
        // D s_1071_3: cmp-lt s_1071_2 s_1071_0
        let s_1071_3: bool = ((s_1071_2) < (s_1071_0));
        // D s_1071_4: write-var gs#411173 <= s_1071_3
        fn_state.gs_411173 = s_1071_3;
        // N s_1071_5: jump b1070
        return block_1070(state, tracer, fn_state);
    }
    fn block_1072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1072_0: const #4s : i
        let s_1072_0: i128 = 4;
        // D s_1072_1: read-var u#33837:u32
        let s_1072_1: u32 = fn_state.u_33837;
        // D s_1072_2: cast zx s_1072_1 -> bv
        let s_1072_2: Bits = Bits::new(s_1072_1 as u128, 32u16);
        // C s_1072_3: const #1s : i64
        let s_1072_3: i64 = 1;
        // C s_1072_4: cast zx s_1072_3 -> i
        let s_1072_4: i128 = (i128::try_from(s_1072_3).unwrap());
        // C s_1072_5: const #7s : i
        let s_1072_5: i128 = 7;
        // C s_1072_6: add s_1072_5 s_1072_4
        let s_1072_6: i128 = (s_1072_5 + s_1072_4);
        // D s_1072_7: bit-extract s_1072_2 s_1072_0 s_1072_6
        let s_1072_7: Bits = (Bits::new(
            ((s_1072_2) >> (s_1072_0)).value(),
            u16::try_from(s_1072_6).unwrap(),
        ));
        // D s_1072_8: cast reint s_1072_7 -> u8
        let s_1072_8: u8 = (s_1072_7.value() as u8);
        // D s_1072_9: cast zx s_1072_8 -> bv
        let s_1072_9: Bits = Bits::new(s_1072_8 as u128, 8u16);
        // C s_1072_10: const #255u : u8
        let s_1072_10: u8 = 255;
        // C s_1072_11: cast zx s_1072_10 -> bv
        let s_1072_11: Bits = Bits::new(s_1072_10 as u128, 8u16);
        // D s_1072_12: cmp-eq s_1072_9 s_1072_11
        let s_1072_12: bool = ((s_1072_9) == (s_1072_11));
        // D s_1072_13: write-var gs#411169 <= s_1072_12
        fn_state.gs_411169 = s_1072_12;
        // N s_1072_14: jump b956
        return block_956(state, tracer, fn_state);
    }
    fn block_1073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1073_0: const #28s : i
        let s_1073_0: i128 = 28;
        // C s_1073_1: const #4s : i
        let s_1073_1: i128 = 4;
        // D s_1073_2: read-var u#33831:u32
        let s_1073_2: u32 = fn_state.u_33831;
        // D s_1073_3: cast zx s_1073_2 -> bv
        let s_1073_3: Bits = Bits::new(s_1073_2 as u128, 32u16);
        // D s_1073_4: bit-extract s_1073_3 s_1073_0 s_1073_1
        let s_1073_4: Bits = (Bits::new(
            ((s_1073_3) >> (s_1073_0)).value(),
            u16::try_from(s_1073_1).unwrap(),
        ));
        // D s_1073_5: cast reint s_1073_4 -> u8
        let s_1073_5: u8 = (s_1073_4.value() as u8);
        // D s_1073_6: cast zx s_1073_5 -> bv
        let s_1073_6: Bits = Bits::new(s_1073_5 as u128, 4u16);
        // C s_1073_7: const #15u : u8
        let s_1073_7: u8 = 15;
        // C s_1073_8: cast zx s_1073_7 -> bv
        let s_1073_8: Bits = Bits::new(s_1073_7 as u128, 4u16);
        // D s_1073_9: cmp-ne s_1073_6 s_1073_8
        let s_1073_9: bool = ((s_1073_6) != (s_1073_8));
        // N s_1073_10: branch s_1073_9 b1076 b1074
        if s_1073_9 {
            return block_1076(state, tracer, fn_state);
        } else {
            return block_1074(state, tracer, fn_state);
        };
    }
    fn block_1074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1074_0: const #0u : u8
        let s_1074_0: bool = false;
        // D s_1074_1: write-var gs#411141 <= s_1074_0
        fn_state.gs_411141 = s_1074_0;
        // N s_1074_2: jump b1075
        return block_1075(state, tracer, fn_state);
    }
    fn block_1075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1075_0: read-var gs#411141:u8
        let s_1075_0: bool = fn_state.gs_411141;
        // D s_1075_1: write-var gs#411142 <= s_1075_0
        fn_state.gs_411142 = s_1075_0;
        // N s_1075_2: jump b941
        return block_941(state, tracer, fn_state);
    }
    fn block_1076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1076_0: const #3332s : i
        let s_1076_0: i128 = 3332;
        // C s_1076_1: const #14696u : u32
        let s_1076_1: u32 = 14696;
        // D s_1076_2: read-reg s_1076_1:i
        let s_1076_2: i128 = {
            let value = state.read_register::<i128>(s_1076_1 as isize);
            tracer.read_register(s_1076_1 as isize, value);
            value
        };
        // D s_1076_3: cmp-lt s_1076_2 s_1076_0
        let s_1076_3: bool = ((s_1076_2) < (s_1076_0));
        // D s_1076_4: write-var gs#411141 <= s_1076_3
        fn_state.gs_411141 = s_1076_3;
        // N s_1076_5: jump b1075
        return block_1075(state, tracer, fn_state);
    }
    fn block_1077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1077_0: const #4s : i
        let s_1077_0: i128 = 4;
        // D s_1077_1: read-var u#33831:u32
        let s_1077_1: u32 = fn_state.u_33831;
        // D s_1077_2: cast zx s_1077_1 -> bv
        let s_1077_2: Bits = Bits::new(s_1077_1 as u128, 32u16);
        // C s_1077_3: const #1s : i64
        let s_1077_3: i64 = 1;
        // C s_1077_4: cast zx s_1077_3 -> i
        let s_1077_4: i128 = (i128::try_from(s_1077_3).unwrap());
        // C s_1077_5: const #7s : i
        let s_1077_5: i128 = 7;
        // C s_1077_6: add s_1077_5 s_1077_4
        let s_1077_6: i128 = (s_1077_5 + s_1077_4);
        // D s_1077_7: bit-extract s_1077_2 s_1077_0 s_1077_6
        let s_1077_7: Bits = (Bits::new(
            ((s_1077_2) >> (s_1077_0)).value(),
            u16::try_from(s_1077_6).unwrap(),
        ));
        // D s_1077_8: cast reint s_1077_7 -> u8
        let s_1077_8: u8 = (s_1077_7.value() as u8);
        // D s_1077_9: cast zx s_1077_8 -> bv
        let s_1077_9: Bits = Bits::new(s_1077_8 as u128, 8u16);
        // C s_1077_10: const #247u : u8
        let s_1077_10: u8 = 247;
        // C s_1077_11: cast zx s_1077_10 -> bv
        let s_1077_11: Bits = Bits::new(s_1077_10 as u128, 8u16);
        // D s_1077_12: cmp-eq s_1077_9 s_1077_11
        let s_1077_12: bool = ((s_1077_9) == (s_1077_11));
        // D s_1077_13: write-var gs#411137 <= s_1077_12
        fn_state.gs_411137 = s_1077_12;
        // N s_1077_14: jump b939
        return block_939(state, tracer, fn_state);
    }
    fn block_1078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1078_0: const #28s : i
        let s_1078_0: i128 = 28;
        // C s_1078_1: const #4s : i
        let s_1078_1: i128 = 4;
        // D s_1078_2: read-var u#33825:u32
        let s_1078_2: u32 = fn_state.u_33825;
        // D s_1078_3: cast zx s_1078_2 -> bv
        let s_1078_3: Bits = Bits::new(s_1078_2 as u128, 32u16);
        // D s_1078_4: bit-extract s_1078_3 s_1078_0 s_1078_1
        let s_1078_4: Bits = (Bits::new(
            ((s_1078_3) >> (s_1078_0)).value(),
            u16::try_from(s_1078_1).unwrap(),
        ));
        // D s_1078_5: cast reint s_1078_4 -> u8
        let s_1078_5: u8 = (s_1078_4.value() as u8);
        // D s_1078_6: cast zx s_1078_5 -> bv
        let s_1078_6: Bits = Bits::new(s_1078_5 as u128, 4u16);
        // C s_1078_7: const #15u : u8
        let s_1078_7: u8 = 15;
        // C s_1078_8: cast zx s_1078_7 -> bv
        let s_1078_8: Bits = Bits::new(s_1078_7 as u128, 4u16);
        // D s_1078_9: cmp-ne s_1078_6 s_1078_8
        let s_1078_9: bool = ((s_1078_6) != (s_1078_8));
        // N s_1078_10: branch s_1078_9 b1081 b1079
        if s_1078_9 {
            return block_1081(state, tracer, fn_state);
        } else {
            return block_1079(state, tracer, fn_state);
        };
    }
    fn block_1079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1079_0: const #0u : u8
        let s_1079_0: bool = false;
        // D s_1079_1: write-var gs#411109 <= s_1079_0
        fn_state.gs_411109 = s_1079_0;
        // N s_1079_2: jump b1080
        return block_1080(state, tracer, fn_state);
    }
    fn block_1080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1080_0: read-var gs#411109:u8
        let s_1080_0: bool = fn_state.gs_411109;
        // D s_1080_1: write-var gs#411110 <= s_1080_0
        fn_state.gs_411110 = s_1080_0;
        // N s_1080_2: jump b924
        return block_924(state, tracer, fn_state);
    }
    fn block_1081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1081_0: const #3330s : i
        let s_1081_0: i128 = 3330;
        // C s_1081_1: const #14696u : u32
        let s_1081_1: u32 = 14696;
        // D s_1081_2: read-reg s_1081_1:i
        let s_1081_2: i128 = {
            let value = state.read_register::<i128>(s_1081_1 as isize);
            tracer.read_register(s_1081_1 as isize, value);
            value
        };
        // D s_1081_3: cmp-lt s_1081_2 s_1081_0
        let s_1081_3: bool = ((s_1081_2) < (s_1081_0));
        // D s_1081_4: write-var gs#411109 <= s_1081_3
        fn_state.gs_411109 = s_1081_3;
        // N s_1081_5: jump b1080
        return block_1080(state, tracer, fn_state);
    }
    fn block_1082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1082_0: const #4s : i
        let s_1082_0: i128 = 4;
        // D s_1082_1: read-var u#33825:u32
        let s_1082_1: u32 = fn_state.u_33825;
        // D s_1082_2: cast zx s_1082_1 -> bv
        let s_1082_2: Bits = Bits::new(s_1082_1 as u128, 32u16);
        // C s_1082_3: const #1s : i64
        let s_1082_3: i64 = 1;
        // C s_1082_4: cast zx s_1082_3 -> i
        let s_1082_4: i128 = (i128::try_from(s_1082_3).unwrap());
        // C s_1082_5: const #7s : i
        let s_1082_5: i128 = 7;
        // C s_1082_6: add s_1082_5 s_1082_4
        let s_1082_6: i128 = (s_1082_5 + s_1082_4);
        // D s_1082_7: bit-extract s_1082_2 s_1082_0 s_1082_6
        let s_1082_7: Bits = (Bits::new(
            ((s_1082_2) >> (s_1082_0)).value(),
            u16::try_from(s_1082_6).unwrap(),
        ));
        // D s_1082_8: cast reint s_1082_7 -> u8
        let s_1082_8: u8 = (s_1082_7.value() as u8);
        // D s_1082_9: cast zx s_1082_8 -> bv
        let s_1082_9: Bits = Bits::new(s_1082_8 as u128, 8u16);
        // C s_1082_10: const #245u : u8
        let s_1082_10: u8 = 245;
        // C s_1082_11: cast zx s_1082_10 -> bv
        let s_1082_11: Bits = Bits::new(s_1082_10 as u128, 8u16);
        // D s_1082_12: cmp-eq s_1082_9 s_1082_11
        let s_1082_12: bool = ((s_1082_9) == (s_1082_11));
        // D s_1082_13: write-var gs#411105 <= s_1082_12
        fn_state.gs_411105 = s_1082_12;
        // N s_1082_14: jump b922
        return block_922(state, tracer, fn_state);
    }
    fn block_1083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1083_0: const #28s : i
        let s_1083_0: i128 = 28;
        // C s_1083_1: const #4s : i
        let s_1083_1: i128 = 4;
        // D s_1083_2: read-var u#33817:u32
        let s_1083_2: u32 = fn_state.u_33817;
        // D s_1083_3: cast zx s_1083_2 -> bv
        let s_1083_3: Bits = Bits::new(s_1083_2 as u128, 32u16);
        // D s_1083_4: bit-extract s_1083_3 s_1083_0 s_1083_1
        let s_1083_4: Bits = (Bits::new(
            ((s_1083_3) >> (s_1083_0)).value(),
            u16::try_from(s_1083_1).unwrap(),
        ));
        // D s_1083_5: cast reint s_1083_4 -> u8
        let s_1083_5: u8 = (s_1083_4.value() as u8);
        // D s_1083_6: cast zx s_1083_5 -> bv
        let s_1083_6: Bits = Bits::new(s_1083_5 as u128, 4u16);
        // C s_1083_7: const #15u : u8
        let s_1083_7: u8 = 15;
        // C s_1083_8: cast zx s_1083_7 -> bv
        let s_1083_8: Bits = Bits::new(s_1083_7 as u128, 4u16);
        // D s_1083_9: cmp-ne s_1083_6 s_1083_8
        let s_1083_9: bool = ((s_1083_6) != (s_1083_8));
        // N s_1083_10: branch s_1083_9 b1086 b1084
        if s_1083_9 {
            return block_1086(state, tracer, fn_state);
        } else {
            return block_1084(state, tracer, fn_state);
        };
    }
    fn block_1084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1084_0: const #0u : u8
        let s_1084_0: bool = false;
        // D s_1084_1: write-var gs#411084 <= s_1084_0
        fn_state.gs_411084 = s_1084_0;
        // N s_1084_2: jump b1085
        return block_1085(state, tracer, fn_state);
    }
    fn block_1085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1085_0: read-var gs#411084:u8
        let s_1085_0: bool = fn_state.gs_411084;
        // D s_1085_1: write-var gs#411085 <= s_1085_0
        fn_state.gs_411085 = s_1085_0;
        // N s_1085_2: jump b918
        return block_918(state, tracer, fn_state);
    }
    fn block_1086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1086_0: const #3328s : i
        let s_1086_0: i128 = 3328;
        // C s_1086_1: const #14696u : u32
        let s_1086_1: u32 = 14696;
        // D s_1086_2: read-reg s_1086_1:i
        let s_1086_2: i128 = {
            let value = state.read_register::<i128>(s_1086_1 as isize);
            tracer.read_register(s_1086_1 as isize, value);
            value
        };
        // D s_1086_3: cmp-lt s_1086_2 s_1086_0
        let s_1086_3: bool = ((s_1086_2) < (s_1086_0));
        // D s_1086_4: write-var gs#411084 <= s_1086_3
        fn_state.gs_411084 = s_1086_3;
        // N s_1086_5: jump b1085
        return block_1085(state, tracer, fn_state);
    }
    fn block_1087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1087_0: const #4s : i
        let s_1087_0: i128 = 4;
        // D s_1087_1: read-var u#33817:u32
        let s_1087_1: u32 = fn_state.u_33817;
        // D s_1087_2: cast zx s_1087_1 -> bv
        let s_1087_2: Bits = Bits::new(s_1087_1 as u128, 32u16);
        // C s_1087_3: const #1s : i64
        let s_1087_3: i64 = 1;
        // C s_1087_4: cast zx s_1087_3 -> i
        let s_1087_4: i128 = (i128::try_from(s_1087_3).unwrap());
        // C s_1087_5: const #1s : i
        let s_1087_5: i128 = 1;
        // C s_1087_6: add s_1087_5 s_1087_4
        let s_1087_6: i128 = (s_1087_5 + s_1087_4);
        // D s_1087_7: bit-extract s_1087_2 s_1087_0 s_1087_6
        let s_1087_7: Bits = (Bits::new(
            ((s_1087_2) >> (s_1087_0)).value(),
            u16::try_from(s_1087_6).unwrap(),
        ));
        // D s_1087_8: cast reint s_1087_7 -> u8
        let s_1087_8: u8 = (s_1087_7.value() as u8);
        // D s_1087_9: cast zx s_1087_8 -> bv
        let s_1087_9: Bits = Bits::new(s_1087_8 as u128, 2u16);
        // C s_1087_10: const #1u : u8
        let s_1087_10: u8 = 1;
        // C s_1087_11: cast zx s_1087_10 -> bv
        let s_1087_11: Bits = Bits::new(s_1087_10 as u128, 2u16);
        // D s_1087_12: cmp-eq s_1087_9 s_1087_11
        let s_1087_12: bool = ((s_1087_9) == (s_1087_11));
        // D s_1087_13: write-var gs#411080 <= s_1087_12
        fn_state.gs_411080 = s_1087_12;
        // N s_1087_14: jump b916
        return block_916(state, tracer, fn_state);
    }
    fn block_1088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1088_0: const #28s : i
        let s_1088_0: i128 = 28;
        // C s_1088_1: const #4s : i
        let s_1088_1: i128 = 4;
        // D s_1088_2: read-var u#33811:u32
        let s_1088_2: u32 = fn_state.u_33811;
        // D s_1088_3: cast zx s_1088_2 -> bv
        let s_1088_3: Bits = Bits::new(s_1088_2 as u128, 32u16);
        // D s_1088_4: bit-extract s_1088_3 s_1088_0 s_1088_1
        let s_1088_4: Bits = (Bits::new(
            ((s_1088_3) >> (s_1088_0)).value(),
            u16::try_from(s_1088_1).unwrap(),
        ));
        // D s_1088_5: cast reint s_1088_4 -> u8
        let s_1088_5: u8 = (s_1088_4.value() as u8);
        // D s_1088_6: cast zx s_1088_5 -> bv
        let s_1088_6: Bits = Bits::new(s_1088_5 as u128, 4u16);
        // C s_1088_7: const #15u : u8
        let s_1088_7: u8 = 15;
        // C s_1088_8: cast zx s_1088_7 -> bv
        let s_1088_8: Bits = Bits::new(s_1088_7 as u128, 4u16);
        // D s_1088_9: cmp-ne s_1088_6 s_1088_8
        let s_1088_9: bool = ((s_1088_6) != (s_1088_8));
        // N s_1088_10: branch s_1088_9 b1091 b1089
        if s_1088_9 {
            return block_1091(state, tracer, fn_state);
        } else {
            return block_1089(state, tracer, fn_state);
        };
    }
    fn block_1089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1089_0: const #0u : u8
        let s_1089_0: bool = false;
        // D s_1089_1: write-var gs#411052 <= s_1089_0
        fn_state.gs_411052 = s_1089_0;
        // N s_1089_2: jump b1090
        return block_1090(state, tracer, fn_state);
    }
    fn block_1090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1090_0: read-var gs#411052:u8
        let s_1090_0: bool = fn_state.gs_411052;
        // D s_1090_1: write-var gs#411053 <= s_1090_0
        fn_state.gs_411053 = s_1090_0;
        // N s_1090_2: jump b901
        return block_901(state, tracer, fn_state);
    }
    fn block_1091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1091_0: const #3326s : i
        let s_1091_0: i128 = 3326;
        // C s_1091_1: const #14696u : u32
        let s_1091_1: u32 = 14696;
        // D s_1091_2: read-reg s_1091_1:i
        let s_1091_2: i128 = {
            let value = state.read_register::<i128>(s_1091_1 as isize);
            tracer.read_register(s_1091_1 as isize, value);
            value
        };
        // D s_1091_3: cmp-lt s_1091_2 s_1091_0
        let s_1091_3: bool = ((s_1091_2) < (s_1091_0));
        // D s_1091_4: write-var gs#411052 <= s_1091_3
        fn_state.gs_411052 = s_1091_3;
        // N s_1091_5: jump b1090
        return block_1090(state, tracer, fn_state);
    }
    fn block_1092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1092_0: const #4s : i
        let s_1092_0: i128 = 4;
        // D s_1092_1: read-var u#33811:u32
        let s_1092_1: u32 = fn_state.u_33811;
        // D s_1092_2: cast zx s_1092_1 -> bv
        let s_1092_2: Bits = Bits::new(s_1092_1 as u128, 32u16);
        // C s_1092_3: const #1s : i64
        let s_1092_3: i64 = 1;
        // C s_1092_4: cast zx s_1092_3 -> i
        let s_1092_4: i128 = (i128::try_from(s_1092_3).unwrap());
        // C s_1092_5: const #7s : i
        let s_1092_5: i128 = 7;
        // C s_1092_6: add s_1092_5 s_1092_4
        let s_1092_6: i128 = (s_1092_5 + s_1092_4);
        // D s_1092_7: bit-extract s_1092_2 s_1092_0 s_1092_6
        let s_1092_7: Bits = (Bits::new(
            ((s_1092_2) >> (s_1092_0)).value(),
            u16::try_from(s_1092_6).unwrap(),
        ));
        // D s_1092_8: cast reint s_1092_7 -> u8
        let s_1092_8: u8 = (s_1092_7.value() as u8);
        // D s_1092_9: cast zx s_1092_8 -> bv
        let s_1092_9: Bits = Bits::new(s_1092_8 as u128, 8u16);
        // C s_1092_10: const #243u : u8
        let s_1092_10: u8 = 243;
        // C s_1092_11: cast zx s_1092_10 -> bv
        let s_1092_11: Bits = Bits::new(s_1092_10 as u128, 8u16);
        // D s_1092_12: cmp-eq s_1092_9 s_1092_11
        let s_1092_12: bool = ((s_1092_9) == (s_1092_11));
        // D s_1092_13: write-var gs#411048 <= s_1092_12
        fn_state.gs_411048 = s_1092_12;
        // N s_1092_14: jump b899
        return block_899(state, tracer, fn_state);
    }
    fn block_1093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1093_0: const #28s : i
        let s_1093_0: i128 = 28;
        // C s_1093_1: const #4s : i
        let s_1093_1: i128 = 4;
        // D s_1093_2: read-var u#33804:u32
        let s_1093_2: u32 = fn_state.u_33804;
        // D s_1093_3: cast zx s_1093_2 -> bv
        let s_1093_3: Bits = Bits::new(s_1093_2 as u128, 32u16);
        // D s_1093_4: bit-extract s_1093_3 s_1093_0 s_1093_1
        let s_1093_4: Bits = (Bits::new(
            ((s_1093_3) >> (s_1093_0)).value(),
            u16::try_from(s_1093_1).unwrap(),
        ));
        // D s_1093_5: cast reint s_1093_4 -> u8
        let s_1093_5: u8 = (s_1093_4.value() as u8);
        // D s_1093_6: cast zx s_1093_5 -> bv
        let s_1093_6: Bits = Bits::new(s_1093_5 as u128, 4u16);
        // C s_1093_7: const #15u : u8
        let s_1093_7: u8 = 15;
        // C s_1093_8: cast zx s_1093_7 -> bv
        let s_1093_8: Bits = Bits::new(s_1093_7 as u128, 4u16);
        // D s_1093_9: cmp-ne s_1093_6 s_1093_8
        let s_1093_9: bool = ((s_1093_6) != (s_1093_8));
        // N s_1093_10: branch s_1093_9 b1096 b1094
        if s_1093_9 {
            return block_1096(state, tracer, fn_state);
        } else {
            return block_1094(state, tracer, fn_state);
        };
    }
    fn block_1094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1094_0: const #0u : u8
        let s_1094_0: bool = false;
        // D s_1094_1: write-var gs#411029 <= s_1094_0
        fn_state.gs_411029 = s_1094_0;
        // N s_1094_2: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_1095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1095_0: read-var gs#411029:u8
        let s_1095_0: bool = fn_state.gs_411029;
        // D s_1095_1: write-var gs#411030 <= s_1095_0
        fn_state.gs_411030 = s_1095_0;
        // N s_1095_2: jump b895
        return block_895(state, tracer, fn_state);
    }
    fn block_1096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1096_0: const #3324s : i
        let s_1096_0: i128 = 3324;
        // C s_1096_1: const #14696u : u32
        let s_1096_1: u32 = 14696;
        // D s_1096_2: read-reg s_1096_1:i
        let s_1096_2: i128 = {
            let value = state.read_register::<i128>(s_1096_1 as isize);
            tracer.read_register(s_1096_1 as isize, value);
            value
        };
        // D s_1096_3: cmp-lt s_1096_2 s_1096_0
        let s_1096_3: bool = ((s_1096_2) < (s_1096_0));
        // D s_1096_4: write-var gs#411029 <= s_1096_3
        fn_state.gs_411029 = s_1096_3;
        // N s_1096_5: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_1097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1097_0: const #4s : i
        let s_1097_0: i128 = 4;
        // D s_1097_1: read-var u#33804:u32
        let s_1097_1: u32 = fn_state.u_33804;
        // D s_1097_2: cast zx s_1097_1 -> bv
        let s_1097_2: Bits = Bits::new(s_1097_1 as u128, 32u16);
        // C s_1097_3: const #1s : i64
        let s_1097_3: i64 = 1;
        // C s_1097_4: cast zx s_1097_3 -> i
        let s_1097_4: i128 = (i128::try_from(s_1097_3).unwrap());
        // C s_1097_5: const #3s : i
        let s_1097_5: i128 = 3;
        // C s_1097_6: add s_1097_5 s_1097_4
        let s_1097_6: i128 = (s_1097_5 + s_1097_4);
        // D s_1097_7: bit-extract s_1097_2 s_1097_0 s_1097_6
        let s_1097_7: Bits = (Bits::new(
            ((s_1097_2) >> (s_1097_0)).value(),
            u16::try_from(s_1097_6).unwrap(),
        ));
        // D s_1097_8: cast reint s_1097_7 -> u8
        let s_1097_8: u8 = (s_1097_7.value() as u8);
        // D s_1097_9: cast zx s_1097_8 -> bv
        let s_1097_9: Bits = Bits::new(s_1097_8 as u128, 4u16);
        // C s_1097_10: const #1u : u8
        let s_1097_10: u8 = 1;
        // C s_1097_11: cast zx s_1097_10 -> bv
        let s_1097_11: Bits = Bits::new(s_1097_10 as u128, 4u16);
        // D s_1097_12: cmp-eq s_1097_9 s_1097_11
        let s_1097_12: bool = ((s_1097_9) == (s_1097_11));
        // D s_1097_13: write-var gs#411025 <= s_1097_12
        fn_state.gs_411025 = s_1097_12;
        // N s_1097_14: jump b893
        return block_893(state, tracer, fn_state);
    }
    fn block_1098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1098_0: const #28s : i
        let s_1098_0: i128 = 28;
        // C s_1098_1: const #4s : i
        let s_1098_1: i128 = 4;
        // D s_1098_2: read-var u#33798:u32
        let s_1098_2: u32 = fn_state.u_33798;
        // D s_1098_3: cast zx s_1098_2 -> bv
        let s_1098_3: Bits = Bits::new(s_1098_2 as u128, 32u16);
        // D s_1098_4: bit-extract s_1098_3 s_1098_0 s_1098_1
        let s_1098_4: Bits = (Bits::new(
            ((s_1098_3) >> (s_1098_0)).value(),
            u16::try_from(s_1098_1).unwrap(),
        ));
        // D s_1098_5: cast reint s_1098_4 -> u8
        let s_1098_5: u8 = (s_1098_4.value() as u8);
        // D s_1098_6: cast zx s_1098_5 -> bv
        let s_1098_6: Bits = Bits::new(s_1098_5 as u128, 4u16);
        // C s_1098_7: const #15u : u8
        let s_1098_7: u8 = 15;
        // C s_1098_8: cast zx s_1098_7 -> bv
        let s_1098_8: Bits = Bits::new(s_1098_7 as u128, 4u16);
        // D s_1098_9: cmp-ne s_1098_6 s_1098_8
        let s_1098_9: bool = ((s_1098_6) != (s_1098_8));
        // N s_1098_10: branch s_1098_9 b1101 b1099
        if s_1098_9 {
            return block_1101(state, tracer, fn_state);
        } else {
            return block_1099(state, tracer, fn_state);
        };
    }
    fn block_1099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1099_0: const #0u : u8
        let s_1099_0: bool = false;
        // D s_1099_1: write-var gs#411008 <= s_1099_0
        fn_state.gs_411008 = s_1099_0;
        // N s_1099_2: jump b1100
        return block_1100(state, tracer, fn_state);
    }
    fn block_1100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1100_0: read-var gs#411008:u8
        let s_1100_0: bool = fn_state.gs_411008;
        // D s_1100_1: write-var gs#411009 <= s_1100_0
        fn_state.gs_411009 = s_1100_0;
        // N s_1100_2: jump b889
        return block_889(state, tracer, fn_state);
    }
    fn block_1101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1101_0: const #3322s : i
        let s_1101_0: i128 = 3322;
        // C s_1101_1: const #14696u : u32
        let s_1101_1: u32 = 14696;
        // D s_1101_2: read-reg s_1101_1:i
        let s_1101_2: i128 = {
            let value = state.read_register::<i128>(s_1101_1 as isize);
            tracer.read_register(s_1101_1 as isize, value);
            value
        };
        // D s_1101_3: cmp-lt s_1101_2 s_1101_0
        let s_1101_3: bool = ((s_1101_2) < (s_1101_0));
        // D s_1101_4: write-var gs#411008 <= s_1101_3
        fn_state.gs_411008 = s_1101_3;
        // N s_1101_5: jump b1100
        return block_1100(state, tracer, fn_state);
    }
    fn block_1102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1102_0: const #12s : i
        let s_1102_0: i128 = 12;
        // D s_1102_1: read-var u#33798:u32
        let s_1102_1: u32 = fn_state.u_33798;
        // D s_1102_2: cast zx s_1102_1 -> bv
        let s_1102_2: Bits = Bits::new(s_1102_1 as u128, 32u16);
        // C s_1102_3: const #1s : i64
        let s_1102_3: i64 = 1;
        // C s_1102_4: cast zx s_1102_3 -> i
        let s_1102_4: i128 = (i128::try_from(s_1102_3).unwrap());
        // C s_1102_5: const #3s : i
        let s_1102_5: i128 = 3;
        // C s_1102_6: add s_1102_5 s_1102_4
        let s_1102_6: i128 = (s_1102_5 + s_1102_4);
        // D s_1102_7: bit-extract s_1102_2 s_1102_0 s_1102_6
        let s_1102_7: Bits = (Bits::new(
            ((s_1102_2) >> (s_1102_0)).value(),
            u16::try_from(s_1102_6).unwrap(),
        ));
        // D s_1102_8: cast reint s_1102_7 -> u8
        let s_1102_8: u8 = (s_1102_7.value() as u8);
        // D s_1102_9: cast zx s_1102_8 -> bv
        let s_1102_9: Bits = Bits::new(s_1102_8 as u128, 4u16);
        // C s_1102_10: const #15u : u8
        let s_1102_10: u8 = 15;
        // C s_1102_11: cast zx s_1102_10 -> bv
        let s_1102_11: Bits = Bits::new(s_1102_10 as u128, 4u16);
        // D s_1102_12: cmp-eq s_1102_9 s_1102_11
        let s_1102_12: bool = ((s_1102_9) == (s_1102_11));
        // N s_1102_13: branch s_1102_12 b1105 b1103
        if s_1102_12 {
            return block_1105(state, tracer, fn_state);
        } else {
            return block_1103(state, tracer, fn_state);
        };
    }
    fn block_1103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1103_0: const #0u : u8
        let s_1103_0: bool = false;
        // D s_1103_1: write-var gs#411003 <= s_1103_0
        fn_state.gs_411003 = s_1103_0;
        // N s_1103_2: jump b1104
        return block_1104(state, tracer, fn_state);
    }
    fn block_1104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1104_0: read-var gs#411003:u8
        let s_1104_0: bool = fn_state.gs_411003;
        // D s_1104_1: write-var gs#411004 <= s_1104_0
        fn_state.gs_411004 = s_1104_0;
        // N s_1104_2: jump b887
        return block_887(state, tracer, fn_state);
    }
    fn block_1105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1105_0: const #4s : i
        let s_1105_0: i128 = 4;
        // D s_1105_1: read-var u#33798:u32
        let s_1105_1: u32 = fn_state.u_33798;
        // D s_1105_2: cast zx s_1105_1 -> bv
        let s_1105_2: Bits = Bits::new(s_1105_1 as u128, 32u16);
        // C s_1105_3: const #1s : i64
        let s_1105_3: i64 = 1;
        // C s_1105_4: cast zx s_1105_3 -> i
        let s_1105_4: i128 = (i128::try_from(s_1105_3).unwrap());
        // C s_1105_5: const #3s : i
        let s_1105_5: i128 = 3;
        // C s_1105_6: add s_1105_5 s_1105_4
        let s_1105_6: i128 = (s_1105_5 + s_1105_4);
        // D s_1105_7: bit-extract s_1105_2 s_1105_0 s_1105_6
        let s_1105_7: Bits = (Bits::new(
            ((s_1105_2) >> (s_1105_0)).value(),
            u16::try_from(s_1105_6).unwrap(),
        ));
        // D s_1105_8: cast reint s_1105_7 -> u8
        let s_1105_8: u8 = (s_1105_7.value() as u8);
        // D s_1105_9: cast zx s_1105_8 -> bv
        let s_1105_9: Bits = Bits::new(s_1105_8 as u128, 4u16);
        // C s_1105_10: const #1u : u8
        let s_1105_10: u8 = 1;
        // C s_1105_11: cast zx s_1105_10 -> bv
        let s_1105_11: Bits = Bits::new(s_1105_10 as u128, 4u16);
        // D s_1105_12: cmp-eq s_1105_9 s_1105_11
        let s_1105_12: bool = ((s_1105_9) == (s_1105_11));
        // D s_1105_13: write-var gs#411003 <= s_1105_12
        fn_state.gs_411003 = s_1105_12;
        // N s_1105_14: jump b1104
        return block_1104(state, tracer, fn_state);
    }
    fn block_1106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1106_0: const #28s : i
        let s_1106_0: i128 = 28;
        // C s_1106_1: const #4s : i
        let s_1106_1: i128 = 4;
        // D s_1106_2: read-var u#33792:u32
        let s_1106_2: u32 = fn_state.u_33792;
        // D s_1106_3: cast zx s_1106_2 -> bv
        let s_1106_3: Bits = Bits::new(s_1106_2 as u128, 32u16);
        // D s_1106_4: bit-extract s_1106_3 s_1106_0 s_1106_1
        let s_1106_4: Bits = (Bits::new(
            ((s_1106_3) >> (s_1106_0)).value(),
            u16::try_from(s_1106_1).unwrap(),
        ));
        // D s_1106_5: cast reint s_1106_4 -> u8
        let s_1106_5: u8 = (s_1106_4.value() as u8);
        // D s_1106_6: cast zx s_1106_5 -> bv
        let s_1106_6: Bits = Bits::new(s_1106_5 as u128, 4u16);
        // C s_1106_7: const #15u : u8
        let s_1106_7: u8 = 15;
        // C s_1106_8: cast zx s_1106_7 -> bv
        let s_1106_8: Bits = Bits::new(s_1106_7 as u128, 4u16);
        // D s_1106_9: cmp-ne s_1106_6 s_1106_8
        let s_1106_9: bool = ((s_1106_6) != (s_1106_8));
        // N s_1106_10: branch s_1106_9 b1109 b1107
        if s_1106_9 {
            return block_1109(state, tracer, fn_state);
        } else {
            return block_1107(state, tracer, fn_state);
        };
    }
    fn block_1107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1107_0: const #0u : u8
        let s_1107_0: bool = false;
        // D s_1107_1: write-var gs#410973 <= s_1107_0
        fn_state.gs_410973 = s_1107_0;
        // N s_1107_2: jump b1108
        return block_1108(state, tracer, fn_state);
    }
    fn block_1108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1108_0: read-var gs#410973:u8
        let s_1108_0: bool = fn_state.gs_410973;
        // D s_1108_1: write-var gs#410974 <= s_1108_0
        fn_state.gs_410974 = s_1108_0;
        // N s_1108_2: jump b872
        return block_872(state, tracer, fn_state);
    }
    fn block_1109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1109_0: const #3320s : i
        let s_1109_0: i128 = 3320;
        // C s_1109_1: const #14696u : u32
        let s_1109_1: u32 = 14696;
        // D s_1109_2: read-reg s_1109_1:i
        let s_1109_2: i128 = {
            let value = state.read_register::<i128>(s_1109_1 as isize);
            tracer.read_register(s_1109_1 as isize, value);
            value
        };
        // D s_1109_3: cmp-lt s_1109_2 s_1109_0
        let s_1109_3: bool = ((s_1109_2) < (s_1109_0));
        // D s_1109_4: write-var gs#410973 <= s_1109_3
        fn_state.gs_410973 = s_1109_3;
        // N s_1109_5: jump b1108
        return block_1108(state, tracer, fn_state);
    }
    fn block_1110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1110_0: const #4s : i
        let s_1110_0: i128 = 4;
        // D s_1110_1: read-var u#33792:u32
        let s_1110_1: u32 = fn_state.u_33792;
        // D s_1110_2: cast zx s_1110_1 -> bv
        let s_1110_2: Bits = Bits::new(s_1110_1 as u128, 32u16);
        // C s_1110_3: const #1s : i64
        let s_1110_3: i64 = 1;
        // C s_1110_4: cast zx s_1110_3 -> i
        let s_1110_4: i128 = (i128::try_from(s_1110_3).unwrap());
        // C s_1110_5: const #7s : i
        let s_1110_5: i128 = 7;
        // C s_1110_6: add s_1110_5 s_1110_4
        let s_1110_6: i128 = (s_1110_5 + s_1110_4);
        // D s_1110_7: bit-extract s_1110_2 s_1110_0 s_1110_6
        let s_1110_7: Bits = (Bits::new(
            ((s_1110_2) >> (s_1110_0)).value(),
            u16::try_from(s_1110_6).unwrap(),
        ));
        // D s_1110_8: cast reint s_1110_7 -> u8
        let s_1110_8: u8 = (s_1110_7.value() as u8);
        // D s_1110_9: cast zx s_1110_8 -> bv
        let s_1110_9: Bits = Bits::new(s_1110_8 as u128, 8u16);
        // C s_1110_10: const #255u : u8
        let s_1110_10: u8 = 255;
        // C s_1110_11: cast zx s_1110_10 -> bv
        let s_1110_11: Bits = Bits::new(s_1110_10 as u128, 8u16);
        // D s_1110_12: cmp-eq s_1110_9 s_1110_11
        let s_1110_12: bool = ((s_1110_9) == (s_1110_11));
        // D s_1110_13: write-var gs#410969 <= s_1110_12
        fn_state.gs_410969 = s_1110_12;
        // N s_1110_14: jump b870
        return block_870(state, tracer, fn_state);
    }
    fn block_1111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1111_0: const #28s : i
        let s_1111_0: i128 = 28;
        // C s_1111_1: const #4s : i
        let s_1111_1: i128 = 4;
        // D s_1111_2: read-var u#33786:u32
        let s_1111_2: u32 = fn_state.u_33786;
        // D s_1111_3: cast zx s_1111_2 -> bv
        let s_1111_3: Bits = Bits::new(s_1111_2 as u128, 32u16);
        // D s_1111_4: bit-extract s_1111_3 s_1111_0 s_1111_1
        let s_1111_4: Bits = (Bits::new(
            ((s_1111_3) >> (s_1111_0)).value(),
            u16::try_from(s_1111_1).unwrap(),
        ));
        // D s_1111_5: cast reint s_1111_4 -> u8
        let s_1111_5: u8 = (s_1111_4.value() as u8);
        // D s_1111_6: cast zx s_1111_5 -> bv
        let s_1111_6: Bits = Bits::new(s_1111_5 as u128, 4u16);
        // C s_1111_7: const #15u : u8
        let s_1111_7: u8 = 15;
        // C s_1111_8: cast zx s_1111_7 -> bv
        let s_1111_8: Bits = Bits::new(s_1111_7 as u128, 4u16);
        // D s_1111_9: cmp-ne s_1111_6 s_1111_8
        let s_1111_9: bool = ((s_1111_6) != (s_1111_8));
        // N s_1111_10: branch s_1111_9 b1114 b1112
        if s_1111_9 {
            return block_1114(state, tracer, fn_state);
        } else {
            return block_1112(state, tracer, fn_state);
        };
    }
    fn block_1112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1112_0: const #0u : u8
        let s_1112_0: bool = false;
        // D s_1112_1: write-var gs#410941 <= s_1112_0
        fn_state.gs_410941 = s_1112_0;
        // N s_1112_2: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_1113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1113_0: read-var gs#410941:u8
        let s_1113_0: bool = fn_state.gs_410941;
        // D s_1113_1: write-var gs#410942 <= s_1113_0
        fn_state.gs_410942 = s_1113_0;
        // N s_1113_2: jump b855
        return block_855(state, tracer, fn_state);
    }
    fn block_1114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1114_0: const #3318s : i
        let s_1114_0: i128 = 3318;
        // C s_1114_1: const #14696u : u32
        let s_1114_1: u32 = 14696;
        // D s_1114_2: read-reg s_1114_1:i
        let s_1114_2: i128 = {
            let value = state.read_register::<i128>(s_1114_1 as isize);
            tracer.read_register(s_1114_1 as isize, value);
            value
        };
        // D s_1114_3: cmp-lt s_1114_2 s_1114_0
        let s_1114_3: bool = ((s_1114_2) < (s_1114_0));
        // D s_1114_4: write-var gs#410941 <= s_1114_3
        fn_state.gs_410941 = s_1114_3;
        // N s_1114_5: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_1115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1115_0: const #4s : i
        let s_1115_0: i128 = 4;
        // D s_1115_1: read-var u#33786:u32
        let s_1115_1: u32 = fn_state.u_33786;
        // D s_1115_2: cast zx s_1115_1 -> bv
        let s_1115_2: Bits = Bits::new(s_1115_1 as u128, 32u16);
        // C s_1115_3: const #1s : i64
        let s_1115_3: i64 = 1;
        // C s_1115_4: cast zx s_1115_3 -> i
        let s_1115_4: i128 = (i128::try_from(s_1115_3).unwrap());
        // C s_1115_5: const #7s : i
        let s_1115_5: i128 = 7;
        // C s_1115_6: add s_1115_5 s_1115_4
        let s_1115_6: i128 = (s_1115_5 + s_1115_4);
        // D s_1115_7: bit-extract s_1115_2 s_1115_0 s_1115_6
        let s_1115_7: Bits = (Bits::new(
            ((s_1115_2) >> (s_1115_0)).value(),
            u16::try_from(s_1115_6).unwrap(),
        ));
        // D s_1115_8: cast reint s_1115_7 -> u8
        let s_1115_8: u8 = (s_1115_7.value() as u8);
        // D s_1115_9: cast zx s_1115_8 -> bv
        let s_1115_9: Bits = Bits::new(s_1115_8 as u128, 8u16);
        // C s_1115_10: const #247u : u8
        let s_1115_10: u8 = 247;
        // C s_1115_11: cast zx s_1115_10 -> bv
        let s_1115_11: Bits = Bits::new(s_1115_10 as u128, 8u16);
        // D s_1115_12: cmp-eq s_1115_9 s_1115_11
        let s_1115_12: bool = ((s_1115_9) == (s_1115_11));
        // D s_1115_13: write-var gs#410937 <= s_1115_12
        fn_state.gs_410937 = s_1115_12;
        // N s_1115_14: jump b853
        return block_853(state, tracer, fn_state);
    }
    fn block_1116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1116_0: const #28s : i
        let s_1116_0: i128 = 28;
        // C s_1116_1: const #4s : i
        let s_1116_1: i128 = 4;
        // D s_1116_2: read-var u#33780:u32
        let s_1116_2: u32 = fn_state.u_33780;
        // D s_1116_3: cast zx s_1116_2 -> bv
        let s_1116_3: Bits = Bits::new(s_1116_2 as u128, 32u16);
        // D s_1116_4: bit-extract s_1116_3 s_1116_0 s_1116_1
        let s_1116_4: Bits = (Bits::new(
            ((s_1116_3) >> (s_1116_0)).value(),
            u16::try_from(s_1116_1).unwrap(),
        ));
        // D s_1116_5: cast reint s_1116_4 -> u8
        let s_1116_5: u8 = (s_1116_4.value() as u8);
        // D s_1116_6: cast zx s_1116_5 -> bv
        let s_1116_6: Bits = Bits::new(s_1116_5 as u128, 4u16);
        // C s_1116_7: const #15u : u8
        let s_1116_7: u8 = 15;
        // C s_1116_8: cast zx s_1116_7 -> bv
        let s_1116_8: Bits = Bits::new(s_1116_7 as u128, 4u16);
        // D s_1116_9: cmp-ne s_1116_6 s_1116_8
        let s_1116_9: bool = ((s_1116_6) != (s_1116_8));
        // N s_1116_10: branch s_1116_9 b1119 b1117
        if s_1116_9 {
            return block_1119(state, tracer, fn_state);
        } else {
            return block_1117(state, tracer, fn_state);
        };
    }
    fn block_1117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1117_0: const #0u : u8
        let s_1117_0: bool = false;
        // D s_1117_1: write-var gs#410909 <= s_1117_0
        fn_state.gs_410909 = s_1117_0;
        // N s_1117_2: jump b1118
        return block_1118(state, tracer, fn_state);
    }
    fn block_1118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1118_0: read-var gs#410909:u8
        let s_1118_0: bool = fn_state.gs_410909;
        // D s_1118_1: write-var gs#410910 <= s_1118_0
        fn_state.gs_410910 = s_1118_0;
        // N s_1118_2: jump b838
        return block_838(state, tracer, fn_state);
    }
    fn block_1119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1119_0: const #3316s : i
        let s_1119_0: i128 = 3316;
        // C s_1119_1: const #14696u : u32
        let s_1119_1: u32 = 14696;
        // D s_1119_2: read-reg s_1119_1:i
        let s_1119_2: i128 = {
            let value = state.read_register::<i128>(s_1119_1 as isize);
            tracer.read_register(s_1119_1 as isize, value);
            value
        };
        // D s_1119_3: cmp-lt s_1119_2 s_1119_0
        let s_1119_3: bool = ((s_1119_2) < (s_1119_0));
        // D s_1119_4: write-var gs#410909 <= s_1119_3
        fn_state.gs_410909 = s_1119_3;
        // N s_1119_5: jump b1118
        return block_1118(state, tracer, fn_state);
    }
    fn block_1120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1120_0: const #4s : i
        let s_1120_0: i128 = 4;
        // D s_1120_1: read-var u#33780:u32
        let s_1120_1: u32 = fn_state.u_33780;
        // D s_1120_2: cast zx s_1120_1 -> bv
        let s_1120_2: Bits = Bits::new(s_1120_1 as u128, 32u16);
        // C s_1120_3: const #1s : i64
        let s_1120_3: i64 = 1;
        // C s_1120_4: cast zx s_1120_3 -> i
        let s_1120_4: i128 = (i128::try_from(s_1120_3).unwrap());
        // C s_1120_5: const #7s : i
        let s_1120_5: i128 = 7;
        // C s_1120_6: add s_1120_5 s_1120_4
        let s_1120_6: i128 = (s_1120_5 + s_1120_4);
        // D s_1120_7: bit-extract s_1120_2 s_1120_0 s_1120_6
        let s_1120_7: Bits = (Bits::new(
            ((s_1120_2) >> (s_1120_0)).value(),
            u16::try_from(s_1120_6).unwrap(),
        ));
        // D s_1120_8: cast reint s_1120_7 -> u8
        let s_1120_8: u8 = (s_1120_7.value() as u8);
        // D s_1120_9: cast zx s_1120_8 -> bv
        let s_1120_9: Bits = Bits::new(s_1120_8 as u128, 8u16);
        // C s_1120_10: const #245u : u8
        let s_1120_10: u8 = 245;
        // C s_1120_11: cast zx s_1120_10 -> bv
        let s_1120_11: Bits = Bits::new(s_1120_10 as u128, 8u16);
        // D s_1120_12: cmp-eq s_1120_9 s_1120_11
        let s_1120_12: bool = ((s_1120_9) == (s_1120_11));
        // D s_1120_13: write-var gs#410905 <= s_1120_12
        fn_state.gs_410905 = s_1120_12;
        // N s_1120_14: jump b836
        return block_836(state, tracer, fn_state);
    }
    fn block_1121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1121_0: const #28s : i
        let s_1121_0: i128 = 28;
        // C s_1121_1: const #4s : i
        let s_1121_1: i128 = 4;
        // D s_1121_2: read-var u#33774:u32
        let s_1121_2: u32 = fn_state.u_33774;
        // D s_1121_3: cast zx s_1121_2 -> bv
        let s_1121_3: Bits = Bits::new(s_1121_2 as u128, 32u16);
        // D s_1121_4: bit-extract s_1121_3 s_1121_0 s_1121_1
        let s_1121_4: Bits = (Bits::new(
            ((s_1121_3) >> (s_1121_0)).value(),
            u16::try_from(s_1121_1).unwrap(),
        ));
        // D s_1121_5: cast reint s_1121_4 -> u8
        let s_1121_5: u8 = (s_1121_4.value() as u8);
        // D s_1121_6: cast zx s_1121_5 -> bv
        let s_1121_6: Bits = Bits::new(s_1121_5 as u128, 4u16);
        // C s_1121_7: const #15u : u8
        let s_1121_7: u8 = 15;
        // C s_1121_8: cast zx s_1121_7 -> bv
        let s_1121_8: Bits = Bits::new(s_1121_7 as u128, 4u16);
        // D s_1121_9: cmp-ne s_1121_6 s_1121_8
        let s_1121_9: bool = ((s_1121_6) != (s_1121_8));
        // N s_1121_10: branch s_1121_9 b1124 b1122
        if s_1121_9 {
            return block_1124(state, tracer, fn_state);
        } else {
            return block_1122(state, tracer, fn_state);
        };
    }
    fn block_1122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1122_0: const #0u : u8
        let s_1122_0: bool = false;
        // D s_1122_1: write-var gs#410877 <= s_1122_0
        fn_state.gs_410877 = s_1122_0;
        // N s_1122_2: jump b1123
        return block_1123(state, tracer, fn_state);
    }
    fn block_1123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1123_0: read-var gs#410877:u8
        let s_1123_0: bool = fn_state.gs_410877;
        // D s_1123_1: write-var gs#410878 <= s_1123_0
        fn_state.gs_410878 = s_1123_0;
        // N s_1123_2: jump b821
        return block_821(state, tracer, fn_state);
    }
    fn block_1124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1124_0: const #3314s : i
        let s_1124_0: i128 = 3314;
        // C s_1124_1: const #14696u : u32
        let s_1124_1: u32 = 14696;
        // D s_1124_2: read-reg s_1124_1:i
        let s_1124_2: i128 = {
            let value = state.read_register::<i128>(s_1124_1 as isize);
            tracer.read_register(s_1124_1 as isize, value);
            value
        };
        // D s_1124_3: cmp-lt s_1124_2 s_1124_0
        let s_1124_3: bool = ((s_1124_2) < (s_1124_0));
        // D s_1124_4: write-var gs#410877 <= s_1124_3
        fn_state.gs_410877 = s_1124_3;
        // N s_1124_5: jump b1123
        return block_1123(state, tracer, fn_state);
    }
    fn block_1125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1125_0: const #4s : i
        let s_1125_0: i128 = 4;
        // D s_1125_1: read-var u#33774:u32
        let s_1125_1: u32 = fn_state.u_33774;
        // D s_1125_2: cast zx s_1125_1 -> bv
        let s_1125_2: Bits = Bits::new(s_1125_1 as u128, 32u16);
        // C s_1125_3: const #1s : i64
        let s_1125_3: i64 = 1;
        // C s_1125_4: cast zx s_1125_3 -> i
        let s_1125_4: i128 = (i128::try_from(s_1125_3).unwrap());
        // C s_1125_5: const #7s : i
        let s_1125_5: i128 = 7;
        // C s_1125_6: add s_1125_5 s_1125_4
        let s_1125_6: i128 = (s_1125_5 + s_1125_4);
        // D s_1125_7: bit-extract s_1125_2 s_1125_0 s_1125_6
        let s_1125_7: Bits = (Bits::new(
            ((s_1125_2) >> (s_1125_0)).value(),
            u16::try_from(s_1125_6).unwrap(),
        ));
        // D s_1125_8: cast reint s_1125_7 -> u8
        let s_1125_8: u8 = (s_1125_7.value() as u8);
        // D s_1125_9: cast zx s_1125_8 -> bv
        let s_1125_9: Bits = Bits::new(s_1125_8 as u128, 8u16);
        // C s_1125_10: const #243u : u8
        let s_1125_10: u8 = 243;
        // C s_1125_11: cast zx s_1125_10 -> bv
        let s_1125_11: Bits = Bits::new(s_1125_10 as u128, 8u16);
        // D s_1125_12: cmp-eq s_1125_9 s_1125_11
        let s_1125_12: bool = ((s_1125_9) == (s_1125_11));
        // D s_1125_13: write-var gs#410873 <= s_1125_12
        fn_state.gs_410873 = s_1125_12;
        // N s_1125_14: jump b819
        return block_819(state, tracer, fn_state);
    }
    fn block_1126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1126_0: const #28s : i
        let s_1126_0: i128 = 28;
        // C s_1126_1: const #4s : i
        let s_1126_1: i128 = 4;
        // D s_1126_2: read-var u#33768:u32
        let s_1126_2: u32 = fn_state.u_33768;
        // D s_1126_3: cast zx s_1126_2 -> bv
        let s_1126_3: Bits = Bits::new(s_1126_2 as u128, 32u16);
        // D s_1126_4: bit-extract s_1126_3 s_1126_0 s_1126_1
        let s_1126_4: Bits = (Bits::new(
            ((s_1126_3) >> (s_1126_0)).value(),
            u16::try_from(s_1126_1).unwrap(),
        ));
        // D s_1126_5: cast reint s_1126_4 -> u8
        let s_1126_5: u8 = (s_1126_4.value() as u8);
        // D s_1126_6: cast zx s_1126_5 -> bv
        let s_1126_6: Bits = Bits::new(s_1126_5 as u128, 4u16);
        // C s_1126_7: const #15u : u8
        let s_1126_7: u8 = 15;
        // C s_1126_8: cast zx s_1126_7 -> bv
        let s_1126_8: Bits = Bits::new(s_1126_7 as u128, 4u16);
        // D s_1126_9: cmp-ne s_1126_6 s_1126_8
        let s_1126_9: bool = ((s_1126_6) != (s_1126_8));
        // N s_1126_10: branch s_1126_9 b1129 b1127
        if s_1126_9 {
            return block_1129(state, tracer, fn_state);
        } else {
            return block_1127(state, tracer, fn_state);
        };
    }
    fn block_1127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1127_0: const #0u : u8
        let s_1127_0: bool = false;
        // D s_1127_1: write-var gs#410845 <= s_1127_0
        fn_state.gs_410845 = s_1127_0;
        // N s_1127_2: jump b1128
        return block_1128(state, tracer, fn_state);
    }
    fn block_1128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1128_0: read-var gs#410845:u8
        let s_1128_0: bool = fn_state.gs_410845;
        // D s_1128_1: write-var gs#410846 <= s_1128_0
        fn_state.gs_410846 = s_1128_0;
        // N s_1128_2: jump b804
        return block_804(state, tracer, fn_state);
    }
    fn block_1129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1129_0: const #3312s : i
        let s_1129_0: i128 = 3312;
        // C s_1129_1: const #14696u : u32
        let s_1129_1: u32 = 14696;
        // D s_1129_2: read-reg s_1129_1:i
        let s_1129_2: i128 = {
            let value = state.read_register::<i128>(s_1129_1 as isize);
            tracer.read_register(s_1129_1 as isize, value);
            value
        };
        // D s_1129_3: cmp-lt s_1129_2 s_1129_0
        let s_1129_3: bool = ((s_1129_2) < (s_1129_0));
        // D s_1129_4: write-var gs#410845 <= s_1129_3
        fn_state.gs_410845 = s_1129_3;
        // N s_1129_5: jump b1128
        return block_1128(state, tracer, fn_state);
    }
    fn block_1130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1130_0: const #4s : i
        let s_1130_0: i128 = 4;
        // D s_1130_1: read-var u#33768:u32
        let s_1130_1: u32 = fn_state.u_33768;
        // D s_1130_2: cast zx s_1130_1 -> bv
        let s_1130_2: Bits = Bits::new(s_1130_1 as u128, 32u16);
        // C s_1130_3: const #1s : i64
        let s_1130_3: i64 = 1;
        // C s_1130_4: cast zx s_1130_3 -> i
        let s_1130_4: i128 = (i128::try_from(s_1130_3).unwrap());
        // C s_1130_5: const #7s : i
        let s_1130_5: i128 = 7;
        // C s_1130_6: add s_1130_5 s_1130_4
        let s_1130_6: i128 = (s_1130_5 + s_1130_4);
        // D s_1130_7: bit-extract s_1130_2 s_1130_0 s_1130_6
        let s_1130_7: Bits = (Bits::new(
            ((s_1130_2) >> (s_1130_0)).value(),
            u16::try_from(s_1130_6).unwrap(),
        ));
        // D s_1130_8: cast reint s_1130_7 -> u8
        let s_1130_8: u8 = (s_1130_7.value() as u8);
        // D s_1130_9: cast zx s_1130_8 -> bv
        let s_1130_9: Bits = Bits::new(s_1130_8 as u128, 8u16);
        // C s_1130_10: const #249u : u8
        let s_1130_10: u8 = 249;
        // C s_1130_11: cast zx s_1130_10 -> bv
        let s_1130_11: Bits = Bits::new(s_1130_10 as u128, 8u16);
        // D s_1130_12: cmp-eq s_1130_9 s_1130_11
        let s_1130_12: bool = ((s_1130_9) == (s_1130_11));
        // D s_1130_13: write-var gs#410841 <= s_1130_12
        fn_state.gs_410841 = s_1130_12;
        // N s_1130_14: jump b802
        return block_802(state, tracer, fn_state);
    }
    fn block_1131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1131_0: const #28s : i
        let s_1131_0: i128 = 28;
        // C s_1131_1: const #4s : i
        let s_1131_1: i128 = 4;
        // D s_1131_2: read-var u#33762:u32
        let s_1131_2: u32 = fn_state.u_33762;
        // D s_1131_3: cast zx s_1131_2 -> bv
        let s_1131_3: Bits = Bits::new(s_1131_2 as u128, 32u16);
        // D s_1131_4: bit-extract s_1131_3 s_1131_0 s_1131_1
        let s_1131_4: Bits = (Bits::new(
            ((s_1131_3) >> (s_1131_0)).value(),
            u16::try_from(s_1131_1).unwrap(),
        ));
        // D s_1131_5: cast reint s_1131_4 -> u8
        let s_1131_5: u8 = (s_1131_4.value() as u8);
        // D s_1131_6: cast zx s_1131_5 -> bv
        let s_1131_6: Bits = Bits::new(s_1131_5 as u128, 4u16);
        // C s_1131_7: const #15u : u8
        let s_1131_7: u8 = 15;
        // C s_1131_8: cast zx s_1131_7 -> bv
        let s_1131_8: Bits = Bits::new(s_1131_7 as u128, 4u16);
        // D s_1131_9: cmp-ne s_1131_6 s_1131_8
        let s_1131_9: bool = ((s_1131_6) != (s_1131_8));
        // N s_1131_10: branch s_1131_9 b1134 b1132
        if s_1131_9 {
            return block_1134(state, tracer, fn_state);
        } else {
            return block_1132(state, tracer, fn_state);
        };
    }
    fn block_1132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1132_0: const #0u : u8
        let s_1132_0: bool = false;
        // D s_1132_1: write-var gs#410813 <= s_1132_0
        fn_state.gs_410813 = s_1132_0;
        // N s_1132_2: jump b1133
        return block_1133(state, tracer, fn_state);
    }
    fn block_1133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1133_0: read-var gs#410813:u8
        let s_1133_0: bool = fn_state.gs_410813;
        // D s_1133_1: write-var gs#410814 <= s_1133_0
        fn_state.gs_410814 = s_1133_0;
        // N s_1133_2: jump b787
        return block_787(state, tracer, fn_state);
    }
    fn block_1134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1134_0: const #3310s : i
        let s_1134_0: i128 = 3310;
        // C s_1134_1: const #14696u : u32
        let s_1134_1: u32 = 14696;
        // D s_1134_2: read-reg s_1134_1:i
        let s_1134_2: i128 = {
            let value = state.read_register::<i128>(s_1134_1 as isize);
            tracer.read_register(s_1134_1 as isize, value);
            value
        };
        // D s_1134_3: cmp-lt s_1134_2 s_1134_0
        let s_1134_3: bool = ((s_1134_2) < (s_1134_0));
        // D s_1134_4: write-var gs#410813 <= s_1134_3
        fn_state.gs_410813 = s_1134_3;
        // N s_1134_5: jump b1133
        return block_1133(state, tracer, fn_state);
    }
    fn block_1135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1135_0: const #4s : i
        let s_1135_0: i128 = 4;
        // D s_1135_1: read-var u#33762:u32
        let s_1135_1: u32 = fn_state.u_33762;
        // D s_1135_2: cast zx s_1135_1 -> bv
        let s_1135_2: Bits = Bits::new(s_1135_1 as u128, 32u16);
        // C s_1135_3: const #1s : i64
        let s_1135_3: i64 = 1;
        // C s_1135_4: cast zx s_1135_3 -> i
        let s_1135_4: i128 = (i128::try_from(s_1135_3).unwrap());
        // C s_1135_5: const #7s : i
        let s_1135_5: i128 = 7;
        // C s_1135_6: add s_1135_5 s_1135_4
        let s_1135_6: i128 = (s_1135_5 + s_1135_4);
        // D s_1135_7: bit-extract s_1135_2 s_1135_0 s_1135_6
        let s_1135_7: Bits = (Bits::new(
            ((s_1135_2) >> (s_1135_0)).value(),
            u16::try_from(s_1135_6).unwrap(),
        ));
        // D s_1135_8: cast reint s_1135_7 -> u8
        let s_1135_8: u8 = (s_1135_7.value() as u8);
        // D s_1135_9: cast zx s_1135_8 -> bv
        let s_1135_9: Bits = Bits::new(s_1135_8 as u128, 8u16);
        // C s_1135_10: const #241u : u8
        let s_1135_10: u8 = 241;
        // C s_1135_11: cast zx s_1135_10 -> bv
        let s_1135_11: Bits = Bits::new(s_1135_10 as u128, 8u16);
        // D s_1135_12: cmp-eq s_1135_9 s_1135_11
        let s_1135_12: bool = ((s_1135_9) == (s_1135_11));
        // D s_1135_13: write-var gs#410809 <= s_1135_12
        fn_state.gs_410809 = s_1135_12;
        // N s_1135_14: jump b785
        return block_785(state, tracer, fn_state);
    }
    fn block_1136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1136_0: const #28s : i
        let s_1136_0: i128 = 28;
        // C s_1136_1: const #4s : i
        let s_1136_1: i128 = 4;
        // D s_1136_2: read-var u#33756:u32
        let s_1136_2: u32 = fn_state.u_33756;
        // D s_1136_3: cast zx s_1136_2 -> bv
        let s_1136_3: Bits = Bits::new(s_1136_2 as u128, 32u16);
        // D s_1136_4: bit-extract s_1136_3 s_1136_0 s_1136_1
        let s_1136_4: Bits = (Bits::new(
            ((s_1136_3) >> (s_1136_0)).value(),
            u16::try_from(s_1136_1).unwrap(),
        ));
        // D s_1136_5: cast reint s_1136_4 -> u8
        let s_1136_5: u8 = (s_1136_4.value() as u8);
        // D s_1136_6: cast zx s_1136_5 -> bv
        let s_1136_6: Bits = Bits::new(s_1136_5 as u128, 4u16);
        // C s_1136_7: const #15u : u8
        let s_1136_7: u8 = 15;
        // C s_1136_8: cast zx s_1136_7 -> bv
        let s_1136_8: Bits = Bits::new(s_1136_7 as u128, 4u16);
        // D s_1136_9: cmp-ne s_1136_6 s_1136_8
        let s_1136_9: bool = ((s_1136_6) != (s_1136_8));
        // N s_1136_10: branch s_1136_9 b1139 b1137
        if s_1136_9 {
            return block_1139(state, tracer, fn_state);
        } else {
            return block_1137(state, tracer, fn_state);
        };
    }
    fn block_1137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1137_0: const #0u : u8
        let s_1137_0: bool = false;
        // D s_1137_1: write-var gs#410781 <= s_1137_0
        fn_state.gs_410781 = s_1137_0;
        // N s_1137_2: jump b1138
        return block_1138(state, tracer, fn_state);
    }
    fn block_1138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1138_0: read-var gs#410781:u8
        let s_1138_0: bool = fn_state.gs_410781;
        // D s_1138_1: write-var gs#410782 <= s_1138_0
        fn_state.gs_410782 = s_1138_0;
        // N s_1138_2: jump b770
        return block_770(state, tracer, fn_state);
    }
    fn block_1139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1139_0: const #3302s : i
        let s_1139_0: i128 = 3302;
        // C s_1139_1: const #14696u : u32
        let s_1139_1: u32 = 14696;
        // D s_1139_2: read-reg s_1139_1:i
        let s_1139_2: i128 = {
            let value = state.read_register::<i128>(s_1139_1 as isize);
            tracer.read_register(s_1139_1 as isize, value);
            value
        };
        // D s_1139_3: cmp-lt s_1139_2 s_1139_0
        let s_1139_3: bool = ((s_1139_2) < (s_1139_0));
        // D s_1139_4: write-var gs#410781 <= s_1139_3
        fn_state.gs_410781 = s_1139_3;
        // N s_1139_5: jump b1138
        return block_1138(state, tracer, fn_state);
    }
    fn block_1140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1140_0: const #4s : i
        let s_1140_0: i128 = 4;
        // D s_1140_1: read-var u#33756:u32
        let s_1140_1: u32 = fn_state.u_33756;
        // D s_1140_2: cast zx s_1140_1 -> bv
        let s_1140_2: Bits = Bits::new(s_1140_1 as u128, 32u16);
        // C s_1140_3: const #1s : i64
        let s_1140_3: i64 = 1;
        // C s_1140_4: cast zx s_1140_3 -> i
        let s_1140_4: i128 = (i128::try_from(s_1140_3).unwrap());
        // C s_1140_5: const #7s : i
        let s_1140_5: i128 = 7;
        // C s_1140_6: add s_1140_5 s_1140_4
        let s_1140_6: i128 = (s_1140_5 + s_1140_4);
        // D s_1140_7: bit-extract s_1140_2 s_1140_0 s_1140_6
        let s_1140_7: Bits = (Bits::new(
            ((s_1140_2) >> (s_1140_0)).value(),
            u16::try_from(s_1140_6).unwrap(),
        ));
        // D s_1140_8: cast reint s_1140_7 -> u8
        let s_1140_8: u8 = (s_1140_7.value() as u8);
        // D s_1140_9: cast zx s_1140_8 -> bv
        let s_1140_9: Bits = Bits::new(s_1140_8 as u128, 8u16);
        // C s_1140_10: const #255u : u8
        let s_1140_10: u8 = 255;
        // C s_1140_11: cast zx s_1140_10 -> bv
        let s_1140_11: Bits = Bits::new(s_1140_10 as u128, 8u16);
        // D s_1140_12: cmp-eq s_1140_9 s_1140_11
        let s_1140_12: bool = ((s_1140_9) == (s_1140_11));
        // D s_1140_13: write-var gs#410777 <= s_1140_12
        fn_state.gs_410777 = s_1140_12;
        // N s_1140_14: jump b768
        return block_768(state, tracer, fn_state);
    }
    fn block_1141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1141_0: const #28s : i
        let s_1141_0: i128 = 28;
        // C s_1141_1: const #4s : i
        let s_1141_1: i128 = 4;
        // D s_1141_2: read-var u#33750:u32
        let s_1141_2: u32 = fn_state.u_33750;
        // D s_1141_3: cast zx s_1141_2 -> bv
        let s_1141_3: Bits = Bits::new(s_1141_2 as u128, 32u16);
        // D s_1141_4: bit-extract s_1141_3 s_1141_0 s_1141_1
        let s_1141_4: Bits = (Bits::new(
            ((s_1141_3) >> (s_1141_0)).value(),
            u16::try_from(s_1141_1).unwrap(),
        ));
        // D s_1141_5: cast reint s_1141_4 -> u8
        let s_1141_5: u8 = (s_1141_4.value() as u8);
        // D s_1141_6: cast zx s_1141_5 -> bv
        let s_1141_6: Bits = Bits::new(s_1141_5 as u128, 4u16);
        // C s_1141_7: const #15u : u8
        let s_1141_7: u8 = 15;
        // C s_1141_8: cast zx s_1141_7 -> bv
        let s_1141_8: Bits = Bits::new(s_1141_7 as u128, 4u16);
        // D s_1141_9: cmp-ne s_1141_6 s_1141_8
        let s_1141_9: bool = ((s_1141_6) != (s_1141_8));
        // N s_1141_10: branch s_1141_9 b1144 b1142
        if s_1141_9 {
            return block_1144(state, tracer, fn_state);
        } else {
            return block_1142(state, tracer, fn_state);
        };
    }
    fn block_1142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1142_0: const #0u : u8
        let s_1142_0: bool = false;
        // D s_1142_1: write-var gs#410749 <= s_1142_0
        fn_state.gs_410749 = s_1142_0;
        // N s_1142_2: jump b1143
        return block_1143(state, tracer, fn_state);
    }
    fn block_1143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1143_0: read-var gs#410749:u8
        let s_1143_0: bool = fn_state.gs_410749;
        // D s_1143_1: write-var gs#410750 <= s_1143_0
        fn_state.gs_410750 = s_1143_0;
        // N s_1143_2: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_1144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1144_0: const #3300s : i
        let s_1144_0: i128 = 3300;
        // C s_1144_1: const #14696u : u32
        let s_1144_1: u32 = 14696;
        // D s_1144_2: read-reg s_1144_1:i
        let s_1144_2: i128 = {
            let value = state.read_register::<i128>(s_1144_1 as isize);
            tracer.read_register(s_1144_1 as isize, value);
            value
        };
        // D s_1144_3: cmp-lt s_1144_2 s_1144_0
        let s_1144_3: bool = ((s_1144_2) < (s_1144_0));
        // D s_1144_4: write-var gs#410749 <= s_1144_3
        fn_state.gs_410749 = s_1144_3;
        // N s_1144_5: jump b1143
        return block_1143(state, tracer, fn_state);
    }
    fn block_1145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1145_0: const #4s : i
        let s_1145_0: i128 = 4;
        // D s_1145_1: read-var u#33750:u32
        let s_1145_1: u32 = fn_state.u_33750;
        // D s_1145_2: cast zx s_1145_1 -> bv
        let s_1145_2: Bits = Bits::new(s_1145_1 as u128, 32u16);
        // C s_1145_3: const #1s : i64
        let s_1145_3: i64 = 1;
        // C s_1145_4: cast zx s_1145_3 -> i
        let s_1145_4: i128 = (i128::try_from(s_1145_3).unwrap());
        // C s_1145_5: const #7s : i
        let s_1145_5: i128 = 7;
        // C s_1145_6: add s_1145_5 s_1145_4
        let s_1145_6: i128 = (s_1145_5 + s_1145_4);
        // D s_1145_7: bit-extract s_1145_2 s_1145_0 s_1145_6
        let s_1145_7: Bits = (Bits::new(
            ((s_1145_2) >> (s_1145_0)).value(),
            u16::try_from(s_1145_6).unwrap(),
        ));
        // D s_1145_8: cast reint s_1145_7 -> u8
        let s_1145_8: u8 = (s_1145_7.value() as u8);
        // D s_1145_9: cast zx s_1145_8 -> bv
        let s_1145_9: Bits = Bits::new(s_1145_8 as u128, 8u16);
        // C s_1145_10: const #247u : u8
        let s_1145_10: u8 = 247;
        // C s_1145_11: cast zx s_1145_10 -> bv
        let s_1145_11: Bits = Bits::new(s_1145_10 as u128, 8u16);
        // D s_1145_12: cmp-eq s_1145_9 s_1145_11
        let s_1145_12: bool = ((s_1145_9) == (s_1145_11));
        // D s_1145_13: write-var gs#410745 <= s_1145_12
        fn_state.gs_410745 = s_1145_12;
        // N s_1145_14: jump b751
        return block_751(state, tracer, fn_state);
    }
    fn block_1146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1146_0: const #28s : i
        let s_1146_0: i128 = 28;
        // C s_1146_1: const #4s : i
        let s_1146_1: i128 = 4;
        // D s_1146_2: read-var u#33744:u32
        let s_1146_2: u32 = fn_state.u_33744;
        // D s_1146_3: cast zx s_1146_2 -> bv
        let s_1146_3: Bits = Bits::new(s_1146_2 as u128, 32u16);
        // D s_1146_4: bit-extract s_1146_3 s_1146_0 s_1146_1
        let s_1146_4: Bits = (Bits::new(
            ((s_1146_3) >> (s_1146_0)).value(),
            u16::try_from(s_1146_1).unwrap(),
        ));
        // D s_1146_5: cast reint s_1146_4 -> u8
        let s_1146_5: u8 = (s_1146_4.value() as u8);
        // D s_1146_6: cast zx s_1146_5 -> bv
        let s_1146_6: Bits = Bits::new(s_1146_5 as u128, 4u16);
        // C s_1146_7: const #15u : u8
        let s_1146_7: u8 = 15;
        // C s_1146_8: cast zx s_1146_7 -> bv
        let s_1146_8: Bits = Bits::new(s_1146_7 as u128, 4u16);
        // D s_1146_9: cmp-ne s_1146_6 s_1146_8
        let s_1146_9: bool = ((s_1146_6) != (s_1146_8));
        // N s_1146_10: branch s_1146_9 b1149 b1147
        if s_1146_9 {
            return block_1149(state, tracer, fn_state);
        } else {
            return block_1147(state, tracer, fn_state);
        };
    }
    fn block_1147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1147_0: const #0u : u8
        let s_1147_0: bool = false;
        // D s_1147_1: write-var gs#410717 <= s_1147_0
        fn_state.gs_410717 = s_1147_0;
        // N s_1147_2: jump b1148
        return block_1148(state, tracer, fn_state);
    }
    fn block_1148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1148_0: read-var gs#410717:u8
        let s_1148_0: bool = fn_state.gs_410717;
        // D s_1148_1: write-var gs#410718 <= s_1148_0
        fn_state.gs_410718 = s_1148_0;
        // N s_1148_2: jump b736
        return block_736(state, tracer, fn_state);
    }
    fn block_1149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1149_0: const #3298s : i
        let s_1149_0: i128 = 3298;
        // C s_1149_1: const #14696u : u32
        let s_1149_1: u32 = 14696;
        // D s_1149_2: read-reg s_1149_1:i
        let s_1149_2: i128 = {
            let value = state.read_register::<i128>(s_1149_1 as isize);
            tracer.read_register(s_1149_1 as isize, value);
            value
        };
        // D s_1149_3: cmp-lt s_1149_2 s_1149_0
        let s_1149_3: bool = ((s_1149_2) < (s_1149_0));
        // D s_1149_4: write-var gs#410717 <= s_1149_3
        fn_state.gs_410717 = s_1149_3;
        // N s_1149_5: jump b1148
        return block_1148(state, tracer, fn_state);
    }
    fn block_1150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1150_0: const #4s : i
        let s_1150_0: i128 = 4;
        // D s_1150_1: read-var u#33744:u32
        let s_1150_1: u32 = fn_state.u_33744;
        // D s_1150_2: cast zx s_1150_1 -> bv
        let s_1150_2: Bits = Bits::new(s_1150_1 as u128, 32u16);
        // C s_1150_3: const #1s : i64
        let s_1150_3: i64 = 1;
        // C s_1150_4: cast zx s_1150_3 -> i
        let s_1150_4: i128 = (i128::try_from(s_1150_3).unwrap());
        // C s_1150_5: const #7s : i
        let s_1150_5: i128 = 7;
        // C s_1150_6: add s_1150_5 s_1150_4
        let s_1150_6: i128 = (s_1150_5 + s_1150_4);
        // D s_1150_7: bit-extract s_1150_2 s_1150_0 s_1150_6
        let s_1150_7: Bits = (Bits::new(
            ((s_1150_2) >> (s_1150_0)).value(),
            u16::try_from(s_1150_6).unwrap(),
        ));
        // D s_1150_8: cast reint s_1150_7 -> u8
        let s_1150_8: u8 = (s_1150_7.value() as u8);
        // D s_1150_9: cast zx s_1150_8 -> bv
        let s_1150_9: Bits = Bits::new(s_1150_8 as u128, 8u16);
        // C s_1150_10: const #245u : u8
        let s_1150_10: u8 = 245;
        // C s_1150_11: cast zx s_1150_10 -> bv
        let s_1150_11: Bits = Bits::new(s_1150_10 as u128, 8u16);
        // D s_1150_12: cmp-eq s_1150_9 s_1150_11
        let s_1150_12: bool = ((s_1150_9) == (s_1150_11));
        // D s_1150_13: write-var gs#410713 <= s_1150_12
        fn_state.gs_410713 = s_1150_12;
        // N s_1150_14: jump b734
        return block_734(state, tracer, fn_state);
    }
    fn block_1151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1151_0: const #28s : i
        let s_1151_0: i128 = 28;
        // C s_1151_1: const #4s : i
        let s_1151_1: i128 = 4;
        // D s_1151_2: read-var u#33738:u32
        let s_1151_2: u32 = fn_state.u_33738;
        // D s_1151_3: cast zx s_1151_2 -> bv
        let s_1151_3: Bits = Bits::new(s_1151_2 as u128, 32u16);
        // D s_1151_4: bit-extract s_1151_3 s_1151_0 s_1151_1
        let s_1151_4: Bits = (Bits::new(
            ((s_1151_3) >> (s_1151_0)).value(),
            u16::try_from(s_1151_1).unwrap(),
        ));
        // D s_1151_5: cast reint s_1151_4 -> u8
        let s_1151_5: u8 = (s_1151_4.value() as u8);
        // D s_1151_6: cast zx s_1151_5 -> bv
        let s_1151_6: Bits = Bits::new(s_1151_5 as u128, 4u16);
        // C s_1151_7: const #15u : u8
        let s_1151_7: u8 = 15;
        // C s_1151_8: cast zx s_1151_7 -> bv
        let s_1151_8: Bits = Bits::new(s_1151_7 as u128, 4u16);
        // D s_1151_9: cmp-ne s_1151_6 s_1151_8
        let s_1151_9: bool = ((s_1151_6) != (s_1151_8));
        // N s_1151_10: branch s_1151_9 b1154 b1152
        if s_1151_9 {
            return block_1154(state, tracer, fn_state);
        } else {
            return block_1152(state, tracer, fn_state);
        };
    }
    fn block_1152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1152_0: const #0u : u8
        let s_1152_0: bool = false;
        // D s_1152_1: write-var gs#410685 <= s_1152_0
        fn_state.gs_410685 = s_1152_0;
        // N s_1152_2: jump b1153
        return block_1153(state, tracer, fn_state);
    }
    fn block_1153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1153_0: read-var gs#410685:u8
        let s_1153_0: bool = fn_state.gs_410685;
        // D s_1153_1: write-var gs#410686 <= s_1153_0
        fn_state.gs_410686 = s_1153_0;
        // N s_1153_2: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_1154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1154_0: const #3296s : i
        let s_1154_0: i128 = 3296;
        // C s_1154_1: const #14696u : u32
        let s_1154_1: u32 = 14696;
        // D s_1154_2: read-reg s_1154_1:i
        let s_1154_2: i128 = {
            let value = state.read_register::<i128>(s_1154_1 as isize);
            tracer.read_register(s_1154_1 as isize, value);
            value
        };
        // D s_1154_3: cmp-lt s_1154_2 s_1154_0
        let s_1154_3: bool = ((s_1154_2) < (s_1154_0));
        // D s_1154_4: write-var gs#410685 <= s_1154_3
        fn_state.gs_410685 = s_1154_3;
        // N s_1154_5: jump b1153
        return block_1153(state, tracer, fn_state);
    }
    fn block_1155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1155_0: const #4s : i
        let s_1155_0: i128 = 4;
        // D s_1155_1: read-var u#33738:u32
        let s_1155_1: u32 = fn_state.u_33738;
        // D s_1155_2: cast zx s_1155_1 -> bv
        let s_1155_2: Bits = Bits::new(s_1155_1 as u128, 32u16);
        // C s_1155_3: const #1s : i64
        let s_1155_3: i64 = 1;
        // C s_1155_4: cast zx s_1155_3 -> i
        let s_1155_4: i128 = (i128::try_from(s_1155_3).unwrap());
        // C s_1155_5: const #7s : i
        let s_1155_5: i128 = 7;
        // C s_1155_6: add s_1155_5 s_1155_4
        let s_1155_6: i128 = (s_1155_5 + s_1155_4);
        // D s_1155_7: bit-extract s_1155_2 s_1155_0 s_1155_6
        let s_1155_7: Bits = (Bits::new(
            ((s_1155_2) >> (s_1155_0)).value(),
            u16::try_from(s_1155_6).unwrap(),
        ));
        // D s_1155_8: cast reint s_1155_7 -> u8
        let s_1155_8: u8 = (s_1155_7.value() as u8);
        // D s_1155_9: cast zx s_1155_8 -> bv
        let s_1155_9: Bits = Bits::new(s_1155_8 as u128, 8u16);
        // C s_1155_10: const #243u : u8
        let s_1155_10: u8 = 243;
        // C s_1155_11: cast zx s_1155_10 -> bv
        let s_1155_11: Bits = Bits::new(s_1155_10 as u128, 8u16);
        // D s_1155_12: cmp-eq s_1155_9 s_1155_11
        let s_1155_12: bool = ((s_1155_9) == (s_1155_11));
        // D s_1155_13: write-var gs#410681 <= s_1155_12
        fn_state.gs_410681 = s_1155_12;
        // N s_1155_14: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_1156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1156_0: const #28s : i
        let s_1156_0: i128 = 28;
        // C s_1156_1: const #4s : i
        let s_1156_1: i128 = 4;
        // D s_1156_2: read-var u#33732:u32
        let s_1156_2: u32 = fn_state.u_33732;
        // D s_1156_3: cast zx s_1156_2 -> bv
        let s_1156_3: Bits = Bits::new(s_1156_2 as u128, 32u16);
        // D s_1156_4: bit-extract s_1156_3 s_1156_0 s_1156_1
        let s_1156_4: Bits = (Bits::new(
            ((s_1156_3) >> (s_1156_0)).value(),
            u16::try_from(s_1156_1).unwrap(),
        ));
        // D s_1156_5: cast reint s_1156_4 -> u8
        let s_1156_5: u8 = (s_1156_4.value() as u8);
        // D s_1156_6: cast zx s_1156_5 -> bv
        let s_1156_6: Bits = Bits::new(s_1156_5 as u128, 4u16);
        // C s_1156_7: const #15u : u8
        let s_1156_7: u8 = 15;
        // C s_1156_8: cast zx s_1156_7 -> bv
        let s_1156_8: Bits = Bits::new(s_1156_7 as u128, 4u16);
        // D s_1156_9: cmp-ne s_1156_6 s_1156_8
        let s_1156_9: bool = ((s_1156_6) != (s_1156_8));
        // N s_1156_10: branch s_1156_9 b1159 b1157
        if s_1156_9 {
            return block_1159(state, tracer, fn_state);
        } else {
            return block_1157(state, tracer, fn_state);
        };
    }
    fn block_1157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1157_0: const #0u : u8
        let s_1157_0: bool = false;
        // D s_1157_1: write-var gs#410653 <= s_1157_0
        fn_state.gs_410653 = s_1157_0;
        // N s_1157_2: jump b1158
        return block_1158(state, tracer, fn_state);
    }
    fn block_1158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1158_0: read-var gs#410653:u8
        let s_1158_0: bool = fn_state.gs_410653;
        // D s_1158_1: write-var gs#410654 <= s_1158_0
        fn_state.gs_410654 = s_1158_0;
        // N s_1158_2: jump b702
        return block_702(state, tracer, fn_state);
    }
    fn block_1159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1159_0: const #3294s : i
        let s_1159_0: i128 = 3294;
        // C s_1159_1: const #14696u : u32
        let s_1159_1: u32 = 14696;
        // D s_1159_2: read-reg s_1159_1:i
        let s_1159_2: i128 = {
            let value = state.read_register::<i128>(s_1159_1 as isize);
            tracer.read_register(s_1159_1 as isize, value);
            value
        };
        // D s_1159_3: cmp-lt s_1159_2 s_1159_0
        let s_1159_3: bool = ((s_1159_2) < (s_1159_0));
        // D s_1159_4: write-var gs#410653 <= s_1159_3
        fn_state.gs_410653 = s_1159_3;
        // N s_1159_5: jump b1158
        return block_1158(state, tracer, fn_state);
    }
    fn block_1160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1160_0: const #4s : i
        let s_1160_0: i128 = 4;
        // D s_1160_1: read-var u#33732:u32
        let s_1160_1: u32 = fn_state.u_33732;
        // D s_1160_2: cast zx s_1160_1 -> bv
        let s_1160_2: Bits = Bits::new(s_1160_1 as u128, 32u16);
        // C s_1160_3: const #1s : i64
        let s_1160_3: i64 = 1;
        // C s_1160_4: cast zx s_1160_3 -> i
        let s_1160_4: i128 = (i128::try_from(s_1160_3).unwrap());
        // C s_1160_5: const #7s : i
        let s_1160_5: i128 = 7;
        // C s_1160_6: add s_1160_5 s_1160_4
        let s_1160_6: i128 = (s_1160_5 + s_1160_4);
        // D s_1160_7: bit-extract s_1160_2 s_1160_0 s_1160_6
        let s_1160_7: Bits = (Bits::new(
            ((s_1160_2) >> (s_1160_0)).value(),
            u16::try_from(s_1160_6).unwrap(),
        ));
        // D s_1160_8: cast reint s_1160_7 -> u8
        let s_1160_8: u8 = (s_1160_7.value() as u8);
        // D s_1160_9: cast zx s_1160_8 -> bv
        let s_1160_9: Bits = Bits::new(s_1160_8 as u128, 8u16);
        // C s_1160_10: const #249u : u8
        let s_1160_10: u8 = 249;
        // C s_1160_11: cast zx s_1160_10 -> bv
        let s_1160_11: Bits = Bits::new(s_1160_10 as u128, 8u16);
        // D s_1160_12: cmp-eq s_1160_9 s_1160_11
        let s_1160_12: bool = ((s_1160_9) == (s_1160_11));
        // D s_1160_13: write-var gs#410649 <= s_1160_12
        fn_state.gs_410649 = s_1160_12;
        // N s_1160_14: jump b700
        return block_700(state, tracer, fn_state);
    }
    fn block_1161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1161_0: const #28s : i
        let s_1161_0: i128 = 28;
        // C s_1161_1: const #4s : i
        let s_1161_1: i128 = 4;
        // D s_1161_2: read-var u#33726:u32
        let s_1161_2: u32 = fn_state.u_33726;
        // D s_1161_3: cast zx s_1161_2 -> bv
        let s_1161_3: Bits = Bits::new(s_1161_2 as u128, 32u16);
        // D s_1161_4: bit-extract s_1161_3 s_1161_0 s_1161_1
        let s_1161_4: Bits = (Bits::new(
            ((s_1161_3) >> (s_1161_0)).value(),
            u16::try_from(s_1161_1).unwrap(),
        ));
        // D s_1161_5: cast reint s_1161_4 -> u8
        let s_1161_5: u8 = (s_1161_4.value() as u8);
        // D s_1161_6: cast zx s_1161_5 -> bv
        let s_1161_6: Bits = Bits::new(s_1161_5 as u128, 4u16);
        // C s_1161_7: const #15u : u8
        let s_1161_7: u8 = 15;
        // C s_1161_8: cast zx s_1161_7 -> bv
        let s_1161_8: Bits = Bits::new(s_1161_7 as u128, 4u16);
        // D s_1161_9: cmp-ne s_1161_6 s_1161_8
        let s_1161_9: bool = ((s_1161_6) != (s_1161_8));
        // N s_1161_10: branch s_1161_9 b1164 b1162
        if s_1161_9 {
            return block_1164(state, tracer, fn_state);
        } else {
            return block_1162(state, tracer, fn_state);
        };
    }
    fn block_1162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1162_0: const #0u : u8
        let s_1162_0: bool = false;
        // D s_1162_1: write-var gs#410621 <= s_1162_0
        fn_state.gs_410621 = s_1162_0;
        // N s_1162_2: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_1163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1163_0: read-var gs#410621:u8
        let s_1163_0: bool = fn_state.gs_410621;
        // D s_1163_1: write-var gs#410622 <= s_1163_0
        fn_state.gs_410622 = s_1163_0;
        // N s_1163_2: jump b685
        return block_685(state, tracer, fn_state);
    }
    fn block_1164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1164_0: const #3292s : i
        let s_1164_0: i128 = 3292;
        // C s_1164_1: const #14696u : u32
        let s_1164_1: u32 = 14696;
        // D s_1164_2: read-reg s_1164_1:i
        let s_1164_2: i128 = {
            let value = state.read_register::<i128>(s_1164_1 as isize);
            tracer.read_register(s_1164_1 as isize, value);
            value
        };
        // D s_1164_3: cmp-lt s_1164_2 s_1164_0
        let s_1164_3: bool = ((s_1164_2) < (s_1164_0));
        // D s_1164_4: write-var gs#410621 <= s_1164_3
        fn_state.gs_410621 = s_1164_3;
        // N s_1164_5: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_1165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1165_0: const #4s : i
        let s_1165_0: i128 = 4;
        // D s_1165_1: read-var u#33726:u32
        let s_1165_1: u32 = fn_state.u_33726;
        // D s_1165_2: cast zx s_1165_1 -> bv
        let s_1165_2: Bits = Bits::new(s_1165_1 as u128, 32u16);
        // C s_1165_3: const #1s : i64
        let s_1165_3: i64 = 1;
        // C s_1165_4: cast zx s_1165_3 -> i
        let s_1165_4: i128 = (i128::try_from(s_1165_3).unwrap());
        // C s_1165_5: const #7s : i
        let s_1165_5: i128 = 7;
        // C s_1165_6: add s_1165_5 s_1165_4
        let s_1165_6: i128 = (s_1165_5 + s_1165_4);
        // D s_1165_7: bit-extract s_1165_2 s_1165_0 s_1165_6
        let s_1165_7: Bits = (Bits::new(
            ((s_1165_2) >> (s_1165_0)).value(),
            u16::try_from(s_1165_6).unwrap(),
        ));
        // D s_1165_8: cast reint s_1165_7 -> u8
        let s_1165_8: u8 = (s_1165_7.value() as u8);
        // D s_1165_9: cast zx s_1165_8 -> bv
        let s_1165_9: Bits = Bits::new(s_1165_8 as u128, 8u16);
        // C s_1165_10: const #241u : u8
        let s_1165_10: u8 = 241;
        // C s_1165_11: cast zx s_1165_10 -> bv
        let s_1165_11: Bits = Bits::new(s_1165_10 as u128, 8u16);
        // D s_1165_12: cmp-eq s_1165_9 s_1165_11
        let s_1165_12: bool = ((s_1165_9) == (s_1165_11));
        // D s_1165_13: write-var gs#410617 <= s_1165_12
        fn_state.gs_410617 = s_1165_12;
        // N s_1165_14: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_1166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1166_0: const #28s : i
        let s_1166_0: i128 = 28;
        // C s_1166_1: const #4s : i
        let s_1166_1: i128 = 4;
        // D s_1166_2: read-var u#33719:u32
        let s_1166_2: u32 = fn_state.u_33719;
        // D s_1166_3: cast zx s_1166_2 -> bv
        let s_1166_3: Bits = Bits::new(s_1166_2 as u128, 32u16);
        // D s_1166_4: bit-extract s_1166_3 s_1166_0 s_1166_1
        let s_1166_4: Bits = (Bits::new(
            ((s_1166_3) >> (s_1166_0)).value(),
            u16::try_from(s_1166_1).unwrap(),
        ));
        // D s_1166_5: cast reint s_1166_4 -> u8
        let s_1166_5: u8 = (s_1166_4.value() as u8);
        // D s_1166_6: cast zx s_1166_5 -> bv
        let s_1166_6: Bits = Bits::new(s_1166_5 as u128, 4u16);
        // C s_1166_7: const #15u : u8
        let s_1166_7: u8 = 15;
        // C s_1166_8: cast zx s_1166_7 -> bv
        let s_1166_8: Bits = Bits::new(s_1166_7 as u128, 4u16);
        // D s_1166_9: cmp-ne s_1166_6 s_1166_8
        let s_1166_9: bool = ((s_1166_6) != (s_1166_8));
        // N s_1166_10: branch s_1166_9 b1169 b1167
        if s_1166_9 {
            return block_1169(state, tracer, fn_state);
        } else {
            return block_1167(state, tracer, fn_state);
        };
    }
    fn block_1167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1167_0: const #0u : u8
        let s_1167_0: bool = false;
        // D s_1167_1: write-var gs#410598 <= s_1167_0
        fn_state.gs_410598 = s_1167_0;
        // N s_1167_2: jump b1168
        return block_1168(state, tracer, fn_state);
    }
    fn block_1168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1168_0: read-var gs#410598:u8
        let s_1168_0: bool = fn_state.gs_410598;
        // D s_1168_1: write-var gs#410599 <= s_1168_0
        fn_state.gs_410599 = s_1168_0;
        // N s_1168_2: jump b679
        return block_679(state, tracer, fn_state);
    }
    fn block_1169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1169_0: const #3290s : i
        let s_1169_0: i128 = 3290;
        // C s_1169_1: const #14696u : u32
        let s_1169_1: u32 = 14696;
        // D s_1169_2: read-reg s_1169_1:i
        let s_1169_2: i128 = {
            let value = state.read_register::<i128>(s_1169_1 as isize);
            tracer.read_register(s_1169_1 as isize, value);
            value
        };
        // D s_1169_3: cmp-lt s_1169_2 s_1169_0
        let s_1169_3: bool = ((s_1169_2) < (s_1169_0));
        // D s_1169_4: write-var gs#410598 <= s_1169_3
        fn_state.gs_410598 = s_1169_3;
        // N s_1169_5: jump b1168
        return block_1168(state, tracer, fn_state);
    }
    fn block_1170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1170_0: const #4s : i
        let s_1170_0: i128 = 4;
        // D s_1170_1: read-var u#33719:u32
        let s_1170_1: u32 = fn_state.u_33719;
        // D s_1170_2: cast zx s_1170_1 -> bv
        let s_1170_2: Bits = Bits::new(s_1170_1 as u128, 32u16);
        // C s_1170_3: const #1s : i64
        let s_1170_3: i64 = 1;
        // C s_1170_4: cast zx s_1170_3 -> i
        let s_1170_4: i128 = (i128::try_from(s_1170_3).unwrap());
        // C s_1170_5: const #3s : i
        let s_1170_5: i128 = 3;
        // C s_1170_6: add s_1170_5 s_1170_4
        let s_1170_6: i128 = (s_1170_5 + s_1170_4);
        // D s_1170_7: bit-extract s_1170_2 s_1170_0 s_1170_6
        let s_1170_7: Bits = (Bits::new(
            ((s_1170_2) >> (s_1170_0)).value(),
            u16::try_from(s_1170_6).unwrap(),
        ));
        // D s_1170_8: cast reint s_1170_7 -> u8
        let s_1170_8: u8 = (s_1170_7.value() as u8);
        // D s_1170_9: cast zx s_1170_8 -> bv
        let s_1170_9: Bits = Bits::new(s_1170_8 as u128, 4u16);
        // C s_1170_10: const #1u : u8
        let s_1170_10: u8 = 1;
        // C s_1170_11: cast zx s_1170_10 -> bv
        let s_1170_11: Bits = Bits::new(s_1170_10 as u128, 4u16);
        // D s_1170_12: cmp-eq s_1170_9 s_1170_11
        let s_1170_12: bool = ((s_1170_9) == (s_1170_11));
        // D s_1170_13: write-var gs#410594 <= s_1170_12
        fn_state.gs_410594 = s_1170_12;
        // N s_1170_14: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_1171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1171_0: const #3287s : i
        let s_1171_0: i128 = 3287;
        // C s_1171_1: const #14696u : u32
        let s_1171_1: u32 = 14696;
        // D s_1171_2: read-reg s_1171_1:i
        let s_1171_2: i128 = {
            let value = state.read_register::<i128>(s_1171_1 as isize);
            tracer.read_register(s_1171_1 as isize, value);
            value
        };
        // D s_1171_3: cmp-lt s_1171_2 s_1171_0
        let s_1171_3: bool = ((s_1171_2) < (s_1171_0));
        // D s_1171_4: write-var gs#410582 <= s_1171_3
        fn_state.gs_410582 = s_1171_3;
        // N s_1171_5: jump b673
        return block_673(state, tracer, fn_state);
    }
    fn block_1172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1172_0: const #4s : i
        let s_1172_0: i128 = 4;
        // D s_1172_1: read-var u#33717:u32
        let s_1172_1: u32 = fn_state.u_33717;
        // D s_1172_2: cast zx s_1172_1 -> bv
        let s_1172_2: Bits = Bits::new(s_1172_1 as u128, 32u16);
        // C s_1172_3: const #1s : i64
        let s_1172_3: i64 = 1;
        // C s_1172_4: cast zx s_1172_3 -> i
        let s_1172_4: i128 = (i128::try_from(s_1172_3).unwrap());
        // C s_1172_5: const #3s : i
        let s_1172_5: i128 = 3;
        // C s_1172_6: add s_1172_5 s_1172_4
        let s_1172_6: i128 = (s_1172_5 + s_1172_4);
        // D s_1172_7: bit-extract s_1172_2 s_1172_0 s_1172_6
        let s_1172_7: Bits = (Bits::new(
            ((s_1172_2) >> (s_1172_0)).value(),
            u16::try_from(s_1172_6).unwrap(),
        ));
        // D s_1172_8: cast reint s_1172_7 -> u8
        let s_1172_8: u8 = (s_1172_7.value() as u8);
        // D s_1172_9: cast zx s_1172_8 -> bv
        let s_1172_9: Bits = Bits::new(s_1172_8 as u128, 4u16);
        // C s_1172_10: const #15u : u8
        let s_1172_10: u8 = 15;
        // C s_1172_11: cast zx s_1172_10 -> bv
        let s_1172_11: Bits = Bits::new(s_1172_10 as u128, 4u16);
        // D s_1172_12: cmp-eq s_1172_9 s_1172_11
        let s_1172_12: bool = ((s_1172_9) == (s_1172_11));
        // D s_1172_13: write-var gs#410580 <= s_1172_12
        fn_state.gs_410580 = s_1172_12;
        // N s_1172_14: jump b671
        return block_671(state, tracer, fn_state);
    }
    fn block_1173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1173_0: const #28s : i
        let s_1173_0: i128 = 28;
        // C s_1173_1: const #4s : i
        let s_1173_1: i128 = 4;
        // D s_1173_2: read-var u#33710:u32
        let s_1173_2: u32 = fn_state.u_33710;
        // D s_1173_3: cast zx s_1173_2 -> bv
        let s_1173_3: Bits = Bits::new(s_1173_2 as u128, 32u16);
        // D s_1173_4: bit-extract s_1173_3 s_1173_0 s_1173_1
        let s_1173_4: Bits = (Bits::new(
            ((s_1173_3) >> (s_1173_0)).value(),
            u16::try_from(s_1173_1).unwrap(),
        ));
        // D s_1173_5: cast reint s_1173_4 -> u8
        let s_1173_5: u8 = (s_1173_4.value() as u8);
        // D s_1173_6: cast zx s_1173_5 -> bv
        let s_1173_6: Bits = Bits::new(s_1173_5 as u128, 4u16);
        // C s_1173_7: const #15u : u8
        let s_1173_7: u8 = 15;
        // C s_1173_8: cast zx s_1173_7 -> bv
        let s_1173_8: Bits = Bits::new(s_1173_7 as u128, 4u16);
        // D s_1173_9: cmp-ne s_1173_6 s_1173_8
        let s_1173_9: bool = ((s_1173_6) != (s_1173_8));
        // N s_1173_10: branch s_1173_9 b1176 b1174
        if s_1173_9 {
            return block_1176(state, tracer, fn_state);
        } else {
            return block_1174(state, tracer, fn_state);
        };
    }
    fn block_1174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1174_0: const #0u : u8
        let s_1174_0: bool = false;
        // D s_1174_1: write-var gs#410561 <= s_1174_0
        fn_state.gs_410561 = s_1174_0;
        // N s_1174_2: jump b1175
        return block_1175(state, tracer, fn_state);
    }
    fn block_1175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1175_0: read-var gs#410561:u8
        let s_1175_0: bool = fn_state.gs_410561;
        // D s_1175_1: write-var gs#410562 <= s_1175_0
        fn_state.gs_410562 = s_1175_0;
        // N s_1175_2: jump b667
        return block_667(state, tracer, fn_state);
    }
    fn block_1176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1176_0: const #3285s : i
        let s_1176_0: i128 = 3285;
        // C s_1176_1: const #14696u : u32
        let s_1176_1: u32 = 14696;
        // D s_1176_2: read-reg s_1176_1:i
        let s_1176_2: i128 = {
            let value = state.read_register::<i128>(s_1176_1 as isize);
            tracer.read_register(s_1176_1 as isize, value);
            value
        };
        // D s_1176_3: cmp-lt s_1176_2 s_1176_0
        let s_1176_3: bool = ((s_1176_2) < (s_1176_0));
        // D s_1176_4: write-var gs#410561 <= s_1176_3
        fn_state.gs_410561 = s_1176_3;
        // N s_1176_5: jump b1175
        return block_1175(state, tracer, fn_state);
    }
    fn block_1177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1177_0: const #4s : i
        let s_1177_0: i128 = 4;
        // D s_1177_1: read-var u#33710:u32
        let s_1177_1: u32 = fn_state.u_33710;
        // D s_1177_2: cast zx s_1177_1 -> bv
        let s_1177_2: Bits = Bits::new(s_1177_1 as u128, 32u16);
        // C s_1177_3: const #1s : i64
        let s_1177_3: i64 = 1;
        // C s_1177_4: cast zx s_1177_3 -> i
        let s_1177_4: i128 = (i128::try_from(s_1177_3).unwrap());
        // C s_1177_5: const #2s : i
        let s_1177_5: i128 = 2;
        // C s_1177_6: add s_1177_5 s_1177_4
        let s_1177_6: i128 = (s_1177_5 + s_1177_4);
        // D s_1177_7: bit-extract s_1177_2 s_1177_0 s_1177_6
        let s_1177_7: Bits = (Bits::new(
            ((s_1177_2) >> (s_1177_0)).value(),
            u16::try_from(s_1177_6).unwrap(),
        ));
        // D s_1177_8: cast reint s_1177_7 -> u8
        let s_1177_8: u8 = (s_1177_7.value() as u8);
        // D s_1177_9: cast zx s_1177_8 -> bv
        let s_1177_9: Bits = Bits::new(s_1177_8 as u128, 3u16);
        // C s_1177_10: const #5u : u8
        let s_1177_10: u8 = 5;
        // C s_1177_11: cast zx s_1177_10 -> bv
        let s_1177_11: Bits = Bits::new(s_1177_10 as u128, 3u16);
        // D s_1177_12: cmp-eq s_1177_9 s_1177_11
        let s_1177_12: bool = ((s_1177_9) == (s_1177_11));
        // D s_1177_13: write-var gs#410557 <= s_1177_12
        fn_state.gs_410557 = s_1177_12;
        // N s_1177_14: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_1178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1178_0: const #28s : i
        let s_1178_0: i128 = 28;
        // C s_1178_1: const #4s : i
        let s_1178_1: i128 = 4;
        // D s_1178_2: read-var u#33704:u32
        let s_1178_2: u32 = fn_state.u_33704;
        // D s_1178_3: cast zx s_1178_2 -> bv
        let s_1178_3: Bits = Bits::new(s_1178_2 as u128, 32u16);
        // D s_1178_4: bit-extract s_1178_3 s_1178_0 s_1178_1
        let s_1178_4: Bits = (Bits::new(
            ((s_1178_3) >> (s_1178_0)).value(),
            u16::try_from(s_1178_1).unwrap(),
        ));
        // D s_1178_5: cast reint s_1178_4 -> u8
        let s_1178_5: u8 = (s_1178_4.value() as u8);
        // D s_1178_6: cast zx s_1178_5 -> bv
        let s_1178_6: Bits = Bits::new(s_1178_5 as u128, 4u16);
        // C s_1178_7: const #15u : u8
        let s_1178_7: u8 = 15;
        // C s_1178_8: cast zx s_1178_7 -> bv
        let s_1178_8: Bits = Bits::new(s_1178_7 as u128, 4u16);
        // D s_1178_9: cmp-ne s_1178_6 s_1178_8
        let s_1178_9: bool = ((s_1178_6) != (s_1178_8));
        // N s_1178_10: branch s_1178_9 b1181 b1179
        if s_1178_9 {
            return block_1181(state, tracer, fn_state);
        } else {
            return block_1179(state, tracer, fn_state);
        };
    }
    fn block_1179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1179_0: const #0u : u8
        let s_1179_0: bool = false;
        // D s_1179_1: write-var gs#410529 <= s_1179_0
        fn_state.gs_410529 = s_1179_0;
        // N s_1179_2: jump b1180
        return block_1180(state, tracer, fn_state);
    }
    fn block_1180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1180_0: read-var gs#410529:u8
        let s_1180_0: bool = fn_state.gs_410529;
        // D s_1180_1: write-var gs#410530 <= s_1180_0
        fn_state.gs_410530 = s_1180_0;
        // N s_1180_2: jump b650
        return block_650(state, tracer, fn_state);
    }
    fn block_1181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1181_0: const #3283s : i
        let s_1181_0: i128 = 3283;
        // C s_1181_1: const #14696u : u32
        let s_1181_1: u32 = 14696;
        // D s_1181_2: read-reg s_1181_1:i
        let s_1181_2: i128 = {
            let value = state.read_register::<i128>(s_1181_1 as isize);
            tracer.read_register(s_1181_1 as isize, value);
            value
        };
        // D s_1181_3: cmp-lt s_1181_2 s_1181_0
        let s_1181_3: bool = ((s_1181_2) < (s_1181_0));
        // D s_1181_4: write-var gs#410529 <= s_1181_3
        fn_state.gs_410529 = s_1181_3;
        // N s_1181_5: jump b1180
        return block_1180(state, tracer, fn_state);
    }
    fn block_1182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1182_0: const #4s : i
        let s_1182_0: i128 = 4;
        // D s_1182_1: read-var u#33704:u32
        let s_1182_1: u32 = fn_state.u_33704;
        // D s_1182_2: cast zx s_1182_1 -> bv
        let s_1182_2: Bits = Bits::new(s_1182_1 as u128, 32u16);
        // C s_1182_3: const #1s : i64
        let s_1182_3: i64 = 1;
        // C s_1182_4: cast zx s_1182_3 -> i
        let s_1182_4: i128 = (i128::try_from(s_1182_3).unwrap());
        // C s_1182_5: const #7s : i
        let s_1182_5: i128 = 7;
        // C s_1182_6: add s_1182_5 s_1182_4
        let s_1182_6: i128 = (s_1182_5 + s_1182_4);
        // D s_1182_7: bit-extract s_1182_2 s_1182_0 s_1182_6
        let s_1182_7: Bits = (Bits::new(
            ((s_1182_2) >> (s_1182_0)).value(),
            u16::try_from(s_1182_6).unwrap(),
        ));
        // D s_1182_8: cast reint s_1182_7 -> u8
        let s_1182_8: u8 = (s_1182_7.value() as u8);
        // D s_1182_9: cast zx s_1182_8 -> bv
        let s_1182_9: Bits = Bits::new(s_1182_8 as u128, 8u16);
        // C s_1182_10: const #243u : u8
        let s_1182_10: u8 = 243;
        // C s_1182_11: cast zx s_1182_10 -> bv
        let s_1182_11: Bits = Bits::new(s_1182_10 as u128, 8u16);
        // D s_1182_12: cmp-eq s_1182_9 s_1182_11
        let s_1182_12: bool = ((s_1182_9) == (s_1182_11));
        // D s_1182_13: write-var gs#410525 <= s_1182_12
        fn_state.gs_410525 = s_1182_12;
        // N s_1182_14: jump b648
        return block_648(state, tracer, fn_state);
    }
    fn block_1183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1183_0: const #28s : i
        let s_1183_0: i128 = 28;
        // C s_1183_1: const #4s : i
        let s_1183_1: i128 = 4;
        // D s_1183_2: read-var u#33698:u32
        let s_1183_2: u32 = fn_state.u_33698;
        // D s_1183_3: cast zx s_1183_2 -> bv
        let s_1183_3: Bits = Bits::new(s_1183_2 as u128, 32u16);
        // D s_1183_4: bit-extract s_1183_3 s_1183_0 s_1183_1
        let s_1183_4: Bits = (Bits::new(
            ((s_1183_3) >> (s_1183_0)).value(),
            u16::try_from(s_1183_1).unwrap(),
        ));
        // D s_1183_5: cast reint s_1183_4 -> u8
        let s_1183_5: u8 = (s_1183_4.value() as u8);
        // D s_1183_6: cast zx s_1183_5 -> bv
        let s_1183_6: Bits = Bits::new(s_1183_5 as u128, 4u16);
        // C s_1183_7: const #15u : u8
        let s_1183_7: u8 = 15;
        // C s_1183_8: cast zx s_1183_7 -> bv
        let s_1183_8: Bits = Bits::new(s_1183_7 as u128, 4u16);
        // D s_1183_9: cmp-ne s_1183_6 s_1183_8
        let s_1183_9: bool = ((s_1183_6) != (s_1183_8));
        // N s_1183_10: branch s_1183_9 b1186 b1184
        if s_1183_9 {
            return block_1186(state, tracer, fn_state);
        } else {
            return block_1184(state, tracer, fn_state);
        };
    }
    fn block_1184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1184_0: const #0u : u8
        let s_1184_0: bool = false;
        // D s_1184_1: write-var gs#410497 <= s_1184_0
        fn_state.gs_410497 = s_1184_0;
        // N s_1184_2: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_1185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1185_0: read-var gs#410497:u8
        let s_1185_0: bool = fn_state.gs_410497;
        // D s_1185_1: write-var gs#410498 <= s_1185_0
        fn_state.gs_410498 = s_1185_0;
        // N s_1185_2: jump b633
        return block_633(state, tracer, fn_state);
    }
    fn block_1186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1186_0: const #3281s : i
        let s_1186_0: i128 = 3281;
        // C s_1186_1: const #14696u : u32
        let s_1186_1: u32 = 14696;
        // D s_1186_2: read-reg s_1186_1:i
        let s_1186_2: i128 = {
            let value = state.read_register::<i128>(s_1186_1 as isize);
            tracer.read_register(s_1186_1 as isize, value);
            value
        };
        // D s_1186_3: cmp-lt s_1186_2 s_1186_0
        let s_1186_3: bool = ((s_1186_2) < (s_1186_0));
        // D s_1186_4: write-var gs#410497 <= s_1186_3
        fn_state.gs_410497 = s_1186_3;
        // N s_1186_5: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_1187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1187_0: const #4s : i
        let s_1187_0: i128 = 4;
        // D s_1187_1: read-var u#33698:u32
        let s_1187_1: u32 = fn_state.u_33698;
        // D s_1187_2: cast zx s_1187_1 -> bv
        let s_1187_2: Bits = Bits::new(s_1187_1 as u128, 32u16);
        // C s_1187_3: const #1s : i64
        let s_1187_3: i64 = 1;
        // C s_1187_4: cast zx s_1187_3 -> i
        let s_1187_4: i128 = (i128::try_from(s_1187_3).unwrap());
        // C s_1187_5: const #7s : i
        let s_1187_5: i128 = 7;
        // C s_1187_6: add s_1187_5 s_1187_4
        let s_1187_6: i128 = (s_1187_5 + s_1187_4);
        // D s_1187_7: bit-extract s_1187_2 s_1187_0 s_1187_6
        let s_1187_7: Bits = (Bits::new(
            ((s_1187_2) >> (s_1187_0)).value(),
            u16::try_from(s_1187_6).unwrap(),
        ));
        // D s_1187_8: cast reint s_1187_7 -> u8
        let s_1187_8: u8 = (s_1187_7.value() as u8);
        // D s_1187_9: cast zx s_1187_8 -> bv
        let s_1187_9: Bits = Bits::new(s_1187_8 as u128, 8u16);
        // C s_1187_10: const #249u : u8
        let s_1187_10: u8 = 249;
        // C s_1187_11: cast zx s_1187_10 -> bv
        let s_1187_11: Bits = Bits::new(s_1187_10 as u128, 8u16);
        // D s_1187_12: cmp-eq s_1187_9 s_1187_11
        let s_1187_12: bool = ((s_1187_9) == (s_1187_11));
        // D s_1187_13: write-var gs#410493 <= s_1187_12
        fn_state.gs_410493 = s_1187_12;
        // N s_1187_14: jump b631
        return block_631(state, tracer, fn_state);
    }
    fn block_1188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1188_0: const #28s : i
        let s_1188_0: i128 = 28;
        // C s_1188_1: const #4s : i
        let s_1188_1: i128 = 4;
        // D s_1188_2: read-var u#33692:u32
        let s_1188_2: u32 = fn_state.u_33692;
        // D s_1188_3: cast zx s_1188_2 -> bv
        let s_1188_3: Bits = Bits::new(s_1188_2 as u128, 32u16);
        // D s_1188_4: bit-extract s_1188_3 s_1188_0 s_1188_1
        let s_1188_4: Bits = (Bits::new(
            ((s_1188_3) >> (s_1188_0)).value(),
            u16::try_from(s_1188_1).unwrap(),
        ));
        // D s_1188_5: cast reint s_1188_4 -> u8
        let s_1188_5: u8 = (s_1188_4.value() as u8);
        // D s_1188_6: cast zx s_1188_5 -> bv
        let s_1188_6: Bits = Bits::new(s_1188_5 as u128, 4u16);
        // C s_1188_7: const #15u : u8
        let s_1188_7: u8 = 15;
        // C s_1188_8: cast zx s_1188_7 -> bv
        let s_1188_8: Bits = Bits::new(s_1188_7 as u128, 4u16);
        // D s_1188_9: cmp-ne s_1188_6 s_1188_8
        let s_1188_9: bool = ((s_1188_6) != (s_1188_8));
        // N s_1188_10: branch s_1188_9 b1191 b1189
        if s_1188_9 {
            return block_1191(state, tracer, fn_state);
        } else {
            return block_1189(state, tracer, fn_state);
        };
    }
    fn block_1189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1189_0: const #0u : u8
        let s_1189_0: bool = false;
        // D s_1189_1: write-var gs#410465 <= s_1189_0
        fn_state.gs_410465 = s_1189_0;
        // N s_1189_2: jump b1190
        return block_1190(state, tracer, fn_state);
    }
    fn block_1190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1190_0: read-var gs#410465:u8
        let s_1190_0: bool = fn_state.gs_410465;
        // D s_1190_1: write-var gs#410466 <= s_1190_0
        fn_state.gs_410466 = s_1190_0;
        // N s_1190_2: jump b616
        return block_616(state, tracer, fn_state);
    }
    fn block_1191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1191_0: const #3279s : i
        let s_1191_0: i128 = 3279;
        // C s_1191_1: const #14696u : u32
        let s_1191_1: u32 = 14696;
        // D s_1191_2: read-reg s_1191_1:i
        let s_1191_2: i128 = {
            let value = state.read_register::<i128>(s_1191_1 as isize);
            tracer.read_register(s_1191_1 as isize, value);
            value
        };
        // D s_1191_3: cmp-lt s_1191_2 s_1191_0
        let s_1191_3: bool = ((s_1191_2) < (s_1191_0));
        // D s_1191_4: write-var gs#410465 <= s_1191_3
        fn_state.gs_410465 = s_1191_3;
        // N s_1191_5: jump b1190
        return block_1190(state, tracer, fn_state);
    }
    fn block_1192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1192_0: const #4s : i
        let s_1192_0: i128 = 4;
        // D s_1192_1: read-var u#33692:u32
        let s_1192_1: u32 = fn_state.u_33692;
        // D s_1192_2: cast zx s_1192_1 -> bv
        let s_1192_2: Bits = Bits::new(s_1192_1 as u128, 32u16);
        // C s_1192_3: const #1s : i64
        let s_1192_3: i64 = 1;
        // C s_1192_4: cast zx s_1192_3 -> i
        let s_1192_4: i128 = (i128::try_from(s_1192_3).unwrap());
        // C s_1192_5: const #7s : i
        let s_1192_5: i128 = 7;
        // C s_1192_6: add s_1192_5 s_1192_4
        let s_1192_6: i128 = (s_1192_5 + s_1192_4);
        // D s_1192_7: bit-extract s_1192_2 s_1192_0 s_1192_6
        let s_1192_7: Bits = (Bits::new(
            ((s_1192_2) >> (s_1192_0)).value(),
            u16::try_from(s_1192_6).unwrap(),
        ));
        // D s_1192_8: cast reint s_1192_7 -> u8
        let s_1192_8: u8 = (s_1192_7.value() as u8);
        // D s_1192_9: cast zx s_1192_8 -> bv
        let s_1192_9: Bits = Bits::new(s_1192_8 as u128, 8u16);
        // C s_1192_10: const #241u : u8
        let s_1192_10: u8 = 241;
        // C s_1192_11: cast zx s_1192_10 -> bv
        let s_1192_11: Bits = Bits::new(s_1192_10 as u128, 8u16);
        // D s_1192_12: cmp-eq s_1192_9 s_1192_11
        let s_1192_12: bool = ((s_1192_9) == (s_1192_11));
        // D s_1192_13: write-var gs#410461 <= s_1192_12
        fn_state.gs_410461 = s_1192_12;
        // N s_1192_14: jump b614
        return block_614(state, tracer, fn_state);
    }
    fn block_1193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1193_0: const #28s : i
        let s_1193_0: i128 = 28;
        // C s_1193_1: const #4s : i
        let s_1193_1: i128 = 4;
        // D s_1193_2: read-var u#33686:u32
        let s_1193_2: u32 = fn_state.u_33686;
        // D s_1193_3: cast zx s_1193_2 -> bv
        let s_1193_3: Bits = Bits::new(s_1193_2 as u128, 32u16);
        // D s_1193_4: bit-extract s_1193_3 s_1193_0 s_1193_1
        let s_1193_4: Bits = (Bits::new(
            ((s_1193_3) >> (s_1193_0)).value(),
            u16::try_from(s_1193_1).unwrap(),
        ));
        // D s_1193_5: cast reint s_1193_4 -> u8
        let s_1193_5: u8 = (s_1193_4.value() as u8);
        // D s_1193_6: cast zx s_1193_5 -> bv
        let s_1193_6: Bits = Bits::new(s_1193_5 as u128, 4u16);
        // C s_1193_7: const #15u : u8
        let s_1193_7: u8 = 15;
        // C s_1193_8: cast zx s_1193_7 -> bv
        let s_1193_8: Bits = Bits::new(s_1193_7 as u128, 4u16);
        // D s_1193_9: cmp-ne s_1193_6 s_1193_8
        let s_1193_9: bool = ((s_1193_6) != (s_1193_8));
        // N s_1193_10: branch s_1193_9 b1196 b1194
        if s_1193_9 {
            return block_1196(state, tracer, fn_state);
        } else {
            return block_1194(state, tracer, fn_state);
        };
    }
    fn block_1194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1194_0: const #0u : u8
        let s_1194_0: bool = false;
        // D s_1194_1: write-var gs#410439 <= s_1194_0
        fn_state.gs_410439 = s_1194_0;
        // N s_1194_2: jump b1195
        return block_1195(state, tracer, fn_state);
    }
    fn block_1195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1195_0: read-var gs#410439:u8
        let s_1195_0: bool = fn_state.gs_410439;
        // D s_1195_1: write-var gs#410440 <= s_1195_0
        fn_state.gs_410440 = s_1195_0;
        // N s_1195_2: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_1196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1196_0: const #3264s : i
        let s_1196_0: i128 = 3264;
        // C s_1196_1: const #14696u : u32
        let s_1196_1: u32 = 14696;
        // D s_1196_2: read-reg s_1196_1:i
        let s_1196_2: i128 = {
            let value = state.read_register::<i128>(s_1196_1 as isize);
            tracer.read_register(s_1196_1 as isize, value);
            value
        };
        // D s_1196_3: cmp-lt s_1196_2 s_1196_0
        let s_1196_3: bool = ((s_1196_2) < (s_1196_0));
        // D s_1196_4: write-var gs#410439 <= s_1196_3
        fn_state.gs_410439 = s_1196_3;
        // N s_1196_5: jump b1195
        return block_1195(state, tracer, fn_state);
    }
    fn block_1197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1197_0: const #4s : i
        let s_1197_0: i128 = 4;
        // D s_1197_1: read-var u#33686:u32
        let s_1197_1: u32 = fn_state.u_33686;
        // D s_1197_2: cast zx s_1197_1 -> bv
        let s_1197_2: Bits = Bits::new(s_1197_1 as u128, 32u16);
        // C s_1197_3: const #1s : i64
        let s_1197_3: i64 = 1;
        // C s_1197_4: cast zx s_1197_3 -> i
        let s_1197_4: i128 = (i128::try_from(s_1197_3).unwrap());
        // C s_1197_5: const #5s : i
        let s_1197_5: i128 = 5;
        // C s_1197_6: add s_1197_5 s_1197_4
        let s_1197_6: i128 = (s_1197_5 + s_1197_4);
        // D s_1197_7: bit-extract s_1197_2 s_1197_0 s_1197_6
        let s_1197_7: Bits = (Bits::new(
            ((s_1197_2) >> (s_1197_0)).value(),
            u16::try_from(s_1197_6).unwrap(),
        ));
        // D s_1197_8: cast reint s_1197_7 -> u8
        let s_1197_8: u8 = (s_1197_7.value() as u8);
        // D s_1197_9: cast zx s_1197_8 -> bv
        let s_1197_9: Bits = Bits::new(s_1197_8 as u128, 6u16);
        // C s_1197_10: const #7u : u8
        let s_1197_10: u8 = 7;
        // C s_1197_11: cast zx s_1197_10 -> bv
        let s_1197_11: Bits = Bits::new(s_1197_10 as u128, 6u16);
        // D s_1197_12: cmp-eq s_1197_9 s_1197_11
        let s_1197_12: bool = ((s_1197_9) == (s_1197_11));
        // D s_1197_13: write-var gs#410435 <= s_1197_12
        fn_state.gs_410435 = s_1197_12;
        // N s_1197_14: jump b603
        return block_603(state, tracer, fn_state);
    }
    fn block_1198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1198_0: const #28s : i
        let s_1198_0: i128 = 28;
        // C s_1198_1: const #4s : i
        let s_1198_1: i128 = 4;
        // D s_1198_2: read-var u#33680:u32
        let s_1198_2: u32 = fn_state.u_33680;
        // D s_1198_3: cast zx s_1198_2 -> bv
        let s_1198_3: Bits = Bits::new(s_1198_2 as u128, 32u16);
        // D s_1198_4: bit-extract s_1198_3 s_1198_0 s_1198_1
        let s_1198_4: Bits = (Bits::new(
            ((s_1198_3) >> (s_1198_0)).value(),
            u16::try_from(s_1198_1).unwrap(),
        ));
        // D s_1198_5: cast reint s_1198_4 -> u8
        let s_1198_5: u8 = (s_1198_4.value() as u8);
        // D s_1198_6: cast zx s_1198_5 -> bv
        let s_1198_6: Bits = Bits::new(s_1198_5 as u128, 4u16);
        // C s_1198_7: const #15u : u8
        let s_1198_7: u8 = 15;
        // C s_1198_8: cast zx s_1198_7 -> bv
        let s_1198_8: Bits = Bits::new(s_1198_7 as u128, 4u16);
        // D s_1198_9: cmp-ne s_1198_6 s_1198_8
        let s_1198_9: bool = ((s_1198_6) != (s_1198_8));
        // N s_1198_10: branch s_1198_9 b1201 b1199
        if s_1198_9 {
            return block_1201(state, tracer, fn_state);
        } else {
            return block_1199(state, tracer, fn_state);
        };
    }
    fn block_1199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1199_0: const #0u : u8
        let s_1199_0: bool = false;
        // D s_1199_1: write-var gs#410413 <= s_1199_0
        fn_state.gs_410413 = s_1199_0;
        // N s_1199_2: jump b1200
        return block_1200(state, tracer, fn_state);
    }
    fn block_1200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1200_0: read-var gs#410413:u8
        let s_1200_0: bool = fn_state.gs_410413;
        // D s_1200_1: write-var gs#410414 <= s_1200_0
        fn_state.gs_410414 = s_1200_0;
        // N s_1200_2: jump b594
        return block_594(state, tracer, fn_state);
    }
    fn block_1201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1201_0: const #3261s : i
        let s_1201_0: i128 = 3261;
        // C s_1201_1: const #14696u : u32
        let s_1201_1: u32 = 14696;
        // D s_1201_2: read-reg s_1201_1:i
        let s_1201_2: i128 = {
            let value = state.read_register::<i128>(s_1201_1 as isize);
            tracer.read_register(s_1201_1 as isize, value);
            value
        };
        // D s_1201_3: cmp-lt s_1201_2 s_1201_0
        let s_1201_3: bool = ((s_1201_2) < (s_1201_0));
        // D s_1201_4: write-var gs#410413 <= s_1201_3
        fn_state.gs_410413 = s_1201_3;
        // N s_1201_5: jump b1200
        return block_1200(state, tracer, fn_state);
    }
    fn block_1202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1202_0: const #4s : i
        let s_1202_0: i128 = 4;
        // D s_1202_1: read-var u#33680:u32
        let s_1202_1: u32 = fn_state.u_33680;
        // D s_1202_2: cast zx s_1202_1 -> bv
        let s_1202_2: Bits = Bits::new(s_1202_1 as u128, 32u16);
        // C s_1202_3: const #1s : i64
        let s_1202_3: i64 = 1;
        // C s_1202_4: cast zx s_1202_3 -> i
        let s_1202_4: i128 = (i128::try_from(s_1202_3).unwrap());
        // C s_1202_5: const #5s : i
        let s_1202_5: i128 = 5;
        // C s_1202_6: add s_1202_5 s_1202_4
        let s_1202_6: i128 = (s_1202_5 + s_1202_4);
        // D s_1202_7: bit-extract s_1202_2 s_1202_0 s_1202_6
        let s_1202_7: Bits = (Bits::new(
            ((s_1202_2) >> (s_1202_0)).value(),
            u16::try_from(s_1202_6).unwrap(),
        ));
        // D s_1202_8: cast reint s_1202_7 -> u8
        let s_1202_8: u8 = (s_1202_7.value() as u8);
        // D s_1202_9: cast zx s_1202_8 -> bv
        let s_1202_9: Bits = Bits::new(s_1202_8 as u128, 6u16);
        // C s_1202_10: const #7u : u8
        let s_1202_10: u8 = 7;
        // C s_1202_11: cast zx s_1202_10 -> bv
        let s_1202_11: Bits = Bits::new(s_1202_10 as u128, 6u16);
        // D s_1202_12: cmp-eq s_1202_9 s_1202_11
        let s_1202_12: bool = ((s_1202_9) == (s_1202_11));
        // D s_1202_13: write-var gs#410409 <= s_1202_12
        fn_state.gs_410409 = s_1202_12;
        // N s_1202_14: jump b592
        return block_592(state, tracer, fn_state);
    }
    fn block_1203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1203_0: const #28s : i
        let s_1203_0: i128 = 28;
        // C s_1203_1: const #4s : i
        let s_1203_1: i128 = 4;
        // D s_1203_2: read-var u#33674:u32
        let s_1203_2: u32 = fn_state.u_33674;
        // D s_1203_3: cast zx s_1203_2 -> bv
        let s_1203_3: Bits = Bits::new(s_1203_2 as u128, 32u16);
        // D s_1203_4: bit-extract s_1203_3 s_1203_0 s_1203_1
        let s_1203_4: Bits = (Bits::new(
            ((s_1203_3) >> (s_1203_0)).value(),
            u16::try_from(s_1203_1).unwrap(),
        ));
        // D s_1203_5: cast reint s_1203_4 -> u8
        let s_1203_5: u8 = (s_1203_4.value() as u8);
        // D s_1203_6: cast zx s_1203_5 -> bv
        let s_1203_6: Bits = Bits::new(s_1203_5 as u128, 4u16);
        // C s_1203_7: const #15u : u8
        let s_1203_7: u8 = 15;
        // C s_1203_8: cast zx s_1203_7 -> bv
        let s_1203_8: Bits = Bits::new(s_1203_7 as u128, 4u16);
        // D s_1203_9: cmp-ne s_1203_6 s_1203_8
        let s_1203_9: bool = ((s_1203_6) != (s_1203_8));
        // N s_1203_10: branch s_1203_9 b1206 b1204
        if s_1203_9 {
            return block_1206(state, tracer, fn_state);
        } else {
            return block_1204(state, tracer, fn_state);
        };
    }
    fn block_1204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1204_0: const #0u : u8
        let s_1204_0: bool = false;
        // D s_1204_1: write-var gs#410387 <= s_1204_0
        fn_state.gs_410387 = s_1204_0;
        // N s_1204_2: jump b1205
        return block_1205(state, tracer, fn_state);
    }
    fn block_1205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1205_0: read-var gs#410387:u8
        let s_1205_0: bool = fn_state.gs_410387;
        // D s_1205_1: write-var gs#410388 <= s_1205_0
        fn_state.gs_410388 = s_1205_0;
        // N s_1205_2: jump b583
        return block_583(state, tracer, fn_state);
    }
    fn block_1206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1206_0: const #3259s : i
        let s_1206_0: i128 = 3259;
        // C s_1206_1: const #14696u : u32
        let s_1206_1: u32 = 14696;
        // D s_1206_2: read-reg s_1206_1:i
        let s_1206_2: i128 = {
            let value = state.read_register::<i128>(s_1206_1 as isize);
            tracer.read_register(s_1206_1 as isize, value);
            value
        };
        // D s_1206_3: cmp-lt s_1206_2 s_1206_0
        let s_1206_3: bool = ((s_1206_2) < (s_1206_0));
        // D s_1206_4: write-var gs#410387 <= s_1206_3
        fn_state.gs_410387 = s_1206_3;
        // N s_1206_5: jump b1205
        return block_1205(state, tracer, fn_state);
    }
    fn block_1207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1207_0: const #4s : i
        let s_1207_0: i128 = 4;
        // D s_1207_1: read-var u#33674:u32
        let s_1207_1: u32 = fn_state.u_33674;
        // D s_1207_2: cast zx s_1207_1 -> bv
        let s_1207_2: Bits = Bits::new(s_1207_1 as u128, 32u16);
        // C s_1207_3: const #1s : i64
        let s_1207_3: i64 = 1;
        // C s_1207_4: cast zx s_1207_3 -> i
        let s_1207_4: i128 = (i128::try_from(s_1207_3).unwrap());
        // C s_1207_5: const #5s : i
        let s_1207_5: i128 = 5;
        // C s_1207_6: add s_1207_5 s_1207_4
        let s_1207_6: i128 = (s_1207_5 + s_1207_4);
        // D s_1207_7: bit-extract s_1207_2 s_1207_0 s_1207_6
        let s_1207_7: Bits = (Bits::new(
            ((s_1207_2) >> (s_1207_0)).value(),
            u16::try_from(s_1207_6).unwrap(),
        ));
        // D s_1207_8: cast reint s_1207_7 -> u8
        let s_1207_8: u8 = (s_1207_7.value() as u8);
        // D s_1207_9: cast zx s_1207_8 -> bv
        let s_1207_9: Bits = Bits::new(s_1207_8 as u128, 6u16);
        // C s_1207_10: const #7u : u8
        let s_1207_10: u8 = 7;
        // C s_1207_11: cast zx s_1207_10 -> bv
        let s_1207_11: Bits = Bits::new(s_1207_10 as u128, 6u16);
        // D s_1207_12: cmp-eq s_1207_9 s_1207_11
        let s_1207_12: bool = ((s_1207_9) == (s_1207_11));
        // D s_1207_13: write-var gs#410383 <= s_1207_12
        fn_state.gs_410383 = s_1207_12;
        // N s_1207_14: jump b581
        return block_581(state, tracer, fn_state);
    }
    fn block_1208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1208_0: const #28s : i
        let s_1208_0: i128 = 28;
        // C s_1208_1: const #4s : i
        let s_1208_1: i128 = 4;
        // D s_1208_2: read-var u#33667:u32
        let s_1208_2: u32 = fn_state.u_33667;
        // D s_1208_3: cast zx s_1208_2 -> bv
        let s_1208_3: Bits = Bits::new(s_1208_2 as u128, 32u16);
        // D s_1208_4: bit-extract s_1208_3 s_1208_0 s_1208_1
        let s_1208_4: Bits = (Bits::new(
            ((s_1208_3) >> (s_1208_0)).value(),
            u16::try_from(s_1208_1).unwrap(),
        ));
        // D s_1208_5: cast reint s_1208_4 -> u8
        let s_1208_5: u8 = (s_1208_4.value() as u8);
        // D s_1208_6: cast zx s_1208_5 -> bv
        let s_1208_6: Bits = Bits::new(s_1208_5 as u128, 4u16);
        // C s_1208_7: const #15u : u8
        let s_1208_7: u8 = 15;
        // C s_1208_8: cast zx s_1208_7 -> bv
        let s_1208_8: Bits = Bits::new(s_1208_7 as u128, 4u16);
        // D s_1208_9: cmp-ne s_1208_6 s_1208_8
        let s_1208_9: bool = ((s_1208_6) != (s_1208_8));
        // N s_1208_10: branch s_1208_9 b1211 b1209
        if s_1208_9 {
            return block_1211(state, tracer, fn_state);
        } else {
            return block_1209(state, tracer, fn_state);
        };
    }
    fn block_1209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1209_0: const #0u : u8
        let s_1209_0: bool = false;
        // D s_1209_1: write-var gs#410359 <= s_1209_0
        fn_state.gs_410359 = s_1209_0;
        // N s_1209_2: jump b1210
        return block_1210(state, tracer, fn_state);
    }
    fn block_1210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1210_0: read-var gs#410359:u8
        let s_1210_0: bool = fn_state.gs_410359;
        // D s_1210_1: write-var gs#410360 <= s_1210_0
        fn_state.gs_410360 = s_1210_0;
        // N s_1210_2: jump b572
        return block_572(state, tracer, fn_state);
    }
    fn block_1211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1211_0: const #3257s : i
        let s_1211_0: i128 = 3257;
        // C s_1211_1: const #14696u : u32
        let s_1211_1: u32 = 14696;
        // D s_1211_2: read-reg s_1211_1:i
        let s_1211_2: i128 = {
            let value = state.read_register::<i128>(s_1211_1 as isize);
            tracer.read_register(s_1211_1 as isize, value);
            value
        };
        // D s_1211_3: cmp-lt s_1211_2 s_1211_0
        let s_1211_3: bool = ((s_1211_2) < (s_1211_0));
        // D s_1211_4: write-var gs#410359 <= s_1211_3
        fn_state.gs_410359 = s_1211_3;
        // N s_1211_5: jump b1210
        return block_1210(state, tracer, fn_state);
    }
    fn block_1212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1212_0: const #4s : i
        let s_1212_0: i128 = 4;
        // D s_1212_1: read-var u#33667:u32
        let s_1212_1: u32 = fn_state.u_33667;
        // D s_1212_2: cast zx s_1212_1 -> bv
        let s_1212_2: Bits = Bits::new(s_1212_1 as u128, 32u16);
        // C s_1212_3: const #1s : i64
        let s_1212_3: i64 = 1;
        // C s_1212_4: cast zx s_1212_3 -> i
        let s_1212_4: i128 = (i128::try_from(s_1212_3).unwrap());
        // C s_1212_5: const #5s : i
        let s_1212_5: i128 = 5;
        // C s_1212_6: add s_1212_5 s_1212_4
        let s_1212_6: i128 = (s_1212_5 + s_1212_4);
        // D s_1212_7: bit-extract s_1212_2 s_1212_0 s_1212_6
        let s_1212_7: Bits = (Bits::new(
            ((s_1212_2) >> (s_1212_0)).value(),
            u16::try_from(s_1212_6).unwrap(),
        ));
        // D s_1212_8: cast reint s_1212_7 -> u8
        let s_1212_8: u8 = (s_1212_7.value() as u8);
        // D s_1212_9: cast zx s_1212_8 -> bv
        let s_1212_9: Bits = Bits::new(s_1212_8 as u128, 6u16);
        // C s_1212_10: const #7u : u8
        let s_1212_10: u8 = 7;
        // C s_1212_11: cast zx s_1212_10 -> bv
        let s_1212_11: Bits = Bits::new(s_1212_10 as u128, 6u16);
        // D s_1212_12: cmp-eq s_1212_9 s_1212_11
        let s_1212_12: bool = ((s_1212_9) == (s_1212_11));
        // D s_1212_13: write-var gs#410355 <= s_1212_12
        fn_state.gs_410355 = s_1212_12;
        // N s_1212_14: jump b570
        return block_570(state, tracer, fn_state);
    }
    fn block_1213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1213_0: const #28s : i
        let s_1213_0: i128 = 28;
        // C s_1213_1: const #4s : i
        let s_1213_1: i128 = 4;
        // D s_1213_2: read-var u#33660:u32
        let s_1213_2: u32 = fn_state.u_33660;
        // D s_1213_3: cast zx s_1213_2 -> bv
        let s_1213_3: Bits = Bits::new(s_1213_2 as u128, 32u16);
        // D s_1213_4: bit-extract s_1213_3 s_1213_0 s_1213_1
        let s_1213_4: Bits = (Bits::new(
            ((s_1213_3) >> (s_1213_0)).value(),
            u16::try_from(s_1213_1).unwrap(),
        ));
        // D s_1213_5: cast reint s_1213_4 -> u8
        let s_1213_5: u8 = (s_1213_4.value() as u8);
        // D s_1213_6: cast zx s_1213_5 -> bv
        let s_1213_6: Bits = Bits::new(s_1213_5 as u128, 4u16);
        // C s_1213_7: const #15u : u8
        let s_1213_7: u8 = 15;
        // C s_1213_8: cast zx s_1213_7 -> bv
        let s_1213_8: Bits = Bits::new(s_1213_7 as u128, 4u16);
        // D s_1213_9: cmp-ne s_1213_6 s_1213_8
        let s_1213_9: bool = ((s_1213_6) != (s_1213_8));
        // N s_1213_10: branch s_1213_9 b1216 b1214
        if s_1213_9 {
            return block_1216(state, tracer, fn_state);
        } else {
            return block_1214(state, tracer, fn_state);
        };
    }
    fn block_1214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1214_0: const #0u : u8
        let s_1214_0: bool = false;
        // D s_1214_1: write-var gs#410331 <= s_1214_0
        fn_state.gs_410331 = s_1214_0;
        // N s_1214_2: jump b1215
        return block_1215(state, tracer, fn_state);
    }
    fn block_1215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1215_0: read-var gs#410331:u8
        let s_1215_0: bool = fn_state.gs_410331;
        // D s_1215_1: write-var gs#410332 <= s_1215_0
        fn_state.gs_410332 = s_1215_0;
        // N s_1215_2: jump b561
        return block_561(state, tracer, fn_state);
    }
    fn block_1216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1216_0: const #3255s : i
        let s_1216_0: i128 = 3255;
        // C s_1216_1: const #14696u : u32
        let s_1216_1: u32 = 14696;
        // D s_1216_2: read-reg s_1216_1:i
        let s_1216_2: i128 = {
            let value = state.read_register::<i128>(s_1216_1 as isize);
            tracer.read_register(s_1216_1 as isize, value);
            value
        };
        // D s_1216_3: cmp-lt s_1216_2 s_1216_0
        let s_1216_3: bool = ((s_1216_2) < (s_1216_0));
        // D s_1216_4: write-var gs#410331 <= s_1216_3
        fn_state.gs_410331 = s_1216_3;
        // N s_1216_5: jump b1215
        return block_1215(state, tracer, fn_state);
    }
    fn block_1217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1217_0: const #4s : i
        let s_1217_0: i128 = 4;
        // D s_1217_1: read-var u#33660:u32
        let s_1217_1: u32 = fn_state.u_33660;
        // D s_1217_2: cast zx s_1217_1 -> bv
        let s_1217_2: Bits = Bits::new(s_1217_1 as u128, 32u16);
        // C s_1217_3: const #1s : i64
        let s_1217_3: i64 = 1;
        // C s_1217_4: cast zx s_1217_3 -> i
        let s_1217_4: i128 = (i128::try_from(s_1217_3).unwrap());
        // C s_1217_5: const #5s : i
        let s_1217_5: i128 = 5;
        // C s_1217_6: add s_1217_5 s_1217_4
        let s_1217_6: i128 = (s_1217_5 + s_1217_4);
        // D s_1217_7: bit-extract s_1217_2 s_1217_0 s_1217_6
        let s_1217_7: Bits = (Bits::new(
            ((s_1217_2) >> (s_1217_0)).value(),
            u16::try_from(s_1217_6).unwrap(),
        ));
        // D s_1217_8: cast reint s_1217_7 -> u8
        let s_1217_8: u8 = (s_1217_7.value() as u8);
        // D s_1217_9: cast zx s_1217_8 -> bv
        let s_1217_9: Bits = Bits::new(s_1217_8 as u128, 6u16);
        // C s_1217_10: const #7u : u8
        let s_1217_10: u8 = 7;
        // C s_1217_11: cast zx s_1217_10 -> bv
        let s_1217_11: Bits = Bits::new(s_1217_10 as u128, 6u16);
        // D s_1217_12: cmp-eq s_1217_9 s_1217_11
        let s_1217_12: bool = ((s_1217_9) == (s_1217_11));
        // D s_1217_13: write-var gs#410327 <= s_1217_12
        fn_state.gs_410327 = s_1217_12;
        // N s_1217_14: jump b559
        return block_559(state, tracer, fn_state);
    }
    fn block_1218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1218_0: const #28s : i
        let s_1218_0: i128 = 28;
        // C s_1218_1: const #4s : i
        let s_1218_1: i128 = 4;
        // D s_1218_2: read-var u#33654:u32
        let s_1218_2: u32 = fn_state.u_33654;
        // D s_1218_3: cast zx s_1218_2 -> bv
        let s_1218_3: Bits = Bits::new(s_1218_2 as u128, 32u16);
        // D s_1218_4: bit-extract s_1218_3 s_1218_0 s_1218_1
        let s_1218_4: Bits = (Bits::new(
            ((s_1218_3) >> (s_1218_0)).value(),
            u16::try_from(s_1218_1).unwrap(),
        ));
        // D s_1218_5: cast reint s_1218_4 -> u8
        let s_1218_5: u8 = (s_1218_4.value() as u8);
        // D s_1218_6: cast zx s_1218_5 -> bv
        let s_1218_6: Bits = Bits::new(s_1218_5 as u128, 4u16);
        // C s_1218_7: const #15u : u8
        let s_1218_7: u8 = 15;
        // C s_1218_8: cast zx s_1218_7 -> bv
        let s_1218_8: Bits = Bits::new(s_1218_7 as u128, 4u16);
        // D s_1218_9: cmp-ne s_1218_6 s_1218_8
        let s_1218_9: bool = ((s_1218_6) != (s_1218_8));
        // N s_1218_10: branch s_1218_9 b1221 b1219
        if s_1218_9 {
            return block_1221(state, tracer, fn_state);
        } else {
            return block_1219(state, tracer, fn_state);
        };
    }
    fn block_1219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1219_0: const #0u : u8
        let s_1219_0: bool = false;
        // D s_1219_1: write-var gs#410303 <= s_1219_0
        fn_state.gs_410303 = s_1219_0;
        // N s_1219_2: jump b1220
        return block_1220(state, tracer, fn_state);
    }
    fn block_1220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1220_0: read-var gs#410303:u8
        let s_1220_0: bool = fn_state.gs_410303;
        // D s_1220_1: write-var gs#410304 <= s_1220_0
        fn_state.gs_410304 = s_1220_0;
        // N s_1220_2: jump b550
        return block_550(state, tracer, fn_state);
    }
    fn block_1221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1221_0: const #3253s : i
        let s_1221_0: i128 = 3253;
        // C s_1221_1: const #14696u : u32
        let s_1221_1: u32 = 14696;
        // D s_1221_2: read-reg s_1221_1:i
        let s_1221_2: i128 = {
            let value = state.read_register::<i128>(s_1221_1 as isize);
            tracer.read_register(s_1221_1 as isize, value);
            value
        };
        // D s_1221_3: cmp-lt s_1221_2 s_1221_0
        let s_1221_3: bool = ((s_1221_2) < (s_1221_0));
        // D s_1221_4: write-var gs#410303 <= s_1221_3
        fn_state.gs_410303 = s_1221_3;
        // N s_1221_5: jump b1220
        return block_1220(state, tracer, fn_state);
    }
    fn block_1222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1222_0: const #4s : i
        let s_1222_0: i128 = 4;
        // D s_1222_1: read-var u#33654:u32
        let s_1222_1: u32 = fn_state.u_33654;
        // D s_1222_2: cast zx s_1222_1 -> bv
        let s_1222_2: Bits = Bits::new(s_1222_1 as u128, 32u16);
        // C s_1222_3: const #1s : i64
        let s_1222_3: i64 = 1;
        // C s_1222_4: cast zx s_1222_3 -> i
        let s_1222_4: i128 = (i128::try_from(s_1222_3).unwrap());
        // C s_1222_5: const #5s : i
        let s_1222_5: i128 = 5;
        // C s_1222_6: add s_1222_5 s_1222_4
        let s_1222_6: i128 = (s_1222_5 + s_1222_4);
        // D s_1222_7: bit-extract s_1222_2 s_1222_0 s_1222_6
        let s_1222_7: Bits = (Bits::new(
            ((s_1222_2) >> (s_1222_0)).value(),
            u16::try_from(s_1222_6).unwrap(),
        ));
        // D s_1222_8: cast reint s_1222_7 -> u8
        let s_1222_8: u8 = (s_1222_7.value() as u8);
        // D s_1222_9: cast zx s_1222_8 -> bv
        let s_1222_9: Bits = Bits::new(s_1222_8 as u128, 6u16);
        // C s_1222_10: const #7u : u8
        let s_1222_10: u8 = 7;
        // C s_1222_11: cast zx s_1222_10 -> bv
        let s_1222_11: Bits = Bits::new(s_1222_10 as u128, 6u16);
        // D s_1222_12: cmp-eq s_1222_9 s_1222_11
        let s_1222_12: bool = ((s_1222_9) == (s_1222_11));
        // D s_1222_13: write-var gs#410299 <= s_1222_12
        fn_state.gs_410299 = s_1222_12;
        // N s_1222_14: jump b548
        return block_548(state, tracer, fn_state);
    }
    fn block_1223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1223_0: const #28s : i
        let s_1223_0: i128 = 28;
        // C s_1223_1: const #4s : i
        let s_1223_1: i128 = 4;
        // D s_1223_2: read-var u#33648:u32
        let s_1223_2: u32 = fn_state.u_33648;
        // D s_1223_3: cast zx s_1223_2 -> bv
        let s_1223_3: Bits = Bits::new(s_1223_2 as u128, 32u16);
        // D s_1223_4: bit-extract s_1223_3 s_1223_0 s_1223_1
        let s_1223_4: Bits = (Bits::new(
            ((s_1223_3) >> (s_1223_0)).value(),
            u16::try_from(s_1223_1).unwrap(),
        ));
        // D s_1223_5: cast reint s_1223_4 -> u8
        let s_1223_5: u8 = (s_1223_4.value() as u8);
        // D s_1223_6: cast zx s_1223_5 -> bv
        let s_1223_6: Bits = Bits::new(s_1223_5 as u128, 4u16);
        // C s_1223_7: const #15u : u8
        let s_1223_7: u8 = 15;
        // C s_1223_8: cast zx s_1223_7 -> bv
        let s_1223_8: Bits = Bits::new(s_1223_7 as u128, 4u16);
        // D s_1223_9: cmp-ne s_1223_6 s_1223_8
        let s_1223_9: bool = ((s_1223_6) != (s_1223_8));
        // N s_1223_10: branch s_1223_9 b1226 b1224
        if s_1223_9 {
            return block_1226(state, tracer, fn_state);
        } else {
            return block_1224(state, tracer, fn_state);
        };
    }
    fn block_1224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1224_0: const #0u : u8
        let s_1224_0: bool = false;
        // D s_1224_1: write-var gs#410271 <= s_1224_0
        fn_state.gs_410271 = s_1224_0;
        // N s_1224_2: jump b1225
        return block_1225(state, tracer, fn_state);
    }
    fn block_1225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1225_0: read-var gs#410271:u8
        let s_1225_0: bool = fn_state.gs_410271;
        // D s_1225_1: write-var gs#410272 <= s_1225_0
        fn_state.gs_410272 = s_1225_0;
        // N s_1225_2: jump b533
        return block_533(state, tracer, fn_state);
    }
    fn block_1226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1226_0: const #3182s : i
        let s_1226_0: i128 = 3182;
        // C s_1226_1: const #14696u : u32
        let s_1226_1: u32 = 14696;
        // D s_1226_2: read-reg s_1226_1:i
        let s_1226_2: i128 = {
            let value = state.read_register::<i128>(s_1226_1 as isize);
            tracer.read_register(s_1226_1 as isize, value);
            value
        };
        // D s_1226_3: cmp-lt s_1226_2 s_1226_0
        let s_1226_3: bool = ((s_1226_2) < (s_1226_0));
        // D s_1226_4: write-var gs#410271 <= s_1226_3
        fn_state.gs_410271 = s_1226_3;
        // N s_1226_5: jump b1225
        return block_1225(state, tracer, fn_state);
    }
    fn block_1227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1227_0: const #4s : i
        let s_1227_0: i128 = 4;
        // D s_1227_1: read-var u#33648:u32
        let s_1227_1: u32 = fn_state.u_33648;
        // D s_1227_2: cast zx s_1227_1 -> bv
        let s_1227_2: Bits = Bits::new(s_1227_1 as u128, 32u16);
        // C s_1227_3: const #1s : i64
        let s_1227_3: i64 = 1;
        // C s_1227_4: cast zx s_1227_3 -> i
        let s_1227_4: i128 = (i128::try_from(s_1227_3).unwrap());
        // C s_1227_5: const #7s : i
        let s_1227_5: i128 = 7;
        // C s_1227_6: add s_1227_5 s_1227_4
        let s_1227_6: i128 = (s_1227_5 + s_1227_4);
        // D s_1227_7: bit-extract s_1227_2 s_1227_0 s_1227_6
        let s_1227_7: Bits = (Bits::new(
            ((s_1227_2) >> (s_1227_0)).value(),
            u16::try_from(s_1227_6).unwrap(),
        ));
        // D s_1227_8: cast reint s_1227_7 -> u8
        let s_1227_8: u8 = (s_1227_7.value() as u8);
        // D s_1227_9: cast zx s_1227_8 -> bv
        let s_1227_9: Bits = Bits::new(s_1227_8 as u128, 8u16);
        // C s_1227_10: const #255u : u8
        let s_1227_10: u8 = 255;
        // C s_1227_11: cast zx s_1227_10 -> bv
        let s_1227_11: Bits = Bits::new(s_1227_10 as u128, 8u16);
        // D s_1227_12: cmp-eq s_1227_9 s_1227_11
        let s_1227_12: bool = ((s_1227_9) == (s_1227_11));
        // D s_1227_13: write-var gs#410267 <= s_1227_12
        fn_state.gs_410267 = s_1227_12;
        // N s_1227_14: jump b531
        return block_531(state, tracer, fn_state);
    }
    fn block_1228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1228_0: const #28s : i
        let s_1228_0: i128 = 28;
        // C s_1228_1: const #4s : i
        let s_1228_1: i128 = 4;
        // D s_1228_2: read-var u#33642:u32
        let s_1228_2: u32 = fn_state.u_33642;
        // D s_1228_3: cast zx s_1228_2 -> bv
        let s_1228_3: Bits = Bits::new(s_1228_2 as u128, 32u16);
        // D s_1228_4: bit-extract s_1228_3 s_1228_0 s_1228_1
        let s_1228_4: Bits = (Bits::new(
            ((s_1228_3) >> (s_1228_0)).value(),
            u16::try_from(s_1228_1).unwrap(),
        ));
        // D s_1228_5: cast reint s_1228_4 -> u8
        let s_1228_5: u8 = (s_1228_4.value() as u8);
        // D s_1228_6: cast zx s_1228_5 -> bv
        let s_1228_6: Bits = Bits::new(s_1228_5 as u128, 4u16);
        // C s_1228_7: const #15u : u8
        let s_1228_7: u8 = 15;
        // C s_1228_8: cast zx s_1228_7 -> bv
        let s_1228_8: Bits = Bits::new(s_1228_7 as u128, 4u16);
        // D s_1228_9: cmp-ne s_1228_6 s_1228_8
        let s_1228_9: bool = ((s_1228_6) != (s_1228_8));
        // N s_1228_10: branch s_1228_9 b1231 b1229
        if s_1228_9 {
            return block_1231(state, tracer, fn_state);
        } else {
            return block_1229(state, tracer, fn_state);
        };
    }
    fn block_1229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1229_0: const #0u : u8
        let s_1229_0: bool = false;
        // D s_1229_1: write-var gs#410239 <= s_1229_0
        fn_state.gs_410239 = s_1229_0;
        // N s_1229_2: jump b1230
        return block_1230(state, tracer, fn_state);
    }
    fn block_1230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1230_0: read-var gs#410239:u8
        let s_1230_0: bool = fn_state.gs_410239;
        // D s_1230_1: write-var gs#410240 <= s_1230_0
        fn_state.gs_410240 = s_1230_0;
        // N s_1230_2: jump b516
        return block_516(state, tracer, fn_state);
    }
    fn block_1231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1231_0: const #3180s : i
        let s_1231_0: i128 = 3180;
        // C s_1231_1: const #14696u : u32
        let s_1231_1: u32 = 14696;
        // D s_1231_2: read-reg s_1231_1:i
        let s_1231_2: i128 = {
            let value = state.read_register::<i128>(s_1231_1 as isize);
            tracer.read_register(s_1231_1 as isize, value);
            value
        };
        // D s_1231_3: cmp-lt s_1231_2 s_1231_0
        let s_1231_3: bool = ((s_1231_2) < (s_1231_0));
        // D s_1231_4: write-var gs#410239 <= s_1231_3
        fn_state.gs_410239 = s_1231_3;
        // N s_1231_5: jump b1230
        return block_1230(state, tracer, fn_state);
    }
    fn block_1232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1232_0: const #4s : i
        let s_1232_0: i128 = 4;
        // D s_1232_1: read-var u#33642:u32
        let s_1232_1: u32 = fn_state.u_33642;
        // D s_1232_2: cast zx s_1232_1 -> bv
        let s_1232_2: Bits = Bits::new(s_1232_1 as u128, 32u16);
        // C s_1232_3: const #1s : i64
        let s_1232_3: i64 = 1;
        // C s_1232_4: cast zx s_1232_3 -> i
        let s_1232_4: i128 = (i128::try_from(s_1232_3).unwrap());
        // C s_1232_5: const #7s : i
        let s_1232_5: i128 = 7;
        // C s_1232_6: add s_1232_5 s_1232_4
        let s_1232_6: i128 = (s_1232_5 + s_1232_4);
        // D s_1232_7: bit-extract s_1232_2 s_1232_0 s_1232_6
        let s_1232_7: Bits = (Bits::new(
            ((s_1232_2) >> (s_1232_0)).value(),
            u16::try_from(s_1232_6).unwrap(),
        ));
        // D s_1232_8: cast reint s_1232_7 -> u8
        let s_1232_8: u8 = (s_1232_7.value() as u8);
        // D s_1232_9: cast zx s_1232_8 -> bv
        let s_1232_9: Bits = Bits::new(s_1232_8 as u128, 8u16);
        // C s_1232_10: const #247u : u8
        let s_1232_10: u8 = 247;
        // C s_1232_11: cast zx s_1232_10 -> bv
        let s_1232_11: Bits = Bits::new(s_1232_10 as u128, 8u16);
        // D s_1232_12: cmp-eq s_1232_9 s_1232_11
        let s_1232_12: bool = ((s_1232_9) == (s_1232_11));
        // D s_1232_13: write-var gs#410235 <= s_1232_12
        fn_state.gs_410235 = s_1232_12;
        // N s_1232_14: jump b514
        return block_514(state, tracer, fn_state);
    }
    fn block_1233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1233_0: const #28s : i
        let s_1233_0: i128 = 28;
        // C s_1233_1: const #4s : i
        let s_1233_1: i128 = 4;
        // D s_1233_2: read-var u#33636:u32
        let s_1233_2: u32 = fn_state.u_33636;
        // D s_1233_3: cast zx s_1233_2 -> bv
        let s_1233_3: Bits = Bits::new(s_1233_2 as u128, 32u16);
        // D s_1233_4: bit-extract s_1233_3 s_1233_0 s_1233_1
        let s_1233_4: Bits = (Bits::new(
            ((s_1233_3) >> (s_1233_0)).value(),
            u16::try_from(s_1233_1).unwrap(),
        ));
        // D s_1233_5: cast reint s_1233_4 -> u8
        let s_1233_5: u8 = (s_1233_4.value() as u8);
        // D s_1233_6: cast zx s_1233_5 -> bv
        let s_1233_6: Bits = Bits::new(s_1233_5 as u128, 4u16);
        // C s_1233_7: const #15u : u8
        let s_1233_7: u8 = 15;
        // C s_1233_8: cast zx s_1233_7 -> bv
        let s_1233_8: Bits = Bits::new(s_1233_7 as u128, 4u16);
        // D s_1233_9: cmp-ne s_1233_6 s_1233_8
        let s_1233_9: bool = ((s_1233_6) != (s_1233_8));
        // N s_1233_10: branch s_1233_9 b1236 b1234
        if s_1233_9 {
            return block_1236(state, tracer, fn_state);
        } else {
            return block_1234(state, tracer, fn_state);
        };
    }
    fn block_1234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1234_0: const #0u : u8
        let s_1234_0: bool = false;
        // D s_1234_1: write-var gs#410207 <= s_1234_0
        fn_state.gs_410207 = s_1234_0;
        // N s_1234_2: jump b1235
        return block_1235(state, tracer, fn_state);
    }
    fn block_1235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1235_0: read-var gs#410207:u8
        let s_1235_0: bool = fn_state.gs_410207;
        // D s_1235_1: write-var gs#410208 <= s_1235_0
        fn_state.gs_410208 = s_1235_0;
        // N s_1235_2: jump b499
        return block_499(state, tracer, fn_state);
    }
    fn block_1236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1236_0: const #3178s : i
        let s_1236_0: i128 = 3178;
        // C s_1236_1: const #14696u : u32
        let s_1236_1: u32 = 14696;
        // D s_1236_2: read-reg s_1236_1:i
        let s_1236_2: i128 = {
            let value = state.read_register::<i128>(s_1236_1 as isize);
            tracer.read_register(s_1236_1 as isize, value);
            value
        };
        // D s_1236_3: cmp-lt s_1236_2 s_1236_0
        let s_1236_3: bool = ((s_1236_2) < (s_1236_0));
        // D s_1236_4: write-var gs#410207 <= s_1236_3
        fn_state.gs_410207 = s_1236_3;
        // N s_1236_5: jump b1235
        return block_1235(state, tracer, fn_state);
    }
    fn block_1237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1237_0: const #4s : i
        let s_1237_0: i128 = 4;
        // D s_1237_1: read-var u#33636:u32
        let s_1237_1: u32 = fn_state.u_33636;
        // D s_1237_2: cast zx s_1237_1 -> bv
        let s_1237_2: Bits = Bits::new(s_1237_1 as u128, 32u16);
        // C s_1237_3: const #1s : i64
        let s_1237_3: i64 = 1;
        // C s_1237_4: cast zx s_1237_3 -> i
        let s_1237_4: i128 = (i128::try_from(s_1237_3).unwrap());
        // C s_1237_5: const #7s : i
        let s_1237_5: i128 = 7;
        // C s_1237_6: add s_1237_5 s_1237_4
        let s_1237_6: i128 = (s_1237_5 + s_1237_4);
        // D s_1237_7: bit-extract s_1237_2 s_1237_0 s_1237_6
        let s_1237_7: Bits = (Bits::new(
            ((s_1237_2) >> (s_1237_0)).value(),
            u16::try_from(s_1237_6).unwrap(),
        ));
        // D s_1237_8: cast reint s_1237_7 -> u8
        let s_1237_8: u8 = (s_1237_7.value() as u8);
        // D s_1237_9: cast zx s_1237_8 -> bv
        let s_1237_9: Bits = Bits::new(s_1237_8 as u128, 8u16);
        // C s_1237_10: const #245u : u8
        let s_1237_10: u8 = 245;
        // C s_1237_11: cast zx s_1237_10 -> bv
        let s_1237_11: Bits = Bits::new(s_1237_10 as u128, 8u16);
        // D s_1237_12: cmp-eq s_1237_9 s_1237_11
        let s_1237_12: bool = ((s_1237_9) == (s_1237_11));
        // D s_1237_13: write-var gs#410203 <= s_1237_12
        fn_state.gs_410203 = s_1237_12;
        // N s_1237_14: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_1238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1238_0: const #28s : i
        let s_1238_0: i128 = 28;
        // C s_1238_1: const #4s : i
        let s_1238_1: i128 = 4;
        // D s_1238_2: read-var u#33629:u32
        let s_1238_2: u32 = fn_state.u_33629;
        // D s_1238_3: cast zx s_1238_2 -> bv
        let s_1238_3: Bits = Bits::new(s_1238_2 as u128, 32u16);
        // D s_1238_4: bit-extract s_1238_3 s_1238_0 s_1238_1
        let s_1238_4: Bits = (Bits::new(
            ((s_1238_3) >> (s_1238_0)).value(),
            u16::try_from(s_1238_1).unwrap(),
        ));
        // D s_1238_5: cast reint s_1238_4 -> u8
        let s_1238_5: u8 = (s_1238_4.value() as u8);
        // D s_1238_6: cast zx s_1238_5 -> bv
        let s_1238_6: Bits = Bits::new(s_1238_5 as u128, 4u16);
        // C s_1238_7: const #15u : u8
        let s_1238_7: u8 = 15;
        // C s_1238_8: cast zx s_1238_7 -> bv
        let s_1238_8: Bits = Bits::new(s_1238_7 as u128, 4u16);
        // D s_1238_9: cmp-ne s_1238_6 s_1238_8
        let s_1238_9: bool = ((s_1238_6) != (s_1238_8));
        // N s_1238_10: branch s_1238_9 b1241 b1239
        if s_1238_9 {
            return block_1241(state, tracer, fn_state);
        } else {
            return block_1239(state, tracer, fn_state);
        };
    }
    fn block_1239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1239_0: const #0u : u8
        let s_1239_0: bool = false;
        // D s_1239_1: write-var gs#410182 <= s_1239_0
        fn_state.gs_410182 = s_1239_0;
        // N s_1239_2: jump b1240
        return block_1240(state, tracer, fn_state);
    }
    fn block_1240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1240_0: read-var gs#410182:u8
        let s_1240_0: bool = fn_state.gs_410182;
        // D s_1240_1: write-var gs#410183 <= s_1240_0
        fn_state.gs_410183 = s_1240_0;
        // N s_1240_2: jump b493
        return block_493(state, tracer, fn_state);
    }
    fn block_1241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1241_0: const #3176s : i
        let s_1241_0: i128 = 3176;
        // C s_1241_1: const #14696u : u32
        let s_1241_1: u32 = 14696;
        // D s_1241_2: read-reg s_1241_1:i
        let s_1241_2: i128 = {
            let value = state.read_register::<i128>(s_1241_1 as isize);
            tracer.read_register(s_1241_1 as isize, value);
            value
        };
        // D s_1241_3: cmp-lt s_1241_2 s_1241_0
        let s_1241_3: bool = ((s_1241_2) < (s_1241_0));
        // D s_1241_4: write-var gs#410182 <= s_1241_3
        fn_state.gs_410182 = s_1241_3;
        // N s_1241_5: jump b1240
        return block_1240(state, tracer, fn_state);
    }
    fn block_1242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1242_0: const #4s : i
        let s_1242_0: i128 = 4;
        // D s_1242_1: read-var u#33629:u32
        let s_1242_1: u32 = fn_state.u_33629;
        // D s_1242_2: cast zx s_1242_1 -> bv
        let s_1242_2: Bits = Bits::new(s_1242_1 as u128, 32u16);
        // C s_1242_3: const #1s : i64
        let s_1242_3: i64 = 1;
        // C s_1242_4: cast zx s_1242_3 -> i
        let s_1242_4: i128 = (i128::try_from(s_1242_3).unwrap());
        // C s_1242_5: const #1s : i
        let s_1242_5: i128 = 1;
        // C s_1242_6: add s_1242_5 s_1242_4
        let s_1242_6: i128 = (s_1242_5 + s_1242_4);
        // D s_1242_7: bit-extract s_1242_2 s_1242_0 s_1242_6
        let s_1242_7: Bits = (Bits::new(
            ((s_1242_2) >> (s_1242_0)).value(),
            u16::try_from(s_1242_6).unwrap(),
        ));
        // D s_1242_8: cast reint s_1242_7 -> u8
        let s_1242_8: u8 = (s_1242_7.value() as u8);
        // D s_1242_9: cast zx s_1242_8 -> bv
        let s_1242_9: Bits = Bits::new(s_1242_8 as u128, 2u16);
        // C s_1242_10: const #1u : u8
        let s_1242_10: u8 = 1;
        // C s_1242_11: cast zx s_1242_10 -> bv
        let s_1242_11: Bits = Bits::new(s_1242_10 as u128, 2u16);
        // D s_1242_12: cmp-eq s_1242_9 s_1242_11
        let s_1242_12: bool = ((s_1242_9) == (s_1242_11));
        // D s_1242_13: write-var gs#410178 <= s_1242_12
        fn_state.gs_410178 = s_1242_12;
        // N s_1242_14: jump b491
        return block_491(state, tracer, fn_state);
    }
    fn block_1243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1243_0: const #28s : i
        let s_1243_0: i128 = 28;
        // C s_1243_1: const #4s : i
        let s_1243_1: i128 = 4;
        // D s_1243_2: read-var u#33624:u32
        let s_1243_2: u32 = fn_state.u_33624;
        // D s_1243_3: cast zx s_1243_2 -> bv
        let s_1243_3: Bits = Bits::new(s_1243_2 as u128, 32u16);
        // D s_1243_4: bit-extract s_1243_3 s_1243_0 s_1243_1
        let s_1243_4: Bits = (Bits::new(
            ((s_1243_3) >> (s_1243_0)).value(),
            u16::try_from(s_1243_1).unwrap(),
        ));
        // D s_1243_5: cast reint s_1243_4 -> u8
        let s_1243_5: u8 = (s_1243_4.value() as u8);
        // D s_1243_6: cast zx s_1243_5 -> bv
        let s_1243_6: Bits = Bits::new(s_1243_5 as u128, 4u16);
        // C s_1243_7: const #15u : u8
        let s_1243_7: u8 = 15;
        // C s_1243_8: cast zx s_1243_7 -> bv
        let s_1243_8: Bits = Bits::new(s_1243_7 as u128, 4u16);
        // D s_1243_9: cmp-ne s_1243_6 s_1243_8
        let s_1243_9: bool = ((s_1243_6) != (s_1243_8));
        // N s_1243_10: branch s_1243_9 b1246 b1244
        if s_1243_9 {
            return block_1246(state, tracer, fn_state);
        } else {
            return block_1244(state, tracer, fn_state);
        };
    }
    fn block_1244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1244_0: const #0u : u8
        let s_1244_0: bool = false;
        // D s_1244_1: write-var gs#410150 <= s_1244_0
        fn_state.gs_410150 = s_1244_0;
        // N s_1244_2: jump b1245
        return block_1245(state, tracer, fn_state);
    }
    fn block_1245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1245_0: read-var gs#410150:u8
        let s_1245_0: bool = fn_state.gs_410150;
        // D s_1245_1: write-var gs#410151 <= s_1245_0
        fn_state.gs_410151 = s_1245_0;
        // N s_1245_2: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_1246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1246_0: const #3174s : i
        let s_1246_0: i128 = 3174;
        // C s_1246_1: const #14696u : u32
        let s_1246_1: u32 = 14696;
        // D s_1246_2: read-reg s_1246_1:i
        let s_1246_2: i128 = {
            let value = state.read_register::<i128>(s_1246_1 as isize);
            tracer.read_register(s_1246_1 as isize, value);
            value
        };
        // D s_1246_3: cmp-lt s_1246_2 s_1246_0
        let s_1246_3: bool = ((s_1246_2) < (s_1246_0));
        // D s_1246_4: write-var gs#410150 <= s_1246_3
        fn_state.gs_410150 = s_1246_3;
        // N s_1246_5: jump b1245
        return block_1245(state, tracer, fn_state);
    }
    fn block_1247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1247_0: const #4s : i
        let s_1247_0: i128 = 4;
        // D s_1247_1: read-var u#33624:u32
        let s_1247_1: u32 = fn_state.u_33624;
        // D s_1247_2: cast zx s_1247_1 -> bv
        let s_1247_2: Bits = Bits::new(s_1247_1 as u128, 32u16);
        // C s_1247_3: const #1s : i64
        let s_1247_3: i64 = 1;
        // C s_1247_4: cast zx s_1247_3 -> i
        let s_1247_4: i128 = (i128::try_from(s_1247_3).unwrap());
        // C s_1247_5: const #7s : i
        let s_1247_5: i128 = 7;
        // C s_1247_6: add s_1247_5 s_1247_4
        let s_1247_6: i128 = (s_1247_5 + s_1247_4);
        // D s_1247_7: bit-extract s_1247_2 s_1247_0 s_1247_6
        let s_1247_7: Bits = (Bits::new(
            ((s_1247_2) >> (s_1247_0)).value(),
            u16::try_from(s_1247_6).unwrap(),
        ));
        // D s_1247_8: cast reint s_1247_7 -> u8
        let s_1247_8: u8 = (s_1247_7.value() as u8);
        // D s_1247_9: cast zx s_1247_8 -> bv
        let s_1247_9: Bits = Bits::new(s_1247_8 as u128, 8u16);
        // C s_1247_10: const #243u : u8
        let s_1247_10: u8 = 243;
        // C s_1247_11: cast zx s_1247_10 -> bv
        let s_1247_11: Bits = Bits::new(s_1247_10 as u128, 8u16);
        // D s_1247_12: cmp-eq s_1247_9 s_1247_11
        let s_1247_12: bool = ((s_1247_9) == (s_1247_11));
        // D s_1247_13: write-var gs#410146 <= s_1247_12
        fn_state.gs_410146 = s_1247_12;
        // N s_1247_14: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_1248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1248_0: const #28s : i
        let s_1248_0: i128 = 28;
        // C s_1248_1: const #4s : i
        let s_1248_1: i128 = 4;
        // D s_1248_2: read-var u#33617:u32
        let s_1248_2: u32 = fn_state.u_33617;
        // D s_1248_3: cast zx s_1248_2 -> bv
        let s_1248_3: Bits = Bits::new(s_1248_2 as u128, 32u16);
        // D s_1248_4: bit-extract s_1248_3 s_1248_0 s_1248_1
        let s_1248_4: Bits = (Bits::new(
            ((s_1248_3) >> (s_1248_0)).value(),
            u16::try_from(s_1248_1).unwrap(),
        ));
        // D s_1248_5: cast reint s_1248_4 -> u8
        let s_1248_5: u8 = (s_1248_4.value() as u8);
        // D s_1248_6: cast zx s_1248_5 -> bv
        let s_1248_6: Bits = Bits::new(s_1248_5 as u128, 4u16);
        // C s_1248_7: const #15u : u8
        let s_1248_7: u8 = 15;
        // C s_1248_8: cast zx s_1248_7 -> bv
        let s_1248_8: Bits = Bits::new(s_1248_7 as u128, 4u16);
        // D s_1248_9: cmp-ne s_1248_6 s_1248_8
        let s_1248_9: bool = ((s_1248_6) != (s_1248_8));
        // N s_1248_10: branch s_1248_9 b1251 b1249
        if s_1248_9 {
            return block_1251(state, tracer, fn_state);
        } else {
            return block_1249(state, tracer, fn_state);
        };
    }
    fn block_1249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1249_0: const #0u : u8
        let s_1249_0: bool = false;
        // D s_1249_1: write-var gs#410127 <= s_1249_0
        fn_state.gs_410127 = s_1249_0;
        // N s_1249_2: jump b1250
        return block_1250(state, tracer, fn_state);
    }
    fn block_1250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1250_0: read-var gs#410127:u8
        let s_1250_0: bool = fn_state.gs_410127;
        // D s_1250_1: write-var gs#410128 <= s_1250_0
        fn_state.gs_410128 = s_1250_0;
        // N s_1250_2: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_1251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1251_0: const #3172s : i
        let s_1251_0: i128 = 3172;
        // C s_1251_1: const #14696u : u32
        let s_1251_1: u32 = 14696;
        // D s_1251_2: read-reg s_1251_1:i
        let s_1251_2: i128 = {
            let value = state.read_register::<i128>(s_1251_1 as isize);
            tracer.read_register(s_1251_1 as isize, value);
            value
        };
        // D s_1251_3: cmp-lt s_1251_2 s_1251_0
        let s_1251_3: bool = ((s_1251_2) < (s_1251_0));
        // D s_1251_4: write-var gs#410127 <= s_1251_3
        fn_state.gs_410127 = s_1251_3;
        // N s_1251_5: jump b1250
        return block_1250(state, tracer, fn_state);
    }
    fn block_1252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1252_0: const #12s : i
        let s_1252_0: i128 = 12;
        // D s_1252_1: read-var u#33617:u32
        let s_1252_1: u32 = fn_state.u_33617;
        // D s_1252_2: cast zx s_1252_1 -> bv
        let s_1252_2: Bits = Bits::new(s_1252_1 as u128, 32u16);
        // C s_1252_3: const #1s : i64
        let s_1252_3: i64 = 1;
        // C s_1252_4: cast zx s_1252_3 -> i
        let s_1252_4: i128 = (i128::try_from(s_1252_3).unwrap());
        // C s_1252_5: const #3s : i
        let s_1252_5: i128 = 3;
        // C s_1252_6: add s_1252_5 s_1252_4
        let s_1252_6: i128 = (s_1252_5 + s_1252_4);
        // D s_1252_7: bit-extract s_1252_2 s_1252_0 s_1252_6
        let s_1252_7: Bits = (Bits::new(
            ((s_1252_2) >> (s_1252_0)).value(),
            u16::try_from(s_1252_6).unwrap(),
        ));
        // D s_1252_8: cast reint s_1252_7 -> u8
        let s_1252_8: u8 = (s_1252_7.value() as u8);
        // D s_1252_9: cast zx s_1252_8 -> bv
        let s_1252_9: Bits = Bits::new(s_1252_8 as u128, 4u16);
        // C s_1252_10: const #15u : u8
        let s_1252_10: u8 = 15;
        // C s_1252_11: cast zx s_1252_10 -> bv
        let s_1252_11: Bits = Bits::new(s_1252_10 as u128, 4u16);
        // D s_1252_12: cmp-eq s_1252_9 s_1252_11
        let s_1252_12: bool = ((s_1252_9) == (s_1252_11));
        // N s_1252_13: branch s_1252_12 b1255 b1253
        if s_1252_12 {
            return block_1255(state, tracer, fn_state);
        } else {
            return block_1253(state, tracer, fn_state);
        };
    }
    fn block_1253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1253_0: const #0u : u8
        let s_1253_0: bool = false;
        // D s_1253_1: write-var gs#410122 <= s_1253_0
        fn_state.gs_410122 = s_1253_0;
        // N s_1253_2: jump b1254
        return block_1254(state, tracer, fn_state);
    }
    fn block_1254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1254_0: read-var gs#410122:u8
        let s_1254_0: bool = fn_state.gs_410122;
        // D s_1254_1: write-var gs#410123 <= s_1254_0
        fn_state.gs_410123 = s_1254_0;
        // N s_1254_2: jump b468
        return block_468(state, tracer, fn_state);
    }
    fn block_1255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1255_0: const #6s : i
        let s_1255_0: i128 = 6;
        // D s_1255_1: read-var u#33617:u32
        let s_1255_1: u32 = fn_state.u_33617;
        // D s_1255_2: cast zx s_1255_1 -> bv
        let s_1255_2: Bits = Bits::new(s_1255_1 as u128, 32u16);
        // C s_1255_3: const #1s : i64
        let s_1255_3: i64 = 1;
        // C s_1255_4: cast zx s_1255_3 -> i
        let s_1255_4: i128 = (i128::try_from(s_1255_3).unwrap());
        // C s_1255_5: const #1s : i
        let s_1255_5: i128 = 1;
        // C s_1255_6: add s_1255_5 s_1255_4
        let s_1255_6: i128 = (s_1255_5 + s_1255_4);
        // D s_1255_7: bit-extract s_1255_2 s_1255_0 s_1255_6
        let s_1255_7: Bits = (Bits::new(
            ((s_1255_2) >> (s_1255_0)).value(),
            u16::try_from(s_1255_6).unwrap(),
        ));
        // D s_1255_8: cast reint s_1255_7 -> u8
        let s_1255_8: u8 = (s_1255_7.value() as u8);
        // D s_1255_9: cast zx s_1255_8 -> bv
        let s_1255_9: Bits = Bits::new(s_1255_8 as u128, 2u16);
        // C s_1255_10: const #1u : u8
        let s_1255_10: u8 = 1;
        // C s_1255_11: cast zx s_1255_10 -> bv
        let s_1255_11: Bits = Bits::new(s_1255_10 as u128, 2u16);
        // D s_1255_12: cmp-eq s_1255_9 s_1255_11
        let s_1255_12: bool = ((s_1255_9) == (s_1255_11));
        // N s_1255_13: branch s_1255_12 b1258 b1256
        if s_1255_12 {
            return block_1258(state, tracer, fn_state);
        } else {
            return block_1256(state, tracer, fn_state);
        };
    }
    fn block_1256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1256_0: const #0u : u8
        let s_1256_0: bool = false;
        // D s_1256_1: write-var gs#410121 <= s_1256_0
        fn_state.gs_410121 = s_1256_0;
        // N s_1256_2: jump b1257
        return block_1257(state, tracer, fn_state);
    }
    fn block_1257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1257_0: read-var gs#410121:u8
        let s_1257_0: bool = fn_state.gs_410121;
        // D s_1257_1: write-var gs#410122 <= s_1257_0
        fn_state.gs_410122 = s_1257_0;
        // N s_1257_2: jump b1254
        return block_1254(state, tracer, fn_state);
    }
    fn block_1258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1258_0: const #4s : i
        let s_1258_0: i128 = 4;
        // D s_1258_1: read-var u#33617:u32
        let s_1258_1: u32 = fn_state.u_33617;
        // D s_1258_2: cast zx s_1258_1 -> bv
        let s_1258_2: Bits = Bits::new(s_1258_1 as u128, 32u16);
        // C s_1258_3: const #1s : i64
        let s_1258_3: i64 = 1;
        // C s_1258_4: cast zx s_1258_3 -> i
        let s_1258_4: i128 = (i128::try_from(s_1258_3).unwrap());
        // C s_1258_5: const #0s : i
        let s_1258_5: i128 = 0;
        // C s_1258_6: add s_1258_5 s_1258_4
        let s_1258_6: i128 = (s_1258_5 + s_1258_4);
        // D s_1258_7: bit-extract s_1258_2 s_1258_0 s_1258_6
        let s_1258_7: Bits = (Bits::new(
            ((s_1258_2) >> (s_1258_0)).value(),
            u16::try_from(s_1258_6).unwrap(),
        ));
        // D s_1258_8: cast reint s_1258_7 -> u8
        let s_1258_8: bool = ((s_1258_7.value()) != 0);
        // D s_1258_9: cast zx s_1258_8 -> bv
        let s_1258_9: Bits = Bits::new(s_1258_8 as u128, 1u16);
        // C s_1258_10: const #1u : u8
        let s_1258_10: bool = true;
        // C s_1258_11: cast zx s_1258_10 -> bv
        let s_1258_11: Bits = Bits::new(s_1258_10 as u128, 1u16);
        // D s_1258_12: cmp-eq s_1258_9 s_1258_11
        let s_1258_12: bool = ((s_1258_9) == (s_1258_11));
        // D s_1258_13: write-var gs#410121 <= s_1258_12
        fn_state.gs_410121 = s_1258_12;
        // N s_1258_14: jump b1257
        return block_1257(state, tracer, fn_state);
    }
    fn block_1259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1259_0: const #28s : i
        let s_1259_0: i128 = 28;
        // C s_1259_1: const #4s : i
        let s_1259_1: i128 = 4;
        // D s_1259_2: read-var u#33610:u32
        let s_1259_2: u32 = fn_state.u_33610;
        // D s_1259_3: cast zx s_1259_2 -> bv
        let s_1259_3: Bits = Bits::new(s_1259_2 as u128, 32u16);
        // D s_1259_4: bit-extract s_1259_3 s_1259_0 s_1259_1
        let s_1259_4: Bits = (Bits::new(
            ((s_1259_3) >> (s_1259_0)).value(),
            u16::try_from(s_1259_1).unwrap(),
        ));
        // D s_1259_5: cast reint s_1259_4 -> u8
        let s_1259_5: u8 = (s_1259_4.value() as u8);
        // D s_1259_6: cast zx s_1259_5 -> bv
        let s_1259_6: Bits = Bits::new(s_1259_5 as u128, 4u16);
        // C s_1259_7: const #15u : u8
        let s_1259_7: u8 = 15;
        // C s_1259_8: cast zx s_1259_7 -> bv
        let s_1259_8: Bits = Bits::new(s_1259_7 as u128, 4u16);
        // D s_1259_9: cmp-ne s_1259_6 s_1259_8
        let s_1259_9: bool = ((s_1259_6) != (s_1259_8));
        // N s_1259_10: branch s_1259_9 b1262 b1260
        if s_1259_9 {
            return block_1262(state, tracer, fn_state);
        } else {
            return block_1260(state, tracer, fn_state);
        };
    }
    fn block_1260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1260_0: const #0u : u8
        let s_1260_0: bool = false;
        // D s_1260_1: write-var gs#410098 <= s_1260_0
        fn_state.gs_410098 = s_1260_0;
        // N s_1260_2: jump b1261
        return block_1261(state, tracer, fn_state);
    }
    fn block_1261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1261_0: read-var gs#410098:u8
        let s_1261_0: bool = fn_state.gs_410098;
        // D s_1261_1: write-var gs#410099 <= s_1261_0
        fn_state.gs_410099 = s_1261_0;
        // N s_1261_2: jump b464
        return block_464(state, tracer, fn_state);
    }
    fn block_1262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1262_0: const #3164s : i
        let s_1262_0: i128 = 3164;
        // C s_1262_1: const #14696u : u32
        let s_1262_1: u32 = 14696;
        // D s_1262_2: read-reg s_1262_1:i
        let s_1262_2: i128 = {
            let value = state.read_register::<i128>(s_1262_1 as isize);
            tracer.read_register(s_1262_1 as isize, value);
            value
        };
        // D s_1262_3: cmp-lt s_1262_2 s_1262_0
        let s_1262_3: bool = ((s_1262_2) < (s_1262_0));
        // D s_1262_4: write-var gs#410098 <= s_1262_3
        fn_state.gs_410098 = s_1262_3;
        // N s_1262_5: jump b1261
        return block_1261(state, tracer, fn_state);
    }
    fn block_1263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1263_0: const #12s : i
        let s_1263_0: i128 = 12;
        // D s_1263_1: read-var u#33610:u32
        let s_1263_1: u32 = fn_state.u_33610;
        // D s_1263_2: cast zx s_1263_1 -> bv
        let s_1263_2: Bits = Bits::new(s_1263_1 as u128, 32u16);
        // C s_1263_3: const #1s : i64
        let s_1263_3: i64 = 1;
        // C s_1263_4: cast zx s_1263_3 -> i
        let s_1263_4: i128 = (i128::try_from(s_1263_3).unwrap());
        // C s_1263_5: const #3s : i
        let s_1263_5: i128 = 3;
        // C s_1263_6: add s_1263_5 s_1263_4
        let s_1263_6: i128 = (s_1263_5 + s_1263_4);
        // D s_1263_7: bit-extract s_1263_2 s_1263_0 s_1263_6
        let s_1263_7: Bits = (Bits::new(
            ((s_1263_2) >> (s_1263_0)).value(),
            u16::try_from(s_1263_6).unwrap(),
        ));
        // D s_1263_8: cast reint s_1263_7 -> u8
        let s_1263_8: u8 = (s_1263_7.value() as u8);
        // D s_1263_9: cast zx s_1263_8 -> bv
        let s_1263_9: Bits = Bits::new(s_1263_8 as u128, 4u16);
        // C s_1263_10: const #15u : u8
        let s_1263_10: u8 = 15;
        // C s_1263_11: cast zx s_1263_10 -> bv
        let s_1263_11: Bits = Bits::new(s_1263_10 as u128, 4u16);
        // D s_1263_12: cmp-eq s_1263_9 s_1263_11
        let s_1263_12: bool = ((s_1263_9) == (s_1263_11));
        // N s_1263_13: branch s_1263_12 b1266 b1264
        if s_1263_12 {
            return block_1266(state, tracer, fn_state);
        } else {
            return block_1264(state, tracer, fn_state);
        };
    }
    fn block_1264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1264_0: const #0u : u8
        let s_1264_0: bool = false;
        // D s_1264_1: write-var gs#410093 <= s_1264_0
        fn_state.gs_410093 = s_1264_0;
        // N s_1264_2: jump b1265
        return block_1265(state, tracer, fn_state);
    }
    fn block_1265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1265_0: read-var gs#410093:u8
        let s_1265_0: bool = fn_state.gs_410093;
        // D s_1265_1: write-var gs#410094 <= s_1265_0
        fn_state.gs_410094 = s_1265_0;
        // N s_1265_2: jump b462
        return block_462(state, tracer, fn_state);
    }
    fn block_1266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1266_0: const #6s : i
        let s_1266_0: i128 = 6;
        // D s_1266_1: read-var u#33610:u32
        let s_1266_1: u32 = fn_state.u_33610;
        // D s_1266_2: cast zx s_1266_1 -> bv
        let s_1266_2: Bits = Bits::new(s_1266_1 as u128, 32u16);
        // C s_1266_3: const #1s : i64
        let s_1266_3: i64 = 1;
        // C s_1266_4: cast zx s_1266_3 -> i
        let s_1266_4: i128 = (i128::try_from(s_1266_3).unwrap());
        // C s_1266_5: const #1s : i
        let s_1266_5: i128 = 1;
        // C s_1266_6: add s_1266_5 s_1266_4
        let s_1266_6: i128 = (s_1266_5 + s_1266_4);
        // D s_1266_7: bit-extract s_1266_2 s_1266_0 s_1266_6
        let s_1266_7: Bits = (Bits::new(
            ((s_1266_2) >> (s_1266_0)).value(),
            u16::try_from(s_1266_6).unwrap(),
        ));
        // D s_1266_8: cast reint s_1266_7 -> u8
        let s_1266_8: u8 = (s_1266_7.value() as u8);
        // D s_1266_9: cast zx s_1266_8 -> bv
        let s_1266_9: Bits = Bits::new(s_1266_8 as u128, 2u16);
        // C s_1266_10: const #0u : u8
        let s_1266_10: u8 = 0;
        // C s_1266_11: cast zx s_1266_10 -> bv
        let s_1266_11: Bits = Bits::new(s_1266_10 as u128, 2u16);
        // D s_1266_12: cmp-eq s_1266_9 s_1266_11
        let s_1266_12: bool = ((s_1266_9) == (s_1266_11));
        // N s_1266_13: branch s_1266_12 b1269 b1267
        if s_1266_12 {
            return block_1269(state, tracer, fn_state);
        } else {
            return block_1267(state, tracer, fn_state);
        };
    }
    fn block_1267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1267_0: const #0u : u8
        let s_1267_0: bool = false;
        // D s_1267_1: write-var gs#410092 <= s_1267_0
        fn_state.gs_410092 = s_1267_0;
        // N s_1267_2: jump b1268
        return block_1268(state, tracer, fn_state);
    }
    fn block_1268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1268_0: read-var gs#410092:u8
        let s_1268_0: bool = fn_state.gs_410092;
        // D s_1268_1: write-var gs#410093 <= s_1268_0
        fn_state.gs_410093 = s_1268_0;
        // N s_1268_2: jump b1265
        return block_1265(state, tracer, fn_state);
    }
    fn block_1269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1269_0: const #4s : i
        let s_1269_0: i128 = 4;
        // D s_1269_1: read-var u#33610:u32
        let s_1269_1: u32 = fn_state.u_33610;
        // D s_1269_2: cast zx s_1269_1 -> bv
        let s_1269_2: Bits = Bits::new(s_1269_1 as u128, 32u16);
        // C s_1269_3: const #1s : i64
        let s_1269_3: i64 = 1;
        // C s_1269_4: cast zx s_1269_3 -> i
        let s_1269_4: i128 = (i128::try_from(s_1269_3).unwrap());
        // C s_1269_5: const #0s : i
        let s_1269_5: i128 = 0;
        // C s_1269_6: add s_1269_5 s_1269_4
        let s_1269_6: i128 = (s_1269_5 + s_1269_4);
        // D s_1269_7: bit-extract s_1269_2 s_1269_0 s_1269_6
        let s_1269_7: Bits = (Bits::new(
            ((s_1269_2) >> (s_1269_0)).value(),
            u16::try_from(s_1269_6).unwrap(),
        ));
        // D s_1269_8: cast reint s_1269_7 -> u8
        let s_1269_8: bool = ((s_1269_7.value()) != 0);
        // D s_1269_9: cast zx s_1269_8 -> bv
        let s_1269_9: Bits = Bits::new(s_1269_8 as u128, 1u16);
        // C s_1269_10: const #1u : u8
        let s_1269_10: bool = true;
        // C s_1269_11: cast zx s_1269_10 -> bv
        let s_1269_11: Bits = Bits::new(s_1269_10 as u128, 1u16);
        // D s_1269_12: cmp-eq s_1269_9 s_1269_11
        let s_1269_12: bool = ((s_1269_9) == (s_1269_11));
        // D s_1269_13: write-var gs#410092 <= s_1269_12
        fn_state.gs_410092 = s_1269_12;
        // N s_1269_14: jump b1268
        return block_1268(state, tracer, fn_state);
    }
    fn block_1270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1270_0: const #28s : i
        let s_1270_0: i128 = 28;
        // C s_1270_1: const #4s : i
        let s_1270_1: i128 = 4;
        // D s_1270_2: read-var u#33603:u32
        let s_1270_2: u32 = fn_state.u_33603;
        // D s_1270_3: cast zx s_1270_2 -> bv
        let s_1270_3: Bits = Bits::new(s_1270_2 as u128, 32u16);
        // D s_1270_4: bit-extract s_1270_3 s_1270_0 s_1270_1
        let s_1270_4: Bits = (Bits::new(
            ((s_1270_3) >> (s_1270_0)).value(),
            u16::try_from(s_1270_1).unwrap(),
        ));
        // D s_1270_5: cast reint s_1270_4 -> u8
        let s_1270_5: u8 = (s_1270_4.value() as u8);
        // D s_1270_6: cast zx s_1270_5 -> bv
        let s_1270_6: Bits = Bits::new(s_1270_5 as u128, 4u16);
        // C s_1270_7: const #15u : u8
        let s_1270_7: u8 = 15;
        // C s_1270_8: cast zx s_1270_7 -> bv
        let s_1270_8: Bits = Bits::new(s_1270_7 as u128, 4u16);
        // D s_1270_9: cmp-ne s_1270_6 s_1270_8
        let s_1270_9: bool = ((s_1270_6) != (s_1270_8));
        // N s_1270_10: branch s_1270_9 b1273 b1271
        if s_1270_9 {
            return block_1273(state, tracer, fn_state);
        } else {
            return block_1271(state, tracer, fn_state);
        };
    }
    fn block_1271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1271_0: const #0u : u8
        let s_1271_0: bool = false;
        // D s_1271_1: write-var gs#410069 <= s_1271_0
        fn_state.gs_410069 = s_1271_0;
        // N s_1271_2: jump b1272
        return block_1272(state, tracer, fn_state);
    }
    fn block_1272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1272_0: read-var gs#410069:u8
        let s_1272_0: bool = fn_state.gs_410069;
        // D s_1272_1: write-var gs#410070 <= s_1272_0
        fn_state.gs_410070 = s_1272_0;
        // N s_1272_2: jump b458
        return block_458(state, tracer, fn_state);
    }
    fn block_1273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1273_0: const #3162s : i
        let s_1273_0: i128 = 3162;
        // C s_1273_1: const #14696u : u32
        let s_1273_1: u32 = 14696;
        // D s_1273_2: read-reg s_1273_1:i
        let s_1273_2: i128 = {
            let value = state.read_register::<i128>(s_1273_1 as isize);
            tracer.read_register(s_1273_1 as isize, value);
            value
        };
        // D s_1273_3: cmp-lt s_1273_2 s_1273_0
        let s_1273_3: bool = ((s_1273_2) < (s_1273_0));
        // D s_1273_4: write-var gs#410069 <= s_1273_3
        fn_state.gs_410069 = s_1273_3;
        // N s_1273_5: jump b1272
        return block_1272(state, tracer, fn_state);
    }
    fn block_1274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1274_0: const #12s : i
        let s_1274_0: i128 = 12;
        // D s_1274_1: read-var u#33603:u32
        let s_1274_1: u32 = fn_state.u_33603;
        // D s_1274_2: cast zx s_1274_1 -> bv
        let s_1274_2: Bits = Bits::new(s_1274_1 as u128, 32u16);
        // C s_1274_3: const #1s : i64
        let s_1274_3: i64 = 1;
        // C s_1274_4: cast zx s_1274_3 -> i
        let s_1274_4: i128 = (i128::try_from(s_1274_3).unwrap());
        // C s_1274_5: const #3s : i
        let s_1274_5: i128 = 3;
        // C s_1274_6: add s_1274_5 s_1274_4
        let s_1274_6: i128 = (s_1274_5 + s_1274_4);
        // D s_1274_7: bit-extract s_1274_2 s_1274_0 s_1274_6
        let s_1274_7: Bits = (Bits::new(
            ((s_1274_2) >> (s_1274_0)).value(),
            u16::try_from(s_1274_6).unwrap(),
        ));
        // D s_1274_8: cast reint s_1274_7 -> u8
        let s_1274_8: u8 = (s_1274_7.value() as u8);
        // D s_1274_9: cast zx s_1274_8 -> bv
        let s_1274_9: Bits = Bits::new(s_1274_8 as u128, 4u16);
        // C s_1274_10: const #15u : u8
        let s_1274_10: u8 = 15;
        // C s_1274_11: cast zx s_1274_10 -> bv
        let s_1274_11: Bits = Bits::new(s_1274_10 as u128, 4u16);
        // D s_1274_12: cmp-eq s_1274_9 s_1274_11
        let s_1274_12: bool = ((s_1274_9) == (s_1274_11));
        // N s_1274_13: branch s_1274_12 b1277 b1275
        if s_1274_12 {
            return block_1277(state, tracer, fn_state);
        } else {
            return block_1275(state, tracer, fn_state);
        };
    }
    fn block_1275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1275_0: const #0u : u8
        let s_1275_0: bool = false;
        // D s_1275_1: write-var gs#410064 <= s_1275_0
        fn_state.gs_410064 = s_1275_0;
        // N s_1275_2: jump b1276
        return block_1276(state, tracer, fn_state);
    }
    fn block_1276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1276_0: read-var gs#410064:u8
        let s_1276_0: bool = fn_state.gs_410064;
        // D s_1276_1: write-var gs#410065 <= s_1276_0
        fn_state.gs_410065 = s_1276_0;
        // N s_1276_2: jump b456
        return block_456(state, tracer, fn_state);
    }
    fn block_1277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1277_0: const #6s : i
        let s_1277_0: i128 = 6;
        // D s_1277_1: read-var u#33603:u32
        let s_1277_1: u32 = fn_state.u_33603;
        // D s_1277_2: cast zx s_1277_1 -> bv
        let s_1277_2: Bits = Bits::new(s_1277_1 as u128, 32u16);
        // C s_1277_3: const #1s : i64
        let s_1277_3: i64 = 1;
        // C s_1277_4: cast zx s_1277_3 -> i
        let s_1277_4: i128 = (i128::try_from(s_1277_3).unwrap());
        // C s_1277_5: const #1s : i
        let s_1277_5: i128 = 1;
        // C s_1277_6: add s_1277_5 s_1277_4
        let s_1277_6: i128 = (s_1277_5 + s_1277_4);
        // D s_1277_7: bit-extract s_1277_2 s_1277_0 s_1277_6
        let s_1277_7: Bits = (Bits::new(
            ((s_1277_2) >> (s_1277_0)).value(),
            u16::try_from(s_1277_6).unwrap(),
        ));
        // D s_1277_8: cast reint s_1277_7 -> u8
        let s_1277_8: u8 = (s_1277_7.value() as u8);
        // D s_1277_9: cast zx s_1277_8 -> bv
        let s_1277_9: Bits = Bits::new(s_1277_8 as u128, 2u16);
        // C s_1277_10: const #0u : u8
        let s_1277_10: u8 = 0;
        // C s_1277_11: cast zx s_1277_10 -> bv
        let s_1277_11: Bits = Bits::new(s_1277_10 as u128, 2u16);
        // D s_1277_12: cmp-eq s_1277_9 s_1277_11
        let s_1277_12: bool = ((s_1277_9) == (s_1277_11));
        // N s_1277_13: branch s_1277_12 b1280 b1278
        if s_1277_12 {
            return block_1280(state, tracer, fn_state);
        } else {
            return block_1278(state, tracer, fn_state);
        };
    }
    fn block_1278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1278_0: const #0u : u8
        let s_1278_0: bool = false;
        // D s_1278_1: write-var gs#410063 <= s_1278_0
        fn_state.gs_410063 = s_1278_0;
        // N s_1278_2: jump b1279
        return block_1279(state, tracer, fn_state);
    }
    fn block_1279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1279_0: read-var gs#410063:u8
        let s_1279_0: bool = fn_state.gs_410063;
        // D s_1279_1: write-var gs#410064 <= s_1279_0
        fn_state.gs_410064 = s_1279_0;
        // N s_1279_2: jump b1276
        return block_1276(state, tracer, fn_state);
    }
    fn block_1280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1280_0: const #4s : i
        let s_1280_0: i128 = 4;
        // D s_1280_1: read-var u#33603:u32
        let s_1280_1: u32 = fn_state.u_33603;
        // D s_1280_2: cast zx s_1280_1 -> bv
        let s_1280_2: Bits = Bits::new(s_1280_1 as u128, 32u16);
        // C s_1280_3: const #1s : i64
        let s_1280_3: i64 = 1;
        // C s_1280_4: cast zx s_1280_3 -> i
        let s_1280_4: i128 = (i128::try_from(s_1280_3).unwrap());
        // C s_1280_5: const #0s : i
        let s_1280_5: i128 = 0;
        // C s_1280_6: add s_1280_5 s_1280_4
        let s_1280_6: i128 = (s_1280_5 + s_1280_4);
        // D s_1280_7: bit-extract s_1280_2 s_1280_0 s_1280_6
        let s_1280_7: Bits = (Bits::new(
            ((s_1280_2) >> (s_1280_0)).value(),
            u16::try_from(s_1280_6).unwrap(),
        ));
        // D s_1280_8: cast reint s_1280_7 -> u8
        let s_1280_8: bool = ((s_1280_7.value()) != 0);
        // D s_1280_9: cast zx s_1280_8 -> bv
        let s_1280_9: Bits = Bits::new(s_1280_8 as u128, 1u16);
        // C s_1280_10: const #1u : u8
        let s_1280_10: bool = true;
        // C s_1280_11: cast zx s_1280_10 -> bv
        let s_1280_11: Bits = Bits::new(s_1280_10 as u128, 1u16);
        // D s_1280_12: cmp-eq s_1280_9 s_1280_11
        let s_1280_12: bool = ((s_1280_9) == (s_1280_11));
        // D s_1280_13: write-var gs#410063 <= s_1280_12
        fn_state.gs_410063 = s_1280_12;
        // N s_1280_14: jump b1279
        return block_1279(state, tracer, fn_state);
    }
    fn block_1281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1281_0: const #28s : i
        let s_1281_0: i128 = 28;
        // C s_1281_1: const #4s : i
        let s_1281_1: i128 = 4;
        // D s_1281_2: read-var u#33595:u32
        let s_1281_2: u32 = fn_state.u_33595;
        // D s_1281_3: cast zx s_1281_2 -> bv
        let s_1281_3: Bits = Bits::new(s_1281_2 as u128, 32u16);
        // D s_1281_4: bit-extract s_1281_3 s_1281_0 s_1281_1
        let s_1281_4: Bits = (Bits::new(
            ((s_1281_3) >> (s_1281_0)).value(),
            u16::try_from(s_1281_1).unwrap(),
        ));
        // D s_1281_5: cast reint s_1281_4 -> u8
        let s_1281_5: u8 = (s_1281_4.value() as u8);
        // D s_1281_6: cast zx s_1281_5 -> bv
        let s_1281_6: Bits = Bits::new(s_1281_5 as u128, 4u16);
        // C s_1281_7: const #15u : u8
        let s_1281_7: u8 = 15;
        // C s_1281_8: cast zx s_1281_7 -> bv
        let s_1281_8: Bits = Bits::new(s_1281_7 as u128, 4u16);
        // D s_1281_9: cmp-ne s_1281_6 s_1281_8
        let s_1281_9: bool = ((s_1281_6) != (s_1281_8));
        // N s_1281_10: branch s_1281_9 b1284 b1282
        if s_1281_9 {
            return block_1284(state, tracer, fn_state);
        } else {
            return block_1282(state, tracer, fn_state);
        };
    }
    fn block_1282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1282_0: const #0u : u8
        let s_1282_0: bool = false;
        // D s_1282_1: write-var gs#410038 <= s_1282_0
        fn_state.gs_410038 = s_1282_0;
        // N s_1282_2: jump b1283
        return block_1283(state, tracer, fn_state);
    }
    fn block_1283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1283_0: read-var gs#410038:u8
        let s_1283_0: bool = fn_state.gs_410038;
        // D s_1283_1: write-var gs#410039 <= s_1283_0
        fn_state.gs_410039 = s_1283_0;
        // N s_1283_2: jump b452
        return block_452(state, tracer, fn_state);
    }
    fn block_1284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1284_0: const #3160s : i
        let s_1284_0: i128 = 3160;
        // C s_1284_1: const #14696u : u32
        let s_1284_1: u32 = 14696;
        // D s_1284_2: read-reg s_1284_1:i
        let s_1284_2: i128 = {
            let value = state.read_register::<i128>(s_1284_1 as isize);
            tracer.read_register(s_1284_1 as isize, value);
            value
        };
        // D s_1284_3: cmp-lt s_1284_2 s_1284_0
        let s_1284_3: bool = ((s_1284_2) < (s_1284_0));
        // D s_1284_4: write-var gs#410038 <= s_1284_3
        fn_state.gs_410038 = s_1284_3;
        // N s_1284_5: jump b1283
        return block_1283(state, tracer, fn_state);
    }
    fn block_1285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1285_0: const #6s : i
        let s_1285_0: i128 = 6;
        // D s_1285_1: read-var u#33595:u32
        let s_1285_1: u32 = fn_state.u_33595;
        // D s_1285_2: cast zx s_1285_1 -> bv
        let s_1285_2: Bits = Bits::new(s_1285_1 as u128, 32u16);
        // C s_1285_3: const #1s : i64
        let s_1285_3: i64 = 1;
        // C s_1285_4: cast zx s_1285_3 -> i
        let s_1285_4: i128 = (i128::try_from(s_1285_3).unwrap());
        // C s_1285_5: const #1s : i
        let s_1285_5: i128 = 1;
        // C s_1285_6: add s_1285_5 s_1285_4
        let s_1285_6: i128 = (s_1285_5 + s_1285_4);
        // D s_1285_7: bit-extract s_1285_2 s_1285_0 s_1285_6
        let s_1285_7: Bits = (Bits::new(
            ((s_1285_2) >> (s_1285_0)).value(),
            u16::try_from(s_1285_6).unwrap(),
        ));
        // D s_1285_8: cast reint s_1285_7 -> u8
        let s_1285_8: u8 = (s_1285_7.value() as u8);
        // D s_1285_9: cast zx s_1285_8 -> bv
        let s_1285_9: Bits = Bits::new(s_1285_8 as u128, 2u16);
        // C s_1285_10: const #3u : u8
        let s_1285_10: u8 = 3;
        // C s_1285_11: cast zx s_1285_10 -> bv
        let s_1285_11: Bits = Bits::new(s_1285_10 as u128, 2u16);
        // D s_1285_12: cmp-eq s_1285_9 s_1285_11
        let s_1285_12: bool = ((s_1285_9) == (s_1285_11));
        // N s_1285_13: branch s_1285_12 b1288 b1286
        if s_1285_12 {
            return block_1288(state, tracer, fn_state);
        } else {
            return block_1286(state, tracer, fn_state);
        };
    }
    fn block_1286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1286_0: const #0u : u8
        let s_1286_0: bool = false;
        // D s_1286_1: write-var gs#410033 <= s_1286_0
        fn_state.gs_410033 = s_1286_0;
        // N s_1286_2: jump b1287
        return block_1287(state, tracer, fn_state);
    }
    fn block_1287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1287_0: read-var gs#410033:u8
        let s_1287_0: bool = fn_state.gs_410033;
        // D s_1287_1: write-var gs#410034 <= s_1287_0
        fn_state.gs_410034 = s_1287_0;
        // N s_1287_2: jump b450
        return block_450(state, tracer, fn_state);
    }
    fn block_1288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1288_0: const #4s : i
        let s_1288_0: i128 = 4;
        // D s_1288_1: read-var u#33595:u32
        let s_1288_1: u32 = fn_state.u_33595;
        // D s_1288_2: cast zx s_1288_1 -> bv
        let s_1288_2: Bits = Bits::new(s_1288_1 as u128, 32u16);
        // C s_1288_3: const #1s : i64
        let s_1288_3: i64 = 1;
        // C s_1288_4: cast zx s_1288_3 -> i
        let s_1288_4: i128 = (i128::try_from(s_1288_3).unwrap());
        // C s_1288_5: const #0s : i
        let s_1288_5: i128 = 0;
        // C s_1288_6: add s_1288_5 s_1288_4
        let s_1288_6: i128 = (s_1288_5 + s_1288_4);
        // D s_1288_7: bit-extract s_1288_2 s_1288_0 s_1288_6
        let s_1288_7: Bits = (Bits::new(
            ((s_1288_2) >> (s_1288_0)).value(),
            u16::try_from(s_1288_6).unwrap(),
        ));
        // D s_1288_8: cast reint s_1288_7 -> u8
        let s_1288_8: bool = ((s_1288_7.value()) != 0);
        // D s_1288_9: cast zx s_1288_8 -> bv
        let s_1288_9: Bits = Bits::new(s_1288_8 as u128, 1u16);
        // C s_1288_10: const #1u : u8
        let s_1288_10: bool = true;
        // C s_1288_11: cast zx s_1288_10 -> bv
        let s_1288_11: Bits = Bits::new(s_1288_10 as u128, 1u16);
        // D s_1288_12: cmp-eq s_1288_9 s_1288_11
        let s_1288_12: bool = ((s_1288_9) == (s_1288_11));
        // D s_1288_13: write-var gs#410033 <= s_1288_12
        fn_state.gs_410033 = s_1288_12;
        // N s_1288_14: jump b1287
        return block_1287(state, tracer, fn_state);
    }
    fn block_1289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1289_0: const #28s : i
        let s_1289_0: i128 = 28;
        // C s_1289_1: const #4s : i
        let s_1289_1: i128 = 4;
        // D s_1289_2: read-var u#33588:u32
        let s_1289_2: u32 = fn_state.u_33588;
        // D s_1289_3: cast zx s_1289_2 -> bv
        let s_1289_3: Bits = Bits::new(s_1289_2 as u128, 32u16);
        // D s_1289_4: bit-extract s_1289_3 s_1289_0 s_1289_1
        let s_1289_4: Bits = (Bits::new(
            ((s_1289_3) >> (s_1289_0)).value(),
            u16::try_from(s_1289_1).unwrap(),
        ));
        // D s_1289_5: cast reint s_1289_4 -> u8
        let s_1289_5: u8 = (s_1289_4.value() as u8);
        // D s_1289_6: cast zx s_1289_5 -> bv
        let s_1289_6: Bits = Bits::new(s_1289_5 as u128, 4u16);
        // C s_1289_7: const #15u : u8
        let s_1289_7: u8 = 15;
        // C s_1289_8: cast zx s_1289_7 -> bv
        let s_1289_8: Bits = Bits::new(s_1289_7 as u128, 4u16);
        // D s_1289_9: cmp-ne s_1289_6 s_1289_8
        let s_1289_9: bool = ((s_1289_6) != (s_1289_8));
        // N s_1289_10: branch s_1289_9 b1292 b1290
        if s_1289_9 {
            return block_1292(state, tracer, fn_state);
        } else {
            return block_1290(state, tracer, fn_state);
        };
    }
    fn block_1290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1290_0: const #0u : u8
        let s_1290_0: bool = false;
        // D s_1290_1: write-var gs#410010 <= s_1290_0
        fn_state.gs_410010 = s_1290_0;
        // N s_1290_2: jump b1291
        return block_1291(state, tracer, fn_state);
    }
    fn block_1291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1291_0: read-var gs#410010:u8
        let s_1291_0: bool = fn_state.gs_410010;
        // D s_1291_1: write-var gs#410011 <= s_1291_0
        fn_state.gs_410011 = s_1291_0;
        // N s_1291_2: jump b446
        return block_446(state, tracer, fn_state);
    }
    fn block_1292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1292_0: const #3158s : i
        let s_1292_0: i128 = 3158;
        // C s_1292_1: const #14696u : u32
        let s_1292_1: u32 = 14696;
        // D s_1292_2: read-reg s_1292_1:i
        let s_1292_2: i128 = {
            let value = state.read_register::<i128>(s_1292_1 as isize);
            tracer.read_register(s_1292_1 as isize, value);
            value
        };
        // D s_1292_3: cmp-lt s_1292_2 s_1292_0
        let s_1292_3: bool = ((s_1292_2) < (s_1292_0));
        // D s_1292_4: write-var gs#410010 <= s_1292_3
        fn_state.gs_410010 = s_1292_3;
        // N s_1292_5: jump b1291
        return block_1291(state, tracer, fn_state);
    }
    fn block_1293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1293_0: const #6s : i
        let s_1293_0: i128 = 6;
        // D s_1293_1: read-var u#33588:u32
        let s_1293_1: u32 = fn_state.u_33588;
        // D s_1293_2: cast zx s_1293_1 -> bv
        let s_1293_2: Bits = Bits::new(s_1293_1 as u128, 32u16);
        // C s_1293_3: const #1s : i64
        let s_1293_3: i64 = 1;
        // C s_1293_4: cast zx s_1293_3 -> i
        let s_1293_4: i128 = (i128::try_from(s_1293_3).unwrap());
        // C s_1293_5: const #1s : i
        let s_1293_5: i128 = 1;
        // C s_1293_6: add s_1293_5 s_1293_4
        let s_1293_6: i128 = (s_1293_5 + s_1293_4);
        // D s_1293_7: bit-extract s_1293_2 s_1293_0 s_1293_6
        let s_1293_7: Bits = (Bits::new(
            ((s_1293_2) >> (s_1293_0)).value(),
            u16::try_from(s_1293_6).unwrap(),
        ));
        // D s_1293_8: cast reint s_1293_7 -> u8
        let s_1293_8: u8 = (s_1293_7.value() as u8);
        // D s_1293_9: cast zx s_1293_8 -> bv
        let s_1293_9: Bits = Bits::new(s_1293_8 as u128, 2u16);
        // C s_1293_10: const #0u : u8
        let s_1293_10: u8 = 0;
        // C s_1293_11: cast zx s_1293_10 -> bv
        let s_1293_11: Bits = Bits::new(s_1293_10 as u128, 2u16);
        // D s_1293_12: cmp-eq s_1293_9 s_1293_11
        let s_1293_12: bool = ((s_1293_9) == (s_1293_11));
        // N s_1293_13: branch s_1293_12 b1296 b1294
        if s_1293_12 {
            return block_1296(state, tracer, fn_state);
        } else {
            return block_1294(state, tracer, fn_state);
        };
    }
    fn block_1294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1294_0: const #0u : u8
        let s_1294_0: bool = false;
        // D s_1294_1: write-var gs#410005 <= s_1294_0
        fn_state.gs_410005 = s_1294_0;
        // N s_1294_2: jump b1295
        return block_1295(state, tracer, fn_state);
    }
    fn block_1295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1295_0: read-var gs#410005:u8
        let s_1295_0: bool = fn_state.gs_410005;
        // D s_1295_1: write-var gs#410006 <= s_1295_0
        fn_state.gs_410006 = s_1295_0;
        // N s_1295_2: jump b444
        return block_444(state, tracer, fn_state);
    }
    fn block_1296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1296_0: const #4s : i
        let s_1296_0: i128 = 4;
        // D s_1296_1: read-var u#33588:u32
        let s_1296_1: u32 = fn_state.u_33588;
        // D s_1296_2: cast zx s_1296_1 -> bv
        let s_1296_2: Bits = Bits::new(s_1296_1 as u128, 32u16);
        // C s_1296_3: const #1s : i64
        let s_1296_3: i64 = 1;
        // C s_1296_4: cast zx s_1296_3 -> i
        let s_1296_4: i128 = (i128::try_from(s_1296_3).unwrap());
        // C s_1296_5: const #0s : i
        let s_1296_5: i128 = 0;
        // C s_1296_6: add s_1296_5 s_1296_4
        let s_1296_6: i128 = (s_1296_5 + s_1296_4);
        // D s_1296_7: bit-extract s_1296_2 s_1296_0 s_1296_6
        let s_1296_7: Bits = (Bits::new(
            ((s_1296_2) >> (s_1296_0)).value(),
            u16::try_from(s_1296_6).unwrap(),
        ));
        // D s_1296_8: cast reint s_1296_7 -> u8
        let s_1296_8: bool = ((s_1296_7.value()) != 0);
        // D s_1296_9: cast zx s_1296_8 -> bv
        let s_1296_9: Bits = Bits::new(s_1296_8 as u128, 1u16);
        // C s_1296_10: const #1u : u8
        let s_1296_10: bool = true;
        // C s_1296_11: cast zx s_1296_10 -> bv
        let s_1296_11: Bits = Bits::new(s_1296_10 as u128, 1u16);
        // D s_1296_12: cmp-eq s_1296_9 s_1296_11
        let s_1296_12: bool = ((s_1296_9) == (s_1296_11));
        // D s_1296_13: write-var gs#410005 <= s_1296_12
        fn_state.gs_410005 = s_1296_12;
        // N s_1296_14: jump b1295
        return block_1295(state, tracer, fn_state);
    }
    fn block_1297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1297_0: const #28s : i
        let s_1297_0: i128 = 28;
        // C s_1297_1: const #4s : i
        let s_1297_1: i128 = 4;
        // D s_1297_2: read-var u#33580:u32
        let s_1297_2: u32 = fn_state.u_33580;
        // D s_1297_3: cast zx s_1297_2 -> bv
        let s_1297_3: Bits = Bits::new(s_1297_2 as u128, 32u16);
        // D s_1297_4: bit-extract s_1297_3 s_1297_0 s_1297_1
        let s_1297_4: Bits = (Bits::new(
            ((s_1297_3) >> (s_1297_0)).value(),
            u16::try_from(s_1297_1).unwrap(),
        ));
        // D s_1297_5: cast reint s_1297_4 -> u8
        let s_1297_5: u8 = (s_1297_4.value() as u8);
        // D s_1297_6: cast zx s_1297_5 -> bv
        let s_1297_6: Bits = Bits::new(s_1297_5 as u128, 4u16);
        // C s_1297_7: const #15u : u8
        let s_1297_7: u8 = 15;
        // C s_1297_8: cast zx s_1297_7 -> bv
        let s_1297_8: Bits = Bits::new(s_1297_7 as u128, 4u16);
        // D s_1297_9: cmp-ne s_1297_6 s_1297_8
        let s_1297_9: bool = ((s_1297_6) != (s_1297_8));
        // N s_1297_10: branch s_1297_9 b1300 b1298
        if s_1297_9 {
            return block_1300(state, tracer, fn_state);
        } else {
            return block_1298(state, tracer, fn_state);
        };
    }
    fn block_1298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1298_0: const #0u : u8
        let s_1298_0: bool = false;
        // D s_1298_1: write-var gs#409982 <= s_1298_0
        fn_state.gs_409982 = s_1298_0;
        // N s_1298_2: jump b1299
        return block_1299(state, tracer, fn_state);
    }
    fn block_1299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1299_0: read-var gs#409982:u8
        let s_1299_0: bool = fn_state.gs_409982;
        // D s_1299_1: write-var gs#409983 <= s_1299_0
        fn_state.gs_409983 = s_1299_0;
        // N s_1299_2: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_1300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1300_0: const #3156s : i
        let s_1300_0: i128 = 3156;
        // C s_1300_1: const #14696u : u32
        let s_1300_1: u32 = 14696;
        // D s_1300_2: read-reg s_1300_1:i
        let s_1300_2: i128 = {
            let value = state.read_register::<i128>(s_1300_1 as isize);
            tracer.read_register(s_1300_1 as isize, value);
            value
        };
        // D s_1300_3: cmp-lt s_1300_2 s_1300_0
        let s_1300_3: bool = ((s_1300_2) < (s_1300_0));
        // D s_1300_4: write-var gs#409982 <= s_1300_3
        fn_state.gs_409982 = s_1300_3;
        // N s_1300_5: jump b1299
        return block_1299(state, tracer, fn_state);
    }
    fn block_1301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1301_0: const #6s : i
        let s_1301_0: i128 = 6;
        // D s_1301_1: read-var u#33580:u32
        let s_1301_1: u32 = fn_state.u_33580;
        // D s_1301_2: cast zx s_1301_1 -> bv
        let s_1301_2: Bits = Bits::new(s_1301_1 as u128, 32u16);
        // C s_1301_3: const #1s : i64
        let s_1301_3: i64 = 1;
        // C s_1301_4: cast zx s_1301_3 -> i
        let s_1301_4: i128 = (i128::try_from(s_1301_3).unwrap());
        // C s_1301_5: const #1s : i
        let s_1301_5: i128 = 1;
        // C s_1301_6: add s_1301_5 s_1301_4
        let s_1301_6: i128 = (s_1301_5 + s_1301_4);
        // D s_1301_7: bit-extract s_1301_2 s_1301_0 s_1301_6
        let s_1301_7: Bits = (Bits::new(
            ((s_1301_2) >> (s_1301_0)).value(),
            u16::try_from(s_1301_6).unwrap(),
        ));
        // D s_1301_8: cast reint s_1301_7 -> u8
        let s_1301_8: u8 = (s_1301_7.value() as u8);
        // D s_1301_9: cast zx s_1301_8 -> bv
        let s_1301_9: Bits = Bits::new(s_1301_8 as u128, 2u16);
        // C s_1301_10: const #1u : u8
        let s_1301_10: u8 = 1;
        // C s_1301_11: cast zx s_1301_10 -> bv
        let s_1301_11: Bits = Bits::new(s_1301_10 as u128, 2u16);
        // D s_1301_12: cmp-eq s_1301_9 s_1301_11
        let s_1301_12: bool = ((s_1301_9) == (s_1301_11));
        // N s_1301_13: branch s_1301_12 b1304 b1302
        if s_1301_12 {
            return block_1304(state, tracer, fn_state);
        } else {
            return block_1302(state, tracer, fn_state);
        };
    }
    fn block_1302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1302_0: const #0u : u8
        let s_1302_0: bool = false;
        // D s_1302_1: write-var gs#409977 <= s_1302_0
        fn_state.gs_409977 = s_1302_0;
        // N s_1302_2: jump b1303
        return block_1303(state, tracer, fn_state);
    }
    fn block_1303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1303_0: read-var gs#409977:u8
        let s_1303_0: bool = fn_state.gs_409977;
        // D s_1303_1: write-var gs#409978 <= s_1303_0
        fn_state.gs_409978 = s_1303_0;
        // N s_1303_2: jump b438
        return block_438(state, tracer, fn_state);
    }
    fn block_1304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1304_0: const #4s : i
        let s_1304_0: i128 = 4;
        // D s_1304_1: read-var u#33580:u32
        let s_1304_1: u32 = fn_state.u_33580;
        // D s_1304_2: cast zx s_1304_1 -> bv
        let s_1304_2: Bits = Bits::new(s_1304_1 as u128, 32u16);
        // C s_1304_3: const #1s : i64
        let s_1304_3: i64 = 1;
        // C s_1304_4: cast zx s_1304_3 -> i
        let s_1304_4: i128 = (i128::try_from(s_1304_3).unwrap());
        // C s_1304_5: const #0s : i
        let s_1304_5: i128 = 0;
        // C s_1304_6: add s_1304_5 s_1304_4
        let s_1304_6: i128 = (s_1304_5 + s_1304_4);
        // D s_1304_7: bit-extract s_1304_2 s_1304_0 s_1304_6
        let s_1304_7: Bits = (Bits::new(
            ((s_1304_2) >> (s_1304_0)).value(),
            u16::try_from(s_1304_6).unwrap(),
        ));
        // D s_1304_8: cast reint s_1304_7 -> u8
        let s_1304_8: bool = ((s_1304_7.value()) != 0);
        // D s_1304_9: cast zx s_1304_8 -> bv
        let s_1304_9: Bits = Bits::new(s_1304_8 as u128, 1u16);
        // C s_1304_10: const #1u : u8
        let s_1304_10: bool = true;
        // C s_1304_11: cast zx s_1304_10 -> bv
        let s_1304_11: Bits = Bits::new(s_1304_10 as u128, 1u16);
        // D s_1304_12: cmp-eq s_1304_9 s_1304_11
        let s_1304_12: bool = ((s_1304_9) == (s_1304_11));
        // D s_1304_13: write-var gs#409977 <= s_1304_12
        fn_state.gs_409977 = s_1304_12;
        // N s_1304_14: jump b1303
        return block_1303(state, tracer, fn_state);
    }
    fn block_1305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1305_0: const #28s : i
        let s_1305_0: i128 = 28;
        // C s_1305_1: const #4s : i
        let s_1305_1: i128 = 4;
        // D s_1305_2: read-var u#33572:u32
        let s_1305_2: u32 = fn_state.u_33572;
        // D s_1305_3: cast zx s_1305_2 -> bv
        let s_1305_3: Bits = Bits::new(s_1305_2 as u128, 32u16);
        // D s_1305_4: bit-extract s_1305_3 s_1305_0 s_1305_1
        let s_1305_4: Bits = (Bits::new(
            ((s_1305_3) >> (s_1305_0)).value(),
            u16::try_from(s_1305_1).unwrap(),
        ));
        // D s_1305_5: cast reint s_1305_4 -> u8
        let s_1305_5: u8 = (s_1305_4.value() as u8);
        // D s_1305_6: cast zx s_1305_5 -> bv
        let s_1305_6: Bits = Bits::new(s_1305_5 as u128, 4u16);
        // C s_1305_7: const #15u : u8
        let s_1305_7: u8 = 15;
        // C s_1305_8: cast zx s_1305_7 -> bv
        let s_1305_8: Bits = Bits::new(s_1305_7 as u128, 4u16);
        // D s_1305_9: cmp-ne s_1305_6 s_1305_8
        let s_1305_9: bool = ((s_1305_6) != (s_1305_8));
        // N s_1305_10: branch s_1305_9 b1308 b1306
        if s_1305_9 {
            return block_1308(state, tracer, fn_state);
        } else {
            return block_1306(state, tracer, fn_state);
        };
    }
    fn block_1306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1306_0: const #0u : u8
        let s_1306_0: bool = false;
        // D s_1306_1: write-var gs#409954 <= s_1306_0
        fn_state.gs_409954 = s_1306_0;
        // N s_1306_2: jump b1307
        return block_1307(state, tracer, fn_state);
    }
    fn block_1307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1307_0: read-var gs#409954:u8
        let s_1307_0: bool = fn_state.gs_409954;
        // D s_1307_1: write-var gs#409955 <= s_1307_0
        fn_state.gs_409955 = s_1307_0;
        // N s_1307_2: jump b434
        return block_434(state, tracer, fn_state);
    }
    fn block_1308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1308_0: const #3154s : i
        let s_1308_0: i128 = 3154;
        // C s_1308_1: const #14696u : u32
        let s_1308_1: u32 = 14696;
        // D s_1308_2: read-reg s_1308_1:i
        let s_1308_2: i128 = {
            let value = state.read_register::<i128>(s_1308_1 as isize);
            tracer.read_register(s_1308_1 as isize, value);
            value
        };
        // D s_1308_3: cmp-lt s_1308_2 s_1308_0
        let s_1308_3: bool = ((s_1308_2) < (s_1308_0));
        // D s_1308_4: write-var gs#409954 <= s_1308_3
        fn_state.gs_409954 = s_1308_3;
        // N s_1308_5: jump b1307
        return block_1307(state, tracer, fn_state);
    }
    fn block_1309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1309_0: const #6s : i
        let s_1309_0: i128 = 6;
        // D s_1309_1: read-var u#33572:u32
        let s_1309_1: u32 = fn_state.u_33572;
        // D s_1309_2: cast zx s_1309_1 -> bv
        let s_1309_2: Bits = Bits::new(s_1309_1 as u128, 32u16);
        // C s_1309_3: const #1s : i64
        let s_1309_3: i64 = 1;
        // C s_1309_4: cast zx s_1309_3 -> i
        let s_1309_4: i128 = (i128::try_from(s_1309_3).unwrap());
        // C s_1309_5: const #1s : i
        let s_1309_5: i128 = 1;
        // C s_1309_6: add s_1309_5 s_1309_4
        let s_1309_6: i128 = (s_1309_5 + s_1309_4);
        // D s_1309_7: bit-extract s_1309_2 s_1309_0 s_1309_6
        let s_1309_7: Bits = (Bits::new(
            ((s_1309_2) >> (s_1309_0)).value(),
            u16::try_from(s_1309_6).unwrap(),
        ));
        // D s_1309_8: cast reint s_1309_7 -> u8
        let s_1309_8: u8 = (s_1309_7.value() as u8);
        // D s_1309_9: cast zx s_1309_8 -> bv
        let s_1309_9: Bits = Bits::new(s_1309_8 as u128, 2u16);
        // C s_1309_10: const #1u : u8
        let s_1309_10: u8 = 1;
        // C s_1309_11: cast zx s_1309_10 -> bv
        let s_1309_11: Bits = Bits::new(s_1309_10 as u128, 2u16);
        // D s_1309_12: cmp-eq s_1309_9 s_1309_11
        let s_1309_12: bool = ((s_1309_9) == (s_1309_11));
        // N s_1309_13: branch s_1309_12 b1312 b1310
        if s_1309_12 {
            return block_1312(state, tracer, fn_state);
        } else {
            return block_1310(state, tracer, fn_state);
        };
    }
    fn block_1310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1310_0: const #0u : u8
        let s_1310_0: bool = false;
        // D s_1310_1: write-var gs#409949 <= s_1310_0
        fn_state.gs_409949 = s_1310_0;
        // N s_1310_2: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_1311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1311_0: read-var gs#409949:u8
        let s_1311_0: bool = fn_state.gs_409949;
        // D s_1311_1: write-var gs#409950 <= s_1311_0
        fn_state.gs_409950 = s_1311_0;
        // N s_1311_2: jump b432
        return block_432(state, tracer, fn_state);
    }
    fn block_1312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1312_0: const #4s : i
        let s_1312_0: i128 = 4;
        // D s_1312_1: read-var u#33572:u32
        let s_1312_1: u32 = fn_state.u_33572;
        // D s_1312_2: cast zx s_1312_1 -> bv
        let s_1312_2: Bits = Bits::new(s_1312_1 as u128, 32u16);
        // C s_1312_3: const #1s : i64
        let s_1312_3: i64 = 1;
        // C s_1312_4: cast zx s_1312_3 -> i
        let s_1312_4: i128 = (i128::try_from(s_1312_3).unwrap());
        // C s_1312_5: const #0s : i
        let s_1312_5: i128 = 0;
        // C s_1312_6: add s_1312_5 s_1312_4
        let s_1312_6: i128 = (s_1312_5 + s_1312_4);
        // D s_1312_7: bit-extract s_1312_2 s_1312_0 s_1312_6
        let s_1312_7: Bits = (Bits::new(
            ((s_1312_2) >> (s_1312_0)).value(),
            u16::try_from(s_1312_6).unwrap(),
        ));
        // D s_1312_8: cast reint s_1312_7 -> u8
        let s_1312_8: bool = ((s_1312_7.value()) != 0);
        // D s_1312_9: cast zx s_1312_8 -> bv
        let s_1312_9: Bits = Bits::new(s_1312_8 as u128, 1u16);
        // C s_1312_10: const #1u : u8
        let s_1312_10: bool = true;
        // C s_1312_11: cast zx s_1312_10 -> bv
        let s_1312_11: Bits = Bits::new(s_1312_10 as u128, 1u16);
        // D s_1312_12: cmp-eq s_1312_9 s_1312_11
        let s_1312_12: bool = ((s_1312_9) == (s_1312_11));
        // D s_1312_13: write-var gs#409949 <= s_1312_12
        fn_state.gs_409949 = s_1312_12;
        // N s_1312_14: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_1313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1313_0: const #28s : i
        let s_1313_0: i128 = 28;
        // C s_1313_1: const #4s : i
        let s_1313_1: i128 = 4;
        // D s_1313_2: read-var u#33566:u32
        let s_1313_2: u32 = fn_state.u_33566;
        // D s_1313_3: cast zx s_1313_2 -> bv
        let s_1313_3: Bits = Bits::new(s_1313_2 as u128, 32u16);
        // D s_1313_4: bit-extract s_1313_3 s_1313_0 s_1313_1
        let s_1313_4: Bits = (Bits::new(
            ((s_1313_3) >> (s_1313_0)).value(),
            u16::try_from(s_1313_1).unwrap(),
        ));
        // D s_1313_5: cast reint s_1313_4 -> u8
        let s_1313_5: u8 = (s_1313_4.value() as u8);
        // D s_1313_6: cast zx s_1313_5 -> bv
        let s_1313_6: Bits = Bits::new(s_1313_5 as u128, 4u16);
        // C s_1313_7: const #15u : u8
        let s_1313_7: u8 = 15;
        // C s_1313_8: cast zx s_1313_7 -> bv
        let s_1313_8: Bits = Bits::new(s_1313_7 as u128, 4u16);
        // D s_1313_9: cmp-ne s_1313_6 s_1313_8
        let s_1313_9: bool = ((s_1313_6) != (s_1313_8));
        // N s_1313_10: branch s_1313_9 b1316 b1314
        if s_1313_9 {
            return block_1316(state, tracer, fn_state);
        } else {
            return block_1314(state, tracer, fn_state);
        };
    }
    fn block_1314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1314_0: const #0u : u8
        let s_1314_0: bool = false;
        // D s_1314_1: write-var gs#409926 <= s_1314_0
        fn_state.gs_409926 = s_1314_0;
        // N s_1314_2: jump b1315
        return block_1315(state, tracer, fn_state);
    }
    fn block_1315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1315_0: read-var gs#409926:u8
        let s_1315_0: bool = fn_state.gs_409926;
        // D s_1315_1: write-var gs#409927 <= s_1315_0
        fn_state.gs_409927 = s_1315_0;
        // N s_1315_2: jump b428
        return block_428(state, tracer, fn_state);
    }
    fn block_1316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1316_0: const #3150s : i
        let s_1316_0: i128 = 3150;
        // C s_1316_1: const #14696u : u32
        let s_1316_1: u32 = 14696;
        // D s_1316_2: read-reg s_1316_1:i
        let s_1316_2: i128 = {
            let value = state.read_register::<i128>(s_1316_1 as isize);
            tracer.read_register(s_1316_1 as isize, value);
            value
        };
        // D s_1316_3: cmp-lt s_1316_2 s_1316_0
        let s_1316_3: bool = ((s_1316_2) < (s_1316_0));
        // D s_1316_4: write-var gs#409926 <= s_1316_3
        fn_state.gs_409926 = s_1316_3;
        // N s_1316_5: jump b1315
        return block_1315(state, tracer, fn_state);
    }
    fn block_1317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1317_0: const #6s : i
        let s_1317_0: i128 = 6;
        // D s_1317_1: read-var u#33566:u32
        let s_1317_1: u32 = fn_state.u_33566;
        // D s_1317_2: cast zx s_1317_1 -> bv
        let s_1317_2: Bits = Bits::new(s_1317_1 as u128, 32u16);
        // C s_1317_3: const #1s : i64
        let s_1317_3: i64 = 1;
        // C s_1317_4: cast zx s_1317_3 -> i
        let s_1317_4: i128 = (i128::try_from(s_1317_3).unwrap());
        // C s_1317_5: const #1s : i
        let s_1317_5: i128 = 1;
        // C s_1317_6: add s_1317_5 s_1317_4
        let s_1317_6: i128 = (s_1317_5 + s_1317_4);
        // D s_1317_7: bit-extract s_1317_2 s_1317_0 s_1317_6
        let s_1317_7: Bits = (Bits::new(
            ((s_1317_2) >> (s_1317_0)).value(),
            u16::try_from(s_1317_6).unwrap(),
        ));
        // D s_1317_8: cast reint s_1317_7 -> u8
        let s_1317_8: u8 = (s_1317_7.value() as u8);
        // D s_1317_9: cast zx s_1317_8 -> bv
        let s_1317_9: Bits = Bits::new(s_1317_8 as u128, 2u16);
        // C s_1317_10: const #0u : u8
        let s_1317_10: u8 = 0;
        // C s_1317_11: cast zx s_1317_10 -> bv
        let s_1317_11: Bits = Bits::new(s_1317_10 as u128, 2u16);
        // D s_1317_12: cmp-eq s_1317_9 s_1317_11
        let s_1317_12: bool = ((s_1317_9) == (s_1317_11));
        // N s_1317_13: branch s_1317_12 b1320 b1318
        if s_1317_12 {
            return block_1320(state, tracer, fn_state);
        } else {
            return block_1318(state, tracer, fn_state);
        };
    }
    fn block_1318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1318_0: const #0u : u8
        let s_1318_0: bool = false;
        // D s_1318_1: write-var gs#409921 <= s_1318_0
        fn_state.gs_409921 = s_1318_0;
        // N s_1318_2: jump b1319
        return block_1319(state, tracer, fn_state);
    }
    fn block_1319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1319_0: read-var gs#409921:u8
        let s_1319_0: bool = fn_state.gs_409921;
        // D s_1319_1: write-var gs#409922 <= s_1319_0
        fn_state.gs_409922 = s_1319_0;
        // N s_1319_2: jump b426
        return block_426(state, tracer, fn_state);
    }
    fn block_1320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1320_0: const #4s : i
        let s_1320_0: i128 = 4;
        // D s_1320_1: read-var u#33566:u32
        let s_1320_1: u32 = fn_state.u_33566;
        // D s_1320_2: cast zx s_1320_1 -> bv
        let s_1320_2: Bits = Bits::new(s_1320_1 as u128, 32u16);
        // C s_1320_3: const #1s : i64
        let s_1320_3: i64 = 1;
        // C s_1320_4: cast zx s_1320_3 -> i
        let s_1320_4: i128 = (i128::try_from(s_1320_3).unwrap());
        // C s_1320_5: const #0s : i
        let s_1320_5: i128 = 0;
        // C s_1320_6: add s_1320_5 s_1320_4
        let s_1320_6: i128 = (s_1320_5 + s_1320_4);
        // D s_1320_7: bit-extract s_1320_2 s_1320_0 s_1320_6
        let s_1320_7: Bits = (Bits::new(
            ((s_1320_2) >> (s_1320_0)).value(),
            u16::try_from(s_1320_6).unwrap(),
        ));
        // D s_1320_8: cast reint s_1320_7 -> u8
        let s_1320_8: bool = ((s_1320_7.value()) != 0);
        // D s_1320_9: cast zx s_1320_8 -> bv
        let s_1320_9: Bits = Bits::new(s_1320_8 as u128, 1u16);
        // C s_1320_10: const #1u : u8
        let s_1320_10: bool = true;
        // C s_1320_11: cast zx s_1320_10 -> bv
        let s_1320_11: Bits = Bits::new(s_1320_10 as u128, 1u16);
        // D s_1320_12: cmp-eq s_1320_9 s_1320_11
        let s_1320_12: bool = ((s_1320_9) == (s_1320_11));
        // D s_1320_13: write-var gs#409921 <= s_1320_12
        fn_state.gs_409921 = s_1320_12;
        // N s_1320_14: jump b1319
        return block_1319(state, tracer, fn_state);
    }
    fn block_1321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1321_0: const #28s : i
        let s_1321_0: i128 = 28;
        // C s_1321_1: const #4s : i
        let s_1321_1: i128 = 4;
        // D s_1321_2: read-var u#33559:u32
        let s_1321_2: u32 = fn_state.u_33559;
        // D s_1321_3: cast zx s_1321_2 -> bv
        let s_1321_3: Bits = Bits::new(s_1321_2 as u128, 32u16);
        // D s_1321_4: bit-extract s_1321_3 s_1321_0 s_1321_1
        let s_1321_4: Bits = (Bits::new(
            ((s_1321_3) >> (s_1321_0)).value(),
            u16::try_from(s_1321_1).unwrap(),
        ));
        // D s_1321_5: cast reint s_1321_4 -> u8
        let s_1321_5: u8 = (s_1321_4.value() as u8);
        // D s_1321_6: cast zx s_1321_5 -> bv
        let s_1321_6: Bits = Bits::new(s_1321_5 as u128, 4u16);
        // C s_1321_7: const #15u : u8
        let s_1321_7: u8 = 15;
        // C s_1321_8: cast zx s_1321_7 -> bv
        let s_1321_8: Bits = Bits::new(s_1321_7 as u128, 4u16);
        // D s_1321_9: cmp-ne s_1321_6 s_1321_8
        let s_1321_9: bool = ((s_1321_6) != (s_1321_8));
        // N s_1321_10: branch s_1321_9 b1324 b1322
        if s_1321_9 {
            return block_1324(state, tracer, fn_state);
        } else {
            return block_1322(state, tracer, fn_state);
        };
    }
    fn block_1322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1322_0: const #0u : u8
        let s_1322_0: bool = false;
        // D s_1322_1: write-var gs#409898 <= s_1322_0
        fn_state.gs_409898 = s_1322_0;
        // N s_1322_2: jump b1323
        return block_1323(state, tracer, fn_state);
    }
    fn block_1323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1323_0: read-var gs#409898:u8
        let s_1323_0: bool = fn_state.gs_409898;
        // D s_1323_1: write-var gs#409899 <= s_1323_0
        fn_state.gs_409899 = s_1323_0;
        // N s_1323_2: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_1324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1324_0: const #3144s : i
        let s_1324_0: i128 = 3144;
        // C s_1324_1: const #14696u : u32
        let s_1324_1: u32 = 14696;
        // D s_1324_2: read-reg s_1324_1:i
        let s_1324_2: i128 = {
            let value = state.read_register::<i128>(s_1324_1 as isize);
            tracer.read_register(s_1324_1 as isize, value);
            value
        };
        // D s_1324_3: cmp-lt s_1324_2 s_1324_0
        let s_1324_3: bool = ((s_1324_2) < (s_1324_0));
        // D s_1324_4: write-var gs#409898 <= s_1324_3
        fn_state.gs_409898 = s_1324_3;
        // N s_1324_5: jump b1323
        return block_1323(state, tracer, fn_state);
    }
    fn block_1325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1325_0: const #6s : i
        let s_1325_0: i128 = 6;
        // D s_1325_1: read-var u#33559:u32
        let s_1325_1: u32 = fn_state.u_33559;
        // D s_1325_2: cast zx s_1325_1 -> bv
        let s_1325_2: Bits = Bits::new(s_1325_1 as u128, 32u16);
        // C s_1325_3: const #1s : i64
        let s_1325_3: i64 = 1;
        // C s_1325_4: cast zx s_1325_3 -> i
        let s_1325_4: i128 = (i128::try_from(s_1325_3).unwrap());
        // C s_1325_5: const #1s : i
        let s_1325_5: i128 = 1;
        // C s_1325_6: add s_1325_5 s_1325_4
        let s_1325_6: i128 = (s_1325_5 + s_1325_4);
        // D s_1325_7: bit-extract s_1325_2 s_1325_0 s_1325_6
        let s_1325_7: Bits = (Bits::new(
            ((s_1325_2) >> (s_1325_0)).value(),
            u16::try_from(s_1325_6).unwrap(),
        ));
        // D s_1325_8: cast reint s_1325_7 -> u8
        let s_1325_8: u8 = (s_1325_7.value() as u8);
        // D s_1325_9: cast zx s_1325_8 -> bv
        let s_1325_9: Bits = Bits::new(s_1325_8 as u128, 2u16);
        // C s_1325_10: const #0u : u8
        let s_1325_10: u8 = 0;
        // C s_1325_11: cast zx s_1325_10 -> bv
        let s_1325_11: Bits = Bits::new(s_1325_10 as u128, 2u16);
        // D s_1325_12: cmp-eq s_1325_9 s_1325_11
        let s_1325_12: bool = ((s_1325_9) == (s_1325_11));
        // N s_1325_13: branch s_1325_12 b1328 b1326
        if s_1325_12 {
            return block_1328(state, tracer, fn_state);
        } else {
            return block_1326(state, tracer, fn_state);
        };
    }
    fn block_1326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1326_0: const #0u : u8
        let s_1326_0: bool = false;
        // D s_1326_1: write-var gs#409893 <= s_1326_0
        fn_state.gs_409893 = s_1326_0;
        // N s_1326_2: jump b1327
        return block_1327(state, tracer, fn_state);
    }
    fn block_1327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1327_0: read-var gs#409893:u8
        let s_1327_0: bool = fn_state.gs_409893;
        // D s_1327_1: write-var gs#409894 <= s_1327_0
        fn_state.gs_409894 = s_1327_0;
        // N s_1327_2: jump b420
        return block_420(state, tracer, fn_state);
    }
    fn block_1328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1328_0: const #4s : i
        let s_1328_0: i128 = 4;
        // D s_1328_1: read-var u#33559:u32
        let s_1328_1: u32 = fn_state.u_33559;
        // D s_1328_2: cast zx s_1328_1 -> bv
        let s_1328_2: Bits = Bits::new(s_1328_1 as u128, 32u16);
        // C s_1328_3: const #1s : i64
        let s_1328_3: i64 = 1;
        // C s_1328_4: cast zx s_1328_3 -> i
        let s_1328_4: i128 = (i128::try_from(s_1328_3).unwrap());
        // C s_1328_5: const #0s : i
        let s_1328_5: i128 = 0;
        // C s_1328_6: add s_1328_5 s_1328_4
        let s_1328_6: i128 = (s_1328_5 + s_1328_4);
        // D s_1328_7: bit-extract s_1328_2 s_1328_0 s_1328_6
        let s_1328_7: Bits = (Bits::new(
            ((s_1328_2) >> (s_1328_0)).value(),
            u16::try_from(s_1328_6).unwrap(),
        ));
        // D s_1328_8: cast reint s_1328_7 -> u8
        let s_1328_8: bool = ((s_1328_7.value()) != 0);
        // D s_1328_9: cast zx s_1328_8 -> bv
        let s_1328_9: Bits = Bits::new(s_1328_8 as u128, 1u16);
        // C s_1328_10: const #1u : u8
        let s_1328_10: bool = true;
        // C s_1328_11: cast zx s_1328_10 -> bv
        let s_1328_11: Bits = Bits::new(s_1328_10 as u128, 1u16);
        // D s_1328_12: cmp-eq s_1328_9 s_1328_11
        let s_1328_12: bool = ((s_1328_9) == (s_1328_11));
        // D s_1328_13: write-var gs#409893 <= s_1328_12
        fn_state.gs_409893 = s_1328_12;
        // N s_1328_14: jump b1327
        return block_1327(state, tracer, fn_state);
    }
    fn block_1329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1329_0: const #28s : i
        let s_1329_0: i128 = 28;
        // C s_1329_1: const #4s : i
        let s_1329_1: i128 = 4;
        // D s_1329_2: read-var u#33553:u32
        let s_1329_2: u32 = fn_state.u_33553;
        // D s_1329_3: cast zx s_1329_2 -> bv
        let s_1329_3: Bits = Bits::new(s_1329_2 as u128, 32u16);
        // D s_1329_4: bit-extract s_1329_3 s_1329_0 s_1329_1
        let s_1329_4: Bits = (Bits::new(
            ((s_1329_3) >> (s_1329_0)).value(),
            u16::try_from(s_1329_1).unwrap(),
        ));
        // D s_1329_5: cast reint s_1329_4 -> u8
        let s_1329_5: u8 = (s_1329_4.value() as u8);
        // D s_1329_6: cast zx s_1329_5 -> bv
        let s_1329_6: Bits = Bits::new(s_1329_5 as u128, 4u16);
        // C s_1329_7: const #15u : u8
        let s_1329_7: u8 = 15;
        // C s_1329_8: cast zx s_1329_7 -> bv
        let s_1329_8: Bits = Bits::new(s_1329_7 as u128, 4u16);
        // D s_1329_9: cmp-ne s_1329_6 s_1329_8
        let s_1329_9: bool = ((s_1329_6) != (s_1329_8));
        // N s_1329_10: branch s_1329_9 b1332 b1330
        if s_1329_9 {
            return block_1332(state, tracer, fn_state);
        } else {
            return block_1330(state, tracer, fn_state);
        };
    }
    fn block_1330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1330_0: const #0u : u8
        let s_1330_0: bool = false;
        // D s_1330_1: write-var gs#409863 <= s_1330_0
        fn_state.gs_409863 = s_1330_0;
        // N s_1330_2: jump b1331
        return block_1331(state, tracer, fn_state);
    }
    fn block_1331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1331_0: read-var gs#409863:u8
        let s_1331_0: bool = fn_state.gs_409863;
        // D s_1331_1: write-var gs#409864 <= s_1331_0
        fn_state.gs_409864 = s_1331_0;
        // N s_1331_2: jump b405
        return block_405(state, tracer, fn_state);
    }
    fn block_1332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1332_0: const #3140s : i
        let s_1332_0: i128 = 3140;
        // C s_1332_1: const #14696u : u32
        let s_1332_1: u32 = 14696;
        // D s_1332_2: read-reg s_1332_1:i
        let s_1332_2: i128 = {
            let value = state.read_register::<i128>(s_1332_1 as isize);
            tracer.read_register(s_1332_1 as isize, value);
            value
        };
        // D s_1332_3: cmp-lt s_1332_2 s_1332_0
        let s_1332_3: bool = ((s_1332_2) < (s_1332_0));
        // D s_1332_4: write-var gs#409863 <= s_1332_3
        fn_state.gs_409863 = s_1332_3;
        // N s_1332_5: jump b1331
        return block_1331(state, tracer, fn_state);
    }
    fn block_1333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1333_0: const #4s : i
        let s_1333_0: i128 = 4;
        // D s_1333_1: read-var u#33553:u32
        let s_1333_1: u32 = fn_state.u_33553;
        // D s_1333_2: cast zx s_1333_1 -> bv
        let s_1333_2: Bits = Bits::new(s_1333_1 as u128, 32u16);
        // C s_1333_3: const #1s : i64
        let s_1333_3: i64 = 1;
        // C s_1333_4: cast zx s_1333_3 -> i
        let s_1333_4: i128 = (i128::try_from(s_1333_3).unwrap());
        // C s_1333_5: const #7s : i
        let s_1333_5: i128 = 7;
        // C s_1333_6: add s_1333_5 s_1333_4
        let s_1333_6: i128 = (s_1333_5 + s_1333_4);
        // D s_1333_7: bit-extract s_1333_2 s_1333_0 s_1333_6
        let s_1333_7: Bits = (Bits::new(
            ((s_1333_2) >> (s_1333_0)).value(),
            u16::try_from(s_1333_6).unwrap(),
        ));
        // D s_1333_8: cast reint s_1333_7 -> u8
        let s_1333_8: u8 = (s_1333_7.value() as u8);
        // D s_1333_9: cast zx s_1333_8 -> bv
        let s_1333_9: Bits = Bits::new(s_1333_8 as u128, 8u16);
        // C s_1333_10: const #255u : u8
        let s_1333_10: u8 = 255;
        // C s_1333_11: cast zx s_1333_10 -> bv
        let s_1333_11: Bits = Bits::new(s_1333_10 as u128, 8u16);
        // D s_1333_12: cmp-eq s_1333_9 s_1333_11
        let s_1333_12: bool = ((s_1333_9) == (s_1333_11));
        // D s_1333_13: write-var gs#409859 <= s_1333_12
        fn_state.gs_409859 = s_1333_12;
        // N s_1333_14: jump b403
        return block_403(state, tracer, fn_state);
    }
    fn block_1334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1334_0: const #28s : i
        let s_1334_0: i128 = 28;
        // C s_1334_1: const #4s : i
        let s_1334_1: i128 = 4;
        // D s_1334_2: read-var u#33547:u32
        let s_1334_2: u32 = fn_state.u_33547;
        // D s_1334_3: cast zx s_1334_2 -> bv
        let s_1334_3: Bits = Bits::new(s_1334_2 as u128, 32u16);
        // D s_1334_4: bit-extract s_1334_3 s_1334_0 s_1334_1
        let s_1334_4: Bits = (Bits::new(
            ((s_1334_3) >> (s_1334_0)).value(),
            u16::try_from(s_1334_1).unwrap(),
        ));
        // D s_1334_5: cast reint s_1334_4 -> u8
        let s_1334_5: u8 = (s_1334_4.value() as u8);
        // D s_1334_6: cast zx s_1334_5 -> bv
        let s_1334_6: Bits = Bits::new(s_1334_5 as u128, 4u16);
        // C s_1334_7: const #15u : u8
        let s_1334_7: u8 = 15;
        // C s_1334_8: cast zx s_1334_7 -> bv
        let s_1334_8: Bits = Bits::new(s_1334_7 as u128, 4u16);
        // D s_1334_9: cmp-ne s_1334_6 s_1334_8
        let s_1334_9: bool = ((s_1334_6) != (s_1334_8));
        // N s_1334_10: branch s_1334_9 b1337 b1335
        if s_1334_9 {
            return block_1337(state, tracer, fn_state);
        } else {
            return block_1335(state, tracer, fn_state);
        };
    }
    fn block_1335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1335_0: const #0u : u8
        let s_1335_0: bool = false;
        // D s_1335_1: write-var gs#409831 <= s_1335_0
        fn_state.gs_409831 = s_1335_0;
        // N s_1335_2: jump b1336
        return block_1336(state, tracer, fn_state);
    }
    fn block_1336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1336_0: read-var gs#409831:u8
        let s_1336_0: bool = fn_state.gs_409831;
        // D s_1336_1: write-var gs#409832 <= s_1336_0
        fn_state.gs_409832 = s_1336_0;
        // N s_1336_2: jump b388
        return block_388(state, tracer, fn_state);
    }
    fn block_1337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1337_0: const #3138s : i
        let s_1337_0: i128 = 3138;
        // C s_1337_1: const #14696u : u32
        let s_1337_1: u32 = 14696;
        // D s_1337_2: read-reg s_1337_1:i
        let s_1337_2: i128 = {
            let value = state.read_register::<i128>(s_1337_1 as isize);
            tracer.read_register(s_1337_1 as isize, value);
            value
        };
        // D s_1337_3: cmp-lt s_1337_2 s_1337_0
        let s_1337_3: bool = ((s_1337_2) < (s_1337_0));
        // D s_1337_4: write-var gs#409831 <= s_1337_3
        fn_state.gs_409831 = s_1337_3;
        // N s_1337_5: jump b1336
        return block_1336(state, tracer, fn_state);
    }
    fn block_1338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1338_0: const #4s : i
        let s_1338_0: i128 = 4;
        // D s_1338_1: read-var u#33547:u32
        let s_1338_1: u32 = fn_state.u_33547;
        // D s_1338_2: cast zx s_1338_1 -> bv
        let s_1338_2: Bits = Bits::new(s_1338_1 as u128, 32u16);
        // C s_1338_3: const #1s : i64
        let s_1338_3: i64 = 1;
        // C s_1338_4: cast zx s_1338_3 -> i
        let s_1338_4: i128 = (i128::try_from(s_1338_3).unwrap());
        // C s_1338_5: const #7s : i
        let s_1338_5: i128 = 7;
        // C s_1338_6: add s_1338_5 s_1338_4
        let s_1338_6: i128 = (s_1338_5 + s_1338_4);
        // D s_1338_7: bit-extract s_1338_2 s_1338_0 s_1338_6
        let s_1338_7: Bits = (Bits::new(
            ((s_1338_2) >> (s_1338_0)).value(),
            u16::try_from(s_1338_6).unwrap(),
        ));
        // D s_1338_8: cast reint s_1338_7 -> u8
        let s_1338_8: u8 = (s_1338_7.value() as u8);
        // D s_1338_9: cast zx s_1338_8 -> bv
        let s_1338_9: Bits = Bits::new(s_1338_8 as u128, 8u16);
        // C s_1338_10: const #247u : u8
        let s_1338_10: u8 = 247;
        // C s_1338_11: cast zx s_1338_10 -> bv
        let s_1338_11: Bits = Bits::new(s_1338_10 as u128, 8u16);
        // D s_1338_12: cmp-eq s_1338_9 s_1338_11
        let s_1338_12: bool = ((s_1338_9) == (s_1338_11));
        // D s_1338_13: write-var gs#409827 <= s_1338_12
        fn_state.gs_409827 = s_1338_12;
        // N s_1338_14: jump b386
        return block_386(state, tracer, fn_state);
    }
    fn block_1339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1339_0: const #28s : i
        let s_1339_0: i128 = 28;
        // C s_1339_1: const #4s : i
        let s_1339_1: i128 = 4;
        // D s_1339_2: read-var u#33541:u32
        let s_1339_2: u32 = fn_state.u_33541;
        // D s_1339_3: cast zx s_1339_2 -> bv
        let s_1339_3: Bits = Bits::new(s_1339_2 as u128, 32u16);
        // D s_1339_4: bit-extract s_1339_3 s_1339_0 s_1339_1
        let s_1339_4: Bits = (Bits::new(
            ((s_1339_3) >> (s_1339_0)).value(),
            u16::try_from(s_1339_1).unwrap(),
        ));
        // D s_1339_5: cast reint s_1339_4 -> u8
        let s_1339_5: u8 = (s_1339_4.value() as u8);
        // D s_1339_6: cast zx s_1339_5 -> bv
        let s_1339_6: Bits = Bits::new(s_1339_5 as u128, 4u16);
        // C s_1339_7: const #15u : u8
        let s_1339_7: u8 = 15;
        // C s_1339_8: cast zx s_1339_7 -> bv
        let s_1339_8: Bits = Bits::new(s_1339_7 as u128, 4u16);
        // D s_1339_9: cmp-ne s_1339_6 s_1339_8
        let s_1339_9: bool = ((s_1339_6) != (s_1339_8));
        // N s_1339_10: branch s_1339_9 b1342 b1340
        if s_1339_9 {
            return block_1342(state, tracer, fn_state);
        } else {
            return block_1340(state, tracer, fn_state);
        };
    }
    fn block_1340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1340_0: const #0u : u8
        let s_1340_0: bool = false;
        // D s_1340_1: write-var gs#409799 <= s_1340_0
        fn_state.gs_409799 = s_1340_0;
        // N s_1340_2: jump b1341
        return block_1341(state, tracer, fn_state);
    }
    fn block_1341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1341_0: read-var gs#409799:u8
        let s_1341_0: bool = fn_state.gs_409799;
        // D s_1341_1: write-var gs#409800 <= s_1341_0
        fn_state.gs_409800 = s_1341_0;
        // N s_1341_2: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_1342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1342_0: const #3136s : i
        let s_1342_0: i128 = 3136;
        // C s_1342_1: const #14696u : u32
        let s_1342_1: u32 = 14696;
        // D s_1342_2: read-reg s_1342_1:i
        let s_1342_2: i128 = {
            let value = state.read_register::<i128>(s_1342_1 as isize);
            tracer.read_register(s_1342_1 as isize, value);
            value
        };
        // D s_1342_3: cmp-lt s_1342_2 s_1342_0
        let s_1342_3: bool = ((s_1342_2) < (s_1342_0));
        // D s_1342_4: write-var gs#409799 <= s_1342_3
        fn_state.gs_409799 = s_1342_3;
        // N s_1342_5: jump b1341
        return block_1341(state, tracer, fn_state);
    }
    fn block_1343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1343_0: const #4s : i
        let s_1343_0: i128 = 4;
        // D s_1343_1: read-var u#33541:u32
        let s_1343_1: u32 = fn_state.u_33541;
        // D s_1343_2: cast zx s_1343_1 -> bv
        let s_1343_2: Bits = Bits::new(s_1343_1 as u128, 32u16);
        // C s_1343_3: const #1s : i64
        let s_1343_3: i64 = 1;
        // C s_1343_4: cast zx s_1343_3 -> i
        let s_1343_4: i128 = (i128::try_from(s_1343_3).unwrap());
        // C s_1343_5: const #7s : i
        let s_1343_5: i128 = 7;
        // C s_1343_6: add s_1343_5 s_1343_4
        let s_1343_6: i128 = (s_1343_5 + s_1343_4);
        // D s_1343_7: bit-extract s_1343_2 s_1343_0 s_1343_6
        let s_1343_7: Bits = (Bits::new(
            ((s_1343_2) >> (s_1343_0)).value(),
            u16::try_from(s_1343_6).unwrap(),
        ));
        // D s_1343_8: cast reint s_1343_7 -> u8
        let s_1343_8: u8 = (s_1343_7.value() as u8);
        // D s_1343_9: cast zx s_1343_8 -> bv
        let s_1343_9: Bits = Bits::new(s_1343_8 as u128, 8u16);
        // C s_1343_10: const #245u : u8
        let s_1343_10: u8 = 245;
        // C s_1343_11: cast zx s_1343_10 -> bv
        let s_1343_11: Bits = Bits::new(s_1343_10 as u128, 8u16);
        // D s_1343_12: cmp-eq s_1343_9 s_1343_11
        let s_1343_12: bool = ((s_1343_9) == (s_1343_11));
        // D s_1343_13: write-var gs#409795 <= s_1343_12
        fn_state.gs_409795 = s_1343_12;
        // N s_1343_14: jump b369
        return block_369(state, tracer, fn_state);
    }
    fn block_1344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1344_0: const #28s : i
        let s_1344_0: i128 = 28;
        // C s_1344_1: const #4s : i
        let s_1344_1: i128 = 4;
        // D s_1344_2: read-var u#33535:u32
        let s_1344_2: u32 = fn_state.u_33535;
        // D s_1344_3: cast zx s_1344_2 -> bv
        let s_1344_3: Bits = Bits::new(s_1344_2 as u128, 32u16);
        // D s_1344_4: bit-extract s_1344_3 s_1344_0 s_1344_1
        let s_1344_4: Bits = (Bits::new(
            ((s_1344_3) >> (s_1344_0)).value(),
            u16::try_from(s_1344_1).unwrap(),
        ));
        // D s_1344_5: cast reint s_1344_4 -> u8
        let s_1344_5: u8 = (s_1344_4.value() as u8);
        // D s_1344_6: cast zx s_1344_5 -> bv
        let s_1344_6: Bits = Bits::new(s_1344_5 as u128, 4u16);
        // C s_1344_7: const #15u : u8
        let s_1344_7: u8 = 15;
        // C s_1344_8: cast zx s_1344_7 -> bv
        let s_1344_8: Bits = Bits::new(s_1344_7 as u128, 4u16);
        // D s_1344_9: cmp-ne s_1344_6 s_1344_8
        let s_1344_9: bool = ((s_1344_6) != (s_1344_8));
        // N s_1344_10: branch s_1344_9 b1347 b1345
        if s_1344_9 {
            return block_1347(state, tracer, fn_state);
        } else {
            return block_1345(state, tracer, fn_state);
        };
    }
    fn block_1345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1345_0: const #0u : u8
        let s_1345_0: bool = false;
        // D s_1345_1: write-var gs#409767 <= s_1345_0
        fn_state.gs_409767 = s_1345_0;
        // N s_1345_2: jump b1346
        return block_1346(state, tracer, fn_state);
    }
    fn block_1346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1346_0: read-var gs#409767:u8
        let s_1346_0: bool = fn_state.gs_409767;
        // D s_1346_1: write-var gs#409768 <= s_1346_0
        fn_state.gs_409768 = s_1346_0;
        // N s_1346_2: jump b354
        return block_354(state, tracer, fn_state);
    }
    fn block_1347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1347_0: const #3134s : i
        let s_1347_0: i128 = 3134;
        // C s_1347_1: const #14696u : u32
        let s_1347_1: u32 = 14696;
        // D s_1347_2: read-reg s_1347_1:i
        let s_1347_2: i128 = {
            let value = state.read_register::<i128>(s_1347_1 as isize);
            tracer.read_register(s_1347_1 as isize, value);
            value
        };
        // D s_1347_3: cmp-lt s_1347_2 s_1347_0
        let s_1347_3: bool = ((s_1347_2) < (s_1347_0));
        // D s_1347_4: write-var gs#409767 <= s_1347_3
        fn_state.gs_409767 = s_1347_3;
        // N s_1347_5: jump b1346
        return block_1346(state, tracer, fn_state);
    }
    fn block_1348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1348_0: const #4s : i
        let s_1348_0: i128 = 4;
        // D s_1348_1: read-var u#33535:u32
        let s_1348_1: u32 = fn_state.u_33535;
        // D s_1348_2: cast zx s_1348_1 -> bv
        let s_1348_2: Bits = Bits::new(s_1348_1 as u128, 32u16);
        // C s_1348_3: const #1s : i64
        let s_1348_3: i64 = 1;
        // C s_1348_4: cast zx s_1348_3 -> i
        let s_1348_4: i128 = (i128::try_from(s_1348_3).unwrap());
        // C s_1348_5: const #7s : i
        let s_1348_5: i128 = 7;
        // C s_1348_6: add s_1348_5 s_1348_4
        let s_1348_6: i128 = (s_1348_5 + s_1348_4);
        // D s_1348_7: bit-extract s_1348_2 s_1348_0 s_1348_6
        let s_1348_7: Bits = (Bits::new(
            ((s_1348_2) >> (s_1348_0)).value(),
            u16::try_from(s_1348_6).unwrap(),
        ));
        // D s_1348_8: cast reint s_1348_7 -> u8
        let s_1348_8: u8 = (s_1348_7.value() as u8);
        // D s_1348_9: cast zx s_1348_8 -> bv
        let s_1348_9: Bits = Bits::new(s_1348_8 as u128, 8u16);
        // C s_1348_10: const #243u : u8
        let s_1348_10: u8 = 243;
        // C s_1348_11: cast zx s_1348_10 -> bv
        let s_1348_11: Bits = Bits::new(s_1348_10 as u128, 8u16);
        // D s_1348_12: cmp-eq s_1348_9 s_1348_11
        let s_1348_12: bool = ((s_1348_9) == (s_1348_11));
        // D s_1348_13: write-var gs#409763 <= s_1348_12
        fn_state.gs_409763 = s_1348_12;
        // N s_1348_14: jump b352
        return block_352(state, tracer, fn_state);
    }
    fn block_1349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1349_0: const #28s : i
        let s_1349_0: i128 = 28;
        // C s_1349_1: const #4s : i
        let s_1349_1: i128 = 4;
        // D s_1349_2: read-var u#33529:u32
        let s_1349_2: u32 = fn_state.u_33529;
        // D s_1349_3: cast zx s_1349_2 -> bv
        let s_1349_3: Bits = Bits::new(s_1349_2 as u128, 32u16);
        // D s_1349_4: bit-extract s_1349_3 s_1349_0 s_1349_1
        let s_1349_4: Bits = (Bits::new(
            ((s_1349_3) >> (s_1349_0)).value(),
            u16::try_from(s_1349_1).unwrap(),
        ));
        // D s_1349_5: cast reint s_1349_4 -> u8
        let s_1349_5: u8 = (s_1349_4.value() as u8);
        // D s_1349_6: cast zx s_1349_5 -> bv
        let s_1349_6: Bits = Bits::new(s_1349_5 as u128, 4u16);
        // C s_1349_7: const #15u : u8
        let s_1349_7: u8 = 15;
        // C s_1349_8: cast zx s_1349_7 -> bv
        let s_1349_8: Bits = Bits::new(s_1349_7 as u128, 4u16);
        // D s_1349_9: cmp-ne s_1349_6 s_1349_8
        let s_1349_9: bool = ((s_1349_6) != (s_1349_8));
        // N s_1349_10: branch s_1349_9 b1352 b1350
        if s_1349_9 {
            return block_1352(state, tracer, fn_state);
        } else {
            return block_1350(state, tracer, fn_state);
        };
    }
    fn block_1350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1350_0: const #0u : u8
        let s_1350_0: bool = false;
        // D s_1350_1: write-var gs#409735 <= s_1350_0
        fn_state.gs_409735 = s_1350_0;
        // N s_1350_2: jump b1351
        return block_1351(state, tracer, fn_state);
    }
    fn block_1351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1351_0: read-var gs#409735:u8
        let s_1351_0: bool = fn_state.gs_409735;
        // D s_1351_1: write-var gs#409736 <= s_1351_0
        fn_state.gs_409736 = s_1351_0;
        // N s_1351_2: jump b337
        return block_337(state, tracer, fn_state);
    }
    fn block_1352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1352_0: const #3132s : i
        let s_1352_0: i128 = 3132;
        // C s_1352_1: const #14696u : u32
        let s_1352_1: u32 = 14696;
        // D s_1352_2: read-reg s_1352_1:i
        let s_1352_2: i128 = {
            let value = state.read_register::<i128>(s_1352_1 as isize);
            tracer.read_register(s_1352_1 as isize, value);
            value
        };
        // D s_1352_3: cmp-lt s_1352_2 s_1352_0
        let s_1352_3: bool = ((s_1352_2) < (s_1352_0));
        // D s_1352_4: write-var gs#409735 <= s_1352_3
        fn_state.gs_409735 = s_1352_3;
        // N s_1352_5: jump b1351
        return block_1351(state, tracer, fn_state);
    }
    fn block_1353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1353_0: const #4s : i
        let s_1353_0: i128 = 4;
        // D s_1353_1: read-var u#33529:u32
        let s_1353_1: u32 = fn_state.u_33529;
        // D s_1353_2: cast zx s_1353_1 -> bv
        let s_1353_2: Bits = Bits::new(s_1353_1 as u128, 32u16);
        // C s_1353_3: const #1s : i64
        let s_1353_3: i64 = 1;
        // C s_1353_4: cast zx s_1353_3 -> i
        let s_1353_4: i128 = (i128::try_from(s_1353_3).unwrap());
        // C s_1353_5: const #7s : i
        let s_1353_5: i128 = 7;
        // C s_1353_6: add s_1353_5 s_1353_4
        let s_1353_6: i128 = (s_1353_5 + s_1353_4);
        // D s_1353_7: bit-extract s_1353_2 s_1353_0 s_1353_6
        let s_1353_7: Bits = (Bits::new(
            ((s_1353_2) >> (s_1353_0)).value(),
            u16::try_from(s_1353_6).unwrap(),
        ));
        // D s_1353_8: cast reint s_1353_7 -> u8
        let s_1353_8: u8 = (s_1353_7.value() as u8);
        // D s_1353_9: cast zx s_1353_8 -> bv
        let s_1353_9: Bits = Bits::new(s_1353_8 as u128, 8u16);
        // C s_1353_10: const #249u : u8
        let s_1353_10: u8 = 249;
        // C s_1353_11: cast zx s_1353_10 -> bv
        let s_1353_11: Bits = Bits::new(s_1353_10 as u128, 8u16);
        // D s_1353_12: cmp-eq s_1353_9 s_1353_11
        let s_1353_12: bool = ((s_1353_9) == (s_1353_11));
        // D s_1353_13: write-var gs#409731 <= s_1353_12
        fn_state.gs_409731 = s_1353_12;
        // N s_1353_14: jump b335
        return block_335(state, tracer, fn_state);
    }
    fn block_1354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1354_0: const #28s : i
        let s_1354_0: i128 = 28;
        // C s_1354_1: const #4s : i
        let s_1354_1: i128 = 4;
        // D s_1354_2: read-var u#33523:u32
        let s_1354_2: u32 = fn_state.u_33523;
        // D s_1354_3: cast zx s_1354_2 -> bv
        let s_1354_3: Bits = Bits::new(s_1354_2 as u128, 32u16);
        // D s_1354_4: bit-extract s_1354_3 s_1354_0 s_1354_1
        let s_1354_4: Bits = (Bits::new(
            ((s_1354_3) >> (s_1354_0)).value(),
            u16::try_from(s_1354_1).unwrap(),
        ));
        // D s_1354_5: cast reint s_1354_4 -> u8
        let s_1354_5: u8 = (s_1354_4.value() as u8);
        // D s_1354_6: cast zx s_1354_5 -> bv
        let s_1354_6: Bits = Bits::new(s_1354_5 as u128, 4u16);
        // C s_1354_7: const #15u : u8
        let s_1354_7: u8 = 15;
        // C s_1354_8: cast zx s_1354_7 -> bv
        let s_1354_8: Bits = Bits::new(s_1354_7 as u128, 4u16);
        // D s_1354_9: cmp-ne s_1354_6 s_1354_8
        let s_1354_9: bool = ((s_1354_6) != (s_1354_8));
        // N s_1354_10: branch s_1354_9 b1357 b1355
        if s_1354_9 {
            return block_1357(state, tracer, fn_state);
        } else {
            return block_1355(state, tracer, fn_state);
        };
    }
    fn block_1355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1355_0: const #0u : u8
        let s_1355_0: bool = false;
        // D s_1355_1: write-var gs#409703 <= s_1355_0
        fn_state.gs_409703 = s_1355_0;
        // N s_1355_2: jump b1356
        return block_1356(state, tracer, fn_state);
    }
    fn block_1356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1356_0: read-var gs#409703:u8
        let s_1356_0: bool = fn_state.gs_409703;
        // D s_1356_1: write-var gs#409704 <= s_1356_0
        fn_state.gs_409704 = s_1356_0;
        // N s_1356_2: jump b320
        return block_320(state, tracer, fn_state);
    }
    fn block_1357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1357_0: const #3130s : i
        let s_1357_0: i128 = 3130;
        // C s_1357_1: const #14696u : u32
        let s_1357_1: u32 = 14696;
        // D s_1357_2: read-reg s_1357_1:i
        let s_1357_2: i128 = {
            let value = state.read_register::<i128>(s_1357_1 as isize);
            tracer.read_register(s_1357_1 as isize, value);
            value
        };
        // D s_1357_3: cmp-lt s_1357_2 s_1357_0
        let s_1357_3: bool = ((s_1357_2) < (s_1357_0));
        // D s_1357_4: write-var gs#409703 <= s_1357_3
        fn_state.gs_409703 = s_1357_3;
        // N s_1357_5: jump b1356
        return block_1356(state, tracer, fn_state);
    }
    fn block_1358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1358_0: const #4s : i
        let s_1358_0: i128 = 4;
        // D s_1358_1: read-var u#33523:u32
        let s_1358_1: u32 = fn_state.u_33523;
        // D s_1358_2: cast zx s_1358_1 -> bv
        let s_1358_2: Bits = Bits::new(s_1358_1 as u128, 32u16);
        // C s_1358_3: const #1s : i64
        let s_1358_3: i64 = 1;
        // C s_1358_4: cast zx s_1358_3 -> i
        let s_1358_4: i128 = (i128::try_from(s_1358_3).unwrap());
        // C s_1358_5: const #7s : i
        let s_1358_5: i128 = 7;
        // C s_1358_6: add s_1358_5 s_1358_4
        let s_1358_6: i128 = (s_1358_5 + s_1358_4);
        // D s_1358_7: bit-extract s_1358_2 s_1358_0 s_1358_6
        let s_1358_7: Bits = (Bits::new(
            ((s_1358_2) >> (s_1358_0)).value(),
            u16::try_from(s_1358_6).unwrap(),
        ));
        // D s_1358_8: cast reint s_1358_7 -> u8
        let s_1358_8: u8 = (s_1358_7.value() as u8);
        // D s_1358_9: cast zx s_1358_8 -> bv
        let s_1358_9: Bits = Bits::new(s_1358_8 as u128, 8u16);
        // C s_1358_10: const #241u : u8
        let s_1358_10: u8 = 241;
        // C s_1358_11: cast zx s_1358_10 -> bv
        let s_1358_11: Bits = Bits::new(s_1358_10 as u128, 8u16);
        // D s_1358_12: cmp-eq s_1358_9 s_1358_11
        let s_1358_12: bool = ((s_1358_9) == (s_1358_11));
        // D s_1358_13: write-var gs#409699 <= s_1358_12
        fn_state.gs_409699 = s_1358_12;
        // N s_1358_14: jump b318
        return block_318(state, tracer, fn_state);
    }
    fn block_1359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1359_0: const #28s : i
        let s_1359_0: i128 = 28;
        // C s_1359_1: const #4s : i
        let s_1359_1: i128 = 4;
        // D s_1359_2: read-var u#33517:u32
        let s_1359_2: u32 = fn_state.u_33517;
        // D s_1359_3: cast zx s_1359_2 -> bv
        let s_1359_3: Bits = Bits::new(s_1359_2 as u128, 32u16);
        // D s_1359_4: bit-extract s_1359_3 s_1359_0 s_1359_1
        let s_1359_4: Bits = (Bits::new(
            ((s_1359_3) >> (s_1359_0)).value(),
            u16::try_from(s_1359_1).unwrap(),
        ));
        // D s_1359_5: cast reint s_1359_4 -> u8
        let s_1359_5: u8 = (s_1359_4.value() as u8);
        // D s_1359_6: cast zx s_1359_5 -> bv
        let s_1359_6: Bits = Bits::new(s_1359_5 as u128, 4u16);
        // C s_1359_7: const #15u : u8
        let s_1359_7: u8 = 15;
        // C s_1359_8: cast zx s_1359_7 -> bv
        let s_1359_8: Bits = Bits::new(s_1359_7 as u128, 4u16);
        // D s_1359_9: cmp-ne s_1359_6 s_1359_8
        let s_1359_9: bool = ((s_1359_6) != (s_1359_8));
        // N s_1359_10: branch s_1359_9 b1362 b1360
        if s_1359_9 {
            return block_1362(state, tracer, fn_state);
        } else {
            return block_1360(state, tracer, fn_state);
        };
    }
    fn block_1360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1360_0: const #0u : u8
        let s_1360_0: bool = false;
        // D s_1360_1: write-var gs#409671 <= s_1360_0
        fn_state.gs_409671 = s_1360_0;
        // N s_1360_2: jump b1361
        return block_1361(state, tracer, fn_state);
    }
    fn block_1361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1361_0: read-var gs#409671:u8
        let s_1361_0: bool = fn_state.gs_409671;
        // D s_1361_1: write-var gs#409672 <= s_1361_0
        fn_state.gs_409672 = s_1361_0;
        // N s_1361_2: jump b303
        return block_303(state, tracer, fn_state);
    }
    fn block_1362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1362_0: const #3123s : i
        let s_1362_0: i128 = 3123;
        // C s_1362_1: const #14696u : u32
        let s_1362_1: u32 = 14696;
        // D s_1362_2: read-reg s_1362_1:i
        let s_1362_2: i128 = {
            let value = state.read_register::<i128>(s_1362_1 as isize);
            tracer.read_register(s_1362_1 as isize, value);
            value
        };
        // D s_1362_3: cmp-lt s_1362_2 s_1362_0
        let s_1362_3: bool = ((s_1362_2) < (s_1362_0));
        // D s_1362_4: write-var gs#409671 <= s_1362_3
        fn_state.gs_409671 = s_1362_3;
        // N s_1362_5: jump b1361
        return block_1361(state, tracer, fn_state);
    }
    fn block_1363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1363_0: const #4s : i
        let s_1363_0: i128 = 4;
        // D s_1363_1: read-var u#33517:u32
        let s_1363_1: u32 = fn_state.u_33517;
        // D s_1363_2: cast zx s_1363_1 -> bv
        let s_1363_2: Bits = Bits::new(s_1363_1 as u128, 32u16);
        // C s_1363_3: const #1s : i64
        let s_1363_3: i64 = 1;
        // C s_1363_4: cast zx s_1363_3 -> i
        let s_1363_4: i128 = (i128::try_from(s_1363_3).unwrap());
        // C s_1363_5: const #7s : i
        let s_1363_5: i128 = 7;
        // C s_1363_6: add s_1363_5 s_1363_4
        let s_1363_6: i128 = (s_1363_5 + s_1363_4);
        // D s_1363_7: bit-extract s_1363_2 s_1363_0 s_1363_6
        let s_1363_7: Bits = (Bits::new(
            ((s_1363_2) >> (s_1363_0)).value(),
            u16::try_from(s_1363_6).unwrap(),
        ));
        // D s_1363_8: cast reint s_1363_7 -> u8
        let s_1363_8: u8 = (s_1363_7.value() as u8);
        // D s_1363_9: cast zx s_1363_8 -> bv
        let s_1363_9: Bits = Bits::new(s_1363_8 as u128, 8u16);
        // C s_1363_10: const #251u : u8
        let s_1363_10: u8 = 251;
        // C s_1363_11: cast zx s_1363_10 -> bv
        let s_1363_11: Bits = Bits::new(s_1363_10 as u128, 8u16);
        // D s_1363_12: cmp-eq s_1363_9 s_1363_11
        let s_1363_12: bool = ((s_1363_9) == (s_1363_11));
        // D s_1363_13: write-var gs#409667 <= s_1363_12
        fn_state.gs_409667 = s_1363_12;
        // N s_1363_14: jump b301
        return block_301(state, tracer, fn_state);
    }
    fn block_1364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1364_0: const #28s : i
        let s_1364_0: i128 = 28;
        // C s_1364_1: const #4s : i
        let s_1364_1: i128 = 4;
        // D s_1364_2: read-var u#33511:u32
        let s_1364_2: u32 = fn_state.u_33511;
        // D s_1364_3: cast zx s_1364_2 -> bv
        let s_1364_3: Bits = Bits::new(s_1364_2 as u128, 32u16);
        // D s_1364_4: bit-extract s_1364_3 s_1364_0 s_1364_1
        let s_1364_4: Bits = (Bits::new(
            ((s_1364_3) >> (s_1364_0)).value(),
            u16::try_from(s_1364_1).unwrap(),
        ));
        // D s_1364_5: cast reint s_1364_4 -> u8
        let s_1364_5: u8 = (s_1364_4.value() as u8);
        // D s_1364_6: cast zx s_1364_5 -> bv
        let s_1364_6: Bits = Bits::new(s_1364_5 as u128, 4u16);
        // C s_1364_7: const #15u : u8
        let s_1364_7: u8 = 15;
        // C s_1364_8: cast zx s_1364_7 -> bv
        let s_1364_8: Bits = Bits::new(s_1364_7 as u128, 4u16);
        // D s_1364_9: cmp-ne s_1364_6 s_1364_8
        let s_1364_9: bool = ((s_1364_6) != (s_1364_8));
        // N s_1364_10: branch s_1364_9 b1367 b1365
        if s_1364_9 {
            return block_1367(state, tracer, fn_state);
        } else {
            return block_1365(state, tracer, fn_state);
        };
    }
    fn block_1365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1365_0: const #0u : u8
        let s_1365_0: bool = false;
        // D s_1365_1: write-var gs#409648 <= s_1365_0
        fn_state.gs_409648 = s_1365_0;
        // N s_1365_2: jump b1366
        return block_1366(state, tracer, fn_state);
    }
    fn block_1366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1366_0: read-var gs#409648:u8
        let s_1366_0: bool = fn_state.gs_409648;
        // D s_1366_1: write-var gs#409649 <= s_1366_0
        fn_state.gs_409649 = s_1366_0;
        // N s_1366_2: jump b297
        return block_297(state, tracer, fn_state);
    }
    fn block_1367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1367_0: const #3121s : i
        let s_1367_0: i128 = 3121;
        // C s_1367_1: const #14696u : u32
        let s_1367_1: u32 = 14696;
        // D s_1367_2: read-reg s_1367_1:i
        let s_1367_2: i128 = {
            let value = state.read_register::<i128>(s_1367_1 as isize);
            tracer.read_register(s_1367_1 as isize, value);
            value
        };
        // D s_1367_3: cmp-lt s_1367_2 s_1367_0
        let s_1367_3: bool = ((s_1367_2) < (s_1367_0));
        // D s_1367_4: write-var gs#409648 <= s_1367_3
        fn_state.gs_409648 = s_1367_3;
        // N s_1367_5: jump b1366
        return block_1366(state, tracer, fn_state);
    }
    fn block_1368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1368_0: const #4s : i
        let s_1368_0: i128 = 4;
        // D s_1368_1: read-var u#33511:u32
        let s_1368_1: u32 = fn_state.u_33511;
        // D s_1368_2: cast zx s_1368_1 -> bv
        let s_1368_2: Bits = Bits::new(s_1368_1 as u128, 32u16);
        // C s_1368_3: const #1s : i64
        let s_1368_3: i64 = 1;
        // C s_1368_4: cast zx s_1368_3 -> i
        let s_1368_4: i128 = (i128::try_from(s_1368_3).unwrap());
        // C s_1368_5: const #3s : i
        let s_1368_5: i128 = 3;
        // C s_1368_6: add s_1368_5 s_1368_4
        let s_1368_6: i128 = (s_1368_5 + s_1368_4);
        // D s_1368_7: bit-extract s_1368_2 s_1368_0 s_1368_6
        let s_1368_7: Bits = (Bits::new(
            ((s_1368_2) >> (s_1368_0)).value(),
            u16::try_from(s_1368_6).unwrap(),
        ));
        // D s_1368_8: cast reint s_1368_7 -> u8
        let s_1368_8: u8 = (s_1368_7.value() as u8);
        // D s_1368_9: cast zx s_1368_8 -> bv
        let s_1368_9: Bits = Bits::new(s_1368_8 as u128, 4u16);
        // C s_1368_10: const #1u : u8
        let s_1368_10: u8 = 1;
        // C s_1368_11: cast zx s_1368_10 -> bv
        let s_1368_11: Bits = Bits::new(s_1368_10 as u128, 4u16);
        // D s_1368_12: cmp-eq s_1368_9 s_1368_11
        let s_1368_12: bool = ((s_1368_9) == (s_1368_11));
        // D s_1368_13: write-var gs#409644 <= s_1368_12
        fn_state.gs_409644 = s_1368_12;
        // N s_1368_14: jump b295
        return block_295(state, tracer, fn_state);
    }
    fn block_1369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1369_0: const #28s : i
        let s_1369_0: i128 = 28;
        // C s_1369_1: const #4s : i
        let s_1369_1: i128 = 4;
        // D s_1369_2: read-var u#33505:u32
        let s_1369_2: u32 = fn_state.u_33505;
        // D s_1369_3: cast zx s_1369_2 -> bv
        let s_1369_3: Bits = Bits::new(s_1369_2 as u128, 32u16);
        // D s_1369_4: bit-extract s_1369_3 s_1369_0 s_1369_1
        let s_1369_4: Bits = (Bits::new(
            ((s_1369_3) >> (s_1369_0)).value(),
            u16::try_from(s_1369_1).unwrap(),
        ));
        // D s_1369_5: cast reint s_1369_4 -> u8
        let s_1369_5: u8 = (s_1369_4.value() as u8);
        // D s_1369_6: cast zx s_1369_5 -> bv
        let s_1369_6: Bits = Bits::new(s_1369_5 as u128, 4u16);
        // C s_1369_7: const #15u : u8
        let s_1369_7: u8 = 15;
        // C s_1369_8: cast zx s_1369_7 -> bv
        let s_1369_8: Bits = Bits::new(s_1369_7 as u128, 4u16);
        // D s_1369_9: cmp-ne s_1369_6 s_1369_8
        let s_1369_9: bool = ((s_1369_6) != (s_1369_8));
        // N s_1369_10: branch s_1369_9 b1372 b1370
        if s_1369_9 {
            return block_1372(state, tracer, fn_state);
        } else {
            return block_1370(state, tracer, fn_state);
        };
    }
    fn block_1370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1370_0: const #0u : u8
        let s_1370_0: bool = false;
        // D s_1370_1: write-var gs#409625 <= s_1370_0
        fn_state.gs_409625 = s_1370_0;
        // N s_1370_2: jump b1371
        return block_1371(state, tracer, fn_state);
    }
    fn block_1371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1371_0: read-var gs#409625:u8
        let s_1371_0: bool = fn_state.gs_409625;
        // D s_1371_1: write-var gs#409626 <= s_1371_0
        fn_state.gs_409626 = s_1371_0;
        // N s_1371_2: jump b291
        return block_291(state, tracer, fn_state);
    }
    fn block_1372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1372_0: const #3119s : i
        let s_1372_0: i128 = 3119;
        // C s_1372_1: const #14696u : u32
        let s_1372_1: u32 = 14696;
        // D s_1372_2: read-reg s_1372_1:i
        let s_1372_2: i128 = {
            let value = state.read_register::<i128>(s_1372_1 as isize);
            tracer.read_register(s_1372_1 as isize, value);
            value
        };
        // D s_1372_3: cmp-lt s_1372_2 s_1372_0
        let s_1372_3: bool = ((s_1372_2) < (s_1372_0));
        // D s_1372_4: write-var gs#409625 <= s_1372_3
        fn_state.gs_409625 = s_1372_3;
        // N s_1372_5: jump b1371
        return block_1371(state, tracer, fn_state);
    }
    fn block_1373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1373_0: const #4s : i
        let s_1373_0: i128 = 4;
        // D s_1373_1: read-var u#33505:u32
        let s_1373_1: u32 = fn_state.u_33505;
        // D s_1373_2: cast zx s_1373_1 -> bv
        let s_1373_2: Bits = Bits::new(s_1373_1 as u128, 32u16);
        // C s_1373_3: const #1s : i64
        let s_1373_3: i64 = 1;
        // C s_1373_4: cast zx s_1373_3 -> i
        let s_1373_4: i128 = (i128::try_from(s_1373_3).unwrap());
        // C s_1373_5: const #2s : i
        let s_1373_5: i128 = 2;
        // C s_1373_6: add s_1373_5 s_1373_4
        let s_1373_6: i128 = (s_1373_5 + s_1373_4);
        // D s_1373_7: bit-extract s_1373_2 s_1373_0 s_1373_6
        let s_1373_7: Bits = (Bits::new(
            ((s_1373_2) >> (s_1373_0)).value(),
            u16::try_from(s_1373_6).unwrap(),
        ));
        // D s_1373_8: cast reint s_1373_7 -> u8
        let s_1373_8: u8 = (s_1373_7.value() as u8);
        // D s_1373_9: cast zx s_1373_8 -> bv
        let s_1373_9: Bits = Bits::new(s_1373_8 as u128, 3u16);
        // C s_1373_10: const #5u : u8
        let s_1373_10: u8 = 5;
        // C s_1373_11: cast zx s_1373_10 -> bv
        let s_1373_11: Bits = Bits::new(s_1373_10 as u128, 3u16);
        // D s_1373_12: cmp-eq s_1373_9 s_1373_11
        let s_1373_12: bool = ((s_1373_9) == (s_1373_11));
        // D s_1373_13: write-var gs#409621 <= s_1373_12
        fn_state.gs_409621 = s_1373_12;
        // N s_1373_14: jump b289
        return block_289(state, tracer, fn_state);
    }
    fn block_1374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1374_0: const #28s : i
        let s_1374_0: i128 = 28;
        // C s_1374_1: const #4s : i
        let s_1374_1: i128 = 4;
        // D s_1374_2: read-var u#33499:u32
        let s_1374_2: u32 = fn_state.u_33499;
        // D s_1374_3: cast zx s_1374_2 -> bv
        let s_1374_3: Bits = Bits::new(s_1374_2 as u128, 32u16);
        // D s_1374_4: bit-extract s_1374_3 s_1374_0 s_1374_1
        let s_1374_4: Bits = (Bits::new(
            ((s_1374_3) >> (s_1374_0)).value(),
            u16::try_from(s_1374_1).unwrap(),
        ));
        // D s_1374_5: cast reint s_1374_4 -> u8
        let s_1374_5: u8 = (s_1374_4.value() as u8);
        // D s_1374_6: cast zx s_1374_5 -> bv
        let s_1374_6: Bits = Bits::new(s_1374_5 as u128, 4u16);
        // C s_1374_7: const #15u : u8
        let s_1374_7: u8 = 15;
        // C s_1374_8: cast zx s_1374_7 -> bv
        let s_1374_8: Bits = Bits::new(s_1374_7 as u128, 4u16);
        // D s_1374_9: cmp-ne s_1374_6 s_1374_8
        let s_1374_9: bool = ((s_1374_6) != (s_1374_8));
        // N s_1374_10: branch s_1374_9 b1377 b1375
        if s_1374_9 {
            return block_1377(state, tracer, fn_state);
        } else {
            return block_1375(state, tracer, fn_state);
        };
    }
    fn block_1375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1375_0: const #0u : u8
        let s_1375_0: bool = false;
        // D s_1375_1: write-var gs#409593 <= s_1375_0
        fn_state.gs_409593 = s_1375_0;
        // N s_1375_2: jump b1376
        return block_1376(state, tracer, fn_state);
    }
    fn block_1376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1376_0: read-var gs#409593:u8
        let s_1376_0: bool = fn_state.gs_409593;
        // D s_1376_1: write-var gs#409594 <= s_1376_0
        fn_state.gs_409594 = s_1376_0;
        // N s_1376_2: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_1377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1377_0: const #3109s : i
        let s_1377_0: i128 = 3109;
        // C s_1377_1: const #14696u : u32
        let s_1377_1: u32 = 14696;
        // D s_1377_2: read-reg s_1377_1:i
        let s_1377_2: i128 = {
            let value = state.read_register::<i128>(s_1377_1 as isize);
            tracer.read_register(s_1377_1 as isize, value);
            value
        };
        // D s_1377_3: cmp-lt s_1377_2 s_1377_0
        let s_1377_3: bool = ((s_1377_2) < (s_1377_0));
        // D s_1377_4: write-var gs#409593 <= s_1377_3
        fn_state.gs_409593 = s_1377_3;
        // N s_1377_5: jump b1376
        return block_1376(state, tracer, fn_state);
    }
    fn block_1378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1378_0: const #4s : i
        let s_1378_0: i128 = 4;
        // D s_1378_1: read-var u#33499:u32
        let s_1378_1: u32 = fn_state.u_33499;
        // D s_1378_2: cast zx s_1378_1 -> bv
        let s_1378_2: Bits = Bits::new(s_1378_1 as u128, 32u16);
        // C s_1378_3: const #1s : i64
        let s_1378_3: i64 = 1;
        // C s_1378_4: cast zx s_1378_3 -> i
        let s_1378_4: i128 = (i128::try_from(s_1378_3).unwrap());
        // C s_1378_5: const #7s : i
        let s_1378_5: i128 = 7;
        // C s_1378_6: add s_1378_5 s_1378_4
        let s_1378_6: i128 = (s_1378_5 + s_1378_4);
        // D s_1378_7: bit-extract s_1378_2 s_1378_0 s_1378_6
        let s_1378_7: Bits = (Bits::new(
            ((s_1378_2) >> (s_1378_0)).value(),
            u16::try_from(s_1378_6).unwrap(),
        ));
        // D s_1378_8: cast reint s_1378_7 -> u8
        let s_1378_8: u8 = (s_1378_7.value() as u8);
        // D s_1378_9: cast zx s_1378_8 -> bv
        let s_1378_9: Bits = Bits::new(s_1378_8 as u128, 8u16);
        // C s_1378_10: const #243u : u8
        let s_1378_10: u8 = 243;
        // C s_1378_11: cast zx s_1378_10 -> bv
        let s_1378_11: Bits = Bits::new(s_1378_10 as u128, 8u16);
        // D s_1378_12: cmp-eq s_1378_9 s_1378_11
        let s_1378_12: bool = ((s_1378_9) == (s_1378_11));
        // D s_1378_13: write-var gs#409589 <= s_1378_12
        fn_state.gs_409589 = s_1378_12;
        // N s_1378_14: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_1379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1379_0: const #28s : i
        let s_1379_0: i128 = 28;
        // C s_1379_1: const #4s : i
        let s_1379_1: i128 = 4;
        // D s_1379_2: read-var u#33493:u32
        let s_1379_2: u32 = fn_state.u_33493;
        // D s_1379_3: cast zx s_1379_2 -> bv
        let s_1379_3: Bits = Bits::new(s_1379_2 as u128, 32u16);
        // D s_1379_4: bit-extract s_1379_3 s_1379_0 s_1379_1
        let s_1379_4: Bits = (Bits::new(
            ((s_1379_3) >> (s_1379_0)).value(),
            u16::try_from(s_1379_1).unwrap(),
        ));
        // D s_1379_5: cast reint s_1379_4 -> u8
        let s_1379_5: u8 = (s_1379_4.value() as u8);
        // D s_1379_6: cast zx s_1379_5 -> bv
        let s_1379_6: Bits = Bits::new(s_1379_5 as u128, 4u16);
        // C s_1379_7: const #15u : u8
        let s_1379_7: u8 = 15;
        // C s_1379_8: cast zx s_1379_7 -> bv
        let s_1379_8: Bits = Bits::new(s_1379_7 as u128, 4u16);
        // D s_1379_9: cmp-ne s_1379_6 s_1379_8
        let s_1379_9: bool = ((s_1379_6) != (s_1379_8));
        // N s_1379_10: branch s_1379_9 b1382 b1380
        if s_1379_9 {
            return block_1382(state, tracer, fn_state);
        } else {
            return block_1380(state, tracer, fn_state);
        };
    }
    fn block_1380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1380_0: const #0u : u8
        let s_1380_0: bool = false;
        // D s_1380_1: write-var gs#409561 <= s_1380_0
        fn_state.gs_409561 = s_1380_0;
        // N s_1380_2: jump b1381
        return block_1381(state, tracer, fn_state);
    }
    fn block_1381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1381_0: read-var gs#409561:u8
        let s_1381_0: bool = fn_state.gs_409561;
        // D s_1381_1: write-var gs#409562 <= s_1381_0
        fn_state.gs_409562 = s_1381_0;
        // N s_1381_2: jump b257
        return block_257(state, tracer, fn_state);
    }
    fn block_1382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1382_0: const #3107s : i
        let s_1382_0: i128 = 3107;
        // C s_1382_1: const #14696u : u32
        let s_1382_1: u32 = 14696;
        // D s_1382_2: read-reg s_1382_1:i
        let s_1382_2: i128 = {
            let value = state.read_register::<i128>(s_1382_1 as isize);
            tracer.read_register(s_1382_1 as isize, value);
            value
        };
        // D s_1382_3: cmp-lt s_1382_2 s_1382_0
        let s_1382_3: bool = ((s_1382_2) < (s_1382_0));
        // D s_1382_4: write-var gs#409561 <= s_1382_3
        fn_state.gs_409561 = s_1382_3;
        // N s_1382_5: jump b1381
        return block_1381(state, tracer, fn_state);
    }
    fn block_1383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1383_0: const #4s : i
        let s_1383_0: i128 = 4;
        // D s_1383_1: read-var u#33493:u32
        let s_1383_1: u32 = fn_state.u_33493;
        // D s_1383_2: cast zx s_1383_1 -> bv
        let s_1383_2: Bits = Bits::new(s_1383_1 as u128, 32u16);
        // C s_1383_3: const #1s : i64
        let s_1383_3: i64 = 1;
        // C s_1383_4: cast zx s_1383_3 -> i
        let s_1383_4: i128 = (i128::try_from(s_1383_3).unwrap());
        // C s_1383_5: const #7s : i
        let s_1383_5: i128 = 7;
        // C s_1383_6: add s_1383_5 s_1383_4
        let s_1383_6: i128 = (s_1383_5 + s_1383_4);
        // D s_1383_7: bit-extract s_1383_2 s_1383_0 s_1383_6
        let s_1383_7: Bits = (Bits::new(
            ((s_1383_2) >> (s_1383_0)).value(),
            u16::try_from(s_1383_6).unwrap(),
        ));
        // D s_1383_8: cast reint s_1383_7 -> u8
        let s_1383_8: u8 = (s_1383_7.value() as u8);
        // D s_1383_9: cast zx s_1383_8 -> bv
        let s_1383_9: Bits = Bits::new(s_1383_8 as u128, 8u16);
        // C s_1383_10: const #249u : u8
        let s_1383_10: u8 = 249;
        // C s_1383_11: cast zx s_1383_10 -> bv
        let s_1383_11: Bits = Bits::new(s_1383_10 as u128, 8u16);
        // D s_1383_12: cmp-eq s_1383_9 s_1383_11
        let s_1383_12: bool = ((s_1383_9) == (s_1383_11));
        // D s_1383_13: write-var gs#409557 <= s_1383_12
        fn_state.gs_409557 = s_1383_12;
        // N s_1383_14: jump b255
        return block_255(state, tracer, fn_state);
    }
    fn block_1384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1384_0: const #28s : i
        let s_1384_0: i128 = 28;
        // C s_1384_1: const #4s : i
        let s_1384_1: i128 = 4;
        // D s_1384_2: read-var u#33487:u32
        let s_1384_2: u32 = fn_state.u_33487;
        // D s_1384_3: cast zx s_1384_2 -> bv
        let s_1384_3: Bits = Bits::new(s_1384_2 as u128, 32u16);
        // D s_1384_4: bit-extract s_1384_3 s_1384_0 s_1384_1
        let s_1384_4: Bits = (Bits::new(
            ((s_1384_3) >> (s_1384_0)).value(),
            u16::try_from(s_1384_1).unwrap(),
        ));
        // D s_1384_5: cast reint s_1384_4 -> u8
        let s_1384_5: u8 = (s_1384_4.value() as u8);
        // D s_1384_6: cast zx s_1384_5 -> bv
        let s_1384_6: Bits = Bits::new(s_1384_5 as u128, 4u16);
        // C s_1384_7: const #15u : u8
        let s_1384_7: u8 = 15;
        // C s_1384_8: cast zx s_1384_7 -> bv
        let s_1384_8: Bits = Bits::new(s_1384_7 as u128, 4u16);
        // D s_1384_9: cmp-ne s_1384_6 s_1384_8
        let s_1384_9: bool = ((s_1384_6) != (s_1384_8));
        // N s_1384_10: branch s_1384_9 b1387 b1385
        if s_1384_9 {
            return block_1387(state, tracer, fn_state);
        } else {
            return block_1385(state, tracer, fn_state);
        };
    }
    fn block_1385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1385_0: const #0u : u8
        let s_1385_0: bool = false;
        // D s_1385_1: write-var gs#409529 <= s_1385_0
        fn_state.gs_409529 = s_1385_0;
        // N s_1385_2: jump b1386
        return block_1386(state, tracer, fn_state);
    }
    fn block_1386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1386_0: read-var gs#409529:u8
        let s_1386_0: bool = fn_state.gs_409529;
        // D s_1386_1: write-var gs#409530 <= s_1386_0
        fn_state.gs_409530 = s_1386_0;
        // N s_1386_2: jump b240
        return block_240(state, tracer, fn_state);
    }
    fn block_1387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1387_0: const #3105s : i
        let s_1387_0: i128 = 3105;
        // C s_1387_1: const #14696u : u32
        let s_1387_1: u32 = 14696;
        // D s_1387_2: read-reg s_1387_1:i
        let s_1387_2: i128 = {
            let value = state.read_register::<i128>(s_1387_1 as isize);
            tracer.read_register(s_1387_1 as isize, value);
            value
        };
        // D s_1387_3: cmp-lt s_1387_2 s_1387_0
        let s_1387_3: bool = ((s_1387_2) < (s_1387_0));
        // D s_1387_4: write-var gs#409529 <= s_1387_3
        fn_state.gs_409529 = s_1387_3;
        // N s_1387_5: jump b1386
        return block_1386(state, tracer, fn_state);
    }
    fn block_1388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1388_0: const #4s : i
        let s_1388_0: i128 = 4;
        // D s_1388_1: read-var u#33487:u32
        let s_1388_1: u32 = fn_state.u_33487;
        // D s_1388_2: cast zx s_1388_1 -> bv
        let s_1388_2: Bits = Bits::new(s_1388_1 as u128, 32u16);
        // C s_1388_3: const #1s : i64
        let s_1388_3: i64 = 1;
        // C s_1388_4: cast zx s_1388_3 -> i
        let s_1388_4: i128 = (i128::try_from(s_1388_3).unwrap());
        // C s_1388_5: const #7s : i
        let s_1388_5: i128 = 7;
        // C s_1388_6: add s_1388_5 s_1388_4
        let s_1388_6: i128 = (s_1388_5 + s_1388_4);
        // D s_1388_7: bit-extract s_1388_2 s_1388_0 s_1388_6
        let s_1388_7: Bits = (Bits::new(
            ((s_1388_2) >> (s_1388_0)).value(),
            u16::try_from(s_1388_6).unwrap(),
        ));
        // D s_1388_8: cast reint s_1388_7 -> u8
        let s_1388_8: u8 = (s_1388_7.value() as u8);
        // D s_1388_9: cast zx s_1388_8 -> bv
        let s_1388_9: Bits = Bits::new(s_1388_8 as u128, 8u16);
        // C s_1388_10: const #241u : u8
        let s_1388_10: u8 = 241;
        // C s_1388_11: cast zx s_1388_10 -> bv
        let s_1388_11: Bits = Bits::new(s_1388_10 as u128, 8u16);
        // D s_1388_12: cmp-eq s_1388_9 s_1388_11
        let s_1388_12: bool = ((s_1388_9) == (s_1388_11));
        // D s_1388_13: write-var gs#409525 <= s_1388_12
        fn_state.gs_409525 = s_1388_12;
        // N s_1388_14: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_1389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1389_0: const #28s : i
        let s_1389_0: i128 = 28;
        // C s_1389_1: const #4s : i
        let s_1389_1: i128 = 4;
        // D s_1389_2: read-var u#33482:u32
        let s_1389_2: u32 = fn_state.u_33482;
        // D s_1389_3: cast zx s_1389_2 -> bv
        let s_1389_3: Bits = Bits::new(s_1389_2 as u128, 32u16);
        // D s_1389_4: bit-extract s_1389_3 s_1389_0 s_1389_1
        let s_1389_4: Bits = (Bits::new(
            ((s_1389_3) >> (s_1389_0)).value(),
            u16::try_from(s_1389_1).unwrap(),
        ));
        // D s_1389_5: cast reint s_1389_4 -> u8
        let s_1389_5: u8 = (s_1389_4.value() as u8);
        // D s_1389_6: cast zx s_1389_5 -> bv
        let s_1389_6: Bits = Bits::new(s_1389_5 as u128, 4u16);
        // C s_1389_7: const #15u : u8
        let s_1389_7: u8 = 15;
        // C s_1389_8: cast zx s_1389_7 -> bv
        let s_1389_8: Bits = Bits::new(s_1389_7 as u128, 4u16);
        // D s_1389_9: cmp-ne s_1389_6 s_1389_8
        let s_1389_9: bool = ((s_1389_6) != (s_1389_8));
        // N s_1389_10: branch s_1389_9 b1392 b1390
        if s_1389_9 {
            return block_1392(state, tracer, fn_state);
        } else {
            return block_1390(state, tracer, fn_state);
        };
    }
    fn block_1390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1390_0: const #0u : u8
        let s_1390_0: bool = false;
        // D s_1390_1: write-var gs#409487 <= s_1390_0
        fn_state.gs_409487 = s_1390_0;
        // N s_1390_2: jump b1391
        return block_1391(state, tracer, fn_state);
    }
    fn block_1391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1391_0: read-var gs#409487:u8
        let s_1391_0: bool = fn_state.gs_409487;
        // D s_1391_1: write-var gs#409488 <= s_1391_0
        fn_state.gs_409488 = s_1391_0;
        // N s_1391_2: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_1392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1392_0: const #3092s : i
        let s_1392_0: i128 = 3092;
        // C s_1392_1: const #14696u : u32
        let s_1392_1: u32 = 14696;
        // D s_1392_2: read-reg s_1392_1:i
        let s_1392_2: i128 = {
            let value = state.read_register::<i128>(s_1392_1 as isize);
            tracer.read_register(s_1392_1 as isize, value);
            value
        };
        // D s_1392_3: cmp-lt s_1392_2 s_1392_0
        let s_1392_3: bool = ((s_1392_2) < (s_1392_0));
        // D s_1392_4: write-var gs#409487 <= s_1392_3
        fn_state.gs_409487 = s_1392_3;
        // N s_1392_5: jump b1391
        return block_1391(state, tracer, fn_state);
    }
    fn block_1393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1393_0: const #4s : i
        let s_1393_0: i128 = 4;
        // D s_1393_1: read-var u#33482:u32
        let s_1393_1: u32 = fn_state.u_33482;
        // D s_1393_2: cast zx s_1393_1 -> bv
        let s_1393_2: Bits = Bits::new(s_1393_1 as u128, 32u16);
        // C s_1393_3: const #1s : i64
        let s_1393_3: i64 = 1;
        // C s_1393_4: cast zx s_1393_3 -> i
        let s_1393_4: i128 = (i128::try_from(s_1393_3).unwrap());
        // C s_1393_5: const #7s : i
        let s_1393_5: i128 = 7;
        // C s_1393_6: add s_1393_5 s_1393_4
        let s_1393_6: i128 = (s_1393_5 + s_1393_4);
        // D s_1393_7: bit-extract s_1393_2 s_1393_0 s_1393_6
        let s_1393_7: Bits = (Bits::new(
            ((s_1393_2) >> (s_1393_0)).value(),
            u16::try_from(s_1393_6).unwrap(),
        ));
        // D s_1393_8: cast reint s_1393_7 -> u8
        let s_1393_8: u8 = (s_1393_7.value() as u8);
        // D s_1393_9: cast zx s_1393_8 -> bv
        let s_1393_9: Bits = Bits::new(s_1393_8 as u128, 8u16);
        // C s_1393_10: const #251u : u8
        let s_1393_10: u8 = 251;
        // C s_1393_11: cast zx s_1393_10 -> bv
        let s_1393_11: Bits = Bits::new(s_1393_10 as u128, 8u16);
        // D s_1393_12: cmp-eq s_1393_9 s_1393_11
        let s_1393_12: bool = ((s_1393_9) == (s_1393_11));
        // D s_1393_13: write-var gs#409483 <= s_1393_12
        fn_state.gs_409483 = s_1393_12;
        // N s_1393_14: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_1394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1394_0: const #28s : i
        let s_1394_0: i128 = 28;
        // C s_1394_1: const #4s : i
        let s_1394_1: i128 = 4;
        // D s_1394_2: read-var u#33477:u32
        let s_1394_2: u32 = fn_state.u_33477;
        // D s_1394_3: cast zx s_1394_2 -> bv
        let s_1394_3: Bits = Bits::new(s_1394_2 as u128, 32u16);
        // D s_1394_4: bit-extract s_1394_3 s_1394_0 s_1394_1
        let s_1394_4: Bits = (Bits::new(
            ((s_1394_3) >> (s_1394_0)).value(),
            u16::try_from(s_1394_1).unwrap(),
        ));
        // D s_1394_5: cast reint s_1394_4 -> u8
        let s_1394_5: u8 = (s_1394_4.value() as u8);
        // D s_1394_6: cast zx s_1394_5 -> bv
        let s_1394_6: Bits = Bits::new(s_1394_5 as u128, 4u16);
        // C s_1394_7: const #15u : u8
        let s_1394_7: u8 = 15;
        // C s_1394_8: cast zx s_1394_7 -> bv
        let s_1394_8: Bits = Bits::new(s_1394_7 as u128, 4u16);
        // D s_1394_9: cmp-ne s_1394_6 s_1394_8
        let s_1394_9: bool = ((s_1394_6) != (s_1394_8));
        // N s_1394_10: branch s_1394_9 b1397 b1395
        if s_1394_9 {
            return block_1397(state, tracer, fn_state);
        } else {
            return block_1395(state, tracer, fn_state);
        };
    }
    fn block_1395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1395_0: const #0u : u8
        let s_1395_0: bool = false;
        // D s_1395_1: write-var gs#409445 <= s_1395_0
        fn_state.gs_409445 = s_1395_0;
        // N s_1395_2: jump b1396
        return block_1396(state, tracer, fn_state);
    }
    fn block_1396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1396_0: read-var gs#409445:u8
        let s_1396_0: bool = fn_state.gs_409445;
        // D s_1396_1: write-var gs#409446 <= s_1396_0
        fn_state.gs_409446 = s_1396_0;
        // N s_1396_2: jump b182
        return block_182(state, tracer, fn_state);
    }
    fn block_1397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1397_0: const #3089s : i
        let s_1397_0: i128 = 3089;
        // C s_1397_1: const #14696u : u32
        let s_1397_1: u32 = 14696;
        // D s_1397_2: read-reg s_1397_1:i
        let s_1397_2: i128 = {
            let value = state.read_register::<i128>(s_1397_1 as isize);
            tracer.read_register(s_1397_1 as isize, value);
            value
        };
        // D s_1397_3: cmp-lt s_1397_2 s_1397_0
        let s_1397_3: bool = ((s_1397_2) < (s_1397_0));
        // D s_1397_4: write-var gs#409445 <= s_1397_3
        fn_state.gs_409445 = s_1397_3;
        // N s_1397_5: jump b1396
        return block_1396(state, tracer, fn_state);
    }
    fn block_1398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1398_0: const #4s : i
        let s_1398_0: i128 = 4;
        // D s_1398_1: read-var u#33477:u32
        let s_1398_1: u32 = fn_state.u_33477;
        // D s_1398_2: cast zx s_1398_1 -> bv
        let s_1398_2: Bits = Bits::new(s_1398_1 as u128, 32u16);
        // C s_1398_3: const #1s : i64
        let s_1398_3: i64 = 1;
        // C s_1398_4: cast zx s_1398_3 -> i
        let s_1398_4: i128 = (i128::try_from(s_1398_3).unwrap());
        // C s_1398_5: const #7s : i
        let s_1398_5: i128 = 7;
        // C s_1398_6: add s_1398_5 s_1398_4
        let s_1398_6: i128 = (s_1398_5 + s_1398_4);
        // D s_1398_7: bit-extract s_1398_2 s_1398_0 s_1398_6
        let s_1398_7: Bits = (Bits::new(
            ((s_1398_2) >> (s_1398_0)).value(),
            u16::try_from(s_1398_6).unwrap(),
        ));
        // D s_1398_8: cast reint s_1398_7 -> u8
        let s_1398_8: u8 = (s_1398_7.value() as u8);
        // D s_1398_9: cast zx s_1398_8 -> bv
        let s_1398_9: Bits = Bits::new(s_1398_8 as u128, 8u16);
        // C s_1398_10: const #243u : u8
        let s_1398_10: u8 = 243;
        // C s_1398_11: cast zx s_1398_10 -> bv
        let s_1398_11: Bits = Bits::new(s_1398_10 as u128, 8u16);
        // D s_1398_12: cmp-eq s_1398_9 s_1398_11
        let s_1398_12: bool = ((s_1398_9) == (s_1398_11));
        // D s_1398_13: write-var gs#409441 <= s_1398_12
        fn_state.gs_409441 = s_1398_12;
        // N s_1398_14: jump b180
        return block_180(state, tracer, fn_state);
    }
    fn block_1399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1399_0: const #28s : i
        let s_1399_0: i128 = 28;
        // C s_1399_1: const #4s : i
        let s_1399_1: i128 = 4;
        // D s_1399_2: read-var u#33472:u32
        let s_1399_2: u32 = fn_state.u_33472;
        // D s_1399_3: cast zx s_1399_2 -> bv
        let s_1399_3: Bits = Bits::new(s_1399_2 as u128, 32u16);
        // D s_1399_4: bit-extract s_1399_3 s_1399_0 s_1399_1
        let s_1399_4: Bits = (Bits::new(
            ((s_1399_3) >> (s_1399_0)).value(),
            u16::try_from(s_1399_1).unwrap(),
        ));
        // D s_1399_5: cast reint s_1399_4 -> u8
        let s_1399_5: u8 = (s_1399_4.value() as u8);
        // D s_1399_6: cast zx s_1399_5 -> bv
        let s_1399_6: Bits = Bits::new(s_1399_5 as u128, 4u16);
        // C s_1399_7: const #15u : u8
        let s_1399_7: u8 = 15;
        // C s_1399_8: cast zx s_1399_7 -> bv
        let s_1399_8: Bits = Bits::new(s_1399_7 as u128, 4u16);
        // D s_1399_9: cmp-ne s_1399_6 s_1399_8
        let s_1399_9: bool = ((s_1399_6) != (s_1399_8));
        // N s_1399_10: branch s_1399_9 b1402 b1400
        if s_1399_9 {
            return block_1402(state, tracer, fn_state);
        } else {
            return block_1400(state, tracer, fn_state);
        };
    }
    fn block_1400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1400_0: const #0u : u8
        let s_1400_0: bool = false;
        // D s_1400_1: write-var gs#409403 <= s_1400_0
        fn_state.gs_409403 = s_1400_0;
        // N s_1400_2: jump b1401
        return block_1401(state, tracer, fn_state);
    }
    fn block_1401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1401_0: read-var gs#409403:u8
        let s_1401_0: bool = fn_state.gs_409403;
        // D s_1401_1: write-var gs#409404 <= s_1401_0
        fn_state.gs_409404 = s_1401_0;
        // N s_1401_2: jump b153
        return block_153(state, tracer, fn_state);
    }
    fn block_1402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1402_0: const #3086s : i
        let s_1402_0: i128 = 3086;
        // C s_1402_1: const #14696u : u32
        let s_1402_1: u32 = 14696;
        // D s_1402_2: read-reg s_1402_1:i
        let s_1402_2: i128 = {
            let value = state.read_register::<i128>(s_1402_1 as isize);
            tracer.read_register(s_1402_1 as isize, value);
            value
        };
        // D s_1402_3: cmp-lt s_1402_2 s_1402_0
        let s_1402_3: bool = ((s_1402_2) < (s_1402_0));
        // D s_1402_4: write-var gs#409403 <= s_1402_3
        fn_state.gs_409403 = s_1402_3;
        // N s_1402_5: jump b1401
        return block_1401(state, tracer, fn_state);
    }
    fn block_1403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1403_0: const #4s : i
        let s_1403_0: i128 = 4;
        // D s_1403_1: read-var u#33472:u32
        let s_1403_1: u32 = fn_state.u_33472;
        // D s_1403_2: cast zx s_1403_1 -> bv
        let s_1403_2: Bits = Bits::new(s_1403_1 as u128, 32u16);
        // C s_1403_3: const #1s : i64
        let s_1403_3: i64 = 1;
        // C s_1403_4: cast zx s_1403_3 -> i
        let s_1403_4: i128 = (i128::try_from(s_1403_3).unwrap());
        // C s_1403_5: const #7s : i
        let s_1403_5: i128 = 7;
        // C s_1403_6: add s_1403_5 s_1403_4
        let s_1403_6: i128 = (s_1403_5 + s_1403_4);
        // D s_1403_7: bit-extract s_1403_2 s_1403_0 s_1403_6
        let s_1403_7: Bits = (Bits::new(
            ((s_1403_2) >> (s_1403_0)).value(),
            u16::try_from(s_1403_6).unwrap(),
        ));
        // D s_1403_8: cast reint s_1403_7 -> u8
        let s_1403_8: u8 = (s_1403_7.value() as u8);
        // D s_1403_9: cast zx s_1403_8 -> bv
        let s_1403_9: Bits = Bits::new(s_1403_8 as u128, 8u16);
        // C s_1403_10: const #251u : u8
        let s_1403_10: u8 = 251;
        // C s_1403_11: cast zx s_1403_10 -> bv
        let s_1403_11: Bits = Bits::new(s_1403_10 as u128, 8u16);
        // D s_1403_12: cmp-eq s_1403_9 s_1403_11
        let s_1403_12: bool = ((s_1403_9) == (s_1403_11));
        // D s_1403_13: write-var gs#409399 <= s_1403_12
        fn_state.gs_409399 = s_1403_12;
        // N s_1403_14: jump b151
        return block_151(state, tracer, fn_state);
    }
    fn block_1404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1404_0: const #28s : i
        let s_1404_0: i128 = 28;
        // C s_1404_1: const #4s : i
        let s_1404_1: i128 = 4;
        // D s_1404_2: read-var u#33467:u32
        let s_1404_2: u32 = fn_state.u_33467;
        // D s_1404_3: cast zx s_1404_2 -> bv
        let s_1404_3: Bits = Bits::new(s_1404_2 as u128, 32u16);
        // D s_1404_4: bit-extract s_1404_3 s_1404_0 s_1404_1
        let s_1404_4: Bits = (Bits::new(
            ((s_1404_3) >> (s_1404_0)).value(),
            u16::try_from(s_1404_1).unwrap(),
        ));
        // D s_1404_5: cast reint s_1404_4 -> u8
        let s_1404_5: u8 = (s_1404_4.value() as u8);
        // D s_1404_6: cast zx s_1404_5 -> bv
        let s_1404_6: Bits = Bits::new(s_1404_5 as u128, 4u16);
        // C s_1404_7: const #15u : u8
        let s_1404_7: u8 = 15;
        // C s_1404_8: cast zx s_1404_7 -> bv
        let s_1404_8: Bits = Bits::new(s_1404_7 as u128, 4u16);
        // D s_1404_9: cmp-ne s_1404_6 s_1404_8
        let s_1404_9: bool = ((s_1404_6) != (s_1404_8));
        // N s_1404_10: branch s_1404_9 b1407 b1405
        if s_1404_9 {
            return block_1407(state, tracer, fn_state);
        } else {
            return block_1405(state, tracer, fn_state);
        };
    }
    fn block_1405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1405_0: const #0u : u8
        let s_1405_0: bool = false;
        // D s_1405_1: write-var gs#409361 <= s_1405_0
        fn_state.gs_409361 = s_1405_0;
        // N s_1405_2: jump b1406
        return block_1406(state, tracer, fn_state);
    }
    fn block_1406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1406_0: read-var gs#409361:u8
        let s_1406_0: bool = fn_state.gs_409361;
        // D s_1406_1: write-var gs#409362 <= s_1406_0
        fn_state.gs_409362 = s_1406_0;
        // N s_1406_2: jump b124
        return block_124(state, tracer, fn_state);
    }
    fn block_1407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1407_0: const #3084s : i
        let s_1407_0: i128 = 3084;
        // C s_1407_1: const #14696u : u32
        let s_1407_1: u32 = 14696;
        // D s_1407_2: read-reg s_1407_1:i
        let s_1407_2: i128 = {
            let value = state.read_register::<i128>(s_1407_1 as isize);
            tracer.read_register(s_1407_1 as isize, value);
            value
        };
        // D s_1407_3: cmp-lt s_1407_2 s_1407_0
        let s_1407_3: bool = ((s_1407_2) < (s_1407_0));
        // D s_1407_4: write-var gs#409361 <= s_1407_3
        fn_state.gs_409361 = s_1407_3;
        // N s_1407_5: jump b1406
        return block_1406(state, tracer, fn_state);
    }
    fn block_1408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1408_0: const #4s : i
        let s_1408_0: i128 = 4;
        // D s_1408_1: read-var u#33467:u32
        let s_1408_1: u32 = fn_state.u_33467;
        // D s_1408_2: cast zx s_1408_1 -> bv
        let s_1408_2: Bits = Bits::new(s_1408_1 as u128, 32u16);
        // C s_1408_3: const #1s : i64
        let s_1408_3: i64 = 1;
        // C s_1408_4: cast zx s_1408_3 -> i
        let s_1408_4: i128 = (i128::try_from(s_1408_3).unwrap());
        // C s_1408_5: const #7s : i
        let s_1408_5: i128 = 7;
        // C s_1408_6: add s_1408_5 s_1408_4
        let s_1408_6: i128 = (s_1408_5 + s_1408_4);
        // D s_1408_7: bit-extract s_1408_2 s_1408_0 s_1408_6
        let s_1408_7: Bits = (Bits::new(
            ((s_1408_2) >> (s_1408_0)).value(),
            u16::try_from(s_1408_6).unwrap(),
        ));
        // D s_1408_8: cast reint s_1408_7 -> u8
        let s_1408_8: u8 = (s_1408_7.value() as u8);
        // D s_1408_9: cast zx s_1408_8 -> bv
        let s_1408_9: Bits = Bits::new(s_1408_8 as u128, 8u16);
        // C s_1408_10: const #243u : u8
        let s_1408_10: u8 = 243;
        // C s_1408_11: cast zx s_1408_10 -> bv
        let s_1408_11: Bits = Bits::new(s_1408_10 as u128, 8u16);
        // D s_1408_12: cmp-eq s_1408_9 s_1408_11
        let s_1408_12: bool = ((s_1408_9) == (s_1408_11));
        // D s_1408_13: write-var gs#409357 <= s_1408_12
        fn_state.gs_409357 = s_1408_12;
        // N s_1408_14: jump b122
        return block_122(state, tracer, fn_state);
    }
    fn block_1409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1409_0: const #28s : i
        let s_1409_0: i128 = 28;
        // C s_1409_1: const #4s : i
        let s_1409_1: i128 = 4;
        // D s_1409_2: read-var u#33461:u32
        let s_1409_2: u32 = fn_state.u_33461;
        // D s_1409_3: cast zx s_1409_2 -> bv
        let s_1409_3: Bits = Bits::new(s_1409_2 as u128, 32u16);
        // D s_1409_4: bit-extract s_1409_3 s_1409_0 s_1409_1
        let s_1409_4: Bits = (Bits::new(
            ((s_1409_3) >> (s_1409_0)).value(),
            u16::try_from(s_1409_1).unwrap(),
        ));
        // D s_1409_5: cast reint s_1409_4 -> u8
        let s_1409_5: u8 = (s_1409_4.value() as u8);
        // D s_1409_6: cast zx s_1409_5 -> bv
        let s_1409_6: Bits = Bits::new(s_1409_5 as u128, 4u16);
        // C s_1409_7: const #15u : u8
        let s_1409_7: u8 = 15;
        // C s_1409_8: cast zx s_1409_7 -> bv
        let s_1409_8: Bits = Bits::new(s_1409_7 as u128, 4u16);
        // D s_1409_9: cmp-ne s_1409_6 s_1409_8
        let s_1409_9: bool = ((s_1409_6) != (s_1409_8));
        // N s_1409_10: branch s_1409_9 b1412 b1410
        if s_1409_9 {
            return block_1412(state, tracer, fn_state);
        } else {
            return block_1410(state, tracer, fn_state);
        };
    }
    fn block_1410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1410_0: const #0u : u8
        let s_1410_0: bool = false;
        // D s_1410_1: write-var gs#409329 <= s_1410_0
        fn_state.gs_409329 = s_1410_0;
        // N s_1410_2: jump b1411
        return block_1411(state, tracer, fn_state);
    }
    fn block_1411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1411_0: read-var gs#409329:u8
        let s_1411_0: bool = fn_state.gs_409329;
        // D s_1411_1: write-var gs#409330 <= s_1411_0
        fn_state.gs_409330 = s_1411_0;
        // N s_1411_2: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_1412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1412_0: const #3080s : i
        let s_1412_0: i128 = 3080;
        // C s_1412_1: const #14696u : u32
        let s_1412_1: u32 = 14696;
        // D s_1412_2: read-reg s_1412_1:i
        let s_1412_2: i128 = {
            let value = state.read_register::<i128>(s_1412_1 as isize);
            tracer.read_register(s_1412_1 as isize, value);
            value
        };
        // D s_1412_3: cmp-lt s_1412_2 s_1412_0
        let s_1412_3: bool = ((s_1412_2) < (s_1412_0));
        // D s_1412_4: write-var gs#409329 <= s_1412_3
        fn_state.gs_409329 = s_1412_3;
        // N s_1412_5: jump b1411
        return block_1411(state, tracer, fn_state);
    }
    fn block_1413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1413_0: const #4s : i
        let s_1413_0: i128 = 4;
        // D s_1413_1: read-var u#33461:u32
        let s_1413_1: u32 = fn_state.u_33461;
        // D s_1413_2: cast zx s_1413_1 -> bv
        let s_1413_2: Bits = Bits::new(s_1413_1 as u128, 32u16);
        // C s_1413_3: const #1s : i64
        let s_1413_3: i64 = 1;
        // C s_1413_4: cast zx s_1413_3 -> i
        let s_1413_4: i128 = (i128::try_from(s_1413_3).unwrap());
        // C s_1413_5: const #7s : i
        let s_1413_5: i128 = 7;
        // C s_1413_6: add s_1413_5 s_1413_4
        let s_1413_6: i128 = (s_1413_5 + s_1413_4);
        // D s_1413_7: bit-extract s_1413_2 s_1413_0 s_1413_6
        let s_1413_7: Bits = (Bits::new(
            ((s_1413_2) >> (s_1413_0)).value(),
            u16::try_from(s_1413_6).unwrap(),
        ));
        // D s_1413_8: cast reint s_1413_7 -> u8
        let s_1413_8: u8 = (s_1413_7.value() as u8);
        // D s_1413_9: cast zx s_1413_8 -> bv
        let s_1413_9: Bits = Bits::new(s_1413_8 as u128, 8u16);
        // C s_1413_10: const #255u : u8
        let s_1413_10: u8 = 255;
        // C s_1413_11: cast zx s_1413_10 -> bv
        let s_1413_11: Bits = Bits::new(s_1413_10 as u128, 8u16);
        // D s_1413_12: cmp-eq s_1413_9 s_1413_11
        let s_1413_12: bool = ((s_1413_9) == (s_1413_11));
        // D s_1413_13: write-var gs#409325 <= s_1413_12
        fn_state.gs_409325 = s_1413_12;
        // N s_1413_14: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_1414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1414_0: const #28s : i
        let s_1414_0: i128 = 28;
        // C s_1414_1: const #4s : i
        let s_1414_1: i128 = 4;
        // D s_1414_2: read-var u#33455:u32
        let s_1414_2: u32 = fn_state.u_33455;
        // D s_1414_3: cast zx s_1414_2 -> bv
        let s_1414_3: Bits = Bits::new(s_1414_2 as u128, 32u16);
        // D s_1414_4: bit-extract s_1414_3 s_1414_0 s_1414_1
        let s_1414_4: Bits = (Bits::new(
            ((s_1414_3) >> (s_1414_0)).value(),
            u16::try_from(s_1414_1).unwrap(),
        ));
        // D s_1414_5: cast reint s_1414_4 -> u8
        let s_1414_5: u8 = (s_1414_4.value() as u8);
        // D s_1414_6: cast zx s_1414_5 -> bv
        let s_1414_6: Bits = Bits::new(s_1414_5 as u128, 4u16);
        // C s_1414_7: const #15u : u8
        let s_1414_7: u8 = 15;
        // C s_1414_8: cast zx s_1414_7 -> bv
        let s_1414_8: Bits = Bits::new(s_1414_7 as u128, 4u16);
        // D s_1414_9: cmp-ne s_1414_6 s_1414_8
        let s_1414_9: bool = ((s_1414_6) != (s_1414_8));
        // N s_1414_10: branch s_1414_9 b1417 b1415
        if s_1414_9 {
            return block_1417(state, tracer, fn_state);
        } else {
            return block_1415(state, tracer, fn_state);
        };
    }
    fn block_1415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1415_0: const #0u : u8
        let s_1415_0: bool = false;
        // D s_1415_1: write-var gs#409297 <= s_1415_0
        fn_state.gs_409297 = s_1415_0;
        // N s_1415_2: jump b1416
        return block_1416(state, tracer, fn_state);
    }
    fn block_1416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1416_0: read-var gs#409297:u8
        let s_1416_0: bool = fn_state.gs_409297;
        // D s_1416_1: write-var gs#409298 <= s_1416_0
        fn_state.gs_409298 = s_1416_0;
        // N s_1416_2: jump b90
        return block_90(state, tracer, fn_state);
    }
    fn block_1417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1417_0: const #3078s : i
        let s_1417_0: i128 = 3078;
        // C s_1417_1: const #14696u : u32
        let s_1417_1: u32 = 14696;
        // D s_1417_2: read-reg s_1417_1:i
        let s_1417_2: i128 = {
            let value = state.read_register::<i128>(s_1417_1 as isize);
            tracer.read_register(s_1417_1 as isize, value);
            value
        };
        // D s_1417_3: cmp-lt s_1417_2 s_1417_0
        let s_1417_3: bool = ((s_1417_2) < (s_1417_0));
        // D s_1417_4: write-var gs#409297 <= s_1417_3
        fn_state.gs_409297 = s_1417_3;
        // N s_1417_5: jump b1416
        return block_1416(state, tracer, fn_state);
    }
    fn block_1418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1418_0: const #4s : i
        let s_1418_0: i128 = 4;
        // D s_1418_1: read-var u#33455:u32
        let s_1418_1: u32 = fn_state.u_33455;
        // D s_1418_2: cast zx s_1418_1 -> bv
        let s_1418_2: Bits = Bits::new(s_1418_1 as u128, 32u16);
        // C s_1418_3: const #1s : i64
        let s_1418_3: i64 = 1;
        // C s_1418_4: cast zx s_1418_3 -> i
        let s_1418_4: i128 = (i128::try_from(s_1418_3).unwrap());
        // C s_1418_5: const #7s : i
        let s_1418_5: i128 = 7;
        // C s_1418_6: add s_1418_5 s_1418_4
        let s_1418_6: i128 = (s_1418_5 + s_1418_4);
        // D s_1418_7: bit-extract s_1418_2 s_1418_0 s_1418_6
        let s_1418_7: Bits = (Bits::new(
            ((s_1418_2) >> (s_1418_0)).value(),
            u16::try_from(s_1418_6).unwrap(),
        ));
        // D s_1418_8: cast reint s_1418_7 -> u8
        let s_1418_8: u8 = (s_1418_7.value() as u8);
        // D s_1418_9: cast zx s_1418_8 -> bv
        let s_1418_9: Bits = Bits::new(s_1418_8 as u128, 8u16);
        // C s_1418_10: const #247u : u8
        let s_1418_10: u8 = 247;
        // C s_1418_11: cast zx s_1418_10 -> bv
        let s_1418_11: Bits = Bits::new(s_1418_10 as u128, 8u16);
        // D s_1418_12: cmp-eq s_1418_9 s_1418_11
        let s_1418_12: bool = ((s_1418_9) == (s_1418_11));
        // D s_1418_13: write-var gs#409293 <= s_1418_12
        fn_state.gs_409293 = s_1418_12;
        // N s_1418_14: jump b88
        return block_88(state, tracer, fn_state);
    }
    fn block_1419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1419_0: const #28s : i
        let s_1419_0: i128 = 28;
        // C s_1419_1: const #4s : i
        let s_1419_1: i128 = 4;
        // D s_1419_2: read-var u#33449:u32
        let s_1419_2: u32 = fn_state.u_33449;
        // D s_1419_3: cast zx s_1419_2 -> bv
        let s_1419_3: Bits = Bits::new(s_1419_2 as u128, 32u16);
        // D s_1419_4: bit-extract s_1419_3 s_1419_0 s_1419_1
        let s_1419_4: Bits = (Bits::new(
            ((s_1419_3) >> (s_1419_0)).value(),
            u16::try_from(s_1419_1).unwrap(),
        ));
        // D s_1419_5: cast reint s_1419_4 -> u8
        let s_1419_5: u8 = (s_1419_4.value() as u8);
        // D s_1419_6: cast zx s_1419_5 -> bv
        let s_1419_6: Bits = Bits::new(s_1419_5 as u128, 4u16);
        // C s_1419_7: const #15u : u8
        let s_1419_7: u8 = 15;
        // C s_1419_8: cast zx s_1419_7 -> bv
        let s_1419_8: Bits = Bits::new(s_1419_7 as u128, 4u16);
        // D s_1419_9: cmp-ne s_1419_6 s_1419_8
        let s_1419_9: bool = ((s_1419_6) != (s_1419_8));
        // N s_1419_10: branch s_1419_9 b1422 b1420
        if s_1419_9 {
            return block_1422(state, tracer, fn_state);
        } else {
            return block_1420(state, tracer, fn_state);
        };
    }
    fn block_1420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1420_0: const #0u : u8
        let s_1420_0: bool = false;
        // D s_1420_1: write-var gs#409265 <= s_1420_0
        fn_state.gs_409265 = s_1420_0;
        // N s_1420_2: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_1421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1421_0: read-var gs#409265:u8
        let s_1421_0: bool = fn_state.gs_409265;
        // D s_1421_1: write-var gs#409266 <= s_1421_0
        fn_state.gs_409266 = s_1421_0;
        // N s_1421_2: jump b73
        return block_73(state, tracer, fn_state);
    }
    fn block_1422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1422_0: const #3076s : i
        let s_1422_0: i128 = 3076;
        // C s_1422_1: const #14696u : u32
        let s_1422_1: u32 = 14696;
        // D s_1422_2: read-reg s_1422_1:i
        let s_1422_2: i128 = {
            let value = state.read_register::<i128>(s_1422_1 as isize);
            tracer.read_register(s_1422_1 as isize, value);
            value
        };
        // D s_1422_3: cmp-lt s_1422_2 s_1422_0
        let s_1422_3: bool = ((s_1422_2) < (s_1422_0));
        // D s_1422_4: write-var gs#409265 <= s_1422_3
        fn_state.gs_409265 = s_1422_3;
        // N s_1422_5: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_1423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1423_0: const #4s : i
        let s_1423_0: i128 = 4;
        // D s_1423_1: read-var u#33449:u32
        let s_1423_1: u32 = fn_state.u_33449;
        // D s_1423_2: cast zx s_1423_1 -> bv
        let s_1423_2: Bits = Bits::new(s_1423_1 as u128, 32u16);
        // C s_1423_3: const #1s : i64
        let s_1423_3: i64 = 1;
        // C s_1423_4: cast zx s_1423_3 -> i
        let s_1423_4: i128 = (i128::try_from(s_1423_3).unwrap());
        // C s_1423_5: const #7s : i
        let s_1423_5: i128 = 7;
        // C s_1423_6: add s_1423_5 s_1423_4
        let s_1423_6: i128 = (s_1423_5 + s_1423_4);
        // D s_1423_7: bit-extract s_1423_2 s_1423_0 s_1423_6
        let s_1423_7: Bits = (Bits::new(
            ((s_1423_2) >> (s_1423_0)).value(),
            u16::try_from(s_1423_6).unwrap(),
        ));
        // D s_1423_8: cast reint s_1423_7 -> u8
        let s_1423_8: u8 = (s_1423_7.value() as u8);
        // D s_1423_9: cast zx s_1423_8 -> bv
        let s_1423_9: Bits = Bits::new(s_1423_8 as u128, 8u16);
        // C s_1423_10: const #245u : u8
        let s_1423_10: u8 = 245;
        // C s_1423_11: cast zx s_1423_10 -> bv
        let s_1423_11: Bits = Bits::new(s_1423_10 as u128, 8u16);
        // D s_1423_12: cmp-eq s_1423_9 s_1423_11
        let s_1423_12: bool = ((s_1423_9) == (s_1423_11));
        // D s_1423_13: write-var gs#409261 <= s_1423_12
        fn_state.gs_409261 = s_1423_12;
        // N s_1423_14: jump b71
        return block_71(state, tracer, fn_state);
    }
    fn block_1424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1424_0: const #28s : i
        let s_1424_0: i128 = 28;
        // C s_1424_1: const #4s : i
        let s_1424_1: i128 = 4;
        // D s_1424_2: read-var u#33443:u32
        let s_1424_2: u32 = fn_state.u_33443;
        // D s_1424_3: cast zx s_1424_2 -> bv
        let s_1424_3: Bits = Bits::new(s_1424_2 as u128, 32u16);
        // D s_1424_4: bit-extract s_1424_3 s_1424_0 s_1424_1
        let s_1424_4: Bits = (Bits::new(
            ((s_1424_3) >> (s_1424_0)).value(),
            u16::try_from(s_1424_1).unwrap(),
        ));
        // D s_1424_5: cast reint s_1424_4 -> u8
        let s_1424_5: u8 = (s_1424_4.value() as u8);
        // D s_1424_6: cast zx s_1424_5 -> bv
        let s_1424_6: Bits = Bits::new(s_1424_5 as u128, 4u16);
        // C s_1424_7: const #15u : u8
        let s_1424_7: u8 = 15;
        // C s_1424_8: cast zx s_1424_7 -> bv
        let s_1424_8: Bits = Bits::new(s_1424_7 as u128, 4u16);
        // D s_1424_9: cmp-ne s_1424_6 s_1424_8
        let s_1424_9: bool = ((s_1424_6) != (s_1424_8));
        // N s_1424_10: branch s_1424_9 b1427 b1425
        if s_1424_9 {
            return block_1427(state, tracer, fn_state);
        } else {
            return block_1425(state, tracer, fn_state);
        };
    }
    fn block_1425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1425_0: const #0u : u8
        let s_1425_0: bool = false;
        // D s_1425_1: write-var gs#409233 <= s_1425_0
        fn_state.gs_409233 = s_1425_0;
        // N s_1425_2: jump b1426
        return block_1426(state, tracer, fn_state);
    }
    fn block_1426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1426_0: read-var gs#409233:u8
        let s_1426_0: bool = fn_state.gs_409233;
        // D s_1426_1: write-var gs#409234 <= s_1426_0
        fn_state.gs_409234 = s_1426_0;
        // N s_1426_2: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_1427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1427_0: const #3070s : i
        let s_1427_0: i128 = 3070;
        // C s_1427_1: const #14696u : u32
        let s_1427_1: u32 = 14696;
        // D s_1427_2: read-reg s_1427_1:i
        let s_1427_2: i128 = {
            let value = state.read_register::<i128>(s_1427_1 as isize);
            tracer.read_register(s_1427_1 as isize, value);
            value
        };
        // D s_1427_3: cmp-lt s_1427_2 s_1427_0
        let s_1427_3: bool = ((s_1427_2) < (s_1427_0));
        // D s_1427_4: write-var gs#409233 <= s_1427_3
        fn_state.gs_409233 = s_1427_3;
        // N s_1427_5: jump b1426
        return block_1426(state, tracer, fn_state);
    }
    fn block_1428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1428_0: const #4s : i
        let s_1428_0: i128 = 4;
        // D s_1428_1: read-var u#33443:u32
        let s_1428_1: u32 = fn_state.u_33443;
        // D s_1428_2: cast zx s_1428_1 -> bv
        let s_1428_2: Bits = Bits::new(s_1428_1 as u128, 32u16);
        // C s_1428_3: const #1s : i64
        let s_1428_3: i64 = 1;
        // C s_1428_4: cast zx s_1428_3 -> i
        let s_1428_4: i128 = (i128::try_from(s_1428_3).unwrap());
        // C s_1428_5: const #7s : i
        let s_1428_5: i128 = 7;
        // C s_1428_6: add s_1428_5 s_1428_4
        let s_1428_6: i128 = (s_1428_5 + s_1428_4);
        // D s_1428_7: bit-extract s_1428_2 s_1428_0 s_1428_6
        let s_1428_7: Bits = (Bits::new(
            ((s_1428_2) >> (s_1428_0)).value(),
            u16::try_from(s_1428_6).unwrap(),
        ));
        // D s_1428_8: cast reint s_1428_7 -> u8
        let s_1428_8: u8 = (s_1428_7.value() as u8);
        // D s_1428_9: cast zx s_1428_8 -> bv
        let s_1428_9: Bits = Bits::new(s_1428_8 as u128, 8u16);
        // C s_1428_10: const #243u : u8
        let s_1428_10: u8 = 243;
        // C s_1428_11: cast zx s_1428_10 -> bv
        let s_1428_11: Bits = Bits::new(s_1428_10 as u128, 8u16);
        // D s_1428_12: cmp-eq s_1428_9 s_1428_11
        let s_1428_12: bool = ((s_1428_9) == (s_1428_11));
        // D s_1428_13: write-var gs#409229 <= s_1428_12
        fn_state.gs_409229 = s_1428_12;
        // N s_1428_14: jump b54
        return block_54(state, tracer, fn_state);
    }
    fn block_1429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1429_0: const #28s : i
        let s_1429_0: i128 = 28;
        // C s_1429_1: const #4s : i
        let s_1429_1: i128 = 4;
        // D s_1429_2: read-var u#33437:u32
        let s_1429_2: u32 = fn_state.u_33437;
        // D s_1429_3: cast zx s_1429_2 -> bv
        let s_1429_3: Bits = Bits::new(s_1429_2 as u128, 32u16);
        // D s_1429_4: bit-extract s_1429_3 s_1429_0 s_1429_1
        let s_1429_4: Bits = (Bits::new(
            ((s_1429_3) >> (s_1429_0)).value(),
            u16::try_from(s_1429_1).unwrap(),
        ));
        // D s_1429_5: cast reint s_1429_4 -> u8
        let s_1429_5: u8 = (s_1429_4.value() as u8);
        // D s_1429_6: cast zx s_1429_5 -> bv
        let s_1429_6: Bits = Bits::new(s_1429_5 as u128, 4u16);
        // C s_1429_7: const #15u : u8
        let s_1429_7: u8 = 15;
        // C s_1429_8: cast zx s_1429_7 -> bv
        let s_1429_8: Bits = Bits::new(s_1429_7 as u128, 4u16);
        // D s_1429_9: cmp-ne s_1429_6 s_1429_8
        let s_1429_9: bool = ((s_1429_6) != (s_1429_8));
        // N s_1429_10: branch s_1429_9 b1432 b1430
        if s_1429_9 {
            return block_1432(state, tracer, fn_state);
        } else {
            return block_1430(state, tracer, fn_state);
        };
    }
    fn block_1430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1430_0: const #0u : u8
        let s_1430_0: bool = false;
        // D s_1430_1: write-var gs#409201 <= s_1430_0
        fn_state.gs_409201 = s_1430_0;
        // N s_1430_2: jump b1431
        return block_1431(state, tracer, fn_state);
    }
    fn block_1431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1431_0: read-var gs#409201:u8
        let s_1431_0: bool = fn_state.gs_409201;
        // D s_1431_1: write-var gs#409202 <= s_1431_0
        fn_state.gs_409202 = s_1431_0;
        // N s_1431_2: jump b39
        return block_39(state, tracer, fn_state);
    }
    fn block_1432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1432_0: const #3066s : i
        let s_1432_0: i128 = 3066;
        // C s_1432_1: const #14696u : u32
        let s_1432_1: u32 = 14696;
        // D s_1432_2: read-reg s_1432_1:i
        let s_1432_2: i128 = {
            let value = state.read_register::<i128>(s_1432_1 as isize);
            tracer.read_register(s_1432_1 as isize, value);
            value
        };
        // D s_1432_3: cmp-lt s_1432_2 s_1432_0
        let s_1432_3: bool = ((s_1432_2) < (s_1432_0));
        // D s_1432_4: write-var gs#409201 <= s_1432_3
        fn_state.gs_409201 = s_1432_3;
        // N s_1432_5: jump b1431
        return block_1431(state, tracer, fn_state);
    }
    fn block_1433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1433_0: const #4s : i
        let s_1433_0: i128 = 4;
        // D s_1433_1: read-var u#33437:u32
        let s_1433_1: u32 = fn_state.u_33437;
        // D s_1433_2: cast zx s_1433_1 -> bv
        let s_1433_2: Bits = Bits::new(s_1433_1 as u128, 32u16);
        // C s_1433_3: const #1s : i64
        let s_1433_3: i64 = 1;
        // C s_1433_4: cast zx s_1433_3 -> i
        let s_1433_4: i128 = (i128::try_from(s_1433_3).unwrap());
        // C s_1433_5: const #7s : i
        let s_1433_5: i128 = 7;
        // C s_1433_6: add s_1433_5 s_1433_4
        let s_1433_6: i128 = (s_1433_5 + s_1433_4);
        // D s_1433_7: bit-extract s_1433_2 s_1433_0 s_1433_6
        let s_1433_7: Bits = (Bits::new(
            ((s_1433_2) >> (s_1433_0)).value(),
            u16::try_from(s_1433_6).unwrap(),
        ));
        // D s_1433_8: cast reint s_1433_7 -> u8
        let s_1433_8: u8 = (s_1433_7.value() as u8);
        // D s_1433_9: cast zx s_1433_8 -> bv
        let s_1433_9: Bits = Bits::new(s_1433_8 as u128, 8u16);
        // C s_1433_10: const #249u : u8
        let s_1433_10: u8 = 249;
        // C s_1433_11: cast zx s_1433_10 -> bv
        let s_1433_11: Bits = Bits::new(s_1433_10 as u128, 8u16);
        // D s_1433_12: cmp-eq s_1433_9 s_1433_11
        let s_1433_12: bool = ((s_1433_9) == (s_1433_11));
        // D s_1433_13: write-var gs#409197 <= s_1433_12
        fn_state.gs_409197 = s_1433_12;
        // N s_1433_14: jump b37
        return block_37(state, tracer, fn_state);
    }
    fn block_1434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1434_0: const #28s : i
        let s_1434_0: i128 = 28;
        // C s_1434_1: const #4s : i
        let s_1434_1: i128 = 4;
        // D s_1434_2: read-var u#33431:u32
        let s_1434_2: u32 = fn_state.u_33431;
        // D s_1434_3: cast zx s_1434_2 -> bv
        let s_1434_3: Bits = Bits::new(s_1434_2 as u128, 32u16);
        // D s_1434_4: bit-extract s_1434_3 s_1434_0 s_1434_1
        let s_1434_4: Bits = (Bits::new(
            ((s_1434_3) >> (s_1434_0)).value(),
            u16::try_from(s_1434_1).unwrap(),
        ));
        // D s_1434_5: cast reint s_1434_4 -> u8
        let s_1434_5: u8 = (s_1434_4.value() as u8);
        // D s_1434_6: cast zx s_1434_5 -> bv
        let s_1434_6: Bits = Bits::new(s_1434_5 as u128, 4u16);
        // C s_1434_7: const #15u : u8
        let s_1434_7: u8 = 15;
        // C s_1434_8: cast zx s_1434_7 -> bv
        let s_1434_8: Bits = Bits::new(s_1434_7 as u128, 4u16);
        // D s_1434_9: cmp-ne s_1434_6 s_1434_8
        let s_1434_9: bool = ((s_1434_6) != (s_1434_8));
        // N s_1434_10: branch s_1434_9 b1437 b1435
        if s_1434_9 {
            return block_1437(state, tracer, fn_state);
        } else {
            return block_1435(state, tracer, fn_state);
        };
    }
    fn block_1435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1435_0: const #0u : u8
        let s_1435_0: bool = false;
        // D s_1435_1: write-var gs#409169 <= s_1435_0
        fn_state.gs_409169 = s_1435_0;
        // N s_1435_2: jump b1436
        return block_1436(state, tracer, fn_state);
    }
    fn block_1436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1436_0: read-var gs#409169:u8
        let s_1436_0: bool = fn_state.gs_409169;
        // D s_1436_1: write-var gs#409170 <= s_1436_0
        fn_state.gs_409170 = s_1436_0;
        // N s_1436_2: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_1437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1437_0: const #3064s : i
        let s_1437_0: i128 = 3064;
        // C s_1437_1: const #14696u : u32
        let s_1437_1: u32 = 14696;
        // D s_1437_2: read-reg s_1437_1:i
        let s_1437_2: i128 = {
            let value = state.read_register::<i128>(s_1437_1 as isize);
            tracer.read_register(s_1437_1 as isize, value);
            value
        };
        // D s_1437_3: cmp-lt s_1437_2 s_1437_0
        let s_1437_3: bool = ((s_1437_2) < (s_1437_0));
        // D s_1437_4: write-var gs#409169 <= s_1437_3
        fn_state.gs_409169 = s_1437_3;
        // N s_1437_5: jump b1436
        return block_1436(state, tracer, fn_state);
    }
    fn block_1438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1438_0: const #4s : i
        let s_1438_0: i128 = 4;
        // D s_1438_1: read-var u#33431:u32
        let s_1438_1: u32 = fn_state.u_33431;
        // D s_1438_2: cast zx s_1438_1 -> bv
        let s_1438_2: Bits = Bits::new(s_1438_1 as u128, 32u16);
        // C s_1438_3: const #1s : i64
        let s_1438_3: i64 = 1;
        // C s_1438_4: cast zx s_1438_3 -> i
        let s_1438_4: i128 = (i128::try_from(s_1438_3).unwrap());
        // C s_1438_5: const #7s : i
        let s_1438_5: i128 = 7;
        // C s_1438_6: add s_1438_5 s_1438_4
        let s_1438_6: i128 = (s_1438_5 + s_1438_4);
        // D s_1438_7: bit-extract s_1438_2 s_1438_0 s_1438_6
        let s_1438_7: Bits = (Bits::new(
            ((s_1438_2) >> (s_1438_0)).value(),
            u16::try_from(s_1438_6).unwrap(),
        ));
        // D s_1438_8: cast reint s_1438_7 -> u8
        let s_1438_8: u8 = (s_1438_7.value() as u8);
        // D s_1438_9: cast zx s_1438_8 -> bv
        let s_1438_9: Bits = Bits::new(s_1438_8 as u128, 8u16);
        // C s_1438_10: const #241u : u8
        let s_1438_10: u8 = 241;
        // C s_1438_11: cast zx s_1438_10 -> bv
        let s_1438_11: Bits = Bits::new(s_1438_10 as u128, 8u16);
        // D s_1438_12: cmp-eq s_1438_9 s_1438_11
        let s_1438_12: bool = ((s_1438_9) == (s_1438_11));
        // D s_1438_13: write-var gs#409165 <= s_1438_12
        fn_state.gs_409165 = s_1438_12;
        // N s_1438_14: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_1439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1439_0: const #28s : i
        let s_1439_0: i128 = 28;
        // C s_1439_1: const #4s : i
        let s_1439_1: i128 = 4;
        // D s_1439_2: read-var u#33426:u32
        let s_1439_2: u32 = fn_state.u_33426;
        // D s_1439_3: cast zx s_1439_2 -> bv
        let s_1439_3: Bits = Bits::new(s_1439_2 as u128, 32u16);
        // D s_1439_4: bit-extract s_1439_3 s_1439_0 s_1439_1
        let s_1439_4: Bits = (Bits::new(
            ((s_1439_3) >> (s_1439_0)).value(),
            u16::try_from(s_1439_1).unwrap(),
        ));
        // D s_1439_5: cast reint s_1439_4 -> u8
        let s_1439_5: u8 = (s_1439_4.value() as u8);
        // D s_1439_6: cast zx s_1439_5 -> bv
        let s_1439_6: Bits = Bits::new(s_1439_5 as u128, 4u16);
        // C s_1439_7: const #15u : u8
        let s_1439_7: u8 = 15;
        // C s_1439_8: cast zx s_1439_7 -> bv
        let s_1439_8: Bits = Bits::new(s_1439_7 as u128, 4u16);
        // D s_1439_9: cmp-ne s_1439_6 s_1439_8
        let s_1439_9: bool = ((s_1439_6) != (s_1439_8));
        // N s_1439_10: branch s_1439_9 b1442 b1440
        if s_1439_9 {
            return block_1442(state, tracer, fn_state);
        } else {
            return block_1440(state, tracer, fn_state);
        };
    }
    fn block_1440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1440_0: const #0u : u8
        let s_1440_0: bool = false;
        // D s_1440_1: write-var gs#409144 <= s_1440_0
        fn_state.gs_409144 = s_1440_0;
        // N s_1440_2: jump b1441
        return block_1441(state, tracer, fn_state);
    }
    fn block_1441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1441_0: read-var gs#409144:u8
        let s_1441_0: bool = fn_state.gs_409144;
        // D s_1441_1: write-var gs#409145 <= s_1441_0
        fn_state.gs_409145 = s_1441_0;
        // N s_1441_2: jump b16
        return block_16(state, tracer, fn_state);
    }
    fn block_1442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1442_0: const #3047s : i
        let s_1442_0: i128 = 3047;
        // C s_1442_1: const #14696u : u32
        let s_1442_1: u32 = 14696;
        // D s_1442_2: read-reg s_1442_1:i
        let s_1442_2: i128 = {
            let value = state.read_register::<i128>(s_1442_1 as isize);
            tracer.read_register(s_1442_1 as isize, value);
            value
        };
        // D s_1442_3: cmp-lt s_1442_2 s_1442_0
        let s_1442_3: bool = ((s_1442_2) < (s_1442_0));
        // D s_1442_4: write-var gs#409144 <= s_1442_3
        fn_state.gs_409144 = s_1442_3;
        // N s_1442_5: jump b1441
        return block_1441(state, tracer, fn_state);
    }
    fn block_1443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1443_0: const #4s : i
        let s_1443_0: i128 = 4;
        // D s_1443_1: read-var u#33426:u32
        let s_1443_1: u32 = fn_state.u_33426;
        // D s_1443_2: cast zx s_1443_1 -> bv
        let s_1443_2: Bits = Bits::new(s_1443_1 as u128, 32u16);
        // C s_1443_3: const #1s : i64
        let s_1443_3: i64 = 1;
        // C s_1443_4: cast zx s_1443_3 -> i
        let s_1443_4: i128 = (i128::try_from(s_1443_3).unwrap());
        // C s_1443_5: const #1s : i
        let s_1443_5: i128 = 1;
        // C s_1443_6: add s_1443_5 s_1443_4
        let s_1443_6: i128 = (s_1443_5 + s_1443_4);
        // D s_1443_7: bit-extract s_1443_2 s_1443_0 s_1443_6
        let s_1443_7: Bits = (Bits::new(
            ((s_1443_2) >> (s_1443_0)).value(),
            u16::try_from(s_1443_6).unwrap(),
        ));
        // D s_1443_8: cast reint s_1443_7 -> u8
        let s_1443_8: u8 = (s_1443_7.value() as u8);
        // D s_1443_9: cast zx s_1443_8 -> bv
        let s_1443_9: Bits = Bits::new(s_1443_8 as u128, 2u16);
        // C s_1443_10: const #1u : u8
        let s_1443_10: u8 = 1;
        // C s_1443_11: cast zx s_1443_10 -> bv
        let s_1443_11: Bits = Bits::new(s_1443_10 as u128, 2u16);
        // D s_1443_12: cmp-eq s_1443_9 s_1443_11
        let s_1443_12: bool = ((s_1443_9) == (s_1443_11));
        // D s_1443_13: write-var gs#409140 <= s_1443_12
        fn_state.gs_409140 = s_1443_12;
        // N s_1443_14: jump b14
        return block_14(state, tracer, fn_state);
    }
    fn block_1444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1444_0: const #28s : i
        let s_1444_0: i128 = 28;
        // C s_1444_1: const #4s : i
        let s_1444_1: i128 = 4;
        // D s_1444_2: read-var u#33420:u32
        let s_1444_2: u32 = fn_state.u_33420;
        // D s_1444_3: cast zx s_1444_2 -> bv
        let s_1444_3: Bits = Bits::new(s_1444_2 as u128, 32u16);
        // D s_1444_4: bit-extract s_1444_3 s_1444_0 s_1444_1
        let s_1444_4: Bits = (Bits::new(
            ((s_1444_3) >> (s_1444_0)).value(),
            u16::try_from(s_1444_1).unwrap(),
        ));
        // D s_1444_5: cast reint s_1444_4 -> u8
        let s_1444_5: u8 = (s_1444_4.value() as u8);
        // D s_1444_6: cast zx s_1444_5 -> bv
        let s_1444_6: Bits = Bits::new(s_1444_5 as u128, 4u16);
        // C s_1444_7: const #15u : u8
        let s_1444_7: u8 = 15;
        // C s_1444_8: cast zx s_1444_7 -> bv
        let s_1444_8: Bits = Bits::new(s_1444_7 as u128, 4u16);
        // D s_1444_9: cmp-ne s_1444_6 s_1444_8
        let s_1444_9: bool = ((s_1444_6) != (s_1444_8));
        // N s_1444_10: branch s_1444_9 b1447 b1445
        if s_1444_9 {
            return block_1447(state, tracer, fn_state);
        } else {
            return block_1445(state, tracer, fn_state);
        };
    }
    fn block_1445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1445_0: const #0u : u8
        let s_1445_0: bool = false;
        // D s_1445_1: write-var gs#409121 <= s_1445_0
        fn_state.gs_409121 = s_1445_0;
        // N s_1445_2: jump b1446
        return block_1446(state, tracer, fn_state);
    }
    fn block_1446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1446_0: read-var gs#409121:u8
        let s_1446_0: bool = fn_state.gs_409121;
        // D s_1446_1: write-var gs#409122 <= s_1446_0
        fn_state.gs_409122 = s_1446_0;
        // N s_1446_2: jump b10
        return block_10(state, tracer, fn_state);
    }
    fn block_1447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1447_0: const #2858s : i
        let s_1447_0: i128 = 2858;
        // C s_1447_1: const #14696u : u32
        let s_1447_1: u32 = 14696;
        // D s_1447_2: read-reg s_1447_1:i
        let s_1447_2: i128 = {
            let value = state.read_register::<i128>(s_1447_1 as isize);
            tracer.read_register(s_1447_1 as isize, value);
            value
        };
        // D s_1447_3: cmp-lt s_1447_2 s_1447_0
        let s_1447_3: bool = ((s_1447_2) < (s_1447_0));
        // D s_1447_4: write-var gs#409121 <= s_1447_3
        fn_state.gs_409121 = s_1447_3;
        // N s_1447_5: jump b1446
        return block_1446(state, tracer, fn_state);
    }
    fn block_1448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1448_0: const #4s : i
        let s_1448_0: i128 = 4;
        // D s_1448_1: read-var u#33420:u32
        let s_1448_1: u32 = fn_state.u_33420;
        // D s_1448_2: cast zx s_1448_1 -> bv
        let s_1448_2: Bits = Bits::new(s_1448_1 as u128, 32u16);
        // C s_1448_3: const #1s : i64
        let s_1448_3: i64 = 1;
        // C s_1448_4: cast zx s_1448_3 -> i
        let s_1448_4: i128 = (i128::try_from(s_1448_3).unwrap());
        // C s_1448_5: const #2s : i
        let s_1448_5: i128 = 2;
        // C s_1448_6: add s_1448_5 s_1448_4
        let s_1448_6: i128 = (s_1448_5 + s_1448_4);
        // D s_1448_7: bit-extract s_1448_2 s_1448_0 s_1448_6
        let s_1448_7: Bits = (Bits::new(
            ((s_1448_2) >> (s_1448_0)).value(),
            u16::try_from(s_1448_6).unwrap(),
        ));
        // D s_1448_8: cast reint s_1448_7 -> u8
        let s_1448_8: u8 = (s_1448_7.value() as u8);
        // D s_1448_9: cast zx s_1448_8 -> bv
        let s_1448_9: Bits = Bits::new(s_1448_8 as u128, 3u16);
        // C s_1448_10: const #1u : u8
        let s_1448_10: u8 = 1;
        // C s_1448_11: cast zx s_1448_10 -> bv
        let s_1448_11: Bits = Bits::new(s_1448_10 as u128, 3u16);
        // D s_1448_12: cmp-eq s_1448_9 s_1448_11
        let s_1448_12: bool = ((s_1448_9) == (s_1448_11));
        // D s_1448_13: write-var gs#409117 <= s_1448_12
        fn_state.gs_409117 = s_1448_12;
        // N s_1448_14: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_1449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1449_0: const #28s : i
        let s_1449_0: i128 = 28;
        // C s_1449_1: const #4s : i
        let s_1449_1: i128 = 4;
        // D s_1449_2: read-var __opcode:u32
        let s_1449_2: u32 = fn_state.u__opcode;
        // D s_1449_3: cast zx s_1449_2 -> bv
        let s_1449_3: Bits = Bits::new(s_1449_2 as u128, 32u16);
        // D s_1449_4: bit-extract s_1449_3 s_1449_0 s_1449_1
        let s_1449_4: Bits = (Bits::new(
            ((s_1449_3) >> (s_1449_0)).value(),
            u16::try_from(s_1449_1).unwrap(),
        ));
        // D s_1449_5: cast reint s_1449_4 -> u8
        let s_1449_5: u8 = (s_1449_4.value() as u8);
        // D s_1449_6: cast zx s_1449_5 -> bv
        let s_1449_6: Bits = Bits::new(s_1449_5 as u128, 4u16);
        // C s_1449_7: const #15u : u8
        let s_1449_7: u8 = 15;
        // C s_1449_8: cast zx s_1449_7 -> bv
        let s_1449_8: Bits = Bits::new(s_1449_7 as u128, 4u16);
        // D s_1449_9: cmp-ne s_1449_6 s_1449_8
        let s_1449_9: bool = ((s_1449_6) != (s_1449_8));
        // N s_1449_10: branch s_1449_9 b1452 b1450
        if s_1449_9 {
            return block_1452(state, tracer, fn_state);
        } else {
            return block_1450(state, tracer, fn_state);
        };
    }
    fn block_1450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1450_0: const #0u : u8
        let s_1450_0: bool = false;
        // D s_1450_1: write-var gs#409100 <= s_1450_0
        fn_state.gs_409100 = s_1450_0;
        // N s_1450_2: jump b1451
        return block_1451(state, tracer, fn_state);
    }
    fn block_1451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1451_0: read-var gs#409100:u8
        let s_1451_0: bool = fn_state.gs_409100;
        // D s_1451_1: write-var gs#409101 <= s_1451_0
        fn_state.gs_409101 = s_1451_0;
        // N s_1451_2: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_1452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1452_0: const #2856s : i
        let s_1452_0: i128 = 2856;
        // C s_1452_1: const #14696u : u32
        let s_1452_1: u32 = 14696;
        // D s_1452_2: read-reg s_1452_1:i
        let s_1452_2: i128 = {
            let value = state.read_register::<i128>(s_1452_1 as isize);
            tracer.read_register(s_1452_1 as isize, value);
            value
        };
        // D s_1452_3: cmp-lt s_1452_2 s_1452_0
        let s_1452_3: bool = ((s_1452_2) < (s_1452_0));
        // D s_1452_4: write-var gs#409100 <= s_1452_3
        fn_state.gs_409100 = s_1452_3;
        // N s_1452_5: jump b1451
        return block_1451(state, tracer, fn_state);
    }
    fn block_1453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1453_0: const #0s : i
        let s_1453_0: i128 = 0;
        // D s_1453_1: read-var __opcode:u32
        let s_1453_1: u32 = fn_state.u__opcode;
        // D s_1453_2: cast zx s_1453_1 -> bv
        let s_1453_2: Bits = Bits::new(s_1453_1 as u128, 32u16);
        // C s_1453_3: const #1s : i64
        let s_1453_3: i64 = 1;
        // C s_1453_4: cast zx s_1453_3 -> i
        let s_1453_4: i128 = (i128::try_from(s_1453_3).unwrap());
        // C s_1453_5: const #6s : i
        let s_1453_5: i128 = 6;
        // C s_1453_6: add s_1453_5 s_1453_4
        let s_1453_6: i128 = (s_1453_5 + s_1453_4);
        // D s_1453_7: bit-extract s_1453_2 s_1453_0 s_1453_6
        let s_1453_7: Bits = (Bits::new(
            ((s_1453_2) >> (s_1453_0)).value(),
            u16::try_from(s_1453_6).unwrap(),
        ));
        // D s_1453_8: cast reint s_1453_7 -> u8
        let s_1453_8: u8 = (s_1453_7.value() as u8);
        // D s_1453_9: cast zx s_1453_8 -> bv
        let s_1453_9: Bits = Bits::new(s_1453_8 as u128, 7u16);
        // C s_1453_10: const #31u : u8
        let s_1453_10: u8 = 31;
        // C s_1453_11: cast zx s_1453_10 -> bv
        let s_1453_11: Bits = Bits::new(s_1453_10 as u128, 7u16);
        // D s_1453_12: cmp-eq s_1453_9 s_1453_11
        let s_1453_12: bool = ((s_1453_9) == (s_1453_11));
        // D s_1453_13: write-var gs#409096 <= s_1453_12
        fn_state.gs_409096 = s_1453_12;
        // N s_1453_14: jump b2
        return block_2(state, tracer, fn_state);
    }
}
